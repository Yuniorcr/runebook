<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="a096978b727394f0a665fb7212a971c3ee9889e1" translate="yes" xml:space="preserve">
          <source>The implemented SASL mechanisms at the moment are &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; and its variant with channel binding &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt;. They are described in detail in RFC 7677 and RFC 5802.</source>
          <target state="translated">В настоящее время реализованы механизмы SASL: &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; и его вариант с привязкой канала &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; . Они подробно описаны в RFC 7677 и RFC 5802.</target>
        </trans-unit>
        <trans-unit id="3994c1cc646c4ef5a61a7d412fe3e39d9a284414" translate="yes" xml:space="preserve">
          <source>The index access costs should be computed using the parameters used by &lt;code&gt;src/backend/optimizer/path/costsize.c&lt;/code&gt;: a sequential disk block fetch has cost &lt;code&gt;seq_page_cost&lt;/code&gt;, a nonsequential fetch has cost &lt;code&gt;random_page_cost&lt;/code&gt;, and the cost of processing one index row should usually be taken as &lt;code&gt;cpu_index_tuple_cost&lt;/code&gt;. In addition, an appropriate multiple of &lt;code&gt;cpu_operator_cost&lt;/code&gt; should be charged for any comparison operators invoked during index processing (especially evaluation of the indexquals themselves).</source>
          <target state="translated">Стоимость доступа к индексу должна быть вычислена с использованием параметров, используемых &lt;code&gt;src/backend/optimizer/path/costsize.c&lt;/code&gt; : последовательная выборка блока с диска имеет стоимость &lt;code&gt;seq_page_cost&lt;/code&gt; , непоследовательная выборка имеет стоимость &lt;code&gt;random_page_cost&lt;/code&gt; , а стоимость обработки одной строки индекса обычно должна приниматься как &lt;code&gt;cpu_index_tuple_cost&lt;/code&gt; . Кроме того, соответствующее значение, кратное &lt;code&gt;cpu_operator_cost&lt;/code&gt; , должно взиматься за любые операторы сравнения, вызываемые во время обработки индекса (особенно при оценке самих значений indexquals).</target>
        </trans-unit>
        <trans-unit id="6fef8227d6c9875a9adfc4cf6467a2aea1121c60" translate="yes" xml:space="preserve">
          <source>The index access path being considered. All fields except cost and selectivity values are valid.</source>
          <target state="translated">Рассматривается путь доступа к индексу.Все поля,за исключением значений стоимости и селективности,являются действительными.</target>
        </trans-unit>
        <trans-unit id="47ab406c0502c2ff0920580c5626f87c7d3ac514" translate="yes" xml:space="preserve">
          <source>The index automatically uses the collation of the underlying column. So a query of the form</source>
          <target state="translated">Индекс автоматически использует сверку базового столбца.Таким образом,запрос формы</target>
        </trans-unit>
        <trans-unit id="d40d5a355329bb21744bf91012270d4b7eadd19f" translate="yes" xml:space="preserve">
          <source>The index cannot have expression columns nor be a partial index. Also, it must be a b-tree index with default sort ordering. These restrictions ensure that the index is equivalent to one that would be built by a regular &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; or &lt;code&gt;ADD UNIQUE&lt;/code&gt; command.</source>
          <target state="translated">Индекс не может содержать столбцы выражений или быть частичным индексом. Кроме того, это должен быть индекс b-дерева с порядком сортировки по умолчанию. Эти ограничения гарантируют, что индекс эквивалентен индексу, который был бы создан с помощью обычной команды &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; или &lt;code&gt;ADD UNIQUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78493f3623537c9a38e59ae58540f722627b962f" translate="yes" xml:space="preserve">
          <source>The index construction and maintenance functions that an index access method must provide in &lt;code&gt;IndexAmRoutine&lt;/code&gt; are:</source>
          <target state="translated">Функции построения и обслуживания индекса, которые метод доступа к индексу должен предоставлять в &lt;code&gt;IndexAmRoutine&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3039446ce33001ce11d9ef4cc9e239f9e80ff013" translate="yes" xml:space="preserve">
          <source>The index is being built by the access method-specific code. In this phase, access methods that support progress reporting fill in their own progress data, and the subphase is indicated in this column. Typically, &lt;code&gt;blocks_total&lt;/code&gt; and &lt;code&gt;blocks_done&lt;/code&gt; will contain progress data, as well as potentially &lt;code&gt;tuples_total&lt;/code&gt; and &lt;code&gt;tuples_done&lt;/code&gt;.</source>
          <target state="translated">Индекс создается с помощью кода, зависящего от метода доступа. На этом этапе методы доступа, поддерживающие отчеты о ходе выполнения, заполняют собственные данные о ходе выполнения, и в этом столбце указывается подфаза. Как правило, &lt;code&gt;blocks_total&lt;/code&gt; и &lt;code&gt;blocks_done&lt;/code&gt; будут содержать данные о ходе выполнения, а также потенциально &lt;code&gt;tuples_total&lt;/code&gt; и &lt;code&gt;tuples_done&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8974784c29c6386bf1253069fdf16bf07fbf780" translate="yes" xml:space="preserve">
          <source>The index is created with a signature length of 80 bits, with attributes i1 and i2 mapped to 2 bits, and attribute i3 mapped to 4 bits. We could have omitted the &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;col1&lt;/code&gt;, and &lt;code&gt;col2&lt;/code&gt; specifications since those have the default values.</source>
          <target state="translated">Индекс создается с длиной подписи 80 бит, при этом атрибуты i1 и i2 отображаются в 2 бита, а атрибут i3 - в 4 бита. Мы могли бы опустить спецификации &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;col1&lt;/code&gt; и &lt;code&gt;col2&lt;/code&gt; , поскольку они имеют значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f53b14842204c3afdf4a8da34fde71ed13d02632" translate="yes" xml:space="preserve">
          <source>The index method's strategy number for an operator associated with the operator class.</source>
          <target state="translated">Номер стратегии метода индекса для оператора,связанного с классом оператора.</target>
        </trans-unit>
        <trans-unit id="62c3a3b1a4517180b23038b6d08f465908556b8b" translate="yes" xml:space="preserve">
          <source>The index method's strategy number for an operator associated with the operator family.</source>
          <target state="translated">Номер стратегии метода индекса для оператора,связанного с семейством операторов.</target>
        </trans-unit>
        <trans-unit id="4a128fb2d5e95c4a7976acace79bbc58b6fb276b" translate="yes" xml:space="preserve">
          <source>The index method's support function number for a function associated with the operator class.</source>
          <target state="translated">Номер функции поддержки метода индекса для функции,ассоциированной с классом оператора.</target>
        </trans-unit>
        <trans-unit id="8c74967c2b0a4ae3a48c94ba4d59d1361af52eba" translate="yes" xml:space="preserve">
          <source>The index method's support function number for a function associated with the operator family.</source>
          <target state="translated">Номер функции поддержки метода индекса для функции,связанной с семейством операторов.</target>
        </trans-unit>
        <trans-unit id="dfbc9f2ec43f190a4f4b92d5261f2d63618ce86e" translate="yes" xml:space="preserve">
          <source>The index search works by extracting trigrams from the regular expression and then looking these up in the index. The more trigrams that can be extracted from the regular expression, the more effective the index search is. Unlike B-tree based searches, the search string need not be left-anchored.</source>
          <target state="translated">Поиск по индексам работает путем извлечения триграмм из регулярного выражения,а затем их поиска в индексе.Чем больше триграмм можно извлечь из регулярного выражения,тем эффективнее индексный поиск.В отличие от поиска по B-дереву,строка поиска не обязательно должна быть левой.</target>
        </trans-unit>
        <trans-unit id="76d1075d790db56a70c52b9e9529c4e67b5fd660" translate="yes" xml:space="preserve">
          <source>The index search works by extracting trigrams from the search string and then looking these up in the index. The more trigrams in the search string, the more effective the index search is. Unlike B-tree based searches, the search string need not be left-anchored.</source>
          <target state="translated">Поиск по индексу работает путем извлечения триграмм из строки поиска,а затем их поиска в индексе.Чем больше триграмм в строке поиска,тем эффективнее индексный поиск.В отличие от поиска на основе B-дерева,строка поиска не обязательно должна быть левосторонней.</target>
        </trans-unit>
        <trans-unit id="2ef045e734746214c8ad4568acd243c24cf2fcf6" translate="yes" xml:space="preserve">
          <source>The index supporting a unique, primary key, referential integrity, or exclusion constraint</source>
          <target state="translated">Индекс,поддерживающий уникальный,первичный ключ,ссылочную целостность или ограничение на исключение.</target>
        </trans-unit>
        <trans-unit id="b1f015828c180dda3ed4f3bdc55e0086cb7fcc71" translate="yes" xml:space="preserve">
          <source>The index supporting this constraint, if it's a unique, primary key, foreign key, or exclusion constraint; else 0</source>
          <target state="translated">Индекс,поддерживающий это ограничение,если это уникальный,первичный ключ,внешний ключ или ограничение на исключение;в противном случае 0</target>
        </trans-unit>
        <trans-unit id="6c3b8559bb8c83cd05e198719da39b30d3fb1043" translate="yes" xml:space="preserve">
          <source>The index type must support index-only scans. B-tree indexes always do. GiST and SP-GiST indexes support index-only scans for some operator classes but not others. Other index types have no support. The underlying requirement is that the index must physically store, or else be able to reconstruct, the original data value for each index entry. As a counterexample, GIN indexes cannot support index-only scans because each index entry typically holds only part of the original data value.</source>
          <target state="translated">Тип индекса должен поддерживать сканирование только по индексам.Индексы B-дерева всегда поддерживают.Индексы GiST и SP-GiST поддерживают только индексное сканирование для одних классов операторов,но не для других.Другие типы индексов не поддерживают.Основополагающим требованием является то,что индекс должен физически хранить,или иначе быть способен восстанавливать исходное значение данных для каждой записи индекса.Как контрпример,GIN-индексы не могут поддерживать только индексное сканирование,потому что каждая запись индекса,как правило,содержит только часть исходного значения данных.</target>
        </trans-unit>
        <trans-unit id="a6836c640c52510a0b02e594ca8bbfc9b8103067" translate="yes" xml:space="preserve">
          <source>The indicated database user name was not found.</source>
          <target state="translated">Указанное имя пользователя базы данных не найдено.</target>
        </trans-unit>
        <trans-unit id="20e3988dff010547d05b25cba96f92a2ac547dbd" translate="yes" xml:space="preserve">
          <source>The individual elements of a &lt;code&gt;CUBE&lt;/code&gt; or &lt;code&gt;ROLLUP&lt;/code&gt; clause may be either individual expressions, or sublists of elements in parentheses. In the latter case, the sublists are treated as single units for the purposes of generating the individual grouping sets. For example:</source>
          <target state="translated">Отдельные элементы предложения &lt;code&gt;CUBE&lt;/code&gt; или &lt;code&gt;ROLLUP&lt;/code&gt; могут быть либо отдельными выражениями, либо подсписками элементов в круглых скобках. В последнем случае подсписки обрабатываются как отдельные блоки для целей создания отдельных группирующих наборов. Например:</target>
        </trans-unit>
        <trans-unit id="478f53ba771627a25e2c5229ba6d54c52bd271c5" translate="yes" xml:space="preserve">
          <source>The individual tables can be added and removed dynamically using &lt;a href=&quot;sql-alterpublication&quot;&gt;ALTER PUBLICATION&lt;/a&gt;. Both the &lt;code&gt;ADD TABLE&lt;/code&gt; and &lt;code&gt;DROP TABLE&lt;/code&gt; operations are transactional; so the table will start or stop replicating at the correct snapshot once the transaction has committed.</source>
          <target state="translated">Отдельные таблицы можно добавлять и удалять динамически с помощью &lt;a href=&quot;sql-alterpublication&quot;&gt;ALTER PUBLICATION&lt;/a&gt; . Обе операции &lt;code&gt;ADD TABLE&lt;/code&gt; и &lt;code&gt;DROP TABLE&lt;/code&gt; являются транзакционными; поэтому таблица начнет или прекратит репликацию с правильного моментального снимка после фиксации транзакции.</target>
        </trans-unit>
        <trans-unit id="55f0b3e0f4002ca62cb368b92a46147d06514b6c" translate="yes" xml:space="preserve">
          <source>The information passed to the client for a notification event includes the notification channel name, the notifying session's server process PID, and the payload string, which is an empty string if it has not been specified.</source>
          <target state="translated">Информация,передаваемая клиенту для события оповещения,включает в себя имя канала оповещения,PID процесса сервера уведомляющей сессии и строку полезной нагрузки,которая является пустой строкой,если она не была указана.</target>
        </trans-unit>
        <trans-unit id="044f2cd515098f5f363f2857b2c2afc07209265a" translate="yes" xml:space="preserve">
          <source>The information schema (&lt;a href=&quot;https://www.postgresql.org/docs/12/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) provides an alternative set of views which overlap the functionality of the system views. Since the information schema is SQL-standard whereas the views described here are PostgreSQL-specific, it's usually better to use the information schema if it provides all the information you need.</source>
          <target state="translated">Информационная схема ( &lt;a href=&quot;https://www.postgresql.org/docs/12/information-schema.html&quot;&gt;глава 36&lt;/a&gt; ) предоставляет альтернативный набор представлений, которые перекрывают функциональность системных представлений. Поскольку информационная схема является стандартом SQL, тогда как описанные здесь представления зависят от PostgreSQL, обычно лучше использовать информационную схему, если она предоставляет всю необходимую информацию.</target>
        </trans-unit>
        <trans-unit id="0c18c9f5485d75a93a8e5be63c2bfb9df98cb595" translate="yes" xml:space="preserve">
          <source>The information schema (&lt;a href=&quot;https://www.postgresql.org/docs/13/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) provides an alternative set of views which overlap the functionality of the system views. Since the information schema is SQL-standard whereas the views described here are PostgreSQL-specific, it's usually better to use the information schema if it provides all the information you need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f201ea8f38230c6e8acfb095bb89803ef41bb1b" translate="yes" xml:space="preserve">
          <source>The information to implement this module was collected from several sites, including:</source>
          <target state="translated">Информация для реализации этого модуля была собрана с нескольких сайтов,в том числе:</target>
        </trans-unit>
        <trans-unit id="8ffbbc2df15378d40a94e42b70d5fb5af1458af3" translate="yes" xml:space="preserve">
          <source>The initial access privileges; see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for details</source>
          <target state="translated">Первоначальные права доступа; см &lt;a href=&quot;ddl-priv&quot;&gt;раздел 5.7&lt;/a&gt; для получения более подробной</target>
        </trans-unit>
        <trans-unit id="8a1054b1ac592ae44e2cf9b51ca38fb26634ef49" translate="yes" xml:space="preserve">
          <source>The initial data in existing subscribed tables are snapshotted and copied in a parallel instance of a special kind of apply process. This process will create its own temporary replication slot and copy the existing data. Once existing data is copied, the worker enters synchronization mode, which ensures that the table is brought up to a synchronized state with the main apply process by streaming any changes that happened during the initial data copy using standard logical replication. Once the synchronization is done, the control of the replication of the table is given back to the main apply process where the replication continues as normal.</source>
          <target state="translated">Исходные данные в существующих подписанных таблицах делаются снимки и копируются в параллельном экземпляре специального вида прикладного процесса.В этом процессе создается собственный временный слот репликации и копируются существующие данные.После копирования существующих данных рабочий переходит в режим синхронизации,который обеспечивает приведение таблицы в синхронизированное состояние с основным прикладным процессом путем потоковой передачи любых изменений,произошедших во время копирования исходных данных с использованием стандартной логической репликации.Как только синхронизация выполнена,управление репликацией таблицы возвращается к основному процессу применения,где репликация продолжается в обычном режиме.</target>
        </trans-unit>
        <trans-unit id="257568e0871ee2fb3ae1bd84f534adce4db0bec5" translate="yes" xml:space="preserve">
          <source>The initial setting for the state value, when using moving-aggregate mode. This works the same as &lt;code&gt;initial_condition&lt;/code&gt;.</source>
          <target state="translated">Начальная установка для значения состояния при использовании режима подвижного агрегата. Это работает так же, как &lt;code&gt;initial_condition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb62c8458668a0689948660586a0f8259374a819" translate="yes" xml:space="preserve">
          <source>The initial setting for the state value. This must be a string constant in the form accepted for the data type &lt;code&gt;state_data_type&lt;/code&gt;. If not specified, the state value starts out null.</source>
          <target state="translated">Начальная установка для значения состояния. Это должна быть строковая константа в форме, принятой для типа данных &lt;code&gt;state_data_type&lt;/code&gt; . Если не указано, значение состояния начинается с нуля.</target>
        </trans-unit>
        <trans-unit id="d82c96a461d121c75c52d8ce64285a1d86e2ab14" translate="yes" xml:space="preserve">
          <source>The initial value of the transition state for moving-aggregate mode. This is a text field containing the initial value in its external string representation. If this field is null, the transition state value starts out null.</source>
          <target state="translated">Начальное значение переходного состояния для режима перемещения-агрегации.Это текстовое поле,содержащее начальное значение во внешнем строковом представлении.Если это поле нулевое,то значение состояния перехода начинается с нуля.</target>
        </trans-unit>
        <trans-unit id="dfef147dfd625c38da29727096d66edbe7450de5" translate="yes" xml:space="preserve">
          <source>The initial value of the transition state. This is a text field containing the initial value in its external string representation. If this field is null, the transition state value starts out null.</source>
          <target state="translated">Начальное значение переходного состояния.Это текстовое поле,содержащее начальное значение во внешнем строковом представлении.Если это поле нулевое,то значение состояния перехода начинается с нуля.</target>
        </trans-unit>
        <trans-unit id="6e8d9c8e49727d756d0711797450f963975e284e" translate="yes" xml:space="preserve">
          <source>The initially assigned data type of a numeric constant is just a starting point for the type resolution algorithms. In most cases the constant will be automatically coerced to the most appropriate type depending on context. When necessary, you can force a numeric value to be interpreted as a specific data type by casting it. For example, you can force a numeric value to be treated as type &lt;code&gt;real&lt;/code&gt; (&lt;code&gt;float4&lt;/code&gt;) by writing:</source>
          <target state="translated">Первоначально назначенный тип данных числовой константы является лишь отправной точкой для алгоритмов разрешения типов. В большинстве случаев константа будет автоматически приведена к наиболее подходящему типу в зависимости от контекста. При необходимости вы можете принудительно интерпретировать числовое значение как определенный тип данных путем его приведения. Например, вы можете заставить числовое значение обрабатываться как тип &lt;code&gt;real&lt;/code&gt; ( &lt;code&gt;float4&lt;/code&gt; ), написав:</target>
        </trans-unit>
        <trans-unit id="f4532069877c3839fd18c7cafdf1b166d436f334" translate="yes" xml:space="preserve">
          <source>The inner &lt;code&gt;UNION&lt;/code&gt; is resolved as emitting type &lt;code&gt;text&lt;/code&gt;, according to the rules given above. Then the outer &lt;code&gt;UNION&lt;/code&gt; has inputs of types &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;integer&lt;/code&gt;, leading to the observed error. The problem can be fixed by ensuring that the leftmost &lt;code&gt;UNION&lt;/code&gt; has at least one input of the desired result type.</source>
          <target state="translated">Внутренний &lt;code&gt;UNION&lt;/code&gt; разрешается как выдающий &lt;code&gt;text&lt;/code&gt; типа в соответствии с правилами, приведенными выше. Затем внешний &lt;code&gt;UNION&lt;/code&gt; имеет входы &lt;code&gt;text&lt;/code&gt; и &lt;code&gt;integer&lt;/code&gt; типов , что приводит к наблюдаемой ошибке. Проблему можно решить, убедившись, что крайний левый &lt;code&gt;UNION&lt;/code&gt; имеет хотя бы один вход желаемого типа результата.</target>
        </trans-unit>
        <trans-unit id="752b1c95a1eae331cb7a120fbc2cbc7b360efa2f" translate="yes" xml:space="preserve">
          <source>The input for a range value must follow one of the following patterns:</source>
          <target state="translated">Ввод значения диапазона должен выполняться по одной из следующих схем:</target>
        </trans-unit>
        <trans-unit id="5db960d2928db992e514ea865af6ec0e73cf5806" translate="yes" xml:space="preserve">
          <source>The input format for this type is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is an IPv4 or IPv6 address and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If the &lt;code&gt;/y&lt;/code&gt; portion is missing, the netmask is 32 for IPv4 and 128 for IPv6, so the value represents just a single host. On display, the &lt;code&gt;/y&lt;/code&gt; portion is suppressed if the netmask specifies a single host.</source>
          <target state="translated">Формат ввода для этого типа - &lt;code&gt;address/y&lt;/code&gt; где &lt;code&gt;address&lt;/code&gt; - это адрес IPv4 или IPv6, а &lt;code&gt;y&lt;/code&gt; - количество бит в сетевой маске. Если часть &lt;code&gt;/y&lt;/code&gt; отсутствует, сетевая маска равна 32 для IPv4 и 128 для IPv6, поэтому значение представляет только один хост. На дисплее часть &lt;code&gt;/y&lt;/code&gt; подавляется, если сетевая маска указывает единственный хост.</target>
        </trans-unit>
        <trans-unit id="a8be18b330a3d96f66997a77713b943e9dcae523" translate="yes" xml:space="preserve">
          <source>The input format for this type is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is an IPv4 or IPv6 address and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If the &lt;code&gt;/y&lt;/code&gt; portion is omitted, the netmask is taken to be 32 for IPv4 or 128 for IPv6, so the value represents just a single host. On display, the &lt;code&gt;/y&lt;/code&gt; portion is suppressed if the netmask specifies a single host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1496dddf6a6d3aece3a51059d08e155ea1323eea" translate="yes" xml:space="preserve">
          <source>The input/output syntax for the JSON data types is as specified in RFC 7159.</source>
          <target state="translated">Синтаксис ввода/вывода для типов данных JSON соответствует указанному в RFC 7159.</target>
        </trans-unit>
        <trans-unit id="28b76175a8e4e44a6929b2bbc612975f4e90fb8f" translate="yes" xml:space="preserve">
          <source>The instance handles all key features of a DBMS: read and write access to files and shared memory, assurance of the ACID properties, &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;connections&lt;/a&gt; to &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;client processes&lt;/a&gt;, privilege verification, crash recovery, replication, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03aa7e8fbd88e7f3d34658426c4782d01d3a8689" translate="yes" xml:space="preserve">
          <source>The intended use of the &lt;code&gt;pause&lt;/code&gt; setting is to allow queries to be executed against the database to check if this recovery target is the most desirable point for recovery. The paused state can be resumed by using &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; (see &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.86&lt;/a&gt;), which then causes recovery to end. If this recovery target is not the desired stopping point, then shut down the server, change the recovery target settings to a later target and restart to continue recovery.</source>
          <target state="translated">Предполагаемое использование параметра &lt;code&gt;pause&lt;/code&gt; - разрешить выполнение запросов к базе данных, чтобы проверить, является ли эта цель восстановления наиболее желательной точкой для восстановления. Приостановленное состояние может быть возобновлено с помощью &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; (см. &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Таблицу 9.86&lt;/a&gt; ), которая затем завершает восстановление. Если эта цель восстановления не является желаемой точкой остановки, выключите сервер, измените настройки цели восстановления на более позднюю цель и перезапустите, чтобы продолжить восстановление.</target>
        </trans-unit>
        <trans-unit id="1eb808aeb9bcf9fecdcdeaa1957208268bb0812e" translate="yes" xml:space="preserve">
          <source>The intended use of the &lt;code&gt;pause&lt;/code&gt; setting is to allow queries to be executed against the database to check if this recovery target is the most desirable point for recovery. The paused state can be resumed by using &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; (see &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.87&lt;/a&gt;), which then causes recovery to end. If this recovery target is not the desired stopping point, then shut down the server, change the recovery target settings to a later target and restart to continue recovery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eae9a7b2978d9149a7d3a255f37f5ad888745278" translate="yes" xml:space="preserve">
          <source>The intended use of this setting is that logical replication systems set it to &lt;code&gt;replica&lt;/code&gt; when they are applying replicated changes. The effect of that will be that triggers and rules (that have not been altered from their default configuration) will not fire on the replica. See the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; clauses &lt;code&gt;ENABLE TRIGGER&lt;/code&gt; and &lt;code&gt;ENABLE RULE&lt;/code&gt; for more information.</source>
          <target state="translated">Предполагаемое использование этого параметра заключается в том, что системы логической репликации устанавливают его на &lt;code&gt;replica&lt;/code&gt; когда они применяют реплицированные изменения. Результатом этого будет то, что триггеры и правила (которые не были изменены по сравнению с их конфигурацией по умолчанию) не будут срабатывать на реплике. Посмотреть &lt;a href=&quot;sql-altertable&quot;&gt;TABLE ALTER&lt;/a&gt; положения &lt;code&gt;ENABLE TRIGGER&lt;/code&gt; и &lt;code&gt;ENABLE RULE&lt;/code&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="e73e54c88ad65514d99a46ba805b5445c9c890d2" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow administrators to reduce the I/O impact of these commands on concurrent database activity. There are many situations where it is not important that maintenance commands like &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; finish quickly; however, it is usually very important that these commands do not significantly interfere with the ability of the system to perform other database operations. Cost-based vacuum delay provides a way for administrators to achieve this.</source>
          <target state="translated">Назначение этой функции - позволить администраторам уменьшить влияние ввода-вывода этих команд на параллельную активность базы данных. Во многих ситуациях не важно, чтобы команды обслуживания, такие как &lt;code&gt;VACUUM&lt;/code&gt; и &lt;code&gt;ANALYZE&lt;/code&gt; ,завершались быстро; однако обычно очень важно, чтобы эти команды не влияли существенно на способность системы выполнять другие операции с базой данных. Задержка вакуумирования, основанная на стоимости, позволяет администраторам добиться этого.</target>
        </trans-unit>
        <trans-unit id="3ce7c282b1076520793e0399674bfd41329343fd" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow debugging or performance-measurement libraries to be loaded into specific sessions without an explicit &lt;code&gt;LOAD&lt;/code&gt; command being given. For example, &lt;a href=&quot;auto-explain&quot;&gt;auto_explain&lt;/a&gt; could be enabled for all sessions under a given user name by setting this parameter with &lt;code&gt;ALTER ROLE SET&lt;/code&gt;. Also, this parameter can be changed without restarting the server (but changes only take effect when a new session is started), so it is easier to add new modules this way, even if they should apply to all sessions.</source>
          <target state="translated">Цель этой функции - позволить загружать библиотеки отладки или измерения производительности в определенные сеансы без явной команды &lt;code&gt;LOAD&lt;/code&gt; . Например, &lt;a href=&quot;auto-explain&quot;&gt;auto_explain&lt;/a&gt; можно включить для всех сеансов под данным именем пользователя, установив этот параметр с помощью &lt;code&gt;ALTER ROLE SET&lt;/code&gt; . Кроме того, этот параметр можно изменить без перезапуска сервера (но изменения вступают в силу только при запуске нового сеанса), поэтому таким образом проще добавлять новые модули, даже если они должны применяться ко всем сеансам.</target>
        </trans-unit>
        <trans-unit id="a2719b729cd7a399352ec70d46ec3bef1938f299" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow unprivileged users to load debugging or performance-measurement libraries into specific sessions without requiring an explicit &lt;code&gt;LOAD&lt;/code&gt; command. To that end, it would be typical to set this parameter using the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable on the client or by using &lt;code&gt;ALTER ROLE SET&lt;/code&gt;.</source>
          <target state="translated">Цель этой функции - позволить непривилегированным пользователям загружать библиотеки отладки или измерения производительности в определенные сеансы, не требуя явной команды &lt;code&gt;LOAD&lt;/code&gt; . С этой целью обычно устанавливается этот параметр с помощью переменной среды &lt;code&gt;PGOPTIONS&lt;/code&gt; на клиенте или с помощью &lt;code&gt;ALTER ROLE SET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="410143821cb3667d869f89c45a8792b1a3405b2c" translate="yes" xml:space="preserve">
          <source>The interface was changed in version 8.4, to reflect the new FSM implementation introduced in the same version.</source>
          <target state="translated">Интерфейс был изменен в версии 8.4,чтобы отразить новую реализацию FSM,введенную в той же версии.</target>
        </trans-unit>
        <trans-unit id="e6f5b2286acbba014ef24a9c86063e430de3bd3b" translate="yes" xml:space="preserve">
          <source>The internal representation of one value of an SQL data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2585564a6c8456926cf3442c468ac844142dcda1" translate="yes" xml:space="preserve">
          <source>The internal transaction ID type (&lt;code&gt;xid&lt;/code&gt;) is 32 bits wide and wraps around every 4 billion transactions. However, these functions export a 64-bit format that is extended with an &amp;ldquo;epoch&amp;rdquo; counter so it will not wrap around during the life of an installation. The data type used by these functions, &lt;code&gt;txid_snapshot&lt;/code&gt;, stores information about transaction ID visibility at a particular moment in time. Its components are described in &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT-PARTS&quot;&gt;Table 9.75&lt;/a&gt;.</source>
          <target state="translated">Тип внутреннего идентификатора транзакции ( &lt;code&gt;xid&lt;/code&gt; ) имеет ширину 32 бита и охватывает каждые 4 миллиарда транзакций. Однако эти функции экспортируют 64-битный формат, который дополнен счетчиком &amp;laquo;эпох&amp;raquo;, поэтому он не будет повторяться в течение всего срока установки. Тип данных, используемый этими функциями, &lt;code&gt;txid_snapshot&lt;/code&gt; , хранит информацию о видимости идентификатора транзакции в определенный момент времени. Его компоненты описаны в &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT-PARTS&quot;&gt;Таблице 9.75&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5975b3720301fef7c0533cfc1f13765af09e30a8" translate="yes" xml:space="preserve">
          <source>The internal transaction ID type &lt;code&gt;xid&lt;/code&gt; is 32 bits wide and wraps around every 4 billion transactions. However, the functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT&quot;&gt;Table 9.74&lt;/a&gt; use a 64-bit type &lt;code&gt;xid8&lt;/code&gt; that does not wrap around during the life of an installation, and can be converted to &lt;code&gt;xid&lt;/code&gt; by casting if required. The data type &lt;code&gt;pg_snapshot&lt;/code&gt; stores information about transaction ID visibility at a particular moment in time. Its components are described in &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT-PARTS&quot;&gt;Table 9.75&lt;/a&gt;. &lt;code&gt;pg_snapshot&lt;/code&gt;'s textual representation is &lt;code&gt;xmin:xmax:xip_list&lt;/code&gt;. For example &lt;code&gt;10:20:10,14,15&lt;/code&gt; means &lt;code&gt;xmin=10, xmax=20, xip_list=10, 14, 15&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed88f1a587353da5320c94618461fa62d026126f" translate="yes" xml:space="preserve">
          <source>The inverse operation, producing a character string value from &lt;code&gt;xml&lt;/code&gt;, uses the function &lt;code&gt;xmlserialize&lt;/code&gt;:</source>
          <target state="translated">Обратная операция, производящая значение символьной строки из &lt;code&gt;xml&lt;/code&gt; , использует функцию &lt;code&gt;xmlserialize&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7d6e11429a0e8345e13107b3c0d526111bff86da" translate="yes" xml:space="preserve">
          <source>The isolation level of a transaction determines what data the transaction can see when other transactions are running concurrently:</source>
          <target state="translated">Уровень изоляции транзакции определяет,какие данные транзакция может видеть,когда другие транзакции выполняются одновременно:</target>
        </trans-unit>
        <trans-unit id="e2ee987ab1ca440434d3e02dd908e8550d18dae5" translate="yes" xml:space="preserve">
          <source>The items themselves are stored in space allocated backwards from the end of unallocated space. The exact structure varies depending on what the table is to contain. Tables and sequences both use a structure named &lt;code&gt;HeapTupleHeaderData&lt;/code&gt;, described below.</source>
          <target state="translated">Сами элементы хранятся в пространстве, выделенном в обратном направлении от конца нераспределенного пространства. Точная структура зависит от того, что должна содержать таблица. Таблицы и последовательности используют структуру с именем &lt;code&gt;HeapTupleHeaderData&lt;/code&gt; , описанную ниже.</target>
        </trans-unit>
        <trans-unit id="e475eb2d988c6851551d574040f066c9556a439f" translate="yes" xml:space="preserve">
          <source>The join condition of an inner join can be written either in the &lt;code&gt;WHERE&lt;/code&gt; clause or in the &lt;code&gt;JOIN&lt;/code&gt; clause. For example, these table expressions are equivalent:</source>
          <target state="translated">Условие соединения внутреннего соединения может быть записано либо в &lt;code&gt;WHERE&lt;/code&gt; , либо в предложении &lt;code&gt;JOIN&lt;/code&gt; . Например, эти табличные выражения эквивалентны:</target>
        </trans-unit>
        <trans-unit id="61d61ab7e2b00d48bd33fdcfe38f2676100e3a4c" translate="yes" xml:space="preserve">
          <source>The join condition specified with &lt;code&gt;ON&lt;/code&gt; can also contain conditions that do not relate directly to the join. This can prove useful for some queries but needs to be thought out carefully. For example:</source>
          <target state="translated">Условие соединения, указанное с помощью &lt;code&gt;ON&lt;/code&gt; , также может содержать условия, не относящиеся непосредственно к соединению. Это может оказаться полезным для некоторых запросов, но требует тщательного обдумывания. Например:</target>
        </trans-unit>
        <trans-unit id="3614aab2546a7b09e20ddc9fc01ce0160043ffc8" translate="yes" xml:space="preserve">
          <source>The join selectivity estimator function for this operator.</source>
          <target state="translated">Функция оценки селективности соединения для данного оператора.</target>
        </trans-unit>
        <trans-unit id="d643834432c9495e055ac02fd710963d0e899ceb" translate="yes" xml:space="preserve">
          <source>The join selectivity estimator function for this operator; write NONE to remove existing selectivity estimator.</source>
          <target state="translated">Функция оценки селективности соединения для данного оператора;запишите NONE,чтобы удалить существующую функцию оценки селективности.</target>
        </trans-unit>
        <trans-unit id="105b61ba49be801d77c8efa5f2d2e79da5107648" translate="yes" xml:space="preserve">
          <source>The journal that keeps track of the changes in the &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;database cluster&lt;/a&gt; as user- and system-invoked operations take place. It comprises many individual &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL records&lt;/a&gt; written sequentially to &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL files&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e444824ca1c6f24ef2a354622bc8815bf038f6fd" translate="yes" xml:space="preserve">
          <source>The key and parent-key fields can be any data type, but they must be the same type. Note that the &lt;em&gt;&lt;code&gt;start_with&lt;/code&gt;&lt;/em&gt; value must be entered as a text string, regardless of the type of the key field.</source>
          <target state="translated">Поля ключа и родительского ключа могут быть любого типа данных, но они должны быть одного типа. Обратите внимание, что значение &lt;em&gt; &lt;code&gt;start_with&lt;/code&gt; &lt;/em&gt; должно быть введено как текстовая строка, независимо от типа ключевого поля.</target>
        </trans-unit>
        <trans-unit id="5ed049b1b7aaa3ba51ad6c118d926aadc8da74a8" translate="yes" xml:space="preserve">
          <source>The key field(s) for the index are specified as column names, or alternatively as expressions written in parentheses. Multiple fields can be specified if the index method supports multicolumn indexes.</source>
          <target state="translated">Ключевое поле (поля)для индекса указывается в виде названий столбцов,или альтернативно-в виде выражений,записанных в круглых скобках.Несколько полей могут быть указаны,если метод индекса поддерживает многоколоночные индексы.</target>
        </trans-unit>
        <trans-unit id="d640126eef92261555823243becabed1414b9599" translate="yes" xml:space="preserve">
          <source>The key part of a catalog header file is a C structure definition describing the layout of each row of the catalog. This begins with a &lt;code&gt;CATALOG&lt;/code&gt; macro, which so far as the C compiler is concerned is just shorthand for &lt;code&gt;typedef struct FormData_catalogname&lt;/code&gt;. Each field in the struct gives rise to a catalog column. Fields can be annotated using the BKI property macros described in &lt;code&gt;genbki.h&lt;/code&gt;, for example to define a default value for a field or mark it as nullable or not nullable. The &lt;code&gt;CATALOG&lt;/code&gt; line can also be annotated, with some other BKI property macros described in &lt;code&gt;genbki.h&lt;/code&gt;, to define other properties of the catalog as a whole, such as whether it is a shared relation.</source>
          <target state="translated">Ключевой частью файла заголовка каталога является определение структуры C, описывающее макет каждой строки каталога. Это начинается с макроса &lt;code&gt;CATALOG&lt;/code&gt; , который с точки зрения компилятора C является сокращением для &lt;code&gt;typedef struct FormData_catalogname&lt;/code&gt; . Каждое поле в структуре порождает столбец каталога. Поля могут быть аннотированы с помощью макросов свойств BKI, описанных в &lt;code&gt;genbki.h&lt;/code&gt; , например, чтобы определить значение по умолчанию для поля или пометить его как допускающее или не допускающее значение null. &lt;code&gt;CATALOG&lt;/code&gt; линия также может быть аннотированный, с некоторыми другими макросами БКИ свойств , описанных в &lt;code&gt;genbki.h&lt;/code&gt; , чтобы определить другие свойства каталога в целом, например, является ли он общим отношением.</target>
        </trans-unit>
        <trans-unit id="84768082ee997613deb3f74ec096a132ad1ca977" translate="yes" xml:space="preserve">
          <source>The key part of all this is to set up a recovery configuration that describes how you want to recover and how far the recovery should run. The one thing that you absolutely must specify is the &lt;code&gt;restore_command&lt;/code&gt;, which tells PostgreSQL how to retrieve archived WAL file segments. Like the &lt;code&gt;archive_command&lt;/code&gt;, this is a shell command string. It can contain &lt;code&gt;%f&lt;/code&gt;, which is replaced by the name of the desired log file, and &lt;code&gt;%p&lt;/code&gt;, which is replaced by the path name to copy the log file to. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Write &lt;code&gt;%%&lt;/code&gt; if you need to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command. The simplest useful command is something like:</source>
          <target state="translated">Ключевой частью всего этого является настройка конфигурации восстановления, которая описывает, как вы хотите восстанавливать и как долго должно выполняться восстановление. Единственное, что вы обязательно должны указать, - это команда &lt;code&gt;restore_command&lt;/code&gt; , которая сообщает PostgreSQL, как извлекать заархивированные сегменты файла WAL. Как и &lt;code&gt;archive_command&lt;/code&gt; , это командная строка оболочки. Он может содержать &lt;code&gt;%f&lt;/code&gt; , которое заменяется именем желаемого файла журнала, и &lt;code&gt;%p&lt;/code&gt; , которое заменяется именем пути для копирования файла журнала. (Имя пути указывается относительно текущего рабочего каталога, т. Е. &lt;code&gt;%%&lt;/code&gt; данных кластера.) Напишите %%, если вам нужно встроить фактический символ &lt;code&gt;%&lt;/code&gt; в команду. Самая простая полезная команда выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="6ce0e2cb46720b77226f610a445bda26007f0b40" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;COLUMN&lt;/code&gt; is noise and can be omitted.</source>
          <target state="translated">Ключевое слово &lt;code&gt;COLUMN&lt;/code&gt; - это шум, и его можно не использовать.</target>
        </trans-unit>
        <trans-unit id="5b5ac0f06c70f1fb5409349bf24004b2a55d2f18" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is allowed for SQL conformance, but it is optional since, unlike in SQL, this feature applies to all functions not only external ones.</source>
          <target state="translated">Ключевое слово &lt;code&gt;EXTERNAL&lt;/code&gt; разрешено для соответствия SQL, но не является обязательным, поскольку, в отличие от SQL, эта функция применяется ко всем функциям, а не только к внешним.</target>
        </trans-unit>
        <trans-unit id="7b66b886be54f4dad1fc59336fb968283aedd583" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is allowed for SQL conformance, but it is optional since, unlike in SQL, this feature applies to all procedures not only external ones.</source>
          <target state="translated">Ключевое слово &lt;code&gt;EXTERNAL&lt;/code&gt; разрешено для соответствия SQL, но не является обязательным, поскольку, в отличие от SQL, эта функция применяется ко всем процедурам, а не только к внешним.</target>
        </trans-unit>
        <trans-unit id="f14ab28890a5b7ef2546dae62a05463965282a2c" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;ILIKE&lt;/code&gt; can be used instead of &lt;code&gt;LIKE&lt;/code&gt; to make the match case-insensitive according to the active locale. This is not in the SQL standard but is a PostgreSQL extension.</source>
          <target state="translated">Ключевое слово &lt;code&gt;ILIKE&lt;/code&gt; можно использовать вместо &lt;code&gt;LIKE&lt;/code&gt; , чтобы сделать совпадение нечувствительным к регистру в соответствии с активной локалью. Этого нет в стандарте SQL, но это расширение PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="56bcc837725f3c99bfbefa9f4ad797df653bb446" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;PUBLIC&lt;/code&gt; indicates that the privileges are to be granted to all roles, including those that might be created later. &lt;code&gt;PUBLIC&lt;/code&gt; can be thought of as an implicitly defined group that always includes all roles. Any particular role will have the sum of privileges granted directly to it, privileges granted to any role it is presently a member of, and privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">Ключевое слово &lt;code&gt;PUBLIC&lt;/code&gt; указывает, что привилегии должны быть предоставлены всем ролям, включая те, которые могут быть созданы позже. &lt;code&gt;PUBLIC&lt;/code&gt; можно рассматривать как неявно определенную группу, которая всегда включает в себя все роли. Любая конкретная роль будет иметь сумму привилегий, предоставленных ей непосредственно, привилегий, предоставленных любой роли, членом которой она в настоящее время является, и привилегий, предоставленных &lt;code&gt;PUBLIC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="099dc57512200b2d79974967fc17d8da0e67f388" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;ROW&lt;/code&gt; is optional when there is more than one expression in the list.</source>
          <target state="translated">Ключевое слово &lt;code&gt;ROW&lt;/code&gt; необязательно, если в списке более одного выражения.</target>
        </trans-unit>
        <trans-unit id="f75dcd3d9f2023dad0df5e4baecf4f11764e4ecf" translate="yes" xml:space="preserve">
          <source>The key words &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;INSENSITIVE&lt;/code&gt;, and &lt;code&gt;SCROLL&lt;/code&gt; can appear in any order.</source>
          <target state="translated">Ключевые слова &lt;code&gt;BINARY&lt;/code&gt; , &lt;code&gt;INSENSITIVE&lt;/code&gt; и &lt;code&gt;SCROLL&lt;/code&gt; могут появляться в любом порядке.</target>
        </trans-unit>
        <trans-unit id="933ba0b83729a47d657b68dbaf9310c7b7c42eff" translate="yes" xml:space="preserve">
          <source>The key words &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are the preferred (SQL-compliant) method for writing Boolean constants in SQL queries. But you can also use the string representations by following the generic string-literal constant syntax described in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Section 4.1.2.7&lt;/a&gt;, for example &lt;code&gt;'yes'::boolean&lt;/code&gt;.</source>
          <target state="translated">Ключевые слова &lt;code&gt;TRUE&lt;/code&gt; и &lt;code&gt;FALSE&lt;/code&gt; - это предпочтительный (совместимый с SQL) метод записи логических констант в SQL-запросах. Но вы также можете использовать строковые представления, следуя общему синтаксису констант строкового литерала, описанному в &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Разделе 4.1.2.7&lt;/a&gt; , например &lt;code&gt;'yes'::boolean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="301ce5b56290e04645decb19cd60fcc9e64d775e" translate="yes" xml:space="preserve">
          <source>The keytab file is generated by the Kerberos software; see the Kerberos documentation for details. The following example is for MIT-compatible Kerberos 5 implementations:</source>
          <target state="translated">Файл keytab генерируется программным обеспечением Kerberos;подробности см.в документации Kerberos.Следующий пример предназначен для MIT-совместимых реализаций Kerberos 5:</target>
        </trans-unit>
        <trans-unit id="77aaa5ebf06bbbd98db8e2f5ba28cce520375eb5" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;ANY&lt;/code&gt;, coupled with &lt;code&gt;num_sync&lt;/code&gt;, specifies a quorum-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;em&gt;at least&lt;/em&gt;&lt;code&gt;num_sync&lt;/code&gt; listed standbys. For example, a setting of &lt;code&gt;ANY 3 (s1, s2, s3, s4)&lt;/code&gt; will cause each commit to proceed as soon as at least any three standbys of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; reply.</source>
          <target state="translated">Ключевое слово &lt;code&gt;ANY&lt;/code&gt; в сочетании с &lt;code&gt;num_sync&lt;/code&gt; определяет синхронную репликацию на основе кворума и заставляет фиксации транзакций ждать, пока их записи WAL не будут реплицированы &lt;em&gt;как минимум на &lt;/em&gt; &lt;code&gt;num_sync&lt;/code&gt; перечисленные в num_sync. Например, установка &lt;code&gt;ANY 3 (s1, s2, s3, s4)&lt;/code&gt; заставит каждую фиксацию продолжаться, как только ответят по крайней мере любые три резервных сервера &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; , &lt;code&gt;s3&lt;/code&gt; и &lt;code&gt;s4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f98af4e22fce388807986209bcfe098613dae4c1" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;FIRST&lt;/code&gt;, coupled with &lt;code&gt;num_sync&lt;/code&gt;, specifies a priority-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;code&gt;num_sync&lt;/code&gt; synchronous standbys chosen based on their priorities. For example, a setting of &lt;code&gt;FIRST 3 (s1, s2, s3, s4)&lt;/code&gt; will cause each commit to wait for replies from three higher-priority standbys chosen from standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt;. The standbys whose names appear earlier in the list are given higher priority and will be considered as synchronous. Other standby servers appearing later in this list represent potential synchronous standbys. If any of the current synchronous standbys disconnects for whatever reason, it will be replaced immediately with the next-highest-priority standby. The keyword &lt;code&gt;FIRST&lt;/code&gt; is optional.</source>
          <target state="translated">Ключевое слово &lt;code&gt;FIRST&lt;/code&gt; в сочетании с &lt;code&gt;num_sync&lt;/code&gt; определяет синхронную репликацию на основе приоритета и заставляет транзакции ждать, пока их записи WAL не будут реплицированы на синхронные резервные &lt;code&gt;num_sync&lt;/code&gt; num_sync, выбранные на основе их приоритетов. Например, установка &lt;code&gt;FIRST 3 (s1, s2, s3, s4)&lt;/code&gt; заставит каждую фиксацию ждать ответов от трех резервных серверов с более высоким приоритетом, выбранных из резервных серверов &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; , &lt;code&gt;s3&lt;/code&gt; и &lt;code&gt;s4&lt;/code&gt; .. Резервным серверам, имена которых указаны раньше в списке, предоставляется более высокий приоритет и они будут считаться синхронными. Другие резервные серверы, указанные ниже в этом списке, представляют собой потенциальные синхронные резервные серверы. Если какой-либо из текущих синхронных резервных серверов отключается по какой-либо причине, он будет немедленно заменен на следующий с наивысшим приоритетом резервный. Ключевое слово &lt;code&gt;FIRST&lt;/code&gt; необязательно.</target>
        </trans-unit>
        <trans-unit id="c6753d4b26b83ec9737507aab616ad0a90dffe5e" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; is required to signify that the column will be computed on write and will be stored on disk.</source>
          <target state="translated">Ключевое слово &lt;code&gt;STORED&lt;/code&gt; требуется для обозначения того, что столбец будет вычисляться при записи и будет сохранен на диске.</target>
        </trans-unit>
        <trans-unit id="436779e1054adc0e89a0677ecb406409dda7f240" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; is required to signify that the column will be computed on write. (The computed value will be presented to the foreign-data wrapper for storage and must be returned on reading.)</source>
          <target state="translated">Ключевое слово &lt;code&gt;STORED&lt;/code&gt; требуется для обозначения того, что столбец будет вычисляться при записи. (Вычисленное значение будет представлено оболочке сторонних данных для хранения и должно быть возвращено при чтении.)</target>
        </trans-unit>
        <trans-unit id="5edd7a55d1b24539fc9cfa0bcf24706822731dd3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; must be specified to choose the stored kind of generated column. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">Ключевое слово &lt;code&gt;STORED&lt;/code&gt; должно быть указано для выбора сохраняемого типа создаваемого столбца. См. &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="e643395261c7f81c30fc2a4e61b7aaf97e975625" translate="yes" xml:space="preserve">
          <source>The label provider associated with this label.</source>
          <target state="translated">Поставщик этикеток,связанный с этой этикеткой.</target>
        </trans-unit>
        <trans-unit id="468c79531b62d3d36755c25fe6c2c2d1c6c04f9c" translate="yes" xml:space="preserve">
          <source>The label provider determines whether a given label is valid and whether it is permissible to assign that label to a given object. The meaning of a given label is likewise at the discretion of the label provider. PostgreSQL places no restrictions on whether or how a label provider must interpret security labels; it merely provides a mechanism for storing them. In practice, this facility is intended to allow integration with label-based mandatory access control (MAC) systems such as SE-Linux. Such systems make all access control decisions based on object labels, rather than traditional discretionary access control (DAC) concepts such as users and groups.</source>
          <target state="translated">Поставщик меток определяет,является ли данная метка действительной и допустимо ли присвоение этой метки определенному объекту.Смысл данной метки также определяется по усмотрению поставщика меток.PostgreSQL не накладывает никаких ограничений на то,должен ли провайдер меток интерпретировать этикетки безопасности или как он это делает;он просто предоставляет механизм их хранения.На практике,эта подсистема предназначена для интеграции с системами принудительного контроля доступа (MAC),основанными на метках,такими как SE-Linux.Такие системы принимают все решения по контролю доступа на основе меток объектов,а не традиционных концепций дискреционного контроля доступа (DAC),таких как пользователи и группы.</target>
        </trans-unit>
        <trans-unit id="8eaf1d04fc556db25e421838f63ccbd315696008" translate="yes" xml:space="preserve">
          <source>The label provider determines whether a given label is valid and whether it is permissible to assign that label to a given object. The meaning of a given label is likewise at the discretion of the label provider. PostgreSQL places no restrictions on whether or how a label provider must interpret security labels; it merely provides a mechanism for storing them. In practice, this facility is intended to allow integration with label-based mandatory access control (MAC) systems such as SELinux. Such systems make all access control decisions based on object labels, rather than traditional discretionary access control (DAC) concepts such as users and groups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fab09475b65e9983ce79215513aca004922a64" translate="yes" xml:space="preserve">
          <source>The lag times reported in the &lt;code&gt;pg_stat_replication&lt;/code&gt; view are measurements of the time taken for recent WAL to be written, flushed and replayed and for the sender to know about it. These times represent the commit delay that was (or would have been) introduced by each synchronous commit level, if the remote server was configured as a synchronous standby. For an asynchronous standby, the &lt;code&gt;replay_lag&lt;/code&gt; column approximates the delay before recent transactions became visible to queries. If the standby server has entirely caught up with the sending server and there is no more WAL activity, the most recently measured lag times will continue to be displayed for a short time and then show NULL.</source>
          <target state="translated">Время задержки, указанное в представлении &lt;code&gt;pg_stat_replication&lt;/code&gt; , является мерой времени, затраченного на запись, сброс и воспроизведение последнего WAL, а также на то, чтобы отправитель узнал об этом. Это время представляет собой задержку фиксации, которая была (или должна была быть) введена каждым уровнем синхронной фиксации, если удаленный сервер был настроен как синхронный резервный. Для асинхронного резервного &lt;code&gt;replay_lag&lt;/code&gt; столбец replay_lag приближает задержку до того, как последние транзакции станут видимыми для запросов. Если резервный сервер полностью догнал отправляющий сервер и больше нет активности WAL, последнее измеренное время задержки продолжит отображаться в течение короткого времени, а затем будет отображаться NULL.</target>
        </trans-unit>
        <trans-unit id="eb0c7351bd920c1bdbdffe727ba791d1a927eafe" translate="yes" xml:space="preserve">
          <source>The largest part of shared memory is known as &lt;em&gt;shared buffers&lt;/em&gt; and is used to mirror part of data files, organized into pages. When a page is modified, it is called a dirty page until it is written back to the file system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee0490b803b85b6819bd67e0eb5d37f8061673f" translate="yes" xml:space="preserve">
          <source>The largest statistics target among the columns being analyzed determines the number of table rows sampled to prepare the statistics. Increasing the target causes a proportional increase in the time and space needed to do &lt;code&gt;ANALYZE&lt;/code&gt;.</source>
          <target state="translated">Наибольшая цель статистики среди анализируемых столбцов определяет количество строк таблицы, отобранных для подготовки статистики. Увеличение цели вызывает пропорциональное увеличение времени и пространства, необходимого для выполнения &lt;code&gt;ANALYZE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08ac6817284c2739892a594416144a19a2fc3c3b" translate="yes" xml:space="preserve">
          <source>The last example shows that the checks include whether namespaces are correctly matched.</source>
          <target state="translated">Последний пример показывает,что проверка включает правильное совпадение пространств имен.</target>
        </trans-unit>
        <trans-unit id="b141d1efe06f21d25a717b844dfa4141ae98f099" translate="yes" xml:space="preserve">
          <source>The last five parameters are pass-by-reference outputs:</source>
          <target state="translated">Последние пять параметров являются выходными параметрами,передаваемыми по ссылкам:</target>
        </trans-unit>
        <trans-unit id="640860dcca4728ae99db3adc4362cf72e26f4370" translate="yes" xml:space="preserve">
          <source>The last line could also be:</source>
          <target state="translated">Последняя строчка тоже может быть:</target>
        </trans-unit>
        <trans-unit id="a268591c13ee52793b16cb868a71b9f235920223" translate="yes" xml:space="preserve">
          <source>The last line is useful in verifying that the client is trying to connect to the right place. If there is in fact no server running there, the kernel error message will typically be either &lt;code&gt;Connection refused&lt;/code&gt; or &lt;code&gt;No such file or directory&lt;/code&gt;, as illustrated. (It is important to realize that &lt;code&gt;Connection refused&lt;/code&gt; in this context does &lt;em&gt;not&lt;/em&gt; mean that the server got your connection request and rejected it. That case will produce a different message, as shown in &lt;a href=&quot;client-authentication-problems&quot;&gt;Section 20.15&lt;/a&gt;.) Other error messages such as &lt;code&gt;Connection timed out&lt;/code&gt; might indicate more fundamental problems, like lack of network connectivity.</source>
          <target state="translated">Последняя строка полезна для проверки того, что клиент пытается подключиться к нужному месту. Если на самом деле там нет запущенного сервера, сообщение об ошибке ядра обычно будет либо В &lt;code&gt;Connection refused&lt;/code&gt; либо &lt;code&gt;No such file or directory&lt;/code&gt; , как показано. (Важно понимать , что &lt;code&gt;Connection refused&lt;/code&gt; в данном контексте не &lt;em&gt;не&lt;/em&gt; означает , что сервер получил ваш запрос на соединение и отверг его. Этот случай будет производить другое сообщение, как показано в &lt;a href=&quot;client-authentication-problems&quot;&gt;разделе 20.15&lt;/a&gt; .) Другие сообщения об ошибках , таких как &lt;code&gt;Connection timed out&lt;/code&gt; мощь указывают на более серьезные проблемы, такие как отсутствие подключения к сети.</target>
        </trans-unit>
        <trans-unit id="cca952ade3d373926896de08f3f6cd0f1c245369" translate="yes" xml:space="preserve">
          <source>The last line printed out by &lt;code&gt;psql&lt;/code&gt; is the prompt, and it indicates that &lt;code&gt;psql&lt;/code&gt; is listening to you and that you can type SQL queries into a work space maintained by &lt;code&gt;psql&lt;/code&gt;. Try out these commands:</source>
          <target state="translated">Последняя строка, &lt;code&gt;psql&lt;/code&gt; - это приглашение, и оно указывает, что &lt;code&gt;psql&lt;/code&gt; слушает вас и что вы можете вводить SQL-запросы в рабочее пространство, поддерживаемое &lt;code&gt;psql&lt;/code&gt; . Попробуйте эти команды:</target>
        </trans-unit>
        <trans-unit id="4a2bf24f5739dd825710ff53126984ef2f6e0852" translate="yes" xml:space="preserve">
          <source>The last modification time of the file as reported by the server at the time of the backup. Unlike the other fields stored in the backup, this field is not used by &lt;a href=&quot;app-pgverifybackup&quot;&gt;pg_verifybackup&lt;/a&gt;. It is included only for informational purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5a300b26673b4a75043297a6f146dcd49c5439" translate="yes" xml:space="preserve">
          <source>The last sequence value written to disk. If caching is used, this value can be greater than the last value handed out from the sequence. Null if the sequence has not been read from yet. Also, if the current user does not have &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the sequence, the value is null.</source>
          <target state="translated">Последнее значение последовательности, записанное на диск. Если используется кеширование, это значение может быть больше, чем последнее значение, переданное из последовательности. Null, если последовательность еще не была прочитана. Кроме того, если текущий пользователь не имеет привилегий &lt;code&gt;USAGE&lt;/code&gt; или &lt;code&gt;SELECT&lt;/code&gt; для этой последовательности, значение равно нулю.</target>
        </trans-unit>
        <trans-unit id="3ddb6dca4d033d643b4947fa1e0c4bfe448712f8" translate="yes" xml:space="preserve">
          <source>The last six input formats shown above are not part of any standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8146be3b6220418f9831589eda3884a4555e4dfa" translate="yes" xml:space="preserve">
          <source>The last two states are seen only when &lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt; is non-negative. If &lt;code&gt;restart_lsn&lt;/code&gt; is NULL, this field is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe313657b9f725a4a4c3652ad1d9e1c661ac0d8" translate="yes" xml:space="preserve">
          <source>The latter is syntactically valid, but it represents a call of a single-argument aggregate function with two &lt;code&gt;ORDER BY&lt;/code&gt; keys (the second one being rather useless since it's a constant).</source>
          <target state="translated">Последний синтаксически действителен, но представляет собой вызов агрегатной функции с одним аргументом с двумя ключами &lt;code&gt;ORDER BY&lt;/code&gt; (второй из них бесполезен, поскольку является константой).</target>
        </trans-unit>
        <trans-unit id="ec920275f2c822a2a5adceef23c754e25dadccba" translate="yes" xml:space="preserve">
          <source>The lax mode facilitates matching of a JSON document structure and path expression if the JSON data does not conform to the expected schema. If an operand does not match the requirements of a particular operation, it can be automatically wrapped as an SQL/JSON array or unwrapped by converting its elements into an SQL/JSON sequence before performing this operation. Besides, comparison operators automatically unwrap their operands in the lax mode, so you can compare SQL/JSON arrays out-of-the-box. An array of size 1 is considered equal to its sole element. Automatic unwrapping is not performed only when:</source>
          <target state="translated">Режим lax облегчает сопоставление JSON-структуры документа и выражения пути,если JSON-данные не соответствуют ожидаемой схеме.Если операнд не соответствует требованиям конкретной операции,его можно автоматически обернуть в массив SQL/JSON или развернуть,преобразовав его элементы в последовательность SQL/JSON перед выполнением этой операции.Кроме того,операторы сравнения автоматически сворачивают свои операнды в режим lax,так что вы можете сравнивать массивы SQL/JSON нестандартно.Массив размером 1 считается равным его единственному элементу.Автоматическое распаковывание не выполняется только когда:</target>
        </trans-unit>
        <trans-unit id="c52a670d06775855c2164b78f437c77c8a3136cd" translate="yes" xml:space="preserve">
          <source>The least downtime can be achieved by installing the new server in a different directory and running both the old and the new servers in parallel, on different ports. Then you can use something like:</source>
          <target state="translated">Наименьшее время простоя может быть достигнуто установкой нового сервера в другой каталог и параллельной работой как старого,так и нового серверов,на разных портах.Тогда вы можете использовать нечто подобное:</target>
        </trans-unit>
        <trans-unit id="082fd8f2f5ff84b43f58645d6265cd8d6ba42c18" translate="yes" xml:space="preserve">
          <source>The left-hand side is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. Furthermore, the subquery cannot return more than one row. (If it returns zero rows, the result is taken to be null.) The left-hand side is evaluated and compared row-wise to the single subquery result row.</source>
          <target state="translated">В левой части находится конструктор строки, как описано в &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Разделе 4.2.13&lt;/a&gt; . Правая часть - это заключенный в скобки подзапрос, который должен возвращать ровно столько столбцов, сколько выражений в левой строке. Кроме того, подзапрос не может возвращать более одной строки. (Если он возвращает ноль строк, результат считается нулевым.) Левая часть оценивается и сравнивается построчно с единственной строкой результата подзапроса.</target>
        </trans-unit>
        <trans-unit id="f44070270517992cebfd8a7909698b4367aa0cae" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;ALL&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result, using the given &lt;code&gt;operator&lt;/code&gt;. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if the comparison returns true for all subquery rows (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if the comparison returns false for any subquery row. The result is NULL if no comparison with a subquery row returns false, and at least one comparison returns NULL.</source>
          <target state="translated">Левая часть этой формы &lt;code&gt;ALL&lt;/code&gt; - это конструктор строки, как описано в &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Разделе 4.2.13&lt;/a&gt; . Правая часть - это заключенный в скобки подзапрос, который должен возвращать ровно столько столбцов, сколько выражений в левой строке. Левые выражения оцениваются и сравниваются по строкам с каждой строкой результата подзапроса с использованием данного &lt;code&gt;operator&lt;/code&gt; . Результатом &lt;code&gt;ALL&lt;/code&gt; является &amp;laquo;истина&amp;raquo;, если сравнение возвращает истину для всех строк подзапроса (включая случай, когда подзапрос не возвращает строк). Результатом будет &amp;laquo;ложь&amp;raquo;, если сравнение вернет ложь для любой строки подзапроса. Результатом является NULL, если никакое сравнение со строкой подзапроса не возвращает false, и хотя бы одно сравнение возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="3a495b6469d287a27574f63256e96477ed641f86" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;ANY&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result, using the given &lt;code&gt;operator&lt;/code&gt;. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if the comparison returns true for any subquery row. The result is &amp;ldquo;false&amp;rdquo; if the comparison returns false for every subquery row (including the case where the subquery returns no rows). The result is NULL if no comparison with a subquery row returns true, and at least one comparison returns NULL.</source>
          <target state="translated">Левая часть этой формы &lt;code&gt;ANY&lt;/code&gt; - конструктор строки, как описано в &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Разделе 4.2.13&lt;/a&gt; . Правая часть - это заключенный в скобки подзапрос, который должен возвращать ровно столько столбцов, сколько выражений в левой строке. Левые выражения оцениваются и сравниваются по строкам с каждой строкой результата подзапроса с использованием данного &lt;code&gt;operator&lt;/code&gt; . Результатом &lt;code&gt;ANY&lt;/code&gt; будет &amp;laquo;истина&amp;raquo;, если сравнение вернет истину для любой строки подзапроса. Результатом будет &amp;laquo;ложь&amp;raquo;, если сравнение возвращает ложь для каждой строки подзапроса (включая случай, когда подзапрос не возвращает строк). Результатом является NULL, если никакое сравнение со строкой подзапроса не возвращает true, и хотя бы одно сравнение возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="afdaf261917f03fc0c447e59e3d5a8be456d89c2" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;IN&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result. The result of &lt;code&gt;IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any equal subquery row is found. The result is &amp;ldquo;false&amp;rdquo; if no equal row is found (including the case where the subquery returns no rows).</source>
          <target state="translated">Левая часть этой формы &lt;code&gt;IN&lt;/code&gt; представляет собой конструктор строки, как описано в &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Разделе 4.2.13&lt;/a&gt; . Правая часть - это заключенный в скобки подзапрос, который должен возвращать ровно столько столбцов, сколько выражений в левой строке. Левые выражения оцениваются и сравниваются построчно с каждой строкой результата подзапроса. Результат &lt;code&gt;IN&lt;/code&gt; - &amp;laquo;истина&amp;raquo;, если найдена любая такая же строка подзапроса. Результатом будет &amp;laquo;ложь&amp;raquo;, если не найдено ни одной одинаковой строки (включая случай, когда подзапрос не возвращает строк).</target>
        </trans-unit>
        <trans-unit id="a1d433de59d411f27b86b3382eba3a1fea3e9e5d" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;NOT IN&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result. The result of &lt;code&gt;NOT IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if only unequal subquery rows are found (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any equal row is found.</source>
          <target state="translated">Левая часть этой формы &lt;code&gt;NOT IN&lt;/code&gt; - это конструктор строки, как описано в &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Разделе 4.2.13&lt;/a&gt; . Правая часть - это заключенный в скобки подзапрос, который должен возвращать ровно столько столбцов, сколько выражений в левой строке. Левые выражения оцениваются и сравниваются построчно с каждой строкой результата подзапроса. Результатом &lt;code&gt;NOT IN&lt;/code&gt; будет &amp;laquo;истина&amp;raquo;, если найдены только неравные строки подзапроса (включая случай, когда подзапрос не возвращает строк). Результатом будет &amp;laquo;ложь&amp;raquo;, если будет найдена любая такая же строка.</target>
        </trans-unit>
        <trans-unit id="4585d75ed76ee1f40b5daa39dfcad2d39fb7784d" translate="yes" xml:space="preserve">
          <source>The left-of/right-of/adjacent operators always return false when an empty range is involved; that is, an empty range is not considered to be either before or after any other range.</source>
          <target state="translated">Операторы слева/справа/слева всегда возвращают false,когда речь идет о пустом диапазоне;т.е.пустой диапазон не считается ни до,ни после любого другого диапазона.</target>
        </trans-unit>
        <trans-unit id="2f5d1e6e1b59ebb3b7a2ceefdc5f69123a880bd7" translate="yes" xml:space="preserve">
          <source>The length of a &lt;code&gt;tsvector&lt;/code&gt; (lexemes + positions) must be less than 1 megabyte</source>
          <target state="translated">Длина &lt;code&gt;tsvector&lt;/code&gt; (лексемы + позиции) должна быть меньше 1 мегабайта.</target>
        </trans-unit>
        <trans-unit id="fb55102e4d77862d8595a399532f60d05305a61a" translate="yes" xml:space="preserve">
          <source>The length of each lexeme must be less than 2 kilobytes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72cf9ee51b093da890b7dcc27caaf482e19db7ab" translate="yes" xml:space="preserve">
          <source>The length of each lexeme must be less than 2K bytes</source>
          <target state="translated">Длина каждой лексемы должна быть менее 2K байт.</target>
        </trans-unit>
        <trans-unit id="07e3cb5f7b40e6d63b3d5d01d67980671a6f7bf1" translate="yes" xml:space="preserve">
          <source>The library file name is typically given as just a bare file name, which is sought in the server's library search path (set by &lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_path&lt;/a&gt;). Alternatively it can be given as a full path name. In either case the platform's standard shared library file name extension may be omitted. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;Section 37.10.1&lt;/a&gt; for more information on this topic.</source>
          <target state="translated">Имя файла библиотеки обычно дается как простое имя файла, которое ищется в пути поиска библиотеки сервера (установленном &lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;динамическим_путь_библиотеки&lt;/a&gt; ). В качестве альтернативы он может быть указан как полное имя пути. В любом случае расширение имени файла стандартной разделяемой библиотеки платформы может быть опущено. См. &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;Раздел 37.10.1&lt;/a&gt; для получения дополнительной информации по этой теме.</target>
        </trans-unit>
        <trans-unit id="ca07c214a1fa57e76fa5efc5dc421655af5b85fc" translate="yes" xml:space="preserve">
          <source>The library file name is typically given as just a bare file name, which is sought in the server's library search path (set by &lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_path&lt;/a&gt;). Alternatively it can be given as a full path name. In either case the platform's standard shared library file name extension may be omitted. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;Section 37.10.1&lt;/a&gt; for more information on this topic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9d5172bb2076ce6b62f3e5058e20954eddcb55" translate="yes" xml:space="preserve">
          <source>The libxml2 library does seem to always return node-sets to PostgreSQL with their members in the same relative order they had in the input document. Its documentation does not commit to this behavior, and an XPath 1.0 expression cannot control it.</source>
          <target state="translated">Похоже,что библиотека libxml2 всегда возвращает наборы узлов в PostgreSQL с их членами в том же относительном порядке,который они имели во входном документе.Ее документация не фиксирует такое поведение,и выражение XPath 1.0 не может его контролировать.</target>
        </trans-unit>
        <trans-unit id="e92855a9b20ea0f884a230e63ef7768d88fd5352" translate="yes" xml:space="preserve">
          <source>The limitations of pg_restore are detailed below.</source>
          <target state="translated">Ограничения pg_restore подробно описаны ниже.</target>
        </trans-unit>
        <trans-unit id="87e598717783e82b1e191a7f90cf401c4ee0b779" translate="yes" xml:space="preserve">
          <source>The line number inside the current statement, starting from &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Номер строки внутри текущего оператора, начиная с &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d10565a24d6154d743d122e032098869756ae365" translate="yes" xml:space="preserve">
          <source>The list below shows the available lock modes and the contexts in which they are used automatically by PostgreSQL. You can also acquire any of these locks explicitly with the command &lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt;. Remember that all of these lock modes are table-level locks, even if the name contains the word &amp;ldquo;row&amp;rdquo;; the names of the lock modes are historical. To some extent the names reflect the typical usage of each lock mode &amp;mdash; but the semantics are all the same. The only real difference between one lock mode and another is the set of lock modes with which each conflicts (see &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;Table 13.2&lt;/a&gt;). Two transactions cannot hold locks of conflicting modes on the same table at the same time. (However, a transaction never conflicts with itself. For example, it might acquire &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock and later acquire &lt;code&gt;ACCESS SHARE&lt;/code&gt; lock on the same table.) Non-conflicting lock modes can be held concurrently by many transactions. Notice in particular that some lock modes are self-conflicting (for example, an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock cannot be held by more than one transaction at a time) while others are not self-conflicting (for example, an &lt;code&gt;ACCESS SHARE&lt;/code&gt; lock can be held by multiple transactions).</source>
          <target state="translated">В списке ниже показаны доступные режимы блокировки и контексты, в которых они автоматически используются PostgreSQL. Вы также можете явно установить любую из этих блокировок с помощью команды &lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt; . Помните, что все эти режимы блокировки являются блокировками на уровне таблицы, даже если в имени содержится слово &amp;laquo;строка&amp;raquo;; названия режимов блокировки исторические. В некоторой степени имена отражают типичное использование каждого режима блокировки, но семантика все та же. Единственное реальное различие между одним режимом блокировки и другим - это набор режимов блокировки, с которыми каждый из них конфликтует (см. &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;Таблицу 13.2&lt;/a&gt; ). Две транзакции не могут одновременно удерживать блокировки конфликтующих режимов на одной и той же таблице. (Однако транзакция никогда не конфликтует сама с собой. Например, она может получить &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock и позже получить &lt;code&gt;ACCESS SHARE&lt;/code&gt; блокировку для той же таблицы. Неконфликтующие режимы блокировки могут поддерживаться одновременно многими транзакциями. Обратите внимание, в частности, что некоторые режимы блокировки являются самоконфликтными (например, блокировка &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; не может удерживаться более чем одной транзакцией одновременно), в то время как другие не являются самоконфликтными (например, блокировка &lt;code&gt;ACCESS SHARE&lt;/code&gt; может удерживаться с помощью множественные транзакции).</target>
        </trans-unit>
        <trans-unit id="4e69c1b0ac656b6b15e1946ebe2102bdb20487dd" translate="yes" xml:space="preserve">
          <source>The list of built-in functions is in &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. Other functions can be added by the user.</source>
          <target state="translated">Список встроенных функций находится в &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;главе 9&lt;/a&gt; . Другие функции могут быть добавлены пользователем.</target>
        </trans-unit>
        <trans-unit id="98078b1844b2f5121863d76d0e6ccd8659c9a105" translate="yes" xml:space="preserve">
          <source>The list of built-in functions is in &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. Other functions can be added by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034ee84c98b899e3f08ab6a22f176f2b0b9c945d" translate="yes" xml:space="preserve">
          <source>The list of output expressions after &lt;code&gt;SELECT&lt;/code&gt; can be empty, producing a zero-column result table. This is not valid syntax according to the SQL standard. PostgreSQL allows it to be consistent with allowing zero-column tables. However, an empty list is not allowed when &lt;code&gt;DISTINCT&lt;/code&gt; is used.</source>
          <target state="translated">Список выходных выражений после &lt;code&gt;SELECT&lt;/code&gt; может быть пустым, в результате получается таблица результатов с нулевым столбцом. Это недопустимый синтаксис в соответствии со стандартом SQL. PostgreSQL позволяет согласовывать его с таблицами с нулевым столбцом. Однако при использовании &lt;code&gt;DISTINCT&lt;/code&gt; пустой список не допускается .</target>
        </trans-unit>
        <trans-unit id="8494c9c3de42f371358e2a2e5b1c91631cba7c4b" translate="yes" xml:space="preserve">
          <source>The listing file consists of a header and one line for each item, e.g.:</source>
          <target state="translated">Файл листинга состоит из заголовка и одной строки для каждого элемента,например:</target>
        </trans-unit>
        <trans-unit id="c073ed3743a7cc8517210053a4e46a167f30e3ab" translate="yes" xml:space="preserve">
          <source>The literal &lt;code&gt;1.2&lt;/code&gt; is of type &lt;code&gt;numeric&lt;/code&gt;, and the &lt;code&gt;integer&lt;/code&gt; value &lt;code&gt;1&lt;/code&gt; can be cast implicitly to &lt;code&gt;numeric&lt;/code&gt;, so that type is used.</source>
          <target state="translated">Литерал &lt;code&gt;1.2&lt;/code&gt; имеет &lt;code&gt;numeric&lt;/code&gt; тип , а &lt;code&gt;integer&lt;/code&gt; значение &lt;code&gt;1&lt;/code&gt; может быть неявно преобразовано в &lt;code&gt;numeric&lt;/code&gt; , так что используется этот тип.</target>
        </trans-unit>
        <trans-unit id="81389809d8e329e135cb6738d28db71cfa07fe84" translate="yes" xml:space="preserve">
          <source>The local shell command to execute to archive a completed WAL file segment. Any &lt;code&gt;%p&lt;/code&gt; in the string is replaced by the path name of the file to archive, and any &lt;code&gt;%f&lt;/code&gt; is replaced by only the file name. (The path name is relative to the working directory of the server, i.e., the cluster's data directory.) Use &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command. It is important for the command to return a zero exit status only if it succeeds. For more information see &lt;a href=&quot;continuous-archiving#BACKUP-ARCHIVING-WAL&quot;&gt;Section 25.3.1&lt;/a&gt;.</source>
          <target state="translated">Команда локальной оболочки, выполняемая для архивации завершенного сегмента файла WAL. Любой &lt;code&gt;%p&lt;/code&gt; в строке заменяется именем пути к файлу для архивирования, а любой &lt;code&gt;%f&lt;/code&gt; заменяется только именем файла. (Путь указывается относительно рабочего каталога сервера, т. &lt;code&gt;%%&lt;/code&gt; Каталога данных кластера.) Используйте %%, чтобы вставить фактический символ &lt;code&gt;%&lt;/code&gt; в команду. Важно, чтобы команда возвращала нулевой статус выхода только в случае успеха. Для получения дополнительной информации см. &lt;a href=&quot;continuous-archiving#BACKUP-ARCHIVING-WAL&quot;&gt;Раздел 25.3.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c6814fd70a4837bf3123c78d06664813ae5c2c3" translate="yes" xml:space="preserve">
          <source>The local shell command to execute to retrieve an archived segment of the WAL file series. This parameter is required for archive recovery, but optional for streaming replication. Any &lt;code&gt;%f&lt;/code&gt; in the string is replaced by the name of the file to retrieve from the archive, and any &lt;code&gt;%p&lt;/code&gt; is replaced by the copy destination path name on the server. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Any &lt;code&gt;%r&lt;/code&gt; is replaced by the name of the file containing the last valid restart point. That is the earliest file that must be kept to allow a restore to be restartable, so this information can be used to truncate the archive to just the minimum required to support restarting from the current restore. &lt;code&gt;%r&lt;/code&gt; is typically only used by warm-standby configurations (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;). Write &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">Локальная команда оболочки, выполняемая для получения заархивированного сегмента файловой серии WAL. Этот параметр необходим для восстановления архива, но необязателен для потоковой репликации. Любой &lt;code&gt;%f&lt;/code&gt; в строке заменяется именем файла, который нужно извлечь из архива, а любой &lt;code&gt;%p&lt;/code&gt; заменяется именем пути назначения копии на сервере. (Имя пути указывается относительно текущего рабочего каталога, т. Е. Каталога данных кластера.) Любой &lt;code&gt;%r&lt;/code&gt; заменяется именем файла, содержащего последнюю допустимую точку перезапуска. Это самый ранний файл, который необходимо сохранить, чтобы можно было перезапустить восстановление, поэтому эту информацию можно использовать для усечения архива до минимума, необходимого для поддержки перезапуска из текущего восстановления. &lt;code&gt;%r&lt;/code&gt; обычно используется только в конфигурациях с горячим резервом (см. &lt;a href=&quot;warm-standby&quot;&gt;Раздел 26.2&lt;/a&gt; ). Напишите &lt;code&gt;%%&lt;/code&gt; , чтобы вставить фактический символ &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1eefb4d9f04f196c0b255cf3b0eec2ac11926c27" translate="yes" xml:space="preserve">
          <source>The locale settings influence the following SQL features:</source>
          <target state="translated">Настройки локали влияют на следующие возможности SQL:</target>
        </trans-unit>
        <trans-unit id="7a32d4357c6c565a2645be6e8f5dcd4ff20db468" translate="yes" xml:space="preserve">
          <source>The location must be an existing, empty directory that is owned by the PostgreSQL operating system user. All objects subsequently created within the tablespace will be stored in files underneath this directory. The location must not be on removable or transient storage, as the cluster might fail to function if the tablespace is missing or lost.</source>
          <target state="translated">Местоположение должно быть существующим,пустым каталогом,который принадлежит пользователю операционной системы PostgreSQL.Все объекты,созданные впоследствии в табличном пространстве,будут храниться в файлах под этой директорией.Местоположение не должно быть на съемном или переходном хранении,так как кластер может не функционировать,если табличное пространство отсутствует или потеряно.</target>
        </trans-unit>
        <trans-unit id="b667dea533a6876f6f89e862e7e520ec6a41f7d3" translate="yes" xml:space="preserve">
          <source>The location of the history file can be set explicitly via the &lt;code&gt;HISTFILE&lt;/code&gt; psql variable or the &lt;code&gt;PSQL_HISTORY&lt;/code&gt; environment variable.</source>
          <target state="translated">Расположение файла истории можно указать явно с помощью переменной &lt;code&gt;HISTFILE&lt;/code&gt; psql или переменной среды &lt;code&gt;PSQL_HISTORY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9e8edabe8e574f621a1a9a4ab6a0372f27514c2" translate="yes" xml:space="preserve">
          <source>The lock mode specifies which locks this lock conflicts with. Lock modes are described in &lt;a href=&quot;explicit-locking&quot;&gt;Section 13.3&lt;/a&gt;.</source>
          <target state="translated">Режим блокировки указывает, с какими блокировками конфликтует эта блокировка. Режимы блокировки описаны в &lt;a href=&quot;explicit-locking&quot;&gt;Разделе 13.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11e9f2a01b63d9d65afbfe49635022cefcf4e76a" translate="yes" xml:space="preserve">
          <source>The locking clause has the general form</source>
          <target state="translated">Положение о блокировке имеет общую форму</target>
        </trans-unit>
        <trans-unit id="91a41283b7fcf940c9ed38d5616364c7bd0504f5" translate="yes" xml:space="preserve">
          <source>The locking clauses cannot be used in contexts where returned rows cannot be clearly identified with individual table rows; for example they cannot be used with aggregation.</source>
          <target state="translated">Оговорки о блокировке не могут использоваться в контекстах,где возвращаемые строки не могут быть четко идентифицированы с отдельными строками таблицы;например,они не могут использоваться с агрегированием.</target>
        </trans-unit>
        <trans-unit id="5be2e9c7a10ee3339b74248910b8189ec3602ecb" translate="yes" xml:space="preserve">
          <source>The logging collector is designed to never lose messages. This means that in case of extremely high load, server processes could be blocked while trying to send additional log messages when the collector has fallen behind. In contrast, syslog prefers to drop messages if it cannot write them, which means it may fail to log some messages in such cases but it will not block the rest of the system.</source>
          <target state="translated">Коллектор протоколирования предназначен для того,чтобы никогда не терять сообщения.Это означает,что в случае чрезвычайно высокой нагрузки,серверные процессы могут быть заблокированы при попытке отправить дополнительные сообщения журнала,когда коллектор отстает.Напротив,syslog предпочитает отбрасывать сообщения,если не может их написать,что означает,что в таких случаях он может не записать в журнал некоторые сообщения,но не заблокировать остальную часть системы.</target>
        </trans-unit>
        <trans-unit id="e54879093a2f0566d1aa83e68c13d2dd946cc6fd" translate="yes" xml:space="preserve">
          <source>The logical replication apply process currently only fires row triggers, not statement triggers. The initial table synchronization, however, is implemented like a &lt;code&gt;COPY&lt;/code&gt; command and thus fires both row and statement triggers for &lt;code&gt;INSERT&lt;/code&gt;.</source>
          <target state="translated">В настоящее время процесс применения логической репликации запускает только триггеры строк, а не триггеры операторов. Однако начальная синхронизация таблицы реализована как команда &lt;code&gt;COPY&lt;/code&gt; и, таким образом, запускает триггеры строк и операторов для &lt;code&gt;INSERT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="497c1b112de3cb7224f97eec3f477dda0c464f33" translate="yes" xml:space="preserve">
          <source>The lower bound of a range can be omitted, meaning that all points less than the upper bound are included in the range. Likewise, if the upper bound of the range is omitted, then all points greater than the lower bound are included in the range. If both lower and upper bounds are omitted, all values of the element type are considered to be in the range.</source>
          <target state="translated">Нижняя граница диапазона может быть опущена,что означает,что в диапазон включены все точки,находящиеся ниже верхней границы.Аналогично,если опустить верхнюю границу диапазона,то в диапазон попадают все точки,которые больше нижней границы.Если опускаются и нижняя,и верхняя границы,то в диапазоне считаются все значения типа элемента.</target>
        </trans-unit>
        <trans-unit id="57c98e1829ac48ed92032df563adc8eac7513b47" translate="yes" xml:space="preserve">
          <source>The lower bound of a range can be omitted, meaning that all values less than the upper bound are included in the range, e.g., &lt;code&gt;(,3]&lt;/code&gt;. Likewise, if the upper bound of the range is omitted, then all values greater than the lower bound are included in the range. If both lower and upper bounds are omitted, all values of the element type are considered to be in the range. Specifying a missing bound as inclusive is automatically converted to exclusive, e.g., &lt;code&gt;[,]&lt;/code&gt; is converted to &lt;code&gt;(,)&lt;/code&gt;. You can think of these missing values as +/-infinity, but they are special range type values and are considered to be beyond any range element type's +/-infinity values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bb8fcfd48d2a42926444acc296752b10019e69" translate="yes" xml:space="preserve">
          <source>The machine used is an Intel Mobile Core i3.</source>
          <target state="translated">В качестве машины используется Intel Mobile Core i3.</target>
        </trans-unit>
        <trans-unit id="a9f59ce368a2e8f66b6b7f102badc5b6a6bb9471" translate="yes" xml:space="preserve">
          <source>The magic that makes the two loosely coupled servers work together is simply a &lt;code&gt;restore_command&lt;/code&gt; used on the standby that, when asked for the next WAL file, waits for it to become available from the primary. Normal recovery processing would request a file from the WAL archive, reporting failure if the file was unavailable. For standby processing it is normal for the next WAL file to be unavailable, so the standby must wait for it to appear. For files ending in &lt;code&gt;.history&lt;/code&gt; there is no need to wait, and a non-zero return code must be returned. A waiting &lt;code&gt;restore_command&lt;/code&gt; can be written as a custom script that loops after polling for the existence of the next WAL file. There must also be some way to trigger failover, which should interrupt the &lt;code&gt;restore_command&lt;/code&gt;, break the loop and return a file-not-found error to the standby server. This ends recovery and the standby will then come up as a normal server.</source>
          <target state="translated">Магия, которая заставляет два слабо связанных сервера работать вместе, - это просто &lt;code&gt;restore_command&lt;/code&gt; используемая на резервном сервере, которая при запросе следующего файла WAL ждет, пока он станет доступным с основного. Обычная обработка восстановления запросит файл из архива WAL, сообщая об ошибке, если файл был недоступен. Для обработки в режиме ожидания это нормально, когда следующий файл WAL недоступен, поэтому резервный файл должен дождаться его появления. Для файлов, заканчивающихся на &lt;code&gt;.history&lt;/code&gt; , ждать не нужно, и должен быть возвращен ненулевой код возврата. Ожидающее &lt;code&gt;restore_command&lt;/code&gt; можно записать в виде пользовательского сценария , который петли после опроса существования следующего файла WAL. Также должен быть способ запустить аварийное переключение, которое должно прервать &lt;code&gt;restore_command&lt;/code&gt; , разорвать цикл и вернуть на резервный сервер сообщение об ошибке &amp;laquo;файл не найден&amp;raquo;. На этом восстановление завершится, и резервный сервер будет работать как обычный сервер.</target>
        </trans-unit>
        <trans-unit id="ce18091b48e231b7d70d5b7f47f40d4962ad395e" translate="yes" xml:space="preserve">
          <source>The main advantage of using the MVCC model of concurrency control rather than locking is that in MVCC locks acquired for querying (reading) data do not conflict with locks acquired for writing data, and so reading never blocks writing and writing never blocks reading. PostgreSQL maintains this guarantee even when providing the strictest level of transaction isolation through the use of an innovative &lt;em&gt;Serializable Snapshot Isolation&lt;/em&gt; (SSI) level.</source>
          <target state="translated">Основное преимущество использования модели управления параллелизмом MVCC вместо блокировки состоит в том, что в MVCC блокировки, полученные для запроса (чтения) данных, не конфликтуют с блокировками, полученными для записи данных, и поэтому чтение никогда не блокирует запись, а запись никогда не блокирует чтение. PostgreSQL сохраняет эту гарантию даже при обеспечении строжайшего уровня изоляции транзакций за счет использования инновационного уровня &lt;em&gt;Serializable Snapshot Isolation&lt;/em&gt; (SSI).</target>
        </trans-unit>
        <trans-unit id="44c8536b44aa283079c384b9a03db01c74d90dd9" translate="yes" xml:space="preserve">
          <source>The main disadvantage of this approach is that searches must scan the list of pending entries in addition to searching the regular index, and so a large list of pending entries will slow searches significantly. Another disadvantage is that, while most updates are fast, an update that causes the pending list to become &amp;ldquo;too large&amp;rdquo; will incur an immediate cleanup cycle and thus be much slower than other updates. Proper use of autovacuum can minimize both of these problems.</source>
          <target state="translated">Основным недостатком этого подхода является то, что поиск должен сканировать список ожидающих записей в дополнение к поиску по обычному индексу, и поэтому большой список ожидающих записей значительно замедлит поиск. Другой недостаток заключается в том, что, хотя большинство обновлений выполняются быстро, обновление, которое приводит к тому, что ожидающий список становится &amp;laquo;слишком большим&amp;raquo;, повлечет за собой немедленный цикл очистки и, следовательно, будет намного медленнее, чем другие обновления. Правильное использование автовакуума может свести к минимуму обе эти проблемы.</target>
        </trans-unit>
        <trans-unit id="4ddd5b9589c157b509c992d47b1a2271d0f14677" translate="yes" xml:space="preserve">
          <source>The main limitation of the single-parameter form of &lt;code&gt;crosstab&lt;/code&gt; is that it treats all values in a group alike, inserting each value into the first available column. If you want the value columns to correspond to specific categories of data, and some groups might not have data for some of the categories, that doesn't work well. The two-parameter form of &lt;code&gt;crosstab&lt;/code&gt; handles this case by providing an explicit list of the categories corresponding to the output columns.</source>
          <target state="translated">Основное ограничение однопараметрической формы &lt;code&gt;crosstab&lt;/code&gt; заключается в том, что она обрабатывает все значения в группе одинаково, вставляя каждое значение в первый доступный столбец. Если вы хотите, чтобы столбцы значений соответствовали определенным категориям данных, а некоторые группы могут не иметь данных для некоторых категорий, это не сработает. &lt;code&gt;crosstab&lt;/code&gt; форма кросс-таблицы обрабатывает этот случай, предоставляя явный список категорий, соответствующих выходным столбцам.</target>
        </trans-unit>
        <trans-unit id="c0c0e4e09c0e4b312acc4efbfbf35b08e17ec465" translate="yes" xml:space="preserve">
          <source>The main purpose of this option is to allow taking a base backup when the server has no free replication slots. Using a replication slot is almost always preferred, because it prevents needed WAL from being removed by the server during the backup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778d9031e427ea1e84edd5ec78787ba6c076cbf5" translate="yes" xml:space="preserve">
          <source>The main purpose of this option is to allow taking a base backup when the server is out of free replication slots. Using replication slots is almost always preferred, because it prevents needed WAL from being removed by the server during the backup.</source>
          <target state="translated">Основная цель этой опции-позволить брать базовую резервную копию,когда на сервере нет свободных слотов репликации.Использование слотов репликации почти всегда является предпочтительным,так как оно предотвращает удаление необходимой WAL сервером во время резервного копирования.</target>
        </trans-unit>
        <trans-unit id="29caa328c42873be4b6687bd164a1f6cd134599f" translate="yes" xml:space="preserve">
          <source>The main reason for providing the option to specify multiple changes in a single &lt;code&gt;ALTER TABLE&lt;/code&gt; is that multiple table scans or rewrites can thereby be combined into a single pass over the table.</source>
          <target state="translated">Основная причина предоставления возможности указать несколько изменений в одном &lt;code&gt;ALTER TABLE&lt;/code&gt; заключается в том, что несколько просмотров или перезаписей таблицы могут быть объединены в один проход по таблице.</target>
        </trans-unit>
        <trans-unit id="cb4b3004c02ae1c44498a4d45ad098f017583f6e" translate="yes" xml:space="preserve">
          <source>The main reason not to use &lt;code&gt;FOR UPDATE&lt;/code&gt; with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; is if you need the cursor to be scrollable, or to be insensitive to the subsequent updates (that is, continue to show the old data). If this is a requirement, pay close heed to the caveats shown above.</source>
          <target state="translated">Основная причина не использовать &lt;code&gt;FOR UPDATE&lt;/code&gt; с &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; заключается в том, что вам нужно, чтобы курсор был прокручиваемым или был нечувствительным к последующим обновлениям (то есть продолжал показывать старые данные). Если это необходимо, обратите внимание на указанные выше предостережения.</target>
        </trans-unit>
        <trans-unit id="4a8b7d5e4956ce1f0f4b5a2c51be8faff6d42ee8" translate="yes" xml:space="preserve">
          <source>The majority of the information defining an operator family is not in its &lt;code&gt;pg_opfamily&lt;/code&gt; row, but in the associated rows in &lt;a href=&quot;catalog-pg-amop&quot;&gt;&lt;code&gt;pg_amop&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;catalog-pg-amproc&quot;&gt;&lt;code&gt;pg_amproc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Большая часть информации, определяющей семейство операторов, содержится не в строке &lt;code&gt;pg_opfamily&lt;/code&gt; , а в связанных строках в &lt;a href=&quot;catalog-pg-amop&quot;&gt; &lt;code&gt;pg_amop&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;catalog-pg-amproc&quot;&gt; &lt;code&gt;pg_amproc&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;catalog-pg-opclass&quot;&gt; &lt;code&gt;pg_opclass&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84e832e692fdd3f5ebc26e5d5addbf853c3e6115" translate="yes" xml:space="preserve">
          <source>The mandatory &lt;code&gt;COLUMNS&lt;/code&gt; clause specifies the list of columns in the output table. Each entry describes a single column. See the syntax summary above for the format. The column name and type are required; the path, default and nullability clauses are optional.</source>
          <target state="translated">Обязательное предложение &lt;code&gt;COLUMNS&lt;/code&gt; определяет список столбцов в выходной таблице. Каждая запись описывает один столбец. См. Описание формата в приведенном выше обзоре синтаксиса. Требуются имя и тип столбца; предложения path, default и nullability необязательны.</target>
        </trans-unit>
        <trans-unit id="1ed034d07246f2d9a932c645c69a5fd7f25b6f13" translate="yes" xml:space="preserve">
          <source>The map is conservative in the sense that we make sure that whenever a bit is set, we know the condition is true, but if a bit is not set, it might or might not be true. Visibility map bits are only set by vacuum, but are cleared by any data-modifying operations on a page.</source>
          <target state="translated">Карта консервативна в том смысле,что мы гарантируем,что всякий раз,когда бит установлен,мы знаем,что условие истинно,но если бит не установлен,он может быть или не быть истинным.Биты карты видимости устанавливаются только в вакууме,но очищаются любыми операциями по изменению данных на странице.</target>
        </trans-unit>
        <trans-unit id="08696b64b531889519840be43314b0f033492f9a" translate="yes" xml:space="preserve">
          <source>The match distance in a &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; (FOLLOWED BY) &lt;code&gt;tsquery&lt;/code&gt; operator cannot be more than 16,384</source>
          <target state="translated">Расстояние &lt;code&gt;tsquery&lt;/code&gt; операторе tsquery &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; ( FOLLOWED BY) не может быть больше 16 384</target>
        </trans-unit>
        <trans-unit id="0adc4fae7a170393939bebd8f752ad648c1e97c9" translate="yes" xml:space="preserve">
          <source>The matching code in the C module could then follow this skeleton:</source>
          <target state="translated">Соответствующий код в модуле C может затем следовать этому скелету:</target>
        </trans-unit>
        <trans-unit id="628cd5529e4eb158401ec35941dd337c440c275a" translate="yes" xml:space="preserve">
          <source>The maximum allowed precision when explicitly specified in the type declaration is 1000; &lt;code&gt;NUMERIC&lt;/code&gt; without a specified precision is subject to the limits described in &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;Table 8.2&lt;/a&gt;.</source>
          <target state="translated">Максимально допустимая точность, если она явно указана в объявлении типа, равна 1000; &lt;code&gt;NUMERIC&lt;/code&gt; без указанной точности подчиняется ограничениям, описанным в &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;таблице 8.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f276734cd29218873896bf82d393e1b3527b68e3" translate="yes" xml:space="preserve">
          <source>The maximum number of buffers that can be registered for a generic WAL record is &lt;code&gt;MAX_GENERIC_XLOG_PAGES&lt;/code&gt;. An error will be thrown if this limit is exceeded.</source>
          <target state="translated">Максимальное количество буферов, которое может быть зарегистрировано для общей записи WAL, составляет &lt;code&gt;MAX_GENERIC_XLOG_PAGES&lt;/code&gt; . Если это ограничение будет превышено, будет выдана ошибка.</target>
        </trans-unit>
        <trans-unit id="62795c0abeb86c3cb2f44c4d31a9efa4ab1b021c" translate="yes" xml:space="preserve">
          <source>The maximum number of columns for a table is further reduced as the tuple being stored must fit in a single 8192-byte heap page. For example, excluding the tuple header, a tuple made up of 1600 &lt;code&gt;int&lt;/code&gt; columns would consume 6400 bytes and could be stored in a heap page, but a tuple of 1600 &lt;code&gt;bigint&lt;/code&gt; columns would consume 12800 bytes and would therefore not fit inside a heap page. Variable-length fields of types such as &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt; can have their values stored out of line in the table's TOAST table when the values are large enough to require it. Only an 18-byte pointer must remain inside the tuple in the table's heap. For shorter length variable-length fields, either a 4-byte or 1-byte field header is used and the value is stored inside the heap tuple.</source>
          <target state="translated">Максимальное количество столбцов для таблицы дополнительно сокращается, поскольку сохраняемый кортеж должен умещаться на одной 8192-байтовой странице кучи. Например, за исключением заголовка кортежа, кортеж, состоящий из 1600 столбцов &lt;code&gt;int&lt;/code&gt; , будет занимать 6400 байт и может храниться на странице кучи, но кортеж из 1600 столбцов &lt;code&gt;bigint&lt;/code&gt; будет занимать 12800 байт и, следовательно, не поместится внутри страницы кучи. Поля переменной длины таких типов, как &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;varchar&lt;/code&gt; и &lt;code&gt;char&lt;/code&gt; могут хранить свои значения вне очереди в таблице TOAST, когда значения достаточно велики, чтобы это требовалось. Внутри кортежа в куче таблицы должен оставаться только 18-байтовый указатель. Для более коротких полей переменной длины используется 4-байтовый или 1-байтовый заголовок поля, а значение сохраняется внутри кортежа кучи.</target>
        </trans-unit>
        <trans-unit id="5febb5cd9beb7e14dc02349a0fabc85e580c54fa" translate="yes" xml:space="preserve">
          <source>The maximum number of commands to store in the command history (default 500). If set to a negative value, no limit is applied.</source>
          <target state="translated">Максимальное количество команд для хранения в истории команд (по умолчанию 500).Если установлено отрицательное значение,то ограничение не применяется.</target>
        </trans-unit>
        <trans-unit id="db38918ed0ba22959c7e085e2da67d6ae9e85522" translate="yes" xml:space="preserve">
          <source>The maximum number of entries in the array fields can be controlled on a column-by-column basis using the &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; command, or globally by setting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; run-time parameter.</source>
          <target state="translated">Максимальным количеством записей в полях массива можно управлять для каждого столбца с помощью команды &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; или глобально, задав параметр времени выполнения &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3e538107920d935aeb7ce10873e4d969580a999" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to return. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">Максимальное количество возвращаемых строк. Подробнее см. &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;Пункт &lt;/a&gt; &lt;code&gt;LIMIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="758de2e2b468c97aa92a9251f6473d290c2c8830" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to return. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196f6ebe76be64ba3b271dddfbd4d6c8ae41617e" translate="yes" xml:space="preserve">
          <source>The maximum number of seconds to wait when attempting connection before returning that the server is not responding. Setting to 0 disables. The default is 3 seconds.</source>
          <target state="translated">Максимальное количество секунд для ожидания при попытке подключения,прежде чем возвращать,что сервер не отвечает.Установка в 0 отключается.По умолчанию 3 секунды.</target>
        </trans-unit>
        <trans-unit id="3aa8188a6b3b3fb92b1108055edfe63bc9db8999" translate="yes" xml:space="preserve">
          <source>The maximum time that a table can go unvacuumed is two billion transactions minus the &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; value at the time of the last aggressive vacuum. If it were to go unvacuumed for longer than that, data loss could result. To ensure that this does not happen, autovacuum is invoked on any table that might contain unfrozen rows with XIDs older than the age specified by the configuration parameter &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt;. (This will happen even if autovacuum is disabled.)</source>
          <target state="translated">Максимальное время, в течение которого таблица может быть не вакуумирована, составляет два миллиарда транзакций минус значение &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; на момент последней агрессивной очистки . Если он будет оставаться без вакуумирования дольше указанного срока, это может привести к потере данных. Чтобы этого не происходило, автоочистка вызывается для любой таблицы, которая может содержать незамороженные строки с XID старше возраста, указанного параметром конфигурации &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; . (Это произойдет, даже если автоочистка отключена.)</target>
        </trans-unit>
        <trans-unit id="a2f6e9f6c92be1d6e4dbdfb81636d51c2482b4e7" translate="yes" xml:space="preserve">
          <source>The maximum transfer rate of data transferred from the server. Values are in kilobytes per second. Use a suffix of &lt;code&gt;M&lt;/code&gt; to indicate megabytes per second. A suffix of &lt;code&gt;k&lt;/code&gt; is also accepted, and has no effect. Valid values are between 32 kilobytes per second and 1024 megabytes per second.</source>
          <target state="translated">Максимальная скорость передачи данных, передаваемых с сервера. Значения указаны в килобайтах в секунду. Используйте суффикс &lt;code&gt;M&lt;/code&gt; для обозначения мегабайт в секунду. Допускается также суффикс &lt;code&gt;k&lt;/code&gt; , который не действует. Допустимые значения: от 32 килобайт в секунду до 1024 мегабайт в секунду.</target>
        </trans-unit>
        <trans-unit id="aad15d96db29ca223b68ad77ebaeeab386249ae0" translate="yes" xml:space="preserve">
          <source>The meaning of the fields is as follows:</source>
          <target state="translated">Значение полей следующее:</target>
        </trans-unit>
        <trans-unit id="cd3a4582b6d44983f8eaba4187d7e09c6429edc7" translate="yes" xml:space="preserve">
          <source>The meaning of this parameter, and its default value, changed in PostgreSQL 12; see &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;Section 8.1.3&lt;/a&gt; for further discussion.</source>
          <target state="translated">Значение этого параметра и его значение по умолчанию изменились в PostgreSQL 12; см. &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;раздел 8.1.3&lt;/a&gt; для дальнейшего обсуждения.</target>
        </trans-unit>
        <trans-unit id="c7b63395362512b01d4281cff1f264dd9fa16bd8" translate="yes" xml:space="preserve">
          <source>The meanings of &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;, and &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; are the same as in &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;. An aggregate will not be considered for parallelization if it is marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (which is the default!) or &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;. Note that the parallel-safety markings of the aggregate's support functions are not consulted by the planner, only the marking of the aggregate itself.</source>
          <target state="translated">Значения &lt;code&gt;PARALLEL SAFE&lt;/code&gt; , &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; и &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; такие же, как в &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; . Агрегат не будет рассматриваться для распараллеливания, если он помечен как &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (по умолчанию!) Или &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; . Обратите внимание, что маркировка параллельной безопасности вспомогательных функций агрегата не учитывается планировщиком, а только маркировкой самого агрегата.</target>
        </trans-unit>
        <trans-unit id="d9104f9afa808fa94ea8a0bf0c8363adf4ab748e" translate="yes" xml:space="preserve">
          <source>The mechanism that converts &lt;code&gt;(+-)&lt;/code&gt; to regular ranges isn't completely accurate in determining the number of significant digits for the boundaries. For example, it adds an extra digit to the lower boundary if the resulting interval includes a power of ten:</source>
          <target state="translated">Механизм, который преобразует &lt;code&gt;(+-)&lt;/code&gt; в обычные диапазоны, не совсем точен при определении количества значащих цифр для границ. Например, он добавляет дополнительную цифру к нижней границе, если полученный интервал включает степень десяти:</target>
        </trans-unit>
        <trans-unit id="221c60f17786086e4d1d8637638f0c8d9f6223fa" translate="yes" xml:space="preserve">
          <source>The members of a group role can use the privileges of the role in two ways. First, every member of a group can explicitly do &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; to temporarily &amp;ldquo;become&amp;rdquo; the group role. In this state, the database session has access to the privileges of the group role rather than the original login role, and any database objects created are considered owned by the group role not the login role. Second, member roles that have the &lt;code&gt;INHERIT&lt;/code&gt; attribute automatically have use of the privileges of roles of which they are members, including any privileges inherited by those roles. As an example, suppose we have done:</source>
          <target state="translated">Члены групповой роли могут использовать привилегии роли двумя способами. Во-первых, каждый член группы может явно выполнить &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE,&lt;/a&gt; чтобы временно &amp;laquo;стать&amp;raquo; групповой ролью. В этом состоянии сеанс базы данных имеет доступ к привилегиям роли группы, а не к исходной роли входа в систему, и любые созданные объекты базы данных считаются принадлежащими роли группы, а не роли входа. Во-вторых, роли-участники, имеющие атрибут &lt;code&gt;INHERIT&lt;/code&gt; , автоматически используют привилегии ролей, членами которых они являются, включая любые привилегии, унаследованные этими ролями. В качестве примера предположим, что мы сделали:</target>
        </trans-unit>
        <trans-unit id="c531d86ffa3bb917e6ad2f8783d407b8d81b1be4" translate="yes" xml:space="preserve">
          <source>The mentioned transformations and compilations are normally done automatically using the &lt;em&gt;makefiles&lt;/em&gt; shipped with the PostgreSQL source distribution.</source>
          <target state="translated">Упомянутые преобразования и компиляции обычно выполняются автоматически с использованием &lt;em&gt;make-файлов,&lt;/em&gt; поставляемых с исходным кодом PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="8cd29d65e9431541c4a7e3d8e7bf9c8ca5af8963" translate="yes" xml:space="preserve">
          <source>The message is encrypted with a symmetric key.</source>
          <target state="translated">Сообщение зашифровано симметричным ключом.</target>
        </trans-unit>
        <trans-unit id="bb36ba49fd3ad58b447d4a645799893632a3669c" translate="yes" xml:space="preserve">
          <source>The message is public-key encrypted, but the key ID has been removed. That means you will need to try all your secret keys on it to see which one decrypts it. &lt;code&gt;pgcrypto&lt;/code&gt; itself does not produce such messages.</source>
          <target state="translated">Сообщение зашифровано с открытым ключом, но идентификатор ключа был удален. Это означает, что вам нужно будет перепробовать на нем все свои секретные ключи, чтобы увидеть, какой из них его расшифровывает. Сам &lt;code&gt;pgcrypto&lt;/code&gt; не создает таких сообщений.</target>
        </trans-unit>
        <trans-unit id="80b9ed75dbe3c0d3f0a0153cbc3b5f5a6c2e4216" translate="yes" xml:space="preserve">
          <source>The metasyntax forms described in &lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;Section 9.7.3.4&lt;/a&gt; do not exist in XQuery.</source>
          <target state="translated">Формы метасинтаксиса, описанные в &lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;Разделе 9.7.3.4&lt;/a&gt; , не существуют в XQuery.</target>
        </trans-unit>
        <trans-unit id="5167d97b5af2d410349f4f14e2833acb2e09f087" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;ANY&lt;/code&gt; specifies a quorum-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;em&gt;at least&lt;/em&gt; the requested number of synchronous standbys in the list.</source>
          <target state="translated">Метод &lt;code&gt;ANY&lt;/code&gt; задает синхронную репликацию на основе кворума и заставляет фиксации транзакций ждать, пока их записи WAL не будут реплицированы по &lt;em&gt;крайней мере&lt;/em&gt; на запрошенное количество синхронных резервных серверов в списке.</target>
        </trans-unit>
        <trans-unit id="f49f419e2b9a22a4fc79b879fb7d7ed163340aa2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;FIRST&lt;/code&gt; specifies a priority-based synchronous replication and makes transaction commits wait until their WAL records are replicated to the requested number of synchronous standbys chosen based on their priorities. The standbys whose names appear earlier in the list are given higher priority and will be considered as synchronous. Other standby servers appearing later in this list represent potential synchronous standbys. If any of the current synchronous standbys disconnects for whatever reason, it will be replaced immediately with the next-highest-priority standby.</source>
          <target state="translated">Метод &lt;code&gt;FIRST&lt;/code&gt; определяет синхронную репликацию на основе приоритетов и заставляет транзакции ждать, пока их записи WAL не будут реплицированы на запрошенное количество синхронных резервных серверов, выбранных на основе их приоритетов. Резервным серверам, имена которых указаны раньше в списке, предоставляется более высокий приоритет, и они будут считаться синхронными. Другие резервные серверы, указанные ниже в этом списке, представляют собой потенциальные синхронные резервные серверы. Если какой-либо из текущих синхронных резервных серверов отключается по какой-либо причине, он будет немедленно заменен на следующий с наивысшим приоритетом резервный.</target>
        </trans-unit>
        <trans-unit id="3b4f76e9dc87199736499aa89b071e2462e85235" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;md5&lt;/code&gt; uses a custom less secure challenge-response mechanism. It prevents password sniffing and avoids storing passwords on the server in plain text but provides no protection if an attacker manages to steal the password hash from the server. Also, the MD5 hash algorithm is nowadays no longer considered secure against determined attacks.</source>
          <target state="translated">Метод &lt;code&gt;md5&lt;/code&gt; использует настраиваемый менее безопасный механизм запрос-ответ. Он предотвращает перехват паролей и позволяет избежать хранения паролей на сервере в виде обычного текста, но не обеспечивает защиты, если злоумышленнику удается украсть хэш пароля с сервера. Кроме того, алгоритм хеширования MD5 в настоящее время больше не считается защищенным от определенных атак.</target>
        </trans-unit>
        <trans-unit id="bbe98735c0b460f287d0e1fc8bbe8558da46b394" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;password&lt;/code&gt; sends the password in clear-text and is therefore vulnerable to password &amp;ldquo;sniffing&amp;rdquo; attacks. It should always be avoided if possible. If the connection is protected by SSL encryption then &lt;code&gt;password&lt;/code&gt; can be used safely, though. (Though SSL certificate authentication might be a better choice if one is depending on using SSL).</source>
          <target state="translated">&lt;code&gt;password&lt;/code&gt; метода отправляет пароль в виде открытого текста и поэтому уязвим для атак &quot;сниффинга&quot; пароля. По возможности всегда следует избегать этого. Однако, если соединение защищено шифрованием SSL, можно безопасно использовать &lt;code&gt;password&lt;/code&gt; . (Хотя проверка подлинности сертификата SSL может быть лучшим выбором, если он зависит от использования SSL).</target>
        </trans-unit>
        <trans-unit id="c4e1d81897ac3ef5344a09ff3085827106ec9fad" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;scram-sha-256&lt;/code&gt; performs SCRAM-SHA-256 authentication, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7677&quot;&gt;RFC 7677&lt;/a&gt;. It is a challenge-response scheme that prevents password sniffing on untrusted connections and supports storing passwords on the server in a cryptographically hashed form that is thought to be secure.</source>
          <target state="translated">Метод &lt;code&gt;scram-sha-256&lt;/code&gt; выполняет аутентификацию SCRAM-SHA-256, как описано в &lt;a href=&quot;https://tools.ietf.org/html/rfc7677&quot;&gt;RFC 7677&lt;/a&gt; . Это схема &quot;запрос-ответ&quot;, которая предотвращает перехват паролей в ненадежных соединениях и поддерживает хранение паролей на сервере в криптографически хешированной форме, которая считается безопасной.</target>
        </trans-unit>
        <trans-unit id="4d38dbf255ad283e492b192c046e51eef7da09c0" translate="yes" xml:space="preserve">
          <source>The method a client application must use to detect notification events depends on which PostgreSQL application programming interface it uses. With the libpq library, the application issues &lt;code&gt;LISTEN&lt;/code&gt; as an ordinary SQL command, and then must periodically call the function &lt;code&gt;PQnotifies&lt;/code&gt; to find out whether any notification events have been received. Other interfaces such as libpgtcl provide higher-level methods for handling notify events; indeed, with libpgtcl the application programmer should not even issue &lt;code&gt;LISTEN&lt;/code&gt; or &lt;code&gt;UNLISTEN&lt;/code&gt; directly. See the documentation for the interface you are using for more details.</source>
          <target state="translated">Метод, который клиентское приложение должно использовать для обнаружения событий уведомления, зависит от того, какой интерфейс прикладного программирования PostgreSQL оно использует. С библиотекой libpq приложение выдает &lt;code&gt;LISTEN&lt;/code&gt; как обычную команду SQL, а затем должно периодически вызывать функцию &lt;code&gt;PQnotifies&lt;/code&gt; , чтобы узнать, были ли получены какие-либо события уведомления. Другие интерфейсы, такие как libpgtcl, предоставляют методы более высокого уровня для обработки событий уведомления; действительно, с libpgtcl прикладной программист не должен даже напрямую &lt;code&gt;UNLISTEN&lt;/code&gt; &lt;code&gt;LISTEN&lt;/code&gt; или UNLISTEN . Дополнительную информацию см. В документации по используемому интерфейсу.</target>
        </trans-unit>
        <trans-unit id="820cf6d702543aba9dfe85b2f79f3d6774753e9a" translate="yes" xml:space="preserve">
          <source>The method described in this section has been obsoleted by the use of stored generated columns, as described in &lt;a href=&quot;textsearch-tables#TEXTSEARCH-TABLES-INDEX&quot;&gt;Section 12.2.2&lt;/a&gt;.</source>
          <target state="translated">Метод, описанный в этом разделе, устарел за счет использования сохраненных сгенерированных столбцов, как описано в &lt;a href=&quot;textsearch-tables#TEXTSEARCH-TABLES-INDEX&quot;&gt;Разделе 12.2.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="318a555813c808d85dcecb5209b3a3a236dc9ab5" translate="yes" xml:space="preserve">
          <source>The method for triggering failover is an important part of planning and design. One potential option is the &lt;code&gt;restore_command&lt;/code&gt; command. It is executed once for each WAL file, but the process running the &lt;code&gt;restore_command&lt;/code&gt; is created and dies for each file, so there is no daemon or server process, and signals or a signal handler cannot be used. Therefore, the &lt;code&gt;restore_command&lt;/code&gt; is not suitable to trigger failover. It is possible to use a simple timeout facility, especially if used in conjunction with a known &lt;code&gt;archive_timeout&lt;/code&gt; setting on the primary. However, this is somewhat error prone since a network problem or busy primary server might be sufficient to initiate failover. A notification mechanism such as the explicit creation of a trigger file is ideal, if this can be arranged.</source>
          <target state="translated">Метод переключения при отказе - важная часть планирования и проектирования. Один из возможных вариантов - это команда &lt;code&gt;restore_command&lt;/code&gt; . Он выполняется один раз для каждого файла WAL, но процесс, выполняющий команду &lt;code&gt;restore_command&lt;/code&gt; , создается и умирает для каждого файла, поэтому нет никакого демона или серверного процесса, а сигналы или обработчик сигналов не могут использоваться. Следовательно, команда &lt;code&gt;restore_command&lt;/code&gt; не подходит для переключения при отказе. Можно использовать простое средство тайм-аута, особенно если оно используется вместе с известным &lt;code&gt;archive_timeout&lt;/code&gt; .настройка на первичном. Однако это в некоторой степени подвержено ошибкам, поскольку проблемы с сетью или занятости основного сервера может быть достаточно для инициирования переключения при отказе. Механизм уведомления, такой как явное создание файла триггера, является идеальным, если это можно организовать.</target>
        </trans-unit>
        <trans-unit id="9ecf9a698c1e522b9c1de1bf5af789211b8be7ed" translate="yes" xml:space="preserve">
          <source>The millennium</source>
          <target state="translated">Тысячелетие</target>
        </trans-unit>
        <trans-unit id="d49286ea0d415b0aad37189b731269fb41a33f65" translate="yes" xml:space="preserve">
          <source>The minute component of the time zone offset</source>
          <target state="translated">Минутная составляющая смещения часового пояса</target>
        </trans-unit>
        <trans-unit id="70c1dd6d1f4cd9d65c5ea9908ee66b76d8b0f4e4" translate="yes" xml:space="preserve">
          <source>The minutes field (0 - 59)</source>
          <target state="translated">Поле минут (0-59)</target>
        </trans-unit>
        <trans-unit id="8e27da07ae7efc7685d90ec013484c3ec2a72626" translate="yes" xml:space="preserve">
          <source>The minutes field (0&amp;ndash;59)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58bb99f67c9dd4fa543f324ba0a954d9aeea2c7" translate="yes" xml:space="preserve">
          <source>The missing positions 1,2,4 are because of stop words. Ranks calculated for documents with and without stop words are quite different:</source>
          <target state="translated">Пропущенные позиции 1,2,4 вызваны стоп-словами.Рейтинги,рассчитанные для документов со стоп-словами и без них,совершенно разные:</target>
        </trans-unit>
        <trans-unit id="7efece902ce6baec1dac421e4950dc636bcb9bc8" translate="yes" xml:space="preserve">
          <source>The mixed notation combines positional and named notation. However, as already mentioned, named arguments cannot precede positional arguments. For example:</source>
          <target state="translated">Смешанная нотация сочетает в себе позиционную и именную нотации.Однако,как уже упоминалось,именованные аргументы не могут предшествовать позиционным аргументам.Например:</target>
        </trans-unit>
        <trans-unit id="dfdfde6fd27332a6600ccf2d0ac2ce0c45f7420f" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;ALTER EXTENSION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">Режим функции, процедуры или агрегированного аргумента: &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; или &lt;code&gt;VARIADIC&lt;/code&gt; . Если не указано, по умолчанию используется &lt;code&gt;IN&lt;/code&gt; . Обратите внимание, что &lt;code&gt;ALTER EXTENSION&lt;/code&gt; на самом деле не обращает внимания на аргументы &lt;code&gt;OUT&lt;/code&gt; , поскольку для определения идентичности функции необходимы только входные аргументы. Поэтому достаточно перечислить аргументы &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; и &lt;code&gt;VARIADIC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68b58e6626dcfa87dd99931a1610596ebfd41322" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;COMMENT&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">Режим функции, процедуры или агрегированного аргумента: &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; или &lt;code&gt;VARIADIC&lt;/code&gt; . Если не указано, по умолчанию используется &lt;code&gt;IN&lt;/code&gt; . Обратите внимание, что &lt;code&gt;COMMENT&lt;/code&gt; на самом деле не обращает внимания на аргументы &lt;code&gt;OUT&lt;/code&gt; , поскольку для определения идентичности функции необходимы только входные аргументы. Поэтому достаточно перечислить аргументы &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; и &lt;code&gt;VARIADIC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d48b93746498257a59bb7fe4e61442dbe73691fd" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;SECURITY LABEL&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">Режим функции, процедуры или агрегированного аргумента: &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; или &lt;code&gt;VARIADIC&lt;/code&gt; . Если не указано, по умолчанию используется &lt;code&gt;IN&lt;/code&gt; . Обратите внимание, что &lt;code&gt;SECURITY LABEL&lt;/code&gt; на самом деле не обращает внимания на аргументы &lt;code&gt;OUT&lt;/code&gt; , поскольку для определения идентичности функции необходимы только входные аргументы. Поэтому достаточно перечислить аргументы &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; и &lt;code&gt;VARIADIC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45f33dca690dafc673c0eaa64fba7b4d58d74383" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt; or &lt;code&gt;VARIADIC&lt;/code&gt;. (Aggregate functions do not support &lt;code&gt;OUT&lt;/code&gt; arguments.) If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Only the last argument can be marked &lt;code&gt;VARIADIC&lt;/code&gt;.</source>
          <target state="translated">Режим аргумента: &lt;code&gt;IN&lt;/code&gt; или &lt;code&gt;VARIADIC&lt;/code&gt; . (Агрегатные функции не поддерживают аргументы &lt;code&gt;OUT&lt;/code&gt; .) Если не указано, по умолчанию используется &lt;code&gt;IN&lt;/code&gt; . Только последний аргумент может быть помечен как &lt;code&gt;VARIADIC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4568485f8330f08f8282bc3a9f4e6ab0835ae883" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt; or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;.</source>
          <target state="translated">Режим аргумента: &lt;code&gt;IN&lt;/code&gt; или &lt;code&gt;VARIADIC&lt;/code&gt; . Если не указано, по умолчанию используется &lt;code&gt;IN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d77ba6d205a4cdad089faf693afa61d51e9631c2" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. (&lt;code&gt;OUT&lt;/code&gt; arguments are currently not supported for procedures. Use &lt;code&gt;INOUT&lt;/code&gt; instead.)</source>
          <target state="translated">Режим аргумента: &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; или &lt;code&gt;VARIADIC&lt;/code&gt; . Если не указано, по умолчанию используется &lt;code&gt;IN&lt;/code&gt; . ( Аргументы &lt;code&gt;OUT&lt;/code&gt; в настоящее время не поддерживаются для процедур. Вместо этого используйте &lt;code&gt;INOUT&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="38c566bf6c299177523daede4805416a31c75adc" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;ALTER FUNCTION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">Режим аргумента: &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; или &lt;code&gt;VARIADIC&lt;/code&gt; . Если не указано, по умолчанию используется &lt;code&gt;IN&lt;/code&gt; . Обратите внимание, что &lt;code&gt;ALTER FUNCTION&lt;/code&gt; фактически не обращает внимания на аргументы &lt;code&gt;OUT&lt;/code&gt; , поскольку для определения идентичности функции необходимы только входные аргументы. Поэтому достаточно перечислить аргументы &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; и &lt;code&gt;VARIADIC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c0698969a82046af9f337be0b0bf94de3d24ca9" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;DROP FUNCTION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">Режим аргумента: &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; или &lt;code&gt;VARIADIC&lt;/code&gt; . Если не указано, по умолчанию используется &lt;code&gt;IN&lt;/code&gt; . Обратите внимание, что &lt;code&gt;DROP FUNCTION&lt;/code&gt; на самом деле не обращает внимания на аргументы &lt;code&gt;OUT&lt;/code&gt; , поскольку для определения идентичности функции необходимы только входные аргументы. Поэтому достаточно перечислить аргументы &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; и &lt;code&gt;VARIADIC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f4ca0b892fae54672225fff5e45afe9a23bd3fa" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Only &lt;code&gt;OUT&lt;/code&gt; arguments can follow a &lt;code&gt;VARIADIC&lt;/code&gt; one. Also, &lt;code&gt;OUT&lt;/code&gt; and &lt;code&gt;INOUT&lt;/code&gt; arguments cannot be used together with the &lt;code&gt;RETURNS TABLE&lt;/code&gt; notation.</source>
          <target state="translated">Режим аргумента: &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; или &lt;code&gt;VARIADIC&lt;/code&gt; . Если не указано, по умолчанию используется &lt;code&gt;IN&lt;/code&gt; . Только аргументы &lt;code&gt;OUT&lt;/code&gt; могут следовать за &lt;code&gt;VARIADIC&lt;/code&gt; . Кроме того, аргументы &lt;code&gt;OUT&lt;/code&gt; и &lt;code&gt;INOUT&lt;/code&gt; нельзя использовать вместе с нотацией &lt;code&gt;RETURNS TABLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51a81b68008882e6907064e5a6c6b245cdf62054" translate="yes" xml:space="preserve">
          <source>The modification of data that is already in the database is referred to as updating. You can update individual rows, all the rows in a table, or a subset of all rows. Each column can be updated separately; the other columns are not affected.</source>
          <target state="translated">Модификация данных,уже имеющихся в базе данных,называется обновлением.Вы можете обновлять отдельные строки,все строки в таблице или подмножество всех строк.Каждый столбец может обновляться отдельно,остальные столбцы не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="853b75e3f66e460231939e7956e83ee3b696375d" translate="yes" xml:space="preserve">
          <source>The module also provides a data type &lt;code&gt;lo&lt;/code&gt;, which is really just a domain of the &lt;code&gt;oid&lt;/code&gt; type. This is useful for differentiating database columns that hold large object references from those that are OIDs of other things. You don't have to use the &lt;code&gt;lo&lt;/code&gt; type to use the trigger, but it may be convenient to use it to keep track of which columns in your database represent large objects that you are managing with the trigger. It is also rumored that the ODBC driver gets confused if you don't use &lt;code&gt;lo&lt;/code&gt; for BLOB columns.</source>
          <target state="translated">Модуль также предоставляет тип данных &lt;code&gt;lo&lt;/code&gt; , который на самом деле является просто доменом типа &lt;code&gt;oid&lt;/code&gt; . Это полезно для различения столбцов базы данных, содержащих ссылки на большие объекты, от столбцов, являющихся OID других объектов. Вам не обязательно использовать тип &lt;code&gt;lo&lt;/code&gt; для использования триггера, но может быть удобно использовать его для отслеживания того, какие столбцы в вашей базе данных представляют большие объекты, которыми вы управляете с помощью триггера. Также ходят слухи, что драйвер ODBC сбивается с толку, если вы не используете &lt;code&gt;lo&lt;/code&gt; для столбцов BLOB.</target>
        </trans-unit>
        <trans-unit id="81ca0d62d96cb007036c4e8c71ad66419c59e2b5" translate="yes" xml:space="preserve">
          <source>The module must be loaded by adding &lt;code&gt;pg_stat_statements&lt;/code&gt; to &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;, because it requires additional shared memory. This means that a server restart is needed to add or remove the module.</source>
          <target state="translated">Модуль необходимо загрузить, добавив &lt;code&gt;pg_stat_statements&lt;/code&gt; в &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; в &lt;code&gt;postgresql.conf&lt;/code&gt; , поскольку для этого требуется дополнительная разделяемая память. Это означает, что для добавления или удаления модуля требуется перезапуск сервера.</target>
        </trans-unit>
        <trans-unit id="d72e93f82e4421713f65eb6d758581a8fbe9cccf" translate="yes" xml:space="preserve">
          <source>The module provides a C function &lt;code&gt;pg_buffercache_pages&lt;/code&gt; that returns a set of records, plus a view &lt;code&gt;pg_buffercache&lt;/code&gt; that wraps the function for convenient use.</source>
          <target state="translated">Модуль предоставляет функцию C &lt;code&gt;pg_buffercache_pages&lt;/code&gt; , которая возвращает набор записей, а также представление &lt;code&gt;pg_buffercache&lt;/code&gt; , которое является оболочкой для функции для удобного использования.</target>
        </trans-unit>
        <trans-unit id="32a787e9d3c71749ae7c7075bc8cc6c86f32c2a0" translate="yes" xml:space="preserve">
          <source>The module provides no SQL-accessible functions. To use it, simply load it into the server. You can load it into an individual session:</source>
          <target state="translated">Модуль не предоставляет SQL-функций.Для его использования достаточно загрузить его на сервер.Вы можете загрузить его в отдельный сеанс:</target>
        </trans-unit>
        <trans-unit id="7b136900f1dbee2d882f7a554d2840c344beb60e" translate="yes" xml:space="preserve">
          <source>The module requires additional shared memory proportional to &lt;code&gt;pg_stat_statements.max&lt;/code&gt;. Note that this memory is consumed whenever the module is loaded, even if &lt;code&gt;pg_stat_statements.track&lt;/code&gt; is set to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_stat_statements.max&lt;/code&gt; требуется дополнительная разделяемая память, пропорциональная pg_stat_statements.max . Обратите внимание, что эта память потребляется всякий раз, когда модуль загружается, даже если для &lt;code&gt;pg_stat_statements.track&lt;/code&gt; установлено значение &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9ad875208f4afcd97973304af9fd6ef485a5b48" translate="yes" xml:space="preserve">
          <source>The monitoring information about subscription is visible in &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SUBSCRIPTION&quot;&gt;&lt;code&gt;pg_stat_subscription&lt;/code&gt;&lt;/a&gt;. This view contains one row for every subscription worker. A subscription can have zero or more active subscription workers depending on its state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96530f50681b8674942f17d7870b9786b275bddf" translate="yes" xml:space="preserve">
          <source>The monitoring information about subscription is visible in &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;&lt;code&gt;pg_stat_subscription&lt;/code&gt;&lt;/a&gt;. This view contains one row for every subscription worker. A subscription can have zero or more active subscription workers depending on its state.</source>
          <target state="translated">Информация о мониторинге подписки отображается в &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt; &lt;code&gt;pg_stat_subscription&lt;/code&gt; &lt;/a&gt; . Это представление содержит по одной строке для каждого работника подписки. Подписка может иметь ноль или более активных сотрудников подписки в зависимости от ее состояния.</target>
        </trans-unit>
        <trans-unit id="e4f2efea26fbea2f4a0f53659ea7db3de7f00c25" translate="yes" xml:space="preserve">
          <source>The most common reason for conflict between standby queries and WAL replay is &amp;ldquo;early cleanup&amp;rdquo;. Normally, PostgreSQL allows cleanup of old row versions when there are no transactions that need to see them to ensure correct visibility of data according to MVCC rules. However, this rule can only be applied for transactions executing on the master. So it is possible that cleanup on the master will remove row versions that are still visible to a transaction on the standby.</source>
          <target state="translated">Наиболее частой причиной конфликта между резервными запросами и воспроизведением WAL является &amp;laquo;ранняя очистка&amp;raquo;. Обычно PostgreSQL позволяет очищать старые версии строк, когда нет транзакций, которым необходимо их видеть, чтобы обеспечить правильную видимость данных в соответствии с правилами MVCC. Однако это правило может применяться только для транзакций, выполняемых на главном сервере. Таким образом, возможно, что очистка на главном сервере удалит версии строк, которые все еще видны транзакции на резервном сервере.</target>
        </trans-unit>
        <trans-unit id="731bbf4edb90976573e528f87d62ab4f72b17368" translate="yes" xml:space="preserve">
          <source>The most critical part of the display is the estimated statement execution cost, which is the planner's guess at how long it will take to run the statement (measured in cost units that are arbitrary, but conventionally mean disk page fetches). Actually two numbers are shown: the start-up cost before the first row can be returned, and the total cost to return all the rows. For most queries the total cost is what matters, but in contexts such as a subquery in &lt;code&gt;EXISTS&lt;/code&gt;, the planner will choose the smallest start-up cost instead of the smallest total cost (since the executor will stop after getting one row, anyway). Also, if you limit the number of rows to return with a &lt;code&gt;LIMIT&lt;/code&gt; clause, the planner makes an appropriate interpolation between the endpoint costs to estimate which plan is really the cheapest.</source>
          <target state="translated">Самая важная часть отображения - это предполагаемая стоимость выполнения оператора, которая представляет собой предположение планировщика о том, сколько времени потребуется для выполнения оператора (измеряется в единицах стоимости, которые являются произвольными, но обычно означают выборки страниц с диска). На самом деле показаны два числа: начальная стоимость до того, как первая строка может быть возвращена, и общая стоимость для возврата всех строк. Для большинства запросов важна общая стоимость, но в таких контекстах, как подзапрос в &lt;code&gt;EXISTS&lt;/code&gt; , планировщик выберет наименьшую начальную стоимость вместо наименьшей общей стоимости (так как исполнитель в любом случае остановится после получения одной строки). Кроме того, если вы ограничите количество возвращаемых строк с помощью &lt;code&gt;LIMIT&lt;/code&gt; В предложении планировщик выполняет соответствующую интерполяцию между затратами на конечную точку, чтобы оценить, какой план действительно самый дешевый.</target>
        </trans-unit>
        <trans-unit id="413b816a60a8ce6de7ad09a5ffb4362dd48af1ec" translate="yes" xml:space="preserve">
          <source>The most fundamental way to set these parameters is to edit the file &lt;code&gt;postgresql.conf&lt;/code&gt;, which is normally kept in the data directory. A default copy is installed when the database cluster directory is initialized. An example of what this file might look like is:</source>
          <target state="translated">Самый простой способ установить эти параметры - отредактировать файл &lt;code&gt;postgresql.conf&lt;/code&gt; , который обычно хранится в каталоге данных. Копия по умолчанию устанавливается при инициализации каталога кластера базы данных. Пример того, как может выглядеть этот файл:</target>
        </trans-unit>
        <trans-unit id="e306bed63f3a1d9eca423326fcf07e6b9edcc6b0" translate="yes" xml:space="preserve">
          <source>The most important disk monitoring task of a database administrator is to make sure the disk doesn't become full. A filled data disk will not result in data corruption, but it might prevent useful activity from occurring. If the disk holding the WAL files grows full, database server panic and consequent shutdown might occur.</source>
          <target state="translated">Самая важная задача администратора БД по мониторингу диска-убедиться,что диск не переполнен.Заполненный диск с данными не приведет к повреждению данных,но может предотвратить полезную деятельность.Если диск,на котором хранятся файлы WAL,переполнится,может возникнуть паника на сервере базы данных и,как следствие,произойти его отключение.</target>
        </trans-unit>
        <trans-unit id="877dc37c3736494355fb75407dc41fe0e6f84483" translate="yes" xml:space="preserve">
          <source>The most interesting options are probably &lt;code&gt;compress-algo&lt;/code&gt; and &lt;code&gt;unicode-mode&lt;/code&gt;. The rest should have reasonable defaults.</source>
          <target state="translated">Наиболее интересными вариантами, вероятно, являются &lt;code&gt;compress-algo&lt;/code&gt; и &lt;code&gt;unicode-mode&lt;/code&gt; . Остальные должны иметь разумные значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="9a6d131c4243d30d96e0db292f1623b359a016fb" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a &lt;em&gt;planner support function&lt;/em&gt; to use for this function. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt; for details. You must be superuser to use this option.</source>
          <target state="translated">Имя (возможно, дополненное схемой) &lt;em&gt;функции поддержки планировщика,&lt;/em&gt; используемой для этой функции. См &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;раздел 37.11&lt;/a&gt; для деталей. Чтобы использовать эту опцию, вы должны быть суперпользователем.</target>
        </trans-unit>
        <trans-unit id="1902fa4c4f3be48a1f8af8f713baf8e7dfa86fb2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a &lt;em&gt;planner support function&lt;/em&gt; to use for this function. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt; for details. You must be superuser to use this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b6fcb4c63d755a00d7e0670d638ed746023a2d" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a domain to be created.</source>
          <target state="translated">Имя (по желанию-схематическое)создаваемого домена.</target>
        </trans-unit>
        <trans-unit id="38611bfc887263be7f78673bf7d9d5cdb57c578a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a function that is an index method support function for the operator class.</source>
          <target state="translated">Имя (необязательно схемное)функции,которая является функцией поддержки метода индекса для операторского класса.</target>
        </trans-unit>
        <trans-unit id="5902522e953f867bcf2f16270ac0968cc20f9546" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a function that is an index method support function for the operator family. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="translated">Имя (по желанию-схематическое)функции,которая является функцией поддержки метода индекса для семейства операторов.Если список аргументов не указан,то имя должно быть уникальным в его схеме.</target>
        </trans-unit>
        <trans-unit id="d845c7a3b53e4177570415c0bc3bcd5b3195e4e2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a sequence to be altered.</source>
          <target state="translated">Имя (по желанию-схематическое)последовательности,которую необходимо изменить.</target>
        </trans-unit>
        <trans-unit id="86f2ddbdf403f4ceac3ce1673bf568f23dd1ad99" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a sequence.</source>
          <target state="translated">Имя (по желанию-схематическое)последовательности.</target>
        </trans-unit>
        <trans-unit id="ac3e3dd701383980ee625dc0305504430477533a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a specific table or materialized view to vacuum. If the specified table is a partitioned table, all of its leaf partitions are vacuumed.</source>
          <target state="translated">Название (по желанию-схематическое)конкретной таблицы или материализованного вида в вакууме.Если указанная таблица является разметкой,то все ее листовые перегородки вакуумируются.</target>
        </trans-unit>
        <trans-unit id="53bb17c6184a24ee8382a2d75581d17a4a86859a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a table to truncate. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is truncated. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are truncated. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">Имя (возможно, дополненное схемой) таблицы для усечения. Если перед именем таблицы указано &lt;code&gt;ONLY&lt;/code&gt; усекается только эта таблица. Если &lt;code&gt;ONLY&lt;/code&gt; не указан, таблица и все ее дочерние таблицы (если есть) усекаются. При желании после имени таблицы можно указать &lt;code&gt;*&lt;/code&gt; , чтобы явно указать, что включены дочерние таблицы.</target>
        </trans-unit>
        <trans-unit id="2e64f1d6069ef5fc5ed6316b39d72b0e2b06f901" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a type to be created.</source>
          <target state="translated">Имя (по желанию-схематическое)создаваемого типа.</target>
        </trans-unit>
        <trans-unit id="f9bf344cdc87b1adaf5636fb2ebcad9f1ddba5b6" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a view to be created.</source>
          <target state="translated">Имя (по желанию-схематическое)создаваемого вида.</target>
        </trans-unit>
        <trans-unit id="b639552e986e941a3c10c2544ec995a239ffb6e3" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing &lt;code&gt;btree&lt;/code&gt; operator family that describes the sort ordering associated with an ordering operator.</source>
          <target state="translated">Имя (возможно, дополненное схемой) существующего семейства операторов &lt;code&gt;btree&lt;/code&gt; , описывающее порядок сортировки, связанный с оператором упорядочивания.</target>
        </trans-unit>
        <trans-unit id="34900785f9149eeefbc60e92cda94ca173cd04e7" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing aggregate function.</source>
          <target state="translated">Название (по желанию-схематическое)существующей агрегатной функции.</target>
        </trans-unit>
        <trans-unit id="578ce1660a308750d3e750170be95b160d2b4eaa" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing collation.</source>
          <target state="translated">Название (по желанию-схематическое)существующего объединения.</target>
        </trans-unit>
        <trans-unit id="f41ad29e0b7f082d84fd62fd8cb20d2acca4d7fc" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing conversion.</source>
          <target state="translated">Название (по желанию-схематическое)существующего преобразования.</target>
        </trans-unit>
        <trans-unit id="3906d435eac2789ae790437fa866de097132bd5f" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing domain.</source>
          <target state="translated">Имя (по желанию-схематическое)существующего домена.</target>
        </trans-unit>
        <trans-unit id="d79e2ff622e47d59db15f73c173411091fa8fabb" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing function. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="translated">Название (по желанию-схематическое)существующей функции.Если список аргументов не указан,имя должно быть уникальным в его схеме.</target>
        </trans-unit>
        <trans-unit id="e19891aa77a7fd37f7b714112d5a229b9e2c2c1e" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing materialized view.</source>
          <target state="translated">Название (по желанию-схематическое)существующего материализованного вида.</target>
        </trans-unit>
        <trans-unit id="d3c124f08f1d17279d8902cee277b8d4f1a183ad" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator class.</source>
          <target state="translated">Имя (по желанию-схематическое)существующего класса оператора.</target>
        </trans-unit>
        <trans-unit id="38e2880de321890fbbcce2e9729e127a62b40b76" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator family.</source>
          <target state="translated">Название (по желанию-схематическое)существующего семейства операторов.</target>
        </trans-unit>
        <trans-unit id="054a0dca285caf1e015006f488ef65a3eecedbf4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator.</source>
          <target state="translated">Имя (по желанию-схематическое)существующего оператора.</target>
        </trans-unit>
        <trans-unit id="77adb5998ee2e3aabde213dad5e54fd26872e3dc" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing procedure. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="translated">Название (по желанию-схематическое)существующей процедуры.Если список аргументов не указан,имя должно быть уникальным в его схеме.</target>
        </trans-unit>
        <trans-unit id="f544776c8e3c1cef33633f466a66f32aea31c3fe" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table or view. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is scanned. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are scanned. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">Имя (возможно, дополненное схемой) существующей таблицы или представления. Если перед именем таблицы указано &lt;code&gt;ONLY&lt;/code&gt; сканируется только эта таблица. Если &lt;code&gt;ONLY&lt;/code&gt; не указано, проверяется таблица и все ее дочерние таблицы (если есть). При желании после имени таблицы можно указать &lt;code&gt;*&lt;/code&gt; , чтобы явно указать, что включены дочерние таблицы.</target>
        </trans-unit>
        <trans-unit id="fed47b49b5a2826cdd529f07291a0b91365295e5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table to alter. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is altered. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are altered. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">Имя (возможно, дополненное схемой) существующей таблицы, которую необходимо изменить. Если перед именем таблицы указано &lt;code&gt;ONLY&lt;/code&gt; изменяется только эта таблица. Если &lt;code&gt;ONLY&lt;/code&gt; не указан, таблица и все ее дочерние таблицы (если есть) изменяются. При желании после имени таблицы можно указать &lt;code&gt;*&lt;/code&gt; , чтобы явно указать, что включены дочерние таблицы.</target>
        </trans-unit>
        <trans-unit id="9e39d635b5a89d3591bd7fd7ce4ecbe9ffd4c1d5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table to lock. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is locked. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are locked. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">Имя (возможно, дополненное схемой) существующей таблицы для блокировки. Если перед именем таблицы указано &lt;code&gt;ONLY&lt;/code&gt; блокируется только эта таблица. Если &lt;code&gt;ONLY&lt;/code&gt; не указан, таблица и все ее дочерние таблицы (если есть) блокируются. При желании после имени таблицы можно указать &lt;code&gt;*&lt;/code&gt; , чтобы явно указать, что включены дочерние таблицы.</target>
        </trans-unit>
        <trans-unit id="7b428f5695f116b2abd1edd43a6b7f791e930f67" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table.</source>
          <target state="translated">Название (по желанию-схематическое)существующей таблицы.</target>
        </trans-unit>
        <trans-unit id="d6bac31933d004e229772d4577bb5205aa40d1b4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search configuration.</source>
          <target state="translated">Название (по желанию-схематическое)существующей конфигурации текстового поиска.</target>
        </trans-unit>
        <trans-unit id="c30fa81fa2fa2992c5e25e7be26425ba28f70618" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search dictionary.</source>
          <target state="translated">Название (по желанию-схематическое)существующего словаря для текстового поиска.</target>
        </trans-unit>
        <trans-unit id="6764c434bb1917335a8e7ae9bad93f1fcc49fc17" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search parser.</source>
          <target state="translated">Название (по желанию-схематическое)существующего парсера текстового поиска.</target>
        </trans-unit>
        <trans-unit id="dcc71c03641d807db453dbb54b0a2fce72902867" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search template.</source>
          <target state="translated">Имя (по желанию-схематическое)существующего текстового шаблона поиска.</target>
        </trans-unit>
        <trans-unit id="c07fc33a37601af59ca6761edf035f64fe688e76" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing view.</source>
          <target state="translated">Название (по желанию-схематическое)существующего вида.</target>
        </trans-unit>
        <trans-unit id="5f3b87270ccb7b31876399c63171eeddc6c5acd0" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an index to remove.</source>
          <target state="translated">Имя (по желанию-схематическое)индекса для удаления.</target>
        </trans-unit>
        <trans-unit id="4d1a15fbadbb463eba7072f8d97b36fff8e4db35" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an operator associated with the operator class.</source>
          <target state="translated">Имя (по желанию-схематическое)оператора,ассоциированного с классом оператора.</target>
        </trans-unit>
        <trans-unit id="f55c07895028de262598e75436d631175b201a69" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an operator associated with the operator family.</source>
          <target state="translated">Имя (по желанию-схематическое)оператора,связанного с семейством операторов.</target>
        </trans-unit>
        <trans-unit id="b2bd7b76dedcec38eb17eed38f1b959f8bd417a7" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the aggregate function to create.</source>
          <target state="translated">Имя (по желанию-схематическое)совокупной функции для создания.</target>
        </trans-unit>
        <trans-unit id="a93a4bd4bc9034a1432f189ca88e837333dc130b" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the data type to remove.</source>
          <target state="translated">Имя (по желанию-схематическое)типа данных для удаления.</target>
        </trans-unit>
        <trans-unit id="985217a7a1fa0c3a567eb7244b6b8b146f2c7b30" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the foreign table to drop.</source>
          <target state="translated">Название (по желанию-схематическое)таблицы иностранных граждан,которую необходимо опустить.</target>
        </trans-unit>
        <trans-unit id="c10f31992b2571e70d614bb2d060a79ba59a8a33" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the function to create.</source>
          <target state="translated">Имя (по желанию-схематическое)создаваемой функции.</target>
        </trans-unit>
        <trans-unit id="83e9847814c3ba939cbc4f420e1c3c7c00a69552" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to be created.</source>
          <target state="translated">Название (по желанию-схематическое)материализованного вида,который будет создан.</target>
        </trans-unit>
        <trans-unit id="2255582209b1f3da815e53122bc13a8a7b84cf00" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to refresh.</source>
          <target state="translated">Название (по желанию-схематическое)материализованного представления для обновления.</target>
        </trans-unit>
        <trans-unit id="2db1fb74b2f868165f2c5564d755e2f43c24353f" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to remove.</source>
          <target state="translated">Название (по желанию-схематическое)материализованного вида для удаления.</target>
        </trans-unit>
        <trans-unit id="9df0359ba8b94b06eb25b013152842f292a7b4df" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the procedure to create.</source>
          <target state="translated">Имя (по желанию-схематическое)создаваемой процедуры.</target>
        </trans-unit>
        <trans-unit id="4cd07bcb956404ed169f912452a4480e70e115e4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the procedure.</source>
          <target state="translated">Название (по желанию-схематическое)процедуры.</target>
        </trans-unit>
        <trans-unit id="2a4c2e1b22bdcbf405362b9ae17fa1fbce426df2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the sequence to be created.</source>
          <target state="translated">Имя (по желанию-схематическое)создаваемой последовательности.</target>
        </trans-unit>
        <trans-unit id="048a9ab4e359ce8b95a4959e9df97e30c4e65d60" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to be altered.</source>
          <target state="translated">Имя (по желанию-схематическое)изменяемого объекта статистики.</target>
        </trans-unit>
        <trans-unit id="f52881167770a0af5eb7409ca2185b9c04bac337" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to be created.</source>
          <target state="translated">Имя (по желанию-схематическое)создаваемого объекта статистики.</target>
        </trans-unit>
        <trans-unit id="4b423cb4d9cc1b2bcdad9b8dd172fb72d89e4e2c" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to drop.</source>
          <target state="translated">Имя (по желанию-схематическое)бросаемого объекта статистики.</target>
        </trans-unit>
        <trans-unit id="b61d21dada065f46c4c7b2b7d604e26966040dc1" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table containing the column(s) the statistics are computed on.</source>
          <target state="translated">Название (по желанию-схематическое)таблицы,содержащей столбец (столбцы),по которым рассчитывается статистика.</target>
        </trans-unit>
        <trans-unit id="8defd757e6f0ae34c512e774b626ccf674726eab" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table for which the trigger is defined.</source>
          <target state="translated">Имя (по желанию-схематическое)таблицы,для которой определен триггер.</target>
        </trans-unit>
        <trans-unit id="4d5698a39cc31b5f7b88bdd408f67f5c7638f5d5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table or view that the rule applies to.</source>
          <target state="translated">Название (по желанию-схематическое)таблицы или представления,к которому применяется правило.</target>
        </trans-unit>
        <trans-unit id="b756bc816e4bf98b49581640b12dbf571a3be447" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table or view the rule applies to.</source>
          <target state="translated">Название (по желанию-схематическое)таблицы или представления,к которому применяется правило.</target>
        </trans-unit>
        <trans-unit id="1babb726cd58996c0c81dade9eb62f3731eca7ef" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table that the policy is on.</source>
          <target state="translated">Имя (по желанию-схематическое)таблицы,в которой находится политика.</target>
        </trans-unit>
        <trans-unit id="66f5ae5d2b295f1ee2b970f57d5d9ecd6bf021d8" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table the policy applies to.</source>
          <target state="translated">Название (по желанию-схематическое)таблицы,к которой применяется политика.</target>
        </trans-unit>
        <trans-unit id="2163decbe5c6781dc3c30049b04dc6fe3b754ccd" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to be created.</source>
          <target state="translated">Имя (по желанию-схематическое)создаваемой таблицы.</target>
        </trans-unit>
        <trans-unit id="7faaacd9226a4e88c9e4c1c3c739210417e124ce" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to delete rows from. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, matching rows are deleted from the named table only. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, matching rows are also deleted from any tables inheriting from the named table. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">Имя (возможно, дополненное схемой) таблицы, из которой нужно удалить строки. Если перед именем таблицы указано &lt;code&gt;ONLY&lt;/code&gt; , совпадающие строки удаляются только из указанной таблицы. Если &lt;code&gt;ONLY&lt;/code&gt; не указан, совпадающие строки также удаляются из любых таблиц, унаследованных от указанной таблицы. При желании после имени таблицы можно указать &lt;code&gt;*&lt;/code&gt; , чтобы явно указать, что включены дочерние таблицы.</target>
        </trans-unit>
        <trans-unit id="2a919fb8f51d9d6b6757a121c98308d8b2e355a9" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to drop.</source>
          <target state="translated">Имя (по желанию-схематическое)таблицы,которую нужно опустить.</target>
        </trans-unit>
        <trans-unit id="805225c1106f83d7720b93b38e959f1241d2a307" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to update. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, matching rows are updated in the named table only. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, matching rows are also updated in any tables inheriting from the named table. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">Имя (возможно, дополненное схемой) обновляемой таблицы. Если перед именем таблицы указано &lt;code&gt;ONLY&lt;/code&gt; , совпадающие строки обновляются только в указанной таблице. Если &lt;code&gt;ONLY&lt;/code&gt; не указано, совпадающие строки также обновляются в любых таблицах, унаследованных от указанной таблицы. При желании после имени таблицы можно указать &lt;code&gt;*&lt;/code&gt; , чтобы явно указать, что включены дочерние таблицы.</target>
        </trans-unit>
        <trans-unit id="56ec5e8966f4a00d4b5c2a7c99ee7bd04c931eab" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table, view, or foreign table the trigger is for.</source>
          <target state="translated">Имя (по желанию-схематическое)таблицы,представления или зарубежной таблицы,для которой предназначен триггер.</target>
        </trans-unit>
        <trans-unit id="72a54509c9fcd2a9291f8a3e62487b349d23e646" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the view to remove.</source>
          <target state="translated">Название (по желанию-схематическое)вида для удаления.</target>
        </trans-unit>
        <trans-unit id="359f50eaf29e3eca920ffd05f6355f20cb0c9f2e" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of a specific table to analyze. If omitted, all regular tables, partitioned tables, and materialized views in the current database are analyzed (but not foreign tables). If the specified table is a partitioned table, both the inheritance statistics of the partitioned table as a whole and statistics of the individual partitions are updated.</source>
          <target state="translated">Название (возможно,квалифицированное по схеме)конкретной таблицы для анализа.Если их пропустить,то анализируются все обычные таблицы,таблицы разбиения и материализованные представления в текущей БД (но не посторонние таблицы).Если указанная таблица является таблицей разделов,то обновляется как статистика наследования таблицы разделов в целом,так и статистика отдельных разделов.</target>
        </trans-unit>
        <trans-unit id="a0cd47e6e1a9ee5389b9c55e40402c5ad699bfc0" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of a table.</source>
          <target state="translated">Название (возможно,схематическое)таблицы.</target>
        </trans-unit>
        <trans-unit id="36578a59c82b2f2c476f7f18ac9898c7cebf4713" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing domain to alter.</source>
          <target state="translated">Имя (возможно,квалифицированное по схеме)существующего домена для изменения.</target>
        </trans-unit>
        <trans-unit id="c76b8e93831ffb6b044097c12ef94efed652a62a" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing foreign table to alter. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is altered. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are altered. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">Имя (возможно, дополненное схемой) существующей внешней таблицы, которую необходимо изменить. Если перед именем таблицы указано &lt;code&gt;ONLY&lt;/code&gt; изменяется только эта таблица. Если &lt;code&gt;ONLY&lt;/code&gt; не указан, таблица и все ее дочерние таблицы (если есть) изменяются. При желании после имени таблицы можно указать &lt;code&gt;*&lt;/code&gt; , чтобы явно указать, что включены дочерние таблицы.</target>
        </trans-unit>
        <trans-unit id="fc6c50c1390116c899b9f1d7b2719134752e51ac" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing index to alter.</source>
          <target state="translated">Название (возможно,с указанием схемы)существующего индекса для изменения.</target>
        </trans-unit>
        <trans-unit id="f3966882870cfe613d0a8e73355b9179fb2c810a" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing type to alter.</source>
          <target state="translated">Название (возможно,квалифицированное по схеме)существующего типа для изменения.</target>
        </trans-unit>
        <trans-unit id="06da0274ecfe82f800f0ab5a5f38a984e49a92a1" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of the table to be indexed.</source>
          <target state="translated">Название (возможно,с указанием схемы)таблицы,подлежащей индексированию.</target>
        </trans-unit>
        <trans-unit id="a158ac6caffff3f341ed81dff98d22b9af284fcf" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;test1_id_index&lt;/code&gt; can be chosen freely, but you should pick something that enables you to remember later what the index was for.</source>
          <target state="translated">Имя &lt;code&gt;test1_id_index&lt;/code&gt; можно выбрать произвольно, но вы должны выбрать что-то, что позволит вам позже вспомнить, для чего был нужен индекс.</target>
        </trans-unit>
        <trans-unit id="27865390113cdcda66f400351749779a6e670188" translate="yes" xml:space="preserve">
          <source>The name can be any string of less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; characters (64 characters in a standard build). Only printable ASCII characters may be used in the &lt;code&gt;cluster_name&lt;/code&gt; value. Other characters will be replaced with question marks (&lt;code&gt;?&lt;/code&gt;). No name is shown if this parameter is set to the empty string &lt;code&gt;''&lt;/code&gt; (which is the default). This parameter can only be set at server start.</source>
          <target state="translated">Имя может быть любой строкой, содержащей менее &lt;code&gt;NAMEDATALEN&lt;/code&gt; символов (64 символа в стандартной сборке). В значении &lt;code&gt;cluster_name&lt;/code&gt; можно использовать только печатаемые символы ASCII . Остальные символы будут заменены вопросительными знаками ( &lt;code&gt;?&lt;/code&gt; ). Имя не отображается, если для этого параметра задана пустая строка &lt;code&gt;''&lt;/code&gt; (значение по умолчанию). Этот параметр можно установить только при запуске сервера.</target>
        </trans-unit>
        <trans-unit id="0be2813c09731c2a742fdb24fc852c07e13e3ed7" translate="yes" xml:space="preserve">
          <source>The name of a &lt;code&gt;table_name&lt;/code&gt; column. Used to infer arbiter indexes. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format. &lt;code&gt;SELECT&lt;/code&gt; privilege on &lt;code&gt;index_column_name&lt;/code&gt; is required.</source>
          <target state="translated">Имя столбца &lt;code&gt;table_name&lt;/code&gt; . Используется для определения индексов арбитра. Соответствует формату &lt;code&gt;CREATE INDEX&lt;/code&gt; . Требуется привилегия &lt;code&gt;SELECT&lt;/code&gt; для &lt;code&gt;index_column_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="347e4a2b8b46492f607cf8e79afee93d1d470e6b" translate="yes" xml:space="preserve">
          <source>The name of a b-tree operator class for the subtype.</source>
          <target state="translated">Название класса оператора b-дерева для подтипа.</target>
        </trans-unit>
        <trans-unit id="84001d19bb8ee2bc0f3fd3214b7948ea87315d70" translate="yes" xml:space="preserve">
          <source>The name of a base-type property to be modified; see above for possible values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4c963309e1915e51f2989fadcd94d4d9264511" translate="yes" xml:space="preserve">
          <source>The name of a column in the new materialized view. If column names are not provided, they are taken from the output column names of the query.</source>
          <target state="translated">Название колонки в новом материализованном представлении.Если имена столбцов не предоставляются,то они берутся из названия выходного столбца запроса.</target>
        </trans-unit>
        <trans-unit id="38a996c1d10563af1a139319a2d1ffd30fc57281" translate="yes" xml:space="preserve">
          <source>The name of a column in the new table. If column names are not provided, they are taken from the output column names of the query.</source>
          <target state="translated">Название столбца в новой таблице.Если имена столбцов не предоставляются,то они берутся из названия выходного столбца запроса.</target>
        </trans-unit>
        <trans-unit id="88674d0aca3396b42507d5f644ff534993edea22" translate="yes" xml:space="preserve">
          <source>The name of a column in the table named by &lt;code&gt;table_name&lt;/code&gt;. The column name can be qualified with a subfield name or array subscript, if needed. (Inserting into only some fields of a composite column leaves the other fields null.) When referencing a column with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt;, do not include the table's name in the specification of a target column. For example, &lt;code&gt;INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1&lt;/code&gt; is invalid (this follows the general behavior for &lt;code&gt;UPDATE&lt;/code&gt;).</source>
          <target state="translated">Имя столбца в таблице с именем &lt;code&gt;table_name&lt;/code&gt; . При необходимости имя столбца может быть дополнено именем подполя или индексом массива. (Вставка только в некоторые поля составного столбца оставляет другие поля пустыми.) При ссылке на столбец с помощью &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; не включайте имя таблицы в спецификацию целевого столбца. Например, &lt;code&gt;INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1&lt;/code&gt; недействительно (это соответствует общему поведению для &lt;code&gt;UPDATE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="37965fca46dac2ae8978b3ba3784bd4c0e6d710a" translate="yes" xml:space="preserve">
          <source>The name of a column in the table named by &lt;code&gt;table_name&lt;/code&gt;. The column name can be qualified with a subfield name or array subscript, if needed. Do not include the table's name in the specification of a target column &amp;mdash; for example, &lt;code&gt;UPDATE table_name SET table_name.col = 1&lt;/code&gt; is invalid.</source>
          <target state="translated">Имя столбца в таблице с именем &lt;code&gt;table_name&lt;/code&gt; . При необходимости имя столбца может быть дополнено именем подполя или индексом массива. Не включайте имя таблицы в спецификацию целевого столбца - например, &lt;code&gt;UPDATE table_name SET table_name.col = 1&lt;/code&gt; недопустимо.</target>
        </trans-unit>
        <trans-unit id="43b0ac7767512f2c3828414a44343ffbdea05c48" translate="yes" xml:space="preserve">
          <source>The name of a column of the table.</source>
          <target state="translated">Название столбца таблицы.</target>
        </trans-unit>
        <trans-unit id="66eab6eba8b42b05c2deccc82d07f73f07802b19" translate="yes" xml:space="preserve">
          <source>The name of a column to be created in the new table.</source>
          <target state="translated">Название столбца,который будет создан в новой таблице.</target>
        </trans-unit>
        <trans-unit id="b107b21b5ebe28c88ce9e0df68fea5f76d67283a" translate="yes" xml:space="preserve">
          <source>The name of a database to create.</source>
          <target state="translated">Имя базы данных для создания.</target>
        </trans-unit>
        <trans-unit id="2836c4dd7800c0b2de8f3f3ed8ae3591f1a8fd6b" translate="yes" xml:space="preserve">
          <source>The name of a difference function for the subtype.</source>
          <target state="translated">Название разностной функции для подтипа.</target>
        </trans-unit>
        <trans-unit id="cc2b3b4a893c2c09d0bead8670c584d57f2b3d8a" translate="yes" xml:space="preserve">
          <source>The name of a function that converts an array of modifier(s) for the type into internal form.</source>
          <target state="translated">Имя функции,которая преобразует массив модификаторов типа во внутренний вид.</target>
        </trans-unit>
        <trans-unit id="9cfae7f4211e6fa9e0eeadb788b0238e1401f532" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's external binary form to its internal form.</source>
          <target state="translated">Имя функции,которая преобразует данные из внешней двоичной формы типа во внутреннюю.</target>
        </trans-unit>
        <trans-unit id="b8ec9150353430f953f8a2508fb1cc00d06ec3ad" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's external textual form to its internal form.</source>
          <target state="translated">Имя функции,которая преобразует данные из внешней текстовой формы типа во внутреннюю.</target>
        </trans-unit>
        <trans-unit id="e45bf619f83208134b19be3fe39ffa394657e429" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's internal form to its external binary form.</source>
          <target state="translated">Имя функции,которая преобразует данные из внутренней формы типа во внешнюю двоичную форму.</target>
        </trans-unit>
        <trans-unit id="ec568fe6711779cbc4fe49c405863a46d77641d0" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's internal form to its external textual form.</source>
          <target state="translated">Имя функции,которая преобразует данные из внутренней формы типа во внешнюю текстовую форму.</target>
        </trans-unit>
        <trans-unit id="a4232581838ec7343a99a8c7be95b2e49c198605" translate="yes" xml:space="preserve">
          <source>The name of a function that converts the internal form of the type's modifier(s) to external textual form.</source>
          <target state="translated">Имя функции,преобразующей внутреннюю форму модификатора(ов)типа во внешнюю текстовую форму.</target>
        </trans-unit>
        <trans-unit id="4ebc5121bc2fa18e076b2f1de0b2de537a76ba61" translate="yes" xml:space="preserve">
          <source>The name of a function that performs statistical analysis for the data type.</source>
          <target state="translated">Название функции,выполняющей статистический анализ для типа данных.</target>
        </trans-unit>
        <trans-unit id="8693551fac54570d94fac46289d20bd3cbf6ee4e" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;ALTER EXTENSION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">Имя функции, процедуры или агрегированного аргумента. Обратите внимание, что &lt;code&gt;ALTER EXTENSION&lt;/code&gt; фактически не обращает внимания на имена аргументов, поскольку для определения идентичности функции необходимы только типы данных аргументов.</target>
        </trans-unit>
        <trans-unit id="6fe30dcb3f4583c58770f03da94374abd82c96ab" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;COMMENT&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">Имя функции, процедуры или агрегированного аргумента. Обратите внимание, что &lt;code&gt;COMMENT&lt;/code&gt; на самом деле не обращает внимания на имена аргументов, так как только типы данных аргументов необходимы для определения идентичности функции.</target>
        </trans-unit>
        <trans-unit id="037ed7ab4666d9436acdd62556426330fa27de4d" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;SECURITY LABEL&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">Имя функции, процедуры или агрегированного аргумента. Обратите внимание, что &lt;code&gt;SECURITY LABEL&lt;/code&gt; фактически не обращает внимания на имена аргументов, поскольку для определения идентичности функции необходимы только типы данных аргументов.</target>
        </trans-unit>
        <trans-unit id="85d26a05a8c2a48486d4d983a4308017ec19fa06" translate="yes" xml:space="preserve">
          <source>The name of a role whose objects will be dropped, and whose privileges will be revoked.</source>
          <target state="translated">Название роли,объекты которой будут удалены,а привилегии аннулированы.</target>
        </trans-unit>
        <trans-unit id="2d651ee55d17fde141e789374afa64231439951d" translate="yes" xml:space="preserve">
          <source>The name of a role. The ownership of all the objects within the current database, and of all shared objects (databases, tablespaces), owned by this role will be reassigned to &lt;code&gt;new_role&lt;/code&gt;.</source>
          <target state="translated">Название роли. Владение всеми объектами в текущей базе данных и всеми совместно используемыми объектами (базами данных, табличными пространствами), принадлежащими этой роли, будет переназначено &lt;code&gt;new_role&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a41f912a967bc6187a0ff565790395916fca2f2a" translate="yes" xml:space="preserve">
          <source>The name of a rule to create. This must be distinct from the name of any other rule for the same table. Multiple rules on the same table and same event type are applied in alphabetical name order.</source>
          <target state="translated">Название создаваемого правила.Оно должно отличаться от имени любого другого правила для той же таблицы.Несколько правил для одной и той же таблицы и одного и того же типа события применяются в алфавитном порядке названий.</target>
        </trans-unit>
        <trans-unit id="16dbd653daa2713c731e96ec7016300d7b0623c9" translate="yes" xml:space="preserve">
          <source>The name of a run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page. In addition, there are a few parameters that can be shown but not set:</source>
          <target state="translated">Имя параметра времени выполнения. Доступные параметры описаны в &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;главе 19&lt;/a&gt; и на справочной странице &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; . Кроме того, есть несколько параметров, которые можно показать, но нельзя установить:</target>
        </trans-unit>
        <trans-unit id="aee34bf395a3fa67b708559214834f0819e94a8b" translate="yes" xml:space="preserve">
          <source>The name of a run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page. In addition, there are a few parameters that can be shown but not set:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb5b09a2e8ba40ee029ef0bb0deb2b715d29f64" translate="yes" xml:space="preserve">
          <source>The name of a schema to be created. If this is omitted, the &lt;code&gt;user_name&lt;/code&gt; is used as the schema name. The name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system schemas.</source>
          <target state="translated">Имя создаваемой схемы. Если это не указано, &lt;code&gt;user_name&lt;/code&gt; используется как имя схемы. Имя не может начинаться с &lt;code&gt;pg_&lt;/code&gt; , поскольку такие имена зарезервированы для системных схем.</target>
        </trans-unit>
        <trans-unit id="19552fb60b57524fdf3c4ba971f713deaf575934" translate="yes" xml:space="preserve">
          <source>The name of a schema.</source>
          <target state="translated">Название схемы.</target>
        </trans-unit>
        <trans-unit id="bec37b1bb0aae7199fe140e94c49fd869d890cc2" translate="yes" xml:space="preserve">
          <source>The name of a specific column to analyze. Defaults to all columns.</source>
          <target state="translated">Название конкретной колонки для анализа.По умолчанию для всех столбцов.</target>
        </trans-unit>
        <trans-unit id="f4dd69da6250801b1a99f96f4fc7a1fc3fc7a5ca" translate="yes" xml:space="preserve">
          <source>The name of a specific column to analyze. Defaults to all columns. If a column list is specified, &lt;code&gt;ANALYZE&lt;/code&gt; must also be specified.</source>
          <target state="translated">Имя конкретного столбца для анализа. По умолчанию для всех столбцов. Если указан список столбцов, необходимо также указать &lt;code&gt;ANALYZE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d277ce7dc1369544c960227202849bca34e3070" translate="yes" xml:space="preserve">
          <source>The name of a standby server for this purpose is the &lt;code&gt;application_name&lt;/code&gt; setting of the standby, as set in the standby's connection information. In case of a physical replication standby, this should be set in the &lt;code&gt;primary_conninfo&lt;/code&gt; setting; the default is the setting of &lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_name&lt;/a&gt; if set, else &lt;code&gt;walreceiver&lt;/code&gt;. For logical replication, this can be set in the connection information of the subscription, and it defaults to the subscription name. For other replication stream consumers, consult their documentation.</source>
          <target state="translated">Имя резервного сервера для этой цели - это параметр &lt;code&gt;application_name&lt;/code&gt; резервного, как указано в информации о соединении резервного сервера . В случае физического резервирования репликации это должно быть установлено в настройке &lt;code&gt;primary_conninfo&lt;/code&gt; ; по умолчанию используется параметр &lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_name,&lt;/a&gt; если он установлен, иначе &lt;code&gt;walreceiver&lt;/code&gt; . Для логической репликации это может быть установлено в информации о подключении подписки, и по умолчанию используется имя подписки. Для других потребителей потока репликации обратитесь к их документации.</target>
        </trans-unit>
        <trans-unit id="c8bcdb2c75dca6dff745c6b72d3eafa935add170" translate="yes" xml:space="preserve">
          <source>The name of a subscription to be dropped.</source>
          <target state="translated">Название подписки,которая будет отменена.</target>
        </trans-unit>
        <trans-unit id="10c04b3f0b50c7a796c21e054204f49c5305809f" translate="yes" xml:space="preserve">
          <source>The name of a subscription whose properties are to be altered.</source>
          <target state="translated">Название подписки,свойства которой должны быть изменены.</target>
        </trans-unit>
        <trans-unit id="a917fa888db788a84ebf308d993302ba69b3956f" translate="yes" xml:space="preserve">
          <source>The name of a table column to be covered by the computed statistics. At least two column names must be given; the order of the column names is insignificant.</source>
          <target state="translated">Название столбца таблицы,на который будет распространяться вычисляемая статистика.Необходимо дать как минимум два названия столбцов;порядок названий столбцов незначителен.</target>
        </trans-unit>
        <trans-unit id="547022940eaa9d3307e6377842b21fffa3dea285" translate="yes" xml:space="preserve">
          <source>The name of a table storage parameter.</source>
          <target state="translated">Имя параметра хранения таблиц.</target>
        </trans-unit>
        <trans-unit id="25f3d061a48202d36e2eddaaf0e7e422750642c9" translate="yes" xml:space="preserve">
          <source>The name of a tablespace to be created. The name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system tablespaces.</source>
          <target state="translated">Имя создаваемого табличного пространства. Имя не может начинаться с &lt;code&gt;pg_&lt;/code&gt; , поскольку такие имена зарезервированы для системных табличных пространств.</target>
        </trans-unit>
        <trans-unit id="f526639651b0458136ca498c2f2f2ac4fbd6800d" translate="yes" xml:space="preserve">
          <source>The name of a tablespace.</source>
          <target state="translated">Название табличного пространства.</target>
        </trans-unit>
        <trans-unit id="3f86890bb22a9b09c6fb6202e966b0cb90e86399" translate="yes" xml:space="preserve">
          <source>The name of a template-specific option to be set for this dictionary.</source>
          <target state="translated">Название опции,специфичной для шаблонов,которая должна быть установлена для данного словаря.</target>
        </trans-unit>
        <trans-unit id="d2fc4bb5096ba459cde4afbb76fdac536da62aa5" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be consulted for the specified token type(s). If multiple dictionaries are listed, they are consulted in the specified order.</source>
          <target state="translated">Название текстового поискового словаря,с которым необходимо обратиться к указанному типу токенов.Если перечислено несколько словарей,то они просматриваются в указанном порядке.</target>
        </trans-unit>
        <trans-unit id="b2ade2843219f0c75eecbdfb9ad26e157949ac15" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be replaced in the mapping.</source>
          <target state="translated">Название текстового поискового словаря,который будет заменен в отображении.</target>
        </trans-unit>
        <trans-unit id="c2e4d9635ee5eae77abbb98d0d04f44a7382134a" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be substituted for &lt;code&gt;old_dictionary&lt;/code&gt;.</source>
          <target state="translated">Имя словаря текстового поиска, которое нужно заменить на &lt;code&gt;old_dictionary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e536a7c03f29f8cbc17f3a583238f110ae4c9ca6" translate="yes" xml:space="preserve">
          <source>The name of a token type that is emitted by the configuration's parser.</source>
          <target state="translated">Имя типа токена,которое выдается синтаксическим анализатором конфигурации.</target>
        </trans-unit>
        <trans-unit id="e42ab0f9b2f16ce7c6531f791e195b576f9b5e7b" translate="yes" xml:space="preserve">
          <source>The name of a variable used to filter events. This makes it possible to restrict the firing of the trigger to a subset of the cases in which it is supported. Currently the only supported &lt;code&gt;filter_variable&lt;/code&gt; is &lt;code&gt;TAG&lt;/code&gt;.</source>
          <target state="translated">Имя переменной, используемой для фильтрации событий. Это позволяет ограничить срабатывание триггера подмножеством случаев, в которых он поддерживается. В настоящее время единственная поддерживаемая &lt;code&gt;filter_variable&lt;/code&gt; - &lt;code&gt;TAG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbbf80f6f4c468a122711e341fba3efb95ed9b4e" translate="yes" xml:space="preserve">
          <source>The name of an argument.</source>
          <target state="translated">Имя аргумента.</target>
        </trans-unit>
        <trans-unit id="e982fa6e95b8aff320484711c377b6849476a259" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the aggregate function's identity.</source>
          <target state="translated">Имя аргумента. Обратите внимание, что &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; фактически не обращает никакого внимания на имена аргументов, поскольку для определения идентичности агрегатной функции необходимы только типы данных аргументов.</target>
        </trans-unit>
        <trans-unit id="56b0baceffec189e51468368e1573f50c02b2801" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER FUNCTION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">Имя аргумента. Обратите внимание, что &lt;code&gt;ALTER FUNCTION&lt;/code&gt; фактически не обращает внимания на имена аргументов, поскольку для определения идентичности функции необходимы только типы данных аргумента.</target>
        </trans-unit>
        <trans-unit id="da880762c1ed4640b76217347360561ae983a357" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the procedure's identity.</source>
          <target state="translated">Имя аргумента. Обратите внимание, что &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; фактически не обращает внимания на имена аргументов, поскольку для определения идентичности процедуры необходимы только типы данных аргументов.</target>
        </trans-unit>
        <trans-unit id="0681d59ee9000bab536592eb7b8ddac88b06215c" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP AGGREGATE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the aggregate function's identity.</source>
          <target state="translated">Имя аргумента. Обратите внимание, что &lt;code&gt;DROP AGGREGATE&lt;/code&gt; фактически не обращает никакого внимания на имена аргументов, поскольку для определения идентичности агрегатной функции необходимы только типы данных аргументов.</target>
        </trans-unit>
        <trans-unit id="5f97c790620d0347b2dc1f2b503ffe310415155c" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP FUNCTION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">Имя аргумента. Обратите внимание, что &lt;code&gt;DROP FUNCTION&lt;/code&gt; на самом деле не обращает никакого внимания на имена аргументов, поскольку для определения идентичности функции необходимы только типы данных аргументов.</target>
        </trans-unit>
        <trans-unit id="75484c7635e6405e3d0e3238f7f514ab40e45aaa" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP PROCEDURE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the procedure's identity.</source>
          <target state="translated">Имя аргумента. Обратите внимание, что &lt;code&gt;DROP PROCEDURE&lt;/code&gt; фактически не обращает внимания на имена аргументов, поскольку для определения идентичности процедуры необходимы только типы данных аргументов.</target>
        </trans-unit>
        <trans-unit id="6264b5b03c956e34b1a101cf23f2e7ebcfb44a8b" translate="yes" xml:space="preserve">
          <source>The name of an argument. Some languages (including SQL and PL/pgSQL) let you use the name in the function body. For other languages the name of an input argument is just extra documentation, so far as the function itself is concerned; but you can use input argument names when calling a function to improve readability (see &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt;). In any case, the name of an output argument is significant, because it defines the column name in the result row type. (If you omit the name for an output argument, the system will choose a default column name.)</source>
          <target state="translated">Имя аргумента. Некоторые языки (включая SQL и PL / pgSQL) позволяют использовать имя в теле функции. Для других языков имя входного аргумента - это просто дополнительная документация, касающаяся самой функции; но вы можете использовать имена входных аргументов при вызове функции для улучшения читаемости (см. &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Раздел 4.3&lt;/a&gt; ). В любом случае имя выходного аргумента имеет значение, поскольку оно определяет имя столбца в типе строки результата. (Если вы опустите имя для выходного аргумента, система выберет имя столбца по умолчанию.)</target>
        </trans-unit>
        <trans-unit id="375094d89a9e7c5813b8961536891f0759815217" translate="yes" xml:space="preserve">
          <source>The name of an argument. This is currently only useful for documentation purposes. If omitted, the argument has no name.</source>
          <target state="translated">Имя аргумента.В настоящее время это полезно только для документации.Если его опустить,то аргумент не имеет имени.</target>
        </trans-unit>
        <trans-unit id="ed524d1ea7eb8aeebc2ae58ea9eeac500ae4de68" translate="yes" xml:space="preserve">
          <source>The name of an attribute (column) for the composite type.</source>
          <target state="translated">Имя атрибута (столбца)для составного типа.</target>
        </trans-unit>
        <trans-unit id="6a17e927a8bc128615b789bf21656b4af0a59747" translate="yes" xml:space="preserve">
          <source>The name of an existing access method.</source>
          <target state="translated">Название существующего метода доступа.</target>
        </trans-unit>
        <trans-unit id="ebcda1893633e936b520a2a0321ab231b1b0ba97" translate="yes" xml:space="preserve">
          <source>The name of an existing collation to be associated with a column of a composite type, or with a range type.</source>
          <target state="translated">Название существующего сопоставления,которое будет ассоциироваться со столбцом составного типа или с типом диапазона.</target>
        </trans-unit>
        <trans-unit id="6a99a7164db5effbf0ea0eafd9c39dd9aa197443" translate="yes" xml:space="preserve">
          <source>The name of an existing collation to copy. The new collation will have the same properties as the existing one, but it will be an independent object.</source>
          <target state="translated">Название существующего сопоставления для копирования.Новое сопоставление будет иметь те же свойства,что и существующее,но оно будет самостоятельным объектом.</target>
        </trans-unit>
        <trans-unit id="af62875da4376911af8fd6633488eb76e3df9aa2" translate="yes" xml:space="preserve">
          <source>The name of an existing data type that the new type will have the same representation as. The values of &lt;code&gt;internallength&lt;/code&gt;, &lt;code&gt;passedbyvalue&lt;/code&gt;, &lt;code&gt;alignment&lt;/code&gt;, and &lt;code&gt;storage&lt;/code&gt; are copied from that type, unless overridden by explicit specification elsewhere in this &lt;code&gt;CREATE TYPE&lt;/code&gt; command.</source>
          <target state="translated">Имя существующего типа данных, которое новый тип будет иметь то же представление, что и. Значения &lt;code&gt;internallength&lt;/code&gt; &lt;code&gt;passedbyvalue&lt;/code&gt; , переданного значения , &lt;code&gt;alignment&lt;/code&gt; и &lt;code&gt;storage&lt;/code&gt; копируются из этого типа, если они не переопределены явной спецификацией где-либо еще в этой команде &lt;code&gt;CREATE TYPE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="269f93ea4a18405eca9d42f3c25429fa59f4bc3d" translate="yes" xml:space="preserve">
          <source>The name of an existing data type to become a column of the composite type.</source>
          <target state="translated">Название существующего типа данных,чтобы стать столбцом составного типа.</target>
        </trans-unit>
        <trans-unit id="9a63f99fdd0bce011ca8d049908cd4539b298e7c" translate="yes" xml:space="preserve">
          <source>The name of an existing foreign server to use for the foreign table. For details on defining a server, see &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;.</source>
          <target state="translated">Имя существующего внешнего сервера, используемого для сторонней таблицы. Для получения дополнительной информации об определении сервера см. &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2454ed01e6d27ce51d6d152286d9f4044a0971f" translate="yes" xml:space="preserve">
          <source>The name of an existing foreign-data wrapper.</source>
          <target state="translated">Название существующей обертки иностранных данных.</target>
        </trans-unit>
        <trans-unit id="215bb96ed8aefedc59bc2785aaa4809857f9f3b1" translate="yes" xml:space="preserve">
          <source>The name of an existing index.</source>
          <target state="translated">Название существующего индекса.</target>
        </trans-unit>
        <trans-unit id="dcfd6d7a1b6a134c08f28bb84b429370f63f9bf9" translate="yes" xml:space="preserve">
          <source>The name of an existing policy to alter.</source>
          <target state="translated">Название существующей политики для изменения.</target>
        </trans-unit>
        <trans-unit id="d3e43edda0ed2c669ea64ea4de1cacab37227192" translate="yes" xml:space="preserve">
          <source>The name of an existing procedural language. For backward compatibility, the name can be enclosed by single quotes.</source>
          <target state="translated">Название существующего процедурного языка.Для обратной совместимости название может быть заключено в кавычки.</target>
        </trans-unit>
        <trans-unit id="dbc811803ec9f6996f00764f5d9b3a696bbe0492" translate="yes" xml:space="preserve">
          <source>The name of an existing publication whose definition is to be altered.</source>
          <target state="translated">Название существующей публикации,определение которой должно быть изменено.</target>
        </trans-unit>
        <trans-unit id="e43f43145062802662e910809c0dbf5106a36151" translate="yes" xml:space="preserve">
          <source>The name of an existing publication.</source>
          <target state="translated">Название существующей публикации.</target>
        </trans-unit>
        <trans-unit id="51d243f6e89c7e39326aaa5f0f4dbaf017f84cd3" translate="yes" xml:space="preserve">
          <source>The name of an existing role of which the current role is a member. If &lt;code&gt;FOR ROLE&lt;/code&gt; is omitted, the current role is assumed.</source>
          <target state="translated">Имя существующей роли, членом которой является текущая роль. Если &lt;code&gt;FOR ROLE&lt;/code&gt; опущено, предполагается текущая роль.</target>
        </trans-unit>
        <trans-unit id="55490c4e62932d1546a037c62cdff84638b0e3d3" translate="yes" xml:space="preserve">
          <source>The name of an existing role to grant or revoke privileges for. This parameter, and all the other parameters in &lt;code&gt;abbreviated_grant_or_revoke&lt;/code&gt;, act as described under &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; or &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;, except that one is setting permissions for a whole class of objects rather than specific named objects.</source>
          <target state="translated">Имя существующей роли, для которой нужно предоставить или отозвать привилегии. Этот параметр и все другие параметры в &lt;code&gt;abbreviated_grant_or_revoke&lt;/code&gt; действуют, как описано в разделе &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; или &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; , за исключением того, что один из них устанавливает разрешения для всего класса объектов, а не для определенных именованных объектов.</target>
        </trans-unit>
        <trans-unit id="c635ecbb1c53d1706cdab235bd6da7bb6c713113" translate="yes" xml:space="preserve">
          <source>The name of an existing rule to alter.</source>
          <target state="translated">Название существующего правила для изменения.</target>
        </trans-unit>
        <trans-unit id="313ea254effb62079628babb9fa1cbd9eaa5bbb0" translate="yes" xml:space="preserve">
          <source>The name of an existing schema.</source>
          <target state="translated">Название существующей схемы.</target>
        </trans-unit>
        <trans-unit id="5f4188f167a8cf646d3b7406994faa33188bb313" translate="yes" xml:space="preserve">
          <source>The name of an existing schema. If specified, the default privileges are altered for objects later created in that schema. If &lt;code&gt;IN SCHEMA&lt;/code&gt; is omitted, the global default privileges are altered. &lt;code&gt;IN SCHEMA&lt;/code&gt; is not allowed when setting privileges for schemas, since schemas can't be nested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc48699243fdc0b302f46f2ff91dbd816b03aa4b" translate="yes" xml:space="preserve">
          <source>The name of an existing schema. If specified, the default privileges are altered for objects later created in that schema. If &lt;code&gt;IN SCHEMA&lt;/code&gt; is omitted, the global default privileges are altered. &lt;code&gt;IN SCHEMA&lt;/code&gt; is not allowed when using &lt;code&gt;ON SCHEMAS&lt;/code&gt; as schemas can't be nested.</source>
          <target state="translated">Имя существующей схемы. Если указано, права по умолчанию изменяются для объектов, позже созданных в этой схеме. Если &lt;code&gt;IN SCHEMA&lt;/code&gt; опущен, глобальные привилегии по умолчанию изменяются. &lt;code&gt;IN SCHEMA&lt;/code&gt; не допускается при использовании &lt;code&gt;ON SCHEMAS&lt;/code&gt; , поскольку схемы не могут быть вложенными.</target>
        </trans-unit>
        <trans-unit id="02ea513b553c81e6e8bfffc28bfc183407ce6f92" translate="yes" xml:space="preserve">
          <source>The name of an existing server for which the user mapping is to be created.</source>
          <target state="translated">Имя существующего сервера,для которого будет создана пользовательская карта.</target>
        </trans-unit>
        <trans-unit id="94ab6bc9007ffe24527bb571f8caf6972fd6e32c" translate="yes" xml:space="preserve">
          <source>The name of an existing server.</source>
          <target state="translated">Имя существующего сервера.</target>
        </trans-unit>
        <trans-unit id="7b99635b20ef9c6fbf704b3d5683df0c76ea50a5" translate="yes" xml:space="preserve">
          <source>The name of an existing tablespace.</source>
          <target state="translated">Название существующего табличного пространства.</target>
        </trans-unit>
        <trans-unit id="1fba9536f8e094817879340972f3fc186e59ac3a" translate="yes" xml:space="preserve">
          <source>The name of an existing text search configuration to copy.</source>
          <target state="translated">Название существующей конфигурации текстового поиска для копирования.</target>
        </trans-unit>
        <trans-unit id="e62d3905f77c5380a51ef346837f8bb973da087a" translate="yes" xml:space="preserve">
          <source>The name of an existing trigger to alter.</source>
          <target state="translated">Имя существующего триггера для изменения.</target>
        </trans-unit>
        <trans-unit id="39eaed243c343dcf7cbdeda1eb27256bd699e984" translate="yes" xml:space="preserve">
          <source>The name of an existing user that is mapped to foreign server. &lt;code&gt;CURRENT_USER&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; match the name of the current user. When &lt;code&gt;PUBLIC&lt;/code&gt; is specified, a so-called public mapping is created that is used when no user-specific mapping is applicable.</source>
          <target state="translated">Имя существующего пользователя, привязанного к внешнему серверу. &lt;code&gt;CURRENT_USER&lt;/code&gt; и &lt;code&gt;USER&lt;/code&gt; соответствуют имени текущего пользователя. Когда указано &lt;code&gt;PUBLIC&lt;/code&gt; , создается так называемое общедоступное сопоставление, которое используется, когда никакое привязанное к пользователю не применимо.</target>
        </trans-unit>
        <trans-unit id="7ff3e30c52fed6a21d64c778f1c3cb5bfde69e2e" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter.</source>
          <target state="translated">Имя конкретного параметра хранения по методу индекса.</target>
        </trans-unit>
        <trans-unit id="391b7b7e4f5957c20764197abfbac06a778f9581" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter. See &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;Index Storage Parameters&lt;/a&gt; below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094d120f87047ccaf9df626ee5c7800b9676897f" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter. See &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;Index Storage Parameters&lt;/a&gt; for details.</source>
          <target state="translated">Имя параметра хранения, зависящего от метода индекса. См. Подробности в разделе &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;Параметры хранилища индексов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4f0f37a4747ead833ac927d954e2f698dfd533d" translate="yes" xml:space="preserve">
          <source>The name of an index.</source>
          <target state="translated">Название индекса.</target>
        </trans-unit>
        <trans-unit id="905bf1ebfe51e20690887bb37e5649f46c622ebf" translate="yes" xml:space="preserve">
          <source>The name of an installed extension.</source>
          <target state="translated">Имя установленного расширения.</target>
        </trans-unit>
        <trans-unit id="31791bd4a497bca0b376ada0235a5c621eadda59" translate="yes" xml:space="preserve">
          <source>The name of an object to be added to or removed from the extension. Names of tables, aggregates, domains, foreign tables, functions, operators, operator classes, operator families, procedures, routines, sequences, text search objects, types, and views can be schema-qualified.</source>
          <target state="translated">Имя объекта,который будет добавлен или удален из расширения.Имена таблиц,агрегатов,доменов,посторонних таблиц,функций,операторов,классов операторов,семейств операторов,процедур,процедур,последовательностей,объектов текстового поиска,типов и представлений могут быть схемными.</target>
        </trans-unit>
        <trans-unit id="649c7c5351f25263eb73a851a860d7f29c995641" translate="yes" xml:space="preserve">
          <source>The name of an open cursor to close.</source>
          <target state="translated">Название открытого курсора для закрытия.</target>
        </trans-unit>
        <trans-unit id="cd55222991d683c14fbae3099b3d272c1928bd18" translate="yes" xml:space="preserve">
          <source>The name of an operator class parameter. See below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b92d299708f5e6b56970b9d25ff76f34c8756f5" translate="yes" xml:space="preserve">
          <source>The name of an operator class. See below for details.</source>
          <target state="translated">Название класса оператора.Подробности см.ниже.</target>
        </trans-unit>
        <trans-unit id="4bf28d916074af135f4ae230a1fccbd417f00476" translate="yes" xml:space="preserve">
          <source>The name of an output column in the &lt;code&gt;RETURNS TABLE&lt;/code&gt; syntax. This is effectively another way of declaring a named &lt;code&gt;OUT&lt;/code&gt; parameter, except that &lt;code&gt;RETURNS TABLE&lt;/code&gt; also implies &lt;code&gt;RETURNS SETOF&lt;/code&gt;.</source>
          <target state="translated">Имя выходного столбца в синтаксисе &lt;code&gt;RETURNS TABLE&lt;/code&gt; . По сути, это еще один способ объявления именованного параметра &lt;code&gt;OUT&lt;/code&gt; , за исключением того, что &lt;code&gt;RETURNS TABLE&lt;/code&gt; также подразумевает &lt;code&gt;RETURNS SETOF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7860b7ca240f288c9e09edb9a6f18857751787c5" translate="yes" xml:space="preserve">
          <source>The name of next WAL segment file should be larger than any WAL segment file name currently existing in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory. These names are also in hexadecimal and have three parts. The first part is the &amp;ldquo;timeline ID&amp;rdquo; and should usually be kept the same. For example, if &lt;code&gt;00000001000000320000004A&lt;/code&gt; is the largest entry in &lt;code&gt;pg_wal&lt;/code&gt;, use &lt;code&gt;-l 00000001000000320000004B&lt;/code&gt; or higher.</source>
          <target state="translated">Имя следующего файла сегмента WAL должно быть больше любого имени файла сегмента WAL, существующего в данный момент в каталоге &lt;code&gt;pg_wal&lt;/code&gt; в каталоге данных. Эти имена также представлены в шестнадцатеричном формате и состоят из трех частей. Первая часть - это &amp;laquo;идентификатор временной шкалы&amp;raquo;, и ее обычно следует оставлять без изменений. Например, если &lt;code&gt;00000001000000320000004A&lt;/code&gt; - самая большая запись в &lt;code&gt;pg_wal&lt;/code&gt; , используйте &lt;code&gt;-l 00000001000000320000004B&lt;/code&gt; или выше.</target>
        </trans-unit>
        <trans-unit id="d8e7a2287904ed813d9d1d342dd594453e6a492a" translate="yes" xml:space="preserve">
          <source>The name of the access method to be created.</source>
          <target state="translated">Имя создаваемого метода доступа.</target>
        </trans-unit>
        <trans-unit id="a1d2d753926a3554219bc61e5340b3472157868a" translate="yes" xml:space="preserve">
          <source>The name of the attribute to add, alter, or drop.</source>
          <target state="translated">Имя атрибута для добавления,изменения или удаления.</target>
        </trans-unit>
        <trans-unit id="5c7d389a37d0c9ede9dd1bea0952aff86a55c92e" translate="yes" xml:space="preserve">
          <source>The name of the canonicalization function for the range type.</source>
          <target state="translated">Название функции канонизации для типа диапазона.</target>
        </trans-unit>
        <trans-unit id="243c7e9e7dd348f6643caec550e3f500eb8cc280" translate="yes" xml:space="preserve">
          <source>The name of the collation to use for the index. By default, the index uses the collation declared for the column to be indexed or the result collation of the expression to be indexed. Indexes with non-default collations can be useful for queries that involve expressions using non-default collations.</source>
          <target state="translated">Название сопоставления для индекса.По умолчанию в индексе используется сопоставление,объявленное для индексируемого столбца,или сопоставление результатов выражения,подлежащего индексированию.Индексы с не по умолчанию могут быть полезны для запросов,в которых используются выражения,использующие не по умолчанию.</target>
        </trans-unit>
        <trans-unit id="77f1c321d574cf562cfe00eca4e768698060a618" translate="yes" xml:space="preserve">
          <source>The name of the collation. The collation name can be schema-qualified.</source>
          <target state="translated">Название сопоставления.Название сопоставления может быть схематичным.</target>
        </trans-unit>
        <trans-unit id="ceb886814d1ec273ae0613d250c7095ff800d469" translate="yes" xml:space="preserve">
          <source>The name of the collation. The collation name can be schema-qualified. If it is not, the collation is defined in the current schema. The collation name must be unique within that schema. (The system catalogs can contain collations with the same name for other encodings, but these are ignored if the database encoding does not match.)</source>
          <target state="translated">Название сопоставления.Название сопоставления может быть схематичным.Если это не так,то сопоставление определяется в текущей схеме.Имя объединения должно быть уникальным в этой схеме.(Системные каталоги могут содержать сопоставления с одинаковым именем для других кодировок,но они игнорируются,если кодировка БД не совпадает).</target>
        </trans-unit>
        <trans-unit id="9f63d4696a4bbfab6f19c7c4c3231039f6a920b8" translate="yes" xml:space="preserve">
          <source>The name of the conversion. The conversion name can be schema-qualified.</source>
          <target state="translated">Название преобразования.Имя преобразования может быть схожим.</target>
        </trans-unit>
        <trans-unit id="0a0e15e0eec7998677fce35d40af5b0838f2cb6f" translate="yes" xml:space="preserve">
          <source>The name of the conversion. The conversion name can be schema-qualified. If it is not, the conversion is defined in the current schema. The conversion name must be unique within a schema.</source>
          <target state="translated">Название преобразования.Имя преобразования может быть схожим.Если это не так,то преобразование определяется в текущей схеме.Имя преобразования должно быть уникальным внутри схемы.</target>
        </trans-unit>
        <trans-unit id="c9574a7a1218329dadec3b5ae9047230517d66aa" translate="yes" xml:space="preserve">
          <source>The name of the current database.</source>
          <target state="translated">Имя текущей базы данных.</target>
        </trans-unit>
        <trans-unit id="1d7349ab2501bed854162775079bf683be5a7fac" translate="yes" xml:space="preserve">
          <source>The name of the cursor</source>
          <target state="translated">Имя курсора</target>
        </trans-unit>
        <trans-unit id="b6d5b083913d1c8495981451aeb22d6a26cea7b8" translate="yes" xml:space="preserve">
          <source>The name of the cursor to be created.</source>
          <target state="translated">Имя создаваемого курсора.</target>
        </trans-unit>
        <trans-unit id="88e407c8ddef33e57e58fe4ab21cafbf53e15168" translate="yes" xml:space="preserve">
          <source>The name of the cursor to use in a &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; condition. The row to be deleted is the one most recently fetched from this cursor. The cursor must be a non-grouping query on the &lt;code&gt;DELETE&lt;/code&gt;'s target table. Note that &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; cannot be specified together with a Boolean condition. See &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; for more information about using cursors with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt;.</source>
          <target state="translated">Имя курсора для использования в условии &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; . Удаляемая строка - это последняя строка, выбранная из этого курсора. Курсор должен быть негруппирующим запросом в целевой таблице &lt;code&gt;DELETE&lt;/code&gt; . Обратите внимание, что &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; нельзя указывать вместе с логическим условием. Смотрите &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; для получения дополнительной информации об использовании курсоров с &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38020942de5ae8771a5e3d0b598b6d0ab023caec" translate="yes" xml:space="preserve">
          <source>The name of the cursor to use in a &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; condition. The row to be updated is the one most recently fetched from this cursor. The cursor must be a non-grouping query on the &lt;code&gt;UPDATE&lt;/code&gt;'s target table. Note that &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; cannot be specified together with a Boolean condition. See &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; for more information about using cursors with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt;.</source>
          <target state="translated">Имя курсора для использования в условии &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; . Обновляемая строка - это строка, выбранная из этого курсора последней. Курсор должен быть не группирующим запросом в целевой таблице &lt;code&gt;UPDATE&lt;/code&gt; . Обратите внимание, что &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; нельзя указывать вместе с логическим условием. Смотрите &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; для получения дополнительной информации об использовании курсоров с &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a37403f5a4aea39da3b7fe089d21ee355979a3e1" translate="yes" xml:space="preserve">
          <source>The name of the data type of the transform.</source>
          <target state="translated">Имя типа данных трансформации.</target>
        </trans-unit>
        <trans-unit id="af7361a3be8ca4eab2c0f2265411cfd60f5af420" translate="yes" xml:space="preserve">
          <source>The name of the database the configuration variable should be set in.</source>
          <target state="translated">Имя БД,в которой должна быть установлена конфигурационная переменная.</target>
        </trans-unit>
        <trans-unit id="84b00afcd962f475515c1915126400e90b5a9818" translate="yes" xml:space="preserve">
          <source>The name of the database this slot is associated with, or null. Only logical slots have an associated database.</source>
          <target state="translated">Имя базы данных,с которой связан этот слот,или ноль.Только логические слоты имеют ассоциированную БД.</target>
        </trans-unit>
        <trans-unit id="2a89c928e3a93a0e913b45ef5c9ea96a08977f60" translate="yes" xml:space="preserve">
          <source>The name of the database to remove.</source>
          <target state="translated">Имя базы данных для удаления.</target>
        </trans-unit>
        <trans-unit id="0fd3bf3f6aa3e86ff6150d84d8e17149c266ae35" translate="yes" xml:space="preserve">
          <source>The name of the database whose attributes are to be altered.</source>
          <target state="translated">Имя базы данных,атрибуты которой должны быть изменены.</target>
        </trans-unit>
        <trans-unit id="0944e5dfd14965f192e2a8ef7a09d183046338d3" translate="yes" xml:space="preserve">
          <source>The name of the database you are currently connected to. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">Имя базы данных,к которой вы в данный момент подключены.Оно устанавливается каждый раз при подключении к базе данных (включая запуск программы),но может быть изменено или отменено.</target>
        </trans-unit>
        <trans-unit id="11232ebb2f1cf69c5f3c6cd470c6a4d13d479f8e" translate="yes" xml:space="preserve">
          <source>The name of the element type that the range type will represent ranges of.</source>
          <target state="translated">Имя типа элемента,который будет представлять собой диапазон.</target>
        </trans-unit>
        <trans-unit id="2c439c06e3cc89c7e2b7094efdc072f8eaa5f405" translate="yes" xml:space="preserve">
          <source>The name of the end function for the parser.</source>
          <target state="translated">Название конечной функции для парсера.</target>
        </trans-unit>
        <trans-unit id="4682e028a8481b8dc70802bb5909c69f9733e336" translate="yes" xml:space="preserve">
          <source>The name of the event that triggers a call to the given function. See &lt;a href=&quot;https://www.postgresql.org/docs/12/event-trigger-definition.html&quot;&gt;Section 39.1&lt;/a&gt; for more information on event names.</source>
          <target state="translated">Имя события, запускающего вызов данной функции. См. &lt;a href=&quot;https://www.postgresql.org/docs/12/event-trigger-definition.html&quot;&gt;Раздел 39.1&lt;/a&gt; для получения дополнительной информации об именах событий.</target>
        </trans-unit>
        <trans-unit id="48923e41b7df203b0e79b78492f062da75beedf7" translate="yes" xml:space="preserve">
          <source>The name of the event that triggers a call to the given function. See &lt;a href=&quot;https://www.postgresql.org/docs/13/event-trigger-definition.html&quot;&gt;Section 39.1&lt;/a&gt; for more information on event names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c26a8cf1a6172d4db73edd5254e5a34f8a5967" translate="yes" xml:space="preserve">
          <source>The name of the event trigger to remove.</source>
          <target state="translated">Имя триггера события для удаления.</target>
        </trans-unit>
        <trans-unit id="850574c01fb5268b0342a8b6bb42720569d55e9d" translate="yes" xml:space="preserve">
          <source>The name of the existing operator family to add this operator class to. If not specified, a family named the same as the operator class is used (creating it, if it doesn't already exist).</source>
          <target state="translated">Имя существующего семейства операторов для добавления данного класса операторов.Если не указано,используется семейство,аналогичное классу оператора (создавая его,если его еще нет).</target>
        </trans-unit>
        <trans-unit id="e1cc11f5fc0531b3a520c5755578268d661fb876" translate="yes" xml:space="preserve">
          <source>The name of the extension that the function is to depend on.</source>
          <target state="translated">Имя расширения,от которого должна зависеть функция.</target>
        </trans-unit>
        <trans-unit id="6af23b7fd50d16bb7de156bad92b5bd09f67edbf" translate="yes" xml:space="preserve">
          <source>The name of the extension that the index is to depend on.</source>
          <target state="translated">Имя расширения,от которого будет зависеть индекс.</target>
        </trans-unit>
        <trans-unit id="0076c726a59acb3194ce3e4e3b9519a8daeff897" translate="yes" xml:space="preserve">
          <source>The name of the extension that the materialized view is to depend on (or no longer dependent on, if &lt;code&gt;NO&lt;/code&gt; is specified). A materialized view that's marked as dependent on an extension is automatically dropped when the extension is dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc831ae12120e6fd5fdd21a20fd1a1e7bd573e67" translate="yes" xml:space="preserve">
          <source>The name of the extension that the materialized view is to depend on.</source>
          <target state="translated">Название расширения,от которого будет зависеть материализованное представление.</target>
        </trans-unit>
        <trans-unit id="4f55051df080e15b2a3119833fb2677544739012" translate="yes" xml:space="preserve">
          <source>The name of the extension that the procedure is to depend on.</source>
          <target state="translated">Название расширения,от которого будет зависеть процедура.</target>
        </trans-unit>
        <trans-unit id="eb5ffaeae34b0a924ba5f2135444604598a2a8e1" translate="yes" xml:space="preserve">
          <source>The name of the extension that the trigger is to depend on (or no longer dependent on, if &lt;code&gt;NO&lt;/code&gt; is specified). A trigger that's marked as dependent on an extension is automatically dropped when the extension is dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a35573e050ab73e125502a3b5564abce7fd88f9" translate="yes" xml:space="preserve">
          <source>The name of the extension that the trigger is to depend on.</source>
          <target state="translated">Имя расширения,от которого должен зависеть триггер.</target>
        </trans-unit>
        <trans-unit id="88e9cf7b26c10377ec9b042f69222e5d8682e8ed" translate="yes" xml:space="preserve">
          <source>The name of the extension to be installed. PostgreSQL will create the extension using details from the file &lt;code&gt;SHAREDIR/extension/&lt;/code&gt;&lt;code&gt;extension_name&lt;/code&gt;&lt;code&gt;.control&lt;/code&gt;.</source>
          <target state="translated">Имя устанавливаемого расширения. PostgreSQL создаст расширение, используя данные из файла &lt;code&gt;SHAREDIR/extension/&lt;/code&gt; &lt;code&gt;extension_name&lt;/code&gt; &lt;code&gt;.control&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6fa04f440c0a0fbd9ef5c8562fd34285144f5e9" translate="yes" xml:space="preserve">
          <source>The name of the final function called to compute the aggregate's result after all input rows have been traversed, when using moving-aggregate mode. This works the same as &lt;code&gt;ffunc&lt;/code&gt;, except that its first argument's type is &lt;code&gt;mstate_data_type&lt;/code&gt; and extra dummy arguments are specified by writing &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;. The aggregate result type determined by &lt;code&gt;mffunc&lt;/code&gt; or &lt;code&gt;mstate_data_type&lt;/code&gt; must match that determined by the aggregate's regular implementation.</source>
          <target state="translated">Имя последней функции, вызываемой для вычисления результата агрегирования после обхода всех входных строк при использовании режима подвижного агрегирования. Это работает так же, как &lt;code&gt;ffunc&lt;/code&gt; , за исключением того, что типом его первого аргумента является &lt;code&gt;mstate_data_type&lt;/code&gt; , а дополнительные фиктивные аргументы указываются записью &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt; . Тип результата агрегата, определяемый &lt;code&gt;mffunc&lt;/code&gt; или &lt;code&gt;mstate_data_type&lt;/code&gt; , должен совпадать с типом , определенным обычной реализацией агрегата.</target>
        </trans-unit>
        <trans-unit id="f5f06809f2c728bd2159e0f8d844d66eca27a10c" translate="yes" xml:space="preserve">
          <source>The name of the final function called to compute the aggregate's result after all input rows have been traversed. For a normal aggregate, this function must take a single argument of type &lt;code&gt;state_data_type&lt;/code&gt;. The return data type of the aggregate is defined as the return type of this function. If &lt;code&gt;ffunc&lt;/code&gt; is not specified, then the ending state value is used as the aggregate's result, and the return type is &lt;code&gt;state_data_type&lt;/code&gt;.</source>
          <target state="translated">Имя последней функции, вызываемой для вычисления результата агрегата после обхода всех входных строк. Для обычного агрегата эта функция должна принимать единственный аргумент типа &lt;code&gt;state_data_type&lt;/code&gt; . Тип возвращаемых данных агрегата определяется как тип возвращаемых данных этой функции. Если &lt;code&gt;ffunc&lt;/code&gt; не указан, то в качестве результата агрегата используется значение конечного состояния, а тип возврата - &lt;code&gt;state_data_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72c35b2edf9735176f859431671ff1f17e5d197c" translate="yes" xml:space="preserve">
          <source>The name of the foreign server to be created.</source>
          <target state="translated">Имя иностранного сервера,который будет создан.</target>
        </trans-unit>
        <trans-unit id="c3a096f51b1b0afdadcf653b248a2d3f34aa4744" translate="yes" xml:space="preserve">
          <source>The name of the foreign-data wrapper that manages the server.</source>
          <target state="translated">Имя обертки иностранных данных,которая управляет сервером.</target>
        </trans-unit>
        <trans-unit id="d54745f11f4179244c18fb9a79fb68702588d241" translate="yes" xml:space="preserve">
          <source>The name of the foreign-data wrapper to be created.</source>
          <target state="translated">Название создаваемой оболочки иностранных данных.</target>
        </trans-unit>
        <trans-unit id="1fdbb3b7aa9f05df80cfbaca84874bb5ff3faf75" translate="yes" xml:space="preserve">
          <source>The name of the forward state transition function to be called for each input row in moving-aggregate mode. This is exactly like the regular transition function, except that its first argument and result are of type &lt;code&gt;mstate_data_type&lt;/code&gt;, which might be different from &lt;code&gt;state_data_type&lt;/code&gt;.</source>
          <target state="translated">Имя функции прямого перехода между состояниями, которая будет вызываться для каждой входной строки в режиме подвижного агрегирования. Это в точности похоже на обычную функцию перехода, за исключением того, что ее первый аргумент и результат имеют тип &lt;code&gt;mstate_data_type&lt;/code&gt; , который может отличаться от &lt;code&gt;state_data_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="644a4d91bed7658870a145ab3141d930ef90e912" translate="yes" xml:space="preserve">
          <source>The name of the function for converting the type from the SQL environment to the language. It must take one argument of type &lt;code&gt;internal&lt;/code&gt; and return type &lt;code&gt;internal&lt;/code&gt;. The actual argument will be of the type for the transform, and the function should be coded as if it were. (But it is not allowed to declare an SQL-level function returning &lt;code&gt;internal&lt;/code&gt; without at least one argument of type &lt;code&gt;internal&lt;/code&gt;.) The actual return value will be something specific to the language implementation. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="translated">Имя функции преобразования типа из среды SQL в язык. Он должен принимать один аргумент типа &lt;code&gt;internal&lt;/code&gt; и возвращаемого типа &lt;code&gt;internal&lt;/code&gt; . Фактический аргумент будет иметь тип для преобразования, а функция должна быть закодирована так, как если бы она была. (Но не разрешается объявлять функцию уровня SQL, возвращающую &lt;code&gt;internal&lt;/code&gt; без хотя бы одного аргумента типа &lt;code&gt;internal&lt;/code&gt; .) Фактическое возвращаемое значение будет чем-то специфическим для языковой реализации. Если список аргументов не указан, имя функции должно быть уникальным в своей схеме.</target>
        </trans-unit>
        <trans-unit id="72f3b32f063bc50605b229238d27a5869c6aa7b9" translate="yes" xml:space="preserve">
          <source>The name of the function for converting the type from the language to the SQL environment. It must take one argument of type &lt;code&gt;internal&lt;/code&gt; and return the type that is the type for the transform. The actual argument value will be something specific to the language implementation. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="translated">Имя функции преобразования типа из языка в среду SQL. Он должен принимать один аргумент типа &lt;code&gt;internal&lt;/code&gt; и возвращать тип, являющийся типом для преобразования. Фактическое значение аргумента будет чем-то специфическим для языковой реализации. Если список аргументов не указан, имя функции должно быть уникальным в своей схеме.</target>
        </trans-unit>
        <trans-unit id="67cb877b3731a337b10795d0e7186566d6a3d1e1" translate="yes" xml:space="preserve">
          <source>The name of the get-next-token function for the parser.</source>
          <target state="translated">Имя функции get-next-token для парсера.</target>
        </trans-unit>
        <trans-unit id="6d1ebf156ba07f5a77467c8ec4ff708f33b3fc16" translate="yes" xml:space="preserve">
          <source>The name of the group (role) to modify.</source>
          <target state="translated">Название группы (роли)для изменения.</target>
        </trans-unit>
        <trans-unit id="2ed53b580ba0bc8625e75a9560c3a6e88d077a4d" translate="yes" xml:space="preserve">
          <source>The name of the headline function for the parser (a function that summarizes a set of tokens).</source>
          <target state="translated">Имя функции заголовка для парсера (функция,которая суммирует набор токенов).</target>
        </trans-unit>
        <trans-unit id="a3a747073ce359aa3857b433256c5b13312b5a04" translate="yes" xml:space="preserve">
          <source>The name of the index access method the operator class is for.</source>
          <target state="translated">Имя метода доступа к индексам,для которого предназначен класс оператора.</target>
        </trans-unit>
        <trans-unit id="ed18a236c732efe90dba559278f7adbf5db0ca9c" translate="yes" xml:space="preserve">
          <source>The name of the index access method the operator family is for.</source>
          <target state="translated">Имя метода доступа к индексам,для которого предназначено семейство операторов.</target>
        </trans-unit>
        <trans-unit id="c45cc6bfca0d231f36cbda7b1370cd41ed1d67b6" translate="yes" xml:space="preserve">
          <source>The name of the index method this operator class is for.</source>
          <target state="translated">Имя метода индекса для данного класса операторов.</target>
        </trans-unit>
        <trans-unit id="615794124cec123ffa046fc334d0b7cb274ccdc2" translate="yes" xml:space="preserve">
          <source>The name of the index method this operator family is for.</source>
          <target state="translated">Имя метода индекса для данного семейства операторов.</target>
        </trans-unit>
        <trans-unit id="4bb90538453113f1fb57ae8f2d37c35f322febf6" translate="yes" xml:space="preserve">
          <source>The name of the index method to be used. Choices are &lt;code&gt;btree&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;gist&lt;/code&gt;, &lt;code&gt;spgist&lt;/code&gt;, &lt;code&gt;gin&lt;/code&gt;, and &lt;code&gt;brin&lt;/code&gt;. The default method is &lt;code&gt;btree&lt;/code&gt;.</source>
          <target state="translated">Имя используемого метода индексации. Возможные варианты: &lt;code&gt;btree&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;gist&lt;/code&gt; , &lt;code&gt;spgist&lt;/code&gt; , &lt;code&gt;gin&lt;/code&gt; и &lt;code&gt;brin&lt;/code&gt; . Метод по умолчанию - &lt;code&gt;btree&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb830e2432e53c927391aeee88f93bb4667bcae4" translate="yes" xml:space="preserve">
          <source>The name of the index to be created. No schema name can be included here; the index is always created in the same schema as its parent table. If the name is omitted, PostgreSQL chooses a suitable name based on the parent table's name and the indexed column name(s).</source>
          <target state="translated">Имя создаваемого индекса.Имя схемы здесь не может быть включено;индекс всегда создается в той же схеме,что и его родительская таблица.Если имя опущено,PostgreSQL выбирает подходящее имя на основе имени родительской таблицы и проиндексированного имени столбца (столбцов).</target>
        </trans-unit>
        <trans-unit id="a4663fb986b280170b92707494282c81c2899c4f" translate="yes" xml:space="preserve">
          <source>The name of the init function for the template.</source>
          <target state="translated">Имя функции init для шаблона.</target>
        </trans-unit>
        <trans-unit id="f00fd5139904e6694b429785636163e14a782210" translate="yes" xml:space="preserve">
          <source>The name of the inverse state transition function to be used in moving-aggregate mode. This function has the same argument and result types as &lt;code&gt;msfunc&lt;/code&gt;, but it is used to remove a value from the current aggregate state, rather than add a value to it. The inverse transition function must have the same strictness attribute as the forward state transition function.</source>
          <target state="translated">Имя функции обратного перехода состояния, которая будет использоваться в режиме подвижного агрегата. Эта функция имеет те же аргументы и типы результатов, что и &lt;code&gt;msfunc&lt;/code&gt; , но она используется для удаления значения из текущего агрегированного состояния, а не для добавления к нему значения. Функция обратного перехода должна иметь тот же атрибут строгости, что и функция прямого перехода между состояниями.</target>
        </trans-unit>
        <trans-unit id="3d95c2fd2534c7b2ce3a1746cb2c27650d29fdc4" translate="yes" xml:space="preserve">
          <source>The name of the language of the transform.</source>
          <target state="translated">Название языка трансформации.</target>
        </trans-unit>
        <trans-unit id="26a3e76d4aff5006209caa326a5bf1517ad79006" translate="yes" xml:space="preserve">
          <source>The name of the language that the function is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g. &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="translated">Имя языка, на котором реализована функция. Это может быть &lt;code&gt;sql&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;internal&lt;/code&gt; или имя определяемого пользователем процедурного языка, например &lt;code&gt;plpgsql&lt;/code&gt; . Заключение имени в одинарные кавычки не рекомендуется и требует совпадения регистра.</target>
        </trans-unit>
        <trans-unit id="c42d1caf7aebd169681e8521779ebec6bdd5b337" translate="yes" xml:space="preserve">
          <source>The name of the language that the function is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g., &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5713bc5c339abbdacc15961df416377c21c0e3" translate="yes" xml:space="preserve">
          <source>The name of the language that the procedure is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g. &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="translated">Имя языка, на котором реализована процедура. Это может быть &lt;code&gt;sql&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;internal&lt;/code&gt; или имя определяемого пользователем процедурного языка, например &lt;code&gt;plpgsql&lt;/code&gt; . Заключение имени в одинарные кавычки не рекомендуется и требует совпадения регистра.</target>
        </trans-unit>
        <trans-unit id="6442a7baa7c6ad1af9dfd2863b84c1d799ed57dc" translate="yes" xml:space="preserve">
          <source>The name of the language that the procedure is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g., &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f56142098dd6b61f4dc395fb22e1f6084da31b" translate="yes" xml:space="preserve">
          <source>The name of the lexize function for the template.</source>
          <target state="translated">Название функции лексизации для шаблона.</target>
        </trans-unit>
        <trans-unit id="78bf3c88f1577390b2b7639c878108066bdde80d" translate="yes" xml:space="preserve">
          <source>The name of the lextypes function for the parser (a function that returns information about the set of token types it produces).</source>
          <target state="translated">Имя функции лектипов для парсера (функция,возвращающая информацию о наборе генерируемых ею типов токенов).</target>
        </trans-unit>
        <trans-unit id="99c5d2489b4f3028ca831f4f9b0e7e15704ecdca" translate="yes" xml:space="preserve">
          <source>The name of the new procedural language. The name must be unique among the languages in the database.</source>
          <target state="translated">Название нового процедурного языка.Название должно быть уникальным среди языков в базе данных.</target>
        </trans-unit>
        <trans-unit id="bf36b4ea435ecc1c1aaf6ed21ca9df2c4c0596b3" translate="yes" xml:space="preserve">
          <source>The name of the new publication.</source>
          <target state="translated">Название новой публикации.</target>
        </trans-unit>
        <trans-unit id="dc580686d337370d500fabd6d8d4233f2a645d1a" translate="yes" xml:space="preserve">
          <source>The name of the new role.</source>
          <target state="translated">Название новой роли.</target>
        </trans-unit>
        <trans-unit id="9deb527e5d18a4a607e93b3c59b44924e3848af5" translate="yes" xml:space="preserve">
          <source>The name of the new subscription.</source>
          <target state="translated">Название новой подписки.</target>
        </trans-unit>
        <trans-unit id="84ca9243f0b08a6130478bf4d0fddd3954c72484" translate="yes" xml:space="preserve">
          <source>The name of the object to be commented. Names of tables, aggregates, collations, conversions, domains, foreign tables, functions, indexes, operators, operator classes, operator families, procedures, routines, sequences, statistics, text search objects, types, and views can be schema-qualified. When commenting on a column, &lt;code&gt;relation_name&lt;/code&gt; must refer to a table, view, composite type, or foreign table.</source>
          <target state="translated">Имя комментируемого объекта. Имена таблиц, агрегатов, сопоставлений, преобразований, доменов, сторонних таблиц, функций, индексов, операторов, классов операторов, семейств операторов, процедур, подпрограмм, последовательностей, статистики, объектов текстового поиска, типов и представлений могут быть дополнены схемой. При комментировании столбца &lt;code&gt;relation_name&lt;/code&gt; должно ссылаться на таблицу, представление, составной тип или стороннюю таблицу.</target>
        </trans-unit>
        <trans-unit id="0ad7f76d8fb02cb1c406ee55180e013d61f5632a" translate="yes" xml:space="preserve">
          <source>The name of the object to be labeled. Names of tables, aggregates, domains, foreign tables, functions, procedures, routines, sequences, types, and views can be schema-qualified.</source>
          <target state="translated">Имя объекта,на который будет наклеиваться этикетка.Имена таблиц,агрегатов,доменов,посторонних таблиц,функций,процедур,процедур,последовательностей,типов и представлений могут быть схемными.</target>
        </trans-unit>
        <trans-unit id="d73d0a54fa511d10e86523f09232c08b9e6d5db1" translate="yes" xml:space="preserve">
          <source>The name of the object to which this label applies, as text.</source>
          <target state="translated">Название объекта,к которому применяется эта метка,в виде текста.</target>
        </trans-unit>
        <trans-unit id="42c399b3a656097491cae7892f14f5784153a41c" translate="yes" xml:space="preserve">
          <source>The name of the operator class to be created. The name can be schema-qualified.</source>
          <target state="translated">Имя создаваемого класса оператора.Имя может быть схематичным.</target>
        </trans-unit>
        <trans-unit id="3c9b852f5483728a82051e673011a9205c74fef8" translate="yes" xml:space="preserve">
          <source>The name of the operator family to be created. The name can be schema-qualified.</source>
          <target state="translated">Имя создаваемого семейства операторов.Название может быть схемообразующим.</target>
        </trans-unit>
        <trans-unit id="aa3dee6563b812e00d9ce856987f40752c4ba957" translate="yes" xml:space="preserve">
          <source>The name of the operator to be defined. See above for allowable characters. The name can be schema-qualified, for example &lt;code&gt;CREATE OPERATOR myschema.+ (...)&lt;/code&gt;. If not, then the operator is created in the current schema. Two operators in the same schema can have the same name if they operate on different data types. This is called &lt;em&gt;overloading&lt;/em&gt;.</source>
          <target state="translated">Имя определяемого оператора. См. Допустимые символы выше. Имя может быть &lt;code&gt;CREATE OPERATOR myschema.+ (...)&lt;/code&gt; схемой, например CREATE OPERATOR myschema. + (...) . Если нет, то оператор создается в текущей схеме. Два оператора в одной схеме могут иметь одно и то же имя, если они работают с разными типами данных. Это называется &lt;em&gt;перегрузкой&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="89042cdb5d6d0a5c95dd63eb06cd01f0a55a975c" translate="yes" xml:space="preserve">
          <source>The name of the policy</source>
          <target state="translated">Название политики</target>
        </trans-unit>
        <trans-unit id="b729bdecc076d261a6f2aa96bf01271915d37a2a" translate="yes" xml:space="preserve">
          <source>The name of the policy to be created. This must be distinct from the name of any other policy for the table.</source>
          <target state="translated">Название создаваемой политики.Это должно отличаться от названия любой другой политики для таблицы.</target>
        </trans-unit>
        <trans-unit id="e268e30430f81e017c4a875eccb62cdf9b012871" translate="yes" xml:space="preserve">
          <source>The name of the policy to drop.</source>
          <target state="translated">Название политики,которую нужно бросить.</target>
        </trans-unit>
        <trans-unit id="e49a87c2d393345ad07affbe76b904f4fe401c81" translate="yes" xml:space="preserve">
          <source>The name of the prepared statement to deallocate.</source>
          <target state="translated">Название подготовленного заявления для разбора.</target>
        </trans-unit>
        <trans-unit id="96c3920c719f442187d159c204dd3612ea686ae5" translate="yes" xml:space="preserve">
          <source>The name of the prepared statement to execute.</source>
          <target state="translated">Название подготовленного к исполнению заявления.</target>
        </trans-unit>
        <trans-unit id="655476f7c7223e1c8c574d3f749ecc5208b3f1a9" translate="yes" xml:space="preserve">
          <source>The name of the procedural language the code is written in. If omitted, the default is &lt;code&gt;plpgsql&lt;/code&gt;.</source>
          <target state="translated">Имя процедурного языка, на котором написан код. Если не указано, по умолчанию используется &lt;code&gt;plpgsql&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03668e7125b4437e3ffadf3e4e590be0e7efc658" translate="yes" xml:space="preserve">
          <source>The name of the provider with which this label is to be associated. The named provider must be loaded and must consent to the proposed labeling operation. If exactly one provider is loaded, the provider name may be omitted for brevity.</source>
          <target state="translated">Имя провайдера,с которым будет ассоциирована эта этикетка.Названный провайдер должен быть загружен и должен дать согласие на предлагаемую операцию по маркировке.Если загружен ровно один провайдер,имя провайдера может быть опущено для краткости.</target>
        </trans-unit>
        <trans-unit id="4982a7a5e8149f1e3c35391b81b9f53d77cb4f02" translate="yes" xml:space="preserve">
          <source>The name of the role that will be made the new owner of the affected objects.</source>
          <target state="translated">Название роли,которая станет новым владельцем пораженных объектов.</target>
        </trans-unit>
        <trans-unit id="d91a150acbfef5a5067b673c038cee51df98a783" translate="yes" xml:space="preserve">
          <source>The name of the role to remove.</source>
          <target state="translated">Название роли,которую нужно снять.</target>
        </trans-unit>
        <trans-unit id="f2c76cbbaae9ad7b16ccf9e7e0922d982cd4547e" translate="yes" xml:space="preserve">
          <source>The name of the role whose attributes are to be altered.</source>
          <target state="translated">Название роли,атрибуты которой должны быть изменены.</target>
        </trans-unit>
        <trans-unit id="a2cca4e02caca1d1f07a5556d0d3f7be637865d7" translate="yes" xml:space="preserve">
          <source>The name of the rule to drop.</source>
          <target state="translated">Название правила,которое нужно опустить.</target>
        </trans-unit>
        <trans-unit id="fc701ae189d9b3d813db243f4da26ea0b33711ef" translate="yes" xml:space="preserve">
          <source>The name of the savepoint to destroy.</source>
          <target state="translated">Имя точки сохранения,которую нужно уничтожить.</target>
        </trans-unit>
        <trans-unit id="4816861b05e3da72c531801eafbb94d541e0e94f" translate="yes" xml:space="preserve">
          <source>The name of the schema in which to install the extension's objects, given that the extension allows its contents to be relocated. The named schema must already exist. If not specified, and the extension's control file does not specify a schema either, the current default object creation schema is used.</source>
          <target state="translated">Имя схемы,в которой будут установлены объекты расширения,учитывая,что расширение позволяет перемещать его содержимое.Названная схема должна уже существовать.Если не указано,и управляющий файл расширения также не указывает схему,используется текущая схема создания объектов по умолчанию.</target>
        </trans-unit>
        <trans-unit id="42eda784d25f0da5728fd9204f655f7fcdcb985b" translate="yes" xml:space="preserve">
          <source>The name of the schema to which the table will be moved.</source>
          <target state="translated">Название схемы,на которую будет перемещена таблица.</target>
        </trans-unit>
        <trans-unit id="baf4061d3be604bdc194c1f14606449bf4b0f2d6" translate="yes" xml:space="preserve">
          <source>The name of the shared memory allocation. NULL for unused memory and &lt;code&gt;&amp;lt;anonymous&amp;gt;&lt;/code&gt; for anonymous allocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac04d5a0b8ecbdd03c9da31af0a4b7d10ec89b66" translate="yes" xml:space="preserve">
          <source>The name of the source data type of the cast.</source>
          <target state="translated">Имя типа исходных данных отливки.</target>
        </trans-unit>
        <trans-unit id="2294ddf1df955220bbac238988facccf0c6a0592" translate="yes" xml:space="preserve">
          <source>The name of the specific index, table, or database to be reindexed. Index and table names can be schema-qualified. Presently, &lt;code&gt;REINDEX DATABASE&lt;/code&gt; and &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; can only reindex the current database, so their parameter must match the current database's name.</source>
          <target state="translated">Имя конкретного индекса, таблицы или базы данных, которые нужно переиндексировать. Имена индексов и таблиц могут быть дополнены схемой. В настоящее время &lt;code&gt;REINDEX DATABASE&lt;/code&gt; и &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; могут переиндексировать только текущую базу данных, поэтому их параметр должен соответствовать имени текущей базы данных.</target>
        </trans-unit>
        <trans-unit id="1371535897b887a5106cddf678bff07e0c5f80a9" translate="yes" xml:space="preserve">
          <source>The name of the start function for the parser.</source>
          <target state="translated">Имя функции запуска для парсера.</target>
        </trans-unit>
        <trans-unit id="015f67e7eaa6c3588c5e9952c547a024ac10153d" translate="yes" xml:space="preserve">
          <source>The name of the state transition function to be called for each input row. For a normal &lt;code&gt;N&lt;/code&gt;-argument aggregate function, the &lt;code&gt;sfunc&lt;/code&gt; must take &lt;code&gt;N&lt;/code&gt;+1 arguments, the first being of type &lt;code&gt;state_data_type&lt;/code&gt; and the rest matching the declared input data type(s) of the aggregate. The function must return a value of type &lt;code&gt;state_data_type&lt;/code&gt;. This function takes the current state value and the current input data value(s), and returns the next state value.</source>
          <target state="translated">Имя функции перехода между состояниями, вызываемой для каждой входной строки. Для нормальной агрегатной функции с &lt;code&gt;N&lt;/code&gt; -аргументами функция &lt;code&gt;sfunc&lt;/code&gt; должна принимать &lt;code&gt;N&lt;/code&gt; +1 аргументов, первый из которых имеет тип &lt;code&gt;state_data_type&lt;/code&gt; , а остальные соответствуют объявленному типу (ам) входных данных агрегата. Функция должна возвращать значение типа &lt;code&gt;state_data_type&lt;/code&gt; . Эта функция принимает текущее значение состояния и текущее значение (значения) входных данных и возвращает следующее значение состояния.</target>
        </trans-unit>
        <trans-unit id="98dfcac96a79ab8d2309606485d5d666ca4e2daa" translate="yes" xml:space="preserve">
          <source>The name of the table and column to update</source>
          <target state="translated">Название таблицы и столбца для обновления</target>
        </trans-unit>
        <trans-unit id="86a9a516ee162e483fd6f8fbe8dac2f83cc35633" translate="yes" xml:space="preserve">
          <source>The name of the table on which this trigger acts.</source>
          <target state="translated">Имя таблицы,на которой действует этот триггер.</target>
        </trans-unit>
        <trans-unit id="df029c5f6289a56399018c193966351757b130e4" translate="yes" xml:space="preserve">
          <source>The name of the table to attach as a new partition or to detach from this table.</source>
          <target state="translated">Название таблицы для прикрепления в качестве нового раздела или для отсоединения от этой таблицы.</target>
        </trans-unit>
        <trans-unit id="910f7a94c4794ba13cd804620ae6f535c8697348" translate="yes" xml:space="preserve">
          <source>The name of the tablespace that will be associated with the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the template database's tablespace. This tablespace will be the default tablespace used for objects created in this database. See &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; for more information.</source>
          <target state="translated">Имя табличного пространства, которое будет связано с новой базой данных, или &lt;code&gt;DEFAULT&lt;/code&gt; , чтобы использовать табличное пространство базы данных шаблона. Это табличное пространство будет табличным пространством по умолчанию, используемым для объектов, созданных в этой базе данных. См. &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="2adc75b40aac253d8d3fd83763a5999e795d523d" translate="yes" xml:space="preserve">
          <source>The name of the tablespace to which the table will be moved.</source>
          <target state="translated">Имя табличного пространства,в которое будет перемещена таблица.</target>
        </trans-unit>
        <trans-unit id="ed5faf3ddd011b5c76e052594331ee12feb17ee5" translate="yes" xml:space="preserve">
          <source>The name of the target data type of the cast.</source>
          <target state="translated">Имя типа данных цели для литья.</target>
        </trans-unit>
        <trans-unit id="f5d196df67f8715141577ca0dfa1d0026e0d7817" translate="yes" xml:space="preserve">
          <source>The name of the template from which to create the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the default template (&lt;code&gt;template1&lt;/code&gt;).</source>
          <target state="translated">Имя шаблона, из которого будет создана новая база данных, или &lt;code&gt;DEFAULT&lt;/code&gt; , чтобы использовать шаблон по умолчанию ( &lt;code&gt;template1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="38cd3261917960f8e539d80ae266a773e2ca894a" translate="yes" xml:space="preserve">
          <source>The name of the text search configuration to be created. The name can be schema-qualified.</source>
          <target state="translated">Название создаваемой конфигурации текстового поиска.Название может быть схожим.</target>
        </trans-unit>
        <trans-unit id="7715676ee8a2df410a7d9b5d6a75ed5f4bbb933b" translate="yes" xml:space="preserve">
          <source>The name of the text search dictionary to be created. The name can be schema-qualified.</source>
          <target state="translated">Название создаваемого словаря текстового поиска.Название может быть схематичным.</target>
        </trans-unit>
        <trans-unit id="08a42806dfcb8f125b19f0057086523042a36ad3" translate="yes" xml:space="preserve">
          <source>The name of the text search parser to be created. The name can be schema-qualified.</source>
          <target state="translated">Название создаваемого парсера текстового поиска.Название может быть схематичным.</target>
        </trans-unit>
        <trans-unit id="24ce45ce2160196c06edff30b966c8ad75ac789f" translate="yes" xml:space="preserve">
          <source>The name of the text search parser to use for this configuration.</source>
          <target state="translated">Название парсера текстового поиска для данной конфигурации.</target>
        </trans-unit>
        <trans-unit id="84cb2dc1f232e52ae9a92c0bb4186a0059e53aa7" translate="yes" xml:space="preserve">
          <source>The name of the text search template that will define the basic behavior of this dictionary.</source>
          <target state="translated">Название шаблона текстового поиска,который определит основное поведение этого словаря.</target>
        </trans-unit>
        <trans-unit id="1584a807877a42990d603d823d759977f3901ddc" translate="yes" xml:space="preserve">
          <source>The name of the text search template to be created. The name can be schema-qualified.</source>
          <target state="translated">Название создаваемого текстового шаблона поиска.Название может быть схожим.</target>
        </trans-unit>
        <trans-unit id="d0987d8df78c216eed09875fd5ebec69f27a40ed" translate="yes" xml:space="preserve">
          <source>The name of the trigger to remove.</source>
          <target state="translated">Имя спускового крючка,который нужно снять.</target>
        </trans-unit>
        <trans-unit id="afd08ce0efd0e1d1a3450afd63d3251269afcb61" translate="yes" xml:space="preserve">
          <source>The name of the user who will own the tablespace. If omitted, defaults to the user executing the command. Only superusers can create tablespaces, but they can assign ownership of tablespaces to non-superusers.</source>
          <target state="translated">Имя пользователя,который будет владеть табличным пространством.Если опущено,по умолчанию это имя будет присвоено пользователю,выполняющему команду.Только суперпользователи могут создавать табличные пространства,но они могут назначать владельцев табличных пространств не суперпользователям.</target>
        </trans-unit>
        <trans-unit id="1c1d8e2ccb4524cb644f6e39612aee840de9a90d" translate="yes" xml:space="preserve">
          <source>The name or IP addresses of the RADIUS servers to connect to. This parameter is required.</source>
          <target state="translated">Имя или IP-адреса серверов RADIUS для подключения.Этот параметр является обязательным.</target>
        </trans-unit>
        <trans-unit id="21389222271889edde6e7b3bd3c9fdd837bca670" translate="yes" xml:space="preserve">
          <source>The name parameter will be MD5-hashed, so the cleartext cannot be derived from the generated UUID. The generation of UUIDs by this method has no random or environment-dependent element and is therefore reproducible.</source>
          <target state="translated">Параметр name будет иметь MD5-хэширование,поэтому чистый текст не может быть получен из сгенерированного UUID.Генерация UUID этим методом не имеет случайного или зависящего от среды элемента и поэтому воспроизводима.</target>
        </trans-unit>
        <trans-unit id="ee74a07e23c9dea72df5a27b777fb65b403c0393" translate="yes" xml:space="preserve">
          <source>The name stems from the fact that this table should not be readable by the public since it contains passwords. &lt;a href=&quot;view-pg-user&quot;&gt;&lt;code&gt;pg_user&lt;/code&gt;&lt;/a&gt; is a publicly readable view on &lt;code&gt;pg_shadow&lt;/code&gt; that blanks out the password field.</source>
          <target state="translated">Название связано с тем, что эта таблица не должна быть доступна для чтения публике, поскольку она содержит пароли. &lt;a href=&quot;view-pg-user&quot;&gt; &lt;code&gt;pg_user&lt;/code&gt; &lt;/a&gt; - это общедоступное представление &lt;code&gt;pg_shadow&lt;/code&gt; ,в котором отсутствует поле пароля.</target>
        </trans-unit>
        <trans-unit id="5d07e8a1b061fb282161f125ed44c357f0d17c75" translate="yes" xml:space="preserve">
          <source>The name to give the new trigger. This must be distinct from the name of any other trigger for the same table. The name cannot be schema-qualified &amp;mdash; the trigger inherits the schema of its table. For a constraint trigger, this is also the name to use when modifying the trigger's behavior using &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;.</source>
          <target state="translated">Имя для нового триггера. Это должно отличаться от имени любого другого триггера для той же таблицы. Имя не может быть дополнено схемой - триггер наследует схему своей таблицы. Для триггера ограничения это также имя, которое следует использовать при изменении поведения триггера с помощью &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b32b1efee504dab33e5254f802082429e271272" translate="yes" xml:space="preserve">
          <source>The name to give the new trigger. This name must be unique within the database.</source>
          <target state="translated">Имя,чтобы дать новый спусковой крючок.Это имя должно быть уникальным в базе данных.</target>
        </trans-unit>
        <trans-unit id="11fed6031dec77608082f3fa5b2080d3486c35aa" translate="yes" xml:space="preserve">
          <source>The name to give to the new savepoint.</source>
          <target state="translated">Имя,которое нужно дать новой точке сохранения.</target>
        </trans-unit>
        <trans-unit id="cf734951b344df7b211da487949af76d60fe726b" translate="yes" xml:space="preserve">
          <source>The names of opclasses and opfamilies are only unique within an access method, so they are represented by &lt;code&gt;access_method_name&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;object_name&lt;/code&gt;.</source>
          <target state="translated">Имена классов операций и семейств операций уникальны только в рамках метода доступа, поэтому они представлены как &lt;code&gt;access_method_name&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;object_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d60acc58684395b40a907774a02224d52b1340e7" translate="yes" xml:space="preserve">
          <source>The naming of output columns here is different from that done in the &lt;code&gt;FROM&lt;/code&gt; clause (see &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;Section 7.2.1.2&lt;/a&gt;). It is possible to rename the same column twice, but the name assigned in the select list is the one that will be passed on.</source>
          <target state="translated">Именование выходных столбцов здесь отличается от того, что сделано в предложении &lt;code&gt;FROM&lt;/code&gt; (см. &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;Раздел 7.2.1.2&lt;/a&gt; ). Можно дважды переименовать один и тот же столбец, но имя, присвоенное в списке выбора, будет тем, которое будет передано.</target>
        </trans-unit>
        <trans-unit id="8c0fc2cb480be9bb9c51a4bc9a223616db655fd1" translate="yes" xml:space="preserve">
          <source>The negator of this operator.</source>
          <target state="translated">Отрицатель этого оператора.</target>
        </trans-unit>
        <trans-unit id="c48796461ad5a772c7e7652201b09a6a57e675ec" translate="yes" xml:space="preserve">
          <source>The new column is initially filled with whatever default value is given (null if you don't specify a &lt;code&gt;DEFAULT&lt;/code&gt; clause).</source>
          <target state="translated">Новый столбец изначально заполняется любым заданным значением по умолчанию (null, если вы не укажете предложение &lt;code&gt;DEFAULT&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="99a5a709438ce00d416364163ad8901072e9ceb4" translate="yes" xml:space="preserve">
          <source>The new comment, written as a string literal; or &lt;code&gt;NULL&lt;/code&gt; to drop the comment.</source>
          <target state="translated">Новый комментарий в виде строкового литерала; или &lt;code&gt;NULL&lt;/code&gt; , чтобы оставить комментарий.</target>
        </trans-unit>
        <trans-unit id="91d67a443bb1c7292a967c48bc783941c67a9238" translate="yes" xml:space="preserve">
          <source>The new connection can re-use connection parameters from the previous connection; not only database name, user, host, and port, but other settings such as &lt;code&gt;sslmode&lt;/code&gt;. By default, parameters are re-used in the positional syntax, but not when a &lt;code&gt;conninfo&lt;/code&gt; string is given. Passing a first argument of &lt;code&gt;-reuse-previous=on&lt;/code&gt; or &lt;code&gt;-reuse-previous=off&lt;/code&gt; overrides that default. If parameters are re-used, then any parameter not explicitly specified as a positional parameter or in the &lt;code&gt;conninfo&lt;/code&gt; string is taken from the existing connection's parameters. An exception is that if the &lt;code&gt;host&lt;/code&gt; setting is changed from its previous value using the positional syntax, any &lt;code&gt;hostaddr&lt;/code&gt; setting present in the existing connection's parameters is dropped. When the command neither specifies nor reuses a particular parameter, the libpq default is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510132e01b735c3f8d5397d2880131961e5b0f83" translate="yes" xml:space="preserve">
          <source>The new contents of the query buffer are then re-parsed according to the normal rules of psql, treating the whole buffer as a single line. Any complete queries are immediately executed; that is, if the query buffer contains or ends with a semicolon, everything up to that point is executed and removed from the query buffer. Whatever remains in the query buffer is redisplayed. Type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel it by clearing the query buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0eef4b2f503cdd8ca575c4d5c2db5edd06b1406" translate="yes" xml:space="preserve">
          <source>The new contents of the query buffer are then re-parsed according to the normal rules of psql, treating the whole buffer as a single line. Any complete queries are immediately executed; that is, if the query buffer contains or ends with a semicolon, everything up to that point is executed. Whatever remains will wait in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel it by clearing the query buffer. Treating the buffer as a single line primarily affects meta-commands: whatever is in the buffer after a meta-command will be taken as argument(s) to the meta-command, even if it spans multiple lines. (Thus you cannot make meta-command-using scripts this way. Use &lt;code&gt;\i&lt;/code&gt; for that.)</source>
          <target state="translated">Новое содержимое буфера запроса затем повторно анализируется в соответствии с обычными правилами psql, обрабатывая весь буфер как одну строку. Любые полные запросы выполняются немедленно; то есть, если буфер запроса содержит или заканчивается точкой с запятой, выполняется все до этого момента. Все, что останется, будет ждать в буфере запроса; введите точку с запятой или &lt;code&gt;\g&lt;/code&gt; чтобы отправить его, или &lt;code&gt;\r&lt;/code&gt; чтобы отменить его, очистив буфер запроса. Обработка буфера как одной строки в первую очередь влияет на метакоманды: все, что находится в буфере после метакоманды, будет приниматься в качестве аргумента (ов) метакоманды, даже если он занимает несколько строк. (Таким образом, вы не можете создавать сценарии с использованием метакоманд таким образом. Используйте для этого &lt;code&gt;\i&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="8c2269882cf52ae9f068a61edc3b778c3a536ff9" translate="yes" xml:space="preserve">
          <source>The new declaration of the tables would look like this:</source>
          <target state="translated">Новая декларация таблиц будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="abb08cd78d70403e2ed01ba829b0b0e107ad79e1" translate="yes" xml:space="preserve">
          <source>The new default tablespace of the database.</source>
          <target state="translated">Новое табличное пространство БД по умолчанию.</target>
        </trans-unit>
        <trans-unit id="bd696aa29e06c8bdaa37006c64334315b20f98b5" translate="yes" xml:space="preserve">
          <source>The new name for the constraint.</source>
          <target state="translated">Новое название для ограничения.</target>
        </trans-unit>
        <trans-unit id="1897f67b69c5b7376acb8d806a5382da72697a70" translate="yes" xml:space="preserve">
          <source>The new name for the domain.</source>
          <target state="translated">Новое имя для домена.</target>
        </trans-unit>
        <trans-unit id="212f3ea5ee1a7012ae1ea00ecf4feddc77a325c7" translate="yes" xml:space="preserve">
          <source>The new name for the foreign server.</source>
          <target state="translated">Новое имя для иностранного сервера.</target>
        </trans-unit>
        <trans-unit id="10044e9774ec8f7e4eeef4126404d9a4c8740bba" translate="yes" xml:space="preserve">
          <source>The new name for the foreign-data wrapper.</source>
          <target state="translated">Новое название для обертки иностранных данных.</target>
        </trans-unit>
        <trans-unit id="c11d926987759462d0f175b4415bf3358d9ff337" translate="yes" xml:space="preserve">
          <source>The new name for the index.</source>
          <target state="translated">Новое название индекса.</target>
        </trans-unit>
        <trans-unit id="33305417939d3b3756d6c5255331fe9d857743c1" translate="yes" xml:space="preserve">
          <source>The new name for the materialized view.</source>
          <target state="translated">Новое название для материализованного вида.</target>
        </trans-unit>
        <trans-unit id="d0bd51a33ddf1dfa219e2e91d0e8c933e6563371" translate="yes" xml:space="preserve">
          <source>The new name for the policy.</source>
          <target state="translated">Новое название политики.</target>
        </trans-unit>
        <trans-unit id="20931af42c3c5e46457e70a88b633cec676d6b34" translate="yes" xml:space="preserve">
          <source>The new name for the publication.</source>
          <target state="translated">Новое название публикации.</target>
        </trans-unit>
        <trans-unit id="afd5b43d5185c06c93949d1324710b679e0f98bd" translate="yes" xml:space="preserve">
          <source>The new name for the rule.</source>
          <target state="translated">Новое название для правила.</target>
        </trans-unit>
        <trans-unit id="b48d77b2ef95f7c457090bcbbe943d0c70311b15" translate="yes" xml:space="preserve">
          <source>The new name for the sequence.</source>
          <target state="translated">Новое имя последовательности.</target>
        </trans-unit>
        <trans-unit id="fc2f67f3244cee265dae6b633cc864544be564aa" translate="yes" xml:space="preserve">
          <source>The new name for the statistics object.</source>
          <target state="translated">Новое имя для объекта статистики.</target>
        </trans-unit>
        <trans-unit id="5e567bc00743ec90ea48cd87ca4d4d39aaaf2a0e" translate="yes" xml:space="preserve">
          <source>The new name for the subscription.</source>
          <target state="translated">Новое имя для подписки.</target>
        </trans-unit>
        <trans-unit id="bb15ea9a2978ce58ebb2c54bd4908c64b61e3ec5" translate="yes" xml:space="preserve">
          <source>The new name for the trigger.</source>
          <target state="translated">Новое имя для спускового крючка.</target>
        </trans-unit>
        <trans-unit id="db155d6348c19b7d3227f389aca4111ed1c5bd26" translate="yes" xml:space="preserve">
          <source>The new name for the type.</source>
          <target state="translated">Новое имя для типа.</target>
        </trans-unit>
        <trans-unit id="c523989c2e7068afb2501bed469e5428f5fdb7a8" translate="yes" xml:space="preserve">
          <source>The new name for the view.</source>
          <target state="translated">Новое название вида.</target>
        </trans-unit>
        <trans-unit id="f2b9a6bf2f60ce509d60ec6a402dbd4fb867b9c2" translate="yes" xml:space="preserve">
          <source>The new name of the aggregate function.</source>
          <target state="translated">Новое название агрегатной функции.</target>
        </trans-unit>
        <trans-unit id="aedc4948fc467788ca8aa2ca7751c93796b91571" translate="yes" xml:space="preserve">
          <source>The new name of the attribute to be renamed.</source>
          <target state="translated">Новое имя переименовываемого атрибута.</target>
        </trans-unit>
        <trans-unit id="e113491ed22e052f8e080471ba08c58dedb8ea64" translate="yes" xml:space="preserve">
          <source>The new name of the collation.</source>
          <target state="translated">Новое название объединения.</target>
        </trans-unit>
        <trans-unit id="4c4b7b49d6b58b2034ea06105277cd50556d40cb" translate="yes" xml:space="preserve">
          <source>The new name of the conversion.</source>
          <target state="translated">Новое название преобразования.</target>
        </trans-unit>
        <trans-unit id="7bd49806ce97a6cf0ae2db0f7447c28e5ce8134f" translate="yes" xml:space="preserve">
          <source>The new name of the database.</source>
          <target state="translated">Новое название базы данных.</target>
        </trans-unit>
        <trans-unit id="75a4aa01c626eb3410b405c18307300931670062" translate="yes" xml:space="preserve">
          <source>The new name of the event trigger.</source>
          <target state="translated">Новое имя триггера события.</target>
        </trans-unit>
        <trans-unit id="e4d75585a773a6cebff31b74551567f8918ab64f" translate="yes" xml:space="preserve">
          <source>The new name of the function.</source>
          <target state="translated">Новое название функции.</target>
        </trans-unit>
        <trans-unit id="2911d96c910b5a17b53eadc422fecbb845a71e4b" translate="yes" xml:space="preserve">
          <source>The new name of the group.</source>
          <target state="translated">Новое название группы.</target>
        </trans-unit>
        <trans-unit id="01ed3bb6171bf404a649ad2b2a5598d4f2218b1d" translate="yes" xml:space="preserve">
          <source>The new name of the language</source>
          <target state="translated">Новое название языка</target>
        </trans-unit>
        <trans-unit id="5629a006f70e9712f7f3f90081ef5ec794958fe9" translate="yes" xml:space="preserve">
          <source>The new name of the operator class.</source>
          <target state="translated">Новое название класса оператора.</target>
        </trans-unit>
        <trans-unit id="cac8082223d146caa1279e011dcbd9499e966dea" translate="yes" xml:space="preserve">
          <source>The new name of the operator family.</source>
          <target state="translated">Новое имя семьи операторов.</target>
        </trans-unit>
        <trans-unit id="b633cb5bdc25233c7a8bdbb49f3cdbe73d120c26" translate="yes" xml:space="preserve">
          <source>The new name of the procedure.</source>
          <target state="translated">Новое название процедуры.</target>
        </trans-unit>
        <trans-unit id="3a9dddb1e76ff061e88bc3524aee453d2bee494e" translate="yes" xml:space="preserve">
          <source>The new name of the role.</source>
          <target state="translated">Новое название роли.</target>
        </trans-unit>
        <trans-unit id="2cf77fbb7b0d27045bc13b02630747a959116461" translate="yes" xml:space="preserve">
          <source>The new name of the schema. The new name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system schemas.</source>
          <target state="translated">Новое имя схемы. Новое имя не может начинаться с &lt;code&gt;pg_&lt;/code&gt; , так как такие имена зарезервированы для системных схем.</target>
        </trans-unit>
        <trans-unit id="a8efb3edcac41dbb05c4e401ddd6f8995c994227" translate="yes" xml:space="preserve">
          <source>The new name of the tablespace. The new name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system tablespaces.</source>
          <target state="translated">Новое имя табличного пространства. Новое имя не может начинаться с &lt;code&gt;pg_&lt;/code&gt; , поскольку такие имена зарезервированы для системных табличных пространств.</target>
        </trans-unit>
        <trans-unit id="5bc002f16673653b0690b28fc66ef20f059c3d17" translate="yes" xml:space="preserve">
          <source>The new name of the text search configuration.</source>
          <target state="translated">Новое название конфигурации текстового поиска.</target>
        </trans-unit>
        <trans-unit id="61d4e96018e9afca4b18c94ddcebcfce618c7e91" translate="yes" xml:space="preserve">
          <source>The new name of the text search dictionary.</source>
          <target state="translated">Новое название словаря для текстового поиска.</target>
        </trans-unit>
        <trans-unit id="b0ee20d36931a187480bdf33645d746804cd8021" translate="yes" xml:space="preserve">
          <source>The new name of the text search parser.</source>
          <target state="translated">Новое название парсера текстового поиска.</target>
        </trans-unit>
        <trans-unit id="1aa4447ea683fc5f23d92a99564476e94e7ba4f8" translate="yes" xml:space="preserve">
          <source>The new name of the text search template.</source>
          <target state="translated">Новое название шаблона текстового поиска.</target>
        </trans-unit>
        <trans-unit id="1cf431c1643a8759a28879f52b1cc3af8c233902" translate="yes" xml:space="preserve">
          <source>The new operator family is initially empty. It should be populated by issuing subsequent &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; commands to add contained operator classes, and optionally &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; commands to add &amp;ldquo;loose&amp;rdquo; operators and their corresponding support functions.</source>
          <target state="translated">Новое семейство операторов изначально пусто. Его следует заполнять путем выполнения последующих команд &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; для добавления содержащихся классов операторов и, при необходимости, команд &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; для добавления &amp;laquo;свободных&amp;raquo; операторов и соответствующих им вспомогательных функций.</target>
        </trans-unit>
        <trans-unit id="f4c637105948973c0a153e08837179c7cca26481" translate="yes" xml:space="preserve">
          <source>The new owner of the aggregate function.</source>
          <target state="translated">Новый владелец совокупной функции.</target>
        </trans-unit>
        <trans-unit id="6e427a5a254b743496752784773d8f681fc927a5" translate="yes" xml:space="preserve">
          <source>The new owner of the collation.</source>
          <target state="translated">Новый владелец коллаборации.</target>
        </trans-unit>
        <trans-unit id="696c05a86f35e15f1b9049294a231e9c92db726b" translate="yes" xml:space="preserve">
          <source>The new owner of the conversion.</source>
          <target state="translated">Новый владелец конверсии.</target>
        </trans-unit>
        <trans-unit id="8c3476b50bc477a63585319a4ee66bd132d319a7" translate="yes" xml:space="preserve">
          <source>The new owner of the database.</source>
          <target state="translated">Новый владелец базы данных.</target>
        </trans-unit>
        <trans-unit id="d33f9460834c9ae8c6bbf2129c64d4ae9c681396" translate="yes" xml:space="preserve">
          <source>The new owner of the function. Note that if the function is marked &lt;code&gt;SECURITY DEFINER&lt;/code&gt;, it will subsequently execute as the new owner.</source>
          <target state="translated">Новый владелец функции. Обратите внимание, что если функция помечена как &lt;code&gt;SECURITY DEFINER&lt;/code&gt; , она впоследствии будет выполняться как новый владелец.</target>
        </trans-unit>
        <trans-unit id="df4e6318da1bb722216c2b84ac2c4e660006a7bf" translate="yes" xml:space="preserve">
          <source>The new owner of the language</source>
          <target state="translated">Новый владелец языка</target>
        </trans-unit>
        <trans-unit id="f528312a4f330c09f0db9a04fb7594d8a6881296" translate="yes" xml:space="preserve">
          <source>The new owner of the large object</source>
          <target state="translated">Новый владелец крупного объекта</target>
        </trans-unit>
        <trans-unit id="042ac141d75c40bbad49229676115d2c3f46dc44" translate="yes" xml:space="preserve">
          <source>The new owner of the operator class.</source>
          <target state="translated">Новый владелец операторского класса.</target>
        </trans-unit>
        <trans-unit id="690e510771eb7df59bdf5e81e98ce1c088ae0a0a" translate="yes" xml:space="preserve">
          <source>The new owner of the operator family.</source>
          <target state="translated">Новый владелец семьи операторов.</target>
        </trans-unit>
        <trans-unit id="9786082232a6fabf8fef79154a67d7d246e8ac12" translate="yes" xml:space="preserve">
          <source>The new owner of the operator.</source>
          <target state="translated">Новый владелец оператора.</target>
        </trans-unit>
        <trans-unit id="3597f21e2766a9a6fcb13ac8067e53ff7ef13d45" translate="yes" xml:space="preserve">
          <source>The new owner of the procedure. Note that if the procedure is marked &lt;code&gt;SECURITY DEFINER&lt;/code&gt;, it will subsequently execute as the new owner.</source>
          <target state="translated">Новый владелец процедуры. Обратите внимание, что если процедура помечена как &lt;code&gt;SECURITY DEFINER&lt;/code&gt; , она впоследствии будет выполняться как новый владелец.</target>
        </trans-unit>
        <trans-unit id="69d41d917f1d5469eff45e378f228e62ac815b74" translate="yes" xml:space="preserve">
          <source>The new owner of the schema.</source>
          <target state="translated">Новый владелец схемы.</target>
        </trans-unit>
        <trans-unit id="db70ea94e40096f71c45b13de8eea08d1af85b1d" translate="yes" xml:space="preserve">
          <source>The new owner of the tablespace.</source>
          <target state="translated">Новый владелец столового пространства.</target>
        </trans-unit>
        <trans-unit id="e5c9278160aed343baae5e000f62f65dff7fc448" translate="yes" xml:space="preserve">
          <source>The new owner of the text search configuration.</source>
          <target state="translated">Новый владелец конфигурации текстового поиска.</target>
        </trans-unit>
        <trans-unit id="aa73a2e5e347d201842eebdd89d547d089c6c8be" translate="yes" xml:space="preserve">
          <source>The new owner of the text search dictionary.</source>
          <target state="translated">Новый владелец словаря текстового поиска.</target>
        </trans-unit>
        <trans-unit id="edb8e480bb54a06edf443d08eda6114457bafd19" translate="yes" xml:space="preserve">
          <source>The new role will automatically inherit privileges of roles it is a member of. This is the default.</source>
          <target state="translated">Новая роль автоматически наследует привилегии ролей,в которых она участвует.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="9a32a2a68f765041e1e9d89874f5db158ceae654" translate="yes" xml:space="preserve">
          <source>The new role will not automatically inherit privileges of roles it is a member of.</source>
          <target state="translated">Новая роль не будет автоматически наследовать привилегии ролей,в которых она участвует.</target>
        </trans-unit>
        <trans-unit id="9261c055206b3b24159966bd5e49b879f7e13689" translate="yes" xml:space="preserve">
          <source>The new schema for the aggregate function.</source>
          <target state="translated">Новая схема для агрегатной функции.</target>
        </trans-unit>
        <trans-unit id="4dc45ae2528649758dd2b3da76e3b1bde5aae0c1" translate="yes" xml:space="preserve">
          <source>The new schema for the collation.</source>
          <target state="translated">Новая схема сопоставления.</target>
        </trans-unit>
        <trans-unit id="fa5c853ff4ce0885678abb91184961581c7c86e8" translate="yes" xml:space="preserve">
          <source>The new schema for the conversion.</source>
          <target state="translated">Новая схема преобразования.</target>
        </trans-unit>
        <trans-unit id="94f971cb399c2e27724257d01667804b12528aea" translate="yes" xml:space="preserve">
          <source>The new schema for the domain.</source>
          <target state="translated">Новая схема для домена.</target>
        </trans-unit>
        <trans-unit id="ffcd3334bad17af07bda4b5f314843b54c035a01" translate="yes" xml:space="preserve">
          <source>The new schema for the extension.</source>
          <target state="translated">Новая схема расширения.</target>
        </trans-unit>
        <trans-unit id="892a2ed0bb951cfb6e7f263bc8da7d70f88d788a" translate="yes" xml:space="preserve">
          <source>The new schema for the function.</source>
          <target state="translated">Новая схема функции.</target>
        </trans-unit>
        <trans-unit id="f75cbb7e0424884c76eaf66a88fc00d8e62673a7" translate="yes" xml:space="preserve">
          <source>The new schema for the materialized view.</source>
          <target state="translated">Новая схема для материализованного вида.</target>
        </trans-unit>
        <trans-unit id="f6752ffe51d8560507628fd3fa3becd8329772f1" translate="yes" xml:space="preserve">
          <source>The new schema for the operator class.</source>
          <target state="translated">Новая схема для класса операторов.</target>
        </trans-unit>
        <trans-unit id="91c91f016c0e190b6282eebefe2a49a89e2c716c" translate="yes" xml:space="preserve">
          <source>The new schema for the operator family.</source>
          <target state="translated">Новая схема для семейства операторов.</target>
        </trans-unit>
        <trans-unit id="a28f607105e64dc0674bab3c516a94057914430b" translate="yes" xml:space="preserve">
          <source>The new schema for the operator.</source>
          <target state="translated">Новая схема для оператора.</target>
        </trans-unit>
        <trans-unit id="5b76b1ebef9ac79184347fc03689e8ad83b75ad3" translate="yes" xml:space="preserve">
          <source>The new schema for the procedure.</source>
          <target state="translated">Новая схема процедуры.</target>
        </trans-unit>
        <trans-unit id="e1ef41d9bc55a3a445826b83357df117508b85c8" translate="yes" xml:space="preserve">
          <source>The new schema for the sequence.</source>
          <target state="translated">Новая схема последовательности.</target>
        </trans-unit>
        <trans-unit id="051afa3d07978a274fc9c7a36c2e3cc09b60a787" translate="yes" xml:space="preserve">
          <source>The new schema for the statistics object.</source>
          <target state="translated">Новая схема для объекта статистики.</target>
        </trans-unit>
        <trans-unit id="b33b53d7a11df09b3be2d48051dd92657dd5246a" translate="yes" xml:space="preserve">
          <source>The new schema for the text search configuration.</source>
          <target state="translated">Новая схема настройки текстового поиска.</target>
        </trans-unit>
        <trans-unit id="ef261ca400ba6b8c404f8ae1051c9ddf74db7470" translate="yes" xml:space="preserve">
          <source>The new schema for the text search dictionary.</source>
          <target state="translated">Новая схема словаря для текстового поиска.</target>
        </trans-unit>
        <trans-unit id="6ee901249db3b5665acf6e566a8134c2dd5623bb" translate="yes" xml:space="preserve">
          <source>The new schema for the text search parser.</source>
          <target state="translated">Новая схема для парсера текстового поиска.</target>
        </trans-unit>
        <trans-unit id="0a8618e7f7d0e904983cf7fb40badda672a564d7" translate="yes" xml:space="preserve">
          <source>The new schema for the text search template.</source>
          <target state="translated">Новая схема для шаблона текстового поиска.</target>
        </trans-unit>
        <trans-unit id="2dae7eeaa9912635729239a107cfdb2251e22f7c" translate="yes" xml:space="preserve">
          <source>The new schema for the type.</source>
          <target state="translated">Новая схема для этого типа.</target>
        </trans-unit>
        <trans-unit id="9da42308b2dd3741e38d355739234da9161529c8" translate="yes" xml:space="preserve">
          <source>The new schema for the view.</source>
          <target state="translated">Новая схема вида.</target>
        </trans-unit>
        <trans-unit id="10efc2ba412402b38cf8661a03b9c2fa3f9344e1" translate="yes" xml:space="preserve">
          <source>The new security label, written as a string literal; or &lt;code&gt;NULL&lt;/code&gt; to drop the security label.</source>
          <target state="translated">Новая метка защиты, записанная в виде строкового литерала; или &lt;code&gt;NULL&lt;/code&gt; , чтобы удалить метку защиты.</target>
        </trans-unit>
        <trans-unit id="e179748e50d17a45a45be3da432d0626ce9f1871" translate="yes" xml:space="preserve">
          <source>The new server can now be safely started, and then any rsync'ed standby servers.</source>
          <target state="translated">Теперь новый сервер можно безопасно запустить,а затем и любые резервные серверы rsync'ed.</target>
        </trans-unit>
        <trans-unit id="9cccbe82fdca6cb05f61febaafdcdbee82d07beb" translate="yes" xml:space="preserve">
          <source>The new user will be a superuser.</source>
          <target state="translated">Новый пользователь будет суперпользователем.</target>
        </trans-unit>
        <trans-unit id="c54c521c104ba07a131d94a8006311919b30f264" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to create databases.</source>
          <target state="translated">Новому пользователю будет разрешено создавать базы данных.</target>
        </trans-unit>
        <trans-unit id="d45b0936a7b0d005278d7069b144bbda44325062" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to create new roles (that is, this user will have &lt;code&gt;CREATEROLE&lt;/code&gt; privilege).</source>
          <target state="translated">Новому пользователю будет разрешено создавать новые роли (то есть этот пользователь будет иметь привилегию &lt;code&gt;CREATEROLE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f77c7b82b1f36620c7d5c97f31d6b3e8156045cd" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to log in (that is, the user name can be used as the initial session user identifier). This is the default.</source>
          <target state="translated">Новому пользователю будет разрешен вход в систему (т.е.имя пользователя может быть использовано в качестве идентификатора пользователя начальной сессии).По умолчанию.</target>
        </trans-unit>
        <trans-unit id="20d6f51c275f9b74aaf81f7d6a5623641aaaf3e3" translate="yes" xml:space="preserve">
          <source>The new user will have the &lt;code&gt;REPLICATION&lt;/code&gt; privilege, which is described more fully in the documentation for &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="translated">У нового пользователя будет привилегия &lt;code&gt;REPLICATION&lt;/code&gt; , которая более подробно описана в документации &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ea6c8532360a87549f7c059f52122ef9c601695" translate="yes" xml:space="preserve">
          <source>The new user will not be a superuser. This is the default.</source>
          <target state="translated">Новый пользователь не будет суперпользователем.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="72c465f76c8179666632ce0c6f15419c4133425d" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to create databases. This is the default.</source>
          <target state="translated">Новому пользователю не будет разрешено создавать базы данных.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="32dd0b63f5a01c58c0731e9846c0b6a55a21f4f0" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to create new roles. This is the default.</source>
          <target state="translated">Новому пользователю не будет разрешено создавать новые роли.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="87cc74c8ed55ae4e670446b51aab48e450dbc14b" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to log in. (A role without login privilege is still useful as a means of managing database permissions.)</source>
          <target state="translated">Новому пользователю будет запрещен вход в систему.(Роль без привилегий входа по-прежнему полезна в качестве средства управления правами доступа к базам данных).</target>
        </trans-unit>
        <trans-unit id="a13d7c8eff958866dd3c2de41dd7c33e5dff939b" translate="yes" xml:space="preserve">
          <source>The new user will not have the &lt;code&gt;REPLICATION&lt;/code&gt; privilege, which is described more fully in the documentation for &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="translated">У нового пользователя не будет привилегии &lt;code&gt;REPLICATION&lt;/code&gt; , которая более подробно описана в документации &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="127849b8d3eea48eada06bb9a69ad7d49b073868" translate="yes" xml:space="preserve">
          <source>The new value for a table storage parameter. This might be a number or a word depending on the parameter.</source>
          <target state="translated">Новое значение для параметра хранения таблиц.Это может быть число или слово в зависимости от параметра.</target>
        </trans-unit>
        <trans-unit id="c290b36401426b8422b4d66e484cd2e82d3b87ce" translate="yes" xml:space="preserve">
          <source>The new value for an index-method-specific storage parameter. This might be a number or a word depending on the parameter.</source>
          <target state="translated">Новое значение для специфического для индекса параметра хранения.Это может быть число или слово в зависимости от параметра.</target>
        </trans-unit>
        <trans-unit id="c34da01d538b4bb95a9dcedad6f42505d9964bfa" translate="yes" xml:space="preserve">
          <source>The new value of the column</source>
          <target state="translated">Новое значение колонки</target>
        </trans-unit>
        <trans-unit id="9cc0b73abbe4bf474235a0a153fa246959f47339" translate="yes" xml:space="preserve">
          <source>The new value to be added to an enum type's list of values, or the new name to be given to an existing value. Like all enum literals, it needs to be quoted.</source>
          <target state="translated">Новое значение,которое будет добавлено в список значений перечислительного типа,или новое имя,которое будет присвоено существующему значению.Как и все литералы перечисления,оно должно быть процитировано.</target>
        </trans-unit>
        <trans-unit id="3abd3f485b5c74bf1e64463613b4fb3d9ef53408" translate="yes" xml:space="preserve">
          <source>The new value to use for a template-specific option. If the equal sign and value are omitted, then any previous setting for the option is removed from the dictionary, allowing the default to be used.</source>
          <target state="translated">Новое значение,используемое для конкретной опции шаблона.Если опустить знак равенства и значение,то любая предыдущая установка для данной опции удаляется из словаря,позволяя использовать значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="54266d9e3dff5c3d85bb17314ebcd06db8a0c4e2" translate="yes" xml:space="preserve">
          <source>The next example shows how to obtain the union of the tables &lt;code&gt;distributors&lt;/code&gt; and &lt;code&gt;actors&lt;/code&gt;, restricting the results to those that begin with the letter W in each table. Only distinct rows are wanted, so the key word &lt;code&gt;ALL&lt;/code&gt; is omitted.</source>
          <target state="translated">В следующем примере показано, как получить объединение &lt;code&gt;distributors&lt;/code&gt; и &lt;code&gt;actors&lt;/code&gt; таблиц , ограничивая результаты теми, которые начинаются с буквы W в каждой таблице. Требуются только отдельные строки, поэтому ключевое слово &lt;code&gt;ALL&lt;/code&gt; опускается.</target>
        </trans-unit>
        <trans-unit id="0b983bad83edd443b7b8ce4de658661eaff249f8" translate="yes" xml:space="preserve">
          <source>The next step is to set the session to use the new configuration, which was created in the &lt;code&gt;public&lt;/code&gt; schema:</source>
          <target state="translated">Следующим шагом является настройка сеанса для использования новой конфигурации, которая была создана в &lt;code&gt;public&lt;/code&gt; схеме:</target>
        </trans-unit>
        <trans-unit id="69b04f7d07fe975427e0f7bf99be4fe924c78cc6" translate="yes" xml:space="preserve">
          <source>The non-default GIN operator class &lt;code&gt;jsonb_path_ops&lt;/code&gt; supports indexing the &lt;code&gt;@&amp;gt;&lt;/code&gt; operator only. An example of creating an index with this operator class is:</source>
          <target state="translated">Класс операторов GIN, &lt;code&gt;jsonb_path_ops&lt;/code&gt; стандартного, jsonb_path_ops поддерживает только индексирование оператора &lt;code&gt;@&amp;gt;&lt;/code&gt; . Пример создания индекса с этим классом операторов:</target>
        </trans-unit>
        <trans-unit id="1d49459b2ff80f4c26bb14ba35712908d50a4f44" translate="yes" xml:space="preserve">
          <source>The normal PostgreSQL query optimizer performs a &lt;em&gt;near-exhaustive search&lt;/em&gt; over the space of alternative strategies. This algorithm, first introduced in IBM's System R database, produces a near-optimal join order, but can take an enormous amount of time and memory space when the number of joins in the query grows large. This makes the ordinary PostgreSQL query optimizer inappropriate for queries that join a large number of tables.</source>
          <target state="translated">Обычный оптимизатор запросов PostgreSQL выполняет &lt;em&gt;почти исчерпывающий поиск&lt;/em&gt; в пространстве альтернативных стратегий. Этот алгоритм, впервые представленный в базе данных IBM System R, обеспечивает почти оптимальный порядок соединения, но может занять огромное количество времени и памяти, когда количество соединений в запросе становится большим. Это делает обычный оптимизатор запросов PostgreSQL неподходящим для запросов, которые объединяют большое количество таблиц.</target>
        </trans-unit>
        <trans-unit id="ddb0abe82fae0bb47141f78e86913e1352bb274e" translate="yes" xml:space="preserve">
          <source>The notations &lt;code&gt;varchar(n)&lt;/code&gt; and &lt;code&gt;char(n)&lt;/code&gt; are aliases for &lt;code&gt;character varying(n)&lt;/code&gt; and &lt;code&gt;character(n)&lt;/code&gt;, respectively. &lt;code&gt;character&lt;/code&gt; without length specifier is equivalent to &lt;code&gt;character(1)&lt;/code&gt;. If &lt;code&gt;character varying&lt;/code&gt; is used without length specifier, the type accepts strings of any size. The latter is a PostgreSQL extension.</source>
          <target state="translated">Обозначения &lt;code&gt;varchar(n)&lt;/code&gt; и &lt;code&gt;char(n)&lt;/code&gt; - это псевдонимы для &lt;code&gt;character varying(n)&lt;/code&gt; и &lt;code&gt;character(n)&lt;/code&gt; , соответственно. &lt;code&gt;character&lt;/code&gt; без спецификатора длины эквивалентен &lt;code&gt;character(1)&lt;/code&gt; . Если &lt;code&gt;character varying&lt;/code&gt; используется без спецификатора длины, тип принимает строки любого размера. Последний является расширением PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="fbc61286b42787c186b2be652915f7206bb4ed7e" translate="yes" xml:space="preserve">
          <source>The number of &lt;em&gt;key columns&lt;/em&gt; in the index, not counting any &lt;em&gt;included columns&lt;/em&gt;, which are merely stored and do not participate in the index semantics</source>
          <target state="translated">Количество &lt;em&gt;ключевых столбцов&lt;/em&gt; в индексе, не считая &lt;em&gt;включенных столбцов&lt;/em&gt; , которые просто сохраняются и не участвуют в семантике индекса.</target>
        </trans-unit>
        <trans-unit id="32236378278e06cdc1ed2783abcf03baa463efaf" translate="yes" xml:space="preserve">
          <source>The number of WAL segment files in &lt;code&gt;pg_wal&lt;/code&gt; directory depends on &lt;code&gt;min_wal_size&lt;/code&gt;, &lt;code&gt;max_wal_size&lt;/code&gt; and the amount of WAL generated in previous checkpoint cycles. When old log segment files are no longer needed, they are removed or recycled (that is, renamed to become future segments in the numbered sequence). If, due to a short-term peak of log output rate, &lt;code&gt;max_wal_size&lt;/code&gt; is exceeded, the unneeded segment files will be removed until the system gets back under this limit. Below that limit, the system recycles enough WAL files to cover the estimated need until the next checkpoint, and removes the rest. The estimate is based on a moving average of the number of WAL files used in previous checkpoint cycles. The moving average is increased immediately if the actual usage exceeds the estimate, so it accommodates peak usage rather than average usage to some extent. &lt;code&gt;min_wal_size&lt;/code&gt; puts a minimum on the amount of WAL files recycled for future usage; that much WAL is always recycled for future use, even if the system is idle and the WAL usage estimate suggests that little WAL is needed.</source>
          <target state="translated">Количество файлов сегментов WAL в &lt;code&gt;pg_wal&lt;/code&gt; зависит от &lt;code&gt;min_wal_size&lt;/code&gt; , &lt;code&gt;max_wal_size&lt;/code&gt; и количества WAL, созданного в предыдущих циклах контрольных точек. Когда старые файлы сегментов журнала больше не нужны, они удаляются или перерабатываются (то есть переименовываются в будущие сегменты в пронумерованной последовательности). Если из-за кратковременного пика скорости вывода журнала &lt;code&gt;max_wal_size&lt;/code&gt; превышено, ненужные файлы сегментов будут удалены, пока система не вернется к этому пределу. Ниже этого предела система перерабатывает достаточно файлов WAL, чтобы покрыть предполагаемую потребность до следующей контрольной точки, а остальные удаляет. Оценка основана на скользящем среднем количестве файлов WAL, использованных в предыдущих циклах контрольных точек. Скользящее среднее немедленно увеличивается, если фактическое использование превышает оценку, поэтому оно в некоторой степени учитывает пиковое использование, а не среднее использование. &lt;code&gt;min_wal_size&lt;/code&gt; устанавливает минимальное количество файлов WAL, перерабатываемых для будущего использования; такое количество WAL всегда перерабатывается для использования в будущем, даже если система простаивает, а оценка использования WAL предполагает, что WAL требуется немного.</target>
        </trans-unit>
        <trans-unit id="e63ffb99c780c2d3b3feec330c071c01fcbaec0d" translate="yes" xml:space="preserve">
          <source>The number of bytes that can be written to WAL such that this slot is not in danger of getting in state &quot;lost&quot;. It is NULL for lost slots, as well as if &lt;code&gt;max_slot_wal_keep_size&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8748e9fef55cda632ea0102b0e063bbbb95c6586" translate="yes" xml:space="preserve">
          <source>The number of columns in partition key</source>
          <target state="translated">Количество столбцов в ключе раздела</target>
        </trans-unit>
        <trans-unit id="edbeec849445e687cd12eea0389ae4b06b732e80" translate="yes" xml:space="preserve">
          <source>The number of direct ancestors this column has. A column with a nonzero number of ancestors cannot be dropped nor renamed.</source>
          <target state="translated">Количество прямых предков в этой колонке.Столбец с ненулевым числом предков не может быть ни опущен,ни переименован.</target>
        </trans-unit>
        <trans-unit id="d7208773dc180e0dd7b3e10265b4f310a20ba88e" translate="yes" xml:space="preserve">
          <source>The number of direct inheritance ancestors this constraint has. A constraint with a nonzero number of ancestors cannot be dropped nor renamed.</source>
          <target state="translated">Количество прямых наследственных предков,которое имеет это ограничение.Ограничение с ненулевым числом предков не может быть ни опущено,ни переименовано.</target>
        </trans-unit>
        <trans-unit id="8301961997733ca48d253481eefaad3008a00674" translate="yes" xml:space="preserve">
          <source>The number of dirty buffers written in each round is based on the number of new buffers that have been needed by server processes during recent rounds. The average recent need is multiplied by &lt;code&gt;bgwriter_lru_multiplier&lt;/code&gt; to arrive at an estimate of the number of buffers that will be needed during the next round. Dirty buffers are written until there are that many clean, reusable buffers available. (However, no more than &lt;code&gt;bgwriter_lru_maxpages&lt;/code&gt; buffers will be written per round.) Thus, a setting of 1.0 represents a &amp;ldquo;just in time&amp;rdquo; policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Количество грязных буферов, записываемых в каждом цикле, основано на количестве новых буферов, которые потребовались серверными процессами во время последних циклов. Средняя недавняя потребность умножается на &lt;code&gt;bgwriter_lru_multiplier&lt;/code&gt; , чтобы получить оценку количества буферов, которые потребуются в следующем раунде. Грязные буферы записываются до тех пор, пока не будет доступно столько чистых буферов, которые можно использовать повторно. (Однако не более чем &lt;code&gt;bgwriter_lru_maxpages&lt;/code&gt; количество буферов будет записываться за цикл.) Таким образом, значение 1.0 представляет политику &amp;laquo;точно в срок&amp;raquo; для записи точно того количества буферов, которое, согласно прогнозам, потребуется. Большие значения обеспечивают некоторую защиту от всплесков спроса, в то время как меньшие значения преднамеренно оставляют запись для серверных процессов. По умолчанию - 2.0. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="3d25f5401af5c842168f311144ea17e37058d652" translate="yes" xml:space="preserve">
          <source>The number of distinct nonnull data values in the column. A value greater than zero is the actual number of distinct values. A value less than zero is the negative of a multiplier for the number of rows in the table; for example, a column in which about 80% of the values are nonnull and each nonnull value appears about twice on average could be represented by &lt;code&gt;stadistinct&lt;/code&gt; = -0.4. A zero value means the number of distinct values is unknown.</source>
          <target state="translated">Количество различных ненулевых значений данных в столбце. Значение больше нуля - это фактическое количество различных значений. Значение меньше нуля является отрицательным множителем числа строк в таблице; например, столбец, в котором около 80% значений ненулевые, и каждое ненулевое значение появляется в среднем дважды, может быть представлен как &lt;code&gt;stadistinct&lt;/code&gt; = -0.4. Нулевое значение означает, что количество различных значений неизвестно.</target>
        </trans-unit>
        <trans-unit id="8289805730489472578e3f27b2f1d288c0d7dec6" translate="yes" xml:space="preserve">
          <source>The number of iterations of the S2K algorithm to use. It must be a value between 1024 and 65011712, inclusive.</source>
          <target state="translated">Количество итераций используемого алгоритма S2K.Оно должно быть между 1024 и 65011712 включительно.</target>
        </trans-unit>
        <trans-unit id="9f0e73558363d09e86314a049abfbcf61eaf5cbd" translate="yes" xml:space="preserve">
          <source>The number of lexemes must be less than 2&lt;sup&gt;64&lt;/sup&gt;</source>
          <target state="translated">Количество лексем должно быть меньше 2 &lt;sup&gt;64&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d2adf53592a4a37e557ef19975d87459fecab27a" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait before reporting an authentication failure. The default is 0.</source>
          <target state="translated">Количество миллисекунд,чтобы подождать,прежде чем сообщить о сбое аутентификации.По умолчанию 0.</target>
        </trans-unit>
        <trans-unit id="4848e62664c3602823768b8a292b1248da926aa5" translate="yes" xml:space="preserve">
          <source>The number of nodes (lexemes + operators) in a &lt;code&gt;tsquery&lt;/code&gt; must be less than 32,768</source>
          <target state="translated">Количество узлов (лексем + операторы) в &lt;code&gt;tsquery&lt;/code&gt; должно быть меньше 32 768</target>
        </trans-unit>
        <trans-unit id="e36ab63c8c21311a28348db0c90c93619e02161d" translate="yes" xml:space="preserve">
          <source>The number of query cancels and the reason for them can be viewed using the &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; system view on the standby server. The &lt;code&gt;pg_stat_database&lt;/code&gt; system view also contains summary information.</source>
          <target state="translated">Количество &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; запросов и их причину можно увидеть в системном представлении pg_stat_database_conflicts на резервном сервере. &lt;code&gt;pg_stat_database&lt;/code&gt; вид системы также содержит краткую информацию.</target>
        </trans-unit>
        <trans-unit id="9d730ed06cd7648c33a05712cd3d40df8021dd41" translate="yes" xml:space="preserve">
          <source>The number of repetitions of the index scan that should be factored into the cost estimates. This will typically be greater than one when considering a parameterized scan for use in the inside of a nestloop join. Note that the cost estimates should still be for just one scan; a larger &lt;em&gt;&lt;code&gt;loop_count&lt;/code&gt;&lt;/em&gt; means that it may be appropriate to allow for some caching effects across multiple scans.</source>
          <target state="translated">Количество повторов сканирования индекса, которое следует учитывать при оценке затрат. Обычно это значение больше единицы, если рассматривать параметризованное сканирование для использования внутри соединения nestloop. Обратите внимание, что смета расходов должна быть рассчитана только на одно сканирование; большее значение &lt;em&gt; &lt;code&gt;loop_count&lt;/code&gt; &lt;/em&gt; означает, что может быть целесообразно учитывать некоторые эффекты кэширования при нескольких сканированиях.</target>
        </trans-unit>
        <trans-unit id="166b286d18f619fbe9f6a3ea1bb840802689109b" translate="yes" xml:space="preserve">
          <source>The number of rows returned or affected by the last SQL query, or 0 if the query failed or did not report a row count.</source>
          <target state="translated">Количество строк,возвращенных или затронутых последним SQL-запросом,или 0,если запрос не удался или не сообщил о количестве строк.</target>
        </trans-unit>
        <trans-unit id="1d69a3b171c0833334cc425ee7e0d762adec494e" translate="yes" xml:space="preserve">
          <source>The number of rows to skip before starting to return rows. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">Количество строк, которые нужно пропустить, прежде чем начать возвращать строки. Подробнее см. &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;Пункт &lt;/a&gt; &lt;code&gt;LIMIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94382b43faed8152ee9a457cefa14e2d7062f389" translate="yes" xml:space="preserve">
          <source>The number of rows to skip before starting to return rows. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aade2c0dad75a39b57c1da4c3274b381a44640e8" translate="yes" xml:space="preserve">
          <source>The number of the ISO 8601 week-numbering week of the year. By definition, ISO weeks start on Mondays and the first week of a year contains January 4 of that year. In other words, the first Thursday of a year is in week 1 of that year.</source>
          <target state="translated">Номер недели по ISO 8601.По определению,недели ISO начинаются по понедельникам,а первая неделя года содержит 4 января этого года.Другими словами,первый четверг года приходится на первую неделю этого года.</target>
        </trans-unit>
        <trans-unit id="4cb2d1007085e9fe567cf2f04104acbb29523d8d" translate="yes" xml:space="preserve">
          <source>The number of the column</source>
          <target state="translated">Номер столбца</target>
        </trans-unit>
        <trans-unit id="17b9b1cbc38db2adfa96c6b3cafb442db5c59e27" translate="yes" xml:space="preserve">
          <source>The number of the column. Ordinary columns are numbered from 1 up. System columns, such as &lt;code&gt;ctid&lt;/code&gt;, have (arbitrary) negative numbers.</source>
          <target state="translated">Номер столбца. Обычные столбцы нумеруются от 1 вверх. Системные столбцы, такие как &lt;code&gt;ctid&lt;/code&gt; , имеют (произвольные) отрицательные числа.</target>
        </trans-unit>
        <trans-unit id="d5de13da859bcae07a08d4b002774933f9c4b34a" translate="yes" xml:space="preserve">
          <source>The number of the described column</source>
          <target state="translated">Номер описанной колонки</target>
        </trans-unit>
        <trans-unit id="8054a525924b0216f44b2c15796e49dd9491e9dd" translate="yes" xml:space="preserve">
          <source>The numbers provided by &lt;code&gt;BUFFERS&lt;/code&gt; help to identify which parts of the query are the most I/O-intensive.</source>
          <target state="translated">Цифры, предоставляемые &lt;code&gt;BUFFERS&lt;/code&gt; помогают определить, какие части запроса являются наиболее интенсивными по вводу-выводу.</target>
        </trans-unit>
        <trans-unit id="a9a9a9a7a626d48ccbaac2fc53aad8be63a44035" translate="yes" xml:space="preserve">
          <source>The numerical, unique, sequentially-assigned identifier that each transaction receives when it first causes a database modification. Frequently abbreviated as &lt;em&gt;xid&lt;/em&gt;. When stored on disk, xids are only 32-bits wide, so only approximately four billion write transaction IDs can be generated; to permit the system to run for longer than that, &lt;em&gt;epochs&lt;/em&gt; are used, also 32 bits wide. When the counter reaches the maximum xid value, it starts over at &lt;code&gt;3&lt;/code&gt; (values under that are reserved) and the epoch value is incremented by one. In some contexts, the epoch and xid values are considered together as a single 64-bit value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f1e0aeb5175fc6ed920199dd580b15702c2054" translate="yes" xml:space="preserve">
          <source>The object which describes a WAL range always has three keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f439f1411e4ff73cafff6f9e11f463408382ecb" translate="yes" xml:space="preserve">
          <source>The object which describes a single file contains either a &lt;code&gt;Path&lt;/code&gt; key or an &lt;code&gt;Encoded-Path&lt;/code&gt; key. Normally, the &lt;code&gt;Path&lt;/code&gt; key will be present. The associated string value is the path of the file relative to the root of the backup directory. Files located in a user-defined tablespace will have paths whose first two components are &lt;code&gt;pg_tblspc&lt;/code&gt; and the OID of the tablespace. If the path is not a string that is legal in UTF-8, or if the user requests that encoded paths be used for all files, then the &lt;code&gt;Encoded-Path&lt;/code&gt; key will be present instead. This stores the same data, but it is encoded as a string of hexadecimal digits. Each pair of hexadecimal digits in the string represents a single octet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3001cae2699919156e01018ff603c7cc3b34ddd4" translate="yes" xml:space="preserve">
          <source>The object's key-value pairs, represented as an array of objects containing three fields: &lt;code&gt;&quot;key&quot;&lt;/code&gt;, &lt;code&gt;&quot;value&quot;&lt;/code&gt;, and &lt;code&gt;&quot;id&quot;&lt;/code&gt;; &lt;code&gt;&quot;id&quot;&lt;/code&gt; is a unique identifier of the object the key-value pair belongs to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96b4217f4ff70cb5052589aed86a75a58ea381a" translate="yes" xml:space="preserve">
          <source>The obsolete options &lt;code&gt;SORT1&lt;/code&gt;, &lt;code&gt;SORT2&lt;/code&gt;, &lt;code&gt;LTCMP&lt;/code&gt;, and &lt;code&gt;GTCMP&lt;/code&gt; were formerly used to specify the names of sort operators associated with a merge-joinable operator. This is no longer necessary, since information about associated operators is found by looking at B-tree operator families instead. If one of these options is given, it is ignored except for implicitly setting &lt;code&gt;MERGES&lt;/code&gt; true.</source>
          <target state="translated">Устаревшие параметры &lt;code&gt;SORT1&lt;/code&gt; , &lt;code&gt;SORT2&lt;/code&gt; , &lt;code&gt;LTCMP&lt;/code&gt; и &lt;code&gt;GTCMP&lt;/code&gt; ранее использовались для указания имен операторов сортировки, связанных с оператором объединения слиянием. В этом больше нет необходимости, поскольку информацию о связанных операторах можно найти, просмотрев семейства операторов B-дерева. Если задана одна из этих опций, она игнорируется, за исключением неявной установки &lt;code&gt;MERGES&lt;/code&gt; в истину.</target>
        </trans-unit>
        <trans-unit id="c4bf61bc0ae75f599a4b04ad0336e82b98b0a3d1" translate="yes" xml:space="preserve">
          <source>The octet with decimal value 92 (backslash) is doubled in the output. Details are in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-RESESC&quot;&gt;Table 8.8&lt;/a&gt;.</source>
          <target state="translated">Октет с десятичным значением 92 (обратная косая черта) удваивается на выходе. Подробности в &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-RESESC&quot;&gt;таблице 8.8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed338423cb1bcb126644c1e6c22121f438859be7" translate="yes" xml:space="preserve">
          <source>The offset at which the allocation starts. NULL for anonymous allocations and unused memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf48e5f27220de9fe763df392dfdaead2007f3b" translate="yes" xml:space="preserve">
          <source>The offset fields specify the hours, and optionally minutes and seconds, difference from UTC. They have the format &lt;code&gt;hh&lt;/code&gt;[&lt;code&gt;:&lt;/code&gt;&lt;code&gt;mm&lt;/code&gt;[&lt;code&gt;:&lt;/code&gt;&lt;code&gt;ss&lt;/code&gt;]] optionally with a leading sign (&lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;). The positive sign is used for zones &lt;em&gt;west&lt;/em&gt; of Greenwich. (Note that this is the opposite of the ISO-8601 sign convention used elsewhere in PostgreSQL.) &lt;code&gt;hh&lt;/code&gt; can have one or two digits; &lt;code&gt;mm&lt;/code&gt; and &lt;code&gt;ss&lt;/code&gt; (if used) must have two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b42992b2dbbebe4441f992b139d475f2a6576d" translate="yes" xml:space="preserve">
          <source>The old indexes are dropped. The &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; session locks for the indexes and the table are released.</source>
          <target state="translated">Старые индексы удаляются. В &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; сессия блокировка для индексов и таблиц высвобождаются.</target>
        </trans-unit>
        <trans-unit id="aff5f1b14035796efdcabc3055a299cc4fcb8ba7" translate="yes" xml:space="preserve">
          <source>The old indexes have &lt;code&gt;pg_index.indisready&lt;/code&gt; switched to &amp;ldquo;false&amp;rdquo; to prevent any new tuple insertions, after waiting for running queries that might reference the old index to complete.</source>
          <target state="translated">Для старых индексов &lt;code&gt;pg_index.indisready&lt;/code&gt; переключено на &amp;laquo;false&amp;raquo;, чтобы предотвратить вставку любых новых кортежей после ожидания выполнения запросов, которые могут ссылаться на старый индекс.</target>
        </trans-unit>
        <trans-unit id="05be6eb32947b010e242b9b77a81ac45522407a1" translate="yes" xml:space="preserve">
          <source>The oldest transaction affecting the system catalogs that this slot needs the database to retain. &lt;code&gt;VACUUM&lt;/code&gt; cannot remove catalog tuples deleted by any later transaction.</source>
          <target state="translated">Самая старая транзакция, влияющая на системные каталоги, которую этот слот должен хранить в базе данных. &lt;code&gt;VACUUM&lt;/code&gt; не может удалить кортежи каталога, удаленные какой-либо последующей транзакцией.</target>
        </trans-unit>
        <trans-unit id="5faf9118a5f5509db65f9f3d1a55a7c88d7b4faa" translate="yes" xml:space="preserve">
          <source>The oldest transaction that this slot needs the database to retain. &lt;code&gt;VACUUM&lt;/code&gt; cannot remove tuples deleted by any later transaction.</source>
          <target state="translated">Самая старая транзакция, которую этот слот должен хранить в базе данных. &lt;code&gt;VACUUM&lt;/code&gt; не может удалить кортежи, удаленные какой-либо последующей транзакцией.</target>
        </trans-unit>
        <trans-unit id="f97ff854cd0196d6cae74ec459d42c99253ddda9" translate="yes" xml:space="preserve">
          <source>The only feature of AREs that is actually incompatible with POSIX EREs is that &lt;code&gt;\&lt;/code&gt; does not lose its special significance inside bracket expressions. All other ARE features use syntax which is illegal or has undefined or unspecified effects in POSIX EREs; the &lt;code&gt;***&lt;/code&gt; syntax of directors likewise is outside the POSIX syntax for both BREs and EREs.</source>
          <target state="translated">Единственная особенность ARE, которая фактически несовместима с POSIX ERE, заключается в том, что &lt;code&gt;\&lt;/code&gt; не теряет своего особого значения внутри выражений в квадратных скобках. Все другие функции ARE используют недопустимый синтаксис или имеют неопределенные или неопределенные эффекты в POSIX ERE; &lt;code&gt;***&lt;/code&gt; синтаксис директоров также находится вне синтаксиса POSIX для обоих Брес и ЭРД.</target>
        </trans-unit>
        <trans-unit id="8a1895f6d1a24facb26fe1c49448d16cf40a3e4a" translate="yes" xml:space="preserve">
          <source>The only firm requirement for using NFS with PostgreSQL is that the file system is mounted using the &lt;code&gt;hard&lt;/code&gt; option. With the &lt;code&gt;hard&lt;/code&gt; option, processes can &amp;ldquo;hang&amp;rdquo; indefinitely if there are network problems, so this configuration will require a careful monitoring setup. The &lt;code&gt;soft&lt;/code&gt; option will interrupt system calls in case of network problems, but PostgreSQL will not repeat system calls interrupted in this way, so any such interruption will result in an I/O error being reported.</source>
          <target state="translated">Единственное твердое требование для использования NFS с PostgreSQL - монтирование файловой системы с использованием &lt;code&gt;hard&lt;/code&gt; параметра. При использовании &lt;code&gt;hard&lt;/code&gt; варианта процессы могут &amp;laquo;зависать&amp;raquo; на неопределенное время при возникновении сетевых проблем, поэтому такая конфигурация потребует тщательной настройки мониторинга. &lt;code&gt;soft&lt;/code&gt; вариант будет прерывать системные вызовы в случае сетевых проблем, но PostgreSQL не будет повторять системные вызовы прерываемый таким образом, так что любое такое прерывание приведет к ошибке ввода / вывода сообщается.</target>
        </trans-unit>
        <trans-unit id="a396e16c5e2752bf51d263513d40dc846694333b" translate="yes" xml:space="preserve">
          <source>The only parameter required by the &lt;code&gt;synonym&lt;/code&gt; template is &lt;code&gt;SYNONYMS&lt;/code&gt;, which is the base name of its configuration file &amp;mdash; &lt;code&gt;my_synonyms&lt;/code&gt; in the above example. The file's full name will be &lt;code&gt;$SHAREDIR/tsearch_data/my_synonyms.syn&lt;/code&gt; (where &lt;code&gt;$SHAREDIR&lt;/code&gt; means the PostgreSQL installation's shared-data directory). The file format is just one line per word to be substituted, with the word followed by its synonym, separated by white space. Blank lines and trailing spaces are ignored.</source>
          <target state="translated">Единственный параметр, который требуется для шаблона &lt;code&gt;synonym&lt;/code&gt; - это &lt;code&gt;SYNONYMS&lt;/code&gt; , который является базовым именем его файла конфигурации - &lt;code&gt;my_synonyms&lt;/code&gt; в приведенном выше примере. Полное имя файла будет &lt;code&gt;$SHAREDIR/tsearch_data/my_synonyms.syn&lt;/code&gt; (где &lt;code&gt;$SHAREDIR&lt;/code&gt; означает каталог общих данных установки PostgreSQL). Формат файла - это просто одна строка на слово, которое нужно заменить, за словом следует его синоним, разделенный пробелом. Пустые строки и конечные пробелы игнорируются.</target>
        </trans-unit>
        <trans-unit id="a030d7c4538742e2439ddd895553830f470ea35b" translate="yes" xml:space="preserve">
          <source>The operations that occur on both primary and standby servers are normal continuous archiving and recovery tasks. The only point of contact between the two database servers is the archive of WAL files that both share: primary writing to the archive, standby reading from the archive. Care must be taken to ensure that WAL archives from separate primary servers do not become mixed together or confused. The archive need not be large if it is only required for standby operation.</source>
          <target state="translated">Операции,которые происходят как на первичном,так и на резервном серверах,являются обычными задачами непрерывного архивирования и восстановления.Единственной точкой контакта между двумя серверами баз данных является архив файлов WAL,которые совместно используются:первичная запись в архив,чтение из архива в режиме ожидания.Необходимо позаботиться о том,чтобы архивы WAL с отдельных первичных серверов не смешивались и не путались.Архив не обязательно должен быть большим,если он необходим только для работы в режиме ожидания.</target>
        </trans-unit>
        <trans-unit id="78a77532759d107a293f71b3071e91121689e001" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;!=&lt;/code&gt; is mapped to &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; on input, so these two names are always equivalent.</source>
          <target state="translated">Оператор &lt;code&gt;!=&lt;/code&gt; Отображается на &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; при вводе, поэтому эти два имени всегда эквивалентны.</target>
        </trans-unit>
        <trans-unit id="7680d70684ff5657bfcc4e3b94f75e49715485f1" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;~~&lt;/code&gt; is equivalent to &lt;code&gt;LIKE&lt;/code&gt;, and &lt;code&gt;~~*&lt;/code&gt; corresponds to &lt;code&gt;ILIKE&lt;/code&gt;. There are also &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt; operators that represent &lt;code&gt;NOT LIKE&lt;/code&gt; and &lt;code&gt;NOT ILIKE&lt;/code&gt;, respectively. All of these operators are PostgreSQL-specific.</source>
          <target state="translated">Оператор &lt;code&gt;~~&lt;/code&gt; эквивалентен &lt;code&gt;LIKE&lt;/code&gt; , а &lt;code&gt;~~*&lt;/code&gt; соответствует &lt;code&gt;ILIKE&lt;/code&gt; . Также существуют операторы &lt;code&gt;!~~&lt;/code&gt; и &lt;code&gt;!~~*&lt;/code&gt; которые представляют &lt;code&gt;NOT LIKE&lt;/code&gt; и &lt;code&gt;NOT ILIKE&lt;/code&gt; соответственно. Все эти операторы специфичны для PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="bd4509fc82896a3a7a34fb1c8f105531cc74d101" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;~~&lt;/code&gt; is equivalent to &lt;code&gt;LIKE&lt;/code&gt;, and &lt;code&gt;~~*&lt;/code&gt; corresponds to &lt;code&gt;ILIKE&lt;/code&gt;. There are also &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt; operators that represent &lt;code&gt;NOT LIKE&lt;/code&gt; and &lt;code&gt;NOT ILIKE&lt;/code&gt;, respectively. All of these operators are PostgreSQL-specific. You may see these operator names in &lt;code&gt;EXPLAIN&lt;/code&gt; output and similar places, since the parser actually translates &lt;code&gt;LIKE&lt;/code&gt; et al. to these operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d017a3795e4c2a850feefb2cba71cdbcd408d49" translate="yes" xml:space="preserve">
          <source>The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on the type &lt;code&gt;int4&lt;/code&gt; would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for values of type &lt;code&gt;int4&lt;/code&gt;. In practice the default operator class for the column's data type is usually sufficient. The main reason for having operator classes is that for some data types, there could be more than one meaningful index behavior. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when making an index. The operator class determines the basic sort ordering (which can then be modified by adding sort options &lt;code&gt;COLLATE&lt;/code&gt;, &lt;code&gt;ASC&lt;/code&gt;/&lt;code&gt;DESC&lt;/code&gt; and/or &lt;code&gt;NULLS FIRST&lt;/code&gt;/&lt;code&gt;NULLS LAST&lt;/code&gt;).</source>
          <target state="translated">Класс операторов определяет операторы, которые будут использоваться индексом для этого столбца. Например, индекс B-дерева для типа &lt;code&gt;int4&lt;/code&gt; будет использовать класс &lt;code&gt;int4_ops&lt;/code&gt; ; этот класс операторов включает функции сравнения для значений типа &lt;code&gt;int4&lt;/code&gt; . На практике обычно достаточно класса операторов по умолчанию для типа данных столбца. Основная причина наличия классов операторов заключается в том, что для некоторых типов данных может существовать более одного значимого поведения индекса. Например, мы могли бы захотеть отсортировать тип данных комплексного числа либо по абсолютному значению, либо по действительной части. Мы могли бы сделать это, определив два класса операторов для типа данных, а затем выбрав соответствующий класс при создании индекса. Класс операторов определяет базовый порядок сортировки (который затем можно изменить, добавив параметры сортировки &lt;code&gt;COLLATE&lt;/code&gt; , &lt;code&gt;ASC&lt;/code&gt; / &lt;code&gt;DESC&lt;/code&gt; и / или &lt;code&gt;NULLS FIRST&lt;/code&gt; / &lt;code&gt;NULLS LAST&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="79d3ccfc646e039879a5fc434785db86b4443933" translate="yes" xml:space="preserve">
          <source>The operator classes &lt;code&gt;text_pattern_ops&lt;/code&gt;, &lt;code&gt;varchar_pattern_ops&lt;/code&gt;, and &lt;code&gt;bpchar_pattern_ops&lt;/code&gt; support B-tree indexes on the types &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt; respectively. The difference from the default operator classes is that the values are compared strictly character by character rather than according to the locale-specific collation rules. This makes these operator classes suitable for use by queries involving pattern matching expressions (&lt;code&gt;LIKE&lt;/code&gt; or POSIX regular expressions) when the database does not use the standard &amp;ldquo;C&amp;rdquo; locale. As an example, you might index a &lt;code&gt;varchar&lt;/code&gt; column like this:</source>
          <target state="translated">Классы операторов &lt;code&gt;text_pattern_ops&lt;/code&gt; , &lt;code&gt;varchar_pattern_ops&lt;/code&gt; и &lt;code&gt;bpchar_pattern_ops&lt;/code&gt; поддерживают индексы B-дерева для типов &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;varchar&lt;/code&gt; и &lt;code&gt;char&lt;/code&gt; соответственно. Отличие от классов операторов по умолчанию заключается в том, что значения сравниваются строго посимвольно, а не в соответствии с правилами сопоставления для конкретной локали. Это делает эти классы операторов подходящими для использования в запросах, включающих выражения сопоставления с образцом ( регулярные выражения &lt;code&gt;LIKE&lt;/code&gt; или POSIX), когда база данных не использует стандартную локаль &amp;laquo;C&amp;raquo;. Например, вы можете проиндексировать столбец &lt;code&gt;varchar&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="33bad4a7b35adf68e8d48de054b950c2d1ec9c35" translate="yes" xml:space="preserve">
          <source>The operator family this entry is for</source>
          <target state="translated">Семейство операторов эта запись предназначена для</target>
        </trans-unit>
        <trans-unit id="223e98e65916141080aa613ffd5f9982aa449061" translate="yes" xml:space="preserve">
          <source>The operator name is a sequence of up to &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 (63 by default) characters from the following list:</source>
          <target state="translated">Имя оператора представляет собой последовательность до &lt;code&gt;NAMEDATALEN&lt;/code&gt; -1 (по умолчанию 63) символов из следующего списка:</target>
        </trans-unit>
        <trans-unit id="e93319af4ff4ab58e4fcfce194629f2f03f458a1" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; are equivalent to PostgreSQL's built-in operators of the same names, except that they work only on integer arrays that do not contain nulls, while the built-in operators work for any array type. This restriction makes them faster than the built-in operators in many cases.</source>
          <target state="translated">Операторы &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;@&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;@&lt;/code&gt; эквивалентны встроенным операторам PostgreSQL с такими же именами, за исключением того, что они работают только с целочисленными массивами, не содержащими нулей, а встроенные операторы работают с любыми типами массивов. Это ограничение во многих случаях делает их быстрее, чем встроенные операторы.</target>
        </trans-unit>
        <trans-unit id="a0d063cd8a5cd2a97ff1408a1433cc81fe5925af" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; have analogues &lt;code&gt;^&amp;lt;@&lt;/code&gt;, &lt;code&gt;^@&amp;gt;&lt;/code&gt;, &lt;code&gt;^@&lt;/code&gt;, &lt;code&gt;^~&lt;/code&gt;, which are the same except they do not use indexes. These are useful only for testing purposes.</source>
          <target state="translated">Операторы &lt;code&gt;&amp;lt;@&lt;/code&gt; , &lt;code&gt;@&amp;gt;&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; и &lt;code&gt;~&lt;/code&gt; имеют аналоги &lt;code&gt;^&amp;lt;@&lt;/code&gt; , &lt;code&gt;^@&amp;gt;&lt;/code&gt; , &lt;code&gt;^@&lt;/code&gt; , &lt;code&gt;^~&lt;/code&gt; , которые одинаковы, за исключением того, что они не используют индексы. Они полезны только для целей тестирования.</target>
        </trans-unit>
        <trans-unit id="fbca8888a118f48ef45503ea9b2b65638278cb3a" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; are commutative, that is, you can switch the left and right operand without affecting the result. But see &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt; for more information about the order of evaluation of subexpressions.</source>
          <target state="translated">Операторы &lt;code&gt;AND&lt;/code&gt; и &lt;code&gt;OR&lt;/code&gt; коммутативны, то есть вы можете переключать левый и правый операнд, не влияя на результат. Но см. &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Раздел 4.2.14&lt;/a&gt; для получения дополнительной информации о порядке вычисления подвыражений.</target>
        </trans-unit>
        <trans-unit id="ab3b948d9f1df6a05c6208cb2087918561197bec" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; are commutative, that is, you can switch the left and right operands without affecting the result. (However, it is not guaranteed that the left operand is evaluated before the right operand. See &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt; for more information about the order of evaluation of subexpressions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afda15b721563ddc4ee8a5707f908cf503dfae35" translate="yes" xml:space="preserve">
          <source>The operators provided by the &lt;code&gt;hstore&lt;/code&gt; module are shown in &lt;a href=&quot;hstore#HSTORE-OP-TABLE&quot;&gt;Table F.7&lt;/a&gt;, the functions in &lt;a href=&quot;hstore#HSTORE-FUNC-TABLE&quot;&gt;Table F.8&lt;/a&gt;.</source>
          <target state="translated">Операторы, предоставляемые модулем &lt;code&gt;hstore&lt;/code&gt; , показаны в &lt;a href=&quot;hstore#HSTORE-OP-TABLE&quot;&gt;таблице F.7&lt;/a&gt; , функции - в &lt;a href=&quot;hstore#HSTORE-FUNC-TABLE&quot;&gt;таблице F.8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43de536c659d022d6659ab7d7ed96e1f9a44966b" translate="yes" xml:space="preserve">
          <source>The operators should not be defined by SQL functions. A SQL function is likely to be inlined into the calling query, which will prevent the optimizer from recognizing that the query matches an index.</source>
          <target state="translated">Операторы не должны определяться функциями SQL.Скорее всего,SQL-функция будет встроена в вызывающий запрос,что не позволит оптимизатору распознать,что запрос соответствует индексу.</target>
        </trans-unit>
        <trans-unit id="c7779f9394f3c14857d843cdc250d88697a649fe" translate="yes" xml:space="preserve">
          <source>The optimal value for this option depends on the hardware setup of the server, of the client, and of the network. Factors include the number of CPU cores and the disk setup. A good place to start is the number of CPU cores on the server, but values larger than that can also lead to faster restore times in many cases. Of course, values that are too high will lead to decreased performance because of thrashing.</source>
          <target state="translated">Оптимальное значение для этого варианта зависит от аппаратной установки сервера,клиента и сети.Факторы включают количество процессорных ядер и настройку диска.Хорошим местом для начала является количество ядер процессора на сервере,но значения больше,чем это может также привести к более быстрому времени восстановления во многих случаях.Конечно,слишком высокие значения приведут к снижению производительности из-за &quot;мусора&quot;.</target>
        </trans-unit>
        <trans-unit id="d0eb1545843db39f7e5b62a874b3d76a7289a03a" translate="yes" xml:space="preserve">
          <source>The optimizer can also use a B-tree index for queries involving the pattern matching operators &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;&lt;em&gt;if&lt;/em&gt; the pattern is a constant and is anchored to the beginning of the string &amp;mdash; for example, &lt;code&gt;col LIKE 'foo%'&lt;/code&gt; or &lt;code&gt;col ~ '^foo'&lt;/code&gt;, but not &lt;code&gt;col LIKE '%bar'&lt;/code&gt;. However, if your database does not use the C locale you will need to create the index with a special operator class to support indexing of pattern-matching queries; see &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; below. It is also possible to use B-tree indexes for &lt;code&gt;ILIKE&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt;, but only if the pattern starts with non-alphabetic characters, i.e., characters that are not affected by upper/lower case conversion.</source>
          <target state="translated">Оптимизатор также может использовать индекс B-дерева для запросов, включающих операторы сопоставления с образцом &lt;code&gt;LIKE&lt;/code&gt; и &lt;code&gt;~&lt;/code&gt; ,&lt;em&gt;если&lt;/em&gt; образец является константой и привязан к началу строки - например, &lt;code&gt;col LIKE 'foo%'&lt;/code&gt; или &lt;code&gt;col ~ '^foo'&lt;/code&gt; , но не &lt;code&gt;col LIKE '%bar'&lt;/code&gt; . Однако, если ваша база данных не использует локаль C, вам потребуется создать индекс с помощью специального класса операторов для поддержки индексации запросов на сопоставление с образцом; см. &lt;a href=&quot;indexes-opclass&quot;&gt;Раздел 11.10&lt;/a&gt; ниже. Также можно использовать индексы B-дерева для &lt;code&gt;ILIKE&lt;/code&gt; и &lt;code&gt;~*&lt;/code&gt; , но только если шаблон начинается с неалфавитных символов, т. е. символов, на которые не влияет преобразование верхнего / нижнего регистра.</target>
        </trans-unit>
        <trans-unit id="8627270becb595b05140641f72d8445a0f79aa4e" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;STORED&lt;/code&gt; is not standard but is also used by other SQL implementations. The SQL standard does not specify the storage of generated columns.</source>
          <target state="translated">Параметр &lt;code&gt;STORED&lt;/code&gt; не является стандартным, но также используется другими реализациями SQL. Стандарт SQL не определяет хранение сгенерированных столбцов.</target>
        </trans-unit>
        <trans-unit id="a815faad2e87479a66432f285e1a514f8c1d46e0" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_basebackup doesn't connect to any particular database in the cluster, any database name in the connection string will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734d38a3ce131eec63febbaae7def3c5bde63bbb" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_basebackup doesn't connect to any particular database in the cluster, database name in the connection string will be ignored.</source>
          <target state="translated">Параметр называется &lt;code&gt;--dbname&lt;/code&gt; для согласованности с другими клиентскими приложениями, но поскольку pg_basebackup не подключается к какой-либо конкретной базе данных в кластере, имя базы данных в строке подключения будет проигнорировано.</target>
        </trans-unit>
        <trans-unit id="0db5016ffe3da0ce1e6c9b806713d2a3baee1dd9" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_dumpall needs to connect to many databases, the database name in the connection string will be ignored. Use the &lt;code&gt;-l&lt;/code&gt; option to specify the name of the database used for the initial connection, which will dump global objects and discover what other databases should be dumped.</source>
          <target state="translated">Параметр называется &lt;code&gt;--dbname&lt;/code&gt; для согласованности с другими клиентскими приложениями, но поскольку pg_dumpall необходимо подключаться ко многим базам данных, имя базы данных в строке подключения будет проигнорировано. Используйте параметр &lt;code&gt;-l&lt;/code&gt; , чтобы указать имя базы данных, используемой для начального соединения, которое будет сбрасывать глобальные объекты и определять, какие другие базы данных следует сбрасывать.</target>
        </trans-unit>
        <trans-unit id="b6f402f5f677410d43632fdfdda39802e1f95c15" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_receivewal doesn't connect to any particular database in the cluster, database name in the connection string will be ignored.</source>
          <target state="translated">Параметр называется &lt;code&gt;--dbname&lt;/code&gt; для согласованности с другими клиентскими приложениями, но поскольку pg_receivewal не подключается к какой-либо конкретной базе данных в кластере, имя базы данных в строке подключения будет проигнорировано.</target>
        </trans-unit>
        <trans-unit id="c7c64ec896dfd3c50e33366b062eb4c419c8b0b7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;CYCLE&lt;/code&gt; key word can be used to enable the sequence to wrap around when the &lt;code&gt;maxvalue&lt;/code&gt; or &lt;code&gt;minvalue&lt;/code&gt; has been reached by an ascending or descending sequence respectively. If the limit is reached, the next number generated will be the &lt;code&gt;minvalue&lt;/code&gt; or &lt;code&gt;maxvalue&lt;/code&gt;, respectively.</source>
          <target state="translated">Необязательное ключевое слово &lt;code&gt;CYCLE&lt;/code&gt; можно использовать, чтобы включить &lt;code&gt;maxvalue&lt;/code&gt; &lt;code&gt;minvalue&lt;/code&gt; последовательности, когда максимальное или минимальное значение было достигнуто посредством возрастающей или убывающей последовательности соответственно. Если предел достигнут, следующим сгенерированным числом будет &lt;code&gt;minvalue&lt;/code&gt; или &lt;code&gt;maxvalue&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="2bdec9ebdf4b00fd140bf7dd49f116ee6c5a4a50" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;GROUP BY&lt;/code&gt; clause has the general form</source>
          <target state="translated">Необязательное предложение &lt;code&gt;GROUP BY&lt;/code&gt; имеет общую форму</target>
        </trans-unit>
        <trans-unit id="9c06d7f3daaeb4524eeb820424e28a6752ac9545" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;HAVING&lt;/code&gt; clause has the general form</source>
          <target state="translated">Необязательное предложение &lt;code&gt;HAVING&lt;/code&gt; имеет общую форму</target>
        </trans-unit>
        <trans-unit id="e76a720d25d7bf8d3cf5b4abaa11a67203b026f7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause specifies a list of columns which will be included in the index as &lt;em&gt;non-key&lt;/em&gt; columns. A non-key column cannot be used in an index scan search qualification, and it is disregarded for purposes of any uniqueness or exclusion constraint enforced by the index. However, an index-only scan can return the contents of non-key columns without having to visit the index's table, since they are available directly from the index entry. Thus, addition of non-key columns allows index-only scans to be used for queries that otherwise could not use them.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;INCLUDE&lt;/code&gt; определяет список столбцов, которые будут включены в индекс как &lt;em&gt;неключевые&lt;/em&gt; столбцы. Неключевой столбец нельзя использовать в квалификационной оценке поиска при сканировании индекса, и он не учитывается в целях ограничения уникальности или исключения, налагаемого индексом. Однако сканирование только индекса может вернуть содержимое неключевых столбцов без необходимости посещать таблицу индекса, поскольку они доступны непосредственно из записи индекса. Таким образом, добавление неключевых столбцов позволяет использовать сканирование только индекса для запросов, которые в противном случае не могли бы их использовать.</target>
        </trans-unit>
        <trans-unit id="2aa8e8dd6edbe127a1d3d92fe785e89d8eca0bac" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INHERITS&lt;/code&gt; clause specifies a list of tables from which the new foreign table automatically inherits all columns. Parent tables can be plain tables or foreign tables. See the similar form of &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;INHERITS&lt;/code&gt; определяет список таблиц, от которых новая сторонняя таблица автоматически наследует все столбцы. Родительские таблицы могут быть простыми или сторонними. См. Аналогичную форму &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="d357ec942143a3e86ce2ca9c6595bccf9733322e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INHERITS&lt;/code&gt; clause specifies a list of tables from which the new table automatically inherits all columns. Parent tables can be plain tables or foreign tables.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;INHERITS&lt;/code&gt; определяет список таблиц, от которых новая таблица автоматически наследует все столбцы. Родительские таблицы могут быть простыми или сторонними.</target>
        </trans-unit>
        <trans-unit id="935c04d83e4414228c1da5a13e9997ce0d9aed17" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LANGUAGE&lt;/code&gt; clause can be written either before or after the code block.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;LANGUAGE&lt;/code&gt; может быть написано до или после блока кода.</target>
        </trans-unit>
        <trans-unit id="4b362bf605fea7a639d64d32d41debf1c9b97b1a" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;ON CONFLICT&lt;/code&gt; clause specifies an alternative action to raising a unique violation or exclusion constraint violation error. For each individual row proposed for insertion, either the insertion proceeds, or, if an &lt;em&gt;arbiter&lt;/em&gt; constraint or index specified by &lt;em&gt;&lt;code&gt;conflict_target&lt;/code&gt;&lt;/em&gt; is violated, the alternative &lt;em&gt;&lt;code&gt;conflict_action&lt;/code&gt;&lt;/em&gt; is taken. &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; simply avoids inserting a row as its alternative action. &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; updates the existing row that conflicts with the row proposed for insertion as its alternative action.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;ON CONFLICT&lt;/code&gt; указывает действие, альтернативное возникновению уникального нарушения или ошибки нарушения ограничения исключения. Для каждой отдельной строки , предложенная для вставки, либо вставка продолжается, или, если &lt;em&gt;арбитр&lt;/em&gt; ограничение или индекс определяется &lt;em&gt; &lt;code&gt;conflict_target&lt;/code&gt; &lt;/em&gt; нарушаются, альтернативный &lt;em&gt; &lt;code&gt;conflict_action&lt;/code&gt; &lt;/em&gt; берется. &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; просто позволяет избежать вставки строки в качестве альтернативного действия. &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; обновляет существующую строку, которая конфликтует со строкой, предложенной для вставки в качестве альтернативного действия.</target>
        </trans-unit>
        <trans-unit id="d5dd05dee5b8b79438a7ed8440a1b3f1d3a71ea3" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;ORDER BY&lt;/code&gt; clause has this general form:</source>
          <target state="translated">Необязательное предложение &lt;code&gt;ORDER BY&lt;/code&gt; имеет следующую общую форму:</target>
        </trans-unit>
        <trans-unit id="7116353ef7e307ca01f79a625c49cbb834ed45dc" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;PARTITION BY&lt;/code&gt; clause specifies a strategy of partitioning the table. The table thus created is called a &lt;em&gt;partitioned&lt;/em&gt; table. The parenthesized list of columns or expressions forms the &lt;em&gt;partition key&lt;/em&gt; for the table. When using range or hash partitioning, the partition key can include multiple columns or expressions (up to 32, but this limit can be altered when building PostgreSQL), but for list partitioning, the partition key must consist of a single column or expression.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;PARTITION BY&lt;/code&gt; определяет стратегию разделения таблицы. Созданная таким образом таблица называется &lt;em&gt;многораздельной&lt;/em&gt; . Заключенный в скобки список столбцов или выражений образует &lt;em&gt;ключ раздела&lt;/em&gt; для таблицы. При использовании разделения по диапазону или хешу ключ раздела может включать несколько столбцов или выражений (до 32, но это ограничение можно изменить при построении PostgreSQL), но для разделения по списку ключ раздела должен состоять из одного столбца или выражения.</target>
        </trans-unit>
        <trans-unit id="f6243054cea2c976be92eb3f4ea9df686539e824" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RECURSIVE&lt;/code&gt; modifier changes &lt;code&gt;WITH&lt;/code&gt; from a mere syntactic convenience into a feature that accomplishes things not otherwise possible in standard SQL. Using &lt;code&gt;RECURSIVE&lt;/code&gt;, a &lt;code&gt;WITH&lt;/code&gt; query can refer to its own output. A very simple example is this query to sum the integers from 1 through 100:</source>
          <target state="translated">Необязательный модификатор &lt;code&gt;RECURSIVE&lt;/code&gt; превращает &lt;code&gt;WITH&lt;/code&gt; из простого синтаксического удобства в функцию, которая выполняет то, что иначе невозможно в стандартном SQL. Используя &lt;code&gt;RECURSIVE&lt;/code&gt; , запрос &lt;code&gt;WITH&lt;/code&gt; может ссылаться на собственный вывод. Очень простой пример - это запрос для суммирования целых чисел от 1 до 100:</target>
        </trans-unit>
        <trans-unit id="fadff698169cd4951ccc6a878ef428bb081f97f0" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;REPEATABLE&lt;/code&gt; clause specifies a &lt;code&gt;seed&lt;/code&gt; number or expression to use for generating random numbers within the sampling method. The seed value can be any non-null floating-point value. Two queries that specify the same seed and &lt;code&gt;argument&lt;/code&gt; values will select the same sample of the table, if the table has not been changed meanwhile. But different seed values will usually produce different samples. If &lt;code&gt;REPEATABLE&lt;/code&gt; is not given then a new random sample is selected for each query, based upon a system-generated seed. Note that some add-on sampling methods do not accept &lt;code&gt;REPEATABLE&lt;/code&gt;, and will always produce new samples on each use.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;REPEATABLE&lt;/code&gt; определяет &lt;code&gt;seed&lt;/code&gt; число или выражение, используемое для генерации случайных чисел в методе выборки. Начальное значение может быть любым ненулевым значением с плавающей запятой. Два запроса, в которых указаны одинаковые начальные значения и значения &lt;code&gt;argument&lt;/code&gt; выберут один и тот же образец таблицы, если таблица за это время не была изменена. Но разные значения семян обычно дают разные образцы. Если &lt;code&gt;REPEATABLE&lt;/code&gt; не указан, то для каждого запроса выбирается новая случайная выборка на основе сгенерированного системой начального числа. Обратите внимание, что некоторые дополнительные методы выборки не принимают &lt;code&gt;REPEATABLE&lt;/code&gt; и всегда будут создавать новые образцы при каждом использовании.</target>
        </trans-unit>
        <trans-unit id="8777d7f8d07792d4f3e98ee0b8208d63db9f0b46" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;DELETE&lt;/code&gt; to compute and return value(s) based on each row actually deleted. Any expression using the table's columns, and/or columns of other tables mentioned in &lt;code&gt;USING&lt;/code&gt;, can be computed. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;RETURNING&lt;/code&gt; заставляет &lt;code&gt;DELETE&lt;/code&gt; вычислять и возвращать значение (я) на основе каждой фактически удаленной строки. Может быть вычислено любое выражение, использующее столбцы таблицы и / или столбцы других таблиц, упомянутых в &lt;code&gt;USING&lt;/code&gt; . Синтаксис списка &lt;code&gt;RETURNING&lt;/code&gt; идентичен синтаксису списка вывода &lt;code&gt;SELECT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3578c21272426a6d018e36dbe114df05af571e18" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;INSERT&lt;/code&gt; to compute and return value(s) based on each row actually inserted (or updated, if an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause was used). This is primarily useful for obtaining values that were supplied by defaults, such as a serial sequence number. However, any expression using the table's columns is allowed. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;. Only rows that were successfully inserted or updated will be returned. For example, if a row was locked but not updated because an &lt;code&gt;ON CONFLICT DO UPDATE ... WHERE&lt;/code&gt; clause &lt;code&gt;condition&lt;/code&gt; was not satisfied, the row will not be returned.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;RETURNING&lt;/code&gt; заставляет &lt;code&gt;INSERT&lt;/code&gt; вычислить и вернуть значение (я) на основе каждой фактически вставленной (или обновленной) строки, если использовалось предложение &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; ). Это в первую очередь полезно для получения значений, которые были предоставлены по умолчанию, таких как порядковый номер. Однако допускается любое выражение, использующее столбцы таблицы. Синтаксис списка &lt;code&gt;RETURNING&lt;/code&gt; идентичен синтаксису списка вывода &lt;code&gt;SELECT&lt;/code&gt; . Будут возвращены только те строки, которые были успешно вставлены или обновлены. Например, если строка была заблокирована, но не обновлена ​​из-за &lt;code&gt;ON CONFLICT DO UPDATE ... WHERE&lt;/code&gt; &lt;code&gt;condition&lt;/code&gt; предложения ON CONFLICT DO UPDATE ... WHERE , строка не будет возвращена.</target>
        </trans-unit>
        <trans-unit id="26fec39eb66cc8ba300ea17034aad6e1ab719ea0" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;UPDATE&lt;/code&gt; to compute and return value(s) based on each row actually updated. Any expression using the table's columns, and/or columns of other tables mentioned in &lt;code&gt;FROM&lt;/code&gt;, can be computed. The new (post-update) values of the table's columns are used. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;RETURNING&lt;/code&gt; заставляет &lt;code&gt;UPDATE&lt;/code&gt; вычислять и возвращать значение (я) на основе каждой фактически обновленной строки. Может быть вычислено любое выражение, использующее столбцы таблицы и / или столбцы других таблиц, упомянутых в &lt;code&gt;FROM&lt;/code&gt; . Используются новые (после обновления) значения столбцов таблицы. Синтаксис списка &lt;code&gt;RETURNING&lt;/code&gt; идентичен синтаксису списка вывода &lt;code&gt;SELECT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7038a19db2dc16317b16f8d00a20421d7087db41" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WHERE&lt;/code&gt; clause has the general form</source>
          <target state="translated">Необязательное &lt;code&gt;WHERE&lt;/code&gt; имеет общую форму</target>
        </trans-unit>
        <trans-unit id="7792c91023d2f01afcab3c87bb09f61e0ba95957" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses in the table expression specify a pipeline of successive transformations performed on the table derived in the &lt;code&gt;FROM&lt;/code&gt; clause. All these transformations produce a virtual table that provides the rows that are passed to the select list to compute the output rows of the query.</source>
          <target state="translated">Необязательные &lt;code&gt;WHERE&lt;/code&gt; , &lt;code&gt;GROUP BY&lt;/code&gt; и &lt;code&gt;HAVING&lt;/code&gt; в табличном выражении определяют конвейер последовательных преобразований, выполняемых в таблице, полученной в предложении &lt;code&gt;FROM&lt;/code&gt; . Все эти преобразования создают виртуальную таблицу, которая предоставляет строки, которые передаются в список выбора для вычисления выходных строк запроса.</target>
        </trans-unit>
        <trans-unit id="8a3824e49e923ca91de9f24e0e18785c61620d57" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WINDOW&lt;/code&gt; clause has the general form</source>
          <target state="translated">Необязательное предложение &lt;code&gt;WINDOW&lt;/code&gt; имеет общую форму</target>
        </trans-unit>
        <trans-unit id="0734bf4cc1224dac3864d0137b3f27ef1692d40c" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WITH&lt;/code&gt; clause specifies &lt;em&gt;storage parameters&lt;/em&gt; for the index. Each index method has its own set of allowed storage parameters. The B-tree, hash, GiST and SP-GiST index methods all accept this parameter:</source>
          <target state="translated">Необязательное предложение &lt;code&gt;WITH&lt;/code&gt; определяет &lt;em&gt;параметры хранения&lt;/em&gt; для индекса. Каждый индексный метод имеет собственный набор разрешенных параметров хранения. Все методы индексации B-tree, hash, GiST и SP-GiST принимают этот параметр:</target>
        </trans-unit>
        <trans-unit id="a2ab89e063673dbb227b7d91abdf56f04b8f9bc9" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;XMLNAMESPACES&lt;/code&gt; clause gives a comma-separated list of namespace definitions, where each &lt;code&gt;namespace_uri&lt;/code&gt; is a &lt;code&gt;text&lt;/code&gt; expression and each &lt;code&gt;namespace_name&lt;/code&gt; is a simple identifier. It specifies the XML namespaces used in the document and their aliases. A default namespace specification is not currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058389bedd0ce52c16be7bfd9114242b91506b69" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;XMLNAMESPACES&lt;/code&gt; clause is a comma-separated list of namespaces. It specifies the XML namespaces used in the document and their aliases. A default namespace specification is not currently supported.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;XMLNAMESPACES&lt;/code&gt; представляет собой список пространств имен, разделенных запятыми. Он определяет пространства имен XML, используемые в документе, и их псевдонимы. Спецификация пространства имен по умолчанию в настоящее время не поддерживается.</target>
        </trans-unit>
        <trans-unit id="57ded7b498b198ec6bfc70d87458a99fd28a21d6" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;analyze_function&lt;/code&gt; performs type-specific statistics collection for columns of the data type. By default, &lt;code&gt;ANALYZE&lt;/code&gt; will attempt to gather statistics using the type's &amp;ldquo;equals&amp;rdquo; and &amp;ldquo;less-than&amp;rdquo; operators, if there is a default b-tree operator class for the type. For non-scalar types this behavior is likely to be unsuitable, so it can be overridden by specifying a custom analysis function. The analysis function must be declared to take a single argument of type &lt;code&gt;internal&lt;/code&gt;, and return a &lt;code&gt;boolean&lt;/code&gt; result. The detailed API for analysis functions appears in &lt;code&gt;src/include/commands/vacuum.h&lt;/code&gt;.</source>
          <target state="translated">Необязательная &lt;code&gt;analyze_function&lt;/code&gt; выполняет сбор статистики для столбцов данного типа данных. По умолчанию &lt;code&gt;ANALYZE&lt;/code&gt; будет пытаться собрать статистику с помощью операторов типа &amp;laquo;равно&amp;raquo; и &amp;laquo;меньше&amp;raquo;, если для типа существует класс операторов b-дерева по умолчанию. Для нескалярных типов такое поведение может быть неподходящим, поэтому его можно изменить, указав пользовательскую функцию анализа. Функция анализа должна быть объявлена ​​так, чтобы она принимала единственный аргумент типа &lt;code&gt;internal&lt;/code&gt; и возвращала &lt;code&gt;boolean&lt;/code&gt; результат. Подробный API для функций анализа находится в &lt;code&gt;src/include/commands/vacuum.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7747a49a90a7a4edd6982d5e13265f6731caae73" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;canonical&lt;/code&gt; function must take one argument of the range type being defined, and return a value of the same type. This is used to convert range values to a canonical form, when applicable. See &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;Section 8.17.8&lt;/a&gt; for more information. Creating a &lt;code&gt;canonical&lt;/code&gt; function is a bit tricky, since it must be defined before the range type can be declared. To do this, you must first create a shell type, which is a placeholder type that has no properties except a name and an owner. This is done by issuing the command &lt;code&gt;CREATE TYPE name&lt;/code&gt;, with no additional parameters. Then the function can be declared using the shell type as argument and result, and finally the range type can be declared using the same name. This automatically replaces the shell type entry with a valid range type.</source>
          <target state="translated">Необязательная &lt;code&gt;canonical&lt;/code&gt; функция должна принимать один аргумент определенного типа диапазона и возвращать значение того же типа. Это используется для преобразования значений диапазона в каноническую форму, когда это применимо. См &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;раздел 8.17.8&lt;/a&gt; для получения дополнительной информации. Создание &lt;code&gt;canonical&lt;/code&gt; функции немного сложно, так как она должна быть определена до объявления типа диапазона. Для этого вы должны сначала создать тип оболочки, который является типом-заполнителем, не имеющим свойств, кроме имени и владельца. Это делается с помощью команды &lt;code&gt;CREATE TYPE name&lt;/code&gt; ., без дополнительных параметров. Затем функция может быть объявлена ​​с использованием типа оболочки в качестве аргумента и результата, и, наконец, тип диапазона может быть объявлен с тем же именем. Это автоматически заменяет запись типа оболочки допустимым типом диапазона.</target>
        </trans-unit>
        <trans-unit id="e405c33bd06f9fd7d49a367fa9d3ceab7c5a9a0c" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;flag&lt;/code&gt; string may include one or more of the characters &lt;code&gt;i&lt;/code&gt; for case-insensitive match, &lt;code&gt;m&lt;/code&gt; to allow &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to match at newlines, &lt;code&gt;s&lt;/code&gt; to allow &lt;code&gt;.&lt;/code&gt; to match a newline, and &lt;code&gt;q&lt;/code&gt; to quote the whole pattern (reducing the behavior to a simple substring match).</source>
          <target state="translated">Необязательная строка &lt;code&gt;flag&lt;/code&gt; может включать в себя один или несколько символов &lt;code&gt;i&lt;/code&gt; для соответствия без учета регистра, &lt;code&gt;m&lt;/code&gt; , чтобы разрешить &lt;code&gt;^&lt;/code&gt; и &lt;code&gt;$&lt;/code&gt; , чтобы соответствовать символам новой строки, &lt;code&gt;s&lt;/code&gt; , чтобы разрешить &lt;code&gt;.&lt;/code&gt; для соответствия новой строке и &lt;code&gt;q&lt;/code&gt; , чтобы заключить в кавычки весь шаблон (сводя поведение к простому совпадению подстроки).</target>
        </trans-unit>
        <trans-unit id="6929038d2d7ee1cd89d49d3d8b27997b9126c9d2" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;frame_clause&lt;/code&gt; can be one of</source>
          <target state="translated">Необязательное предложение &lt;code&gt;frame_clause&lt;/code&gt; может быть одним из</target>
        </trans-unit>
        <trans-unit id="1a0ad788554501dd9d4e6143a34e5057b31ec466" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;frame_clause&lt;/code&gt; defines the &lt;em&gt;window frame&lt;/em&gt; for window functions that depend on the frame (not all do). The window frame is a set of related rows for each row of the query (called the &lt;em&gt;current row&lt;/em&gt;). The &lt;code&gt;frame_clause&lt;/code&gt; can be one of</source>
          <target state="translated">Необязательное предложение &lt;code&gt;frame_clause&lt;/code&gt; определяет &lt;em&gt;рамку окна&lt;/em&gt; для оконных функций, которые зависят от рамки (не все так). Рамка окна - это набор связанных строк для каждой строки запроса (называемой &lt;em&gt;текущей строкой&lt;/em&gt; ). &lt;code&gt;frame_clause&lt;/code&gt; может быть один из</target>
        </trans-unit>
        <trans-unit id="78c603df9d8f5aec2127eee4c089f14a6a63935b" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;like_option&lt;/code&gt; clauses specify which additional properties of the original table to copy. Specifying &lt;code&gt;INCLUDING&lt;/code&gt; copies the property, specifying &lt;code&gt;EXCLUDING&lt;/code&gt; omits the property. &lt;code&gt;EXCLUDING&lt;/code&gt; is the default. If multiple specifications are made for the same kind of object, the last one is used. The available options are:</source>
          <target state="translated">Необязательные предложения &lt;code&gt;like_option&lt;/code&gt; указывают, какие дополнительные свойства исходной таблицы нужно копировать. Указание &lt;code&gt;INCLUDING&lt;/code&gt; копирует свойство, указание &lt;code&gt;EXCLUDING&lt;/code&gt; пропускает свойство. &lt;code&gt;EXCLUDING&lt;/code&gt; - это значение по умолчанию. Если для одного и того же типа объекта сделано несколько спецификаций, используется последняя из них. Доступные варианты:</target>
        </trans-unit>
        <trans-unit id="3b1514641d42b559d683d1926252a8c2e4d381f2" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;receive_function&lt;/code&gt; converts the type's external binary representation to the internal representation. If this function is not supplied, the type cannot participate in binary input. The binary representation should be chosen to be cheap to convert to internal form, while being reasonably portable. (For example, the standard integer data types use network byte order as the external binary representation, while the internal representation is in the machine's native byte order.) The receive function should perform adequate checking to ensure that the value is valid. The receive function can be declared as taking one argument of type &lt;code&gt;internal&lt;/code&gt;, or as taking three arguments of types &lt;code&gt;internal&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;. The first argument is a pointer to a &lt;code&gt;StringInfo&lt;/code&gt; buffer holding the received byte string; the optional arguments are the same as for the text input function. The receive function must return a value of the data type itself. Usually, a receive function should be declared STRICT; if it is not, it will be called with a NULL first parameter when reading a NULL input value. The function must still return NULL in this case, unless it raises an error. (This case is mainly meant to support domain receive functions, which might need to reject NULL inputs.) Similarly, the optional &lt;code&gt;send_function&lt;/code&gt; converts from the internal representation to the external binary representation. If this function is not supplied, the type cannot participate in binary output. The send function must be declared as taking one argument of the new data type. The send function must return type &lt;code&gt;bytea&lt;/code&gt;. Send functions are not invoked for NULL values.</source>
          <target state="translated">Необязательная &lt;code&gt;receive_function&lt;/code&gt; преобразует внешнее двоичное представление типа во внутреннее представление. Если эта функция не указана, тип не может участвовать в двоичном вводе. Двоичное представление следует выбирать таким образом, чтобы оно было дешевым для преобразования во внутреннюю форму и при этом было достаточно переносимым. (Например, стандартные целочисленные типы данных используют сетевой порядок байтов в качестве внешнего двоичного представления, в то время как внутреннее представление находится в собственном порядке байтов машины.) Функция приема должна выполнять соответствующую проверку, чтобы гарантировать, что значение является допустимым. Функция приема может быть объявлена ​​как принимающая один аргумент типа &lt;code&gt;internal&lt;/code&gt; или как принимающая три аргумента типа &lt;code&gt;internal&lt;/code&gt; , &lt;code&gt;oid&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; .. Первый аргумент - это указатель на буфер &lt;code&gt;StringInfo&lt;/code&gt; , содержащий полученную строку байтов; необязательные аргументы такие же, как для функции ввода текста. Функция приема должна возвращать значение самого типа данных. Обычно функцию приема следует объявлять STRICT; если это не так, он будет вызываться с первым параметром NULL при чтении входного значения NULL. В этом случае функция все равно должна возвращать NULL, если только она не вызывает ошибку. (Этот случай в основном предназначен для поддержки функций приема домена, которым может потребоваться отклонять входные данные NULL.) Аналогично, необязательная &lt;code&gt;send_function&lt;/code&gt; преобразует внутреннее представление во внешнее двоичное представление. Если эта функция не указана, тип не может участвовать в двоичном выводе. Функция отправки должна быть объявлена ​​как принимающая один аргумент нового типа данных. Функция отправки должна возвращать тип &lt;code&gt;bytea&lt;/code&gt; . Функции отправки не вызываются для значений NULL.</target>
        </trans-unit>
        <trans-unit id="7d7acb9837f1f10a2e0445707407528f679ac86a" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;sequence_options&lt;/code&gt; clause can be used to override the options of the sequence. See &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; for details.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;sequence_options&lt;/code&gt; может использоваться для переопределения параметров последовательности. Подробнее см. &lt;a href=&quot;sql-createsequence&quot;&gt;СОЗДАТЬ ПОСЛЕДОВАТЕЛЬНОСТЬ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bcdb21e727a9ca38cf42b2a6d25b5e2872506f6" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;subtype_diff&lt;/code&gt; function must take two values of the &lt;code&gt;subtype&lt;/code&gt; type as argument, and return a &lt;code&gt;double precision&lt;/code&gt; value representing the difference between the two given values. While this is optional, providing it allows much greater efficiency of GiST indexes on columns of the range type. See &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;Section 8.17.8&lt;/a&gt; for more information.</source>
          <target state="translated">Необязательная функция &lt;code&gt;subtype_diff&lt;/code&gt; должна принимать в качестве аргумента два значения типа &lt;code&gt;subtype&lt;/code&gt; и возвращать значение &lt;code&gt;double precision&lt;/code&gt; представляющее разницу между двумя заданными значениями. Хотя это необязательно, но при условии, что это позволяет значительно повысить эффективность индексов GiST для столбцов типа диапазона. См &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;раздел 8.17.8&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="1325ceadd1cae01690d39e7c916f8ac8cf741797" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;type_modifier_input_function&lt;/code&gt; and &lt;code&gt;type_modifier_output_function&lt;/code&gt; are needed if the type supports modifiers, that is optional constraints attached to a type declaration, such as &lt;code&gt;char(5)&lt;/code&gt; or &lt;code&gt;numeric(30,2)&lt;/code&gt;. PostgreSQL allows user-defined types to take one or more simple constants or identifiers as modifiers. However, this information must be capable of being packed into a single non-negative integer value for storage in the system catalogs. The &lt;code&gt;type_modifier_input_function&lt;/code&gt; is passed the declared modifier(s) in the form of a &lt;code&gt;cstring&lt;/code&gt; array. It must check the values for validity (throwing an error if they are wrong), and if they are correct, return a single non-negative &lt;code&gt;integer&lt;/code&gt; value that will be stored as the column &amp;ldquo;typmod&amp;rdquo;. Type modifiers will be rejected if the type does not have a &lt;code&gt;type_modifier_input_function&lt;/code&gt;. The &lt;code&gt;type_modifier_output_function&lt;/code&gt; converts the internal integer typmod value back to the correct form for user display. It must return a &lt;code&gt;cstring&lt;/code&gt; value that is the exact string to append to the type name; for example &lt;code&gt;numeric&lt;/code&gt;'s function might return &lt;code&gt;(30,2)&lt;/code&gt;. It is allowed to omit the &lt;code&gt;type_modifier_output_function&lt;/code&gt;, in which case the default display format is just the stored typmod integer value enclosed in parentheses.</source>
          <target state="translated">Необязательные &lt;code&gt;type_modifier_input_function&lt;/code&gt; и &lt;code&gt;type_modifier_output_function&lt;/code&gt; необходимы, если тип поддерживает модификаторы, то есть необязательные ограничения, прикрепленные к объявлению типа, такие как &lt;code&gt;char(5)&lt;/code&gt; или &lt;code&gt;numeric(30,2)&lt;/code&gt; . PostgreSQL позволяет определяемым пользователем типам принимать в качестве модификаторов одну или несколько простых констант или идентификаторов. Однако эта информация должна быть способна упаковываться в одно неотрицательное целое число для хранения в системных каталогах. В &lt;code&gt;type_modifier_input_function&lt;/code&gt; передается объявленный модификатор (-ы) в виде массива &lt;code&gt;cstring&lt;/code&gt; . Он должен проверять значения на достоверность (выдавать ошибку, если они неправильные), и, если они верны, возвращать один неотрицательный &lt;code&gt;integer&lt;/code&gt; значение, которое будет сохранено как столбец &amp;laquo;typmod&amp;raquo;. Модификаторы типа будут отклонены, если тип не имеет &lt;code&gt;type_modifier_input_function&lt;/code&gt; . Функция &lt;code&gt;type_modifier_output_function&lt;/code&gt; преобразует внутреннее целочисленное значение typmod обратно в правильную форму для отображения пользователем. Он должен возвращать значение &lt;code&gt;cstring&lt;/code&gt; , которое является точной строкой, добавляемой к имени типа; например , функция &lt;code&gt;numeric&lt;/code&gt; может вернуть &lt;code&gt;(30,2)&lt;/code&gt; . Разрешено опускать &lt;code&gt;type_modifier_output_function&lt;/code&gt; , и в этом случае формат отображения по умолчанию - это просто сохраненное целочисленное значение typmod, заключенное в круглые скобки.</target>
        </trans-unit>
        <trans-unit id="af1ecc2cb7dfd4fb66fffd97bf916a5a132fb429" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;AS data_type&lt;/code&gt; changes the data type of the sequence. Valid types are &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt;.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;AS data_type&lt;/code&gt; изменяет тип данных последовательности. Допустимые типы: &lt;code&gt;smallint&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; и &lt;code&gt;bigint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6491ae8d81a26646c521265ecd71bb3dba07346" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;AS data_type&lt;/code&gt; specifies the data type of the sequence. Valid types are &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt;. &lt;code&gt;bigint&lt;/code&gt; is the default. The data type determines the default minimum and maximum values of the sequence.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;AS data_type&lt;/code&gt; указывает тип данных последовательности. Допустимые типы: &lt;code&gt;smallint&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; и &lt;code&gt;bigint&lt;/code&gt; . &lt;code&gt;bigint&lt;/code&gt; умолчанию используется bigint . Тип данных определяет минимальное и максимальное значения последовательности по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4ef52006c6e494bfa443e060a826bdc36541e6b7" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;CACHE cache&lt;/code&gt; specifies how many sequence numbers are to be preallocated and stored in memory for faster access. The minimum value is 1 (only one value can be generated at a time, i.e., no cache), and this is also the default.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;CACHE cache&lt;/code&gt; указывает, сколько порядковых номеров должно быть предварительно выделено и сохранено в памяти для более быстрого доступа. Минимальное значение - 1 (единовременно может быть сгенерировано только одно значение, т. Е. Без кеша), и это также значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e1922af2324c94734b798d29c69dd1e6a8cd6788" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;INCREMENT BY increment&lt;/code&gt; specifies which value is added to the current sequence value to create a new value. A positive value will make an ascending sequence, a negative one a descending sequence. The default value is 1.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;INCREMENT BY increment&lt;/code&gt; указывает, какое значение добавляется к текущему значению последовательности для создания нового значения. Положительное значение образует восходящую последовательность, отрицательное - убывающую. Значение по умолчанию - 1.</target>
        </trans-unit>
        <trans-unit id="129d57b7ace9b8671169f53fc01dbaf732d5dd2a" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; determines the maximum value for the sequence. If &lt;code&gt;NO MAXVALUE&lt;/code&gt; is specified, the defaults of the maximum value of the data type and -1 for ascending and descending sequences, respectively, will be used. If neither option is specified, the current maximum value will be maintained.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; определяет максимальное значение для последовательности. Если &lt;code&gt;NO MAXVALUE&lt;/code&gt; , будут использоваться значения по умолчанию максимального значения типа данных и -1 для восходящей и нисходящей последовательностей соответственно. Если ни одна из опций не указана, будет сохранено текущее максимальное значение.</target>
        </trans-unit>
        <trans-unit id="636d2219bc9ef5ee8fa4e79b4cd4c563ed5f1551" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; determines the maximum value for the sequence. If this clause is not supplied or &lt;code&gt;NO MAXVALUE&lt;/code&gt; is specified, then default values will be used. The default for an ascending sequence is the maximum value of the data type. The default for a descending sequence is -1.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; определяет максимальное значение для последовательности. Если это предложение не указано или не указано &lt;code&gt;NO MAXVALUE&lt;/code&gt; , будут использоваться значения по умолчанию. По умолчанию для возрастающей последовательности установлено максимальное значение типа данных. По умолчанию для убывающей последовательности -1.</target>
        </trans-unit>
        <trans-unit id="c5eb2614e0e305c391d790e5028cc9a0dac1d3fe" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MINVALUE minvalue&lt;/code&gt; determines the minimum value a sequence can generate. If &lt;code&gt;NO MINVALUE&lt;/code&gt; is specified, the defaults of 1 and the minimum value of the data type for ascending and descending sequences, respectively, will be used. If neither option is specified, the current minimum value will be maintained.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;MINVALUE minvalue&lt;/code&gt; определяет минимальное значение, которое может генерировать последовательность. Если не указано &lt;code&gt;NO MINVALUE&lt;/code&gt; , будут использоваться значения по умолчанию 1 и минимальное значение типа данных для восходящей и нисходящей последовательностей соответственно. Если ни одна из опций не указана, будет сохранено текущее минимальное значение.</target>
        </trans-unit>
        <trans-unit id="e9e2bcb7eb75a3afb340c5c1fc227a8406ff8640" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MINVALUE minvalue&lt;/code&gt; determines the minimum value a sequence can generate. If this clause is not supplied or &lt;code&gt;NO MINVALUE&lt;/code&gt; is specified, then defaults will be used. The default for an ascending sequence is 1. The default for a descending sequence is the minimum value of the data type.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;MINVALUE minvalue&lt;/code&gt; определяет минимальное значение, которое может генерировать последовательность. Если это предложение не указано или &lt;code&gt;NO MINVALUE&lt;/code&gt; , будут использоваться значения по умолчанию. По умолчанию для восходящей последовательности установлено 1. По умолчанию для нисходящей последовательности установлено минимальное значение типа данных.</target>
        </trans-unit>
        <trans-unit id="fcd2de5b18440bca469ca6adbeb6f5f5db2e6405" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;RESTART [ WITH restart ]&lt;/code&gt; changes the current value of the sequence. This is similar to calling the &lt;code&gt;setval&lt;/code&gt; function with &lt;code&gt;is_called&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt;: the specified value will be returned by the &lt;em&gt;next&lt;/em&gt; call of &lt;code&gt;nextval&lt;/code&gt;. Writing &lt;code&gt;RESTART&lt;/code&gt; with no &lt;code&gt;restart&lt;/code&gt; value is equivalent to supplying the start value that was recorded by &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; or last set by &lt;code&gt;ALTER SEQUENCE START WITH&lt;/code&gt;.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;RESTART [ WITH restart ]&lt;/code&gt; изменяет текущее значение последовательности. Это похоже на вызов функции &lt;code&gt;setval&lt;/code&gt; с &lt;code&gt;is_called&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; : указанное значение будет возвращено при &lt;em&gt;следующем&lt;/em&gt; вызове &lt;code&gt;nextval&lt;/code&gt; . Запись &lt;code&gt;RESTART&lt;/code&gt; без значения &lt;code&gt;restart&lt;/code&gt; эквивалентна предоставлению начального значения, которое было записано &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; или последним установлено &lt;code&gt;ALTER SEQUENCE START WITH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fb28acc2fa41aa8ead28a09cd415f780a8cadf0" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;START WITH start&lt;/code&gt; allows the sequence to begin anywhere. The default starting value is &lt;code&gt;minvalue&lt;/code&gt; for ascending sequences and &lt;code&gt;maxvalue&lt;/code&gt; for descending ones.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;START WITH start&lt;/code&gt; позволяет последовательности начинаться где угодно. Начальным значением по умолчанию является &lt;code&gt;minvalue&lt;/code&gt; для возрастающих последовательностей и &lt;code&gt;maxvalue&lt;/code&gt; для убывающих.</target>
        </trans-unit>
        <trans-unit id="eb785729e5f5d903e46bb6918c0a11aa04baffd1" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;START WITH start&lt;/code&gt; changes the recorded start value of the sequence. This has no effect on the &lt;em&gt;current&lt;/em&gt; sequence value; it simply sets the value that future &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; commands will use.</source>
          <target state="translated">Необязательное предложение &lt;code&gt;START WITH start&lt;/code&gt; изменяет записанное начальное значение последовательности. Это не влияет на &lt;em&gt;текущее&lt;/em&gt; значение последовательности; он просто устанавливает значение, которое будут использовать будущие команды &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1713a9e1e99f66c0bcfe7df0c08c776ea8b0c311" translate="yes" xml:space="preserve">
          <source>The optional constraint clauses specify constraints (tests) that new or updated rows must satisfy for an insert or update operation to succeed. A constraint is an SQL object that helps define the set of valid values in the table in various ways.</source>
          <target state="translated">Необязательные клаузулы об ограничениях определяют ограничения (тесты),которым должны удовлетворять новые или обновленные строки,чтобы операция вставки или обновления прошла успешно.Ограничение-это SQL-объект,который различными способами помогает определить набор допустимых значений в таблице.</target>
        </trans-unit>
        <trans-unit id="e18e0d61bcb7c9d71d791c91de29bb60405c83c7" translate="yes" xml:space="preserve">
          <source>The optional flag &lt;code&gt;PASSEDBYVALUE&lt;/code&gt; indicates that values of this data type are passed by value, rather than by reference. Types passed by value must be fixed-length, and their internal representation cannot be larger than the size of the &lt;code&gt;Datum&lt;/code&gt; type (4 bytes on some machines, 8 bytes on others).</source>
          <target state="translated">Необязательный флаг &lt;code&gt;PASSEDBYVALUE&lt;/code&gt; указывает, что значения этого типа данных передаются по значению, а не по ссылке. Типы, передаваемые по значению, должны иметь фиксированную длину, и их внутреннее представление не может быть больше, чем размер типа &lt;code&gt;Datum&lt;/code&gt; (4 байта на некоторых машинах, 8 байтов на других).</target>
        </trans-unit>
        <trans-unit id="96f5588e1c2e2855ea8548eee4502bfe5b21503f" translate="yes" xml:space="preserve">
          <source>The optional parameter &lt;code&gt;PATTERN&lt;/code&gt; can be the name of a text search object, optionally schema-qualified. If &lt;code&gt;PATTERN&lt;/code&gt; is omitted then information about all visible objects will be displayed. &lt;code&gt;PATTERN&lt;/code&gt; can be a regular expression and can provide &lt;em&gt;separate&lt;/em&gt; patterns for the schema and object names. The following examples illustrate this:</source>
          <target state="translated">Необязательный параметр &lt;code&gt;PATTERN&lt;/code&gt; может быть именем объекта текстового поиска, возможно, дополненным схемой. Если &lt;code&gt;PATTERN&lt;/code&gt; не указан, будет отображаться информация обо всех видимых объектах. &lt;code&gt;PATTERN&lt;/code&gt; может быть регулярным выражением и может предоставлять &lt;em&gt;отдельные&lt;/em&gt; шаблоны для имен схемы и объектов. Следующие примеры иллюстрируют это:</target>
        </trans-unit>
        <trans-unit id="de01abc64ad555117df4d2eb14da2dc8395e780a" translate="yes" xml:space="preserve">
          <source>The optional third argument of the function is an array of namespace mappings. This array should be a two-dimensional &lt;code&gt;text&lt;/code&gt; array with the length of the second axis being equal to 2 (i.e., it should be an array of arrays, each of which consists of exactly 2 elements). The first element of each array entry is the namespace name (alias), the second the namespace URI. It is not required that aliases provided in this array be the same as those being used in the XML document itself (in other words, both in the XML document and in the &lt;code&gt;xpath&lt;/code&gt; function context, aliases are &lt;em&gt;local&lt;/em&gt;).</source>
          <target state="translated">Необязательный третий аргумент функции - это массив сопоставлений пространств имен. Этот массив должен быть двумерным &lt;code&gt;text&lt;/code&gt; массивом с длиной второй оси, равной 2 (т.е. это должен быть массив массивов, каждый из которых состоит ровно из 2 элементов). Первый элемент каждой записи массива - это имя пространства имен (псевдоним), второй - URI пространства имен. Не требуется, чтобы псевдонимы, представленные в этом массиве, были такими же, как и псевдонимы, используемые в самом XML-документе (другими словами, как в XML-документе, так и в контексте функции &lt;code&gt;xpath&lt;/code&gt; псевдонимы являются &lt;em&gt;локальными&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="3d0c8a9e2cea5113636abde4ca21364d5044faa7" translate="yes" xml:space="preserve">
          <source>The optional user-defined method are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c4a4f219f0aa64d3de98d0b070691b60ede2a2" translate="yes" xml:space="preserve">
          <source>The optional user-defined method is:</source>
          <target state="translated">Необязательный пользовательский метод:</target>
        </trans-unit>
        <trans-unit id="84a938a7941f222eb580e7e8263bbd7142209820" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;--docdir&lt;/code&gt;, &lt;code&gt;--pkgincludedir&lt;/code&gt;, &lt;code&gt;--localedir&lt;/code&gt;, &lt;code&gt;--mandir&lt;/code&gt;, &lt;code&gt;--sharedir&lt;/code&gt;, &lt;code&gt;--sysconfdir&lt;/code&gt;, &lt;code&gt;--cc&lt;/code&gt;, &lt;code&gt;--cppflags&lt;/code&gt;, &lt;code&gt;--cflags&lt;/code&gt;, &lt;code&gt;--cflags_sl&lt;/code&gt;, &lt;code&gt;--ldflags&lt;/code&gt;, &lt;code&gt;--ldflags_sl&lt;/code&gt;, and &lt;code&gt;--libs&lt;/code&gt; were added in PostgreSQL 8.1. The option &lt;code&gt;--htmldir&lt;/code&gt; was added in PostgreSQL 8.4. The option &lt;code&gt;--ldflags_ex&lt;/code&gt; was added in PostgreSQL 9.0.</source>
          <target state="translated">Параметры &lt;code&gt;--docdir&lt;/code&gt; , &lt;code&gt;--pkgincludedir&lt;/code&gt; , &lt;code&gt;--localedir&lt;/code&gt; , &lt;code&gt;--mandir&lt;/code&gt; , &lt;code&gt;--sharedir&lt;/code&gt; , &lt;code&gt;--sysconfdir&lt;/code&gt; , &lt;code&gt;--cc&lt;/code&gt; , &lt;code&gt;--cppflags&lt;/code&gt; , &lt;code&gt;--cflags&lt;/code&gt; , &lt;code&gt;--cflags_sl&lt;/code&gt; , &lt;code&gt;--ldflags&lt;/code&gt; , &lt;code&gt;--ldflags_sl&lt;/code&gt; , и &lt;code&gt;--libs&lt;/code&gt; были добавлены в PostgreSQL 8.1. Параметр &lt;code&gt;--htmldir&lt;/code&gt; был добавлен в PostgreSQL 8.4. Параметр &lt;code&gt;--ldflags_ex&lt;/code&gt; был добавлен в PostgreSQL 9.0.</target>
        </trans-unit>
        <trans-unit id="fabb800956bbdc09009ffd9f1b017eb0d6e1abef" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;-D&lt;/code&gt;, &lt;code&gt;-l&lt;/code&gt;, &lt;code&gt;-E&lt;/code&gt;, &lt;code&gt;-O&lt;/code&gt;, and &lt;code&gt;-T&lt;/code&gt; correspond to options of the underlying SQL command &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;; see there for more information about them.</source>
          <target state="translated">Параметры &lt;code&gt;-D&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-E&lt;/code&gt; , &lt;code&gt;-O&lt;/code&gt; и &lt;code&gt;-T&lt;/code&gt; соответствуют параметрам базовой команды SQL &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; ; см. там дополнительную информацию о них.</target>
        </trans-unit>
        <trans-unit id="b59022ce6b09c2f629170565a77c3c19be85bd9c" translate="yes" xml:space="preserve">
          <source>The options can appear in any order.</source>
          <target state="translated">Опции могут появиться в любом порядке.</target>
        </trans-unit>
        <trans-unit id="83b4362928db8b9651a7b14a89534a668d30b89b" translate="yes" xml:space="preserve">
          <source>The options described here are used mainly for debugging purposes, and in some cases to assist with recovery of severely damaged databases. There should be no reason to use them in a production database setup. They are listed here only for use by PostgreSQL system developers. Furthermore, these options might change or be removed in a future release without notice.</source>
          <target state="translated">Описанные здесь опции используются в основном в целях отладки,а в некоторых случаях для оказания помощи в восстановлении сильно поврежденных баз данных.Не должно быть причин использовать их при настройке производственной базы данных.Они перечислены здесь только для использования разработчиками системы PostgreSQL.Более того,эти опции могут быть изменены или удалены в будущем релизе без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="f8dd3a92af0a56bfda8d9752b838ef4b2d6a4df2" translate="yes" xml:space="preserve">
          <source>The order 3501 might be among the billed or unbilled orders.</source>
          <target state="translated">Заказ 3501 может быть в числе выставленных или невыставленных заказов.</target>
        </trans-unit>
        <trans-unit id="abcd49a17f5a3270a489cdc6cf5f6ae4822bbd01" translate="yes" xml:space="preserve">
          <source>The order doesn't matter. It does not necessarily determine in which order the constraints are checked.</source>
          <target state="translated">Приказ не имеет значения.Он не обязательно определяет,в каком порядке проверяются ограничения.</target>
        </trans-unit>
        <trans-unit id="4885441a3f0959533bfa66d30ac9b400042a2243" translate="yes" xml:space="preserve">
          <source>The order of evaluation of subexpressions is not defined. In particular, the inputs of an operator or function are not necessarily evaluated left-to-right or in any other fixed order.</source>
          <target state="translated">Порядок оценки подвыражений не определен.В частности,входы оператора или функции не обязательно обрабатываются слева направо или в любом другом фиксированном порядке.</target>
        </trans-unit>
        <trans-unit id="89519eed893d527079231a8a6443c77bf1a65103" translate="yes" xml:space="preserve">
          <source>The order of the pairs is not significant (and may not be reproduced on output). Whitespace between pairs or around the &lt;code&gt;=&amp;gt;&lt;/code&gt; sign is ignored. Double-quote keys and values that include whitespace, commas, &lt;code&gt;=&lt;/code&gt;s or &lt;code&gt;&amp;gt;&lt;/code&gt;s. To include a double quote or a backslash in a key or value, escape it with a backslash.</source>
          <target state="translated">Порядок пар не имеет значения (и не может быть воспроизведен на выходе). Пробелы между парами или вокруг знака &lt;code&gt;=&amp;gt;&lt;/code&gt; игнорируются. Ключи и значения в двойных кавычках, которые включают пробелы, запятые, &lt;code&gt;=&lt;/code&gt; s или &lt;code&gt;&amp;gt;&lt;/code&gt; s. Чтобы включить двойные кавычки или обратную косую черту в ключ или значение, закройте их обратной косой чертой.</target>
        </trans-unit>
        <trans-unit id="6a0d0d4551f2d45fd2b79524bceb16c2da137ff6" translate="yes" xml:space="preserve">
          <source>The ordering of the values in an enum type is the order in which the values were listed when the type was created. All standard comparison operators and related aggregate functions are supported for enums. For example:</source>
          <target state="translated">Порядок перечисления значений в перечислительном типе-это порядок,в котором значения были перечислены при создании типа.Для перечислений поддерживаются все стандартные операторы сравнения и связанные с ними агрегатные функции.Например:</target>
        </trans-unit>
        <trans-unit id="4a1c45805d8830616db8f03a352b425367265a0b" translate="yes" xml:space="preserve">
          <source>The ordinal number refers to the ordinal (left-to-right) position of the index column.</source>
          <target state="translated">Код порядкового номера относится к порядковому (слева направо)положению столбца индекса.</target>
        </trans-unit>
        <trans-unit id="542906884bd50e7620583567769e2555be971b00" translate="yes" xml:space="preserve">
          <source>The ordinal number refers to the ordinal (left-to-right) position of the output column. This feature makes it possible to define an ordering on the basis of a column that does not have a unique name. This is never absolutely necessary because it is always possible to assign a name to an output column using the &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">Порядковый номер относится к порядковому (слева направо) положению выходного столбца. Эта функция позволяет определять порядок на основе столбца, не имеющего уникального имени. Это никогда не является абсолютно необходимым, потому что всегда можно присвоить имя выходному столбцу с помощью предложения &lt;code&gt;AS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b06b3bbd9847482f4b77272cbdd9dddfd2293b02" translate="yes" xml:space="preserve">
          <source>The ordinary qualified-column-name syntax &lt;code&gt;table_name&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;&lt;code&gt;column_name&lt;/code&gt; can be understood as applying &lt;a href=&quot;sql-expressions#FIELD-SELECTION&quot;&gt;field selection&lt;/a&gt; to the composite value of the table's current row. (For efficiency reasons, it's not actually implemented that way.)</source>
          <target state="translated">Обычный синтаксис квалифицированного имени столбца &lt;code&gt;table_name&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;column_name&lt;/code&gt; можно понимать как применение &lt;a href=&quot;sql-expressions#FIELD-SELECTION&quot;&gt;выбора поля&lt;/a&gt; к составному значению текущей строки таблицы. (По соображениям эффективности на самом деле это не реализовано таким образом.)</target>
        </trans-unit>
        <trans-unit id="26d29240df565151bc026ac25aff13ab3efc3c48" translate="yes" xml:space="preserve">
          <source>The origin node's LSN up to which data has been replicated.</source>
          <target state="translated">Исходный узел-это LSN,на который были скопированы данные.</target>
        </trans-unit>
        <trans-unit id="0c0890af1d3eba99328b2705ec2de494e2103157" translate="yes" xml:space="preserve">
          <source>The other clauses specify optional operator optimization clauses. Their meaning is detailed in &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper-optimization.html&quot;&gt;Section 37.15&lt;/a&gt;.</source>
          <target state="translated">Другие предложения определяют необязательные предложения оптимизации операторов. Их значение подробно описано в &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper-optimization.html&quot;&gt;Разделе 37.15&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9473f0f0dfb8c5d74bfb5c710889c3c431764eb1" translate="yes" xml:space="preserve">
          <source>The other clauses specify optional operator optimization clauses. Their meaning is detailed in &lt;a href=&quot;https://www.postgresql.org/docs/13/xoper-optimization.html&quot;&gt;Section 37.15&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968a2d78a8c8100f337e33a5ce08a9f2a42bbad9" translate="yes" xml:space="preserve">
          <source>The other locale categories can be changed whenever desired by setting the server configuration parameters that have the same name as the locale categories (see &lt;a href=&quot;runtime-config-client#RUNTIME-CONFIG-CLIENT-FORMAT&quot;&gt;Section 19.11.2&lt;/a&gt; for details). The values that are chosen by &lt;code&gt;initdb&lt;/code&gt; are actually only written into the configuration file &lt;code&gt;postgresql.conf&lt;/code&gt; to serve as defaults when the server is started. If you remove these assignments from &lt;code&gt;postgresql.conf&lt;/code&gt; then the server will inherit the settings from its execution environment.</source>
          <target state="translated">Другие категории языковых стандартов могут быть изменены по желанию путем установки параметров конфигурации сервера, которые имеют то же имя, что и категории языковых стандартов (подробности см. В &lt;a href=&quot;runtime-config-client#RUNTIME-CONFIG-CLIENT-FORMAT&quot;&gt;Разделе 19.11.2&lt;/a&gt; ). Значения, выбранные &lt;code&gt;initdb&lt;/code&gt; , на самом деле записываются только в файл конфигурации &lt;code&gt;postgresql.conf&lt;/code&gt; и служат значениями по умолчанию при запуске сервера. Если вы удалите эти назначения из &lt;code&gt;postgresql.conf&lt;/code&gt; , сервер унаследует настройки из своей среды выполнения.</target>
        </trans-unit>
        <trans-unit id="c995e27c615e98c0f723cb03133efd117f67f54f" translate="yes" xml:space="preserve">
          <source>The other locale settings &lt;a href=&quot;runtime-config-client#GUC-LC-MESSAGES&quot;&gt;lc_messages&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numeric&lt;/a&gt;, and &lt;a href=&quot;runtime-config-client#GUC-LC-TIME&quot;&gt;lc_time&lt;/a&gt; are not fixed per database and are not set by this command. If you want to make them the default for a specific database, you can use &lt;code&gt;ALTER DATABASE ... SET&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f628b39443abf4900d7c741215add2d55c377a2" translate="yes" xml:space="preserve">
          <source>The other required settings have default values that are sufficient for a basic setup.</source>
          <target state="translated">Остальные необходимые настройки имеют значения по умолчанию,достаточные для базовой настройки.</target>
        </trans-unit>
        <trans-unit id="37e3a8e885deb65cc32448cece3ed8b5de192c3e" translate="yes" xml:space="preserve">
          <source>The other three operators are defined in terms of &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; in the obvious way, and must act consistently with them.</source>
          <target state="translated">Остальные три оператора определены в терминах &lt;code&gt;=&lt;/code&gt; и &lt;code&gt;&amp;lt;&lt;/code&gt; очевидным образом и должны действовать согласованно с ними.</target>
        </trans-unit>
        <trans-unit id="cca1af5395645eeb86ba526f8d241c5ba5b41b07" translate="yes" xml:space="preserve">
          <source>The output columns are described in &lt;a href=&quot;pgstattuple#PGSTATAPPROX-COLUMNS&quot;&gt;Table F.23&lt;/a&gt;.</source>
          <target state="translated">Выходные столбцы описаны в &lt;a href=&quot;pgstattuple#PGSTATAPPROX-COLUMNS&quot;&gt;Таблице F.23&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2061781f2ae71dd3ed97908a6bff9dc965e50b4d" translate="yes" xml:space="preserve">
          <source>The output columns are described in &lt;a href=&quot;pgstattuple#PGSTATTUPLE-COLUMNS&quot;&gt;Table F.22&lt;/a&gt;.</source>
          <target state="translated">Выходные столбцы описаны в &lt;a href=&quot;pgstattuple#PGSTATTUPLE-COLUMNS&quot;&gt;Таблице F.22&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9d41f9345eb262fbbccef45f4cf925c1a6818ef" translate="yes" xml:space="preserve">
          <source>The output columns are:</source>
          <target state="translated">Выходные колонки:</target>
        </trans-unit>
        <trans-unit id="ddee20dbbcf56a7d470d5e18264fdb853ffab834" translate="yes" xml:space="preserve">
          <source>The output format of the date/time types can be set to one of the four styles ISO 8601, SQL (Ingres), traditional POSTGRES (Unix date format), or German. The default is the ISO format. (The SQL standard requires the use of the ISO 8601 format. The name of the &amp;ldquo;SQL&amp;rdquo; output format is a historical accident.) &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT-TABLE&quot;&gt;Table 8.14&lt;/a&gt; shows examples of each output style. The output of the &lt;code&gt;date&lt;/code&gt; and &lt;code&gt;time&lt;/code&gt; types is generally only the date or time part in accordance with the given examples. However, the POSTGRES style outputs date-only values in ISO format.</source>
          <target state="translated">Формат вывода типов даты / времени может быть установлен в один из четырех стилей: ISO 8601, SQL (Ingres), традиционный POSTGRES (формат даты Unix) или немецкий. По умолчанию используется формат ISO. (Стандарт SQL требует использования формата ISO 8601. Название формата вывода &amp;laquo;SQL&amp;raquo; - историческая случайность.) В &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT-TABLE&quot;&gt;таблице 8.14&lt;/a&gt; показаны примеры каждого стиля вывода. Вывод типов &lt;code&gt;date&lt;/code&gt; и &lt;code&gt;time&lt;/code&gt; обычно представляет собой только часть даты или времени в соответствии с приведенными примерами. Однако стиль POSTGRES выводит только даты в формате ISO.</target>
        </trans-unit>
        <trans-unit id="ca0d537c6aa930d0ccd3e11ab06cbea4823708c4" translate="yes" xml:space="preserve">
          <source>The output format of the interval type can be set to one of the four styles &lt;code&gt;sql_standard&lt;/code&gt;, &lt;code&gt;postgres&lt;/code&gt;, &lt;code&gt;postgres_verbose&lt;/code&gt;, or &lt;code&gt;iso_8601&lt;/code&gt;, using the command &lt;code&gt;SET intervalstyle&lt;/code&gt;. The default is the &lt;code&gt;postgres&lt;/code&gt; format. &lt;a href=&quot;datatype-datetime#INTERVAL-STYLE-OUTPUT-TABLE&quot;&gt;Table 8.18&lt;/a&gt; shows examples of each output style.</source>
          <target state="translated">Формат вывода типа интервала может быть установлен в один из четырех стилей &lt;code&gt;sql_standard&lt;/code&gt; , &lt;code&gt;postgres&lt;/code&gt; , &lt;code&gt;postgres_verbose&lt;/code&gt; или &lt;code&gt;iso_8601&lt;/code&gt; с помощью команды &lt;code&gt;SET intervalstyle&lt;/code&gt; . По умолчанию используется формат &lt;code&gt;postgres&lt;/code&gt; . &lt;a href=&quot;datatype-datetime#INTERVAL-STYLE-OUTPUT-TABLE&quot;&gt;В таблице 8.18&lt;/a&gt; приведены примеры каждого стиля вывода.</target>
        </trans-unit>
        <trans-unit id="46e4d541f5041111722fb3ba79a2c654be039359" translate="yes" xml:space="preserve">
          <source>The output is a multiline string, with one line per node in the binary tree within the page. Only those nodes that are not zero are printed. The so-called &quot;next&quot; pointer, which points to the next slot to be returned from the page, is also printed.</source>
          <target state="translated">Вывод представляет собой многострочную строку,по одной строке на узел в двоичном дереве внутри страницы.Печатаются только те узлы,которые не являются нулевыми.Также выводится так называемый указатель &quot;следующий&quot;,который указывает на следующий слот,возвращаемый из страницы.</target>
        </trans-unit>
        <trans-unit id="ad08831002285835cd9adfadf104f64de7aa0e5d" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;command&lt;/code&gt;, similar to ordinary &amp;ldquo;back-tick&amp;rdquo; substitution.</source>
          <target state="translated">Вывод &lt;code&gt;command&lt;/code&gt; аналогичен обычной подстановке &amp;laquo;обратного тика&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f5a340fab5cd2f5c7335b7c6ceb29826d0789ea6" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;pg_config --configure&lt;/code&gt; contains shell quotation marks so arguments with spaces are represented correctly. Therefore, using &lt;code&gt;eval&lt;/code&gt; is required for proper results.</source>
          <target state="translated">Вывод &lt;code&gt;pg_config --configure&lt;/code&gt; содержит кавычки оболочки, поэтому аргументы с пробелами представлены правильно. Следовательно, для получения правильных результатов необходимо использовать &lt;code&gt;eval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a81f92d4917ee9ed4622690e19a83d472fca1d6" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;iso_8601&lt;/code&gt; style matches the &amp;ldquo;format with designators&amp;rdquo; described in section 4.4.3.2 of the ISO 8601 standard.</source>
          <target state="translated">Вывод стиля &lt;code&gt;iso_8601&lt;/code&gt; соответствует &amp;laquo;формату с указателями&amp;raquo;, описанному в разделе 4.4.3.2 стандарта ISO 8601.</target>
        </trans-unit>
        <trans-unit id="2ff8c3f12c0cc1fd0eb9b2845008220be0844b33" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;postgres&lt;/code&gt; style matches the output of PostgreSQL releases prior to 8.4 when the &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; parameter was set to &lt;code&gt;ISO&lt;/code&gt;.</source>
          <target state="translated">Вывод стиля &lt;code&gt;postgres&lt;/code&gt; совпадает с выводом выпусков PostgreSQL до 8.4, когда для параметра &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; было задано значение &lt;code&gt;ISO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1546f3a4ad8e76189b8c8e44c823160ec87aa0b6" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;postgres_verbose&lt;/code&gt; style matches the output of PostgreSQL releases prior to 8.4 when the &lt;code&gt;DateStyle&lt;/code&gt; parameter was set to non-&lt;code&gt;ISO&lt;/code&gt; output.</source>
          <target state="translated">Вывод стиля &lt;code&gt;postgres_verbose&lt;/code&gt; совпадает с выводом выпусков PostgreSQL до 8.4, когда для параметра &lt;code&gt;DateStyle&lt;/code&gt; был задан вывод, отличный от &lt;code&gt;ISO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7adcbeb9a00e6f9f8d55d348527ceb949cebeb0" translate="yes" xml:space="preserve">
          <source>The output should be:</source>
          <target state="translated">Выход должен быть:</target>
        </trans-unit>
        <trans-unit id="7d18635316d58c0f1b2d1367a93ab0ee048d2342" translate="yes" xml:space="preserve">
          <source>The overall file layout is: open square bracket, one or more sets of curly braces each of which represents a catalog row, close square bracket. Write a comma after each closing curly brace.</source>
          <target state="translated">Общий план файла:открытая квадратная скобка,один или несколько наборов фигурных скобок,каждая из которых представляет строку каталога,закрытая квадратная скобка.После каждой закрывающей фигурной скобки записывайте запятую.</target>
        </trans-unit>
        <trans-unit id="8de7f224fb0466b959b163b48657edcd9f526ad8" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can alter user mappings for that server for any user. Also, a user can alter a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="translated">Владелец внешнего сервера может изменять сопоставления пользователей этого сервера для любого пользователя. Кроме того, пользователь может изменить отображение пользователя для своего собственного имени пользователя, если ему предоставлена привилегия &lt;code&gt;USAGE&lt;/code&gt; на сервере.</target>
        </trans-unit>
        <trans-unit id="70e088bcc4a224d8f310f80a737853c522321de9" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can create user mappings for that server for any user. Also, a user can create a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="translated">Владелец внешнего сервера может создавать сопоставления пользователей для этого сервера для любого пользователя. Кроме того, пользователь может создать отображение пользователя для своего собственного имени пользователя, если ему предоставлена привилегия &lt;code&gt;USAGE&lt;/code&gt; на сервере.</target>
        </trans-unit>
        <trans-unit id="85f81248211a9e60d13a1c97f497ca0b1b6a21d0" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can drop user mappings for that server for any user. Also, a user can drop a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="translated">Владелец внешнего сервера может сбросить сопоставления пользователей для этого сервера для любого пользователя. Кроме того, пользователь может отбросить отображение пользователя для своего собственного имени пользователя, если ему предоставлена привилегия &lt;code&gt;USAGE&lt;/code&gt; на сервере.</target>
        </trans-unit>
        <trans-unit id="6963c00112713ecda93817baf7fc7475ab9e7155" translate="yes" xml:space="preserve">
          <source>The papal bull of February 1582 decreed that 10 days should be dropped from October 1582 so that 15 October should follow immediately after 4 October. This was observed in Italy, Poland, Portugal, and Spain. Other Catholic countries followed shortly after, but Protestant countries were reluctant to change, and the Greek Orthodox countries didn't change until the start of the 20th century. The reform was observed by Great Britain and its dominions (including what is now the USA) in 1752. Thus 2 September 1752 was followed by 14 September 1752. This is why Unix systems that have the &lt;code&gt;cal&lt;/code&gt; program produce the following:</source>
          <target state="translated">Папская булла от февраля 1582 г. постановила, что с октября 1582 г. следует исключить 10 дней, так что 15 октября должно следовать сразу после 4 октября. Это наблюдалось в Италии, Польше, Португалии и Испании. Вскоре последовали и другие католические страны, но протестантские страны не хотели меняться, а греко-православные страны не менялись до начала 20-го века. Реформа наблюдалась в Великобритании и ее владениях (включая то, что сейчас является США) в 1752 году. Таким образом, за 2 сентября 1752 года последовало 14 сентября 1752 года. Вот почему системы Unix, имеющие программу &lt;code&gt;cal&lt;/code&gt; , производят следующее:</target>
        </trans-unit>
        <trans-unit id="265188275c6e5e56d9f827410bd00598d6ffb2ea" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITIES&quot;&gt;track_activities&lt;/a&gt; enables monitoring of the current command being executed by any server process.</source>
          <target state="translated">Параметр &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITIES&quot;&gt;track_activities&lt;/a&gt; позволяет отслеживать выполнение текущей команды любым серверным процессом.</target>
        </trans-unit>
        <trans-unit id="e1be1796cec7a4cb2472b6d31337e6a73b1f4697" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt; controls whether statistics are collected about table and index accesses.</source>
          <target state="translated">Параметр &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt; определяет, собирается ли статистика о доступах к таблицам и индексам.</target>
        </trans-unit>
        <trans-unit id="c3e68d3468b41bd94198c06d139a59af78cfd7be" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt; enables tracking of usage of user-defined functions.</source>
          <target state="translated">Параметр &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt; позволяет отслеживать использование пользовательских функций.</target>
        </trans-unit>
        <trans-unit id="8df18f4279a1a3adf31a5aebfa3bc87053f75fc7" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; enables monitoring of block read and write times.</source>
          <target state="translated">Параметр &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; включает мониторинг времени чтения и записи блока.</target>
        </trans-unit>
        <trans-unit id="fc99094ae896ae637595cea62c377dc56ce6f9fd" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;count&lt;/code&gt; specifies the maximum number of rows to return, while &lt;code&gt;start&lt;/code&gt; specifies the number of rows to skip before starting to return rows. When both are specified, &lt;code&gt;start&lt;/code&gt; rows are skipped before starting to count the &lt;code&gt;count&lt;/code&gt; rows to be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d547546da964747acd19cdd9eb1f2bdf8c4f57e8" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;&lt;code&gt;nulls&lt;/code&gt;&lt;/em&gt; determines whether null values should be included in the output. If true, null values in columns are represented as:</source>
          <target state="translated">Параметр &lt;em&gt; &lt;code&gt;nulls&lt;/code&gt; &lt;/em&gt; определяет, следует ли включать в вывод нулевые значения. Если true, нулевые значения в столбцах представлены как:</target>
        </trans-unit>
        <trans-unit id="0b194e705f492d2a9e697965a54eb7bc8ec38435" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;&lt;code&gt;targetns&lt;/code&gt;&lt;/em&gt; specifies the desired XML namespace of the result. If no particular namespace is wanted, an empty string should be passed.</source>
          <target state="translated">Параметр &lt;em&gt; &lt;code&gt;targetns&lt;/code&gt; &lt;/em&gt; указывает желаемое пространство имен XML для результата. Если конкретное пространство имен не требуется, следует передать пустую строку.</target>
        </trans-unit>
        <trans-unit id="9da16630f92a321b59e356eb1f16f45959c31e24" translate="yes" xml:space="preserve">
          <source>The parameter data type(s) of the function.</source>
          <target state="translated">Тип(ы)данных параметров функции.</target>
        </trans-unit>
        <trans-unit id="5d10e331ebaa600753d0a6fe423faa9e38a0555a" translate="yes" xml:space="preserve">
          <source>The parameter is the name of a table. The result is a set of records, with one row for each locked row within the table. The output columns are shown in &lt;a href=&quot;pgrowlocks#PGROWLOCKS-COLUMNS&quot;&gt;Table F.20&lt;/a&gt;.</source>
          <target state="translated">Параметр - это имя таблицы. Результатом является набор записей с одной строкой для каждой заблокированной строки в таблице. Выходные столбцы показаны в &lt;a href=&quot;pgrowlocks#PGROWLOCKS-COLUMNS&quot;&gt;Таблице F.20&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c2a6968b73a82456119add43eff37f88e4a3336" translate="yes" xml:space="preserve">
          <source>The parameter name</source>
          <target state="translated">Имя параметра</target>
        </trans-unit>
        <trans-unit id="10634e221a9f53cda3c36547bc9c020dce985fe4" translate="yes" xml:space="preserve">
          <source>The parameter symbols used to replace constants in representative query texts start from the next number after the highest &lt;code&gt;$&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; parameter in the original query text, or &lt;code&gt;$1&lt;/code&gt; if there was none. It's worth noting that in some cases there may be hidden parameter symbols that affect this numbering. For example, PL/pgSQL uses hidden parameter symbols to insert values of function local variables into queries, so that a PL/pgSQL statement like &lt;code&gt;SELECT i + 1 INTO j&lt;/code&gt; would have representative text like &lt;code&gt;SELECT i + $2&lt;/code&gt;.</source>
          <target state="translated">Символы параметров, используемые для замены констант в репрезентативных текстах запросов, начинаются со следующего числа после самого высокого параметра &lt;code&gt;$&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; в исходном тексте запроса или &lt;code&gt;$1&lt;/code&gt; если его не было. Стоит отметить, что в некоторых случаях могут быть скрытые символы параметров, влияющие на эту нумерацию. Например, PL / pgSQL использует символы скрытых параметров для вставки значений локальных переменных функции в запросы, так что оператор PL / pgSQL, такой как &lt;code&gt;SELECT i + 1 INTO j&lt;/code&gt; будет иметь репрезентативный текст, такой как &lt;code&gt;SELECT i + $2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61c677b727193bb37a9911ff1962107228c69d5b" translate="yes" xml:space="preserve">
          <source>The parameter value</source>
          <target state="translated">Значение параметра</target>
        </trans-unit>
        <trans-unit id="bbcaadaf51c94b64fefad474400e1f3834e2ed35" translate="yes" xml:space="preserve">
          <source>The parameters can appear in any order, not only that illustrated above, and most are optional. You must register two or more functions (using &lt;code&gt;CREATE FUNCTION&lt;/code&gt;) before defining the type. The support functions &lt;code&gt;input_function&lt;/code&gt; and &lt;code&gt;output_function&lt;/code&gt; are required, while the functions &lt;code&gt;receive_function&lt;/code&gt;, &lt;code&gt;send_function&lt;/code&gt;, &lt;code&gt;type_modifier_input_function&lt;/code&gt;, &lt;code&gt;type_modifier_output_function&lt;/code&gt; and &lt;code&gt;analyze_function&lt;/code&gt; are optional. Generally these functions have to be coded in C or another low-level language.</source>
          <target state="translated">Параметры могут появляться в любом порядке, не только в указанном выше, и большинство из них являются необязательными. Вы должны зарегистрировать две или более функций (используя &lt;code&gt;CREATE FUNCTION&lt;/code&gt; ) перед определением типа. &lt;code&gt;input_function&lt;/code&gt; вспомогательные функции input_function и &lt;code&gt;output_function&lt;/code&gt; , тогда как функции &lt;code&gt;receive_function&lt;/code&gt; , &lt;code&gt;send_function&lt;/code&gt; , &lt;code&gt;type_modifier_input_function&lt;/code&gt; , &lt;code&gt;type_modifier_output_function&lt;/code&gt; и &lt;code&gt;analyze_function&lt;/code&gt; являются необязательными. Обычно эти функции должны быть написаны на C или другом низкоуровневом языке.</target>
        </trans-unit>
        <trans-unit id="35c28a20bb52660d5ea22014191009de5ae11925" translate="yes" xml:space="preserve">
          <source>The parameters for the &lt;code&gt;MOVE&lt;/code&gt; command are identical to those of the &lt;code&gt;FETCH&lt;/code&gt; command; refer to &lt;a href=&quot;sql-fetch&quot;&gt;FETCH&lt;/a&gt; for details on syntax and usage.</source>
          <target state="translated">Параметры команды &lt;code&gt;MOVE&lt;/code&gt; идентичны параметрам команды &lt;code&gt;FETCH&lt;/code&gt; ; обратитесь к &lt;a href=&quot;sql-fetch&quot;&gt;FETCH&lt;/a&gt; для получения подробной информации о синтаксисе и использовании.</target>
        </trans-unit>
        <trans-unit id="c486bfa67e493a85ca76bb0a5dfe71e780089bca" translate="yes" xml:space="preserve">
          <source>The parameters of &lt;code&gt;CREATE AGGREGATE&lt;/code&gt; can be written in any order, not just the order illustrated above.</source>
          <target state="translated">Параметры &lt;code&gt;CREATE AGGREGATE&lt;/code&gt; можно записывать в любом порядке, а не только в порядке, показанном выше.</target>
        </trans-unit>
        <trans-unit id="d0f868092f1804769e10c18a42faa0f07b1980df" translate="yes" xml:space="preserve">
          <source>The parameters representing table and field names are copied as-is into the SQL queries that &lt;code&gt;connectby&lt;/code&gt; generates internally. Therefore, include double quotes if the names are mixed-case or contain special characters. You may also need to schema-qualify the table name.</source>
          <target state="translated">Параметры, представляющие имена таблиц и полей, копируются как есть в запросы SQL, которые &lt;code&gt;connectby&lt;/code&gt; генерирует внутренне. Поэтому используйте двойные кавычки, если имена написаны в смешанном регистре или содержат специальные символы. Вам также может потребоваться уточнение схемы имени таблицы.</target>
        </trans-unit>
        <trans-unit id="7230bb5c0f71b8c1dd5a14e1c76f97c166b31063" translate="yes" xml:space="preserve">
          <source>The parentheses are required here to show that &lt;code&gt;compositecol&lt;/code&gt; is a column name not a table name, or that &lt;code&gt;mytable&lt;/code&gt; is a table name not a schema name in the second case.</source>
          <target state="translated">Скобки здесь необходимы, чтобы показать, что &lt;code&gt;compositecol&lt;/code&gt; столбец - это имя столбца, а не имя таблицы, или что &lt;code&gt;mytable&lt;/code&gt; - это имя таблицы, а не имя схемы во втором случае.</target>
        </trans-unit>
        <trans-unit id="3872d508fa039522a5d3058284138f504197106f" translate="yes" xml:space="preserve">
          <source>The parentheses in the last example are required. See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt; for more about arrays.</source>
          <target state="translated">Скобки в последнем примере обязательны. См. &lt;a href=&quot;arrays&quot;&gt;Раздел 8.15&lt;/a&gt; для получения дополнительной информации о массивах.</target>
        </trans-unit>
        <trans-unit id="ba38ce516ae1d7c833e7896243109df28d306a9d" translate="yes" xml:space="preserve">
          <source>The parentheses or brackets indicate whether the lower and upper bounds are exclusive or inclusive, as described previously. Notice that the final pattern is &lt;code&gt;empty&lt;/code&gt;, which represents an empty range (a range that contains no points).</source>
          <target state="translated">Скобки или скобки указывают, являются ли нижняя и верхняя границы исключающими или включающими, как описано ранее. Обратите внимание, что последний шаблон &lt;code&gt;empty&lt;/code&gt; , что представляет собой пустой диапазон (диапазон, не содержащий точек).</target>
        </trans-unit>
        <trans-unit id="09b446449a4319a7ef9115b3be9989109d17ce7e" translate="yes" xml:space="preserve">
          <source>The parser has to check the query string (which arrives as plain text) for valid syntax. If the syntax is correct a &lt;em&gt;parse tree&lt;/em&gt; is built up and handed back; otherwise an error is returned. The parser and lexer are implemented using the well-known Unix tools bison and flex.</source>
          <target state="translated">Синтаксический анализатор должен проверить строку запроса (которая поступает в виде обычного текста) на предмет допустимого синтаксиса. Если синтаксис правильный, создается &lt;em&gt;дерево синтаксического анализа&lt;/em&gt; и передается обратно; в противном случае возвращается ошибка. Синтаксический анализатор и лексер реализованы с использованием хорошо известных инструментов Unix bison и flex.</target>
        </trans-unit>
        <trans-unit id="6ff5674ed423bd0fd40e474001e355555798b1f1" translate="yes" xml:space="preserve">
          <source>The parser initially marks the constants as being of type &lt;code&gt;integer&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt; respectively. There is no &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator in the system catalogs, but there is a &lt;code&gt;numeric&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator. The query will therefore succeed if a cast from &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;numeric&lt;/code&gt; is available and is marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; &amp;mdash; which in fact it is. The parser will apply the implicit cast and resolve the query as if it had been written</source>
          <target state="translated">Синтаксический анализатор изначально отмечает константы как &lt;code&gt;integer&lt;/code&gt; и &lt;code&gt;numeric&lt;/code&gt; соответственно. В системных каталогах нет &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;numeric&lt;/code&gt; оператора, но есть &lt;code&gt;numeric&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;numeric&lt;/code&gt; оператор. Следовательно, запрос будет успешным, если &lt;code&gt;AS IMPLICIT&lt;/code&gt; &lt;code&gt;integer&lt;/code&gt; в &lt;code&gt;numeric&lt;/code&gt; доступно и помечено КАК IMPLICIT - что на самом деле так и есть. Парсер применит неявное приведение и разрешит запрос, как если бы он был написан</target>
        </trans-unit>
        <trans-unit id="25f13c18d68a86fdbefd4291a356d75813cdb2e5" translate="yes" xml:space="preserve">
          <source>The parser is defined in the file &lt;code&gt;gram.y&lt;/code&gt; and consists of a set of &lt;em&gt;grammar rules&lt;/em&gt; and &lt;em&gt;actions&lt;/em&gt; that are executed whenever a rule is fired. The code of the actions (which is actually C code) is used to build up the parse tree.</source>
          <target state="translated">Парсер определен в файле &lt;code&gt;gram.y&lt;/code&gt; и состоит из набора &lt;em&gt;грамматических правил&lt;/em&gt; и &lt;em&gt;действий&lt;/em&gt; , которые выполняются всякий раз, когда правило срабатывает. Код действий (который на самом деле является кодом C) используется для построения дерева синтаксического анализа.</target>
        </trans-unit>
        <trans-unit id="1857339fc15ab225bd01ccd9d926ca70975b0fc9" translate="yes" xml:space="preserve">
          <source>The parser learns from the &lt;code&gt;pg_cast&lt;/code&gt; catalog that &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;varchar&lt;/code&gt; are binary-compatible, meaning that one can be passed to a function that accepts the other without doing any physical conversion. Therefore, no type conversion call is really inserted in this case.</source>
          <target state="translated">Анализатор узнает из каталога &lt;code&gt;pg_cast&lt;/code&gt; , что &lt;code&gt;text&lt;/code&gt; и &lt;code&gt;varchar&lt;/code&gt; двоично совместимы, что означает, что один может быть передан функции, которая принимает другой, без какого-либо физического преобразования. Следовательно, в этом случае в действительности не вставляется вызов преобразования типа.</target>
        </trans-unit>
        <trans-unit id="0e756c19d42be08cb71cc09834d6f8f8f843f91e" translate="yes" xml:space="preserve">
          <source>The parser stage creates a parse tree using only fixed rules about the syntactic structure of SQL. It does not make any lookups in the system catalogs, so there is no possibility to understand the detailed semantics of the requested operations. After the parser completes, the &lt;em&gt;transformation process&lt;/em&gt; takes the tree handed back by the parser as input and does the semantic interpretation needed to understand which tables, functions, and operators are referenced by the query. The data structure that is built to represent this information is called the &lt;em&gt;query tree&lt;/em&gt;.</source>
          <target state="translated">На этапе синтаксического анализа создается дерево синтаксического анализа с использованием только фиксированных правил синтаксической структуры SQL. Он не выполняет поиск в системных каталогах, поэтому нет возможности понять детальную семантику запрошенных операций. После завершения синтаксического анализа &lt;em&gt;процесс преобразования&lt;/em&gt; принимает дерево, возвращенное анализатором, в качестве входных данных и выполняет семантическую интерпретацию, необходимую для понимания того, на какие таблицы, функции и операторы ссылается запрос. Структура данных, созданная для представления этой информации, называется &lt;em&gt;деревом запроса&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ebdbb42aa00d24e0d513d01a8c9b666b615ba1dd" translate="yes" xml:space="preserve">
          <source>The parser's notion of a &amp;ldquo;letter&amp;rdquo; is determined by the database's locale setting, specifically &lt;code&gt;lc_ctype&lt;/code&gt;. Words containing only the basic ASCII letters are reported as a separate token type, since it is sometimes useful to distinguish them. In most European languages, token types &lt;code&gt;word&lt;/code&gt; and &lt;code&gt;asciiword&lt;/code&gt; should be treated alike.</source>
          <target state="translated">Понятие &amp;laquo;буква&amp;raquo; в парсере определяется настройкой локали базы данных, в частности &lt;code&gt;lc_ctype&lt;/code&gt; . Слова, содержащие только основные буквы ASCII, сообщаются как отдельный тип лексемы, поскольку иногда бывает полезно различать их. В большинстве европейских языков к типам токенов &lt;code&gt;word&lt;/code&gt; и &lt;code&gt;asciiword&lt;/code&gt; следует обращаться одинаково.</target>
        </trans-unit>
        <trans-unit id="9c43fc6c8c7c3f14d277b633b89dfade64caf03b" translate="yes" xml:space="preserve">
          <source>The part of PostgreSQL that is devoted to determining (&lt;em&gt;planning&lt;/em&gt;) the most efficient way to execute &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;queries&lt;/a&gt;. Also known as &lt;em&gt;query optimizer&lt;/em&gt;, &lt;em&gt;optimizer&lt;/em&gt;, or simply &lt;em&gt;planner&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4e5a431eb644b141f3790b8cfbc5fd53514f52" translate="yes" xml:space="preserve">
          <source>The partial transaction isolation provided by Read Committed mode is adequate for many applications, and this mode is fast and simple to use; however, it is not sufficient for all cases. Applications that do complex queries and updates might require a more rigorously consistent view of the database than Read Committed mode provides.</source>
          <target state="translated">Частичная изоляция транзакций,обеспечиваемая режимом Read Committed,адекватна для многих приложений,и этот режим быстр и прост в использовании;однако его недостаточно для всех случаев.Приложениям,которые выполняют сложные запросы и обновления,может потребоваться более строгое отображение базы данных,чем в режиме Read Committed.</target>
        </trans-unit>
        <trans-unit id="eb9b101fa3ff04c41a301e2ea58c51b731736d02" translate="yes" xml:space="preserve">
          <source>The partition bound specification for a new partition. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details on the syntax of the same.</source>
          <target state="translated">Спецификация границы раздела для нового раздела. Обратитесь к &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; для получения более подробной информации о синтаксисе того же.</target>
        </trans-unit>
        <trans-unit id="a843f1857d3445c37bfb25c214ac7c60e2eda3b2" translate="yes" xml:space="preserve">
          <source>The password is always stored encrypted in the system catalogs. The &lt;code&gt;ENCRYPTED&lt;/code&gt; keyword has no effect, but is accepted for backwards compatibility. The method of encryption is determined by the configuration parameter &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt;. If the presented password string is already in MD5-encrypted or SCRAM-encrypted format, then it is stored as-is regardless of &lt;code&gt;password_encryption&lt;/code&gt; (since the system cannot decrypt the specified encrypted password string, to encrypt it in a different format). This allows reloading of encrypted passwords during dump/restore.</source>
          <target state="translated">Пароль всегда хранится в системных каталогах в зашифрованном виде. &lt;code&gt;ENCRYPTED&lt;/code&gt; ключевого слова не имеет никакого эффекта, но принимается для обратной совместимости. Метод шифрования определяется параметром конфигурации &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt; . Если представленная строка пароля уже находится в формате с шифрованием MD5 или SCRAM, она сохраняется как есть, независимо от &lt;code&gt;password_encryption&lt;/code&gt; (поскольку система не может расшифровать указанную зашифрованную строку пароля, чтобы зашифровать ее в другом формате). Это позволяет перезагружать зашифрованные пароли во время дампа / восстановления.</target>
        </trans-unit>
        <trans-unit id="d6a56dd735da3ef3f125939acf3298322bea99f6" translate="yes" xml:space="preserve">
          <source>The path at your site might be different. Contact your site administrator or check the installation instructions to correct the situation.</source>
          <target state="translated">Путь на вашем сайте может быть другим.Свяжитесь с администратором вашего сайта или ознакомьтесь с инструкциями по установке,чтобы исправить ситуацию.</target>
        </trans-unit>
        <trans-unit id="ae4a259e6f096215a3bc76dbbbf4ab5a1fa7063f" translate="yes" xml:space="preserve">
          <source>The path expression contains &lt;code&gt;type()&lt;/code&gt; or &lt;code&gt;size()&lt;/code&gt; methods that return the type and the number of elements in the array, respectively.</source>
          <target state="translated">Выражение пути содержит методы &lt;code&gt;type()&lt;/code&gt; или &lt;code&gt;size()&lt;/code&gt; которые возвращают тип и количество элементов в массиве соответственно.</target>
        </trans-unit>
        <trans-unit id="665f879c5dd1bad744ce39b38be0ec7bfa475f6e" translate="yes" xml:space="preserve">
          <source>The path name of the input or output file. An input file name can be an absolute or relative path, but an output file name must be an absolute path. Windows users might need to use an &lt;code&gt;E''&lt;/code&gt; string and double any backslashes used in the path name.</source>
          <target state="translated">Путь к входному или выходному файлу. Имя входного файла может быть абсолютным или относительным путем, но имя выходного файла должно быть абсолютным путем. Пользователям Windows может потребоваться использовать строку &lt;code&gt;E''&lt;/code&gt; и удвоить любые обратные косые черты, используемые в имени пути.</target>
        </trans-unit>
        <trans-unit id="acfece2d4d4a40c54bd9f721a413e8f8e6ea9b4c" translate="yes" xml:space="preserve">
          <source>The pattern characters &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, and &lt;code&gt;G&lt;/code&gt; represent the sign, currency symbol, decimal point, and thousands separator characters defined by the current locale (see &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt; and &lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numeric&lt;/a&gt;). The pattern characters period and comma represent those exact characters, with the meanings of decimal point and thousands separator, regardless of locale.</source>
          <target state="translated">Символы шаблона &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;D&lt;/code&gt; и &lt;code&gt;G&lt;/code&gt; представляют знак, символ валюты, десятичную точку и символы-разделители тысяч, определенные текущей &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;локалью&lt;/a&gt; (см. Lc_monetary и &lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numeric&lt;/a&gt; ). Точка и запятая в шаблоне представляют эти точные символы со значениями десятичной точки и разделителя тысяч, независимо от языкового стандарта.</target>
        </trans-unit>
        <trans-unit id="0f3ba6e11e445232d30834cd144281a86bebafa9" translate="yes" xml:space="preserve">
          <source>The pattern matching operators of all three kinds do not support nondeterministic collations. If required, apply a different collation to the expression to work around this limitation.</source>
          <target state="translated">Операторы сопоставления шаблонов всех трех видов не поддерживают недетерминистические сопоставления.Если необходимо,применяйте к выражению другую коллиляцию,чтобы обойти это ограничение.</target>
        </trans-unit>
        <trans-unit id="53ad7762f98479cbca28b8363660cbfe1cf95173" translate="yes" xml:space="preserve">
          <source>The payload of the notifications consists of the table name, a letter to indicate which type of operation was performed, and column name/value pairs for primary key columns. Each part is separated from the next by a comma. For ease of parsing using regular expressions, table and column names are always wrapped in double quotes, and data values are always wrapped in single quotes. Embedded quotes are doubled.</source>
          <target state="translated">Полезная нагрузка уведомлений состоит из названия таблицы,буквы,указывающей,какой тип операции был выполнен,и пар колонок названия/значения для колонок первичного ключа.Каждая часть отделяется от следующей запятой.Для удобства разбора с использованием регулярных выражений имена таблиц и столбцов всегда заключены в двойные кавычки,а значения данных всегда заключены в одинарные кавычки.Вложенные кавычки удваиваются.</target>
        </trans-unit>
        <trans-unit id="99b6bf90a9bb8e6d618127a1a2c46cd208469261" translate="yes" xml:space="preserve">
          <source>The peer authentication method works by obtaining the client's operating system user name from the kernel and using it as the allowed database user name (with optional user name mapping). This method is only supported on local connections.</source>
          <target state="translated">Метод одноранговой аутентификации работает путем получения пользовательского имени операционной системы клиента из ядра и использования его в качестве разрешенного имени пользователя базы данных (с необязательным отображением имени пользователя).Этот метод поддерживается только при локальных соединениях.</target>
        </trans-unit>
        <trans-unit id="919e0066d8303b60f8d9dce39383d269124b1827" translate="yes" xml:space="preserve">
          <source>The per-index statistics are particularly useful to determine which indexes are being used and how effective they are.</source>
          <target state="translated">Статистика по каждому индексу особенно полезна для определения того,какие индексы используются и насколько они эффективны.</target>
        </trans-unit>
        <trans-unit id="2b32037bdcf53d4293fda5e00a43bb07b50f376a" translate="yes" xml:space="preserve">
          <source>The performance of an R-tree index can largely depend on the initial order of input values. It may be very helpful to sort the input table on the &lt;code&gt;seg&lt;/code&gt; column; see the script &lt;code&gt;sort-segments.pl&lt;/code&gt; for an example.</source>
          <target state="translated">Производительность индекса R-дерева может во многом зависеть от начального порядка входных значений. Может быть очень полезно отсортировать входную таблицу по столбцу &lt;code&gt;seg&lt;/code&gt; ; см. &lt;code&gt;sort-segments.pl&lt;/code&gt; скрипта sort-segments.pl .</target>
        </trans-unit>
        <trans-unit id="794af340a68964153b03ef2b6d22753d285cf9d8" translate="yes" xml:space="preserve">
          <source>The period (&lt;code&gt;.&lt;/code&gt;) is used in numeric constants, and to separate schema, table, and column names.</source>
          <target state="translated">Точка ( &lt;code&gt;.&lt;/code&gt; ) Используется в числовых константах и ​​для разделения имен схемы, таблицы и столбца.</target>
        </trans-unit>
        <trans-unit id="1dd06a0691afe3884d57662cd23df0c2e7cc6503" translate="yes" xml:space="preserve">
          <source>The pg_config utility prints configuration parameters of the currently installed version of PostgreSQL. It is intended, for example, to be used by software packages that want to interface to PostgreSQL to facilitate finding the required header files and libraries.</source>
          <target state="translated">Утилита pg_config печатает параметры конфигурации текущей версии PostgreSQL.Она предназначена,например,для использования программными пакетами,которые хотят взаимодействовать с PostgreSQL для облегчения поиска необходимых заголовочных файлов и библиотек.</target>
        </trans-unit>
        <trans-unit id="38257de71aaf3c94498314a3023e95f97988a3ee" translate="yes" xml:space="preserve">
          <source>The phenomena which are prohibited at various levels are:</source>
          <target state="translated">Явления,которые запрещены на различных уровнях:</target>
        </trans-unit>
        <trans-unit id="23f998eae14382a70d2324fb449ffb907b06c285" translate="yes" xml:space="preserve">
          <source>The phrases &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;ILIKE&lt;/code&gt;, &lt;code&gt;NOT LIKE&lt;/code&gt;, and &lt;code&gt;NOT ILIKE&lt;/code&gt; are generally treated as operators in PostgreSQL syntax; for example they can be used in &lt;code&gt;expression&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt; ANY (&lt;code&gt;subquery&lt;/code&gt;) constructs, although an &lt;code&gt;ESCAPE&lt;/code&gt; clause cannot be included there. In some obscure cases it may be necessary to use the underlying operator names instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2bc77065c28244748a514edbbf72d360f29dfc" translate="yes" xml:space="preserve">
          <source>The physical location of the row version within its table. Note that although the &lt;code&gt;ctid&lt;/code&gt; can be used to locate the row version very quickly, a row's &lt;code&gt;ctid&lt;/code&gt; will change if it is updated or moved by &lt;code&gt;VACUUM FULL&lt;/code&gt;. Therefore &lt;code&gt;ctid&lt;/code&gt; is useless as a long-term row identifier. A primary key should be used to identify logical rows.</source>
          <target state="translated">Физическое расположение версии строки в таблице. Обратите внимание, что хотя &lt;code&gt;ctid&lt;/code&gt; можно использовать для очень быстрого поиска версии строки, &lt;code&gt;ctid&lt;/code&gt; строки изменится, если она будет обновлена ​​или перемещена с помощью &lt;code&gt;VACUUM FULL&lt;/code&gt; . Следовательно, &lt;code&gt;ctid&lt;/code&gt; бесполезен как долгосрочный идентификатор строки. Для идентификации логических строк следует использовать первичный ключ.</target>
        </trans-unit>
        <trans-unit id="ed43e04d92b420464b4279a7468ab8888b8672c6" translate="yes" xml:space="preserve">
          <source>The planner assumes that the two conditions are independent, so that the individual selectivities of the clauses can be multiplied together:</source>
          <target state="translated">Планировщик исходит из того,что эти два условия являются независимыми,так что индивидуальная избирательность пунктов может быть умножена вместе:</target>
        </trans-unit>
        <trans-unit id="5f8b19a5896d87add8af3e241d28d22aabc60ce5" translate="yes" xml:space="preserve">
          <source>The planner cannot automatically determine whether a user-defined function or aggregate is parallel safe, parallel restricted, or parallel unsafe, because this would require predicting every operation which the function could possibly perform. In general, this is equivalent to the Halting Problem and therefore impossible. Even for simple functions where it could conceivably be done, we do not try, since this would be expensive and error-prone. Instead, all user-defined functions are assumed to be parallel unsafe unless otherwise marked. When using &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; or &lt;a href=&quot;sql-alterfunction&quot;&gt;ALTER FUNCTION&lt;/a&gt;, markings can be set by specifying &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;, or &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; as appropriate. When using &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;, the &lt;code&gt;PARALLEL&lt;/code&gt; option can be specified with &lt;code&gt;SAFE&lt;/code&gt;, &lt;code&gt;RESTRICTED&lt;/code&gt;, or &lt;code&gt;UNSAFE&lt;/code&gt; as the corresponding value.</source>
          <target state="translated">Планировщик не может автоматически определить, является ли определяемая пользователем функция или агрегат параллельной безопасностью, параллельной ограниченностью или параллельной небезопасностью, потому что это потребовало бы прогнозирования каждой операции, которую функция могла бы выполнить. В общем, это эквивалентно проблеме остановки и поэтому невозможно. Мы не пытаемся выполнить даже простые функции, которые предположительно могут быть выполнены, поскольку это было бы дорого и чревато ошибками. Вместо этого предполагается, что все определяемые пользователем функции небезопасны при параллельном использовании, если не указано иное. При использовании &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; или &lt;a href=&quot;sql-alterfunction&quot;&gt;ALTER FUNCTION&lt;/a&gt; маркировку можно установить, указав &lt;code&gt;PARALLEL SAFE&lt;/code&gt; , &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; или &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; в зависимости от ситуации. Когда используешь&lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; , параметр &lt;code&gt;PARALLEL&lt;/code&gt; может быть указан с &lt;code&gt;SAFE&lt;/code&gt; , &lt;code&gt;RESTRICTED&lt;/code&gt; или &lt;code&gt;UNSAFE&lt;/code&gt; в качестве соответствующего значения.</target>
        </trans-unit>
        <trans-unit id="9b371bcb4f76e8388ab2f98830da7c42b56f6e59" translate="yes" xml:space="preserve">
          <source>The planner classifies operations involved in a query as either &lt;em&gt;parallel safe&lt;/em&gt;, &lt;em&gt;parallel restricted&lt;/em&gt;, or &lt;em&gt;parallel unsafe&lt;/em&gt;. A parallel safe operation is one which does not conflict with the use of parallel query. A parallel restricted operation is one which cannot be performed in a parallel worker, but which can be performed in the leader while parallel query is in use. Therefore, parallel restricted operations can never occur below a &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node, but can occur elsewhere in a plan which contains such a node. A parallel unsafe operation is one which cannot be performed while parallel query is in use, not even in the leader. When a query contains anything which is parallel unsafe, parallel query is completely disabled for that query.</source>
          <target state="translated">Планировщик классифицирует операции, участвующие в запросе, как &lt;em&gt;параллельные безопасные&lt;/em&gt; , &lt;em&gt;параллельные ограниченные&lt;/em&gt; или &lt;em&gt;параллельные небезопасные&lt;/em&gt; . Безопасная параллельная операция - это операция, которая не конфликтует с использованием параллельного запроса. Параллельная ограниченная операция - это операция, которая не может выполняться в параллельном работнике, но может выполняться в ведущем, пока используется параллельный запрос. Следовательно, параллельные операции с ограничениями никогда не могут происходить ниже &lt;code&gt;Gather&lt;/code&gt; или &lt;code&gt;Gather Merge&lt;/code&gt; .узел, но может встречаться в любом месте плана, содержащего такой узел. Параллельная небезопасная операция - это операция, которая не может быть выполнена во время использования параллельного запроса, даже в ведущем. Когда запрос содержит что-либо, что является небезопасным для параллелизма, параллельный запрос для этого запроса полностью отключается.</target>
        </trans-unit>
        <trans-unit id="41ec537c1145f33dc399ea4d0d8e72c677f37799" translate="yes" xml:space="preserve">
          <source>The planner estimates the selectivity for each condition individually, arriving at the same 1% estimates as above. Then it assumes that the conditions are independent, and so it multiplies their selectivities, producing a final selectivity estimate of just 0.01%. This is a significant underestimate, as the actual number of rows matching the conditions (100) is two orders of magnitude higher.</source>
          <target state="translated">Планировщик оценивает селективность для каждого условия индивидуально,получая те же 1% оценки,что и выше.Затем он предполагает,что условия являются независимыми,и поэтому умножает их селективность,получив окончательную оценку селективности всего в 0,01%.Это существенно недооценивается,так как фактическое количество строк,соответствующих условиям (100)на два порядка выше.</target>
        </trans-unit>
        <trans-unit id="12ef35e8963b60e1a1f66c8c5c86ede0e85c0b68" translate="yes" xml:space="preserve">
          <source>The planner examines the &lt;code&gt;WHERE&lt;/code&gt; clause condition and looks up the selectivity function for the operator &lt;code&gt;&amp;lt;&lt;/code&gt; in &lt;code&gt;pg_operator&lt;/code&gt;. This is held in the column &lt;code&gt;oprrest&lt;/code&gt;, and the entry in this case is &lt;code&gt;scalarltsel&lt;/code&gt;. The &lt;code&gt;scalarltsel&lt;/code&gt; function retrieves the histogram for &lt;code&gt;unique1&lt;/code&gt; from &lt;code&gt;pg_statistic&lt;/code&gt;. For manual queries it is more convenient to look in the simpler &lt;code&gt;pg_stats&lt;/code&gt; view:</source>
          <target state="translated">Планировщик проверяет условие предложения &lt;code&gt;WHERE&lt;/code&gt; и ищет функцию селективности для оператора &lt;code&gt;&amp;lt;&lt;/code&gt; в &lt;code&gt;pg_operator&lt;/code&gt; . Это содержится в столбце &lt;code&gt;oprrest&lt;/code&gt; , и запись в данном случае - &lt;code&gt;scalarltsel&lt;/code&gt; . Функция &lt;code&gt;scalarltsel&lt;/code&gt; извлекает гистограмму для &lt;code&gt;unique1&lt;/code&gt; из &lt;code&gt;pg_statistic&lt;/code&gt; . Для ручных запросов удобнее искать в более &lt;code&gt;pg_stats&lt;/code&gt; представлении pg_stats :</target>
        </trans-unit>
        <trans-unit id="55eece76171cb5150093319bc0d23d3c3262a30e" translate="yes" xml:space="preserve">
          <source>The planner examines the condition and determines the selectivity of this clause to be 1%. By comparing this estimate and the actual number of rows, we see that the estimate is very accurate (in fact exact, as the table is very small). Changing the &lt;code&gt;WHERE&lt;/code&gt; condition to use the &lt;code&gt;b&lt;/code&gt; column, an identical plan is generated. But observe what happens if we apply the same condition on both columns, combining them with &lt;code&gt;AND&lt;/code&gt;:</source>
          <target state="translated">Планировщик проверяет условие и определяет селективность этого пункта равной 1%. Сравнивая эту оценку и фактическое количество строк, мы видим, что оценка очень точна (на самом деле точна, поскольку таблица очень мала). При изменении условия &lt;code&gt;WHERE&lt;/code&gt; на использование столбца &lt;code&gt;b&lt;/code&gt; создается идентичный план. Но посмотрите, что произойдет, если мы применим одно и то же условие к обоим столбцам, объединив их с &lt;code&gt;AND&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7a1338924ef7e4d51c210a157253f9f111c3a5a5" translate="yes" xml:space="preserve">
          <source>The planner may implement an &lt;code&gt;ORDER BY&lt;/code&gt; clause in several ways. The above example shows that such an ordering clause may be implemented implicitly. The planner may also add an explicit &lt;code&gt;sort&lt;/code&gt; step:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccbe97e96812fba17e36b64c7a8a14a6a5fc672b" translate="yes" xml:space="preserve">
          <source>The planner thinks (quite correctly) that this sample table is too small to bother with an index scan, so we have a plain sequential scan in which all the rows got rejected by the filter condition. But if we force an index scan to be used, we see:</source>
          <target state="translated">Планировщик считает (вполне корректно),что этот образец таблицы слишком мал,чтобы беспокоиться о сканировании индексов,поэтому у нас есть простая последовательная проверка,в которой все строки были отвергнуты условием фильтрации.Но если мы заставим использовать проверку индексов,мы увидим:</target>
        </trans-unit>
        <trans-unit id="9e657fb9f6d61f80be4eb7b46475ad5f607f9e2a" translate="yes" xml:space="preserve">
          <source>The planner will consider satisfying an &lt;code&gt;ORDER BY&lt;/code&gt; specification either by scanning an available index that matches the specification, or by scanning the table in physical order and doing an explicit sort. For a query that requires scanning a large fraction of the table, an explicit sort is likely to be faster than using an index because it requires less disk I/O due to following a sequential access pattern. Indexes are more useful when only a few rows need be fetched. An important special case is &lt;code&gt;ORDER BY&lt;/code&gt; in combination with &lt;code&gt;LIMIT&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;: an explicit sort will have to process all the data to identify the first &lt;code&gt;n&lt;/code&gt; rows, but if there is an index matching the &lt;code&gt;ORDER BY&lt;/code&gt;, the first &lt;code&gt;n&lt;/code&gt; rows can be retrieved directly, without scanning the remainder at all.</source>
          <target state="translated">Планировщик рассмотрит возможность удовлетворения спецификации &lt;code&gt;ORDER BY&lt;/code&gt; либо путем сканирования доступного индекса, который соответствует спецификации, либо путем сканирования таблицы в физическом порядке и выполнения явной сортировки. Для запроса, который требует сканирования большой части таблицы, явная сортировка, вероятно, будет быстрее, чем использование индекса, поскольку для этого требуется меньше операций ввода-вывода на диск из-за следования последовательному шаблону доступа. Индексы более полезны, когда нужно выбрать только несколько строк. Важным особым случаем является &lt;code&gt;ORDER BY&lt;/code&gt; в сочетании с &lt;code&gt;LIMIT&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; : явная сортировка должна обработать все данные для идентификации первых &lt;code&gt;n&lt;/code&gt; строк, но если есть индекс, соответствующий &lt;code&gt;ORDER BY&lt;/code&gt; , первые &lt;code&gt;n&lt;/code&gt; строки могут быть извлечены напрямую, без сканирования остатка.</target>
        </trans-unit>
        <trans-unit id="f13fe03a32c9bbc1e61cf84d9ac188afb139c0ce" translate="yes" xml:space="preserve">
          <source>The planner will merge sub-queries into upper queries if the resulting &lt;code&gt;FROM&lt;/code&gt; list would have no more than this many items. Smaller values reduce planning time but might yield inferior query plans. The default is eight. For more information see &lt;a href=&quot;explicit-joins&quot;&gt;Section 14.3&lt;/a&gt;.</source>
          <target state="translated">Планировщик объединит подзапросы в запросы верхнего уровня, если в &lt;code&gt;FROM&lt;/code&gt; списке FROM будет не более указанного количества элементов. Меньшие значения сокращают время планирования, но могут привести к плохим планам запросов. По умолчанию восемь. Для получения дополнительной информации см. &lt;a href=&quot;explicit-joins&quot;&gt;Раздел 14.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e54dd315c563119cab38a459210d1e25c17b541" translate="yes" xml:space="preserve">
          <source>The planner will rewrite explicit &lt;code&gt;JOIN&lt;/code&gt; constructs (except &lt;code&gt;FULL JOIN&lt;/code&gt;s) into lists of &lt;code&gt;FROM&lt;/code&gt; items whenever a list of no more than this many items would result. Smaller values reduce planning time but might yield inferior query plans.</source>
          <target state="translated">Планировщик перепишет явные конструкции &lt;code&gt;JOIN&lt;/code&gt; (кроме &lt;code&gt;FULL JOIN&lt;/code&gt; ) в списки элементов &lt;code&gt;FROM&lt;/code&gt; всякий раз, когда в результате будет получен список, не превышающий этого количества элементов. Меньшие значения сокращают время планирования, но могут привести к плохим планам запросов.</target>
        </trans-unit>
        <trans-unit id="51459135e7da0626e3461453ee190521c7ca83f8" translate="yes" xml:space="preserve">
          <source>The planner's information about the query being processed.</source>
          <target state="translated">Информация планировщика о обрабатываемом запросе.</target>
        </trans-unit>
        <trans-unit id="1577e921445112f0dec558626039eff4a0e20d9e" translate="yes" xml:space="preserve">
          <source>The planner's search procedure actually works with data structures called &lt;em&gt;paths&lt;/em&gt;, which are simply cut-down representations of plans containing only as much information as the planner needs to make its decisions. After the cheapest path is determined, a full-fledged &lt;em&gt;plan tree&lt;/em&gt; is built to pass to the executor. This represents the desired execution plan in sufficient detail for the executor to run it. In the rest of this section we'll ignore the distinction between paths and plans.</source>
          <target state="translated">Процедура поиска планировщика фактически работает со структурами данных, называемыми &lt;em&gt;путями&lt;/em&gt; , которые представляют собой просто сокращенные представления планов, содержащие ровно столько информации, сколько требуется планировщику для принятия решений. После определения наиболее дешевого пути строится полноценное &lt;em&gt;дерево плана&lt;/em&gt; для передачи исполнителю. Это представляет желаемый план выполнения достаточно подробно, чтобы исполнитель мог его запустить. В оставшейся части этого раздела мы проигнорируем различие между путями и планами.</target>
        </trans-unit>
        <trans-unit id="4a55c4b471813d250b09c8e9cf01cec1bc297015" translate="yes" xml:space="preserve">
          <source>The planner/optimizer starts by generating plans for scanning each individual relation (table) used in the query. The possible plans are determined by the available indexes on each relation. There is always the possibility of performing a sequential scan on a relation, so a sequential scan plan is always created. Assume an index is defined on a relation (for example a B-tree index) and a query contains the restriction &lt;code&gt;relation.attribute OPR constant&lt;/code&gt;. If &lt;code&gt;relation.attribute&lt;/code&gt; happens to match the key of the B-tree index and &lt;code&gt;OPR&lt;/code&gt; is one of the operators listed in the index's &lt;em&gt;operator class&lt;/em&gt;, another plan is created using the B-tree index to scan the relation. If there are further indexes present and the restrictions in the query happen to match a key of an index, further plans will be considered. Index scan plans are also generated for indexes that have a sort ordering that can match the query's &lt;code&gt;ORDER BY&lt;/code&gt; clause (if any), or a sort ordering that might be useful for merge joining (see below).</source>
          <target state="translated">Планировщик / оптимизатор начинает с создания планов сканирования каждого отдельного отношения (таблицы), используемого в запросе. Возможные планы определяются доступными индексами для каждого отношения. Всегда есть возможность выполнить последовательное сканирование отношения, поэтому всегда создается план последовательного сканирования. Предположим, что индекс определен для отношения (например, индекс B-дерева), а запрос содержит &lt;code&gt;relation.attribute OPR constant&lt;/code&gt; ограничения атрибута . Если &lt;code&gt;relation.attribute&lt;/code&gt; происходит в соответствии с ключом индекса B-дерева и &lt;code&gt;OPR&lt;/code&gt; является одним из операторов , перечисленных в индексе в &lt;em&gt;классе оператора&lt;/em&gt;, другой план создается с использованием индекса B-дерева для сканирования отношения. Если имеются другие индексы и ограничения в запросе совпадают с ключом индекса, будут рассмотрены дальнейшие планы. Планы сканирования индексов также создаются для индексов, которые имеют порядок сортировки, который может соответствовать предложению &lt;code&gt;ORDER BY&lt;/code&gt; запроса (если есть), или порядок сортировки, который может быть полезен для объединения слиянием (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="af6fcc949e29ec6b5395bb9895c598ac00851a39" translate="yes" xml:space="preserve">
          <source>The policy above implicitly provides a &lt;code&gt;WITH CHECK&lt;/code&gt; clause identical to its &lt;code&gt;USING&lt;/code&gt; clause, so that the constraint applies both to rows selected by a command (so a manager cannot &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; existing rows belonging to a different manager) and to rows modified by a command (so rows belonging to a different manager cannot be created via &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;).</source>
          <target state="translated">Вышеупомянутая политика неявно предоставляет предложение &lt;code&gt;WITH CHECK&lt;/code&gt; , идентичное его предложению &lt;code&gt;USING&lt;/code&gt; , так что ограничение применяется как к строкам, выбранным командой (поэтому менеджер не может &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; существующие строки, принадлежащие другому менеджеру), так и к измененным строкам. с помощью команды (поэтому строки, принадлежащие другому менеджеру, не могут быть созданы с помощью &lt;code&gt;INSERT&lt;/code&gt; или &lt;code&gt;UPDATE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="332f3ca0119d1ff928cc3032c43d7a8c6d076ef7" translate="yes" xml:space="preserve">
          <source>The port number at which the database server is listening.</source>
          <target state="translated">Номер порта,на котором прослушивается сервер базы данных.</target>
        </trans-unit>
        <trans-unit id="3946be524d4d21ed59a4396709c558221452e965" translate="yes" xml:space="preserve">
          <source>The port number on the RADIUS servers to connect to. If no port is specified, the default port &lt;code&gt;1812&lt;/code&gt; will be used.</source>
          <target state="translated">Номер порта на серверах RADIUS для подключения. Если порт не указан, будет использоваться порт по умолчанию &lt;code&gt;1812&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e70d1aceb09cc5ddba7934344393827032e6f65c" translate="yes" xml:space="preserve">
          <source>The port numbers to connect to on the RADIUS servers. If no port is specified, the default RADIUS port (&lt;code&gt;1812&lt;/code&gt;) will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78397caeb854681d204384441be23fbf5963377" translate="yes" xml:space="preserve">
          <source>The possible privileges are:</source>
          <target state="translated">Возможные привилегии:</target>
        </trans-unit>
        <trans-unit id="f40d6965a9bc397fb0c918307a4356333c6e9be1" translate="yes" xml:space="preserve">
          <source>The possible types of qualified join are:</source>
          <target state="translated">Возможные типы квалифицированного соединения:</target>
        </trans-unit>
        <trans-unit id="150d329b119d4f11b9ac2cd02c8c0d218611bacb" translate="yes" xml:space="preserve">
          <source>The potential for bloat in non-B-tree indexes has not been well researched. It is a good idea to periodically monitor the index's physical size when using any non-B-tree index type.</source>
          <target state="translated">Потенциал разбухания в не-деревянных индексах не был хорошо изучен.Хорошей идеей является периодический мониторинг физических размеров индекса при использовании любого не-деревянного типа индексов.</target>
        </trans-unit>
        <trans-unit id="d757a72d029cfb4caba9e0b1db29785724f4d19a" translate="yes" xml:space="preserve">
          <source>The preceding statement is not true on Microsoft Windows: there, any changes in the &lt;code&gt;pg_hba.conf&lt;/code&gt; file are immediately applied by subsequent new connections.</source>
          <target state="translated">Предыдущее утверждение неверно в Microsoft Windows: там любые изменения в &lt;code&gt;pg_hba.conf&lt;/code&gt; немедленно применяются при последующих новых подключениях.</target>
        </trans-unit>
        <trans-unit id="252c412e1c63dfae47e051caef322b62e83bb886" translate="yes" xml:space="preserve">
          <source>The precise rule that is applied in such cases is that an invalid timestamp that appears to fall within a jump-forward daylight savings transition is assigned the UTC offset that prevailed in the time zone just before the transition, while an ambiguous timestamp that could fall on either side of a jump-back transition is assigned the UTC offset that prevailed just after the transition. In most time zones this is equivalent to saying that &amp;ldquo;the standard-time interpretation is preferred when in doubt&amp;rdquo;.</source>
          <target state="translated">Точное правило, которое применяется в таких случаях, заключается в том, что недействительной метке времени, которая, кажется, попадает в переход на летнее время с переходом вперед, назначается смещение UTC, которое преобладало в часовом поясе непосредственно перед переходом, в то время как неоднозначная метка времени, которая могла выпасть на обеим сторонам обратного перехода назначается смещение по всемирному координированному времени, которое преобладало сразу после перехода. В большинстве часовых поясов это эквивалентно тому, что &amp;laquo;в случае сомнений предпочтительнее использовать стандартное время&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="28bfcc19c7bbea45feb0d0e7674c45c3d0b2a8ce" translate="yes" xml:space="preserve">
          <source>The precision must be positive, the scale zero or positive. Alternatively:</source>
          <target state="translated">Точность должна быть положительной,нулевая или положительная.В качестве альтернативы:</target>
        </trans-unit>
        <trans-unit id="3ffc8a93a54e6689bf8eb9af624f2ca2cef390c0" translate="yes" xml:space="preserve">
          <source>The predefined aggregate functions are described in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt;. Other aggregate functions can be added by the user.</source>
          <target state="translated">Предопределенные агрегатные функции описаны в &lt;a href=&quot;functions-aggregate&quot;&gt;Разделе 9.20&lt;/a&gt; . Другие агрегатные функции могут быть добавлены пользователем.</target>
        </trans-unit>
        <trans-unit id="e0a2c0ac127cccc7aaf6bb36feba44f57ab9026a" translate="yes" xml:space="preserve">
          <source>The predefined aggregate functions are described in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt;. Other aggregate functions can be added by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85290651a145a4790c306bf3090be3ac088ff86f" translate="yes" xml:space="preserve">
          <source>The preferred key type is &amp;ldquo;DSA and Elgamal&amp;rdquo;.</source>
          <target state="translated">Предпочтительный тип ключа - &amp;laquo;DSA и Elgamal&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9dcad895255c51069330af5d11a7861de5e972db" translate="yes" xml:space="preserve">
          <source>The preferred way of creating any of the standard procedural languages is just:</source>
          <target state="translated">Предпочтительный способ создания любого из стандартных процедурных языков-просто:</target>
        </trans-unit>
        <trans-unit id="1d193e74c38ebc3f88cf6c96d5dc626c1a851ce8" translate="yes" xml:space="preserve">
          <source>The preferred way to add and remove members of roles that are being used as groups is to use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;.</source>
          <target state="translated">Предпочтительный способ добавления и удаления членов ролей, которые используются как группы, - использовать &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; и &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="56dfc8a10ef1e4c4eee74088145c35840ecca451" translate="yes" xml:space="preserve">
          <source>The prefixes used for hyphenation were also compiled from:</source>
          <target state="translated">Также были скомпилированы префиксы,используемые для дешифрирования:</target>
        </trans-unit>
        <trans-unit id="21fd2dec3de8b8ad1e5f622c8c13eab56cd148d6" translate="yes" xml:space="preserve">
          <source>The presence of &lt;code&gt;HAVING&lt;/code&gt; turns a query into a grouped query even if there is no &lt;code&gt;GROUP BY&lt;/code&gt; clause. This is the same as what happens when the query contains aggregate functions but no &lt;code&gt;GROUP BY&lt;/code&gt; clause. All the selected rows are considered to form a single group, and the &lt;code&gt;SELECT&lt;/code&gt; list and &lt;code&gt;HAVING&lt;/code&gt; clause can only reference table columns from within aggregate functions. Such a query will emit a single row if the &lt;code&gt;HAVING&lt;/code&gt; condition is true, zero rows if it is not true.</source>
          <target state="translated">Наличие &lt;code&gt;HAVING&lt;/code&gt; превращает запрос в сгруппированный запрос, даже если нет предложения &lt;code&gt;GROUP BY&lt;/code&gt; . Это то же самое, что происходит, когда запрос содержит агрегатные функции, но не содержит предложения &lt;code&gt;GROUP BY&lt;/code&gt; . Считается, что все выбранные строки образуют единую группу, а список &lt;code&gt;SELECT&lt;/code&gt; и предложение &lt;code&gt;HAVING&lt;/code&gt; могут ссылаться только на столбцы таблицы из агрегатных функций. Такой запрос выдаст одну строку, если условие &lt;code&gt;HAVING&lt;/code&gt; истинно, и ноль строк, если это не так.</target>
        </trans-unit>
        <trans-unit id="48e01dab4eaf7172ed513c36aea408ac9dcff0a1" translate="yes" xml:space="preserve">
          <source>The previous example with &lt;code&gt;unique1 &amp;lt; 1000&lt;/code&gt; was an oversimplification of what &lt;code&gt;scalarltsel&lt;/code&gt; really does; now that we have seen an example of the use of MCVs, we can fill in some more detail. The example was correct as far as it went, because since &lt;code&gt;unique1&lt;/code&gt; is a unique column it has no MCVs (obviously, no value is any more common than any other value). For a non-unique column, there will normally be both a histogram and an MCV list, and &lt;em&gt;the histogram does not include the portion of the column population represented by the MCVs&lt;/em&gt;. We do things this way because it allows more precise estimation. In this situation &lt;code&gt;scalarltsel&lt;/code&gt; directly applies the condition (e.g., &amp;ldquo;&amp;lt; 1000&amp;rdquo;) to each value of the MCV list, and adds up the frequencies of the MCVs for which the condition is true. This gives an exact estimate of the selectivity within the portion of the table that is MCVs. The histogram is then used in the same way as above to estimate the selectivity in the portion of the table that is not MCVs, and then the two numbers are combined to estimate the overall selectivity. For example, consider</source>
          <target state="translated">Предыдущий пример с &lt;code&gt;unique1 &amp;lt; 1000&lt;/code&gt; был чрезмерным упрощением того, что на &lt;code&gt;scalarltsel&lt;/code&gt; деле делает scalarltsel ; Теперь, когда мы увидели пример использования MCV, мы можем заполнить некоторые детали. Пример был правильным, поскольку он зашел, потому что, поскольку &lt;code&gt;unique1&lt;/code&gt; - уникальный столбец, он не имеет MCV (очевидно, что нет значения более распространенного, чем любое другое значение). Для неуникального столбца обычно будет и гистограмма, и список MCV, и &lt;em&gt;гистограмма не включает часть совокупности столбца, представленную MCV&lt;/em&gt; . Мы поступаем так, потому что это позволяет более точно оценить. В этой ситуации &lt;code&gt;scalarltsel&lt;/code&gt; непосредственно применяет условие (например, &amp;laquo;&amp;lt;1000&amp;raquo;) к каждому значению списка MCV и складывает частоты MCV, для которых условие истинно. Это дает точную оценку селективности в той части таблицы, которая соответствует MCV. Затем гистограмма используется таким же образом, как и выше, для оценки избирательности в той части таблицы, которая не является MCV, а затем два числа объединяются для оценки общей избирательности. Например, рассмотрим</target>
        </trans-unit>
        <trans-unit id="bb34259f0365c548655973db55e1cb8224129b77" translate="yes" xml:space="preserve">
          <source>The primary and standby server work together to provide this capability, though the servers are only loosely coupled. The primary server operates in continuous archiving mode, while each standby server operates in continuous recovery mode, reading the WAL files from the primary. No changes to the database tables are required to enable this capability, so it offers low administration overhead compared to some other replication solutions. This configuration also has relatively low performance impact on the primary server.</source>
          <target state="translated">Основной и резервный сервер работают вместе,чтобы обеспечить эту возможность,хотя серверы только слабо связаны друг с другом.Основной сервер работает в режиме непрерывного архивирования,в то время как каждый резервный сервер работает в режиме непрерывного восстановления,читая файлы WAL с основного.Для включения этой возможности не требуется вносить никаких изменений в таблицы базы данных,поэтому она обеспечивает низкие накладные расходы на администрирование по сравнению с некоторыми другими решениями по репликации.Такая конфигурация также имеет относительно низкое влияние на производительность основного сервера.</target>
        </trans-unit>
        <trans-unit id="0da66f61871c96b75f9ab923507bcc1a24b7f889" translate="yes" xml:space="preserve">
          <source>The primary and standby servers are in many ways loosely connected. Actions on the primary will have an effect on the standby. As a result, there is potential for negative interactions or conflicts between them. The easiest conflict to understand is performance: if a huge data load is taking place on the primary then this will generate a similar stream of WAL records on the standby, so standby queries may contend for system resources, such as I/O.</source>
          <target state="translated">Основной и резервный серверы во многом слабо связаны между собой.Действия с первичным сервером повлияют на резервный.В результате,существует вероятность негативного взаимодействия или конфликтов между ними.Самый простой конфликт,который можно понять,это производительность:если на первичном сервере происходит огромная нагрузка на данные,то это сгенерирует аналогичный поток записей WAL на резервном сервере,поэтому резервные запросы могут претендовать на системные ресурсы,такие как ввод/вывод.</target>
        </trans-unit>
        <trans-unit id="798c0c5f43fda644a454b46372f29e554497fa2e" translate="yes" xml:space="preserve">
          <source>The primary error message and associated SQLSTATE code for the most recent failed query in the current psql session, or an empty string and &lt;code&gt;00000&lt;/code&gt; if no error has occurred in the current session.</source>
          <target state="translated">Основное сообщение об ошибке и связанный с ним код SQLSTATE для последнего неудачного запроса в текущем сеансе psql или пустая строка и &lt;code&gt;00000&lt;/code&gt; , если в текущем сеансе ошибок не было.</target>
        </trans-unit>
        <trans-unit id="3ab145e1a33deb5fe3582f237dbec8cdd7e1d8ca" translate="yes" xml:space="preserve">
          <source>The primary goal of developing GIN indexes was to create support for highly scalable full-text search in PostgreSQL, and there are often situations when a full-text search returns a very large set of results. Moreover, this often happens when the query contains very frequent words, so that the large result set is not even useful. Since reading many tuples from the disk and sorting them could take a lot of time, this is unacceptable for production. (Note that the index search itself is very fast.)</source>
          <target state="translated">Основной целью разработки GIN-индексов было создание поддержки высокомасштабируемого полнотекстового поиска в PostgreSQL,и часто возникают ситуации,когда полнотекстовый поиск возвращает очень большой набор результатов.Более того,это часто бывает,когда запрос содержит очень частые слова,так что большой набор результатов даже не приносит пользы.Поскольку чтение многих кортежей с диска и их сортировка могут занять много времени,это недопустимо для производства.(Обратите внимание,что поиск по индексам сам по себе очень быстрый).</target>
        </trans-unit>
        <trans-unit id="6c7d00d06905a4bbc00c744c0f27a07f33dd5060" translate="yes" xml:space="preserve">
          <source>The primary key constraint should name a set of columns that is different from the set of columns named by any unique constraint defined for the same table. (Otherwise, the unique constraint is redundant and will be discarded.)</source>
          <target state="translated">Ограничение первичного ключа должно называть набор столбцов,который отличается от набора столбцов,названного любым уникальным ограничением,определенным для одной и той же таблицы.(В противном случае,уникальное ограничение является избыточным и будет отброшено).</target>
        </trans-unit>
        <trans-unit id="095c1f180ee69bf2f8a1425ef17c7371474cd375" translate="yes" xml:space="preserve">
          <source>The primary query and the &lt;code&gt;WITH&lt;/code&gt; queries are all (notionally) executed at the same time. This implies that the effects of a data-modifying statement in &lt;code&gt;WITH&lt;/code&gt; cannot be seen from other parts of the query, other than by reading its &lt;code&gt;RETURNING&lt;/code&gt; output. If two such data-modifying statements attempt to modify the same row, the results are unspecified.</source>
          <target state="translated">Первичный запрос и запросы &lt;code&gt;WITH&lt;/code&gt; выполняются (условно) одновременно. Это означает, что эффекты оператора изменения данных в &lt;code&gt;WITH&lt;/code&gt; нельзя увидеть из других частей запроса, кроме как при чтении его вывода &lt;code&gt;RETURNING&lt;/code&gt; . Если два таких оператора изменения данных пытаются изменить одну и ту же строку, результаты не указаны.</target>
        </trans-unit>
        <trans-unit id="9af619375db4792c2c6568b4b82266a2578d8e4a" translate="yes" xml:space="preserve">
          <source>The primary use of unlogged tables is for storing transient work data that must be shared across processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ea3da5c410e9ce91a550f33e83dec4f1762b9fe" translate="yes" xml:space="preserve">
          <source>The privileges necessary to execute this command are left implementation-defined by the standard.</source>
          <target state="translated">Привилегии,необходимые для выполнения этой команды,оставлены реализацией,определяемой стандартом.</target>
        </trans-unit>
        <trans-unit id="3d054afefddca1f4fd0c80061650d8bf2f8607fd" translate="yes" xml:space="preserve">
          <source>The privileges required by other commands are listed on the reference page of the respective command.</source>
          <target state="translated">Привилегии,требуемые другими командами,перечислены на странице ссылок соответствующей команды.</target>
        </trans-unit>
        <trans-unit id="304d4014e67dda82fac817f06e9aef50bfd659e4" translate="yes" xml:space="preserve">
          <source>The privileges required to create a conversion might be changed in a future release.</source>
          <target state="translated">Привилегии,необходимые для создания преобразования,могут быть изменены в будущем релизе.</target>
        </trans-unit>
        <trans-unit id="1eb7e4f8bb27785f30b9b8a7055a803cd67b6df6" translate="yes" xml:space="preserve">
          <source>The privileges that have been granted for a particular object are displayed as a list of &lt;code&gt;aclitem&lt;/code&gt; entries, where each &lt;code&gt;aclitem&lt;/code&gt; describes the permissions of one grantee that have been granted by a particular grantor. For example, &lt;code&gt;calvin=r*w/hobbes&lt;/code&gt; specifies that the role &lt;code&gt;calvin&lt;/code&gt; has the privilege &lt;code&gt;SELECT&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;) with grant option (&lt;code&gt;*&lt;/code&gt;) as well as the non-grantable privilege &lt;code&gt;UPDATE&lt;/code&gt; (&lt;code&gt;w&lt;/code&gt;), both granted by the role &lt;code&gt;hobbes&lt;/code&gt;. If &lt;code&gt;calvin&lt;/code&gt; also has some privileges on the same object granted by a different grantor, those would appear as a separate &lt;code&gt;aclitem&lt;/code&gt; entry. An empty grantee field in an &lt;code&gt;aclitem&lt;/code&gt; stands for &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">Привилегии, предоставленные конкретному объекту, отображаются в виде списка записей &lt;code&gt;aclitem&lt;/code&gt; , где каждый &lt;code&gt;aclitem&lt;/code&gt; описывает разрешения одного получателя гранта, предоставленные конкретным поставщиком. Например, &lt;code&gt;calvin=r*w/hobbes&lt;/code&gt; указывает, что роль &lt;code&gt;calvin&lt;/code&gt; имеет привилегию &lt;code&gt;SELECT&lt;/code&gt; ( &lt;code&gt;r&lt;/code&gt; ) с опцией предоставления ( &lt;code&gt;*&lt;/code&gt; ), а также не предоставляемую привилегию &lt;code&gt;UPDATE&lt;/code&gt; ( &lt;code&gt;w&lt;/code&gt; ), обе предоставленные ролью &lt;code&gt;hobbes&lt;/code&gt; . Если у &lt;code&gt;calvin&lt;/code&gt; также есть некоторые привилегии на тот же объект, предоставленные другим праводателем, они будут отображаться как отдельный &lt;code&gt;aclitem&lt;/code&gt; вход. Пустое поле получателя гранта в &lt;code&gt;aclitem&lt;/code&gt; означает &lt;code&gt;PUBLIC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="146fa2f880a1a0967ddf597dd80c4df17c9e7c69" translate="yes" xml:space="preserve">
          <source>The procedural language code to be executed. This must be specified as a string literal, just as in &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Use of a dollar-quoted literal is recommended.</source>
          <target state="translated">Код процедурного языка, который нужно выполнить. Это должно быть указано как строковый литерал, как в &lt;code&gt;CREATE FUNCTION&lt;/code&gt; . Рекомендуется использовать буквальные кавычки в долларах.</target>
        </trans-unit>
        <trans-unit id="6f86ee50294a4a7a3fef4b5b2297c9c5402611ba" translate="yes" xml:space="preserve">
          <source>The procedural language to be used must already have been installed into the current database by means of &lt;code&gt;CREATE EXTENSION&lt;/code&gt;. &lt;code&gt;plpgsql&lt;/code&gt; is installed by default, but other languages are not.</source>
          <target state="translated">Используемый процедурный язык должен быть уже установлен в текущей базе данных с помощью &lt;code&gt;CREATE EXTENSION&lt;/code&gt; . &lt;code&gt;plpgsql&lt;/code&gt; установлен по умолчанию, но другие языки нет.</target>
        </trans-unit>
        <trans-unit id="eeffbbfe4a95a1cfc7af97774b63ebc4c95bcc67" translate="yes" xml:space="preserve">
          <source>The procedure for making a base backup using the low level APIs contains a few more steps than the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; method, but is relatively simple. It is very important that these steps are executed in sequence, and that the success of a step is verified before proceeding to the next step.</source>
          <target state="translated">Процедура создания базовой резервной копии с использованием API низкого уровня содержит на несколько шагов больше, чем метод &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; , но относительно проста. Очень важно, чтобы эти шаги выполнялись последовательно, и чтобы успех шага проверялся перед переходом к следующему шагу.</target>
        </trans-unit>
        <trans-unit id="0cb38c62a0e05e7bd2148e42b61d27ee2ab30693" translate="yes" xml:space="preserve">
          <source>The procedure will now execute with whatever search path is used by its caller.</source>
          <target state="translated">Теперь процедура будет выполняться с любым поисковым путем,используемым вызывающим ее абонентом.</target>
        </trans-unit>
        <trans-unit id="4b5bcbc092d024a0a7543e925fc016ccd66517c6" translate="yes" xml:space="preserve">
          <source>The process ID of the backend currently connected to.</source>
          <target state="translated">Идентификатор процесса бэкэнда,к которому в настоящее время подключен.</target>
        </trans-unit>
        <trans-unit id="34795750bd1d44ec3bd68f7c69b56e729608c717" translate="yes" xml:space="preserve">
          <source>The process ID of the session using this slot if the slot is currently actively being used. &lt;code&gt;NULL&lt;/code&gt; if inactive.</source>
          <target state="translated">Идентификатор процесса сеанса, использующего этот слот, если слот в настоящее время активно используется. &lt;code&gt;NULL&lt;/code&gt; , если неактивен.</target>
        </trans-unit>
        <trans-unit id="32a4bb7cc46bcf50934800d5f3c98570d230e94a" translate="yes" xml:space="preserve">
          <source>The process for an exclusive backup is mostly the same as for a non-exclusive one, but it differs in a few key steps. This type of backup can only be taken on a primary and does not allow concurrent backups. Moreover, because it creates a backup label file, as described below, it can block automatic restart of the master server after a crash. On the other hand, the erroneous removal of this file from a backup or standby is a common mistake, which can result in serious data corruption. If it is necessary to use this method, the following steps may be used.</source>
          <target state="translated">Процесс создания эксклюзивной резервной копии в основном такой же,как и для неэксклюзивной,но отличается несколькими ключевыми этапами.Этот тип резервного копирования может быть принят только на первичном и не допускает одновременного резервного копирования.Более того,поскольку он создает файл метки резервного копирования,как описано ниже,он может блокировать автоматический перезапуск главного сервера после сбоя.С другой стороны,ошибочное удаление этого файла из резервной копии или резервной копии в режиме ожидания является распространенной ошибкой,которая может привести к серьезному повреждению данных.Если необходимо использовать этот метод,можно воспользоваться следующими шагами.</target>
        </trans-unit>
        <trans-unit id="3ac18966156d31cda12f7c9ac2957f1b7e5f24a9" translate="yes" xml:space="preserve">
          <source>The process of collecting statistics from data in &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;tables&lt;/a&gt; and other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt; to help the &lt;a href=&quot;glossary#GLOSSARY-PLANNER&quot;&gt;query planner&lt;/a&gt; to make decisions about how to execute &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;queries&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164dce5302a4d4d5322e298ad9a4e62c23cc3474" translate="yes" xml:space="preserve">
          <source>The process of removing outdated &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuple versions&lt;/a&gt; from tables or materialized views, and other closely related processing required by PostgreSQL's implementation of &lt;a href=&quot;glossary#GLOSSARY-MVCC&quot;&gt;MVCC&lt;/a&gt;. This can be initiated through the use of the &lt;code&gt;VACUUM&lt;/code&gt; command, but can also be handled automatically via &lt;a href=&quot;glossary#GLOSSARY-AUTOVACUUM&quot;&gt;autovacuum&lt;/a&gt; processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e312719075282712af63a4478358c161b9ce7c1" translate="yes" xml:space="preserve">
          <source>The process of retrieving or the command to retrieve data from a database is called a &lt;em&gt;query&lt;/em&gt;. In SQL the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command is used to specify queries. The general syntax of the &lt;code&gt;SELECT&lt;/code&gt; command is</source>
          <target state="translated">Процесс получения или команда для получения данных из базы данных называется &lt;em&gt;запросом&lt;/em&gt; . В SQL для задания запросов используется команда &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; . Общий синтаксис команды &lt;code&gt;SELECT&lt;/code&gt; следующий :</target>
        </trans-unit>
        <trans-unit id="b0bd352dde02b38bfa623807b29516cb539dd331" translate="yes" xml:space="preserve">
          <source>The program &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; is a wrapper program around this command, provided for convenience.</source>
          <target state="translated">Программа &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; представляет собой программу-оболочку вокруг этой команды, предоставленную для удобства.</target>
        </trans-unit>
        <trans-unit id="3eff284be443ff432de37efc6563b33dc2f6e837" translate="yes" xml:space="preserve">
          <source>The prompts psql issues can be customized to your preference. The three variables &lt;code&gt;PROMPT1&lt;/code&gt;, &lt;code&gt;PROMPT2&lt;/code&gt;, and &lt;code&gt;PROMPT3&lt;/code&gt; contain strings and special escape sequences that describe the appearance of the prompt. Prompt 1 is the normal prompt that is issued when psql requests a new command. Prompt 2 is issued when more input is expected during command entry, for example because the command was not terminated with a semicolon or a quote was not closed. Prompt 3 is issued when you are running an SQL &lt;code&gt;COPY FROM STDIN&lt;/code&gt; command and you need to type in a row value on the terminal.</source>
          <target state="translated">Вы можете настроить запросы psql по своему усмотрению. Три переменные &lt;code&gt;PROMPT1&lt;/code&gt; , &lt;code&gt;PROMPT2&lt;/code&gt; и &lt;code&gt;PROMPT3&lt;/code&gt; содержат строки и специальные escape-последовательности, которые описывают внешний вид приглашения. Подсказка 1 - это обычное приглашение, которое выдается, когда psql запрашивает новую команду. Подсказка 2 выдается, когда во время ввода команды ожидается дополнительный ввод, например, потому что команда не была завершена точкой с запятой или цитата не была закрыта. Подсказка 3 выдается, когда вы запускаете команду SQL &lt;code&gt;COPY FROM STDIN&lt;/code&gt; и вам нужно ввести значение строки на терминале.</target>
        </trans-unit>
        <trans-unit id="beda63023776d34df94471c0f164755d13f940bc" translate="yes" xml:space="preserve">
          <source>The property of a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; that either all its operations complete as a single unit or none do. In addition, if a system failure occurs during the execution of a transaction, no partial results are visible after recovery. This is one of the ACID properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60437688afa311c4869b8b3f6a8991364e3687d3" translate="yes" xml:space="preserve">
          <source>The property of certain &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt; that the changes to them are not reflected in the &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;. This disables replication and crash recovery for these relations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb5f3d4498a374f31c0813bda303e196477c5021" translate="yes" xml:space="preserve">
          <source>The property that some information has been pre-computed and stored for later use, rather than computing it on-the-fly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b4c095224b564ce4e74b023e585d03df96a6dc" translate="yes" xml:space="preserve">
          <source>The property that the data in the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; is always in compliance with &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;integrity constraints&lt;/a&gt;. Transactions may be allowed to violate some of the constraints transiently before it commits, but if such violations are not resolved by the time it commits, such a transaction is automatically &lt;a href=&quot;glossary#GLOSSARY-ROLLBACK&quot;&gt;rolled back&lt;/a&gt;. This is one of the ACID properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6435c94ce6f1ff88843d11bc1738457d2390918" translate="yes" xml:space="preserve">
          <source>The property that the effects of a transaction are not visible to &lt;a href=&quot;glossary#GLOSSARY-CONCURRENCY&quot;&gt;concurrent transactions&lt;/a&gt; before it commits. This is one of the ACID properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b52632ebba8d8fdc7d9a5f3df0121e320094037" translate="yes" xml:space="preserve">
          <source>The provided functions are shown in &lt;a href=&quot;earthdistance#EARTHDISTANCE-CUBE-FUNCTIONS&quot;&gt;Table F.5&lt;/a&gt;.</source>
          <target state="translated">Предоставляемые функции показаны в &lt;a href=&quot;earthdistance#EARTHDISTANCE-CUBE-FUNCTIONS&quot;&gt;Таблице F.5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5afa1f9b64bd52e3a56222e3e5d393c2eefea25a" translate="yes" xml:space="preserve">
          <source>The purpose is to limit the impact of pg_basebackup on the running server.</source>
          <target state="translated">Целью является ограничение влияния pg_basebackup на работающий сервер.</target>
        </trans-unit>
        <trans-unit id="5073941a47e032b26bcb9d69507584568abea85b" translate="yes" xml:space="preserve">
          <source>The purpose of a &lt;code&gt;WINDOW&lt;/code&gt; clause is to specify the behavior of &lt;em&gt;window functions&lt;/em&gt; appearing in the query's &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; List&lt;/a&gt; or &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;. These functions can reference the &lt;code&gt;WINDOW&lt;/code&gt; clause entries by name in their &lt;code&gt;OVER&lt;/code&gt; clauses. A &lt;code&gt;WINDOW&lt;/code&gt; clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any &lt;code&gt;WINDOW&lt;/code&gt; clause at all, since a window function call can specify its window definition directly in its &lt;code&gt;OVER&lt;/code&gt; clause. However, the &lt;code&gt;WINDOW&lt;/code&gt; clause saves typing when the same window definition is needed for more than one window function.</source>
          <target state="translated">Цель &lt;code&gt;WINDOW&lt;/code&gt; статьи заключается в определении поведения &lt;em&gt;оконных функций&lt;/em&gt; , возникающих в запросе в &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt; &lt;code&gt;SELECT&lt;/code&gt; список&lt;/a&gt; или &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; пункта&lt;/a&gt; . Эти функции могут ссылаться на записи предложения &lt;code&gt;WINDOW&lt;/code&gt; по имени в своих предложениях &lt;code&gt;OVER&lt;/code&gt; . Однако на запись предложения &lt;code&gt;WINDOW&lt;/code&gt; нигде не нужно ссылаться; если он не используется в запросе, он просто игнорируется. Можно использовать оконные функции вообще без какого-либо предложения &lt;code&gt;WINDOW&lt;/code&gt; , поскольку вызов оконной функции может указывать определение своего окна непосредственно в предложении &lt;code&gt;OVER&lt;/code&gt; . Однако &lt;code&gt;WINDOW&lt;/code&gt; Предложение сохраняет набор текста, когда одно и то же определение окна требуется для более чем одной оконной функции.</target>
        </trans-unit>
        <trans-unit id="b96262653baf1cfb436f7851543f2559b2750e87" translate="yes" xml:space="preserve">
          <source>The purpose of a &lt;code&gt;WINDOW&lt;/code&gt; clause is to specify the behavior of &lt;em&gt;window functions&lt;/em&gt; appearing in the query's &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; list&lt;/a&gt; or &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt;&lt;/a&gt; clause. These functions can reference the &lt;code&gt;WINDOW&lt;/code&gt; clause entries by name in their &lt;code&gt;OVER&lt;/code&gt; clauses. A &lt;code&gt;WINDOW&lt;/code&gt; clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any &lt;code&gt;WINDOW&lt;/code&gt; clause at all, since a window function call can specify its window definition directly in its &lt;code&gt;OVER&lt;/code&gt; clause. However, the &lt;code&gt;WINDOW&lt;/code&gt; clause saves typing when the same window definition is needed for more than one window function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a79e1e6c48912d3a19f2334c5cde8a4adb3de10" translate="yes" xml:space="preserve">
          <source>The purpose of an index, of course, is to support scans for tuples matching an indexable &lt;code&gt;WHERE&lt;/code&gt; condition, often called a &lt;em&gt;qualifier&lt;/em&gt; or &lt;em&gt;scan key&lt;/em&gt;. The semantics of index scanning are described more fully in &lt;a href=&quot;index-scanning&quot;&gt;Section 61.3&lt;/a&gt;, below. An index access method can support &amp;ldquo;plain&amp;rdquo; index scans, &amp;ldquo;bitmap&amp;rdquo; index scans, or both. The scan-related functions that an index access method must or may provide are:</source>
          <target state="translated">Целью индекса, конечно же, является поддержка сканирования кортежей, соответствующих индексируемому условию &lt;code&gt;WHERE&lt;/code&gt; , часто называемому &lt;em&gt;квалификатором&lt;/em&gt; или &lt;em&gt;ключом сканирования&lt;/em&gt; . Семантика сканирования индекса более подробно описана в &lt;a href=&quot;index-scanning&quot;&gt;Разделе 61.3&lt;/a&gt; ниже. Метод доступа к индексу может поддерживать &amp;laquo;обычное&amp;raquo; сканирование индекса, сканирование &amp;laquo;растрового изображения&amp;raquo; или и то, и другое. Функции, связанные со сканированием, которые должен или может предоставить метод доступа к индексу:</target>
        </trans-unit>
        <trans-unit id="71dfcd4f15fca395ab847bf8654ecc1126908484" translate="yes" xml:space="preserve">
          <source>The quantifiers &lt;code&gt;{1,1}&lt;/code&gt; and &lt;code&gt;{1,1}?&lt;/code&gt; can be used to force greediness or non-greediness, respectively, on a subexpression or a whole RE. This is useful when you need the whole RE to have a greediness attribute different from what's deduced from its elements. As an example, suppose that we are trying to separate a string containing some digits into the digits and the parts before and after them. We might try to do that like this:</source>
          <target state="translated">Кванторы &lt;code&gt;{1,1}&lt;/code&gt; и &lt;code&gt;{1,1}?&lt;/code&gt; может использоваться для принудительной жадности или нежадности соответственно для подвыражения или целого RE. Это полезно, когда вам нужно, чтобы у всего RE был атрибут жадности, отличный от того, который выводится из его элементов. В качестве примера предположим, что мы пытаемся разделить строку, содержащую некоторые цифры, на цифры и части до и после них. Мы можем попробовать сделать это так:</target>
        </trans-unit>
        <trans-unit id="343b9e25e0029b4f349abf2c9eb3c709d6c9db46" translate="yes" xml:space="preserve">
          <source>The quarter of the year (1 - 4) that the date is in</source>
          <target state="translated">Четверть года (1-4),в котором дата находится в</target>
        </trans-unit>
        <trans-unit id="4b7ab2f4293b424598bc3b854175b38f8e2117d5" translate="yes" xml:space="preserve">
          <source>The quarter of the year (1&amp;ndash;4) that the date is in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c024cf5d71d6d58e1719ea5b88c2edd0af4738d" translate="yes" xml:space="preserve">
          <source>The queried JSON data contain nested arrays. In this case, only the outermost array is unwrapped, while all the inner arrays remain unchanged. Thus, implicit unwrapping can only go one level down within each path evaluation step.</source>
          <target state="translated">Опрошенные JSON-данные содержат вложенные массивы.В этом случае распаковывается только крайний массив,в то время как все внутренние массивы остаются неизменными.Таким образом,неявная распаковка может пройти только один уровень в пределах каждого шага оценки пути.</target>
        </trans-unit>
        <trans-unit id="9ec83a60a4572c2a39f277feef2e26e14c05d5aa" translate="yes" xml:space="preserve">
          <source>The query above specifies that the &lt;code&gt;english&lt;/code&gt; configuration is to be used to parse and normalize the strings. Alternatively we could omit the configuration parameters:</source>
          <target state="translated">В приведенном выше запросе указано, что для анализа и нормализации строк должна использоваться &lt;code&gt;english&lt;/code&gt; конфигурация. В качестве альтернативы мы могли бы опустить параметры конфигурации:</target>
        </trans-unit>
        <trans-unit id="755893eaea71f45690b0b8daa7c44ccecde3f16e" translate="yes" xml:space="preserve">
          <source>The query is running inside of another query that is already parallel. For example, if a function called by a parallel query issues an SQL query itself, that query will never use a parallel plan. This is a limitation of the current implementation, but it may not be desirable to remove this limitation, since it could result in a single query using a very large number of processes.</source>
          <target state="translated">Запрос выполняется внутри другого,уже параллельного,запроса.Например,если функция,вызываемая параллельным запросом,сама выполняет SQL-запрос,то этот запрос никогда не будет использовать параллельный план.Это ограничение является ограничением текущей реализации,но может быть нецелесообразно его снимать,так как это может привести к одному запросу,использующему очень большое количество процессов.</target>
        </trans-unit>
        <trans-unit id="5a0a949650f6ba760f80fb27f318b51f13c26bd4" translate="yes" xml:space="preserve">
          <source>The query might be suspended during execution. In any situation in which the system thinks that partial or incremental execution might occur, no parallel plan is generated. For example, a cursor created using &lt;a href=&quot;sql-declare&quot;&gt;DECLARE CURSOR&lt;/a&gt; will never use a parallel plan. Similarly, a PL/pgSQL loop of the form &lt;code&gt;FOR x IN query LOOP .. END LOOP&lt;/code&gt; will never use a parallel plan, because the parallel query system is unable to verify that the code in the loop is safe to execute while parallel query is active.</source>
          <target state="translated">Запрос может быть приостановлен во время выполнения. В любой ситуации, когда система считает, что может произойти частичное или инкрементное выполнение, параллельный план не создается. Например, курсор, созданный с помощью &lt;a href=&quot;sql-declare&quot;&gt;DECLARE CURSOR&lt;/a&gt; , никогда не будет использовать параллельный план. Точно так же цикл PL / pgSQL формы &lt;code&gt;FOR x IN query LOOP .. END LOOP&lt;/code&gt; никогда не будет использовать параллельный план, потому что система параллельных запросов не может проверить, безопасно ли выполнение кода в цикле, пока параллельный запрос активен. .</target>
        </trans-unit>
        <trans-unit id="bdfa8875f3090d46606e95d96800e6f18174861f" translate="yes" xml:space="preserve">
          <source>The query must reference only columns stored in the index. For example, given an index on columns &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; of a table that also has a column &lt;code&gt;z&lt;/code&gt;, these queries could use index-only scans:</source>
          <target state="translated">Запрос должен ссылаться только на столбцы, хранящиеся в индексе. Например, учитывая индекс по столбцам &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; таблицы, в которой также есть столбец &lt;code&gt;z&lt;/code&gt; , эти запросы могут использовать сканирование только индекса:</target>
        </trans-unit>
        <trans-unit id="c50468726e4134a52ce71c84ac34c354a3e1b957" translate="yes" xml:space="preserve">
          <source>The query optimizer takes &lt;code&gt;LIMIT&lt;/code&gt; into account when generating query plans, so you are very likely to get different plans (yielding different row orders) depending on what you give for &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt;. Thus, using different &lt;code&gt;LIMIT&lt;/code&gt;/&lt;code&gt;OFFSET&lt;/code&gt; values to select different subsets of a query result &lt;em&gt;will give inconsistent results&lt;/em&gt; unless you enforce a predictable result ordering with &lt;code&gt;ORDER BY&lt;/code&gt;. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless &lt;code&gt;ORDER BY&lt;/code&gt; is used to constrain the order.</source>
          <target state="translated">Оптимизатор запросов принимает во внимание &lt;code&gt;LIMIT&lt;/code&gt; при создании планов запроса, поэтому вы, скорее всего, получите разные планы (дающие разные порядки строк) в зависимости от того, что вы даете для &lt;code&gt;LIMIT&lt;/code&gt; и &lt;code&gt;OFFSET&lt;/code&gt; . Таким образом, использование разных значений &lt;code&gt;LIMIT&lt;/code&gt; / &lt;code&gt;OFFSET&lt;/code&gt; для выбора разных подмножеств результата запроса &lt;em&gt;приведет к противоречивым результатам,&lt;/em&gt; если вы не установите предсказуемый порядок результатов с помощью &lt;code&gt;ORDER BY&lt;/code&gt; . Это не ошибка; это неотъемлемое следствие того факта, что SQL не обещает доставлять результаты запроса в каком-либо конкретном порядке, если только &lt;code&gt;ORDER BY&lt;/code&gt; не используется для ограничения порядка.</target>
        </trans-unit>
        <trans-unit id="9591ec91d27bd94fc1ed0042a9c68fc7e7f8799e" translate="yes" xml:space="preserve">
          <source>The query planner takes &lt;code&gt;LIMIT&lt;/code&gt; into account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use for &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt;. Thus, using different &lt;code&gt;LIMIT&lt;/code&gt;/&lt;code&gt;OFFSET&lt;/code&gt; values to select different subsets of a query result &lt;em&gt;will give inconsistent results&lt;/em&gt; unless you enforce a predictable result ordering with &lt;code&gt;ORDER BY&lt;/code&gt;. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless &lt;code&gt;ORDER BY&lt;/code&gt; is used to constrain the order.</source>
          <target state="translated">Планировщик запросов принимает во внимание &lt;code&gt;LIMIT&lt;/code&gt; при создании плана запроса, поэтому вы, скорее всего, получите разные планы (дающие разные порядки строк) в зависимости от того, что вы используете для &lt;code&gt;LIMIT&lt;/code&gt; и &lt;code&gt;OFFSET&lt;/code&gt; . Таким образом, использование разных значений &lt;code&gt;LIMIT&lt;/code&gt; / &lt;code&gt;OFFSET&lt;/code&gt; для выбора разных подмножеств результата запроса &lt;em&gt;приведет к противоречивым результатам,&lt;/em&gt; если вы не установите предсказуемый порядок результатов с помощью &lt;code&gt;ORDER BY&lt;/code&gt; . Это не ошибка; это неотъемлемое следствие того факта, что SQL не обещает доставлять результаты запроса в каком-либо конкретном порядке, если только &lt;code&gt;ORDER BY&lt;/code&gt; не используется для ограничения порядка.</target>
        </trans-unit>
        <trans-unit id="4af81e08bfabc175af6208808228c3292ec1d219" translate="yes" xml:space="preserve">
          <source>The query rewriter is discussed in some detail in &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;, so there is no need to cover it here. We will only point out that both the input and the output of the rewriter are query trees, that is, there is no change in the representation or level of semantic detail in the trees. Rewriting can be thought of as a form of macro expansion.</source>
          <target state="translated">Переписчик запросов подробно обсуждается в &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;главе 40&lt;/a&gt; , поэтому здесь нет необходимости описывать его. Мы только укажем, что и вход, и выход программы перезаписи являются деревьями запросов, то есть в деревьях нет изменений в представлении или уровне семантической детализации. Переписывание можно рассматривать как форму расширения макросов.</target>
        </trans-unit>
        <trans-unit id="294de92ad34c3155980be69ecc50bda8db23e6c8" translate="yes" xml:space="preserve">
          <source>The query rewriter is discussed in some detail in &lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;Chapter 40&lt;/a&gt;, so there is no need to cover it here. We will only point out that both the input and the output of the rewriter are query trees, that is, there is no change in the representation or level of semantic detail in the trees. Rewriting can be thought of as a form of macro expansion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84cbe05d8623ccd8c2adba905f772e1af6572a6b" translate="yes" xml:space="preserve">
          <source>The query string submitted by the client to create this prepared statement. For prepared statements created via SQL, this is the &lt;code&gt;PREPARE&lt;/code&gt; statement submitted by the client. For prepared statements created via the frontend/backend protocol, this is the text of the prepared statement itself.</source>
          <target state="translated">Строка запроса, отправленная клиентом для создания этого подготовленного оператора. Для подготовленных операторов, созданных с помощью SQL, это оператор &lt;code&gt;PREPARE&lt;/code&gt; , отправленный клиентом. Для подготовленных операторов, созданных с помощью протокола внешнего / внутреннего интерфейса, это текст самого подготовленного оператора.</target>
        </trans-unit>
        <trans-unit id="b1d53885b655d33f7ad2a2d0f4ca8ce4c9afa697" translate="yes" xml:space="preserve">
          <source>The query that is actually sent to the remote server for execution can be examined using &lt;code&gt;EXPLAIN VERBOSE&lt;/code&gt;.</source>
          <target state="translated">Запрос, который фактически отправляется на удаленный сервер для выполнения, можно проверить с помощью &lt;code&gt;EXPLAIN VERBOSE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb7170c364ffc0983c042ed7b707bee01230d841" translate="yes" xml:space="preserve">
          <source>The query tree created by the transformation process is structurally similar to the raw parse tree in most places, but it has many differences in detail. For example, a &lt;code&gt;FuncCall&lt;/code&gt; node in the parse tree represents something that looks syntactically like a function call. This might be transformed to either a &lt;code&gt;FuncExpr&lt;/code&gt; or &lt;code&gt;Aggref&lt;/code&gt; node depending on whether the referenced name turns out to be an ordinary function or an aggregate function. Also, information about the actual data types of columns and expression results is added to the query tree.</source>
          <target state="translated">Дерево запросов, созданное в процессе преобразования, во многих местах структурно похоже на необработанное дерево синтаксического анализа, но имеет много отличий в деталях. Например, узел &lt;code&gt;FuncCall&lt;/code&gt; в дереве синтаксического анализа представляет нечто синтаксически похожее на вызов функции. Это может быть преобразовано в узел &lt;code&gt;FuncExpr&lt;/code&gt; или &lt;code&gt;Aggref&lt;/code&gt; в зависимости от того, является ли указанное имя обычной функцией или агрегатной функцией. Кроме того, в дерево запроса добавляется информация о фактических типах данных столбцов и результатах выражений.</target>
        </trans-unit>
        <trans-unit id="85e8ce3a8f2eab045a32523ebad51fd65a628dc9" translate="yes" xml:space="preserve">
          <source>The query uses any function marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt;. Most system-defined functions are &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, but user-defined functions are marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; by default. See the discussion of &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt;.</source>
          <target state="translated">Запрос использует любую функцию с пометкой &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; . Большинство системных функций являются &lt;code&gt;PARALLEL SAFE&lt;/code&gt; , но пользовательские функции по умолчанию помечены как &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; . См. Обсуждение &lt;a href=&quot;parallel-safety&quot;&gt;Раздела 15.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae584697a944b3092f1bdba0372976965b96c14e" translate="yes" xml:space="preserve">
          <source>The query writes any data or locks any database rows. If a query contains a data-modifying operation either at the top level or within a CTE, no parallel plans for that query will be generated. As an exception, the commands &lt;code&gt;CREATE TABLE ... AS&lt;/code&gt;, &lt;code&gt;SELECT INTO&lt;/code&gt;, and &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; which create a new table and populate it can use a parallel plan.</source>
          <target state="translated">Запрос записывает любые данные или блокирует любые строки базы данных. Если запрос содержит операцию изменения данных либо на верхнем уровне, либо в CTE, параллельные планы для этого запроса не будут созданы. В качестве исключения команды &lt;code&gt;CREATE TABLE ... AS&lt;/code&gt; , &lt;code&gt;SELECT INTO&lt;/code&gt; и &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; , которые создают новую таблицу и заполняют ее, могут использовать параллельный план.</target>
        </trans-unit>
        <trans-unit id="646431d95f05f7752d11dec325de9bca5192ab21" translate="yes" xml:space="preserve">
          <source>The radius of the Earth is obtained from the &lt;code&gt;earth()&lt;/code&gt; function. It is given in meters. But by changing this one function you can change the module to use some other units, or to use a different value of the radius that you feel is more appropriate.</source>
          <target state="translated">Радиус Земли получается из функции &lt;code&gt;earth()&lt;/code&gt; . Он указан в метрах. Но, изменив эту функцию, вы можете изменить модуль, чтобы использовать другие единицы измерения или использовать другое значение радиуса, которое вы считаете более подходящим.</target>
        </trans-unit>
        <trans-unit id="33dd011e0a27c9e4a8da0750e328420ec5636341" translate="yes" xml:space="preserve">
          <source>The range type's &lt;code&gt;subtype&lt;/code&gt; can be any type with an associated b-tree operator class (to determine the ordering of values for the range type). Normally the subtype's default b-tree operator class is used to determine ordering; to use a non-default operator class, specify its name with &lt;code&gt;subtype_opclass&lt;/code&gt;. If the subtype is collatable, and you want to use a non-default collation in the range's ordering, specify the desired collation with the &lt;code&gt;collation&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;subtype&lt;/code&gt; типа диапазона может быть любым типом со связанным классом операторов b-дерева (для определения порядка значений для типа диапазона). Обычно для определения порядка используется класс операторов b-дерева по умолчанию для подтипа; чтобы использовать класс операторов, &lt;code&gt;subtype_opclass&lt;/code&gt; стандартного, укажите его имя с помощью subtype_opclass . Если подтип можно сопоставить, и вы хотите использовать сопоставление не по умолчанию в порядке сортировки диапазона, укажите нужное сопоставление с помощью параметра &lt;code&gt;collation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45e371c3b97fa5eccf6d1070963f8eb35bb332f4" translate="yes" xml:space="preserve">
          <source>The rate is targeted by starting transactions along a Poisson-distributed schedule time line. The expected start time schedule moves forward based on when the client first started, not when the previous transaction ended. That approach means that when transactions go past their original scheduled end time, it is possible for later ones to catch up again.</source>
          <target state="translated">Ставка рассчитывается путем начала транзакций по распределенной по Пуассону временной линии графика.Ожидаемое время начала движения в зависимости от того,когда клиент начал транзакцию впервые,а не от того,когда закончилась предыдущая транзакция.Такой подход означает,что когда транзакции выходят за изначально запланированное время окончания,возможно,что более поздние транзакции снова наверстают упущенное.</target>
        </trans-unit>
        <trans-unit id="f993d6ebc7309b2d31242d61b21f2b56ac8f6a72" translate="yes" xml:space="preserve">
          <source>The reason for separating raw parsing from semantic analysis is that system catalog lookups can only be done within a transaction, and we do not wish to start a transaction immediately upon receiving a query string. The raw parsing stage is sufficient to identify the transaction control commands (&lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;ROLLBACK&lt;/code&gt;, etc), and these can then be correctly executed without any further analysis. Once we know that we are dealing with an actual query (such as &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;), it is okay to start a transaction if we're not already in one. Only then can the transformation process be invoked.</source>
          <target state="translated">Причина отделения необработанного синтаксического анализа от семантического анализа заключается в том, что поиск в системном каталоге может выполняться только внутри транзакции, и мы не хотим начинать транзакцию сразу после получения строки запроса. Стадии необработанного синтаксического анализа достаточно для идентификации команд управления транзакцией ( &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;ROLLBACK&lt;/code&gt; и т. Д.), И затем они могут быть правильно выполнены без какого-либо дальнейшего анализа. Как только мы узнаем, что имеем дело с фактическим запросом (таким как &lt;code&gt;SELECT&lt;/code&gt; или &lt;code&gt;UPDATE&lt;/code&gt; ), можно начать транзакцию, если мы еще не в ней. Только тогда может быть запущен процесс преобразования.</target>
        </trans-unit>
        <trans-unit id="2555cbea73ebf259be548a413cb3f00d947e85ce" translate="yes" xml:space="preserve">
          <source>The reason that periodic vacuuming solves the problem is that &lt;code&gt;VACUUM&lt;/code&gt; will mark rows as &lt;em&gt;frozen&lt;/em&gt;, indicating that they were inserted by a transaction that committed sufficiently far in the past that the effects of the inserting transaction are certain to be visible to all current and future transactions. Normal XIDs are compared using modulo-2&lt;sup&gt;32&lt;/sup&gt; arithmetic. This means that for every normal XID, there are two billion XIDs that are &amp;ldquo;older&amp;rdquo; and two billion that are &amp;ldquo;newer&amp;rdquo;; another way to say it is that the normal XID space is circular with no endpoint. Therefore, once a row version has been created with a particular normal XID, the row version will appear to be &amp;ldquo;in the past&amp;rdquo; for the next two billion transactions, no matter which normal XID we are talking about. If the row version still exists after more than two billion transactions, it will suddenly appear to be in the future. To prevent this, PostgreSQL reserves a special XID, &lt;code&gt;FrozenTransactionId&lt;/code&gt;, which does not follow the normal XID comparison rules and is always considered older than every normal XID. Frozen row versions are treated as if the inserting XID were &lt;code&gt;FrozenTransactionId&lt;/code&gt;, so that they will appear to be &amp;ldquo;in the past&amp;rdquo; to all normal transactions regardless of wraparound issues, and so such row versions will be valid until deleted, no matter how long that is.</source>
          <target state="translated">Причина, по которой периодическая очистка решает проблему, заключается в том, что &lt;code&gt;VACUUM&lt;/code&gt; помечает строки как &lt;em&gt;замороженные&lt;/em&gt; , указывая на то, что они были вставлены транзакцией, которая была зафиксирована достаточно далеко в прошлом, поэтому эффекты вставки транзакции наверняка будут видны для всех текущих и будущих транзакций. . Нормальные XID сравниваются по модулю 2 &lt;sup&gt;32&lt;/sup&gt;арифметика. Это означает, что на каждый нормальный XID приходится два миллиарда XID, которые &amp;laquo;старше&amp;raquo;, и два миллиарда, которые &amp;laquo;новее&amp;raquo;; другой способ сказать, что нормальное пространство XID является круговым без конечной точки. Следовательно, как только версия строки была создана с определенным нормальным XID, эта версия строки будет казаться &amp;laquo;в прошлом&amp;raquo; для следующих двух миллиардов транзакций, независимо от того, о каком нормальном XID мы говорим. Если версия строки все еще существует после более чем двух миллиардов транзакций, она внезапно появится в будущем. Чтобы предотвратить это, PostgreSQL резервирует специальный XID &lt;code&gt;FrozenTransactionId&lt;/code&gt; , который не соответствует обычным правилам сравнения XID и всегда считается более старым, чем любой обычный XID. Замороженные версии строк обрабатываются так, как если бы вставляемый XID был &lt;code&gt;FrozenTransactionId&lt;/code&gt; , так что они будут казаться &amp;laquo;в прошлом&amp;raquo; для всех обычных транзакций независимо от проблем с циклическим переносом, и поэтому такие версии строк будут действительны до удаления, независимо от того, сколько времени это будет.</target>
        </trans-unit>
        <trans-unit id="3e52350494447bb6f36961ad4e797bd18a9eb61e" translate="yes" xml:space="preserve">
          <source>The reason that single quotes must be doubled, as shown in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt;, is that this is true for any string literal in a SQL command. The generic string-literal parser consumes the outermost single quotes and reduces any pair of single quotes to one data character. What the &lt;code&gt;bytea&lt;/code&gt; input function sees is just one single quote, which it treats as a plain data character. However, the &lt;code&gt;bytea&lt;/code&gt; input function treats backslashes as special, and the other behaviors shown in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt; are implemented by that function.</source>
          <target state="translated">Причина, по которой одинарные кавычки должны быть удвоены, как показано в &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Таблице 8.7&lt;/a&gt; , состоит в том, что это верно для любого строкового литерала в команде SQL. Общий синтаксический анализатор строкового литерала использует самые внешние одинарные кавычки и сокращает любую пару одинарных кавычек до одного символа данных. Что &lt;code&gt;bytea&lt;/code&gt; функция входа видит только один апостроф, который он рассматривает как обычный символ данных. Однако &lt;code&gt;bytea&lt;/code&gt; ввода bytea обрабатывает обратную косую черту как особую, и другие варианты поведения, показанные в &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;таблице 8.7&lt;/a&gt; , реализуются этой функцией.</target>
        </trans-unit>
        <trans-unit id="035f0c664448dfa923a884566e84523654a5a8a5" translate="yes" xml:space="preserve">
          <source>The recommended method for configuring shared memory in macOS is to create a file named &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, containing variable assignments such as:</source>
          <target state="translated">Рекомендуемый метод настройки общей памяти в macOS - создать файл с именем &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; , содержащий назначения переменных, такие как:</target>
        </trans-unit>
        <trans-unit id="b6faaba60ea4ceaac002ffa0497dd503d8d8e004" translate="yes" xml:space="preserve">
          <source>The recommended recovery method in such cases is to drop the index and try again to perform &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;. (Another possibility is to rebuild the index with &lt;code&gt;REINDEX INDEX CONCURRENTLY&lt;/code&gt;).</source>
          <target state="translated">Рекомендуемый метод восстановления в таких случаях - отбросить индекс и снова попытаться выполнить &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; . (Другая возможность - перестроить индекс с &lt;code&gt;REINDEX INDEX CONCURRENTLY&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="65854068ac8d3288768569a456ffe6db4148ee2b" translate="yes" xml:space="preserve">
          <source>The recommended recovery method in such cases is to drop the invalid index and try again to perform &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;. The concurrent index created during the processing has a name ending in the suffix &lt;code&gt;ccnew&lt;/code&gt;, or &lt;code&gt;ccold&lt;/code&gt; if it is an old index definition which we failed to drop. Invalid indexes can be dropped using &lt;code&gt;DROP INDEX&lt;/code&gt;, including invalid toast indexes.</source>
          <target state="translated">Рекомендуемый метод восстановления в таких случаях - удалить недопустимый индекс и снова попытаться выполнить &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; . У параллельного индекса, созданного во время обработки, есть имя, оканчивающееся на суффикс &lt;code&gt;ccnew&lt;/code&gt; или &lt;code&gt;ccold&lt;/code&gt; , если это старое определение индекса, которое нам не удалось удалить. Недействительные индексы можно удалить с помощью &lt;code&gt;DROP INDEX&lt;/code&gt; , включая недопустимые всплывающие индексы.</target>
        </trans-unit>
        <trans-unit id="dfc0dfd0875395d5ad4e9971dc3ba071b3c62b6b" translate="yes" xml:space="preserve">
          <source>The recommended syntax for referencing an ordered-set aggregate is to write &lt;code&gt;ORDER BY&lt;/code&gt; between the direct and aggregated argument specifications, in the same style as in &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;. However, it will also work to omit &lt;code&gt;ORDER BY&lt;/code&gt; and just run the direct and aggregated argument specifications into a single list. In this abbreviated form, if &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; was used in both the direct and aggregated argument lists, write &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; only once.</source>
          <target state="translated">Рекомендуемый синтаксис для ссылки на агрегат с упорядоченным набором - это запись &lt;code&gt;ORDER BY&lt;/code&gt; между прямыми и агрегированными спецификациями аргументов в том же стиле, что и в &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; . Однако можно также опустить &lt;code&gt;ORDER BY&lt;/code&gt; и просто выполнить прямые и агрегированные спецификации аргументов в один список. В этой сокращенной форме, если &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; использовался как в прямом, так и в агрегированном списках аргументов, пишите &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; только один раз.</target>
        </trans-unit>
        <trans-unit id="2c54b57bbcf06dd2c13692d0332c35778b6cad50" translate="yes" xml:space="preserve">
          <source>The recursive query evaluation algorithm produces its output in breadth-first search order. You can display the results in depth-first search order by making the outer query &lt;code&gt;ORDER BY&lt;/code&gt; a &amp;ldquo;path&amp;rdquo; column constructed in this way.</source>
          <target state="translated">Алгоритм оценки рекурсивного запроса выдает результат в порядке поиска в ширину. Вы можете отобразить результаты в порядке поиска в глубину, сделав внешний запрос &lt;code&gt;ORDER BY&lt;/code&gt; столбцом &amp;laquo;путь&amp;raquo;, построенным таким образом.</target>
        </trans-unit>
        <trans-unit id="10c71ff4aa80650437aaee9d5a8e7f1f079dae18" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is mentioned as the target of a dependent policy object.</source>
          <target state="translated">Объект,на который делается ссылка (а это должна быть роль),упоминается как цель объекта зависимой политики.</target>
        </trans-unit>
        <trans-unit id="c023a7885506a46d5cd80a1b95eea9a1b30194d8" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is mentioned in the ACL (access control list, i.e., privileges list) of the dependent object. (A &lt;code&gt;SHARED_DEPENDENCY_ACL&lt;/code&gt; entry is not made for the owner of the object, since the owner will have a &lt;code&gt;SHARED_DEPENDENCY_OWNER&lt;/code&gt; entry anyway.)</source>
          <target state="translated">Указанный объект (который должен быть ролью) упоминается в ACL (списке управления доступом, т. Е. Списке привилегий) зависимого объекта. (Запись &lt;code&gt;SHARED_DEPENDENCY_ACL&lt;/code&gt; не создается для владельца объекта, поскольку у владельца в любом случае будет запись &lt;code&gt;SHARED_DEPENDENCY_OWNER&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="b0815ccf510952893128b6ac3763e885ed6f0544" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is the owner of the dependent object.</source>
          <target state="translated">Объект,на который делается ссылка (а это должна быть роль),является владельцем зависимого объекта.</target>
        </trans-unit>
        <trans-unit id="a3a42d2bcdc41726ac7929beb724897943cebede" translate="yes" xml:space="preserve">
          <source>The regular expression flag letters defined by XQuery are related to but not the same as the option letters for POSIX (&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;). While the &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; options behave the same, others do not:</source>
          <target state="translated">Буквы флагов регулярного выражения, определенные XQuery, связаны с буквами параметров для POSIX, но не идентичны им ( &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Таблица 9.23&lt;/a&gt; ). В то время как параметры &lt;code&gt;i&lt;/code&gt; и &lt;code&gt;q&lt;/code&gt; ведут себя одинаково, другие нет:</target>
        </trans-unit>
        <trans-unit id="ae81b35c4a3c7dab3568d7bb9b480ebd9e7e6d71" translate="yes" xml:space="preserve">
          <source>The regular expression flag letters defined by XQuery are related to but not the same as the option letters for POSIX (&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24&lt;/a&gt;). While the &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; options behave the same, others do not:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba9e7d00d7dfab39d193126f7366a926fa396e54" translate="yes" xml:space="preserve">
          <source>The relevant files have to be installed into &lt;code&gt;$pkglibdir/bitcode/$extension/&lt;/code&gt; and a summary of them into &lt;code&gt;$pkglibdir/bitcode/$extension.index.bc&lt;/code&gt;, where &lt;code&gt;$pkglibdir&lt;/code&gt; is the directory returned by &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; and &lt;code&gt;$extension&lt;/code&gt; is the base name of the extension's shared library.</source>
          <target state="translated">Соответствующие файлы должны быть установлены в &lt;code&gt;$pkglibdir/bitcode/$extension/&lt;/code&gt; а их сводка - в &lt;code&gt;$pkglibdir/bitcode/$extension.index.bc&lt;/code&gt; , где &lt;code&gt;$pkglibdir&lt;/code&gt; - это каталог, возвращаемый &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; , а &lt;code&gt;$extension&lt;/code&gt; - базовое имя разделяемой библиотеки расширения.</target>
        </trans-unit>
        <trans-unit id="6ba726b7abb409f8a48dfda787ffd9ea8e7624bd" translate="yes" xml:space="preserve">
          <source>The relevant settings can be changed in &lt;code&gt;/etc/system&lt;/code&gt;, for example:</source>
          <target state="translated">Соответствующие настройки можно изменить в &lt;code&gt;/etc/system&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="7fd56dd803d0f7d0e1d83485ba93a1ea518a48b4" translate="yes" xml:space="preserve">
          <source>The remaining defaults are quite generously sized, and usually do not require changes.</source>
          <target state="translated">Остальные дефолты довольно великодушны и,как правило,не требуют изменений.</target>
        </trans-unit>
        <trans-unit id="e214a53b19603c5bd3de31f71ebb545b28127eb2" translate="yes" xml:space="preserve">
          <source>The remaining five input formats are not part of any standard.</source>
          <target state="translated">Остальные пять форматов ввода не являются частью какого-либо стандарта.</target>
        </trans-unit>
        <trans-unit id="a23206cc28b1e52f80477ca74330c7ee7d48a063" translate="yes" xml:space="preserve">
          <source>The remaining forms change the session default for a run-time configuration variable for a PostgreSQL database. Whenever a new session is subsequently started in that database, the specified value becomes the session default value. The database-specific default overrides whatever setting is present in &lt;code&gt;postgresql.conf&lt;/code&gt; or has been received from the &lt;code&gt;postgres&lt;/code&gt; command line. Only the database owner or a superuser can change the session defaults for a database. Certain variables cannot be set this way, or can only be set by a superuser.</source>
          <target state="translated">Остальные формы изменяют значение сеанса по умолчанию для переменной конфигурации времени выполнения для базы данных PostgreSQL. Каждый раз, когда впоследствии в этой базе данных запускается новый сеанс, указанное значение становится значением сеанса по умолчанию. Значение по умолчанию для конкретной базы данных переопределяет любой параметр, присутствующий в &lt;code&gt;postgresql.conf&lt;/code&gt; или полученный из командной строки &lt;code&gt;postgres&lt;/code&gt; . Только владелец базы данных или суперпользователь может изменять параметры сеанса по умолчанию для базы данных. Некоторые переменные не могут быть установлены таким образом или могут быть установлены только суперпользователем.</target>
        </trans-unit>
        <trans-unit id="657f4dc87f97eb4fa07203598556b9c37fdd908d" translate="yes" xml:space="preserve">
          <source>The remaining locale categories can be changed later when the server is started. You can also use &lt;code&gt;--locale&lt;/code&gt; to set the default for all locale categories, including collation order and character set classes. All server locale values (&lt;code&gt;lc_*&lt;/code&gt;) can be displayed via &lt;code&gt;SHOW ALL&lt;/code&gt;. More details can be found in &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt;.</source>
          <target state="translated">Остальные категории языковых стандартов можно изменить позже, когда сервер будет запущен. Вы также можете использовать &lt;code&gt;--locale&lt;/code&gt; , чтобы установить значение по умолчанию для всех категорий языковых стандартов, включая порядок сортировки и классы набора символов. Все значения локали сервера ( &lt;code&gt;lc_*&lt;/code&gt; ) можно отобразить с помощью &lt;code&gt;SHOW ALL&lt;/code&gt; . Более подробную информацию можно найти в &lt;a href=&quot;locale&quot;&gt;Разделе 23.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="39583e46f87084afedd4c54635cee3575eddc6c6" translate="yes" xml:space="preserve">
          <source>The remaining variants change a role's session default for a configuration variable, either for all databases or, when the &lt;code&gt;IN DATABASE&lt;/code&gt; clause is specified, only for sessions in the named database. If &lt;code&gt;ALL&lt;/code&gt; is specified instead of a role name, this changes the setting for all roles. Using &lt;code&gt;ALL&lt;/code&gt; with &lt;code&gt;IN DATABASE&lt;/code&gt; is effectively the same as using the command &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt;.</source>
          <target state="translated">Остальные варианты изменяют значение сеанса роли по умолчанию для переменной конфигурации либо для всех баз данных, либо, если указано предложение &lt;code&gt;IN DATABASE&lt;/code&gt; , только для сеансов в указанной базе данных. Если вместо имени роли указано &lt;code&gt;ALL&lt;/code&gt; , это изменяет настройку для всех ролей. Использование &lt;code&gt;ALL&lt;/code&gt; с &lt;code&gt;IN DATABASE&lt;/code&gt; фактически то же самое , как с помощью команды &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5290f23dd3a823420c1c9cce7d4e8058bd8eb3fa" translate="yes" xml:space="preserve">
          <source>The remaining variants change the owner and the name of the publication.</source>
          <target state="translated">Остальные варианты изменяют владельца и название публикации.</target>
        </trans-unit>
        <trans-unit id="fd818ebf2b83e4b29f88c818dcaf7941b628e1ea" translate="yes" xml:space="preserve">
          <source>The remote schema to import from. The specific meaning of a remote schema depends on the foreign data wrapper in use.</source>
          <target state="translated">Удаленная схема для импорта.Конкретное значение удаленной схемы зависит от используемой зарубежной обертки данных.</target>
        </trans-unit>
        <trans-unit id="c2f6cfebe2ad1dd2cbdde5a3b92b04d140d615ff" translate="yes" xml:space="preserve">
          <source>The remote transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level when the local transaction has &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level; otherwise it uses &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level. This choice ensures that if a query performs multiple table scans on the remote server, it will get snapshot-consistent results for all the scans. A consequence is that successive queries within a single transaction will see the same data from the remote server, even if concurrent updates are occurring on the remote server due to other activities. That behavior would be expected anyway if the local transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; or &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level, but it might be surprising for a &lt;code&gt;READ COMMITTED&lt;/code&gt; local transaction. A future PostgreSQL release might modify these rules.</source>
          <target state="translated">Удаленная транзакция использует &lt;code&gt;SERIALIZABLE&lt;/code&gt; изоляции SERIALIZABLE, когда локальная транзакция имеет &lt;code&gt;SERIALIZABLE&lt;/code&gt; изоляции SERIALIZABLE ; в противном случае используется &lt;code&gt;REPEATABLE READ&lt;/code&gt; изоляции REPEATABLE READ . Этот выбор гарантирует, что если запрос выполняет несколько сканирований таблиц на удаленном сервере, он будет получать согласованные с моментальными снимками результаты для всех сканирований. Следствием этого является то, что последовательные запросы в рамках одной транзакции будут видеть одни и те же данные с удаленного сервера, даже если одновременные обновления происходят на удаленном сервере из-за других действий. Такое поведение в любом случае можно было бы ожидать, если локальная транзакция использует &lt;code&gt;REPEATABLE READ&lt;/code&gt; изоляции &lt;code&gt;SERIALIZABLE&lt;/code&gt; или REPEATABLE READ , но это может быть неожиданным для &lt;code&gt;READ COMMITTED&lt;/code&gt; местная сделка. В будущем выпуске PostgreSQL эти правила могут быть изменены.</target>
        </trans-unit>
        <trans-unit id="b784ef85aba666ab41976b71fec7b8c205701bef" translate="yes" xml:space="preserve">
          <source>The reported &lt;code&gt;index_size&lt;/code&gt; will normally correspond to one more page than is accounted for by &lt;code&gt;internal_pages + leaf_pages + empty_pages + deleted_pages&lt;/code&gt;, because it also includes the index's metapage.</source>
          <target state="translated">Сообщаемый &lt;code&gt;index_size&lt;/code&gt; обычно соответствует на одну страницу больше, чем учитывается с помощью &lt;code&gt;internal_pages + leaf_pages + empty_pages + deleted_pages&lt;/code&gt; , потому что он также включает мета-страницу индекса.</target>
        </trans-unit>
        <trans-unit id="55f0c215e7b27076f4a6dfbf779db270819931cc" translate="yes" xml:space="preserve">
          <source>The reported lag times are not predictions of how long it will take for the standby to catch up with the sending server assuming the current rate of replay. Such a system would show similar times while new WAL is being generated, but would differ when the sender becomes idle. In particular, when the standby has caught up completely, &lt;code&gt;pg_stat_replication&lt;/code&gt; shows the time taken to write, flush and replay the most recent reported WAL location rather than zero as some users might expect. This is consistent with the goal of measuring synchronous commit and transaction visibility delays for recent write transactions. To reduce confusion for users expecting a different model of lag, the lag columns revert to NULL after a short time on a fully replayed idle system. Monitoring systems should choose whether to represent this as missing data, zero or continue to display the last known value.</source>
          <target state="translated">Сообщаемое время задержки не является предсказанием того, сколько времени потребуется резервному серверу, чтобы догнать отправляющий сервер, исходя из текущей скорости воспроизведения. Такая система будет показывать аналогичное время при создании нового WAL, но будет отличаться, когда отправитель будет бездействовать. В частности, когда резервный &lt;code&gt;pg_stat_replication&lt;/code&gt; полностью загружен , pg_stat_replicationпоказывает время, затраченное на запись, очистку и воспроизведение самого последнего сообщенного местоположения WAL, а не ноль, как могли ожидать некоторые пользователи. Это соответствует цели измерения задержек синхронной фиксации и видимости транзакций для недавних транзакций записи. Чтобы уменьшить путаницу для пользователей, ожидающих другой модели задержки, столбцы задержки через короткое время вернутся к NULL в полностью воспроизведенной системе ожидания. Системы мониторинга должны выбрать, отображать ли это как отсутствующие данные, ноль или продолжать отображать последнее известное значение.</target>
        </trans-unit>
        <trans-unit id="a645551df2ec2063cbaae776527e78ce19d49632" translate="yes" xml:space="preserve">
          <source>The representative query texts are kept in an external disk file, and do not consume shared memory. Therefore, even very lengthy query texts can be stored successfully. However, if many long query texts are accumulated, the external file might grow unmanageably large. As a recovery method if that happens, &lt;code&gt;pg_stat_statements&lt;/code&gt; may choose to discard the query texts, whereupon all existing entries in the &lt;code&gt;pg_stat_statements&lt;/code&gt; view will show null &lt;code&gt;query&lt;/code&gt; fields, though the statistics associated with each &lt;code&gt;queryid&lt;/code&gt; are preserved. If this happens, consider reducing &lt;code&gt;pg_stat_statements.max&lt;/code&gt; to prevent recurrences.</source>
          <target state="translated">Типичные тексты запросов хранятся во внешнем файле на диске и не занимают общую память. Таким образом, можно успешно сохранить даже очень длинные тексты запросов. Однако, если накапливается много длинных текстов запросов, внешний файл может стать неуправляемо большим. В качестве метода восстановления, если это произойдет, &lt;code&gt;pg_stat_statements&lt;/code&gt; может отказаться от текстов запроса, после чего все существующие записи в представлении &lt;code&gt;pg_stat_statements&lt;/code&gt; будут отображать пустые поля &lt;code&gt;query&lt;/code&gt; , хотя статистика, связанная с каждым &lt;code&gt;queryid&lt;/code&gt; , сохраняется. Если это произойдет, &lt;code&gt;pg_stat_statements.max&lt;/code&gt; уменьшить pg_stat_statements.max, чтобы предотвратить повторение.</target>
        </trans-unit>
        <trans-unit id="af46176f2702f864ba766599fbfd240339b13483" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;COLUMNS&lt;/code&gt; clause specifies the column(s) that will be produced in the output table. See the syntax summary above for the format. A name is required for each column, as is a data type (unless &lt;code&gt;FOR ORDINALITY&lt;/code&gt; is specified, in which case type &lt;code&gt;integer&lt;/code&gt; is implicit). The path, default and nullability clauses are optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8d7c0fc3cb406e8f13266456fbfe6097e7dd7f" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;row_expression&lt;/code&gt; argument is an XPath 1.0 expression (given as &lt;code&gt;text&lt;/code&gt;) that is evaluated, passing the XML value &lt;code&gt;document_expression&lt;/code&gt; as its context item, to obtain a set of XML nodes. These nodes are what &lt;code&gt;xmltable&lt;/code&gt; transforms into output rows. No rows will be produced if the &lt;code&gt;document_expression&lt;/code&gt; is null, nor if the &lt;code&gt;row_expression&lt;/code&gt; produces an empty node-set or any value other than a node-set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec95cfaa7fde5c159e36da65695933b4d1251cc" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;row_expression&lt;/code&gt; argument is an XPath 1.0 expression that is evaluated, passing the &lt;code&gt;document_expression&lt;/code&gt; as its context item, to obtain a set of XML nodes. These nodes are what &lt;code&gt;xmltable&lt;/code&gt; transforms into output rows. No rows will be produced if the &lt;code&gt;document_expression&lt;/code&gt; is null, nor if the &lt;code&gt;row_expression&lt;/code&gt; produces an empty node-set or any value other than a node-set.</source>
          <target state="translated">Требуется &lt;code&gt;row_expression&lt;/code&gt; аргумент является выражением XPath 1.0 , который оценивается, передавая &lt;code&gt;document_expression&lt;/code&gt; в качестве контекста пункта, чтобы получить набор узлов XML. Эти узлы - это то, что &lt;code&gt;xmltable&lt;/code&gt; преобразует в выходные строки. Никакие строки не будут созданы, если &lt;code&gt;document_expression&lt;/code&gt; имеет значение null, а также если &lt;code&gt;row_expression&lt;/code&gt; создает пустой набор узлов или любое значение, кроме набора узлов.</target>
        </trans-unit>
        <trans-unit id="b11399ca691e0ca5b399e8672e2715124cece495" translate="yes" xml:space="preserve">
          <source>The requirement to escape &lt;em&gt;non-printable&lt;/em&gt; octets varies depending on locale settings. In some instances you can get away with leaving them unescaped.</source>
          <target state="translated">Требование экранировать &lt;em&gt;непечатаемые&lt;/em&gt; октеты зависит от настроек локали. В некоторых случаях вам может сойти с рук, оставив их без защиты.</target>
        </trans-unit>
        <trans-unit id="b1fdcf794bda35b8905b9d7b4d4c5b307eaf0f21" translate="yes" xml:space="preserve">
          <source>The resolution can be done either by changing data on the subscriber so that it does not conflict with the incoming change or by skipping the transaction that conflicts with the existing data. The transaction can be skipped by calling the &lt;a href=&quot;functions-admin#PG-REPLICATION-ORIGIN-ADVANCE&quot;&gt;&lt;code&gt;pg_replication_origin_advance()&lt;/code&gt;&lt;/a&gt; function with a &lt;em&gt;&lt;code&gt;node_name&lt;/code&gt;&lt;/em&gt; corresponding to the subscription name, and a position. The current position of origins can be seen in the &lt;a href=&quot;view-pg-replication-origin-status&quot;&gt;&lt;code&gt;pg_replication_origin_status&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">Решение может быть выполнено либо путем изменения данных на подписчике, чтобы они не конфликтовали с входящими изменениями, либо путем пропуска транзакции, которая конфликтует с существующими данными. Транзакцию можно пропустить, вызвав &lt;a href=&quot;functions-admin#PG-REPLICATION-ORIGIN-ADVANCE&quot;&gt; &lt;code&gt;pg_replication_origin_advance()&lt;/code&gt; &lt;/a&gt; с &lt;em&gt; &lt;code&gt;node_name&lt;/code&gt; &lt;/em&gt; соответствующим имени подписки, и положением. Текущее положение источников можно увидеть в системном представлении &lt;a href=&quot;view-pg-replication-origin-status&quot;&gt; &lt;code&gt;pg_replication_origin_status&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="723a98a8202cef2494a119e8677686ce411c0bb4" translate="yes" xml:space="preserve">
          <source>The response indicates that the large object received object ID 152801, which can be used to access the newly-created large object in the future. For the sake of readability, it is recommended to always associate a human-readable comment with every object. Both OIDs and comments can be viewed with the &lt;code&gt;\lo_list&lt;/code&gt; command.</source>
          <target state="translated">Ответ указывает, что большой объект получил идентификатор объекта 152801, который можно использовать для доступа к вновь созданному большому объекту в будущем. Для удобства чтения рекомендуется всегда связывать удобочитаемый комментарий с каждым объектом. И OID, и комментарии можно просмотреть с помощью команды &lt;code&gt;\lo_list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2934d0e903001f7986e041f38eab1c8c1f288032" translate="yes" xml:space="preserve">
          <source>The restriction for the join is &lt;code&gt;t2.unique2 = t1.unique2&lt;/code&gt;. The operator is just our familiar &lt;code&gt;=&lt;/code&gt;, however the selectivity function is obtained from the &lt;code&gt;oprjoin&lt;/code&gt; column of &lt;code&gt;pg_operator&lt;/code&gt;, and is &lt;code&gt;eqjoinsel&lt;/code&gt;. &lt;code&gt;eqjoinsel&lt;/code&gt; looks up the statistical information for both &lt;code&gt;tenk2&lt;/code&gt; and &lt;code&gt;tenk1&lt;/code&gt;:</source>
          <target state="translated">Ограничение для объединения: &lt;code&gt;t2.unique2 = t1.unique2&lt;/code&gt; . Оператор просто наши знакомые &lt;code&gt;=&lt;/code&gt; , однако функция селективности , полученные из &lt;code&gt;oprjoin&lt;/code&gt; колонке &lt;code&gt;pg_operator&lt;/code&gt; , и является &lt;code&gt;eqjoinsel&lt;/code&gt; . &lt;code&gt;eqjoinsel&lt;/code&gt; ищет статистическую информацию как для &lt;code&gt;tenk2&lt;/code&gt; ,так и для &lt;code&gt;tenk1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="42ea840e6963b1db2f144f830a72190a8a92d8a7" translate="yes" xml:space="preserve">
          <source>The restriction on &lt;code&gt;tenk1&lt;/code&gt;, &lt;code&gt;unique1 &amp;lt; 50&lt;/code&gt;, is evaluated before the nested-loop join. This is handled analogously to the previous range example. This time the value 50 falls into the first bucket of the &lt;code&gt;unique1&lt;/code&gt; histogram:</source>
          <target state="translated">Ограничение на &lt;code&gt;tenk1&lt;/code&gt; , &lt;code&gt;unique1 &amp;lt; 50&lt;/code&gt; , оценивается перед соединением с вложенным циклом. Это обрабатывается аналогично предыдущему примеру диапазона. На этот раз значение 50 попадает в первую &lt;code&gt;unique1&lt;/code&gt; гистограммы unique1 :</target>
        </trans-unit>
        <trans-unit id="80154a0c17a7ca3699a207d67e1600353cb2e59b" translate="yes" xml:space="preserve">
          <source>The restriction selectivity estimator function for this operator.</source>
          <target state="translated">Функция оценки селективности ограничения для данного оператора.</target>
        </trans-unit>
        <trans-unit id="c1e9d6876e675991a0158e89b5c587ee7ffe971a" translate="yes" xml:space="preserve">
          <source>The restriction selectivity estimator function for this operator; write NONE to remove existing selectivity estimator.</source>
          <target state="translated">Функция оценки селективности ограничения для данного оператора;запишите NONE,чтобы удалить существующую функцию оценки селективности.</target>
        </trans-unit>
        <trans-unit id="bff27a668430c02df3bea2ab6b32530d85a3310d" translate="yes" xml:space="preserve">
          <source>The result has the same type as the first argument &amp;mdash; but there is a subtlety. What is actually returned is the first argument of the implied &lt;code&gt;=&lt;/code&gt; operator, and in some cases that will have been promoted to match the second argument's type. For example, &lt;code&gt;NULLIF(1, 2.2)&lt;/code&gt; yields &lt;code&gt;numeric&lt;/code&gt;, because there is no &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator, only &lt;code&gt;numeric&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e176f734fe6408fc6b88696f88ea896277748c08" translate="yes" xml:space="preserve">
          <source>The result is equivalent to replacing the target data directory with the source one. Only changed blocks from relation files are copied; all other files are copied in full, including configuration files. The advantage of pg_rewind over taking a new base backup, or tools like rsync, is that pg_rewind does not require reading through unchanged blocks in the cluster. This makes it a lot faster when the database is large and only a small fraction of blocks differ between the clusters.</source>
          <target state="translated">Результат эквивалентен замене целевого каталога данных на исходный.Из файлов связи копируются только измененные блоки;все остальные файлы копируются полностью,включая конфигурационные файлы.Преимущество pg_rewind перед принятием новой базовой резервной копии или таких инструментов,как rsync,заключается в том,что pg_rewind не требует чтения неизмененных блоков в кластере.Это делает его намного быстрее,когда база данных большая и только небольшая часть блоков различается между кластерами.</target>
        </trans-unit>
        <trans-unit id="71c257a34cf97f05e33ccd5803182c14ff7c7772" translate="yes" xml:space="preserve">
          <source>The result looks like &lt;code&gt;/CN=Somebody /C=Some country/O=Some organization&lt;/code&gt;.</source>
          <target state="translated">Результат выглядит так: &lt;code&gt;/CN=Somebody /C=Some country/O=Some organization&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="465e9b5b70493d1bded19fc1f9a4a0487651fc46" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;EXCEPT&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. With &lt;code&gt;ALL&lt;/code&gt;, a row that has &lt;code&gt;m&lt;/code&gt; duplicates in the left table and &lt;code&gt;n&lt;/code&gt; duplicates in the right table will appear max(&lt;code&gt;m&lt;/code&gt;-&lt;code&gt;n&lt;/code&gt;,0) times in the result set. &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="translated">Результат &lt;code&gt;EXCEPT&lt;/code&gt; не содержит повторяющихся строк, если не указана опция &lt;code&gt;ALL&lt;/code&gt; . При использовании &lt;code&gt;ALL&lt;/code&gt; строка, имеющая &lt;code&gt;m&lt;/code&gt; дубликатов в левой таблице и &lt;code&gt;n&lt;/code&gt; дубликатов в правой таблице, будет отображаться в результирующем наборе не более ( &lt;code&gt;m&lt;/code&gt; - &lt;code&gt;n&lt;/code&gt; , 0) раз. Можно написать &lt;code&gt;DISTINCT&lt;/code&gt; , чтобы явно указать поведение по умолчанию для удаления повторяющихся строк.</target>
        </trans-unit>
        <trans-unit id="8e065829e339ca2263a957857644dcd1c568a754" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;INTERSECT&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. With &lt;code&gt;ALL&lt;/code&gt;, a row that has &lt;code&gt;m&lt;/code&gt; duplicates in the left table and &lt;code&gt;n&lt;/code&gt; duplicates in the right table will appear min(&lt;code&gt;m&lt;/code&gt;,&lt;code&gt;n&lt;/code&gt;) times in the result set. &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="translated">Результат &lt;code&gt;INTERSECT&lt;/code&gt; не содержит повторяющихся строк, если не указан параметр &lt;code&gt;ALL&lt;/code&gt; . При использовании &lt;code&gt;ALL&lt;/code&gt; строка, имеющая &lt;code&gt;m&lt;/code&gt; дубликатов в левой таблице и &lt;code&gt;n&lt;/code&gt; дубликатов в правой таблице, появится в наборе результатов минимум ( &lt;code&gt;m&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; ) раз. Можно написать &lt;code&gt;DISTINCT&lt;/code&gt; , чтобы явно указать поведение по умолчанию для удаления повторяющихся строк.</target>
        </trans-unit>
        <trans-unit id="2ef35ef4ee4e7ace61e6bdb22721c0932c911c40" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;UNION&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. &lt;code&gt;ALL&lt;/code&gt; prevents elimination of duplicates. (Therefore, &lt;code&gt;UNION ALL&lt;/code&gt; is usually significantly quicker than &lt;code&gt;UNION&lt;/code&gt;; use &lt;code&gt;ALL&lt;/code&gt; when you can.) &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="translated">Результат &lt;code&gt;UNION&lt;/code&gt; не содержит повторяющихся строк, если не указан параметр &lt;code&gt;ALL&lt;/code&gt; . &lt;code&gt;ALL&lt;/code&gt; предотвращает удаление дубликатов. (Следовательно, &lt;code&gt;UNION ALL&lt;/code&gt; обычно значительно быстрее, чем &lt;code&gt;UNION&lt;/code&gt; ; используйте &lt;code&gt;ALL&lt;/code&gt; , когда можете.) &lt;code&gt;DISTINCT&lt;/code&gt; может быть написан для явного указания поведения по умолчанию для удаления повторяющихся строк.</target>
        </trans-unit>
        <trans-unit id="72402b7b0b331fd1b54d5308fde49885c6b05ef8" translate="yes" xml:space="preserve">
          <source>The result of a database content mapping looks like this:</source>
          <target state="translated">Результат отображения содержимого базы данных выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="5bf0f22088cf3019c1a1b1dbed662be7a69e9148" translate="yes" xml:space="preserve">
          <source>The result of a schema content mapping looks like this:</source>
          <target state="translated">Результат отображения содержимого схемы выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="31f7fafc96662c4abec5838f93938c08f12e39f5" translate="yes" xml:space="preserve">
          <source>The result of each path evaluation step can be processed by one or more &lt;code&gt;jsonpath&lt;/code&gt; operators and methods listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.15.2.3&lt;/a&gt;. Each method name must be preceded by a dot. For example, you can get an array size:</source>
          <target state="translated">Результат каждого этапа оценки пути могут быть обработаны одним или несколькими &lt;code&gt;jsonpath&lt;/code&gt; операторов и методов , перечисленных в &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;разделе 9.15.2.3&lt;/a&gt; . Каждому имени метода должна предшествовать точка. Например, вы можете получить размер массива:</target>
        </trans-unit>
        <trans-unit id="ec7ce6cfc1de15ad9d69c5a41b7880b123d8687e" translate="yes" xml:space="preserve">
          <source>The result of each path evaluation step can be processed by one or more &lt;code&gt;jsonpath&lt;/code&gt; operators and methods listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.16.2.2&lt;/a&gt;. Each method name must be preceded by a dot. For example, you can get the size of an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c39389298dad4176af2cd2f4f928038308a6b18" translate="yes" xml:space="preserve">
          <source>The result of successfully committing a group of transactions is inconsistent with all possible orderings of running those transactions one at a time.</source>
          <target state="translated">Результат успешного совершения группы транзакций несовместим со всеми возможными порядками проведения этих транзакций по одному.</target>
        </trans-unit>
        <trans-unit id="f90d6b2c73e8ea4c0551da0df475a8d425331eb2" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;union&lt;/code&gt; function must be a value of the index's storage type, whatever that is (it might or might not be different from the indexed column's type). The &lt;code&gt;union&lt;/code&gt; function should return a pointer to newly &lt;code&gt;palloc()&lt;/code&gt;ed memory. You can't just return the input value as-is, even if there is no type change.</source>
          <target state="translated">Результатом функции &lt;code&gt;union&lt;/code&gt; должно быть значение типа хранения индекса, каким бы оно ни было (оно может отличаться или не отличаться от типа индексированного столбца). Функция &lt;code&gt;union&lt;/code&gt; должна возвращать указатель на недавно &lt;code&gt;palloc()&lt;/code&gt; память palloc () . Вы не можете просто вернуть входное значение как есть, даже если нет изменения типа.</target>
        </trans-unit>
        <trans-unit id="1b294fef53c3a5221592cc68d2bcc8aa48d712cd" translate="yes" xml:space="preserve">
          <source>The result of the function is a single record. The &lt;em&gt;&lt;code&gt;lsn&lt;/code&gt;&lt;/em&gt; column holds the backup's ending write-ahead log location (which again can be ignored). The second and third columns are &lt;code&gt;NULL&lt;/code&gt; when ending an exclusive backup; after a non-exclusive backup they hold the desired contents of the label and tablespace map files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a9c39c953a9312145a45ccbb983953c2e08ee1" translate="yes" xml:space="preserve">
          <source>The result of the previous two inserts looks like this:</source>
          <target state="translated">Результат двух предыдущих вставок выглядит так:</target>
        </trans-unit>
        <trans-unit id="b464f588a5c51e3217548207540b5bba236a02d5" translate="yes" xml:space="preserve">
          <source>The result returned by &lt;code&gt;setval&lt;/code&gt; is just the value of its second argument.</source>
          <target state="translated">Результат, возвращаемый &lt;code&gt;setval&lt;/code&gt; , - это просто значение его второго аргумента.</target>
        </trans-unit>
        <trans-unit id="94a3bc7cb16b6aa14b4272070826c46eaa5db71f" translate="yes" xml:space="preserve">
          <source>The result type of the &lt;code&gt;datetime()&lt;/code&gt; and &lt;code&gt;datetime(template)&lt;/code&gt; methods can be &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;timetz&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamptz&lt;/code&gt;, or &lt;code&gt;timestamp&lt;/code&gt;. Both methods determine their result type dynamically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5675fc85ce2eab9d13414767f82a9b7b9d9a68bc" translate="yes" xml:space="preserve">
          <source>The resulting dump can be restored with psql:</source>
          <target state="translated">Полученный дамп может быть восстановлен с помощью psql:</target>
        </trans-unit>
        <trans-unit id="bd98dcbc013dfe386ef25cd013047250a70319f2" translate="yes" xml:space="preserve">
          <source>The results of the &lt;code&gt;in_range&lt;/code&gt; function must be consistent with the sort ordering imposed by the operator family. To be precise, given any fixed values of &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;sub&lt;/code&gt;, then:</source>
          <target state="translated">Результаты функции &lt;code&gt;in_range&lt;/code&gt; должны согласовываться с порядком сортировки, установленным семейством операторов. Чтобы быть точным, учитывая любые фиксированные значения &lt;code&gt;offset&lt;/code&gt; и &lt;code&gt;sub&lt;/code&gt; , тогда:</target>
        </trans-unit>
        <trans-unit id="09c3bbabf641766b5c1086657a825502c1601a40" translate="yes" xml:space="preserve">
          <source>The results of two queries can be combined using the set operations union, intersection, and difference. The syntax is</source>
          <target state="translated">Результаты двух запросов могут быть объединены с помощью заданных операций объединения,пересечения и разности.Синтаксис</target>
        </trans-unit>
        <trans-unit id="6af5cccdc36b9ba47ebe00f94b9f0ae450f2173e" translate="yes" xml:space="preserve">
          <source>The return data type (optionally schema-qualified). The return type can be a base, composite, or domain type, or can reference the type of a table column. Depending on the implementation language it might also be allowed to specify &amp;ldquo;pseudo-types&amp;rdquo; such as &lt;code&gt;cstring&lt;/code&gt;. If the function is not supposed to return a value, specify &lt;code&gt;void&lt;/code&gt; as the return type.</source>
          <target state="translated">Тип возвращаемых данных (возможно, дополненный схемой). Тип возврата может быть базовым, составным или доменным типом либо может ссылаться на тип столбца таблицы. В зависимости от языка реализации также может быть разрешено указывать &amp;laquo;псевдотипы&amp;raquo;, такие как &lt;code&gt;cstring&lt;/code&gt; . Если функция не должна возвращать значение, укажите &lt;code&gt;void&lt;/code&gt; в качестве типа возврата.</target>
        </trans-unit>
        <trans-unit id="68f515e9225e3a8bd926fdcf278047adb080a143" translate="yes" xml:space="preserve">
          <source>The return type of a cast function must be identical to or binary-coercible to the cast's target type.</source>
          <target state="translated">Возвращаемый тип приводимой функции должен быть идентичен или двоично-смешивающийся с типом цели приводимой функции.</target>
        </trans-unit>
        <trans-unit id="e79b9ffc9a06ade0f94c181bff76d0c5e0055f02" translate="yes" xml:space="preserve">
          <source>The return type of each function is &lt;code&gt;xml&lt;/code&gt;.</source>
          <target state="translated">Тип возврата каждой функции - &lt;code&gt;xml&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ccb6d89ec3d8d5f1a14886d00086edc74d4f798" translate="yes" xml:space="preserve">
          <source>The return value is static information about an operator class and collation. Returning &lt;code&gt;true&lt;/code&gt; indicates that the &lt;code&gt;order&lt;/code&gt; function for the operator class is guaranteed to only return &lt;code&gt;0&lt;/code&gt; (&amp;ldquo;arguments are equal&amp;rdquo;) when its &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; arguments are also interchangeable without any loss of semantic information. Not registering an &lt;code&gt;equalimage&lt;/code&gt; function or returning &lt;code&gt;false&lt;/code&gt; indicates that this condition cannot be assumed to hold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae53d800dbf466337096571156e983ea2cef4a1a" translate="yes" xml:space="preserve">
          <source>The returned columns correspond to the fields in the &lt;code&gt;BrinMemTuple&lt;/code&gt; and &lt;code&gt;BrinValues&lt;/code&gt; structs. See &lt;code&gt;src/include/access/brin_tuple.h&lt;/code&gt; for details.</source>
          <target state="translated">&lt;code&gt;BrinMemTuple&lt;/code&gt; столбцы соответствуют полям в структурах BrinMemTuple и &lt;code&gt;BrinValues&lt;/code&gt; . Подробнее см. &lt;code&gt;src/include/access/brin_tuple.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbe5a0ea635cc6baf516f6e2eb370c36b529a917" translate="yes" xml:space="preserve">
          <source>The returned columns correspond to the fields in the &lt;code&gt;PageHeaderData&lt;/code&gt; struct. See &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; for details.</source>
          <target state="translated">&lt;code&gt;PageHeaderData&lt;/code&gt; столбцы соответствуют полям в структуре PageHeaderData . Подробности см. В &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ce8dcca026fdd1326a0feb6d5dcbe4fd79aa2a7" translate="yes" xml:space="preserve">
          <source>The rewriting forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; are not MVCC-safe. After a table rewrite, the table will appear empty to concurrent transactions, if they are using a snapshot taken before the rewrite occurred. See &lt;a href=&quot;mvcc-caveats&quot;&gt;Section 13.5&lt;/a&gt; for more details.</source>
          <target state="translated">Формы перезаписи &lt;code&gt;ALTER TABLE&lt;/code&gt; небезопасны для MVCC. После перезаписи таблицы она будет казаться пустой для параллельных транзакций, если они используют моментальный снимок, сделанный до перезаписи. За подробностями &lt;a href=&quot;mvcc-caveats&quot;&gt;обратитесь&lt;/a&gt; к Разделу 13.5 .</target>
        </trans-unit>
        <trans-unit id="9dd9c3f397a07f60ffdbedaa5659c2ca90ab6d90" translate="yes" xml:space="preserve">
          <source>The right to drop an object, or to alter its definition in any way, is not treated as a grantable privilege; it is inherent in the owner, and cannot be granted or revoked. (However, a similar effect can be obtained by granting or revoking membership in the role that owns the object; see below.) The owner implicitly has all grant options for the object, too.</source>
          <target state="translated">Право отказаться от предмета или каким-либо образом изменить его определение не рассматривается как привилегия,подлежащая передаче;оно присуще владельцу и не может быть предоставлено или отозвано.(Однако аналогичный эффект может быть получен в результате предоставления или отмены членства в роли владельца предмета;см.ниже).Владелец косвенно также имеет все возможности предоставления объекта.</target>
        </trans-unit>
        <trans-unit id="1485f3d0af50f7ad2c38bab6ab4b82f7cade74e8" translate="yes" xml:space="preserve">
          <source>The right to modify or destroy an object is always the privilege of the owner only.</source>
          <target state="translated">Право изменять или уничтожать объект всегда является привилегией только владельца.</target>
        </trans-unit>
        <trans-unit id="081b4bb5f9bb63c56a6d0ef4a59ec5296ea9be8b" translate="yes" xml:space="preserve">
          <source>The right to modify or destroy an object is inherent in being the object's owner, and cannot be granted or revoked in itself. (However, like all privileges, that right can be inherited by members of the owning role; see &lt;a href=&quot;role-membership&quot;&gt;Section 21.3&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b02a1fae471a2cfa0b9f0f9afcb866f7eeb267" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized expression, which must yield an array value. The left-hand expression is evaluated and compared to each element of the array using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if all comparisons yield true (including the case where the array has zero elements). The result is &amp;ldquo;false&amp;rdquo; if any false result is found.</source>
          <target state="translated">Правая часть - это выражение в скобках, которое должно давать значение массива. Левое выражение оценивается и сравнивается с каждым элементом массива с помощью заданного &lt;code&gt;operator&lt;/code&gt; , который должен давать логический результат. Результатом &lt;code&gt;ALL&lt;/code&gt; является &amp;laquo;истина&amp;raquo;, если все сравнения дают истинное значение (включая случай, когда в массиве нулевые элементы). Результат будет &amp;laquo;ложным&amp;raquo;, если будет обнаружен какой-либо ложный результат.</target>
        </trans-unit>
        <trans-unit id="0854056fb124d8ec388aaba4b2f113f43a992144" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized expression, which must yield an array value. The left-hand expression is evaluated and compared to each element of the array using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any true result is obtained. The result is &amp;ldquo;false&amp;rdquo; if no true result is found (including the case where the array has zero elements).</source>
          <target state="translated">Правая часть - это выражение в скобках, которое должно давать значение массива. Левое выражение оценивается и сравнивается с каждым элементом массива с использованием данного &lt;code&gt;operator&lt;/code&gt; , который должен давать логический результат. Результат &lt;code&gt;ANY&lt;/code&gt; является &amp;laquo;истинным&amp;raquo;, если получен какой-либо истинный результат. Результат будет &amp;laquo;ложным&amp;raquo;, если истинный результат не найден (включая случай, когда в массиве нулевые элементы).</target>
        </trans-unit>
        <trans-unit id="4cadd4592ac992256e9ca190e2ede2776b0f06bb" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized list of scalar expressions. The result is &amp;ldquo;true&amp;rdquo; if the left-hand expression's result is equal to any of the right-hand expressions. This is a shorthand notation for</source>
          <target state="translated">Правая часть - это список скалярных выражений в скобках. Результатом будет &amp;laquo;истина&amp;raquo;, если результат левого выражения равен любому из правых выражений. Это сокращенное обозначение</target>
        </trans-unit>
        <trans-unit id="9a6bece97382db0f9b6ad5060523f2f32e422503" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized list of scalar expressions. The result is &amp;ldquo;true&amp;rdquo; if the left-hand expression's result is unequal to all of the right-hand expressions. This is a shorthand notation for</source>
          <target state="translated">Правая часть - это список скалярных выражений в скобках. Результатом будет &amp;laquo;истина&amp;raquo;, если результат левого выражения не равен всем правым выражениям. Это сокращенное обозначение</target>
        </trans-unit>
        <trans-unit id="4623e53b09512588ad13e7eaadc6e34f6d36d750" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if all rows yield true (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any false result is found. The result is NULL if no comparison with a subquery row returns false, and at least one comparison returns NULL.</source>
          <target state="translated">Правая часть - это подзапрос в скобках, который должен возвращать ровно один столбец. Левое выражение оценивается и сравнивается с каждой строкой результата подзапроса с использованием данного &lt;code&gt;operator&lt;/code&gt; , который должен давать логический результат. Результатом &lt;code&gt;ALL&lt;/code&gt; является &amp;laquo;истина&amp;raquo;, если все строки возвращают истину (включая случай, когда подзапрос не возвращает строк). Результат будет &amp;laquo;ложным&amp;raquo;, если будет обнаружен какой-либо ложный результат. Результатом является NULL, если никакое сравнение со строкой подзапроса не возвращает false, и хотя бы одно сравнение возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="89b47774fd6157f8ca176076b1ed18f995c2daef" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any true result is obtained. The result is &amp;ldquo;false&amp;rdquo; if no true result is found (including the case where the subquery returns no rows).</source>
          <target state="translated">Правая часть - это подзапрос в скобках, который должен возвращать ровно один столбец. Левое выражение оценивается и сравнивается с каждой строкой результата подзапроса с использованием данного &lt;code&gt;operator&lt;/code&gt; , который должен давать логический результат. Результат &lt;code&gt;ANY&lt;/code&gt; является &amp;laquo;истинным&amp;raquo;, если получен какой-либо истинный результат. Результатом будет &amp;laquo;ложь&amp;raquo;, если истинный результат не найден (включая случай, когда подзапрос не возвращает строк).</target>
        </trans-unit>
        <trans-unit id="a7873b5839bfc7065dc6edeb7940049a4cb53216" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result. The result of &lt;code&gt;IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any equal subquery row is found. The result is &amp;ldquo;false&amp;rdquo; if no equal row is found (including the case where the subquery returns no rows).</source>
          <target state="translated">Правая часть - это подзапрос в скобках, который должен возвращать ровно один столбец. Левое выражение оценивается и сравнивается с каждой строкой результата подзапроса. Результат &lt;code&gt;IN&lt;/code&gt; - &amp;laquo;истина&amp;raquo;, если найдена любая такая же строка подзапроса. Результатом будет &amp;laquo;ложь&amp;raquo;, если не найдено ни одной одинаковой строки (включая случай, когда подзапрос не возвращает строк).</target>
        </trans-unit>
        <trans-unit id="0ca2d475edb7fe77a4b6be61177af0a4c222988e" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result. The result of &lt;code&gt;NOT IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if only unequal subquery rows are found (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any equal row is found.</source>
          <target state="translated">Правая часть - это подзапрос в скобках, который должен возвращать ровно один столбец. Левое выражение оценивается и сравнивается с каждой строкой результата подзапроса. Результатом &lt;code&gt;NOT IN&lt;/code&gt; будет &amp;laquo;истина&amp;raquo;, если найдены только неравные строки подзапроса (включая случай, когда подзапрос не возвращает строк). Результатом будет &amp;laquo;ложь&amp;raquo;, если будет найдена любая такая же строка.</target>
        </trans-unit>
        <trans-unit id="60ffe49fd73a1dfeb0ff0a3cd27bc012700f7f66" translate="yes" xml:space="preserve">
          <source>The risk that is taken by using asynchronous commit is of data loss, not data corruption. If the database should crash, it will recover by replaying WAL up to the last record that was flushed. The database will therefore be restored to a self-consistent state, but any transactions that were not yet flushed to disk will not be reflected in that state. The net effect is therefore loss of the last few transactions. Because the transactions are replayed in commit order, no inconsistency can be introduced &amp;mdash; for example, if transaction B made changes relying on the effects of a previous transaction A, it is not possible for A's effects to be lost while B's effects are preserved.</source>
          <target state="translated">При использовании асинхронной фиксации возникает риск потери данных, а не их повреждения. Если база данных выйдет из строя, она восстановится путем воспроизведения WAL до последней сброшенной записи. Таким образом, база данных будет восстановлена ​​до самосогласованного состояния, но любые транзакции, которые еще не были сброшены на диск, не будут отражены в этом состоянии. Таким образом, чистым эффектом является потеря нескольких последних транзакций. Поскольку транзакции воспроизводятся в порядке фиксации, несогласованность не может быть внесена - например, если транзакция B внесла изменения, полагаясь на эффекты предыдущей транзакции A, эффекты A не могут быть потеряны, пока эффекты B сохраняются.</target>
        </trans-unit>
        <trans-unit id="458aee8243a88af8890a3686268fbeeebdc768b4" translate="yes" xml:space="preserve">
          <source>The role attributes &lt;code&gt;LOGIN&lt;/code&gt;, &lt;code&gt;SUPERUSER&lt;/code&gt;, &lt;code&gt;CREATEDB&lt;/code&gt;, and &lt;code&gt;CREATEROLE&lt;/code&gt; can be thought of as special privileges, but they are never inherited as ordinary privileges on database objects are. You must actually &lt;code&gt;SET ROLE&lt;/code&gt; to a specific role having one of these attributes in order to make use of the attribute. Continuing the above example, we might choose to grant &lt;code&gt;CREATEDB&lt;/code&gt; and &lt;code&gt;CREATEROLE&lt;/code&gt; to the &lt;code&gt;admin&lt;/code&gt; role. Then a session connecting as role &lt;code&gt;joe&lt;/code&gt; would not have these privileges immediately, only after doing &lt;code&gt;SET ROLE admin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SUPERUSER&lt;/code&gt; атрибуты &lt;code&gt;LOGIN&lt;/code&gt; , SUPERUSER , &lt;code&gt;CREATEDB&lt;/code&gt; и &lt;code&gt;CREATEROLE&lt;/code&gt; можно рассматривать как особые привилегии, но они никогда не наследуются как обычные привилегии для объектов базы данных. Вы должны фактически &lt;code&gt;SET ROLE&lt;/code&gt; для конкретной роли, имеющей один из этих атрибутов, чтобы использовать атрибут. Продолжая предыдущий пример, мы можем выбрать , чтобы предоставить &lt;code&gt;CREATEDB&lt;/code&gt; и &lt;code&gt;CREATEROLE&lt;/code&gt; к &lt;code&gt;admin&lt;/code&gt; роли. Тогда сеанс, подключающийся с ролью &lt;code&gt;joe&lt;/code&gt; , не получит эти привилегии сразу, только после выполнения &lt;code&gt;SET ROLE admin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc4f14a678d35107865a506875d403f1fabcef04" translate="yes" xml:space="preserve">
          <source>The role name of the user who will own the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the default (namely, the user executing the command). To create a database owned by another role, you must be a direct or indirect member of that role, or be a superuser.</source>
          <target state="translated">Имя роли пользователя, которому будет принадлежать новая база данных, или &lt;code&gt;DEFAULT&lt;/code&gt; , чтобы использовать значение по умолчанию (а именно, пользователь, выполняющий команду). Чтобы создать базу данных, принадлежащую другой роли, вы должны быть прямым или косвенным членом этой роли или быть суперпользователем.</target>
        </trans-unit>
        <trans-unit id="e0cd094fcb28a6d1c971a4fe5ea4b6668f0b2297" translate="yes" xml:space="preserve">
          <source>The role name of the user who will own the new schema. If omitted, defaults to the user executing the command. To create a schema owned by another role, you must be a direct or indirect member of that role, or be a superuser.</source>
          <target state="translated">Имя роли пользователя,который будет владеть новой схемой.Если опущено,по умолчанию это имя будет присвоено пользователю,выполняющему команду.Для создания схемы,принадлежащей другой роли,вы должны быть прямым или косвенным членом этой роли или быть суперпользователем.</target>
        </trans-unit>
        <trans-unit id="288659e152f65b17d46027cdd207a204fb13225f" translate="yes" xml:space="preserve">
          <source>The role used for the replication connection must have the &lt;code&gt;REPLICATION&lt;/code&gt; attribute (or be a superuser). Access for the role must be configured in &lt;code&gt;pg_hba.conf&lt;/code&gt; and it must have the &lt;code&gt;LOGIN&lt;/code&gt; attribute.</source>
          <target state="translated">Роль, используемая для соединения репликации, должна иметь атрибут &lt;code&gt;REPLICATION&lt;/code&gt; (или быть суперпользователем). Доступ для роли должен быть настроен в &lt;code&gt;pg_hba.conf&lt;/code&gt; , и он должен иметь атрибут &lt;code&gt;LOGIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae4f6c3527bb773eca24ae98fe7bc2235694a76b" translate="yes" xml:space="preserve">
          <source>The role used for the replication connection must have the &lt;code&gt;REPLICATION&lt;/code&gt; attribute (or be a superuser). If the role lacks &lt;code&gt;SUPERUSER&lt;/code&gt; and &lt;code&gt;BYPASSRLS&lt;/code&gt;, publisher row security policies can execute. If the role does not trust all table owners, include &lt;code&gt;options=-crow_security=off&lt;/code&gt; in the connection string; if a table owner then adds a row security policy, that setting will cause replication to halt rather than execute the policy. Access for the role must be configured in &lt;code&gt;pg_hba.conf&lt;/code&gt; and it must have the &lt;code&gt;LOGIN&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7270c8298ccd5ab28e0386f721a4bd64642b81f5" translate="yes" xml:space="preserve">
          <source>The role(s) to which the policy applies. Multiple roles can be specified at one time. To apply the policy to all roles, use &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">Роли, к которым применяется политика. Одновременно можно указать несколько ролей. Чтобы применить политику ко всем ролям, используйте &lt;code&gt;PUBLIC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="672dc56056e4468fca330096a6f7988e99426d64" translate="yes" xml:space="preserve">
          <source>The role(s) to which the policy is to be applied. The default is &lt;code&gt;PUBLIC&lt;/code&gt;, which will apply the policy to all roles.</source>
          <target state="translated">Роли, к которым должна применяться политика. Значение по умолчанию - &lt;code&gt;PUBLIC&lt;/code&gt; , что применяет политику ко всем ролям.</target>
        </trans-unit>
        <trans-unit id="da08283627fb6b277f73d5b0ddf0372ed6cb0f5d" translate="yes" xml:space="preserve">
          <source>The roles to which the policy is applied</source>
          <target state="translated">Роли,к которым применяется политика</target>
        </trans-unit>
        <trans-unit id="0b502eae099c8f10d1ed4ef0c354669f63bce361" translate="yes" xml:space="preserve">
          <source>The roles to which this policy applies</source>
          <target state="translated">Роли,к которым применяется эта политика</target>
        </trans-unit>
        <trans-unit id="acd6a9c4a0e56d2f8f09c7b30b75a454cb6c1d08" translate="yes" xml:space="preserve">
          <source>The rows considered by a window function are those of the &amp;ldquo;virtual table&amp;rdquo; produced by the query's &lt;code&gt;FROM&lt;/code&gt; clause as filtered by its &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses if any. For example, a row removed because it does not meet the &lt;code&gt;WHERE&lt;/code&gt; condition is not seen by any window function. A query can contain multiple window functions that slice up the data in different ways using different &lt;code&gt;OVER&lt;/code&gt; clauses, but they all act on the same collection of rows defined by this virtual table.</source>
          <target state="translated">Строки, рассматриваемые оконной функцией, - это строки &amp;laquo;виртуальной таблицы&amp;raquo;, созданной предложением &lt;code&gt;FROM&lt;/code&gt; запроса, отфильтрованные его &lt;code&gt;WHERE&lt;/code&gt; , &lt;code&gt;GROUP BY&lt;/code&gt; и &lt;code&gt;HAVING&lt;/code&gt; , если таковые имеются. Например, строка, удаленная из-за &lt;code&gt;WHERE&lt;/code&gt; условию WHERE, не отображается ни одной оконной функцией. Запрос может содержать несколько оконных функций, которые по-разному &lt;code&gt;OVER&lt;/code&gt; данные с помощью разных предложений OVER , но все они действуют на один и тот же набор строк, определенных этой виртуальной таблицей.</target>
        </trans-unit>
        <trans-unit id="ac9a42afd27bb82c7fefe7d8456c8e56005d3e20" translate="yes" xml:space="preserve">
          <source>The rows skipped by an &lt;code&gt;OFFSET&lt;/code&gt; clause still have to be computed inside the server; therefore a large &lt;code&gt;OFFSET&lt;/code&gt; might be inefficient.</source>
          <target state="translated">Строки, пропущенные предложением &lt;code&gt;OFFSET&lt;/code&gt; , все равно должны вычисляться на сервере; поэтому большое &lt;code&gt;OFFSET&lt;/code&gt; может быть неэффективным.</target>
        </trans-unit>
        <trans-unit id="9c6595d74dd986e8e704f616ce70f02f89a3b6e5" translate="yes" xml:space="preserve">
          <source>The rule firing mechanism is also affected by the configuration variable &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;, analogous to triggers as described above.</source>
          <target state="translated">На механизм запуска правила также влияет конфигурационная переменная &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt; , аналогично триггерам, описанным выше.</target>
        </trans-unit>
        <trans-unit id="77cbd29a44e08d42c19c09374140fe6b3a2c7eb5" translate="yes" xml:space="preserve">
          <source>The rules file has the following format:</source>
          <target state="translated">Файл с правилами имеет следующий формат:</target>
        </trans-unit>
        <trans-unit id="20f26d0e3be07fc8411c53cf4fec028b4fb7ddc1" translate="yes" xml:space="preserve">
          <source>The rules given in the preceding sections will result in assignment of non-&lt;code&gt;unknown&lt;/code&gt; data types to all expressions in a SQL query, except for unspecified-type literals that appear as simple output columns of a &lt;code&gt;SELECT&lt;/code&gt; command. For example, in</source>
          <target state="translated">Правила, приведенные в предыдущих разделах, приведут к присвоению &lt;code&gt;unknown&lt;/code&gt; типов данных всем выражениям в запросе SQL, за исключением литералов неопределенного типа, которые появляются как простые выходные столбцы команды &lt;code&gt;SELECT&lt;/code&gt; . Например, в</target>
        </trans-unit>
        <trans-unit id="a710b4d0128d22b5baa147d345de94a14b25c08a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;1...2&lt;/code&gt;, or &lt;code&gt;1 .. 2&lt;/code&gt;, or &lt;code&gt;1..2&lt;/code&gt; (spaces around the range operator are ignored)</source>
          <target state="translated">То же, что &lt;code&gt;1...2&lt;/code&gt; , или &lt;code&gt;1 .. 2&lt;/code&gt; , или &lt;code&gt;1..2&lt;/code&gt; (пробелы вокруг оператора диапазона игнорируются)</target>
        </trans-unit>
        <trans-unit id="e6e201d82f084cc5d95195c10944ee93631d8df0" translate="yes" xml:space="preserve">
          <source>The same, and also reset any associated sequence generators:</source>
          <target state="translated">То же самое,а также сбросить все связанные с ними генераторы последовательности:</target>
        </trans-unit>
        <trans-unit id="241b8d226e8b5f79ed0ec6888a0ce004af81b21c" translate="yes" xml:space="preserve">
          <source>The same, but counting only word occurrences with weight &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">То же самое, но с учетом только вхождений слов с весом &lt;code&gt;A&lt;/code&gt; или &lt;code&gt;B&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d2d2e57444e30e19980ec9c24adfc53e9305e592" translate="yes" xml:space="preserve">
          <source>The same, but only execute the function if column &lt;code&gt;balance&lt;/code&gt; is specified as a target in the &lt;code&gt;UPDATE&lt;/code&gt; command:</source>
          <target state="translated">То же самое, но выполнять функцию только в том случае, если &lt;code&gt;balance&lt;/code&gt; столбца указан в качестве цели в команде &lt;code&gt;UPDATE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="002437cb1427716a633526fb7913d4100317c440" translate="yes" xml:space="preserve">
          <source>The same, specified as a table constraint:</source>
          <target state="translated">То же самое,указанное в качестве ограничения таблицы:</target>
        </trans-unit>
        <trans-unit id="788d460ac0c5a82665dae9bd0fa72bfb74260b32" translate="yes" xml:space="preserve">
          <source>The same, using regular expression notation to consolidate the switches:</source>
          <target state="translated">То же самое,используя нотацию регулярных выражений для консолидации переключателей:</target>
        </trans-unit>
        <trans-unit id="bfae0e75e1b6288495d53b506d9a241bf9d03b6d" translate="yes" xml:space="preserve">
          <source>The same, when the column has a default expression that won't automatically cast to the new data type:</source>
          <target state="translated">То же самое,когда столбец имеет выражение по умолчанию,которое не будет автоматически приведено к новому типу данных:</target>
        </trans-unit>
        <trans-unit id="d799562b98253554741c727e0742611d0f2a5b8b" translate="yes" xml:space="preserve">
          <source>The sample results shown on this page assume that the server parameter &lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt;&lt;code&gt;bytea_output&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;escape&lt;/code&gt; (the traditional PostgreSQL format).</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt; &lt;code&gt;bytea_output&lt;/code&gt; &lt;/a&gt; результатов, показанные на этой странице, предполагают, что для параметра сервера bytea_output установлено значение &lt;code&gt;escape&lt;/code&gt; (традиционный формат PostgreSQL).</target>
        </trans-unit>
        <trans-unit id="63cecb1fda6e05d04ffb99e00faba23729910dbf" translate="yes" xml:space="preserve">
          <source>The savepoint to roll back to.</source>
          <target state="translated">Точка сохранения,к которой нужно откатиться.</target>
        </trans-unit>
        <trans-unit id="237920c06713568a0627b8a6cf3c35b4a6fcf5f1" translate="yes" xml:space="preserve">
          <source>The scalar ordering operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, etc) do not make a lot of sense for any practical purpose but sorting. These operators first compare the first coordinates, and if those are equal, compare the second coordinates, etc. They exist mainly to support the b-tree index operator class for &lt;code&gt;cube&lt;/code&gt;, which can be useful for example if you would like a UNIQUE constraint on a &lt;code&gt;cube&lt;/code&gt; column.</source>
          <target state="translated">Операторы скалярного упорядочивания ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; и т. Д.) Не имеют большого смысла для каких-либо практических целей, кроме сортировки. Эти операторы сначала сравнивают первые координаты, и, если они равны, сравнивают вторые координаты и т. Д. Они существуют в основном для поддержки класса операторов индекса b-дерева для &lt;code&gt;cube&lt;/code&gt; , который может быть полезен, например, если вы хотите установить ограничение UNIQUE для &lt;code&gt;cube&lt;/code&gt; колонки.</target>
        </trans-unit>
        <trans-unit id="c8365d330a7b8ee61b52ae905279178001855d43" translate="yes" xml:space="preserve">
          <source>The schema containing the &lt;code&gt;citext&lt;/code&gt; operators must be in the current &lt;code&gt;search_path&lt;/code&gt; (typically &lt;code&gt;public&lt;/code&gt;); if it is not, the normal case-sensitive &lt;code&gt;text&lt;/code&gt; operators will be invoked instead.</source>
          <target state="translated">Схема, содержащая операторы &lt;code&gt;citext&lt;/code&gt; , должна находиться в текущем &lt;code&gt;search_path&lt;/code&gt; (обычно &lt;code&gt;public&lt;/code&gt; ); в противном случае вместо этого будут вызываться обычные &lt;code&gt;text&lt;/code&gt; операторы с учетом регистра .</target>
        </trans-unit>
        <trans-unit id="a1b72adef26aba98ed5b9a11c3f8d9f992851abe" translate="yes" xml:space="preserve">
          <source>The schema definitions are not replicated, and the published tables must exist on the subscriber. Only regular tables may be the target of replication. For example, you can't replicate to a view.</source>
          <target state="translated">Определения схемы не тиражируются,а опубликованные таблицы должны существовать на подписчике.Только обычные таблицы могут быть объектом тиражирования.Например,вы не можете реплицироваться на представление.</target>
        </trans-unit>
        <trans-unit id="459a237a85ce3b91cf8ef1e52361b976ab47c1f2" translate="yes" xml:space="preserve">
          <source>The schema in which the imported foreign tables will be created.</source>
          <target state="translated">Схема,в которой будут созданы импортные зарубежные таблицы.</target>
        </trans-unit>
        <trans-unit id="01865c073aef636c813a71a650ffa6b695ee5717" translate="yes" xml:space="preserve">
          <source>The schemes shown here assume that the values of a row's key column(s) never change, or at least do not change enough to require it to move to another partition. An &lt;code&gt;UPDATE&lt;/code&gt; that attempts to do that will fail because of the &lt;code&gt;CHECK&lt;/code&gt; constraints. If you need to handle such cases, you can put suitable update triggers on the child tables, but it makes management of the structure much more complicated.</source>
          <target state="translated">В схемах, показанных здесь, предполагается, что значения ключевого столбца (столбцов) строки никогда не меняются или, по крайней мере, не меняются настолько, чтобы потребовать его перемещения в другой раздел. &lt;code&gt;UPDATE&lt;/code&gt; , что попытки сделать это не удастся из-за &lt;code&gt;CHECK&lt;/code&gt; ограничений. Если вам нужно обработать такие случаи, вы можете поместить подходящие триггеры обновления в дочерние таблицы, но это значительно усложнит управление структурой.</target>
        </trans-unit>
        <trans-unit id="ec9b55e40d83c1563492fc665bcf7be0f37fb815" translate="yes" xml:space="preserve">
          <source>The scripts can be run in any order and can be deleted once they have been run.</source>
          <target state="translated">Скрипты могут быть запущены в любом порядке и могут быть удалены после их запуска.</target>
        </trans-unit>
        <trans-unit id="5351b57ec30c67488f197082c674a1ac3697572e" translate="yes" xml:space="preserve">
          <source>The search filter to use when doing search+bind authentication. Occurrences of &lt;code&gt;$username&lt;/code&gt; will be replaced with the user name. This allows for more flexible search filters than &lt;code&gt;ldapsearchattribute&lt;/code&gt;.</source>
          <target state="translated">Фильтр поиска, используемый при выполнении аутентификации поиск + привязка. Вхождения &lt;code&gt;$username&lt;/code&gt; будет заменено именем пользователя. Это позволяет использовать более гибкие фильтры поиска, чем &lt;code&gt;ldapsearchattribute&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc9e6cb9abd2e41c04bc258bc4b8a29867d6da64" translate="yes" xml:space="preserve">
          <source>The search path can be altered at run time. The command is:</source>
          <target state="translated">Путь поиска может быть изменен во время выполнения.Команда такова:</target>
        </trans-unit>
        <trans-unit id="478354e0ca1e05b1455044d0dbe23d731c182378" translate="yes" xml:space="preserve">
          <source>The search path works in the same way for data type names, function names, and operator names as it does for table names. Data type and function names can be qualified in exactly the same way as table names. If you need to write a qualified operator name in an expression, there is a special provision: you must write</source>
          <target state="translated">Путь поиска работает так же,как и для имен типов данных,имен функций и имен операторов,как и для имен таблиц.Имена типов данных и функций могут быть квалифицированы точно так же,как и имена таблиц.Если вам нужно написать квалифицированное имя оператора в выражении,то есть специальное положение:вы должны написать</target>
        </trans-unit>
        <trans-unit id="90f585a0c61cda16f1f2f37af64c77ecb164389f" translate="yes" xml:space="preserve">
          <source>The second approach combines any authentication method for &lt;code&gt;hostssl&lt;/code&gt; entries with the verification of client certificates by setting the &lt;code&gt;clientcert&lt;/code&gt; authentication option to &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;. The former option only enforces that the certificate is valid, while the latter also ensures that the &lt;code&gt;cn&lt;/code&gt; (Common Name) in the certificate matches the user name or an applicable mapping.</source>
          <target state="translated">Второй подход сочетает в себе любой метод аутентификации для записей &lt;code&gt;hostssl&lt;/code&gt; с проверкой сертификатов клиентов, задав для &lt;code&gt;clientcert&lt;/code&gt; аутентификации clientcert значение verify &lt;code&gt;verify-ca&lt;/code&gt; или verify &lt;code&gt;verify-full&lt;/code&gt; . Первый вариант обеспечивает только то, что сертификат действителен, а второй также гарантирует, что &lt;code&gt;cn&lt;/code&gt; (общее имя) в сертификате соответствует имени пользователя или применимому сопоставлению.</target>
        </trans-unit>
        <trans-unit id="4e7e9d77036e0c9575b0fa838e7bb55bd546fa0a" translate="yes" xml:space="preserve">
          <source>The second argument must be a well formed XML document. In particular, it must have a single root node element.</source>
          <target state="translated">Вторым аргументом должен быть хорошо сформированный XML-документ.В частности,он должен иметь один элемент корневого узла.</target>
        </trans-unit>
        <trans-unit id="971af670862eab67d21e45dbeea285001e2a069e" translate="yes" xml:space="preserve">
          <source>The second example will store cities and their associated geographical location:</source>
          <target state="translated">Во втором примере будут храниться города и связанное с ними географическое положение:</target>
        </trans-unit>
        <trans-unit id="a8fdfc2d4d4050aa9351fe7e549967c0e1502821" translate="yes" xml:space="preserve">
          <source>The second form changes the name of the database. Only the database owner or a superuser can rename a database; non-superuser owners must also have the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. The current database cannot be renamed. (Connect to a different database if you need to do that.)</source>
          <target state="translated">Вторая форма меняет имя базы данных. Только владелец базы данных или суперпользователь может переименовать базу данных; Владельцы, не являющиеся суперпользователями, также должны иметь привилегию &lt;code&gt;CREATEDB&lt;/code&gt; . Текущая база данных не может быть переименована. (Подключитесь к другой базе данных, если вам нужно это сделать.)</target>
        </trans-unit>
        <trans-unit id="5f97cd14403d43a28906f958a63aa9be74a831f3" translate="yes" xml:space="preserve">
          <source>The second form is a PostgreSQL extension. It fills the columns from the left with as many values as are given, and the rest will be defaulted.</source>
          <target state="translated">Вторая форма-расширение PostgreSQL.Оно заполняет столбцы слева таким количеством значений,сколько дано,а остальные будут по умолчанию.</target>
        </trans-unit>
        <trans-unit id="001f55ae6b12f7691ee493402996a3cedd18d43d" translate="yes" xml:space="preserve">
          <source>The second form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates an enumerated (enum) type, as described in &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;. Enum types take a list of quoted labels, each of which must be less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; bytes long (64 bytes in a standard PostgreSQL build). (It is possible to create an enumerated type with zero labels, but such a type cannot be used to hold values before at least one label is added using &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;.)</source>
          <target state="translated">Вторая форма &lt;code&gt;CREATE TYPE&lt;/code&gt; создает перечислимый тип (enum), как описано в &lt;a href=&quot;datatype-enum&quot;&gt;Разделе 8.7&lt;/a&gt; . Типы Enum принимают список заключенных в кавычки меток, каждая из которых должна быть меньше &lt;code&gt;NAMEDATALEN&lt;/code&gt; байтов (64 байта в стандартной сборке PostgreSQL). (Можно создать перечислимый тип с нулевыми метками, но такой тип нельзя использовать для хранения значений до того, как с помощью &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt; будет добавлена ​​хотя бы одна метка .)</target>
        </trans-unit>
        <trans-unit id="9646c72014e3dc0cdbc889805cc625cb2e00d4a4" translate="yes" xml:space="preserve">
          <source>The second implementation of the rule system is a technique called &lt;em&gt;query rewriting&lt;/em&gt;. The &lt;em&gt;rewrite system&lt;/em&gt; is a module that exists between the &lt;em&gt;parser stage&lt;/em&gt; and the &lt;em&gt;planner/optimizer&lt;/em&gt;. This technique is still implemented.</source>
          <target state="translated">Вторая реализация системы правил - это метод, называемый &lt;em&gt;переписыванием запросов&lt;/em&gt; . Система &lt;em&gt;перезаписи&lt;/em&gt; - это модуль, который существует между &lt;em&gt;этапом синтаксического анализа&lt;/em&gt; и &lt;em&gt;планировщиком / оптимизатором&lt;/em&gt; . Эта техника все еще применяется.</target>
        </trans-unit>
        <trans-unit id="b82fe6094f17ae862d5ae179aa9cdfdad11af121" translate="yes" xml:space="preserve">
          <source>The second line is the command that would be invoked in restart mode.</source>
          <target state="translated">Вторая строка-это команда,которая будет вызвана в режиме перезапуска.</target>
        </trans-unit>
        <trans-unit id="5e54d9500bd7199e013e0c26f4d1118e580aabf7" translate="yes" xml:space="preserve">
          <source>The second part of the module relies on representing Earth locations as values of type &lt;code&gt;point&lt;/code&gt;, in which the first component is taken to represent longitude in degrees, and the second component is taken to represent latitude in degrees. Points are taken as (longitude, latitude) and not vice versa because longitude is closer to the intuitive idea of x-axis and latitude to y-axis.</source>
          <target state="translated">Вторая часть модуля основана на представлении местоположений Земли в виде значений типа &lt;code&gt;point&lt;/code&gt; , в котором первый компонент используется для представления долготы в градусах, а второй компонент - для представления широты в градусах. Точки берутся как (долгота, широта), а не наоборот, потому что долгота ближе к интуитивному представлению об оси x, а широта - к оси y.</target>
        </trans-unit>
        <trans-unit id="07476921b1bd87798420cb9dffdda71ef3f07ce3" translate="yes" xml:space="preserve">
          <source>The second variant changes the name of the role. Database superusers can rename any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can rename non-superuser roles. The current session user cannot be renamed. (Connect as a different user if you need to do that.) Because &lt;code&gt;MD5&lt;/code&gt;-encrypted passwords use the role name as cryptographic salt, renaming a role clears its password if the password is &lt;code&gt;MD5&lt;/code&gt;-encrypted.</source>
          <target state="translated">Второй вариант меняет название роли. Суперпользователи базы данных могут переименовывать любую роль. Роли с привилегией &lt;code&gt;CREATEROLE&lt;/code&gt; могут переименовывать роли не суперпользователя. Текущего пользователя сеанса переименовать нельзя. (Подключитесь как другой пользователь, если вам нужно это сделать.) Поскольку пароли, зашифрованные с помощью &lt;code&gt;MD5&lt;/code&gt; , используют имя роли в качестве криптографической соли, при переименовании роли ее пароль очищается, если пароль зашифрован с помощью &lt;code&gt;MD5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee438b765dcc18ec34d603a483697e804f9db58b" translate="yes" xml:space="preserve">
          <source>The seconds field, including any fractional seconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe4da30b9c6bff8e95fbde2fcc03500be370613" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts (0 - 59&lt;a href=&quot;#ftn.id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;)</source>
          <target state="translated">Поле секунд, включая дробные части (0&amp;ndash;59 &lt;a href=&quot;#ftn.id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="663b58f51194288bd80b435fbc5e648d8e6f6580" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts, multiplied by 1 000 000; note that this includes full seconds</source>
          <target state="translated">Секундное поле,включая дробные части,умноженное на 1 000 000;обратите внимание,что это включает в себя целые секунды.</target>
        </trans-unit>
        <trans-unit id="2d44e15dba826649cac46abaee1bc5cb23f259a3" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts, multiplied by 1000. Note that this includes full seconds.</source>
          <target state="translated">Секундное поле,включая дробные части,умноженное на 1000.Обратите внимание,что это включает в себя целые секунды.</target>
        </trans-unit>
        <trans-unit id="7bfc04444cf0b5a28dd815138a4bbbe840cd72f0" translate="yes" xml:space="preserve">
          <source>The security label applied to this object.</source>
          <target state="translated">Метка безопасности,наложенная на этот объект.</target>
        </trans-unit>
        <trans-unit id="b47689b397bbce6da7cf131cc329c56ad0b8b0d2" translate="yes" xml:space="preserve">
          <source>The security model of SELinux describes all the access control rules as relationships between a subject entity (typically, a client of the database) and an object entity (such as a database object), each of which is identified by a security label. If access to an unlabeled object is attempted, the object is treated as if it were assigned the label &lt;code&gt;unlabeled_t&lt;/code&gt;.</source>
          <target state="translated">Модель безопасности SELinux описывает все правила контроля доступа как отношения между субъектом (обычно клиентом базы данных) и объектом (например, объектом базы данных), каждое из которых идентифицируется меткой безопасности. Если предпринимается попытка доступа к объекту без метки, объект обрабатывается так, как если бы ему была присвоена метка &lt;code&gt;unlabeled_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="230231accae0954bfa7e47d9f5e404dcd469b2c5" translate="yes" xml:space="preserve">
          <source>The security policy of SELinux also has rules to control whether or not particular accesses are logged. By default, access violations are logged, but allowed accesses are not.</source>
          <target state="translated">Политика безопасности SELinux также имеет правила для контроля того,регистрируется ли определенный доступ.По умолчанию,нарушения доступа регистрируются,но разрешенные доступы-нет.</target>
        </trans-unit>
        <trans-unit id="dbcd4d113ca55d30a1adafc062bb48c13c7f8e98" translate="yes" xml:space="preserve">
          <source>The seed can also be set by invoking the function &lt;code&gt;setseed&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;setseed&lt;/code&gt; также можно установить, вызвав функцию setseed :</target>
        </trans-unit>
        <trans-unit id="1c3344ee525a48fbaf283fc79a5b884444be3dcb" translate="yes" xml:space="preserve">
          <source>The segment [a, b] contains the segment [c, d], that is, a &amp;lt;= c and b &amp;gt;= d.</source>
          <target state="translated">Отрезок [a, b] содержит отрезок [c, d], то есть a &amp;lt;= c и b&amp;gt; = d.</target>
        </trans-unit>
        <trans-unit id="0167ae8a0ef2744b5f058f32dbb8df42b67bb33e" translate="yes" xml:space="preserve">
          <source>The segment [a, b] is contained in [c, d], that is, a &amp;gt;= c and b &amp;lt;= d.</source>
          <target state="translated">Отрезок [a, b] содержится в [c, d], то есть a&amp;gt; = c и b &amp;lt;= d.</target>
        </trans-unit>
        <trans-unit id="2f9dfe875337796db870c4bb2a262e2bbef3945b" translate="yes" xml:space="preserve">
          <source>The segments [a, b] and [c, d] overlap.</source>
          <target state="translated">Сегменты [a,b]и [c,d]пересекаются.</target>
        </trans-unit>
        <trans-unit id="b10711fce98e1c5fe5a4897a9961ed9ae2f37aef" translate="yes" xml:space="preserve">
          <source>The semantics of SQL/JSON path predicates and operators generally follow SQL. At the same time, to provide a most natural way of working with JSON data, SQL/JSON path syntax uses some of the JavaScript conventions:</source>
          <target state="translated">Семантика пути SQL/JSON предикатирует и операторы обычно следуют за SQL.В то же время,для обеспечения наиболее естественного способа работы с данными JSON,синтаксис пути SQL/JSON использует некоторые из соглашений JavaScript:</target>
        </trans-unit>
        <trans-unit id="fd623d8bcf9db9273d58642da7f1fb001cf303e9" translate="yes" xml:space="preserve">
          <source>The semantics of SQL/JSON path predicates and operators generally follow SQL. At the same time, to provide a natural way of working with JSON data, SQL/JSON path syntax uses some JavaScript conventions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2f632c9b81511535163336539f86f918d83e9e" translate="yes" xml:space="preserve">
          <source>The semicolon (&lt;code&gt;;&lt;/code&gt;) terminates an SQL command. It cannot appear anywhere within a command, except within a string constant or quoted identifier.</source>
          <target state="translated">Точка с запятой ( &lt;code&gt;;&lt;/code&gt; ) завершает команду SQL. Он не может появляться где-либо в команде, кроме строковой константы или идентификатора в кавычках.</target>
        </trans-unit>
        <trans-unit id="7c68a3eca090a3377bf1a78fea499d56ec605109" translate="yes" xml:space="preserve">
          <source>The sequence created for a &lt;code&gt;serial&lt;/code&gt; column is automatically dropped when the owning column is dropped. You can drop the sequence without dropping the column, but this will force removal of the column default expression.</source>
          <target state="translated">Последовательность, созданная для &lt;code&gt;serial&lt;/code&gt; столбца, автоматически удаляется при удалении столбца-владельца. Вы можете отбросить последовательность, не удаляя столбец, но это приведет к удалению выражения столбца по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b5a5d93057bd5edff8daf4648c4c935388f9e10e" translate="yes" xml:space="preserve">
          <source>The sequence name can be schema-qualified if necessary:</source>
          <target state="translated">Имя последовательности может быть при необходимости определено по схеме:</target>
        </trans-unit>
        <trans-unit id="c6a359aa04dbc4531fddf8d09e8fef46d55e14f6" translate="yes" xml:space="preserve">
          <source>The sequence to be operated on by a sequence function is specified by a &lt;code&gt;regclass&lt;/code&gt; argument, which is simply the OID of the sequence in the &lt;code&gt;pg_class&lt;/code&gt; system catalog. You do not have to look up the OID by hand, however, since the &lt;code&gt;regclass&lt;/code&gt; data type's input converter will do the work for you. Just write the sequence name enclosed in single quotes so that it looks like a literal constant. For compatibility with the handling of ordinary SQL names, the string will be converted to lower case unless it contains double quotes around the sequence name. Thus:</source>
          <target state="translated">Последовательность, с которой должна работать функция последовательности, определяется аргументом &lt;code&gt;regclass&lt;/code&gt; , который представляет собой просто OID последовательности в системном каталоге &lt;code&gt;pg_class&lt;/code&gt; . Однако вам не нужно искать OID вручную, поскольку преобразователь ввода типа данных &lt;code&gt;regclass&lt;/code&gt; сделает всю работу за вас. Просто напишите имя последовательности в одинарных кавычках, чтобы оно выглядело как буквальная константа. Для совместимости с обработкой обычных имен SQL строка будет преобразована в нижний регистр, если она не содержит двойных кавычек вокруг имени последовательности. Таким образом:</target>
        </trans-unit>
        <trans-unit id="ea7d18fda0e93393ee728bac05185520e2d92f5c" translate="yes" xml:space="preserve">
          <source>The server log might contain more information about an authentication failure than is reported to the client. If you are confused about the reason for a failure, check the server log.</source>
          <target state="translated">Журнал сервера может содержать больше информации о сбое аутентификации,чем сообщается клиенту.Если вы запутались в причинах сбоя,проверьте журнал сервера.</target>
        </trans-unit>
        <trans-unit id="4ca1254319f0477050eedb4dcb243dbc28231770" translate="yes" xml:space="preserve">
          <source>The server name must be unique within the database.</source>
          <target state="translated">Имя сервера должно быть уникальным в базе данных.</target>
        </trans-unit>
        <trans-unit id="7c59301168d9556837d6ae02c071fa4e2e245b97" translate="yes" xml:space="preserve">
          <source>The server process is idle. This event type indicates a process waiting for activity in its main processing loop. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-ACTIVITY-TABLE&quot;&gt;Table 27.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a48413f524a2e22ba2b89cc5a923ac95e25337" translate="yes" xml:space="preserve">
          <source>The server process is waiting for a heavyweight lock. Heavyweight locks, also known as lock manager locks or simply locks, primarily protect SQL-visible objects such as tables. However, they are also used to ensure mutual exclusion for certain internal operations such as relation extension. &lt;code&gt;wait_event&lt;/code&gt; will identify the type of lock awaited; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LOCK-TABLE&quot;&gt;Table 27.11&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f51ae65c30da3ee23ba46209eb3c2d669b578e3" translate="yes" xml:space="preserve">
          <source>The server process is waiting for a lightweight lock. Most such locks protect a particular data structure in shared memory. &lt;code&gt;wait_event&lt;/code&gt; will contain a name identifying the purpose of the lightweight lock. (Some locks have specific names; others are part of a group of locks each with a similar purpose.) See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LWLOCK-TABLE&quot;&gt;Table 27.12&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1282755dbc7fcbac3f92fb89910bc9353d2096ee" translate="yes" xml:space="preserve">
          <source>The server process is waiting for a timeout to expire. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TIMEOUT-TABLE&quot;&gt;Table 27.13&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0987499e5a13bf6c786db17c89cc8ef22d6f54" translate="yes" xml:space="preserve">
          <source>The server process is waiting for activity on a socket connected to a user application. Thus, the server expects something to happen that is independent of its internal processes. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-CLIENT-TABLE&quot;&gt;Table 27.7&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b31b52ace66848125879633c9823a38b3287ac3" translate="yes" xml:space="preserve">
          <source>The server process is waiting for an I/O operation to complete. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-IO-TABLE&quot;&gt;Table 27.9&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8bb014aedce015b73f39d1e5ca61f9c69eeed52" translate="yes" xml:space="preserve">
          <source>The server process is waiting for exclusive access to a data buffer. Buffer pin waits can be protracted if another process holds an open cursor that last read data from the buffer in question. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-BUFFERPIN-TABLE&quot;&gt;Table 27.6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9849ed38bcc2dc42a7bd3ba776b5832e6dd4516" translate="yes" xml:space="preserve">
          <source>The server process is waiting for some condition defined by an extension module. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-EXTENSION-TABLE&quot;&gt;Table 27.8&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fff16781ff90b488a09e62468878f27f389a70f" translate="yes" xml:space="preserve">
          <source>The server process is waiting for some interaction with another server process. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-IPC-TABLE&quot;&gt;Table 27.10&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac56c0453261e732a23fed94e0a24c8f95cc0488" translate="yes" xml:space="preserve">
          <source>The server reads these files at server start and whenever the server configuration is reloaded. On Windows systems, they are also re-read whenever a new backend process is spawned for a new client connection.</source>
          <target state="translated">Сервер читает эти файлы при запуске сервера и при каждой перезагрузке конфигурации сервера.На системах Windows они также перечитываются всякий раз,когда создается новый процесс бэкэнда для нового клиентского подключения.</target>
        </trans-unit>
        <trans-unit id="d0d31219164213fd90b64aadc8577b6089ce02b9" translate="yes" xml:space="preserve">
          <source>The server sends an AuthenticationSASL message. It includes a list of SASL authentication mechanisms that the server can accept. This will be &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; and &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; if the server is built with SSL support, or else just the latter.</source>
          <target state="translated">Сервер отправляет сообщение AuthenticationSASL. Он включает список механизмов аутентификации SASL, которые может принять сервер. Это будут &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; и &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; , если сервер построен с поддержкой SSL, или только последний.</target>
        </trans-unit>
        <trans-unit id="b019b1a1b7d85dded861255aa6e59d8f9921d05a" translate="yes" xml:space="preserve">
          <source>The server will occasionally request the client to perform a flush and report the flush position to the server. This setting is in addition to that, to perform flushes more frequently.</source>
          <target state="translated">Время от времени сервер будет запрашивать у клиента выполнение флеша и сообщать серверу о позиции флеша.Эта настройка является дополнением к этому,для более частого выполнения флеш-флеш-памяти.</target>
        </trans-unit>
        <trans-unit id="7b8da77a2b390601e3adff073821408d13cdbea6" translate="yes" xml:space="preserve">
          <source>The server's checkpointer process automatically performs a checkpoint every so often. A checkpoint is begun every &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt; seconds, or if &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; is about to be exceeded, whichever comes first. The default settings are 5 minutes and 1 GB, respectively. If no WAL has been written since the previous checkpoint, new checkpoints will be skipped even if &lt;code&gt;checkpoint_timeout&lt;/code&gt; has passed. (If WAL archiving is being used and you want to put a lower limit on how often files are archived in order to bound potential data loss, you should adjust the &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; parameter rather than the checkpoint parameters.) It is also possible to force a checkpoint by using the SQL command &lt;code&gt;CHECKPOINT&lt;/code&gt;.</source>
          <target state="translated">Процесс контрольной точки сервера автоматически выполняет контрольную точку время от времени. Контрольная точка &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;запускается&lt;/a&gt; каждые &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt; секунд или в случае превышения max_wal_size , в зависимости от того, что наступит раньше. Настройки по умолчанию - 5 минут и 1 ГБ соответственно. Если с момента предыдущей контрольной точки не было записано ни одного WAL, новые контрольные точки будут пропущены, даже если пройден &lt;code&gt;checkpoint_timeout&lt;/code&gt; . (Если используется архивирование WAL и вы хотите установить более низкий предел &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;частоты&lt;/a&gt; архивирования файлов, чтобы ограничить потенциальную потерю данных, вам следует настроить параметр archive_timeout, а не параметры контрольной точки.) Также можно принудительно установить контрольную точку. с помощью команды SQL &lt;code&gt;CHECKPOINT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c205218c3546e4b301b493a03547b46277844636" translate="yes" xml:space="preserve">
          <source>The server's version number as a string, for example &lt;code&gt;9.6.2&lt;/code&gt;, &lt;code&gt;10.1&lt;/code&gt; or &lt;code&gt;11beta1&lt;/code&gt;, and in numeric form, for example &lt;code&gt;90602&lt;/code&gt; or &lt;code&gt;100001&lt;/code&gt;. These are set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">Номер версии сервера в виде строки, например &lt;code&gt;9.6.2&lt;/code&gt; , &lt;code&gt;10.1&lt;/code&gt; или &lt;code&gt;11beta1&lt;/code&gt; , и в числовой форме, например, &lt;code&gt;90602&lt;/code&gt; или &lt;code&gt;100001&lt;/code&gt; . Они устанавливаются каждый раз, когда вы подключаетесь к базе данных (включая запуск программы), но их можно изменить или сбросить.</target>
        </trans-unit>
        <trans-unit id="5a84cc79fdbb16a887f43ceaad26726c6755ffe1" translate="yes" xml:space="preserve">
          <source>The session default transaction modes can also be set by setting the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt;, and &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrable&lt;/a&gt;. (In fact &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; is just a verbose equivalent for setting these variables with &lt;code&gt;SET&lt;/code&gt;.) This means the defaults can be set in the configuration file, via &lt;code&gt;ALTER DATABASE&lt;/code&gt;, etc. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for more information.</source>
          <target state="translated">Режимы транзакции по умолчанию для сеанса также можно установить, задав параметры конфигурации &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt; , &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt; и &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrable&lt;/a&gt; . (Фактически &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; - это просто подробный эквивалент установки этих переменных с помощью &lt;code&gt;SET&lt;/code&gt; .) Это означает, что значения по умолчанию могут быть установлены в файле конфигурации с помощью &lt;code&gt;ALTER DATABASE&lt;/code&gt; и т. Д. Обратитесь к &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;главе 19&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="2aaa3b9320a8aa3d463da80f8c085ef96d144a67" translate="yes" xml:space="preserve">
          <source>The session default transaction modes can also be set by setting the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt;, and &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrable&lt;/a&gt;. (In fact &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; is just a verbose equivalent for setting these variables with &lt;code&gt;SET&lt;/code&gt;.) This means the defaults can be set in the configuration file, via &lt;code&gt;ALTER DATABASE&lt;/code&gt;, etc. Consult &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6723e0bdad2077d09fd447f64653c3402fb21a9f" translate="yes" xml:space="preserve">
          <source>The session user identifier can be changed only if the initial session user (the &lt;em&gt;authenticated user&lt;/em&gt;) had the superuser privilege. Otherwise, the command is accepted only if it specifies the authenticated user name.</source>
          <target state="translated">Идентификатор пользователя сеанса может быть изменен, только если начальный пользователь сеанса ( &lt;em&gt;аутентифицированный пользователь&lt;/em&gt; ) имел привилегию суперпользователя. В противном случае команда принимается только в том случае, если в ней указано аутентифицированное имя пользователя.</target>
        </trans-unit>
        <trans-unit id="715d310203fd1767744b0e3abc3cbaadfd49947d" translate="yes" xml:space="preserve">
          <source>The session user identifier is initially set to be the (possibly authenticated) user name provided by the client. The current user identifier is normally equal to the session user identifier, but might change temporarily in the context of &lt;code&gt;SECURITY DEFINER&lt;/code&gt; functions and similar mechanisms; it can also be changed by &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;. The current user identifier is relevant for permission checking.</source>
          <target state="translated">Идентификатор пользователя сеанса изначально устанавливается как (возможно, аутентифицированное) имя пользователя, предоставленное клиентом. Идентификатор текущего пользователя обычно совпадает с идентификатором пользователя сеанса, но может временно измениться в контексте функций &lt;code&gt;SECURITY DEFINER&lt;/code&gt; и подобных механизмов; его также можно изменить с помощью &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; . Текущий идентификатор пользователя важен для проверки прав доступа.</target>
        </trans-unit>
        <trans-unit id="94dcf85932be3ca953bb5dbee89cd4f7713067fb" translate="yes" xml:space="preserve">
          <source>The set of database roles a given client connection can connect as is determined by the client authentication setup, as explained in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;. (Thus, a client is not limited to connect as the role matching its operating system user, just as a person's login name need not match his or her real name.) Since the role identity determines the set of privileges available to a connected client, it is important to carefully configure privileges when setting up a multiuser environment.</source>
          <target state="translated">Набор ролей базы данных, к которым может подключаться данное клиентское соединение, определяется настройкой аутентификации клиента, как описано в &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;главе 20&lt;/a&gt; . (Таким образом, клиент не ограничен подключением в качестве роли, соответствующей пользователю операционной системы, так же как имя пользователя не обязательно должно совпадать с его или ее настоящим именем.) Поскольку идентификатор роли определяет набор привилегий, доступных подключенному клиенту, При настройке многопользовательской среды важно тщательно настраивать привилегии.</target>
        </trans-unit>
        <trans-unit id="116c57f39b5a10aa3016899fd490e3422c042da6" translate="yes" xml:space="preserve">
          <source>The set of database roles a given client connection can connect as is determined by the client authentication setup, as explained in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;. (Thus, a client is not limited to connect as the role matching its operating system user, just as a person's login name need not match his or her real name.) Since the role identity determines the set of privileges available to a connected client, it is important to carefully configure privileges when setting up a multiuser environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e7e3efb30616b981cfefa41268aa6951e3d5f2" translate="yes" xml:space="preserve">
          <source>The setting &lt;code&gt;RemoveIPC&lt;/code&gt; in &lt;code&gt;logind.conf&lt;/code&gt; controls whether IPC objects are removed when a user fully logs out. System users are exempt. This setting defaults to on in stock systemd, but some operating system distributions default it to off.</source>
          <target state="translated">Параметр &lt;code&gt;RemoveIPC&lt;/code&gt; в &lt;code&gt;logind.conf&lt;/code&gt; определяет, удаляются ли объекты IPC при полном выходе пользователя из системы. Пользователи системы освобождены от уплаты налогов. Этот параметр по умолчанию включен в стандартной системе systemd, но в некоторых дистрибутивах операционных систем он по умолчанию отключен.</target>
        </trans-unit>
        <trans-unit id="64eba0ac674f39ed469aa292d2c2a8445eebc9f9" translate="yes" xml:space="preserve">
          <source>The setting of some parameters on the standby will need reconfiguration if they have been changed on the primary. For these parameters, the value on the standby must be equal to or greater than the value on the primary. Therefore, if you want to increase these values, you should do so on all standby servers first, before applying the changes to the primary server. Conversely, if you want to decrease these values, you should do so on the primary server first, before applying the changes to all standby servers. If these parameters are not set high enough then the standby will refuse to start. Higher values can then be supplied and the server restarted to begin recovery again. These parameters are:</source>
          <target state="translated">Настройка некоторых параметров в режиме ожидания потребует переконфигурации,если они были изменены на первичном.Для этих параметров значение в режиме ожидания должно быть равно или больше значения на первичном.Поэтому,если вы хотите увеличить эти значения,вы должны сделать это сначала на всех резервных серверах,прежде чем применять изменения на основном сервере.И наоборот,если вы хотите уменьшить эти значения,вы должны сделать это сначала на основном сервере,перед применением изменений на всех резервных серверах.Если эти параметры не будут установлены достаточно высоко,то резервный сервер откажется запускаться.Более высокие значения могут быть установлены,и сервер перезапустится,чтобы начать восстановление заново.Этими параметрами являются:</target>
        </trans-unit>
        <trans-unit id="8f66060d984a3d43717aaa1c8e7136685e2e6d1f" translate="yes" xml:space="preserve">
          <source>The shared lock table tracks locks on &lt;code&gt;max_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has historically proven sufficient, but you might need to raise this value if you have queries that touch many different tables in a single transaction, e.g. query of a parent table with many children. This parameter can only be set at server start.</source>
          <target state="translated">Общая таблица блокировок отслеживает блокировки на &lt;code&gt;max_locks_per_transaction&lt;/code&gt; * ( &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt; ) (например, таблицах); следовательно, одновременно может быть заблокировано не более этого множества различных объектов. Этот параметр контролирует среднее количество блокировок объектов, выделяемых для каждой транзакции; отдельные транзакции могут блокировать больше объектов, если блокировки всех транзакций помещаются в таблицу блокировок. Это &lt;em&gt;не&lt;/em&gt;количество строк, которые можно заблокировать; это значение не ограничено. Значение по умолчанию, 64, исторически оказалось достаточным, но вам может потребоваться поднять это значение, если у вас есть запросы, которые касаются многих различных таблиц в одной транзакции, например, запрос родительской таблицы с множеством дочерних элементов. Этот параметр можно установить только при запуске сервера.</target>
        </trans-unit>
        <trans-unit id="f3a2293e6351084a16aac1acbf3842262fd1322f" translate="yes" xml:space="preserve">
          <source>The shared lock table tracks locks on &lt;code&gt;max_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has historically proven sufficient, but you might need to raise this value if you have queries that touch many different tables in a single transaction, e.g., query of a parent table with many children. This parameter can only be set at server start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8d27015cd393d0e4d2ed8b1d7004db3e56b61f" translate="yes" xml:space="preserve">
          <source>The shared memory size settings can be changed via the &lt;code&gt;sysctl&lt;/code&gt; interface. For example, to allow 16 GB:</source>
          <target state="translated">Параметры размера разделяемой памяти можно изменить через интерфейс &lt;code&gt;sysctl&lt;/code&gt; . Например, чтобы разрешить 16 ГБ:</target>
        </trans-unit>
        <trans-unit id="068843c57f60fb86ac3cb60c430b5300612b2f9d" translate="yes" xml:space="preserve">
          <source>The shared predicate lock table tracks locks on &lt;code&gt;max_pred_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has generally been sufficient in testing, but you might need to raise this value if you have clients that touch many different tables in a single serializable transaction. This parameter can only be set at server start.</source>
          <target state="translated">Общая таблица блокировки предикатов отслеживает блокировки на &lt;code&gt;max_pred_locks_per_transaction&lt;/code&gt; * ( &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt; ) (например, таблицах); следовательно, одновременно может быть заблокировано не более этого множества различных объектов. Этот параметр контролирует среднее количество блокировок объектов, выделяемых для каждой транзакции; отдельные транзакции могут блокировать больше объектов, если блокировки всех транзакций помещаются в таблицу блокировок. Это &lt;em&gt;не&lt;/em&gt; количество строк, которые можно заблокировать; это значение не ограничено. Значение по умолчанию, 64, как правило, было достаточным при тестировании, но вам может потребоваться поднять это значение, если у вас есть клиенты, которые касаются многих разных таблиц в одной сериализуемой транзакции. Этот параметр можно установить только при запуске сервера.</target>
        </trans-unit>
        <trans-unit id="ca5a87d53a78cc8149d60b5d1c35e814aa59a259" translate="yes" xml:space="preserve">
          <source>The shared secrets used when talking securely to the RADIUS server. This must have exactly the same value on the PostgreSQL and RADIUS servers. It is recommended that this be a string of at least 16 characters. This parameter is required.</source>
          <target state="translated">Общие секреты,используемые при безопасном разговоре с сервером RADIUS.Они должны иметь точно такое же значение на серверах PostgreSQL и RADIUS.Рекомендуется,чтобы это была строка,состоящая не менее чем из 16 символов.Этот параметр является обязательным.</target>
        </trans-unit>
        <trans-unit id="1aeeff6b5f410ecdf1f1d99d13f99d22c13ce407" translate="yes" xml:space="preserve">
          <source>The shared secrets used when talking securely to the RADIUS servers. This must have exactly the same value on the PostgreSQL and RADIUS servers. It is recommended that this be a string of at least 16 characters. This parameter is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e38019afd1ad1853e1d01481b88d4b91b8d05a" translate="yes" xml:space="preserve">
          <source>The sharp (&lt;code&gt;#&lt;/code&gt;) sign is a comment delimiter. It may appear at any position in a line. The rest of the line will be skipped.</source>
          <target state="translated">Знак &amp;laquo;острый&amp;raquo; ( &lt;code&gt;#&lt;/code&gt; ) - это разделитель комментариев. Он может появиться в любом месте строки. Остальная часть строки будет пропущена.</target>
        </trans-unit>
        <trans-unit id="67cfcf8acce2ecc45db3a0f17045ee10928b08a1" translate="yes" xml:space="preserve">
          <source>The short procedure for configuring a standby server using this alternative method is as follows. For full details of each step, refer to previous sections as noted.</source>
          <target state="translated">Короткая процедура настройки резервного сервера с помощью этого альтернативного метода выглядит следующим образом.Для получения более подробной информации о каждом шаге,обратитесь к предыдущим разделам,как указано выше.</target>
        </trans-unit>
        <trans-unit id="968f59638db3803d09dafd7e362f7206431f6346" translate="yes" xml:space="preserve">
          <source>The simple comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; compare the lower bounds first, and only if those are equal, compare the upper bounds. These comparisons are not usually very useful for ranges, but are provided to allow B-tree indexes to be constructed on ranges.</source>
          <target state="translated">Простые операторы сравнения &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;=&lt;/code&gt; сначала сравнивают нижние границы, и только если они равны, сравнивают верхние границы. Эти сравнения обычно не очень полезны для диапазонов, но предназначены для того, чтобы индексы B-дерева можно было построить по диапазонам.</target>
        </trans-unit>
        <trans-unit id="8ea620de73d7bb2e034a3dc8ebd2dd0118f06f72" translate="yes" xml:space="preserve">
          <source>The simplest kind of extended statistics tracks &lt;em&gt;functional dependencies&lt;/em&gt;, a concept used in definitions of database normal forms. We say that column &lt;code&gt;b&lt;/code&gt; is functionally dependent on column &lt;code&gt;a&lt;/code&gt; if knowledge of the value of &lt;code&gt;a&lt;/code&gt; is sufficient to determine the value of &lt;code&gt;b&lt;/code&gt;, that is there are no two rows having the same value of &lt;code&gt;a&lt;/code&gt; but different values of &lt;code&gt;b&lt;/code&gt;. In a fully normalized database, functional dependencies should exist only on primary keys and superkeys. However, in practice many data sets are not fully normalized for various reasons; intentional denormalization for performance reasons is a common example. Even in a fully normalized database, there may be partial correlation between some columns, which can be expressed as partial functional dependency.</source>
          <target state="translated">Самый простой вид расширенной статистики отслеживает &lt;em&gt;функциональные зависимости&lt;/em&gt; - концепция, используемая в определениях нормальных форм базы данных. Мы говорим, что столбец &lt;code&gt;b&lt;/code&gt; функционально зависит от столбца &lt;code&gt;a&lt;/code&gt; , если знания значения &lt;code&gt;a&lt;/code&gt; достаточно для определения значения &lt;code&gt;b&lt;/code&gt; , то есть не существует двух строк, имеющих одинаковое значение &lt;code&gt;a&lt;/code&gt; , но разные значения &lt;code&gt;b&lt;/code&gt; .. В полностью нормализованной базе данных функциональные зависимости должны существовать только от первичных ключей и суперключей. Однако на практике многие наборы данных не полностью нормализованы по разным причинам; преднамеренная денормализация по соображениям производительности - распространенный пример. Даже в полностью нормализованной базе данных между некоторыми столбцами может быть частичная корреляция, которая может быть выражена как частичная функциональная зависимость.</target>
        </trans-unit>
        <trans-unit id="218e0e862d91c332c13bb63fca705baa68ee5396" translate="yes" xml:space="preserve">
          <source>The simplest kind of select list is &lt;code&gt;*&lt;/code&gt; which emits all columns that the table expression produces. Otherwise, a select list is a comma-separated list of value expressions (as defined in &lt;a href=&quot;sql-expressions&quot;&gt;Section 4.2&lt;/a&gt;). For instance, it could be a list of column names:</source>
          <target state="translated">Самый простой вид списка выбора - &lt;code&gt;*&lt;/code&gt; , который генерирует все столбцы, создаваемые табличным выражением. В противном случае список выбора представляет собой список выражений значений, разделенных запятыми (как определено в &lt;a href=&quot;sql-expressions&quot;&gt;разделе 4.2&lt;/a&gt; ). Например, это может быть список имен столбцов:</target>
        </trans-unit>
        <trans-unit id="95ff410c0d68dcd6b5d1a3a14a5e05f946ef4e40" translate="yes" xml:space="preserve">
          <source>The simplest option for removing old data is to drop the partition that is no longer necessary:</source>
          <target state="translated">Самый простой способ удаления старых данных-это удалить раздел,который больше не нужен:</target>
        </trans-unit>
        <trans-unit id="9d938ffa1d7d07edb850b5b705fb8034d9885325" translate="yes" xml:space="preserve">
          <source>The size of the block range is determined at index creation time by the &lt;code&gt;pages_per_range&lt;/code&gt; storage parameter. The number of index entries will be equal to the size of the relation in pages divided by the selected value for &lt;code&gt;pages_per_range&lt;/code&gt;. Therefore, the smaller the number, the larger the index becomes (because of the need to store more index entries), but at the same time the summary data stored can be more precise and more data blocks can be skipped during an index scan.</source>
          <target state="translated">Размер диапазона блоков определяется во время создания индекса параметром хранения &lt;code&gt;pages_per_range&lt;/code&gt; . Количество записей указателя будет равно размеру отношения в страницах, деленному на выбранное значение для &lt;code&gt;pages_per_range&lt;/code&gt; . Следовательно, чем меньше число, тем больше становится индекс (из-за необходимости хранить больше записей индекса), но в то же время сохраненные сводные данные могут быть более точными, и во время сканирования индекса можно пропустить больше блоков данных.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
