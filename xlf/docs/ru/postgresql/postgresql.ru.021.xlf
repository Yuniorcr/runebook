<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="99c46fa0bf1c41a332643fa4668a817dafffd6e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;planner/optimizer&lt;/em&gt; takes the (rewritten) query tree and creates a &lt;em&gt;query plan&lt;/em&gt; that will be the input to the &lt;em&gt;executor&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Планировщик / оптимизатор&lt;/em&gt; принимает дерево (переписано) запроса и создает &lt;em&gt;план запроса&lt;/em&gt; , который будет вкладом в &lt;em&gt;исполнителю&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f0bfc85eac5f506c4396fe64f83cd201f163702b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rewrite system&lt;/em&gt; takes the query tree created by the parser stage and looks for any &lt;em&gt;rules&lt;/em&gt; (stored in the &lt;em&gt;system catalogs&lt;/em&gt;) to apply to the query tree. It performs the transformations given in the &lt;em&gt;rule bodies&lt;/em&gt;.</source>
          <target state="translated">Система &lt;em&gt;перезаписи&lt;/em&gt; берет дерево запросов, созданное на этапе синтаксического анализа, и ищет любые &lt;em&gt;правила&lt;/em&gt; (хранящиеся в &lt;em&gt;системных каталогах&lt;/em&gt; ), которые можно применить к дереву запросов. Он выполняет преобразования, указанные в &lt;em&gt;телах правил&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="daa9a547059ab18709c7d9a8b34e0eb273fde26d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;transformation process&lt;/em&gt; does modifications and augmentations to the data structures returned by the parser.</source>
          <target state="translated">В &lt;em&gt;процессе преобразования&lt;/em&gt; вносятся изменения и дополнения в структуры данных, возвращаемые анализатором.</target>
        </trans-unit>
        <trans-unit id="6005c8d6a8d942aa977decf6b60a95978aaf5aab" translate="yes" xml:space="preserve">
          <source>The API for constructing generic WAL records is defined in &lt;code&gt;access/generic_xlog.h&lt;/code&gt; and implemented in &lt;code&gt;access/transam/generic_xlog.c&lt;/code&gt;.</source>
          <target state="translated">API для создания общих записей WAL определен в &lt;code&gt;access/generic_xlog.h&lt;/code&gt; и реализован в &lt;code&gt;access/transam/generic_xlog.c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaa78d1712bc527d8b8229b7cb39f829dcef0b7a" translate="yes" xml:space="preserve">
          <source>The B-tree operator family this entry sorts according to, if an ordering operator; zero if a search operator</source>
          <target state="translated">Семейство операторов B-дерева эта запись сортируется в соответствии с,если оператор заказа;ноль,если оператор поиска</target>
        </trans-unit>
        <trans-unit id="4717590c35f3a3113f7d473dbe7410d944c8d2f4" translate="yes" xml:space="preserve">
          <source>The BRIN interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The BRIN layer itself takes care of concurrency, logging and searching the index structure.</source>
          <target state="translated">Интерфейс BRIN имеет высокий уровень абстракции,требующий от исполнителя метода доступа только реализации семантики запрашиваемого типа данных.Сам слой BRIN заботится о параллельности,протоколировании и поиске структуры индекса.</target>
        </trans-unit>
        <trans-unit id="12f1f91360cdc7254651ab3db114c105bbc973aa" translate="yes" xml:space="preserve">
          <source>The BRIN operator classes included in the standard distribution are documented in &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 67.1&lt;/a&gt;. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/12/brin.html&quot;&gt;Chapter 67&lt;/a&gt;.</source>
          <target state="translated">Классы операторов BRIN, включенные в стандартный дистрибутив, задокументированы в &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Таблице 67.1&lt;/a&gt; . Для получения дополнительной информации см. &lt;a href=&quot;https://www.postgresql.org/docs/12/brin.html&quot;&gt;Главу 67&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81c19a64f78d13b55febf5112697413cfeeb5aad" translate="yes" xml:space="preserve">
          <source>The BRIN operator classes included in the standard distribution are documented in &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 67.1&lt;/a&gt;. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/13/brin.html&quot;&gt;Chapter 67&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61d2e62e5b85bf8f1a9692cb79be49a20ae4934" translate="yes" xml:space="preserve">
          <source>The DNS names or IP addresses of the RADIUS servers to connect to. This parameter is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d73c5606dbc5d228281af7029fd60e51759995" translate="yes" xml:space="preserve">
          <source>The Double Metaphone system computes two &amp;ldquo;sounds like&amp;rdquo; strings for a given input string &amp;mdash; a &amp;ldquo;primary&amp;rdquo; and an &amp;ldquo;alternate&amp;rdquo;. In most cases they are the same, but for non-English names especially they can be a bit different, depending on pronunciation. These functions compute the primary and alternate codes:</source>
          <target state="translated">Система Double Metaphone вычисляет две &amp;laquo;звуковые&amp;raquo; строки для данной входной строки - &amp;laquo;основную&amp;raquo; и &amp;laquo;альтернативную&amp;raquo;. В большинстве случаев они одинаковы, но особенно для неанглийских имен они могут немного отличаться в зависимости от произношения. Эти функции вычисляют основной и альтернативный коды:</target>
        </trans-unit>
        <trans-unit id="c8af7d6c825c894dd0eb03ecb26fae46fecd94c6" translate="yes" xml:space="preserve">
          <source>The Free Space Map is organized as a tree of FSM pages. The bottom level FSM pages store the free space available on each heap (or index) page, using one byte to represent each such page. The upper levels aggregate information from the lower levels.</source>
          <target state="translated">Карта свободного пространства организована в виде дерева страниц FSM.На страницах FSM нижнего уровня хранится свободное пространство,доступное на каждой куче (или в индексе)страниц,используя один байт для представления каждой такой страницы.Верхние уровни объединяют информацию с нижних уровней.</target>
        </trans-unit>
        <trans-unit id="30fb294fef92ba7b2398333f6fd38e60940f0136" translate="yes" xml:space="preserve">
          <source>The GEQO module allows the PostgreSQL query optimizer to support large join queries effectively through non-exhaustive search.</source>
          <target state="translated">Модуль GEQO позволяет оптимизатору PostgreSQL запросов эффективно поддерживать большие запросы на присоединение с помощью неисчерпывающего поиска.</target>
        </trans-unit>
        <trans-unit id="9943a2120bd9e8c3e6721e67541600ca21fe96fa" translate="yes" xml:space="preserve">
          <source>The GEQO module approaches the query optimization problem as though it were the well-known traveling salesman problem (TSP). Possible query plans are encoded as integer strings. Each string represents the join order from one relation of the query to the next. For example, the join tree</source>
          <target state="translated">Модуль GEQO подходит к проблеме оптимизации запросов так,как будто это известная проблема продавцов путешествий (TSP).Возможные планы запросов кодируются в виде целочисленных строк.Каждая строка представляет собой порядок соединения от одного отношения запроса к другому.Например,дерево соединения</target>
        </trans-unit>
        <trans-unit id="a13542c5aa9b5acc83ba91d19d31a9262ad99881" translate="yes" xml:space="preserve">
          <source>The GEQO planning process uses the standard planner code to generate plans for scans of individual relations. Then join plans are developed using the genetic approach. As shown above, each candidate join plan is represented by a sequence in which to join the base relations. In the initial stage, the GEQO code simply generates some possible join sequences at random. For each join sequence considered, the standard planner code is invoked to estimate the cost of performing the query using that join sequence. (For each step of the join sequence, all three possible join strategies are considered; and all the initially-determined relation scan plans are available. The estimated cost is the cheapest of these possibilities.) Join sequences with lower estimated cost are considered &amp;ldquo;more fit&amp;rdquo; than those with higher cost. The genetic algorithm discards the least fit candidates. Then new candidates are generated by combining genes of more-fit candidates &amp;mdash; that is, by using randomly-chosen portions of known low-cost join sequences to create new sequences for consideration. This process is repeated until a preset number of join sequences have been considered; then the best one found at any time during the search is used to generate the finished plan.</source>
          <target state="translated">В процессе планирования GEQO используется стандартный код планировщика для создания планов сканирования отдельных отношений. Затем планы присоединения разрабатываются с использованием генетического подхода. Как показано выше, каждый план объединения кандидатов представлен последовательностью, в которой необходимо объединить базовые отношения. На начальном этапе код GEQO просто случайным образом генерирует несколько возможных последовательностей соединения. Для каждой рассматриваемой последовательности соединения вызывается стандартный код планировщика, чтобы оценить стоимость выполнения запроса с использованием этой последовательности соединения. (Для каждого шага последовательности соединения рассматриваются все три возможные стратегии соединения; и доступны все первоначально определенные планы сканирования отношений. Расчетная стоимость является самой дешевой из этих возможностей.) Последовательности соединения с более низкой оценочной стоимостью считаются &amp;laquo;больше&amp;raquo; подходят &amp;raquo;, чем у более дорогих.Генетический алгоритм отбрасывает наименее подходящих кандидатов. Затем новые кандидаты генерируются путем объединения генов более подходящих кандидатов, то есть путем использования случайно выбранных частей известных недорогих последовательностей соединения для создания новых последовательностей для рассмотрения. Этот процесс повторяется до тех пор, пока не будет учтено заданное количество последовательностей соединения; тогда лучший из найденных в любой момент во время поиска используется для создания законченного плана.</target>
        </trans-unit>
        <trans-unit id="12d46a50018559dae87055222c8f226b8336aa38" translate="yes" xml:space="preserve">
          <source>The GIN implementation in PostgreSQL is primarily maintained by Teodor Sigaev and Oleg Bartunov. There is more information about GIN on their &lt;a href=&quot;http://www.sai.msu.su/~megera/wiki/Gin&quot;&gt;website&lt;/a&gt;.</source>
          <target state="translated">Реализацию GIN в PostgreSQL в основном поддерживают Теодор Сигаев и Олег Бартунов. Больше информации о GIN можно найти на их &lt;a href=&quot;http://www.sai.msu.su/~megera/wiki/Gin&quot;&gt;сайте&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2e1dce9027c2870a4be78df483750ab0dd368b7" translate="yes" xml:space="preserve">
          <source>The GIN interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The GIN layer itself takes care of concurrency, logging and searching the tree structure.</source>
          <target state="translated">GIN-интерфейс имеет высокий уровень абстракции,требующий от исполнителя метода доступа только реализации семантики используемого типа данных.Сам слой GIN заботится о параллельности,протоколировании и поиске в древовидной структуре.</target>
        </trans-unit>
        <trans-unit id="47e8892c842e09af9d1e34fe3c02e2f04b0f5d8f" translate="yes" xml:space="preserve">
          <source>The GNU Privacy Handbook.</source>
          <target state="translated">Руководство по конфиденциальности GNU.</target>
        </trans-unit>
        <trans-unit id="3d32f64c87806d58fdb89cae3ce39c10adecb6af" translate="yes" xml:space="preserve">
          <source>The High Precision Event Timer (HPET) is the preferred timer on systems where it's available and TSC is not accurate. The timer chip itself is programmable to allow up to 100 nanosecond resolution, but you may not see that much accuracy in your system clock.</source>
          <target state="translated">Высокоточный таймер событий (HPET)является предпочтительным таймером на системах,где он доступен,а TSC не является точным.Сам чип таймера запрограммирован на разрешение до 100 наносекунд,но вы можете не заметить такой высокой точности в системных часах.</target>
        </trans-unit>
        <trans-unit id="daab10f496a1f89a75df255f2cd5f238cad28e22" translate="yes" xml:space="preserve">
          <source>The IP network address types, &lt;code&gt;cidr&lt;/code&gt; and &lt;code&gt;inet&lt;/code&gt;, support the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; as well as the specialized operators and functions shown in &lt;a href=&quot;functions-net#CIDR-INET-OPERATORS-TABLE&quot;&gt;Table 9.38&lt;/a&gt; and &lt;a href=&quot;functions-net#CIDR-INET-FUNCTIONS-TABLE&quot;&gt;Table 9.39&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1ae3a20afea53927e5a775df1db6e7daba0537" translate="yes" xml:space="preserve">
          <source>The ISO 8601 week-numbering year that the date falls in (not applicable to intervals)</source>
          <target state="translated">ИСО 8601 год с номером недели,в котором дата выпадает (не применимо к интервалам).</target>
        </trans-unit>
        <trans-unit id="a2f552c0c2f33843207363b12ed183813abd32ee" translate="yes" xml:space="preserve">
          <source>The Identification Protocol is not intended as an authorization or access control protocol.</source>
          <target state="translated">Протокол идентификации не предназначен в качестве протокола авторизации или контроля доступа.</target>
        </trans-unit>
        <trans-unit id="34d3089a14d3fce4ff8f4421c9f8177fa0b6d74c" translate="yes" xml:space="preserve">
          <source>The Institute of Automatic Control at the University of Mining and Technology, in Freiberg, Germany, encountered some problems when it wanted to use PostgreSQL as the backend for a decision support knowledge based system for the maintenance of an electrical power grid. The DBMS needed to handle large join queries for the inference machine of the knowledge based system. The number of joins in these queries made using the normal query optimizer infeasible.</source>
          <target state="translated">Институт автоматического управления при Горно-технологическом университете во Фрайберге (Германия)столкнулся с некоторыми проблемами,когда захотел использовать PostgreSQL в качестве бэкэнда для основанной на знаниях системы поддержки принятия решений при обслуживании электросетей.СУБД должна была обрабатывать большие запросы по соединению для машины вывода системы,основанной на знаниях.Количество соединений в этих запросах,выполненных с использованием обычного оптимизатора запросов,было невозможно.</target>
        </trans-unit>
        <trans-unit id="aa9845a0dd3274b254c00b6f19f94269db7f2403" translate="yes" xml:space="preserve">
          <source>The Ispell dictionary template supports &lt;em&gt;morphological dictionaries&lt;/em&gt;, which can normalize many different linguistic forms of a word into the same lexeme. For example, an English Ispell dictionary can match all declensions and conjugations of the search term &lt;code&gt;bank&lt;/code&gt;, e.g., &lt;code&gt;banking&lt;/code&gt;, &lt;code&gt;banked&lt;/code&gt;, &lt;code&gt;banks&lt;/code&gt;, &lt;code&gt;banks'&lt;/code&gt;, and &lt;code&gt;bank's&lt;/code&gt;.</source>
          <target state="translated">Шаблон словаря Ispell поддерживает &lt;em&gt;морфологические словари&lt;/em&gt; , которые могут нормализовать множество различных лингвистических форм слова в одну и ту же лексему. Например, английский словарь Ispell может сопоставить все склонения и спряжения в поисковом запросе &lt;code&gt;bank&lt;/code&gt; , например, &lt;code&gt;banking&lt;/code&gt; , &lt;code&gt;banked&lt;/code&gt; , &lt;code&gt;banks&lt;/code&gt; , &lt;code&gt;banks'&lt;/code&gt; и &lt;code&gt;bank's&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="282b226a01a92e56fbbd4540780287fee9277216" translate="yes" xml:space="preserve">
          <source>The Julian calendar was introduced by Julius Caesar in 45 BC. It was in common use in the Western world until the year 1582, when countries started changing to the Gregorian calendar. In the Julian calendar, the tropical year is approximated as 365 1/4 days = 365.25 days. This gives an error of about 1 day in 128 years.</source>
          <target state="translated">Юлианский календарь был введен Юлием Цезарем в 45 году до нашей эры.Он широко применялся в западном мире до 1582 года,когда страны начали переходить на григорианский календарь.В юлианском календаре тропический год приблизительно равен 365 1/4 дням=365,25 дням.Это дает погрешность примерно в 1 день за 128 лет.</target>
        </trans-unit>
        <trans-unit id="2e4c29ef7c0e6bc4328db2d150be07eebedb7c84" translate="yes" xml:space="preserve">
          <source>The LSN at which replay must begin on the indicated timeline in order to make use of this backup. The LSN is stored in the format normally used by PostgreSQL; that is, it is a string consisting of two strings of hexadecimal characters, each with a length of between 1 and 8, separated by a slash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cde8e59b22c9d6c409e59a264cd6d5133433aa8" translate="yes" xml:space="preserve">
          <source>The Locking Clause</source>
          <target state="translated">Клаузула о блокировке</target>
        </trans-unit>
        <trans-unit id="813d5e4d57613a4c405c690aaab6fce9270d1bf4" translate="yes" xml:space="preserve">
          <source>The MAC address types, &lt;code&gt;macaddr&lt;/code&gt; and &lt;code&gt;macaddr8&lt;/code&gt;, support the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; as well as the specialized functions shown in &lt;a href=&quot;functions-net#MACADDR-FUNCTIONS-TABLE&quot;&gt;Table 9.40&lt;/a&gt;. In addition, they support the bitwise logical operators &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt; (NOT, AND and OR), just as shown above for IP addresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aaa9a5d10023ba2866dd37afda193155af0f247" translate="yes" xml:space="preserve">
          <source>The MCV list gives the planner more detailed information about the specific values that commonly appear in the table, as well as an upper bound on the selectivities of combinations of values that do not appear in the table, allowing it to generate better estimates in both cases.</source>
          <target state="translated">Список MCV дает проектировщику более подробную информацию о конкретных значениях,которые обычно появляются в таблице,а также верхнюю границу по выбору комбинаций значений,которые не появляются в таблице,что позволяет ему генерировать более качественные оценки в обоих случаях.</target>
        </trans-unit>
        <trans-unit id="55e485d087fdc5b4b841601869e3bb93e6bf3639" translate="yes" xml:space="preserve">
          <source>The MD5 Message-Digest Algorithm.</source>
          <target state="translated">Алгоритм сообщений MD5.</target>
        </trans-unit>
        <trans-unit id="2127ad6c429aa49a235fd761eacdf2db8d6f6769" translate="yes" xml:space="preserve">
          <source>The Nagios plugin check_pgsql will work, because the simple information it checks for exists. The check_postgres monitoring script will also work, though some reported values could give different or confusing results. For example, last vacuum time will not be maintained, since no vacuum occurs on the standby. Vacuums running on the primary do still send their changes to the standby.</source>
          <target state="translated">Плагин Nagios check_pgsql будет работать,потому что простая информация,которую он проверяет,существует.Скрипт мониторинга Check_postgres также будет работать,хотя некоторые сообщаемые значения могут давать разные или запутанные результаты.Например,последнее время вакуума не будет поддерживаться,так как в режиме ожидания вакуум не возникает.Вакуумы,работающие на первичном,все еще посылают свои изменения в режим ожидания.</target>
        </trans-unit>
        <trans-unit id="5e71865447d6bc9ea383afd7d76b7761f19aa1b6" translate="yes" xml:space="preserve">
          <source>The OID alias types do not completely follow transaction isolation rules. The planner also treats them as simple constants, which may result in sub-optimal planning.</source>
          <target state="translated">Типы псевдонимов OID не полностью соответствуют правилам изоляции транзакций.Планировщик также рассматривает их как простые константы,что может привести к неоптимальному планированию.</target>
        </trans-unit>
        <trans-unit id="31161126282561c5d74d32ce529fddd65e0a76bd" translate="yes" xml:space="preserve">
          <source>The OID alias types have no operations of their own except for specialized input and output routines. These routines are able to accept and display symbolic names for system objects, rather than the raw numeric value that type &lt;code&gt;oid&lt;/code&gt; would use. The alias types allow simplified lookup of OID values for objects. For example, to examine the &lt;code&gt;pg_attribute&lt;/code&gt; rows related to a table &lt;code&gt;mytable&lt;/code&gt;, one could write:</source>
          <target state="translated">Типы псевдонимов OID не имеют собственных операций, за исключением специализированных процедур ввода и вывода. Эти подпрограммы могут принимать и отображать символические имена для системных объектов, а не исходное числовое значение, которое будет использовать тип &lt;code&gt;oid&lt;/code&gt; . Типы псевдонимов позволяют упростить поиск значений OID для объектов. Например, чтобы проверить строки &lt;code&gt;pg_attribute&lt;/code&gt; , относящиеся к таблице &lt;code&gt;mytable&lt;/code&gt; , можно написать:</target>
        </trans-unit>
        <trans-unit id="1f728998e1513edf5bb0f58e995427e26f8967db" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for the default partition of this partitioned table, or zero if this partitioned table does not have a default partition.</source>
          <target state="translated">OID записи &lt;code&gt;pg_class&lt;/code&gt; для раздела по умолчанию этой многораздельной таблицы или ноль, если эта многораздельная таблица не имеет раздела по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0e41c17d955ca3267fc3e0f5f9ba923e41ea0513" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for the table this index is for</source>
          <target state="translated">OID записи &lt;code&gt;pg_class&lt;/code&gt; для таблицы, для которой предназначен этот индекс</target>
        </trans-unit>
        <trans-unit id="071dd0d457f9f27d9bee0d2e3ff6291a6f564862" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this index</source>
          <target state="translated">OID записи &lt;code&gt;pg_class&lt;/code&gt; для этого индекса</target>
        </trans-unit>
        <trans-unit id="f5a48c524de61d425315c3640ed2f8c5273484e3" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this partitioned table</source>
          <target state="translated">OID записи &lt;code&gt;pg_class&lt;/code&gt; для этой многораздельной таблицы</target>
        </trans-unit>
        <trans-unit id="eda438d49a92e642ba61a005c3405da4f9f1c62a" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this sequence</source>
          <target state="translated">OID записи &lt;code&gt;pg_class&lt;/code&gt; для этой последовательности</target>
        </trans-unit>
        <trans-unit id="303197c3c31b1c60eee9019793731af72e0dc006" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_ts_config&lt;/code&gt; entry owning this map entry</source>
          <target state="translated">OID записи &lt;code&gt;pg_ts_config&lt;/code&gt; , владеющей этой записью карты</target>
        </trans-unit>
        <trans-unit id="f8bdb5895be29901070dfef3e22b4e60f7c2d267" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_type&lt;/code&gt; entry owning this enum value</source>
          <target state="translated">OID записи &lt;code&gt;pg_type&lt;/code&gt; , владеющей этим значением перечисления</target>
        </trans-unit>
        <trans-unit id="a977c33ead1b2b309c764b95248966dbf41f0217" translate="yes" xml:space="preserve">
          <source>The OID of the child table</source>
          <target state="translated">Детский столик с OID</target>
        </trans-unit>
        <trans-unit id="fcb128bef4bb51d558b2cbbe176487c983a3358d" translate="yes" xml:space="preserve">
          <source>The OID of the child table or index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ebd50be09b18866cd4d57833179194c831f037b" translate="yes" xml:space="preserve">
          <source>The OID of the data type that corresponds to this table's row type, if any (zero for indexes, which have no &lt;code&gt;pg_type&lt;/code&gt; entry)</source>
          <target state="translated">OID типа данных, который соответствует типу строки этой таблицы, если таковой имеется (ноль для индексов, которые не &lt;code&gt;pg_type&lt;/code&gt; записи pg_type )</target>
        </trans-unit>
        <trans-unit id="b8b4662cb4e6288ca284849c4be148da66825b82" translate="yes" xml:space="preserve">
          <source>The OID of the database the dependent object is in, or zero for a shared object</source>
          <target state="translated">OID базы данных,в которой находится зависимый объект,или ноль для общего объекта.</target>
        </trans-unit>
        <trans-unit id="898b60ec7f694b0fc006eda8e50f6b63d49620a6" translate="yes" xml:space="preserve">
          <source>The OID of the database the setting is applicable to, or zero if not database-specific</source>
          <target state="translated">OID базы данных,к которой эта установка применима,или ноль,если она не специфична для базы данных.</target>
        </trans-unit>
        <trans-unit id="61af788beaa116f1b955c318390c380729eb624f" translate="yes" xml:space="preserve">
          <source>The OID of the database this slot is associated with, or null. Only logical slots have an associated database.</source>
          <target state="translated">OID базы данных,с которой связан этот слот,или нулевой.Только логические слоты имеют ассоциированную БД.</target>
        </trans-unit>
        <trans-unit id="dffe34cbcb64c59bdcb3677d3a1fd7a1a7165871" translate="yes" xml:space="preserve">
          <source>The OID of the foreign server that contains this mapping</source>
          <target state="translated">OID иностранного сервера,который содержит это отображение.</target>
        </trans-unit>
        <trans-unit id="5048d68506cd122e63f767db512f5ebd84d67ed5" translate="yes" xml:space="preserve">
          <source>The OID of the function to use to perform this cast. Zero is stored if the cast method doesn't require a function.</source>
          <target state="translated">OID функции,используемой для выполнения этого слепка.Ноль сохраняется,если метод приведения не требует наличия функции.</target>
        </trans-unit>
        <trans-unit id="59c37f70d3d21e1cf2530f6e69c1cd78c664862f" translate="yes" xml:space="preserve">
          <source>The OID of the function to use when converting output from the procedural language (e.g., return values) to the data type. Zero is stored if this operation is not supported.</source>
          <target state="translated">OID функции для использования при преобразовании вывода из процедурного языка (например,возвращаемых значений)в тип данных.Ноль сохраняется,если эта операция не поддерживается.</target>
        </trans-unit>
        <trans-unit id="b438ec49041a86ff7da5085d6d696fab9858a564" translate="yes" xml:space="preserve">
          <source>The OID of the function to use when converting the data type for input to the procedural language (e.g., function parameters). Zero is stored if this operation is not supported.</source>
          <target state="translated">OID функции для использования при преобразовании типа данных для ввода на процедурном языке (например,параметры функции).Ноль сохраняется,если эта операция не поддерживается.</target>
        </trans-unit>
        <trans-unit id="8427c56037bb672e3eaf5c784fadd5373d00c50d" translate="yes" xml:space="preserve">
          <source>The OID of the large object.</source>
          <target state="translated">OID большого объекта.</target>
        </trans-unit>
        <trans-unit id="aa257a5cc909f035b6b365a8de79171496abef73" translate="yes" xml:space="preserve">
          <source>The OID of the namespace associated with this entry, or 0 if none</source>
          <target state="translated">OID пространства имён,связанного с этой записью,или 0,если нет.</target>
        </trans-unit>
        <trans-unit id="3c9f55892a56c80828f11ba8da0cec8b6667ea0f" translate="yes" xml:space="preserve">
          <source>The OID of the namespace for this object, if applicable; otherwise NULL.</source>
          <target state="translated">OID пространства имен для этого объекта,если применимо;в противном случае NULL.</target>
        </trans-unit>
        <trans-unit id="6544239c27c8b98d678c4d86cd8cf2fb4a45d909" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this collation</source>
          <target state="translated">OID пространства имён,которое содержит эту сверку.</target>
        </trans-unit>
        <trans-unit id="67632f7b86c5d28c986c07563f79e9f57ab7488a" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this configuration</source>
          <target state="translated">OID пространства имен,которое содержит эту конфигурацию.</target>
        </trans-unit>
        <trans-unit id="f78b68f0e0d540debab34518ee53138dd78afc9d" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this constraint</source>
          <target state="translated">OID пространства имен,которое содержит это ограничение.</target>
        </trans-unit>
        <trans-unit id="26651bac2ebe9b8df63182bb4f09e8b29d4375b5" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this conversion</source>
          <target state="translated">OID пространства имен,которое содержит это преобразование.</target>
        </trans-unit>
        <trans-unit id="58fcc7c98890e8c2834e53212732cd77ac260148" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this dictionary</source>
          <target state="translated">OID пространства имён,которое содержит этот словарь...</target>
        </trans-unit>
        <trans-unit id="0ffa036dc5da9392b5ff92b8de19382988ae095b" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this function</source>
          <target state="translated">OID пространства имен,которое содержит эту функцию.</target>
        </trans-unit>
        <trans-unit id="4836cfb15733aecb9038935daa22b144847fa0b0" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this operator</source>
          <target state="translated">OID пространства имен,которое содержит этот оператор</target>
        </trans-unit>
        <trans-unit id="bd2956b2c54813a0f702f1bbd1860a3130d1cd13" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this parser</source>
          <target state="translated">OID пространства имен,которое содержит этот синтаксический анализатор.</target>
        </trans-unit>
        <trans-unit id="4fa4ff9a62cc6b391718b0f0a2fcbd7ba489a8a1" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this relation</source>
          <target state="translated">OID пространства имён,которое содержит это отношение.</target>
        </trans-unit>
        <trans-unit id="f3b00f8f6b6908679ca83ef8448db4669f9c3f2b" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this statistics object</source>
          <target state="translated">OID пространства имен,которое содержит этот объект статистики.</target>
        </trans-unit>
        <trans-unit id="0eccd6202b6e25a82e3cb731c01941486b802fde" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this template</source>
          <target state="translated">OID пространства имен,которое содержит этот шаблон.</target>
        </trans-unit>
        <trans-unit id="2ad5e85b9c67d0c9e6855e2f98983c857e3e9cc9" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this type</source>
          <target state="translated">OID пространства имен,которое содержит этот тип</target>
        </trans-unit>
        <trans-unit id="4da576b45acb3f961f666fac031b8e0b7887d94a" translate="yes" xml:space="preserve">
          <source>The OID of the object this description pertains to</source>
          <target state="translated">OID объекта,к которому относится это описание.</target>
        </trans-unit>
        <trans-unit id="92fb8b43568522d54e99e8435ff353f995d4d31c" translate="yes" xml:space="preserve">
          <source>The OID of the object this security label pertains to</source>
          <target state="translated">OID объекта,к которому относится эта метка безопасности.</target>
        </trans-unit>
        <trans-unit id="0002c6e72af222de4cb8c506a6f1bc7c20ab1dc4" translate="yes" xml:space="preserve">
          <source>The OID of the parent table</source>
          <target state="translated">OID родительской таблицы</target>
        </trans-unit>
        <trans-unit id="2b333512ca9c37807a07a256f4818991b100a615" translate="yes" xml:space="preserve">
          <source>The OID of the parent table or index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ffd02286699ef3905e8a972c66ee4bb2835bfc" translate="yes" xml:space="preserve">
          <source>The OID of the role associated with this entry</source>
          <target state="translated">УОР роли,связанной с этой записью.</target>
        </trans-unit>
        <trans-unit id="c0915654e58b310d5210b25d19abfd7806a843de" translate="yes" xml:space="preserve">
          <source>The OID of the role the setting is applicable to, or zero if not role-specific</source>
          <target state="translated">OID роли,к которой эта настройка применима,или ноль,если она не специфична для этой роли</target>
        </trans-unit>
        <trans-unit id="c9f3ec9e29e6e5e35e198f85cfeb26802f0a6d99" translate="yes" xml:space="preserve">
          <source>The OID of the specific dependent object</source>
          <target state="translated">OID конкретного зависимого объекта</target>
        </trans-unit>
        <trans-unit id="b9087659abb5a8df685a282e464694231a05c905" translate="yes" xml:space="preserve">
          <source>The OID of the specific object</source>
          <target state="translated">OID конкретного объекта</target>
        </trans-unit>
        <trans-unit id="9442b82a85ff19f9d0307346795cdb1c1390d555" translate="yes" xml:space="preserve">
          <source>The OID of the specific referenced object</source>
          <target state="translated">OID конкретного упоминаемого объекта</target>
        </trans-unit>
        <trans-unit id="3b6fda1c623aa2d59a074893167f643c66f63048" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the dependent object is in</source>
          <target state="translated">OID системного каталога,в котором находится зависимый объект.</target>
        </trans-unit>
        <trans-unit id="45c628ea8dfbe9deffe2a6beca65b182150c549a" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the object is in</source>
          <target state="translated">OID системного каталога объект находится в</target>
        </trans-unit>
        <trans-unit id="651df0c1a82da14b1a69c5c748c986ddebc8aa71" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the referenced object is in</source>
          <target state="translated">OID системного каталога объект,на который делается ссылка,находится в</target>
        </trans-unit>
        <trans-unit id="b623975e8da0f35427faa44f2916bd8169911114" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the referenced object is in (must be a shared catalog)</source>
          <target state="translated">OID системного каталога,в котором находится объект,на который делается ссылка (должен быть общий каталог).</target>
        </trans-unit>
        <trans-unit id="d29abf904f17279c11d42dc4f5568269360fdcb9" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog this object appears in</source>
          <target state="translated">OID системного каталога этого объекта появляется в</target>
        </trans-unit>
        <trans-unit id="067e884e18cd2aa571279cd559f882f0cf4ff2a1" translate="yes" xml:space="preserve">
          <source>The OID of the table containing this row. This column is particularly handy for queries that select from inheritance hierarchies (see &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt;), since without it, it's difficult to tell which individual table a row came from. The &lt;code&gt;tableoid&lt;/code&gt; can be joined against the &lt;code&gt;oid&lt;/code&gt; column of &lt;code&gt;pg_class&lt;/code&gt; to obtain the table name.</source>
          <target state="translated">OID таблицы, содержащей эту строку. Этот столбец особенно удобен для запросов, которые выбирают из иерархий наследования (см. &lt;a href=&quot;ddl-inherit&quot;&gt;Раздел 5.10&lt;/a&gt; ), поскольку без него трудно определить, из какой отдельной таблицы была взята строка. &lt;code&gt;tableoid&lt;/code&gt; могут быть соединены по отношению к &lt;code&gt;oid&lt;/code&gt; колонке &lt;code&gt;pg_class&lt;/code&gt; , чтобы получить имя таблицы.</target>
        </trans-unit>
        <trans-unit id="6a0b9e6d63b6cf8a833e5a7e3f6047bb0a93a945" translate="yes" xml:space="preserve">
          <source>The OID of the text search dictionary to consult</source>
          <target state="translated">OID словаря текстового поиска для консультации</target>
        </trans-unit>
        <trans-unit id="b6ba84785ad334e01b83ec445d3dda1ac4ac96bb" translate="yes" xml:space="preserve">
          <source>The OID of the text search parser for this configuration</source>
          <target state="translated">OID парсера текстового поиска для этой конфигурации</target>
        </trans-unit>
        <trans-unit id="a117213bd13a98b62f97b549d2037dd5baede006" translate="yes" xml:space="preserve">
          <source>The OID of the text search template for this dictionary</source>
          <target state="translated">OID шаблона текстового поиска для этого словаря</target>
        </trans-unit>
        <trans-unit id="58df61b40061f6a6618e8266483da7f989d95f26" translate="yes" xml:space="preserve">
          <source>The OIDs for &lt;code&gt;pg_enum&lt;/code&gt; rows follow a special rule: even-numbered OIDs are guaranteed to be ordered in the same way as the sort ordering of their enum type. That is, if two even OIDs belong to the same enum type, the smaller OID must have the smaller &lt;code&gt;enumsortorder&lt;/code&gt; value. Odd-numbered OID values need bear no relationship to the sort order. This rule allows the enum comparison routines to avoid catalog lookups in many common cases. The routines that create and alter enum types attempt to assign even OIDs to enum values whenever possible.</source>
          <target state="translated">Идентификаторы OID для строк &lt;code&gt;pg_enum&lt;/code&gt; подчиняются особому правилу: четные идентификаторы OID гарантированно упорядочиваются таким же образом, как и порядок сортировки их перечислимого типа. То есть, если два четных OID принадлежат одному и тому же типу перечисления, меньший OID должен иметь меньшее значение &lt;code&gt;enumsortorder&lt;/code&gt; . Нечетные значения OID не должны иметь отношения к порядку сортировки. Это правило позволяет подпрограммам сравнения перечислений избегать поиска в каталоге во многих распространенных случаях. Подпрограммы, которые создают и изменяют типы перечисления, пытаются назначить даже OID значениям перечисления, когда это возможно.</target>
        </trans-unit>
        <trans-unit id="362f3646de7e2bebf05ad74a6325f7165ac1988c" translate="yes" xml:space="preserve">
          <source>The OpenSSL default order for &lt;code&gt;HIGH&lt;/code&gt; is problematic because it orders 3DES higher than AES128. This is wrong because 3DES offers less security than AES128, and it is also much slower. &lt;code&gt;+3DES&lt;/code&gt; reorders it after all other &lt;code&gt;HIGH&lt;/code&gt; and &lt;code&gt;MEDIUM&lt;/code&gt; ciphers.</source>
          <target state="translated">Порядок OpenSSL по умолчанию для &lt;code&gt;HIGH&lt;/code&gt; проблематичен, потому что он упорядочивает 3DES выше, чем AES128. Это неверно, потому что 3DES предлагает меньшую безопасность, чем AES128, а также намного медленнее. &lt;code&gt;+3DES&lt;/code&gt; переупорядочивает его после всех других &lt;code&gt;HIGH&lt;/code&gt; и &lt;code&gt;MEDIUM&lt;/code&gt; шифров.</target>
        </trans-unit>
        <trans-unit id="b73c1bd60aad8104323371d01b1ec1a8338ede73" translate="yes" xml:space="preserve">
          <source>The Oversized-Attribute Storage Technique</source>
          <target state="translated">Техника хранения крупногабаритных грузов.</target>
        </trans-unit>
        <trans-unit id="e0b1bfcde4d47951e13640eda18c565a127fb8e6" translate="yes" xml:space="preserve">
          <source>The POSIX pattern language is described in much greater detail below.</source>
          <target state="translated">Язык шаблонов POSIX более подробно описан ниже.</target>
        </trans-unit>
        <trans-unit id="153ece47c4d9b24a5da118c8706404d098e93a76" translate="yes" xml:space="preserve">
          <source>The PostgreSQL &lt;code&gt;xml&lt;/code&gt; data type can only hold a value in &lt;code&gt;DOCUMENT&lt;/code&gt; or &lt;code&gt;CONTENT&lt;/code&gt; form. An XQuery/XPath expression context item must be a single XML node or atomic value, but XPath 1.0 further restricts it to be only an XML node, and has no node type allowing &lt;code&gt;CONTENT&lt;/code&gt;. The upshot is that a well-formed &lt;code&gt;DOCUMENT&lt;/code&gt; is the only form of XML value that PostgreSQL can supply as an XPath context item.</source>
          <target state="translated">Тип данных PostgreSQL &lt;code&gt;xml&lt;/code&gt; может содержать значение только в форме &lt;code&gt;DOCUMENT&lt;/code&gt; или &lt;code&gt;CONTENT&lt;/code&gt; . Элемент контекста выражения XQuery / XPath должен быть одним узлом XML или атомарным значением, но XPath 1.0 дополнительно ограничивает его только узлом XML и не имеет типа узла, допускающего &lt;code&gt;CONTENT&lt;/code&gt; . В результате правильно сформированный &lt;code&gt;DOCUMENT&lt;/code&gt; - это единственная форма значения XML, которую PostgreSQL может предоставить как элемент контекста XPath.</target>
        </trans-unit>
        <trans-unit id="8019e62373b33be0ae1394da9ad186299d75d149" translate="yes" xml:space="preserve">
          <source>The PostgreSQL concept of tablespaces is not part of the standard. Hence, the clause &lt;code&gt;TABLESPACE&lt;/code&gt; is an extension.</source>
          <target state="translated">Концепция табличных пространств PostgreSQL не является частью стандарта. Следовательно, предложение &lt;code&gt;TABLESPACE&lt;/code&gt; является расширением.</target>
        </trans-unit>
        <trans-unit id="36ca8d540410a034c5a8f32708649004d256e17f" translate="yes" xml:space="preserve">
          <source>The PostgreSQL concept of tablespaces is not part of the standard. Hence, the clauses &lt;code&gt;TABLESPACE&lt;/code&gt; and &lt;code&gt;USING INDEX TABLESPACE&lt;/code&gt; are extensions.</source>
          <target state="translated">Концепция табличных пространств PostgreSQL не является частью стандарта. Следовательно, предложения &lt;code&gt;TABLESPACE&lt;/code&gt; и &lt;code&gt;USING INDEX TABLESPACE&lt;/code&gt; являются расширениями.</target>
        </trans-unit>
        <trans-unit id="74677c1410d0f3c49eba1a7361732a37abea01cf" translate="yes" xml:space="preserve">
          <source>The PostgreSQL formatting functions provide a powerful set of tools for converting various data types (date/time, integer, floating point, numeric) to formatted strings and for converting from formatted strings to specific data types. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-TABLE&quot;&gt;Table 9.24&lt;/a&gt; lists them. These functions all follow a common calling convention: the first argument is the value to be formatted and the second argument is a template that defines the output or input format.</source>
          <target state="translated">Функции форматирования PostgreSQL предоставляют мощный набор инструментов для преобразования различных типов данных (дата / время, целые числа, числа с плавающей запятой, числовые) в форматированные строки и для преобразования из форматированных строк в определенные типы данных. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-TABLE&quot;&gt;В таблице 9.24 они&lt;/a&gt; перечислены. Все эти функции следуют общему соглашению о вызовах: первый аргумент - это форматируемое значение, а второй аргумент - это шаблон, определяющий формат вывода или ввода.</target>
        </trans-unit>
        <trans-unit id="d0224dd17eece7d6f08f80bf4f5c518add98b147" translate="yes" xml:space="preserve">
          <source>The PostgreSQL formatting functions provide a powerful set of tools for converting various data types (date/time, integer, floating point, numeric) to formatted strings and for converting from formatted strings to specific data types. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-TABLE&quot;&gt;Table 9.25&lt;/a&gt; lists them. These functions all follow a common calling convention: the first argument is the value to be formatted and the second argument is a template that defines the output or input format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477d95f901512677a235f7ee46a8f81ecd4001b6" translate="yes" xml:space="preserve">
          <source>The PostgreSQL operator catalog has several entries for the infix operator &lt;code&gt;&amp;lt;@&lt;/code&gt;, but the only two that could possibly accept an integer array on the left-hand side are array inclusion (&lt;code&gt;anyarray&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;anyarray&lt;/code&gt;) and range inclusion (&lt;code&gt;anyelement&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;anyrange&lt;/code&gt;). Since none of these polymorphic pseudo-types (see &lt;a href=&quot;datatype-pseudo&quot;&gt;Section 8.21&lt;/a&gt;) are considered preferred, the parser cannot resolve the ambiguity on that basis. However, &lt;a href=&quot;typeconv-oper#OP-RESOL-LAST-UNKNOWN&quot;&gt;Step 3.f&lt;/a&gt; tells it to assume that the unknown-type literal is of the same type as the other input, that is, integer array. Now only one of the two operators can match, so array inclusion is selected. (Had range inclusion been selected, we would have gotten an error, because the string does not have the right format to be a range literal.)</source>
          <target state="translated">В каталоге операторов PostgreSQL есть несколько записей для инфиксного оператора &lt;code&gt;&amp;lt;@&lt;/code&gt; , но единственные две, которые могли бы принять целочисленный массив с левой стороны, - это включение массива ( &lt;code&gt;anyarray&lt;/code&gt; &lt;code&gt;&amp;lt;@&lt;/code&gt; &lt;code&gt;anyarray&lt;/code&gt; ) и включение диапазона ( &lt;code&gt;anyelement&lt;/code&gt; &lt;code&gt;&amp;lt;@&lt;/code&gt; &lt;code&gt;anyrange&lt;/code&gt; ). Поскольку ни один из этих полиморфных псевдотипов (см. &lt;a href=&quot;datatype-pseudo&quot;&gt;Раздел 8.21&lt;/a&gt; ) не считается предпочтительным, синтаксический анализатор не может разрешить неоднозначность на этом основании. Однако &lt;a href=&quot;typeconv-oper#OP-RESOL-LAST-UNKNOWN&quot;&gt;шаг 3.f&lt;/a&gt;указывает ему предположить, что литерал неизвестного типа имеет тот же тип, что и другой вход, то есть целочисленный массив. Теперь может соответствовать только один из двух операторов, поэтому выбрано включение массива. (Если бы было выбрано включение диапазона, мы получили бы ошибку, потому что строка не имеет правильного формата, чтобы быть литералом диапазона.)</target>
        </trans-unit>
        <trans-unit id="7623f7756c9bed57d74564163e6b686074d22548" translate="yes" xml:space="preserve">
          <source>The PostgreSQL operator catalog has several entries for the prefix operator &lt;code&gt;@&lt;/code&gt;, all of which implement absolute-value operations for various numeric data types. One of these entries is for type &lt;code&gt;float8&lt;/code&gt;, which is the preferred type in the numeric category. Therefore, PostgreSQL will use that entry when faced with an &lt;code&gt;unknown&lt;/code&gt; input:</source>
          <target state="translated">В каталоге операторов PostgreSQL есть несколько записей для префикса operator &lt;code&gt;@&lt;/code&gt; , каждая из которых реализует операции абсолютного значения для различных числовых типов данных. Одна из этих записей предназначена для типа &lt;code&gt;float8&lt;/code&gt; , который является предпочтительным типом в числовой категории. Следовательно, PostgreSQL будет использовать эту запись при обнаружении &lt;code&gt;unknown&lt;/code&gt; ввода:</target>
        </trans-unit>
        <trans-unit id="0de6cec8150a5ca1beb884d1dae8f1be83758f61" translate="yes" xml:space="preserve">
          <source>The PostgreSQL query planner relies on statistical information about the contents of tables in order to generate good plans for queries. These statistics are gathered by the &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; command, which can be invoked by itself or as an optional step in &lt;code&gt;VACUUM&lt;/code&gt;. It is important to have reasonably accurate statistics, otherwise poor choices of plans might degrade database performance.</source>
          <target state="translated">Планировщик запросов PostgreSQL полагается на статистическую информацию о содержимом таблиц, чтобы создавать хорошие планы для запросов. Эти статистические данные собираются командой &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; , которую можно вызвать отдельно или как дополнительный шаг в &lt;code&gt;VACUUM&lt;/code&gt; . Важно иметь достаточно точную статистику, иначе неправильный выбор планов может снизить производительность базы данных.</target>
        </trans-unit>
        <trans-unit id="091f965ebb32941711ea5df90e349daf215494b9" translate="yes" xml:space="preserve">
          <source>The PostgreSQL rule system allows one to define an alternative action to be performed on insertions, updates, or deletions in database tables. Roughly speaking, a rule causes additional commands to be executed when a given command on a given table is executed. Alternatively, an &lt;code&gt;INSTEAD&lt;/code&gt; rule can replace a given command by another, or cause a command not to be executed at all. Rules are used to implement SQL views as well. It is important to realize that a rule is really a command transformation mechanism, or command macro. The transformation happens before the execution of the command starts. If you actually want an operation that fires independently for each physical row, you probably want to use a trigger, not a rule. More information about the rules system is in &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;.</source>
          <target state="translated">Система правил PostgreSQL позволяет определять альтернативные действия, выполняемые при вставке, обновлении или удалении в таблицах базы данных. Грубо говоря, правило вызывает выполнение дополнительных команд при выполнении заданной команды для данной таблицы. В качестве альтернативы правило &lt;code&gt;INSTEAD&lt;/code&gt; может заменить данную команду другой или заставить команду вообще не выполняться. Правила также используются для реализации представлений SQL. Важно понимать, что правило - это действительно механизм преобразования команд или командный макрос. Преобразование происходит до начала выполнения команды. Если вам действительно нужна операция, которая запускается независимо для каждой физической строки, вы, вероятно, захотите использовать триггер, а не правило. Более подробная информация о системе правил находится в &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;главе 40&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e154a2cce3e777e6a59136969a3016037e9c1d8" translate="yes" xml:space="preserve">
          <source>The PostgreSQL rule system allows one to define an alternative action to be performed on insertions, updates, or deletions in database tables. Roughly speaking, a rule causes additional commands to be executed when a given command on a given table is executed. Alternatively, an &lt;code&gt;INSTEAD&lt;/code&gt; rule can replace a given command by another, or cause a command not to be executed at all. Rules are used to implement SQL views as well. It is important to realize that a rule is really a command transformation mechanism, or command macro. The transformation happens before the execution of the command starts. If you actually want an operation that fires independently for each physical row, you probably want to use a trigger, not a rule. More information about the rules system is in &lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;Chapter 40&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a690ef1ea7666469e6c355dbc334d6d1d70eb6" translate="yes" xml:space="preserve">
          <source>The PostgreSQL scanner/parser divides lexical elements into five fundamental categories: integers, non-integer numbers, strings, identifiers, and key words. Constants of most non-numeric types are first classified as strings. The SQL language definition allows specifying type names with strings, and this mechanism can be used in PostgreSQL to start the parser down the correct path. For example, the query:</source>
          <target state="translated">Сканер/парсер PostgreSQL разделяет лексические элементы на пять фундаментальных категорий:целые числа,нецифровые числа,строки,идентификаторы и ключевые слова.Константы большинства нецифровых типов сначала классифицируются как строки.Определение языка SQL позволяет указывать имена типов со строками,и этот механизм может быть использован в PostgreSQL для запуска синтаксического анализатора по правильному пути.Например,запрос:</target>
        </trans-unit>
        <trans-unit id="b6aed6106f2d7424b2bbb821dba77f382392bc5d" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server can handle multiple concurrent connections from clients. To achieve this it starts (&amp;ldquo;forks&amp;rdquo;) a new process for each connection. From that point on, the client and the new server process communicate without intervention by the original &lt;code&gt;postgres&lt;/code&gt; process. Thus, the master server process is always running, waiting for client connections, whereas client and associated server processes come and go. (All of this is of course invisible to the user. We only mention it here for completeness.)</source>
          <target state="translated">Сервер PostgreSQL может обрабатывать несколько одновременных подключений от клиентов. Для этого он запускает (&amp;laquo;разветвляет&amp;raquo;) новый процесс для каждого соединения. С этого момента клиент и новый серверный процесс обмениваются данными без вмешательства исходного процесса &lt;code&gt;postgres&lt;/code&gt; . Таким образом, процесс главного сервера всегда работает, ожидая клиентских подключений, тогда как клиентские и связанные серверные процессы приходят и уходят. (Все это, конечно, невидимо для пользователя. Мы упоминаем это здесь только для полноты.)</target>
        </trans-unit>
        <trans-unit id="7af0f9ca01829c95b3c4cfa20671b04ccaa7a1b4" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server uses one process per connection so you should provide for at least as many processes as allowed connections, in addition to what you need for the rest of your system. This is usually not a problem but if you run several servers on one machine things might get tight.</source>
          <target state="translated">Сервер PostgreSQL использует по одному процессу на каждое соединение,поэтому вы должны обеспечить как минимум столько процессов,сколько разрешено соединений,в дополнение к тому,что вам нужно для остальной части системы.Обычно это не является проблемой,но если вы запустите несколько серверов на одной машине,то все может стать напряженным.</target>
        </trans-unit>
        <trans-unit id="929274b54effcc47ded1784455530166b7871347" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server will listen for both normal and GSSAPI-encrypted connections on the same TCP port, and will negotiate with any connecting client on whether to use GSSAPI for encryption (and for authentication). By default, this decision is up to the client (which means it can be downgraded by an attacker); see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about setting up the server to require the use of GSSAPI for some or all connections.</source>
          <target state="translated">Сервер PostgreSQL будет прослушивать как обычные, так и зашифрованные GSSAPI соединения на одном и том же TCP-порту и согласовывать с любым подключающимся клиентом, использовать ли GSSAPI для шифрования (и для аутентификации). По умолчанию это решение остается за клиентом (что означает, что злоумышленник может понизить его рейтинг); см. &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Раздел 20.1&lt;/a&gt; о настройке сервера, чтобы требовать использования GSSAPI для некоторых или всех подключений.</target>
        </trans-unit>
        <trans-unit id="c912054f27c4ee7b0f1b38b55011027ea73de0d0" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server will listen for both normal and GSSAPI-encrypted connections on the same TCP port, and will negotiate with any connecting client whether to use GSSAPI for encryption (and for authentication). By default, this decision is up to the client (which means it can be downgraded by an attacker); see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about setting up the server to require the use of GSSAPI for some or all connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4cf80f6b7604fb8b47859e4bbfb35130b5f3d5d" translate="yes" xml:space="preserve">
          <source>The PostgreSQL source distribution includes several examples of index methods implemented using GiST. The core system currently provides text search support (indexing for &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;) as well as R-Tree equivalent functionality for some of the built-in geometric data types (see &lt;code&gt;src/backend/access/gist/gistproc.c&lt;/code&gt;). The following &lt;code&gt;contrib&lt;/code&gt; modules also contain GiST operator classes:</source>
          <target state="translated">Исходный код PostgreSQL включает несколько примеров методов индексации, реализованных с использованием GiST. В настоящее время основная система обеспечивает поддержку текстового поиска (индексирование для &lt;code&gt;tsvector&lt;/code&gt; и &lt;code&gt;tsquery&lt;/code&gt; ), а также эквивалентную функциональность R-Tree для некоторых встроенных геометрических типов данных (см. &lt;code&gt;src/backend/access/gist/gistproc.c&lt;/code&gt; ). Следующие модули &lt;code&gt;contrib&lt;/code&gt; также содержат классы операторов GiST:</target>
        </trans-unit>
        <trans-unit id="f0456fd311416d751f4442303736e9783a5f29ea" translate="yes" xml:space="preserve">
          <source>The PostgreSQL source distribution includes several examples of index operator classes for SP-GiST, as described in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;. Look into &lt;code&gt;src/backend/access/spgist/&lt;/code&gt; and &lt;code&gt;src/backend/utils/adt/&lt;/code&gt; to see the code.</source>
          <target state="translated">Исходный код PostgreSQL включает несколько примеров классов операторов индекса для SP-GiST, как описано в &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Таблице 65.1&lt;/a&gt; . Загляните в &lt;code&gt;src/backend/access/spgist/&lt;/code&gt; и &lt;code&gt;src/backend/utils/adt/&lt;/code&gt; чтобы увидеть код.</target>
        </trans-unit>
        <trans-unit id="da6bb87f4fbef7ca2cd7285a5ff15baca5680b91" translate="yes" xml:space="preserve">
          <source>The PostgreSQL type system contains a number of special-purpose entries that are collectively called &lt;em&gt;pseudo-types&lt;/em&gt;. A pseudo-type cannot be used as a column data type, but it can be used to declare a function's argument or result type. Each of the available pseudo-types is useful in situations where a function's behavior does not correspond to simply taking or returning a value of a specific SQL data type. &lt;a href=&quot;datatype-pseudo#DATATYPE-PSEUDOTYPES-TABLE&quot;&gt;Table 8.27&lt;/a&gt; lists the existing pseudo-types.</source>
          <target state="translated">Система типов PostgreSQL содержит ряд записей специального назначения, которые вместе называются &lt;em&gt;псевдотипами&lt;/em&gt; . Псевдотип не может использоваться как тип данных столбца, но его можно использовать для объявления аргумента функции или типа результата. Каждый из доступных псевдотипов полезен в ситуациях, когда поведение функции не соответствует простому получению или возврату значения определенного типа данных SQL. &lt;a href=&quot;datatype-pseudo#DATATYPE-PSEUDOTYPES-TABLE&quot;&gt;В таблице 8.27&lt;/a&gt; перечислены существующие псевдотипы.</target>
        </trans-unit>
        <trans-unit id="3627ccc448cafae762325bbb25d1d00e8338b2f1" translate="yes" xml:space="preserve">
          <source>The PostgreSQL-specific functions &lt;code&gt;xpath()&lt;/code&gt; and &lt;code&gt;xpath_exists()&lt;/code&gt; query XML documents using the XPath language. PostgreSQL also provides XPath-only variants of the standard functions &lt;code&gt;XMLEXISTS&lt;/code&gt; and &lt;code&gt;XMLTABLE&lt;/code&gt;, which officially use the XQuery language. For all of these functions, PostgreSQL relies on the libxml2 library, which provides only XPath 1.0.</source>
          <target state="translated">Специфичные для PostgreSQL функции &lt;code&gt;xpath()&lt;/code&gt; и &lt;code&gt;xpath_exists()&lt;/code&gt; запрашивают XML-документы, используя язык XPath. PostgreSQL также предоставляет варианты стандартных функций &lt;code&gt;XMLEXISTS&lt;/code&gt; и &lt;code&gt;XMLTABLE&lt;/code&gt; только для XPath , которые официально используют язык XQuery. Для всех этих функций PostgreSQL использует библиотеку libxml2, которая предоставляет только XPath 1.0.</target>
        </trans-unit>
        <trans-unit id="efd965ec5103a44f1272738f66a9e9d5dd0aabd5" translate="yes" xml:space="preserve">
          <source>The ROW keyword is actually optional as long as you have more than one field in the expression, so these can be simplified to:</source>
          <target state="translated">Ключевое слово ROW на самом деле является необязательным,если в выражении есть несколько полей,так что их можно упростить:</target>
        </trans-unit>
        <trans-unit id="4adee7e95f5294837cef6adde9f546d2e1f9b70f" translate="yes" xml:space="preserve">
          <source>The Repeatable Read isolation level is implemented using a technique known in academic database literature and in some other database products as &lt;em&gt;Snapshot Isolation&lt;/em&gt;. Differences in behavior and performance may be observed when compared with systems that use a traditional locking technique that reduces concurrency. Some other systems may even offer Repeatable Read and Snapshot Isolation as distinct isolation levels with different behavior. The permitted phenomena that distinguish the two techniques were not formalized by database researchers until after the SQL standard was developed, and are outside the scope of this manual. For a full treatment, please see &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#BERENSON95&quot;&gt;[berenson95]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091f62aabb99c30a476910bd3ba420fa9f860db6" translate="yes" xml:space="preserve">
          <source>The Repeatable Read mode provides a rigorous guarantee that each transaction sees a completely stable view of the database. However, this view will not necessarily always be consistent with some serial (one at a time) execution of concurrent transactions of the same level. For example, even a read only transaction at this level may see a control record updated to show that a batch has been completed but &lt;em&gt;not&lt;/em&gt; see one of the detail records which is logically part of the batch because it read an earlier revision of the control record. Attempts to enforce business rules by transactions running at this isolation level are not likely to work correctly without careful use of explicit locks to block conflicting transactions.</source>
          <target state="translated">Режим Repeatable Read обеспечивает строгую гарантию того, что каждая транзакция видит полностью стабильное представление базы данных. Однако это представление не обязательно всегда будет соответствовать некоторому последовательному (по одному) выполнению параллельных транзакций одного и того же уровня. Например, даже транзакция только для чтения на этом уровне может видеть обновленную контрольную запись, чтобы показать, что пакет был завершен, но &lt;em&gt;не&lt;/em&gt; видеть одну из подробных записей, которая логически является частью пакета, потому что она прочитала более раннюю версию контрольной записи . Попытки обеспечить соблюдение бизнес-правил с помощью транзакций, выполняемых на этом уровне изоляции, вряд ли будут работать правильно без осторожного использования явных блокировок для блокировки конфликтующих транзакций.</target>
        </trans-unit>
        <trans-unit id="bebce75022660ba392e40784c2cdda41c615a64f" translate="yes" xml:space="preserve">
          <source>The SCRAM specification dictates that the password is also in UTF-8, and is processed with the &lt;em&gt;SASLprep&lt;/em&gt; algorithm. PostgreSQL, however, does not require UTF-8 to be used for the password. When a user's password is set, it is processed with SASLprep as if it was in UTF-8, regardless of the actual encoding used. However, if it is not a legal UTF-8 byte sequence, or it contains UTF-8 byte sequences that are prohibited by the SASLprep algorithm, the raw password will be used without SASLprep processing, instead of throwing an error. This allows the password to be normalized when it is in UTF-8, but still allows a non-UTF-8 password to be used, and doesn't require the system to know which encoding the password is in.</source>
          <target state="translated">Согласно спецификации SCRAM, пароль также находится в UTF-8 и обрабатывается алгоритмом &lt;em&gt;SASLprep&lt;/em&gt; . Однако PostgreSQL не требует использования UTF-8 в качестве пароля. Когда пароль пользователя установлен, он обрабатывается с помощью SASLprep, как если бы он был в UTF-8, независимо от фактической используемой кодировки. Однако, если это недопустимая последовательность байтов UTF-8 или она содержит последовательности байтов UTF-8, запрещенные алгоритмом SASLprep, необработанный пароль будет использоваться без обработки SASLprep, а не вызывать ошибку. Это позволяет нормализовать пароль, когда он находится в UTF-8, но по-прежнему позволяет использовать пароль, отличный от UTF-8, и не требует, чтобы система знала, в какой кодировке находится пароль.</target>
        </trans-unit>
        <trans-unit id="0e7a1522eba0328b9be11871eb393a000b642ba7" translate="yes" xml:space="preserve">
          <source>The SP-GiST core can override the results of the operator class's &lt;code&gt;picksplit&lt;/code&gt; function when &lt;code&gt;picksplit&lt;/code&gt; fails to divide the supplied leaf values into at least two node categories. When this happens, the new inner tuple is created with multiple nodes that each have the same label (if any) that &lt;code&gt;picksplit&lt;/code&gt; gave to the one node it did use, and the leaf values are divided at random among these equivalent nodes. The &lt;code&gt;allTheSame&lt;/code&gt; flag is set on the inner tuple to warn the &lt;code&gt;choose&lt;/code&gt; and &lt;code&gt;inner_consistent&lt;/code&gt; functions that the tuple does not have the node set that they might otherwise expect.</source>
          <target state="translated">Ядро SP-GiST может отменить результаты этого операторского класса &lt;code&gt;picksplit&lt;/code&gt; функции при &lt;code&gt;picksplit&lt;/code&gt; не удается разделить прилагаемые значения листа, по меньшей мере , две категорий узлов. Когда это происходит, создается новый внутренний кортеж с несколькими узлами, каждый из которых имеет ту же метку (если таковая имеется), которую &lt;code&gt;picksplit&lt;/code&gt; присвоил одному узлу, который он использовал, и значения листьев делятся случайным образом между этими эквивалентными узлами. &lt;code&gt;allTheSame&lt;/code&gt; флаг установлен на внутреннем кортеже предупредить &lt;code&gt;choose&lt;/code&gt; и &lt;code&gt;inner_consistent&lt;/code&gt; функции , что кортеж не имеет набора узлов , которые они могли бы в противном случае ожидать.</target>
        </trans-unit>
        <trans-unit id="d1b14a46877d8df03142e17f562b21c36e25830b" translate="yes" xml:space="preserve">
          <source>The SP-GiST core code takes care of null entries. Although SP-GiST indexes do store entries for nulls in indexed columns, this is hidden from the index operator class code: no null index entries or search conditions will ever be passed to the operator class methods. (It is assumed that SP-GiST operators are strict and so cannot succeed for null values.) Null values are therefore not discussed further here.</source>
          <target state="translated">Основной код SP-GiST заботится о нулевых записях.Хотя в индексах SP-GiST записи для нулей хранятся в индексированных столбцах,это скрыто от кода класса оператора:нулевые записи индекса или условия поиска никогда не будут переданы методам класса оператора.(Предполагается,что операторы SP-GiST являются строгими и поэтому не могут быть успешными для нулевых значений).Поэтому нулевые значения здесь далее не рассматриваются.</target>
        </trans-unit>
        <trans-unit id="fe87973f3ef5a0d6b6662bce168960f63417cd65" translate="yes" xml:space="preserve">
          <source>The SQL &lt;code&gt;CASE&lt;/code&gt; expression is a generic conditional expression, similar to if/else statements in other programming languages:</source>
          <target state="translated">Выражение SQL &lt;code&gt;CASE&lt;/code&gt; - это общее условное выражение, подобное операторам if / else в других языках программирования:</target>
        </trans-unit>
        <trans-unit id="d48ab325670cd3e1aa8741d57a661891b103e0ac" translate="yes" xml:space="preserve">
          <source>The SQL command &lt;code&gt;SET TIME ZONE&lt;/code&gt; sets the time zone for the session. This is an alternative spelling of &lt;code&gt;SET TIMEZONE TO&lt;/code&gt; with a more SQL-spec-compatible syntax.</source>
          <target state="translated">Команда SQL &lt;code&gt;SET TIME ZONE&lt;/code&gt; устанавливает часовой пояс для сеанса. Это альтернативное написание &lt;code&gt;SET TIMEZONE TO&lt;/code&gt; с синтаксисом, более совместимым со спецификациями SQL.</target>
        </trans-unit>
        <trans-unit id="d138e80b8b9922df49f297ce30f8d0bcbf9cc1b2" translate="yes" xml:space="preserve">
          <source>The SQL command used to request data from a &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;. Normally, &lt;code&gt;SELECT&lt;/code&gt; commands are not expected to modify the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; in any way, but it is possible that &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;functions&lt;/a&gt; invoked within the query could have side effects that do modify data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64de07c340bdb76d49ccd2451af6603ff373cc2b" translate="yes" xml:space="preserve">
          <source>The SQL declaration of the function must look like this:</source>
          <target state="translated">SQL-декларация функции должна выглядеть так:</target>
        </trans-unit>
        <trans-unit id="d7b4645499046b1f0731ca7d87e83bccfa0f031d" translate="yes" xml:space="preserve">
          <source>The SQL script will be written to the standard output. Use the &lt;code&gt;-f&lt;/code&gt;/&lt;code&gt;--file&lt;/code&gt; option or shell operators to redirect it into a file.</source>
          <target state="translated">Скрипт SQL будет записан на стандартный вывод. Используйте параметр &lt;code&gt;-f&lt;/code&gt; / &lt;code&gt;--file&lt;/code&gt; или операторы оболочки, чтобы перенаправить его в файл.</target>
        </trans-unit>
        <trans-unit id="e638b08fc8b7ed4b2fdc056d0b48506d414e8ee3" translate="yes" xml:space="preserve">
          <source>The SQL specification requires row-wise comparison to return NULL if the result depends on comparing two NULL values or a NULL and a non-NULL. PostgreSQL does this only when comparing the results of two row constructors (as in &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt;) or comparing a row constructor to the output of a subquery (as in &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;). In other contexts where two composite-type values are compared, two NULL field values are considered equal, and a NULL is considered larger than a non-NULL. This is necessary in order to have consistent sorting and indexing behavior for composite types.</source>
          <target state="translated">Спецификация SQL требует, чтобы сравнение по строкам возвращало NULL, если результат зависит от сравнения двух значений NULL или NULL и ненулевого значения. PostgreSQL делает это только при сравнении результатов двух конструкторов строк (как в &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Разделе 9.23.5&lt;/a&gt; ) или сравнении конструктора строки с выводом подзапроса (как в &lt;a href=&quot;functions-subquery&quot;&gt;Разделе 9.22&lt;/a&gt; ). В других контекстах, где сравниваются два значения составного типа, два значения поля NULL считаются равными, а значение NULL считается большим, чем значение, отличное от NULL. Это необходимо для согласованного поведения сортировки и индексации для составных типов.</target>
        </trans-unit>
        <trans-unit id="70d6fe59fbf6e2a74e4c6678f95fcbb041c7ebd1" translate="yes" xml:space="preserve">
          <source>The SQL specification requires row-wise comparison to return NULL if the result depends on comparing two NULL values or a NULL and a non-NULL. PostgreSQL does this only when comparing the results of two row constructors (as in &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.24.5&lt;/a&gt;) or comparing a row constructor to the output of a subquery (as in &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.23&lt;/a&gt;). In other contexts where two composite-type values are compared, two NULL field values are considered equal, and a NULL is considered larger than a non-NULL. This is necessary in order to have consistent sorting and indexing behavior for composite types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ab3c86af000737aa210aeaf592af19c218233b" translate="yes" xml:space="preserve">
          <source>The SQL standard (not XQuery itself) attempts to cater for more variants of &amp;ldquo;newline&amp;rdquo; than POSIX does. The newline-sensitive matching options described above consider only ASCII NL (&lt;code&gt;\n&lt;/code&gt;) to be a newline, but SQL would have us treat CR (&lt;code&gt;\r&lt;/code&gt;), CRLF (&lt;code&gt;\r\n&lt;/code&gt;) (a Windows-style newline), and some Unicode-only characters like LINE SEPARATOR (U+2028) as newlines as well. Notably, &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;\s&lt;/code&gt; should count &lt;code&gt;\r\n&lt;/code&gt; as one character not two according to SQL.</source>
          <target state="translated">Стандарт SQL (а не сам XQuery) пытается обслуживать больше вариантов &amp;laquo;новой строки&amp;raquo;, чем POSIX. Описанные выше параметры сопоставления, чувствительные к новой строке, рассматривают только ASCII NL ( &lt;code&gt;\n&lt;/code&gt; ) как новую строку, но SQL заставит нас обрабатывать CR ( &lt;code&gt;\r&lt;/code&gt; ), CRLF ( &lt;code&gt;\r\n&lt;/code&gt; ) ( символ новой строки в стиле Windows) и некоторые Символы только Unicode, такие как LINE SEPARATOR (U + 2028), также как символы новой строки. Примечательно, что &lt;code&gt;.&lt;/code&gt; и &lt;code&gt;\s&lt;/code&gt; должен считать &lt;code&gt;\r\n&lt;/code&gt; одним символом, а не двумя согласно SQL.</target>
        </trans-unit>
        <trans-unit id="3ca979281ade8cf94abb51fcd1544322941db9bd" translate="yes" xml:space="preserve">
          <source>The SQL standard allows a &lt;code&gt;DEFAULT CHARACTER SET&lt;/code&gt; clause in &lt;code&gt;CREATE SCHEMA&lt;/code&gt;, as well as more subcommand types than are presently accepted by PostgreSQL.</source>
          <target state="translated">Стандарт SQL допускает предложение &lt;code&gt;DEFAULT CHARACTER SET&lt;/code&gt; в &lt;code&gt;CREATE SCHEMA&lt;/code&gt; , а также большее количество типов подкоманд, чем в настоящее время принимает PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="a28253dba0b95d8667501243721aade5c4069637" translate="yes" xml:space="preserve">
          <source>The SQL standard allows cursors only in embedded SQL and in modules. PostgreSQL permits cursors to be used interactively.</source>
          <target state="translated">Стандарт SQL позволяет использовать курсоры только во встроенном SQL и в модулях.PostgreSQL позволяет использовать курсоры интерактивно.</target>
        </trans-unit>
        <trans-unit id="7005659d6b42749138703e7ef74f259a352e97f5" translate="yes" xml:space="preserve">
          <source>The SQL standard allows only &lt;code&gt;FROM&lt;/code&gt; preceding the cursor name; the option to use &lt;code&gt;IN&lt;/code&gt;, or to leave them out altogether, is an extension.</source>
          <target state="translated">Стандарт SQL допускает только &lt;code&gt;FROM&lt;/code&gt; перед именем курсора; возможность использовать &lt;code&gt;IN&lt;/code&gt; или вообще исключить их - это расширение.</target>
        </trans-unit>
        <trans-unit id="69a8fc7cc008eb25ed064f0d1fdca190a5bf8644" translate="yes" xml:space="preserve">
          <source>The SQL standard allows some other expressions to appear in place of the literal &lt;code&gt;user_name&lt;/code&gt;, but these options are not important in practice. PostgreSQL allows identifier syntax (&lt;code&gt;&quot;username&quot;&lt;/code&gt;), which SQL does not. SQL does not allow this command during a transaction; PostgreSQL does not make this restriction because there is no reason to. The &lt;code&gt;SESSION&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; modifiers are a PostgreSQL extension, as is the &lt;code&gt;RESET&lt;/code&gt; syntax.</source>
          <target state="translated">Стандарт SQL позволяет использовать некоторые другие выражения вместо буквального &lt;code&gt;user_name&lt;/code&gt; , но на практике эти параметры не важны. PostgreSQL допускает синтаксис идентификатора ( &lt;code&gt;&quot;username&quot;&lt;/code&gt; ), чего нет в SQL. SQL не разрешает эту команду во время транзакции; PostgreSQL не накладывает этого ограничения, потому что для этого нет причин. &lt;code&gt;SESSION&lt;/code&gt; и &lt;code&gt;LOCAL&lt;/code&gt; модификаторы расширение PostgreSQL, как это &lt;code&gt;RESET&lt;/code&gt; синтаксиса.</target>
        </trans-unit>
        <trans-unit id="473020e153f860561552af61b3a2ab3766cfb98d" translate="yes" xml:space="preserve">
          <source>The SQL standard allows the &lt;code&gt;GRANTED BY&lt;/code&gt; option to be used in all forms of &lt;code&gt;GRANT&lt;/code&gt;. PostgreSQL only supports it when granting role membership, and even then only superusers may use it in nontrivial ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b623e7f141c55510760b9b77e9eb99f9e4321e9e" translate="yes" xml:space="preserve">
          <source>The SQL standard also distinguishes between global and local temporary tables, where a local temporary table has a separate set of contents for each SQL module within each session, though its definition is still shared across sessions. Since PostgreSQL does not support SQL modules, this distinction is not relevant in PostgreSQL.</source>
          <target state="translated">Стандарт SQL также различает глобальные и локальные временные таблицы,где локальная временная таблица имеет отдельный набор содержимого для каждого модуля SQL в течение каждого сеанса,хотя ее определение все равно разделяется между сеансами.Поскольку PostgreSQL не поддерживает модули SQL,это различие в PostgreSQL не имеет значения.</target>
        </trans-unit>
        <trans-unit id="6f9fa0f99df0f3d6e4d172f087bbf08f499d13c0" translate="yes" xml:space="preserve">
          <source>The SQL standard and PostgreSQL-implemented transaction isolation levels are described in &lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;Table 13.1&lt;/a&gt;.</source>
          <target state="translated">Уровни изоляции транзакций в стандарте SQL и PostgreSQL описаны в &lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;таблице 13.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e49f9cf60061c8b5fe47367c7175f7b9d12754fa" translate="yes" xml:space="preserve">
          <source>The SQL standard calls databases &amp;ldquo;catalogs&amp;rdquo;, but there is no difference in practice.</source>
          <target state="translated">Стандарт SQL называет базы данных каталогами, но на практике разницы нет.</target>
        </trans-unit>
        <trans-unit id="f6b9dd41b616b1103c4995e9bab7f0a1474529d1" translate="yes" xml:space="preserve">
          <source>The SQL standard defines &lt;code&gt;DROP ROLE&lt;/code&gt;, but it allows only one role to be dropped at a time, and it specifies different privilege requirements than PostgreSQL uses.</source>
          <target state="translated">Стандарт SQL определяет &lt;code&gt;DROP ROLE&lt;/code&gt; , но позволяет отбрасывать только одну роль за раз и определяет другие требования к привилегиям, нежели PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="89dd410d4b1dc70cede977d3716ec82a83bd84ad" translate="yes" xml:space="preserve">
          <source>The SQL standard defines &lt;code&gt;FETCH&lt;/code&gt; for use in embedded SQL only. The variant of &lt;code&gt;FETCH&lt;/code&gt; described here returns the data as if it were a &lt;code&gt;SELECT&lt;/code&gt; result rather than placing it in host variables. Other than this point, &lt;code&gt;FETCH&lt;/code&gt; is fully upward-compatible with the SQL standard.</source>
          <target state="translated">Стандарт SQL определяет &lt;code&gt;FETCH&lt;/code&gt; для использования только во встроенном SQL. Описанный здесь вариант &lt;code&gt;FETCH&lt;/code&gt; возвращает данные, как если бы это был результат &lt;code&gt;SELECT&lt;/code&gt; , а не помещал их в переменные хоста. Помимо этого пункта, &lt;code&gt;FETCH&lt;/code&gt; полностью совместим со стандартом SQL.</target>
        </trans-unit>
        <trans-unit id="0433545c375e6f7a87b9a6951397354ec73ee790" translate="yes" xml:space="preserve">
          <source>The SQL standard defines a &lt;code&gt;RESPECT NULLS&lt;/code&gt; or &lt;code&gt;IGNORE NULLS&lt;/code&gt; option for &lt;code&gt;lead&lt;/code&gt;, &lt;code&gt;lag&lt;/code&gt;, &lt;code&gt;first_value&lt;/code&gt;, &lt;code&gt;last_value&lt;/code&gt;, and &lt;code&gt;nth_value&lt;/code&gt;. This is not implemented in PostgreSQL: the behavior is always the same as the standard's default, namely &lt;code&gt;RESPECT NULLS&lt;/code&gt;. Likewise, the standard's &lt;code&gt;FROM FIRST&lt;/code&gt; or &lt;code&gt;FROM LAST&lt;/code&gt; option for &lt;code&gt;nth_value&lt;/code&gt; is not implemented: only the default &lt;code&gt;FROM FIRST&lt;/code&gt; behavior is supported. (You can achieve the result of &lt;code&gt;FROM LAST&lt;/code&gt; by reversing the &lt;code&gt;ORDER BY&lt;/code&gt; ordering.)</source>
          <target state="translated">Стандарт SQL определяет &lt;code&gt;RESPECT NULLS&lt;/code&gt; или &lt;code&gt;IGNORE NULLS&lt;/code&gt; вариант для &lt;code&gt;lead&lt;/code&gt; , &lt;code&gt;lag&lt;/code&gt; , &lt;code&gt;first_value&lt;/code&gt; , &lt;code&gt;last_value&lt;/code&gt; и &lt;code&gt;nth_value&lt;/code&gt; . Это не реализовано в PostgreSQL: поведение всегда такое же, как и в стандарте по умолчанию, а именно &lt;code&gt;RESPECT NULLS&lt;/code&gt; . Аналогичным образом, стандартная опция &lt;code&gt;FROM FIRST&lt;/code&gt; или &lt;code&gt;FROM LAST&lt;/code&gt; для &lt;code&gt;nth_value&lt;/code&gt; не реализована: поддерживается только поведение &lt;code&gt;FROM FIRST&lt;/code&gt; по умолчанию . (Вы можете получить результат &lt;code&gt;FROM LAST&lt;/code&gt; , изменив порядок &lt;code&gt;ORDER BY&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="fa458ed41634d193bea2fac0154b209dd0cf765a" translate="yes" xml:space="preserve">
          <source>The SQL standard defines a different binary string type, called &lt;code&gt;BLOB&lt;/code&gt; or &lt;code&gt;BINARY LARGE OBJECT&lt;/code&gt;. The input format is different from &lt;code&gt;bytea&lt;/code&gt;, but the provided functions and operators are mostly the same.</source>
          <target state="translated">Стандарт SQL определяет другой тип двоичной строки, называемый &lt;code&gt;BLOB&lt;/code&gt; или &lt;code&gt;BINARY LARGE OBJECT&lt;/code&gt; . Формат ввода отличается от &lt;code&gt;bytea&lt;/code&gt; , но предоставляемые функции и операторы в основном такие же.</target>
        </trans-unit>
        <trans-unit id="a6502238836b3c1e6ea2cb2c05c9c3eff6b47428" translate="yes" xml:space="preserve">
          <source>The SQL standard defines four levels of transaction isolation. The most strict is Serializable, which is defined by the standard in a paragraph which says that any concurrent execution of a set of Serializable transactions is guaranteed to produce the same effect as running them one at a time in some order. The other three levels are defined in terms of phenomena, resulting from interaction between concurrent transactions, which must not occur at each level. The standard notes that due to the definition of Serializable, none of these phenomena are possible at that level. (This is hardly surprising -- if the effect of the transactions must be consistent with having been run one at a time, how could you see any phenomena caused by interactions?)</source>
          <target state="translated">Стандарт SQL определяет четыре уровня изоляции транзакций.Наиболее строгим является Serializable,который определяется стандартом в параграфе,где сказано,что любое параллельное выполнение набора Serializable-транзакций гарантированно дает тот же эффект,что и их одновременное выполнение по одному в каком-то порядке.Остальные три уровня определяются с точки зрения явлений,возникающих в результате взаимодействия между параллельными транзакциями,которое не должно происходить на каждом уровне.В стандарте отмечается,что благодаря определению Serializable ни одно из этих явлений не возможно на этом уровне.(Это неудивительно-если эффект от транзакций должен соответствовать тому,что они выполняются по очереди,то как вы можете видеть какие-либо явления,вызванные взаимодействиями?).</target>
        </trans-unit>
        <trans-unit id="e0bda65f48165dca64ab0bb74baf32b2635a1f88" translate="yes" xml:space="preserve">
          <source>The SQL standard defines one additional level, &lt;code&gt;READ UNCOMMITTED&lt;/code&gt;. In PostgreSQL &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; is treated as &lt;code&gt;READ COMMITTED&lt;/code&gt;.</source>
          <target state="translated">Стандарт SQL определяет один дополнительный уровень, &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; . В PostgreSQL &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; рассматривается как &lt;code&gt;READ COMMITTED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4646156599f749581333cb75ad841c671d1c0b23" translate="yes" xml:space="preserve">
          <source>The SQL standard defines the concepts of users and roles, but it regards them as distinct concepts and leaves all commands defining users to be specified by each database implementation. In PostgreSQL we have chosen to unify users and roles into a single kind of entity. Roles therefore have many more optional attributes than they do in the standard.</source>
          <target state="translated">Стандарт SQL определяет понятия пользователей и ролей,но рассматривает их как отдельные понятия и оставляет все команды,определяющие пользователей,для каждой реализации БД.В PostgreSQL мы выбрали объединение пользователей и ролей в единый вид сущностей.Таким образом,роли имеют гораздо больше необязательных атрибутов,чем в стандарте.</target>
        </trans-unit>
        <trans-unit id="0663b6424dd2f8b2135d82962a5208510f77e258" translate="yes" xml:space="preserve">
          <source>The SQL standard defines two &lt;em&gt;passing mechanisms&lt;/em&gt; that apply when passing an XML argument from SQL to an XML function or receiving a result: &lt;code&gt;BY REF&lt;/code&gt;, in which a particular XML value retains its node identity, and &lt;code&gt;BY VALUE&lt;/code&gt;, in which the content of the XML is passed but node identity is not preserved. A mechanism can be specified before a list of parameters, as the default mechanism for all of them, or after any parameter, to override the default.</source>
          <target state="translated">Стандарт SQL определяет два &lt;em&gt;механизма передачи,&lt;/em&gt; которые применяются при передаче аргумента XML из SQL в функцию XML или получении результата: &lt;code&gt;BY REF&lt;/code&gt; , в котором конкретное значение XML сохраняет свою идентичность узла, и &lt;code&gt;BY VALUE&lt;/code&gt; , в котором содержимое XML передается, но идентичность узла не сохраняется. Механизм можно указать перед списком параметров, как механизм по умолчанию для всех из них, или после любого параметра, чтобы переопределить значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="8be5477647682fea4652e9633a7fdf7ae02cb95d" translate="yes" xml:space="preserve">
          <source>The SQL standard differentiates &lt;code&gt;timestamp without time zone&lt;/code&gt; and &lt;code&gt;timestamp with time zone&lt;/code&gt; literals by the presence of a &amp;ldquo;+&amp;rdquo; or &amp;ldquo;-&amp;rdquo; symbol and time zone offset after the time. Hence, according to the standard,</source>
          <target state="translated">Стандарт SQL различает &lt;code&gt;timestamp without time zone&lt;/code&gt; и &lt;code&gt;timestamp with time zone&lt;/code&gt; литералами часового пояса по наличию символа &amp;laquo;+&amp;raquo; или &amp;laquo;-&amp;raquo; и смещения часового пояса после времени. Следовательно, согласно стандарту,</target>
        </trans-unit>
        <trans-unit id="e664f1068d4185a0e2c4e6676631526d39744df1" translate="yes" xml:space="preserve">
          <source>The SQL standard includes a &lt;code&gt;DEALLOCATE&lt;/code&gt; statement, but it is only for use in embedded SQL.</source>
          <target state="translated">Стандарт SQL включает оператор &lt;code&gt;DEALLOCATE&lt;/code&gt; , но он предназначен только для использования во встроенном SQL.</target>
        </trans-unit>
        <trans-unit id="c90f74b3a15257d28d6e4bb3296f2c0e98aadae3" translate="yes" xml:space="preserve">
          <source>The SQL standard includes a &lt;code&gt;PREPARE&lt;/code&gt; statement, but it is only for use in embedded SQL. This version of the &lt;code&gt;PREPARE&lt;/code&gt; statement also uses a somewhat different syntax.</source>
          <target state="translated">Стандарт SQL включает оператор &lt;code&gt;PREPARE&lt;/code&gt; , но он предназначен только для использования во встроенном SQL. В этой версии оператора &lt;code&gt;PREPARE&lt;/code&gt; также используется несколько иной синтаксис.</target>
        </trans-unit>
        <trans-unit id="fe224ee017c2bd35d24d44088347efdd2b498c3d" translate="yes" xml:space="preserve">
          <source>The SQL standard includes an &lt;code&gt;EXECUTE&lt;/code&gt; statement, but it is only for use in embedded SQL. This version of the &lt;code&gt;EXECUTE&lt;/code&gt; statement also uses a somewhat different syntax.</source>
          <target state="translated">Стандарт SQL включает оператор &lt;code&gt;EXECUTE&lt;/code&gt; , но он предназначен только для использования во встроенном SQL. В этой версии оператора &lt;code&gt;EXECUTE&lt;/code&gt; также используется несколько иной синтаксис.</target>
        </trans-unit>
        <trans-unit id="3efa28b82e46f4409adc369dc8a870c8a673cbae" translate="yes" xml:space="preserve">
          <source>The SQL standard only makes provisions for cursors in embedded SQL. The PostgreSQL server does not implement an &lt;code&gt;OPEN&lt;/code&gt; statement for cursors; a cursor is considered to be open when it is declared. However, ECPG, the embedded SQL preprocessor for PostgreSQL, supports the standard SQL cursor conventions, including those involving &lt;code&gt;DECLARE&lt;/code&gt; and &lt;code&gt;OPEN&lt;/code&gt; statements.</source>
          <target state="translated">Стандарт SQL предусматривает только курсоры во встроенном SQL. Сервер PostgreSQL не реализует оператор &lt;code&gt;OPEN&lt;/code&gt; для курсоров; Курсор считается открытым при его объявлении. Однако ECPG, встроенный препроцессор SQL для PostgreSQL, поддерживает стандартные соглашения о курсорах SQL, включая те, которые включают &lt;code&gt;DECLARE&lt;/code&gt; и &lt;code&gt;OPEN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27a77950710338562f963e53983e9db24c286f83" translate="yes" xml:space="preserve">
          <source>The SQL standard provides for a &lt;code&gt;USAGE&lt;/code&gt; privilege on other kinds of objects: character sets, collations, translations.</source>
          <target state="translated">Стандарт SQL предоставляет привилегию &lt;code&gt;USAGE&lt;/code&gt; для других типов объектов: наборов символов, сопоставлений, переводов.</target>
        </trans-unit>
        <trans-unit id="eee762b9a6787226a912a1d85c8be87d3dbf797a" translate="yes" xml:space="preserve">
          <source>The SQL standard requires commas between successive &lt;code&gt;transaction_modes&lt;/code&gt;, but for historical reasons PostgreSQL allows the commas to be omitted.</source>
          <target state="translated">Стандарт SQL требует запятых между последовательными режимами &lt;code&gt;transaction_modes&lt;/code&gt; , но по историческим причинам PostgreSQL позволяет опускать запятые.</target>
        </trans-unit>
        <trans-unit id="0cdcd239c4d51fe5d06e09469371cb72d1e4c5cc" translate="yes" xml:space="preserve">
          <source>The SQL standard requires parentheses around the table name when writing &lt;code&gt;ONLY&lt;/code&gt;, for example &lt;code&gt;SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...&lt;/code&gt;. PostgreSQL considers these parentheses to be optional.</source>
          <target state="translated">Стандарт SQL требует скобки вокруг имени таблицы при записи &lt;code&gt;ONLY&lt;/code&gt; , например &lt;code&gt;SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...&lt;/code&gt; . PostgreSQL считает эти круглые скобки необязательными.</target>
        </trans-unit>
        <trans-unit id="9c327a647bb63bff5c4e11d3c2640afdd42ebe7e" translate="yes" xml:space="preserve">
          <source>The SQL standard requires that writing just &lt;code&gt;timestamp&lt;/code&gt; be equivalent to &lt;code&gt;timestamp without time zone&lt;/code&gt;, and PostgreSQL honors that behavior. &lt;code&gt;timestamptz&lt;/code&gt; is accepted as an abbreviation for &lt;code&gt;timestamp with time zone&lt;/code&gt;; this is a PostgreSQL extension.</source>
          <target state="translated">Стандарт SQL требует, чтобы запись просто &lt;code&gt;timestamp&lt;/code&gt; была эквивалентна &lt;code&gt;timestamp without time zone&lt;/code&gt; , и PostgreSQL уважает это поведение. &lt;code&gt;timestamptz&lt;/code&gt; - это сокращение от &lt;code&gt;timestamp with time zone&lt;/code&gt; ; это расширение PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="b32d323a75124833c9180676bb48b77e9c8490b4" translate="yes" xml:space="preserve">
          <source>The SQL standard says that &lt;code&gt;CHECK&lt;/code&gt; column constraints can only refer to the column they apply to; only &lt;code&gt;CHECK&lt;/code&gt; table constraints can refer to multiple columns. PostgreSQL does not enforce this restriction; it treats column and table check constraints alike.</source>
          <target state="translated">Стандарт SQL говорит, что ограничения столбца &lt;code&gt;CHECK&lt;/code&gt; могут относиться только к столбцу, к которому они применяются; только ограничения таблицы &lt;code&gt;CHECK&lt;/code&gt; могут ссылаться на несколько столбцов. PostgreSQL не применяет это ограничение; он одинаково обрабатывает ограничения столбцов и таблиц.</target>
        </trans-unit>
        <trans-unit id="17cd16f5bf5a8ca370f92a98424035c167fcaa79" translate="yes" xml:space="preserve">
          <source>The SQL standard says that it is implementation-dependent whether cursors are sensitive to concurrent updates of the underlying data by default. In PostgreSQL, cursors are insensitive by default, and can be made sensitive by specifying &lt;code&gt;FOR UPDATE&lt;/code&gt;. Other products may work differently.</source>
          <target state="translated">Стандарт SQL говорит, что это зависит от реализации, чувствительны ли курсоры к одновременным обновлениям базовых данных по умолчанию. В PostgreSQL курсоры по умолчанию нечувствительны, и их можно сделать чувствительными, указав &lt;code&gt;FOR UPDATE&lt;/code&gt; . Другие продукты могут работать иначе.</target>
        </trans-unit>
        <trans-unit id="6c0e6c19202fe94a3734c19398394df433a6c622" translate="yes" xml:space="preserve">
          <source>The SQL standard says that table and domain constraints must have names that are unique across the schema containing the table or domain. PostgreSQL is laxer: it only requires constraint names to be unique across the constraints attached to a particular table or domain. However, this extra freedom does not exist for index-based constraints (&lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, and &lt;code&gt;EXCLUDE&lt;/code&gt; constraints), because the associated index is named the same as the constraint, and index names must be unique across all relations within the same schema.</source>
          <target state="translated">Стандарт SQL гласит, что ограничения таблицы и домена должны иметь имена, уникальные для всей схемы, содержащей таблицу или домен. PostgreSQL более слабый: он требует, чтобы только имена ограничений были уникальными среди ограничений, прикрепленных к конкретной таблице или домену. Однако эта дополнительная свобода не существует для ограничений на основе индекса (ограничения &lt;code&gt;UNIQUE&lt;/code&gt; , &lt;code&gt;PRIMARY KEY&lt;/code&gt; и &lt;code&gt;EXCLUDE&lt;/code&gt; ), потому что связанный индекс называется так же, как ограничение, и имена индексов должны быть уникальными для всех отношений в одной схеме.</target>
        </trans-unit>
        <trans-unit id="5a79884799ecc17f7b669e9ed40107182ffe5aca" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; can only be specified if an identity column that is generated always exists. PostgreSQL allows the clause in any case and ignores it if it is not applicable.</source>
          <target state="translated">В стандарте SQL указано, что &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; может быть указано только в том случае, если всегда существует генерируемый столбец идентификаторов. PostgreSQL допускает это предложение в любом случае и игнорирует его, если оно неприменимо.</target>
        </trans-unit>
        <trans-unit id="5b1e1c604541e0514a1f4ecda3cb5b97bda57985" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that the key word &lt;code&gt;SAVEPOINT&lt;/code&gt; is mandatory, but PostgreSQL and Oracle allow it to be omitted. SQL allows only &lt;code&gt;WORK&lt;/code&gt;, not &lt;code&gt;TRANSACTION&lt;/code&gt;, as a noise word after &lt;code&gt;ROLLBACK&lt;/code&gt;. Also, SQL has an optional clause &lt;code&gt;AND [ NO ] CHAIN&lt;/code&gt; which is not currently supported by PostgreSQL. Otherwise, this command conforms to the SQL standard.</source>
          <target state="translated">Стандарт SQL указывает, что ключевое слово &lt;code&gt;SAVEPOINT&lt;/code&gt; является обязательным, но PostgreSQL и Oracle разрешают его опускать. SQL допускает только &lt;code&gt;WORK&lt;/code&gt; , но не &lt;code&gt;TRANSACTION&lt;/code&gt; , как служебное слово после &lt;code&gt;ROLLBACK&lt;/code&gt; . Кроме того, в SQL есть необязательное предложение &lt;code&gt;AND [ NO ] CHAIN&lt;/code&gt; которое в настоящее время не поддерживается PostgreSQL. В остальном эта команда соответствует стандарту SQL.</target>
        </trans-unit>
        <trans-unit id="4ef02d5b8713fad53d23c6b10f7669991c2a9427" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that the subcommands in &lt;code&gt;CREATE SCHEMA&lt;/code&gt; can appear in any order. The present PostgreSQL implementation does not handle all cases of forward references in subcommands; it might sometimes be necessary to reorder the subcommands in order to avoid forward references.</source>
          <target state="translated">Стандарт SQL определяет, что подкоманды в &lt;code&gt;CREATE SCHEMA&lt;/code&gt; могут появляться в любом порядке. Текущая реализация PostgreSQL не обрабатывает все случаи прямых ссылок в подкомандах; иногда может потребоваться изменить порядок подкоманд, чтобы избежать прямых ссылок.</target>
        </trans-unit>
        <trans-unit id="7b4258f023ecf83c293dc59266efcd9181140a14" translate="yes" xml:space="preserve">
          <source>The SQL standard states that &amp;ldquo;Within the definition of a &amp;lsquo;datetime literal&amp;rsquo;, the &amp;lsquo;datetime values&amp;rsquo; are constrained by the natural rules for dates and times according to the Gregorian calendar&amp;rdquo;. PostgreSQL follows the SQL standard's lead by counting dates exclusively in the Gregorian calendar, even for years before that calendar was in use. This rule is known as the &lt;em&gt;proleptic Gregorian calendar&lt;/em&gt;.</source>
          <target state="translated">Стандарт SQL гласит, что &amp;laquo;В рамках определения&amp;laquo; литерала даты и времени &amp;raquo;&amp;laquo; значения даты и времени &amp;raquo;ограничиваются естественными правилами для дат и времени в соответствии с григорианским календарем&amp;raquo;. PostgreSQL следует стандарту SQL, считая даты исключительно по григорианскому календарю, даже за годы до того, как этот календарь использовался. Это правило известно как &lt;em&gt;пролептический григорианский календарь&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d19cb60e6641fce6ca2d40fc0e7200daf402177c" translate="yes" xml:space="preserve">
          <source>The SQL standard uses &lt;code&gt;SELECT INTO&lt;/code&gt; to represent selecting values into scalar variables of a host program, rather than creating a new table. This indeed is the usage found in ECPG (see &lt;a href=&quot;https://www.postgresql.org/docs/12/ecpg.html&quot;&gt;Chapter 35&lt;/a&gt;) and PL/pgSQL (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql.html&quot;&gt;Chapter 42&lt;/a&gt;). The PostgreSQL usage of &lt;code&gt;SELECT INTO&lt;/code&gt; to represent table creation is historical. It is best to use &lt;code&gt;CREATE TABLE AS&lt;/code&gt; for this purpose in new code.</source>
          <target state="translated">Стандарт SQL использует &lt;code&gt;SELECT INTO&lt;/code&gt; для представления выбора значений в скалярных переменных основной программы, а не для создания новой таблицы. Это действительно используется в ECPG (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/ecpg.html&quot;&gt;Главу 35&lt;/a&gt; ) и PL / pgSQL (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql.html&quot;&gt;Главу 42&lt;/a&gt; ). Использование в PostgreSQL &lt;code&gt;SELECT INTO&lt;/code&gt; для представления создания таблиц исторически. Лучше всего использовать &lt;code&gt;CREATE TABLE AS&lt;/code&gt; для этой цели в новом коде.</target>
        </trans-unit>
        <trans-unit id="975d3d6f53b33edd080d2a6f73dab7ae808007c0" translate="yes" xml:space="preserve">
          <source>The SQL standard uses &lt;code&gt;SELECT INTO&lt;/code&gt; to represent selecting values into scalar variables of a host program, rather than creating a new table. This indeed is the usage found in ECPG (see &lt;a href=&quot;https://www.postgresql.org/docs/13/ecpg.html&quot;&gt;Chapter 35&lt;/a&gt;) and PL/pgSQL (see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql.html&quot;&gt;Chapter 42&lt;/a&gt;). The PostgreSQL usage of &lt;code&gt;SELECT INTO&lt;/code&gt; to represent table creation is historical. It is best to use &lt;code&gt;CREATE TABLE AS&lt;/code&gt; for this purpose in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe56d39f2bcc805d7f67d5dc92546476c02ed72d" translate="yes" xml:space="preserve">
          <source>The SQL standard uses this term to indicate what is called a &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; in PostgreSQL's terminology.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f96ecc2fb3538c905f725be2098ce0d65cd6679" translate="yes" xml:space="preserve">
          <source>The SQL syntax is not very consistent regarding what tokens identify commands and which are operands or parameters. The first few tokens are generally the command name, so in the above example we would usually speak of a &amp;ldquo;SELECT&amp;rdquo;, an &amp;ldquo;UPDATE&amp;rdquo;, and an &amp;ldquo;INSERT&amp;rdquo; command. But for instance the &lt;code&gt;UPDATE&lt;/code&gt; command always requires a &lt;code&gt;SET&lt;/code&gt; token to appear in a certain position, and this particular variation of &lt;code&gt;INSERT&lt;/code&gt; also requires a &lt;code&gt;VALUES&lt;/code&gt; in order to be complete. The precise syntax rules for each command are described in &lt;a href=&quot;index&quot;&gt;Part VI&lt;/a&gt;.</source>
          <target state="translated">Синтаксис SQL не очень согласован в отношении того, какие токены идентифицируют команды, а какие являются операндами или параметрами. Первые несколько токенов обычно являются именем команды, поэтому в приведенном выше примере мы обычно говорим о командах &amp;laquo;SELECT&amp;raquo;, &amp;laquo;UPDATE&amp;raquo; и &amp;laquo;INSERT&amp;raquo;. Но, например, команда &lt;code&gt;UPDATE&lt;/code&gt; всегда требует, чтобы токен &lt;code&gt;SET&lt;/code&gt; появлялся в определенной позиции, и этот конкретный вариант &lt;code&gt;INSERT&lt;/code&gt; также требует &lt;code&gt;VALUES&lt;/code&gt; для завершения. Точные правила синтаксиса для каждой команды описаны в &lt;a href=&quot;index&quot;&gt;Части VI&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb05fc557b9719130cdacd9aa3c915a94bbdf061" translate="yes" xml:space="preserve">
          <source>The SQL/JSON standard borrows its definition for regular expressions from the &lt;code&gt;LIKE_REGEX&lt;/code&gt; operator, which in turn uses the XQuery standard. PostgreSQL does not currently support the &lt;code&gt;LIKE_REGEX&lt;/code&gt; operator. Therefore, the &lt;code&gt;like_regex&lt;/code&gt; filter is implemented using the POSIX regular expression engine described in &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;. This leads to various minor discrepancies from standard SQL/JSON behavior, which are cataloged in &lt;a href=&quot;functions-matching#POSIX-VS-XQUERY&quot;&gt;Section 9.7.3.8&lt;/a&gt;. Note, however, that the flag-letter incompatibilities described there do not apply to SQL/JSON, as it translates the XQuery flag letters to match what the POSIX engine expects.</source>
          <target state="translated">Стандарт SQL / JSON заимствует свое определение для регулярных выражений из оператора &lt;code&gt;LIKE_REGEX&lt;/code&gt; , который, в свою очередь, использует стандарт XQuery. PostgreSQL в настоящее время не поддерживает оператор &lt;code&gt;LIKE_REGEX&lt;/code&gt; . Поэтому фильтр &lt;code&gt;like_regex&lt;/code&gt; реализован с использованием механизма регулярных выражений POSIX, описанного в &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Разделе 9.7.3&lt;/a&gt; . Это приводит к различным незначительным отклонениям от стандартного поведения SQL / JSON, которые каталогизированы в &lt;a href=&quot;functions-matching#POSIX-VS-XQUERY&quot;&gt;Разделе 9.7.3.8&lt;/a&gt; . Обратите внимание, однако, что описанная здесь несовместимость флаг-буква не применяется к SQL / JSON, поскольку он переводит буквы флага XQuery в соответствии с ожиданиями механизма POSIX.</target>
        </trans-unit>
        <trans-unit id="2c1fd14d6c7b89183a3f90fd72282a55b3166126" translate="yes" xml:space="preserve">
          <source>The SQL:2008 standard includes a &lt;code&gt;TRUNCATE&lt;/code&gt; command with the syntax &lt;code&gt;TRUNCATE TABLE tablename&lt;/code&gt;. The clauses &lt;code&gt;CONTINUE IDENTITY&lt;/code&gt;/&lt;code&gt;RESTART IDENTITY&lt;/code&gt; also appear in that standard, but have slightly different though related meanings. Some of the concurrency behavior of this command is left implementation-defined by the standard, so the above notes should be considered and compared with other implementations if necessary.</source>
          <target state="translated">Стандарт SQL: 2008 включает команду &lt;code&gt;TRUNCATE&lt;/code&gt; с синтаксисом &lt;code&gt;TRUNCATE TABLE tablename&lt;/code&gt; . Пункты &lt;code&gt;CONTINUE IDENTITY&lt;/code&gt; / &lt;code&gt;RESTART IDENTITY&lt;/code&gt; также присутствуют в этом стандарте, но имеют немного другое, хотя и родственное значение. Некоторая часть параллельного поведения этой команды остается определяемой реализацией стандартом, поэтому приведенные выше примечания следует учитывать и при необходимости сравнивать с другими реализациями.</target>
        </trans-unit>
        <trans-unit id="0be6f583c1240a1ebc14deaf65c6d5260c133db4" translate="yes" xml:space="preserve">
          <source>The Serializable isolation level is implemented using a technique known in academic database literature as Serializable Snapshot Isolation, which builds on Snapshot Isolation by adding checks for serialization anomalies. Some differences in behavior and performance may be observed when compared with other systems that use a traditional locking technique. Please see &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#PORTS12&quot;&gt;[ports12]&lt;/a&gt; for detailed information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="106deb17fc13475a8af50970b808cc1e2661d130" translate="yes" xml:space="preserve">
          <source>The Serializable transaction isolation level is not yet available in hot standby. (See &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt; and &lt;a href=&quot;applevel-consistency#SERIALIZABLE-CONSISTENCY&quot;&gt;Section 13.4.1&lt;/a&gt; for details.) An attempt to set a transaction to the serializable isolation level in hot standby mode will generate an error.</source>
          <target state="translated">Уровень изоляции сериализуемой транзакции пока недоступен в горячем резерве. (За подробностями &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;обратитесь к Разделу 13.2.3&lt;/a&gt; и &lt;a href=&quot;applevel-consistency#SERIALIZABLE-CONSISTENCY&quot;&gt;Разделу 13.4.1&lt;/a&gt; .) Попытка установить транзакцию на сериализуемый уровень изоляции в режиме горячего резервирования приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="66e4ba5dbccb413a9c06a219a5d2e98558807585" translate="yes" xml:space="preserve">
          <source>The Snowball dictionary template is based on a project by Martin Porter, inventor of the popular Porter's stemming algorithm for the English language. Snowball now provides stemming algorithms for many languages (see the &lt;a href=&quot;http://snowballstem.org/&quot;&gt;Snowball site&lt;/a&gt; for more information). Each algorithm understands how to reduce common variant forms of words to a base, or stem, spelling within its language. A Snowball dictionary requires a &lt;code&gt;language&lt;/code&gt; parameter to identify which stemmer to use, and optionally can specify a &lt;code&gt;stopword&lt;/code&gt; file name that gives a list of words to eliminate. (PostgreSQL's standard stopword lists are also provided by the Snowball project.) For example, there is a built-in definition equivalent to</source>
          <target state="translated">Шаблон словаря Snowball основан на проекте Мартина Портера, изобретателя популярного алгоритма стемминга Портера для английского языка. Snowball теперь предоставляет алгоритмы выделения текста для многих языков ( дополнительную информацию см. На &lt;a href=&quot;http://snowballstem.org/&quot;&gt;сайте Snowball&lt;/a&gt; ). Каждый алгоритм понимает, как сократить распространенные вариантные формы слов до основы или основы написания в пределах своего языка. Для словаря Snowball требуется параметр &lt;code&gt;language&lt;/code&gt; чтобы определить, какой стеммер использовать, и при необходимости можно указать &lt;code&gt;stopword&lt;/code&gt; файла стоп-слов, который дает список слов, которые нужно исключить. (Стандартные списки запрещенных слов PostgreSQL также предоставляются проектом Snowball.) Например, есть встроенное определение, эквивалентное</target>
        </trans-unit>
        <trans-unit id="00f96728bd51fe9881e179ce29f4aab84f3a0eb5" translate="yes" xml:space="preserve">
          <source>The Snowball dictionary template is based on a project by Martin Porter, inventor of the popular Porter's stemming algorithm for the English language. Snowball now provides stemming algorithms for many languages (see the &lt;a href=&quot;https://snowballstem.org/&quot;&gt;Snowball site&lt;/a&gt; for more information). Each algorithm understands how to reduce common variant forms of words to a base, or stem, spelling within its language. A Snowball dictionary requires a &lt;code&gt;language&lt;/code&gt; parameter to identify which stemmer to use, and optionally can specify a &lt;code&gt;stopword&lt;/code&gt; file name that gives a list of words to eliminate. (PostgreSQL's standard stopword lists are also provided by the Snowball project.) For example, there is a built-in definition equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e42c2d23de5bce64e42840619341e599527d06" translate="yes" xml:space="preserve">
          <source>The Sort node shows the sort method used (in particular, whether the sort was in-memory or on-disk) and the amount of memory or disk space needed. The Hash node shows the number of hash buckets and batches as well as the peak amount of memory used for the hash table. (If the number of batches exceeds one, there will also be disk space usage involved, but that is not shown.)</source>
          <target state="translated">Узел Sort показывает используемый метод сортировки (в частности,была ли сортировка в памяти или на диске),а также необходимый объем памяти или дискового пространства.Хэш-узел показывает количество хэш-вёдер и партий,а также пиковый объем памяти,используемый для хэш-таблицы.(Если количество партий превысит единицу,то будет задействовано и дисковое пространство,но это не показано).</target>
        </trans-unit>
        <trans-unit id="ffcd4e9238fc5943a8a630abc801447e679c88d8" translate="yes" xml:space="preserve">
          <source>The Soundex system is a method of matching similar-sounding names by converting them to the same code. It was initially used by the United States Census in 1880, 1900, and 1910. Note that Soundex is not very useful for non-English names.</source>
          <target state="translated">Система Soundex представляет собой метод сопоставления однотипных имен путем их преобразования в один и тот же код.Первоначально она использовалась при переписи населения США в 1880,1900 и 1910 годах.Обратите внимание,что Soundex не очень полезен для неанглийских имен.</target>
        </trans-unit>
        <trans-unit id="30ad8964ef3e16d1b565ba3b7fd4ae7ed8f17e69" translate="yes" xml:space="preserve">
          <source>The TCP port the server listens on; 5432 by default. Note that the same port number is used for all IP addresses the server listens on. This parameter can only be set at server start.</source>
          <target state="translated">TCP-порт,который прослушивает сервер;по умолчанию 5432.Обратите внимание,что один и тот же номер порта используется для всех IP-адресов,которые прослушивает сервер.Этот параметр может быть установлен только при запуске сервера.</target>
        </trans-unit>
        <trans-unit id="4a5c86c75e37eef9f48a99edd2521f09dbad0224" translate="yes" xml:space="preserve">
          <source>The TOAST management code is triggered only when a row value to be stored in a table is wider than &lt;code&gt;TOAST_TUPLE_THRESHOLD&lt;/code&gt; bytes (normally 2 kB). The TOAST code will compress and/or move field values out-of-line until the row value is shorter than &lt;code&gt;TOAST_TUPLE_TARGET&lt;/code&gt; bytes (also normally 2 kB, adjustable) or no more gains can be had. During an UPDATE operation, values of unchanged fields are normally preserved as-is; so an UPDATE of a row with out-of-line values incurs no TOAST costs if none of the out-of-line values change.</source>
          <target state="translated">Код управления TOAST запускается только тогда, когда значение строки, которое должно быть сохранено в таблице, шире, чем байты &lt;code&gt;TOAST_TUPLE_THRESHOLD&lt;/code&gt; (обычно 2 кБ). Код TOAST будет сжимать и / или перемещать значения полей за пределы строки до тех пор, пока значение строки не станет короче, чем &lt;code&gt;TOAST_TUPLE_TARGET&lt;/code&gt; байтов (также обычно 2 кБ, регулируется), или пока больше не будет получено никакого усиления. Во время операции UPDATE значения неизмененных полей обычно сохраняются как есть; поэтому ОБНОВЛЕНИЕ строки с внешними значениями не требует затрат TOAST, если ни одно из внешних значений не изменится.</target>
        </trans-unit>
        <trans-unit id="2962f8d4658219a67247690e9e9ec2e5d8ddb34b" translate="yes" xml:space="preserve">
          <source>The TOAST management code recognizes four different strategies for storing TOAST-able columns on disk:</source>
          <target state="translated">Управляющий код TOAST распознает четыре различные стратегии хранения столбцов TOAST на диске:</target>
        </trans-unit>
        <trans-unit id="a81c03b713c7e31311d0848c27a627beb8a79d13" translate="yes" xml:space="preserve">
          <source>The Time Stamp Counter (TSC) clock source is the most accurate one available on current generation CPUs. It's the preferred way to track the system time when it's supported by the operating system and the TSC clock is reliable. There are several ways that TSC can fail to provide an accurate timing source, making it unreliable. Older systems can have a TSC clock that varies based on the CPU temperature, making it unusable for timing. Trying to use TSC on some older multicore CPUs can give a reported time that's inconsistent among multiple cores. This can result in the time going backwards, a problem this program checks for. And even the newest systems can fail to provide accurate TSC timing with very aggressive power saving configurations.</source>
          <target state="translated">Источник часов с метками времени (TSC)является наиболее точным из доступных на ЦПУ текущего поколения.Это предпочтительный способ отслеживания системного времени,когда он поддерживается операционной системой и часы TSC надежны.Существует несколько способов,при помощи которых TSC может не предоставить точный источник времени,что делает его ненадежным.Более старые системы могут иметь часы TSC,которые варьируются в зависимости от температуры ЦП,что делает их непригодными для синхронизации.Попытки использовать TSC на некоторых старых многоядерных процессорах могут давать отчетное время,которое несовместимо с несколькими ядрами.Это может привести к тому,что время пойдет в обратном направлении,проблема,которую эта программа проверяет.И даже новейшие системы могут не обеспечивать точную синхронизацию TSC с очень агрессивными конфигурациями энергосбережения.</target>
        </trans-unit>
        <trans-unit id="42e64c3210927fbc153414d6d364fd7a502138f4" translate="yes" xml:space="preserve">
          <source>The URL scheme &lt;code&gt;ldaps&lt;/code&gt; chooses the LDAPS method for making LDAP connections over SSL, equivalent to using &lt;code&gt;ldapscheme=ldaps&lt;/code&gt;. To use encrypted LDAP connections using the &lt;code&gt;StartTLS&lt;/code&gt; operation, use the normal URL scheme &lt;code&gt;ldap&lt;/code&gt; and specify the &lt;code&gt;ldaptls&lt;/code&gt; option in addition to &lt;code&gt;ldapurl&lt;/code&gt;.</source>
          <target state="translated">Схема URL &lt;code&gt;ldaps&lt;/code&gt; выбирает метод LDAPS для создания LDAP-соединений через SSL, что эквивалентно использованию &lt;code&gt;ldapscheme=ldaps&lt;/code&gt; . Чтобы использовать зашифрованные соединения LDAP с &lt;code&gt;StartTLS&lt;/code&gt; операции StartTLS , используйте обычную схему URL-адресов &lt;code&gt;ldap&lt;/code&gt; и укажите параметр &lt;code&gt;ldaptls&lt;/code&gt; в дополнение к &lt;code&gt;ldapurl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c6010c68a5af10d545c5e024dfa86cf3e81ff1d" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works fully only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\u007F&lt;/code&gt;) can be specified. Both the 4-digit and the 8-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 8-digit form technically makes this unnecessary. (When surrogate pairs are used when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;, they are first combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="translated">Синтаксис экранирования Unicode работает полностью только в том случае, если кодировка сервера - &lt;code&gt;UTF8&lt;/code&gt; . При использовании других серверных кодировок можно указать только кодовые точки в диапазоне ASCII (до &lt;code&gt;\u007F&lt;/code&gt; ). Как 4-значная, так и 8-значная форма могут использоваться для указания суррогатных пар UTF-16 для составления символов с кодовыми точками, большими, чем U + FFFF, хотя наличие 8-значной формы технически делает это ненужным. (Когда используются суррогатные пары, когда кодировка сервера - &lt;code&gt;UTF8&lt;/code&gt; , они сначала объединяются в одну кодовую точку, которая затем кодируется в UTF-8.)</target>
        </trans-unit>
        <trans-unit id="9d177c404952bede8f8a850e0e6bf27fc770e815" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\007F&lt;/code&gt;) can be specified. Both the 4-digit and the 6-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (Surrogate pairs are not stored directly, but combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="translated">Синтаксис экранирования Unicode работает только в том случае, если кодировка сервера - &lt;code&gt;UTF8&lt;/code&gt; . При использовании других серверных кодировок можно указать только кодовые точки в диапазоне ASCII (до &lt;code&gt;\007F&lt;/code&gt; ). Как 4-значная, так и 6-значная форма могут использоваться для указания суррогатных пар UTF-16 для составления символов с кодовыми точками, превышающими U + FFFF, хотя наличие 6-значной формы технически делает это ненужным. (Суррогатные пары не сохраняются напрямую, а объединяются в одну кодовую точку, которая затем кодируется в UTF-8.)</target>
        </trans-unit>
        <trans-unit id="7a66f8e165736e1d6137c7cb68f9f8d177bec3f5" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\007F&lt;/code&gt;) can be specified. Both the 4-digit and the 6-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (When surrogate pairs are used when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;, they are first combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="translated">Синтаксис экранирования Unicode работает только в том случае, если кодировка сервера - &lt;code&gt;UTF8&lt;/code&gt; . Когда используются другие серверные кодировки, можно указать только кодовые точки в диапазоне ASCII (до &lt;code&gt;\007F&lt;/code&gt; ). Как 4-значная, так и 6-значная форма могут использоваться для указания суррогатных пар UTF-16 для составления символов с кодовыми точками, превышающими U + FFFF, хотя наличие 6-значной формы технически делает это ненужным. (Когда используются суррогатные пары, когда кодировка сервера - &lt;code&gt;UTF8&lt;/code&gt; , они сначала объединяются в одну кодовую точку, которая затем кодируется в UTF-8.)</target>
        </trans-unit>
        <trans-unit id="f25ec485689944e9d0206ff9e943ed99a4c57c18" translate="yes" xml:space="preserve">
          <source>The WAL sender process is currently estimating the total amount of database files that will be streamed as a base backup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad15d4e7352ffeba617fa81631fe16434d0ac21" translate="yes" xml:space="preserve">
          <source>The WAL sender process is currently performing &lt;code&gt;pg_start_backup&lt;/code&gt; to prepare to take a base backup, and waiting for the start-of-backup checkpoint to finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b81498551e6dcef3f85194b60965948e30f611" translate="yes" xml:space="preserve">
          <source>The WAL sender process is currently performing &lt;code&gt;pg_stop_backup&lt;/code&gt; to finish the backup, and waiting for all the WAL files required for the base backup to be successfully archived. If either &lt;code&gt;--wal-method=none&lt;/code&gt; or &lt;code&gt;--wal-method=stream&lt;/code&gt; is specified in pg_basebackup, the backup will end when this phase is completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742081e8987be9e068dabd67697e13799d4135be" translate="yes" xml:space="preserve">
          <source>The WAL sender process is currently streaming database files as a base backup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f868b9098d5fef7b7fac16f33bf4c597bcd9b6" translate="yes" xml:space="preserve">
          <source>The WAL sender process is currently transferring all WAL logs generated during the backup. This phase occurs after &lt;code&gt;waiting for wal archiving to finish&lt;/code&gt; phase if &lt;code&gt;--wal-method=fetch&lt;/code&gt; is specified in pg_basebackup. The backup will end when this phase is completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="614ca7f59107c1f62192373c03f83f3a6cdc3ee6" translate="yes" xml:space="preserve">
          <source>The WAL sender process is preparing to begin the backup. This phase is expected to be very brief.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ece699458bd7501153fdfb1c5912141f3441417" translate="yes" xml:space="preserve">
          <source>The XPath-based functions support passing one parameter to serve as the XPath expression's context item, but do not support passing additional values to be available to the expression as named parameters.</source>
          <target state="translated">Функции,основанные на XPath,поддерживают передачу одного параметра в качестве контекстного элемента выражения XPath,но не поддерживают передачу дополнительных значений,которые должны быть доступны выражению в качестве именованных параметров.</target>
        </trans-unit>
        <trans-unit id="68d2d71e2fc0b0be97c31a2b21762a50375e3cf0" translate="yes" xml:space="preserve">
          <source>The ability of pg_dump and psql to write to or read from pipes makes it possible to dump a database directly from one server to another, for example:</source>
          <target state="translated">Способность pg_dump и psql записывать на трубы или читать с них позволяет,например,создавать дампы базы данных непосредственно с одного сервера на другой:</target>
        </trans-unit>
        <trans-unit id="fa4fd86ff72f122e1d8e3fdfa6f01d6588a00c68" translate="yes" xml:space="preserve">
          <source>The ability to create a composite type with zero attributes is a PostgreSQL-specific deviation from the standard (analogous to the same case in &lt;code&gt;CREATE TABLE&lt;/code&gt;).</source>
          <target state="translated">Возможность создания составного типа с нулевыми атрибутами - это специфическое для PostgreSQL отклонение от стандарта (аналогично тому же случаю в &lt;code&gt;CREATE TABLE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="adfc2f9948045f7d285be1359a7594bd62946d41" translate="yes" xml:space="preserve">
          <source>The ability to create like-named objects in different schemas complicates writing a query that references precisely the same objects every time. It also opens up the potential for users to change the behavior of other users' queries, maliciously or accidentally. Due to the prevalence of unqualified names in queries and their use in PostgreSQL internals, adding a schema to &lt;code&gt;search_path&lt;/code&gt; effectively trusts all users having &lt;code&gt;CREATE&lt;/code&gt; privilege on that schema. When you run an ordinary query, a malicious user able to create objects in a schema of your search path can take control and execute arbitrary SQL functions as though you executed them.</source>
          <target state="translated">Возможность создавать объекты с одинаковыми именами в разных схемах усложняет написание запроса, который каждый раз ссылается на одни и те же объекты. Это также открывает для пользователей возможность злонамеренно или случайно изменить поведение запросов других пользователей. Из-за преобладания неквалифицированных имен в запросах и их использования во внутреннем устройстве PostgreSQL добавление схемы в &lt;code&gt;search_path&lt;/code&gt; эффективно доверяет всем пользователям, имеющим привилегию &lt;code&gt;CREATE&lt;/code&gt; для этой схемы. Когда вы запускаете обычный запрос, злоумышленник, способный создавать объекты в схеме вашего пути поиска, может взять на себя управление и выполнять произвольные функции SQL, как если бы вы их выполняли.</target>
        </trans-unit>
        <trans-unit id="b4ae0fec1e129dc1403f8e4a1f54de4512e5b908" translate="yes" xml:space="preserve">
          <source>The ability to fire triggers for &lt;code&gt;TRUNCATE&lt;/code&gt; is a PostgreSQL extension of the SQL standard, as is the ability to define statement-level triggers on views.</source>
          <target state="translated">Возможность запускать триггеры для &lt;code&gt;TRUNCATE&lt;/code&gt; является расширением PostgreSQL стандарта SQL, как и возможность определять триггеры на уровне операторов для представлений.</target>
        </trans-unit>
        <trans-unit id="a5cde4cacd03ad144a2f1d01e84ddaf95711d39b" translate="yes" xml:space="preserve">
          <source>The ability to handle parts of executing a &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;query&lt;/a&gt; to take advantage of parallel processes on servers with multiple CPUs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3edb8c451c19be6c183faaf56035a29e2c4b780" translate="yes" xml:space="preserve">
          <source>The ability to restore the database to a previous point in time creates some complexities that are akin to science-fiction stories about time travel and parallel universes. For example, in the original history of the database, suppose you dropped a critical table at 5:15PM on Tuesday evening, but didn't realize your mistake until Wednesday noon. Unfazed, you get out your backup, restore to the point-in-time 5:14PM Tuesday evening, and are up and running. In &lt;em&gt;this&lt;/em&gt; history of the database universe, you never dropped the table. But suppose you later realize this wasn't such a great idea, and would like to return to sometime Wednesday morning in the original history. You won't be able to if, while your database was up-and-running, it overwrote some of the WAL segment files that led up to the time you now wish you could get back to. Thus, to avoid this, you need to distinguish the series of WAL records generated after you've done a point-in-time recovery from those that were generated in the original database history.</source>
          <target state="translated">Возможность восстановить базу данных на предыдущий момент времени создает некоторые сложности, похожие на научно-фантастические истории о путешествиях во времени и параллельных вселенных. Например, в исходной истории базы данных предположим, что вы сбросили критическую таблицу в 17:15 во вторник вечером, но не осознали свою ошибку до полудня среды. Не беспокоясь, вы достаете свою резервную копию, восстанавливаете до нужного момента времени в 17:14 во вторник вечером и готовы к работе. В &lt;em&gt;этом&lt;/em&gt;история вселенной базы данных, вы никогда не уронили таблицу. Но предположим, что позже вы поймете, что это была не такая уж хорошая идея, и хотели бы вернуться к утру среды в первоначальной истории. Вы не сможете этого сделать, если, пока ваша база данных была в рабочем состоянии, она перезаписала некоторые файлы сегментов WAL, которые привели к тому времени, к которому вы теперь хотите вернуться. Таким образом, чтобы избежать этого, вам нужно отличать серию записей WAL, созданных после того, как вы выполнили восстановление на определенный момент времени, от тех, которые были созданы в исходной истории базы данных.</target>
        </trans-unit>
        <trans-unit id="e29767e86a52c901615b571a0d1b5b49dcfd5235" translate="yes" xml:space="preserve">
          <source>The ability to specify argument modes and names</source>
          <target state="translated">Возможность задавать режимы и имена аргументов</target>
        </trans-unit>
        <trans-unit id="f83cfa93265ba6bdf2c4af4154ac85132df7584f" translate="yes" xml:space="preserve">
          <source>The ability to specify both &lt;code&gt;DISTINCT&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; in an aggregate function is a PostgreSQL extension.</source>
          <target state="translated">Возможность указывать &lt;code&gt;DISTINCT&lt;/code&gt; и &lt;code&gt;ORDER BY&lt;/code&gt; в агрегатной функции является расширением PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="36892c35402a71971c62f926cf33611f0095f448" translate="yes" xml:space="preserve">
          <source>The ability to specify multiple actions for a single trigger using &lt;code&gt;OR&lt;/code&gt; is a PostgreSQL extension of the SQL standard.</source>
          <target state="translated">Возможность указывать несколько действий для одного триггера с помощью &lt;code&gt;OR&lt;/code&gt; является расширением PostgreSQL стандарта SQL.</target>
        </trans-unit>
        <trans-unit id="12f8b21071990877da6aa1b7a33a6ab04258d42b" translate="yes" xml:space="preserve">
          <source>The ability to temporarily enable or disable a trigger is provided by &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;, not by &lt;code&gt;ALTER TRIGGER&lt;/code&gt;, because &lt;code&gt;ALTER TRIGGER&lt;/code&gt; has no convenient way to express the option of enabling or disabling all of a table's triggers at once.</source>
          <target state="translated">Возможность временного включения или отключения триггера обеспечивается &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; , а не &lt;code&gt;ALTER TRIGGER&lt;/code&gt; , потому что &lt;code&gt;ALTER TRIGGER&lt;/code&gt; не имеет удобного способа выразить возможность включения или отключения всех триггеров таблицы одновременно.</target>
        </trans-unit>
        <trans-unit id="181b9f5d513d598d56342cbdee6549b14a30572c" translate="yes" xml:space="preserve">
          <source>The ability to use indexes with &lt;code&gt;LIKE&lt;/code&gt; clauses</source>
          <target state="translated">Возможность использовать индексы с предложениями &lt;code&gt;LIKE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf1bad54aa29381ffc99e0cd6534801214045eea" translate="yes" xml:space="preserve">
          <source>The above are all simple text search examples. As mentioned before, full text search functionality includes the ability to do many more things: skip indexing certain words (stop words), process synonyms, and use sophisticated parsing, e.g., parse based on more than just white space. This functionality is controlled by &lt;em&gt;text search configurations&lt;/em&gt;. PostgreSQL comes with predefined configurations for many languages, and you can easily create your own configurations. (psql's &lt;code&gt;\dF&lt;/code&gt; command shows all available configurations.)</source>
          <target state="translated">Выше приведены все примеры простого текстового поиска. Как упоминалось ранее, функция полнотекстового поиска включает в себя возможность делать гораздо больше: пропускать индексацию определенных слов (стоп-слов), обрабатывать синонимы и использовать сложный синоним, например, анализ на основе большего, чем просто пробела. Эта функция контролируется &lt;em&gt;конфигурациями текстового поиска&lt;/em&gt; . PostgreSQL поставляется с предопределенными конфигурациями для многих языков, и вы можете легко создавать свои собственные конфигурации. ( Команда psql &lt;code&gt;\dF&lt;/code&gt; показывает все доступные конфигурации.)</target>
        </trans-unit>
        <trans-unit id="2c3e1167e52b923579b2a7fc4d461580b2f1f1dc" translate="yes" xml:space="preserve">
          <source>The above operations should be performed by an administrative user.</source>
          <target state="translated">Вышеперечисленные операции должен выполнять административный пользователь.</target>
        </trans-unit>
        <trans-unit id="d0d28ebaf3e9bc7217eabce77d41a45e775db518" translate="yes" xml:space="preserve">
          <source>The above query only shows the rows from the inner query having &lt;code&gt;rank&lt;/code&gt; less than 3.</source>
          <target state="translated">Вышеупомянутый запрос показывает только строки из внутреннего запроса, имеющие &lt;code&gt;rank&lt;/code&gt; меньше 3.</target>
        </trans-unit>
        <trans-unit id="5129e9bc20e65e89b0d436aa6187d7cf918d1aeb" translate="yes" xml:space="preserve">
          <source>The above query using &lt;code&gt;int_array_enum&lt;/code&gt; produces the same results as</source>
          <target state="translated">Вышеупомянутый запрос с использованием &lt;code&gt;int_array_enum&lt;/code&gt; дает те же результаты, что и</target>
        </trans-unit>
        <trans-unit id="8107fdc88da76184415ef69e2ecad722706ac13d" translate="yes" xml:space="preserve">
          <source>The above rules associate greediness attributes not only with individual quantified atoms, but with branches and entire REs that contain quantified atoms. What that means is that the matching is done in such a way that the branch, or whole RE, matches the longest or shortest possible substring &lt;em&gt;as a whole&lt;/em&gt;. Once the length of the entire match is determined, the part of it that matches any particular subexpression is determined on the basis of the greediness attribute of that subexpression, with subexpressions starting earlier in the RE taking priority over ones starting later.</source>
          <target state="translated">Приведенные выше правила связывают атрибуты жадности не только с отдельными количественно определенными атомами, но и с ветвями и целыми RE, которые содержат количественно определенные атомы. Это означает, что сопоставление выполняется таким образом, что ветвь или весь RE соответствует самой длинной или самой короткой возможной подстроке &lt;em&gt;в целом&lt;/em&gt; . Как только длина всего совпадения определена, его часть, которая соответствует любому конкретному подвыражению, определяется на основе атрибута жадности этого подвыражения, причем подвыражения, начинающиеся раньше в RE, имеют приоритет над теми, которые начинаются позже.</target>
        </trans-unit>
        <trans-unit id="fe4e00a739ad370965c561bc4d7c298f0756e50c" translate="yes" xml:space="preserve">
          <source>The above skeleton is suitable for the case where no decompression is needed. (But, of course, omitting the method altogether is even easier, and is recommended in such cases.)</source>
          <target state="translated">Вышеуказанный скелет подходит для случая,когда декомпрессия не требуется.(Но,конечно,полностью отказаться от этого метода еще проще,и в таких случаях рекомендуется).</target>
        </trans-unit>
        <trans-unit id="6987a09f0b14c398190d54898784ad9944a48328" translate="yes" xml:space="preserve">
          <source>The above syntax has the drawback that you need to know the order of the columns in the table. To avoid this you can also list the columns explicitly. For example, both of the following commands have the same effect as the one above:</source>
          <target state="translated">Синтаксис выше имеет недостаток,заключающийся в том,что вам необходимо знать порядок расположения столбцов в таблице.Чтобы избежать этого,вы также можете явным образом перечислить столбцы.Например,обе следующие команды имеют тот же эффект,что и вышеприведенная:</target>
        </trans-unit>
        <trans-unit id="d92b695ce2e1fc99e7debc111a49b6a3b4275271" translate="yes" xml:space="preserve">
          <source>The above transaction will insert both 3 and 4.</source>
          <target state="translated">Вышеуказанная операция будет вставлена как 3,так и 4.</target>
        </trans-unit>
        <trans-unit id="d3ded6bad4b3e8cb90f32aef7f2e2ce8e740539c" translate="yes" xml:space="preserve">
          <source>The above transaction will insert the values 1 and 3, but not 2.</source>
          <target state="translated">Вышеуказанная операция вставит значения 1 и 3,но не 2.</target>
        </trans-unit>
        <trans-unit id="dec9b433ac3e4e8910b0ae4310ac815b98eb482c" translate="yes" xml:space="preserve">
          <source>The above will start the replication process, which synchronizes the initial table contents of the tables &lt;code&gt;users&lt;/code&gt; and &lt;code&gt;departments&lt;/code&gt; and then starts replicating incremental changes to those tables.</source>
          <target state="translated">Вышеупомянутый запускает процесс репликации, который синхронизирует исходное содержимое таблиц &lt;code&gt;users&lt;/code&gt; и &lt;code&gt;departments&lt;/code&gt; а затем начинает репликацию инкрементных изменений в эти таблицы.</target>
        </trans-unit>
        <trans-unit id="4792ca68861299622c8a8489cae6e3ff6fc1e734" translate="yes" xml:space="preserve">
          <source>The access costs should include all disk and CPU costs associated with scanning the index itself, but &lt;em&gt;not&lt;/em&gt; the costs of retrieving or processing the parent-table rows that are identified by the index.</source>
          <target state="translated">Затраты на доступ должны включать все затраты на диск и ЦП, связанные со сканированием самого индекса, но &lt;em&gt;не&lt;/em&gt; затраты на извлечение или обработку строк родительской таблицы, которые определяются индексом.</target>
        </trans-unit>
        <trans-unit id="07883ad5be74942310a3c715c9a683e447816066" translate="yes" xml:space="preserve">
          <source>The access method can report that the index is &lt;em&gt;lossy&lt;/em&gt;, or requires rechecks, for a particular query. This implies that the index scan will return all the entries that pass the scan key, plus possibly additional entries that do not. The core system's index-scan machinery will then apply the index conditions again to the heap tuple to verify whether or not it really should be selected. If the recheck option is not specified, the index scan must return exactly the set of matching entries.</source>
          <target state="translated">Метод доступа может сообщить, что индекс &lt;em&gt;с потерями&lt;/em&gt; или требует повторной проверки для определенного запроса. Это означает, что сканирование индекса вернет все записи, которые передают ключ сканирования, а также, возможно, дополнительные записи, которые этого не сделали. Затем механизм сканирования индекса базовой системы снова применит условия индекса к кортежу кучи, чтобы проверить, действительно ли он должен быть выбран. Если опция повторной проверки не указана, сканирование индекса должно возвращать точно набор совпадающих записей.</target>
        </trans-unit>
        <trans-unit id="7463ace40ac0727457d3fd85331890fec1e03b44" translate="yes" xml:space="preserve">
          <source>The access method must identify any rows which might violate the unique constraint, but it is not an error for it to report false positives. This allows the check to be done without waiting for other transactions to finish; conflicts reported here are not treated as errors and will be rechecked later, by which time they may no longer be conflicts.</source>
          <target state="translated">Метод доступа должен идентифицировать любые строки,которые могут нарушить уникальное ограничение,но для него не является ошибкой сообщать о ложных срабатываниях.Это позволяет проводить проверку,не дожидаясь завершения других транзакций;конфликты,сообщаемые здесь,не рассматриваются как ошибки и будут перепроверены позже,к тому времени,когда они могут перестать быть конфликтами.</target>
        </trans-unit>
        <trans-unit id="3b57f7233950ac2f66da1f759e801ef6dd2f3764" translate="yes" xml:space="preserve">
          <source>The access method must support &lt;code&gt;amgettuple&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;Chapter 61&lt;/a&gt;); at present this means GIN cannot be used. Although it's allowed, there is little point in using B-tree or hash indexes with an exclusion constraint, because this does nothing that an ordinary unique constraint doesn't do better. So in practice the access method will always be GiST or SP-GiST.</source>
          <target state="translated">Метод доступа должен поддерживать &lt;code&gt;amgettuple&lt;/code&gt; (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;Главу 61&lt;/a&gt; ); в настоящее время это означает, что GIN нельзя использовать. Хотя это разрешено, нет особого смысла в использовании B-дерева или хэш-индексов с ограничением исключения, потому что это не делает ничего такого, что обычное ограничение уникальности не работает лучше. Таким образом, на практике метод доступа всегда будет GiST или SP-GiST.</target>
        </trans-unit>
        <trans-unit id="f11bb13c1be4b89a9073f3965e1e4a21ea97d02b" translate="yes" xml:space="preserve">
          <source>The access method must support &lt;code&gt;amgettuple&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/indexam.html&quot;&gt;Chapter 61&lt;/a&gt;); at present this means GIN cannot be used. Although it's allowed, there is little point in using B-tree or hash indexes with an exclusion constraint, because this does nothing that an ordinary unique constraint doesn't do better. So in practice the access method will always be GiST or SP-GiST.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="925d234c42527636b378041891a37fa8bc13f69a" translate="yes" xml:space="preserve">
          <source>The access method name must be unique within the database.</source>
          <target state="translated">Имя метода доступа должно быть уникальным в базе данных.</target>
        </trans-unit>
        <trans-unit id="269e5a0688390217e0c08f2b5f501b6e542e7ab1" translate="yes" xml:space="preserve">
          <source>The accumulated cost that will cause the vacuuming process to sleep. The default value is 200.</source>
          <target state="translated">Накопленная стоимость,которая заставит процесс вакуумирования заснуть.Значение по умолчанию-200.</target>
        </trans-unit>
        <trans-unit id="1dfce3d6c647c6b7a46c7536dcf8246e840a748e" translate="yes" xml:space="preserve">
          <source>The accumulating calendar error prompted Pope Gregory XIII to reform the calendar in accordance with instructions from the Council of Trent. In the Gregorian calendar, the tropical year is approximated as 365 + 97 / 400 days = 365.2425 days. Thus it takes approximately 3300 years for the tropical year to shift one day with respect to the Gregorian calendar.</source>
          <target state="translated">Накопившаяся календарная ошибка побудила Папу Римского Григория XIII реформировать календарь в соответствии с указаниями Трентского Совета.В григорианском календаре тропический год приблизительно равен 365+97/400 дням=365.2425 дням.Таким образом,в тропическом году для смены одного дня по отношению к григорианскому календарю требуется примерно 3300 лет.</target>
        </trans-unit>
        <trans-unit id="e8af8f1a0118bcdb3de7cccd47ade7dfba7146dc" translate="yes" xml:space="preserve">
          <source>The act of finalizing a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; within the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;, which makes it visible to other transactions and assures its &lt;a href=&quot;glossary#GLOSSARY-DURABILITY&quot;&gt;durability&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db888abdcc969733f24ba8448a46853590f7acc2" translate="yes" xml:space="preserve">
          <source>The act of reproducing data on one &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; onto another server called a &lt;a href=&quot;glossary#GLOSSARY-REPLICA&quot;&gt;replica&lt;/a&gt;. This can take the form of &lt;em&gt;physical replication&lt;/em&gt;, where all file changes from one server are copied verbatim, or &lt;em&gt;logical replication&lt;/em&gt; where a defined subset of data changes are conveyed using a higher-level representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5a51f4541a92f0a7b8eafcdaec433dbe4bd0a9" translate="yes" xml:space="preserve">
          <source>The actions for identity columns (&lt;code&gt;ADD GENERATED&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt; etc., &lt;code&gt;DROP IDENTITY&lt;/code&gt;), as well as the actions &lt;code&gt;TRIGGER&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;OWNER&lt;/code&gt;, and &lt;code&gt;TABLESPACE&lt;/code&gt; never recurse to descendant tables; that is, they always act as though &lt;code&gt;ONLY&lt;/code&gt; were specified. Adding a constraint recurses only for &lt;code&gt;CHECK&lt;/code&gt; constraints that are not marked &lt;code&gt;NO INHERIT&lt;/code&gt;.</source>
          <target state="translated">Действия для столбцов идентификаторов ( &lt;code&gt;ADD GENERATED&lt;/code&gt; , &lt;code&gt;SET&lt;/code&gt; и т. Д., &lt;code&gt;DROP IDENTITY&lt;/code&gt; ), а также действия &lt;code&gt;TRIGGER&lt;/code&gt; , &lt;code&gt;CLUSTER&lt;/code&gt; , &lt;code&gt;OWNER&lt;/code&gt; и &lt;code&gt;TABLESPACE&lt;/code&gt; никогда не рекурсивно передаются в дочерние таблицы; то есть они всегда действуют так, как если бы &lt;code&gt;ONLY&lt;/code&gt; были указаны. Добавление ограничения рекурсивно только для ограничений &lt;code&gt;CHECK&lt;/code&gt; , которые не помечены как &lt;code&gt;NO INHERIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="909f7edd282ab8c888fdf2ed34039a5329b6ad7a" translate="yes" xml:space="preserve">
          <source>The actual choice here is mostly a matter of taste, constrained only by possible restrictions in client applications. Both methods support all possible values, although the hex encoding will be somewhat larger than the base64 encoding.</source>
          <target state="translated">Реальный выбор здесь,в основном,дело вкуса,ограниченного только возможными ограничениями в клиентских приложениях.Оба метода поддерживают все возможные значения,хотя шестнадцатеричная кодировка будет несколько больше,чем базовая64-кодировка.</target>
        </trans-unit>
        <trans-unit id="42c8786b869e4cc819db8d6cf4749d981fd3444f" translate="yes" xml:space="preserve">
          <source>The actual colors to be used are configured using the environment variable &lt;code&gt;PG_COLORS&lt;/code&gt; (note plural). The value is a colon-separated list of &lt;code&gt;key=value&lt;/code&gt; pairs. The keys specify what the color is to be used for. The values are SGR (Select Graphic Rendition) specifications, which are interpreted by the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486a25c1f79db6232bfe3c602e8f3539de88dd46" translate="yes" xml:space="preserve">
          <source>The actual data types of the various &lt;code&gt;Datum&lt;/code&gt; values mentioned above vary depending on the operator class. The item values passed to &lt;code&gt;extractValue&lt;/code&gt; are always of the operator class's input type, and all key values must be of the class's &lt;code&gt;STORAGE&lt;/code&gt; type. The type of the &lt;code&gt;query&lt;/code&gt; argument passed to &lt;code&gt;extractQuery&lt;/code&gt;, &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;triConsistent&lt;/code&gt; is whatever is the right-hand input type of the class member operator identified by the strategy number. This need not be the same as the indexed type, so long as key values of the correct type can be extracted from it. However, it is recommended that the SQL declarations of these three support functions use the opclass's indexed data type for the &lt;code&gt;query&lt;/code&gt; argument, even though the actual type might be something else depending on the operator.</source>
          <target state="translated">Фактические типы данных различных значений &lt;code&gt;Datum&lt;/code&gt; , упомянутых выше, различаются в зависимости от класса оператора. Значения элементов, передаваемые в &lt;code&gt;extractValue&lt;/code&gt; , всегда относятся к типу ввода класса оператора, и все значения ключей должны иметь тип &lt;code&gt;STORAGE&lt;/code&gt; класса . Тип аргумента &lt;code&gt;query&lt;/code&gt; переданного в &lt;code&gt;extractQuery&lt;/code&gt; , &lt;code&gt;consistent&lt;/code&gt; и &lt;code&gt;triConsistent&lt;/code&gt; - это то, что является правым типом ввода оператора-члена класса, идентифицированного по номеру стратегии. Он не обязательно должен быть таким же, как индексированный тип, если из него можно извлечь ключевые значения правильного типа. Однако рекомендуется, чтобы в объявлениях SQL этих трех вспомогательных функций использовался индексированный тип данных opclass для аргумента &lt;code&gt;query&lt;/code&gt; , даже если фактический тип может быть другим, в зависимости от оператора.</target>
        </trans-unit>
        <trans-unit id="941436b14f077228160b589974e7f72ed527cb34" translate="yes" xml:space="preserve">
          <source>The actual items themselves.</source>
          <target state="translated">Сами предметы.</target>
        </trans-unit>
        <trans-unit id="fffe8ba3b231865545aa8ca6fdb204ce35d44eac" translate="yes" xml:space="preserve">
          <source>The actual number of rows this query would select is 7000, but the &lt;code&gt;rows&lt;/code&gt; estimate is only approximate. If you try to duplicate this experiment, you will probably get a slightly different estimate; moreover, it can change after each &lt;code&gt;ANALYZE&lt;/code&gt; command, because the statistics produced by &lt;code&gt;ANALYZE&lt;/code&gt; are taken from a randomized sample of the table.</source>
          <target state="translated">Фактическое количество строк, которое выберет этот запрос, составляет 7000, но оценка &lt;code&gt;rows&lt;/code&gt; является лишь приблизительной. Если вы попытаетесь повторить этот эксперимент, вы, вероятно, получите немного другую оценку; более того, он может изменяться после каждой команды &lt;code&gt;ANALYZE&lt;/code&gt; , потому что статистика, производимая &lt;code&gt;ANALYZE&lt;/code&gt; , берется из случайной выборки таблицы.</target>
        </trans-unit>
        <trans-unit id="6d27af95eda9a00aefcefbbb3f7c08b95ed3e6d3" translate="yes" xml:space="preserve">
          <source>The actual output rows are computed using the &lt;code&gt;SELECT&lt;/code&gt; output expressions for each selected row or row group. (See &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; List&lt;/a&gt; below.)</source>
          <target state="translated">Фактические выходные строки вычисляются с использованием выходных выражений &lt;code&gt;SELECT&lt;/code&gt; для каждой выбранной строки или группы строк. (См. &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;Список &lt;/a&gt; &lt;code&gt;SELECT&lt;/code&gt; ниже.)</target>
        </trans-unit>
        <trans-unit id="748767c5001b9a6c88bed2030a93343c4f97acfc" translate="yes" xml:space="preserve">
          <source>The actual output rows are computed using the &lt;code&gt;SELECT&lt;/code&gt; output expressions for each selected row or row group. (See &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;SELECT List&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="747c207c89333b66eb66b4cfc2d12a9cf95c6535" translate="yes" xml:space="preserve">
          <source>The actual value of a parameter to the prepared statement. This must be an expression yielding a value that is compatible with the data type of this parameter, as was determined when the prepared statement was created.</source>
          <target state="translated">Фактическое значение параметра к подготовленному отчету.Это должно быть выражение,дающее значение,совместимое с типом данных этого параметра,как было определено при создании подготовленного оператора.</target>
        </trans-unit>
        <trans-unit id="ac7f1235d4be6ac9ddfc264172bcdc008188f6f4" translate="yes" xml:space="preserve">
          <source>The added condition &lt;code&gt;stringu1 = 'xxx'&lt;/code&gt; reduces the output row count estimate, but not the cost because we still have to visit the same set of rows. Notice that the &lt;code&gt;stringu1&lt;/code&gt; clause cannot be applied as an index condition, since this index is only on the &lt;code&gt;unique1&lt;/code&gt; column. Instead it is applied as a filter on the rows retrieved by the index. Thus the cost has actually gone up slightly to reflect this extra checking.</source>
          <target state="translated">Добавленное условие &lt;code&gt;stringu1 = 'xxx'&lt;/code&gt; уменьшает оценку количества выходных строк, но не снижает стоимость, потому что нам все равно нужно посещать тот же набор строк. Обратите внимание, что предложение &lt;code&gt;stringu1&lt;/code&gt; не может применяться как условие индекса, поскольку этот индекс находится только в столбце &lt;code&gt;unique1&lt;/code&gt; . Вместо этого он применяется как фильтр к строкам, полученным индексом. Таким образом, стоимость фактически немного выросла, чтобы отразить эту дополнительную проверку.</target>
        </trans-unit>
        <trans-unit id="0d6d3b7f07c64185ea468d2b62ff4270f9a83a5e" translate="yes" xml:space="preserve">
          <source>The additional &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; phase adds significant overhead: verification will typically take several times longer. However, there is no change to the relation-level locks acquired when &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is performed.</source>
          <target state="translated">Дополнительная фаза &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; добавляет значительные накладные расходы: проверка обычно занимает в несколько раз больше времени. Однако при &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; проверки с &lt;em&gt;индексом кучи&lt;/em&gt; не происходит никаких изменений в блокировках на уровне отношений .</target>
        </trans-unit>
        <trans-unit id="9c1fb74bfe43620aa3ec5e950d1f4303783e6a3c" translate="yes" xml:space="preserve">
          <source>The address (&lt;code&gt;LSN&lt;/code&gt;) of oldest WAL which still might be required by the consumer of this slot and thus won't be automatically removed during checkpoints unless this LSN gets behind more than &lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt; from the current LSN. &lt;code&gt;NULL&lt;/code&gt; if the &lt;code&gt;LSN&lt;/code&gt; of this slot has never been reserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce4777382e2000ea7e60f8a7131343e38753550" translate="yes" xml:space="preserve">
          <source>The address (&lt;code&gt;LSN&lt;/code&gt;) of oldest WAL which still might be required by the consumer of this slot and thus won't be automatically removed during checkpoints. &lt;code&gt;NULL&lt;/code&gt; if the &lt;code&gt;LSN&lt;/code&gt; of this slot has never been reserved.</source>
          <target state="translated">Адрес ( &lt;code&gt;LSN&lt;/code&gt; ) самого старого WAL, который все еще может потребоваться потребителю этого слота и, следовательно, не будет автоматически удален во время контрольных точек. &lt;code&gt;NULL&lt;/code&gt; , если &lt;code&gt;LSN&lt;/code&gt; этого слота никогда не был зарезервирован.</target>
        </trans-unit>
        <trans-unit id="034439fc21dbd36a2802df824278cae81f75f88d" translate="yes" xml:space="preserve">
          <source>The address (&lt;code&gt;LSN&lt;/code&gt;) up to which the logical slot's consumer has confirmed receiving data. Data older than this is not available anymore. &lt;code&gt;NULL&lt;/code&gt; for physical slots.</source>
          <target state="translated">Адрес ( &lt;code&gt;LSN&lt;/code&gt; ), по которому потребитель логического слота подтвердил получение данных. Данные старше этого срока больше не доступны. &lt;code&gt;NULL&lt;/code&gt; для физических слотов.</target>
        </trans-unit>
        <trans-unit id="7a0ec05d31abc58e50953bffde428d1c139a9fa7" translate="yes" xml:space="preserve">
          <source>The aggregate functions &lt;code&gt;array_agg&lt;/code&gt;, &lt;code&gt;json_agg&lt;/code&gt;, &lt;code&gt;jsonb_agg&lt;/code&gt;, &lt;code&gt;json_object_agg&lt;/code&gt;, &lt;code&gt;jsonb_object_agg&lt;/code&gt;, &lt;code&gt;string_agg&lt;/code&gt;, and &lt;code&gt;xmlagg&lt;/code&gt;, as well as similar user-defined aggregate functions, produce meaningfully different result values depending on the order of the input values. This ordering is unspecified by default, but can be controlled by writing an &lt;code&gt;ORDER BY&lt;/code&gt; clause within the aggregate call, as shown in &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Section 4.2.7&lt;/a&gt;. Alternatively, supplying the input values from a sorted subquery will usually work. For example:</source>
          <target state="translated">Агрегатные функции &lt;code&gt;array_agg&lt;/code&gt; , &lt;code&gt;json_agg&lt;/code&gt; , &lt;code&gt;jsonb_agg&lt;/code&gt; , &lt;code&gt;json_object_agg&lt;/code&gt; , &lt;code&gt;jsonb_object_agg&lt;/code&gt; , &lt;code&gt;string_agg&lt;/code&gt; и &lt;code&gt;xmlagg&lt;/code&gt; , а также аналогичные определяемые пользователем агрегатные функции выдают существенно разные значения результатов в зависимости от порядка входных значений. Этот порядок по умолчанию не определен, но его можно контролировать, написав предложение &lt;code&gt;ORDER BY&lt;/code&gt; внутри агрегированного вызова, как показано в &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Разделе 4.2.7&lt;/a&gt; . В качестве альтернативы обычно работает предоставление входных значений из отсортированного подзапроса. Например:</target>
        </trans-unit>
        <trans-unit id="25a2a3e2d738bffa30059bdc53d46f7e3eca9a3f" translate="yes" xml:space="preserve">
          <source>The aggregator is an aggregate function &lt;code&gt;int_array_aggregate(integer)&lt;/code&gt; that produces an integer array containing exactly the integers it is fed. This is a wrapper around &lt;code&gt;array_agg&lt;/code&gt;, which does the same thing for any array type.</source>
          <target state="translated">Агрегатор - это агрегатная функция &lt;code&gt;int_array_aggregate(integer)&lt;/code&gt; которая производит целочисленный массив, содержащий именно те целые числа, которые ему передаются. Это оболочка для &lt;code&gt;array_agg&lt;/code&gt; , которая делает то же самое для любого типа массива.</target>
        </trans-unit>
        <trans-unit id="424703d8d222e3285ae8821252bab5f244b1d269" translate="yes" xml:space="preserve">
          <source>The aim of WAL is to ensure that the log is written before database records are altered, but this can be subverted by disk drives that falsely report a successful write to the kernel, when in fact they have only cached the data and not yet stored it on the disk. A power failure in such a situation might lead to irrecoverable data corruption. Administrators should try to ensure that disks holding PostgreSQL's WAL log files do not make such false reports. (See &lt;a href=&quot;wal-reliability&quot;&gt;Section 29.1&lt;/a&gt;.)</source>
          <target state="translated">Цель WAL - обеспечить запись журнала до изменения записей базы данных, но это может быть нарушено дисками, которые ложно сообщают об успешной записи в ядро, хотя на самом деле они только кэшировали данные, но еще не сохранили их. на диске. Сбой питания в такой ситуации может привести к безвозвратному повреждению данных. Администраторы должны попытаться убедиться, что диски, содержащие файлы журнала PostgreSQL WAL, не создают таких ложных отчетов. (См. &lt;a href=&quot;wal-reliability&quot;&gt;Раздел 29.1&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="f9e7ab5030dfc9ff217b5be87f2efd2576b52bbd" translate="yes" xml:space="preserve">
          <source>The algorithms in &lt;code&gt;crypt()&lt;/code&gt; differ from the usual MD5 or SHA1 hashing algorithms in the following respects:</source>
          <target state="translated">Алгоритмы в &lt;code&gt;crypt()&lt;/code&gt; отличаются от обычных алгоритмов хеширования MD5 или SHA1 в следующих отношениях:</target>
        </trans-unit>
        <trans-unit id="bb6ddacff228befd7481577e88b1910758787a46" translate="yes" xml:space="preserve">
          <source>The alias becomes the new name of the table reference so far as the current query is concerned &amp;mdash; it is not allowed to refer to the table by the original name elsewhere in the query. Thus, this is not valid:</source>
          <target state="translated">Псевдоним становится новым именем ссылки на таблицу в том, что касается текущего запроса - не разрешается ссылаться на таблицу по исходному имени в другом месте запроса. Таким образом, это неверно:</target>
        </trans-unit>
        <trans-unit id="5c707c122664d3415484ea0149341fcdfab44cfa" translate="yes" xml:space="preserve">
          <source>The allowed contents of a &lt;code&gt;RETURNING&lt;/code&gt; clause are the same as a &lt;code&gt;SELECT&lt;/code&gt; command's output list (see &lt;a href=&quot;queries-select-lists&quot;&gt;Section 7.3&lt;/a&gt;). It can contain column names of the command's target table, or value expressions using those columns. A common shorthand is &lt;code&gt;RETURNING *&lt;/code&gt;, which selects all columns of the target table in order.</source>
          <target state="translated">Допустимое содержимое предложения &lt;code&gt;RETURNING&lt;/code&gt; такое же, как и в выходном списке команды &lt;code&gt;SELECT&lt;/code&gt; (см. &lt;a href=&quot;queries-select-lists&quot;&gt;Раздел 7.3&lt;/a&gt; ). Он может содержать имена столбцов целевой таблицы команды или выражения значений, использующие эти столбцы. Распространенным сокращением является &lt;code&gt;RETURNING *&lt;/code&gt; , которое выбирает все столбцы целевой таблицы по порядку.</target>
        </trans-unit>
        <trans-unit id="6fc27c228553cd704a3ef6963db1526d2404113f" translate="yes" xml:space="preserve">
          <source>The alternative archive file formats must be used with &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; to rebuild the database. They allow pg_restore to be selective about what is restored, or even to reorder the items prior to being restored. The archive file formats are designed to be portable across architectures.</source>
          <target state="translated">Альтернативные форматы архивных файлов должны использоваться с &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; для восстановления базы данных. Они позволяют pg_restore выбирать, что восстанавливается, или даже изменять порядок элементов перед восстановлением. Форматы файлов архивов предназначены для переносимости между архитектурами.</target>
        </trans-unit>
        <trans-unit id="30b730b12e2a6a8e73614c8aa5e3a5771cc3031c" translate="yes" xml:space="preserve">
          <source>The amount of information stored in &lt;code&gt;pg_statistic&lt;/code&gt; by &lt;code&gt;ANALYZE&lt;/code&gt;, in particular the maximum number of entries in the &lt;code&gt;most_common_vals&lt;/code&gt; and &lt;code&gt;histogram_bounds&lt;/code&gt; arrays for each column, can be set on a column-by-column basis using the &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; command, or globally by setting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration variable. The default limit is presently 100 entries. Raising the limit might allow more accurate planner estimates to be made, particularly for columns with irregular data distributions, at the price of consuming more space in &lt;code&gt;pg_statistic&lt;/code&gt; and slightly more time to compute the estimates. Conversely, a lower limit might be sufficient for columns with simple data distributions.</source>
          <target state="translated">Объем информации , хранящийся в &lt;code&gt;pg_statistic&lt;/code&gt; по &lt;code&gt;ANALYZE&lt;/code&gt; , в частности , максимальное число записей в &lt;code&gt;most_common_vals&lt;/code&gt; и &lt;code&gt;histogram_bounds&lt;/code&gt; массивов для каждого столбца, может быть установлен на основе столбца за столбцом , используя &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; команды или глобально установка &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; переменная конфигурации. Предел по умолчанию в настоящее время составляет 100 записей. Увеличение предела может позволить сделать более точные оценки планировщика, особенно для столбцов с нерегулярным распределением данных, за счет использования большего пространства в &lt;code&gt;pg_statistic&lt;/code&gt; и немного больше времени для расчета оценок. И наоборот, нижнего предела может быть достаточно для столбцов с простым распределением данных.</target>
        </trans-unit>
        <trans-unit id="0881173259f19f591f19be0dcc933c7ede671117" translate="yes" xml:space="preserve">
          <source>The amount of shared memory used for WAL data that has not yet been written to disk. The default setting of -1 selects a size equal to 1/32nd (about 3%) of &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but not less than &lt;code&gt;64kB&lt;/code&gt; nor more than the size of one WAL segment, typically &lt;code&gt;16MB&lt;/code&gt;. This value can be set manually if the automatic choice is too large or too small, but any positive value less than &lt;code&gt;32kB&lt;/code&gt; will be treated as &lt;code&gt;32kB&lt;/code&gt;. If this value is specified without units, it is taken as WAL blocks, that is &lt;code&gt;XLOG_BLCKSZ&lt;/code&gt; bytes, typically 8kB. This parameter can only be set at server start.</source>
          <target state="translated">Объем разделяемой памяти, используемой для данных WAL, которые еще не были записаны на диск. Значение по умолчанию -1 выбирает размер, равный 1/32 (около 3%) &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; , но не менее &lt;code&gt;64kB&lt;/code&gt; не более размера одного сегмента WAL, обычно &lt;code&gt;16MB&lt;/code&gt; . Это значение можно установить вручную, если автоматический выбор слишком велик или слишком мал, но любое положительное значение меньше &lt;code&gt;32kB&lt;/code&gt; будет рассматриваться как &lt;code&gt;32kB&lt;/code&gt; . Если это значение указано без единиц измерения, оно принимается как блоки WAL, то есть байты &lt;code&gt;XLOG_BLCKSZ&lt;/code&gt; , обычно 8 КБ. Этот параметр можно установить только при запуске сервера.</target>
        </trans-unit>
        <trans-unit id="fb3e8e0a1884bdfed25b92caf4ca9464cbb400f7" translate="yes" xml:space="preserve">
          <source>The amount of time that the process will sleep when the cost limit has been exceeded. If this value is specified without units, it is taken as milliseconds. The default value is zero, which disables the cost-based vacuum delay feature. Positive values enable cost-based vacuuming.</source>
          <target state="translated">Количество времени,в течение которого процесс будет спать,когда предел затрат превышен.Если это значение указано без единиц,то оно принимается за миллисекунды.Значение по умолчанию равно нулю,что отключает функцию задержки вакуума на основе затрат.Положительные значения позволяют использовать затратное вакуумирование.</target>
        </trans-unit>
        <trans-unit id="398a780c0d81cf69e4ef47e3ad5d58413fde5194" translate="yes" xml:space="preserve">
          <source>The amount of time to delay just after a new server process is forked, before it conducts the authentication procedure. This is intended to give developers an opportunity to attach to the server process with a debugger to trace down misbehavior in authentication. If this value is specified without units, it is taken as seconds. A value of zero (the default) disables the delay. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Время задержки сразу после разветвления нового серверного процесса, прежде чем он выполнит процедуру аутентификации. Это предназначено для того, чтобы дать разработчикам возможность подключиться к серверному процессу с помощью отладчика, чтобы отследить неправильное поведение при аутентификации. Если это значение указано без единиц измерения, оно принимается в секундах. Нулевое значение (по умолчанию) отключает задержку. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="eaa9e04a9a492e3d82c3eee69d98abd9fe97d974" translate="yes" xml:space="preserve">
          <source>The amount of time to delay when a new server process is started, after it conducts the authentication procedure. This is intended to give developers an opportunity to attach to the server process with a debugger. If this value is specified without units, it is taken as seconds. A value of zero (the default) disables the delay. This parameter cannot be changed after session start.</source>
          <target state="translated">Количество времени,которое требуется для задержки при запуске нового процесса на сервере,после того,как он проведет процедуру аутентификации.Это предназначено для того,чтобы дать разработчикам возможность прикрепить к серверному процессу отладчик.Если это значение указано без единиц,то оно принимается за секунды.Значение нуля (по умолчанию)отключает задержку.Этот параметр не может быть изменен после запуска сессии.</target>
        </trans-unit>
        <trans-unit id="6eb708237d12cba546c559b2942241cf8b7e257d" translate="yes" xml:space="preserve">
          <source>The apply process on the subscriber database always runs with &lt;code&gt;session_replication_role&lt;/code&gt; set to &lt;code&gt;replica&lt;/code&gt;, which produces the usual effects on triggers and constraints.</source>
          <target state="translated">Процесс применения в базе данных подписчика всегда выполняется с параметром &lt;code&gt;session_replication_role&lt;/code&gt; , установленным на &lt;code&gt;replica&lt;/code&gt; , что производит обычные эффекты на триггеры и ограничения.</target>
        </trans-unit>
        <trans-unit id="7cc0c47ee6bb287c95c39ac65d501649b42f2391" translate="yes" xml:space="preserve">
          <source>The approach of lower-casing strings for comparison does not handle some Unicode special cases correctly, for example when one upper-case letter has two lower-case letter equivalents. Unicode distinguishes between &lt;em&gt;case mapping&lt;/em&gt; and &lt;em&gt;case folding&lt;/em&gt; for this reason. Use nondeterministic collations instead of &lt;code&gt;citext&lt;/code&gt; to handle that correctly.</source>
          <target state="translated">Подход строк в нижнем регистре для сравнения некорректно обрабатывает некоторые особые случаи Unicode, например, когда одна заглавная буква имеет два эквивалента строчной буквы. По этой причине Unicode различает &lt;em&gt;отображение регистра&lt;/em&gt; и &lt;em&gt;сворачивание регистра&lt;/em&gt; . Используйте недетерминированные сопоставления вместо &lt;code&gt;citext&lt;/code&gt; для правильной обработки.</target>
        </trans-unit>
        <trans-unit id="6080666b4ca02e10aa81255d6daacddec5bda53b" translate="yes" xml:space="preserve">
          <source>The approximate average size (in bytes) of the aggregate's state value, when using moving-aggregate mode. This works the same as &lt;code&gt;state_data_size&lt;/code&gt;.</source>
          <target state="translated">Приблизительный средний размер (в байтах) значения состояния агрегата при использовании режима подвижного агрегата. Это работает так же, как &lt;code&gt;state_data_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f88fc1ceaae9590f9501a23eabf20365f3ad0987" translate="yes" xml:space="preserve">
          <source>The approximate average size (in bytes) of the aggregate's state value. If this parameter is omitted or is zero, a default estimate is used based on the &lt;code&gt;state_data_type&lt;/code&gt;. The planner uses this value to estimate the memory required for a grouped aggregate query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3a8a8bd1d1979e55b0fa66bfe45e8f15c71463" translate="yes" xml:space="preserve">
          <source>The approximate average size (in bytes) of the aggregate's state value. If this parameter is omitted or is zero, a default estimate is used based on the &lt;code&gt;state_data_type&lt;/code&gt;. The planner uses this value to estimate the memory required for a grouped aggregate query. The planner will consider using hash aggregation for such a query only if the hash table is estimated to fit in &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt;; therefore, large values of this parameter discourage use of hash aggregation.</source>
          <target state="translated">Приблизительный средний размер (в байтах) значения состояния агрегата. Если этот параметр опущен или равен нулю, используется оценка по умолчанию на основе &lt;code&gt;state_data_type&lt;/code&gt; . Планировщик использует это значение, чтобы оценить объем памяти, необходимый для группового агрегированного запроса. Планировщик рассмотрит возможность использования агрегирования хешей для такого запроса только в том случае, если хэш-таблица оценивается как подходящая для &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt; ; поэтому большие значения этого параметра препятствуют использованию агрегирования хешей.</target>
        </trans-unit>
        <trans-unit id="5bc1a8ecb6b5b4b69664dd591c46774534fc3e77" translate="yes" xml:space="preserve">
          <source>The approximation 365+97/400 is achieved by having 97 leap years every 400 years, using the following rules:</source>
          <target state="translated">Приблизительное значение 365+97/400 достигается за счет 97 високосных лет каждые 400 лет при использовании следующих правил:</target>
        </trans-unit>
        <trans-unit id="31a6736bfcac19a9525dbc2f1d3d326327c448b4" translate="yes" xml:space="preserve">
          <source>The archive command is only invoked on completed WAL segments. Hence, if your server generates only little WAL traffic (or has slack periods where it does so), there could be a long delay between the completion of a transaction and its safe recording in archive storage. To put a limit on how old unarchived data can be, you can set &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; to force the server to switch to a new WAL segment file at least that often. Note that archived files that are archived early due to a forced switch are still the same length as completely full files. It is therefore unwise to set a very short &lt;code&gt;archive_timeout&lt;/code&gt; &amp;mdash; it will bloat your archive storage. &lt;code&gt;archive_timeout&lt;/code&gt; settings of a minute or so are usually reasonable.</source>
          <target state="translated">Команда архивирования вызывается только для завершенных сегментов WAL. Следовательно, если ваш сервер генерирует лишь небольшой трафик WAL (или имеет периоды простоя, когда он это делает), может быть большая задержка между завершением транзакции и ее безопасной записью в архивное хранилище. Чтобы установить ограничение на то, насколько старыми могут быть &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;неархивированные&lt;/a&gt; данные, вы можете установить archive_timeout, чтобы заставить сервер переключаться на новый файл сегмента WAL хотя бы так часто. Обратите внимание, что заархивированные файлы, которые были заархивированы раньше из-за принудительного переключения, по-прежнему имеют ту же длину, что и полностью полные файлы. Поэтому неразумно устанавливать очень короткий &lt;code&gt;archive_timeout&lt;/code&gt; - это приведет к раздутию вашего архивного хранилища. &lt;code&gt;archive_timeout&lt;/code&gt; в минуту или около того обычно разумно.</target>
        </trans-unit>
        <trans-unit id="4b5c4c289983b255b0c54296b2920b77c593a40a" translate="yes" xml:space="preserve">
          <source>The archive command should generally be designed to refuse to overwrite any pre-existing archive file. This is an important safety feature to preserve the integrity of your archive in case of administrator error (such as sending the output of two different servers to the same archive directory).</source>
          <target state="translated">Команда &quot;Архив&quot;,как правило,должна быть спроектирована так,чтобы отказать в перезаписи любого существующего архивного файла.Это важная функция безопасности для сохранения целостности архива в случае ошибки администратора (например,отправка вывода двух разных серверов в один архивный каталог).</target>
        </trans-unit>
        <trans-unit id="cf0db639e47353fbf356cd38ab714bab5a462b99" translate="yes" xml:space="preserve">
          <source>The archive command will be executed under the ownership of the same user that the PostgreSQL server is running as. Since the series of WAL files being archived contains effectively everything in your database, you will want to be sure that the archived data is protected from prying eyes; for example, archive into a directory that does not have group or world read access.</source>
          <target state="translated">Команда &quot;Архив&quot; будет выполнена под тем же пользователем,под которым запущен сервер PostgreSQL.Поскольку серия архивируемых WAL-файлов фактически содержит все в вашей базе данных,вы захотите быть уверены,что архивные данные защищены от посторонних глаз;например,архивировать в директорию,не имеющую доступа к групповому или мировому считыванию.</target>
        </trans-unit>
        <trans-unit id="c8f2b342beee7c3f52ad6834dd7e62ec7b49990d" translate="yes" xml:space="preserve">
          <source>The archive is a &lt;code&gt;tar&lt;/code&gt; archive.</source>
          <target state="translated">Архив представляет собой &lt;code&gt;tar&lt;/code&gt; - архив.</target>
        </trans-unit>
        <trans-unit id="d5dd8d384e2ea3f19ced747049fc2fc3701b0b55" translate="yes" xml:space="preserve">
          <source>The archive is a directory archive.</source>
          <target state="translated">Архив-это архив каталогов.</target>
        </trans-unit>
        <trans-unit id="055700e9693e4de21f0986775e962d50e33c74ee" translate="yes" xml:space="preserve">
          <source>The archive is in the custom format of pg_dump.</source>
          <target state="translated">Архив находится в пользовательском формате pg_dump.</target>
        </trans-unit>
        <trans-unit id="eadab5c3d582261bf3c9c742fde723a5f27a622f" translate="yes" xml:space="preserve">
          <source>The argument is a pointer to a &lt;code&gt;GISTENTRY&lt;/code&gt; struct. On entry, its &lt;code&gt;key&lt;/code&gt; field contains a non-NULL leaf datum in compressed form. The return value is another &lt;code&gt;GISTENTRY&lt;/code&gt; struct, whose &lt;code&gt;key&lt;/code&gt; field contains the same datum in its original, uncompressed form. If the opclass's compress function does nothing for leaf entries, the &lt;code&gt;fetch&lt;/code&gt; method can return the argument as-is. Or, if the opclass does not have a compress function, the &lt;code&gt;fetch&lt;/code&gt; method can be omitted as well, since it would necessarily be a no-op.</source>
          <target state="translated">Аргумент - указатель на структуру &lt;code&gt;GISTENTRY&lt;/code&gt; . При входе его &lt;code&gt;key&lt;/code&gt; поле содержит не NULL листовые данные в сжатой форме. Возвращаемое значение - другая структура &lt;code&gt;GISTENTRY&lt;/code&gt; , &lt;code&gt;key&lt;/code&gt; поле которой содержит те же данные в исходной несжатой форме. Если функция сжатия класса операций ничего не делает для листовых записей, метод &lt;code&gt;fetch&lt;/code&gt; может вернуть аргумент как есть. Или, если класс операций не имеет функции сжатия, метод &lt;code&gt;fetch&lt;/code&gt; может быть опущен, так как он обязательно будет отключенным.</target>
        </trans-unit>
        <trans-unit id="dac840b1ef4656a9069d124658163a0da1612eba" translate="yes" xml:space="preserve">
          <source>The argument of &lt;code&gt;EXISTS&lt;/code&gt; is an arbitrary &lt;code&gt;SELECT&lt;/code&gt; statement, or &lt;em&gt;subquery&lt;/em&gt;. The subquery is evaluated to determine whether it returns any rows. If it returns at least one row, the result of &lt;code&gt;EXISTS&lt;/code&gt; is &amp;ldquo;true&amp;rdquo;; if the subquery returns no rows, the result of &lt;code&gt;EXISTS&lt;/code&gt; is &amp;ldquo;false&amp;rdquo;.</source>
          <target state="translated">Аргументом &lt;code&gt;EXISTS&lt;/code&gt; является произвольный &lt;code&gt;SELECT&lt;/code&gt; или &lt;em&gt;подзапрос&lt;/em&gt; . Подзапрос оценивается, чтобы определить, возвращает ли он какие-либо строки. Если он возвращает хотя бы одну строку, результатом &lt;code&gt;EXISTS&lt;/code&gt; будет &amp;laquo;истина&amp;raquo;; если подзапрос не возвращает строк, результатом &lt;code&gt;EXISTS&lt;/code&gt; будет &amp;laquo;ложь&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d6ba5cebe3465380bdcbb01333aff93c94b4f911" translate="yes" xml:space="preserve">
          <source>The arguments can appear in any order, not only the one shown above.</source>
          <target state="translated">Аргументы могут быть представлены в любом порядке,а не только показанные выше.</target>
        </trans-unit>
        <trans-unit id="e994da275c22b1ba01eba6c807a42b44a7a8c8c1" translate="yes" xml:space="preserve">
          <source>The arguments can optionally have names attached. See &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt; for details.</source>
          <target state="translated">Аргументы могут иметь дополнительные имена. См. Подробности в &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;разделе 4.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b00f745b2cd63e4e8f1ed5a9dd09b736b5753686" translate="yes" xml:space="preserve">
          <source>The arguments must all be convertible to a common data type, which will be the type of the result (see &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdbe896c9bc5e0129d6c42af254aeecec20136cc" translate="yes" xml:space="preserve">
          <source>The arguments of &lt;code&gt;\set&lt;/code&gt; are subject to the same substitution rules as with other commands. Thus you can construct interesting references such as &lt;code&gt;\set :foo 'something'&lt;/code&gt; and get &amp;ldquo;soft links&amp;rdquo; or &amp;ldquo;variable variables&amp;rdquo; of Perl or PHP fame, respectively. Unfortunately (or fortunately?), there is no way to do anything useful with these constructs. On the other hand, &lt;code&gt;\set bar :foo&lt;/code&gt; is a perfectly valid way to copy a variable.</source>
          <target state="translated">Аргументы &lt;code&gt;\set&lt;/code&gt; подчиняются тем же правилам замены, что и для других команд. Таким образом, вы можете создавать интересные ссылки, такие как &lt;code&gt;\set :foo 'something'&lt;/code&gt; и получать &amp;laquo;мягкие ссылки&amp;raquo; или &amp;laquo;переменные переменные&amp;raquo;, известные как Perl или PHP, соответственно. К сожалению (или к счастью?), С этими конструкциями нет возможности сделать что-нибудь полезное. С другой стороны, &lt;code&gt;\set bar :foo&lt;/code&gt; - вполне допустимый способ скопировать переменную.</target>
        </trans-unit>
        <trans-unit id="2a1116027fc276cc8421c002135dbd224494828a" translate="yes" xml:space="preserve">
          <source>The arguments to the &lt;code&gt;distance&lt;/code&gt; function are identical to the arguments of the &lt;code&gt;consistent&lt;/code&gt; function.</source>
          <target state="translated">Аргументы функции &lt;code&gt;distance&lt;/code&gt; идентичны аргументам &lt;code&gt;consistent&lt;/code&gt; функции.</target>
        </trans-unit>
        <trans-unit id="7770d5c449c9e31af54123c29733b7fdcc835b68" translate="yes" xml:space="preserve">
          <source>The arithmetic, bitwise, comparison and logical operators listed in &lt;a href=&quot;pgbench#PGBENCH-OPERATORS&quot;&gt;Table 258&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Арифметические, побитовые, сравнительные и логические операторы, перечисленные в &lt;a href=&quot;pgbench#PGBENCH-OPERATORS&quot;&gt;Таблице 258&lt;/a&gt; , встроены в pgbench и могут использоваться в выражениях, появляющихся в &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt; &lt;code&gt;\set&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c75d7c8ffc6407b194e547c6bae30091147ee957" translate="yes" xml:space="preserve">
          <source>The arithmetic, bitwise, comparison and logical operators listed in &lt;a href=&quot;pgbench#PGBENCH-OPERATORS&quot;&gt;Table 274&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;. The operators are listed in increasing precedence order. Except as noted, operators taking two numeric inputs will produce a double value if either input is double, otherwise they produce an integer result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99ae22a382dffdb58abe986f81d4d8fc31ff15a" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;scankeys&lt;/code&gt;, of length &lt;code&gt;nkeys&lt;/code&gt;, describes the index search condition(s). These conditions are combined with AND &amp;mdash; only index entries that satisfy all of them are interesting. (Note that &lt;code&gt;nkeys&lt;/code&gt; = 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the &lt;code&gt;sk_strategy&lt;/code&gt; and &lt;code&gt;sk_argument&lt;/code&gt; fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check &lt;code&gt;sk_flags&lt;/code&gt; to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. The array &lt;code&gt;orderbys&lt;/code&gt;, of length &lt;code&gt;norderbys&lt;/code&gt;, describes ordering operators (if any) in the same manner. &lt;code&gt;reconstructedValue&lt;/code&gt; is the value reconstructed for the parent tuple; it is &lt;code&gt;(Datum) 0&lt;/code&gt; at the root level or if the &lt;code&gt;inner_consistent&lt;/code&gt; function did not provide a value at the parent level. &lt;code&gt;reconstructedValue&lt;/code&gt; is always of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; type. &lt;code&gt;traversalValue&lt;/code&gt; is a pointer to any traverse data passed down from the previous call of &lt;code&gt;inner_consistent&lt;/code&gt; on the parent index tuple, or NULL at the root level. &lt;code&gt;traversalMemoryContext&lt;/code&gt; is the memory context in which to store output traverse values (see below). &lt;code&gt;level&lt;/code&gt; is the current inner tuple's level, starting at zero for the root level. &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if reconstructed data is required for this query; this will only be so if the &lt;code&gt;config&lt;/code&gt; function asserted &lt;code&gt;canReturnData&lt;/code&gt;. &lt;code&gt;allTheSame&lt;/code&gt; is true if the current inner tuple is marked &amp;ldquo;all-the-same&amp;rdquo;; in this case all the nodes have the same label (if any) and so either all or none of them match the query (see &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt;). &lt;code&gt;hasPrefix&lt;/code&gt; is true if the current inner tuple contains a prefix; if so, &lt;code&gt;prefixDatum&lt;/code&gt; is its value. &lt;code&gt;nNodes&lt;/code&gt; is the number of child nodes contained in the inner tuple, and &lt;code&gt;nodeLabels&lt;/code&gt; is an array of their label values, or NULL if the nodes do not have labels.</source>
          <target state="translated">Массив &lt;code&gt;scankeys&lt;/code&gt; длиной &lt;code&gt;nkeys&lt;/code&gt; описывает условие (я) поиска индекса. Эти условия комбинируются с И - интересны только элементы указателя, которые им всем удовлетворяют. (Обратите внимание, что &lt;code&gt;nkeys&lt;/code&gt; = 0 означает, что все записи индекса удовлетворяют запросу.) Обычно согласованная функция заботится только о &lt;code&gt;sk_strategy&lt;/code&gt; и &lt;code&gt;sk_argument&lt;/code&gt; каждой записи массива, которые соответственно дают индексируемый оператор и значение сравнения. В частности, нет необходимости проверять &lt;code&gt;sk_flags&lt;/code&gt; , чтобы увидеть, является ли значение сравнения NULL, потому что основной код SP-GiST будет отфильтровывать такие условия. Массив &lt;code&gt;orderbys&lt;/code&gt; длины &lt;code&gt;norderbys&lt;/code&gt; , таким же образом описывает операторы упорядочения (если есть). &lt;code&gt;reconstructedValue&lt;/code&gt; - это значение, восстановленное для родительского кортежа; это &lt;code&gt;(Datum) 0&lt;/code&gt; на корневом уровне или если функция &lt;code&gt;inner_consistent&lt;/code&gt; не предоставила значение на родительском уровне. &lt;code&gt;reconstructedValue&lt;/code&gt; всегда имеет значение &lt;code&gt;spgConfigOut&lt;/code&gt; . Тип &lt;code&gt;leafType&lt;/code&gt; . &lt;code&gt;traversalValue&lt;/code&gt; - это указатель на любые данные обхода, переданные из предыдущего вызова &lt;code&gt;inner_consistent&lt;/code&gt; в родительском кортеже индекса, или NULL на корневом уровне. &lt;code&gt;traversalMemoryContext&lt;/code&gt; - это контекст памяти, в котором хранятся выходные значения обхода (см. ниже). &lt;code&gt;level&lt;/code&gt; - текущий внутренний уровень кортежа, начиная с нуля для корневого уровня. &lt;code&gt;returnData&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , если восстановленные данные , необходимые для этого запроса; это будет только в том случае, если функция &lt;code&gt;config&lt;/code&gt; заявила &lt;code&gt;canReturnData&lt;/code&gt; . &lt;code&gt;allTheSame&lt;/code&gt; истинно, если текущий внутренний кортеж помечен как &amp;laquo;все-то же&amp;raquo;; в этом случае все узлы имеют одинаковую метку (если есть), и поэтому либо все, либо ни один из них не соответствует запросу (см. &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Подраздел 65.4.3&lt;/a&gt; ). &lt;code&gt;hasPrefix&lt;/code&gt; истинно, если текущий внутренний кортеж содержит префикс; если да, &lt;code&gt;prefixDatum&lt;/code&gt; значение prefixDatum . &lt;code&gt;nNodes&lt;/code&gt; - это количество дочерних узлов, содержащихся во внутреннем кортеже, а &lt;code&gt;nodeLabels&lt;/code&gt; представляет собой массив значений их меток или NULL, если узлы не имеют меток.</target>
        </trans-unit>
        <trans-unit id="b4cb45da91499c64a7e30418524dae4c6bc491fc" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;scankeys&lt;/code&gt;, of length &lt;code&gt;nkeys&lt;/code&gt;, describes the index search condition(s). These conditions are combined with AND &amp;mdash; only index entries that satisfy all of them satisfy the query. (Note that &lt;code&gt;nkeys&lt;/code&gt; = 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the &lt;code&gt;sk_strategy&lt;/code&gt; and &lt;code&gt;sk_argument&lt;/code&gt; fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check &lt;code&gt;sk_flags&lt;/code&gt; to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. The array &lt;code&gt;orderbys&lt;/code&gt;, of length &lt;code&gt;norderbys&lt;/code&gt;, describes the ordering operators in the same manner. &lt;code&gt;reconstructedValue&lt;/code&gt; is the value reconstructed for the parent tuple; it is &lt;code&gt;(Datum) 0&lt;/code&gt; at the root level or if the &lt;code&gt;inner_consistent&lt;/code&gt; function did not provide a value at the parent level. &lt;code&gt;reconstructedValue&lt;/code&gt; is always of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; type. &lt;code&gt;traversalValue&lt;/code&gt; is a pointer to any traverse data passed down from the previous call of &lt;code&gt;inner_consistent&lt;/code&gt; on the parent index tuple, or NULL at the root level. &lt;code&gt;level&lt;/code&gt; is the current leaf tuple's level, starting at zero for the root level. &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if reconstructed data is required for this query; this will only be so if the &lt;code&gt;config&lt;/code&gt; function asserted &lt;code&gt;canReturnData&lt;/code&gt;. &lt;code&gt;leafDatum&lt;/code&gt; is the key value of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; stored in the current leaf tuple.</source>
          <target state="translated">Массив &lt;code&gt;scankeys&lt;/code&gt; длиной &lt;code&gt;nkeys&lt;/code&gt; описывает условие (я) поиска индекса. Эти условия комбинируются с И - только те элементы индекса, которые удовлетворяют всем из них, удовлетворяют запросу. (Обратите внимание, что &lt;code&gt;nkeys&lt;/code&gt; = 0 означает, что все записи индекса удовлетворяют запросу.) Обычно согласованная функция заботится только о &lt;code&gt;sk_strategy&lt;/code&gt; и &lt;code&gt;sk_argument&lt;/code&gt; каждой записи массива, которые соответственно дают индексируемый оператор и значение сравнения. В частности, нет необходимости проверять &lt;code&gt;sk_flags&lt;/code&gt; , чтобы увидеть, является ли значение сравнения NULL, потому что основной код SP-GiST будет отфильтровывать такие условия. Массив &lt;code&gt;orderbys&lt;/code&gt; длины &lt;code&gt;norderbys&lt;/code&gt; , описывает операторы упорядочивания таким же образом. &lt;code&gt;reconstructedValue&lt;/code&gt; - это значение, восстановленное для родительского кортежа; это &lt;code&gt;(Datum) 0&lt;/code&gt; на корневом уровне или если функция &lt;code&gt;inner_consistent&lt;/code&gt; не предоставила значение на родительском уровне. &lt;code&gt;reconstructedValue&lt;/code&gt; всегда имеет значение &lt;code&gt;spgConfigOut&lt;/code&gt; . Тип &lt;code&gt;leafType&lt;/code&gt; . &lt;code&gt;traversalValue&lt;/code&gt; - это указатель на любые данные обхода, переданные из предыдущего вызова &lt;code&gt;inner_consistent&lt;/code&gt; в родительском кортеже индекса, или NULL на корневом уровне. &lt;code&gt;level&lt;/code&gt; - это уровень текущего конечного кортежа, начиная с нуля для корневого уровня. &lt;code&gt;returnData&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; если для этого запроса требуются восстановленные данные; это будет только в том случае, если функция &lt;code&gt;config&lt;/code&gt; заявила &lt;code&gt;canReturnData&lt;/code&gt; . &lt;code&gt;leafDatum&lt;/code&gt; - это ключевое значение &lt;code&gt;spgConfigOut&lt;/code&gt; . &lt;code&gt;leafType&lt;/code&gt; хранится в текущем листовом кортеже.</target>
        </trans-unit>
        <trans-unit id="e26f508cb31ef1599228fd2a799f7ebeb7c2026b" translate="yes" xml:space="preserve">
          <source>The array containment operators (&lt;code&gt;&amp;lt;@&lt;/code&gt; and &lt;code&gt;@&amp;gt;&lt;/code&gt;) consider one array to be contained in another one if each of its elements appears in the other one. Duplicates are not treated specially, thus &lt;code&gt;ARRAY[1]&lt;/code&gt; and &lt;code&gt;ARRAY[1,1]&lt;/code&gt; are each considered to contain the other.</source>
          <target state="translated">Операторы включения массива ( &lt;code&gt;&amp;lt;@&lt;/code&gt; и &lt;code&gt;@&amp;gt;&lt;/code&gt; ) считают, что один массив содержится в другом, если каждый из его элементов появляется в другом. Дубликаты не обрабатываются специально, поэтому &lt;code&gt;ARRAY[1]&lt;/code&gt; и &lt;code&gt;ARRAY[1,1]&lt;/code&gt; считаются содержащими друг друга.</target>
        </trans-unit>
        <trans-unit id="a1ac56c0bce21554d688d27823930a835d434c12" translate="yes" xml:space="preserve">
          <source>The array ordering operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, etc) compare the array contents element-by-element, using the default B-tree comparison function for the element data type, and sort based on the first difference. In multidimensional arrays the elements are visited in row-major order (last subscript varies most rapidly). If the contents of two arrays are equal but the dimensionality is different, the first difference in the dimensionality information determines the sort order. (This is a change from versions of PostgreSQL prior to 8.2: older versions would claim that two arrays with the same contents were equal, even if the number of dimensions or subscript ranges were different.)</source>
          <target state="translated">Операторы упорядочивания массивов ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; и т. Д.) Сравнивают содержимое массива элемент за элементом, используя функцию сравнения B-дерева по умолчанию для типа данных элемента, и сортируют на основе первого различия. В многомерных массивах элементы просматриваются в порядке возрастания строк (последний индекс изменяется наиболее быстро). Если содержимое двух массивов одинаково, но размерность различна, первое различие в информации о размерности определяет порядок сортировки. (Это изменение по сравнению с версиями PostgreSQL до 8.2: более старые версии утверждали, что два массива с одинаковым содержимым были равны, даже если количество измерений или диапазонов нижнего индекса было различным.)</target>
        </trans-unit>
        <trans-unit id="46741e31bee949b907d3858dce5eac23fd4bcbdf" translate="yes" xml:space="preserve">
          <source>The array output routine will include explicit dimensions in its result only when there are one or more lower bounds different from one.</source>
          <target state="translated">Выходной режим массива будет включать в свой результат явные измерения только в том случае,если есть одна или несколько нижних границ,отличных от одной.</target>
        </trans-unit>
        <trans-unit id="145d4d2c0c7cafb8b7bd9116657b494c47b146d7" translate="yes" xml:space="preserve">
          <source>The array output routine will put double quotes around element values if they are empty strings, contain curly braces, delimiter characters, double quotes, backslashes, or white space, or match the word &lt;code&gt;NULL&lt;/code&gt;. Double quotes and backslashes embedded in element values will be backslash-escaped. For numeric data types it is safe to assume that double quotes will never appear, but for textual data types one should be prepared to cope with either the presence or absence of quotes.</source>
          <target state="translated">Подпрограмма вывода массива помещает значения элементов в двойные кавычки, если они являются пустыми строками, содержат фигурные скобки, символы-разделители, двойные кавычки, обратную косую черту или пробелы или соответствуют слову &lt;code&gt;NULL&lt;/code&gt; . Двойные кавычки и обратная косая черта, встроенные в значения элементов, будут экранированы обратной косой чертой. Для числовых типов данных можно с уверенностью предположить, что двойные кавычки никогда не появятся, но для текстовых типов данных следует быть готовым справиться с наличием или отсутствием кавычек.</target>
        </trans-unit>
        <trans-unit id="103411c7faff9f23f3f96fc9d71ef919bccd0156" translate="yes" xml:space="preserve">
          <source>The array subscript numbers are written within square brackets. By default PostgreSQL uses a one-based numbering convention for arrays, that is, an array of &lt;code&gt;n&lt;/code&gt; elements starts with &lt;code&gt;array[1]&lt;/code&gt; and ends with &lt;code&gt;array[n]&lt;/code&gt;.</source>
          <target state="translated">Номера индексов массива записываются в квадратных скобках. По умолчанию PostgreSQL использует для массивов соглашение о нумерации с единицей, то есть массив из &lt;code&gt;n&lt;/code&gt; элементов начинается с &lt;code&gt;array[1]&lt;/code&gt; и заканчивается &lt;code&gt;array[n]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d22d8bf767f7e2f65ff41f5dea0e4f13bccb5b56" translate="yes" xml:space="preserve">
          <source>The associated sort operator for a &lt;code&gt;MIN&lt;/code&gt;- or &lt;code&gt;MAX&lt;/code&gt;-like aggregate. This is just an operator name (possibly schema-qualified). The operator is assumed to have the same input data types as the aggregate (which must be a single-argument normal aggregate).</source>
          <target state="translated">Связанный оператор сортировки для агрегата, подобного &lt;code&gt;MIN&lt;/code&gt; или &lt;code&gt;MAX&lt;/code&gt; . Это просто имя оператора (возможно, дополненное схемой). Предполагается, что оператор имеет те же типы входных данных, что и агрегат (который должен быть обычным агрегатом с одним аргументом).</target>
        </trans-unit>
        <trans-unit id="9f45180efdf5d69d899f4c71484ab019adca9bab" translate="yes" xml:space="preserve">
          <source>The associated value is always a list of objects, each describing a range of WAL records that must be readable from a particular timeline in order to make use of the backup. The structure of these objects is further described in &lt;a href=&quot;backup-manifest-wal-ranges&quot;&gt;Section 71.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="658fbccdd7164ea13c1ae7470c9f741a09ac38d8" translate="yes" xml:space="preserve">
          <source>The associated value is always a list of objects, each describing one file that is present in the backup. No entries are present in this list for the WAL files that are needed in order to use the backup, or for the backup manifest itself. The structure of each object in the list is described in &lt;a href=&quot;backup-manifest-files&quot;&gt;Section 71.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c6c90066586df369729932567a3ffed5f17a48" translate="yes" xml:space="preserve">
          <source>The associated value is always the integer 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354efec1fb802640a13d0696d88d4e7e365ca415" translate="yes" xml:space="preserve">
          <source>The assurance that once a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; has been &lt;a href=&quot;glossary#GLOSSARY-COMMIT&quot;&gt;committed&lt;/a&gt;, the changes remain even after a system failure or crash. This is one of the ACID properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf89077b4ae20ed63b034eee053148490bd888b" translate="yes" xml:space="preserve">
          <source>The asterisk (&lt;code&gt;*&lt;/code&gt;) is used in some contexts to denote all the fields of a table row or composite value. It also has a special meaning when used as the argument of an aggregate function, namely that the aggregate does not require any explicit parameter.</source>
          <target state="translated">Звездочка ( &lt;code&gt;*&lt;/code&gt; ) используется в некоторых контекстах для обозначения всех полей строки таблицы или составного значения. Он также имеет особое значение при использовании в качестве аргумента агрегатной функции, а именно, что агрегат не требует каких-либо явных параметров.</target>
        </trans-unit>
        <trans-unit id="a8f1751d17a34d74d41affe83afc62bf9926cd57" translate="yes" xml:space="preserve">
          <source>The autocommit-on mode is PostgreSQL's traditional behavior, but autocommit-off is closer to the SQL spec. If you prefer autocommit-off, you might wish to set it in the system-wide &lt;code&gt;psqlrc&lt;/code&gt; file or your &lt;code&gt;~/.psqlrc&lt;/code&gt; file.</source>
          <target state="translated">Режим autocommit-on - это традиционное поведение PostgreSQL, но autocommit-off ближе к спецификации SQL. Если вы предпочитаете &lt;code&gt;psqlrc&lt;/code&gt; , вы можете установить ее в общесистемном файле psqlrc или в файле &lt;code&gt;~/.psqlrc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a786e81687748275f55ad70f3f5bbc00d402d949" translate="yes" xml:space="preserve">
          <source>The autovacuum daemon does not issue &lt;code&gt;ANALYZE&lt;/code&gt; commands for foreign tables, since it has no means of determining how often that might be useful. If your queries require statistics on foreign tables for proper planning, it's a good idea to run manually-managed &lt;code&gt;ANALYZE&lt;/code&gt; commands on those tables on a suitable schedule.</source>
          <target state="translated">Демон автоочистки не выполняет команды &lt;code&gt;ANALYZE&lt;/code&gt; для сторонних таблиц, поскольку у него нет средств определения того, как часто это может быть полезно. Если ваши запросы требуют статистики по сторонним таблицам для правильного планирования, рекомендуется запускать управляемые вручную команды &lt;code&gt;ANALYZE&lt;/code&gt; для этих таблиц по подходящему расписанию.</target>
        </trans-unit>
        <trans-unit id="c3fb21098ee7138941d3ecbb7f53e34e6b514d65" translate="yes" xml:space="preserve">
          <source>The autovacuum daemon, if enabled, will automatically issue &lt;code&gt;ANALYZE&lt;/code&gt; commands whenever the content of a table has changed sufficiently. However, administrators might prefer to rely on manually-scheduled &lt;code&gt;ANALYZE&lt;/code&gt; operations, particularly if it is known that update activity on a table will not affect the statistics of &amp;ldquo;interesting&amp;rdquo; columns. The daemon schedules &lt;code&gt;ANALYZE&lt;/code&gt; strictly as a function of the number of rows inserted or updated; it has no knowledge of whether that will lead to meaningful statistical changes.</source>
          <target state="translated">Демон автоочистки, если он включен, будет автоматически выдавать команды &lt;code&gt;ANALYZE&lt;/code&gt; всякий раз, когда содержимое таблицы изменилось в достаточной степени. Однако администраторы могут предпочесть использовать запланированные вручную операции &lt;code&gt;ANALYZE&lt;/code&gt; , особенно если известно, что действия по обновлению таблицы не повлияют на статистику &amp;laquo;интересных&amp;raquo; столбцов. Демон планирует &lt;code&gt;ANALYZE&lt;/code&gt; строго в зависимости от количества вставленных или обновленных строк; он не знает, приведет ли это к значимым статистическим изменениям.</target>
        </trans-unit>
        <trans-unit id="252860c5ed0258d1ec21ceb8459b34f92032e663" translate="yes" xml:space="preserve">
          <source>The availability of the different password-based authentication methods depends on how a user's password on the server is encrypted (or hashed, more accurately). This is controlled by the configuration parameter &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt; at the time the password is set. If a password was encrypted using the &lt;code&gt;scram-sha-256&lt;/code&gt; setting, then it can be used for the authentication methods &lt;code&gt;scram-sha-256&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; (but password transmission will be in plain text in the latter case). The authentication method specification &lt;code&gt;md5&lt;/code&gt; will automatically switch to using the &lt;code&gt;scram-sha-256&lt;/code&gt; method in this case, as explained above, so it will also work. If a password was encrypted using the &lt;code&gt;md5&lt;/code&gt; setting, then it can be used only for the &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; authentication method specifications (again, with the password transmitted in plain text in the latter case). (Previous PostgreSQL releases supported storing the password on the server in plain text. This is no longer possible.) To check the currently stored password hashes, see the system catalog &lt;code&gt;pg_authid&lt;/code&gt;.</source>
          <target state="translated">Доступность различных методов аутентификации на основе пароля зависит от того, как пароль пользователя на сервере зашифрован (или, точнее, хеширован). Это контролируется параметром конфигурации &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt; во время установки пароля. Если пароль был зашифрован с использованием параметра &lt;code&gt;scram-sha-256&lt;/code&gt; , то его можно использовать для методов аутентификации &lt;code&gt;scram-sha-256&lt;/code&gt; и &lt;code&gt;password&lt;/code&gt; (но в последнем случае передача пароля будет осуществляться в виде обычного текста). Спецификация метода аутентификации &lt;code&gt;md5&lt;/code&gt; автоматически переключится на использование метода &lt;code&gt;scram-sha-256&lt;/code&gt; в этом случае, как описано выше, поэтому он также будет работать. Если пароль был зашифрован с помощью &lt;code&gt;md5&lt;/code&gt; , то его можно использовать только для спецификации метода аутентификации &lt;code&gt;md5&lt;/code&gt; и &lt;code&gt;password&lt;/code&gt; (опять же, с паролем, передаваемым в виде обычного текста в последнем случае). (Предыдущие выпуски PostgreSQL поддерживали сохранение пароля на сервере в виде обычного текста. Это больше невозможно.) Чтобы проверить сохраненные в настоящее время хэши паролей, см. Системный каталог &lt;code&gt;pg_authid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be4db45cb9d664398bfb8a833d78745c5f0e03cb" translate="yes" xml:space="preserve">
          <source>The available commands are:</source>
          <target state="translated">Доступны команды:</target>
        </trans-unit>
        <trans-unit id="a8b4cfaf9660d8b419b38ef501d2e57aeb699d73" translate="yes" xml:space="preserve">
          <source>The available functions are shown in &lt;a href=&quot;ltree#LTREE-FUNC-TABLE&quot;&gt;Table F.14&lt;/a&gt;.</source>
          <target state="translated">Доступные функции показаны в &lt;a href=&quot;ltree#LTREE-FUNC-TABLE&quot;&gt;Таблице F.14&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4cf27edb4ec77236cfb1d7851c53ced1470b1ae0" translate="yes" xml:space="preserve">
          <source>The available privileges are:</source>
          <target state="translated">Доступные привилегии:</target>
        </trans-unit>
        <trans-unit id="b24cdea942d5e58d37185d11c8d0001459291bc6" translate="yes" xml:space="preserve">
          <source>The available sequence functions are:</source>
          <target state="translated">Доступные функции последовательности:</target>
        </trans-unit>
        <trans-unit id="1f54359e34884f0f14a7082c4b037dceb1040a71" translate="yes" xml:space="preserve">
          <source>The available transaction characteristics are the transaction isolation level, the transaction access mode (read/write or read-only), and the deferrable mode. In addition, a snapshot can be selected, though only for the current transaction, not as a session default.</source>
          <target state="translated">Доступными характеристиками транзакций являются уровень изоляции транзакций,режим доступа к транзакциям (чтение/запись или только чтение)и режим отсрочки.Кроме того,можно выбрать моментальный снимок,хотя и только для текущей транзакции,а не как сеанс по умолчанию.</target>
        </trans-unit>
        <trans-unit id="690838e9cb021af0a2b1acec6c3a93a7e08f1bb6" translate="yes" xml:space="preserve">
          <source>The average stored width, in bytes, of nonnull entries</source>
          <target state="translated">Средняя сохраненная ширина в байтах записей,не являющихся нулями.</target>
        </trans-unit>
        <trans-unit id="4f544e0e02bfed2fa010d1f669949bc62b79024b" translate="yes" xml:space="preserve">
          <source>The backend type corresponds to the column &lt;code&gt;backend_type&lt;/code&gt; in the view &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ACTIVITY-VIEW&quot;&gt;&lt;code&gt;pg_stat_activity&lt;/code&gt;&lt;/a&gt;, but additional types can appear in the log that don't show in that view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde6e34822920c61d23e994603a609b1307667e3" translate="yes" xml:space="preserve">
          <source>The background writer is active during recovery and will perform restartpoints (similar to checkpoints on the primary) and normal block cleaning activities. This can include updates of the hint bit information stored on the standby server. The &lt;code&gt;CHECKPOINT&lt;/code&gt; command is accepted during recovery, though it performs a restartpoint rather than a new checkpoint.</source>
          <target state="translated">Фоновая запись активна во время восстановления и будет выполнять точки перезапуска (аналогичные контрольным точкам на основном сервере) и обычные действия по очистке блоков. Это может включать обновления информации битов подсказки, хранящейся на резервном сервере. Команда &lt;code&gt;CHECKPOINT&lt;/code&gt; принимается во время восстановления, хотя она выполняет точку перезапуска, а не новую контрольную точку.</target>
        </trans-unit>
        <trans-unit id="6a4770c7c3de3b5a6b683a55e8771f9ee1778b13" translate="yes" xml:space="preserve">
          <source>The backup history file is just a small text file. It contains the label string you gave to &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;, as well as the starting and ending times and WAL segments of the backup. If you used the label to identify the associated dump file, then the archived history file is enough to tell you which dump file to restore.</source>
          <target state="translated">Файл истории резервного копирования представляет собой небольшой текстовый файл. Он содержит строку метки, которую вы дали &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; , а также время начала и окончания и сегменты WAL резервной копии. Если вы использовали метку для идентификации связанного файла дампа, то архивированного файла истории достаточно, чтобы указать, какой файл дампа нужно восстановить.</target>
        </trans-unit>
        <trans-unit id="c801dce038f073674a8ac5aca2db97b365640813" translate="yes" xml:space="preserve">
          <source>The backup history file is not created in the database cluster backed up.</source>
          <target state="translated">Файл истории резервного копирования не создается в кластере БД с резервной копией.</target>
        </trans-unit>
        <trans-unit id="0c8b05e2a70131e9b678814d20139ef5d923c4dc" translate="yes" xml:space="preserve">
          <source>The backup is made over a regular PostgreSQL connection that uses the replication protocol. The connection must be made with a user ID that has &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;) or is a superuser, and &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;&lt;code&gt;pg_hba.conf&lt;/code&gt;&lt;/a&gt; must permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to provide at least one walsender for the backup plus one for WAL streaming (if used).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be7e03b230f28bb65cecb0388bcfd3f69ad98241" translate="yes" xml:space="preserve">
          <source>The backup is made over a regular PostgreSQL connection, and uses the replication protocol. The connection must be made with a superuser or a user having &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;), and &lt;code&gt;pg_hba.conf&lt;/code&gt; must explicitly permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to leave at least one session available for the backup and one for WAL streaming (if used).</source>
          <target state="translated">Резервное копирование выполняется через обычное соединение PostgreSQL и использует протокол репликации. Соединение должно быть выполнено с суперпользователем или пользователем, имеющим права &lt;code&gt;REPLICATION&lt;/code&gt; (см. &lt;a href=&quot;role-attributes&quot;&gt;Раздел 21.2&lt;/a&gt; ), а &lt;code&gt;pg_hba.conf&lt;/code&gt; должен явно разрешать соединение для репликации. Сервер также должен быть настроен с &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;максимальным значением max_wal_senders&lt;/a&gt; , чтобы оставить по крайней мере один сеанс доступным для резервного копирования и один для потоковой передачи WAL (если используется).</target>
        </trans-unit>
        <trans-unit id="eee28f79bda7267e3e26bc973ac8a0442a749a1b" translate="yes" xml:space="preserve">
          <source>The backup label file includes the label string you gave to &lt;code&gt;pg_start_backup&lt;/code&gt;, as well as the time at which &lt;code&gt;pg_start_backup&lt;/code&gt; was run, and the name of the starting WAL file. In case of confusion it is therefore possible to look inside a backup file and determine exactly which backup session the dump file came from. The tablespace map file includes the symbolic link names as they exist in the directory &lt;code&gt;pg_tblspc/&lt;/code&gt; and the full path of each symbolic link. These files are not merely for your information; their presence and contents are critical to the proper operation of the system's recovery process.</source>
          <target state="translated">Файл метки резервной копии включает строку метки, которую вы дали &lt;code&gt;pg_start_backup&lt;/code&gt; , а также время &lt;code&gt;pg_start_backup&lt;/code&gt; и имя начального файла WAL. Поэтому в случае путаницы можно заглянуть внутрь файла резервной копии и точно определить, из какого сеанса резервного копирования был получен файл дампа. Файл карты табличного пространства включает имена символических ссылок в том виде, в &lt;code&gt;pg_tblspc/&lt;/code&gt; они существуют в каталоге pg_tblspc /, и полный путь к каждой символической ссылке. Эти файлы предназначены не только для вашей информации; их наличие и содержимое имеют решающее значение для правильной работы процесса восстановления системы.</target>
        </trans-unit>
        <trans-unit id="e501c42ea79c8d19e5c5b2265b4863425cf9ba55" translate="yes" xml:space="preserve">
          <source>The backup manifest JSON document contains the following keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec28fc3545975c7f203eb96bb815ab982f3d0305" translate="yes" xml:space="preserve">
          <source>The backup will include all files in the data directory and tablespaces, including the configuration files and any additional files placed in the directory by third parties, except certain temporary files managed by PostgreSQL. But only regular files and directories are copied, except that symbolic links used for tablespaces are preserved. Symbolic links pointing to certain directories known to PostgreSQL are copied as empty directories. Other symbolic links and special device files are skipped. See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt; for the precise details.</source>
          <target state="translated">Резервная копия будет включать все файлы в каталоге данных и табличных пространствах, включая файлы конфигурации и любые дополнительные файлы, помещенные в каталог третьими сторонами, за исключением некоторых временных файлов, управляемых PostgreSQL. Но копируются только обычные файлы и каталоги, за исключением того, что символические ссылки, используемые для табличных пространств, сохраняются. Символьные ссылки, указывающие на определенные каталоги, известные PostgreSQL, копируются как пустые каталоги. Другие символические ссылки и специальные файлы устройств пропускаются. За подробностями &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;обратитесь&lt;/a&gt; к Разделу 52.4 .</target>
        </trans-unit>
        <trans-unit id="fcd73c92b5c4d4bc4af88fe2398a5bc2bbfd5cfa" translate="yes" xml:space="preserve">
          <source>The backup will include all files in the data directory and tablespaces, including the configuration files and any additional files placed in the directory by third parties, except certain temporary files managed by PostgreSQL. But only regular files and directories are copied, except that symbolic links used for tablespaces are preserved. Symbolic links pointing to certain directories known to PostgreSQL are copied as empty directories. Other symbolic links and special device files are skipped. See &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt; for the precise details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3172c702cad81af002509edf932aeb8ebbddf103" translate="yes" xml:space="preserve">
          <source>The bare-bones way to start the server manually is just to invoke &lt;code&gt;postgres&lt;/code&gt; directly, specifying the location of the data directory with the &lt;code&gt;-D&lt;/code&gt; option, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010379dd868ed62184a64309858104a1ef8bdfc1" translate="yes" xml:space="preserve">
          <source>The base directory on the file system of a &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; that contains all data files and subdirectories associated with a &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;database cluster&lt;/a&gt; (with the exception of &lt;a href=&quot;glossary#GLOSSARY-TABLESPACE&quot;&gt;tablespaces&lt;/a&gt;, and optionally &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;). The environment variable &lt;code&gt;PGDATA&lt;/code&gt; is commonly used to refer to the data directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5658ad1f6ce193a23633c994bf8ae4b8bb4bf57e" translate="yes" xml:space="preserve">
          <source>The base name of the shared object containing the output plugin this logical slot is using, or null for physical slots.</source>
          <target state="translated">Базовое имя общего объекта,содержащего выходной плагин,используемый этим логическим слотом,или ноль для физических слотов.</target>
        </trans-unit>
        <trans-unit id="01f76877be594c383342f8dd0d2d641fff88c4a5" translate="yes" xml:space="preserve">
          <source>The basic idea is to copy all file system-level changes from the source cluster to the target cluster:</source>
          <target state="translated">Основная идея заключается в копировании всех изменений на уровне файловой системы из исходного кластера в целевой кластер:</target>
        </trans-unit>
        <trans-unit id="37c34616336e6db6cae77db2468a45723a3fb8d6" translate="yes" xml:space="preserve">
          <source>The basic structure used to store relation data. All pages are of the same size. Data pages are typically stored on disk, each in a specific file, and can be read to &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared buffers&lt;/a&gt; where they can be modified, becoming &lt;em&gt;dirty&lt;/em&gt;. They become clean when written to disk. New pages, which initially exist in memory only, are also dirty until written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e50f37cd3ac57ef618ac5cb372c8487c7f1bd1" translate="yes" xml:space="preserve">
          <source>The basic value of &lt;code&gt;SELECT&lt;/code&gt; in &lt;code&gt;WITH&lt;/code&gt; is to break down complicated queries into simpler parts. An example is:</source>
          <target state="translated">Основное значение &lt;code&gt;SELECT&lt;/code&gt; в &lt;code&gt;WITH&lt;/code&gt; - разбивать сложные запросы на более простые части. Пример:</target>
        </trans-unit>
        <trans-unit id="a2b5aa5c42d40515ef87930aadc0b43fe175a670" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;%&lt;/code&gt; is a bit complicated. It tries to match words rather than the entire label. For example &lt;code&gt;foo_bar%&lt;/code&gt; matches &lt;code&gt;foo_bar_baz&lt;/code&gt; but not &lt;code&gt;foo_barbaz&lt;/code&gt;. If combined with &lt;code&gt;*&lt;/code&gt;, prefix matching applies to each word separately, for example &lt;code&gt;foo_bar%*&lt;/code&gt; matches &lt;code&gt;foo1_bar2_baz&lt;/code&gt; but not &lt;code&gt;foo1_br2_baz&lt;/code&gt;.</source>
          <target state="translated">Поведение &lt;code&gt;%&lt;/code&gt; немного сложное. Он пытается сопоставить слова, а не весь ярлык. Например, &lt;code&gt;foo_bar%&lt;/code&gt; соответствует &lt;code&gt;foo_bar_baz&lt;/code&gt; , но не &lt;code&gt;foo_barbaz&lt;/code&gt; . В сочетании с &lt;code&gt;*&lt;/code&gt; соответствие префикса применяется к каждому слову отдельно, например, &lt;code&gt;foo_bar%*&lt;/code&gt; соответствует &lt;code&gt;foo1_bar2_baz&lt;/code&gt; , но не &lt;code&gt;foo1_br2_baz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e8f85d7de8ab2c8253e41f10bbddbd7196e58ed" translate="yes" xml:space="preserve">
          <source>The behavior of a custom text search configuration can easily become confusing. The functions described in this section are useful for testing text search objects. You can test a complete configuration, or test parsers and dictionaries separately.</source>
          <target state="translated">Поведение пользовательской конфигурации текстового поиска может легко запутаться.Функции,описанные в этом разделе,полезны для тестирования текстовых объектов поиска.Вы можете протестировать полную конфигурацию или протестировать парсеры и словари отдельно.</target>
        </trans-unit>
        <trans-unit id="7b27c83984e819ed5cc108965dd1a811c9d23e12" translate="yes" xml:space="preserve">
          <source>The behavior of foreign keys can be finely tuned to your application. We will not go beyond this simple example in this tutorial, but just refer you to &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; for more information. Making correct use of foreign keys will definitely improve the quality of your database applications, so you are strongly encouraged to learn about them.</source>
          <target state="translated">Поведение внешних ключей можно точно настроить для вашего приложения. В этом руководстве мы не будем выходить за рамки этого простого примера, а просто отсылаем вас к &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;главе 5&lt;/a&gt; для получения дополнительной информации. Правильное использование внешних ключей определенно улучшит качество ваших приложений баз данных, поэтому вам настоятельно рекомендуется узнать о них.</target>
        </trans-unit>
        <trans-unit id="3eeed7c57eb15931aa5b185d4f571a20fdfcd681" translate="yes" xml:space="preserve">
          <source>The behavior of foreign keys can be finely tuned to your application. We will not go beyond this simple example in this tutorial, but just refer you to &lt;a href=&quot;https://www.postgresql.org/docs/13/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; for more information. Making correct use of foreign keys will definitely improve the quality of your database applications, so you are strongly encouraged to learn about them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296b0cebbabc7c8e4b2d8335b6fb9121ab843326" translate="yes" xml:space="preserve">
          <source>The behavior of temporary tables at the end of a transaction block can be controlled using &lt;code&gt;ON COMMIT&lt;/code&gt;. The three options are:</source>
          <target state="translated">Поведение временных таблиц в конце блока транзакции можно контролировать с помощью &lt;code&gt;ON COMMIT&lt;/code&gt; . Есть три варианта:</target>
        </trans-unit>
        <trans-unit id="80731f14bda7a7a22a0a9014398f2bbf94eee233" translate="yes" xml:space="preserve">
          <source>The behavior of the &lt;code&gt;-t&lt;/code&gt; switch is not entirely upward compatible with pre-8.2 PostgreSQL versions. Formerly, writing &lt;code&gt;-t tab&lt;/code&gt; would dump all tables named &lt;code&gt;tab&lt;/code&gt;, but now it just dumps whichever one is visible in your default search path. To get the old behavior you can write &lt;code&gt;-t '*.tab'&lt;/code&gt;. Also, you must write something like &lt;code&gt;-t sch.tab&lt;/code&gt; to select a table in a particular schema, rather than the old locution of &lt;code&gt;-n sch -t tab&lt;/code&gt;.</source>
          <target state="translated">Поведение ключа &lt;code&gt;-t&lt;/code&gt; не полностью совместимо снизу вверх с версиями PostgreSQL до 8.2. Раньше запись &lt;code&gt;-t tab&lt;/code&gt; сбрасывала все таблицы с именем &lt;code&gt;tab&lt;/code&gt; , но теперь она просто сбрасывает ту, которая видна в вашем пути поиска по умолчанию. Чтобы получить старое поведение, вы можете написать &lt;code&gt;-t '*.tab'&lt;/code&gt; . Кроме того, вы должны написать что-то вроде &lt;code&gt;-t sch.tab&lt;/code&gt; для выбора таблицы в конкретной схеме, а не старое выражение &lt;code&gt;-n sch -t tab&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bad8faf22e7898fa3d14beb6bbfad8894c7e5cb" translate="yes" xml:space="preserve">
          <source>The behavior specified by the SQL standard is most closely approximated by giving users the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute, while roles are given the &lt;code&gt;INHERIT&lt;/code&gt; attribute.</source>
          <target state="translated">Поведение, указанное в стандарте SQL, наиболее точно соответствует предоставлению пользователям атрибута &lt;code&gt;NOINHERIT&lt;/code&gt; , а ролям - атрибут &lt;code&gt;INHERIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="999fc3c54ee5c4c5f6f59e07c2e8f063ee92343a" translate="yes" xml:space="preserve">
          <source>The benefits will normally be worthwhile only when a table would otherwise be very large. The exact point at which a table will benefit from partitioning depends on the application, although a rule of thumb is that the size of the table should exceed the physical memory of the database server.</source>
          <target state="translated">Преимущества,как правило,стоят только тогда,когда стол в противном случае был бы очень большим.Точная точка,в которой таблица выиграет от разметки,зависит от приложения,хотя эмпирическое правило заключается в том,что размер таблицы должен превышать физическую память сервера БД.</target>
        </trans-unit>
        <trans-unit id="7e72906a1cbbbaa7de5bc80e5365aa82f11074fd" translate="yes" xml:space="preserve">
          <source>The best defense against deadlocks is generally to avoid them by being certain that all applications using a database acquire locks on multiple objects in a consistent order. In the example above, if both transactions had updated the rows in the same order, no deadlock would have occurred. One should also ensure that the first lock acquired on an object in a transaction is the most restrictive mode that will be needed for that object. If it is not feasible to verify this in advance, then deadlocks can be handled on-the-fly by retrying transactions that abort due to deadlocks.</source>
          <target state="translated">Лучшая защита от тупиков,как правило,заключается в том,чтобы избежать их,будучи уверенным,что все приложения,использующие базу данных,получают замки на нескольких объектах в последовательном порядке.В приведенном выше примере,если бы обе транзакции обновили строки в одном и том же порядке,то никакого тупика не произошло бы.Следует также убедиться в том,что первая блокировка,полученная на объекте в транзакции,является наиболее ограничительным режимом,который будет необходим для этого объекта.Если это невозможно проверить заранее,то тупиковые ситуации могут быть обработаны &quot;на лету&quot; путем повторных попыток транзакций,которые прерываются из-за тупиковых ситуаций.</target>
        </trans-unit>
        <trans-unit id="d85f73754546926f4e2d17ccb6f522601d212cb5" translate="yes" xml:space="preserve">
          <source>The best solution for high availability is to ensure you keep as many synchronous standbys as requested. This can be achieved by naming multiple potential synchronous standbys using &lt;code&gt;synchronous_standby_names&lt;/code&gt;.</source>
          <target state="translated">Лучшее решение для обеспечения высокой доступности - обеспечить необходимое количество синхронных резервных серверов. Это может быть достигнуто путем присвоения имен нескольким потенциальным синхронным резервным серверам с помощью &lt;code&gt;synchronous_standby_names&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9ecf6d09480763021769b90c87994739dc69c88" translate="yes" xml:space="preserve">
          <source>The bitwise operators work only on integral data types, whereas the others are available for all numeric data types. The bitwise operators are also available for the bit string types &lt;code&gt;bit&lt;/code&gt; and &lt;code&gt;bit varying&lt;/code&gt;, as shown in &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;Table 9.14&lt;/a&gt;.</source>
          <target state="translated">Поразрядные операторы работают только с целыми типами данных, тогда как другие доступны для всех числовых типов данных. Поразрядные операторы также доступны для типов битовых строк, &lt;code&gt;bit&lt;/code&gt; и &lt;code&gt;bit varying&lt;/code&gt; , как показано в &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;Таблице 9.14&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1111c2349c7453008fe438b3fef48bff0b694759" translate="yes" xml:space="preserve">
          <source>The boolean aggregates &lt;code&gt;bool_and&lt;/code&gt; and &lt;code&gt;bool_or&lt;/code&gt; correspond to the standard SQL aggregates &lt;code&gt;every&lt;/code&gt; and &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;some&lt;/code&gt;. PostgreSQL supports &lt;code&gt;every&lt;/code&gt;, but not &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;some&lt;/code&gt;, because there is an ambiguity built into the standard syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb544aef82eb5e331a1c83d14ba3f14981e458a" translate="yes" xml:space="preserve">
          <source>The built-in parser is named &lt;code&gt;pg_catalog.default&lt;/code&gt;. It recognizes 23 token types, shown in &lt;a href=&quot;textsearch-parsers#TEXTSEARCH-DEFAULT-PARSER&quot;&gt;Table 12.1&lt;/a&gt;.</source>
          <target state="translated">Встроенный парсер называется &lt;code&gt;pg_catalog.default&lt;/code&gt; . Он распознает 23 типа токенов, показанных в &lt;a href=&quot;textsearch-parsers#TEXTSEARCH-DEFAULT-PARSER&quot;&gt;Таблице 12.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0849997236dc34c615a4c13089f2ec08456d374b" translate="yes" xml:space="preserve">
          <source>The built-in range types &lt;code&gt;int4range&lt;/code&gt;, &lt;code&gt;int8range&lt;/code&gt;, and &lt;code&gt;daterange&lt;/code&gt; all use a canonical form that includes the lower bound and excludes the upper bound; that is, &lt;code&gt;[)&lt;/code&gt;. User-defined range types can use other conventions, however.</source>
          <target state="translated">Все встроенные типы диапазонов &lt;code&gt;int4range&lt;/code&gt; , &lt;code&gt;int8range&lt;/code&gt; и &lt;code&gt;daterange&lt;/code&gt; используют каноническую форму, которая включает нижнюю границу и исключает верхнюю границу; то есть &lt;code&gt;[)&lt;/code&gt; . Однако определяемые пользователем типы диапазонов могут использовать другие соглашения.</target>
        </trans-unit>
        <trans-unit id="2a312305dbd3d6563e32a6d1866cf9d94a8d3583" translate="yes" xml:space="preserve">
          <source>The built-in window functions are described in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt;. Other window functions can be added by the user. Also, any built-in or user-defined general-purpose or statistical aggregate can be used as a window function. (Ordered-set and hypothetical-set aggregates cannot presently be used as window functions.)</source>
          <target state="translated">Встроенные оконные функции описаны в &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Табл. 9.60&lt;/a&gt; . Другие функции окна могут быть добавлены пользователем. Кроме того, в качестве оконной функции можно использовать любой встроенный или определяемый пользователем агрегат общего назначения или статистический агрегат. (Агрегаты упорядоченного набора и гипотетического набора в настоящее время не могут использоваться в качестве оконных функций.)</target>
        </trans-unit>
        <trans-unit id="1eb1519109d2d92138e97ee3336017e3e8180e57" translate="yes" xml:space="preserve">
          <source>The built-in window functions are listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt;. Note that these functions &lt;em&gt;must&lt;/em&gt; be invoked using window function syntax, i.e., an &lt;code&gt;OVER&lt;/code&gt; clause is required.</source>
          <target state="translated">Встроенные оконные функции перечислены в &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Таблице 9.60&lt;/a&gt; . Обратите внимание, что эти функции &lt;em&gt;должны&lt;/em&gt; вызываться с использованием синтаксиса оконных функций, т. &lt;code&gt;OVER&lt;/code&gt; Требуется предложение OVER .</target>
        </trans-unit>
        <trans-unit id="0a15741ae39e976d65eb76bd158e7ef106ba0c6d" translate="yes" xml:space="preserve">
          <source>The call handler function, the inline handler function (if any), and the validator function (if any) must already exist if the server does not have an entry for the language in &lt;code&gt;pg_pltemplate&lt;/code&gt;. But when there is an entry, the functions need not already exist; they will be automatically defined if not present in the database. (This might result in &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; failing, if the shared library that implements the language is not available in the installation.)</source>
          <target state="translated">Функция обработчика вызовов, встроенная функция обработчика (если есть) и функция валидатора (если есть) должны уже существовать, если на сервере нет записи для языка в &lt;code&gt;pg_pltemplate&lt;/code&gt; . Но когда есть запись, функции уже не должны существовать; они будут автоматически определены, если их нет в базе данных. (Это может привести к &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; , если общая библиотека, реализующая язык, недоступна в установке.)</target>
        </trans-unit>
        <trans-unit id="8a84995528c0ec41b02f477f2f19723fd9aad88c" translate="yes" xml:space="preserve">
          <source>The calling &lt;code&gt;SELECT&lt;/code&gt; statement doesn't necessarily have to be just &lt;code&gt;SELECT *&lt;/code&gt; &amp;mdash; it can reference the output columns by name or join them to other tables. The function produces a virtual table with which you can perform any operation you wish (e.g. aggregation, joining, sorting etc). So we could also have:</source>
          <target state="translated">Вызывающий &lt;code&gt;SELECT&lt;/code&gt; не обязательно должен быть просто &lt;code&gt;SELECT *&lt;/code&gt; - он может ссылаться на выходные столбцы по имени или присоединять их к другим таблицам. Функция создает виртуальную таблицу, с которой вы можете выполнять любую операцию, которую хотите (например, агрегирование, объединение, сортировку и т. Д.). Так что у нас также может быть:</target>
        </trans-unit>
        <trans-unit id="811562b4913f9796ae3f8f1999c658370788685e" translate="yes" xml:space="preserve">
          <source>The calling &lt;code&gt;SELECT&lt;/code&gt; statement doesn't necessarily have to be just &lt;code&gt;SELECT *&lt;/code&gt; &amp;mdash; it can reference the output columns by name or join them to other tables. The function produces a virtual table with which you can perform any operation you wish (e.g., aggregation, joining, sorting etc). So we could also have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f5d39131b77dc8ba4b8e8bbcf6ab1ac892db18" translate="yes" xml:space="preserve">
          <source>The capabilities available for administrators to monitor and control the server often change and improve in each major release.</source>
          <target state="translated">Возможности,доступные администраторам для мониторинга и управления сервером,часто меняются и улучшаются в каждом крупном выпуске.</target>
        </trans-unit>
        <trans-unit id="dcba21726e373c0ef3c1310c54912c4461e260b5" translate="yes" xml:space="preserve">
          <source>The cascading replication feature allows a standby server to accept replication connections and stream WAL records to other standbys, acting as a relay. This can be used to reduce the number of direct connections to the master and also to minimize inter-site bandwidth overheads.</source>
          <target state="translated">Функция каскадной репликации позволяет резервному серверу принимать соединения репликации и передавать записи WAL на другие резервные серверы,действуя в качестве ретранслятора.Это может быть использовано для уменьшения количества прямых соединений с ведущим сервером,а также для минимизации накладных расходов на межсайтовую пропускную способность.</target>
        </trans-unit>
        <trans-unit id="2414745d3bf9d469e38eb6deaa116aeca4c295eb" translate="yes" xml:space="preserve">
          <source>The cast functions listed in &lt;code&gt;pg_cast&lt;/code&gt; must always take the cast source type as their first argument type, and return the cast destination type as their result type. A cast function can have up to three arguments. The second argument, if present, must be type &lt;code&gt;integer&lt;/code&gt;; it receives the type modifier associated with the destination type, or -1 if there is none. The third argument, if present, must be type &lt;code&gt;boolean&lt;/code&gt;; it receives &lt;code&gt;true&lt;/code&gt; if the cast is an explicit cast, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Функции приведения, перечисленные в &lt;code&gt;pg_cast&lt;/code&gt; , всегда должны принимать тип источника приведения в качестве своего первого типа аргумента и возвращать целевой тип приведения в качестве своего типа результата. Функция приведения может иметь до трех аргументов. Второй аргумент, если он присутствует, должен иметь &lt;code&gt;integer&lt;/code&gt; тип ; он получает модификатор типа, связанный с типом назначения, или -1, если его нет. Третий аргумент, если он присутствует, должен иметь &lt;code&gt;boolean&lt;/code&gt; тип ; он получает &lt;code&gt;true&lt;/code&gt; , если приведение явное, и &lt;code&gt;false&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="fc5f1d64f67b0574d5ae7974d9bf0296a9ac950c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_aggregate&lt;/code&gt; stores information about aggregate functions. An aggregate function is a function that operates on a set of values (typically one column from each row that matches a query condition) and returns a single value computed from all these values. Typical aggregate functions are &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, and &lt;code&gt;max&lt;/code&gt;. Each entry in &lt;code&gt;pg_aggregate&lt;/code&gt; is an extension of an entry in &lt;code&gt;pg_proc&lt;/code&gt;. The &lt;code&gt;pg_proc&lt;/code&gt; entry carries the aggregate's name, input and output data types, and other information that is similar to ordinary functions.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_aggregate&lt;/code&gt; хранится информация об агрегатных функциях. Агрегатная функция - это функция, которая работает с набором значений (обычно один столбец из каждой строки, которая соответствует условию запроса) и возвращает одно значение, вычисленное из всех этих значений. Типичными агрегатными функциями являются &lt;code&gt;sum&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; и &lt;code&gt;max&lt;/code&gt; . Каждая запись в &lt;code&gt;pg_aggregate&lt;/code&gt; является расширением записи в &lt;code&gt;pg_proc&lt;/code&gt; . Запись &lt;code&gt;pg_proc&lt;/code&gt; содержит имя агрегата, типы входных и выходных данных и другую информацию, аналогичную обычным функциям.</target>
        </trans-unit>
        <trans-unit id="a29845311714d7d30ac211e7ed8230388dda9146" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_am&lt;/code&gt; stores information about relation access methods. There is one row for each access method supported by the system. Currently, only tables and indexes have access methods. The requirements for table and index access methods are discussed in detail in &lt;a href=&quot;tableam&quot;&gt;Chapter 60&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;Chapter 61&lt;/a&gt; respectively.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_am&lt;/code&gt; хранится информация о методах доступа к отношениям. Для каждого метода доступа, поддерживаемого системой, есть одна строка. В настоящее время методы доступа имеют только таблицы и индексы. Требования к методам доступа к таблицам и индексам подробно обсуждаются в &lt;a href=&quot;tableam&quot;&gt;главах 60&lt;/a&gt; и &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;61&lt;/a&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="a660b5abad7b774d10c5ce0b5d5dff4f4fa539e0" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_am&lt;/code&gt; stores information about relation access methods. There is one row for each access method supported by the system. Currently, only tables and indexes have access methods. The requirements for table and index access methods are discussed in detail in &lt;a href=&quot;tableam&quot;&gt;Chapter 60&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/indexam.html&quot;&gt;Chapter 61&lt;/a&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bec1e44f2188ec347a755f0e3375dfd03dbafab" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_amop&lt;/code&gt; stores information about operators associated with access method operator families. There is one row for each operator that is a member of an operator family. A family member can be either a &lt;em&gt;search&lt;/em&gt; operator or an &lt;em&gt;ordering&lt;/em&gt; operator. An operator can appear in more than one family, but cannot appear in more than one search position nor more than one ordering position within a family. (It is allowed, though unlikely, for an operator to be used for both search and ordering purposes.)</source>
          <target state="translated">В каталоге &lt;code&gt;pg_amop&lt;/code&gt; хранится информация об операторах, связанных с семействами операторов методов доступа. Для каждого оператора, входящего в семейство операторов, есть одна строка. Член семьи может быть либо оператором &lt;em&gt;поиска,&lt;/em&gt; либо оператором &lt;em&gt;заказа&lt;/em&gt; . Оператор может присутствовать более чем в одном семействе, но не может появляться более чем в одной позиции поиска или более чем в одной позиции упорядочивания в семействе. (Допускается, хотя и маловероятно, использование оператора как для поиска, так и для целей заказа.)</target>
        </trans-unit>
        <trans-unit id="7b26f7790ff6d1feb6dfed34e5224303ebaba082" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_amproc&lt;/code&gt; stores information about support functions associated with access method operator families. There is one row for each support function belonging to an operator family.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_amproc&lt;/code&gt; хранится информация о функциях поддержки, связанных с семействами операторов методов доступа. Для каждой вспомогательной функции, принадлежащей семейству операторов, есть одна строка.</target>
        </trans-unit>
        <trans-unit id="e1c43da8c1bc3b1aedcc6d0b4907170e6e551dad" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_attrdef&lt;/code&gt; stores column default values. The main information about columns is stored in &lt;a href=&quot;catalog-pg-attribute&quot;&gt;&lt;code&gt;pg_attribute&lt;/code&gt;&lt;/a&gt;. Only columns for which a default value has been explicitly set will have an entry here.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_attrdef&lt;/code&gt; хранятся значения столбцов по умолчанию. Основная информация о столбцах хранится в &lt;a href=&quot;catalog-pg-attribute&quot;&gt; &lt;code&gt;pg_attribute&lt;/code&gt; &lt;/a&gt; . Только столбцы, для которых явно установлено значение по умолчанию, будут иметь здесь запись.</target>
        </trans-unit>
        <trans-unit id="418f63e0244ab894621f6561175c2bc70b572229" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_attribute&lt;/code&gt; stores information about table columns. There will be exactly one &lt;code&gt;pg_attribute&lt;/code&gt; row for every column in every table in the database. (There will also be attribute entries for indexes, and indeed all objects that have &lt;code&gt;pg_class&lt;/code&gt; entries.)</source>
          <target state="translated">В каталоге &lt;code&gt;pg_attribute&lt;/code&gt; хранится информация о столбцах таблицы. Для каждого столбца в каждой таблице в базе данных будет ровно одна строка &lt;code&gt;pg_attribute&lt;/code&gt; . (Также будут записи атрибутов для индексов, да и вообще все объекты, имеющие записи &lt;code&gt;pg_class&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="85bbce99b3a9fdd7e277ae10030b9970f56238bf" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_auth_members&lt;/code&gt; shows the membership relations between roles. Any non-circular set of relationships is allowed.</source>
          <target state="translated">Каталог &lt;code&gt;pg_auth_members&lt;/code&gt; показывает отношения членства между ролями. Допускается любой некруговой набор отношений.</target>
        </trans-unit>
        <trans-unit id="c8154dc7e56592f09e48c6280c85b2550f6de4fa" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_authid&lt;/code&gt; contains information about database authorization identifiers (roles). A role subsumes the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo;. A user is essentially just a role with the &lt;code&gt;rolcanlogin&lt;/code&gt; flag set. Any role (with or without &lt;code&gt;rolcanlogin&lt;/code&gt;) can have other roles as members; see &lt;a href=&quot;catalog-pg-auth-members&quot;&gt;&lt;code&gt;pg_auth_members&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Каталог &lt;code&gt;pg_authid&lt;/code&gt; содержит информацию об идентификаторах (ролях) авторизации базы данных. Роль включает в себя понятия &amp;laquo;пользователи&amp;raquo; и &amp;laquo;группы&amp;raquo;. По сути, пользователь - это просто роль с &lt;code&gt;rolcanlogin&lt;/code&gt; флагом rolcanlogin . Любая роль (с или без &lt;code&gt;rolcanlogin&lt;/code&gt; ) может иметь другие роли в качестве участников; см. &lt;a href=&quot;catalog-pg-auth-members&quot;&gt; &lt;code&gt;pg_auth_members&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec983a869f6c2ea34ce8826bbeff462247f967af" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_cast&lt;/code&gt; stores data type conversion paths, both built-in and user-defined.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_cast&lt;/code&gt; хранятся пути преобразования типов данных, как встроенные, так и определяемые пользователем.</target>
        </trans-unit>
        <trans-unit id="9d04631bf68325b8525e49c943e731abe3613af7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_class&lt;/code&gt; catalogs tables and most everything else that has columns or is otherwise similar to a table. This includes indexes (but see also &lt;code&gt;pg_index&lt;/code&gt;), sequences (but see also &lt;code&gt;pg_sequence&lt;/code&gt;), views, materialized views, composite types, and TOAST tables; see &lt;code&gt;relkind&lt;/code&gt;. Below, when we mean all of these kinds of objects we speak of &amp;ldquo;relations&amp;rdquo;. Not all columns are meaningful for all relation types.</source>
          <target state="translated">Каталог &lt;code&gt;pg_class&lt;/code&gt; каталогизирует таблицы и большинство всего остального, что имеет столбцы или иным образом похоже на таблицу. Сюда входят индексы (но смотрите также &lt;code&gt;pg_index&lt;/code&gt; ), последовательности (но смотрите также &lt;code&gt;pg_sequence&lt;/code&gt; ), представления, материализованные представления, составные типы и таблицы TOAST; см. &lt;code&gt;relkind&lt;/code&gt; . Ниже, когда мы имеем в виду все эти виды объектов, мы говорим об &amp;laquo;отношениях&amp;raquo;. Не все столбцы значимы для всех типов отношений.</target>
        </trans-unit>
        <trans-unit id="ce60dbecc80ee8b02722d2865bea98e5166433a6" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_collation&lt;/code&gt; describes the available collations, which are essentially mappings from an SQL name to operating system locale categories. See &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt; for more information.</source>
          <target state="translated">Каталог &lt;code&gt;pg_collation&lt;/code&gt; описывает доступные сопоставления, которые, по сути, представляют собой сопоставления имени SQL с категориями языковых стандартов операционной системы. См. &lt;a href=&quot;collation&quot;&gt;Раздел 23.2&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="b24facc60ba613b096ec1ffd9828eff85b641f58" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_constraint&lt;/code&gt; stores check, primary key, unique, foreign key, and exclusion constraints on tables. (Column constraints are not treated specially. Every column constraint is equivalent to some table constraint.) Not-null constraints are represented in the &lt;code&gt;pg_attribute&lt;/code&gt; catalog, not here.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_constraint&lt;/code&gt; хранятся ограничения проверки, первичного ключа, уникальности, внешнего ключа и исключения для таблиц. (Ограничения столбца специально не обрабатываются. Каждое ограничение столбца эквивалентно некоторому ограничению таблицы.) &lt;code&gt;pg_attribute&lt;/code&gt; ограничения представлены в каталоге pg_attribute , а не здесь.</target>
        </trans-unit>
        <trans-unit id="b1be34b922edf24e062d7f1ae068ab828f281a75" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_conversion&lt;/code&gt; describes encoding conversion functions. See &lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt; for more information.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_conversion&lt;/code&gt; описаны функции преобразования кодировки. См. &lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="7fa266de7304c33b5491fba7214040981ff64d51" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_database&lt;/code&gt; stores information about the available databases. Databases are created with the &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; command. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for details about the meaning of some of the parameters.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_database&lt;/code&gt; хранится информация о доступных базах данных. Базы данных создаются с помощью команды &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; . Обратитесь к &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;главе 22&lt;/a&gt; для получения подробной информации о значении некоторых параметров.</target>
        </trans-unit>
        <trans-unit id="f49685a729552e79238070db8b64c8366090dda2" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_database&lt;/code&gt; stores information about the available databases. Databases are created with the &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; command. Consult &lt;a href=&quot;https://www.postgresql.org/docs/13/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for details about the meaning of some of the parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eca146c013dcb962be7fbc89316ecc63d19d2b8" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_db_role_setting&lt;/code&gt; records the default values that have been set for run-time configuration variables, for each role and database combination.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_db_role_setting&lt;/code&gt; записываются значения по умолчанию, которые были установлены для переменных конфигурации времени выполнения для каждой комбинации роли и базы данных.</target>
        </trans-unit>
        <trans-unit id="e6bd2b6528e4d970391e533c9ea2086c3fe18fc0" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_default_acl&lt;/code&gt; stores initial privileges to be assigned to newly created objects.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_default_acl&lt;/code&gt; хранятся начальные привилегии, назначаемые вновь созданным объектам.</target>
        </trans-unit>
        <trans-unit id="fa08d6f7153471b38ae0793d338ba6ab5b3ad0bd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_depend&lt;/code&gt; records the dependency relationships between database objects. This information allows &lt;code&gt;DROP&lt;/code&gt; commands to find which other objects must be dropped by &lt;code&gt;DROP CASCADE&lt;/code&gt; or prevent dropping in the &lt;code&gt;DROP RESTRICT&lt;/code&gt; case.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_depend&lt;/code&gt; записываются отношения зависимости между объектами базы данных. Эта информация позволяет командам &lt;code&gt;DROP&lt;/code&gt; находить, какие другие объекты должны быть отброшены с помощью &lt;code&gt;DROP CASCADE&lt;/code&gt; , или предотвращать удаление в случае &lt;code&gt;DROP RESTRICT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef59984dd4696772f2e8a7bbf2dcc9de1f2f041a" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_description&lt;/code&gt; stores optional descriptions (comments) for each database object. Descriptions can be manipulated with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command and viewed with psql's &lt;code&gt;\d&lt;/code&gt; commands. Descriptions of many built-in system objects are provided in the initial contents of &lt;code&gt;pg_description&lt;/code&gt;.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_description&lt;/code&gt; хранятся необязательные описания (комментарии) для каждого объекта базы данных. Описаниями можно управлять с помощью команды &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; и просматривать с помощью команд psql &lt;code&gt;\d&lt;/code&gt; . Описание многих встроенных системных объектов содержится в исходном содержании &lt;code&gt;pg_description&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f9198ecc665eb9bf0a1925898c8388b6df71db7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_event_trigger&lt;/code&gt; stores event triggers. See &lt;a href=&quot;https://www.postgresql.org/docs/12/event-triggers.html&quot;&gt;Chapter 39&lt;/a&gt; for more information.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_event_trigger&lt;/code&gt; хранятся триггеры событий. См. &lt;a href=&quot;https://www.postgresql.org/docs/12/event-triggers.html&quot;&gt;Главу 39&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="5ae659e278f2c6f623d87b5b040902fb8aebc1a0" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_event_trigger&lt;/code&gt; stores event triggers. See &lt;a href=&quot;https://www.postgresql.org/docs/13/event-triggers.html&quot;&gt;Chapter 39&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e240a6b04efec03e383c5c2cbf6a0f5343f115" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_extension&lt;/code&gt; stores information about the installed extensions. See &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt; for details about extensions.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_extension&lt;/code&gt; хранится информация об установленных расширениях. См. &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;Раздел 37.17&lt;/a&gt; для подробностей о расширениях.</target>
        </trans-unit>
        <trans-unit id="9a6bd669eb72e3c7fbbe3af8a149088d554d60d9" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_extension&lt;/code&gt; stores information about the installed extensions. See &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt; for details about extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ec179e1854cef6ef5b48336a3d0be1aebd94a3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_data_wrapper&lt;/code&gt; stores foreign-data wrapper definitions. A foreign-data wrapper is the mechanism by which external data, residing on foreign servers, is accessed.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_foreign_data_wrapper&lt;/code&gt; хранятся определения оболочки сторонних данных. Оболочка сторонних данных - это механизм, с помощью которого осуществляется доступ к внешним данным, находящимся на внешних серверах.</target>
        </trans-unit>
        <trans-unit id="14e59b5f4fd68c0de1f4d9757cb9140d56e66bca" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_server&lt;/code&gt; stores foreign server definitions. A foreign server describes a source of external data, such as a remote server. Foreign servers are accessed via foreign-data wrappers.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_foreign_server&lt;/code&gt; хранятся определения сторонних серверов. Внешний сервер описывает источник внешних данных, например удаленный сервер. Доступ к внешним серверам осуществляется через оболочки сторонних данных.</target>
        </trans-unit>
        <trans-unit id="51d82ed7d4c3db5d6e6e20d733bd83d0fb2db31f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_table&lt;/code&gt; contains auxiliary information about foreign tables. A foreign table is primarily represented by a &lt;code&gt;pg_class&lt;/code&gt; entry, just like a regular table. Its &lt;code&gt;pg_foreign_table&lt;/code&gt; entry contains the information that is pertinent only to foreign tables and not any other kind of relation.</source>
          <target state="translated">Каталог &lt;code&gt;pg_foreign_table&lt;/code&gt; содержит вспомогательную информацию о сторонних таблицах. Внешняя таблица в основном представлена &lt;code&gt;pg_class&lt;/code&gt; , как и обычная таблица. Его запись &lt;code&gt;pg_foreign_table&lt;/code&gt; содержит информацию, имеющую отношение только к сторонним таблицам, а не к каким-либо другим видам отношений.</target>
        </trans-unit>
        <trans-unit id="775fb259c9b9e32be3ed5d81afd596a58bfd39dd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_index&lt;/code&gt; contains part of the information about indexes. The rest is mostly in &lt;code&gt;pg_class&lt;/code&gt;.</source>
          <target state="translated">Каталог &lt;code&gt;pg_index&lt;/code&gt; содержит часть информации об индексах. Остальное в основном находится в &lt;code&gt;pg_class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be9fa6ee074572af10ef89fb86dd033d0a67087f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_inherits&lt;/code&gt; records information about table and index inheritance hierarchies. There is one entry for each direct parent-child table or index relationship in the database. (Indirect inheritance can be determined by following chains of entries.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a623a0b18b2ebaf8e83d5ac1d0d6cf3474af033" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_inherits&lt;/code&gt; records information about table inheritance hierarchies. There is one entry for each direct parent-child table relationship in the database. (Indirect inheritance can be determined by following chains of entries.)</source>
          <target state="translated">В каталоге &lt;code&gt;pg_inherits&lt;/code&gt; записывается информация об иерархиях наследования таблиц. Есть одна запись для каждой прямой связи родительско-дочерней таблицы в базе данных. (Косвенное наследование можно определить, следуя цепочке записей.)</target>
        </trans-unit>
        <trans-unit id="3ef3657b35ed0b4f238ec5987d2edc24285c1ce6" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_init_privs&lt;/code&gt; records information about the initial privileges of objects in the system. There is one entry for each object in the database which has a non-default (non-NULL) initial set of privileges.</source>
          <target state="translated">Каталог &lt;code&gt;pg_init_privs&lt;/code&gt; записывает информацию о начальных привилегиях объектов в системе. Есть одна запись для каждого объекта в базе данных, который имеет нестандартный (не равный NULL) начальный набор привилегий.</target>
        </trans-unit>
        <trans-unit id="aed131707c511022c9597a108a69123aaaa06b71" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_language&lt;/code&gt; registers languages in which you can write functions or stored procedures. See &lt;a href=&quot;sql-createlanguage&quot;&gt;CREATE LANGUAGE&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xplang.html&quot;&gt;Chapter 41&lt;/a&gt; for more information about language handlers.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_language&lt;/code&gt; зарегистрированы языки, на которых вы можете писать функции или хранимые процедуры. См. &lt;a href=&quot;sql-createlanguage&quot;&gt;CREATE LANGUAGE&lt;/a&gt; и &lt;a href=&quot;https://www.postgresql.org/docs/12/xplang.html&quot;&gt;Глава 41&lt;/a&gt; для получения дополнительной информации о языковых обработчиках.</target>
        </trans-unit>
        <trans-unit id="3dbfd44a82e6b207a606d4410b4069adc945e68c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_language&lt;/code&gt; registers languages in which you can write functions or stored procedures. See &lt;a href=&quot;sql-createlanguage&quot;&gt;CREATE LANGUAGE&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/xplang.html&quot;&gt;Chapter 41&lt;/a&gt; for more information about language handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc853ae6dcab566bb8d51b6c3df6a48ca149be41" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_largeobject&lt;/code&gt; holds the data making up &amp;ldquo;large objects&amp;rdquo;. A large object is identified by an OID assigned when it is created. Each large object is broken into segments or &amp;ldquo;pages&amp;rdquo; small enough to be conveniently stored as rows in &lt;code&gt;pg_largeobject&lt;/code&gt;. The amount of data per page is defined to be &lt;code&gt;LOBLKSIZE&lt;/code&gt; (which is currently &lt;code&gt;BLCKSZ/4&lt;/code&gt;, or typically 2 kB).</source>
          <target state="translated">В каталоге &lt;code&gt;pg_largeobject&lt;/code&gt; хранятся данные, составляющие &amp;laquo;большие объекты&amp;raquo;. Большой объект идентифицируется по OID, присвоенному при его создании. Каждый большой объект разбит на сегменты или &amp;laquo;страницы&amp;raquo;, достаточно маленькие, чтобы их можно было удобно хранить в виде строк в &lt;code&gt;pg_largeobject&lt;/code&gt; . Объем данных на странице определяется как &lt;code&gt;LOBLKSIZE&lt;/code&gt; (в настоящее время это &lt;code&gt;BLCKSZ/4&lt;/code&gt; , или обычно 2 кБ).</target>
        </trans-unit>
        <trans-unit id="637a0fff02f805fcd7f6572b41b759dc3d88c524" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_largeobject_metadata&lt;/code&gt; holds metadata associated with large objects. The actual large object data is stored in &lt;a href=&quot;catalog-pg-largeobject&quot;&gt;&lt;code&gt;pg_largeobject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Каталог &lt;code&gt;pg_largeobject_metadata&lt;/code&gt; содержит метаданные, связанные с большими объектами. Фактические данные большого объекта хранятся в &lt;a href=&quot;catalog-pg-largeobject&quot;&gt; &lt;code&gt;pg_largeobject&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1da9fb341c1eb2b89353bf65057bd43bdb97a022" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_namespace&lt;/code&gt; stores namespaces. A namespace is the structure underlying SQL schemas: each namespace can have a separate collection of relations, types, etc. without name conflicts.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_namespace&lt;/code&gt; хранятся пространства имен. Пространство имен - это структура, лежащая в основе схем SQL: каждое пространство имен может иметь отдельный набор отношений, типов и т. Д. Без конфликтов имен.</target>
        </trans-unit>
        <trans-unit id="85e7a372d092106d4f08f9fcd3ea02828fcaa191" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_opclass&lt;/code&gt; defines index access method operator classes. Each operator class defines semantics for index columns of a particular data type and a particular index access method. An operator class essentially specifies that a particular operator family is applicable to a particular indexable column data type. The set of operators from the family that are actually usable with the indexed column are whichever ones accept the column's data type as their left-hand input.</source>
          <target state="translated">Каталог &lt;code&gt;pg_opclass&lt;/code&gt; определяет классы операторов метода доступа к индексу. Каждый класс операторов определяет семантику для столбцов индекса определенного типа данных и конкретного метода доступа к индексу. Класс операторов по существу указывает, что конкретное семейство операторов применимо к определенному типу данных индексируемого столбца. Набор операторов из семейства, которые фактически можно использовать с индексированным столбцом, - это те, которые принимают тип данных столбца как левый ввод.</target>
        </trans-unit>
        <trans-unit id="c87fca68633fb63db57e86d79fac7ce1b22101ea" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_operator&lt;/code&gt; stores information about operators. See &lt;a href=&quot;sql-createoperator&quot;&gt;CREATE OPERATOR&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper.html&quot;&gt;Section 37.14&lt;/a&gt; for more information.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_operator&lt;/code&gt; хранится информация об операторах. См. &lt;a href=&quot;sql-createoperator&quot;&gt;CREATE OPERATOR&lt;/a&gt; и &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper.html&quot;&gt;Раздел 37.14&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="db699f37242b8105097dbca69774e5077ef97a6f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_operator&lt;/code&gt; stores information about operators. See &lt;a href=&quot;sql-createoperator&quot;&gt;CREATE OPERATOR&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/xoper.html&quot;&gt;Section 37.14&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3fdeed75aa3ce97ce3c38ef12f91f3c508c158" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_opfamily&lt;/code&gt; defines operator families. Each operator family is a collection of operators and associated support routines that implement the semantics specified for a particular index access method. Furthermore, the operators in a family are all &amp;ldquo;compatible&amp;rdquo;, in a way that is specified by the access method. The operator family concept allows cross-data-type operators to be used with indexes and to be reasoned about using knowledge of access method semantics.</source>
          <target state="translated">Каталог &lt;code&gt;pg_opfamily&lt;/code&gt; определяет семейства операторов. Каждое семейство операторов представляет собой набор операторов и связанных подпрограмм поддержки, реализующих семантику, указанную для конкретного метода доступа к индексу. Более того, все операторы в семействе &amp;laquo;совместимы&amp;raquo;, что определяется методом доступа. Концепция семейства операторов позволяет использовать операторы с разными типами данных с индексами и рассуждать об использовании знания семантики метода доступа.</target>
        </trans-unit>
        <trans-unit id="9f9d81d5db57fdf3722685cee5c72c0b7b266b01" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_partitioned_table&lt;/code&gt; stores information about how tables are partitioned.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_partitioned_table&lt;/code&gt; хранится информация о том, как разделены таблицы.</target>
        </trans-unit>
        <trans-unit id="c4598dc8a02ea46018473ad3a155097abd3c7904" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_pltemplate&lt;/code&gt; stores &amp;ldquo;template&amp;rdquo; information for procedural languages. A template for a language allows the language to be created in a particular database by a simple &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; command, with no need to specify implementation details.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_pltemplate&lt;/code&gt; хранится &amp;laquo;шаблонная&amp;raquo; информация для процедурных языков. Шаблон для языка позволяет создать язык в конкретной базе данных с помощью простой команды &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; , без необходимости указывать детали реализации.</target>
        </trans-unit>
        <trans-unit id="38521eab8f4daa25e1c972502335611e746aa47f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_policy&lt;/code&gt; stores row level security policies for tables. A policy includes the kind of command that it applies to (possibly all commands), the roles that it applies to, the expression to be added as a security-barrier qualification to queries that include the table, and the expression to be added as a &lt;code&gt;WITH CHECK&lt;/code&gt; option for queries that attempt to add new records to the table.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_policy&lt;/code&gt; хранятся политики безопасности на уровне строк для таблиц. Политика включает в себя тип команды, к которой она применяется (возможно, все команды), роли, к которым она применяется, выражение, которое должно быть добавлено в качестве квалификации барьера безопасности к запросам, которые включают таблицу, и выражение, которое будет добавлено как &lt;code&gt;WITH CHECK&lt;/code&gt; для запросов, которые пытаются добавить новые записи в таблицу.</target>
        </trans-unit>
        <trans-unit id="077da08d3639d4de1fea458f7cc6d9c77756beb9" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_proc&lt;/code&gt; stores information about functions, procedures, aggregate functions, and window functions (collectively also known as routines). See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;, &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt; for more information.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_proc&lt;/code&gt; хранится информация о функциях, процедурах, агрегатных функциях и оконных функциях (вместе также известных как подпрограммы). См. &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; , &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt; и &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Раздел 37.3&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="9e11644222b2201539ac16dfa7848782b7baf235" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_proc&lt;/code&gt; stores information about functions, procedures, aggregate functions, and window functions (collectively also known as routines). See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;, &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfdad63a7f3f3f55487cbe48d50b5126f2fe14c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_publication&lt;/code&gt; contains all publications created in the database. For more on publications see &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt;.</source>
          <target state="translated">Каталог &lt;code&gt;pg_publication&lt;/code&gt; содержит все публикации, созданные в базе данных. Подробнее о публикациях см. &lt;a href=&quot;logical-replication-publication&quot;&gt;Раздел 30.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b073514e28d8a7dd7d94b64ba581679b1b8073f2" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_publication_rel&lt;/code&gt; contains the mapping between relations and publications in the database. This is a many-to-many mapping. See also &lt;a href=&quot;view-pg-publication-tables&quot;&gt;Section 51.78&lt;/a&gt; for a more user-friendly view of this information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221d9ab9d81b22114af5be8f658f635812a98821" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_publication_rel&lt;/code&gt; contains the mapping between relations and publications in the database. This is a many-to-many mapping. See also &lt;a href=&quot;view-pg-publication-tables&quot;&gt;Section 51.79&lt;/a&gt; for a more user-friendly view of this information.</source>
          <target state="translated">Каталог &lt;code&gt;pg_publication_rel&lt;/code&gt; содержит отображение между отношениями и публикациями в базе данных. Это отображение &quot;многие ко многим&quot;. См. Также &lt;a href=&quot;view-pg-publication-tables&quot;&gt;Раздел 51.79&lt;/a&gt; для более удобного просмотра этой информации.</target>
        </trans-unit>
        <trans-unit id="52875f38f647bef6fb760c4d6882bec8ce49439c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_range&lt;/code&gt; stores information about range types. This is in addition to the types' entries in &lt;a href=&quot;catalog-pg-type&quot;&gt;&lt;code&gt;pg_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_range&lt;/code&gt; хранится информация о типах диапазонов. Это дополнение к записям типов в &lt;a href=&quot;catalog-pg-type&quot;&gt; &lt;code&gt;pg_type&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc31d507f60721e880a15f8324203d061317541c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_rewrite&lt;/code&gt; stores rewrite rules for tables and views.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_rewrite&lt;/code&gt; хранятся правила перезаписи для таблиц и представлений.</target>
        </trans-unit>
        <trans-unit id="2bbefd7f86634f56307ee5fef9c894c5719937d5" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_seclabel&lt;/code&gt; stores security labels on database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.83&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="743cf387d8af7cd433c0ab8fa075de457723d7d5" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_seclabel&lt;/code&gt; stores security labels on database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.84&lt;/a&gt;.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_seclabel&lt;/code&gt; хранятся метки защиты объектов базы данных. Метки защиты можно изменять с помощью команды &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; . Более простой способ просмотра защитных меток см. В &lt;a href=&quot;view-pg-seclabels&quot;&gt;Разделе 51.84&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06336f290aa5f875fbaac3ca8b83cb8674898645" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_sequence&lt;/code&gt; contains information about sequences. Some of the information about sequences, such as the name and the schema, is in &lt;code&gt;pg_class&lt;/code&gt;.</source>
          <target state="translated">Каталог &lt;code&gt;pg_sequence&lt;/code&gt; содержит информацию о последовательностях. Некоторая информация о последовательностях, такая как имя и схема, находится в &lt;code&gt;pg_class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98aafe9d92bd83fff00a553e40adb49ebd9fb0ff" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shdepend&lt;/code&gt; records the dependency relationships between database objects and shared objects, such as roles. This information allows PostgreSQL to ensure that those objects are unreferenced before attempting to delete them.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_shdepend&lt;/code&gt; записываются отношения зависимости между объектами базы данных и общими объектами, такими как роли. Эта информация позволяет PostgreSQL гарантировать, что на эти объекты нет ссылок, прежде чем пытаться удалить их.</target>
        </trans-unit>
        <trans-unit id="707a904a0a65e47118a70277c90bf66e00682ea7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shdescription&lt;/code&gt; stores optional descriptions (comments) for shared database objects. Descriptions can be manipulated with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command and viewed with psql's &lt;code&gt;\d&lt;/code&gt; commands.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_shdescription&lt;/code&gt; хранятся необязательные описания (комментарии) для общих объектов базы данных. Описаниями можно управлять с помощью команды &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; и просматривать с помощью команд psql &lt;code&gt;\d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="108e726e137da0b8ec8293c84d0b89131f7f1510" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shseclabel&lt;/code&gt; stores security labels on shared database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.83&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb1cad576af7b20a74691e7e84a0abf3918f82ca" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shseclabel&lt;/code&gt; stores security labels on shared database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.84&lt;/a&gt;.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_shseclabel&lt;/code&gt; хранятся метки безопасности для общих объектов базы данных. Метки защиты можно изменять с помощью команды &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; . Более простой способ просмотра защитных меток см. В &lt;a href=&quot;view-pg-seclabels&quot;&gt;Разделе 51.84&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d95048be51e3aac388b17358a36c3017066f7afd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic&lt;/code&gt; stores statistical data about the contents of the database. Entries are created by &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; and subsequently used by the query planner. Note that all the statistical data is inherently approximate, even assuming that it is up-to-date.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_statistic&lt;/code&gt; хранятся статистические данные о содержимом базы данных. Записи создаются &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; и впоследствии используются планировщиком запросов. Обратите внимание, что все статистические данные по своей сути приблизительны, даже если предположить, что они актуальны.</target>
        </trans-unit>
        <trans-unit id="1a788b199242747f1e3ab3d464f7f212c88021b3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic_ext&lt;/code&gt; holds definitions of extended planner statistics. Each row in this catalog corresponds to a &lt;em&gt;statistics object&lt;/em&gt; created with &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt;.</source>
          <target state="translated">Каталог &lt;code&gt;pg_statistic_ext&lt;/code&gt; содержит определения расширенной статистики планировщика. Каждая строка в этом каталоге соответствует &lt;em&gt;объекту статистики,&lt;/em&gt; созданному с помощью &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="efd7c967165399ed5a01a4ab9407cb379c75802f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; holds data for extended planner statistics defined in &lt;code&gt;pg_statistic_ext&lt;/code&gt;. Each row in this catalog corresponds to a &lt;em&gt;statistics object&lt;/em&gt; created with &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt;.</source>
          <target state="translated">Каталог &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; содержит данные для расширенной статистики планировщика, определенной в &lt;code&gt;pg_statistic_ext&lt;/code&gt; . Каждая строка в этом каталоге соответствует &lt;em&gt;объекту статистики,&lt;/em&gt; созданному с помощью &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c35fed25fc50b397d0a14fb9dcbeb17e75e6fe0f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_subscription&lt;/code&gt; contains all existing logical replication subscriptions. For more information about logical replication see &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="translated">Каталог &lt;code&gt;pg_subscription&lt;/code&gt; содержит все существующие подписки логической репликации. Дополнительные сведения о логической репликации см. В &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;главе 30&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2bfa0dd174813a02371e96eb1388d8212cb9d420" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_subscription&lt;/code&gt; contains all existing logical replication subscriptions. For more information about logical replication see &lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cdf4cde86fcb864fb5af90b023119fc34f2142d" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_subscription_rel&lt;/code&gt; contains the state for each replicated relation in each subscription. This is a many-to-many mapping.</source>
          <target state="translated">Каталог &lt;code&gt;pg_subscription_rel&lt;/code&gt; содержит состояние каждого реплицированного отношения в каждой подписке. Это отображение &quot;многие ко многим&quot;.</target>
        </trans-unit>
        <trans-unit id="c447f5488ab316d33bbd3ebcf5f5d8b7c31ae85d" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_tablespace&lt;/code&gt; stores information about the available tablespaces. Tables can be placed in particular tablespaces to aid administration of disk layout.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_tablespace&lt;/code&gt; хранится информация о доступных табличных пространствах. Таблицы могут быть размещены в определенных табличных пространствах для облегчения администрирования структуры диска.</target>
        </trans-unit>
        <trans-unit id="5fd8fed96cb099d0e2d39d4d04e6e7c47d74045e" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_transform&lt;/code&gt; stores information about transforms, which are a mechanism to adapt data types to procedural languages. See &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt; for more information.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_transform&lt;/code&gt; хранится информация о преобразованиях, которые представляют собой механизм адаптации типов данных к процедурным языкам. См. &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="75ce3dfcf04f9d1f1bc6bfe6a8a43c82175b0a72" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_trigger&lt;/code&gt; stores triggers on tables and views. See &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; for more information.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_trigger&lt;/code&gt; хранятся триггеры для таблиц и представлений. См. &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="392fc6d5e6430c985734db6f435318b9f05a7dd3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_type&lt;/code&gt; stores information about data types. Base types and enum types (scalar types) are created with &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;, and domains with &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;. A composite type is automatically created for each table in the database, to represent the row structure of the table. It is also possible to create composite types with &lt;code&gt;CREATE TYPE AS&lt;/code&gt;.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_type&lt;/code&gt; хранится информация о типах данных. Базовые типы и типы перечислений (скалярные типы) создаются с помощью &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; , а домены - с помощью &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt; . Составной тип автоматически создается для каждой таблицы в базе данных, чтобы представить структуру строк таблицы. Также можно создавать составные типы с помощью &lt;code&gt;CREATE TYPE AS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bc1e303fc4f7bb28411737b0ff9561def41771f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_user_mapping&lt;/code&gt; stores the mappings from local user to remote. Access to this catalog is restricted from normal users, use the view &lt;a href=&quot;view-pg-user-mappings&quot;&gt;&lt;code&gt;pg_user_mappings&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">В каталоге &lt;code&gt;pg_user_mapping&lt;/code&gt; хранятся сопоставления от локального пользователя к удаленному. Доступ к этому каталогу ограничен для обычных пользователей, используйте вместо него представление &lt;a href=&quot;view-pg-user-mappings&quot;&gt; &lt;code&gt;pg_user_mappings&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96e368561ccfd905eaa08f49037cf99602ef83c4" translate="yes" xml:space="preserve">
          <source>The category code (a single ASCII character) for this type. The default is &lt;code&gt;'U'&lt;/code&gt; for &amp;ldquo;user-defined type&amp;rdquo;. Other standard category codes can be found in &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.63&lt;/a&gt;. You may also choose other ASCII characters in order to create custom categories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a544b25f1cc2eef0830902b29eb1826d7423c5" translate="yes" xml:space="preserve">
          <source>The category code (a single ASCII character) for this type. The default is &lt;code&gt;'U'&lt;/code&gt; for &amp;ldquo;user-defined type&amp;rdquo;. Other standard category codes can be found in &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.64&lt;/a&gt;. You may also choose other ASCII characters in order to create custom categories.</source>
          <target state="translated">Код категории (один символ ASCII) для этого типа. По умолчанию это &lt;code&gt;'U'&lt;/code&gt; для &amp;laquo;определяемого пользователем типа&amp;raquo;. Коды других стандартных категорий можно найти в &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Таблице 51.64&lt;/a&gt; . Вы также можете выбрать другие символы ASCII для создания собственных категорий.</target>
        </trans-unit>
        <trans-unit id="6e0699308172a4d35d3852cf096bcc7cdc0d6fc5" translate="yes" xml:space="preserve">
          <source>The category names translate into names of &lt;code&gt;initdb&lt;/code&gt; options to override the locale choice for a specific category. For instance, to set the locale to French Canadian, but use U.S. rules for formatting currency, use &lt;code&gt;initdb --locale=fr_CA --lc-monetary=en_US&lt;/code&gt;.</source>
          <target state="translated">Имена категорий переводятся в имена параметров &lt;code&gt;initdb&lt;/code&gt; , чтобы переопределить выбор локали для конкретной категории. Например, чтобы установить языковой стандарт на французско-канадский, но использовать правила США для форматирования валюты, используйте &lt;code&gt;initdb --locale=fr_CA --lc-monetary=en_US&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90aadd1f991be6c6a59649f2cf2279a49d630988" translate="yes" xml:space="preserve">
          <source>The century</source>
          <target state="translated">Век</target>
        </trans-unit>
        <trans-unit id="64714127e62379960f8b9dabad3b7dd16b967248" translate="yes" xml:space="preserve">
          <source>The character set encoding specified for the new database must be compatible with the chosen locale settings (&lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;). If the locale is &lt;code&gt;C&lt;/code&gt; (or equivalently &lt;code&gt;POSIX&lt;/code&gt;), then all encodings are allowed, but for other locale settings there is only one encoding that will work properly. (On Windows, however, UTF-8 encoding can be used with any locale.) &lt;code&gt;CREATE DATABASE&lt;/code&gt; will allow superusers to specify &lt;code&gt;SQL_ASCII&lt;/code&gt; encoding regardless of the locale settings, but this choice is deprecated and may result in misbehavior of character-string functions if data that is not encoding-compatible with the locale is stored in the database.</source>
          <target state="translated">Кодировка набора символов, указанная для новой базы данных, должна быть совместима с выбранными настройками локали ( &lt;code&gt;LC_COLLATE&lt;/code&gt; и &lt;code&gt;LC_CTYPE&lt;/code&gt; ). Если языковой стандарт &lt;code&gt;C&lt;/code&gt; (или эквивалентный &lt;code&gt;POSIX&lt;/code&gt; ), тогда разрешены все кодировки, но для других настроек языкового стандарта существует только одна кодировка, которая будет работать правильно. (В Windows, однако, кодировка UTF-8 может использоваться с любой локалью.) &lt;code&gt;CREATE DATABASE&lt;/code&gt; позволит суперпользователям указывать кодировку &lt;code&gt;SQL_ASCII&lt;/code&gt; независимо от настроек локали, но этот выбор не рекомендуется и может привести к неправильному поведению функций символьной строки, если данные кодировка, несовместимая с локалью, хранится в базе данных.</target>
        </trans-unit>
        <trans-unit id="89d6fa6368565c20d96f1143f8a41b5bdded6f20" translate="yes" xml:space="preserve">
          <source>The character set support in PostgreSQL allows you to store text in a variety of character sets (also called encodings), including single-byte character sets such as the ISO 8859 series and multiple-byte character sets such as EUC (Extended Unix Code), UTF-8, and Mule internal code. All supported character sets can be used transparently by clients, but a few are not supported for use within the server (that is, as a server-side encoding). The default character set is selected while initializing your PostgreSQL database cluster using &lt;code&gt;initdb&lt;/code&gt;. It can be overridden when you create a database, so you can have multiple databases each with a different character set.</source>
          <target state="translated">Поддержка набора символов в PostgreSQL позволяет хранить текст в различных наборах символов (также называемых кодировками), включая однобайтовые наборы символов, такие как серия ISO 8859, и многобайтовые наборы символов, такие как EUC (Extended Unix Code), UTF-8 и внутренний код Mule. Все поддерживаемые наборы символов могут прозрачно использоваться клиентами, но некоторые из них не поддерживаются для использования на сервере (то есть как кодирование на стороне сервера). Набор символов по умолчанию выбирается при инициализации кластера базы данных PostgreSQL с помощью &lt;code&gt;initdb&lt;/code&gt; . Его можно переопределить при создании базы данных, поэтому у вас может быть несколько баз данных с различным набором символов.</target>
        </trans-unit>
        <trans-unit id="97fdcbffdcc8da09aa147a46393111714ca188e7" translate="yes" xml:space="preserve">
          <source>The character with the code zero cannot be in a string constant.</source>
          <target state="translated">Символ с кодовым нулем не может находиться в строковой константе.</target>
        </trans-unit>
        <trans-unit id="1c743222d29807902173d80c9ab0c69944ad07be" translate="yes" xml:space="preserve">
          <source>The character with the indicated octal code is substituted.</source>
          <target state="translated">Подставляется символ с указанным восьмеричным кодом.</target>
        </trans-unit>
        <trans-unit id="9883df04aca064376efa049e7f1ac203fe46e46b" translate="yes" xml:space="preserve">
          <source>The character-entry escapes are always taken as ordinary characters. For example, &lt;code&gt;\135&lt;/code&gt; is &lt;code&gt;]&lt;/code&gt; in ASCII, but &lt;code&gt;\135&lt;/code&gt; does not terminate a bracket expression.</source>
          <target state="translated">Экраны для ввода символов всегда воспринимаются как обычные символы. Например, &lt;code&gt;\135&lt;/code&gt; is &lt;code&gt;]&lt;/code&gt; в ASCII, но &lt;code&gt;\135&lt;/code&gt; не завершает выражение в скобках.</target>
        </trans-unit>
        <trans-unit id="ef0e78b53fce5d8f9142725e8e0f3c5fa09a015f" translate="yes" xml:space="preserve">
          <source>The checkpoint requirement of flushing all dirty data pages to disk can cause a significant I/O load. For this reason, checkpoint activity is throttled so that I/O begins at checkpoint start and completes before the next checkpoint is due to start; this minimizes performance degradation during checkpoints.</source>
          <target state="translated">Требование к контрольной точке при промывке всех загрязненных страниц данных на диск может вызвать значительную нагрузку на входы/выходы.По этой причине работа контрольной точки дросселируется таким образом,что ввод/вывод начинается при запуске контрольной точки и завершается до того,как должна начаться следующая контрольная точка;это сводит к минимуму снижение производительности во время работы контрольной точки.</target>
        </trans-unit>
        <trans-unit id="f4d35c97f000761ce44e09472b3a63a412d56f71" translate="yes" xml:space="preserve">
          <source>The checkpointer process and the background writer process are active during recovery. The checkpointer process will perform restartpoints (similar to checkpoints on the primary) and the background writer process will perform normal block cleaning activities. This can include updates of the hint bit information stored on the standby server. The &lt;code&gt;CHECKPOINT&lt;/code&gt; command is accepted during recovery, though it performs a restartpoint rather than a new checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35fb7c2595863d64a01efb7c2bd0d7867c26535" translate="yes" xml:space="preserve">
          <source>The checksum algorithm used to compute a checksum for this file. Currently, this will be the same for every file in the backup manifest, but this may change in future releases. At present, the supported checksum algorithms are &lt;code&gt;CRC32C&lt;/code&gt;, &lt;code&gt;SHA224&lt;/code&gt;, &lt;code&gt;SHA256&lt;/code&gt;, &lt;code&gt;SHA384&lt;/code&gt;, and &lt;code&gt;SHA512&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e144e6ae4a14c0e501dd6cac26f66ddeeba08c8" translate="yes" xml:space="preserve">
          <source>The checksum computed for this file, stored as a series of hexadecimal characters, two for each byte of the checksum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea1ec4dfdbf684f4c49444bdb751e65ee9f5e89" translate="yes" xml:space="preserve">
          <source>The checksum computed with this function can be compared with the &lt;code&gt;checksum&lt;/code&gt; result field of the function &lt;code&gt;page_header&lt;/code&gt;. If data checksums are enabled for this instance, then the two values should be equal.</source>
          <target state="translated">Контрольную сумму, вычисленную с помощью этой функции, можно сравнить с полем результата &lt;code&gt;checksum&lt;/code&gt; функции &lt;code&gt;page_header&lt;/code&gt; . Если для этого экземпляра включены контрольные суммы данных, то два значения должны быть равны.</target>
        </trans-unit>
        <trans-unit id="12cbfddc1d2244a2eb37d3e1009dc9d4f7140abc" translate="yes" xml:space="preserve">
          <source>The choice between GiST and GIN indexing depends on the relative performance characteristics of GiST and GIN, which are discussed elsewhere.</source>
          <target state="translated">Выбор между GiST и GIN индексацией зависит от относительных эксплуатационных характеристик GiST и GIN,которые рассматриваются в других разделах.</target>
        </trans-unit>
        <trans-unit id="3567ccb40f1481d219e5951c92fe9f650cc7303e" translate="yes" xml:space="preserve">
          <source>The choice between these formats is up to the user. The first format is a proper XML document, which will be important in many applications. The second format tends to be more useful in the &lt;code&gt;cursor_to_xml&lt;/code&gt; function if the result values are to be reassembled into one document later on. The functions for producing XML content discussed above, in particular &lt;code&gt;xmlelement&lt;/code&gt;, can be used to alter the results to taste.</source>
          <target state="translated">Выбор между этими форматами остается за пользователем. Первый формат - это правильный XML-документ, который будет важен для многих приложений. Второй формат имеет тенденцию быть более полезным в функции &lt;code&gt;cursor_to_xml&lt;/code&gt; , если результирующие значения должны быть повторно собраны в один документ позже. Функции для создания XML-контента, описанные выше, в частности &lt;code&gt;xmlelement&lt;/code&gt; , можно использовать для изменения результатов по вкусу.</target>
        </trans-unit>
        <trans-unit id="2fcd6e12232fcafb17e4f9eed475f29ab9c942d0" translate="yes" xml:space="preserve">
          <source>The choice of how to partition a table should be made carefully as the performance of query planning and execution can be negatively affected by poor design.</source>
          <target state="translated">Выбор способа разбиения таблицы должен быть сделан тщательно,так как на производительность планирования и выполнения запросов может негативно повлиять плохая конструкция.</target>
        </trans-unit>
        <trans-unit id="eba68582494f00f7d7461ffee77aebc9a862ba45" translate="yes" xml:space="preserve">
          <source>The clause &lt;code&gt;CACHE cache&lt;/code&gt; enables sequence numbers to be preallocated and stored in memory for faster access. The minimum value is 1 (only one value can be generated at a time, i.e., no cache). If unspecified, the old cache value will be maintained.</source>
          <target state="translated">Предложение &lt;code&gt;CACHE cache&lt;/code&gt; позволяет предварительно выделить и сохранить порядковые номера в памяти для более быстрого доступа. Минимальное значение - 1 (единовременно может быть сгенерировано только одно значение, т. Е. Без кеша). Если не указано иное, будет сохранено старое значение кеша.</target>
        </trans-unit>
        <trans-unit id="75a69760c05706a624428c520aa62a2819be2cc8" translate="yes" xml:space="preserve">
          <source>The clause &lt;code&gt;INCREMENT BY increment&lt;/code&gt; is optional. A positive value will make an ascending sequence, a negative one a descending sequence. If unspecified, the old increment value will be maintained.</source>
          <target state="translated">Предложение &lt;code&gt;INCREMENT BY increment&lt;/code&gt; является необязательным. Положительное значение образует восходящую последовательность, отрицательное - убывающую. Если не указано иное, будет сохранено старое значение приращения.</target>
        </trans-unit>
        <trans-unit id="1e885032e33c3c5f3562475ecafb5ece897bbab7" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;ALWAYS&lt;/code&gt; and &lt;code&gt;BY DEFAULT&lt;/code&gt; determine how explicitly user-specified values are handled in &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867e5349b79e57e50c69654c14c2d9c684ca93bc" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;ALWAYS&lt;/code&gt; and &lt;code&gt;BY DEFAULT&lt;/code&gt; determine how the sequence value is given precedence over a user-specified value in an &lt;code&gt;INSERT&lt;/code&gt; statement. If &lt;code&gt;ALWAYS&lt;/code&gt; is specified, a user-specified value is only accepted if the &lt;code&gt;INSERT&lt;/code&gt; statement specifies &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt;. If &lt;code&gt;BY DEFAULT&lt;/code&gt; is specified, then the user-specified value takes precedence. See &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; for details. (In the &lt;code&gt;COPY&lt;/code&gt; command, user-specified values are always used regardless of this setting.)</source>
          <target state="translated">Предложения &lt;code&gt;ALWAYS&lt;/code&gt; и &lt;code&gt;BY DEFAULT&lt;/code&gt; определяют, как значение последовательности имеет приоритет над значением, указанным пользователем в операторе &lt;code&gt;INSERT&lt;/code&gt; . Если указано &lt;code&gt;ALWAYS&lt;/code&gt; , то указанное пользователем значение принимается только в том случае, если оператор &lt;code&gt;INSERT&lt;/code&gt; указывает &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; . Если указано &lt;code&gt;BY DEFAULT&lt;/code&gt; , то значение, указанное пользователем, имеет приоритет. Подробнее см. &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; . (В команде &lt;code&gt;COPY&lt;/code&gt; всегда используются значения, указанные пользователем, независимо от этого параметра.)</target>
        </trans-unit>
        <trans-unit id="234bcc40e3c1c6669b66cf6ee7882220428cd61f" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; are PostgreSQL-specific syntax, also used by MySQL. The SQL:2008 standard has introduced the clauses &lt;code&gt;OFFSET ... FETCH {FIRST|NEXT} ...&lt;/code&gt; for the same functionality, as shown above in &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;. This syntax is also used by IBM DB2. (Applications written for Oracle frequently use a workaround involving the automatically generated &lt;code&gt;rownum&lt;/code&gt; column, which is not available in PostgreSQL, to implement the effects of these clauses.)</source>
          <target state="translated">Предложения &lt;code&gt;LIMIT&lt;/code&gt; и &lt;code&gt;OFFSET&lt;/code&gt; представляют собой синтаксис, специфичный для PostgreSQL, также используемый MySQL. SQL: стандарт 2008 уже введены положения &lt;code&gt;OFFSET ... FETCH {FIRST|NEXT} ...&lt;/code&gt; для той же функциональностью, как показано выше в &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; пункта&lt;/a&gt; . Этот синтаксис также используется IBM DB2. (Приложения, написанные для Oracle, часто используют обходной путь, включающий автоматически сгенерированный столбец &lt;code&gt;rownum&lt;/code&gt; , который недоступен в PostgreSQL, для реализации эффектов этих предложений.)</target>
        </trans-unit>
        <trans-unit id="4ef779e24cd70dc78d1e7371780e8d692d8fd135" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; are PostgreSQL-specific syntax, also used by MySQL. The SQL:2008 standard has introduced the clauses &lt;code&gt;OFFSET ... FETCH {FIRST|NEXT} ...&lt;/code&gt; for the same functionality, as shown above in &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt;. This syntax is also used by IBM DB2. (Applications written for Oracle frequently use a workaround involving the automatically generated &lt;code&gt;rownum&lt;/code&gt; column, which is not available in PostgreSQL, to implement the effects of these clauses.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54380a0f1c98e1a0a687fefef82dc949bcffc323" translate="yes" xml:space="preserve">
          <source>The client must be allowed to access all referenced tables and columns, even if they originated from views which were then expanded, so that we apply consistent access control rules independent of the manner in which the table contents are referenced.</source>
          <target state="translated">Клиенту должен быть разрешен доступ ко всем ссылающимся таблицам и столбцам,даже если они происходят из представлений,которые затем были расширены,так что мы применяем последовательные правила контроля доступа независимо от способа,которым содержимое таблицы ссылается.</target>
        </trans-unit>
        <trans-unit id="05fdc0ebe765756a24f5709f3f5f878e85b6fb9a" translate="yes" xml:space="preserve">
          <source>The client process can be any program that understands the PostgreSQL protocol described in &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;Chapter 52&lt;/a&gt;. Many clients are based on the C-language library libpq, but several independent implementations of the protocol exist, such as the Java JDBC driver.</source>
          <target state="translated">Клиентский процесс может быть любой программой, которая понимает протокол PostgreSQL, описанный в &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;главе 52&lt;/a&gt; . Многие клиенты основаны на библиотеке языка C libpq, но существует несколько независимых реализаций протокола, например драйвер Java JDBC.</target>
        </trans-unit>
        <trans-unit id="973ecfa139cd389fe92d63aca6613fcea6c732f4" translate="yes" xml:space="preserve">
          <source>The client process can be any program that understands the PostgreSQL protocol described in &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol.html&quot;&gt;Chapter 52&lt;/a&gt;. Many clients are based on the C-language library libpq, but several independent implementations of the protocol exist, such as the Java JDBC driver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c663b89bef91d752e19ecca16e81b132b43904" translate="yes" xml:space="preserve">
          <source>The client responds by sending a SASLInitialResponse message, which indicates the chosen mechanism, &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; or &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt;. (A client is free to choose either mechanism, but for better security it should choose the channel-binding variant if it can support it.) In the Initial Client response field, the message contains the SCRAM &lt;code&gt;client-first-message&lt;/code&gt;. The &lt;code&gt;client-first-message&lt;/code&gt; also contains the channel binding type chosen by the client.</source>
          <target state="translated">Клиент отвечает, отправляя сообщение SASLInitialResponse, в котором указывается выбранный механизм, &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; или &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; . (Клиент может выбрать любой из этих механизмов, но для большей безопасности он должен выбрать вариант привязки канала, если он может его поддерживать.) В поле &amp;laquo;Первоначальный ответ клиента&amp;raquo; сообщение содержит SCRAM &lt;code&gt;client-first-message&lt;/code&gt; . Сообщение &lt;code&gt;client-first-message&lt;/code&gt; также содержит тип привязки канала, выбранный клиентом.</target>
        </trans-unit>
        <trans-unit id="28e4175f56ce1936736eeadfb881155016ea4fed" translate="yes" xml:space="preserve">
          <source>The client selects one of the supported mechanisms from the list, and sends a SASLInitialResponse message to the server. The message includes the name of the selected mechanism, and an optional Initial Client Response, if the selected mechanism uses that.</source>
          <target state="translated">Клиент выбирает один из поддерживаемых механизмов из списка и отправляет сообщение SASLInitialResponse на сервер.Сообщение включает имя выбранного механизма,а также необязательный начальный ответ клиента,если выбранный механизм его использует.</target>
        </trans-unit>
        <trans-unit id="229cec88eb4f3eac7279336f40b13a71ae9b84dd" translate="yes" xml:space="preserve">
          <source>The client sends an Execute message with a non-zero fetch count. See the discussion of the &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;extended query protocol&lt;/a&gt;. Since &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq.html&quot;&gt;libpq&lt;/a&gt; currently provides no way to send such a message, this can only occur when using a client that does not rely on libpq. If this is a frequent occurrence, it may be a good idea to set &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt; to zero in sessions where it is likely, so as to avoid generating query plans that may be suboptimal when run serially.</source>
          <target state="translated">Клиент отправляет сообщение Execute с ненулевым счетчиком выборки. См. Обсуждение &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;протокола расширенных запросов&lt;/a&gt; . Поскольку &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq.html&quot;&gt;libpq в&lt;/a&gt; настоящее время не предоставляет возможности отправить такое сообщение, это может произойти только при использовании клиента, который не полагается на libpq. Если это частое явление, может быть хорошей идеей установить &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt; равным нулю в сеансах, где это вероятно, чтобы избежать генерации планов запросов, которые могут быть неоптимальными при последовательном запуске.</target>
        </trans-unit>
        <trans-unit id="b4c35b44809114c2fabb0bca78243a5e0e3a582e" translate="yes" xml:space="preserve">
          <source>The client sends an Execute message with a non-zero fetch count. See the discussion of the &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;extended query protocol&lt;/a&gt;. Since &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq.html&quot;&gt;libpq&lt;/a&gt; currently provides no way to send such a message, this can only occur when using a client that does not rely on libpq. If this is a frequent occurrence, it may be a good idea to set &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt; to zero in sessions where it is likely, so as to avoid generating query plans that may be suboptimal when run serially.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8bc9da59ada6925c6ca4e1408b3caa10a534cd" translate="yes" xml:space="preserve">
          <source>The code block is treated as though it were the body of a function with no parameters, returning &lt;code&gt;void&lt;/code&gt;. It is parsed and executed a single time.</source>
          <target state="translated">Блок кода рассматривается, как если бы он был телом функции без параметров, возвращающей &lt;code&gt;void&lt;/code&gt; . Он анализируется и выполняется один раз.</target>
        </trans-unit>
        <trans-unit id="312278044badf1f81c35c2b663c752edaa662f24" translate="yes" xml:space="preserve">
          <source>The collation assigned to a function or operator's combined input expressions is also considered to apply to the function or operator's result, if the function or operator delivers a result of a collatable data type. So, in</source>
          <target state="translated">Сопоставление,присваиваемое функции или комбинированным выражениям оператора на входе,также считается применимым к функции или результату оператора,если функция или оператор выдают результат,который может быть сопоставлен с типом данных.Итак,в</target>
        </trans-unit>
        <trans-unit id="07ad042e8eb9598587dcbb36503b3ffb45fa7270" translate="yes" xml:space="preserve">
          <source>The collation feature allows specifying the sort order and character classification behavior of data per-column, or even per-operation. This alleviates the restriction that the &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; settings of a database cannot be changed after its creation.</source>
          <target state="translated">Функция сопоставления позволяет указать порядок сортировки и поведение классификации символов данных для каждого столбца или даже для каждой операции. Это &lt;code&gt;LC_COLLATE&lt;/code&gt; ограничение, согласно которому параметры LC_COLLATE и &lt;code&gt;LC_CTYPE&lt;/code&gt; базы данных не могут быть изменены после ее создания.</target>
        </trans-unit>
        <trans-unit id="6968224c63a84f2b924666a708e6eefcbe1a5fe3" translate="yes" xml:space="preserve">
          <source>The collation of an expression can be the &amp;ldquo;default&amp;rdquo; collation, which means the locale settings defined for the database. It is also possible for an expression's collation to be indeterminate. In such cases, ordering operations and other operations that need to know the collation will fail.</source>
          <target state="translated">Сопоставление выражения может быть сопоставлением &amp;laquo;по умолчанию&amp;raquo;, что означает параметры локали, определенные для базы данных. Кроме того, сопоставление выражения может быть неопределенным. В таких случаях операции упорядочивания и другие операции, которым необходимо знать сопоставление, завершатся ошибкой.</target>
        </trans-unit>
        <trans-unit id="8cbb0497a2d0489a87ba349c1f09ee8dec4f3fd5" translate="yes" xml:space="preserve">
          <source>The collation used to derive the statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;. For example, a histogram slot for a collatable column would show the collation that defines the sort order of the data. Zero for noncollatable data.</source>
          <target state="translated">Сопоставление, используемое для получения статистики, хранящейся в &lt;code&gt;N&lt;/code&gt; - м &amp;laquo;слоте&amp;raquo;. Например, слот гистограммы для сопоставимого столбца будет показывать сопоставление, которое определяет порядок сортировки данных. Ноль для неразборчивых данных.</target>
        </trans-unit>
        <trans-unit id="b4385bb7e15544b6f2f8d39c7296d888e4a8a5d9" translate="yes" xml:space="preserve">
          <source>The colon (&lt;code&gt;:&lt;/code&gt;) is used to select &amp;ldquo;slices&amp;rdquo; from arrays. (See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt;.) In certain SQL dialects (such as Embedded SQL), the colon is used to prefix variable names.</source>
          <target state="translated">Двоеточие ( &lt;code&gt;:&lt;/code&gt; ) используется для выбора &amp;laquo;срезов&amp;raquo; из массивов. (См. &lt;a href=&quot;arrays&quot;&gt;Раздел 8.15&lt;/a&gt; .) В некоторых диалектах SQL (например, Embedded SQL) двоеточие используется для префикса имен переменных.</target>
        </trans-unit>
        <trans-unit id="b41c26c54c1ac62b21f77b8fd62d5d3012b96e24" translate="yes" xml:space="preserve">
          <source>The colon syntax for variables is standard SQL for embedded query languages, such as ECPG. The colon syntaxes for array slices and type casts are PostgreSQL extensions, which can sometimes conflict with the standard usage. The colon-quote syntax for escaping a variable's value as an SQL literal or identifier is a psql extension.</source>
          <target state="translated">Синтаксис двоеточия для переменных-это стандартный SQL для встроенных языков запросов,таких как ECPG.Синтаксис двоеточия для фрагментов массива и каста типов-это расширения PostgreSQL,которые иногда могут вступать в конфликт со стандартным использованием.Синтаксис двоеточия для экранирования значения переменной в виде SQL-литерала или идентификатора является psql расширением.</target>
        </trans-unit>
        <trans-unit id="d094304df5c5c2f3f002a3a5f2b5b0282e855c32" translate="yes" xml:space="preserve">
          <source>The column data type that this operator class is for.</source>
          <target state="translated">Тип данных столбца,для которого предназначен данный класс оператора.</target>
        </trans-unit>
        <trans-unit id="5a6fb4ccabc2a7663f993c4ebb4c744ff2affbac" translate="yes" xml:space="preserve">
          <source>The column default value, in &lt;code&gt;nodeToString()&lt;/code&gt; representation. Use &lt;code&gt;pg_get_expr(adbin, adrelid)&lt;/code&gt; to convert it to an SQL expression.</source>
          <target state="translated">Значение столбца по умолчанию в представлении &lt;code&gt;nodeToString()&lt;/code&gt; . Используйте &lt;code&gt;pg_get_expr(adbin, adrelid)&lt;/code&gt; чтобы преобразовать его в выражение SQL.</target>
        </trans-unit>
        <trans-unit id="08368fd428556014aaea42a5338ea6c2743ad445" translate="yes" xml:space="preserve">
          <source>The column is allowed to contain null values. This is the default.</source>
          <target state="translated">В колонке разрешается указывать нулевые значения.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="5bb55967abb94c1ccc24a2441d33dbf806399e61" translate="yes" xml:space="preserve">
          <source>The column is not allowed to contain null values.</source>
          <target state="translated">Нулевые значения в столбце не допускаются.</target>
        </trans-unit>
        <trans-unit id="8420d2c88df44919ff7832e5423eccf9e0e7b65d" translate="yes" xml:space="preserve">
          <source>The column name</source>
          <target state="translated">Название столбца</target>
        </trans-unit>
        <trans-unit id="d9ec3849dbdc73ff83e6e2b53f90a20a6fb0948f" translate="yes" xml:space="preserve">
          <source>The column source table(s) must be &lt;code&gt;INNER&lt;/code&gt; or &lt;code&gt;LEFT&lt;/code&gt; joined to the &lt;code&gt;LATERAL&lt;/code&gt; item, else there would not be a well-defined set of rows from which to compute each set of rows for the &lt;code&gt;LATERAL&lt;/code&gt; item. Thus, although a construct such as &lt;code&gt;X RIGHT JOIN LATERAL Y&lt;/code&gt; is syntactically valid, it is not actually allowed for &lt;code&gt;Y&lt;/code&gt; to reference &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">Исходные таблицы столбцов должны быть &lt;code&gt;INNER&lt;/code&gt; или &lt;code&gt;LEFT&lt;/code&gt; присоединенными к &lt;code&gt;LATERAL&lt;/code&gt; элементу, иначе не будет четко определенного набора строк, из которого будет вычисляться каждый набор строк для &lt;code&gt;LATERAL&lt;/code&gt; элемента. Таким образом, хотя конструкция , такие как &lt;code&gt;X RIGHT JOIN LATERAL Y&lt;/code&gt; синтаксический действителен, то на самом деле не допускается &lt;code&gt;Y&lt;/code&gt; эталонного &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e991f9b83115d7ba9de797ba7c6fd7f9b86d5e91" translate="yes" xml:space="preserve">
          <source>The columns names &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; are either the actual names of the columns of tables referenced in the &lt;code&gt;FROM&lt;/code&gt; clause, or the aliases given to them as explained in &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;Section 7.2.1.2&lt;/a&gt;. The name space available in the select list is the same as in the &lt;code&gt;WHERE&lt;/code&gt; clause, unless grouping is used, in which case it is the same as in the &lt;code&gt;HAVING&lt;/code&gt; clause.</source>
          <target state="translated">Имена столбцов &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; являются либо фактическими именами столбцов таблиц, упомянутых в предложении &lt;code&gt;FROM&lt;/code&gt; , либо псевдонимами, присвоенными им, как описано в &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;Разделе 7.2.1.2&lt;/a&gt; . Пространство имен, доступное в списке выбора, такое же, как и в &lt;code&gt;WHERE&lt;/code&gt; , если не используется группировка, и в этом случае оно такое же, как в предложении &lt;code&gt;HAVING&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4599d6eec1312706887ef09d2464d5545c627474" translate="yes" xml:space="preserve">
          <source>The combination of the return value of this function with the certificate serial number uniquely identifies the certificate.</source>
          <target state="translated">Сочетание возвращаемого значения этой функции с серийным номером сертификата однозначно идентифицирует сертификат.</target>
        </trans-unit>
        <trans-unit id="062e4ea98a9662fe6dca5fb34a40a037aa606eb5" translate="yes" xml:space="preserve">
          <source>The command</source>
          <target state="translated">Команда</target>
        </trans-unit>
        <trans-unit id="fd4ecf316bcb95382c9ca99fb6834b4e0a4db40c" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; can also be used to create a new collation from an existing collation, which can be useful to be able to use operating-system-independent collation names in applications, create compatibility names, or use an ICU-provided collation under a more readable name. For example:</source>
          <target state="translated">Команда &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; также может использоваться для создания нового сопоставления из существующего сопоставления, что может быть полезно для использования в приложениях имен сопоставления, не зависящих от операционной системы, создания имен совместимости или использования сопоставления, предоставленного ICU, под более читабельное имя. Например:</target>
        </trans-unit>
        <trans-unit id="d977c35dcae77bd0de806a55a77621ba14612b62" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;ALTER PUBLICATION&lt;/code&gt; can change the attributes of a publication.</source>
          <target state="translated">Команда &lt;code&gt;ALTER PUBLICATION&lt;/code&gt; может изменять атрибуты публикации.</target>
        </trans-unit>
        <trans-unit id="969778663757608a9ceb272b57ae37cfa06e3dd9" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;COMMIT&lt;/code&gt; conforms to the SQL standard. The form &lt;code&gt;COMMIT TRANSACTION&lt;/code&gt; is a PostgreSQL extension.</source>
          <target state="translated">Команда &lt;code&gt;COMMIT&lt;/code&gt; соответствует стандарту SQL. Форма &lt;code&gt;COMMIT TRANSACTION&lt;/code&gt; - это расширение PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="dbf0fa331f942a39e4739f4ed15c74b619e12d1b" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;CREATE DOMAIN&lt;/code&gt; conforms to the SQL standard.</source>
          <target state="translated">Команда &lt;code&gt;CREATE DOMAIN&lt;/code&gt; соответствует стандарту SQL.</target>
        </trans-unit>
        <trans-unit id="c0e7572b18c65a9a6261e55f6991fd2f67f9ff3c" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;LOCK TABLE a, b;&lt;/code&gt; is equivalent to &lt;code&gt;LOCK TABLE a; LOCK TABLE b;&lt;/code&gt;. The tables are locked one-by-one in the order specified in the &lt;code&gt;LOCK TABLE&lt;/code&gt; command.</source>
          <target state="translated">Команда &lt;code&gt;LOCK TABLE a, b;&lt;/code&gt; эквивалентно &lt;code&gt;LOCK TABLE a; LOCK TABLE b;&lt;/code&gt; . Таблицы блокируются одна за другой в порядке, указанном в команде &lt;code&gt;LOCK TABLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd29caedfd38b09e6ed21c78963ca39d6d0fdf15" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;ROLLBACK&lt;/code&gt; conforms to the SQL standard. The form &lt;code&gt;ROLLBACK TRANSACTION&lt;/code&gt; is a PostgreSQL extension.</source>
          <target state="translated">Команда &lt;code&gt;ROLLBACK&lt;/code&gt; соответствует стандарту SQL. Форма &lt;code&gt;ROLLBACK TRANSACTION&lt;/code&gt; - это расширение PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="14f45c2838c91f3d088f1dbeb531759099cc9619" translate="yes" xml:space="preserve">
          <source>The command does not actually have to prompt the user for a passphrase. It can read it from a file, obtain it from a keychain facility, or similar. It is up to the user to make sure the chosen mechanism is adequately secure.</source>
          <target state="translated">Команда на самом деле не должна запрашивать у пользователя ключевую фразу.Она может прочитать ее из файла,получить ее из связки ключей или что-то подобное.Пользователь должен убедиться,что выбранный механизм достаточно безопасен.</target>
        </trans-unit>
        <trans-unit id="125f23e3bb7186ab7a646a52cf5bf9eca19bcc45" translate="yes" xml:space="preserve">
          <source>The command form &lt;code&gt;\d+&lt;/code&gt; is identical, except that more information is displayed: any comments associated with the columns of the table are shown, as is the presence of OIDs in the table, the view definition if the relation is a view, a non-default &lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;replica identity&lt;/a&gt; setting.</source>
          <target state="translated">Форма команды &lt;code&gt;\d+&lt;/code&gt; идентична, за исключением того, что отображается дополнительная информация: отображаются любые комментарии, связанные со столбцами таблицы, а также наличие OID в таблице, определение представления, если отношение является представлением, не- настройка &lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;идентификации реплики по&lt;/a&gt; умолчанию .</target>
        </trans-unit>
        <trans-unit id="0916bd8daa5b51f8834876be91b7f972c2fe0c9c" translate="yes" xml:space="preserve">
          <source>The command identifier (starting at zero) within the inserting transaction.</source>
          <target state="translated">Идентификатор команды (начинающийся с нуля)внутри вставляемой транзакции.</target>
        </trans-unit>
        <trans-unit id="d1364d07c5f1725771640b150e94c42c6a8b2515" translate="yes" xml:space="preserve">
          <source>The command identifier within the deleting transaction, or zero.</source>
          <target state="translated">Идентификатор команды в транзакции удаления,или ноль.</target>
        </trans-unit>
        <trans-unit id="1437750e20fa527029f8f074bcd579b652d1fc5a" translate="yes" xml:space="preserve">
          <source>The command is computing extended statistics from the sample rows obtained during the table scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733186417b69bd6a5c32f04973634c419eb62936" translate="yes" xml:space="preserve">
          <source>The command is computing statistics from the sample rows obtained during the table scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0382226380f9ead190eb302a73c778dbdd6e8d" translate="yes" xml:space="preserve">
          <source>The command is currently rebuilding an index.</source>
          <target state="translated">В настоящее время команда восстанавливает индекс.</target>
        </trans-unit>
        <trans-unit id="08589d87d0f9a78f65af3716f713118502dde96d" translate="yes" xml:space="preserve">
          <source>The command is currently scanning child tables to obtain sample rows. Columns &lt;code&gt;child_tables_total&lt;/code&gt;, &lt;code&gt;child_tables_done&lt;/code&gt;, and &lt;code&gt;current_child_table_relid&lt;/code&gt; contain the progress information for this phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818a6c346e272bdd257338212ea062e5d982098f" translate="yes" xml:space="preserve">
          <source>The command is currently scanning the table given by &lt;code&gt;relid&lt;/code&gt; to obtain sample rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf18e6a22964c8d441f27d38a4a845cd36e9d7a8" translate="yes" xml:space="preserve">
          <source>The command is currently scanning the table using a sequential scan.</source>
          <target state="translated">В настоящее время команда сканирует таблицу с помощью последовательного сканирования.</target>
        </trans-unit>
        <trans-unit id="2d997222e2d809bc7ed01be5d82f30faa7501100" translate="yes" xml:space="preserve">
          <source>The command is currently swapping newly-built files into place.</source>
          <target state="translated">В настоящее время команда производит замену только что созданных файлов.</target>
        </trans-unit>
        <trans-unit id="d36048945358a61f078040109a39866ba3017fd5" translate="yes" xml:space="preserve">
          <source>The command is performing final cleanup. When this phase is completed, &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; will end.</source>
          <target state="translated">Команда выполняет окончательную очистку. Когда эта фаза завершена, &lt;code&gt;CLUSTER&lt;/code&gt; или &lt;code&gt;VACUUM FULL&lt;/code&gt; завершится.</target>
        </trans-unit>
        <trans-unit id="b779f0c2e033575cc8fc0dc14c755c01561f9ff6" translate="yes" xml:space="preserve">
          <source>The command is preparing to begin scanning the heap. This phase is expected to be very brief.</source>
          <target state="translated">Команда готовится начать сканирование кучи.Ожидается,что этот этап будет очень коротким.</target>
        </trans-unit>
        <trans-unit id="68b75bc58da613bc57b4a395ff1c9dc327e8f607" translate="yes" xml:space="preserve">
          <source>The command is updating &lt;code&gt;pg_class&lt;/code&gt;. When this phase is completed, &lt;code&gt;ANALYZE&lt;/code&gt; will end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00faacb1d010fe63608a96c43ef3a7084a48b136" translate="yes" xml:space="preserve">
          <source>The command must print the passphrase to the standard output and exit with code 0. In the parameter value, &lt;code&gt;%p&lt;/code&gt; is replaced by a prompt string. (Write &lt;code&gt;%%&lt;/code&gt; for a literal &lt;code&gt;%&lt;/code&gt;.) Note that the prompt string will probably contain whitespace, so be sure to quote adequately. A single newline is stripped from the end of the output if present.</source>
          <target state="translated">Команда должна вывести парольную фразу на стандартный вывод и выйти с кодом 0. В значении параметра &lt;code&gt;%p&lt;/code&gt; заменяется строкой приглашения. (Напишите &lt;code&gt;%%&lt;/code&gt; для буквального символа &lt;code&gt;%&lt;/code&gt; .) Обратите внимание, что строка приглашения, вероятно, будет содержать пробелы, поэтому убедитесь, что вы используете соответствующие кавычки. Одиночный символ новой строки удаляется из конца вывода, если он присутствует.</target>
        </trans-unit>
        <trans-unit id="c98b53eebf8fcd4fa5340e65c4d477e99fd91e81" translate="yes" xml:space="preserve">
          <source>The command or commands that make up the rule action. Valid commands are &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;NOTIFY&lt;/code&gt;.</source>
          <target state="translated">Команда или команды, составляющие действие правила. Допустимые команды: &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; или &lt;code&gt;NOTIFY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f5e5a53841d0cfd1aacf0accff8cefa2f5212ac" translate="yes" xml:space="preserve">
          <source>The command tag returned by &lt;code&gt;EXECUTE&lt;/code&gt; is that of the prepared statement, and not &lt;code&gt;EXECUTE&lt;/code&gt;.</source>
          <target state="translated">Тег команды, возвращаемый &lt;code&gt;EXECUTE&lt;/code&gt; , является тегом подготовленного оператора, а не &lt;code&gt;EXECUTE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74ac6ad09ab58057a9fed1f64a26a788f3d3e326" translate="yes" xml:space="preserve">
          <source>The command that is running. Either &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;.</source>
          <target state="translated">Команда, которая выполняется. Либо &lt;code&gt;CLUSTER&lt;/code&gt; либо &lt;code&gt;VACUUM FULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9850fa889a0eec791cad23100b9e331cd2aa4fc" translate="yes" xml:space="preserve">
          <source>The command that is running: &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, or &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; &lt;code&gt;REINDEX&lt;/code&gt; : &lt;code&gt;CREATE INDEX&lt;/code&gt; , CREATE INDEX CONCURRENTLY , REINDEX или &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="559d421f3432d35c3d9a8fb5131571d6eb8752e8" translate="yes" xml:space="preserve">
          <source>The command to which the policy applies. Valid options are &lt;code&gt;ALL&lt;/code&gt;, &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. &lt;code&gt;ALL&lt;/code&gt; is the default. See below for specifics regarding how these are applied.</source>
          <target state="translated">Команда, к которой применяется политика. Допустимые варианты: &lt;code&gt;ALL&lt;/code&gt; , &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; . &lt;code&gt;ALL&lt;/code&gt; по умолчанию. См. Ниже подробные сведения о том, как они применяются.</target>
        </trans-unit>
        <trans-unit id="7852202b8a6003f108d83f18dfb4650d44b65813" translate="yes" xml:space="preserve">
          <source>The command type to which the policy is applied</source>
          <target state="translated">Тип команды,к которой применяется политика</target>
        </trans-unit>
        <trans-unit id="6c49af8969ccfcd1693376760717e08595698aa9" translate="yes" xml:space="preserve">
          <source>The command type to which the policy is applied: &lt;code&gt;r&lt;/code&gt; for &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; for &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt; for &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt; for &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;*&lt;/code&gt; for all</source>
          <target state="translated">Тип команды, к которой применяется политика: &lt;code&gt;r&lt;/code&gt; для &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; для &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; для &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; для &lt;code&gt;DELETE&lt;/code&gt; или &lt;code&gt;*&lt;/code&gt; для всех</target>
        </trans-unit>
        <trans-unit id="31a55b9a99200f37a1fc91d5f4fc188806cc57ad" translate="yes" xml:space="preserve">
          <source>The command's result is a textual description of the plan selected for the &lt;code&gt;statement&lt;/code&gt;, optionally annotated with execution statistics. &lt;a href=&quot;using-explain&quot;&gt;Section 14.1&lt;/a&gt; describes the information provided.</source>
          <target state="translated">Результатом выполнения команды является текстовое описание плана, выбранного для &lt;code&gt;statement&lt;/code&gt; , которое может быть дополнено статистикой выполнения. &lt;a href=&quot;using-explain&quot;&gt;Раздел 14.1&lt;/a&gt; описывает предоставленную информацию.</target>
        </trans-unit>
        <trans-unit id="40e0a2632f98d43624e2ba898ef7cc5bdd1cf8c1" translate="yes" xml:space="preserve">
          <source>The command-line history is stored in the file &lt;code&gt;~/.psql_history&lt;/code&gt;, or &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; on Windows.</source>
          <target state="translated">История командной строки хранится в файле &lt;code&gt;~/.psql_history&lt;/code&gt; или &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; в Windows.</target>
        </trans-unit>
        <trans-unit id="f9e42c3efb15d8e677dc2308149404249d782207" translate="yes" xml:space="preserve">
          <source>The command-line-style arguments specified in &lt;code&gt;extra-options&lt;/code&gt; are passed to all server processes started by this &lt;code&gt;postgres&lt;/code&gt; process.</source>
          <target state="translated">Аргументы в стиле командной строки, указанные в &lt;code&gt;extra-options&lt;/code&gt; , передаются всем серверным процессам, запущенным этим процессом &lt;code&gt;postgres&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="360d0f8394d720d22156d27a3f3ab0d50f8729e3" translate="yes" xml:space="preserve">
          <source>The commands &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;INSERT&lt;/code&gt; acquire this lock mode on the target table (in addition to &lt;code&gt;ACCESS SHARE&lt;/code&gt; locks on any other referenced tables). In general, this lock mode will be acquired by any command that &lt;em&gt;modifies data&lt;/em&gt; in a table.</source>
          <target state="translated">Команды &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; и &lt;code&gt;INSERT&lt;/code&gt; устанавливают этот режим блокировки для целевой таблицы (в дополнение к блокировкам &lt;code&gt;ACCESS SHARE&lt;/code&gt; для любых других ссылочных таблиц). Как правило, этот режим блокировки применяется любой командой, &lt;em&gt;изменяющей данные&lt;/em&gt; в таблице.</target>
        </trans-unit>
        <trans-unit id="b120614b8a1edecdcf4c676c85b59acab98338cc" translate="yes" xml:space="preserve">
          <source>The commutator of this operator.</source>
          <target state="translated">Коммутатор этого оператора.</target>
        </trans-unit>
        <trans-unit id="f6803da73417ed20d6aa993c5529f00237b3f6a3" translate="yes" xml:space="preserve">
          <source>The compatibility notes of the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command apply analogously to &lt;code&gt;REVOKE&lt;/code&gt;. The keyword &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; is required according to the standard, but PostgreSQL assumes &lt;code&gt;RESTRICT&lt;/code&gt; by default.</source>
          <target state="translated">Примечания по совместимости команды &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; аналогично &lt;code&gt;REVOKE&lt;/code&gt; . Ключевое слово &lt;code&gt;RESTRICT&lt;/code&gt; или &lt;code&gt;CASCADE&lt;/code&gt; требуется в соответствии со стандартом, но PostgreSQL по умолчанию предполагает &lt;code&gt;RESTRICT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40702de9ee6c2366268d72254909613dec0511c4" translate="yes" xml:space="preserve">
          <source>The complete lack of these facilities is usually manifested by an &amp;ldquo;Illegal system call&amp;rdquo; error upon server start. In that case there is no alternative but to reconfigure your kernel. PostgreSQL won't work without them. This situation is rare, however, among modern operating systems.</source>
          <target state="translated">Полное отсутствие этих возможностей обычно проявляется ошибкой &amp;laquo;Недопустимый системный вызов&amp;raquo; при запуске сервера. В этом случае нет другого выхода, кроме как перенастроить ядро. PostgreSQL без них работать не будет. Однако среди современных операционных систем такая ситуация встречается редко.</target>
        </trans-unit>
        <trans-unit id="8728921721ecf34d843d2d7d08bdc9c0ecc2f84b" translate="yes" xml:space="preserve">
          <source>The composite output routine will put double quotes around field values if they are empty strings or contain parentheses, commas, double quotes, backslashes, or white space. (Doing so for white space is not essential, but aids legibility.) Double quotes and backslashes embedded in field values will be doubled.</source>
          <target state="translated">Комбинированная процедура вывода будет заключать двойные кавычки вокруг значений полей,если они являются пустыми строками или содержат круглые скобки,запятые,двойные кавычки,обратные слеши или пробелы.(Делать это для пробела не обязательно,но помогает разборчивость.)Двойные кавычки и обратные слеши,вложенные в значения полей,будут удвоены.</target>
        </trans-unit>
        <trans-unit id="7b5e42f8ee02c00c89066a781bb2783e80203625" translate="yes" xml:space="preserve">
          <source>The compression technique used for either in-line or out-of-line compressed data is a fairly simple and very fast member of the LZ family of compression techniques. See &lt;code&gt;src/common/pg_lzcompress.c&lt;/code&gt; for the details.</source>
          <target state="translated">Техника сжатия, используемая как для линейных, так и для внешних сжатых данных, является довольно простым и очень быстрым членом семейства методов сжатия LZ. См. Подробности в &lt;code&gt;src/common/pg_lzcompress.c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74936e59660e5e1e74d04f83302b0b914fcee784" translate="yes" xml:space="preserve">
          <source>The concatenation operator allows a single element to be pushed onto the beginning or end of a one-dimensional array. It also accepts two &lt;code&gt;N&lt;/code&gt;-dimensional arrays, or an &lt;code&gt;N&lt;/code&gt;-dimensional and an &lt;code&gt;N+1&lt;/code&gt;-dimensional array.</source>
          <target state="translated">Оператор конкатенации позволяет поместить отдельный элемент в начало или конец одномерного массива. Он также принимает два &lt;code&gt;N&lt;/code&gt; -мерных массива или &lt;code&gt;N&lt;/code&gt; - мерный и &lt;code&gt;N+1&lt;/code&gt; - мерный массив.</target>
        </trans-unit>
        <trans-unit id="4e300a4f5e6f2c02a48d5242548de8a6b349eea4" translate="yes" xml:space="preserve">
          <source>The concept that multiple independent operations happen within the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; at the same time. In PostgreSQL, concurrency is controlled by the &lt;a href=&quot;glossary#GLOSSARY-MVCC&quot;&gt;multiversion concurrency control&lt;/a&gt; mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5239ff4b58c91e7e13723e3163e22ecae35f6c6f" translate="yes" xml:space="preserve">
          <source>The condition &lt;code&gt;t1.hundred &amp;lt; t2.hundred&lt;/code&gt; can't be tested in the &lt;code&gt;tenk2_unique2&lt;/code&gt; index, so it's applied at the join node. This reduces the estimated output row count of the join node, but does not change either input scan.</source>
          <target state="translated">Условие &lt;code&gt;t1.hundred &amp;lt; t2.hundred&lt;/code&gt; не может быть проверено в индексе &lt;code&gt;tenk2_unique2&lt;/code&gt; , поэтому оно применяется на узле соединения. Это уменьшает предполагаемое количество выходных строк узла соединения, но не меняет сканирование входных данных.</target>
        </trans-unit>
        <trans-unit id="c068c3abe0f845f75d348f1e71b7501c9e85d719" translate="yes" xml:space="preserve">
          <source>The configuration file is reread whenever the main server process receives a SIGHUP signal; this signal is most easily sent by running &lt;code&gt;pg_ctl reload&lt;/code&gt; from the command line or by calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;. The main server process also propagates this signal to all currently running server processes, so that existing sessions also adopt the new values (this will happen after they complete any currently-executing client command). Alternatively, you can send the signal to a single server process directly. Some parameters can only be set at server start; any changes to their entries in the configuration file will be ignored until the server is restarted. Invalid parameter settings in the configuration file are likewise ignored (but logged) during SIGHUP processing.</source>
          <target state="translated">Файл конфигурации перечитывается всякий раз, когда основной серверный процесс получает сигнал SIGHUP; этот сигнал легче всего отправить, запустив &lt;code&gt;pg_ctl reload&lt;/code&gt; из командной строки или вызвав SQL-функцию &lt;code&gt;pg_reload_conf()&lt;/code&gt; . Главный серверный процесс также передает этот сигнал всем запущенным в данный момент серверным процессам, так что существующие сеансы также принимают новые значения (это произойдет после того, как они завершат любую выполняющуюся в данный момент клиентскую команду). Кроме того, вы можете отправить сигнал напрямую одному серверному процессу. Некоторые параметры можно установить только при запуске сервера; любые изменения их записей в файле конфигурации будут игнорироваться до перезапуска сервера. Неверные значения параметров в файле конфигурации также игнорируются (но регистрируются) во время обработки SIGHUP.</target>
        </trans-unit>
        <trans-unit id="b9dccd142849bf4c5f5639f61a51dab8e56e5d09" translate="yes" xml:space="preserve">
          <source>The configuration variable &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; determines whether JIT compilation is enabled or disabled. If it is enabled, the configuration variables &lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;, and &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; determine whether JIT compilation is performed for a query, and how much effort is spent doing so.</source>
          <target state="translated">Переменная конфигурации &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; определяет, включена или отключена JIT-компиляция. Если он включен, переменные конфигурации &lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt; , &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt; и &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; определяют, выполняется ли JIT-компиляция для запроса и сколько усилий на это затрачивается.</target>
        </trans-unit>
        <trans-unit id="19797f9713f4025f6738d996f66f2f16f1bb3ee3" translate="yes" xml:space="preserve">
          <source>The connection must be to the same database used to create the slot.</source>
          <target state="translated">Соединение должно быть с той же самой базой данных,которая использовалась для создания слота.</target>
        </trans-unit>
        <trans-unit id="cbc80489eb4bf174c233f6bbbaa42452b7d3d86f" translate="yes" xml:space="preserve">
          <source>The connection string should specify the host name (or address) of the sending server, as well as the port number if it is not the same as the standby server's default. Also specify a user name corresponding to a suitably-privileged role on the sending server (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-AUTHENTICATION&quot;&gt;Section 26.2.5.1&lt;/a&gt;). A password needs to be provided too, if the sender demands password authentication. It can be provided in the &lt;code&gt;primary_conninfo&lt;/code&gt; string, or in a separate &lt;code&gt;~/.pgpass&lt;/code&gt; file on the standby server (use &lt;code&gt;replication&lt;/code&gt; as the database name). Do not specify a database name in the &lt;code&gt;primary_conninfo&lt;/code&gt; string.</source>
          <target state="translated">В строке подключения должно быть указано имя хоста (или адрес) отправляющего сервера, а также номер порта, если он не совпадает со значением по умолчанию для резервного сервера. Также укажите имя пользователя, соответствующее соответствующей привилегированной роли на отправляющем сервере (см. &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-AUTHENTICATION&quot;&gt;Раздел 26.2.5.1&lt;/a&gt; ). Также необходимо указать пароль, если отправитель требует аутентификации по паролю. Его можно &lt;code&gt;primary_conninfo&lt;/code&gt; строке primary_conninfo или в отдельном файле &lt;code&gt;~/.pgpass&lt;/code&gt; на резервном сервере (используйте &lt;code&gt;replication&lt;/code&gt; качестве имени базы данных). Не указывайте имя базы данных в строке &lt;code&gt;primary_conninfo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31fcb6829f600da0b565f01362ffaf255feb5d94" translate="yes" xml:space="preserve">
          <source>The connection string to the publisher. For details see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt;.</source>
          <target state="translated">Строка подключения к издателю. Подробности см. В &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Разделе 33.1.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3910ec7c4e89817bfb9d10225155392dd277cac9" translate="yes" xml:space="preserve">
          <source>The connection string to the publisher. For details see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164c7293cd6f4e265338f6fb352f7b98d06266a8" translate="yes" xml:space="preserve">
          <source>The constraint expression for a partial index.</source>
          <target state="translated">Сдерживающее выражение для частичного индекса.</target>
        </trans-unit>
        <trans-unit id="0a023003d324d129028d83c645a2d4429045b67a" translate="yes" xml:space="preserve">
          <source>The constraint will be checked immediately, so the table data must satisfy the constraint before it can be added.</source>
          <target state="translated">Ограничение будет проверено немедленно,поэтому данные таблицы должны удовлетворять ограничению,прежде чем их можно будет добавить.</target>
        </trans-unit>
        <trans-unit id="f753df8000fdee9203aa2be3a2862eb377d770ad" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;(a, b)&lt;/code&gt; is normally recognized in expressions as a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt;. Within the &lt;code&gt;GROUP BY&lt;/code&gt; clause, this does not apply at the top levels of expressions, and &lt;code&gt;(a, b)&lt;/code&gt; is parsed as a list of expressions as described above. If for some reason you &lt;em&gt;need&lt;/em&gt; a row constructor in a grouping expression, use &lt;code&gt;ROW(a, b)&lt;/code&gt;.</source>
          <target state="translated">Конструкция &lt;code&gt;(a, b)&lt;/code&gt; обычно распознается в выражениях как &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;конструктор строки&lt;/a&gt; . В предложении &lt;code&gt;GROUP BY&lt;/code&gt; это не применяется к верхним уровням выражений, и &lt;code&gt;(a, b)&lt;/code&gt; анализируется как список выражений, как описано выше. Если по какой-то причине вам &lt;em&gt;нужен&lt;/em&gt; конструктор строки в выражении группировки, используйте &lt;code&gt;ROW(a, b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdace32fdb5c0027816e247b4bd1b7fb7ff95259" translate="yes" xml:space="preserve">
          <source>The contents of tables and indexes are discussed further in &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;.</source>
          <target state="translated">Содержание таблиц и индексов обсуждается далее в &lt;a href=&quot;storage-page-layout&quot;&gt;Разделе 68.6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="38f47269fb5aeb6c838c026cdcf1f0ae2ecfc4fc" translate="yes" xml:space="preserve">
          <source>The contents of the WAL buffers are written out to disk at every transaction commit, so extremely large values are unlikely to provide a significant benefit. However, setting this value to at least a few megabytes can improve write performance on a busy server where many clients are committing at once. The auto-tuning selected by the default setting of -1 should give reasonable results in most cases.</source>
          <target state="translated">Содержимое буферов WAL записывается на диск при каждом фиксации транзакции,поэтому чрезвычайно большие значения вряд ли принесут существенную пользу.Однако,установка этого значения как минимум в несколько мегабайт может улучшить производительность записи на занятом сервере,где многие клиенты совершают коммиты одновременно.Автоматическая настройка,выбранная в настройках по умолчанию -1,в большинстве случаев должна давать разумные результаты.</target>
        </trans-unit>
        <trans-unit id="b1c6502d2f4ffe992973e02c33536a28b4746870" translate="yes" xml:space="preserve">
          <source>The contents of the directories &lt;code&gt;pg_dynshmem/&lt;/code&gt;, &lt;code&gt;pg_notify/&lt;/code&gt;, &lt;code&gt;pg_serial/&lt;/code&gt;, &lt;code&gt;pg_snapshots/&lt;/code&gt;, &lt;code&gt;pg_stat_tmp/&lt;/code&gt;, and &lt;code&gt;pg_subtrans/&lt;/code&gt; (but not the directories themselves) can be omitted from the backup as they will be initialized on postmaster startup. If &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; is set and is under the data directory then the contents of that directory can also be omitted.</source>
          <target state="translated">Содержимое каталогов &lt;code&gt;pg_dynshmem/&lt;/code&gt; , &lt;code&gt;pg_notify/&lt;/code&gt; , &lt;code&gt;pg_serial/&lt;/code&gt; , &lt;code&gt;pg_snapshots/&lt;/code&gt; , &lt;code&gt;pg_stat_tmp/&lt;/code&gt; и &lt;code&gt;pg_subtrans/&lt;/code&gt; (но не сами каталоги) можно исключить из резервной копии, поскольку они будут инициализированы при запуске postmaster. Если &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; установлен и находится в каталоге данных, то содержимое этого каталога также можно опустить.</target>
        </trans-unit>
        <trans-unit id="3de8d3c890918676d736b678933d22a18ab061b7" translate="yes" xml:space="preserve">
          <source>The convention followed by the operator classes included with the core PostgreSQL distribution is to register a stock, generic &lt;code&gt;equalimage&lt;/code&gt; function. Most operator classes register &lt;code&gt;btequalimage()&lt;/code&gt;, which indicates that deduplication is safe unconditionally. Operator classes for collatable data types such as &lt;code&gt;text&lt;/code&gt; register &lt;code&gt;btvarstrequalimage()&lt;/code&gt;, which indicates that deduplication is safe with deterministic collations. Best practice for third-party extensions is to register their own custom function to retain control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e0411ab62d3d86cfefc61b32fd0a5818262ee5" translate="yes" xml:space="preserve">
          <source>The conversion rules presented here are not exactly those of the SQL standard, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-CASTS&quot;&gt;Section D.3.1.3&lt;/a&gt;.</source>
          <target state="translated">Представленные здесь правила преобразования не совсем соответствуют правилам стандарта SQL, как описано в &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-CASTS&quot;&gt;Разделе D.3.1.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93003637d33db2eb4895822b5caba9508ac9a024" translate="yes" xml:space="preserve">
          <source>The coordinates of an individual in the search space are represented by &lt;em&gt;chromosomes&lt;/em&gt;, in essence a set of character strings. A &lt;em&gt;gene&lt;/em&gt; is a subsection of a chromosome which encodes the value of a single parameter being optimized. Typical encodings for a gene could be &lt;em&gt;binary&lt;/em&gt; or &lt;em&gt;integer&lt;/em&gt;.</source>
          <target state="translated">Координаты человека в пространстве поиска представлены &lt;em&gt;хромосомами&lt;/em&gt; , по сути, набором строк символов. &lt;em&gt;Ген&lt;/em&gt; представляет собой подраздел хромосомы , который кодирует значение одного параметра оптимизируется. Типичное кодирование гена может быть &lt;em&gt;двоичным&lt;/em&gt; или &lt;em&gt;целым&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="862293286080d0a9f0113978ebf74556e90249fd" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the BRIN operator classes shown in &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 67.1&lt;/a&gt;.</source>
          <target state="translated">Базовый дистрибутив PostgreSQL включает классы операторов BRIN, показанные в &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Таблице 67.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7243c976dc744d56b010e5d36a8288b88892f5dc" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GIN operator classes previously shown in &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 66.1&lt;/a&gt;. The following &lt;code&gt;contrib&lt;/code&gt; modules also contain GIN operator classes:</source>
          <target state="translated">Базовый дистрибутив PostgreSQL включает классы операторов GIN, ранее показанные в &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Таблице 66.1&lt;/a&gt; . Следующие модули &lt;code&gt;contrib&lt;/code&gt; также содержат классы операторов GIN:</target>
        </trans-unit>
        <trans-unit id="c2fbf40f11cf35a0a12e58dfa2d5f0d5377fea85" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GIN operator classes shown in &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 66.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GIN operator classes.)</source>
          <target state="translated">Базовый дистрибутив PostgreSQL включает классы операторов GIN, показанные в &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Таблице 66.1&lt;/a&gt; . (Некоторые из дополнительных модулей, описанных в &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Приложении F,&lt;/a&gt; предоставляют дополнительные классы операторов GIN.)</target>
        </trans-unit>
        <trans-unit id="806d720c4b8fe7fcc17e70e9b466b37e2e2f856b" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GIN operator classes shown in &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 66.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GIN operator classes.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8a9d6f1f395ae01d0f93e48fe3bca4cc653cd4" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GiST operator classes shown in &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 64.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GiST operator classes.)</source>
          <target state="translated">Основной дистрибутив PostgreSQL включает классы операторов GiST, показанные в &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Таблице 64.1&lt;/a&gt; . (Некоторые из дополнительных модулей, описанных в &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Приложении F,&lt;/a&gt; предоставляют дополнительные классы операторов GiST.)</target>
        </trans-unit>
        <trans-unit id="0cf2930ff562138360e1ed4d1a72443d736ec8f6" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GiST operator classes shown in &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 64.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GiST operator classes.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4f128e5e4ead669ae57136a3aca466199dcb9f" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the SP-GiST operator classes shown in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;.</source>
          <target state="translated">Основной дистрибутив PostgreSQL включает классы операторов SP-GiST, показанные в &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Таблице 65.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05fafa81f43ebb1970323c27149ee647ab30ffe3" translate="yes" xml:space="preserve">
          <source>The core code is fundamentally unable to deduce anything about the &amp;ldquo;equality implies image equality&amp;rdquo; status of an operator class within a multiple-data-type family based on details from other operator classes in the same family. Also, it is not sensible for an operator family to register a cross-type &lt;code&gt;equalimage&lt;/code&gt; function, and attempting to do so will result in an error. This is because &amp;ldquo;equality implies image equality&amp;rdquo; status does not just depend on sorting/equality semantics, which are more or less defined at the operator family level. In general, the semantics that one particular data type implements must be considered separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a856912c9ac553c9e328fb462dc4a3dc3f226a" translate="yes" xml:space="preserve">
          <source>The core distribution includes support for two types of operator classes: minmax and inclusion. Operator class definitions using them are shipped for in-core data types as appropriate. Additional operator classes can be defined by the user for other data types using equivalent definitions, without having to write any source code; appropriate catalog entries being declared is enough. Note that assumptions about the semantics of operator strategies are embedded in the support functions' source code.</source>
          <target state="translated">Распределение ядра включает поддержку двух типов операторных классов:minmax и inclusion.Определения операторных классов с их использованием поставляются для внутриядерных типов данных по мере необходимости.Дополнительные классы операторов могут быть определены пользователем для других типов данных с использованием эквивалентных определений,без необходимости написания какого-либо исходного кода;достаточно объявить соответствующие записи каталога.Обратите внимание,что предположения о семантике стратегий операторов встроены в исходный код функций поддержки.</target>
        </trans-unit>
        <trans-unit id="c6af74783e2e512b02fff35f8b9b1611ba92c8bc" translate="yes" xml:space="preserve">
          <source>The corresponding column will be filled with its default value.</source>
          <target state="translated">Соответствующий столбец будет заполнен значением по умолчанию.</target>
        </trans-unit>
        <trans-unit id="33e9a48b1e5df95c7200af8afb9a8f1b54ef12f2" translate="yes" xml:space="preserve">
          <source>The corresponding column will be filled with its default value. An identity column will be filled with a new value generated by the associated sequence. For a generated column, specifying this is permitted but merely specifies the normal behavior of computing the column from its generation expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b1b5853e1b21f147904a21bac6120e0399eff4" translate="yes" xml:space="preserve">
          <source>The corresponding constraint in the parent partitioned table, if this is a constraint in a partition; else 0</source>
          <target state="translated">Соответствующее ограничение в родительской таблице разметки,если это ограничение в разделе;в противном случае 0</target>
        </trans-unit>
        <trans-unit id="e50bc6dd81573c8b84e401b93b09d0320c5165e6" translate="yes" xml:space="preserve">
          <source>The costs are measured in arbitrary units determined by the planner's cost parameters (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;). Traditional practice is to measure the costs in units of disk page fetches; that is, &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt; is conventionally set to &lt;code&gt;1.0&lt;/code&gt; and the other cost parameters are set relative to that. The examples in this section are run with the default cost parameters.</source>
          <target state="translated">Затраты измеряются в произвольных единицах, определяемых параметрами затрат планировщика (см. &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Раздел 19.7.2&lt;/a&gt; ). Традиционная практика заключается в измерении затрат в единицах выборки страниц с диска; то есть &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt; обычно устанавливается равным &lt;code&gt;1.0&lt;/code&gt; , а другие параметры стоимости устанавливаются относительно этого. Примеры в этом разделе выполняются с параметрами стоимости по умолчанию.</target>
        </trans-unit>
        <trans-unit id="40a2e5c659fc82ea65929c45fcbdccd61dafc250" translate="yes" xml:space="preserve">
          <source>The creation of a publication does not start replication. It only defines a grouping and filtering logic for future subscribers.</source>
          <target state="translated">Создание публикации не начинает репликации.Оно лишь определяет логику группировки и фильтрации для будущих подписчиков.</target>
        </trans-unit>
        <trans-unit id="3e98adbd0156fb7d426b89504f191dda4a555319" translate="yes" xml:space="preserve">
          <source>The creation of databases is a restricted operation. See &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt; for how to grant permission.</source>
          <target state="translated">Создание баз данных - это ограниченная операция. См. &lt;a href=&quot;role-attributes&quot;&gt;Раздел 21.2,&lt;/a&gt; чтобы узнать, как предоставить разрешение.</target>
        </trans-unit>
        <trans-unit id="1880291804157d355a896d197b0a52d8a09b04b7" translate="yes" xml:space="preserve">
          <source>The cube a contains the cube b.</source>
          <target state="translated">Куб a содержит куб b.</target>
        </trans-unit>
        <trans-unit id="375266423676b7d7beda6d0e513197403bfef8c1" translate="yes" xml:space="preserve">
          <source>The cube a is contained in the cube b.</source>
          <target state="translated">Куб a содержится в кубе b.</target>
        </trans-unit>
        <trans-unit id="b588f40bf468c3153645f14f27d51be8b21426c9" translate="yes" xml:space="preserve">
          <source>The cube a is greater than or equal to the cube b.</source>
          <target state="translated">Кубик a больше или равен кубу b.</target>
        </trans-unit>
        <trans-unit id="2f01cfa360b4f7c3692487eca6dd5b417fc389b3" translate="yes" xml:space="preserve">
          <source>The cube a is greater than the cube b.</source>
          <target state="translated">Кубик a больше,чем кубик b.</target>
        </trans-unit>
        <trans-unit id="0e6cf54be6b186407704fdff88fc957131d4ed9b" translate="yes" xml:space="preserve">
          <source>The cube a is less than or equal to the cube b.</source>
          <target state="translated">Кубик a меньше или равен кубу b.</target>
        </trans-unit>
        <trans-unit id="f2d342ff49043cacce0129a759922d79461a11fa" translate="yes" xml:space="preserve">
          <source>The cube a is less than the cube b.</source>
          <target state="translated">Кубик a меньше,чем кубик b.</target>
        </trans-unit>
        <trans-unit id="4634367f6224780d287c24528a5fced1237e5fa1" translate="yes" xml:space="preserve">
          <source>The cube a is not equal to the cube b.</source>
          <target state="translated">Куб a не равен кубу b.</target>
        </trans-unit>
        <trans-unit id="45987f656860bb4eb975fa1cd72ba43bc699f956" translate="yes" xml:space="preserve">
          <source>The cubes a and b are identical.</source>
          <target state="translated">Кубики a и b идентичны.</target>
        </trans-unit>
        <trans-unit id="9213cf52b8d8a10f6b7daa93550fc8c65e89e83d" translate="yes" xml:space="preserve">
          <source>The cubes a and b overlap.</source>
          <target state="translated">Кубики a и b перекрываются.</target>
        </trans-unit>
        <trans-unit id="1a1e2040f8ce058f3c38c6e6d3751c0a69992146" translate="yes" xml:space="preserve">
          <source>The current backend's &lt;code&gt;xmin&lt;/code&gt; horizon.</source>
          <target state="translated">Горизонт &lt;code&gt;xmin&lt;/code&gt; текущего бэкенда .</target>
        </trans-unit>
        <trans-unit id="71bea49a2448467c39ae3d46b44b8328244be40c" translate="yes" xml:space="preserve">
          <source>The current client character set encoding. This is set every time you connect to a database (including program start-up), and when you change the encoding with &lt;code&gt;\encoding&lt;/code&gt;, but it can be changed or unset.</source>
          <target state="translated">Текущая кодировка набора символов клиента. Это устанавливается каждый раз, когда вы подключаетесь к базе данных (включая запуск программы), и когда вы меняете кодировку с помощью &lt;code&gt;\encoding&lt;/code&gt; , но ее можно изменить или сбросить.</target>
        </trans-unit>
        <trans-unit id="0deea51724bf6c34acfe1425e13fc10373b6c41e" translate="yes" xml:space="preserve">
          <source>The current dimensions of any array value can be retrieved with the &lt;code&gt;array_dims&lt;/code&gt; function:</source>
          <target state="translated">Текущие размеры любого значения массива можно получить с &lt;code&gt;array_dims&lt;/code&gt; функции array_dims :</target>
        </trans-unit>
        <trans-unit id="8c3a8302b74a0c1c2418c7953403859316142fae" translate="yes" xml:space="preserve">
          <source>The current effective value of the search path can be examined via the SQL function &lt;code&gt;current_schemas&lt;/code&gt; (see &lt;a href=&quot;functions-info&quot;&gt;Section 9.25&lt;/a&gt;). This is not quite the same as examining the value of &lt;code&gt;search_path&lt;/code&gt;, since &lt;code&gt;current_schemas&lt;/code&gt; shows how the items appearing in &lt;code&gt;search_path&lt;/code&gt; were resolved.</source>
          <target state="translated">Текущее эффективное значение пути поиска можно проверить с помощью функции SQL &lt;code&gt;current_schemas&lt;/code&gt; (см. &lt;a href=&quot;functions-info&quot;&gt;Раздел 9.25&lt;/a&gt; ). Это не совсем то же самое, что &lt;code&gt;search_path&lt;/code&gt; значения search_path , поскольку &lt;code&gt;current_schemas&lt;/code&gt; показывает, как были разрешены элементы, появляющиеся в &lt;code&gt;search_path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="197001cc9f21d760f60e1fb495baacfbe4512e51" translate="yes" xml:space="preserve">
          <source>The current effective value of the search path can be examined via the SQL function &lt;code&gt;current_schemas&lt;/code&gt; (see &lt;a href=&quot;functions-info&quot;&gt;Section 9.26&lt;/a&gt;). This is not quite the same as examining the value of &lt;code&gt;search_path&lt;/code&gt;, since &lt;code&gt;current_schemas&lt;/code&gt; shows how the items appearing in &lt;code&gt;search_path&lt;/code&gt; were resolved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588306ac744664bcce2285f16a927597e5d43ed4" translate="yes" xml:space="preserve">
          <source>The current implementation does not enforce the declared number of dimensions either. Arrays of a particular element type are all considered to be of the same type, regardless of size or number of dimensions. So, declaring the array size or number of dimensions in &lt;code&gt;CREATE TABLE&lt;/code&gt; is simply documentation; it does not affect run-time behavior.</source>
          <target state="translated">Текущая реализация также не требует заявленного количества измерений. Считается, что все массивы элементов определенного типа относятся к одному типу, независимо от размера или количества измерений. Итак, объявление размера массива или количества измерений в &lt;code&gt;CREATE TABLE&lt;/code&gt; - это просто документация; это не влияет на поведение во время выполнения.</target>
        </trans-unit>
        <trans-unit id="03a220364aef06c1bbc7f574a82ccaeced5bea27" translate="yes" xml:space="preserve">
          <source>The current implementation has significant limitations, and does not enforce mandatory access control for all actions. See &lt;a href=&quot;sepgsql#SEPGSQL-LIMITATIONS&quot;&gt;Section F.35.7&lt;/a&gt;.</source>
          <target state="translated">Текущая реализация имеет значительные ограничения и не обеспечивает принудительный контроль доступа для всех действий. См. &lt;a href=&quot;sepgsql#SEPGSQL-LIMITATIONS&quot;&gt;Раздел F.35.7&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25210d55190c9236b389899a74a7b5704fff78d4" translate="yes" xml:space="preserve">
          <source>The current implementation of &lt;code&gt;unaccent&lt;/code&gt; cannot be used as a normalizing dictionary for the &lt;code&gt;thesaurus&lt;/code&gt; dictionary.</source>
          <target state="translated">Текущая реализация &lt;code&gt;unaccent&lt;/code&gt; не может использоваться как нормализующий словарь для словаря &lt;code&gt;thesaurus&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed96c59248b01f330729c6c44b2035a2f3097a16" translate="yes" xml:space="preserve">
          <source>The current limitations of PostgreSQL's text search features are:</source>
          <target state="translated">Текущие ограничения возможностей текстового поиска PostgreSQL:</target>
        </trans-unit>
        <trans-unit id="11ad6de9ae99189b133ed48695fe71e760901959" translate="yes" xml:space="preserve">
          <source>The cursor should be declared with the &lt;code&gt;SCROLL&lt;/code&gt; option if one intends to use any variants of &lt;code&gt;FETCH&lt;/code&gt; other than &lt;code&gt;FETCH NEXT&lt;/code&gt; or &lt;code&gt;FETCH FORWARD&lt;/code&gt; with a positive count. For simple queries PostgreSQL will allow backwards fetch from cursors not declared with &lt;code&gt;SCROLL&lt;/code&gt;, but this behavior is best not relied on. If the cursor is declared with &lt;code&gt;NO SCROLL&lt;/code&gt;, no backward fetches are allowed.</source>
          <target state="translated">Курсор должен быть объявлен с опцией &lt;code&gt;SCROLL&lt;/code&gt; , если кто-то намеревается использовать любые варианты &lt;code&gt;FETCH&lt;/code&gt; , кроме &lt;code&gt;FETCH NEXT&lt;/code&gt; или &lt;code&gt;FETCH FORWARD&lt;/code&gt; с положительным счетчиком. Для простых запросов PostgreSQL разрешит обратную выборку из курсоров, не объявленных с помощью &lt;code&gt;SCROLL&lt;/code&gt; , но на такое поведение лучше не полагаться. Если курсор объявлен с &lt;code&gt;NO SCROLL&lt;/code&gt; , обратная выборка не разрешена.</target>
        </trans-unit>
        <trans-unit id="4f29dd59131cbd500833c5a80fec96f77393e7a4" translate="yes" xml:space="preserve">
          <source>The data distribution is very simple; there are only 100 distinct values in each column, uniformly distributed.</source>
          <target state="translated">Распределение данных очень простое,в каждом столбце всего 100 различных значений,распределенных равномерно.</target>
        </trans-unit>
        <trans-unit id="bf388f98f91dd65f88f15e7c3f1b408fc205654b" translate="yes" xml:space="preserve">
          <source>The data is prefixed with a block of random bytes. This is equivalent to using a random IV.</source>
          <target state="translated">Данные префиксуются блоком случайных байт.Это эквивалентно использованию случайного IV.</target>
        </trans-unit>
        <trans-unit id="d53ba1352e33254f15d2784088350652d0fec89f" translate="yes" xml:space="preserve">
          <source>The data on the standby takes some time to arrive from the primary server so there will be a measurable delay between primary and standby. Running the same query nearly simultaneously on both primary and standby might therefore return differing results. We say that data on the standby is &lt;em&gt;eventually consistent&lt;/em&gt; with the primary. Once the commit record for a transaction is replayed on the standby, the changes made by that transaction will be visible to any new snapshots taken on the standby. Snapshots may be taken at the start of each query or at the start of each transaction, depending on the current transaction isolation level. For more details, see &lt;a href=&quot;transaction-iso&quot;&gt;Section 13.2&lt;/a&gt;.</source>
          <target state="translated">Для получения данных на резервном сервере от основного сервера требуется некоторое время, поэтому между основным и резервным будет измеримая задержка. Таким образом, выполнение одного и того же запроса почти одновременно на первичном и резервном серверах может привести к разным результатам. Мы говорим, что данные на резервном сервере в &lt;em&gt;конечном итоге согласуются&lt;/em&gt; с основным. После воспроизведения записи фиксации транзакции на резервном сервере изменения, внесенные этой транзакцией, будут видны для любых новых снимков, сделанных на резервном сервере. Моментальные снимки могут быть сделаны в начале каждого запроса или в начале каждой транзакции, в зависимости от текущего уровня изоляции транзакции. Для получения дополнительной информации см. &lt;a href=&quot;transaction-iso&quot;&gt;Раздел 13.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b4139483f5abc1e06390b32222b164b98282561" translate="yes" xml:space="preserve">
          <source>The data section contains actual table data as well as large-object definitions. Post-data items consist of definitions of indexes, triggers, rules and constraints other than validated check constraints. Pre-data items consist of all other data definition items.</source>
          <target state="translated">Раздел данных содержит актуальные табличные данные,а также определения больших объектов.Элементы пост-данных состоят из определений индексов,триггеров,правил и ограничений,отличных от валидированных ограничений проверки.Элементы предварительных данных состоят из всех других элементов определений данных.</target>
        </trans-unit>
        <trans-unit id="e6ca4b823a5f4163ec85e2bd3fdf29af04d8b385" translate="yes" xml:space="preserve">
          <source>The data section contains actual table data, large-object contents, and sequence values. Post-data items include definitions of indexes, triggers, rules, and constraints other than validated check constraints. Pre-data items include all other data definition items.</source>
          <target state="translated">Раздел данных содержит актуальные табличные данные,содержимое больших объектов и значения последовательности.Элементы пост-данных включают определения индексов,триггеров,правил и ограничений,отличных от ограничений проверки достоверности.Элементы предварительных данных включают в себя все другие элементы определения данных.</target>
        </trans-unit>
        <trans-unit id="b17b79d26641dd87ba0c23b6c9bc174faa3a8b61" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;uuid&lt;/code&gt; stores Universally Unique Identifiers (UUID) as defined by RFC 4122, ISO/IEC 9834-8:2005, and related standards. (Some systems refer to this data type as a globally unique identifier, or GUID, instead.) This identifier is a 128-bit quantity that is generated by an algorithm chosen to make it very unlikely that the same identifier will be generated by anyone else in the known universe using the same algorithm. Therefore, for distributed systems, these identifiers provide a better uniqueness guarantee than sequence generators, which are only unique within a single database.</source>
          <target state="translated">Тип данных &lt;code&gt;uuid&lt;/code&gt; хранит универсальные уникальные идентификаторы (UUID), как определено в RFC 4122, ISO / IEC 9834-8: 2005 и связанных стандартах. (Некоторые системы вместо этого называют этот тип данных глобальным уникальным идентификатором или GUID.) Этот идентификатор представляет собой 128-битное количество, которое генерируется алгоритмом, выбранным таким образом, чтобы очень маловероятно, что тот же идентификатор будет сгенерирован кем-либо еще. в известной вселенной с использованием того же алгоритма. Следовательно, для распределенных систем эти идентификаторы обеспечивают лучшую гарантию уникальности, чем генераторы последовательностей, которые уникальны только в пределах одной базы данных.</target>
        </trans-unit>
        <trans-unit id="9a349537e0ccabe90f0be4224865fb39a87fb38c" translate="yes" xml:space="preserve">
          <source>The data type actually stored in the index. Normally this is the same as the column data type, but some index methods (currently GiST, GIN and BRIN) allow it to be different. The &lt;code&gt;STORAGE&lt;/code&gt; clause must be omitted unless the index method allows a different type to be used. If the column &lt;code&gt;data_type&lt;/code&gt; is specified as &lt;code&gt;anyarray&lt;/code&gt;, the &lt;code&gt;storage_type&lt;/code&gt; can be declared as &lt;code&gt;anyelement&lt;/code&gt; to indicate that the index entries are members of the element type belonging to the actual array type that each particular index is created for.</source>
          <target state="translated">Тип данных, фактически хранящийся в индексе. Обычно это тот же тип данных столбца, но некоторые методы индекса (в настоящее время GiST, GIN и BRIN) позволяют ему быть другим. Предложение &lt;code&gt;STORAGE&lt;/code&gt; должно быть опущено, если только метод индекса не позволяет использовать другой тип. Если столбец &lt;code&gt;data_type&lt;/code&gt; указан как &lt;code&gt;anyarray&lt;/code&gt; , &lt;code&gt;storage_type&lt;/code&gt; может быть объявлен как &lt;code&gt;anyelement&lt;/code&gt; , чтобы указать, что записи индекса являются элементами типа элемента, принадлежащего фактическому типу массива, для которого создается каждый конкретный индекс.</target>
        </trans-unit>
        <trans-unit id="b3cf16533d2c33c2548b22d8bef5b9f8bd26fb43" translate="yes" xml:space="preserve">
          <source>The data type for the aggregate's state value, when using moving-aggregate mode.</source>
          <target state="translated">Тип данных для значения состояния агрегата при использовании режима перемещения-агрегации.</target>
        </trans-unit>
        <trans-unit id="450e47ffde369f976b7ab98b3a6e066768317211" translate="yes" xml:space="preserve">
          <source>The data type for the aggregate's state value.</source>
          <target state="translated">Тип данных для значения состояния агрегата.</target>
        </trans-unit>
        <trans-unit id="a84accdb873accb8d045ec8f5d98450a1c8038e0" translate="yes" xml:space="preserve">
          <source>The data type of a function, procedure, or aggregate argument.</source>
          <target state="translated">Тип данных функции,процедуры или совокупного аргумента.</target>
        </trans-unit>
        <trans-unit id="7678a7f2db2f20f82bdcd718575a886bbedb555c" translate="yes" xml:space="preserve">
          <source>The data type of a parameter to the prepared statement. If the data type of a particular parameter is unspecified or is specified as &lt;code&gt;unknown&lt;/code&gt;, it will be inferred from the context in which the parameter is first referenced. To refer to the parameters in the prepared statement itself, use &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc.</source>
          <target state="translated">Тип данных параметра подготовленного оператора. Если тип данных конкретного параметра не указан или указан как &lt;code&gt;unknown&lt;/code&gt; , он будет выведен из контекста, в котором параметр впервые упоминается. Чтобы ссылаться на параметры в самом подготовленном операторе, используйте &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="97e7b1042480837c18e5146ff95fc1e9e9d4ce38" translate="yes" xml:space="preserve">
          <source>The data type of an output column in the &lt;code&gt;RETURNS TABLE&lt;/code&gt; syntax.</source>
          <target state="translated">Тип данных выходного столбца в синтаксисе &lt;code&gt;RETURNS TABLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f4da46a2e46ee99f93db576da8c6c70a740dbca" translate="yes" xml:space="preserve">
          <source>The data type of the attribute to add, or the new type of the attribute to alter.</source>
          <target state="translated">Тип данных атрибута для добавления или новый тип атрибута для изменения.</target>
        </trans-unit>
        <trans-unit id="643babd5ccd3dbc1eadd607ad51f52e3099e9220" translate="yes" xml:space="preserve">
          <source>The data type of the column. This can include array specifiers. For more information on the data types supported by PostgreSQL, refer to &lt;a href=&quot;datatype&quot;&gt;Chapter 8&lt;/a&gt;.</source>
          <target state="translated">Тип данных столбца. Это может включать спецификаторы массива. Дополнительные сведения о типах данных, поддерживаемых PostgreSQL, см. В &lt;a href=&quot;datatype&quot;&gt;главе 8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00e2be0bf08b0f249705f534c771af62f659c534" translate="yes" xml:space="preserve">
          <source>The data type of the operator's left operand, if any. This option would be omitted for a left-unary operator.</source>
          <target state="translated">Тип данных левого операнда оператора,если таковой имеется.Эта опция будет опущена для левостороннего оператора.</target>
        </trans-unit>
        <trans-unit id="3851b291352047da5cb8dab5436b1049af2b810b" translate="yes" xml:space="preserve">
          <source>The data type of the operator's left operand; write &lt;code&gt;NONE&lt;/code&gt; if the operator has no left operand.</source>
          <target state="translated">Тип данных левого операнда оператора; напишите &lt;code&gt;NONE&lt;/code&gt; , если у оператора нет левого операнда.</target>
        </trans-unit>
        <trans-unit id="ccbd8cc94b9c8b592bbe8864eb6cc7e34df08235" translate="yes" xml:space="preserve">
          <source>The data type of the operator's right operand, if any. This option would be omitted for a right-unary operator.</source>
          <target state="translated">Тип данных правого операнда оператора,если таковой имеется.Эта опция будет опущена для правого оператора.</target>
        </trans-unit>
        <trans-unit id="977b80839dcec0a264635f6fae2341cd4abe466d" translate="yes" xml:space="preserve">
          <source>The data type of the operator's right operand; write &lt;code&gt;NONE&lt;/code&gt; if the operator has no right operand.</source>
          <target state="translated">Тип данных правого операнда оператора; напишите &lt;code&gt;NONE&lt;/code&gt; , если у оператора нет правильного операнда.</target>
        </trans-unit>
        <trans-unit id="d1e6d9a6627f0f8541d4b2888407afff0ea3591c" translate="yes" xml:space="preserve">
          <source>The data type of this column</source>
          <target state="translated">Тип данных этой колонки</target>
        </trans-unit>
        <trans-unit id="536b65adfc0c23a20e0043a6c217a813568358a2" translate="yes" xml:space="preserve">
          <source>The data type(s) of the function's arguments (optionally schema-qualified), if any.</source>
          <target state="translated">Тип(ы)данных аргументов функции (необязательно с точки зрения схемы),если таковые имеются.</target>
        </trans-unit>
        <trans-unit id="c1899d531f40a6d2bc934ee7a1bdb436b5b33cc2" translate="yes" xml:space="preserve">
          <source>The data type(s) of the function's arguments (optionally schema-qualified), if any. The argument types can be base, composite, or domain types, or can reference the type of a table column.</source>
          <target state="translated">Тип(ы)данных аргументов функции (необязательно с точки зрения схемы),если таковые имеются.Типы аргументов могут быть базовыми,составными или доменными,или могут ссылаться на тип столбца таблицы.</target>
        </trans-unit>
        <trans-unit id="0fa26cbbebcfa5ffa72e0fb66013b91729e1dbea" translate="yes" xml:space="preserve">
          <source>The data type(s) of the operator's arguments (optionally schema-qualified). Write &lt;code&gt;NONE&lt;/code&gt; for the missing argument of a prefix or postfix operator.</source>
          <target state="translated">Тип (ы) данных аргументов оператора (возможно, дополненных схемой). Напишите &lt;code&gt;NONE&lt;/code&gt; для отсутствующего аргумента префиксного или постфиксного оператора.</target>
        </trans-unit>
        <trans-unit id="f78d5722d424ec9c1eb5a72c627a144311353db1" translate="yes" xml:space="preserve">
          <source>The data type(s) of the procedure's arguments (optionally schema-qualified), if any.</source>
          <target state="translated">Тип(ы)данных аргументов процедуры (необязательно с точки зрения схемы),если таковые имеются.</target>
        </trans-unit>
        <trans-unit id="cc4ed7c8f0edb91ee3802c9f1cbfdfe5d88cd95f" translate="yes" xml:space="preserve">
          <source>The data type(s) of the procedure's arguments (optionally schema-qualified), if any. The argument types can be base, composite, or domain types, or can reference the type of a table column.</source>
          <target state="translated">Тип(ы)данных аргументов процедуры (необязательно с точки зрения схемы),если таковые имеются.Типы аргументов могут быть базовыми,составными или доменными,или могут ссылаться на тип столбца таблицы.</target>
        </trans-unit>
        <trans-unit id="b13b1cfa55ac5025cb1667821c336a02f9958dc9" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; are inexact, variable-precision numeric types. On all currently supported platforms, these types are implementations of IEEE Standard 754 for Binary Floating-Point Arithmetic (single and double precision, respectively), to the extent that the underlying processor, operating system, and compiler support it.</source>
          <target state="translated">Типы данных &lt;code&gt;real&lt;/code&gt; и &lt;code&gt;double precision&lt;/code&gt; являются неточными числовыми типами переменной точности. На всех поддерживаемых в настоящее время платформах эти типы являются реализациями стандарта IEEE 754 для двоичной арифметики с плавающей запятой (одинарная и двойная точность, соответственно) в той мере, в какой это поддерживают базовый процессор, операционная система и компилятор.</target>
        </trans-unit>
        <trans-unit id="95cc47952f3a5e2e5bea18ece63744adf6f3d52b" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are not true types, but merely a notational convenience for creating unique identifier columns (similar to the &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; property supported by some other databases). In the current implementation, specifying:</source>
          <target state="translated">Типы данных &lt;code&gt;smallserial&lt;/code&gt; , &lt;code&gt;serial&lt;/code&gt; и &lt;code&gt;bigserial&lt;/code&gt; не являются истинными типами, а являются просто удобством записи для создания столбцов уникальных идентификаторов (аналогично свойству &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; , поддерживаемому некоторыми другими базами данных). В текущей реализации, указав:</target>
        </trans-unit>
        <trans-unit id="c1d4cee11581ccf46822d30574cc04ac170d447c" translate="yes" xml:space="preserve">
          <source>The data types of all the &lt;code&gt;result&lt;/code&gt; expressions must be convertible to a single output type. See &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt; for more details.</source>
          <target state="translated">Типы данных всех выражений &lt;code&gt;result&lt;/code&gt; должны быть преобразованы в один тип вывода. За подробностями &lt;a href=&quot;typeconv-union-case&quot;&gt;обратитесь&lt;/a&gt; к Разделу 10.5 .</target>
        </trans-unit>
        <trans-unit id="833950eaad4f091a792f16ed765cff996e89f49e" translate="yes" xml:space="preserve">
          <source>The data values are listed in the order in which the columns appear in the table, separated by commas. Usually, the data values will be literals (constants), but scalar expressions are also allowed.</source>
          <target state="translated">Значения данных приведены в том порядке,в котором столбцы отображаются в таблице,разделенные запятыми.Обычно значения данных будут буквами (константами),но допускаются и скалярные выражения.</target>
        </trans-unit>
        <trans-unit id="511f74682fefbedf40676929009d5d52bb81a56d" translate="yes" xml:space="preserve">
          <source>The data values are mapped in the same way as described for the function &lt;code&gt;xmlelement&lt;/code&gt; above.</source>
          <target state="translated">Значения данных отображаются таким же образом, как описано выше для функции &lt;code&gt;xmlelement&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3854c2d1d8f8304933b603d0d2fef62ed88a35f" translate="yes" xml:space="preserve">
          <source>The database activity of pg_dump is normally collected by the statistics collector. If this is undesirable, you can set parameter &lt;code&gt;track_counts&lt;/code&gt; to false via &lt;code&gt;PGOPTIONS&lt;/code&gt; or the &lt;code&gt;ALTER USER&lt;/code&gt; command.</source>
          <target state="translated">Активность pg_dump в базе данных обычно собирается сборщиком статистики. Если это нежелательно, вы можете установить для параметра &lt;code&gt;track_counts&lt;/code&gt; значение false с помощью &lt;code&gt;PGOPTIONS&lt;/code&gt; или команды &lt;code&gt;ALTER USER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e78726feeb2c4690a432f23c59d13fb4ceea2509" translate="yes" xml:space="preserve">
          <source>The database named in the &lt;code&gt;-d&lt;/code&gt; switch can be any database existing in the cluster; pg_restore only uses it to issue the &lt;code&gt;CREATE DATABASE&lt;/code&gt; command for &lt;code&gt;mydb&lt;/code&gt;. With &lt;code&gt;-C&lt;/code&gt;, data is always restored into the database name that appears in the dump file.</source>
          <target state="translated">База данных, &lt;code&gt;-d&lt;/code&gt; переключателе -d, может быть любой базой данных, существующей в кластере; pg_restore использует его только для выполнения команды &lt;code&gt;CREATE DATABASE&lt;/code&gt; для &lt;code&gt;mydb&lt;/code&gt; . С &lt;code&gt;-C&lt;/code&gt; данные всегда восстанавливаются в имя базы данных, которое появляется в файле дампа.</target>
        </trans-unit>
        <trans-unit id="a7217998725cfcd7339a40affa714dc41a9f7779" translate="yes" xml:space="preserve">
          <source>The database schema and DDL commands are not replicated. The initial schema can be copied by hand using &lt;code&gt;pg_dump --schema-only&lt;/code&gt;. Subsequent schema changes would need to be kept in sync manually. (Note, however, that there is no need for the schemas to be absolutely the same on both sides.) Logical replication is robust when schema definitions change in a live database: When the schema is changed on the publisher and replicated data starts arriving at the subscriber but does not fit into the table schema, replication will error until the schema is updated. In many cases, intermittent errors can be avoided by applying additive schema changes to the subscriber first.</source>
          <target state="translated">Схема базы данных и команды DDL не реплицируются. Первоначальную схему можно скопировать вручную, используя &lt;code&gt;pg_dump --schema-only&lt;/code&gt; . Последующие изменения схемы необходимо будет синхронизировать вручную. (Обратите внимание, однако, что нет необходимости в том, чтобы схемы были абсолютно одинаковыми с обеих сторон.) Логическая репликация является надежной, когда определения схемы изменяются в действующей базе данных: когда схема изменяется на издателе и реплицируемые данные начинают поступать в подписчик, но не вписывается в схему таблицы, репликация будет ошибочной, пока схема не будет обновлена. Во многих случаях периодических ошибок можно избежать, применив сначала дополнительные изменения схемы к подписчику.</target>
        </trans-unit>
        <trans-unit id="7126248724d0590ca70b478abc60308b632b1141" translate="yes" xml:space="preserve">
          <source>The database server &lt;em&gt;must&lt;/em&gt; be shut down in order to get a usable backup. Half-way measures such as disallowing all connections will &lt;em&gt;not&lt;/em&gt; work (in part because &lt;code&gt;tar&lt;/code&gt; and similar tools do not take an atomic snapshot of the state of the file system, but also because of internal buffering within the server). Information about stopping the server can be found in &lt;a href=&quot;server-shutdown&quot;&gt;Section 18.5&lt;/a&gt;. Needless to say, you also need to shut down the server before restoring the data.</source>
          <target state="translated">Чтобы получить работоспособную резервную копию, &lt;em&gt;необходимо&lt;/em&gt; выключить сервер базы данных . Промежуточные меры, такие как запрет всех подключений, &lt;em&gt;не&lt;/em&gt; будут работать (отчасти потому, что &lt;code&gt;tar&lt;/code&gt; и подобные инструменты не делают атомарный снимок состояния файловой системы, но также из-за внутренней буферизации на сервере). Информацию об остановке сервера можно найти в &lt;a href=&quot;server-shutdown&quot;&gt;Разделе 18.5&lt;/a&gt; . Излишне говорить, что вам также необходимо выключить сервер перед восстановлением данных.</target>
        </trans-unit>
        <trans-unit id="c8210278fffa651db73498b44685083caea4837b" translate="yes" xml:space="preserve">
          <source>The database server host you are currently connected to. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">Хост сервера баз данных,к которому вы в данный момент подключены.Он устанавливается каждый раз,когда вы подключаетесь к базе данных (включая запуск программы),но может быть изменен или отменен.</target>
        </trans-unit>
        <trans-unit id="4225ad89a733947e3891f6391650e080a1af4ac1" translate="yes" xml:space="preserve">
          <source>The database server port to which you are currently connected. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">Порт сервера базы данных,к которому вы в данный момент подключены.Он устанавливается каждый раз при подключении к базе данных (включая запуск программы),но может быть изменен или отменен.</target>
        </trans-unit>
        <trans-unit id="cc0f8108abc644f84f0071b412b2512b78ad2132" translate="yes" xml:space="preserve">
          <source>The database server's host name</source>
          <target state="translated">Имя хоста сервера базы данных</target>
        </trans-unit>
        <trans-unit id="a4b3d744975ee6b60121119bc335e231f7de4513" translate="yes" xml:space="preserve">
          <source>The database server's port number</source>
          <target state="translated">Номер порта сервера базы данных</target>
        </trans-unit>
        <trans-unit id="cfe5c0809041f0c5dee1fdfbdf2f909905d7bde5" translate="yes" xml:space="preserve">
          <source>The database session user name. (The expansion of this value might change during a database session as the result of the command &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt;.)</source>
          <target state="translated">Имя пользователя сеанса базы данных. (Расширение этого значения может измениться во время сеанса базы данных в результате выполнения команды &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="7c6fc494e971daf47c30896ebfcc78ba315d5aed" translate="yes" xml:space="preserve">
          <source>The database to connect to. See the description of the actions for what this means in detail. The &lt;code&gt;dbname&lt;/code&gt; can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options. Defaults to the user name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8854074f0a9f2884a73fba5bef5522aadc8c6fe8" translate="yes" xml:space="preserve">
          <source>The database to connect to. See the description of the actions for what this means in detail. This can be a libpq connection string; see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt; for more information. Defaults to user name.</source>
          <target state="translated">База данных для подключения. См. Описание действий, чтобы узнать, что это означает подробно. Это может быть строка подключения libpq; см. &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Раздел 33.1.1&lt;/a&gt; для получения дополнительной информации. По умолчанию имя пользователя.</target>
        </trans-unit>
        <trans-unit id="8142c603a5c381a14fdd730098342401f6c26eea" translate="yes" xml:space="preserve">
          <source>The database user you are currently connected as. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">Пользователь базы данных,от имени которого вы в данный момент подключены.Устанавливается каждый раз при подключении к базе данных (включая запуск программы),но может быть изменен или отменен.</target>
        </trans-unit>
        <trans-unit id="b630a685a9f1e8cf73c559db8e767d96cc4b9662" translate="yes" xml:space="preserve">
          <source>The database you are trying to connect to does not exist. Note that if you do not specify a database name, it defaults to the database user name, which might or might not be the right thing.</source>
          <target state="translated">Базы данных,к которой вы пытаетесь подключиться,не существует.Обратите внимание,что если вы не указываете имя базы данных,то по умолчанию оно совпадает с именем пользователя базы данных,что может быть правильно,а может и неправильно.</target>
        </trans-unit>
        <trans-unit id="fee1a6c055e42f40e71b91d8726649529647f66d" translate="yes" xml:space="preserve">
          <source>The datatype input function for type &lt;code&gt;boolean&lt;/code&gt; accepts these string representations for the &amp;ldquo;true&amp;rdquo; state:</source>
          <target state="translated">Функция ввода типа данных для типа &lt;code&gt;boolean&lt;/code&gt; принимает эти строковые представления для &amp;laquo;истинного&amp;raquo; состояния:</target>
        </trans-unit>
        <trans-unit id="ae4a7ff4b226f1bae5a99aaa421f3e1ec4a71979" translate="yes" xml:space="preserve">
          <source>The datatype output function for type &lt;code&gt;boolean&lt;/code&gt; always emits either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt;, as shown in &lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-EXAMPLE&quot;&gt;Example 8.2&lt;/a&gt;.</source>
          <target state="translated">Функция вывода типа данных для типа &lt;code&gt;boolean&lt;/code&gt; всегда выдает либо &lt;code&gt;t&lt;/code&gt; , либо &lt;code&gt;f&lt;/code&gt; , как показано в &lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-EXAMPLE&quot;&gt;примере 8.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cfcef52fd742ca2a7d47081e6367dac502e36ab" translate="yes" xml:space="preserve">
          <source>The date/time style can be selected by the user using the &lt;code&gt;SET datestyle&lt;/code&gt; command, the &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; parameter in the &lt;code&gt;postgresql.conf&lt;/code&gt; configuration file, or the &lt;code&gt;PGDATESTYLE&lt;/code&gt; environment variable on the server or client.</source>
          <target state="translated">Стиль даты / времени может быть выбран пользователем с помощью команды &lt;code&gt;SET datestyle&lt;/code&gt; , параметра &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; в файле конфигурации &lt;code&gt;postgresql.conf&lt;/code&gt; или &lt;code&gt;PGDATESTYLE&lt;/code&gt; среды PGDATESTYLE на сервере или клиенте.</target>
        </trans-unit>
        <trans-unit id="5d764ba10f260d8d4e8bfcd3a741fca678bd1d96" translate="yes" xml:space="preserve">
          <source>The day of the week as Monday (&lt;code&gt;1&lt;/code&gt;) to Sunday (&lt;code&gt;7&lt;/code&gt;)</source>
          <target state="translated">День недели с понедельника ( &lt;code&gt;1&lt;/code&gt; ) по воскресенье ( &lt;code&gt;7&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a891efc073ada13a5907f18625fe5fde82907c09" translate="yes" xml:space="preserve">
          <source>The day of the week as Sunday (&lt;code&gt;0&lt;/code&gt;) to Saturday (&lt;code&gt;6&lt;/code&gt;)</source>
          <target state="translated">День недели с воскресенья ( &lt;code&gt;0&lt;/code&gt; ) по субботу ( &lt;code&gt;6&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9ca4eefed78bdde53eebbe05d44c2b02c01e2924" translate="yes" xml:space="preserve">
          <source>The day of the year (1 - 365/366)</source>
          <target state="translated">День года (1-365/366)</target>
        </trans-unit>
        <trans-unit id="9a1fd8cf416c0db89c29a7999ef88f31189e883a" translate="yes" xml:space="preserve">
          <source>The day of the year (1&amp;ndash;365/366)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0c5380f15a2fcb247a4681d0ebeea27f30d33e" translate="yes" xml:space="preserve">
          <source>The daylight-savings transition &lt;code&gt;rule&lt;/code&gt; has the format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a9223278a724eaae749c9ac28592e80acca20f" translate="yes" xml:space="preserve">
          <source>The decrypted data and the decryption key are present on the server for a brief time while it is being decrypted and communicated between the client and server. This presents a brief moment where the data and keys can be intercepted by someone with complete access to the database server, such as the system administrator.</source>
          <target state="translated">Дешифрованные данные и ключ дешифрования находятся на сервере в течение короткого времени,пока они дешифруются и передаются между клиентом и сервером.Это представляет собой короткий момент,когда данные и ключи могут быть перехвачены кем-либо,имеющим полный доступ к серверу базы данных,например,системным администратором.</target>
        </trans-unit>
        <trans-unit id="0c0cddca1cd2a66e6ef93ce9c61b41178a127f6f" translate="yes" xml:space="preserve">
          <source>The deduplication process occurs lazily, when a new item is inserted that cannot fit on an existing leaf page. This prevents (or at least delays) leaf page splits. Unlike GIN posting list tuples, B-Tree posting list tuples do not need to expand every time a new duplicate is inserted; they are merely an alternative physical representation of the original logical contents of the leaf page. This design prioritizes consistent performance with mixed read-write workloads. Most client applications will at least see a moderate performance benefit from using deduplication. Deduplication is enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164046e431b6ca84db93b57b79867c4791c090cf" translate="yes" xml:space="preserve">
          <source>The default (and recommended) setting of &lt;a href=&quot;runtime-config-query#GUC-CONSTRAINT-EXCLUSION&quot;&gt;constraint_exclusion&lt;/a&gt; is neither &lt;code&gt;on&lt;/code&gt; nor &lt;code&gt;off&lt;/code&gt;, but an intermediate setting called &lt;code&gt;partition&lt;/code&gt;, which causes the technique to be applied only to queries that are likely to be working on inheritance partitioned tables. The &lt;code&gt;on&lt;/code&gt; setting causes the planner to examine &lt;code&gt;CHECK&lt;/code&gt; constraints in all queries, even simple ones that are unlikely to benefit.</source>
          <target state="translated">По умолчанию (и рекомендуемое) в &lt;a href=&quot;runtime-config-query#GUC-CONSTRAINT-EXCLUSION&quot;&gt;constraint_exclusion&lt;/a&gt; не является ни &lt;code&gt;on&lt;/code&gt; , ни &lt;code&gt;off&lt;/code&gt; , но промежуточный параметр называется &lt;code&gt;partition&lt;/code&gt; , который вызывает метод будет применяться только к запросам , которые, вероятно, будут работать на наследование распределяли таблицы. Параметр &lt;code&gt;on&lt;/code&gt; заставляет планировщик проверять ограничения &lt;code&gt;CHECK&lt;/code&gt; во всех запросах, даже в простых, которые вряд ли принесут пользу.</target>
        </trans-unit>
        <trans-unit id="1787e7e5cf03a442dbbaaa1d6af68edf6096b6e2" translate="yes" xml:space="preserve">
          <source>The default GIN operator class for &lt;code&gt;jsonb&lt;/code&gt; supports queries with top-level key-exists operators &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;?&amp;amp;&lt;/code&gt; and &lt;code&gt;?|&lt;/code&gt; operators and path/value-exists operator &lt;code&gt;@&amp;gt;&lt;/code&gt;. (For details of the semantics that these operators implement, see &lt;a href=&quot;functions-json#FUNCTIONS-JSONB-OP-TABLE&quot;&gt;Table 9.45&lt;/a&gt;.) An example of creating an index with this operator class is:</source>
          <target state="translated">Класс операторов GIN по умолчанию для &lt;code&gt;jsonb&lt;/code&gt; поддерживает запросы с операторами существования ключа верхнего уровня &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;?&amp;amp;&lt;/code&gt; и &lt;code&gt;?|&lt;/code&gt; операторы и оператор &quot;путь / значение существует&quot; &lt;code&gt;@&amp;gt;&lt;/code&gt; . (Подробнее о семантике, которую реализуют эти операторы, см. В &lt;a href=&quot;functions-json#FUNCTIONS-JSONB-OP-TABLE&quot;&gt;Таблице 9.45&lt;/a&gt; .) Пример создания индекса с помощью этого класса операторов:</target>
        </trans-unit>
        <trans-unit id="2eb60f012e323a27dd228ff40f13cdf0f9d72cff" translate="yes" xml:space="preserve">
          <source>The default IPC settings can be changed using the &lt;code&gt;sysctl&lt;/code&gt; or &lt;code&gt;loader&lt;/code&gt; interfaces. The following parameters can be set using &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="translated">Настройки IPC по умолчанию можно изменить с помощью интерфейсов &lt;code&gt;sysctl&lt;/code&gt; или &lt;code&gt;loader&lt;/code&gt; . Следующие параметры можно установить с помощью &lt;code&gt;sysctl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0939858e47c24e25aea8221bd11aa7efd06e7d2d" translate="yes" xml:space="preserve">
          <source>The default TPC-B-like transaction test requires specific tables to be set up beforehand. pgbench should be invoked with the &lt;code&gt;-i&lt;/code&gt; (initialize) option to create and populate these tables. (When you are testing a custom script, you don't need this step, but will instead need to do whatever setup your test needs.) Initialization looks like:</source>
          <target state="translated">Тест транзакции по умолчанию, подобный TPC-B, требует предварительной настройки определенных таблиц. Для создания и заполнения этих таблиц необходимо вызвать pgbench с параметром &lt;code&gt;-i&lt;/code&gt; (инициализировать). (Когда вы тестируете собственный сценарий, вам не нужен этот шаг, вместо этого вам нужно будет выполнить любую настройку, необходимую для вашего теста.) Инициализация выглядит так:</target>
        </trans-unit>
        <trans-unit id="1cd3fc8c960efc439298488cea62fca507ea8c64" translate="yes" xml:space="preserve">
          <source>The default behavior for huge pages in PostgreSQL is to use them when possible and to fall back to normal pages when failing. To enforce the use of huge pages, you can set &lt;a href=&quot;runtime-config-resource#GUC-HUGE-PAGES&quot;&gt;huge_pages&lt;/a&gt; to &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. Note that with this setting PostgreSQL will fail to start if not enough huge pages are available.</source>
          <target state="translated">Поведение по умолчанию для огромных страниц в PostgreSQL - использовать их, когда это возможно, и возвращаться к обычным страницам при сбое. Для того, чтобы обеспечить использование больших страниц, вы можете установить &lt;a href=&quot;runtime-config-resource#GUC-HUGE-PAGES&quot;&gt;huge_pages&lt;/a&gt; , чтобы &lt;code&gt;on&lt;/code&gt; в &lt;code&gt;postgresql.conf&lt;/code&gt; . Обратите внимание, что с этой настройкой PostgreSQL не запустится, если доступно недостаточно больших страниц.</target>
        </trans-unit>
        <trans-unit id="aaa5ded69b6418f38f6ec7a4670e3b4d29f7971b" translate="yes" xml:space="preserve">
          <source>The default behavior of recovery is to recover along the same timeline that was current when the base backup was taken. If you wish to recover into some child timeline (that is, you want to return to some state that was itself generated after a recovery attempt), you need to specify the target timeline ID in &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-TIMELINE&quot;&gt;recovery_target_timeline&lt;/a&gt;. You cannot recover into timelines that branched off earlier than the base backup.</source>
          <target state="translated">По умолчанию восстановление выполняется по той же временной шкале, которая была текущей на момент создания базовой резервной копии. Если вы хотите восстановить на некоторой дочерней временной шкале (то есть, вы хотите вернуться в какое-то состояние, которое само было создано после попытки восстановления), вам необходимо указать идентификатор целевой временной шкалы в &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-TIMELINE&quot;&gt;recovery_target_timeline&lt;/a&gt; . Вы не можете выполнить восстановление в сроки, разветвленные раньше, чем базовая резервная копия.</target>
        </trans-unit>
        <trans-unit id="3a7ad1055953cf587ab781a3bc1fc4c9129cc265" translate="yes" xml:space="preserve">
          <source>The default built-in transaction script (also invoked with &lt;code&gt;-b tpcb-like&lt;/code&gt;) issues seven commands per transaction over randomly chosen &lt;code&gt;aid&lt;/code&gt;, &lt;code&gt;tid&lt;/code&gt;, &lt;code&gt;bid&lt;/code&gt; and &lt;code&gt;delta&lt;/code&gt;. The scenario is inspired by the TPC-B benchmark, but is not actually TPC-B, hence the name.</source>
          <target state="translated">Встроенный сценарий транзакции по умолчанию (также вызываемый с помощью &lt;code&gt;-b tpcb-like&lt;/code&gt; ) выдает семь команд для каждой транзакции через случайно выбранные &lt;code&gt;aid&lt;/code&gt; , &lt;code&gt;tid&lt;/code&gt; , &lt;code&gt;bid&lt;/code&gt; и &lt;code&gt;delta&lt;/code&gt; . Сценарий основан на тесте TPC-B, но на самом деле это не TPC-B, отсюда и название.</target>
        </trans-unit>
        <trans-unit id="23125fde28fb9f59764dcf1b23a280a89053eb88" translate="yes" xml:space="preserve">
          <source>The default database privilege system allows database superusers to modify system catalogs using DML commands, and reference or modify toast tables. These operations are prohibited when &lt;code&gt;sepgsql&lt;/code&gt; is enabled.</source>
          <target state="translated">Система привилегий базы данных по умолчанию позволяет суперпользователям базы данных изменять системные каталоги с помощью команд DML, а также ссылаться или изменять всплывающие таблицы. Эти операции запрещены, если включен &lt;code&gt;sepgsql&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc78e0117d012c08a955c11c85e0b86286d746a5" translate="yes" xml:space="preserve">
          <source>The default expression will be used in any insert operation that does not specify a value for the column. If a default value is defined for a particular column, it overrides any default associated with the domain. In turn, the domain default overrides any default value associated with the underlying data type.</source>
          <target state="translated">Выражение по умолчанию будет использоваться в любой операции вставки,которая не задает значение для столбца.Если значение по умолчанию определено для конкретного столбца,оно перекрывает любое значение по умолчанию,связанное с доменом.В свою очередь,значение по умолчанию домена отменяет любое значение по умолчанию,связанное с типом данных,лежащих в основе.</target>
        </trans-unit>
        <trans-unit id="e924dec24aeaf46efa87502acfc94f6cc77685ce" translate="yes" xml:space="preserve">
          <source>The default expression will be used in any insert operation that does not specify a value for the column. If there is no default for a column, then the default is null.</source>
          <target state="translated">Выражение по умолчанию будет использоваться в любой операции вставки,которая не задает значение для столбца.Если для столбца нет значения по умолчанию,то значение по умолчанию равно нулю.</target>
        </trans-unit>
        <trans-unit id="5c475e2d48f46531de3913f26ad3045b4e6daa74" translate="yes" xml:space="preserve">
          <source>The default framing option is &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt;, which is the same as &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt;. With &lt;code&gt;ORDER BY&lt;/code&gt;, this sets the frame to be all rows from the partition start up through the current row's last &lt;code&gt;ORDER BY&lt;/code&gt; peer. Without &lt;code&gt;ORDER BY&lt;/code&gt;, this means all rows of the partition are included in the window frame, since all rows become peers of the current row.</source>
          <target state="translated">Опция кадрирования по умолчанию - &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt; , что совпадает с &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt; . С &lt;code&gt;ORDER BY&lt;/code&gt; это устанавливает в кадре все строки от запуска раздела до последнего &lt;code&gt;ORDER BY&lt;/code&gt; текущей строки . Без &lt;code&gt;ORDER BY&lt;/code&gt; это означает, что все строки раздела включены в рамку окна, поскольку все строки становятся равноправными в текущей строке.</target>
        </trans-unit>
        <trans-unit id="ab9ba2008544bbedbbd493b6d70ae946d72bc7ec" translate="yes" xml:space="preserve">
          <source>The default framing option is &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt;, which is the same as &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt;; it sets the frame to be all rows from the partition start up through the current row's last &lt;em&gt;peer&lt;/em&gt; (a row that the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause considers equivalent to the current row; all rows are peers if there is no &lt;code&gt;ORDER BY&lt;/code&gt;). In general, &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; means that the frame starts with the first row of the partition, and similarly &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; means that the frame ends with the last row of the partition, regardless of &lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;ROWS&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode. In &lt;code&gt;ROWS&lt;/code&gt; mode, &lt;code&gt;CURRENT ROW&lt;/code&gt; means that the frame starts or ends with the current row; but in &lt;code&gt;RANGE&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode it means that the frame starts or ends with the current row's first or last peer in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering. The &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; options vary in meaning depending on the frame mode. In &lt;code&gt;ROWS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; is an integer indicating that the frame starts or ends that many rows before or after the current row. In &lt;code&gt;GROUPS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; is an integer indicating that the frame starts or ends that many peer groups before or after the current row's peer group, where a &lt;em&gt;peer group&lt;/em&gt; is a group of rows that are equivalent according to the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause. In &lt;code&gt;RANGE&lt;/code&gt; mode, use of an &lt;code&gt;offset&lt;/code&gt; option requires that there be exactly one &lt;code&gt;ORDER BY&lt;/code&gt; column in the window definition. Then the frame contains those rows whose ordering column value is no more than &lt;code&gt;offset&lt;/code&gt; less than (for &lt;code&gt;PRECEDING&lt;/code&gt;) or more than (for &lt;code&gt;FOLLOWING&lt;/code&gt;) the current row's ordering column value. In these cases the data type of the &lt;code&gt;offset&lt;/code&gt; expression depends on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an &lt;code&gt;interval&lt;/code&gt;. In all these cases, the value of the &lt;code&gt;offset&lt;/code&gt; must be non-null and non-negative. Also, while the &lt;code&gt;offset&lt;/code&gt; does not have to be a simple constant, it cannot contain variables, aggregate functions, or window functions.</source>
          <target state="translated">Опция кадрирования по умолчанию - &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt; , что совпадает с &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt; ; он устанавливает в качестве кадра все строки от начала раздела до последнего &lt;em&gt;однорангового узла&lt;/em&gt; текущей строки (строка, которую предложение &lt;code&gt;ORDER BY&lt;/code&gt; окна считает эквивалентной текущей строке; все строки являются одноранговыми, если нет &lt;code&gt;ORDER BY&lt;/code&gt; ). В общем случае &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; означает, что кадр начинается с первой строки раздела, и аналогично &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; означает, что кадр заканчивается последней строкой раздела, независимо от &lt;code&gt;RANGE&lt;/code&gt; , &lt;code&gt;ROWS&lt;/code&gt; или &lt;code&gt;GROUPS&lt;/code&gt; .Режим. В режиме &lt;code&gt;ROWS&lt;/code&gt; &lt;code&gt;CURRENT ROW&lt;/code&gt; означает, что кадр начинается или заканчивается текущей строкой; но в режиме &lt;code&gt;RANGE&lt;/code&gt; или &lt;code&gt;GROUPS&lt;/code&gt; это означает, что кадр начинается или заканчивается первым или последним одноранговым &lt;code&gt;ORDER BY&lt;/code&gt; текущей строки в порядке ORDER BY . Параметры &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;PRECEDING&lt;/code&gt; и &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;FOLLOWING&lt;/code&gt; различаются по значению в зависимости от режима кадра. В режиме &lt;code&gt;ROWS&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; представляет собой целое число, указывающее, что кадр начинается или заканчивается на такое количество строк до или после текущей строки. В режиме &lt;code&gt;GROUPS&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; является целым числом, указывающим, что кадр начинается или заканчивается таким количеством одноранговых групп до или после одноранговой группы текущей строки, где &lt;em&gt;одноранговая группа&lt;/em&gt; - это группа строк, которые эквивалентны согласно предложению окна &lt;code&gt;ORDER BY&lt;/code&gt; . В режиме &lt;code&gt;RANGE&lt;/code&gt; для использования опции &lt;code&gt;offset&lt;/code&gt; требуется, чтобы в определении окна был ровно один столбец &lt;code&gt;ORDER BY&lt;/code&gt; . Затем фрейм содержит те строки, значение столбца упорядочивания которых не более чем &lt;code&gt;offset&lt;/code&gt; меньше (для &lt;code&gt;PRECEDING&lt;/code&gt; ) или больше (для &lt;code&gt;FOLLOWING&lt;/code&gt; ) значения столбца упорядочивания текущей строки. В этих случаях тип данных &lt;code&gt;offset&lt;/code&gt; выражение зависит от типа данных столбца упорядочивания. Для числовых столбцов упорядочения он обычно того же типа, что и столбец упорядочивания, но для столбцов упорядочивания по дате и &lt;code&gt;interval&lt;/code&gt; это интервал . Во всех этих случаях значение &lt;code&gt;offset&lt;/code&gt; должно быть ненулевым и неотрицательным. Кроме того, хотя &lt;code&gt;offset&lt;/code&gt; не обязательно должно быть простой константой, оно не может содержать переменные, агрегатные функции или оконные функции.</target>
        </trans-unit>
        <trans-unit id="02427aea9e6cc1534ffa5badcc166ebd495d7d99" translate="yes" xml:space="preserve">
          <source>The default initialization behavior uses client-side data generation (equivalent to &lt;code&gt;g&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585bb809ddf49c27ccd679a2aefbbe26ae6b7fc7" translate="yes" xml:space="preserve">
          <source>The default is 1 on supported systems, otherwise 0. This value can be overridden for tables in a particular tablespace by setting the tablespace parameter of the same name (see &lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt;).</source>
          <target state="translated">В поддерживаемых системах значение по умолчанию равно 1, в противном случае - 0. Это значение можно переопределить для таблиц в определенном табличном пространстве, установив параметр табличного пространства с тем же именем (см. &lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b428941637c56ecacd6f3388f30af9a9f66c9397" translate="yes" xml:space="preserve">
          <source>The default is 10 on supported systems, otherwise 0. This value can be overridden for tables in a particular tablespace by setting the tablespace parameter of the same name (see &lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91abeb434a6ce9f069e1f28ad61aa04fc26c2bb" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;+&lt;/code&gt; on Unix systems (corresponding to the default editor &lt;code&gt;vi&lt;/code&gt;, and useful for many other common editors); but there is no default on Windows systems.</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;+&lt;/code&gt; в системах Unix (соответствует редактору по умолчанию &lt;code&gt;vi&lt;/code&gt; и полезно для многих других распространенных редакторов); но в системах Windows по умолчанию нет.</target>
        </trans-unit>
        <trans-unit id="20bd35f00ae043441f0cf7d67ea091592c87a851" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;CONTENT&lt;/code&gt;, so all forms of XML data are allowed.</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;CONTENT&lt;/code&gt; , поэтому разрешены все формы XML-данных.</target>
        </trans-unit>
        <trans-unit id="a9030ed63211ad93fd21a5052bbbc9ec44c66fe7" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;TLSv1.2&lt;/code&gt;, which satisfies industry best practices as of this writing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="520d36bf5a7163373f8a236d77b263a2c0a04d44" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;TLSv1&lt;/code&gt;, mainly to support older versions of the OpenSSL library. You might want to set this to a higher value if all software components can support the newer protocol versions.</source>
          <target state="translated">По умолчанию используется &lt;code&gt;TLSv1&lt;/code&gt; , в основном для поддержки старых версий библиотеки OpenSSL. Вы можете установить более высокое значение, если все программные компоненты могут поддерживать более новые версии протокола.</target>
        </trans-unit>
        <trans-unit id="231c42f70ffe5e8ab4244e5bdc8f6dbabaa3b107" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;none&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">По умолчанию &lt;code&gt;none&lt;/code&gt; . Только суперпользователи могут изменять этот параметр.</target>
        </trans-unit>
        <trans-unit id="bd107bd07370addfaeb12f86e3bf6c56137f5dc1" translate="yes" xml:space="preserve">
          <source>The default is simple query protocol. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;Chapter 52&lt;/a&gt; for more information.)</source>
          <target state="translated">По умолчанию используется простой протокол запросов. (См. &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;Главу 52&lt;/a&gt; для получения дополнительной информации.)</target>
        </trans-unit>
        <trans-unit id="4a4b29d9014d7b5f69a6f2afb601d3ce7d3550d2" translate="yes" xml:space="preserve">
          <source>The default is simple query protocol. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol.html&quot;&gt;Chapter 52&lt;/a&gt; for more information.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f72dd6acfbb83ab51b40e408e5dc009e36a5da" translate="yes" xml:space="preserve">
          <source>The default maximum segment size is 32 MB, and the default maximum total size is 2097152 pages. A page is almost always 4096 bytes except in unusual kernel configurations with &amp;ldquo;huge pages&amp;rdquo; (use &lt;code&gt;getconf PAGE_SIZE&lt;/code&gt; to verify).</source>
          <target state="translated">Максимальный размер сегмента по умолчанию составляет 32 МБ, а максимальный общий размер по умолчанию - 2097152 страницы. Страница почти всегда &lt;code&gt;getconf PAGE_SIZE&lt;/code&gt; 4096 байт, за исключением необычных конфигураций ядра с &amp;laquo;огромными страницами&amp;raquo; ( для проверки используйте getconf PAGE_SIZE ).</target>
        </trans-unit>
        <trans-unit id="d525664dcf3bd05b109fdf34118093a16b891bcb" translate="yes" xml:space="preserve">
          <source>The default permissions are &lt;code&gt;0600&lt;/code&gt;, meaning only the server owner can read or write the log files. The other commonly useful setting is &lt;code&gt;0640&lt;/code&gt;, allowing members of the owner's group to read the files. Note however that to make use of such a setting, you'll need to alter &lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt; to store the files somewhere outside the cluster data directory. In any case, it's unwise to make the log files world-readable, since they might contain sensitive data.</source>
          <target state="translated">Разрешения по умолчанию - &lt;code&gt;0600&lt;/code&gt; , что означает, что только владелец сервера может читать или записывать файлы журнала. Другой часто используемый параметр - &lt;code&gt;0640&lt;/code&gt; , позволяющий членам группы владельца читать файлы. Однако обратите внимание, что для использования такой настройки вам необходимо изменить &lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt; для хранения файлов где-то за пределами каталога данных кластера. В любом случае неразумно делать файлы журнала общедоступными, поскольку они могут содержать конфиденциальные данные.</target>
        </trans-unit>
        <trans-unit id="d2132a47fb8ed97625d8e6972b86c9c464704580" translate="yes" xml:space="preserve">
          <source>The default permissions are &lt;code&gt;0777&lt;/code&gt;, meaning anyone can connect. Reasonable alternatives are &lt;code&gt;0770&lt;/code&gt; (only user and group, see also &lt;code&gt;unix_socket_group&lt;/code&gt;) and &lt;code&gt;0700&lt;/code&gt; (only user). (Note that for a Unix-domain socket, only write permission matters, so there is no point in setting or revoking read or execute permissions.)</source>
          <target state="translated">Разрешения по умолчанию - &lt;code&gt;0777&lt;/code&gt; , что означает, что любой может подключиться. Разумные альтернативы: &lt;code&gt;0770&lt;/code&gt; (только пользователь и группа, см. Также &lt;code&gt;unix_socket_group&lt;/code&gt; ) и &lt;code&gt;0700&lt;/code&gt; (только пользователь). (Обратите внимание, что для сокета домена Unix имеет значение только разрешение на запись, поэтому нет смысла устанавливать или отзывать разрешения на чтение или выполнение.)</target>
        </trans-unit>
        <trans-unit id="68b85b4979bd5c75a82926a217579dec94acad6f" translate="yes" xml:space="preserve">
          <source>The default roles are described in &lt;a href=&quot;default-roles#DEFAULT-ROLES-TABLE&quot;&gt;Table 21.1&lt;/a&gt;. Note that the specific permissions for each of the default roles may change in the future as additional capabilities are added. Administrators should monitor the release notes for changes.</source>
          <target state="translated">Роли по умолчанию описаны в &lt;a href=&quot;default-roles#DEFAULT-ROLES-TABLE&quot;&gt;Таблице 21.1&lt;/a&gt; . Обратите внимание, что конкретные разрешения для каждой из ролей по умолчанию могут измениться в будущем по мере добавления дополнительных возможностей. Администраторы должны следить за изменениями в примечаниях к выпуску.</target>
        </trans-unit>
        <trans-unit id="252df4a98d09d9259c2e1911dffde240009cf803" translate="yes" xml:space="preserve">
          <source>The default set of collations provided by &lt;code&gt;libc&lt;/code&gt; map directly to the locales installed in the operating system, which can be listed using the command &lt;code&gt;locale -a&lt;/code&gt;. In case a &lt;code&gt;libc&lt;/code&gt; collation is needed that has different values for &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;, or if new locales are installed in the operating system after the database system was initialized, then a new collation may be created using the &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; command. New operating system locales can also be imported en masse using the &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-COLLATION&quot;&gt;&lt;code&gt;pg_import_system_collations()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Набор параметров сортировки по умолчанию, предоставляемый &lt;code&gt;libc&lt;/code&gt; , сопоставляется непосредственно с &lt;code&gt;locale -a&lt;/code&gt; установленными в операционной системе, которые можно указать с помощью команды locale -a . Если требуется сопоставление &lt;code&gt;libc&lt;/code&gt; , которое имеет разные значения для &lt;code&gt;LC_COLLATE&lt;/code&gt; и &lt;code&gt;LC_CTYPE&lt;/code&gt; , или если новые языковые стандарты установлены в операционной системе после инициализации системы баз данных, то новое сопоставление можно создать с помощью команды &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; . Новые &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-COLLATION&quot;&gt; &lt;code&gt;pg_import_system_collations()&lt;/code&gt; &lt;/a&gt; операционной системы также можно массово импортировать с помощью функции pg_import_system_collations () .</target>
        </trans-unit>
        <trans-unit id="bd6c5d1d773597e919f54fc6c40b0813dfeb2846" translate="yes" xml:space="preserve">
          <source>The default settings tend to suffice for normal installations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa3c32f18b7a363e1e30df22bf5f90a31fa97a8" translate="yes" xml:space="preserve">
          <source>The default settings tend to suffice for normal installations. On HP-UX 10, the factory default for &lt;code&gt;SEMMNS&lt;/code&gt; is 128, which might be too low for larger database sites.</source>
          <target state="translated">Для обычных установок обычно достаточно настроек по умолчанию. В HP-UX 10 заводское значение по умолчанию для &lt;code&gt;SEMMNS&lt;/code&gt; - 128, что может быть слишком низким для больших сайтов баз данных.</target>
        </trans-unit>
        <trans-unit id="387f794e89c6e468e480bdf4684dee520f1e3ee6" translate="yes" xml:space="preserve">
          <source>The default shared memory and semaphore settings are usually good enough for most PostgreSQL applications. Solaris defaults to a &lt;code&gt;SHMMAX&lt;/code&gt; of one-quarter of system RAM. To further adjust this setting, use a project setting associated with the &lt;code&gt;postgres&lt;/code&gt; user. For example, run the following as &lt;code&gt;root&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f84f4a393cffab388bec3988211dd06baa8b6f3" translate="yes" xml:space="preserve">
          <source>The default shared memory and semaphore settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8182b5b7aff519b85fd1a2180f16c9dae4671198" translate="yes" xml:space="preserve">
          <source>The default shared memory settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;, and even then only on older kernel versions that shipped with low defaults. System V semaphores are not used on this platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb304375b17e288f6f388651b3f58cf692da39fb" translate="yes" xml:space="preserve">
          <source>The default shared memory settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;. System V semaphores are not used on this platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4af5ef9d1d5b1be0577de1bcf13eca580f5485e" translate="yes" xml:space="preserve">
          <source>The default shared memory settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;. You will usually want to increase &lt;code&gt;kern.ipc.semmni&lt;/code&gt; and &lt;code&gt;kern.ipc.semmns&lt;/code&gt;, as NetBSD's default settings for these are uncomfortably small.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5adefc1dbffba745f0ea181ce26972df7feee97e" translate="yes" xml:space="preserve">
          <source>The default shared memory settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;. You will usually want to increase &lt;code&gt;kern.seminfo.semmni&lt;/code&gt; and &lt;code&gt;kern.seminfo.semmns&lt;/code&gt;, as OpenBSD's default settings for these are uncomfortably small.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e22ca1caa169ea01c4c21799c6c36ccb13234f" translate="yes" xml:space="preserve">
          <source>The default tablespace for the database. Within this database, all tables for which &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltablespace&lt;/code&gt; is zero will be stored in this tablespace; in particular, all the non-shared system catalogs will be there.</source>
          <target state="translated">Табличное пространство по умолчанию для базы данных. В этой базе данных все таблицы, для которых &lt;code&gt;pg_class&lt;/code&gt; . &lt;code&gt;reltablespace&lt;/code&gt; , равный нулю, будет сохранен в этом табличном пространстве; в частности, там будут все необщие системные каталоги.</target>
        </trans-unit>
        <trans-unit id="80289ade38539d0a5fbe52bfa6a8f6f1dac442e4" translate="yes" xml:space="preserve">
          <source>The default test scenario is also quite sensitive to how long it's been since the tables were initialized: accumulation of dead rows and dead space in the tables changes the results. To understand the results you must keep track of the total number of updates and when vacuuming happens. If autovacuum is enabled it can result in unpredictable changes in measured performance.</source>
          <target state="translated">Тестовый сценарий по умолчанию также достаточно чувствителен к тому,сколько времени прошло с момента инициализации таблиц:накопление мертвых строк и мертвого пространства в таблицах меняет результаты.Чтобы понять результаты,вы должны следить за общим количеством обновлений и за тем,когда происходит вакуумирование.Если включена функция автоматического вакуумирования,это может привести к непредсказуемым изменениям в измеряемой производительности.</target>
        </trans-unit>
        <trans-unit id="9132263848d1108e0d8602af59d87e147d73248d" translate="yes" xml:space="preserve">
          <source>The default thresholds and scale factors are taken from &lt;code&gt;postgresql.conf&lt;/code&gt;, but it is possible to override them (and many other autovacuum control parameters) on a per-table basis; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. If a setting has been changed via a table's storage parameters, that value is used when processing that table; otherwise the global settings are used. See &lt;a href=&quot;runtime-config-autovacuum&quot;&gt;Section 19.10&lt;/a&gt; for more details on the global settings.</source>
          <target state="translated">Пороговые значения и коэффициенты масштабирования по умолчанию взяты из &lt;code&gt;postgresql.conf&lt;/code&gt; , но их можно переопределить (и многие другие параметры управления автоочисткой) для каждой таблицы; см. &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Параметры хранения&lt;/a&gt; для получения дополнительной информации. Если настройка была изменена через параметры хранения таблицы, это значение используется при обработке этой таблицы; в противном случае используются глобальные настройки. См. &lt;a href=&quot;runtime-config-autovacuum&quot;&gt;Раздел 19.10&lt;/a&gt; для получения более подробной информации о глобальных настройках.</target>
        </trans-unit>
        <trans-unit id="0424e3dc5096d9c8dbd34cb8d06e5315c54e045d" translate="yes" xml:space="preserve">
          <source>The default time zone is specified as a constant numeric offset from UTC. It is therefore impossible to adapt to daylight-saving time when doing date/time arithmetic across DST boundaries.</source>
          <target state="translated">Часовой пояс по умолчанию указан как постоянное числовое смещение от UTC.Поэтому невозможно адаптироваться к летнему времени при выполнении арифметики даты/времени через границы DST.</target>
        </trans-unit>
        <trans-unit id="cfbfb39fe00c30f34ca2449d77325fd4667682f6" translate="yes" xml:space="preserve">
          <source>The default timing of the trigger. See the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for details of these constraint options. This can only be specified for constraint triggers.</source>
          <target state="translated">Время срабатывания триггера по умолчанию. См. Документацию &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; для получения подробной информации об этих параметрах ограничения. Это можно указать только для триггеров ограничения.</target>
        </trans-unit>
        <trans-unit id="d7cc14aa1c7871e1d91e9c6189dd189cdc4b1317" translate="yes" xml:space="preserve">
          <source>The default value can be an expression, which will be evaluated whenever the default value is inserted (&lt;em&gt;not&lt;/em&gt; when the table is created). A common example is for a &lt;code&gt;timestamp&lt;/code&gt; column to have a default of &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, so that it gets set to the time of row insertion. Another common example is generating a &amp;ldquo;serial number&amp;rdquo; for each row. In PostgreSQL this is typically done by something like:</source>
          <target state="translated">Значение по умолчанию может быть выражением, которое будет вычисляться всякий раз, когда будет вставлено значение по умолчанию (а &lt;em&gt;не&lt;/em&gt; при создании таблицы). Типичный пример - для столбца с &lt;code&gt;timestamp&lt;/code&gt; по умолчанию &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; , чтобы он был установлен на время вставки строки. Другой распространенный пример - создание &amp;laquo;серийного номера&amp;raquo; для каждой строки. В PostgreSQL это обычно делается примерно так:</target>
        </trans-unit>
        <trans-unit id="0b0db30e831b0c9d520dd21139ba84ee034c9c6b" translate="yes" xml:space="preserve">
          <source>The default value for the data type. If this is omitted, the default is null.</source>
          <target state="translated">Значение по умолчанию для типа данных.Если оно опущено,то значение по умолчанию равно нулю.</target>
        </trans-unit>
        <trans-unit id="ee14fce3a3ca851f605a2ff7d5b6a51a01fb240b" translate="yes" xml:space="preserve">
          <source>The default value for this parameter is &lt;code&gt;&quot;$user&quot;, public&lt;/code&gt;. This setting supports shared use of a database (where no users have private schemas, and all share use of &lt;code&gt;public&lt;/code&gt;), private per-user schemas, and combinations of these. Other effects can be obtained by altering the default search path setting, either globally or per-user.</source>
          <target state="translated">Значение по умолчанию для этого параметра - &lt;code&gt;&quot;$user&quot;, public&lt;/code&gt; . Этот параметр поддерживает совместное использование базы данных (где ни у одного пользователя нет частных схем, а все совместно используют &lt;code&gt;public&lt;/code&gt; ), частные схемы для каждого пользователя и их комбинации. Другие эффекты можно получить, изменив настройку пути поиска по умолчанию, глобально или для каждого пользователя.</target>
        </trans-unit>
        <trans-unit id="85d16eca710f45efd17caf29c22cdac95ac6757a" translate="yes" xml:space="preserve">
          <source>The default value for this parameter is &lt;code&gt;'$libdir'&lt;/code&gt;. If the value is set to an empty string, the automatic path search is turned off.</source>
          <target state="translated">Значение по умолчанию для этого параметра - &lt;code&gt;'$libdir'&lt;/code&gt; . Если задано значение пустой строки, автоматический поиск пути отключен.</target>
        </trans-unit>
        <trans-unit id="71d008eed3fec13080aed7c6d124a51c1f2df8b8" translate="yes" xml:space="preserve">
          <source>The default value is 2.</source>
          <target state="translated">Значение по умолчанию равно 2.</target>
        </trans-unit>
        <trans-unit id="d8e9c33db68a29a970a8558f211b5f4b07ef1edd" translate="yes" xml:space="preserve">
          <source>The default value is 4.</source>
          <target state="translated">Значение по умолчанию равно 4.</target>
        </trans-unit>
        <trans-unit id="65c175fa9341b5e979c73accbe6240cd619cd0dc" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;error=01;31:warning=01;35:locus=01&lt;/code&gt; (&lt;code&gt;01;31&lt;/code&gt; = bold red, &lt;code&gt;01;35&lt;/code&gt; = bold magenta, &lt;code&gt;01&lt;/code&gt; = bold default color).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca161bfe7f68575f9b78d9b22cc20c4f61990ca6" translate="yes" xml:space="preserve">
          <source>The default value is an empty string, which results in all temporary objects being created in the default tablespace of the current database.</source>
          <target state="translated">Значение по умолчанию-пустая строка,в результате чего все временные объекты создаются в табличном пространстве текущей БД по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2dbc96deb9627171cbe40ca7523d55ca78505616" translate="yes" xml:space="preserve">
          <source>The default value is defined as the value that the parameter would have had, if no &lt;code&gt;SET&lt;/code&gt; had ever been issued for it in the current session. The actual source of this value might be a compiled-in default, the configuration file, command-line options, or per-database or per-user default settings. This is subtly different from defining it as &amp;ldquo;the value that the parameter had at session start&amp;rdquo;, because if the value came from the configuration file, it will be reset to whatever is specified by the configuration file now. See &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for details.</source>
          <target state="translated">Значение по умолчанию определяется как значение, которое параметр имел бы, если бы для него никогда не было выдано &lt;code&gt;SET&lt;/code&gt; в текущем сеансе. Фактическим источником этого значения может быть скомпилированный файл по умолчанию, файл конфигурации, параметры командной строки или настройки по умолчанию для каждой базы данных или пользователя. Это немного отличается от определения его как &amp;laquo;значения, которое параметр имел при запуске сеанса&amp;raquo;, потому что, если значение было получено из файла конфигурации, оно будет сброшено на то, что сейчас указано в файле конфигурации. См. Подробности в &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;главе 19&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04f2d094b00a5be29b7b3b7af554f26ca4e00d68" translate="yes" xml:space="preserve">
          <source>The default value is defined as the value that the parameter would have had, if no &lt;code&gt;SET&lt;/code&gt; had ever been issued for it in the current session. The actual source of this value might be a compiled-in default, the configuration file, command-line options, or per-database or per-user default settings. This is subtly different from defining it as &amp;ldquo;the value that the parameter had at session start&amp;rdquo;, because if the value came from the configuration file, it will be reset to whatever is specified by the configuration file now. See &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7169dc9a643791bfe51c929b266f11a33c289429" translate="yes" xml:space="preserve">
          <source>The default value is three connections. The value must be less than &lt;code&gt;max_connections&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">Значение по умолчанию - три соединения. Значение должно быть меньше &lt;code&gt;max_connections&lt;/code&gt; . Этот параметр можно установить только при запуске сервера.</target>
        </trans-unit>
        <trans-unit id="72f22d9e98b0402b3ffa342734437db31335a193" translate="yes" xml:space="preserve">
          <source>The default value of this setting is the empty string, which disables the feature. It can be set to &lt;code&gt;all&lt;/code&gt; to check all records, or to a comma-separated list of resource managers to check only records originating from those resource managers. Currently, the supported resource managers are &lt;code&gt;heap&lt;/code&gt;, &lt;code&gt;heap2&lt;/code&gt;, &lt;code&gt;btree&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;gin&lt;/code&gt;, &lt;code&gt;gist&lt;/code&gt;, &lt;code&gt;sequence&lt;/code&gt;, &lt;code&gt;spgist&lt;/code&gt;, &lt;code&gt;brin&lt;/code&gt;, and &lt;code&gt;generic&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">Значение по умолчанию для этого параметра - пустая строка, которая отключает функцию. Его можно установить на &lt;code&gt;all&lt;/code&gt; чтобы проверять все записи, или на список менеджеров ресурсов, разделенных запятыми, чтобы проверять только записи, исходящие от этих менеджеров ресурсов. В настоящее время поддерживаются менеджерами ресурсов являются &lt;code&gt;heap&lt;/code&gt; , &lt;code&gt;heap2&lt;/code&gt; , &lt;code&gt;btree&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;gin&lt;/code&gt; , &lt;code&gt;gist&lt;/code&gt; , &lt;code&gt;sequence&lt;/code&gt; , &lt;code&gt;spgist&lt;/code&gt; , &lt;code&gt;brin&lt;/code&gt; и &lt;code&gt;generic&lt;/code&gt; . Только суперпользователи могут изменять этот параметр.</target>
        </trans-unit>
        <trans-unit id="20ab73f20d81504384efda8f5568618702ec519f" translate="yes" xml:space="preserve">
          <source>The default virtual memory behavior on Linux is not optimal for PostgreSQL. Because of the way that the kernel implements memory overcommit, the kernel might terminate the PostgreSQL postmaster (the master server process) if the memory demands of either PostgreSQL or another process cause the system to run out of virtual memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9068090248fdb711a8f2a412ca5077ebbda170" translate="yes" xml:space="preserve">
          <source>The defined collation of the column, or zero if the column is not of a collatable data type.</source>
          <target state="translated">Определенная коллакция столбца,или ноль,если столбец не имеет коллатируемого типа данных.</target>
        </trans-unit>
        <trans-unit id="b0e121be440089b477e6ea25c5d7cb8d2a246664" translate="yes" xml:space="preserve">
          <source>The definitions of the columns exposed by the view are shown in &lt;a href=&quot;pgbuffercache#PGBUFFERCACHE-COLUMNS&quot;&gt;Table F.15&lt;/a&gt;.</source>
          <target state="translated">Определения столбцов, отображаемых в представлении, показаны в &lt;a href=&quot;pgbuffercache#PGBUFFERCACHE-COLUMNS&quot;&gt;таблице F.15&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8c0177656a1475222b9e9f01f048f945368cb6d" translate="yes" xml:space="preserve">
          <source>The delay occurs once the database in recovery has reached a consistent state, until the standby is promoted or triggered. After that the standby will end recovery without further waiting.</source>
          <target state="translated">Задержка возникает после того,как база данных в процессе восстановления достигла стабильного состояния,до тех пор,пока не повысится или не сработает режим ожидания.После этого режим ожидания завершает восстановление без дальнейшего ожидания.</target>
        </trans-unit>
        <trans-unit id="37c54600b84522926deb2fb64ab7c8c51ddae0fc" translate="yes" xml:space="preserve">
          <source>The delay occurs only on WAL records for transaction commits. Other records are replayed as quickly as possible, which is not a problem because MVCC visibility rules ensure their effects are not visible until the corresponding commit record is applied.</source>
          <target state="translated">Задержка происходит только на записях WAL для фиксации транзакций.Остальные записи воспроизводятся как можно быстрее,что не является проблемой,так как правила видимости MVCC гарантируют,что их эффекты не будут видны до тех пор,пока не будет применена соответствующая запись коммита.</target>
        </trans-unit>
        <trans-unit id="790720978a39aefa71d264470fa610449c099e01" translate="yes" xml:space="preserve">
          <source>The delimiter character to be used between values in arrays made of this type.</source>
          <target state="translated">Разделительный символ,который будет использоваться между значениями в массивах данного типа.</target>
        </trans-unit>
        <trans-unit id="e3f72476c5f4c3f27d14849d70a712b70cac2da9" translate="yes" xml:space="preserve">
          <source>The dependent object can be dropped separately from the referenced object, and should be automatically dropped (regardless of &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; mode) if the referenced object is dropped. Example: a named constraint on a table is made auto-dependent on the table, so that it will go away if the table is dropped.</source>
          <target state="translated">Зависимый объект может быть удален отдельно от объекта, на который имеется ссылка, и должен автоматически удаляться (независимо от режима &lt;code&gt;RESTRICT&lt;/code&gt; или &lt;code&gt;CASCADE&lt;/code&gt; ), если объект, на который указывает ссылка, удаляется. Пример: именованное ограничение таблицы становится автоматически зависимым от таблицы, поэтому оно исчезнет, ​​если таблица будет отброшена.</target>
        </trans-unit>
        <trans-unit id="42b52b99ac2341cf62bd00d9b5e1bc3f8c4f0ef2" translate="yes" xml:space="preserve">
          <source>The dependent object is a member of the &lt;em&gt;extension&lt;/em&gt; that is the referenced object (see &lt;a href=&quot;catalog-pg-extension&quot;&gt;&lt;code&gt;pg_extension&lt;/code&gt;&lt;/a&gt;). The dependent object can be dropped only via &lt;code&gt;DROP EXTENSION&lt;/code&gt; on the referenced object. Functionally this dependency type acts the same as an &lt;code&gt;INTERNAL&lt;/code&gt; dependency, but it's kept separate for clarity and to simplify pg_dump.</source>
          <target state="translated">Зависимый объект является членом &lt;em&gt;расширения,&lt;/em&gt; которое является объектом ссылки (см. &lt;a href=&quot;catalog-pg-extension&quot;&gt; &lt;code&gt;pg_extension&lt;/code&gt; &lt;/a&gt; ). Зависимый объект может быть удален только с помощью &lt;code&gt;DROP EXTENSION&lt;/code&gt; на указанном объекте. Функционально этот тип зависимости действует так же, как и &lt;code&gt;INTERNAL&lt;/code&gt; зависимость, но для ясности и упрощения pg_dump сохраняется отдельно.</target>
        </trans-unit>
        <trans-unit id="bf57c8a0f5e570bb9686592bde8b3b28f101a435" translate="yes" xml:space="preserve">
          <source>The dependent object is not a member of the extension that is the referenced object (and so it should not be ignored by pg_dump), but it cannot function without the extension and should be auto-dropped if the extension is. The dependent object may be dropped on its own as well. Functionally this dependency type acts the same as an &lt;code&gt;AUTO&lt;/code&gt; dependency, but it's kept separate for clarity and to simplify pg_dump.</source>
          <target state="translated">Зависимый объект не является членом расширения, на которое ссылается объект (и поэтому он не должен игнорироваться pg_dump), но он не может работать без расширения и должен быть автоматически удален, если расширение есть. Зависимый объект также может быть удален сам по себе. Функционально этот тип зависимости действует так же, как и зависимость &lt;code&gt;AUTO&lt;/code&gt; , но для ясности и упрощения pg_dump сохраняется отдельно.</target>
        </trans-unit>
        <trans-unit id="39aa74188fe1f062ac474926c65191d5babb5508" translate="yes" xml:space="preserve">
          <source>The dependent object was created as part of creation of the referenced object, and is really just a part of its internal implementation. A direct &lt;code&gt;DROP&lt;/code&gt; of the dependent object will be disallowed outright (we'll tell the user to issue a &lt;code&gt;DROP&lt;/code&gt; against the referenced object, instead). A &lt;code&gt;DROP&lt;/code&gt; of the referenced object will result in automatically dropping the dependent object whether &lt;code&gt;CASCADE&lt;/code&gt; is specified or not. If the dependent object has to be dropped due to a dependency on some other object being removed, its drop is converted to a drop of the referenced object, so that &lt;code&gt;NORMAL&lt;/code&gt; and &lt;code&gt;AUTO&lt;/code&gt; dependencies of the dependent object behave much like they were dependencies of the referenced object. Example: a view's &lt;code&gt;ON SELECT&lt;/code&gt; rule is made internally dependent on the view, preventing it from being dropped while the view remains. Dependencies of the rule (such as tables it refers to) act as if they were dependencies of the view.</source>
          <target state="translated">Зависимый объект был создан как часть создания объекта, на который имеется ссылка, и на самом деле является лишь частью его внутренней реализации. Прямое &lt;code&gt;DROP&lt;/code&gt; зависимого объекта будет сразу запрещено ( вместо этого мы скажем пользователю выполнить &lt;code&gt;DROP&lt;/code&gt; для указанного объекта). &lt;code&gt;DROP&lt;/code&gt; ссылочного объекта приведет автоматически понижая зависимый объект является ли &lt;code&gt;CASCADE&lt;/code&gt; указан или нет. Если зависимый объект должен быть удален из-за зависимости от какого-либо другого удаляемого объекта, его отбрасывание преобразуется в отбрасывание указанного объекта, так что &lt;code&gt;NORMAL&lt;/code&gt; и &lt;code&gt;AUTO&lt;/code&gt; зависимости зависимого объекта ведут себя так же, как и зависимости объекта, на который имеется ссылка. Пример: правило &lt;code&gt;ON SELECT&lt;/code&gt; представления становится внутренне зависимым от представления, предотвращая его удаление, пока представление остается. Зависимости правила (например, таблицы, на которые оно ссылается) действуют так, как если бы они были зависимостями представления.</target>
        </trans-unit>
        <trans-unit id="6f08ad4e0433fd5acac3297aba03b2acf8ab1183" translate="yes" xml:space="preserve">
          <source>The dependent object was created as part of creation of the referenced object, and is really just a part of its internal implementation; however, unlike &lt;code&gt;INTERNAL&lt;/code&gt;, there is more than one such referenced object. The dependent object must not be dropped unless at least one of these referenced objects is dropped; if any one is, the dependent object should be dropped whether or not &lt;code&gt;CASCADE&lt;/code&gt; is specified. Also unlike &lt;code&gt;INTERNAL&lt;/code&gt;, a drop of some other object that the dependent object depends on does not result in automatic deletion of any partition-referenced object. Hence, if the drop does not cascade to at least one of these objects via some other path, it will be refused. (In most cases, the dependent object shares all its non-partition dependencies with at least one partition-referenced object, so that this restriction does not result in blocking any cascaded delete.) Primary and secondary partition dependencies behave identically except that the primary dependency is preferred for use in error messages; hence, a partition-dependent object should have one primary partition dependency and one or more secondary partition dependencies. Note that partition dependencies are made in addition to, not instead of, any dependencies the object would normally have. This simplifies &lt;code&gt;ATTACH/DETACH PARTITION&lt;/code&gt; operations: the partition dependencies need only be added or removed. Example: a child partitioned index is made partition-dependent on both the partition table it is on and the parent partitioned index, so that it goes away if either of those is dropped, but not otherwise. The dependency on the parent index is primary, so that if the user tries to drop the child partitioned index, the error message will suggest dropping the parent index instead (not the table).</source>
          <target state="translated">Зависимый объект был создан как часть создания объекта, на который имеется ссылка, и на самом деле является лишь частью его внутренней реализации; однако, в отличие от &lt;code&gt;INTERNAL&lt;/code&gt; , существует более одного такого ссылочного объекта. Зависимый объект нельзя отбрасывать, пока не будет удален хотя бы один из этих ссылочных объектов; если есть, зависимый объект должен быть отброшен независимо от того, указан ли &lt;code&gt;CASCADE&lt;/code&gt; . Также в отличие от &lt;code&gt;INTERNAL&lt;/code&gt; , удаление какого-либо другого объекта, от которого зависит зависимый объект, не приводит к автоматическому удалению любого объекта, на который ссылается секция. Следовательно, если перетаскивание не передается каскадом хотя бы к одному из этих объектов по другому пути, оно будет отклонено. (В большинстве случаев зависимый объект разделяет все свои зависимости, не относящиеся к разделу, по крайней мере, с одним объектом, на который ссылается раздел, так что это ограничение не приводит к блокированию любого каскадного удаления.) Зависимости основного и дополнительного разделов ведут себя одинаково, за исключением того, что основная зависимость предпочтительнее использовать в сообщениях об ошибках; следовательно, объект, зависящий от раздела, должен иметь одну зависимость основного раздела и одну или несколько зависимостей дополнительного раздела. Обратите внимание, что зависимости секций создаются в дополнение к любым зависимостям, которые обычно имеют объект, а не вместо них.Это упрощает &lt;code&gt;ATTACH/DETACH PARTITION&lt;/code&gt; Операции ATTACH / DETACH PARTITION : нужно только добавить или удалить зависимости разделов. Пример: дочерний многораздельный индекс становится зависимым от разделов как от таблицы разделов, в которой он находится, так и от родительского многораздельного индекса, поэтому он исчезает, если один из них отбрасывается, но не в противном случае. Зависимость от родительского индекса является первичной, поэтому, если пользователь попытается удалить дочерний многораздельный индекс, в сообщении об ошибке будет предложено удалить родительский индекс (а не таблицу).</target>
        </trans-unit>
        <trans-unit id="7ba979debfd87ef975dc568dd7e8792b4269670b" translate="yes" xml:space="preserve">
          <source>The desired new version of the extension. This can be written as either an identifier or a string literal. If not specified, &lt;code&gt;ALTER EXTENSION UPDATE&lt;/code&gt; attempts to update to whatever is shown as the default version in the extension's control file.</source>
          <target state="translated">Желаемая новая версия расширения. Это может быть записано как идентификатор или строковый литерал. Если не указано, &lt;code&gt;ALTER EXTENSION UPDATE&lt;/code&gt; пытается выполнить обновление до того, что показано как версия по умолчанию в управляющем файле расширения.</target>
        </trans-unit>
        <trans-unit id="fbd0e34ca3a19b97d0aeb9f0e2c89bbf73246c51" translate="yes" xml:space="preserve">
          <source>The destination encoding name.</source>
          <target state="translated">Имя кодировки назначения.</target>
        </trans-unit>
        <trans-unit id="acbe64874af1481c3f0cac1a6029d7f03fb77273" translate="yes" xml:space="preserve">
          <source>The details of these commands are not important here; the important point is that there are several separate updates involved to accomplish this rather simple operation. Our bank's officers will want to be assured that either all these updates happen, or none of them happen. It would certainly not do for a system failure to result in Bob receiving $100.00 that was not debited from Alice. Nor would Alice long remain a happy customer if she was debited without Bob being credited. We need a guarantee that if something goes wrong partway through the operation, none of the steps executed so far will take effect. Grouping the updates into a &lt;em&gt;transaction&lt;/em&gt; gives us this guarantee. A transaction is said to be &lt;em&gt;atomic&lt;/em&gt;: from the point of view of other transactions, it either happens completely or not at all.</source>
          <target state="translated">Детали этих команд здесь не важны; Важным моментом является то, что для выполнения этой довольно простой операции требуется несколько отдельных обновлений. Сотрудники нашего банка захотят быть уверены, что либо все эти обновления происходят, либо ничего не происходит. Это определенно не годится для сбоя системы, когда Боб получит 100 долларов, которые не были списаны с Алисы. Алиса также не могла бы долго оставаться счастливым клиентом, если бы она была списана без кредитования Боба. Нам нужна гарантия, что если что-то пойдет не так в ходе операции, ни один из выполненных шагов не вступит в силу. Группировка обновлений в &lt;em&gt;транзакцию&lt;/em&gt; дает нам эту гарантию. Транзакция называется &lt;em&gt;атомарной&lt;/em&gt;: с точки зрения других транзакций это либо происходит полностью, либо не происходит совсем.</target>
        </trans-unit>
        <trans-unit id="81c51a0e7b9a40e273e8f7fe3f2164c947629b88" translate="yes" xml:space="preserve">
          <source>The dictionary accepts three options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e98ae374f333e238cb54e40ccd57bf293c2950f" translate="yes" xml:space="preserve">
          <source>The dictionary accepts two options:</source>
          <target state="translated">Словарь принимает два варианта:</target>
        </trans-unit>
        <trans-unit id="a19f3de80263e9a6413003bf67d42fb29a4dfff8" translate="yes" xml:space="preserve">
          <source>The difference between enabling &lt;code&gt;log_duration&lt;/code&gt; and setting &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statement&lt;/a&gt; to zero is that exceeding &lt;code&gt;log_min_duration_statement&lt;/code&gt; forces the text of the query to be logged, but this option doesn't. Thus, if &lt;code&gt;log_duration&lt;/code&gt; is &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;log_min_duration_statement&lt;/code&gt; has a positive value, all durations are logged but the query text is included only for statements exceeding the threshold. This behavior can be useful for gathering statistics in high-load installations.</source>
          <target state="translated">Разница между включением &lt;code&gt;log_duration&lt;/code&gt; и установкой &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statement&lt;/a&gt; равным нулю заключается в том, что превышение &lt;code&gt;log_min_duration_statement&lt;/code&gt; приводит к тому, что текст запроса будет регистрироваться в журнале, а этот параметр - нет. Таким образом, если &lt;code&gt;log_duration&lt;/code&gt; находится &lt;code&gt;on&lt;/code&gt; и &lt;code&gt;log_min_duration_statement&lt;/code&gt; имеет положительное значение, все длительностей регистрируются , но текст запроса включается только для операторов , превышающих пороговое значение. Такое поведение может быть полезно для сбора статистики в высоконагруженных установках.</target>
        </trans-unit>
        <trans-unit id="86d6a3829cada6f81d9cef342af0288f96d331f4" translate="yes" xml:space="preserve">
          <source>The difference is that the query against the summary table has to get only one row from the table, whereas the direct query against &lt;code&gt;one_to_many&lt;/code&gt; must index scan and fetch a row for each entry.</source>
          <target state="translated">Разница в том, что запрос к сводной таблице должен получить только одну строку из таблицы, тогда как прямой запрос к &lt;code&gt;one_to_many&lt;/code&gt; должен сканировать индекс и выбирать строку для каждой записи.</target>
        </trans-unit>
        <trans-unit id="638327d505052c3c14e5ba331469e70ba93f8131" translate="yes" xml:space="preserve">
          <source>The differences highlighted here are not all of them. In XQuery and the 2.0 and later versions of XPath, there is an XPath 1.0 compatibility mode, and the W3C lists of &lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-functions-20101214/#xpath1-compatibility&quot;&gt;function library changes&lt;/a&gt; and &lt;a href=&quot;https://www.w3.org/TR/xpath20/#id-backwards-compatibility&quot;&gt;language changes&lt;/a&gt; applied in that mode offer a more complete (but still not exhaustive) account of the differences. The compatibility mode cannot make the later languages exactly equivalent to XPath 1.0.</source>
          <target state="translated">Обозначенные здесь различия - это не все. В XQuery и XPath 2.0 и более поздних версиях существует режим совместимости с XPath 1.0, а списки &lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-functions-20101214/#xpath1-compatibility&quot;&gt;изменений библиотеки функций&lt;/a&gt; и &lt;a href=&quot;https://www.w3.org/TR/xpath20/#id-backwards-compatibility&quot;&gt;языка,&lt;/a&gt; применяемые в этом режиме, W3C предлагают более полное (но все же не исчерпывающее) описание различий. Режим совместимости не может сделать более поздние языки в точности эквивалентными XPath 1.0.</target>
        </trans-unit>
        <trans-unit id="3e588858632409434bd776e63f92b5761c3db20c" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;$PGDATA/pg_tblspc&lt;/code&gt; contains symbolic links that point to each of the non-built-in tablespaces defined in the cluster. Although not recommended, it is possible to adjust the tablespace layout by hand by redefining these links. Under no circumstances perform this operation while the server is running. Note that in PostgreSQL 9.1 and earlier you will also need to update the &lt;code&gt;pg_tablespace&lt;/code&gt; catalog with the new locations. (If you do not, &lt;code&gt;pg_dump&lt;/code&gt; will continue to output the old tablespace locations.)</source>
          <target state="translated">Каталог &lt;code&gt;$PGDATA/pg_tblspc&lt;/code&gt; содержит символические ссылки, указывающие на каждое из невстроенных табличных пространств, определенных в кластере. Хотя это не рекомендуется, но можно настроить макет табличного пространства вручную, переопределив эти ссылки. Ни при каких обстоятельствах не выполняйте эту операцию во время работы сервера. Обратите внимание, что в PostgreSQL 9.1 и ранее вам также потребуется обновить каталог &lt;code&gt;pg_tablespace&lt;/code&gt; ,указав новые местоположения. (Если вы этого не сделаете, &lt;code&gt;pg_dump&lt;/code&gt; продолжит выводить старые местоположения табличных пространств.)</target>
        </trans-unit>
        <trans-unit id="48e3d4bb3b396fb8ccb3377c9877d054f3fd3eaa" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;src/test/locale&lt;/code&gt; in the source distribution contains a test suite for PostgreSQL's locale support.</source>
          <target state="translated">Каталог &lt;code&gt;src/test/locale&lt;/code&gt; в исходном дистрибутиве содержит набор тестов для поддержки локали PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="8f609b85a02a4ded47fa5c57a791418dd0d72112" translate="yes" xml:space="preserve">
          <source>The directory that will be used for the tablespace. The directory must exist (&lt;code&gt;CREATE TABLESPACE&lt;/code&gt; will not create it), should be empty, and must be owned by the PostgreSQL system user. The directory must be specified by an absolute path name.</source>
          <target state="translated">Каталог, который будет использоваться для табличного пространства. Каталог должен существовать ( &lt;code&gt;CREATE TABLESPACE&lt;/code&gt; не создает его), должен быть пустым и принадлежать системному пользователю PostgreSQL. Каталог должен быть указан по абсолютному пути.</target>
        </trans-unit>
        <trans-unit id="0c9ae3d8cb40fd37366fec2ea07a50700e4c2316" translate="yes" xml:space="preserve">
          <source>The domain this constraint is on; 0 if not a domain constraint</source>
          <target state="translated">Домен,на котором установлено это ограничение;0,если не ограничение домена</target>
        </trans-unit>
        <trans-unit id="66141cd3e18bcdc88d4a038dfc634ffad3fa560d" translate="yes" xml:space="preserve">
          <source>The drawback of this procedure is that it depends on the integrity of the client: if the client machine is untrusted or compromised, an attacker could run just about any program on port 113 and return any user name they choose. This authentication method is therefore only appropriate for closed networks where each client machine is under tight control and where the database and system administrators operate in close contact. In other words, you must trust the machine running the ident server. Heed the warning:</source>
          <target state="translated">Недостатком этой процедуры является то,что она зависит от целостности клиента:если клиентская машина недоверена или скомпрометирована,злоумышленник может запустить практически любую программу на порту 113 и вернуть любое выбранное им имя пользователя.Поэтому такой метод аутентификации подходит только для закрытых сетей,где каждая клиентская машина находится под жестким контролем и где база данных и системные администраторы работают в тесном контакте.Другими словами,вы должны доверять машине,на которой запущен сервер ident.Прислушайтесь к предупреждению:</target>
        </trans-unit>
        <trans-unit id="13aa020c26befcd9c06640c85756679a7699e20c" translate="yes" xml:space="preserve">
          <source>The drawback of using locales other than &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt; in PostgreSQL is its performance impact. It slows character handling and prevents ordinary indexes from being used by &lt;code&gt;LIKE&lt;/code&gt;. For this reason use locales only if you actually need them.</source>
          <target state="translated">Недостатком использования в PostgreSQL других локалей, кроме &lt;code&gt;C&lt;/code&gt; или &lt;code&gt;POSIX&lt;/code&gt; , является их влияние на производительность. Это замедляет обработку символов и предотвращает использование &lt;code&gt;LIKE&lt;/code&gt; обычных индексов . По этой причине используйте локали только в том случае, если они вам действительно нужны.</target>
        </trans-unit>
        <trans-unit id="ff3e6b54f5a69b71d88bd211c608fb1a58dc225c" translate="yes" xml:space="preserve">
          <source>The dump file produced by pg_dump does not contain the statistics used by the optimizer to make query planning decisions. Therefore, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; after restoring from a dump file to ensure optimal performance; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">Файл дампа, созданный pg_dump, не содержит статистики, используемой оптимизатором для принятия решений по планированию запросов. Поэтому разумно запустить &lt;code&gt;ANALYZE&lt;/code&gt; после восстановления из файла дампа, чтобы обеспечить оптимальную производительность; см. &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Раздел 24.1.3&lt;/a&gt; и &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Раздел 24.1.6&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="7b92c28f4a6038b16d370463cb2b0c497c1536e4" translate="yes" xml:space="preserve">
          <source>The dump script should not be expected to run completely without errors. In particular, because the script will issue &lt;code&gt;CREATE ROLE&lt;/code&gt; for every role existing in the source cluster, it is certain to get a &amp;ldquo;role already exists&amp;rdquo; error for the bootstrap superuser, unless the destination cluster was initialized with a different bootstrap superuser name. This error is harmless and should be ignored. Use of the &lt;code&gt;--clean&lt;/code&gt; option is likely to produce additional harmless error messages about non-existent objects, although you can minimize those by adding &lt;code&gt;--if-exists&lt;/code&gt;.</source>
          <target state="translated">Не следует ожидать, что сценарий дампа будет работать полностью без ошибок. В частности, поскольку сценарий выдаст &lt;code&gt;CREATE ROLE&lt;/code&gt; для каждой роли, существующей в исходном кластере, для суперпользователя начальной загрузки наверняка появится ошибка &amp;laquo;роль уже существует&amp;raquo;, если только целевой кластер не был инициализирован с другим именем суперпользователя начальной загрузки. Эта ошибка безвредна, и ее следует игнорировать. Использование &lt;code&gt;--clean&lt;/code&gt; вариант, скорее всего , для получения дополнительных сообщений об ошибках безвредны о несуществующих объектах, хотя вы можете свести к минимуму те , путем добавления &lt;code&gt;--if-exists&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f3181a66ca9fbe6427fab730ca21eb224bb5bb9" translate="yes" xml:space="preserve">
          <source>The dumps produced by pg_dump are relative to &lt;code&gt;template0&lt;/code&gt;. This means that any languages, procedures, etc. added via &lt;code&gt;template1&lt;/code&gt; will also be dumped by pg_dump. As a result, when restoring, if you are using a customized &lt;code&gt;template1&lt;/code&gt;, you must create the empty database from &lt;code&gt;template0&lt;/code&gt;, as in the example above.</source>
          <target state="translated">Дампы, создаваемые pg_dump, относятся к &lt;code&gt;template0&lt;/code&gt; . Это означает, что любые языки, процедуры и т. Д., Добавленные через &lt;code&gt;template1&lt;/code&gt; , также будут сброшены pg_dump. В результате при восстановлении, если вы используете настроенный &lt;code&gt;template1&lt;/code&gt; , вы должны создать пустую базу данных из &lt;code&gt;template0&lt;/code&gt; , как в примере выше.</target>
        </trans-unit>
        <trans-unit id="95dc72eaaf7198b33e4096fb87aae7d094164670" translate="yes" xml:space="preserve">
          <source>The earliest LSN at which replay on the indicated timeline may end when making use of this backup. This is stored in the same format as &lt;code&gt;Start-LSN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7817fb8368f1c7b07f344d07c4746bc348201b26" translate="yes" xml:space="preserve">
          <source>The easiest way to perform a base backup is to use the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; tool. It can create a base backup either as regular files or as a tar archive. If more flexibility than &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; can provide is required, you can also make a base backup using the low level API (see &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;).</source>
          <target state="translated">Самый простой способ выполнить базовое резервное копирование - использовать инструмент &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; . Он может создавать базовую резервную копию как в виде обычных файлов, так и в виде tar-архива. Если требуется большая гибкость, чем может предоставить &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; , вы также можете сделать базовую резервную копию, используя низкоуровневый API (см. &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Раздел 25.3.3&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="29f1de90d9c685081e50b22b770744253403d7c5" translate="yes" xml:space="preserve">
          <source>The effect of this mechanism is that in the default configuration, triggers do not fire on replicas. This is useful because if a trigger is used on the origin to propagate data between tables, then the replication system will also replicate the propagated data, and the trigger should not fire a second time on the replica, because that would lead to duplication. However, if a trigger is used for another purpose such as creating external alerts, then it might be appropriate to set it to &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; so that it is also fired on replicas.</source>
          <target state="translated">Эффект этого механизма заключается в том, что в конфигурации по умолчанию триггеры не срабатывают на репликах. Это полезно, потому что если в источнике используется триггер для распространения данных между таблицами, тогда система репликации также будет реплицировать распространенные данные, и триггер не должен срабатывать второй раз на реплике, потому что это приведет к дублированию. Однако, если триггер используется для другой цели, например для создания внешних предупреждений, может быть целесообразно установить для него значение &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; чтобы он также запускался на репликах.</target>
        </trans-unit>
        <trans-unit id="11f70bcfbdc794c385378840673cf0a249c54a0a" translate="yes" xml:space="preserve">
          <source>The effective maximum for &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; is 0.95 * &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt;; a setting higher than that will be capped to the maximum. A value higher than &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; wouldn't make sense because an anti-wraparound autovacuum would be triggered at that point anyway, and the 0.95 multiplier leaves some breathing room to run a manual &lt;code&gt;VACUUM&lt;/code&gt; before that happens. As a rule of thumb, &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; should be set to a value somewhat below &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt;, leaving enough gap so that a regularly scheduled &lt;code&gt;VACUUM&lt;/code&gt; or an autovacuum triggered by normal delete and update activity is run in that window. Setting it too close could lead to anti-wraparound autovacuums, even though the table was recently vacuumed to reclaim space, whereas lower values lead to more frequent aggressive vacuuming.</source>
          <target state="translated">Эффективный максимум для &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; составляет 0,95 * &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; ; значение выше этого будет ограничено до максимума. Значение выше &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; не имело бы смысла, потому что на этом этапе все равно будет запущена автовакуумная очистка, а множитель 0,95 оставляет некоторую передышку для ручного &lt;code&gt;VACUUM&lt;/code&gt; , прежде чем это произойдет. Как показывает &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; , для параметра vacuum_freeze_table_age должно быть установлено значение несколько ниже &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; , оставляя достаточный промежуток, чтобы регулярно планировалось &lt;code&gt;VACUUM&lt;/code&gt; или в этом окне запускается автоочистка, запускаемая обычным удалением и обновлением. Установка слишком близко может привести к автоочистке, препятствующей наматыванию, даже если стол недавно был очищен пылесосом для освобождения места, тогда как более низкие значения приводят к более частой агрессивной уборке.</target>
        </trans-unit>
        <trans-unit id="6acae8d5fe7431e883721a35bb83f27f6d33e399" translate="yes" xml:space="preserve">
          <source>The effective resolution of the sleep interval is platform-specific; 0.01 seconds is a common value. The sleep delay will be at least as long as specified. It might be longer depending on factors such as server load. In particular, &lt;code&gt;pg_sleep_until&lt;/code&gt; is not guaranteed to wake up exactly at the specified time, but it will not wake up any earlier.</source>
          <target state="translated">Эффективное разрешение интервала ожидания зависит от платформы; 0,01 секунды - обычное значение. Задержка сна будет не меньше указанного. Это может быть больше в зависимости от таких факторов, как нагрузка на сервер. В частности, не гарантируется , что &lt;code&gt;pg_sleep_until&lt;/code&gt; проснется точно в указанное время, но он не проснется раньше.</target>
        </trans-unit>
        <trans-unit id="ca3e0b7947e98767e7bc3c70b05110c06d007fc6" translate="yes" xml:space="preserve">
          <source>The effects of &lt;code&gt;SET LOCAL&lt;/code&gt; last only till the end of the current transaction, whether committed or not. A special case is &lt;code&gt;SET&lt;/code&gt; followed by &lt;code&gt;SET LOCAL&lt;/code&gt; within a single transaction: the &lt;code&gt;SET LOCAL&lt;/code&gt; value will be seen until the end of the transaction, but afterwards (if the transaction is committed) the &lt;code&gt;SET&lt;/code&gt; value will take effect.</source>
          <target state="translated">Эффект &lt;code&gt;SET LOCAL&lt;/code&gt; длятся только до конца текущей транзакции, независимо от того, совершена она или нет. Особым случаем является &lt;code&gt;SET&lt;/code&gt; , за которым следует &lt;code&gt;SET LOCAL&lt;/code&gt; в рамках одной транзакции: значение &lt;code&gt;SET LOCAL&lt;/code&gt; будет отображаться до конца транзакции, но после (если транзакция зафиксирована) вступит в силу значение &lt;code&gt;SET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1963e14d77518dfe80e47bfcd05e2429f11a8bde" translate="yes" xml:space="preserve">
          <source>The effects of &lt;code&gt;SET&lt;/code&gt; or &lt;code&gt;SET LOCAL&lt;/code&gt; are also canceled by rolling back to a savepoint that is earlier than the command.</source>
          <target state="translated">Эффекты &lt;code&gt;SET&lt;/code&gt; или &lt;code&gt;SET LOCAL&lt;/code&gt; также отменяются откатом к точке сохранения, которая предшествует команде.</target>
        </trans-unit>
        <trans-unit id="005a74c57d93879fd436d69f089f03e96ff53b14" translate="yes" xml:space="preserve">
          <source>The elements of the &lt;code&gt;PARTITION BY&lt;/code&gt; list are interpreted in much the same fashion as elements of a &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt; Clause&lt;/a&gt;, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular &lt;code&gt;GROUP BY&lt;/code&gt; clause. They are allowed here because windowing occurs after grouping and aggregation.</source>
          <target state="translated">Элементы &lt;code&gt;PARTITION BY&lt;/code&gt; списка интерпретируются во многом таким же образом , как элементы &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt; &lt;code&gt;GROUP BY&lt;/code&gt; пункта&lt;/a&gt; , за исключением того, что они всегда простые выражения и никогда имя или номер выходного столбца. Другое отличие состоит в том, что эти выражения могут содержать вызовы агрегатных функций, которые не допускаются в обычном предложении &lt;code&gt;GROUP BY&lt;/code&gt; . Здесь они разрешены, потому что оконное управление происходит после группировки и агрегации.</target>
        </trans-unit>
        <trans-unit id="ee005edb8cd95f17a956edeff522c590d6992936" translate="yes" xml:space="preserve">
          <source>The elements of the &lt;code&gt;PARTITION BY&lt;/code&gt; list are interpreted in much the same fashion as elements of a &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt;&lt;/a&gt; clause, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular &lt;code&gt;GROUP BY&lt;/code&gt; clause. They are allowed here because windowing occurs after grouping and aggregation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd51d8414173fa812e307883cf9daca455add1a4" translate="yes" xml:space="preserve">
          <source>The empty scalar sub-SELECT will produce a null value that is considered to be of the domain type, so no further constraint checking is applied to it, and the insertion will succeed.</source>
          <target state="translated">Пустой скаляр sub-SELECT выдаст нулевое значение,которое считается типом домена,поэтому к нему не применяется дополнительная проверка ограничений,и вставка будет успешной.</target>
        </trans-unit>
        <trans-unit id="750129d09bd31bb5985c26e665018fb53719c8d3" translate="yes" xml:space="preserve">
          <source>The encoding and locale settings must match those of the template database, except when &lt;code&gt;template0&lt;/code&gt; is used as template. This is because other databases might contain data that does not match the specified encoding, or might contain indexes whose sort ordering is affected by &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;. Copying such data would result in a database that is corrupt according to the new settings. &lt;code&gt;template0&lt;/code&gt;, however, is known to not contain any data or indexes that would be affected.</source>
          <target state="translated">Параметры кодировки и локали должны соответствовать параметрам базы данных шаблонов, за исключением случаев, когда в качестве &lt;code&gt;template0&lt;/code&gt; используется template0. Это связано с тем, что другие базы данных могут содержать данные, которые не соответствуют указанной кодировке, или могут содержать индексы, порядок сортировки которых зависит от &lt;code&gt;LC_COLLATE&lt;/code&gt; и &lt;code&gt;LC_CTYPE&lt;/code&gt; . Копирование таких данных приведет к повреждению базы данных в соответствии с новыми настройками. Однако известно, что &lt;code&gt;template0&lt;/code&gt; не содержит никаких данных или индексов, которые могут быть затронуты.</target>
        </trans-unit>
        <trans-unit id="06ebfe8f29152790c8c19069e09027b276e20d6f" translate="yes" xml:space="preserve">
          <source>The encoding for a database is stored in the system catalog &lt;code&gt;pg_database&lt;/code&gt;. You can see it by using the &lt;code&gt;psql&lt;/code&gt;&lt;code&gt;-l&lt;/code&gt; option or the &lt;code&gt;\l&lt;/code&gt; command.</source>
          <target state="translated">Кодировка для базы данных хранится в системном каталоге &lt;code&gt;pg_database&lt;/code&gt; . Вы можете увидеть это, используя параметр &lt;code&gt;psql&lt;/code&gt; &lt;code&gt;-l&lt;/code&gt; или команду &lt;code&gt;\l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b548a79db3b694cdb5c78e7ae46892fe80152d6" translate="yes" xml:space="preserve">
          <source>The encryption vector used will only be cryptographically strong if PostgreSQL is built with support for OpenSSL. In other cases, the transmission to the RADIUS server should only be considered obfuscated, not secured, and external security measures should be applied if necessary.</source>
          <target state="translated">Используемый вектор шифрования будет криптографически сильным только в том случае,если PostgreSQL собран с поддержкой OpenSSL.В других случаях передачу на сервер RADIUS следует считать только обфусцированной,не защищенной,при необходимости следует применять внешние меры безопасности.</target>
        </trans-unit>
        <trans-unit id="807f48853a85df34d9a80e7027652fd76ea8d1d2" translate="yes" xml:space="preserve">
          <source>The entries in the select list can be assigned names for subsequent processing, such as for use in an &lt;code&gt;ORDER BY&lt;/code&gt; clause or for display by the client application. For example:</source>
          <target state="translated">Записи в списке выбора могут иметь имена для последующей обработки, например, для использования в предложении &lt;code&gt;ORDER BY&lt;/code&gt; или для отображения клиентским приложением. Например:</target>
        </trans-unit>
        <trans-unit id="5ed44cca4375f0386d06f29a5cb471a7a637f589" translate="yes" xml:space="preserve">
          <source>The enumerator is a function &lt;code&gt;int_array_enum(integer[])&lt;/code&gt; that returns &lt;code&gt;setof integer&lt;/code&gt;. It is essentially the reverse operation of the aggregator: given an array of integers, expand it into a set of rows. This is a wrapper around &lt;code&gt;unnest&lt;/code&gt;, which does the same thing for any array type.</source>
          <target state="translated">Перечислитель - это функция &lt;code&gt;int_array_enum(integer[])&lt;/code&gt; которая возвращает &lt;code&gt;setof integer&lt;/code&gt; . По сути, это операция, обратная агрегатору: дан массив целых чисел, он расширяется до набора строк. Это оболочка для &lt;code&gt;unnest&lt;/code&gt; , которая делает то же самое для любого типа массива.</target>
        </trans-unit>
        <trans-unit id="adf2db7b61ef30b8a94189e9e7cbc4a2342e7f7a" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PG_COLOR&lt;/code&gt; specifies whether to use color in diagnostic messages. Possible values are &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d14b9d4e54d6bcfb1eb32844ae2033e082cd8255" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PG_COLOR&lt;/code&gt; specifies whether to use color in diagnostics messages. Possible values are &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">Переменная среды &lt;code&gt;PG_COLOR&lt;/code&gt; указывает, следует ли использовать цвет в диагностических сообщениях. Возможные значения: &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;auto&lt;/code&gt; , &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0960a83450dbd1eaf41a4a82cb1e20f4eb07da46" translate="yes" xml:space="preserve">
          <source>The error code (see &lt;a href=&quot;errcodes-appendix&quot;&gt;Appendix A&lt;/a&gt;) associated with the last SQL query's failure, or &lt;code&gt;00000&lt;/code&gt; if it succeeded.</source>
          <target state="translated">Код ошибки (см. &lt;a href=&quot;errcodes-appendix&quot;&gt;Приложение A&lt;/a&gt; ), связанный с ошибкой последнего SQL-запроса, или &lt;code&gt;00000&lt;/code&gt; , если он был успешным.</target>
        </trans-unit>
        <trans-unit id="18033404335da13276f24e2efbba0cea44bc2fa8" translate="yes" xml:space="preserve">
          <source>The error message contains a useful hint: if you do not want to bother deleting all the dependent objects individually, you can run:</source>
          <target state="translated">Сообщение об ошибке содержит полезную подсказку:если вы не хотите утруждать себя удалением всех зависимых объектов по отдельности,можно запускать:</target>
        </trans-unit>
        <trans-unit id="57829bc22f9a034fee876abab6cb834a1c2e8f4d" translate="yes" xml:space="preserve">
          <source>The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character.</source>
          <target state="translated">Экранирующий символ может быть любым одиночным символом,кроме шестнадцатеричной цифры,знака плюс,одиночной кавычки,двойной кавычки или пробела.</target>
        </trans-unit>
        <trans-unit id="67bd70b6b09776588b82cea1e08b3ca407b7095e" translate="yes" xml:space="preserve">
          <source>The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character. Note that the escape character is written in single quotes, not double quotes, after &lt;code&gt;UESCAPE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558d22a4e0d0e48723c35f2a0cfc8e75bf258ba8" translate="yes" xml:space="preserve">
          <source>The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character. Note that the escape character is written in single quotes, not double quotes.</source>
          <target state="translated">Экранирующий символ может быть любым одиночным символом,кроме шестнадцатеричной цифры,знака плюс,одиночной кавычки,двойной кавычки или пробела.Обратите внимание,что управляющий символ записывается в одинарные кавычки,а не в двойные кавычки.</target>
        </trans-unit>
        <trans-unit id="c319bbe8d3e052f0e1ded51a38eee81a844539cf" translate="yes" xml:space="preserve">
          <source>The escape-double-quote separators actually divide &lt;code&gt;substring&lt;/code&gt;'s pattern into three independent regular expressions; for example, a vertical bar (&lt;code&gt;|&lt;/code&gt;) in any of the three sections affects only that section. Also, the first and third of these regular expressions are defined to match the smallest possible amount of text, not the largest, when there is any ambiguity about how much of the data string matches which pattern. (In POSIX parlance, the first and third regular expressions are forced to be non-greedy.)</source>
          <target state="translated">Разделители escape-двойных кавычек фактически разделяют шаблон &lt;code&gt;substring&lt;/code&gt; на три независимых регулярных выражения; например, вертикальная черта ( &lt;code&gt;|&lt;/code&gt; ) в любом из трех разделов влияет только на этот раздел. Кроме того, первое и третье из этих регулярных выражений определены так, чтобы соответствовать минимально возможному количеству текста, а не самому большому, когда есть какая-либо двусмысленность в отношении того, какая часть строки данных соответствует какому шаблону. (На языке POSIX первое и третье регулярные выражения вынуждены быть нежадными.)</target>
        </trans-unit>
        <trans-unit id="3b9ec713fc7d733ff3cae68659b4d4e80a25bebd" translate="yes" xml:space="preserve">
          <source>The essential difference between &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt; data types is that &lt;code&gt;inet&lt;/code&gt; accepts values with nonzero bits to the right of the netmask, whereas &lt;code&gt;cidr&lt;/code&gt; does not. For example, &lt;code&gt;192.168.0.1/24&lt;/code&gt; is valid for &lt;code&gt;inet&lt;/code&gt; but not for &lt;code&gt;cidr&lt;/code&gt;.</source>
          <target state="translated">Существенное различие между &lt;code&gt;cidr&lt;/code&gt; данных &lt;code&gt;inet&lt;/code&gt; и cidr состоит в том, что &lt;code&gt;inet&lt;/code&gt; принимает значения с ненулевыми битами справа от &lt;code&gt;cidr&lt;/code&gt; маски, а cidr - нет. Например, &lt;code&gt;192.168.0.1/24&lt;/code&gt; действителен для &lt;code&gt;inet&lt;/code&gt; , но не для &lt;code&gt;cidr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df18f95e8b31c041dbe1102915fb4ff49c1585b3" translate="yes" xml:space="preserve">
          <source>The essential semantics of an &lt;code&gt;in_range&lt;/code&gt; function depend on the two Boolean flag parameters. It should add or subtract &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;, then compare &lt;code&gt;val&lt;/code&gt; to the result, as follows:</source>
          <target state="translated">Существенная семантика функции &lt;code&gt;in_range&lt;/code&gt; зависит от двух параметров логического флага. Следует добавить или вычесть &lt;code&gt;base&lt;/code&gt; и &lt;code&gt;offset&lt;/code&gt; , а затем сравнить &lt;code&gt;val&lt;/code&gt; к результату, а именно:</target>
        </trans-unit>
        <trans-unit id="e84d23798c1117bda45a63153c240c91e5736421" translate="yes" xml:space="preserve">
          <source>The estimate is as accurate as with the functional dependencies, mostly thanks to the table being fairly small and having a simple distribution with a low number of distinct values. Before looking at the second query, which was not handled by functional dependencies particularly well, let's inspect the MCV list a bit.</source>
          <target state="translated">Оценка столь же точна,как и в случае с функциональными зависимостями,в основном благодаря тому,что таблица достаточно мала и имеет простое распределение с небольшим количеством различных значений.Прежде чем рассматривать второй запрос,который не был особенно хорошо обработан функциональными зависимостями,давайте немного посмотрим на список MCV.</target>
        </trans-unit>
        <trans-unit id="e69083f44a757893f1ada1ae6b8cb9bd97b58e99" translate="yes" xml:space="preserve">
          <source>The estimated cost charged when vacuum modifies a block that was previously clean. It represents the extra I/O required to flush the dirty block out to disk again. The default value is 20.</source>
          <target state="translated">Сметная стоимость,взимаемая при внесении пылесосом изменений в блок,который ранее был чистым.Она представляет собой дополнительные входы/выходы,необходимые для повторной промывки грязного блока на диск.Значение по умолчанию-20.</target>
        </trans-unit>
        <trans-unit id="ee2db52b19d2bfa03dc1ab623c01a2a1907e2459" translate="yes" xml:space="preserve">
          <source>The estimated cost for vacuuming a buffer found in the shared buffer cache. It represents the cost to lock the buffer pool, lookup the shared hash table and scan the content of the page. The default value is one.</source>
          <target state="translated">Оценочная стоимость вакуумирования буфера,находящегося в общей буферной кэш-памяти.Она представляет собой стоимость блокировки буферного пула,поиска общей хеш-таблицы и сканирования содержимого страницы.Значение по умолчанию равно единице.</target>
        </trans-unit>
        <trans-unit id="83ce27e1c08fee6790695cac6b8c3ef5bff725b5" translate="yes" xml:space="preserve">
          <source>The estimated cost for vacuuming a buffer that has to be read from disk. This represents the effort to lock the buffer pool, lookup the shared hash table, read the desired block in from the disk and scan its content. The default value is 10.</source>
          <target state="translated">Предполагаемая стоимость вакуумирования буфера,который должен считываться с диска.Это представляет собой попытку заблокировать буферный пул,просмотреть общую хэш-таблицу,прочитать нужный блок с диска и просканировать его содержимое.Значение по умолчанию равно 10.</target>
        </trans-unit>
        <trans-unit id="a717571e9b46bfa71ced49ce7ab5ad2053e90b7b" translate="yes" xml:space="preserve">
          <source>The event is one of &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. Note that an &lt;code&gt;INSERT&lt;/code&gt; containing an &lt;code&gt;ON CONFLICT&lt;/code&gt; clause cannot be used on tables that have either &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; rules. Consider using an updatable view instead.</source>
          <target state="translated">Событие может быть одним из &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; . Обратите внимание, что &lt;code&gt;INSERT&lt;/code&gt; , содержащий предложение &lt;code&gt;ON CONFLICT&lt;/code&gt; , не может использоваться в таблицах, которые имеют правила &lt;code&gt;INSERT&lt;/code&gt; или &lt;code&gt;UPDATE&lt;/code&gt; . Вместо этого рассмотрите возможность использования обновляемого представления.</target>
        </trans-unit>
        <trans-unit id="227dafe90d62bc0d6660bf9b763aa381e9cc9dfe" translate="yes" xml:space="preserve">
          <source>The exact values that are acceptable for the &lt;code&gt;locale&lt;/code&gt; clause in this command depend on the operating system. On Unix-like systems, the command &lt;code&gt;locale -a&lt;/code&gt; will show a list.</source>
          <target state="translated">Точные значения, которые приемлемы для предложения &lt;code&gt;locale&lt;/code&gt; в этой команде, зависят от операционной системы. В Unix-подобных системах команда &lt;code&gt;locale -a&lt;/code&gt; покажет список.</target>
        </trans-unit>
        <trans-unit id="1583bbd20b51e7ac63ce0bb194332cc2a7d7d470" translate="yes" xml:space="preserve">
          <source>The example above can be written using the simple &lt;code&gt;CASE&lt;/code&gt; syntax:</source>
          <target state="translated">Пример выше может быть написан с использованием простого синтаксиса &lt;code&gt;CASE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="af8e2a351cf21a24426f9811e0f9ff471eeba69b" translate="yes" xml:space="preserve">
          <source>The example below shows a DTrace script for analyzing transaction counts in the system, as an alternative to snapshotting &lt;code&gt;pg_stat_database&lt;/code&gt; before and after a performance test:</source>
          <target state="translated">В приведенном ниже примере показан сценарий DTrace для анализа количества транзакций в системе в качестве альтернативы &lt;code&gt;pg_stat_database&lt;/code&gt; снимков pg_stat_database до и после теста производительности:</target>
        </trans-unit>
        <trans-unit id="f0d6977a3eaffb08d482eddd947f053b0bf9bd5c" translate="yes" xml:space="preserve">
          <source>The examples above only show &lt;code&gt;WITH&lt;/code&gt; being used with &lt;code&gt;SELECT&lt;/code&gt;, but it can be attached in the same way to &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. In each case it effectively provides temporary table(s) that can be referred to in the main command.</source>
          <target state="translated">В приведенных выше примерах показано использование &lt;code&gt;WITH&lt;/code&gt; только с &lt;code&gt;SELECT&lt;/code&gt; , но его можно таким же образом присоединить к &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; . В каждом случае он фактически предоставляет временные таблицы, на которые можно ссылаться в основной команде.</target>
        </trans-unit>
        <trans-unit id="380cc7f137a8c15a1ad87e0fd8242117724c9f5a" translate="yes" xml:space="preserve">
          <source>The examples in the previous section illustrated full text matching using simple constant strings. This section shows how to search table data, optionally using indexes.</source>
          <target state="translated">Примеры в предыдущем разделе иллюстрировали полнотекстовое совпадение с использованием простых константных строк.В этом разделе показано,как искать данные в таблицах,опционально используя индексы.</target>
        </trans-unit>
        <trans-unit id="b9b0afad9f26eddf93a4253af463b944d4205ce4" translate="yes" xml:space="preserve">
          <source>The examples shown below use tables in the PostgreSQL regression test database. The outputs shown are taken from version 8.3. The behavior of earlier (or later) versions might vary. Note also that since &lt;code&gt;ANALYZE&lt;/code&gt; uses random sampling while producing statistics, the results will change slightly after any new &lt;code&gt;ANALYZE&lt;/code&gt;.</source>
          <target state="translated">В приведенных ниже примерах используются таблицы из базы данных регрессионного теста PostgreSQL. Показанные результаты взяты из версии 8.3. Поведение более ранних (или более поздних) версий может отличаться. Также обратите внимание, что, поскольку &lt;code&gt;ANALYZE&lt;/code&gt; использует случайную выборку при создании статистики, результаты будут немного изменяться после любого нового &lt;code&gt;ANALYZE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2367138a166c600af3d676a2ed6d45de33c069c" translate="yes" xml:space="preserve">
          <source>The examples use &lt;code&gt;EXPLAIN&lt;/code&gt;'s default &amp;ldquo;text&amp;rdquo; output format, which is compact and convenient for humans to read. If you want to feed &lt;code&gt;EXPLAIN&lt;/code&gt;'s output to a program for further analysis, you should use one of its machine-readable output formats (XML, JSON, or YAML) instead.</source>
          <target state="translated">В примерах используется формат вывода &lt;code&gt;EXPLAIN&lt;/code&gt; по умолчанию &amp;laquo;текст&amp;raquo;, который компактен и удобен для чтения людьми. Если вы хотите &lt;code&gt;EXPLAIN&lt;/code&gt; вывод EXPLAIN программе для дальнейшего анализа, вам следует вместо этого использовать один из его машиночитаемых форматов вывода (XML, JSON или YAML).</target>
        </trans-unit>
        <trans-unit id="d75f123f158a40ce2bca3268003c1deb66947f66" translate="yes" xml:space="preserve">
          <source>The exclusive backup method is deprecated and should be avoided. Prior to PostgreSQL 9.6, this was the only low-level method available, but it is now recommended that all users upgrade their scripts to use non-exclusive backups.</source>
          <target state="translated">Исключительный метод резервного копирования является устаревшим и его следует избегать.До PostgreSQL 9.6 это был единственный доступный низкоуровневый метод,но теперь всем пользователям рекомендуется обновить свои скрипты для использования неэксклюзивных резервных копий.</target>
        </trans-unit>
        <trans-unit id="bb6f1793100519508110d4857d8c27514367d631" translate="yes" xml:space="preserve">
          <source>The executor mechanism is used to evaluate all four basic SQL query types: &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. For &lt;code&gt;SELECT&lt;/code&gt;, the top-level executor code only needs to send each row returned by the query plan tree off to the client. For &lt;code&gt;INSERT&lt;/code&gt;, each returned row is inserted into the target table specified for the &lt;code&gt;INSERT&lt;/code&gt;. This is done in a special top-level plan node called &lt;code&gt;ModifyTable&lt;/code&gt;. (A simple &lt;code&gt;INSERT ... VALUES&lt;/code&gt; command creates a trivial plan tree consisting of a single &lt;code&gt;Result&lt;/code&gt; node, which computes just one result row, and &lt;code&gt;ModifyTable&lt;/code&gt; above it to perform the insertion. But &lt;code&gt;INSERT ... SELECT&lt;/code&gt; can demand the full power of the executor mechanism.) For &lt;code&gt;UPDATE&lt;/code&gt;, the planner arranges that each computed row includes all the updated column values, plus the &lt;em&gt;TID&lt;/em&gt; (tuple ID, or row ID) of the original target row; this data is fed into a &lt;code&gt;ModifyTable&lt;/code&gt; node, which uses the information to create a new updated row and mark the old row deleted. For &lt;code&gt;DELETE&lt;/code&gt;, the only column that is actually returned by the plan is the TID, and the &lt;code&gt;ModifyTable&lt;/code&gt; node simply uses the TID to visit each target row and mark it deleted.</source>
          <target state="translated">Механизм исполнителя используется для оценки всех четырех основных типов SQL-запросов: &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; . Для &lt;code&gt;SELECT&lt;/code&gt; код исполнителя верхнего уровня должен только отправить клиенту каждую строку, возвращаемую деревом плана запроса. Для &lt;code&gt;INSERT&lt;/code&gt; каждая возвращенная строка вставляется в целевую таблицу, указанную для &lt;code&gt;INSERT&lt;/code&gt; . Это делается в специальном узле плана верхнего уровня под названием &lt;code&gt;ModifyTable&lt;/code&gt; . (Простая команда &lt;code&gt;INSERT ... VALUES&lt;/code&gt; создает тривиальное дерево плана, состоящее из одного узла &lt;code&gt;Result&lt;/code&gt; , который вычисляет только одну строку результата, и &lt;code&gt;ModifyTable&lt;/code&gt; над ним, чтобы выполнить вставку. Но &lt;code&gt;INSERT ... SELECT&lt;/code&gt; может потребовать полной мощности механизма исполнителя.) Для &lt;code&gt;UPDATE&lt;/code&gt; планировщик организует, чтобы каждая вычисляемая строка включала все обновленные значения столбца, а также &lt;em&gt;TID&lt;/em&gt; (идентификатор кортежа или идентификатор строки) исходной целевой строки. ; эти данные &lt;code&gt;ModifyTable&lt;/code&gt; узел ModifyTable , который использует информацию для создания новой обновленной строки и пометки старой строки как удаленной. Для &lt;code&gt;DELETE&lt;/code&gt; единственный столбец, который фактически возвращается планом, - это TID, а узел &lt;code&gt;ModifyTable&lt;/code&gt; просто использует TID для посещения каждой целевой строки и пометки ее удаленной.</target>
        </trans-unit>
        <trans-unit id="4ce520996e20d2c06a7766155c3058caa75b4272" translate="yes" xml:space="preserve">
          <source>The executor recursively steps through the &lt;em&gt;plan tree&lt;/em&gt; and retrieves rows in the way represented by the plan. The executor makes use of the &lt;em&gt;storage system&lt;/em&gt; while scanning relations, performs &lt;em&gt;sorts&lt;/em&gt; and &lt;em&gt;joins&lt;/em&gt;, evaluates &lt;em&gt;qualifications&lt;/em&gt; and finally hands back the rows derived.</source>
          <target state="translated">Исполнитель рекурсивно проходит через &lt;em&gt;дерево плана&lt;/em&gt; и извлекает строки способом, представленным планом. Исполнитель использует систему &lt;em&gt;хранения&lt;/em&gt; при сканировании отношений, выполняет &lt;em&gt;сортировку&lt;/em&gt; и &lt;em&gt;объединение&lt;/em&gt; , оценивает &lt;em&gt;квалификации&lt;/em&gt; и, наконец, возвращает полученные строки.</target>
        </trans-unit>
        <trans-unit id="cf8658aa7a1382f233186544e10108cceaf18988" translate="yes" xml:space="preserve">
          <source>The existence of functional dependencies directly affects the accuracy of estimates in certain queries. If a query contains conditions on both the independent and the dependent column(s), the conditions on the dependent columns do not further reduce the result size; but without knowledge of the functional dependency, the query planner will assume that the conditions are independent, resulting in underestimating the result size.</source>
          <target state="translated">Наличие функциональных зависимостей напрямую влияет на точность оценок в определенных запросах.Если запрос содержит условия как на независимом,так и на зависимом столбце (столбцах),то условия на зависимом столбце (столбцах)в дальнейшем не уменьшают размер результата;но без знания функциональной зависимости планировщик запроса будет считать,что условия независимы,что приводит к занижению размера результата.</target>
        </trans-unit>
        <trans-unit id="278c43dc066d35135921d352f59558e56072aaf4" translate="yes" xml:space="preserve">
          <source>The existing enum value that should be renamed. Like all enum literals, it needs to be quoted.</source>
          <target state="translated">Существующее перечислительное значение,которое следует переименовать.Как и все литералы перечисления,оно должно быть процитировано.</target>
        </trans-unit>
        <trans-unit id="ec72bab01087d3968b75adfc77dfce97e7c1c187" translate="yes" xml:space="preserve">
          <source>The existing enum value that the new value should be added immediately before or after in the enum type's sort ordering. Like all enum literals, it needs to be quoted.</source>
          <target state="translated">Существующее значение переписи,которое новое значение должно быть добавлено непосредственно перед или после в порядке сортировки перечислительного типа.Как и все литералы перечисления,оно должно быть процитировано.</target>
        </trans-unit>
        <trans-unit id="288730aef18ef4aa044e0dc2a74d3a67ae251dbc" translate="yes" xml:space="preserve">
          <source>The expected parameter types for the prepared statement in the form of an array of &lt;code&gt;regtype&lt;/code&gt;. The OID corresponding to an element of this array can be obtained by casting the &lt;code&gt;regtype&lt;/code&gt; value to &lt;code&gt;oid&lt;/code&gt;.</source>
          <target state="translated">Ожидаемые типы параметров для подготовленного оператора в виде массива &lt;code&gt;regtype&lt;/code&gt; . OID , соответствующий элемент этого массива может быть получен путем отливки &lt;code&gt;regtype&lt;/code&gt; значения &lt;code&gt;oid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f35445a6307ee1d7e051209ff3712898a533184" translate="yes" xml:space="preserve">
          <source>The expected size of this file, as an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d73c415087d49efbf447ec5f41bf9143b5e43b5" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;IS DOCUMENT&lt;/code&gt; returns true if the argument XML value is a proper XML document, false if it is not (that is, it is a content fragment), or null if the argument is null. See &lt;a href=&quot;datatype-xml&quot;&gt;Section 8.13&lt;/a&gt; about the difference between documents and content fragments.</source>
          <target state="translated">Выражение &lt;code&gt;IS DOCUMENT&lt;/code&gt; возвращает true, если значение XML аргумента является правильным XML-документом, false, если это не так (то есть это фрагмент содержимого), или null, если аргумент имеет значение null. См. &lt;a href=&quot;datatype-xml&quot;&gt;Раздел 8.13&lt;/a&gt; о различиях между документами и фрагментами содержимого.</target>
        </trans-unit>
        <trans-unit id="d3f0f5215911482c31ec80c4c63789e99b22d5c9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;IS NOT DOCUMENT&lt;/code&gt; returns false if the argument XML value is a proper XML document, true if it is not (that is, it is a content fragment), or null if the argument is null.</source>
          <target state="translated">Выражение &lt;code&gt;IS NOT DOCUMENT&lt;/code&gt; возвращает false, если значение XML аргумента является правильным XML-документом, true, если это не так (то есть, это фрагмент содержимого), или null, если аргумент равен null.</target>
        </trans-unit>
        <trans-unit id="2fefc72765ee0edb8389edc8b54df23ebd5b6c13" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;collation for&lt;/code&gt; returns the collation of the value that is passed to it. Example:</source>
          <target state="translated">&lt;code&gt;collation for&lt;/code&gt; выражения для возвращает сопоставление переданного ему значения. Пример:</target>
        </trans-unit>
        <trans-unit id="9cec711d90ae7214afb1e767819f2c01ba82f2bc" translate="yes" xml:space="preserve">
          <source>The expression added to the WITH CHECK qualifications for queries that attempt to add rows to this table</source>
          <target state="translated">Выражение,добавленное к квалификации WITH CHECK для запросов,которые пытаются добавить строки в эту таблицу</target>
        </trans-unit>
        <trans-unit id="fa02a0029d6349d8e6423a393d9fb0288905f902" translate="yes" xml:space="preserve">
          <source>The expression added to the security barrier qualifications for queries that this policy applies to</source>
          <target state="translated">Выражение,добавленное к квалификации барьеров безопасности для запросов,к которым применима данная политика</target>
        </trans-unit>
        <trans-unit id="239121cdfc5b45b387f1658717f60a67584813d6" translate="yes" xml:space="preserve">
          <source>The expression tree to be added to the WITH CHECK qualifications for queries that attempt to add rows to the table</source>
          <target state="translated">Дерево выражений,которое должно быть добавлено в квалификацию WITH CHECK для запросов,которые пытаются добавить строки в таблицу</target>
        </trans-unit>
        <trans-unit id="710b7212dd7cdac519a9932cd2101a57cc49631a" translate="yes" xml:space="preserve">
          <source>The expression tree to be added to the security barrier qualifications for queries that use the table</source>
          <target state="translated">Дерево выражений,которое должно быть добавлено в квалификацию барьеров безопасности для запросов,использующих таблицу</target>
        </trans-unit>
        <trans-unit id="d2c435961e2d1a2d5fc091620a3b53aedf1bc369" translate="yes" xml:space="preserve">
          <source>The expression used in the &lt;code&gt;WHERE&lt;/code&gt; clause can refer only to columns of the underlying table, but it can use all columns, not just the ones being indexed. Presently, subqueries and aggregate expressions are also forbidden in &lt;code&gt;WHERE&lt;/code&gt;. The same restrictions apply to index fields that are expressions.</source>
          <target state="translated">Выражение, используемое в &lt;code&gt;WHERE&lt;/code&gt; , может относиться только к столбцам базовой таблицы, но может использовать все столбцы, а не только индексируемые. В настоящее время подзапросы и агрегатные выражения также запрещены в &lt;code&gt;WHERE&lt;/code&gt; . Те же ограничения применяются к индексным полям, которые являются выражениями.</target>
        </trans-unit>
        <trans-unit id="e44d27b215403bd620571252d0254bbcc4cec3b6" translate="yes" xml:space="preserve">
          <source>The expressions described in this section check properties of &lt;code&gt;xml&lt;/code&gt; values.</source>
          <target state="translated">Выражения, описанные в этом разделе, проверяют свойства значений &lt;code&gt;xml&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56934ce6588045922ec59583c810f1cb0acd84a1" translate="yes" xml:space="preserve">
          <source>The extensions currently available for loading can be identified from the &lt;a href=&quot;view-pg-available-extensions&quot;&gt;&lt;code&gt;pg_available_extensions&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;view-pg-available-extension-versions&quot;&gt;&lt;code&gt;pg_available_extension_versions&lt;/code&gt;&lt;/a&gt; system views.</source>
          <target state="translated">Расширения, доступные в настоящее время для загрузки, можно определить в &lt;a href=&quot;view-pg-available-extensions&quot;&gt; &lt;code&gt;pg_available_extensions&lt;/code&gt; &lt;/a&gt; представлениях pg_available_extensions или &lt;a href=&quot;view-pg-available-extension-versions&quot;&gt; &lt;code&gt;pg_available_extension_versions&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8afec2ee5b2d1b2e4a42a77922b5f5aca2fe0a53" translate="yes" xml:space="preserve">
          <source>The extensions for PL/Perl are called &lt;code&gt;jsonb_plperl&lt;/code&gt; and &lt;code&gt;jsonb_plperlu&lt;/code&gt;. If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Perl arrays, hashes, and scalars, as appropriate.</source>
          <target state="translated">Расширения для PL / Perl называются &lt;code&gt;jsonb_plperl&lt;/code&gt; и &lt;code&gt;jsonb_plperlu&lt;/code&gt; . Если вы их используете, значения &lt;code&gt;jsonb&lt;/code&gt; сопоставляются с массивами Perl, хешами и скалярами, если это необходимо.</target>
        </trans-unit>
        <trans-unit id="19e8b6e34d048aaf0ad16665bbe37cdf1acb53f4" translate="yes" xml:space="preserve">
          <source>The extensions for PL/Python are called &lt;code&gt;jsonb_plpythonu&lt;/code&gt;, &lt;code&gt;jsonb_plpython2u&lt;/code&gt;, and &lt;code&gt;jsonb_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Python dictionaries, lists, and scalars, as appropriate.</source>
          <target state="translated">Расширения для PL / Python называются &lt;code&gt;jsonb_plpythonu&lt;/code&gt; , &lt;code&gt;jsonb_plpython2u&lt;/code&gt; и &lt;code&gt;jsonb_plpython3u&lt;/code&gt; ( соглашение об именах PL / Python см. В &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Разделе 45.1&lt;/a&gt; ). Если вы их используете, значения &lt;code&gt;jsonb&lt;/code&gt; сопоставляются со словарями, списками и скалярами Python, если это необходимо.</target>
        </trans-unit>
        <trans-unit id="b34c58961fecd5bbfea5deffa1c8dc758272c022" translate="yes" xml:space="preserve">
          <source>The extensions for PL/Python are called &lt;code&gt;jsonb_plpythonu&lt;/code&gt;, &lt;code&gt;jsonb_plpython2u&lt;/code&gt;, and &lt;code&gt;jsonb_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Python dictionaries, lists, and scalars, as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f3501f99bc04897b07450c60fab261a8909a70" translate="yes" xml:space="preserve">
          <source>The extensions supplied with PostgreSQL are believed to be secure against installation-time attacks of this sort, except for a few that depend on other extensions. As stated in the documentation for those extensions, they should be installed into secure schemas, or installed into the same schemas as the extensions they depend on, or both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75cf68d4493c1ff227589e69d7f36aa6187d6f32" translate="yes" xml:space="preserve">
          <source>The extent of analysis can be controlled by adjusting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration variable, or on a column-by-column basis by setting the per-column statistics target with &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET STATISTICS&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;). The target value sets the maximum number of entries in the most-common-value list and the maximum number of bins in the histogram. The default target value is 100, but this can be adjusted up or down to trade off accuracy of planner estimates against the time taken for &lt;code&gt;ANALYZE&lt;/code&gt; and the amount of space occupied in &lt;code&gt;pg_statistic&lt;/code&gt;. In particular, setting the statistics target to zero disables collection of statistics for that column. It might be useful to do that for columns that are never used as part of the &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;ORDER BY&lt;/code&gt; clauses of queries, since the planner will have no use for statistics on such columns.</source>
          <target state="translated">Степень анализа можно контролировать, регулируя переменную конфигурации &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; , или на основе столбца за столбцом, задавая цель статистики для каждого столбца с помощью &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET STATISTICS&lt;/code&gt; (см. &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; ). Целевое значение устанавливает максимальное количество записей в списке наиболее часто используемых значений и максимальное количество интервалов в гистограмме. Целевое значение по умолчанию - 100, но его можно увеличить или уменьшить, чтобы &lt;code&gt;pg_statistic&lt;/code&gt; точность оценок планировщика со временем, затраченным на &lt;code&gt;ANALYZE&lt;/code&gt; , и объемом пространства, занятого в pg_statistic. В частности, установка цели статистики на ноль отключает сбор статистики для этого столбца. Это может быть полезно для столбцов, которые никогда не используются как часть &lt;code&gt;WHERE&lt;/code&gt; , &lt;code&gt;GROUP BY&lt;/code&gt; или &lt;code&gt;ORDER BY&lt;/code&gt; запросов, поскольку планировщик не будет использовать статистику по таким столбцам.</target>
        </trans-unit>
        <trans-unit id="4a1085020ce268691ef6285fd13220f59746e5a1" translate="yes" xml:space="preserve">
          <source>The external representation of an interval is formed using one or two floating-point numbers joined by the range operator (&lt;code&gt;..&lt;/code&gt; or &lt;code&gt;...&lt;/code&gt;). Alternatively, it can be specified as a center point plus or minus a deviation. Optional certainty indicators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;~&lt;/code&gt;) can be stored as well. (Certainty indicators are ignored by all the built-in operators, however.) &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;Table F.26&lt;/a&gt; gives an overview of allowed representations; &lt;a href=&quot;seg#SEG-INPUT-EXAMPLES&quot;&gt;Table F.27&lt;/a&gt; shows some examples.</source>
          <target state="translated">Внешнее представление интервала формируется с помощью одного или двух чисел с плавающей запятой, соединенных оператором диапазона ( &lt;code&gt;..&lt;/code&gt; или &lt;code&gt;...&lt;/code&gt; ). В качестве альтернативы его можно указать как центральную точку плюс или минус отклонение. Также можно сохранить дополнительные индикаторы достоверности ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; или &lt;code&gt;~&lt;/code&gt; ). (Однако индикаторы достоверности игнорируются всеми встроенными операторами.) &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;Таблица F.26&lt;/a&gt; дает обзор разрешенных представлений; &lt;a href=&quot;seg#SEG-INPUT-EXAMPLES&quot;&gt;В таблице F.27&lt;/a&gt; приведены некоторые примеры.</target>
        </trans-unit>
        <trans-unit id="ae94f4d8ec241ec4efa4661c23c0573db1da2b96" translate="yes" xml:space="preserve">
          <source>The external text representation of a composite value consists of items that are interpreted according to the I/O conversion rules for the individual field types, plus decoration that indicates the composite structure. The decoration consists of parentheses (&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt;) around the whole value, plus commas (&lt;code&gt;,&lt;/code&gt;) between adjacent items. Whitespace outside the parentheses is ignored, but within the parentheses it is considered part of the field value, and might or might not be significant depending on the input conversion rules for the field data type. For example, in:</source>
          <target state="translated">Внешнее текстовое представление составного значения состоит из элементов, которые интерпретируются в соответствии с правилами преобразования ввода-вывода для отдельных типов полей, плюс украшение, указывающее на составную структуру. Оформление состоит из круглых скобок ( &lt;code&gt;(&lt;/code&gt; и &lt;code&gt;)&lt;/code&gt; ) вокруг всего значения плюс запятые ( &lt;code&gt;,&lt;/code&gt; ) между соседними элементами. Пробелы за пределами круглых скобок игнорируются, но внутри скобок они считаются частью значения поля и могут иметь значение, а могут и не иметь значения в зависимости от правил преобразования ввода для типа данных поля. Например, в:</target>
        </trans-unit>
        <trans-unit id="165e79d513851869bfa7df4f3e60a06eff8eadcf" translate="yes" xml:space="preserve">
          <source>The external text representation of an array value consists of items that are interpreted according to the I/O conversion rules for the array's element type, plus decoration that indicates the array structure. The decoration consists of curly braces (&lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;) around the array value plus delimiter characters between adjacent items. The delimiter character is usually a comma (&lt;code&gt;,&lt;/code&gt;) but can be something else: it is determined by the &lt;code&gt;typdelim&lt;/code&gt; setting for the array's element type. Among the standard data types provided in the PostgreSQL distribution, all use a comma, except for type &lt;code&gt;box&lt;/code&gt;, which uses a semicolon (&lt;code&gt;;&lt;/code&gt;). In a multidimensional array, each dimension (row, plane, cube, etc.) gets its own level of curly braces, and delimiters must be written between adjacent curly-braced entities of the same level.</source>
          <target state="translated">Внешнее текстовое представление значения массива состоит из элементов, которые интерпретируются в соответствии с правилами преобразования ввода-вывода для типа элемента массива, плюс украшение, которое указывает структуру массива. Украшение состоит из фигурных скобок ( &lt;code&gt;{&lt;/code&gt; и &lt;code&gt;}&lt;/code&gt; ) вокруг значения массива и символов-разделителей между соседними элементами. Символ-разделитель обычно представляет собой запятую ( &lt;code&gt;,&lt;/code&gt; ), но может быть и другим: он определяется параметром &lt;code&gt;typdelim&lt;/code&gt; для типа элемента массива. Среди стандартных типов данных, представленных в дистрибутиве PostgreSQL, все используют запятую, за исключением &lt;code&gt;box&lt;/code&gt; типа , в котором используется точка с запятой ( &lt;code&gt;;&lt;/code&gt; ). В многомерном массиве каждое измерение (строка, плоскость, куб и т. Д.) Получает свой собственный уровень фигурных скобок, и разделители должны быть написаны между смежными фигурными скобками одного уровня.</target>
        </trans-unit>
        <trans-unit id="6b72823d964b50e21e643394f5a86559900b575c" translate="yes" xml:space="preserve">
          <source>The external, user defined, name of a replication origin.</source>
          <target state="translated">Внешнее,определяемое пользователем,имя источника репликации.</target>
        </trans-unit>
        <trans-unit id="b158be94edfd836340b3eb6a9fee5fccbd77513b" translate="yes" xml:space="preserve">
          <source>The fact that a result set is a relation means that a query can be used in the definition of another query, becoming a &lt;em&gt;subquery&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e10c575081917649336c89f16d01777906e835" translate="yes" xml:space="preserve">
          <source>The fact that constraint exclusion uses &lt;code&gt;CHECK&lt;/code&gt; constraints, which makes it slow compared to partition pruning, can sometimes be used as an advantage: because constraints can be defined even on declaratively-partitioned tables, in addition to their internal partition bounds, constraint exclusion may be able to elide additional partitions from the query plan.</source>
          <target state="translated">Тот факт, что исключение ограничений использует ограничения &lt;code&gt;CHECK&lt;/code&gt; , что делает его медленным по сравнению с сокращением секций, иногда может использоваться как преимущество: поскольку ограничения могут быть определены даже в декларативно секционированных таблицах, в дополнение к их внутренним границам секционирования, исключение ограничений может быть возможность исключить дополнительные разделы из плана запроса.</target>
        </trans-unit>
        <trans-unit id="19233032264a45feb14fbaa7d90f7412bf00d3b4" translate="yes" xml:space="preserve">
          <source>The factory default limit on open files is often set to &amp;ldquo;socially friendly&amp;rdquo; values that allow many users to coexist on a machine without using an inappropriate fraction of the system resources. If you run many servers on a machine this is perhaps what you want, but on dedicated servers you might want to raise this limit.</source>
          <target state="translated">Заводское ограничение по умолчанию для открытых файлов часто устанавливается на &amp;laquo;социально дружественные&amp;raquo; значения, которые позволяют многим пользователям сосуществовать на машине без использования несоответствующей части системных ресурсов. Если вы запускаете много серверов на машине, это, возможно, именно то, что вам нужно, но на выделенных серверах вы, возможно, захотите поднять этот предел.</target>
        </trans-unit>
        <trans-unit id="656ca22572866570d9b541e49d642f6e1926acfb" translate="yes" xml:space="preserve">
          <source>The field/element/path extraction operators return NULL, rather than failing, if the JSON input does not have the right structure to match the request; for example if no such key or array element exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb210aea67c31ef1dbed7fd3eae3f43ab6220c6" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; is only honored in macOS 10.3.9 and later. If you are running a previous 10.3.x release, you must edit the file &lt;code&gt;/etc/rc&lt;/code&gt; and change the values in the following commands:</source>
          <target state="translated">Файл &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; поддерживается только в macOS 10.3.9 и новее. Если вы используете предыдущую версию 10.3.x, вы должны отредактировать файл &lt;code&gt;/etc/rc&lt;/code&gt; и изменить значения в следующих командах:</target>
        </trans-unit>
        <trans-unit id="84e9c854c59c60e0df39d55604e40742c14a3b04" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;scan.l&lt;/code&gt; is transformed to the C source file &lt;code&gt;scan.c&lt;/code&gt; using the program flex and &lt;code&gt;gram.y&lt;/code&gt; is transformed to &lt;code&gt;gram.c&lt;/code&gt; using bison. After these transformations have taken place a normal C compiler can be used to create the parser. Never make any changes to the generated C files as they will be overwritten the next time flex or bison is called.</source>
          <target state="translated">Файл &lt;code&gt;scan.l&lt;/code&gt; преобразуется в исходный файл C &lt;code&gt;scan.c&lt;/code&gt; с помощью программы flex, а &lt;code&gt;gram.y&lt;/code&gt; преобразуется в &lt;code&gt;gram.c&lt;/code&gt; с помощью bison. После того, как эти преобразования были выполнены, для создания синтаксического анализатора можно использовать обычный компилятор C. Никогда не вносите никаких изменений в сгенерированные файлы C, так как они будут перезаписаны при следующем вызове flex или bison.</target>
        </trans-unit>
        <trans-unit id="45d0800a2dc4458be5cbd179d0ad2c43301c7d89" translate="yes" xml:space="preserve">
          <source>The file header consists of 15 bytes of fixed fields, followed by a variable-length header extension area. The fixed fields are:</source>
          <target state="translated">Заголовок файла состоит из 15 байт фиксированных полей,за которыми следует область расширения заголовка переменной длины.Фиксированные поля:</target>
        </trans-unit>
        <trans-unit id="08e8ce7451fee51ac789a7527b77201e50285954" translate="yes" xml:space="preserve">
          <source>The file name that will be used to store the history list. If unset, the file name is taken from the &lt;code&gt;PSQL_HISTORY&lt;/code&gt; environment variable. If that is not set either, the default is &lt;code&gt;~/.psql_history&lt;/code&gt;, or &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; on Windows. For example, putting:</source>
          <target state="translated">Имя файла, который будет использоваться для хранения списка истории. Если не задано, имя файла берется из переменной среды &lt;code&gt;PSQL_HISTORY&lt;/code&gt; . Если он тоже не установлен, по умолчанию используется &lt;code&gt;~/.psql_history&lt;/code&gt; или &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; в Windows. Например, поставив:</target>
        </trans-unit>
        <trans-unit id="349919ea5386038c9255234a7dc46c1f159466f8" translate="yes" xml:space="preserve">
          <source>The file trailer consists of a 16-bit integer word containing -1. This is easily distinguished from a tuple's field-count word.</source>
          <target state="translated">Файловый трейлер состоит из 16-битного целочисленного слова,содержащего -1.Это легко отличить от слова счетчика полей кортежа.</target>
        </trans-unit>
        <trans-unit id="80e18aa528aa991bd67d4fb018eb762c1dfd60ad" translate="yes" xml:space="preserve">
          <source>The fillfactor for a table is a percentage between 10 and 100. 100 (complete packing) is the default. When a smaller fillfactor is specified, &lt;code&gt;INSERT&lt;/code&gt; operations pack table pages only to the indicated percentage; the remaining space on each page is reserved for updating rows on that page. This gives &lt;code&gt;UPDATE&lt;/code&gt; a chance to place the updated copy of a row on the same page as the original, which is more efficient than placing it on a different page. For a table whose entries are never updated, complete packing is the best choice, but in heavily updated tables smaller fillfactors are appropriate. This parameter cannot be set for TOAST tables.</source>
          <target state="translated">Коэффициент заполнения таблицы - это процентное значение от 10 до 100. 100 (полная упаковка) - значение по умолчанию. Если указан меньший коэффициент заполнения, операции &lt;code&gt;INSERT&lt;/code&gt; упаковывают страницы таблицы только до указанного процента; оставшееся пространство на каждой странице зарезервировано для обновления строк на этой странице. Это дает &lt;code&gt;UPDATE&lt;/code&gt; возможность разместить обновленную копию строки на той же странице, что и оригинал, что более эффективно, чем размещение ее на другой странице. Для таблицы, записи которой никогда не обновляются, полная упаковка - лучший выбор, но для сильно обновляемых таблиц подходят меньшие факторы заполнения. Этот параметр нельзя установить для таблиц TOAST.</target>
        </trans-unit>
        <trans-unit id="4a018942b6effccffd16cfc6cd2d9f3b5906ea0a" translate="yes" xml:space="preserve">
          <source>The fillfactor for an index is a percentage that determines how full the index method will try to pack index pages. For B-trees, leaf pages are filled to this percentage during initial index build, and also when extending the index at the right (adding new largest key values). If pages subsequently become completely full, they will be split, leading to gradual degradation in the index's efficiency. B-trees use a default fillfactor of 90, but any integer value from 10 to 100 can be selected. If the table is static then fillfactor 100 is best to minimize the index's physical size, but for heavily updated tables a smaller fillfactor is better to minimize the need for page splits. The other index methods use fillfactor in different but roughly analogous ways; the default fillfactor varies between methods.</source>
          <target state="translated">Заполняющий коэффициент для индекса-это процент,который определяет,насколько полно метод индекса будет пытаться упаковать индексные страницы.Для B-деревьев листовые страницы заполняются до этого процента при первоначальном построении индекса,а также при расширении индекса справа (добавлении новых наибольших ключевых значений).Если впоследствии страницы будут полностью заполнены,они будут разделены,что приведет к постепенному снижению эффективности индекса.B-деревья используют коэффициент заполнения по умолчанию 90,но можно выбрать любое целое значение от 10 до 100.Если таблица статична,то лучше всего использовать коэффициент 100,чтобы минимизировать физический размер индекса,но для сильно обновляемых таблиц лучше использовать меньший коэффициент заполнения,чтобы минимизировать необходимость разбиения страниц.В других методах индекса коэффициент заполнения используется по-разному,но примерно аналогичным образом;коэффициент заполнения по умолчанию варьируется в зависимости от метода.</target>
        </trans-unit>
        <trans-unit id="5c29e42edd123c00869988ea11e4589bccf58ecb" translate="yes" xml:space="preserve">
          <source>The final section is the &amp;ldquo;special section&amp;rdquo; which can contain anything the access method wishes to store. For example, b-tree indexes store links to the page's left and right siblings, as well as some other data relevant to the index structure. Ordinary tables do not use a special section at all (indicated by setting &lt;code&gt;pd_special&lt;/code&gt; to equal the page size).</source>
          <target state="translated">Последний раздел - это &amp;laquo;специальный раздел&amp;raquo;, который может содержать все, что метод доступа желает сохранить. Например, индексы в виде b-дерева хранят ссылки на левых и правых братьев и сестер страницы, а также некоторые другие данные, относящиеся к структуре индекса. Обычные таблицы вообще не используют специальный раздел (это указывается установкой &lt;code&gt;pd_special&lt;/code&gt; равным размеру страницы).</target>
        </trans-unit>
        <trans-unit id="02efe302dcd79b9e88f3a8473b49b8f9d4ac5123" translate="yes" xml:space="preserve">
          <source>The finished plan tree consists of sequential or index scans of the base relations, plus nested-loop, merge, or hash join nodes as needed, plus any auxiliary steps needed, such as sort nodes or aggregate-function calculation nodes. Most of these plan node types have the additional ability to do &lt;em&gt;selection&lt;/em&gt; (discarding rows that do not meet a specified Boolean condition) and &lt;em&gt;projection&lt;/em&gt; (computation of a derived column set based on given column values, that is, evaluation of scalar expressions where needed). One of the responsibilities of the planner is to attach selection conditions from the &lt;code&gt;WHERE&lt;/code&gt; clause and computation of required output expressions to the most appropriate nodes of the plan tree.</source>
          <target state="translated">Готовое дерево плана состоит из последовательных или индексных сканирований базовых отношений, а также узлов вложенного цикла, слияния или хэш-соединения по мере необходимости, а также любых необходимых вспомогательных шагов, таких как узлы сортировки или узлы вычисления агрегатных функций. Большинство этих типов узлов плана имеют дополнительную возможность выполнять &lt;em&gt;выбор&lt;/em&gt; (отбрасывание строк, не соответствующих указанному логическому условию) и &lt;em&gt;проекцию&lt;/em&gt; (вычисление производного набора столбцов на основе заданных значений столбцов, то есть, при необходимости, оценка скалярных выражений) . Одна из обязанностей планировщика - привязать условия выбора из &lt;code&gt;WHERE&lt;/code&gt; и вычисление требуемых выходных выражений к наиболее подходящим узлам дерева плана.</target>
        </trans-unit>
        <trans-unit id="2f91a1368250aec82fa6c3ae45da03e945de99bb" translate="yes" xml:space="preserve">
          <source>The firing of triggers that are declared as &amp;ldquo;constraint triggers&amp;rdquo; is also controlled by this setting &amp;mdash; they fire at the same time that the associated constraint should be checked.</source>
          <target state="translated">Срабатывание триггеров, объявленных как &amp;laquo;триггеры ограничения&amp;raquo;, также контролируется этим параметром - они срабатывают одновременно с проверкой связанного ограничения.</target>
        </trans-unit>
        <trans-unit id="88e7caa4743ed2b44e88bb8540b5ed22e8f063f5" translate="yes" xml:space="preserve">
          <source>The first 24 bytes of each page consists of a page header (&lt;code&gt;PageHeaderData&lt;/code&gt;). Its format is detailed in &lt;a href=&quot;storage-page-layout#PAGEHEADERDATA-TABLE&quot;&gt;Table 68.3&lt;/a&gt;. The first field tracks the most recent WAL entry related to this page. The second field contains the page checksum if &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;data checksums&lt;/a&gt; are enabled. Next is a 2-byte field containing flag bits. This is followed by three 2-byte integer fields (&lt;code&gt;pd_lower&lt;/code&gt;, &lt;code&gt;pd_upper&lt;/code&gt;, and &lt;code&gt;pd_special&lt;/code&gt;). These contain byte offsets from the page start to the start of unallocated space, to the end of unallocated space, and to the start of the special space. The next 2 bytes of the page header, &lt;code&gt;pd_pagesize_version&lt;/code&gt;, store both the page size and a version indicator. Beginning with PostgreSQL 8.3 the version number is 4; PostgreSQL 8.1 and 8.2 used version number 3; PostgreSQL 8.0 used version number 2; PostgreSQL 7.3 and 7.4 used version number 1; prior releases used version number 0. (The basic page layout and header format has not changed in most of these versions, but the layout of heap row headers has.) The page size is basically only present as a cross-check; there is no support for having more than one page size in an installation. The last field is a hint that shows whether pruning the page is likely to be profitable: it tracks the oldest un-pruned XMAX on the page.</source>
          <target state="translated">Первые 24 байта каждой страницы состоят из заголовка страницы ( &lt;code&gt;PageHeaderData&lt;/code&gt; ). Его формат подробно описан в &lt;a href=&quot;storage-page-layout#PAGEHEADERDATA-TABLE&quot;&gt;Таблице 68.3&lt;/a&gt; . Первое поле отслеживает самую последнюю запись WAL, относящуюся к этой странице. Второе поле содержит контрольную сумму страницы, если &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;контрольные&lt;/a&gt; суммы данных включены. Далее идет 2-байтовое поле, содержащее биты флага. За ним следуют три 2-байтовых целочисленных поля ( &lt;code&gt;pd_lower&lt;/code&gt; , &lt;code&gt;pd_upper&lt;/code&gt; и &lt;code&gt;pd_special&lt;/code&gt; ). Они содержат байтовые смещения от начала страницы до начала нераспределенного пространства, до конца нераспределенного пространства и до начала специального пространства. Следующие 2 байта заголовка страницы, &lt;code&gt;pd_pagesize_version&lt;/code&gt; , сохраните и размер страницы, и индикатор версии. Начиная с PostgreSQL 8.3 номер версии - 4; PostgreSQL 8.1 и 8.2 использовала версию 3; PostgreSQL 8.0 использовал версию 2; PostgreSQL 7.3 и 7.4 использовали версию 1; предыдущие выпуски использовали номер версии 0. (Базовый макет страницы и формат заголовка не изменились в большинстве этих версий, но макет заголовков строк кучи изменился.) Размер страницы в основном присутствует только для перекрестной проверки; не поддерживается установка более одного размера страницы. Последнее поле является подсказкой, которая показывает, будет ли обрезка страницы выгодной: оно отслеживает самый старый необрезанный XMAX на странице.</target>
        </trans-unit>
        <trans-unit id="146b5ed003ceae9188015f907676c66e37810a01" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;UPDATE&lt;/code&gt; statement successfully acquires a row-level lock on the specified row, so it succeeds in updating that row. However, the second &lt;code&gt;UPDATE&lt;/code&gt; statement finds that the row it is attempting to update has already been locked, so it waits for the transaction that acquired the lock to complete. Transaction two is now waiting on transaction one to complete before it continues execution. Now, transaction one executes:</source>
          <target state="translated">Первый оператор &lt;code&gt;UPDATE&lt;/code&gt; успешно устанавливает блокировку на уровне строки для указанной строки, поэтому он успешно обновляет эту строку. Однако второй оператор &lt;code&gt;UPDATE&lt;/code&gt; обнаруживает, что строка, которую он пытается обновить, уже заблокирована, поэтому он ожидает завершения транзакции, получившей блокировку. Транзакция 2 теперь ожидает завершения транзакции 1, прежде чем продолжить выполнение. Теперь выполняется первая транзакция:</target>
        </trans-unit>
        <trans-unit id="5efcfda2d8c77b88473ca9337c42439a024d54ff" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;expression&lt;/code&gt; is computed, then compared to each of the &lt;code&gt;value&lt;/code&gt; expressions in the &lt;code&gt;WHEN&lt;/code&gt; clauses until one is found that is equal to it. If no match is found, the &lt;code&gt;result&lt;/code&gt; of the &lt;code&gt;ELSE&lt;/code&gt; clause (or a null value) is returned. This is similar to the &lt;code&gt;switch&lt;/code&gt; statement in C.</source>
          <target state="translated">Первое &lt;code&gt;expression&lt;/code&gt; вычисляется, затем сравнивается с каждым из выражений &lt;code&gt;value&lt;/code&gt; в предложениях &lt;code&gt;WHEN&lt;/code&gt; , пока не будет найдено одно, равное ему. Если совпадение не найдено, возвращается &lt;code&gt;result&lt;/code&gt; предложения &lt;code&gt;ELSE&lt;/code&gt; (или нулевое значение). Это похоже на оператор &lt;code&gt;switch&lt;/code&gt; в C.</target>
        </trans-unit>
        <trans-unit id="db81095a43bec432038707d12a55f4ea232797fc" translate="yes" xml:space="preserve">
          <source>The first approach makes use of the &lt;code&gt;cert&lt;/code&gt; authentication method for &lt;code&gt;hostssl&lt;/code&gt; entries in &lt;code&gt;pg_hba.conf&lt;/code&gt;, such that the certificate itself is used for authentication while also providing ssl connection security. See &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt; for details. (It is not necessary to specify any &lt;code&gt;clientcert&lt;/code&gt; options explicitly when using the &lt;code&gt;cert&lt;/code&gt; authentication method.) In this case, the &lt;code&gt;cn&lt;/code&gt; (Common Name) provided in the certificate is checked against the user name or an applicable mapping.</source>
          <target state="translated">Первый подход использует метод проверки подлинности &lt;code&gt;cert&lt;/code&gt; для записей &lt;code&gt;hostssl&lt;/code&gt; в &lt;code&gt;pg_hba.conf&lt;/code&gt; , так что сам сертификат используется для проверки подлинности, а также обеспечивает безопасность соединения ssl. См &lt;a href=&quot;auth-cert&quot;&gt;раздел 20.12&lt;/a&gt; для деталей. (Нет необходимости явно указывать какие- &lt;code&gt;clientcert&lt;/code&gt; параметры clientcert при использовании метода проверки подлинности &lt;code&gt;cert&lt;/code&gt; .) В этом случае &lt;code&gt;cn&lt;/code&gt; (общее имя), указанное в сертификате, проверяется на соответствие имени пользователя или применимому сопоставлению.</target>
        </trans-unit>
        <trans-unit id="44f0ace0e5a351af8867382fc6a4698f25099edc" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgChooseIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgChooseOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">Первый аргумент - это указатель на &lt;code&gt;spgChooseIn&lt;/code&gt; C spgChooseIn , содержащую входные данные для функции. Второй аргумент - это указатель на структуру &lt;code&gt;spgChooseOut&lt;/code&gt; C, которую функция должна заполнить данными результата.</target>
        </trans-unit>
        <trans-unit id="73a46dbd547b3476953fd0d40d226d75ab67a447" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgConfigIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgConfigOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">Первый аргумент - это указатель на &lt;code&gt;spgConfigIn&lt;/code&gt; C spgConfigIn , содержащую входные данные для функции. Второй аргумент - это указатель на C-структуру &lt;code&gt;spgConfigOut&lt;/code&gt; , которую функция должна заполнить данными результата.</target>
        </trans-unit>
        <trans-unit id="b3d25ba584bb4c4acb9f3461e219135398ddc741" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgInnerConsistentIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgInnerConsistentOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">Первый аргумент - это указатель на C-структуру &lt;code&gt;spgInnerConsistentIn&lt;/code&gt; , содержащую входные данные для функции. Второй аргумент - это указатель на структуру &lt;code&gt;spgInnerConsistentOut&lt;/code&gt; C, которую функция должна заполнить данными результата.</target>
        </trans-unit>
        <trans-unit id="4b95190547cc0ff307d0a7948518c66223c69217" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgLeafConsistentIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgLeafConsistentOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">Первый аргумент - это указатель на &lt;code&gt;spgLeafConsistentIn&lt;/code&gt; C spgLeafConsistentIn , содержащую входные данные для функции. Второй аргумент - это указатель на &lt;code&gt;spgLeafConsistentOut&lt;/code&gt; C spgLeafConsistentOut , которую функция должна заполнить данными результата.</target>
        </trans-unit>
        <trans-unit id="ca5853d09340bad3adb00c3e57ccca9e872f72bb" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgPickSplitIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgPickSplitOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">Первый аргумент - это указатель на &lt;code&gt;spgPickSplitIn&lt;/code&gt; C spgPickSplitIn , содержащую входные данные для функции. Второй аргумент - это указатель на C-структуру &lt;code&gt;spgPickSplitOut&lt;/code&gt; , которую функция должна заполнить данными результата.</target>
        </trans-unit>
        <trans-unit id="1f369dd1771752484284223f6c8b61724d963075" translate="yes" xml:space="preserve">
          <source>The first argument is the relation to be prewarmed. The second argument is the prewarming method to be used, as further discussed below; the third is the relation fork to be prewarmed, usually &lt;code&gt;main&lt;/code&gt;. The fourth argument is the first block number to prewarm (&lt;code&gt;NULL&lt;/code&gt; is accepted as a synonym for zero). The fifth argument is the last block number to prewarm (&lt;code&gt;NULL&lt;/code&gt; means prewarm through the last block in the relation). The return value is the number of blocks prewarmed.</source>
          <target state="translated">Первый аргумент - это отношение, которое нужно подогреть. Второй аргумент - это метод предварительного нагрева, который будет использоваться, как более подробно обсуждается ниже; третья - это относительная вилка, которую нужно предварительно разогреть, обычно &lt;code&gt;main&lt;/code&gt; . Четвертый аргумент - это номер первого блока для предварительного прогрева ( &lt;code&gt;NULL&lt;/code&gt; принимается как синоним нуля). Пятый аргумент - это номер последнего блока для предварительного нагрева ( &lt;code&gt;NULL&lt;/code&gt; означает предварительное нагревание до последнего блока в отношении). Возвращаемое значение - количество предварительно нагретых блоков.</target>
        </trans-unit>
        <trans-unit id="cd29c1ca625357cd146a327c957cb4b92e5a317e" translate="yes" xml:space="preserve">
          <source>The first century starts at 0001-01-01 00:00:00 AD, although they did not know it at the time. This definition applies to all Gregorian calendar countries. There is no century number 0, you go from -1 century to 1 century. If you disagree with this, please write your complaint to: Pope, Cathedral Saint-Peter of Roma, Vatican.</source>
          <target state="translated">Первый век начинается в 0001-01-01 00:00,хотя в то время они об этом не знали.Это определение применимо ко всем странам григорианского календаря.Нет столетия под номером 0,вы переходите от -1 века к 1 веку.Если вы не согласны с этим,пожалуйста,напишите вашу жалобу:Папе Римскому,собор Святого Петра,Ватикан.</target>
        </trans-unit>
        <trans-unit id="31c0daddd0e62eb1e65c5d8c244c78848b7fb826" translate="yes" xml:space="preserve">
          <source>The first certificate in &lt;code&gt;server.crt&lt;/code&gt; must be the server's certificate because it must match the server's private key. The certificates of &amp;ldquo;intermediate&amp;rdquo; certificate authorities can also be appended to the file. Doing this avoids the necessity of storing intermediate certificates on clients, assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions. (This sets the certificate's basic constraint of &lt;code&gt;CA&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.) This allows easier expiration of intermediate certificates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256263538ce2e1f28734e2b2ed2dbaa9ee5222c8" translate="yes" xml:space="preserve">
          <source>The first certificate in &lt;code&gt;server.crt&lt;/code&gt; must be the server's certificate because it must match the server's private key. The certificates of &amp;ldquo;intermediate&amp;rdquo; certificate authorities can also be appended to the file. Doing this avoids the necessity of storing intermediate certificates on clients, assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions. This allows easier expiration of intermediate certificates.</source>
          <target state="translated">Первый сертификат в &lt;code&gt;server.crt&lt;/code&gt; должен быть сертификатом сервера, потому что он должен соответствовать закрытому ключу сервера. К файлу также могут быть добавлены сертификаты &amp;laquo;промежуточных&amp;raquo; центров сертификации. Это позволяет избежать необходимости хранить промежуточные сертификаты на клиентах, предполагая, что корневой и промежуточный сертификаты были созданы с расширениями &lt;code&gt;v3_ca&lt;/code&gt; . Это упрощает истечение срока действия промежуточных сертификатов.</target>
        </trans-unit>
        <trans-unit id="79f3996eda734e252b355fcb3237a8e729927963" translate="yes" xml:space="preserve">
          <source>The first element specifies that a schema with the same name as the current user is to be searched. If no such schema exists, the entry is ignored. The second element refers to the public schema that we have seen already.</source>
          <target state="translated">Первый элемент указывает,что должна быть найдена схема с тем же именем,что и текущий пользователь.Если такой схемы нет,запись игнорируется.Второй элемент относится к публичной схеме,которую мы уже видели.</target>
        </trans-unit>
        <trans-unit id="f0dca4048f0fcfac6cd746615ce4e8a0baea6f2f" translate="yes" xml:space="preserve">
          <source>The first example adds a time zone to a value that lacks it, and displays the value using the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The second example shifts the time stamp with time zone value to the specified time zone, and returns the value without a time zone. This allows storage and display of values different from the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The third example converts Tokyo time to Chicago time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd1c81747f7da19e4955a86256d7b17a34ec6f9" translate="yes" xml:space="preserve">
          <source>The first example adds a time zone to a value that lacks it, and displays the value using the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The second example shifts the time stamp with time zone value to the specified time zone, and returns the value without a time zone. This allows storage and display of values different from the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The third example converts Tokyo time to Chicago time. Converting &lt;em&gt;time&lt;/em&gt; values to other time zones uses the currently active time zone rules since no date is supplied.</source>
          <target state="translated">В первом примере часовой пояс добавляется к отсутствующему значению и отображается значение с использованием текущего параметра &lt;code&gt;TimeZone&lt;/code&gt; . Во втором примере метка времени со значением часового пояса сдвигается на указанный часовой пояс и возвращается значение без часового пояса. Это позволяет сохранять и отображать значения, отличные от текущей настройки &lt;code&gt;TimeZone&lt;/code&gt; . В третьем примере время Токио преобразуется во время Чикаго. При преобразовании значений &lt;em&gt;времени&lt;/em&gt; в другие часовые пояса используются текущие активные правила часовых поясов, поскольку дата не указана.</target>
        </trans-unit>
        <trans-unit id="dd4f388d81712247b36f96199e31fe01ab0dcd8a" translate="yes" xml:space="preserve">
          <source>The first example omits &lt;code&gt;ROW&lt;/code&gt;, the second uses it; we could have done it either way.</source>
          <target state="translated">В первом примере &lt;code&gt;ROW&lt;/code&gt; отсутствует , во втором используется; мы могли сделать это в любом случае.</target>
        </trans-unit>
        <trans-unit id="612c7d9435df3c5121ea73e09ab866021bad4c1b" translate="yes" xml:space="preserve">
          <source>The first example selects the ICU locale using a &amp;ldquo;language tag&amp;rdquo; per BCP 47. The second example uses the traditional ICU-specific locale syntax. The first style is preferred going forward, but it is not supported by older ICU versions.</source>
          <target state="translated">В первом примере языковой стандарт ICU выбирается с помощью &amp;laquo;языкового тега&amp;raquo; согласно BCP 47. Во втором примере используется традиционный синтаксис языкового стандарта, специфичный для ICU. В дальнейшем предпочтительнее использовать первый стиль, но он не поддерживается более старыми версиями ICU.</target>
        </trans-unit>
        <trans-unit id="f1d60b8c5a21ae5115bceb8211e299ddf895cf0f" translate="yes" xml:space="preserve">
          <source>The first example shows how to spread a command over several lines of input. Notice the changing prompt:</source>
          <target state="translated">Первый пример показывает,как распределить команду по нескольким строкам ввода.Обратите внимание на приглашение на изменение:</target>
        </trans-unit>
        <trans-unit id="e43256b97dc53da480190315bac59bb3f0cada5f" translate="yes" xml:space="preserve">
          <source>The first form changes certain per-database settings. (See below for details.) Only the database owner or a superuser can change these settings.</source>
          <target state="translated">Первая форма изменяет некоторые настройки для каждой базы данных.(Подробнее см.ниже.)Только владелец базы данных или суперпользователь может изменить эти настройки.</target>
        </trans-unit>
        <trans-unit id="da17ae59b4b9d415d049588fbe4c802a8a77a808" translate="yes" xml:space="preserve">
          <source>The first form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a composite type. The composite type is specified by a list of attribute names and data types. An attribute's collation can be specified too, if its data type is collatable. A composite type is essentially the same as the row type of a table, but using &lt;code&gt;CREATE TYPE&lt;/code&gt; avoids the need to create an actual table when all that is wanted is to define a type. A stand-alone composite type is useful, for example, as the argument or return type of a function.</source>
          <target state="translated">Первая форма &lt;code&gt;CREATE TYPE&lt;/code&gt; создает составной тип. Составной тип определяется списком имен атрибутов и типов данных. Также можно указать сопоставление атрибута, если его тип данных является сопоставимым. Составной тип по существу совпадает с типом строки таблицы, но использование &lt;code&gt;CREATE TYPE&lt;/code&gt; позволяет избежать необходимости создавать фактическую таблицу, когда все, что нужно, - это определить тип. Автономный составной тип полезен, например, как тип аргумента или возвращаемого значения функции.</target>
        </trans-unit>
        <trans-unit id="a9da06ff6dbdef653da94da0ffaf44a0aef0024f" translate="yes" xml:space="preserve">
          <source>The first form of aggregate expression invokes the aggregate once for each input row. The second form is the same as the first, since &lt;code&gt;ALL&lt;/code&gt; is the default. The third form invokes the aggregate once for each distinct value of the expression (or distinct set of values, for multiple expressions) found in the input rows. The fourth form invokes the aggregate once for each input row; since no particular input value is specified, it is generally only useful for the &lt;code&gt;count(*)&lt;/code&gt; aggregate function. The last form is used with &lt;em&gt;ordered-set&lt;/em&gt; aggregate functions, which are described below.</source>
          <target state="translated">Первая форма агрегатного выражения вызывает агрегат один раз для каждой входной строки. Вторая форма такая же, как первая, так как &lt;code&gt;ALL&lt;/code&gt; по умолчанию. Третья форма вызывает агрегат один раз для каждого отдельного значения выражения (или отдельного набора значений для нескольких выражений), найденного во входных строках. Четвертая форма вызывает агрегат один раз для каждой входной строки; поскольку конкретное входное значение не указано, оно обычно используется только для агрегатной функции &lt;code&gt;count(*)&lt;/code&gt; . Последняя форма используется с агрегатными функциями &lt;em&gt;упорядоченного набора&lt;/em&gt; , которые описаны ниже.</target>
        </trans-unit>
        <trans-unit id="c6c37d2c4cb9171a6fcf0c1214edbc6145fc4b4d" translate="yes" xml:space="preserve">
          <source>The first form of the &lt;code&gt;CREATE TYPE&lt;/code&gt; command, which creates a composite type, conforms to the SQL standard. The other forms are PostgreSQL extensions. The &lt;code&gt;CREATE TYPE&lt;/code&gt; statement in the SQL standard also defines other forms that are not implemented in PostgreSQL.</source>
          <target state="translated">Первая форма команды &lt;code&gt;CREATE TYPE&lt;/code&gt; , которая создает составной тип, соответствует стандарту SQL. Другие формы - это расширения PostgreSQL. Оператор &lt;code&gt;CREATE TYPE&lt;/code&gt; в стандарте SQL также определяет другие формы, которые не реализованы в PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="c38ff028812a13bb491adf5222d97dc3de42b820" translate="yes" xml:space="preserve">
          <source>The first line of an affix class is the header. Fields of an affix rules are listed after the header:</source>
          <target state="translated">Первая строка класса аффиксов-это заголовок.Поля правил аффиксов перечислены после заголовка:</target>
        </trans-unit>
        <trans-unit id="c36e2c0d0e2475af262a16c7939f4fd6fcb834b7" translate="yes" xml:space="preserve">
          <source>The first number in the &lt;code&gt;-L&lt;/code&gt; argument, 63333, is the local port number of the tunnel; it can be any unused port. (IANA reserves ports 49152 through 65535 for private use.) The name or IP address after this is the remote bind address you are connecting to, i.e., &lt;code&gt;localhost&lt;/code&gt;, which is the default. The second number, 5432, is the remote end of the tunnel, e.g., the port number your database server is using. In order to connect to the database server using this tunnel, you connect to port 63333 on the local machine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e805cf56cf5d6631bb0160a0e06bad5df15b037" translate="yes" xml:space="preserve">
          <source>The first number in the &lt;code&gt;-L&lt;/code&gt; argument, 63333, is the port number of your end of the tunnel; it can be any unused port. (IANA reserves ports 49152 through 65535 for private use.) The second number, 5432, is the remote end of the tunnel: the port number your server is using. The name or IP address between the port numbers is the host with the database server you are going to connect to, as seen from the host you are logging in to, which is &lt;code&gt;foo.com&lt;/code&gt; in this example. In order to connect to the database server using this tunnel, you connect to port 63333 on the local machine:</source>
          <target state="translated">Первое число в аргументе &lt;code&gt;-L&lt;/code&gt; , 63333, - это номер порта вашего конца туннеля; это может быть любой неиспользуемый порт. (IANA резервирует порты с 49152 по 65535 для частного использования.) Второй номер, 5432, является удаленным концом туннеля: номер порта, который использует ваш сервер. Имя или IP-адрес между номерами портов - это хост с сервером базы данных, к которому вы собираетесь подключиться, как видно с хоста, на который вы &lt;code&gt;foo.com&lt;/code&gt; , которым в данном примере является foo.com . Чтобы подключиться к серверу базы данных с помощью этого туннеля, вы подключаетесь к порту 63333 на локальном компьютере:</target>
        </trans-unit>
        <trans-unit id="3f99873fa941c47208f84d01e9069ef478e98de2" translate="yes" xml:space="preserve">
          <source>The first one worked using &lt;em&gt;row level&lt;/em&gt; processing and was implemented deep in the &lt;em&gt;executor&lt;/em&gt;. The rule system was called whenever an individual row had been accessed. This implementation was removed in 1995 when the last official release of the Berkeley Postgres project was transformed into Postgres95.</source>
          <target state="translated">Первый работал с обработкой на &lt;em&gt;уровне строк&lt;/em&gt; и был реализован глубоко в &lt;em&gt;исполнителе&lt;/em&gt; . Система правил вызывалась всякий раз, когда осуществлялся доступ к отдельной строке. Эта реализация была удалена в 1995 году, когда последний официальный выпуск проекта Berkeley Postgres был преобразован в Postgres95.</target>
        </trans-unit>
        <trans-unit id="0fa18c39fe287e28bd5e7314fe8af5727d16d727" translate="yes" xml:space="preserve">
          <source>The first schema in the search path that exists is the default location for creating new objects. That is the reason that by default objects are created in the public schema. When objects are referenced in any other context without schema qualification (table modification, data modification, or query commands) the search path is traversed until a matching object is found. Therefore, in the default configuration, any unqualified access again can only refer to the public schema.</source>
          <target state="translated">Первая схема в существующем пути поиска-это место по умолчанию для создания новых объектов.По этой причине объекты по умолчанию создаются в публичной схеме.Когда на объекты ссылаются в любом другом контексте без квалификации схемы (модификация таблицы,изменение данных или команды запроса),путь поиска проходит до тех пор,пока не будет найден подходящий объект.Поэтому,в конфигурации по умолчанию,любой неквалифицированный доступ снова может ссылаться только на публичную схему.</target>
        </trans-unit>
        <trans-unit id="9f3413da7a0291a52f1a7dcc2b820079440b3c54" translate="yes" xml:space="preserve">
          <source>The first schema named in the search path is called the current schema. Aside from being the first schema searched, it is also the schema in which new tables will be created if the &lt;code&gt;CREATE TABLE&lt;/code&gt; command does not specify a schema name.</source>
          <target state="translated">Первая схема, указанная в пути поиска, называется текущей схемой. Помимо того, что поиск является первой схемой, это также схема, в которой будут создаваться новые таблицы, если команда &lt;code&gt;CREATE TABLE&lt;/code&gt; не указывает имя схемы.</target>
        </trans-unit>
        <trans-unit id="9d12bc7a9f0942909d34ace4bd41d7e184667d01" translate="yes" xml:space="preserve">
          <source>The first six lines report some of the most important parameter settings. The next line reports the number of transactions completed and intended (the latter being just the product of number of clients and number of transactions per client); these will be equal unless the run failed before completion. (In &lt;code&gt;-T&lt;/code&gt; mode, only the actual number of transactions is printed.) The last two lines report the number of transactions per second, figured with and without counting the time to start database sessions.</source>
          <target state="translated">Первые шесть строк сообщают о некоторых наиболее важных настройках параметров. В следующей строке указывается количество завершенных и запланированных транзакций (последнее является просто произведением количества клиентов и количества транзакций на одного клиента); они будут равны, если прогон не завершился неудачно. (В режиме &lt;code&gt;-T&lt;/code&gt; печатается только фактическое количество транзакций.) Последние две строки сообщают количество транзакций в секунду, рассчитанное с учетом и без учета времени начала сеансов базы данных.</target>
        </trans-unit>
        <trans-unit id="46861698534eb993d5363434e9d5cb2bd00b93d2" translate="yes" xml:space="preserve">
          <source>The first step is to generate an auxiliary table containing all the unique words in the documents:</source>
          <target state="translated">Первый шаг-создание вспомогательной таблицы,содержащей все уникальные слова в документах:</target>
        </trans-unit>
        <trans-unit id="d440c66135f418ef7372813549a4be5ffe416b8b" translate="yes" xml:space="preserve">
          <source>The first test to see whether you can access the database server is to try to create a database. A running PostgreSQL server can manage many databases. Typically, a separate database is used for each project or for each user.</source>
          <target state="translated">Первый тест,чтобы увидеть,можете ли вы получить доступ к серверу базы данных,заключается в попытке создать базу данных.Запущенный PostgreSQL-сервер может управлять многими базами данных.Обычно для каждого проекта или для каждого пользователя используется отдельная база данных.</target>
        </trans-unit>
        <trans-unit id="c00d09908f3f4ddbf657d8ad0f17eabf84136b00" translate="yes" xml:space="preserve">
          <source>The first three output columns come directly from the table &lt;code&gt;empsalary&lt;/code&gt;, and there is one output row for each row in the table. The fourth column represents an average taken across all the table rows that have the same &lt;code&gt;depname&lt;/code&gt; value as the current row. (This actually is the same function as the non-window &lt;code&gt;avg&lt;/code&gt; aggregate, but the &lt;code&gt;OVER&lt;/code&gt; clause causes it to be treated as a window function and computed across the window frame.)</source>
          <target state="translated">Первые три выходных столбца берутся непосредственно из таблицы &lt;code&gt;empsalary&lt;/code&gt; , и для каждой строки таблицы есть одна выходная строка. Четвертый столбец представляет собой среднее значение по всем строкам таблицы, которые имеют то же значение имени &lt;code&gt;depname&lt;/code&gt; что и текущая строка. (На самом деле это та же функция, что и агрегат &lt;code&gt;avg&lt;/code&gt; без окна , но предложение &lt;code&gt;OVER&lt;/code&gt; приводит к тому, что она обрабатывается как оконная функция и вычисляется во всей рамке окна.)</target>
        </trans-unit>
        <trans-unit id="c0413166d43e378dc8855747d05360346ec4b249" translate="yes" xml:space="preserve">
          <source>The first three parameters are inputs:</source>
          <target state="translated">Первые три параметра-это входы:</target>
        </trans-unit>
        <trans-unit id="54956845c90a8b39103dc2ab8d6e4402b710d114" translate="yes" xml:space="preserve">
          <source>The first three variants change which tables are part of the publication. The &lt;code&gt;SET TABLE&lt;/code&gt; clause will replace the list of tables in the publication with the specified one. The &lt;code&gt;ADD TABLE&lt;/code&gt; and &lt;code&gt;DROP TABLE&lt;/code&gt; clauses will add and remove one or more tables from the publication. Note that adding tables to a publication that is already subscribed to will require a &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; action on the subscribing side in order to become effective.</source>
          <target state="translated">Первые три варианта изменяют, какие таблицы являются частью публикации. Предложение &lt;code&gt;SET TABLE&lt;/code&gt; заменит список таблиц в публикации на указанный. Предложения &lt;code&gt;ADD TABLE&lt;/code&gt; и &lt;code&gt;DROP TABLE&lt;/code&gt; добавляют и удаляют одну или несколько таблиц из публикации. Обратите внимание, что добавление таблиц к публикации, на которую уже подписана подписка, потребует действия &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; на подписывающей стороне, чтобы оно вступило в силу.</target>
        </trans-unit>
        <trans-unit id="70d5b4450dbfd9e788e4338d7701eefa6a67f05f" translate="yes" xml:space="preserve">
          <source>The first trigger argument must be the name of the &lt;code&gt;tsvector&lt;/code&gt; column to be updated. The second argument specifies the text search configuration to be used to perform the conversion. For &lt;code&gt;tsvector_update_trigger&lt;/code&gt;, the configuration name is simply given as the second trigger argument. It must be schema-qualified as shown above, so that the trigger behavior will not change with changes in &lt;code&gt;search_path&lt;/code&gt;. For &lt;code&gt;tsvector_update_trigger_column&lt;/code&gt;, the second trigger argument is the name of another table column, which must be of type &lt;code&gt;regconfig&lt;/code&gt;. This allows a per-row selection of configuration to be made. The remaining argument(s) are the names of textual columns (of type &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, or &lt;code&gt;char&lt;/code&gt;). These will be included in the document in the order given. NULL values will be skipped (but the other columns will still be indexed).</source>
          <target state="translated">Первым аргументом триггера должно быть имя &lt;code&gt;tsvector&lt;/code&gt; столбца tsvector . Второй аргумент указывает конфигурацию текстового поиска, которая будет использоваться для выполнения преобразования. Для &lt;code&gt;tsvector_update_trigger&lt;/code&gt; имя конфигурации просто указывается как второй аргумент триггера. Он должен быть дополнен схемой, как показано выше, чтобы поведение триггера не изменилось при изменении &lt;code&gt;search_path&lt;/code&gt; . Для &lt;code&gt;tsvector_update_trigger_column&lt;/code&gt; второй аргумент триггера - это имя другого столбца таблицы, который должен иметь тип &lt;code&gt;regconfig&lt;/code&gt; . Это позволяет выбирать конфигурацию для каждой строки. Остальные аргументы - это имена текстовых столбцов (типа &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;varchar&lt;/code&gt; , или &lt;code&gt;char&lt;/code&gt; ). Они будут включены в документ в указанном порядке. Значения NULL будут пропущены (но остальные столбцы все равно будут проиндексированы).</target>
        </trans-unit>
        <trans-unit id="01ce9912b77202e1b48ed397f2bfc3b3783947c2" translate="yes" xml:space="preserve">
          <source>The first two constraints should look familiar. The third one uses a new syntax. It is not attached to a particular column, instead it appears as a separate item in the comma-separated column list. Column definitions and these constraint definitions can be listed in mixed order.</source>
          <target state="translated">Первые два ограничения должны выглядеть знакомо.Третий использует новый синтаксис.Он не привязывается к конкретному столбцу,а появляется как отдельный элемент в списке столбцов,разделенных запятыми.Определения столбцов и эти ограничения могут быть перечислены в смешанном порядке.</target>
        </trans-unit>
        <trans-unit id="2927557f90bef3d374c5198102a6e3ea28461171" translate="yes" xml:space="preserve">
          <source>The first two of these we saw already. The form &lt;code&gt;text&lt;/code&gt;&lt;code&gt;@@&lt;/code&gt;&lt;code&gt;tsquery&lt;/code&gt; is equivalent to &lt;code&gt;to_tsvector(x) @@ y&lt;/code&gt;. The form &lt;code&gt;text&lt;/code&gt;&lt;code&gt;@@&lt;/code&gt;&lt;code&gt;text&lt;/code&gt; is equivalent to &lt;code&gt;to_tsvector(x) @@ plainto_tsquery(y)&lt;/code&gt;.</source>
          <target state="translated">Первые два из них мы уже видели. Форма &lt;code&gt;text&lt;/code&gt; &lt;code&gt;@@&lt;/code&gt; &lt;code&gt;tsquery&lt;/code&gt; эквивалентно &lt;code&gt;to_tsvector(x) @@ y&lt;/code&gt; . Форма &lt;code&gt;text&lt;/code&gt; &lt;code&gt;@@&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; эквивалентен &lt;code&gt;to_tsvector(x) @@ plainto_tsquery(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdaab7b9b529bcc8f6406321204002fe17ed4b88" translate="yes" xml:space="preserve">
          <source>The first two output columns are used for the current row's key and its parent row's key; they must match the type of the table's key field. The third output column is the depth in the tree and must be of type &lt;code&gt;integer&lt;/code&gt;. If a &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; parameter was given, the next output column is the branch display and must be of type &lt;code&gt;text&lt;/code&gt;. Finally, if an &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; parameter was given, the last output column is a serial number, and must be of type &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="translated">Первые два выходных столбца используются для ключа текущей строки и ключа ее родительской строки; они должны соответствовать типу ключевого поля таблицы. Третий выходной столбец - это глубина дерева, и он должен иметь &lt;code&gt;integer&lt;/code&gt; тип . Если был &lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt; параметр &lt;em&gt;branch_delim&lt;/em&gt; , следующий выходной столбец является отображением ветви и должен иметь &lt;code&gt;text&lt;/code&gt; тип . Наконец, если был &lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt; параметр &lt;em&gt;orderby_fld&lt;/em&gt; , последний выходной столбец является серийным номером и должен иметь &lt;code&gt;integer&lt;/code&gt; тип .</target>
        </trans-unit>
        <trans-unit id="bf7215eea980a2a0bf86f75a412a5f3cd60fbcd5" translate="yes" xml:space="preserve">
          <source>The first two variants add users to a group or remove them from a group. (Any role can play the part of either a &amp;ldquo;user&amp;rdquo; or a &amp;ldquo;group&amp;rdquo; for this purpose.) These variants are effectively equivalent to granting or revoking membership in the role named as the &amp;ldquo;group&amp;rdquo;; so the preferred way to do this is to use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; or &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;.</source>
          <target state="translated">Первые два варианта добавляют пользователей в группу или удаляют их из группы. (Для этой цели любая роль может играть роль либо &amp;laquo;пользователя&amp;raquo;, либо &amp;laquo;группы&amp;raquo;.) Эти варианты фактически эквивалентны предоставлению или отмене членства в роли, названной &amp;laquo;группа&amp;raquo;; поэтому предпочтительный способ сделать это - использовать &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; или &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="586ee19112a7a3ecf50504f1b0e758b680347d53" translate="yes" xml:space="preserve">
          <source>The first variant of this command listed in the synopsis can change many of the role attributes that can be specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. (All the possible attributes are covered, except that there are no options for adding or removing memberships; use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; for that.) Attributes not mentioned in the command retain their previous settings. Database superusers can change any of these settings for any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can change any of these settings except &lt;code&gt;SUPERUSER&lt;/code&gt;, &lt;code&gt;REPLICATION&lt;/code&gt;, and &lt;code&gt;BYPASSRLS&lt;/code&gt;; but only for non-superuser and non-replication roles. Ordinary roles can only change their own password.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5e370e58213823b4126e17f4b6e7ad4cef2b17" translate="yes" xml:space="preserve">
          <source>The first variant of this command listed in the synopsis can change many of the role attributes that can be specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. (All the possible attributes are covered, except that there are no options for adding or removing memberships; use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; for that.) Attributes not mentioned in the command retain their previous settings. Database superusers can change any of these settings for any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can change any of these settings, but only for non-superuser and non-replication roles. Ordinary roles can only change their own password.</source>
          <target state="translated">Первый вариант этой команды, указанный в синопсисе, может изменить многие атрибуты роли, которые могут быть указаны в &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; . (Охвачены все возможные атрибуты, за исключением того, что нет никаких опций для добавления или удаления членства; для этого используйте &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; и &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; .) Атрибуты, не упомянутые в команде, сохраняют свои предыдущие настройки. Суперпользователи базы данных могут изменить любой из этих параметров для любой роли. Роли с привилегией &lt;code&gt;CREATEROLE&lt;/code&gt; могут изменять любой из этих параметров, но только для ролей без суперпользователя и без репликации. Обычные роли могут изменять только собственный пароль.</target>
        </trans-unit>
        <trans-unit id="25ae6ee44a0f0d836e1704c794f00aceb8d356c4" translate="yes" xml:space="preserve">
          <source>The five mandatory user-defined methods are:</source>
          <target state="translated">Пять обязательных пользовательских методов:</target>
        </trans-unit>
        <trans-unit id="72ce333d0c25ef1597b4fa8ad61ed91fb435220e" translate="yes" xml:space="preserve">
          <source>The following &amp;ldquo;parameters&amp;rdquo; are read-only, and are determined when PostgreSQL is compiled or when it is installed. As such, they have been excluded from the sample &lt;code&gt;postgresql.conf&lt;/code&gt; file. These options report various aspects of PostgreSQL behavior that might be of interest to certain applications, particularly administrative front-ends.</source>
          <target state="translated">Следующие &amp;laquo;параметры&amp;raquo; доступны только для чтения и определяются при компиляции PostgreSQL или при его установке. Таким образом, они были исключены из образца файла &lt;code&gt;postgresql.conf&lt;/code&gt; . Эти параметры сообщают о различных аспектах поведения PostgreSQL, которые могут представлять интерес для определенных приложений, особенно для административных интерфейсов.</target>
        </trans-unit>
        <trans-unit id="a28614c3e8ef3dfbb002911a23857ed9cadcc2f2" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;method&lt;/code&gt;s for collecting the write-ahead logs are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="771558088b2464a0c70d76532be21bcb4ca8194b" translate="yes" xml:space="preserve">
          <source>The following SQL-compatible functions can also be used to obtain the current time value for the corresponding data type: &lt;code&gt;CURRENT_DATE&lt;/code&gt;, &lt;code&gt;CURRENT_TIME&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, &lt;code&gt;LOCALTIME&lt;/code&gt;, &lt;code&gt;LOCALTIMESTAMP&lt;/code&gt;. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-CURRENT&quot;&gt;Section 9.9.4&lt;/a&gt;.) Note that these are SQL functions and are &lt;em&gt;not&lt;/em&gt; recognized in data input strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f94e73cd2b87aba8e9913a22c540c941db79c62c" translate="yes" xml:space="preserve">
          <source>The following SQL-compatible functions can also be used to obtain the current time value for the corresponding data type: &lt;code&gt;CURRENT_DATE&lt;/code&gt;, &lt;code&gt;CURRENT_TIME&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, &lt;code&gt;LOCALTIME&lt;/code&gt;, &lt;code&gt;LOCALTIMESTAMP&lt;/code&gt;. The latter four accept an optional subsecond precision specification. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-CURRENT&quot;&gt;Section 9.9.4&lt;/a&gt;.) Note that these are SQL functions and are &lt;em&gt;not&lt;/em&gt; recognized in data input strings.</source>
          <target state="translated">Следующие SQL-совместимые функции также могут использоваться для получения текущего значения времени для соответствующего типа данных: &lt;code&gt;CURRENT_DATE&lt;/code&gt; , &lt;code&gt;CURRENT_TIME&lt;/code&gt; , &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; , &lt;code&gt;LOCALTIME&lt;/code&gt; , &lt;code&gt;LOCALTIMESTAMP&lt;/code&gt; . Последние четыре принимают необязательную спецификацию субсекундной точности. (См. &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-CURRENT&quot;&gt;Раздел 9.9.4&lt;/a&gt; .) Обратите внимание, что это функции SQL и &lt;em&gt;не&lt;/em&gt; распознаются в строках ввода данных.</target>
        </trans-unit>
        <trans-unit id="7345097a3373ddd38c8dbf7f484bcb7a83adcfc5" translate="yes" xml:space="preserve">
          <source>The following SQL-standard functions work on bit strings as well as character strings: &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;bit_length&lt;/code&gt;, &lt;code&gt;octet_length&lt;/code&gt;, &lt;code&gt;position&lt;/code&gt;, &lt;code&gt;substring&lt;/code&gt;, &lt;code&gt;overlay&lt;/code&gt;.</source>
          <target state="translated">Следующие стандартные функции SQL работают как с битовыми строками, так и с символьными строками: &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;bit_length&lt;/code&gt; , &lt;code&gt;octet_length&lt;/code&gt; , &lt;code&gt;position&lt;/code&gt; , &lt;code&gt;substring&lt;/code&gt; , &lt;code&gt;overlay&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bd2c2e8eaa4afd48046645ba794fcbca53b28f4" translate="yes" xml:space="preserve">
          <source>The following additional options are available:</source>
          <target state="translated">Доступны следующие дополнительные опции:</target>
        </trans-unit>
        <trans-unit id="0f218f3efdde351da4f071874c06c4afe80e209d" translate="yes" xml:space="preserve">
          <source>The following are all valid &lt;code&gt;json&lt;/code&gt; (or &lt;code&gt;jsonb&lt;/code&gt;) expressions:</source>
          <target state="translated">Ниже приведены все допустимые выражения &lt;code&gt;json&lt;/code&gt; (или &lt;code&gt;jsonb&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="c039bfa9f08ddfc0a59acd61d84cddcf4b0d6ac9" translate="yes" xml:space="preserve">
          <source>The following caveats apply to constraint exclusion:</source>
          <target state="translated">Следующие предостережения относятся к исключению ограничений:</target>
        </trans-unit>
        <trans-unit id="ed89af6d7b571e68348aa46975289d8d36b6f9e9" translate="yes" xml:space="preserve">
          <source>The following caveats apply to partitioning implemented using inheritance:</source>
          <target state="translated">Следующие предостережения относятся к разметке,реализованной с помощью наследования:</target>
        </trans-unit>
        <trans-unit id="29e533c6b217bf172992ac716839050a2d3fd0b7" translate="yes" xml:space="preserve">
          <source>The following command can be used to create an index on the &lt;code&gt;id&lt;/code&gt; column, as discussed:</source>
          <target state="translated">Следующая команда может использоваться для создания индекса столбца &lt;code&gt;id&lt;/code&gt; , как уже говорилось:</target>
        </trans-unit>
        <trans-unit id="4545d07872378e0f1220b619c3281f607f171dfb" translate="yes" xml:space="preserve">
          <source>The following command defines a new operator, area-equality, for the data type &lt;code&gt;box&lt;/code&gt;:</source>
          <target state="translated">Следующая команда определяет новый оператор равенства областей для &lt;code&gt;box&lt;/code&gt; типа данных :</target>
        </trans-unit>
        <trans-unit id="55cc91b2b085f350c73a66cbdf6d3a5a0c4fb379" translate="yes" xml:space="preserve">
          <source>The following command-line options are available:</source>
          <target state="translated">Доступны следующие опции командной строки:</target>
        </trans-unit>
        <trans-unit id="7065caab547161a186d449fdb20fb545416a7f46" translate="yes" xml:space="preserve">
          <source>The following command-line options control the connection to the source server:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b5ca5337b558c5af015478dbbd74c89d07107d2" translate="yes" xml:space="preserve">
          <source>The following command-line options control the content and format of the output.</source>
          <target state="translated">Следующие опции командной строки управляют содержанием и форматом вывода.</target>
        </trans-unit>
        <trans-unit id="05475cf2eec87e97d8772a07ec18d9fdca7b5435" translate="yes" xml:space="preserve">
          <source>The following command-line options control the database connection parameters.</source>
          <target state="translated">Следующие опции командной строки управляют параметрами подключения к БД.</target>
        </trans-unit>
        <trans-unit id="3d113b81b40bdffb0cde200d7b3c4f6a86ddbb52" translate="yes" xml:space="preserve">
          <source>The following command-line options control the generation of the backup and the invocation of the program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220365fea8f99014f431d00f0ea052b58e2c1fcb" translate="yes" xml:space="preserve">
          <source>The following command-line options control the generation of the backup and the running of the program.</source>
          <target state="translated">Следующие опции командной строки управляют генерацией резервного копирования и запуском программы.</target>
        </trans-unit>
        <trans-unit id="a56b05f8e623fa43fb5bc9f1eeba6d4c3440d581" translate="yes" xml:space="preserve">
          <source>The following command-line options control the location and format of the output and other replication behavior:</source>
          <target state="translated">Следующие опции командной строки управляют местоположением и форматом вывода и другим поведением репликации:</target>
        </trans-unit>
        <trans-unit id="f449555e10b2046b1ccc209c3ef5b6dce0f90612" translate="yes" xml:space="preserve">
          <source>The following command-line options control the location and format of the output.</source>
          <target state="translated">Следующие опции командной строки управляют местоположением и форматом вывода.</target>
        </trans-unit>
        <trans-unit id="00a034b5b9d901cf6c0ba2052c558173c4b654b2" translate="yes" xml:space="preserve">
          <source>The following command-line options control the location and format of the output:</source>
          <target state="translated">Следующие опции командной строки управляют местоположением и форматом вывода:</target>
        </trans-unit>
        <trans-unit id="b90c14e70ab12e4fce9bec3bf939f8e3cd367938" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for GSSAPI:</source>
          <target state="translated">Для GSSAPI поддерживаются следующие варианты конфигурации:</target>
        </trans-unit>
        <trans-unit id="46edfe1841a44936730cc915774b2516fbe1a78a" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for PAM:</source>
          <target state="translated">Для PAM поддерживаются следующие опции конфигурации:</target>
        </trans-unit>
        <trans-unit id="514923f06896538a2f8d0943aa9139974686a363" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for RADIUS:</source>
          <target state="translated">Для RADIUS поддерживаются следующие опции конфигурации:</target>
        </trans-unit>
        <trans-unit id="acf0b28821a566799fd52288a31f3e25a128c408" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for SSL certificate authentication:</source>
          <target state="translated">Для аутентификации с помощью SSL-сертификата поддерживаются следующие параметры конфигурации:</target>
        </trans-unit>
        <trans-unit id="bad3bae7c6cb5e9156e0aafc4f4c4d5aa18bfd10" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for SSPI:</source>
          <target state="translated">Для SSPI поддерживаются следующие опции конфигурации:</target>
        </trans-unit>
        <trans-unit id="be704faf73a86cf08decb39d5cfdd09dedabb81b" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for ident:</source>
          <target state="translated">Для ident поддерживаются следующие опции конфигурации:</target>
        </trans-unit>
        <trans-unit id="7fd3b16b14e5df4be73c034d0d0a8f2f793213cc" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for peer:</source>
          <target state="translated">Следующие опции конфигурации поддерживаются для одноранговых:</target>
        </trans-unit>
        <trans-unit id="b2cc6138e97e8a814646a47d2cd6ecdb0c1d8d16" translate="yes" xml:space="preserve">
          <source>The following configuration options are used in both modes:</source>
          <target state="translated">В обоих режимах используются следующие опции конфигурации:</target>
        </trans-unit>
        <trans-unit id="82ae133d649ffad972068d98ba1e0a950ea94086" translate="yes" xml:space="preserve">
          <source>The following containment predicate uses the point syntax, while in fact the second argument is internally represented by a box. This syntax makes it unnecessary to define a separate point type and functions for (box,point) predicates.</source>
          <target state="translated">Следующий предикат локализации использует точечный синтаксис,в то время как на самом деле второй аргумент внутренне представлен ящиком.Этот синтаксис делает ненужным определение отдельного типа точки и функций для (box,point)предикатов.</target>
        </trans-unit>
        <trans-unit id="ab1f58c5086fb9d7dbb2dff29ebf934fc1fd38a7" translate="yes" xml:space="preserve">
          <source>The following example command &amp;ldquo;updates&amp;rdquo; the dictionary's definition without actually changing anything.</source>
          <target state="translated">В следующем примере команда &amp;laquo;обновляет&amp;raquo; определение словаря, фактически ничего не меняя.</target>
        </trans-unit>
        <trans-unit id="5f20cbbdfc0e4abc07d317b7cde01bad2e3188ac" translate="yes" xml:space="preserve">
          <source>The following example command adds cross-data-type operators and support functions to an operator family that already contains B-tree operator classes for data types &lt;code&gt;int4&lt;/code&gt; and &lt;code&gt;int2&lt;/code&gt;.</source>
          <target state="translated">В следующем примере команды добавляются операторы перекрестных типов данных и вспомогательные функции в семейство операторов, которое уже содержит классы операторов B-дерева для типов данных &lt;code&gt;int4&lt;/code&gt; и &lt;code&gt;int2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98ce952daa9dd539b9ae5ea67f8fc03311bc7883" translate="yes" xml:space="preserve">
          <source>The following example command changes the language option to &lt;code&gt;dutch&lt;/code&gt;, and removes the stopword option entirely.</source>
          <target state="translated">В следующем примере команда изменяет параметр языка на &lt;code&gt;dutch&lt;/code&gt; и полностью удаляет параметр стоп-слова.</target>
        </trans-unit>
        <trans-unit id="0690fd36226cece879c24f85e0b2a34e7740cb2a" translate="yes" xml:space="preserve">
          <source>The following example command changes the stopword list for a Snowball-based dictionary. Other parameters remain unchanged.</source>
          <target state="translated">В следующем примере команда изменяет список стоп-слов для словаря на основе Snowball.Остальные параметры остаются неизменными.</target>
        </trans-unit>
        <trans-unit id="c6c6101649b45994a81cc07611f7c341ccfd2d4d" translate="yes" xml:space="preserve">
          <source>The following example command creates a Snowball-based dictionary with a nonstandard list of stop words.</source>
          <target state="translated">В следующем примере команда создает словарь на основе Snowball с нестандартным списком стоп-слов.</target>
        </trans-unit>
        <trans-unit id="0540cfecb071eb102ec89874893aeae6b2dac906" translate="yes" xml:space="preserve">
          <source>The following example command defines a GiST index operator class for the data type &lt;code&gt;_int4&lt;/code&gt; (array of &lt;code&gt;int4&lt;/code&gt;). See the &lt;a href=&quot;intarray&quot;&gt;intarray&lt;/a&gt; module for the complete example.</source>
          <target state="translated">В следующем примере команды определяется класс оператора индекса GiST для типа данных &lt;code&gt;_int4&lt;/code&gt; (массив &lt;code&gt;int4&lt;/code&gt; ). См. Полный &lt;a href=&quot;intarray&quot;&gt;пример в&lt;/a&gt; модуле intarray .</target>
        </trans-unit>
        <trans-unit id="ef3a1ce4208d975ebd37d2a046e1777755826724" translate="yes" xml:space="preserve">
          <source>The following example copies a table to the client using the vertical bar (&lt;code&gt;|&lt;/code&gt;) as the field delimiter:</source>
          <target state="translated">В следующем примере таблица копируется клиенту с использованием вертикальной черты ( &lt;code&gt;|&lt;/code&gt; ) в качестве разделителя полей:</target>
        </trans-unit>
        <trans-unit id="0d013459769f3027ad75584e21efea2204848877" translate="yes" xml:space="preserve">
          <source>The following example illustrates how the &lt;code&gt;XMLNAMESPACES&lt;/code&gt; clause can be used to specify a list of namespaces used in the XML document as well as in the XPath expressions:</source>
          <target state="translated">В следующем примере показано, как можно использовать предложение &lt;code&gt;XMLNAMESPACES&lt;/code&gt; для указания списка пространств имен, используемых в XML-документе, а также в выражениях XPath:</target>
        </trans-unit>
        <trans-unit id="8120020f967b896e9eb5f42600de6773abdc4c59" translate="yes" xml:space="preserve">
          <source>The following example puts the final account balance from the first query into variable &lt;code&gt;abalance&lt;/code&gt;, and fills variables &lt;code&gt;p_two&lt;/code&gt; and &lt;code&gt;p_three&lt;/code&gt; with integers from the third query. The result of the second query is discarded.</source>
          <target state="translated">В следующем примере окончательный баланс счета из первого запроса &lt;code&gt;abalance&lt;/code&gt; в переменную abalance , а переменные &lt;code&gt;p_two&lt;/code&gt; и &lt;code&gt;p_three&lt;/code&gt; заполняются целыми числами из третьего запроса. Результат второго запроса отбрасывается.</target>
        </trans-unit>
        <trans-unit id="550fb6dd31ce5c45513c6afc9762a8e612652741" translate="yes" xml:space="preserve">
          <source>The following example puts the final account balance from the first query into variable &lt;code&gt;abalance&lt;/code&gt;, and fills variables &lt;code&gt;p_two&lt;/code&gt; and &lt;code&gt;p_three&lt;/code&gt; with integers from the third query. The result of the second query is discarded. The result of the two last combined queries are stored in variables &lt;code&gt;four&lt;/code&gt; and &lt;code&gt;five&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0272043332c15e45fca8627b9940585ab0ce4a" translate="yes" xml:space="preserve">
          <source>The following example replaces the &lt;code&gt;english&lt;/code&gt; dictionary with the &lt;code&gt;swedish&lt;/code&gt; dictionary anywhere that &lt;code&gt;english&lt;/code&gt; is used within &lt;code&gt;my_config&lt;/code&gt;.</source>
          <target state="translated">В следующем примере &lt;code&gt;english&lt;/code&gt; словарь заменяется &lt;code&gt;swedish&lt;/code&gt; любом месте, где используется &lt;code&gt;english&lt;/code&gt; в &lt;code&gt;my_config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a86c39babfe81954fe9ebb108b217aea8248e655" translate="yes" xml:space="preserve">
          <source>The following example shows concatenation of multiple text() nodes, usage of the column name as XPath filter, and the treatment of whitespace, XML comments and processing instructions:</source>
          <target state="translated">Следующий пример показывает конкатенирование нескольких текстовых()узлов,использование имени колонки в качестве XPath-фильтра,а также обработку пробела,XML комментариев и инструкций по обработке:</target>
        </trans-unit>
        <trans-unit id="54642b031a2227e507d5a953bc0c97aa2f10ca2d" translate="yes" xml:space="preserve">
          <source>The following example shows how the security label of a table might be changed.</source>
          <target state="translated">В следующем примере показано,как может быть изменена метка безопасности таблицы.</target>
        </trans-unit>
        <trans-unit id="b9d0858a7dd21e2c17fd7d8938ac8b2bda33b78f" translate="yes" xml:space="preserve">
          <source>The following example shows the result of estimating a &lt;code&gt;WHERE&lt;/code&gt; condition on the &lt;code&gt;a&lt;/code&gt; column:</source>
          <target state="translated">В следующем примере показан результат оценки условия &lt;code&gt;WHERE&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; столбца a :</target>
        </trans-unit>
        <trans-unit id="04036b5b20e932a63bf10913615aab08c6e7f9bb" translate="yes" xml:space="preserve">
          <source>The following example traverses a table using a cursor:</source>
          <target state="translated">Следующий пример пересекает таблицу с помощью курсора:</target>
        </trans-unit>
        <trans-unit id="b0c8644502b27c5f09c1b2cd46083c907b3859da" translate="yes" xml:space="preserve">
          <source>The following examples will illustrate the usage of all three notations, using the following function definition:</source>
          <target state="translated">Следующие примеры проиллюстрируют использование всех трех нотаций,используя следующее определение функции:</target>
        </trans-unit>
        <trans-unit id="ddc2a5eced86eee0d88b99c3c79c239f1015ae7c" translate="yes" xml:space="preserve">
          <source>The following functions allow direct testing of a text search parser.</source>
          <target state="translated">Следующие функции позволяют напрямую тестировать парсер текстового поиска.</target>
        </trans-unit>
        <trans-unit id="5e0070eaa8f2988c475085144814bd098c68e7d6" translate="yes" xml:space="preserve">
          <source>The following functions are available if libxslt is installed:</source>
          <target state="translated">При установке libxslt доступны следующие функции:</target>
        </trans-unit>
        <trans-unit id="6868f6a5c512b545d6b54882e8a5b465e4040e96" translate="yes" xml:space="preserve">
          <source>The following functions are available to delay execution of the server process:</source>
          <target state="translated">Для задержки выполнения серверного процесса доступны следующие функции:</target>
        </trans-unit>
        <trans-unit id="7eaa7ab3c8107e57a840871a19a9fd7639ac2e60" translate="yes" xml:space="preserve">
          <source>The following functions map the contents of relational tables to XML values. They can be thought of as XML export functionality:</source>
          <target state="translated">Следующие функции сопоставляют содержимое таблиц реляций с XML-значениями.Их можно рассматривать как функции экспорта XML:</target>
        </trans-unit>
        <trans-unit id="d99534b0054b1dbaf525bfa83dffbf3dceb4ed5a" translate="yes" xml:space="preserve">
          <source>The following functions produce XML data mappings and the corresponding XML Schema in one document (or forest), linked together. They can be useful where self-contained and self-describing results are wanted:</source>
          <target state="translated">Следующие функции создают отображение данных в формате XML и соответствующую схему XML в одном документе (или лесу),связанном между собой.Они могут быть полезны там,где нужны самостоятельные и самооформляющиеся результаты:</target>
        </trans-unit>
        <trans-unit id="0717a340e1889a17503b962f24442ac075bb61f2" translate="yes" xml:space="preserve">
          <source>The following functions return XML Schema documents describing the mappings performed by the corresponding functions above:</source>
          <target state="translated">Следующие функции возвращают документы XML-схемы,описывающие отображения,выполненные соответствующими функциями выше:</target>
        </trans-unit>
        <trans-unit id="87e9cfe2ae99c540eae639b3c0d4e7139991c05c" translate="yes" xml:space="preserve">
          <source>The following functions work on bit strings as well as binary strings: &lt;code&gt;get_bit&lt;/code&gt;, &lt;code&gt;set_bit&lt;/code&gt;. When working with a bit string, these functions number the first (leftmost) bit of the string as bit 0.</source>
          <target state="translated">Следующие функции работают с битовыми строками, а также с двоичными строками: &lt;code&gt;get_bit&lt;/code&gt; , &lt;code&gt;set_bit&lt;/code&gt; . При работе с битовой строкой эти функции нумеруют первый (крайний левый) бит строки как бит 0.</target>
        </trans-unit>
        <trans-unit id="f8888d531981405af8909029406e91231d32e3fc" translate="yes" xml:space="preserve">
          <source>The following is an equivalent way of accomplishing the same result:</source>
          <target state="translated">Следующее является эквивалентным способом достижения того же результата:</target>
        </trans-unit>
        <trans-unit id="f5156ec918109db1c50b00eba83d4a25d3045435" translate="yes" xml:space="preserve">
          <source>The following is divided into three subsections. Different options are used during database initialization and while running benchmarks, but some options are useful in both cases.</source>
          <target state="translated">Следующее разделено на три подраздела.Различные опции используются при инициализации базы данных и при выполнении бенчмарков,но некоторые опции полезны в обоих случаях.</target>
        </trans-unit>
        <trans-unit id="647af377018af1687ed8efb04b9618837aa7790d" translate="yes" xml:space="preserve">
          <source>The following is the same data, output in binary format. The data is shown after filtering through the Unix utility &lt;code&gt;od -c&lt;/code&gt;. The table has three columns; the first has type &lt;code&gt;char(2)&lt;/code&gt;, the second has type &lt;code&gt;text&lt;/code&gt;, and the third has type &lt;code&gt;integer&lt;/code&gt;. All the rows have a null value in the third column.</source>
          <target state="translated">Ниже приведены те же данные в двоичном формате. Данные отображаются после фильтрации с помощью утилиты Unix &lt;code&gt;od -c&lt;/code&gt; . Таблица состоит из трех столбцов; первый имеет тип &lt;code&gt;char(2)&lt;/code&gt; , второй - &lt;code&gt;text&lt;/code&gt; , а третий - &lt;code&gt;integer&lt;/code&gt; . Все строки в третьем столбце имеют нулевое значение.</target>
        </trans-unit>
        <trans-unit id="c1be0628b6cf705e05d346385bba0020aac7aea8" translate="yes" xml:space="preserve">
          <source>The following keys are currently in use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda35f89f366a92b9c1f3ee20bc9ca7f81e63cc1" translate="yes" xml:space="preserve">
          <source>The following less trivial example writes the Russian word &amp;ldquo;slon&amp;rdquo; (elephant) in Cyrillic letters:</source>
          <target state="translated">В следующем, менее тривиальном примере, русское слово &amp;laquo;слон&amp;raquo; записывается кириллическими буквами:</target>
        </trans-unit>
        <trans-unit id="189e345b5ef4ff87c793abeb8737dfccbc0f04c1" translate="yes" xml:space="preserve">
          <source>The following limitations apply to partitioned tables:</source>
          <target state="translated">Следующие ограничения применяются к таблицам разбиения:</target>
        </trans-unit>
        <trans-unit id="44e788f5edc12a91d7e7f317a229ad70f5f2729c" translate="yes" xml:space="preserve">
          <source>The following meta-commands are defined:</source>
          <target state="translated">Определены следующие мета-команды:</target>
        </trans-unit>
        <trans-unit id="cd608061d746b035415cdac00c81458451b62316" translate="yes" xml:space="preserve">
          <source>The following methods for collecting the write-ahead logs are supported:</source>
          <target state="translated">Поддерживаются следующие методы сбора журналов:</target>
        </trans-unit>
        <trans-unit id="a56049877daf2d04bdadddbc86e9035f590ef7d4" translate="yes" xml:space="preserve">
          <source>The following non-standard approach used to be recommended in previous versions, and may still be useful in specific cases:</source>
          <target state="translated">Следующий нестандартный подход использовался в предыдущих версиях и может быть полезен в конкретных случаях:</target>
        </trans-unit>
        <trans-unit id="8a441d0a9d0ce26e47c5d9596d3d57e320cb00a5" translate="yes" xml:space="preserve">
          <source>The following operations are always parallel restricted.</source>
          <target state="translated">Следующие операции всегда ограничены параллельно.</target>
        </trans-unit>
        <trans-unit id="0e406b45cfda5d02b89a1154761a86fa7316f577" translate="yes" xml:space="preserve">
          <source>The following operations are always parallel restricted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e78db2119a951e7a8c9fc8a972d223a3355886" translate="yes" xml:space="preserve">
          <source>The following options are only needed when &lt;code&gt;pg_resetwal&lt;/code&gt; is unable to determine appropriate values by reading &lt;code&gt;pg_control&lt;/code&gt;. Safe values can be determined as described below. For values that take numeric arguments, hexadecimal values can be specified by using the prefix &lt;code&gt;0x&lt;/code&gt;.</source>
          <target state="translated">Следующие параметры необходимы только тогда, когда &lt;code&gt;pg_resetwal&lt;/code&gt; не может определить подходящие значения путем чтения &lt;code&gt;pg_control&lt;/code&gt; . Безопасные значения можно определить, как описано ниже. Для значений, которые принимают числовые аргументы, можно указать шестнадцатеричные значения с помощью префикса &lt;code&gt;0x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69bed63b9b9fa472f1bfef341fe738b22ca2d102" translate="yes" xml:space="preserve">
          <source>The following options are used in search+bind mode only:</source>
          <target state="translated">Следующие опции используются только в режиме поиск+привязка:</target>
        </trans-unit>
        <trans-unit id="a727fc2f66779d9648449bd2ed769b9bf5969532" translate="yes" xml:space="preserve">
          <source>The following options are used in simple bind mode only:</source>
          <target state="translated">Следующие опции используются только в режиме простой привязки:</target>
        </trans-unit>
        <trans-unit id="537f6640d02bb24a88ec9d9b40defc6c0eca02e5" translate="yes" xml:space="preserve">
          <source>The following options further specify the recovery target, and affect what happens when the target is reached:</source>
          <target state="translated">Следующие опции далее определяют цель восстановления и влияют на то,что произойдет,когда цель будет достигнута:</target>
        </trans-unit>
        <trans-unit id="b33280ef9e0c134ead04314d2e16bd6297d099cc" translate="yes" xml:space="preserve">
          <source>The following options only apply to the single-user mode (see &lt;a href=&quot;app-postgres#APP-POSTGRES-SINGLE-USER&quot;&gt;Single-User Mode&lt;/a&gt; below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7135a7643cb1d0d74cb2e4a970ae91d9faed5be8" translate="yes" xml:space="preserve">
          <source>The following options only apply to the single-user mode (see &lt;a href=&quot;app-postgres#APP-POSTGRES-SINGLE-USER&quot;&gt;Single-User Mode&lt;/a&gt;).</source>
          <target state="translated">Следующие параметры применимы только к однопользовательскому режиму (см. &lt;a href=&quot;app-postgres#APP-POSTGRES-SINGLE-USER&quot;&gt;Однопользовательский режим&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e806d19c35f4be356192bcaf56df7bac7d67cbd" translate="yes" xml:space="preserve">
          <source>The following parameters are intended for work on the PostgreSQL source code, and in some cases to assist with recovery of severely damaged databases. There should be no reason to use them on a production database. As such, they have been excluded from the sample &lt;code&gt;postgresql.conf&lt;/code&gt; file. Note that many of these parameters require special source compilation flags to work at all.</source>
          <target state="translated">Следующие параметры предназначены для работы с исходным кодом PostgreSQL и в некоторых случаях для помощи в восстановлении сильно поврежденных баз данных. Не должно быть причин использовать их в производственной базе данных. Таким образом, они были исключены из образца файла &lt;code&gt;postgresql.conf&lt;/code&gt; . Обратите внимание, что для работы многих из этих параметров требуются специальные флаги компиляции исходного кода.</target>
        </trans-unit>
        <trans-unit id="4026e02031547a37479fb9b05f84b97775d5fe92" translate="yes" xml:space="preserve">
          <source>The following query can be used to identify all collations in the current database that need to be refreshed and the objects that depend on them:</source>
          <target state="translated">Следующий запрос может быть использован для идентификации всех коллизий в текущей базе данных,которые нуждаются в обновлении,и объектов,которые от них зависят:</target>
        </trans-unit>
        <trans-unit id="c0122a37523d76103f38f449cd343e0b060ab0d9" translate="yes" xml:space="preserve">
          <source>The following query shows all defined operator classes:</source>
          <target state="translated">В следующем запросе показаны все определенные классы операторов:</target>
        </trans-unit>
        <trans-unit id="8cfe858c80303e50296d8f2a37810c84b510900d" translate="yes" xml:space="preserve">
          <source>The following resources contain additional information about genetic algorithms:</source>
          <target state="translated">Следующие ресурсы содержат дополнительную информацию о генетических алгоритмах:</target>
        </trans-unit>
        <trans-unit id="66737f1e0a66b3e5bd4174eda08630ddc7c2985c" translate="yes" xml:space="preserve">
          <source>The following sections describe each of these authentication methods in more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327c23aaa47c9cad7b97d5d2a03e766b6d51df50" translate="yes" xml:space="preserve">
          <source>The following sections describe the authentication methods in more detail.</source>
          <target state="translated">В следующих разделах методы аутентификации описаны более подробно.</target>
        </trans-unit>
        <trans-unit id="aeb4c79f6ac510d43001882e836e62ac542ea4a4" translate="yes" xml:space="preserve">
          <source>The following sections describe the details of the select list, the table expression, and the sort specification. &lt;code&gt;WITH&lt;/code&gt; queries are treated last since they are an advanced feature.</source>
          <target state="translated">В следующих разделах подробно описаны список выбора, табличное выражение и спецификация сортировки. Запросы &lt;code&gt;WITH&lt;/code&gt; обрабатываются в последнюю очередь, поскольку они являются расширенной функцией.</target>
        </trans-unit>
        <trans-unit id="9d4ca436eba9354db1bd47061237b54b62f2b67c" translate="yes" xml:space="preserve">
          <source>The following special backslash sequences are recognized by &lt;code&gt;COPY FROM&lt;/code&gt;:</source>
          <target state="translated">Следующие специальные последовательности обратной косой черты распознаются &lt;code&gt;COPY FROM&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8f427c4f9638a34d3033435ec6c0132981a12871" translate="yes" xml:space="preserve">
          <source>The following steps occur in a concurrent reindex. Each step is run in a separate transaction. If there are multiple indexes to be rebuilt, then each step loops through all the indexes before moving to the next step.</source>
          <target state="translated">Следующие шаги выполняются при одновременной реиндексации.Каждый шаг выполняется в отдельной транзакции.Если существует несколько индексов,которые необходимо перестроить,то каждый шаг проходит через все индексы,прежде чем перейти к следующему шагу.</target>
        </trans-unit>
        <trans-unit id="e32c87e22cead595c4cbd93a657097e6823f09e3" translate="yes" xml:space="preserve">
          <source>The following subsections describe the kinds of extended statistics that are currently supported.</source>
          <target state="translated">В следующих подразделах описаны виды расширенной статистики,которые поддерживаются в настоящее время.</target>
        </trans-unit>
        <trans-unit id="542557b3d5f6134bfa542b4b0f72c63ee404d9ac" translate="yes" xml:space="preserve">
          <source>The following syntax was used before PostgreSQL version 7.3 and is still supported:</source>
          <target state="translated">Следующий синтаксис использовался до PostgreSQL версии 7.3 и до сих пор поддерживается:</target>
        </trans-unit>
        <trans-unit id="cb4264d6fcf534ad0d711543bbbad940acfd384f" translate="yes" xml:space="preserve">
          <source>The following syntax was used before PostgreSQL version 9.0 and is still supported:</source>
          <target state="translated">Следующий синтаксис использовался до PostgreSQL версии 9.0 и до сих пор поддерживается:</target>
        </trans-unit>
        <trans-unit id="7ffe77d533e655164667efaec733a8644752fd0c" translate="yes" xml:space="preserve">
          <source>The following table summarizes which types of triggers may be used on tables, views, and foreign tables:</source>
          <target state="translated">В следующей таблице приведена краткая информация о том,какие типы триггеров могут использоваться в таблицах,представлениях и зарубежных таблицах:</target>
        </trans-unit>
        <trans-unit id="b9dedb03b6c7c1e94159053f8cafdd1b64ee1259" translate="yes" xml:space="preserve">
          <source>The following two examples are identical ways of sorting the individual results according to the contents of the second column (&lt;code&gt;name&lt;/code&gt;):</source>
          <target state="translated">Следующие два примера представляют собой идентичные способы сортировки отдельных результатов в соответствии с содержимым второго столбца ( &lt;code&gt;name&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="a55bcd1aa5b5db14890555290a8f28e4c18316d2" translate="yes" xml:space="preserve">
          <source>The following two keys are always present:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82d287994dca1133e1c905ec21b4420d1348aaa" translate="yes" xml:space="preserve">
          <source>The following types (or spellings thereof) are specified by SQL: &lt;code&gt;bigint&lt;/code&gt;, &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;bit varying&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;character varying&lt;/code&gt;, &lt;code&gt;character&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;double precision&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;decimal&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt; (with or without time zone), &lt;code&gt;timestamp&lt;/code&gt; (with or without time zone), &lt;code&gt;xml&lt;/code&gt;.</source>
          <target state="translated">Следующие типы (или их варианты написания) задаются SQL: &lt;code&gt;bigint&lt;/code&gt; , &lt;code&gt;bit&lt;/code&gt; , &lt;code&gt;bit varying&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;character varying&lt;/code&gt; , &lt;code&gt;character&lt;/code&gt; , &lt;code&gt;varchar&lt;/code&gt; , &lt;code&gt;date&lt;/code&gt; , &lt;code&gt;double precision&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;interval&lt;/code&gt; , &lt;code&gt;numeric&lt;/code&gt; , &lt;code&gt;decimal&lt;/code&gt; , &lt;code&gt;real&lt;/code&gt; , &lt;code&gt;smallint&lt;/code&gt; , &lt;code&gt;time&lt;/code&gt; ( с часовым поясом или без него), &lt;code&gt;timestamp&lt;/code&gt; (с часовым поясом или без него), &lt;code&gt;xml&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="008f4840c9bbbc114acf97e5143a54c88f68912b" translate="yes" xml:space="preserve">
          <source>The following types of administration commands are not accepted during recovery mode:</source>
          <target state="translated">Следующие типы команд администрирования не принимаются в режиме восстановления:</target>
        </trans-unit>
        <trans-unit id="d4a4cbf72726623686906a4dfcab95be0271a53f" translate="yes" xml:space="preserve">
          <source>The following types of parallel-aware table scans are currently supported.</source>
          <target state="translated">В настоящее время поддерживаются следующие типы сканирования параллельных таблиц.</target>
        </trans-unit>
        <trans-unit id="45ec767602366e0da0c6d60741f363eda41896e3" translate="yes" xml:space="preserve">
          <source>The foreign server to import from.</source>
          <target state="translated">Иностранный сервер для импорта.</target>
        </trans-unit>
        <trans-unit id="fbe288bd62bdf2a35ec4994319ad86594322f65f" translate="yes" xml:space="preserve">
          <source>The foreign-data wrapper name must be unique within the database.</source>
          <target state="translated">Имя обертки иностранных данных должно быть уникальным в базе данных.</target>
        </trans-unit>
        <trans-unit id="721abb232cb1907cbf75dfbc734244683645423e" translate="yes" xml:space="preserve">
          <source>The form of &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; that does not supply any handler function is obsolete. For backwards compatibility with old dump files, it is interpreted as &lt;code&gt;CREATE EXTENSION&lt;/code&gt;. That will work if the language has been packaged into an extension of the same name, which is the conventional way to set up procedural languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="128070d44af946b3f1ecf65ccd252fb06b8cf14f" translate="yes" xml:space="preserve">
          <source>The format of a psql command is the backslash, followed immediately by a command verb, then any arguments. The arguments are separated from the command verb and each other by any number of whitespace characters.</source>
          <target state="translated">Формат команды psql-обратная косая черта,за которой сразу следует командный глагол,затем любые аргументы.Аргументы отделяются от командного глагола и друг от друга любым количеством пробельных символов.</target>
        </trans-unit>
        <trans-unit id="7f3c7541e2c4fcc461ec02ccb2547741ee4be834" translate="yes" xml:space="preserve">
          <source>The format of the log is:</source>
          <target state="translated">Формат журнала таков:</target>
        </trans-unit>
        <trans-unit id="c1adf1c1ec6d1279c3ae3b2793de10b99dbd36d4" translate="yes" xml:space="preserve">
          <source>The formatting function &lt;code&gt;to_char&lt;/code&gt; (see &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;) is also available as a more flexible way to format date/time output.</source>
          <target state="translated">Функция форматирования &lt;code&gt;to_char&lt;/code&gt; (см. &lt;a href=&quot;functions-formatting&quot;&gt;Раздел 9.8&lt;/a&gt; ) также доступна как более гибкий способ форматирования вывода даты / времени.</target>
        </trans-unit>
        <trans-unit id="9ba5e32cb8a2291627c08e67bf1bfb6249955cd8" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;ADD&lt;/code&gt; (without &lt;code&gt;USING INDEX&lt;/code&gt;), &lt;code&gt;DROP [COLUMN]&lt;/code&gt;, &lt;code&gt;DROP IDENTITY&lt;/code&gt;, &lt;code&gt;RESTART&lt;/code&gt;, &lt;code&gt;SET DEFAULT&lt;/code&gt;, &lt;code&gt;SET DATA TYPE&lt;/code&gt; (without &lt;code&gt;USING&lt;/code&gt;), &lt;code&gt;SET GENERATED&lt;/code&gt;, and &lt;code&gt;SET sequence_option&lt;/code&gt; conform with the SQL standard. The other forms are PostgreSQL extensions of the SQL standard. Also, the ability to specify more than one manipulation in a single &lt;code&gt;ALTER TABLE&lt;/code&gt; command is an extension.</source>
          <target state="translated">Формы &lt;code&gt;ADD&lt;/code&gt; (без &lt;code&gt;USING INDEX&lt;/code&gt; ), &lt;code&gt;DROP [COLUMN]&lt;/code&gt; , &lt;code&gt;DROP IDENTITY&lt;/code&gt; , &lt;code&gt;RESTART&lt;/code&gt; , &lt;code&gt;SET DEFAULT&lt;/code&gt; , &lt;code&gt;SET DATA TYPE&lt;/code&gt; (без &lt;code&gt;USING&lt;/code&gt; ), &lt;code&gt;SET GENERATED&lt;/code&gt; и &lt;code&gt;SET sequence_option&lt;/code&gt; соответствуют стандарту SQL. Другие формы являются расширениями PostgreSQL стандарта SQL. Кроме того, расширением является возможность указать более одной манипуляции в одной команде &lt;code&gt;ALTER TABLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60e0a26739b6392b783c8e0781017e51a86f2c82" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;DROP&lt;/code&gt;, and &lt;code&gt;SET DATA TYPE&lt;/code&gt; conform with the SQL standard. The other forms are PostgreSQL extensions of the SQL standard. Also, the ability to specify more than one manipulation in a single &lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt; command is an extension.</source>
          <target state="translated">Формы &lt;code&gt;ADD&lt;/code&gt; , &lt;code&gt;DROP&lt;/code&gt; и &lt;code&gt;SET DATA TYPE&lt;/code&gt; соответствуют стандарту SQL. Другие формы являются расширениями PostgreSQL стандарта SQL. Кроме того, расширением является возможность указать более одной манипуляции в одной команде &lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceb183e300587222b81cf3fc6aa4245c9a8136ea" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;NEXT&lt;/code&gt;, &lt;code&gt;PRIOR&lt;/code&gt;, &lt;code&gt;FIRST&lt;/code&gt;, &lt;code&gt;LAST&lt;/code&gt;, &lt;code&gt;ABSOLUTE&lt;/code&gt;, &lt;code&gt;RELATIVE&lt;/code&gt; fetch a single row after moving the cursor appropriately. If there is no such row, an empty result is returned, and the cursor is left positioned before the first row or after the last row as appropriate.</source>
          <target state="translated">Формы &lt;code&gt;NEXT&lt;/code&gt; , &lt;code&gt;PRIOR&lt;/code&gt; уровень , &lt;code&gt;FIRST&lt;/code&gt; , &lt;code&gt;LAST&lt;/code&gt; , &lt;code&gt;ABSOLUTE&lt;/code&gt; , &lt;code&gt;RELATIVE&lt;/code&gt; принести одну строку после перемещения курсора соответствующим образом . Если такой строки нет, возвращается пустой результат, а курсор остается перед первой строкой или после последней строки, в зависимости от ситуации.</target>
        </trans-unit>
        <trans-unit id="2588add0e86c17b12a1c6aa4f12342731ddacd9b" translate="yes" xml:space="preserve">
          <source>The forms using &lt;code&gt;FORWARD&lt;/code&gt; and &lt;code&gt;BACKWARD&lt;/code&gt; retrieve the indicated number of rows moving in the forward or backward direction, leaving the cursor positioned on the last-returned row (or after/before all rows, if the &lt;code&gt;count&lt;/code&gt; exceeds the number of rows available).</source>
          <target state="translated">Формы, использующие &lt;code&gt;FORWARD&lt;/code&gt; и &lt;code&gt;BACKWARD&lt;/code&gt; , извлекают указанное количество строк, перемещающихся в прямом или обратном направлении, оставляя курсор на последней возвращенной строке (или после / перед всеми строками, если &lt;code&gt;count&lt;/code&gt; превышает количество доступных строк).</target>
        </trans-unit>
        <trans-unit id="38a28d1e90b500392094fc0f5e04fc9e1934bc5b" translate="yes" xml:space="preserve">
          <source>The forms using &lt;code&gt;{&lt;/code&gt;&lt;code&gt;...&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; are known as &lt;em&gt;bounds&lt;/em&gt;. The numbers &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; within a bound are unsigned decimal integers with permissible values from 0 to 255 inclusive.</source>
          <target state="translated">Формы, использующие &lt;code&gt;{&lt;/code&gt; &lt;code&gt;...&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; , называются &lt;em&gt;границами&lt;/em&gt; . Числа &lt;code&gt;m&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; в пределах границы представляют собой десятичные целые числа без знака с допустимыми значениями от 0 до 255 включительно.</target>
        </trans-unit>
        <trans-unit id="35372a44df7778273e762917011aca61a01afe9f" translate="yes" xml:space="preserve">
          <source>The forward transition function for moving-aggregate mode is not allowed to return NULL as the new state value. If the inverse transition function returns NULL, this is taken as an indication that the inverse function cannot reverse the state calculation for this particular input, and so the aggregate calculation will be redone from scratch for the current frame starting position. This convention allows moving-aggregate mode to be used in situations where there are some infrequent cases that are impractical to reverse out of the running state value.</source>
          <target state="translated">Функция прямого перехода для режима перемещения-агрегации не позволяет вернуть NULL в качестве нового значения состояния.Если функция обратного перехода возвращает NULL,то это воспринимается как указание на то,что функция обратного перехода не может перевернуть вычисление состояния для этого конкретного входа,и поэтому вычисление агрегированного состояния будет переделано с нуля для текущей начальной позиции кадра.Эта конвенция позволяет использовать режим сдвига-агрегата в ситуациях,когда есть некоторые редкие случаи,когда обратное значение текущего состояния нецелесообразно.</target>
        </trans-unit>
        <trans-unit id="5ac2696bdfdb7d076133fbfd9fa64682db1b8328" translate="yes" xml:space="preserve">
          <source>The four timezone names &lt;code&gt;EST5EDT&lt;/code&gt;, &lt;code&gt;CST6CDT&lt;/code&gt;, &lt;code&gt;MST7MDT&lt;/code&gt;, and &lt;code&gt;PST8PDT&lt;/code&gt; look like they are POSIX zone specifications. However, they actually are treated as named time zones because (for historical reasons) there are files by those names in the IANA time zone database. The practical implication of this is that these zone names will produce valid historical USA daylight-savings transitions, even when a plain POSIX specification would not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab5226a0f4072d37673ee94afa6e18b7e80854c8" translate="yes" xml:space="preserve">
          <source>The fourth form changes the default tablespace of the database. Only the database owner or a superuser can do this; you must also have create privilege for the new tablespace. This command physically moves any tables or indexes in the database's old default tablespace to the new tablespace. The new default tablespace must be empty for this database, and no one can be connected to the database. Tables and indexes in non-default tablespaces are unaffected.</source>
          <target state="translated">Четвертая форма изменяет табличное пространство БД по умолчанию.Это может сделать только владелец БД или суперпользователь;необходимо также создать привилегии для нового табличного пространства.Эта команда физически перемещает любые таблицы или индексы в старом табличном пространстве БД по умолчанию в новое табличное пространство.Новое табличное пространство по умолчанию должно быть пустым для этой БД,и никто не может быть подключен к БД.Таблицы и индексы в табличном пространстве не по умолчанию не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="36812cc6bb8478aaca401b63d7fbabaea11a3122" translate="yes" xml:space="preserve">
          <source>The fourth form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a new base type (scalar type). To create a new base type, you must be a superuser. (This restriction is made because an erroneous type definition could confuse or even crash the server.)</source>
          <target state="translated">Четвертая форма &lt;code&gt;CREATE TYPE&lt;/code&gt; создает новый базовый тип (скалярный тип). Чтобы создать новый базовый тип, вы должны быть суперпользователем. (Это ограничение сделано потому, что ошибочное определение типа может запутать или даже привести к сбою сервера.)</target>
        </trans-unit>
        <trans-unit id="9a5bc0cc22101b5b7b3dd6dc1462291809c736e9" translate="yes" xml:space="preserve">
          <source>The fourth variant of this command listed in the synopsis can change all of the publication properties specified in &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;. Properties not mentioned in the command retain their previous settings.</source>
          <target state="translated">Четвертый вариант этой команды, указанный в синопсисе, может изменять все свойства публикации, указанные в &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt; . Свойства, не упомянутые в команде, сохраняют свои предыдущие настройки.</target>
        </trans-unit>
        <trans-unit id="dea2017c78cbd95284b251ddbea3a7b1e10a923d" translate="yes" xml:space="preserve">
          <source>The fraction of the column's entries that are null</source>
          <target state="translated">Дробь записей столбца,которые являются нулевыми.</target>
        </trans-unit>
        <trans-unit id="44d7567a007c45862dffe28ca10785cde8529aa6" translate="yes" xml:space="preserve">
          <source>The full SQL type syntax is allowed for declaring a function's arguments and return value. However, parenthesized type modifiers (e.g., the precision field for type &lt;code&gt;numeric&lt;/code&gt;) are discarded by &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Thus for example &lt;code&gt;CREATE FUNCTION foo (varchar(10)) ...&lt;/code&gt; is exactly the same as &lt;code&gt;CREATE FUNCTION foo (varchar) ...&lt;/code&gt;.</source>
          <target state="translated">Полный синтаксис типа SQL разрешен для объявления аргументов функции и возвращаемого значения. Однако модификаторы типа в скобках (например, поле точности для &lt;code&gt;numeric&lt;/code&gt; типа ) отбрасываются &lt;code&gt;CREATE FUNCTION&lt;/code&gt; . Так, например , &lt;code&gt;CREATE FUNCTION foo (varchar(10)) ...&lt;/code&gt; точно так же , как &lt;code&gt;CREATE FUNCTION foo (varchar) ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b36f659c83072f67d547396d3e51c25042456bdd" translate="yes" xml:space="preserve">
          <source>The full host name (with domain name) of the database server, or &lt;code&gt;[local]&lt;/code&gt; if the connection is over a Unix domain socket, or &lt;code&gt;[local:/dir/name]&lt;/code&gt;, if the Unix domain socket is not at the compiled in default location.</source>
          <target state="translated">Полное имя хоста (с именем домена) сервера базы данных, или &lt;code&gt;[local]&lt;/code&gt; , если соединение осуществляется через сокет домена Unix, или &lt;code&gt;[local:/dir/name]&lt;/code&gt; , если сокет домена Unix не скомпилирован по умолчанию расположение.</target>
        </trans-unit>
        <trans-unit id="51d56119fb00f5592b9aaa01b9f5e760e9ad4329" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current_setting&lt;/code&gt; produces equivalent output; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;. Also, the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view produces the same information.</source>
          <target state="translated">Функция &lt;code&gt;current_setting&lt;/code&gt; производит эквивалентный вывод; см. &lt;a href=&quot;functions-admin&quot;&gt;Раздел 9.26&lt;/a&gt; . Кроме того, системное представление &lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt; выдает ту же информацию.</target>
        </trans-unit>
        <trans-unit id="5afbca91f6730238f363a7b1792e0e6d19d8f348" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current_setting&lt;/code&gt; produces equivalent output; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.27&lt;/a&gt;. Also, the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view produces the same information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa8c22afca8c86aa84834df3d7365a4c4ad70ab" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current_setting&lt;/code&gt; yields the current value of the setting &lt;em&gt;&lt;code&gt;setting_name&lt;/code&gt;&lt;/em&gt;. It corresponds to the SQL command &lt;code&gt;SHOW&lt;/code&gt;. An example:</source>
          <target state="translated">Функция &lt;code&gt;current_setting&lt;/code&gt; возвращает текущее значение параметра &lt;em&gt; &lt;code&gt;setting_name&lt;/code&gt; &lt;/em&gt; . Это соответствует SQL-команде &lt;code&gt;SHOW&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="f6649ace670e65e10a1490b2ecf7a4829ee526f2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;date_trunc&lt;/code&gt; is conceptually similar to the &lt;code&gt;trunc&lt;/code&gt; function for numbers.</source>
          <target state="translated">Функция &lt;code&gt;date_trunc&lt;/code&gt; концептуально аналогична функции &lt;code&gt;trunc&lt;/code&gt; для чисел.</target>
        </trans-unit>
        <trans-unit id="246b10543803d9782a161a47909e8e612b910177" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;format&lt;/code&gt; produces output formatted according to a format string, in a style similar to the C function &lt;code&gt;sprintf&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;format&lt;/code&gt; производит вывод отформатированный в соответствии со строкой формата, в стиле , подобной функции С &lt;code&gt;sprintf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f972d6e5c3f5f9e5c41c594a5f0d51dc8e13164" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;hstore_to_json&lt;/code&gt; is used when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;json&lt;/code&gt;. Likewise, &lt;code&gt;hstore_to_jsonb&lt;/code&gt; is used when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;jsonb&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;hstore_to_json&lt;/code&gt; используется, когда значение &lt;code&gt;hstore&lt;/code&gt; приводится к &lt;code&gt;json&lt;/code&gt; . Аналогично, &lt;code&gt;hstore_to_jsonb&lt;/code&gt; используется, когда значение &lt;code&gt;hstore&lt;/code&gt; приводится к &lt;code&gt;jsonb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e40c0481379cfb3fb5e6423f9267d79ee88e237" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pg_export_snapshot&lt;/code&gt; saves the current snapshot and returns a &lt;code&gt;text&lt;/code&gt; string identifying the snapshot. This string must be passed (outside the database) to clients that want to import the snapshot. The snapshot is available for import only until the end of the transaction that exported it. A transaction can export more than one snapshot, if needed. Note that doing so is only useful in &lt;code&gt;READ COMMITTED&lt;/code&gt; transactions, since in &lt;code&gt;REPEATABLE READ&lt;/code&gt; and higher isolation levels, transactions use the same snapshot throughout their lifetime. Once a transaction has exported any snapshots, it cannot be prepared with &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;pg_export_snapshot&lt;/code&gt; сохраняет текущий снимок и возвращает &lt;code&gt;text&lt;/code&gt; строку, идентифицирующую снимок. Эта строка должна быть передана (вне базы данных) клиентам, которые хотят импортировать моментальный снимок. Снимок доступен для импорта только до конца транзакции, которая его экспортировала. При необходимости транзакция может экспортировать более одного снимка. Обратите внимание, что это полезно только в транзакциях &lt;code&gt;READ COMMITTED&lt;/code&gt; , поскольку при &lt;code&gt;REPEATABLE READ&lt;/code&gt; и более высоких уровнях изоляции транзакции используют один и тот же моментальный снимок на протяжении всего своего жизненного цикла. После того, как транзакция экспортировала какие-либо снимки, ее нельзя подготовить с помощью &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f7c2a78ba8dec8a097ba6554379141ee778a83d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pg_notification_queue_usage&lt;/code&gt; returns the fraction of the queue that is currently occupied by pending notifications. See &lt;a href=&quot;functions-info&quot;&gt;Section 9.25&lt;/a&gt; for more information.</source>
          <target state="translated">Функция &lt;code&gt;pg_notification_queue_usage&lt;/code&gt; возвращает долю очереди, которая в настоящее время занята ожидающими уведомлениями. См. &lt;a href=&quot;functions-info&quot;&gt;Раздел 9.25&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="47fe71d7219fa50bb753b32d84319041e350cf1a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pg_notification_queue_usage&lt;/code&gt; returns the fraction of the queue that is currently occupied by pending notifications. See &lt;a href=&quot;functions-info&quot;&gt;Section 9.26&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082064f30064e38cacd08cc4cf5d96bae8c8c23d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;populate_record&lt;/code&gt; is actually declared with &lt;code&gt;anyelement&lt;/code&gt;, not &lt;code&gt;record&lt;/code&gt;, as its first argument, but it will reject non-record types with a run-time error.</source>
          <target state="translated">Функция &lt;code&gt;populate_record&lt;/code&gt; фактически объявлена с &lt;code&gt;anyelement&lt;/code&gt; , а не &lt;code&gt;record&lt;/code&gt; , в качестве первого аргумента, но он будет отвергать , не тип записей с ошибкой времени выполнения.</target>
        </trans-unit>
        <trans-unit id="472db68032e87a9f5dc2308d607eed94d8936c47" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;set_config&lt;/code&gt; provides equivalent functionality; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;. Also, it is possible to UPDATE the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view to perform the equivalent of &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;set_config&lt;/code&gt; обеспечивает эквивалентную функциональность; см. &lt;a href=&quot;functions-admin&quot;&gt;Раздел 9.26&lt;/a&gt; . Кроме того, можно &lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt; системное представление pg_settings для выполнения эквивалента &lt;code&gt;SET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a81b9de17dd1c89cda6e145c6b31e9ece522492" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;set_config&lt;/code&gt; provides equivalent functionality; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.27&lt;/a&gt;. Also, it is possible to UPDATE the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view to perform the equivalent of &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0af8636b241010eb58f1e64ca4ece0dacf61bc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;setweight&lt;/code&gt; can be used to label the entries of a &lt;code&gt;tsvector&lt;/code&gt; with a given &lt;em&gt;weight&lt;/em&gt;, where a weight is one of the letters &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, or &lt;code&gt;D&lt;/code&gt;. This is typically used to mark entries coming from different parts of a document, such as title versus body. Later, this information can be used for ranking of search results.</source>
          <target state="translated">Функция &lt;code&gt;setweight&lt;/code&gt; может быть использован для обозначения элементов матрицы с &lt;code&gt;tsvector&lt;/code&gt; с заданным &lt;em&gt;весом&lt;/em&gt; , где вес является одной из букв , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; или &lt;code&gt;D&lt;/code&gt; . Обычно это используется для отметки записей, поступающих из разных частей документа, таких как заголовок и тело. Позже эта информация может быть использована для ранжирования результатов поиска. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13cca378c8ae0fc168761a1769d0060a92e5808a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;timezone(zone, timestamp)&lt;/code&gt; is equivalent to the SQL-conforming construct &lt;code&gt;timestamp AT TIME ZONE zone&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;timezone(zone, timestamp)&lt;/code&gt; эквивалентна SQL-совместимой конструкции &lt;code&gt;timestamp AT TIME ZONE zone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c2461207b12b5b4e196270e7b51786ac6ccae21" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ts_debug&lt;/code&gt; allows easy testing of a text search configuration.</source>
          <target state="translated">Функция &lt;code&gt;ts_debug&lt;/code&gt; позволяет легко протестировать конфигурацию текстового поиска.</target>
        </trans-unit>
        <trans-unit id="99af9ae29d7989fa85e4ac3a29989c54729ceea6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ts_stat&lt;/code&gt; is useful for checking your configuration and for finding stop-word candidates.</source>
          <target state="translated">Функция &lt;code&gt;ts_stat&lt;/code&gt; полезна для проверки вашей конфигурации и для поиска кандидатов в стоп-слова.</target>
        </trans-unit>
        <trans-unit id="2e394c193235d538ba957624ee9cbb6815d37e36" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlagg&lt;/code&gt; is, unlike the other functions described here, an aggregate function. It concatenates the input values to the aggregate function call, much like &lt;code&gt;xmlconcat&lt;/code&gt; does, except that concatenation occurs across rows rather than across expressions in a single row. See &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt; for additional information about aggregate functions.</source>
          <target state="translated">Функция &lt;code&gt;xmlagg&lt;/code&gt; , в отличие от других описанных здесь функций, является агрегатной функцией. Он объединяет входные значения с вызовом агрегатной функции, как и &lt;code&gt;xmlconcat&lt;/code&gt; , за исключением того, что объединение происходит по строкам, а не по выражениям в одной строке. См. &lt;a href=&quot;functions-aggregate&quot;&gt;Раздел 9.20&lt;/a&gt; для получения дополнительной информации об агрегатных функциях.</target>
        </trans-unit>
        <trans-unit id="0c233db134ccdaf6d9f67f9f0ee69ad09d27e178" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlagg&lt;/code&gt; is, unlike the other functions described here, an aggregate function. It concatenates the input values to the aggregate function call, much like &lt;code&gt;xmlconcat&lt;/code&gt; does, except that concatenation occurs across rows rather than across expressions in a single row. See &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt; for additional information about aggregate functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1fc89a699325691e39d0dd59e92400a699e36a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlcomment&lt;/code&gt; creates an XML value containing an XML comment with the specified text as content. The text cannot contain &amp;ldquo;&lt;code&gt;--&lt;/code&gt;&amp;rdquo; or end with a &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; so that the resulting construct is a valid XML comment. If the argument is null, the result is null.</source>
          <target state="translated">Функция &lt;code&gt;xmlcomment&lt;/code&gt; создает значение XML, содержащее комментарий XML с указанным текстом в качестве содержимого. Текст не может содержать &amp;laquo; &lt;code&gt;--&lt;/code&gt; &amp;raquo; или заканчиваться &amp;laquo; &lt;code&gt;-&lt;/code&gt; &amp;raquo;, чтобы результирующая конструкция была допустимым комментарием XML. Если аргумент равен нулю, результат равен нулю.</target>
        </trans-unit>
        <trans-unit id="3e13677298d4e7c49ab95cddcc30183542277248" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlcomment&lt;/code&gt; creates an XML value containing an XML comment with the specified text as content. The text cannot contain &amp;ldquo;&lt;code&gt;--&lt;/code&gt;&amp;rdquo; or end with a &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo;, otherwise the resulting construct would not be a valid XML comment. If the argument is null, the result is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebaef272546a7798627e85265fe680ca3031d61e" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlconcat&lt;/code&gt; concatenates a list of individual XML values to create a single value containing an XML content fragment. Null values are omitted; the result is only null if there are no nonnull arguments.</source>
          <target state="translated">Функция &lt;code&gt;xmlconcat&lt;/code&gt; объединяет список отдельных значений XML для создания одного значения, содержащего фрагмент содержимого XML. Нулевые значения опускаются; результат будет нулевым, только если нет ненулевых аргументов.</target>
        </trans-unit>
        <trans-unit id="ef22fdb70040aafe9245779771954e498b2f3f6a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlexists&lt;/code&gt; evaluates an XPath 1.0 expression (the first argument), with the passed XML value as its context item. The function returns false if the result of that evaluation yields an empty node-set, true if it yields any other value. The function returns null if any argument is null. A nonnull value passed as the context item must be an XML document, not a content fragment or any non-XML value.</source>
          <target state="translated">Функция &lt;code&gt;xmlexists&lt;/code&gt; оценивает выражение XPath 1.0 (первый аргумент) с переданным значением XML в качестве элемента контекста. Функция возвращает false, если результат этой оценки дает пустой набор узлов, и true, если он дает любое другое значение. Функция возвращает значение null, если какой-либо аргумент имеет значение null. Ненулевое значение, передаваемое в качестве элемента контекста, должно быть XML-документом, а не фрагментом содержимого или любым не-XML значением.</target>
        </trans-unit>
        <trans-unit id="837a957d18da91847b5357c6c3108da0982c435c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xpath&lt;/code&gt; evaluates the XPath 1.0 expression &lt;code&gt;xpath&lt;/code&gt; (a &lt;code&gt;text&lt;/code&gt; value) against the XML value &lt;code&gt;xml&lt;/code&gt;. It returns an array of XML values corresponding to the node-set produced by the XPath expression. If the XPath expression returns a scalar value rather than a node-set, a single-element array is returned.</source>
          <target state="translated">Функция &lt;code&gt;xpath&lt;/code&gt; вычисляет выражение XPath 1.0 &lt;code&gt;xpath&lt;/code&gt; (а &lt;code&gt;text&lt;/code&gt; значение) по отношению к значению XML - &lt;code&gt;xml&lt;/code&gt; . Он возвращает массив значений XML, соответствующий набору узлов, созданному выражением XPath. Если выражение XPath возвращает скалярное значение, а не набор узлов, возвращается одноэлементный массив.</target>
        </trans-unit>
        <trans-unit id="8aa320cc15b2fe4c99adf1be98b695e1536ba201" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xpath&lt;/code&gt; evaluates the XPath 1.0 expression &lt;em&gt;&lt;code&gt;xpath&lt;/code&gt;&lt;/em&gt; (given as text) against the XML value &lt;em&gt;&lt;code&gt;xml&lt;/code&gt;&lt;/em&gt;. It returns an array of XML values corresponding to the node-set produced by the XPath expression. If the XPath expression returns a scalar value rather than a node-set, a single-element array is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49641632c456630ce0fe9561c2cd9fece93afa1f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xpath_exists&lt;/code&gt; is a specialized form of the &lt;code&gt;xpath&lt;/code&gt; function. Instead of returning the individual XML values that satisfy the XPath 1.0 expression, this function returns a Boolean indicating whether the query was satisfied or not (specifically, whether it produced any value other than an empty node-set). This function is equivalent to the &lt;code&gt;XMLEXISTS&lt;/code&gt; predicate, except that it also offers support for a namespace mapping argument.</source>
          <target state="translated">Функция &lt;code&gt;xpath_exists&lt;/code&gt; - это специализированная форма функции &lt;code&gt;xpath&lt;/code&gt; . Вместо того, чтобы возвращать отдельные значения XML, удовлетворяющие выражению XPath 1.0, эта функция возвращает логическое значение, указывающее, был ли запрос удовлетворен или нет (в частности, произвел ли он какое-либо значение, кроме пустого набора узлов). Эта функция эквивалентна предикату &lt;code&gt;XMLEXISTS&lt;/code&gt; , за исключением того, что она также предлагает поддержку аргумента сопоставления пространства имен.</target>
        </trans-unit>
        <trans-unit id="5c574a36f3d0b3b9d8fd4793fb7a1aefa7712dc3" translate="yes" xml:space="preserve">
          <source>The function has no side effects. No information about the arguments is conveyed except via the return value. Any function that might throw an error depending on the values of its arguments is not leak-proof.</source>
          <target state="translated">Функция не имеет побочных эффектов.Информация об аргументах передается только через возвращаемое значение.Любая функция,которая может выдать ошибку в зависимости от значений своих аргументов,не является герметичной.</target>
        </trans-unit>
        <trans-unit id="b27ab2a24cc42745c4233c190a0fd395e1a3a156" translate="yes" xml:space="preserve">
          <source>The function has to be used in a &lt;code&gt;FROM&lt;/code&gt; expression, with an &lt;code&gt;AS&lt;/code&gt; clause to specify the output columns; for example</source>
          <target state="translated">Функция должна использоваться в выражении &lt;code&gt;FROM&lt;/code&gt; с предложением &lt;code&gt;AS&lt;/code&gt; для указания выходных столбцов; например</target>
        </trans-unit>
        <trans-unit id="c9d8fff21244f2a2d5eabd0812b19e459568cfb8" translate="yes" xml:space="preserve">
          <source>The function is passed a pointer to a &lt;code&gt;local_relopts&lt;/code&gt; struct, which needs to be filled with a set of operator class specific options. The options can be accessed from other support functions using the &lt;code&gt;PG_HAS_OPCLASS_OPTIONS()&lt;/code&gt; and &lt;code&gt;PG_GET_OPCLASS_OPTIONS()&lt;/code&gt; macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bc1caecad2cc53ec1c4c77402a0b8f9335155f" translate="yes" xml:space="preserve">
          <source>The function must have the following signature:</source>
          <target state="translated">Функция должна иметь следующую подпись:</target>
        </trans-unit>
        <trans-unit id="c9d3b3a8b1ce80dcb6ec1f9fb5fa0bcff0d4df0d" translate="yes" xml:space="preserve">
          <source>The function must return &lt;code&gt;true&lt;/code&gt; if the leaf tuple matches the query, or &lt;code&gt;false&lt;/code&gt; if not. In the &lt;code&gt;true&lt;/code&gt; case, if &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then &lt;code&gt;leafValue&lt;/code&gt; must be set to the value of &lt;code&gt;spgConfigIn&lt;/code&gt;.&lt;code&gt;attType&lt;/code&gt; type originally supplied to be indexed for this leaf tuple. Also, &lt;code&gt;recheck&lt;/code&gt; may be set to &lt;code&gt;true&lt;/code&gt; if the match is uncertain and so the operator(s) must be re-applied to the actual heap tuple to verify the match. If ordered search is performed, set &lt;code&gt;distances&lt;/code&gt; to an array of distance values according to &lt;code&gt;orderbys&lt;/code&gt; array. Leave it NULL otherwise. If at least one of returned distances is not exact, set &lt;code&gt;recheckDistances&lt;/code&gt; to true. In this case, the executor will calculate the exact distances after fetching the tuple from the heap, and will reorder the tuples if needed.</source>
          <target state="translated">Функция должна возвращать &lt;code&gt;true&lt;/code&gt; если конечный кортеж соответствует запросу, или &lt;code&gt;false&lt;/code&gt; если нет. В &lt;code&gt;true&lt;/code&gt; случае, если &lt;code&gt;returnData&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , тогда для &lt;code&gt;leafValue&lt;/code&gt; должно быть установлено значение &lt;code&gt;spgConfigIn&lt;/code&gt; . Тип &lt;code&gt;attType&lt;/code&gt; , изначально предоставленный для индексации для этого конечного кортежа. Кроме того, для параметра &lt;code&gt;recheck&lt;/code&gt; может быть установлено значение &amp;laquo; &lt;code&gt;true&lt;/code&gt; если совпадение не определено, и поэтому оператор (ы) необходимо повторно применить к фактическому кортежу кучи, чтобы проверить совпадение. Если выполняется упорядоченный поиск, установите &lt;code&gt;distances&lt;/code&gt; в массив значений расстояний в соответствии с &lt;code&gt;orderbys&lt;/code&gt; массив. В противном случае оставьте NULL. Если хотя бы одно из возвращенных расстояний &lt;code&gt;recheckDistances&lt;/code&gt; , установите для recheckDistances значение true. В этом случае исполнитель вычислит точные расстояния после извлечения кортежа из кучи и при необходимости изменит порядок кортежей.</target>
        </trans-unit>
        <trans-unit id="dbb965af01f35df576ea93f5375cbc5d7cb5a800" translate="yes" xml:space="preserve">
          <source>The function names can be schema-qualified if necessary. Argument types are not given, since the argument list for each type of function is predetermined. All except the headline function are required.</source>
          <target state="translated">При необходимости имена функций могут быть определены по схеме.Типы аргументов не приводятся,так как список аргументов для каждого типа функции предопределен.Требуются все функции,кроме функции заголовка.</target>
        </trans-unit>
        <trans-unit id="85e3b58b43bc6834c37e08716eb6be535f35e900" translate="yes" xml:space="preserve">
          <source>The function names can be schema-qualified if necessary. Argument types are not given, since the argument list for each type of function is predetermined. The lexize function is required, but the init function is optional.</source>
          <target state="translated">При необходимости имена функций могут быть определены по схеме.Типы аргументов не приводятся,так как список аргументов для каждого типа функции предопределен.Функция лексики обязательна,но функция init необязательна.</target>
        </trans-unit>
        <trans-unit id="3e644e558fc444f59115fd62f759afc494438aeb" translate="yes" xml:space="preserve">
          <source>The function to be called</source>
          <target state="translated">Функция,которая будет вызвана</target>
        </trans-unit>
        <trans-unit id="10c50baf8431e61e9cb02cb427556dde06fcb6c7" translate="yes" xml:space="preserve">
          <source>The function used to implement this operator.</source>
          <target state="translated">Функция,используемая для реализации этого оператора.</target>
        </trans-unit>
        <trans-unit id="0c214640ce9489d4916101b16e01715654ee3006" translate="yes" xml:space="preserve">
          <source>The function used to perform the cast. The function name can be schema-qualified. If it is not, the function will be looked up in the schema search path. The function's result data type must match the target type of the cast. Its arguments are discussed below. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="translated">Функция,используемая для выполнения литья.Имя функции может быть схожим.Если это не так,то функция будет искаться в пути поиска схемы.Тип данных результата функции должен соответствовать целевому типу приводимых данных.Ее аргументы рассматриваются ниже.Если список аргументов не указан,то имя функции должно быть уникальным в ее схеме.</target>
        </trans-unit>
        <trans-unit id="4070b563f17e2132c89c11f1dad26e620d3d0a33" translate="yes" xml:space="preserve">
          <source>The function used to perform the conversion. The function name can be schema-qualified. If it is not, the function will be looked up in the path.</source>
          <target state="translated">Функция,используемая для выполнения преобразования.Имя функции может быть схожим.Если это не так,то функция будет искаться по пути вверх.</target>
        </trans-unit>
        <trans-unit id="32829bac3c1c7822fdaafe64cfff6a892c8b38d6" translate="yes" xml:space="preserve">
          <source>The function will now execute with whatever search path is used by its caller.</source>
          <target state="translated">Теперь функция будет работать с любым поисковым трактом,используемым ее вызывающим абонентом.</target>
        </trans-unit>
        <trans-unit id="3887f28b4d8dd432ded2ac6b6e06e93d7b6fd604" translate="yes" xml:space="preserve">
          <source>The function's Boolean result value is significant only when &lt;code&gt;checkUnique&lt;/code&gt; is &lt;code&gt;UNIQUE_CHECK_PARTIAL&lt;/code&gt;. In this case a true result means the new entry is known unique, whereas false means it might be non-unique (and a deferred uniqueness check must be scheduled). For other cases a constant false result is recommended.</source>
          <target state="translated">Логическое значение результата функции имеет значение, только когда &lt;code&gt;checkUnique&lt;/code&gt; имеет значение &lt;code&gt;UNIQUE_CHECK_PARTIAL&lt;/code&gt; . В этом случае истинный результат означает, что новая запись известна уникальной, тогда как ложь означает, что она может быть неуникальной (и должна быть запланирована отложенная проверка уникальности). В остальных случаях рекомендуется постоянный ложный результат.</target>
        </trans-unit>
        <trans-unit id="e1dfbee76245b05e9845e2733e79d53c030e40bb" translate="yes" xml:space="preserve">
          <source>The function-like syntax is in fact just a function call. When one of the two standard cast syntaxes is used to do a run-time conversion, it will internally invoke a registered function to perform the conversion. By convention, these conversion functions have the same name as their output type, and thus the &amp;ldquo;function-like syntax&amp;rdquo; is nothing more than a direct invocation of the underlying conversion function. Obviously, this is not something that a portable application should rely on. For further details see &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;.</source>
          <target state="translated">Функциональный синтаксис на самом деле является просто вызовом функции. Когда для выполнения преобразования во время выполнения используется один из двух стандартных синтаксисов приведения, он внутренне вызывает зарегистрированную функцию для выполнения преобразования. По соглашению, эти функции преобразования имеют то же имя, что и их тип вывода, и, таким образом, &amp;laquo;синтаксис, подобный функциям&amp;raquo;, является не чем иным, как прямым вызовом базовой функции преобразования. Очевидно, портативное приложение не должно полагаться на это. Для получения дополнительной информации см. &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1ff17dc219c0bcfbebd29717a230a4a214e2cbc8" translate="yes" xml:space="preserve">
          <source>The functionality provided by this module overlaps substantially with the functionality of the older &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; module. But &lt;code&gt;postgres_fdw&lt;/code&gt; provides more transparent and standards-compliant syntax for accessing remote tables, and can give better performance in many cases.</source>
          <target state="translated">Функциональность, предоставляемая этим модулем, в значительной степени перекрывается функциональностью более старого модуля &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; . Но &lt;code&gt;postgres_fdw&lt;/code&gt; обеспечивает более прозрачный и соответствующий стандартам синтаксис для доступа к удаленным таблицам и во многих случаях может обеспечить лучшую производительность.</target>
        </trans-unit>
        <trans-unit id="a4c5ee9bf20fe8736a119caaca754b1fea56c984" translate="yes" xml:space="preserve">
          <source>The functionality provided by this module overlaps substantially with the functionality of the older &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt; module. But &lt;code&gt;postgres_fdw&lt;/code&gt; provides more transparent and standards-compliant syntax for accessing remote tables, and can give better performance in many cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31e36b0f324aa4e2e4f308d3f86f3d1cbe3d7e22" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;crypt()&lt;/code&gt; and &lt;code&gt;gen_salt()&lt;/code&gt; are specifically designed for hashing passwords. &lt;code&gt;crypt()&lt;/code&gt; does the hashing and &lt;code&gt;gen_salt()&lt;/code&gt; prepares algorithm parameters for it.</source>
          <target state="translated">Функции &lt;code&gt;crypt()&lt;/code&gt; и &lt;code&gt;gen_salt()&lt;/code&gt; специально разработаны для хеширования паролей. &lt;code&gt;crypt()&lt;/code&gt; выполняет хеширование, а &lt;code&gt;gen_salt()&lt;/code&gt; подготавливает для него параметры алгоритма.</target>
        </trans-unit>
        <trans-unit id="459538ee1cd160dead602c42a37b3db46574d899" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;json[b]_populate_record&lt;/code&gt;, &lt;code&gt;json[b]_populate_recordset&lt;/code&gt;, &lt;code&gt;json[b]_to_record&lt;/code&gt; and &lt;code&gt;json[b]_to_recordset&lt;/code&gt; operate on a JSON object, or array of objects, and extract the values associated with keys whose names match column names of the output row type. Object fields that do not correspond to any output column name are ignored, and output columns that do not match any object field will be filled with nulls. To convert a JSON value to the SQL type of an output column, the following rules are applied in sequence:</source>
          <target state="translated">Функции &lt;code&gt;json[b]_populate_record&lt;/code&gt; , &lt;code&gt;json[b]_populate_recordset&lt;/code&gt; , &lt;code&gt;json[b]_to_record&lt;/code&gt; и &lt;code&gt;json[b]_to_recordset&lt;/code&gt; работают с объектом JSON или массивом объектов и извлекают значения, связанные с ключами, имена которых совпадают с именами столбцов тип выходной строки. Поля объектов, которые не соответствуют ни одному имени выходного столбца, игнорируются, а выходные столбцы, не соответствующие ни одному полю объекта, будут заполнены нулями. Чтобы преобразовать значение JSON в тип SQL выходного столбца, последовательно применяются следующие правила:</target>
        </trans-unit>
        <trans-unit id="377b36f768957552b23e80bcd91c885aadb25355" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;lower_inc&lt;/code&gt; and &lt;code&gt;upper_inc&lt;/code&gt; test the inclusivity of the lower and upper bounds of a range value, respectively.</source>
          <target state="translated">Функции &lt;code&gt;lower_inc&lt;/code&gt; и &lt;code&gt;upper_inc&lt;/code&gt; проверяют инклюзивность нижней и верхней границ значения диапазона соответственно.</target>
        </trans-unit>
        <trans-unit id="f9b6f07f168f9bab47cb0d63914798ab55512000" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;lower_inf&lt;/code&gt; and &lt;code&gt;upper_inf&lt;/code&gt; test for infinite lower and upper bounds of a range, respectively.</source>
          <target state="translated">Функции &lt;code&gt;lower_inf&lt;/code&gt; и &lt;code&gt;upper_inf&lt;/code&gt; проверяют бесконечные нижнюю и верхнюю границы диапазона соответственно.</target>
        </trans-unit>
        <trans-unit id="f703d74ff7244a4147930578a835fc919fa68d3e" translate="yes" xml:space="preserve">
          <source>The functions above that operate on tables or indexes accept a &lt;code&gt;regclass&lt;/code&gt; argument, which is simply the OID of the table or index in the &lt;code&gt;pg_class&lt;/code&gt; system catalog. You do not have to look up the OID by hand, however, since the &lt;code&gt;regclass&lt;/code&gt; data type's input converter will do the work for you. Just write the table name enclosed in single quotes so that it looks like a literal constant. For compatibility with the handling of ordinary SQL names, the string will be converted to lower case unless it contains double quotes around the table name.</source>
          <target state="translated">Вышеупомянутые функции, которые работают с таблицами или индексами, принимают аргумент &lt;code&gt;regclass&lt;/code&gt; , который представляет собой просто OID таблицы или индекса в системном каталоге &lt;code&gt;pg_class&lt;/code&gt; . Однако вам не нужно искать OID вручную, поскольку преобразователь ввода типа данных &lt;code&gt;regclass&lt;/code&gt; сделает всю работу за вас. Просто напишите имя таблицы в одинарных кавычках, чтобы оно выглядело как буквальная константа. Для совместимости с обработкой обычных имен SQL строка будет преобразована в нижний регистр, если она не содержит двойных кавычек вокруг имени таблицы.</target>
        </trans-unit>
        <trans-unit id="c0e923506f65e63b3dddbd22a7fb5e1606f3b604" translate="yes" xml:space="preserve">
          <source>The functions and function-like expressions described in this section operate on values of type &lt;code&gt;xml&lt;/code&gt;. See &lt;a href=&quot;datatype-xml&quot;&gt;Section 8.13&lt;/a&gt; for information about the &lt;code&gt;xml&lt;/code&gt; type. The function-like expressions &lt;code&gt;xmlparse&lt;/code&gt; and &lt;code&gt;xmlserialize&lt;/code&gt; for converting to and from type &lt;code&gt;xml&lt;/code&gt; are documented there, not in this section.</source>
          <target state="translated">Функции и подобные функции выражения, описанные в этом разделе, работают со значениями типа &lt;code&gt;xml&lt;/code&gt; . См. &lt;a href=&quot;datatype-xml&quot;&gt;Раздел 8.13&lt;/a&gt; для получения информации о типе &lt;code&gt;xml&lt;/code&gt; . Функциональные выражения &lt;code&gt;xmlparse&lt;/code&gt; и &lt;code&gt;xmlserialize&lt;/code&gt; для преобразования в тип &lt;code&gt;xml&lt;/code&gt; и обратно задокументированы там, а не в этом разделе.</target>
        </trans-unit>
        <trans-unit id="446413d467bd2bbb60b9839ce5313e8b03a2051d" translate="yes" xml:space="preserve">
          <source>The functions and operators that can be used in filter expressions are listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-FILTER-EX-TABLE&quot;&gt;Table 9.49&lt;/a&gt;. Within a filter expression, the &lt;code&gt;@&lt;/code&gt; variable denotes the value being filtered (i.e., one result of the preceding path step). You can write accessor operators after &lt;code&gt;@&lt;/code&gt; to retrieve component items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ccb73aae614647b2269d26a350b909a44513b27" translate="yes" xml:space="preserve">
          <source>The functions described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP&quot;&gt;Section 9.26.3&lt;/a&gt;, &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL&quot;&gt;Section 9.26.4&lt;/a&gt;, and &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;Section 9.26.5&lt;/a&gt; are also relevant for replication.</source>
          <target state="translated">Функции, описанные в &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP&quot;&gt;Разделе 9.26.3&lt;/a&gt; , &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL&quot;&gt;Разделе 9.26.4&lt;/a&gt; и &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;Разделе 9.26.5&lt;/a&gt; , также актуальны для репликации.</target>
        </trans-unit>
        <trans-unit id="b81751fa3955355b5d3a556c7a3d013468731610" translate="yes" xml:space="preserve">
          <source>The functions described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP&quot;&gt;Section 9.27.3&lt;/a&gt;, &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL&quot;&gt;Section 9.27.4&lt;/a&gt;, and &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;Section 9.27.5&lt;/a&gt; are also relevant for replication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e464a1af28710d4a1fd7e811bd3d0475c5576752" translate="yes" xml:space="preserve">
          <source>The functions described in this section are used to control and monitor a PostgreSQL installation.</source>
          <target state="translated">Функции,описанные в этом разделе,используются для управления и мониторинга установки PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="01945498ca90e6ae3cd1d1b921c28c9c72aead1f" translate="yes" xml:space="preserve">
          <source>The functions here implement the encryption part of the OpenPGP (RFC 4880) standard. Supported are both symmetric-key and public-key encryption.</source>
          <target state="translated">Здесь функции реализуют шифровальную часть стандарта OpenPGP (RFC 4880).Поддерживается как симметричное шифрование,так и шифрование с открытым ключом.</target>
        </trans-unit>
        <trans-unit id="122b22a585b5cb5a2901cc7acf3393bb3b507311" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-DEBUG-TABLE&quot;&gt;Table 9.43&lt;/a&gt; are listed separately because they are not usually used in everyday text searching operations. They are helpful for development and debugging of new text search configurations.</source>
          <target state="translated">Функции в &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-DEBUG-TABLE&quot;&gt;таблице 9.43&lt;/a&gt; перечислены отдельно, поскольку они обычно не используются в повседневных операциях поиска текста. Они полезны для разработки и отладки новых конфигураций текстового поиска.</target>
        </trans-unit>
        <trans-unit id="c6ad12baa54d39c8fc88a5e6e9a85448981c7055" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-DEBUG-TABLE&quot;&gt;Table 9.43&lt;/a&gt; are listed separately because they are not usually used in everyday text searching operations. They are primarily helpful for development and debugging of new text search configurations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ec00f1a0d952540e42b411ff256f01a844ba9a" translate="yes" xml:space="preserve">
          <source>The functions listed in &lt;a href=&quot;pgbench#PGBENCH-FUNCTIONS&quot;&gt;Table 259&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Функции, перечисленные в &lt;a href=&quot;pgbench#PGBENCH-FUNCTIONS&quot;&gt;Таблице 259&lt;/a&gt; , встроены в pgbench и могут использоваться в выражениях, появляющихся в &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt; &lt;code&gt;\set&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb877f9037b63b7fb5ec45e9dfbcbce68a00d900" translate="yes" xml:space="preserve">
          <source>The functions listed in &lt;a href=&quot;pgbench#PGBENCH-FUNCTIONS&quot;&gt;Table 275&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d976c2e21ce82fc5ee166341bd65f2f942d7585" translate="yes" xml:space="preserve">
          <source>The functions provided by the &lt;code&gt;intarray&lt;/code&gt; module are shown in &lt;a href=&quot;intarray#INTARRAY-FUNC-TABLE&quot;&gt;Table F.9&lt;/a&gt;, the operators in &lt;a href=&quot;intarray#INTARRAY-OP-TABLE&quot;&gt;Table F.10&lt;/a&gt;.</source>
          <target state="translated">Функции, предоставляемые модулем &lt;code&gt;intarray&lt;/code&gt; , показаны в &lt;a href=&quot;intarray#INTARRAY-FUNC-TABLE&quot;&gt;таблице F.9&lt;/a&gt; , операторы - в &lt;a href=&quot;intarray#INTARRAY-OP-TABLE&quot;&gt;таблице F.10&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="589cd253a59ec741e7593831b0243a0b8a47c194" translate="yes" xml:space="preserve">
          <source>The functions provided by the &lt;code&gt;pg_trgm&lt;/code&gt; module are shown in &lt;a href=&quot;pgtrgm#PGTRGM-FUNC-TABLE&quot;&gt;Table F.24&lt;/a&gt;, the operators in &lt;a href=&quot;pgtrgm#PGTRGM-OP-TABLE&quot;&gt;Table F.25&lt;/a&gt;.</source>
          <target state="translated">Функции, предоставляемые модулем &lt;code&gt;pg_trgm&lt;/code&gt; , показаны в &lt;a href=&quot;pgtrgm#PGTRGM-FUNC-TABLE&quot;&gt;таблице F.24&lt;/a&gt; , операторы - в &lt;a href=&quot;pgtrgm#PGTRGM-OP-TABLE&quot;&gt;таблице F.25&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5afb7a5be90f1ea0d87d155bbd2bc796569625a1" translate="yes" xml:space="preserve">
          <source>The functions provided to manipulate advisory locks are described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS&quot;&gt;Section 9.26.10&lt;/a&gt;.</source>
          <target state="translated">Функции, обеспечивающие управление рекомендательными блокировками, описаны в &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS&quot;&gt;Разделе 9.26.10&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cd30982d3557c91a4d774832819968f49725f2e" translate="yes" xml:space="preserve">
          <source>The functions provided to manipulate advisory locks are described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS&quot;&gt;Section 9.27.10&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ef1c3ef042af3960555b6b81e0fa70ed4d457f" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;adminpack#FUNCTIONS-ADMINPACK-TABLE&quot;&gt;Table F.1&lt;/a&gt; provide write access to files on the machine hosting the server. (See also the functions in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.94&lt;/a&gt;, which provide read-only access.) Only files within the database cluster directory can be accessed, unless the user is a superuser or given one of the pg_read_server_files, or pg_write_server_files roles, as appropriate for the function, but either a relative or absolute path is allowable.</source>
          <target state="translated">Функции, показанные в &lt;a href=&quot;adminpack#FUNCTIONS-ADMINPACK-TABLE&quot;&gt;Таблице F.1,&lt;/a&gt; обеспечивают доступ на запись к файлам на машине, на которой размещен сервер. (См. Также функции в &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Таблице 9.94&lt;/a&gt; , которые обеспечивают доступ только для чтения.) Доступны только файлы в каталоге кластера базы данных, если только пользователь не является суперпользователем или ему не назначена одна из ролей pg_read_server_files или pg_write_server_files, в зависимости от функции , но допустим как относительный, так и абсолютный путь.</target>
        </trans-unit>
        <trans-unit id="70cd1eb89b2a38aa3978efc4d80de7d291b55bb8" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;adminpack#FUNCTIONS-ADMINPACK-TABLE&quot;&gt;Table F.1&lt;/a&gt; provide write access to files on the machine hosting the server. (See also the functions in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.95&lt;/a&gt;, which provide read-only access.) Only files within the database cluster directory can be accessed, unless the user is a superuser or given one of the pg_read_server_files, or pg_write_server_files roles, as appropriate for the function, but either a relative or absolute path is allowable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af557d79922e415d01771dc33cbf93a73edbe83c" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt; assist in making on-line backups. These functions cannot be executed during recovery (except non-exclusive &lt;code&gt;pg_start_backup&lt;/code&gt;, non-exclusive &lt;code&gt;pg_stop_backup&lt;/code&gt;, &lt;code&gt;pg_is_in_backup&lt;/code&gt;, &lt;code&gt;pg_backup_start_time&lt;/code&gt; and &lt;code&gt;pg_wal_lsn_diff&lt;/code&gt;).</source>
          <target state="translated">Функции, показанные в &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Таблице 9.84,&lt;/a&gt; помогают создавать резервные копии в оперативном режиме. Эти функции не могут быть выполнены во время восстановления (кроме неисключительных &lt;code&gt;pg_start_backup&lt;/code&gt; , неисключительных &lt;code&gt;pg_stop_backup&lt;/code&gt; , &lt;code&gt;pg_is_in_backup&lt;/code&gt; , &lt;code&gt;pg_backup_start_time&lt;/code&gt; и &lt;code&gt;pg_wal_lsn_diff&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fbbf6edb07e082e01233d3732d43204b4655cc4b" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.85&lt;/a&gt; assist in making on-line backups. These functions cannot be executed during recovery (except non-exclusive &lt;code&gt;pg_start_backup&lt;/code&gt;, non-exclusive &lt;code&gt;pg_stop_backup&lt;/code&gt;, &lt;code&gt;pg_is_in_backup&lt;/code&gt;, &lt;code&gt;pg_backup_start_time&lt;/code&gt; and &lt;code&gt;pg_wal_lsn_diff&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2948c9238f28bd4ff2bb40ce8791d0b13005bd" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBLOCATION&quot;&gt;Table 9.90&lt;/a&gt; assist in identifying the specific disk files associated with database objects.</source>
          <target state="translated">Функции, представленные в &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBLOCATION&quot;&gt;Таблице 9.90,&lt;/a&gt; помогают идентифицировать конкретные файлы на диске, связанные с объектами базы данных.</target>
        </trans-unit>
        <trans-unit id="862902fc740913f3db230495f16a3481a70b3805" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBLOCATION&quot;&gt;Table 9.91&lt;/a&gt; assist in identifying the specific disk files associated with database objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d92b50819e3d60d5191300256c8390d3bc20d24" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.89&lt;/a&gt; calculate the disk space usage of database objects.</source>
          <target state="translated">Функции, показанные в &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Таблице 9.89,&lt;/a&gt; вычисляют использование дискового пространства объектами базы данных.</target>
        </trans-unit>
        <trans-unit id="4a83057be3a29505df68ff81363e61d91a887e44" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.90&lt;/a&gt; calculate the disk space usage of database objects, or assist in presentation of usage results. All these functions return sizes measured in bytes. If an OID that does not represent an existing object is passed to one of these functions, &lt;code&gt;NULL&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="596d61caa752f0c6f6982e0c8634c7eacfed18b6" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.94&lt;/a&gt; provide native access to files on the machine hosting the server. Only files within the database cluster directory and the &lt;code&gt;log_directory&lt;/code&gt; can be accessed unless the user is granted the role &lt;code&gt;pg_read_server_files&lt;/code&gt;. Use a relative path for files in the cluster directory, and a path matching the &lt;code&gt;log_directory&lt;/code&gt; configuration setting for log files.</source>
          <target state="translated">Функции, показанные в &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Таблице 9.94,&lt;/a&gt; обеспечивают собственный доступ к файлам на машине, на которой размещен сервер. &lt;code&gt;log_directory&lt;/code&gt; только файлы в каталоге кластера базы данных и log_directory , если пользователю не назначена роль &lt;code&gt;pg_read_server_files&lt;/code&gt; . Используйте относительный путь для файлов в каталоге кластера и путь, соответствующий &lt;code&gt;log_directory&lt;/code&gt; конфигурации log_directory для файлов журнала.</target>
        </trans-unit>
        <trans-unit id="e2846b4d9144cb92c1cdd58938547d8a0b822c70" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.95&lt;/a&gt; provide native access to files on the machine hosting the server. Only files within the database cluster directory and the &lt;code&gt;log_directory&lt;/code&gt; can be accessed, unless the user is a superuser or is granted the role &lt;code&gt;pg_read_server_files&lt;/code&gt;. Use a relative path for files in the cluster directory, and a path matching the &lt;code&gt;log_directory&lt;/code&gt; configuration setting for log files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c73f231d92075fb0c71fc7740bf5175d685468" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;Table 9.83&lt;/a&gt; send control signals to other server processes. Use of these functions is restricted to superusers by default but access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;, with noted exceptions.</source>
          <target state="translated">Функции, показанные в &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;Таблице 9.83,&lt;/a&gt; отправляют управляющие сигналы другим серверным процессам. Использование этих функций по умолчанию ограничено суперпользователями, но доступ может быть предоставлен другим пользователям с помощью &lt;code&gt;GRANT&lt;/code&gt; , с отмеченными исключениями.</target>
        </trans-unit>
        <trans-unit id="3a4405481fecb5e6303cc2c9e6917c8fc5078234" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;Table 9.84&lt;/a&gt; send control signals to other server processes. Use of these functions is restricted to superusers by default but access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;, with noted exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11868a349a93977f4f568672a07b5dec83a888d7" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS-TABLE&quot;&gt;Table 9.95&lt;/a&gt; manage advisory locks. For details about proper use of these functions, see &lt;a href=&quot;explicit-locking#ADVISORY-LOCKS&quot;&gt;Section 13.3.5&lt;/a&gt;.</source>
          <target state="translated">Функции, показанные в &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS-TABLE&quot;&gt;Таблице 9.95,&lt;/a&gt; управляют консультативными блокировками. Подробные сведения о правильном использовании этих функций см. В &lt;a href=&quot;explicit-locking#ADVISORY-LOCKS&quot;&gt;Разделе 13.3.5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b59303348c39a352bb589d8b03735abeb1beeb3" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS-TABLE&quot;&gt;Table 9.96&lt;/a&gt; manage advisory locks. For details about proper use of these functions, see &lt;a href=&quot;explicit-locking#ADVISORY-LOCKS&quot;&gt;Section 13.3.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba997e6585ffd2ebf0df203e2718f49b87e3ad76" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.86&lt;/a&gt; control the progress of recovery. These functions may be executed only during recovery.</source>
          <target state="translated">Функции, показанные в &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Таблице 9.86,&lt;/a&gt; контролируют ход восстановления. Эти функции могут быть выполнены только во время восстановления.</target>
        </trans-unit>
        <trans-unit id="127dcdaf3c316cf3d90889d6aee1511f65db73de" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.87&lt;/a&gt; control the progress of recovery. These functions may be executed only during recovery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf9851935069d5da8579d648493492e0773919e" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt; provide information about the current status of the standby. These functions may be executed both during recovery and in normal running.</source>
          <target state="translated">Функции, показанные в &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Табл. 9.85,&lt;/a&gt; предоставляют информацию о текущем состоянии резервного. Эти функции могут выполняться как во время восстановления, так и при нормальной работе.</target>
        </trans-unit>
        <trans-unit id="341a6188170e97e18176dfb27299fdbe78c52ae6" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.86&lt;/a&gt; provide information about the current status of a standby server. These functions may be executed both during recovery and in normal running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ba5a0a32a32de29b727183748ebc1db30a8063" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION-TABLE&quot;&gt;Table 9.88&lt;/a&gt; are for controlling and interacting with replication features. See &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;, &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt; for information about the underlying features. Use of functions for replication origin is restricted to superusers. Use of functions for replication slot is restricted to superusers and users having &lt;code&gt;REPLICATION&lt;/code&gt; privilege.</source>
          <target state="translated">Функции, показанные в &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION-TABLE&quot;&gt;таблице 9.88,&lt;/a&gt; предназначены для управления функциями репликации и взаимодействия с ними. См. &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Раздел 26.2.5&lt;/a&gt; , &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Раздел 26.2.6&lt;/a&gt; и &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;Глава 49&lt;/a&gt; для получения информации о базовых функциях. Использование функций для источника репликации ограничено суперпользователями. Использование функций для слота репликации ограничено суперпользователями и пользователями, имеющими привилегию &lt;code&gt;REPLICATION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dad85ba1196a94eeff1c17a7e2716734fef21a9" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION-TABLE&quot;&gt;Table 9.89&lt;/a&gt; are for controlling and interacting with replication features. See &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;, &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/13/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt; for information about the underlying features. Use of functions for replication origin is restricted to superusers. Use of functions for replication slots is restricted to superusers and users having &lt;code&gt;REPLICATION&lt;/code&gt; privilege.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423b085ba2dc236f90217ee4b570443351039e1a" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-COMMIT-TIMESTAMP&quot;&gt;Table 9.76&lt;/a&gt; provide information about transactions that have been already committed. These functions mainly provide information about when the transactions were committed. They only provide useful data when &lt;a href=&quot;runtime-config-replication#GUC-TRACK-COMMIT-TIMESTAMP&quot;&gt;track_commit_timestamp&lt;/a&gt; configuration option is enabled and only for transactions that were committed after it was enabled.</source>
          <target state="translated">Функции, показанные в &lt;a href=&quot;functions-info#FUNCTIONS-COMMIT-TIMESTAMP&quot;&gt;Таблице 9.76,&lt;/a&gt; предоставляют информацию об уже зафиксированных транзакциях. Эти функции в основном предоставляют информацию о том, когда транзакции были совершены. Они предоставляют полезные данные только при &lt;a href=&quot;runtime-config-replication#GUC-TRACK-COMMIT-TIMESTAMP&quot;&gt;включенной&lt;/a&gt; опции конфигурации track_commit_timestamp и только для транзакций, которые были зафиксированы после того, как она была включена.</target>
        </trans-unit>
        <trans-unit id="d456c632c2c97e3b05a72328c838d9913de5f8d0" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-COMMIT-TIMESTAMP&quot;&gt;Table 9.77&lt;/a&gt; provide information about when past transactions were committed. They only provide useful data when the &lt;a href=&quot;runtime-config-replication#GUC-TRACK-COMMIT-TIMESTAMP&quot;&gt;track_commit_timestamp&lt;/a&gt; configuration option is enabled, and only for transactions that were committed after it was enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bfe1a4de569556a1d516d3985556b63d6f6146f" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-CONTROLDATA&quot;&gt;Table 9.77&lt;/a&gt; print information initialized during &lt;code&gt;initdb&lt;/code&gt;, such as the catalog version. They also show information about write-ahead logging and checkpoint processing. This information is cluster-wide, and not specific to any one database. They provide most of the same information, from the same source, as &lt;a href=&quot;app-pgcontroldata&quot;&gt;pg_controldata&lt;/a&gt;, although in a form better suited to SQL functions.</source>
          <target state="translated">Функции, показанные в &lt;a href=&quot;functions-info#FUNCTIONS-CONTROLDATA&quot;&gt;Таблице 9.77,&lt;/a&gt; печатают информацию, инициализированную во время &lt;code&gt;initdb&lt;/code&gt; , например, версию каталога. Они также показывают информацию о ведении журнала упреждающей записи и обработке контрольных точек. Эта информация распространяется на весь кластер и не относится к какой-либо одной базе данных. Они предоставляют большую часть той же информации из того же источника, что и &lt;a href=&quot;app-pgcontroldata&quot;&gt;pg_controldata&lt;/a&gt; , хотя в форме, более подходящей для функций SQL.</target>
        </trans-unit>
        <trans-unit id="f4644a53e9bb9e3b709daab47cfd9c549aaf8f50" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-CONTROLDATA&quot;&gt;Table 9.78&lt;/a&gt; print information initialized during &lt;code&gt;initdb&lt;/code&gt;, such as the catalog version. They also show information about write-ahead logging and checkpoint processing. This information is cluster-wide, not specific to any one database. These functions provide most of the same information, from the same source, as the &lt;a href=&quot;app-pgcontroldata&quot;&gt;pg_controldata&lt;/a&gt; application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46311f3452a56adeb669710af158b1d331e3ba4e" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-INFO-COMMENT-TABLE&quot;&gt;Table 9.73&lt;/a&gt; extract comments previously stored with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command. A null value is returned if no comment could be found for the specified parameters.</source>
          <target state="translated">Функции, показанные в &lt;a href=&quot;functions-info#FUNCTIONS-INFO-COMMENT-TABLE&quot;&gt;Таблице 9.73,&lt;/a&gt; извлекают комментарии, ранее сохраненные с помощью команды &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; . Если для указанных параметров не удалось найти комментарий, возвращается нулевое значение.</target>
        </trans-unit>
        <trans-unit id="d1b030aa28d10d3a864b72b4ee87a9054320e5c9" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT&quot;&gt;Table 9.74&lt;/a&gt; provide server transaction information in an exportable form. The main use of these functions is to determine which transactions were committed between two snapshots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f306d4b7a9229188bb697a19658366a35ce8588" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;Table 9.74&lt;/a&gt; provide server transaction information in an exportable form. The main use of these functions is to determine which transactions were committed between two snapshots.</source>
          <target state="translated">Функции, показанные в &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;таблице 9.74,&lt;/a&gt; предоставляют информацию о транзакциях сервера в экспортируемой форме. Основное использование этих функций - определить, какие транзакции были зафиксированы между двумя снимками состояния.</target>
        </trans-unit>
        <trans-unit id="9398f596a0390810b3e41d607c70ae410202516a" translate="yes" xml:space="preserve">
          <source>The functions verify various &lt;em&gt;invariants&lt;/em&gt; in the structure of the representation of particular relations. The correctness of the access method functions behind index scans and other important operations relies on these invariants always holding. For example, certain functions verify, among other things, that all B-Tree pages have items in &amp;ldquo;logical&amp;rdquo; order (e.g., for B-Tree indexes on &lt;code&gt;text&lt;/code&gt;, index tuples should be in collated lexical order). If that particular invariant somehow fails to hold, we can expect binary searches on the affected page to incorrectly guide index scans, resulting in wrong answers to SQL queries.</source>
          <target state="translated">Функции проверяют различные &lt;em&gt;инварианты&lt;/em&gt; в структуре представления конкретных отношений. Правильность функций метода доступа при сканировании индекса и других важных операциях зависит от того, что эти инварианты всегда сохраняются. Например, определенные функции проверяют, среди прочего, что все страницы B-дерева имеют элементы в &amp;laquo;логическом&amp;raquo; порядке (например, для индексов B-Tree в &lt;code&gt;text&lt;/code&gt; кортежи индекса должны располагаться в упорядоченном лексическом порядке). Если этот конкретный инвариант каким-либо образом не выполняется, мы можем ожидать, что двоичный поиск на затронутой странице будет неправильно направлять сканирование индекса, что приведет к неправильным ответам на запросы SQL.</target>
        </trans-unit>
        <trans-unit id="0d68a3d97b1b4428fbfcb9d0333819c6fcb3c2b0" translate="yes" xml:space="preserve">
          <source>The fundamental type of an XQuery/XPath expression, the &lt;code&gt;sequence&lt;/code&gt;, which can contain XML nodes, atomic values, or both, does not exist in XPath 1.0. A 1.0 expression can only produce a node-set (containing zero or more XML nodes), or a single atomic value.</source>
          <target state="translated">Фундаментальный тип выражения XQuery / XPath, &lt;code&gt;sequence&lt;/code&gt; , которая может содержать узлы XML, атомарные значения или и то, и другое, не существует в XPath 1.0. Выражение 1.0 может создавать только набор узлов (содержащий ноль или более узлов XML) или одно атомарное значение.</target>
        </trans-unit>
        <trans-unit id="01481c12012dd36b33a9e59e6d02e28615f69f45" translate="yes" xml:space="preserve">
          <source>The general form of a recursive &lt;code&gt;WITH&lt;/code&gt; query is always a &lt;em&gt;non-recursive term&lt;/em&gt;, then &lt;code&gt;UNION&lt;/code&gt; (or &lt;code&gt;UNION ALL&lt;/code&gt;), then a &lt;em&gt;recursive term&lt;/em&gt;, where only the recursive term can contain a reference to the query's own output. Such a query is executed as follows:</source>
          <target state="translated">Общая форма рекурсивного запроса &lt;code&gt;WITH&lt;/code&gt; - это всегда &lt;em&gt;нерекурсивный термин&lt;/em&gt; , затем &lt;code&gt;UNION&lt;/code&gt; (или &lt;code&gt;UNION ALL&lt;/code&gt; ), затем &lt;em&gt;рекурсивный термин&lt;/em&gt; , где только рекурсивный термин может содержать ссылку на собственный вывод запроса. Такой запрос выполняется следующим образом:</target>
        </trans-unit>
        <trans-unit id="8eee7d4e38c500df724907fbea7403f66500c981" translate="yes" xml:space="preserve">
          <source>The general format of the &lt;code&gt;pg_hba.conf&lt;/code&gt; file is a set of records, one per line. Blank lines are ignored, as is any text after the &lt;code&gt;#&lt;/code&gt; comment character. Records cannot be continued across lines. A record is made up of a number of fields which are separated by spaces and/or tabs. Fields can contain white space if the field value is double-quoted. Quoting one of the keywords in a database, user, or address field (e.g., &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;replication&lt;/code&gt;) makes the word lose its special meaning, and just match a database, user, or host with that name.</source>
          <target state="translated">Общий формат файла &lt;code&gt;pg_hba.conf&lt;/code&gt; - это набор записей, по одной в строке. Пустые строки игнорируются, как и любой текст после символа комментария &lt;code&gt;#&lt;/code&gt; . Записи не могут продолжаться через строки. Запись состоит из ряда полей, разделенных пробелами и / или табуляциями. Поля могут содержать пробелы, если значение поля заключено в двойные кавычки. Заключение в кавычки одного из ключевых слов в поле базы данных, пользователя или адреса (например, &lt;code&gt;all&lt;/code&gt; или &lt;code&gt;replication&lt;/code&gt; ) приводит к тому, что слово теряет свое особое значение и просто соответствует базе данных, пользователю или хосту с этим именем.</target>
        </trans-unit>
        <trans-unit id="2ed177efb04faf95279eeefdbca2d0ce9a32d2a9" translate="yes" xml:space="preserve">
          <source>The general principle is that the contained object must match the containing object as to structure and data contents, possibly after discarding some non-matching array elements or object key/value pairs from the containing object. But remember that the order of array elements is not significant when doing a containment match, and duplicate array elements are effectively considered only once.</source>
          <target state="translated">Общий принцип заключается в том,что содержащийся объект должен соответствовать содержащемуся объекту по структуре и содержанию данных,возможно,после удаления из содержащегося объекта некоторых несовпадающих элементов массива или пар ключ/значение объекта.Но помните,что порядок элементов массива не имеет значения при совпадении содержащихся в нем элементов,а дубликаты элементов массива эффективно рассматриваются только один раз.</target>
        </trans-unit>
        <trans-unit id="ab5e9d694a644360b18b209b2a60b5fe2f2901b9" translate="yes" xml:space="preserve">
          <source>The general rule for configuring a list of dictionaries is to place first the most narrow, most specific dictionary, then the more general dictionaries, finishing with a very general dictionary, like a Snowball stemmer or &lt;code&gt;simple&lt;/code&gt;, which recognizes everything. For example, for an astronomy-specific search (&lt;code&gt;astro_en&lt;/code&gt; configuration) one could bind token type &lt;code&gt;asciiword&lt;/code&gt; (ASCII word) to a synonym dictionary of astronomical terms, a general English dictionary and a Snowball English stemmer:</source>
          <target state="translated">Общее правило настройки списка словарей состоит в том, чтобы поместить сначала самый узкий, самый конкретный словарь, затем более общие словари, заканчивая очень общим словарем, например, стеммером Snowball или &lt;code&gt;simple&lt;/code&gt; , который распознает все. Например, для поиска по астрономии ( конфигурация &lt;code&gt;astro_en&lt;/code&gt; ) можно привязать &lt;code&gt;asciiword&lt;/code&gt; типа токена (слово ASCII) к словарю синонимов астрономических терминов, общему английскому словарю и стеммеру английского языка Snowball:</target>
        </trans-unit>
        <trans-unit id="5f82a175fcf092449c33c188da71a078b0c24826" translate="yes" xml:space="preserve">
          <source>The generated array type's name is the scalar type's name with an underscore prepended. The array entry's other fields are filled from &lt;code&gt;BKI_ARRAY_DEFAULT(value)&lt;/code&gt; annotations in &lt;code&gt;pg_type.h&lt;/code&gt;, or if there isn't one, copied from the scalar type. (There's also a special case for &lt;code&gt;typalign&lt;/code&gt;.) Then the &lt;code&gt;typelem&lt;/code&gt; and &lt;code&gt;typarray&lt;/code&gt; fields of the two entries are set to cross-reference each other.</source>
          <target state="translated">Имя сгенерированного типа массива - это имя скалярного типа с добавленным подчеркиванием. Остальные поля записи массива заполняются из &lt;code&gt;BKI_ARRAY_DEFAULT(value)&lt;/code&gt; в &lt;code&gt;pg_type.h&lt;/code&gt; или, если их нет, копируются из скалярного типа. (Существует также особый случай для &lt;code&gt;typalign&lt;/code&gt; .) Затем &lt;code&gt;typelem&lt;/code&gt; и &lt;code&gt;typarray&lt;/code&gt; двух записей устанавливаются для перекрестных ссылок друг на друга.</target>
        </trans-unit>
        <trans-unit id="3eb30312d4c2f46733a2c8327c7814b6e7e52a77" translate="yes" xml:space="preserve">
          <source>The generated queries are executed in the order in which the rows are returned, and left-to-right within each row if there is more than one column. NULL fields are ignored. The generated queries are sent literally to the server for processing, so they cannot be psql meta-commands nor contain psql variable references. If any individual query fails, execution of the remaining queries continues unless &lt;code&gt;ON_ERROR_STOP&lt;/code&gt; is set. Execution of each query is subject to &lt;code&gt;ECHO&lt;/code&gt; processing. (Setting &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;queries&lt;/code&gt; is often advisable when using &lt;code&gt;\gexec&lt;/code&gt;.) Query logging, single-step mode, timing, and other query execution features apply to each generated query as well.</source>
          <target state="translated">Сгенерированные запросы выполняются в том порядке, в котором возвращаются строки, и слева направо в каждой строке, если имеется более одного столбца. Поля NULL игнорируются. Сгенерированные запросы буквально отправляются на сервер для обработки, поэтому они не могут быть метакомандами psql или содержать ссылки на переменные psql. Если какой-либо отдельный запрос завершается неудачно, выполнение остальных запросов продолжается, если не установлено значение &lt;code&gt;ON_ERROR_STOP&lt;/code&gt; . Выполнение каждого запроса подлежит обработке &lt;code&gt;ECHO&lt;/code&gt; . ( При использовании &lt;code&gt;\gexec&lt;/code&gt; часто рекомендуется устанавливать &lt;code&gt;ECHO&lt;/code&gt; для &lt;code&gt;all&lt;/code&gt; или &lt;code&gt;queries&lt;/code&gt; .) Ведение журнала запросов, пошаговый режим, синхронизация и другие функции выполнения запроса также применимы к каждому сгенерированному запросу.</target>
        </trans-unit>
        <trans-unit id="b9932b57cc46c7c3eb3f68c8f986add5fa46c3a0" translate="yes" xml:space="preserve">
          <source>The generation expression can only use immutable functions and cannot use subqueries or reference anything other than the current row in any way.</source>
          <target state="translated">Выражение &quot;генерация&quot; может использовать только непреложные функции и ни в коем случае не может использовать подзапросы или ссылаться ни на что,кроме текущей строки.</target>
        </trans-unit>
        <trans-unit id="491279f444aecfec04612928c73be9653a1967ca" translate="yes" xml:space="preserve">
          <source>The generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.</source>
          <target state="translated">Выражение &quot;генерация&quot; может относиться к другим столбцам таблицы,но не к другим генерируемым столбцам.Любые используемые функции и операторы должны быть неизменными.Ссылки на другие таблицы не допускаются.</target>
        </trans-unit>
        <trans-unit id="107e72819959dbe843c78d42ff3ca5cede1b2e0f" translate="yes" xml:space="preserve">
          <source>The generic WAL redo function will acquire exclusive locks to buffers in the same order as they were registered. After redoing all changes, the locks will be released in the same order.</source>
          <target state="translated">Общая функция переделки WAL будет приобретать эксклюзивные замки к буферам в том же порядке,в котором они были зарегистрированы.После переделывания всех изменений,замки будут освобождены в том же порядке.</target>
        </trans-unit>
        <trans-unit id="0ec880a1f4bc52e38225ff4766fdd3a9f49cf436" translate="yes" xml:space="preserve">
          <source>The generic term for all objects in a &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; that have a name and a list of &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; defined in a specific order. &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;Tables&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-SEQUENCE&quot;&gt;sequences&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;views&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign tables&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-MATERIALIZED-VIEW&quot;&gt;materialized views&lt;/a&gt;, composite types, and &lt;a href=&quot;glossary#GLOSSARY-INDEX&quot;&gt;indexes&lt;/a&gt; are all relations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82aaa212b0dcfe65dc390eb2bddcbdc50aeac8ad" translate="yes" xml:space="preserve">
          <source>The genetic algorithm (GA) is a heuristic optimization method which operates through randomized search. The set of possible solutions for the optimization problem is considered as a &lt;em&gt;population&lt;/em&gt; of &lt;em&gt;individuals&lt;/em&gt;. The degree of adaptation of an individual to its environment is specified by its &lt;em&gt;fitness&lt;/em&gt;.</source>
          <target state="translated">Генетический алгоритм (GA) - это эвристический метод оптимизации, который работает через рандомизированный поиск. Множество возможных решений задачи оптимизации рассматриваются как &lt;em&gt;населения&lt;/em&gt; от &lt;em&gt;физических лиц&lt;/em&gt; . Степень адаптации человека к окружающей среде определяется его &lt;em&gt;приспособленностью&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7ee74388f5d56affe1f244671fe03aad5cc5e12c" translate="yes" xml:space="preserve">
          <source>The genetic query optimizer (GEQO) is an algorithm that does query planning using heuristic searching. This reduces planning time for complex queries (those joining many relations), at the cost of producing plans that are sometimes inferior to those found by the normal exhaustive-search algorithm. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;.</source>
          <target state="translated">Оптимизатор генетических запросов (GEQO) - это алгоритм, который выполняет планирование запросов с использованием эвристического поиска. Это сокращает время планирования сложных запросов (которые объединяют множество отношений) за счет создания планов, которые иногда уступают планам, найденным с помощью обычного алгоритма исчерпывающего поиска. Для получения дополнительной информации см. &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Главу 59&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76e81ac1072d86242c4bc156a134a00ceecb9182" translate="yes" xml:space="preserve">
          <source>The genetic query optimizer (GEQO) is an algorithm that does query planning using heuristic searching. This reduces planning time for complex queries (those joining many relations), at the cost of producing plans that are sometimes inferior to those found by the normal exhaustive-search algorithm. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4cf5614687e283544003825f41ef8216ea5370" translate="yes" xml:space="preserve">
          <source>The geometric types &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; have a large set of native support functions and operators, shown in &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-OP-TABLE&quot;&gt;Table 9.34&lt;/a&gt;, &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-FUNC-TABLE&quot;&gt;Table 9.35&lt;/a&gt;, and &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-CONV-TABLE&quot;&gt;Table 9.36&lt;/a&gt;.</source>
          <target state="translated">Геометрические типы &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;lseg&lt;/code&gt; , &lt;code&gt;line&lt;/code&gt; , &lt;code&gt;path&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; и &lt;code&gt;circle&lt;/code&gt; имеют большой набор встроенных вспомогательных функций и операторов, показанных в &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-OP-TABLE&quot;&gt;Таблице 9.34&lt;/a&gt; , &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-FUNC-TABLE&quot;&gt;Таблице 9.35&lt;/a&gt; и &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-CONV-TABLE&quot;&gt;Таблице 9.36&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="347bd2183f41ac71a7c964a957ff88f0b7d2f9db" translate="yes" xml:space="preserve">
          <source>The geometric types &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; have a large set of native support functions and operators, shown in &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-OP-TABLE&quot;&gt;Table 9.35&lt;/a&gt;, &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-FUNC-TABLE&quot;&gt;Table 9.36&lt;/a&gt;, and &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-CONV-TABLE&quot;&gt;Table 9.37&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66e8935cc591dee18b7ed24a47a78f49e5afb1a3" translate="yes" xml:space="preserve">
          <source>The geometry of measurements is usually more complex than that of a point in a numeric continuum. A measurement is usually a segment of that continuum with somewhat fuzzy limits. The measurements come out as intervals because of uncertainty and randomness, as well as because the value being measured may naturally be an interval indicating some condition, such as the temperature range of stability of a protein.</source>
          <target state="translated">Геометрия измерений обычно более сложна,чем геометрия точки в числовом континууме.Измерение обычно представляет собой отрезок этого континуума с несколько нечеткими границами.Измерения выходят в виде интервалов из-за неопределенности и случайности,а также потому,что измеряемое значение,естественно,может быть интервалом,указывающим на некоторое условие,например,диапазон температуры стабильности белка.</target>
        </trans-unit>
        <trans-unit id="443b3b682ab171a2c355d696fdc2acc186cfef4d" translate="yes" xml:space="preserve">
          <source>The given password is hashed using a String2Key (S2K) algorithm. This is rather similar to &lt;code&gt;crypt()&lt;/code&gt; algorithms &amp;mdash; purposefully slow and with random salt &amp;mdash; but it produces a full-length binary key.</source>
          <target state="translated">Данный пароль хешируется с использованием алгоритма String2Key (S2K). Это очень похоже на алгоритмы &lt;code&gt;crypt()&lt;/code&gt; - намеренно медленные и со случайной солью - но он создает полный двоичный ключ.</target>
        </trans-unit>
        <trans-unit id="0e4e030b166d032a885deba1d77181dbb66b8bc9" translate="yes" xml:space="preserve">
          <source>The grouping operations shown in &lt;a href=&quot;functions-aggregate#FUNCTIONS-GROUPING-TABLE&quot;&gt;Table 9.59&lt;/a&gt; are used in conjunction with grouping sets (see &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;Section 7.2.4&lt;/a&gt;) to distinguish result rows. The arguments to the &lt;code&gt;GROUPING&lt;/code&gt; function are not actually evaluated, but they must exactly match expressions given in the &lt;code&gt;GROUP BY&lt;/code&gt; clause of the associated query level. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b9a6b33b61484344b41d8768ea944df1857641" translate="yes" xml:space="preserve">
          <source>The header extension area is envisioned to contain a sequence of self-identifying chunks. The flags field is not intended to tell readers what is in the extension area. Specific design of header extension contents is left for a later release.</source>
          <target state="translated">Область расширения заголовка должна содержать последовательность самоидентифицирующихся кусков.Поле флагов не предназначено для того,чтобы сообщить читателям,что находится в области расширения.Конкретное оформление содержимого расширений заголовков оставляется для последующего выпуска.</target>
        </trans-unit>
        <trans-unit id="6e01e0ce077bd1d9c99c3825e5edad48a491fa26" translate="yes" xml:space="preserve">
          <source>The horizontal header, displayed as the first row, contains the values found in column &lt;code&gt;colH&lt;/code&gt;, with duplicates removed. By default, these appear in the same order as in the query results. But if the optional &lt;code&gt;sortcolH&lt;/code&gt; argument is given, it identifies a column whose values must be integer numbers, and the values from &lt;code&gt;colH&lt;/code&gt; will appear in the horizontal header sorted according to the corresponding &lt;code&gt;sortcolH&lt;/code&gt; values.</source>
          <target state="translated">Горизонтальный заголовок, отображаемый как первая строка, содержит значения, найденные в столбце &lt;code&gt;colH&lt;/code&gt; , с удаленными дубликатами. По умолчанию они появляются в том же порядке, что и в результатах запроса. Но если &lt;code&gt;sortcolH&lt;/code&gt; необязательный аргумент sortcolH , он идентифицирует столбец, значения которого должны быть целыми числами, а значения из &lt;code&gt;colH&lt;/code&gt; появятся в горизонтальном заголовке, отсортированном в соответствии с соответствующими значениями &lt;code&gt;sortcolH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="323272ce1c2fce6128855defbc54368c470d5d34" translate="yes" xml:space="preserve">
          <source>The host name and port number of the primary, connection user name, and password are specified in the &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt;. The password can also be set in the &lt;code&gt;~/.pgpass&lt;/code&gt; file on the standby (specify &lt;code&gt;replication&lt;/code&gt; in the &lt;code&gt;database&lt;/code&gt; field). For example, if the primary is running on host IP &lt;code&gt;192.168.1.50&lt;/code&gt;, port &lt;code&gt;5432&lt;/code&gt;, the account name for replication is &lt;code&gt;foo&lt;/code&gt;, and the password is &lt;code&gt;foopass&lt;/code&gt;, the administrator can add the following line to the &lt;code&gt;postgresql.conf&lt;/code&gt; file on the standby:</source>
          <target state="translated">Имя хоста и номер порта основного, имя пользователя подключения и пароль указываются в &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; . Пароль также можно установить в файле &lt;code&gt;~/.pgpass&lt;/code&gt; на резервном сервере (укажите &lt;code&gt;replication&lt;/code&gt; в поле &lt;code&gt;database&lt;/code&gt; ). Например, если основной запущен на IP- &lt;code&gt;192.168.1.50&lt;/code&gt; хоста 192.168.1.50 , порт &lt;code&gt;5432&lt;/code&gt; , имя учетной записи для репликации - &lt;code&gt;foo&lt;/code&gt; , а пароль - &lt;code&gt;foopass&lt;/code&gt; , администратор может добавить следующую строку в файл &lt;code&gt;postgresql.conf&lt;/code&gt; на резервном сервере :</target>
        </trans-unit>
        <trans-unit id="41cfca1d0872f04d37ad8cb9cbf3834cb90f01db" translate="yes" xml:space="preserve">
          <source>The host name of the database server, truncated at the first dot, or &lt;code&gt;[local]&lt;/code&gt; if the connection is over a Unix domain socket.</source>
          <target state="translated">Имя хоста сервера базы данных, усеченное до первой точки, или &lt;code&gt;[local]&lt;/code&gt; , если соединение осуществляется через сокет домена Unix.</target>
        </trans-unit>
        <trans-unit id="0b7649f0038242a26a0c621f7315d0b3f51c7304" translate="yes" xml:space="preserve">
          <source>The hour component of the time zone offset</source>
          <target state="translated">Часовая составляющая смещения часового пояса</target>
        </trans-unit>
        <trans-unit id="6ced8e552c81e4a5ec5eb0ba5039b71c87a5c484" translate="yes" xml:space="preserve">
          <source>The hour field (0 - 23)</source>
          <target state="translated">Часовое поле (0-23)</target>
        </trans-unit>
        <trans-unit id="c96645608711f945ba53324fe90b2674f60c24de" translate="yes" xml:space="preserve">
          <source>The hour field (0&amp;ndash;23)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="842cd42d6043fc7261db6ee13e01b6e92f6c88ea" translate="yes" xml:space="preserve">
          <source>The i7-860 system measured runs the count query in 9.8 ms while the &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; version takes 16.6 ms, each processing just over 100,000 rows. That 6.8 ms difference means the timing overhead per row is 68 ns, about twice what pg_test_timing estimated it would be. Even that relatively small amount of overhead is making the fully timed count statement take almost 70% longer. On more substantial queries, the timing overhead would be less problematic.</source>
          <target state="translated">Измеренная система i7-860 выполняет запрос счета за 9,8 мс, в то время как версия &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; занимает 16,6 мс, каждая из которых обрабатывает чуть более 100 000 строк. Эта разница в 6,8 мс означает, что накладные расходы по синхронизации для каждой строки составляют 68 нс, что примерно вдвое превышает оценку pg_test_timing. Даже из-за этого относительно небольшого количества накладных расходов выполнение полностью синхронизированного подсчета занимает почти 70% больше времени. При более существенных запросах временные издержки будут менее проблематичными.</target>
        </trans-unit>
        <trans-unit id="fbf85920bba7cb75c10687cf6cd36aab7a7c9b2a" translate="yes" xml:space="preserve">
          <source>The idea behind this dump method is to generate a file with SQL commands that, when fed back to the server, will recreate the database in the same state as it was at the time of the dump. PostgreSQL provides the utility program &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; for this purpose. The basic usage of this command is:</source>
          <target state="translated">Идея этого метода дампа состоит в том, чтобы сгенерировать файл с командами SQL, которые при отправке обратно на сервер воссоздают базу данных в том же состоянии, что и во время дампа. PostgreSQL предоставляет для этой цели служебную программу &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; . Основное использование этой команды:</target>
        </trans-unit>
        <trans-unit id="6cf4bd1d2fa41d408b71387e9f46d7734f70e2c4" translate="yes" xml:space="preserve">
          <source>The ident authentication method works by obtaining the client's operating system user name from an ident server and using it as the allowed database user name (with an optional user name mapping). This is only supported on TCP/IP connections.</source>
          <target state="translated">Метод аутентификации по иденту работает путем получения пользовательского имени операционной системы клиента с сервера-идентификатора и использования его в качестве разрешенного имени пользователя базы данных (с опциональным сопоставлением имен пользователей).Это поддерживается только при TCP/IP соединениях.</target>
        </trans-unit>
        <trans-unit id="75cef3c7a191b437000bac7046319a3652002a6f" translate="yes" xml:space="preserve">
          <source>The identifier of the prepared statement</source>
          <target state="translated">Идентификатор подготовленного заявления</target>
        </trans-unit>
        <trans-unit id="5814fec88046aa889ddca71e977eccd80834a133" translate="yes" xml:space="preserve">
          <source>The identity (transaction ID) of the deleting transaction, or zero for an undeleted row version. It is possible for this column to be nonzero in a visible row version. That usually indicates that the deleting transaction hasn't committed yet, or that an attempted deletion was rolled back.</source>
          <target state="translated">Идентификатор (ID транзакции)удаляющей транзакции,или ноль для версии с неудаленной строкой.В видимой версии строки этот столбец может быть ненулевым.Это обычно указывает на то,что транзакция удаления еще не зафиксирована,или на то,что попытка удаления была откатирована.</target>
        </trans-unit>
        <trans-unit id="7c52aeea0184eb0092fc19e054b01bbe20a261fc" translate="yes" xml:space="preserve">
          <source>The identity (transaction ID) of the inserting transaction for this row version. (A row version is an individual state of a row; each update of a row creates a new row version for the same logical row.)</source>
          <target state="translated">Идентификатор (ID транзакции)вставляемой транзакции для данной версии строки.(Версия строки-это индивидуальное состояние строки;каждое обновление строки создает новую версию строки для той же самой логической строки).</target>
        </trans-unit>
        <trans-unit id="61965181bc017854598b0845bd8393cd487f7cfb" translate="yes" xml:space="preserve">
          <source>The implementation does not resist &lt;a href=&quot;https://en.wikipedia.org/wiki/Side-channel_attack&quot;&gt;side-channel attacks&lt;/a&gt;. For example, the time required for a &lt;code&gt;pgcrypto&lt;/code&gt; decryption function to complete varies among ciphertexts of a given size.</source>
          <target state="translated">Реализация не противостоит &lt;a href=&quot;https://en.wikipedia.org/wiki/Side-channel_attack&quot;&gt;атакам по побочным каналам&lt;/a&gt; . Например, время, необходимое для выполнения &lt;code&gt;pgcrypto&lt;/code&gt; дешифрования pgcrypto, варьируется в зависимости от зашифрованного текста заданного размера.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
