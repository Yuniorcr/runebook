<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="1daf3db24fd8109b791952bf2bea84cc95a73e77" translate="yes" xml:space="preserve">
          <source>Two parameterized GiST index operator classes are provided: &lt;code&gt;gist__int_ops&lt;/code&gt; (used by default) is suitable for small- to medium-size data sets, while &lt;code&gt;gist__intbig_ops&lt;/code&gt; uses a larger signature and is more suitable for indexing large data sets (i.e., columns containing a large number of distinct array values). The implementation uses an RD-tree data structure with built-in lossy compression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="662248ac968d8ab661b9569a6e6849ae788e24f8" translate="yes" xml:space="preserve">
          <source>Two significant incompatibilities exist between AREs and the ERE syntax recognized by pre-7.4 releases of PostgreSQL:</source>
          <target state="translated">Существует две существенные несовместимости между ARE и синтаксисом ERE,признанным в предыдущих версиях PostgreSQL до 7.4:</target>
        </trans-unit>
        <trans-unit id="6a32f2ed2800b3a048eac6f3c98ed4d6f0004a87" translate="yes" xml:space="preserve">
          <source>Two string constants that are only separated by whitespace &lt;em&gt;with at least one newline&lt;/em&gt; are concatenated and effectively treated as if the string had been written as one constant. For example:</source>
          <target state="translated">Две строковые константы, разделенные только пробелом &lt;em&gt;с хотя бы одной новой&lt;/em&gt; строкой, объединяются и эффективно обрабатываются так, как если бы строка была записана как одна константа. Например:</target>
        </trans-unit>
        <trans-unit id="90b63e2a4e205cf20d0c53869ecd885349050bdf" translate="yes" xml:space="preserve">
          <source>Two tablespaces are automatically created when the database cluster is initialized. The &lt;code&gt;pg_global&lt;/code&gt; tablespace is used for shared system catalogs. The &lt;code&gt;pg_default&lt;/code&gt; tablespace is the default tablespace of the &lt;code&gt;template1&lt;/code&gt; and &lt;code&gt;template0&lt;/code&gt; databases (and, therefore, will be the default tablespace for other databases as well, unless overridden by a &lt;code&gt;TABLESPACE&lt;/code&gt; clause in &lt;code&gt;CREATE DATABASE&lt;/code&gt;).</source>
          <target state="translated">При инициализации кластера базы данных автоматически создаются два табличных пространства. &lt;code&gt;pg_global&lt;/code&gt; табличный используются для общих системных каталогов. &lt;code&gt;pg_default&lt;/code&gt; табличного пространства табличное пространство по умолчанию &lt;code&gt;template1&lt;/code&gt; и &lt;code&gt;template0&lt;/code&gt; баз данных (и, следовательно, будет табличное пространство по умолчанию для других баз данных , а также, если они не были перезаписаны &lt;code&gt;TABLESPACE&lt;/code&gt; пунктом в инструкции &lt;code&gt;CREATE DATABASE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c5b854b5685b242cd142ae86c5c04afbc5fc30b6" translate="yes" xml:space="preserve">
          <source>Two types can be &lt;em&gt;binary coercible&lt;/em&gt;, which means that the conversion can be performed &amp;ldquo;for free&amp;rdquo; without invoking any function. This requires that corresponding values use the same internal representation. For instance, the types &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;varchar&lt;/code&gt; are binary coercible both ways. Binary coercibility is not necessarily a symmetric relationship. For example, the cast from &lt;code&gt;xml&lt;/code&gt; to &lt;code&gt;text&lt;/code&gt; can be performed for free in the present implementation, but the reverse direction requires a function that performs at least a syntax check. (Two types that are binary coercible both ways are also referred to as binary compatible.)</source>
          <target state="translated">Два типа могут быть &lt;em&gt;двоично-принудительными&lt;/em&gt; , что означает, что преобразование может выполняться &amp;laquo;бесплатно&amp;raquo; без вызова какой-либо функции. Это требует, чтобы соответствующие значения использовали одно и то же внутреннее представление. Например, типы &lt;code&gt;text&lt;/code&gt; и &lt;code&gt;varchar&lt;/code&gt; могут приводиться двоично в обоих направлениях. Бинарная принуждение не обязательно является симметричным отношением. Например, &lt;code&gt;text&lt;/code&gt; из &lt;code&gt;xml&lt;/code&gt; в текст может выполняться бесплатно в настоящей реализации, но в обратном направлении требуется функция, которая выполняет как минимум проверку синтаксиса. (Два типа, которые являются двоичными, приводимыми в обе стороны, также называются двоично-совместимыми.)</target>
        </trans-unit>
        <trans-unit id="51632bd25b09e4b06271cc8939c29fce73a7a60c" translate="yes" xml:space="preserve">
          <source>Two useful flags exist in &lt;code&gt;pg_database&lt;/code&gt; for each database: the columns &lt;code&gt;datistemplate&lt;/code&gt; and &lt;code&gt;datallowconn&lt;/code&gt;. &lt;code&gt;datistemplate&lt;/code&gt; can be set to indicate that a database is intended as a template for &lt;code&gt;CREATE DATABASE&lt;/code&gt;. If this flag is set, the database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if it is not set, only superusers and the owner of the database can clone it. If &lt;code&gt;datallowconn&lt;/code&gt; is false, then no new connections to that database will be allowed (but existing sessions are not terminated simply by setting the flag false). The &lt;code&gt;template0&lt;/code&gt; database is normally marked &lt;code&gt;datallowconn = false&lt;/code&gt; to prevent its modification. Both &lt;code&gt;template0&lt;/code&gt; and &lt;code&gt;template1&lt;/code&gt; should always be marked with &lt;code&gt;datistemplate = true&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;pg_database&lt;/code&gt; есть два полезных флага для каждой базы данных: &lt;code&gt;datistemplate&lt;/code&gt; столбцов и &lt;code&gt;datallowconn&lt;/code&gt; . &lt;code&gt;datistemplate&lt;/code&gt; может быть установлен, чтобы указать, что база данных предназначена в качестве шаблона для &lt;code&gt;CREATE DATABASE&lt;/code&gt; . Если этот флаг установлен, база данных может быть клонирована любым пользователем с привилегиями &lt;code&gt;CREATEDB&lt;/code&gt; ; если он не установлен, клонировать его могут только суперпользователи и владелец базы данных. Если &lt;code&gt;datallowconn&lt;/code&gt; имеет значение false, то новые подключения к этой базе данных не будут разрешены (но существующие сеансы не будут завершены просто установкой флага false). База данных &lt;code&gt;template0&lt;/code&gt; обычно помечается как &lt;code&gt;datallowconn = false&lt;/code&gt; чтобы предотвратить его изменение. И &lt;code&gt;template0&lt;/code&gt; , и &lt;code&gt;template1&lt;/code&gt; всегда должны быть помечены как &lt;code&gt;datistemplate = true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ba8214ba00d79461864d0001c2912a5c18b7b9a" translate="yes" xml:space="preserve">
          <source>Two-phase commit commands - &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, &lt;code&gt;COMMIT PREPARED&lt;/code&gt;, &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; because even read-only transactions need to write WAL in the prepare phase (the first phase of two phase commit).</source>
          <target state="translated">Команды двухфазной фиксации - &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; , &lt;code&gt;COMMIT PREPARED&lt;/code&gt; , &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; , потому что даже транзакции только для чтения должны записывать WAL на этапе подготовки (первая фаза двухфазной фиксации).</target>
        </trans-unit>
        <trans-unit id="2e2bfc913787b0e6ea8551f81e2791cd42f7a318" translate="yes" xml:space="preserve">
          <source>Two-phase commit commands: &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, &lt;code&gt;COMMIT PREPARED&lt;/code&gt;, &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; because even read-only transactions need to write WAL in the prepare phase (the first phase of two phase commit).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="caa2352205156323130852be37f36d8839e386c6" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;ltree&lt;/code&gt; has the usual comparison operators &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;. Comparison sorts in the order of a tree traversal, with the children of a node sorted by label text. In addition, the specialized operators shown in &lt;a href=&quot;ltree#LTREE-OP-TABLE&quot;&gt;Table F.13&lt;/a&gt; are available.</source>
          <target state="translated">Тип &lt;code&gt;ltree&lt;/code&gt; имеет обычные операторы сравнения &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; . Сравнение сортируется в порядке обхода дерева, при этом дочерние элементы узла сортируются по тексту метки. Кроме того, доступны специализированные операторы, показанные в &lt;a href=&quot;ltree#LTREE-OP-TABLE&quot;&gt;таблице F.13&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e1573953474c6c0a25673b1f064154b46a8a93e" translate="yes" xml:space="preserve">
          <source>Type Conversion</source>
          <target state="translated">Преобразование типа</target>
        </trans-unit>
        <trans-unit id="0f621c80a40b4c3bb2242b9a8d5ab32c97b28181" translate="yes" xml:space="preserve">
          <source>Type modifier input function, or 0 if type does not support modifiers</source>
          <target state="translated">Функция ввода модификатора типа,или 0,если тип не поддерживает модификаторы</target>
        </trans-unit>
        <trans-unit id="49427798b611e70520545325588242b32904d7b8" translate="yes" xml:space="preserve">
          <source>Type modifier output function, or 0 to use the standard format</source>
          <target state="translated">Выходная функция модификатора типа,или 0 для использования стандартного формата</target>
        </trans-unit>
        <trans-unit id="13f4f7c42905c25fa5436f830df968dd5cfd652c" translate="yes" xml:space="preserve">
          <source>Type of connection</source>
          <target state="translated">Тип соединения</target>
        </trans-unit>
        <trans-unit id="4a864d40476979903a17a15ee7653201ddd8043f" translate="yes" xml:space="preserve">
          <source>Type of current backend. Possible types are &lt;code&gt;autovacuum launcher&lt;/code&gt;, &lt;code&gt;autovacuum worker&lt;/code&gt;, &lt;code&gt;logical replication launcher&lt;/code&gt;, &lt;code&gt;logical replication worker&lt;/code&gt;, &lt;code&gt;parallel worker&lt;/code&gt;, &lt;code&gt;background writer&lt;/code&gt;, &lt;code&gt;client backend&lt;/code&gt;, &lt;code&gt;checkpointer&lt;/code&gt;, &lt;code&gt;startup&lt;/code&gt;, &lt;code&gt;walreceiver&lt;/code&gt;, &lt;code&gt;walsender&lt;/code&gt; and &lt;code&gt;walwriter&lt;/code&gt;. In addition, background workers registered by extensions may have additional types.</source>
          <target state="translated">Тип текущего бэкенда. Возможные типы &lt;code&gt;autovacuum launcher&lt;/code&gt; , &lt;code&gt;autovacuum worker&lt;/code&gt; , &lt;code&gt;logical replication launcher&lt;/code&gt; , &lt;code&gt;logical replication worker&lt;/code&gt; , &lt;code&gt;parallel worker&lt;/code&gt; , &lt;code&gt;background writer&lt;/code&gt; , &lt;code&gt;client backend&lt;/code&gt; , &lt;code&gt;checkpointer&lt;/code&gt; , &lt;code&gt;startup&lt;/code&gt; , &lt;code&gt;walreceiver&lt;/code&gt; , &lt;code&gt;walsender&lt;/code&gt; и &lt;code&gt;walwriter&lt;/code&gt; . Кроме того, фоновые рабочие, зарегистрированные расширениями, могут иметь дополнительные типы.</target>
        </trans-unit>
        <trans-unit id="c82ff0d03f044b1bc03e6d585b2bc9ad0f83dd9c" translate="yes" xml:space="preserve">
          <source>Type of data stored in index, or zero if same as &lt;code&gt;opcintype&lt;/code&gt;</source>
          <target state="translated">Тип данных, хранящихся в индексе, или ноль, если такой же, как &lt;code&gt;opcintype&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4055eb85cfd66c39ef30f33fb4b4a5d50d592112" translate="yes" xml:space="preserve">
          <source>Type of object this entry is for: &lt;code&gt;r&lt;/code&gt; = relation (table, view), &lt;code&gt;S&lt;/code&gt; = sequence, &lt;code&gt;f&lt;/code&gt; = function, &lt;code&gt;T&lt;/code&gt; = type, &lt;code&gt;n&lt;/code&gt; = schema</source>
          <target state="translated">Тип объекта, для которого предназначена эта запись: &lt;code&gt;r&lt;/code&gt; = отношение (таблица, представление), &lt;code&gt;S&lt;/code&gt; = последовательность, &lt;code&gt;f&lt;/code&gt; = функция, &lt;code&gt;T&lt;/code&gt; = тип, &lt;code&gt;n&lt;/code&gt; = схема</target>
        </trans-unit>
        <trans-unit id="3399c96b222ffc038be1234147fc38489a358880" translate="yes" xml:space="preserve">
          <source>Type of the JSON item (see &lt;code&gt;json_typeof&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f5ec2f1c5458817693d6d76b369073909c045e" translate="yes" xml:space="preserve">
          <source>Type of the SQL/JSON item</source>
          <target state="translated">Тип элемента SQL/JSON</target>
        </trans-unit>
        <trans-unit id="00a9fa45d41b5ea65aa7f18aa2626b820f2f9cef" translate="yes" xml:space="preserve">
          <source>Type of the left operand</source>
          <target state="translated">Тип левого оперного театра</target>
        </trans-unit>
        <trans-unit id="21ac751dedd0b562597b93f21b2acf37d95f8772" translate="yes" xml:space="preserve">
          <source>Type of the lockable object: &lt;code&gt;relation&lt;/code&gt;, &lt;code&gt;extend&lt;/code&gt;, &lt;code&gt;frozenid&lt;/code&gt;, &lt;code&gt;page&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, &lt;code&gt;transactionid&lt;/code&gt;, &lt;code&gt;virtualxid&lt;/code&gt;, &lt;code&gt;spectoken&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;userlock&lt;/code&gt;, or &lt;code&gt;advisory&lt;/code&gt;. (See also &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LOCK-TABLE&quot;&gt;Table 27.11&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767fb9969a4cc64a16553ca389e0f0b5a4e5c458" translate="yes" xml:space="preserve">
          <source>Type of the lockable object: &lt;code&gt;relation&lt;/code&gt;, &lt;code&gt;extend&lt;/code&gt;, &lt;code&gt;page&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, &lt;code&gt;transactionid&lt;/code&gt;, &lt;code&gt;virtualxid&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;userlock&lt;/code&gt;, or &lt;code&gt;advisory&lt;/code&gt;</source>
          <target state="translated">Тип блокируемого объекта: &lt;code&gt;relation&lt;/code&gt; , &lt;code&gt;extend&lt;/code&gt; , &lt;code&gt;page&lt;/code&gt; , &lt;code&gt;tuple&lt;/code&gt; , &lt;code&gt;transactionid&lt;/code&gt; , &lt;code&gt;virtualxid&lt;/code&gt; , &lt;code&gt;object&lt;/code&gt; , &lt;code&gt;userlock&lt;/code&gt; или &lt;code&gt;advisory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="727af93962dbd00f156d10d2619e6fe4d2766070" translate="yes" xml:space="preserve">
          <source>Type of the result</source>
          <target state="translated">Тип результата</target>
        </trans-unit>
        <trans-unit id="4b171dbb72682b90735ae1019128b1fa8fc68223" translate="yes" xml:space="preserve">
          <source>Type of the right operand</source>
          <target state="translated">Тип правильного операнда</target>
        </trans-unit>
        <trans-unit id="886a7edda3ba752fafb210f2d1fc042903763b8a" translate="yes" xml:space="preserve">
          <source>Type of the server (optional)</source>
          <target state="translated">Тип сервера (необязательно)</target>
        </trans-unit>
        <trans-unit id="b84c44ea065844d42eb4ff46ceca0a63ebb5fb0f" translate="yes" xml:space="preserve">
          <source>Typed Tables</source>
          <target state="translated">Типовые таблицы</target>
        </trans-unit>
        <trans-unit id="0e36cf7838eed64c7c287419b5db638ff701a9f7" translate="yes" xml:space="preserve">
          <source>Typed tables implement a subset of the SQL standard. According to the standard, a typed table has columns corresponding to the underlying composite type as well as one other column that is the &amp;ldquo;self-referencing column&amp;rdquo;. PostgreSQL does not support self-referencing columns explicitly.</source>
          <target state="translated">Типизированные таблицы реализуют подмножество стандарта SQL. В соответствии со стандартом типизированная таблица имеет столбцы, соответствующие базовому составному типу, а также еще один столбец, который является &amp;laquo;самореферентным столбцом&amp;raquo;. PostgreSQL не поддерживает явным образом ссылающиеся на себя столбцы.</target>
        </trans-unit>
        <trans-unit id="5754e4191a491637e871b6ade422b1bcee16cbbf" translate="yes" xml:space="preserve">
          <source>Types of extended statistics enabled for this record</source>
          <target state="translated">Типы расширенной статистики,включенные для этой записи</target>
        </trans-unit>
        <trans-unit id="30b55d03eac01f6040e3abe9feb9e154100f2081" translate="yes" xml:space="preserve">
          <source>Typical examples of an IPv4 address range specified this way are &lt;code&gt;172.20.143.89/32&lt;/code&gt; for a single host, or &lt;code&gt;172.20.143.0/24&lt;/code&gt; for a small network, or &lt;code&gt;10.6.0.0/16&lt;/code&gt; for a larger one. An IPv6 address range might look like &lt;code&gt;::1/128&lt;/code&gt; for a single host (in this case the IPv6 loopback address) or &lt;code&gt;fe80::7a31:c1ff:0000:0000/96&lt;/code&gt; for a small network. &lt;code&gt;0.0.0.0/0&lt;/code&gt; represents all IPv4 addresses, and &lt;code&gt;::0/0&lt;/code&gt; represents all IPv6 addresses. To specify a single host, use a mask length of 32 for IPv4 or 128 for IPv6. In a network address, do not omit trailing zeroes.</source>
          <target state="translated">Типичными примерами диапазона адресов IPv4, указанного таким образом, являются &lt;code&gt;172.20.143.89/32&lt;/code&gt; для одиночного хоста, &lt;code&gt;172.20.143.0/24&lt;/code&gt; для небольшой сети или &lt;code&gt;10.6.0.0/16&lt;/code&gt; для более крупной сети. Диапазон адресов IPv6 может выглядеть следующим образом &lt;code&gt;::1/128&lt;/code&gt; для одного хоста (в данном случае адрес обратной связи IPv6) или &lt;code&gt;fe80::7a31:c1ff:0000:0000/96&lt;/code&gt; для небольшой сети. &lt;code&gt;0.0.0.0/0&lt;/code&gt; представляет все адреса IPv4, а &lt;code&gt;::0/0&lt;/code&gt; представляет все адреса IPv6. Чтобы указать один хост, используйте длину маски 32 для IPv4 или 128 для IPv6. В сетевом адресе не пропускайте нули в конце.</target>
        </trans-unit>
        <trans-unit id="3ba7280f9a6416aff842d582d030dc0d547a8079" translate="yes" xml:space="preserve">
          <source>Typical examples would be:</source>
          <target state="translated">Типичные примеры были бы:</target>
        </trans-unit>
        <trans-unit id="c3ae6c139f98be74a60c4eaf214c1269190843b0" translate="yes" xml:space="preserve">
          <source>Typical output from pgbench looks like:</source>
          <target state="translated">Типичный выход из pgbench выглядит так:</target>
        </trans-unit>
        <trans-unit id="4f215729680a38802cfd4b9559a7e299252d552b" translate="yes" xml:space="preserve">
          <source>Typical output from this plugin, used over the SQL logical decoding interface, might be:</source>
          <target state="translated">Типичным выходом из этого плагина,используемым через интерфейс логического декодирования SQL,может быть:</target>
        </trans-unit>
        <trans-unit id="5d9380cc46b3004a735b71b1ddc5769ac9cc9d80" translate="yes" xml:space="preserve">
          <source>Typically a role being used as a group would not have the &lt;code&gt;LOGIN&lt;/code&gt; attribute, though you can set it if you wish.</source>
          <target state="translated">Обычно роль, используемая как группа, не имеет атрибута &lt;code&gt;LOGIN&lt;/code&gt; , хотя вы можете установить его, если хотите.</target>
        </trans-unit>
        <trans-unit id="0c79e0bb5747a47177b68165db0b8e29d1e90432" translate="yes" xml:space="preserve">
          <source>Typically an &lt;code&gt;UPDATE&lt;/code&gt; command also needs to read data from columns in the relation being updated (e.g., in a &lt;code&gt;WHERE&lt;/code&gt; clause or a &lt;code&gt;RETURNING&lt;/code&gt; clause, or in an expression on the right hand side of the &lt;code&gt;SET&lt;/code&gt; clause). In this case, &lt;code&gt;SELECT&lt;/code&gt; rights are also required on the relation being updated, and the appropriate &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policies will be applied in addition to the &lt;code&gt;UPDATE&lt;/code&gt; policies. Thus the user must have access to the row(s) being updated through a &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy in addition to being granted permission to update the row(s) via an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy.</source>
          <target state="translated">Обычно команде &lt;code&gt;UPDATE&lt;/code&gt; также необходимо читать данные из столбцов в обновляемом отношении (например, в предложении &lt;code&gt;WHERE&lt;/code&gt; или предложении &lt;code&gt;RETURNING&lt;/code&gt; , или в выражении в правой части предложения &lt;code&gt;SET&lt;/code&gt; ). В этом случае также требуются права &lt;code&gt;SELECT&lt;/code&gt; для обновляемого отношения, и в дополнение к политикам &lt;code&gt;UPDATE&lt;/code&gt; будут применяться соответствующие политики &lt;code&gt;SELECT&lt;/code&gt; или &lt;code&gt;ALL&lt;/code&gt; . Таким образом, пользователь должен иметь доступ к строкам, которые обновляются с помощью политики &lt;code&gt;SELECT&lt;/code&gt; или &lt;code&gt;ALL&lt;/code&gt; , в дополнение к предоставлению разрешения на обновление строки (строк) с помощью &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;ALL&lt;/code&gt; политика.</target>
        </trans-unit>
        <trans-unit id="4a5dff53d37ef582f6443160c6077ab3c024f6ad" translate="yes" xml:space="preserve">
          <source>Typically libraries like libpq only add new functionality, again unless mentioned in the release notes.</source>
          <target state="translated">Обычно такие библиотеки,как libpq,только добавляют новую функциональность,опять же,если это не упомянуто в замечаниях по выпуску.</target>
        </trans-unit>
        <trans-unit id="74be98305cce33f0717978700ff85879bd035ba2" translate="yes" xml:space="preserve">
          <source>Typically that would be written in an extension's creation script, and users would do this to install the extension:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d506067679b9e62e7a37578f7129dcc3d999cc58" translate="yes" xml:space="preserve">
          <source>Typically this includes new SQL command capabilities and not changes in behavior, unless specifically mentioned in the release notes.</source>
          <target state="translated">Обычно это включает в себя новые возможности SQL-команд,а не изменения в поведении,если только это специально не упомянуто в примечаниях к выпуску.</target>
        </trans-unit>
        <trans-unit id="3822092fc5f3e669e643e30f8ce5e23c88a10d9c" translate="yes" xml:space="preserve">
          <source>Typically weights are used to mark words from special areas of the document, like the title or an initial abstract, so they can be treated with more or less importance than words in the document body.</source>
          <target state="translated">Обычно для обозначения слов из специальных областей документа,таких как заголовок или исходный реферат,используются весовые коэффициенты,поэтому к ним можно относиться с большей или меньшей важностью,чем к словам в теле документа.</target>
        </trans-unit>
        <trans-unit id="75ec6d184c198c058b18b104c2264bc1718aff70" translate="yes" xml:space="preserve">
          <source>UNION, CASE, and Related Constructs</source>
          <target state="translated">ЮНИОН,Кейс и связанные с ними конструкции</target>
        </trans-unit>
        <trans-unit id="e85ec09bfd030dc1a5734a458795c226244fc313" translate="yes" xml:space="preserve">
          <source>UNLISTEN</source>
          <target state="translated">UNLISTEN</target>
        </trans-unit>
        <trans-unit id="4e75e16efe1381bdf958afc52921070dcac9674c" translate="yes" xml:space="preserve">
          <source>UNLISTEN &amp;mdash; stop listening for a notification</source>
          <target state="translated">UNLISTEN - прекратить прослушивание уведомлений</target>
        </trans-unit>
        <trans-unit id="e42fbf3248836a2bda1822a0f26f66440fa0c899" translate="yes" xml:space="preserve">
          <source>UPC &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">UPC &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="8ea457eae40d594e81201972c4abd897fed37408" translate="yes" xml:space="preserve">
          <source>UPC numbers are a subset of the EAN13 numbers (they are basically EAN13 without the first &lt;code&gt;0&lt;/code&gt; digit).</source>
          <target state="translated">Номера UPC - это подмножество номеров EAN13 (в основном это EAN13 без первой цифры &lt;code&gt;0&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="391f048e928d94ac0bc9a0124d925ff0ab247d37" translate="yes" xml:space="preserve">
          <source>UPDATE &amp;mdash; update rows of a table</source>
          <target state="translated">ОБНОВЛЕНИЕ - обновить строки таблицы</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="5bc5065b4243467de49ffd6feb4dc052247ba467" translate="yes" xml:space="preserve">
          <source>URL locations can be canonicalized to make equivalent URLs match:</source>
          <target state="translated">URL-адреса могут быть канонизированы,чтобы эквивалентные URL-адреса совпадали:</target>
        </trans-unit>
        <trans-unit id="5e1156d91b64895766702da1dac1a03bdacc18d8" translate="yes" xml:space="preserve">
          <source>URL path</source>
          <target state="translated">путь URL-адреса</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="618f65101275eae124d9a7c9c7a5431c588e88d8" translate="yes" xml:space="preserve">
          <source>UTF</source>
          <target state="translated">UTF</target>
        </trans-unit>
        <trans-unit id="006a48ffb6b1c6d449c6f984e56102797a110071" translate="yes" xml:space="preserve">
          <source>UTF-8 (8-bit UCS/Unicode Transformation Format) is defined here.</source>
          <target state="translated">Здесь определяется UTF-8 (8-битный UCS/Unicode Transformation Format).</target>
        </trans-unit>
        <trans-unit id="7fa9ad7f9065e92883a9407e908d043b05c218a2" translate="yes" xml:space="preserve">
          <source>UTF8</source>
          <target state="translated">UTF8</target>
        </trans-unit>
        <trans-unit id="21bf75a5255af008f6315cb6aca4bb3bdccee521" translate="yes" xml:space="preserve">
          <source>UUID</source>
          <target state="translated">UUID</target>
        </trans-unit>
        <trans-unit id="cd5f8485e99e1466105fe2ccda1a6e32ac64f458" translate="yes" xml:space="preserve">
          <source>UUID Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b3aa0aafa91ea5c6d6154167ed0f9530a1ec26c" translate="yes" xml:space="preserve">
          <source>UUID Type</source>
          <target state="translated">тип UUID</target>
        </trans-unit>
        <trans-unit id="0a7e35cb9fd13ab0f8bc30cc95fe3965c0075fa2" translate="yes" xml:space="preserve">
          <source>Unary plus (no operation)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93712543c02319baab11b2b81799e7e791b6f5f" translate="yes" xml:space="preserve">
          <source>Unary plus (no operation); unlike addition, this can iterate over multiple values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbfa247ab63ebe054b1f625efaac8d7d2ed2786f" translate="yes" xml:space="preserve">
          <source>Unconditionally trace locks on this table (OID).</source>
          <target state="translated">Безоговорочно отследить замки на этом столе (OID).</target>
        </trans-unit>
        <trans-unit id="1a26494bd46f598c2d3b286cc32f8f8da4c3c529" translate="yes" xml:space="preserve">
          <source>Undo that, restoring whatever setting was effective in &lt;code&gt;postgresql.conf&lt;/code&gt;:</source>
          <target state="translated">Отмените это, восстановив те настройки, которые были эффективны в &lt;code&gt;postgresql.conf&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d82f20269a7ba351c65d96d467573f44ed2241db" translate="yes" xml:space="preserve">
          <source>Undo the above, so that subsequently-created tables won't have any more permissions than normal:</source>
          <target state="translated">Отмените вышеизложенное,чтобы впоследствии созданные таблицы не имели больше разрешений,чем обычно:</target>
        </trans-unit>
        <trans-unit id="69537adb0c6a954242641822e574baa70cf65b67" translate="yes" xml:space="preserve">
          <source>Unexpected results might be obtained if a &lt;code&gt;cache&lt;/code&gt; setting greater than one is used for a sequence object that will be used concurrently by multiple sessions. Each session will allocate and cache successive sequence values during one access to the sequence object and increase the sequence object's &lt;code&gt;last_value&lt;/code&gt; accordingly. Then, the next &lt;code&gt;cache&lt;/code&gt;-1 uses of &lt;code&gt;nextval&lt;/code&gt; within that session simply return the preallocated values without touching the sequence object. So, any numbers allocated but not used within a session will be lost when that session ends, resulting in &amp;ldquo;holes&amp;rdquo; in the sequence.</source>
          <target state="translated">Неожиданные результаты могут быть получены, если параметр &lt;code&gt;cache&lt;/code&gt; больше единицы используется для объекта последовательности, который будет использоваться одновременно несколькими сеансами. Каждый сеанс будет выделять и кэшировать последовательные значения последовательности во время одного доступа к объекту последовательности и соответственно увеличивать &lt;code&gt;last_value&lt;/code&gt; объекта последовательности . Затем следующее использование &lt;code&gt;cache&lt;/code&gt; -1 &lt;code&gt;nextval&lt;/code&gt; в этом сеансе просто возвращает предварительно выделенные значения, не касаясь объекта последовательности. Таким образом, любые номера, выделенные, но не используемые в сеансе, будут потеряны по окончании сеанса, что приведет к появлению &amp;laquo;дыр&amp;raquo; в последовательности.</target>
        </trans-unit>
        <trans-unit id="bac601add3bc88ae7a8e23e81f98747db513fcef" translate="yes" xml:space="preserve">
          <source>Unfortunately, there is no well-defined method for determining ideal values for the cost variables. They are best treated as averages over the entire mix of queries that a particular installation will receive. This means that changing them on the basis of just a few experiments is very risky.</source>
          <target state="translated">К сожалению,не существует четко определенного метода определения идеальных значений для стоимостных переменных.Лучше всего рассматривать их как средние по всему набору запросов,которые получит конкретная установка.Это означает,что их изменение на основе всего лишь нескольких экспериментов очень рискованно.</target>
        </trans-unit>
        <trans-unit id="5477f70b1eea785630b35cd84e386522cded5715" translate="yes" xml:space="preserve">
          <source>Unicode Transformation Format</source>
          <target state="translated">Формат преобразования Юникода</target>
        </trans-unit>
        <trans-unit id="8de2de87fc64e84d8c1aa641cad76e717bc7b29c" translate="yes" xml:space="preserve">
          <source>Unicode, 8-bit</source>
          <target state="translated">Юникод,8 бит</target>
        </trans-unit>
        <trans-unit id="93a858d6fa1dc81e7eaad3250789d05cb036b8fa" translate="yes" xml:space="preserve">
          <source>Unified Hangul Code</source>
          <target state="translated">Единый хангыльский кодекс</target>
        </trans-unit>
        <trans-unit id="67ef7a3b2dde1ee8d6d2f80347f89266789839b9" translate="yes" xml:space="preserve">
          <source>Uniform Resource Locator</source>
          <target state="translated">Единый локатор ресурсов</target>
        </trans-unit>
        <trans-unit id="86a932dd65a48b174d2aada36f1bfffd412deac8" translate="yes" xml:space="preserve">
          <source>Unique Indexes</source>
          <target state="translated">Уникальные индексы</target>
        </trans-unit>
        <trans-unit id="77df08227da6ac685804effa87058e13d84c4065" translate="yes" xml:space="preserve">
          <source>Unique constraint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94adb10ebc944ac8b8156528bb8fd8dc3337202a" translate="yes" xml:space="preserve">
          <source>Unique constraints (and hence primary keys) on partitioned tables must include all the partition key columns. This limitation exists because PostgreSQL can only enforce uniqueness in each partition individually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e5e39c7a8efbcd5a2b7282c47950080c8841cd" translate="yes" xml:space="preserve">
          <source>Unique constraints and primary keys are not inherited in the current implementation. This makes the combination of inheritance and unique constraints rather dysfunctional.</source>
          <target state="translated">Уникальные ограничения и первичные ключи не наследуются в текущей реализации.Это делает комбинацию наследования и уникальных ограничений весьма дисфункциональной.</target>
        </trans-unit>
        <trans-unit id="a46827700fc4ef4d046ba4ec7203d49efc58d66f" translate="yes" xml:space="preserve">
          <source>Unique constraints ensure that the data contained in a column, or a group of columns, is unique among all the rows in the table. The syntax is:</source>
          <target state="translated">Уникальные ограничения обеспечивают уникальность данных,содержащихся в столбце или группе столбцов,среди всех строк таблицы.Синтаксис таков:</target>
        </trans-unit>
        <trans-unit id="b9aef8c8c0041d90e74399130137479516c8ba5f" translate="yes" xml:space="preserve">
          <source>Unique constraints on partitioned tables must include all the partition key columns. This limitation exists because PostgreSQL can only enforce uniqueness in each partition individually.</source>
          <target state="translated">Уникальные ограничения на таблицы разметки должны включать в себя все ключевые столбцы разделов.Это ограничение существует потому,что PostgreSQL может обеспечить уникальность только для каждого раздела в отдельности.</target>
        </trans-unit>
        <trans-unit id="9ef954009038fb621257b004ec6cd8cd826ed58e" translate="yes" xml:space="preserve">
          <source>Unique prefixes of these strings are also accepted, for example &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;n&lt;/code&gt;. Leading or trailing whitespace is ignored, and case does not matter.</source>
          <target state="translated">Также принимаются уникальные префиксы этих строк, например &lt;code&gt;t&lt;/code&gt; или &lt;code&gt;n&lt;/code&gt; . Начальные и конечные пробелы игнорируются, регистр не имеет значения.</target>
        </trans-unit>
        <trans-unit id="f49788f44915bd3a94e16e6f26e2424dc403e286" translate="yes" xml:space="preserve">
          <source>Universal Product Codes</source>
          <target state="translated">Универсальные коды продуктов</target>
        </trans-unit>
        <trans-unit id="b3357a0d067580c052d7ebc854b226e0d5262199" translate="yes" xml:space="preserve">
          <source>Universally Unique Identifier</source>
          <target state="translated">Универсальный уникальный идентификатор</target>
        </trans-unit>
        <trans-unit id="49e71ce661ccc6dfcd03e849d0ea4cd3cac1c011" translate="yes" xml:space="preserve">
          <source>Unix System V</source>
          <target state="translated">Unix-система V</target>
        </trans-unit>
        <trans-unit id="356c3f979b3eb09e01dc5a248ce81de4df5a2076" translate="yes" xml:space="preserve">
          <source>Unix-like operating systems enforce various kinds of resource limits that might interfere with the operation of your PostgreSQL server. Of particular importance are limits on the number of processes per user, the number of open files per process, and the amount of memory available to each process. Each of these have a &amp;ldquo;hard&amp;rdquo; and a &amp;ldquo;soft&amp;rdquo; limit. The soft limit is what actually counts but it can be changed by the user up to the hard limit. The hard limit can only be changed by the root user. The system call &lt;code&gt;setrlimit&lt;/code&gt; is responsible for setting these parameters. The shell's built-in command &lt;code&gt;ulimit&lt;/code&gt; (Bourne shells) or &lt;code&gt;limit&lt;/code&gt; (csh) is used to control the resource limits from the command line. On BSD-derived systems the file &lt;code&gt;/etc/login.conf&lt;/code&gt; controls the various resource limits set during login. See the operating system documentation for details. The relevant parameters are &lt;code&gt;maxproc&lt;/code&gt;, &lt;code&gt;openfiles&lt;/code&gt;, and &lt;code&gt;datasize&lt;/code&gt;. For example:</source>
          <target state="translated">Unix-подобные операционные системы применяют различные ограничения ресурсов, которые могут мешать работе вашего сервера PostgreSQL. Особое значение имеют ограничения на количество процессов на пользователя, количество открытых файлов на процесс и объем памяти, доступной каждому процессу. У каждого из них есть &amp;laquo;жесткий&amp;raquo; и &amp;laquo;мягкий&amp;raquo; лимит. Фактически учитывается мягкий предел, но он может быть изменен пользователем до жесткого. Жесткий предел может быть изменен только пользователем root. За установку этих параметров отвечает системный вызов &lt;code&gt;setrlimit&lt;/code&gt; . Встроенная команда оболочки &lt;code&gt;ulimit&lt;/code&gt; (оболочки Bourne) или &lt;code&gt;limit&lt;/code&gt; (csh) используется для управления ограничениями ресурсов из командной строки. В системах, основанных на BSD, файл &lt;code&gt;/etc/login.conf&lt;/code&gt; контролирует различные ограничения ресурсов, установленные во время входа в систему. Подробности см. В документации по операционной системе. Соответствующие параметры: &lt;code&gt;maxproc&lt;/code&gt; , &lt;code&gt;openfiles&lt;/code&gt; и &lt;code&gt;datasize&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="3a738963ffda0371927d9ea96b648a8947fa84b5" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;WITH HOLD&lt;/code&gt; is specified, the cursor created by this command can only be used within the current transaction. Thus, &lt;code&gt;DECLARE&lt;/code&gt; without &lt;code&gt;WITH HOLD&lt;/code&gt; is useless outside a transaction block: the cursor would survive only to the completion of the statement. Therefore PostgreSQL reports an error if such a command is used outside a transaction block. Use &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; and &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; (or &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt;) to define a transaction block.</source>
          <target state="translated">Если не указано &lt;code&gt;WITH HOLD&lt;/code&gt; , курсор, созданный этой командой, может использоваться только в текущей транзакции. Таким образом, &lt;code&gt;DECLARE&lt;/code&gt; без &lt;code&gt;WITH HOLD&lt;/code&gt; бесполезно вне блока транзакции: курсор останется в живых только до завершения оператора. Поэтому PostgreSQL сообщает об ошибке, если такая команда используется вне блока транзакции. Используйте &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; и &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; (или &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt; ) для определения блока транзакции.</target>
        </trans-unit>
        <trans-unit id="f36df6a348af57e59d7545a3e535407a26fb9186" translate="yes" xml:space="preserve">
          <source>Unless it is passed an &lt;code&gt;-X&lt;/code&gt; option, psql attempts to read and execute commands from the system-wide startup file (&lt;code&gt;psqlrc&lt;/code&gt;) and then the user's personal startup file (&lt;code&gt;~/.psqlrc&lt;/code&gt;), after connecting to the database but before accepting normal commands. These files can be used to set up the client and/or the server to taste, typically with &lt;code&gt;\set&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; commands.</source>
          <target state="translated">Если не передана опция &lt;code&gt;-X&lt;/code&gt; , psql пытается читать и выполнять команды из общесистемного файла запуска ( &lt;code&gt;psqlrc&lt;/code&gt; ), а затем из личного файла запуска пользователя ( &lt;code&gt;~/.psqlrc&lt;/code&gt; ), после подключения к базе данных, но до принятия обычных команд. . Эти файлы можно использовать для настройки клиента и / или сервера по вкусу, обычно с помощью команд &lt;code&gt;\set&lt;/code&gt; и &lt;code&gt;SET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ebac9c6005801410e118c32c680d55ed8b8c195" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;, there is no large performance advantage to loading a library at session start rather than when it is first used. There is some advantage, however, when connection pooling is used.</source>
          <target state="translated">В отличие от &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; , загрузка библиотеки в начале сеанса не дает большого преимущества в производительности, а не при ее первом использовании. Однако использование пула соединений дает некоторые преимущества.</target>
        </trans-unit>
        <trans-unit id="36f97215c9ceadf639797c9ff18cfda7e2adaae5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;INHERITS&lt;/code&gt;, the new table and original table are completely decoupled after creation is complete. Changes to the original table will not be applied to the new table, and it is not possible to include data of the new table in scans of the original table.</source>
          <target state="translated">В отличие от &lt;code&gt;INHERITS&lt;/code&gt; , новая таблица и исходная таблица полностью отделяются после завершения создания. Изменения исходной таблицы не будут применены к новой таблице, и невозможно включить данные новой таблицы в сканирование исходной таблицы.</target>
        </trans-unit>
        <trans-unit id="155a510971d12c46f75bfa7a5024bf809f98a32b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;statement_timeout&lt;/code&gt;, this timeout can only occur while waiting for locks. Note that if &lt;code&gt;statement_timeout&lt;/code&gt; is nonzero, it is rather pointless to set &lt;code&gt;lock_timeout&lt;/code&gt; to the same or larger value, since the statement timeout would always trigger first. If &lt;code&gt;log_min_error_statement&lt;/code&gt; is set to &lt;code&gt;ERROR&lt;/code&gt; or lower, the statement that timed out will be logged.</source>
          <target state="translated">В отличие от &lt;code&gt;statement_timeout&lt;/code&gt; , этот тайм-аут может произойти только во время ожидания блокировок. Обратите внимание, что если &lt;code&gt;statement_timeout&lt;/code&gt; не равно нулю, довольно бессмысленно устанавливать для &lt;code&gt;lock_timeout&lt;/code&gt; такое же или большее значение, поскольку тайм-аут оператора всегда срабатывает первым. Если для &lt;code&gt;log_min_error_statement&lt;/code&gt; установлено значение &lt;code&gt;ERROR&lt;/code&gt; или ниже, оператор с истекшим временем ожидания будет зарегистрирован.</target>
        </trans-unit>
        <trans-unit id="01f67f25338b64081817dcfc5c06974c9678164c" translate="yes" xml:space="preserve">
          <source>Unlike an XQuery/XPath sequence, which can contain any desired items in any desired order, an XPath 1.0 node-set has no guaranteed order and, like any set, does not allow multiple appearances of the same item.</source>
          <target state="translated">В отличие от последовательности XQuery/XPath,которая может содержать любые желаемые элементы в любом желаемом порядке,набор узлов XPath 1.0 не имеет гарантированного порядка и,как и любой набор,не допускает многократного появления одного и того же элемента.</target>
        </trans-unit>
        <trans-unit id="7bd39bd8bedec3e142d1db4767a229ec44898026" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\!&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments. The rest of the line is simply passed literally to the shell.</source>
          <target state="translated">В отличие от большинства других мета-команд, вся оставшаяся часть строки всегда считается аргументом (-ами) &lt;code&gt;\!&lt;/code&gt; , и в аргументах не выполняется ни интерполяция переменных, ни обратные кавычки. Остальная часть строки просто передается оболочке буквально.</target>
        </trans-unit>
        <trans-unit id="f03bc80a9071747274c116c1e2637b147c1236d6" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\ef&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">В отличие от большинства других мета-команд, весь остаток строки всегда считается аргументом (-ами) &lt;code&gt;\ef&lt;/code&gt; , и в аргументах не выполняется ни интерполяция переменных, ни обратные кавычки.</target>
        </trans-unit>
        <trans-unit id="2ad59f5d51ac2d51e40eadad80e70c35b9563ffa" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\ev&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">В отличие от большинства других мета-команд, весь остаток строки всегда считается аргументом (-ами) &lt;code&gt;\ev&lt;/code&gt; , и в аргументах не выполняется ни интерполяция переменных, ни обратные кавычки.</target>
        </trans-unit>
        <trans-unit id="969a2dc5b4f67a3964fc411e75789aab5f823e51" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\help&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">В отличие от большинства других мета-команд, весь остаток строки всегда считается аргументом (-ами) &lt;code&gt;\help&lt;/code&gt; , и в аргументах не выполняется ни интерполяция переменных, ни расширение обратных кавычек.</target>
        </trans-unit>
        <trans-unit id="1bcb7b9bd68e7cf599cb0566f121f159d3638a90" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\sf&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">В отличие от большинства других мета-команд, весь остаток строки всегда считается аргументом (-ами) &lt;code&gt;\sf&lt;/code&gt; , и в аргументах не выполняется ни интерполяция переменных, ни обратные кавычки.</target>
        </trans-unit>
        <trans-unit id="b3d8189c59a9d485c225bb21085a7dacfbf70328" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\sv&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">В отличие от большинства других мета-команд, весь остаток строки всегда считается аргументом (-ами) &lt;code&gt;\sv&lt;/code&gt; , и в аргументах не выполняется ни интерполяция переменных, ни обратные кавычки.</target>
        </trans-unit>
        <trans-unit id="af5b4f9ec65cdc48545903249d2323c25ceebafa" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_database&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_database&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">В отличие от большинства системных каталогов, &lt;code&gt;pg_database&lt;/code&gt; является общей для всех баз данных кластера: существует только одна копия &lt;code&gt;pg_database&lt;/code&gt; на кластер, а не одна на базу данных.</target>
        </trans-unit>
        <trans-unit id="b4e709aa40757d88375a6ee47a77d6e0698e4303" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_db_role_setting&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_db_role_setting&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">В отличие от большинства системных каталогов, &lt;code&gt;pg_db_role_setting&lt;/code&gt; является общим для всех баз данных кластера: существует только одна копия &lt;code&gt;pg_db_role_setting&lt;/code&gt; для каждого кластера, а не одна для каждой базы данных.</target>
        </trans-unit>
        <trans-unit id="2dbf1c1060e2c0aacae52353ec7fcd45b3ccceac" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_pltemplate&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_pltemplate&lt;/code&gt; per cluster, not one per database. This allows the information to be accessible in each database as it is needed.</source>
          <target state="translated">В отличие от большинства системных каталогов, &lt;code&gt;pg_pltemplate&lt;/code&gt; является общим для всех баз данных кластера: существует только одна копия &lt;code&gt;pg_pltemplate&lt;/code&gt; для каждого кластера, а не одна для каждой базы данных. Это позволяет получать доступ к информации в каждой базе данных по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="90ff2576b542214d688a9eed4987d1a4510c063b" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_replication_origin&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_replication_origin&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">В отличие от большинства системных каталогов, &lt;code&gt;pg_replication_origin&lt;/code&gt; является общим для всех баз данных кластера: существует только одна копия &lt;code&gt;pg_replication_origin&lt;/code&gt; на кластер, а не одна на базу данных.</target>
        </trans-unit>
        <trans-unit id="091dfd81e1c158b99b74cd5401b694679d3d2a31" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_shdepend&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_shdepend&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">В отличие от большинства системных каталогов, &lt;code&gt;pg_shdepend&lt;/code&gt; используется всеми базами данных кластера: существует только одна копия &lt;code&gt;pg_shdepend&lt;/code&gt; на кластер, а не одна на базу данных.</target>
        </trans-unit>
        <trans-unit id="b1cd5b470b7693ec3b4e72d1482e8ab6f1102fe7" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_shdescription&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_shdescription&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">В отличие от большинства системных каталогов, &lt;code&gt;pg_shdescription&lt;/code&gt; является общим для всех баз данных кластера: существует только одна копия &lt;code&gt;pg_shdescription&lt;/code&gt; для каждого кластера, а не одна для каждой базы данных.</target>
        </trans-unit>
        <trans-unit id="45f9981f7d01238e6386247ed7e8c9b367559cb4" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_shseclabel&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_shseclabel&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">В отличие от большинства системных каталогов, &lt;code&gt;pg_shseclabel&lt;/code&gt; является общим для всех баз данных кластера: для каждого кластера существует только одна копия &lt;code&gt;pg_shseclabel&lt;/code&gt; , а не одна для каждой базы данных.</target>
        </trans-unit>
        <trans-unit id="eec8ee0cfbfbe1f6f908ff68c376680c64650f41" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_subscription&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_subscription&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">В отличие от большинства системных каталогов, &lt;code&gt;pg_subscription&lt;/code&gt; является общим для всех баз данных кластера: существует только одна копия &lt;code&gt;pg_subscription&lt;/code&gt; для каждого кластера, а не одна для каждой базы данных.</target>
        </trans-unit>
        <trans-unit id="0b07b56a669f78b6086b457c5748686a76e734e9" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_tablespace&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_tablespace&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">В отличие от большинства системных каталогов, &lt;code&gt;pg_tablespace&lt;/code&gt; является общим для всех баз данных кластера: существует только одна копия &lt;code&gt;pg_tablespace&lt;/code&gt; на кластер, а не одна на базу данных.</target>
        </trans-unit>
        <trans-unit id="92c63faeedbf5e16bc5b93cceba5f7d683c79fc1" translate="yes" xml:space="preserve">
          <source>Unlike the WAL receiver of a PostgreSQL standby server, pg_receivewal by default flushes WAL data only when a WAL file is closed. The option &lt;code&gt;--synchronous&lt;/code&gt; must be specified to flush WAL data in real time. Since pg_receivewal does not apply WAL, you should not allow it to become a synchronous standby when &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; equals &lt;code&gt;remote_apply&lt;/code&gt;. If it does, it will appear to be a standby that never catches up, and will cause transaction commits to block. To avoid this, you should either configure an appropriate value for &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt;, or specify &lt;code&gt;application_name&lt;/code&gt; for pg_receivewal that does not match it, or change the value of &lt;code&gt;synchronous_commit&lt;/code&gt; to something other than &lt;code&gt;remote_apply&lt;/code&gt;.</source>
          <target state="translated">В отличие от получателя WAL резервного сервера PostgreSQL, pg_receivewal по умолчанию сбрасывает данные WAL только при закрытии файла WAL. Для очистки данных WAL в реальном времени необходимо указать параметр &lt;code&gt;--synchronous&lt;/code&gt; . Поскольку pg_receivewal не применяет WAL, вы не должны позволять ему становиться синхронным резервным сервером, когда &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; равно &lt;code&gt;remote_apply&lt;/code&gt; . Если это произойдет, это будет выглядеть как резерв, который никогда не догонит, и приведет к блокировке фиксации транзакции. Чтобы избежать этого, вы должны либо настроить соответствующее значение для &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; , либо указать &lt;code&gt;application_name&lt;/code&gt; для pg_receivewal, которое не соответствует ему, либо изменить значение &lt;code&gt;synchronous_commit&lt;/code&gt; на другое, кроме &lt;code&gt;remote_apply&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="209b27f026f1a4e49e27f779263f8527ec3c4bc5" translate="yes" xml:space="preserve">
          <source>Unlike the case when adding a constraint to a regular table, nothing is done to verify the constraint is correct; rather, this action simply declares that some new condition should be assumed to hold for all rows in the foreign table. (See the discussion in &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.) If the constraint is marked &lt;code&gt;NOT VALID&lt;/code&gt;, then it isn't assumed to hold, but is only recorded for possible future use.</source>
          <target state="translated">В отличие от случая добавления ограничения в обычную таблицу, ничего не делается для проверки правильности ограничения; скорее, это действие просто объявляет, что какое-то новое условие должно выполняться для всех строк во внешней таблице. (См. Обсуждение в &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; .) Если ограничение помечено как &lt;code&gt;NOT VALID&lt;/code&gt; , то предполагается, что оно не выполняется, а только записывается для возможного использования в будущем.</target>
        </trans-unit>
        <trans-unit id="8b364554eb1587843dacba831a236e3430803901" translate="yes" xml:space="preserve">
          <source>Unlike the case with privileges, membership in a role cannot be granted to &lt;code&gt;PUBLIC&lt;/code&gt;. Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt; in &lt;code&gt;role_specification&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0b1d236f8fe0f3fb7bccf02c7559e609f29c15" translate="yes" xml:space="preserve">
          <source>Unlike the case with privileges, membership in a role cannot be granted to &lt;code&gt;PUBLIC&lt;/code&gt;. Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt;.</source>
          <target state="translated">В отличие от случая с привилегиями, членство в роли не может быть предоставлено &lt;code&gt;PUBLIC&lt;/code&gt; . Также обратите внимание, что эта форма команды не позволяет использовать слово &lt;code&gt;GROUP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d61210b660dd2a2ba353539f0d486b1b1e1ca0f9" translate="yes" xml:space="preserve">
          <source>Unlike the standard C function &lt;code&gt;sprintf&lt;/code&gt;, PostgreSQL's &lt;code&gt;format&lt;/code&gt; function allows format specifiers with and without &lt;code&gt;position&lt;/code&gt; fields to be mixed in the same format string. A format specifier without a &lt;code&gt;position&lt;/code&gt; field always uses the next argument after the last argument consumed. In addition, the &lt;code&gt;format&lt;/code&gt; function does not require all function arguments to be used in the format string. For example:</source>
          <target state="translated">В отличие от стандартной функции С &lt;code&gt;sprintf&lt;/code&gt; , PostgreSQL в &lt;code&gt;format&lt;/code&gt; функция позволяет формат спецификаторов с и без &lt;code&gt;position&lt;/code&gt; полей , чтобы быть смешаны в одной и той же строке формата. Спецификатор формата без поля &lt;code&gt;position&lt;/code&gt; всегда использует следующий аргумент после последнего использованного аргумента. Кроме того, функция &lt;code&gt;format&lt;/code&gt; не требует, чтобы все аргументы функции использовались в строке формата. Например:</target>
        </trans-unit>
        <trans-unit id="42d22ba12e56f3a8c0a56dce7ddb132f01963118" translate="yes" xml:space="preserve">
          <source>Unlike the standard C function &lt;code&gt;sprintf&lt;/code&gt;, PostgreSQL's &lt;code&gt;format&lt;/code&gt; function allows format specifiers with and without &lt;em&gt;&lt;code&gt;position&lt;/code&gt;&lt;/em&gt; fields to be mixed in the same format string. A format specifier without a &lt;em&gt;&lt;code&gt;position&lt;/code&gt;&lt;/em&gt; field always uses the next argument after the last argument consumed. In addition, the &lt;code&gt;format&lt;/code&gt; function does not require all function arguments to be used in the format string. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56340fd933fcc44d2d615474f7eee7f478fca5bb" translate="yes" xml:space="preserve">
          <source>Unlogged</source>
          <target state="translated">Unlogged</target>
        </trans-unit>
        <trans-unit id="b45f16ac00bccd2d97ad31eb4586a8a733d1ed1a" translate="yes" xml:space="preserve">
          <source>Unsets (deletes) the psql variable &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">Сбрасывает (удаляет) &lt;code&gt;name&lt;/code&gt; переменной psql .</target>
        </trans-unit>
        <trans-unit id="9b27e09825b38c1619e31484868bfeb48e96d8d2" translate="yes" xml:space="preserve">
          <source>Unsigned integer</source>
          <target state="translated">беззнаковое целое число</target>
        </trans-unit>
        <trans-unit id="50b79815e623c9d659af2f6f4f16ea14ba889265" translate="yes" xml:space="preserve">
          <source>Unused column contain zeroes. For example, &lt;code&gt;oprleft&lt;/code&gt; is zero for a prefix operator.</source>
          <target state="translated">Неиспользуемый столбец содержит нули. Например, для префиксного оператора &lt;code&gt;oprleft&lt;/code&gt; равно нулю.</target>
        </trans-unit>
        <trans-unit id="2038bdec9210202d0d9d74839e3925ff0cd91ba1" translate="yes" xml:space="preserve">
          <source>Up</source>
          <target state="translated">Up</target>
        </trans-unit>
        <trans-unit id="d7530c6545fdfa9b651c7e47222acdb144b78573" translate="yes" xml:space="preserve">
          <source>Updatable Views</source>
          <target state="translated">Обновляемые виды</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="6f08e7604a29958aee71de0f6521d5ea65d07570" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;autoprewarm.blocks&lt;/code&gt; immediately. This may be useful if the autoprewarm worker is not running but you anticipate running it after the next restart. The return value is the number of records written to &lt;code&gt;autoprewarm.blocks&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;autoprewarm.blocks&lt;/code&gt; обновите autoprewarm.blocks . Это может быть полезно, если рабочий процесс autoprewarm не запущен, но вы ожидаете его запуска после следующего перезапуска. Возвращаемое значение - это количество записей, записанных в &lt;code&gt;autoprewarm.blocks&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd357ab63dd67dab2769f9aad042acbec503d583" translate="yes" xml:space="preserve">
          <source>Update a pre-9.1 installation of &lt;code&gt;hstore&lt;/code&gt; into extension style:</source>
          <target state="translated">Обновите установку &lt;code&gt;hstore&lt;/code&gt; до 9.1 в стиле расширения:</target>
        </trans-unit>
        <trans-unit id="155fdafe50a3b57765513f60c5758d6496a123b2" translate="yes" xml:space="preserve">
          <source>Update contact names in an accounts table to match the currently assigned salesmen:</source>
          <target state="translated">Обновите имена контактов в таблице счетов в соответствии с текущими назначениями продавцов:</target>
        </trans-unit>
        <trans-unit id="a54b58d6201c8e67be3e5d043168cab0aaf4bd7b" translate="yes" xml:space="preserve">
          <source>Update statistics in a summary table to match the current data:</source>
          <target state="translated">Обновите статистику в сводной таблице в соответствии с текущими данными:</target>
        </trans-unit>
        <trans-unit id="a72e347972a409d75e922a98a8cb86184a8c091e" translate="yes" xml:space="preserve">
          <source>Update the collation's version. See &lt;a href=&quot;sql-altercollation#SQL-ALTERCOLLATION-NOTES&quot;&gt;Notes&lt;/a&gt; below.</source>
          <target state="translated">Обновите версию сопоставления. См. &lt;a href=&quot;sql-altercollation#SQL-ALTERCOLLATION-NOTES&quot;&gt;Примечания&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="886aa2619ee6c1b5dcabc291df392328e61fad29" translate="yes" xml:space="preserve">
          <source>Update the sequence value after a &lt;code&gt;COPY FROM&lt;/code&gt;:</source>
          <target state="translated">Обновите значение последовательности после &lt;code&gt;COPY FROM&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="40cf1fe41c48155dea09e4ac1106c72553cfd43c" translate="yes" xml:space="preserve">
          <source>Updates statistics used by the planner to determine the most efficient way to execute a query.</source>
          <target state="translated">Обновляет статистику,используемую планировщиком для определения наиболее эффективного способа выполнения запроса.</target>
        </trans-unit>
        <trans-unit id="dd8ce06e479993fd7940ea48abaafb1c49415931" translate="yes" xml:space="preserve">
          <source>Updating Data</source>
          <target state="translated">Обновление данных</target>
        </trans-unit>
        <trans-unit id="bbfacc342802549d59dc86ad3b2d308cd32c8b65" translate="yes" xml:space="preserve">
          <source>Updating a GIN index tends to be slow because of the intrinsic nature of inverted indexes: inserting or updating one heap row can cause many inserts into the index (one for each key extracted from the indexed item). As of PostgreSQL 8.4, GIN is capable of postponing much of this work by inserting new tuples into a temporary, unsorted list of pending entries. When the table is vacuumed or autoanalyzed, or when &lt;code&gt;gin_clean_pending_list&lt;/code&gt; function is called, or if the pending list becomes larger than &lt;a href=&quot;runtime-config-client#GUC-GIN-PENDING-LIST-LIMIT&quot;&gt;gin_pending_list_limit&lt;/a&gt;, the entries are moved to the main GIN data structure using the same bulk insert techniques used during initial index creation. This greatly improves GIN index update speed, even counting the additional vacuum overhead. Moreover the overhead work can be done by a background process instead of in foreground query processing.</source>
          <target state="translated">Обновление индекса GIN имеет тенденцию быть медленным из-за внутренней природы инвертированных индексов: вставка или обновление одной строки кучи может вызвать множество вставок в индекс (по одной для каждого ключа, извлеченного из индексированного элемента). Начиная с PostgreSQL 8.4, GIN может откладывать большую часть этой работы, вставляя новые кортежи во временный несортированный список ожидающих записей. Когда таблица очищается или анализируется автоматически, или когда &lt;code&gt;gin_clean_pending_list&lt;/code&gt; функция gin_clean_pending_list , или если ожидающий список становится больше, чем &lt;a href=&quot;runtime-config-client#GUC-GIN-PENDING-LIST-LIMIT&quot;&gt;gin_pending_list_limit&lt;/a&gt;записи перемещаются в основную структуру данных GIN с использованием тех же методов массовой вставки, которые использовались при создании начального индекса. Это значительно увеличивает скорость обновления индекса GIN, даже с учетом дополнительных накладных расходов на очистку. Более того, накладные расходы могут выполняться фоновым процессом, а не обработкой запросов на переднем плане.</target>
        </trans-unit>
        <trans-unit id="f5a2d3257a7cb0893d951688c3d6595c16276249" translate="yes" xml:space="preserve">
          <source>Updating the partition key of a row might cause it to be moved into a different partition where this row satisfies the partition bounds.</source>
          <target state="translated">Обновление ключа раздела строки может привести к ее перемещению в другой раздел,где эта строка удовлетворяет границам раздела.</target>
        </trans-unit>
        <trans-unit id="cf5d0b369531663af264541c44e93e18c3ec6ca5" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster</source>
          <target state="translated">Обновление кластера PostgreSQL</target>
        </trans-unit>
        <trans-unit id="953812b4543e49a3e367bde451848478a686a885" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster: Upgrading Data via Replication</source>
          <target state="translated">Обновление кластера PostgreSQL:Обновление данных посредством репликации</target>
        </trans-unit>
        <trans-unit id="2a87484838982cc6d197b8aae2ccdf6a9936eca6" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster: Upgrading Data via pg_dumpall</source>
          <target state="translated">Обновление кластера PostgreSQL:Обновление данных через pg_dumpall</target>
        </trans-unit>
        <trans-unit id="725bfd4bce7d201deda730473db6dfc713d4524b" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster: Upgrading Data via pg_upgrade</source>
          <target state="translated">Обновление кластера PostgreSQL:Обновление данных через pg_upgrade</target>
        </trans-unit>
        <trans-unit id="4b80cb33cf9b567178f3f5855946aac8c80e285f" translate="yes" xml:space="preserve">
          <source>Upon creation, a constraint is given one of three characteristics: &lt;code&gt;DEFERRABLE INITIALLY DEFERRED&lt;/code&gt;, &lt;code&gt;DEFERRABLE INITIALLY IMMEDIATE&lt;/code&gt;, or &lt;code&gt;NOT DEFERRABLE&lt;/code&gt;. The third class is always &lt;code&gt;IMMEDIATE&lt;/code&gt; and is not affected by the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; command. The first two classes start every transaction in the indicated mode, but their behavior can be changed within a transaction by &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;.</source>
          <target state="translated">После создания ограничению присваивается одна из трех характеристик: &lt;code&gt;DEFERRABLE INITIALLY DEFERRED&lt;/code&gt; , &lt;code&gt;DEFERRABLE INITIALLY IMMEDIATE&lt;/code&gt; или &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; . Третий класс всегда является &lt;code&gt;IMMEDIATE&lt;/code&gt; и на него не влияет команда &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; . Первые два класса запускают каждую транзакцию в указанном режиме, но их поведение может быть изменено в транзакции с помощью &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d7a654640c2b50b3e7df60aeeabb5b08422ed24" translate="yes" xml:space="preserve">
          <source>Upper Limit</source>
          <target state="translated">верхний предел</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="b4f04a10cb842d23a6e0c14dfb525ccfc19a7eeb" translate="yes" xml:space="preserve">
          <source>Usage notes for date/time formatting:</source>
          <target state="translated">Примечания по использованию для форматирования даты/времени:</target>
        </trans-unit>
        <trans-unit id="c18762bb9fd2f772e7a3cc1038dad6521a3cdc73" translate="yes" xml:space="preserve">
          <source>Usage notes for numeric formatting:</source>
          <target state="translated">Примечания к использованию для цифрового форматирования:</target>
        </trans-unit>
        <trans-unit id="c17fd067f164433138f454d194adc8307cae8bca" translate="yes" xml:space="preserve">
          <source>Usage of &lt;em&gt;edge recombination crossover&lt;/em&gt; which is especially suited to keep edge losses low for the solution of the TSP by means of a GA;</source>
          <target state="translated">Использование &lt;em&gt;кроссовера с рекомбинацией краев,&lt;/em&gt; который особенно подходит для поддержания низких краевых потерь для решения TSP с помощью GA;</target>
        </trans-unit>
        <trans-unit id="8cb6064dc167ff3a0e3b42195a78e15770baa73c" translate="yes" xml:space="preserve">
          <source>Usage of a &lt;em&gt;steady state&lt;/em&gt; GA (replacement of the least fit individuals in a population, not whole-generational replacement) allows fast convergence towards improved query plans. This is essential for query handling with reasonable time;</source>
          <target state="translated">Использование GA &lt;em&gt;устойчивого состояния&lt;/em&gt; (замена наименее подходящих людей в популяции, а не замена целого поколения) позволяет быстро перейти к улучшенным планам запросов. Это важно для обработки запросов в разумные сроки;</target>
        </trans-unit>
        <trans-unit id="fc32adaef16ee6908ebadfca82b7126506f9473f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;'s &lt;code&gt;\ddp&lt;/code&gt; command to obtain information about existing assignments of default privileges. The meaning of the privilege display is the same as explained for &lt;code&gt;\dp&lt;/code&gt; in &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;.</source>
          <target state="translated">Использование &lt;a href=&quot;app-psql&quot;&gt;PSQL&lt;/a&gt; &amp;laquo;ы &lt;code&gt;\ddp&lt;/code&gt; команду , чтобы получить информацию о существующих присвоений привилегий по умолчанию. Значение отображения привилегий такое же, как объяснено для &lt;code&gt;\dp&lt;/code&gt; в &lt;a href=&quot;ddl-priv&quot;&gt;Разделе 5.7&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ba1f539905474c7406568a7a7f9b3f0d11b5735" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; to change the attributes of a role, and &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; to remove a role. All the attributes specified by &lt;code&gt;CREATE ROLE&lt;/code&gt; can be modified by later &lt;code&gt;ALTER ROLE&lt;/code&gt; commands.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE,&lt;/a&gt; чтобы изменить атрибуты роли, и &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE,&lt;/a&gt; чтобы удалить роль. Все атрибуты, указанные в &lt;code&gt;CREATE ROLE&lt;/code&gt; , могут быть изменены более поздними командами &lt;code&gt;ALTER ROLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7488ebe056d7926158f410bc5c4336c809c61a3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-call&quot;&gt;CALL&lt;/a&gt; to execute a procedure.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-call&quot;&gt;CALL&lt;/a&gt; для выполнения процедуры.</target>
        </trans-unit>
        <trans-unit id="63fbf455d11c44c5877b87a971f27977e59c85ca" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt; to terminate a transaction block.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; или &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt; для завершения блока транзакции.</target>
        </trans-unit>
        <trans-unit id="aa95bc5e0df28b02065365fe45c3e1b0d1eafbd6" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; to successfully terminate a transaction.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; для успешного завершения транзакции.</target>
        </trans-unit>
        <trans-unit id="66e6213ccf4796834fff65a2132381a6fc00d716" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; to load all the rows in one command, instead of using a series of &lt;code&gt;INSERT&lt;/code&gt; commands. The &lt;code&gt;COPY&lt;/code&gt; command is optimized for loading large numbers of rows; it is less flexible than &lt;code&gt;INSERT&lt;/code&gt;, but incurs significantly less overhead for large data loads. Since &lt;code&gt;COPY&lt;/code&gt; is a single command, there is no need to disable autocommit if you use this method to populate a table.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-copy&quot;&gt;КОПИРОВАНИЕ&lt;/a&gt; для загрузки всех строк одной командой вместо использования серии команд &lt;code&gt;INSERT&lt;/code&gt; . Команда &lt;code&gt;COPY&lt;/code&gt; оптимизирована для загрузки большого количества строк; он менее гибкий, чем &lt;code&gt;INSERT&lt;/code&gt; , но требует значительно меньше накладных расходов при больших загрузках данных. Поскольку &lt;code&gt;COPY&lt;/code&gt; - это отдельная команда, нет необходимости отключать автоматическую фиксацию, если вы используете этот метод для заполнения таблицы.</target>
        </trans-unit>
        <trans-unit id="09047c3a617e15ed6b5d857521bdd8e734e0300e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; to add new roles, and &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; to remove a role.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE,&lt;/a&gt; чтобы добавить новые роли, и &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE,&lt;/a&gt; чтобы удалить роль.</target>
        </trans-unit>
        <trans-unit id="9b4d3d6618c9949a9ad76ab0ddb5874169d923d3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropcast&quot;&gt;DROP CAST&lt;/a&gt; to remove user-defined casts.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-dropcast&quot;&gt;DROP CAST&lt;/a&gt; для удаления определенных пользователем приведений.</target>
        </trans-unit>
        <trans-unit id="f593b5e915433730446b465706be5f4af789f7c8" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; to remove a database.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; для удаления базы данных.</target>
        </trans-unit>
        <trans-unit id="f6d31dd4270e5743088ace63fb2eb93db009e693" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropindex&quot;&gt;DROP INDEX&lt;/a&gt; to remove an index.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-dropindex&quot;&gt;DROP INDEX&lt;/a&gt; для удаления индекса.</target>
        </trans-unit>
        <trans-unit id="c243eaa6db16e01a7e2d96464804f5badfa4a886" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-droplanguage&quot;&gt;DROP LANGUAGE&lt;/a&gt; to drop procedural languages.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-droplanguage&quot;&gt;DROP LANGUAGE&lt;/a&gt; для удаления процедурных языков.</target>
        </trans-unit>
        <trans-unit id="611b170ec13c2b52270c3dae6f1ab02cf82d138c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropoperator&quot;&gt;DROP OPERATOR&lt;/a&gt; to delete user-defined operators from a database. Use &lt;a href=&quot;sql-alteroperator&quot;&gt;ALTER OPERATOR&lt;/a&gt; to modify operators in a database.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-dropoperator&quot;&gt;DROP OPERATOR&lt;/a&gt; для удаления определяемых пользователем операторов из базы данных. Используйте &lt;a href=&quot;sql-alteroperator&quot;&gt;ALTER OPERATOR&lt;/a&gt; для изменения операторов в базе данных.</target>
        </trans-unit>
        <trans-unit id="58497b86e7746a484024506bf39de0e9955831f3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-droptransform&quot;&gt;DROP TRANSFORM&lt;/a&gt; to remove transforms.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-droptransform&quot;&gt;DROP TRANSFORM&lt;/a&gt; для удаления преобразований.</target>
        </trans-unit>
        <trans-unit id="b075359ef1491da7c72c666849ad06ca28042837" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; to remove a trigger.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-droptrigger&quot;&gt;DROP TRIGGER,&lt;/a&gt; чтобы удалить триггер.</target>
        </trans-unit>
        <trans-unit id="e27e35b2729f99b5a4d57cb1356ed22041def512" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-release-savepoint&quot;&gt;RELEASE SAVEPOINT&lt;/a&gt; to destroy a savepoint without discarding the effects of commands executed after it was established.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-release-savepoint&quot;&gt;RELEASE SAVEPOINT,&lt;/a&gt; чтобы уничтожить точку сохранения без отмены результатов команд, выполненных после ее создания.</target>
        </trans-unit>
        <trans-unit id="54340c6db432893de03388140d111cf79cc5bd33" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt; to abort a transaction.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK,&lt;/a&gt; чтобы прервать транзакцию.</target>
        </trans-unit>
        <trans-unit id="b54ec80fcdd9c1cc0a780b0c3e10b24a114e978c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-rollback-to&quot;&gt;ROLLBACK TO SAVEPOINT&lt;/a&gt; to rollback to a savepoint. Use &lt;a href=&quot;sql-release-savepoint&quot;&gt;RELEASE SAVEPOINT&lt;/a&gt; to destroy a savepoint, keeping the effects of commands executed after it was established.</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-rollback-to&quot;&gt;ROLLBACK TO SAVEPOINT&lt;/a&gt; для отката к точке сохранения. Используйте &lt;a href=&quot;sql-release-savepoint&quot;&gt;RELEASE SAVEPOINT,&lt;/a&gt; чтобы уничтожить точку сохранения, сохранив эффекты команд, выполненных после ее создания.</target>
        </trans-unit>
        <trans-unit id="f8f348396f663d6710748aac99721ad4f0c1192d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;DROP COLLATION&lt;/code&gt; to remove user-defined collations.</source>
          <target state="translated">Используйте &lt;code&gt;DROP COLLATION&lt;/code&gt; , чтобы удалить определенные пользователем параметры сортировки.</target>
        </trans-unit>
        <trans-unit id="f84b3986ffc86a297e493d0aa18ef741b0d79725" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;DROP CONVERSION&lt;/code&gt; to remove user-defined conversions.</source>
          <target state="translated">Используйте &lt;code&gt;DROP CONVERSION&lt;/code&gt; , чтобы удалить определенные пользователем преобразования.</target>
        </trans-unit>
        <trans-unit id="ff15db4e13f780cb214c1fb5755bb245ba8cdda8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;DROP SEQUENCE&lt;/code&gt; to remove a sequence.</source>
          <target state="translated">Используйте &lt;code&gt;DROP SEQUENCE&lt;/code&gt; , чтобы удалить последовательность.</target>
        </trans-unit>
        <trans-unit id="15726e7944bcacfcfd9200215f0e42b66131bfdd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;OUT&lt;/code&gt; parameters to define the return type implicitly. The same example could also be done this way:</source>
          <target state="translated">Используйте параметры &lt;code&gt;OUT&lt;/code&gt; , чтобы неявно определить тип возвращаемого значения. Тот же пример можно сделать так:</target>
        </trans-unit>
        <trans-unit id="67538321bf9a606c6338bda53e8523a0fee89c08" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;\lo_list&lt;/code&gt; to find out the large object's OID.</source>
          <target state="translated">Используйте &lt;code&gt;\lo_list&lt;/code&gt; чтобы узнать OID большого объекта.</target>
        </trans-unit>
        <trans-unit id="2965f87f5b2b233b83696be719d6f81a6a38ddaa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;restore_command&lt;/code&gt; defined in the target cluster configuration to retrieve WAL files from the WAL archive if these files are no longer available in the &lt;code&gt;pg_wal&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c1ddd9e45a36cc1cb06c4712dd45f333163ae53" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;separator&lt;/code&gt; as the field separator for unaligned output. This is equivalent to &lt;code&gt;\pset fieldsep&lt;/code&gt; or &lt;code&gt;\f&lt;/code&gt;.</source>
          <target state="translated">Используйте &lt;code&gt;separator&lt;/code&gt; в качестве разделителя полей для невыровненного вывода. Это эквивалентно &lt;code&gt;\pset fieldsep&lt;/code&gt; или &lt;code&gt;\f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f33f5b37daa8a924b75643b07be4642a71a3839" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;separator&lt;/code&gt; as the record separator for unaligned output. This is equivalent to &lt;code&gt;\pset recordsep&lt;/code&gt;.</source>
          <target state="translated">Используйте &lt;code&gt;separator&lt;/code&gt; в качестве разделителя записей для невыровненного вывода. Это эквивалент &lt;code&gt;\pset recordsep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5d5c3e044f569ed4a54b5c8b2aeebf1c2b6cc75" translate="yes" xml:space="preserve">
          <source>Use GSSAPI to authenticate the user. This is only available for TCP/IP connections. See &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt; for details. It can be used in conjunction with GSSAPI encryption.</source>
          <target state="translated">Используйте GSSAPI для аутентификации пользователя. Это доступно только для соединений TCP / IP. См &lt;a href=&quot;gssapi-auth&quot;&gt;раздел 20.6&lt;/a&gt; для деталей. Его можно использовать вместе с шифрованием GSSAPI.</target>
        </trans-unit>
        <trans-unit id="aeb12709af5299bd1b78d1fc87510677adf5e4d9" translate="yes" xml:space="preserve">
          <source>Use SSPI to authenticate the user. This is only available on Windows. See &lt;a href=&quot;sspi-auth&quot;&gt;Section 20.7&lt;/a&gt; for details.</source>
          <target state="translated">Используйте SSPI для аутентификации пользователя. Это доступно только в Windows. См &lt;a href=&quot;sspi-auth&quot;&gt;раздел 20.7&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="09a0b632c4471d6df190780101d005ba97319161" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;serializable&lt;/code&gt; transaction for the dump, to ensure that the snapshot used is consistent with later database states; but do this by waiting for a point in the transaction stream at which no anomalies can be present, so that there isn't a risk of the dump failing or causing other transactions to roll back with a &lt;code&gt;serialization_failure&lt;/code&gt;. See &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="translated">Используйте &lt;code&gt;serializable&lt;/code&gt; транзакцию для дампа, чтобы гарантировать, что используемый моментальный снимок совместим с более поздними состояниями базы данных; но сделайте это, дождавшись точки в потоке транзакций, в которой не может быть никаких аномалий, чтобы не было риска сбоя дампа или отката других транзакций с помощью &lt;code&gt;serialization_failure&lt;/code&gt; . См. &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Главу 13&lt;/a&gt; для получения дополнительной информации об изоляции транзакций и управлении параллелизмом.</target>
        </trans-unit>
        <trans-unit id="9ca5d4bab09764f17142fbf20ac5e71fb208ada4" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;serializable&lt;/code&gt; transaction for the dump, to ensure that the snapshot used is consistent with later database states; but do this by waiting for a point in the transaction stream at which no anomalies can be present, so that there isn't a risk of the dump failing or causing other transactions to roll back with a &lt;code&gt;serialization_failure&lt;/code&gt;. See &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c1cd79ab101e360e9a13e652ea38bf6edc2d76e" translate="yes" xml:space="preserve">
          <source>Use an &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;exclusion constraint&lt;/a&gt; to enforce the rule that a cage at a zoo can contain only one kind of animal:</source>
          <target state="translated">Используйте &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;ограничение исключения,&lt;/a&gt; чтобы обеспечить соблюдение правила, согласно которому клетка в зоопарке может содержать только один вид животных:</target>
        </trans-unit>
        <trans-unit id="f3ff396f1aa38be47c72d90438e9b5c8fc599d4d" translate="yes" xml:space="preserve">
          <source>Use checksums on data pages to help detect corruption by the I/O system that would otherwise be silent. Enabling checksums may incur a noticeable performance penalty. If set, checksums are calculated for all objects, in all databases. All checksum failures will be reported in the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-VIEW&quot;&gt;&lt;code&gt;pg_stat_database&lt;/code&gt;&lt;/a&gt; view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed495ec2e832a44d27151818dc3a53eb05f6485b" translate="yes" xml:space="preserve">
          <source>Use checksums on data pages to help detect corruption by the I/O system that would otherwise be silent. Enabling checksums may incur a noticeable performance penalty. If set, checksums are calculated for all objects, in all databases. All checksum failures will be reported in the &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; view.</source>
          <target state="translated">Используйте контрольные суммы на страницах данных, чтобы помочь обнаружить повреждение системой ввода-вывода, которая в противном случае не работала бы. Включение контрольных сумм может привести к заметному снижению производительности. Если установлено, контрольные суммы рассчитываются для всех объектов во всех базах данных. Все ошибки контрольной суммы будут сообщены в представлении &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce023d8439552305d2edc6e2bf4149ad204ec26c" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">Используйте условные команды (например, добавьте предложение &lt;code&gt;IF EXISTS&lt;/code&gt; ) для удаления объектов базы данных. Эта опция недействительна, если также не указано &lt;code&gt;--clean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d755e67717cdd34225a86cde8e3134de7095e52a" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop databases and other objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">Используйте условные команды (например, добавьте предложение &lt;code&gt;IF EXISTS&lt;/code&gt; ) для удаления баз данных и других объектов. Эта опция недействительна, если также не указано &lt;code&gt;--clean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="723b15fd565cd7b73cc4c9f69508e6bb65d787d0" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) when cleaning database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">Используйте условные команды (например, добавьте предложение &lt;code&gt;IF EXISTS&lt;/code&gt; ) при очистке объектов базы данных. Эта опция недействительна, если также не указано &lt;code&gt;--clean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e393204f90a01988137d09cb6497fb713cc35dc8" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e., add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03fb63958860db5f3f91183fba351eaf47350bb0" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e., add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop databases and other objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dab14262df7a0d62d0ac14dd30b69bdadab90b1" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e., add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) when cleaning database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8dc23b011f6f1a62e695d4c31ea4636fb489dcc" translate="yes" xml:space="preserve">
          <source>Use efficient file cloning (also known as &amp;ldquo;reflinks&amp;rdquo; on some systems) instead of copying files to the new cluster. This can result in near-instantaneous copying of the data files, giving the speed advantages of &lt;code&gt;-k&lt;/code&gt;/&lt;code&gt;--link&lt;/code&gt; while leaving the old cluster untouched.</source>
          <target state="translated">Используйте эффективное клонирование файлов (также известное как &amp;laquo;рефссылки&amp;raquo; в некоторых системах) вместо копирования файлов в новый кластер. Это может привести к почти мгновенному копированию файлов данных, что дает преимущества скорости &lt;code&gt;-k&lt;/code&gt; / &lt;code&gt;--link&lt;/code&gt; , оставляя старый кластер нетронутым.</target>
        </trans-unit>
        <trans-unit id="717457386c7410d1c0caadadb8bcf5cee9b94ef2" translate="yes" xml:space="preserve">
          <source>Use genetic query optimization to plan queries with at least this many &lt;code&gt;FROM&lt;/code&gt; items involved. (Note that a &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; construct counts as only one &lt;code&gt;FROM&lt;/code&gt; item.) The default is 12. For simpler queries it is usually best to use the regular, exhaustive-search planner, but for queries with many tables the exhaustive search takes too long, often longer than the penalty of executing a suboptimal plan. Thus, a threshold on the size of the query is a convenient way to manage use of GEQO.</source>
          <target state="translated">Используйте генетическую оптимизацию запросов для планирования запросов, в которых задействовано хотя бы такое количество элементов &lt;code&gt;FROM&lt;/code&gt; . (Обратите внимание, что конструкция &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; считается только одним элементом &lt;code&gt;FROM&lt;/code&gt; .) По умолчанию - 12. Для более простых запросов обычно лучше использовать обычный планировщик исчерпывающего поиска, но для запросов с большим количеством таблиц исчерпывающий поиск занимает слишком много времени. , часто дольше, чем штраф за выполнение неоптимального плана. Таким образом, пороговое значение размера запроса - удобный способ управлять использованием GEQO.</target>
        </trans-unit>
        <trans-unit id="a0976de4de13332a56e83de88d1173b0054dd784" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;INHERITS&lt;/code&gt; creates a persistent relationship between the new child table and its parent table(s). Schema modifications to the parent(s) normally propagate to children as well, and by default the data of the child table is included in scans of the parent(s).</source>
          <target state="translated">Использование &lt;code&gt;INHERITS&lt;/code&gt; создает постоянную связь между новой дочерней таблицей и ее родительскими таблицами. Изменения схемы родительского (-ых) элемента (-ей) обычно распространяются и на дочерние элементы, и по умолчанию данные дочерней таблицы включаются в сканирование родительского (-ых).</target>
        </trans-unit>
        <trans-unit id="9e4eb26aa371684361e3e419e078890b371282ac" translate="yes" xml:space="preserve">
          <source>Use of most of these functions requires PostgreSQL to have been built with &lt;code&gt;configure --with-libxml&lt;/code&gt;.</source>
          <target state="translated">Для использования большинства этих функций требуется, чтобы PostgreSQL был &lt;code&gt;configure --with-libxml&lt;/code&gt; с помощью configure --with-libxml .</target>
        </trans-unit>
        <trans-unit id="c68e27d415e6287dfc4c6988546eee3d268cda34" translate="yes" xml:space="preserve">
          <source>Use of symbolic references is enabled in a particular catalog column by attaching &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; to the column's definition, where &lt;code&gt;lookuprule&lt;/code&gt; is the name of the referenced catalog, e.g. &lt;code&gt;pg_proc&lt;/code&gt;. &lt;code&gt;BKI_LOOKUP&lt;/code&gt; can be attached to columns of type &lt;code&gt;Oid&lt;/code&gt;, &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;oidvector&lt;/code&gt;, or &lt;code&gt;Oid[]&lt;/code&gt;; in the latter two cases it implies performing a lookup on each element of the array.</source>
          <target state="translated">Использование символических ссылок &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; в конкретном столбце каталога путем присоединения BKI_LOOKUP (правила поиска) к определению столбца, где &lt;code&gt;lookuprule&lt;/code&gt; - это имя каталога, на который имеется ссылка, например, &lt;code&gt;pg_proc&lt;/code&gt; . &lt;code&gt;BKI_LOOKUP&lt;/code&gt; можно присоединить к столбцам типа &lt;code&gt;Oid&lt;/code&gt; , &lt;code&gt;regproc&lt;/code&gt; , &lt;code&gt;oidvector&lt;/code&gt; или &lt;code&gt;Oid[]&lt;/code&gt; ; в последних двух случаях подразумевается выполнение поиска по каждому элементу массива.</target>
        </trans-unit>
        <trans-unit id="3fb4ce36062b56e26da7090e374ab7610c6e2ceb" translate="yes" xml:space="preserve">
          <source>Use of symbolic references is enabled in a particular catalog column by attaching &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; to the column's definition, where &lt;code&gt;lookuprule&lt;/code&gt; is the name of the referenced catalog, e.g., &lt;code&gt;pg_proc&lt;/code&gt;. &lt;code&gt;BKI_LOOKUP&lt;/code&gt; can be attached to columns of type &lt;code&gt;Oid&lt;/code&gt;, &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;oidvector&lt;/code&gt;, or &lt;code&gt;Oid[]&lt;/code&gt;; in the latter two cases it implies performing a lookup on each element of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7de245d3c3aa0bf5e90f594f4cb93e3038943a92" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;RETURNING&lt;/code&gt; clause requires &lt;code&gt;SELECT&lt;/code&gt; privilege on all columns mentioned in &lt;code&gt;RETURNING&lt;/code&gt;. If you use the &lt;code&gt;query&lt;/code&gt; clause to insert rows from a query, you of course need to have &lt;code&gt;SELECT&lt;/code&gt; privilege on any table or column used in the query.</source>
          <target state="translated">Использование предложения &lt;code&gt;RETURNING&lt;/code&gt; требует привилегии &lt;code&gt;SELECT&lt;/code&gt; для всех столбцов, упомянутых в &lt;code&gt;RETURNING&lt;/code&gt; . Если вы используете предложение &lt;code&gt;query&lt;/code&gt; для вставки строк из запроса, вам, конечно, необходимо иметь привилегию &lt;code&gt;SELECT&lt;/code&gt; для любой таблицы или столбца, используемого в запросе.</target>
        </trans-unit>
        <trans-unit id="2aa84cc2dc2791298c5a401376b7bb182eec75e7" translate="yes" xml:space="preserve">
          <source>Use real data for experimentation. Using test data for setting up indexes will tell you what indexes you need for the test data, but that is all.</source>
          <target state="translated">Используйте реальные данные для экспериментов.Использование тестовых данных для настройки индексов скажет вам,какие индексы вам нужны для тестовых данных,но это все.</target>
        </trans-unit>
        <trans-unit id="740a1a424b9afbaad4fd5f97eac328593356e696" translate="yes" xml:space="preserve">
          <source>Use semicolon followed by two newlines, rather than just newline, as the command entry terminator.</source>
          <target state="translated">В качестве терминатора ввода команды используйте точку с запятой,за которой следуют две новые строки,а не просто новую.</target>
        </trans-unit>
        <trans-unit id="493672dde3eb1e21802c93c463663707684dc28f" translate="yes" xml:space="preserve">
          <source>Use separate session key. Public-key encryption always uses a separate session key; this option is for symmetric-key encryption, which by default uses the S2K key directly.</source>
          <target state="translated">Используйте отдельный ключ сеанса.Шифрование открытым ключом всегда использует отдельный ключ сеанса;эта опция предназначена для шифрования симметричным ключом,которое по умолчанию использует S2K ключ напрямую.</target>
        </trans-unit>
        <trans-unit id="93c526253accc03345c125a338a69425d93d7a5c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;sql-dropview&quot;&gt;DROP VIEW&lt;/a&gt; statement to drop views.</source>
          <target state="translated">Используйте оператор &lt;a href=&quot;sql-dropview&quot;&gt;DROP VIEW&lt;/a&gt; для удаления представлений.</target>
        </trans-unit>
        <trans-unit id="0d8fcf6d0e2c0c387fa9db23f6382b953340061f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option. See &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; for further information.</source>
          <target state="translated">Используйте опцию &lt;code&gt;CONCURRENTLY&lt;/code&gt; . Смотрите &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="3b4b457d273cfa55849542aa4f8ee8d5c092684f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option. See &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;, where all the caveats of this option are explained in detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49e85f329c30105292985206289324c8f90af224" translate="yes" xml:space="preserve">
          <source>Use the alternative column-list syntax to do the same update:</source>
          <target state="translated">Используйте альтернативный синтаксис списка столбцов,чтобы сделать то же самое обновление:</target>
        </trans-unit>
        <trans-unit id="c367993bbb1f90b5675f542abe2a7cf24ff8d497" translate="yes" xml:space="preserve">
          <source>Use the manifest file at the specified path, rather than one located in the root of the backup directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae2307b8f401e6a987e3d05544bf2939cd859f9" translate="yes" xml:space="preserve">
          <source>Use the specified operating system locale for the &lt;code&gt;LC_COLLATE&lt;/code&gt; locale category.</source>
          <target state="translated">Используйте указанный языковой стандарт операционной системы для категории &lt;code&gt;LC_COLLATE&lt;/code&gt; стандарта LC_COLLATE .</target>
        </trans-unit>
        <trans-unit id="55a394e7b9e61f2a206b4b6967eab6c67d2c7b7c" translate="yes" xml:space="preserve">
          <source>Use the specified operating system locale for the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale category.</source>
          <target state="translated">Используйте указанный языковой стандарт операционной системы для &lt;code&gt;LC_CTYPE&lt;/code&gt; языкового стандарта LC_CTYPE .</target>
        </trans-unit>
        <trans-unit id="b2aa6b91b4c4ba84fa390b2a6da37aa75a60894a" translate="yes" xml:space="preserve">
          <source>Use the specified synchronized snapshot when making a dump of the database (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;Table 9.87&lt;/a&gt; for more details).</source>
          <target state="translated">Используйте указанный синхронизированный снимок при создании дампа базы данных (подробнее см. &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;Табл. 9.87&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f01c307a5f93cc4ea8d811925d49d9a9c26369ed" translate="yes" xml:space="preserve">
          <source>Use the specified synchronized snapshot when making a dump of the database (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;Table 9.88&lt;/a&gt; for more details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee78ab2ce0e01deb66fa480713a33b2c2b35d2ab" translate="yes" xml:space="preserve">
          <source>Use the specified value of &lt;code&gt;extra_float_digits&lt;/code&gt; when dumping floating-point data, instead of the maximum available precision. Routine dumps made for backup purposes should not use this option.</source>
          <target state="translated">Используйте указанное значение &lt;code&gt;extra_float_digits&lt;/code&gt; при выгрузке данных с плавающей запятой вместо максимально доступной точности. В обычных дампах, сделанных для резервного копирования, этот параметр использовать не следует.</target>
        </trans-unit>
        <trans-unit id="af4516f566a55d94c31709c01f556432e3bd7291" translate="yes" xml:space="preserve">
          <source>Use the specified value of extra_float_digits when dumping floating-point data, instead of the maximum available precision. Routine dumps made for backup purposes should not use this option.</source>
          <target state="translated">Используйте указанное значение extra_float_digits при дампинге данных с плавающей точкой вместо максимальной доступной точности.Рутинные дампы,созданные для резервного копирования,не должны использовать эту опцию.</target>
        </trans-unit>
        <trans-unit id="6f31da9aa85cb07454372ac17645a52a84247324" translate="yes" xml:space="preserve">
          <source>Use this sequence in an &lt;code&gt;INSERT&lt;/code&gt; command:</source>
          <target state="translated">Используйте эту последовательность в команде &lt;code&gt;INSERT&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="29370364d5a3aa7edfb47c0679c084d535a999d7" translate="yes" xml:space="preserve">
          <source>Used to allow inference of partial unique indexes. Any indexes that satisfy the predicate (which need not actually be partial indexes) can be inferred. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format. &lt;code&gt;SELECT&lt;/code&gt; privilege on any column appearing within &lt;code&gt;index_predicate&lt;/code&gt; is required.</source>
          <target state="translated">Используется для вывода частичных уникальных индексов. Могут быть выведены любые индексы, удовлетворяющие предикату (которые на самом деле не обязательно должны быть частичными индексами). Соответствует формату &lt;code&gt;CREATE INDEX&lt;/code&gt; . Требуется привилегия &lt;code&gt;SELECT&lt;/code&gt; для любого столбца, &lt;code&gt;index_predicate&lt;/code&gt; в index_predicate .</target>
        </trans-unit>
        <trans-unit id="60a26aae579e4125ce2ef1b4188cb642a6c52362" translate="yes" xml:space="preserve">
          <source>Used to compute the maximum amount of memory that hash-based operations can use. The final limit is determined by multiplying &lt;code&gt;work_mem&lt;/code&gt; by &lt;code&gt;hash_mem_multiplier&lt;/code&gt;. The default value is 1.0, which makes hash-based operations subject to the same simple &lt;code&gt;work_mem&lt;/code&gt; maximum as sort-based operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bfbb286795d184b793a60a1094e6c47b8ed4218" translate="yes" xml:space="preserve">
          <source>Useful values for production work probably range from a small number of hours to a few days. Small values (such as &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1min&lt;/code&gt;) are only allowed because they may sometimes be useful for testing. While a setting as high as &lt;code&gt;60d&lt;/code&gt; is allowed, please note that in many workloads extreme bloat or transaction ID wraparound may occur in much shorter time frames.</source>
          <target state="translated">Полезные значения для производственной работы, вероятно, варьируются от небольшого количества часов до нескольких дней. Небольшие значения (например, &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;1min&lt;/code&gt; ) разрешены только потому, что иногда они могут быть полезны для тестирования. Хотя допускается настройка до &lt;code&gt;60d&lt;/code&gt; , обратите внимание, что во многих рабочих нагрузках чрезмерное раздувание или перенос идентификатора транзакции может происходить в гораздо более короткие сроки.</target>
        </trans-unit>
        <trans-unit id="9f8a2389a20ca0752aa9e95093515517e90e194c" translate="yes" xml:space="preserve">
          <source>User</source>
          <target state="translated">User</target>
        </trans-unit>
        <trans-unit id="0aa9c997122e493dfcfb31ff0542b184a558e6ef" translate="yes" xml:space="preserve">
          <source>User Name Maps</source>
          <target state="translated">Имя пользователя Карты</target>
        </trans-unit>
        <trans-unit id="657c8b98d31db02ca6e2f49846863d392059fe65" translate="yes" xml:space="preserve">
          <source>User bypasses every row level security policy, see &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt; for more information.</source>
          <target state="translated">Пользователь обходит каждую политику безопасности на уровне строк, дополнительную информацию см. В &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Разделе 5.8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17a367250b51dc731bdf8cbd166e2c6618238172" translate="yes" xml:space="preserve">
          <source>User can create databases</source>
          <target state="translated">Пользователь может создавать базы данных</target>
        </trans-unit>
        <trans-unit id="0cd638046cbfe5c1f3e3cd84a3d83b310d114f21" translate="yes" xml:space="preserve">
          <source>User can initiate streaming replication and put the system in and out of backup mode.</source>
          <target state="translated">Пользователь может инициировать потоковую репликацию и перевести систему в режим резервного копирования и из него.</target>
        </trans-unit>
        <trans-unit id="62ff3be7aa18f82b61ae56cce7156698ab778283" translate="yes" xml:space="preserve">
          <source>User is a superuser</source>
          <target state="translated">Пользователь является суперпользователем</target>
        </trans-unit>
        <trans-unit id="4aef5e6fb407d9fa24def89a2aaec4ed9412ef6a" translate="yes" xml:space="preserve">
          <source>User mapping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0381065a82fe9d6c10d8cd3e9089f5c14f9312b8" translate="yes" xml:space="preserve">
          <source>User mapping specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">Специальные параметры сопоставления пользователей в виде строк &amp;laquo;ключевое слово = значение&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="542fc71480dec743e60c20434ec6dd5838fc4b52" translate="yes" xml:space="preserve">
          <source>User name</source>
          <target state="translated">Имя пользователя</target>
        </trans-unit>
        <trans-unit id="0966c5e99e856745941e09bf863b1894eaa04766" translate="yes" xml:space="preserve">
          <source>User name for the user to run the service as. For domain users, use the format &lt;code&gt;DOMAIN\username&lt;/code&gt;.</source>
          <target state="translated">Имя пользователя, от имени которого будет запущена служба. Для пользователей домена используйте формат &lt;code&gt;DOMAIN\username&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae03b2f53e94d67697836cc9ddba3d24303f1bd3" translate="yes" xml:space="preserve">
          <source>User name maps are defined in the ident map file, which by default is named &lt;code&gt;pg_ident.conf&lt;/code&gt; and is stored in the cluster's data directory. (It is possible to place the map file elsewhere, however; see the &lt;a href=&quot;runtime-config-file-locations#GUC-IDENT-FILE&quot;&gt;ident_file&lt;/a&gt; configuration parameter.) The ident map file contains lines of the general form:</source>
          <target state="translated">Карты имен пользователей определены в файле карты идентификаторов, который по умолчанию называется &lt;code&gt;pg_ident.conf&lt;/code&gt; и хранится в каталоге данных кластера. (Однако можно разместить файл карты в другом месте; см. &lt;a href=&quot;runtime-config-file-locations#GUC-IDENT-FILE&quot;&gt;Параметр&lt;/a&gt; конфигурации identifier_file .) Файл карты идентификатора содержит строки общей формы:</target>
        </trans-unit>
        <trans-unit id="26c83bd5ba1faee58ca4dfcad77ca8603bcdb897" translate="yes" xml:space="preserve">
          <source>User name of the mapping. &lt;code&gt;CURRENT_USER&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; match the name of the current user. &lt;code&gt;PUBLIC&lt;/code&gt; is used to match all present and future user names in the system.</source>
          <target state="translated">Имя пользователя сопоставления. &lt;code&gt;CURRENT_USER&lt;/code&gt; и &lt;code&gt;USER&lt;/code&gt; соответствуют имени текущего пользователя. &lt;code&gt;PUBLIC&lt;/code&gt; используется для сопоставления всех нынешних и будущих имен пользователей в системе.</target>
        </trans-unit>
        <trans-unit id="5f782be03fcdc443b383e428fe084103c7519032" translate="yes" xml:space="preserve">
          <source>User name to connect as (not the user name to create).</source>
          <target state="translated">Имя пользователя для подключения как (не имя пользователя для создания).</target>
        </trans-unit>
        <trans-unit id="58a48e5ec3f1ddd8734180ce7a8bcf7ce3e61813" translate="yes" xml:space="preserve">
          <source>User name to connect as (not the user name to drop).</source>
          <target state="translated">Имя пользователя для подключения как (не имя пользователя,чтобы бросить).</target>
        </trans-unit>
        <trans-unit id="6c7c5d855fc83ff64eb10669f8523b7d11212f01" translate="yes" xml:space="preserve">
          <source>User name to connect as.</source>
          <target state="translated">Имя пользователя для подключения как.</target>
        </trans-unit>
        <trans-unit id="104f2eb40da0056ec5533c282848e3fce154c0c2" translate="yes" xml:space="preserve">
          <source>User name to connect as. Defaults to current operating system user name.</source>
          <target state="translated">Имя пользователя для подключения как.По умолчанию используется текущее имя пользователя операционной системы.</target>
        </trans-unit>
        <trans-unit id="d47cce93b040f97f45693a064d2ec0fe0d47cbfa" translate="yes" xml:space="preserve">
          <source>User-defined constraint triggers (created with &lt;code&gt;CREATE CONSTRAINT TRIGGER&lt;/code&gt;) also give rise to an entry in this table.</source>
          <target state="translated">Определяемые пользователем триггеры ограничения (созданные с помощью &lt;code&gt;CREATE CONSTRAINT TRIGGER&lt;/code&gt; ) также приводят к появлению записи в этой таблице.</target>
        </trans-unit>
        <trans-unit id="c0ef205df825ba4213dcb43cc225636454550c49" translate="yes" xml:space="preserve">
          <source>User-defined types</source>
          <target state="translated">Определяемые пользователем типы</target>
        </trans-unit>
        <trans-unit id="08a19bf7678e0c925ef7e00adabbc0a5965212bf" translate="yes" xml:space="preserve">
          <source>Users (roles) that are to be added to or removed from the group. The users must already exist; &lt;code&gt;ALTER GROUP&lt;/code&gt; does not create or drop users.</source>
          <target state="translated">Пользователи (роли), которых нужно добавить в группу или удалить из нее. Пользователи должны уже существовать; &lt;code&gt;ALTER GROUP&lt;/code&gt; не создает и не удаляет пользователей.</target>
        </trans-unit>
        <trans-unit id="c368e154de403e348ebf85b5c480f63c95e940b6" translate="yes" xml:space="preserve">
          <source>Users accustomed to working with other SQL database management systems might be disappointed by the performance of the &lt;code&gt;count&lt;/code&gt; aggregate when it is applied to the entire table. A query like:</source>
          <target state="translated">Пользователи, привыкшие работать с другими системами управления базами данных SQL, могут быть разочарованы производительностью агрегата &lt;code&gt;count&lt;/code&gt; когда он применяется ко всей таблице. Запрос вроде:</target>
        </trans-unit>
        <trans-unit id="ec14cfda8b568c538e7a2b35ec4764216fe766a6" translate="yes" xml:space="preserve">
          <source>Users can define their own range types. The most common reason to do this is to use ranges over subtypes not provided among the built-in range types. For example, to define a new range type of subtype &lt;code&gt;float8&lt;/code&gt;:</source>
          <target state="translated">Пользователи могут определять свои собственные типы диапазонов. Наиболее частая причина для этого - использование диапазонов над подтипами, не предусмотренных среди встроенных типов диапазонов. Например, чтобы определить новый тип диапазона подтипа &lt;code&gt;float8&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9a9efc48c7a0e88a7803961454d90d55b5ba0528" translate="yes" xml:space="preserve">
          <source>Users of a cluster do not necessarily have the privilege to access every database in the cluster. Sharing of role names means that there cannot be different roles named, say, &lt;code&gt;joe&lt;/code&gt; in two databases in the same cluster; but the system can be configured to allow &lt;code&gt;joe&lt;/code&gt; access to only some of the databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4944fa9df06f02dea3273ddeb97bb2eab5830741" translate="yes" xml:space="preserve">
          <source>Users of a cluster do not necessarily have the privilege to access every database in the cluster. Sharing of user names means that there cannot be different users named, say, &lt;code&gt;joe&lt;/code&gt; in two databases in the same cluster; but the system can be configured to allow &lt;code&gt;joe&lt;/code&gt; access to only some of the databases.</source>
          <target state="translated">Пользователи кластера не обязательно имеют право доступа к каждой базе данных в кластере. Совместное использование имен пользователей означает, что в двух базах данных одного кластера не может быть разных пользователей с именем, например, &lt;code&gt;joe&lt;/code&gt; ; но система может быть настроена так, чтобы &lt;code&gt;joe&lt;/code&gt; доступ только некоторые из баз данных.</target>
        </trans-unit>
        <trans-unit id="655defefcbd5cf77a94fb403c6b891d5f809540a" translate="yes" xml:space="preserve">
          <source>Users should be clear that tables that are regularly and heavily updated on the primary server will quickly cause cancellation of longer running queries on the standby. In such cases the setting of a finite value for &lt;code&gt;max_standby_archive_delay&lt;/code&gt; or &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; can be considered similar to setting &lt;code&gt;statement_timeout&lt;/code&gt;.</source>
          <target state="translated">Пользователи должны понимать, что таблицы, которые регулярно и сильно обновляются на первичном сервере, быстро вызовут отмену более длительных запросов на резервном. В таких случаях установка конечного значения для &lt;code&gt;max_standby_archive_delay&lt;/code&gt; или &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; может считаться аналогичной установке &lt;code&gt;statement_timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc34515c6a1d7984b3e11718da650ce1ef5ed348" translate="yes" xml:space="preserve">
          <source>Users sometimes try to declare operators applying just to a domain type. This is possible but is not nearly as useful as it might seem, because the operator resolution rules are designed to select operators applying to the domain's base type. As an example consider</source>
          <target state="translated">Иногда пользователи пытаются объявить операторы,применяемые только к типу домена.Это возможно,но не так полезно,как может показаться,поскольку правила разрешения операторов предназначены для выбора операторов,применяемых к базовому типу домена.В качестве примера рассмотрим</target>
        </trans-unit>
        <trans-unit id="1772f82727e2e70cce145a14908f76eba9dee789" translate="yes" xml:space="preserve">
          <source>Users sometimes wonder why host names are handled in this seemingly complicated way, with two name resolutions including a reverse lookup of the client's IP address. This complicates use of the feature in case the client's reverse DNS entry is not set up or yields some undesirable host name. It is done primarily for efficiency: this way, a connection attempt requires at most two resolver lookups, one reverse and one forward. If there is a resolver problem with some address, it becomes only that client's problem. A hypothetical alternative implementation that only did forward lookups would have to resolve every host name mentioned in &lt;code&gt;pg_hba.conf&lt;/code&gt; during every connection attempt. That could be quite slow if many names are listed. And if there is a resolver problem with one of the host names, it becomes everyone's problem.</source>
          <target state="translated">Пользователи иногда задаются вопросом, почему имена хостов обрабатываются таким, казалось бы, сложным способом, с двумя разрешениями имен, включая обратный поиск IP-адреса клиента. Это усложняет использование функции, если обратная запись DNS клиента не настроена или выдает нежелательное имя хоста. Это делается в первую очередь для эффективности: таким образом, попытка подключения требует не более двух поисков распознавателя, одного обратного и одного прямого. Если существует проблема решателя с каким-либо адресом, она становится проблемой только этого клиента. Гипотетическая альтернативная реализация, которая выполняет только прямой поиск, должна разрешать каждое имя хоста, указанное в &lt;code&gt;pg_hba.conf&lt;/code&gt; при каждой попытке подключения. Это может быть довольно медленным, если будет указано много имен. И если есть проблема решателя с одним из имен хостов, это становится проблемой для всех.</target>
        </trans-unit>
        <trans-unit id="4adcca052990f33f0c6c8200c5c596110e4cd88f" translate="yes" xml:space="preserve">
          <source>Users will be able to tell whether their session is read-only by issuing &lt;code&gt;SHOW transaction_read_only&lt;/code&gt;. In addition, a set of functions (&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt;) allow users to access information about the standby server. These allow you to write programs that are aware of the current state of the database. These can be used to monitor the progress of recovery, or to allow you to write complex programs that restore the database to particular states.</source>
          <target state="translated">Пользователи смогут определить, доступен ли их сеанс только для чтения, выполнив &lt;code&gt;SHOW transaction_read_only&lt;/code&gt; . Кроме того, набор функций ( &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Таблица 9.85&lt;/a&gt; ) позволяет пользователям получать доступ к информации о резервном сервере. Это позволяет вам писать программы, которые осведомлены о текущем состоянии базы данных. Их можно использовать для отслеживания процесса восстановления или для написания сложных программ, восстанавливающих базу данных до определенных состояний.</target>
        </trans-unit>
        <trans-unit id="83c06bb19535af77b0a89cf5ee576459c7758e4d" translate="yes" xml:space="preserve">
          <source>Users will be able to tell whether their session is read-only by issuing &lt;code&gt;SHOW transaction_read_only&lt;/code&gt;. In addition, a set of functions (&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.86&lt;/a&gt;) allow users to access information about the standby server. These allow you to write programs that are aware of the current state of the database. These can be used to monitor the progress of recovery, or to allow you to write complex programs that restore the database to particular states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e2bf0df748000aab563d6b102d035c272f7dd2" translate="yes" xml:space="preserve">
          <source>Users will stop waiting if a fast shutdown is requested. However, as when using asynchronous replication, the server will not fully shutdown until all outstanding WAL records are transferred to the currently connected standby servers.</source>
          <target state="translated">Пользователи перестанут ждать,если будет запрошено быстрое выключение.Однако,как и при использовании асинхронной репликации,сервер не будет полностью выключен до тех пор,пока все оставшиеся записи WAL не будут переданы на подключенные в данный момент резервные серверы.</target>
        </trans-unit>
        <trans-unit id="00379b69f39e7e2d3d7c05f05b12ede542302d0d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; on an object additionally requires &lt;code&gt;relabelfrom&lt;/code&gt; permission for the object in conjunction with its old security label and &lt;code&gt;relabelto&lt;/code&gt; permission for the object in conjunction with its new security label. (In cases where multiple label providers are installed and the user tries to set a security label, but it is not managed by SELinux, only &lt;code&gt;setattr&lt;/code&gt; should be checked here. This is currently not done due to implementation restrictions.)</source>
          <target state="translated">Использование &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; на объекте дополнительно требует разрешения &lt;code&gt;relabelfrom&lt;/code&gt; для объекта в сочетании с его старой меткой безопасности и разрешения &lt;code&gt;relabelto&lt;/code&gt; для объекта в сочетании с его новой меткой безопасности. (В случаях, когда установлено несколько поставщиков меток и пользователь пытается установить метку безопасности, но она не управляется SELinux, &lt;code&gt;setattr&lt;/code&gt; следует проверять только setattr . В настоящее время это не делается из-за ограничений реализации.)</target>
        </trans-unit>
        <trans-unit id="7ba7d6f6db215ecebd0a0dd010a3ef4d72762c57" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; on this view, specifically updating the &lt;code&gt;setting&lt;/code&gt; column, is the equivalent of issuing &lt;code&gt;SET&lt;/code&gt; commands. For example, the equivalent of</source>
          <target state="translated">Использование &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; в этом представлении, в частности, обновление столбца &lt;code&gt;setting&lt;/code&gt; , эквивалентно выдаче команд &lt;code&gt;SET&lt;/code&gt; . Например, эквивалент</target>
        </trans-unit>
        <trans-unit id="9f4a279994eeee7b66ef6f4b6c4072e3efe337a2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ALL&lt;/code&gt; for a policy means that it will apply to all commands, regardless of the type of command. If an &lt;code&gt;ALL&lt;/code&gt; policy exists and more specific policies exist, then both the &lt;code&gt;ALL&lt;/code&gt; policy and the more specific policy (or policies) will be applied. Additionally, &lt;code&gt;ALL&lt;/code&gt; policies will be applied to both the selection side of a query and the modification side, using the &lt;code&gt;USING&lt;/code&gt; expression for both cases if only a &lt;code&gt;USING&lt;/code&gt; expression has been defined.</source>
          <target state="translated">Использование &lt;code&gt;ALL&lt;/code&gt; для политики означает, что она будет применяться ко всем командам, независимо от типа команды. Если существует политика &lt;code&gt;ALL&lt;/code&gt; и более конкретные политики, то будут применяться как политика &lt;code&gt;ALL&lt;/code&gt; и более конкретная политика (или политики). Кроме того, &lt;code&gt;ALL&lt;/code&gt; политики будут применяться как к стороне выбора запроса, так и к стороне модификации, с использованием выражения &lt;code&gt;USING&lt;/code&gt; для обоих случаев, если было определено только выражение &lt;code&gt;USING&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1caa6904d1b2e3c70cf23410fccedf2e858e4cc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;DELETE&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;DELETE&lt;/code&gt; commands. Only rows that pass this policy will be seen by a &lt;code&gt;DELETE&lt;/code&gt; command. There can be rows that are visible through a &lt;code&gt;SELECT&lt;/code&gt; that are not available for deletion, if they do not pass the &lt;code&gt;USING&lt;/code&gt; expression for the &lt;code&gt;DELETE&lt;/code&gt; policy.</source>
          <target state="translated">Использование &lt;code&gt;DELETE&lt;/code&gt; для политики означает, что она будет применяться к командам &lt;code&gt;DELETE&lt;/code&gt; . Команда &lt;code&gt;DELETE&lt;/code&gt; увидит только те строки, которые соответствуют этой политике . Могут быть строки, видимые через &lt;code&gt;SELECT&lt;/code&gt; , которые недоступны для удаления, если они не передают выражение &lt;code&gt;USING&lt;/code&gt; для политики &lt;code&gt;DELETE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ba736c87dfcbb2c8e16a4a5fbcf41dc4d34ae6e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;INSERT&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;INSERT&lt;/code&gt; commands. Rows being inserted that do not pass this policy will result in a policy violation error, and the entire &lt;code&gt;INSERT&lt;/code&gt; command will be aborted. An &lt;code&gt;INSERT&lt;/code&gt; policy cannot have a &lt;code&gt;USING&lt;/code&gt; expression, as it only applies in cases where records are being added to the relation.</source>
          <target state="translated">Использование &lt;code&gt;INSERT&lt;/code&gt; для политики означает, что она будет применяться к командам &lt;code&gt;INSERT&lt;/code&gt; . Вставка строк, которые не соответствуют этой политике, приведет к ошибке нарушения политики, и вся команда &lt;code&gt;INSERT&lt;/code&gt; будет прервана. В политике &lt;code&gt;INSERT&lt;/code&gt; не может быть выражения &lt;code&gt;USING&lt;/code&gt; , поскольку оно применяется только в тех случаях, когда записи добавляются в отношение.</target>
        </trans-unit>
        <trans-unit id="4584b8b01123eb82dc7847c4d9677c40b0e5bba4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ONLY&lt;/code&gt; to add or drop a constraint on only the partitioned table is supported as long as there are no partitions. Once partitions exist, using &lt;code&gt;ONLY&lt;/code&gt; will result in an error as adding or dropping constraints on only the partitioned table, when partitions exist, is not supported. Instead, constraints on the partitions themselves can be added and (if they are not present in the parent table) dropped.</source>
          <target state="translated">Использование &lt;code&gt;ONLY&lt;/code&gt; для добавления или удаления ограничения только для многораздельной таблицы поддерживается до тех пор, пока нет разделов. Как только разделы существуют, использование &lt;code&gt;ONLY&lt;/code&gt; приведет к ошибке, поскольку добавление или удаление ограничений только для многораздельной таблицы, когда разделы существуют, не поддерживается. Вместо этого ограничения для самих разделов могут быть добавлены и (если они отсутствуют в родительской таблице) удалены.</target>
        </trans-unit>
        <trans-unit id="9191967f0b2195c21483c93a60dfe19fe3e18ef8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;PGCLIENTENCODING&lt;/code&gt;. If the environment variable &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; is defined in the client's environment, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)</source>
          <target state="translated">Использование &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; . Если переменная среды &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; определена в среде клиента, эта кодировка клиента автоматически выбирается при подключении к серверу. (Впоследствии это можно изменить с помощью любого из других методов, упомянутых выше.)</target>
        </trans-unit>
        <trans-unit id="de75f251dab5b0ad3801e8b63609c603b9f339f8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SELECT&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;SELECT&lt;/code&gt; queries and whenever &lt;code&gt;SELECT&lt;/code&gt; permissions are required on the relation the policy is defined for. The result is that only those records from the relation that pass the &lt;code&gt;SELECT&lt;/code&gt; policy will be returned during a &lt;code&gt;SELECT&lt;/code&gt; query, and that queries that require &lt;code&gt;SELECT&lt;/code&gt; permissions, such as &lt;code&gt;UPDATE&lt;/code&gt;, will also only see those records that are allowed by the &lt;code&gt;SELECT&lt;/code&gt; policy. A &lt;code&gt;SELECT&lt;/code&gt; policy cannot have a &lt;code&gt;WITH CHECK&lt;/code&gt; expression, as it only applies in cases where records are being retrieved from the relation.</source>
          <target state="translated">Использование &lt;code&gt;SELECT&lt;/code&gt; для политики означает, что она будет применяться к запросам &lt;code&gt;SELECT&lt;/code&gt; и всякий раз, когда требуются разрешения &lt;code&gt;SELECT&lt;/code&gt; для отношения, для которого определена политика. В результате во время запроса &lt;code&gt;SELECT&lt;/code&gt; будут возвращены только те записи из отношения, которые проходят политику &lt;code&gt;SELECT&lt;/code&gt; , а запросы, требующие разрешений &lt;code&gt;SELECT&lt;/code&gt; , такие как &lt;code&gt;UPDATE&lt;/code&gt; , также будут видеть только те записи, которые разрешены политикой &lt;code&gt;SELECT&lt;/code&gt; . &lt;code&gt;SELECT&lt;/code&gt; политик не может иметь &lt;code&gt;WITH CHECK&lt;/code&gt; выражения, так как оно применяется только в тех случаях , когда записи в настоящее время извлекаются из соотношения.</target>
        </trans-unit>
        <trans-unit id="8ea11f118aea185625aef767542a580e19f76285" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SET client_encoding TO&lt;/code&gt;. Setting the client encoding can be done with this SQL command:</source>
          <target state="translated">Использование &lt;code&gt;SET client_encoding TO&lt;/code&gt; . Установить клиентскую кодировку можно с помощью этой команды SQL:</target>
        </trans-unit>
        <trans-unit id="c3e9a2e659e09abe2efa2c5be22d40b62c3aee16" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Type=notify&lt;/code&gt; requires that the server binary was built with &lt;code&gt;configure --with-systemd&lt;/code&gt;.</source>
          <target state="translated">Использование &lt;code&gt;Type=notify&lt;/code&gt; требует, чтобы двоичный файл сервера был собран с помощью &lt;code&gt;configure --with-systemd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f17447546dfac5a3cba43658b86d3ae11e9f49a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;UPDATE&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; commands, as well as auxiliary &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clauses of &lt;code&gt;INSERT&lt;/code&gt; commands. Since &lt;code&gt;UPDATE&lt;/code&gt; involves pulling an existing record and replacing it with a new modified record, &lt;code&gt;UPDATE&lt;/code&gt; policies accept both a &lt;code&gt;USING&lt;/code&gt; expression and a &lt;code&gt;WITH CHECK&lt;/code&gt; expression. The &lt;code&gt;USING&lt;/code&gt; expression determines which records the &lt;code&gt;UPDATE&lt;/code&gt; command will see to operate against, while the &lt;code&gt;WITH CHECK&lt;/code&gt; expression defines which modified rows are allowed to be stored back into the relation.</source>
          <target state="translated">Использование &lt;code&gt;UPDATE&lt;/code&gt; для политики означает , что он будет применяться к &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; и &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; команды, а также вспомогательные &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; положений &lt;code&gt;INSERT&lt;/code&gt; команд. Поскольку &lt;code&gt;UPDATE&lt;/code&gt; включает извлечение существующей записи и замену ее новой измененной записью, политики &lt;code&gt;UPDATE&lt;/code&gt; принимают как выражение &lt;code&gt;USING&lt;/code&gt; ,так и выражение &lt;code&gt;WITH CHECK&lt;/code&gt; . В &lt;code&gt;USING&lt;/code&gt; выражения определяет , который записывает &lt;code&gt;UPDATE&lt;/code&gt; команды будет видеть , чтобы действовать против, в то время как &lt;code&gt;WITH CHECK&lt;/code&gt; Выражение определяет, какие измененные строки могут быть сохранены обратно в отношение.</target>
        </trans-unit>
        <trans-unit id="4872b905960b3b0bb609a1d1f16d8a8085172d7f" translate="yes" xml:space="preserve">
          <source>Using WAL results in a significantly reduced number of disk writes, because only the log file needs to be flushed to disk to guarantee that a transaction is committed, rather than every data file changed by the transaction. The log file is written sequentially, and so the cost of syncing the log is much less than the cost of flushing the data pages. This is especially true for servers handling many small transactions touching different parts of the data store. Furthermore, when the server is processing many small concurrent transactions, one &lt;code&gt;fsync&lt;/code&gt; of the log file may suffice to commit many transactions.</source>
          <target state="translated">Использование WAL приводит к значительному сокращению количества операций записи на диск, потому что для гарантии подтверждения транзакции на диск необходимо сбрасывать только файл журнала, а не каждый файл данных, измененный транзакцией. Файл журнала записывается последовательно, поэтому стоимость синхронизации журнала намного меньше, чем стоимость очистки страниц данных. Это особенно верно для серверов, обрабатывающих множество мелких транзакций, затрагивающих разные части хранилища данных. Более того, когда сервер обрабатывает много небольших одновременных транзакций, одной &lt;code&gt;fsync&lt;/code&gt; файла журнала может хватить для фиксации множества транзакций.</target>
        </trans-unit>
        <trans-unit id="c4792021563cf0153c3bbaaa6301ad807dbacef8" translate="yes" xml:space="preserve">
          <source>Using a SHA hash function provides a cryptographically secure digest of each file for users who wish to verify that the backup has not been tampered with, while the CRC32C algorithm provides a checksum that is much faster to calculate; it is good at catching errors due to accidental changes but is not resistant to malicious modifications. Note that, to be useful against an adversary who has access to the backup, the backup manifest would need to be stored securely elsewhere or otherwise verified not to have been modified since the backup was taken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e62e4e51350449dc0eec4f1e12ec4aa76a1f3f9" translate="yes" xml:space="preserve">
          <source>Using a separate script file is advisable any time you want to use more than a single command in the archiving process. This allows all complexity to be managed within the script, which can be written in a popular scripting language such as bash or perl.</source>
          <target state="translated">Использование отдельного файла скрипта рекомендуется в любое время,когда вы хотите использовать более одной команды в процессе архивирования.Это позволяет управлять любой сложностью внутри скрипта,который может быть написан на популярном скриптовом языке,таком как bash или perl.</target>
        </trans-unit>
        <trans-unit id="b28cc95da9f9c8ec1f9441e5caff1c654ea239b4" translate="yes" xml:space="preserve">
          <source>Using a simple integer &lt;code&gt;offset&lt;/code&gt; is preferred when defining an abbreviation whose offset from UTC has never changed, as such abbreviations are much cheaper to process than those that require consulting a time zone definition.</source>
          <target state="translated">Использование простого целочисленного &lt;code&gt;offset&lt;/code&gt; предпочтительно при определении аббревиатуры, смещение которой относительно UTC никогда не менялось, поскольку такие сокращения намного дешевле обрабатывать, чем те, которые требуют консультации с определением часового пояса.</target>
        </trans-unit>
        <trans-unit id="d159535298801ecd67e86d11daf24d3f29bae4e5" translate="yes" xml:space="preserve">
          <source>Using a table:</source>
          <target state="translated">Используя стол:</target>
        </trans-unit>
        <trans-unit id="97a7d609ae1fc837ff854c4a8fe8b3cbd1349e8b" translate="yes" xml:space="preserve">
          <source>Using an existing graphical frontend tool like pgAdmin or an office suite with ODBC or JDBC support to create and manipulate a database. These possibilities are not covered in this tutorial.</source>
          <target state="translated">Используя существующий графический инструмент фронтенда,такой как pgAdmin или офисный пакет с поддержкой ODBC или JDBC,для создания и манипулирования базой данных.Эти возможности не рассматриваются в данном учебном пособии.</target>
        </trans-unit>
        <trans-unit id="9b0ce3043e87fd971bf85082c10b3ea412051c05" translate="yes" xml:space="preserve">
          <source>Using filter expressions at different nesting levels is also allowed. The following example first filters all segments by location, and then returns high heart rate values for these segments, if available:</source>
          <target state="translated">Также допускается использование выражений фильтров на различных уровнях вложенности.Следующий пример сначала фильтрует все сегменты по местоположению,а затем возвращает высокие значения пульса для этих сегментов,если они доступны:</target>
        </trans-unit>
        <trans-unit id="3f87542d489a5d09a003c3d32c1fdd090240fb1a" translate="yes" xml:space="preserve">
          <source>Using huge pages reduces overhead when using large contiguous chunks of memory, as PostgreSQL does, particularly when using large values of &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;. To use this feature in PostgreSQL you need a kernel with &lt;code&gt;CONFIG_HUGETLBFS=y&lt;/code&gt; and &lt;code&gt;CONFIG_HUGETLB_PAGE=y&lt;/code&gt;. You will also have to adjust the kernel setting &lt;code&gt;vm.nr_hugepages&lt;/code&gt;. To estimate the number of huge pages needed, start PostgreSQL without huge pages enabled and check the postmaster's anonymous shared memory segment size, as well as the system's huge page size, using the &lt;code&gt;/proc&lt;/code&gt; file system. This might look like:</source>
          <target state="translated">Использование огромных страниц снижает накладные расходы при использовании больших непрерывных фрагментов памяти, как это делает PostgreSQL, особенно при использовании больших значений &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; . Чтобы использовать эту функцию в PostgreSQL, вам необходимо ядро ​​с &lt;code&gt;CONFIG_HUGETLBFS=y&lt;/code&gt; и &lt;code&gt;CONFIG_HUGETLB_PAGE=y&lt;/code&gt; . Вам также необходимо изменить настройку ядра &lt;code&gt;vm.nr_hugepages&lt;/code&gt; . Чтобы оценить количество необходимых огромных страниц, запустите PostgreSQL без включения огромных страниц и проверьте размер сегмента анонимной разделяемой памяти постмастера, а также огромный размер страницы системы, используя файловую систему &lt;code&gt;/proc&lt;/code&gt; . Это может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="c0f4579fb33ddb8969cb60774c58272e5c781549" translate="yes" xml:space="preserve">
          <source>Using just common sense, it appears more convenient to store such data as intervals, rather than pairs of numbers. In practice, it even turns out more efficient in most applications.</source>
          <target state="translated">Используя здравый смысл,представляется более удобным хранить такие данные,как интервалы,а не пары чисел.На практике это даже оказывается более эффективным в большинстве приложений.</target>
        </trans-unit>
        <trans-unit id="a8fc95773ce3956bab8c2e8bf2027d9e849d1b1f" translate="yes" xml:space="preserve">
          <source>Using psql on a recently vacuumed or analyzed database, you can issue queries to see the disk usage of any table:</source>
          <target state="translated">Используя psql на недавно вакуумированной или анализируемой базе данных,вы можете делать запросы,чтобы увидеть использование диска в любой таблице:</target>
        </trans-unit>
        <trans-unit id="65181e02239e5820a5b7c0dec699536af98e9eef" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;CASCADE&lt;/code&gt; option might make the command recurse to objects owned by other users.</source>
          <target state="translated">Использование опции &lt;code&gt;CASCADE&lt;/code&gt; может сделать команду рекурсивной для объектов, принадлежащих другим пользователям.</target>
        </trans-unit>
        <trans-unit id="a3919689ac7e30c1a7b51bdbeb0b298903ed7b06" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;CASCADE&lt;/code&gt; option might make the command remove objects in other schemas besides the one(s) named.</source>
          <target state="translated">Использование опции &lt;code&gt;CASCADE&lt;/code&gt; может заставить команду удалить объекты в других схемах, кроме названных.</target>
        </trans-unit>
        <trans-unit id="9d956f8965b7e70f75d823768214bbad6a425210" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;\encoding&lt;/code&gt; command in psql. &lt;code&gt;\encoding&lt;/code&gt; allows you to change client encoding on the fly. For example, to change the encoding to &lt;code&gt;SJIS&lt;/code&gt;, type:</source>
          <target state="translated">Используя команду &lt;code&gt;\encoding&lt;/code&gt; в psql. &lt;code&gt;\encoding&lt;/code&gt; позволяет вам на лету изменять клиентскую кодировку. Например, чтобы изменить кодировку на &lt;code&gt;SJIS&lt;/code&gt; , введите:</target>
        </trans-unit>
        <trans-unit id="ce95ab1950e8fbb1a63e8b189b58b6a856d611e2" translate="yes" xml:space="preserve">
          <source>Using the configuration variable &lt;a href=&quot;runtime-config-client#GUC-CLIENT-ENCODING&quot;&gt;client_encoding&lt;/a&gt;. If the &lt;code&gt;client_encoding&lt;/code&gt; variable is set, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)</source>
          <target state="translated">Используя конфигурационную переменную &lt;a href=&quot;runtime-config-client#GUC-CLIENT-ENCODING&quot;&gt;client_encoding&lt;/a&gt; . Если &lt;code&gt;client_encoding&lt;/code&gt; переменная client_encoding , эта клиентская кодировка автоматически выбирается при подключении к серверу. (Впоследствии это можно изменить с помощью любого из других методов, упомянутых выше.)</target>
        </trans-unit>
        <trans-unit id="7b44d852d97da519564a9d99f8e49c858203cdb6" translate="yes" xml:space="preserve">
          <source>Using the operators &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, and &lt;code&gt;EXCEPT&lt;/code&gt;, the output of more than one &lt;code&gt;SELECT&lt;/code&gt; statement can be combined to form a single result set. The &lt;code&gt;UNION&lt;/code&gt; operator returns all rows that are in one or both of the result sets. The &lt;code&gt;INTERSECT&lt;/code&gt; operator returns all rows that are strictly in both result sets. The &lt;code&gt;EXCEPT&lt;/code&gt; operator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unless &lt;code&gt;ALL&lt;/code&gt; is specified. The noise word &lt;code&gt;DISTINCT&lt;/code&gt; can be added to explicitly specify eliminating duplicate rows. Notice that &lt;code&gt;DISTINCT&lt;/code&gt; is the default behavior here, even though &lt;code&gt;ALL&lt;/code&gt; is the default for &lt;code&gt;SELECT&lt;/code&gt; itself. (See &lt;a href=&quot;sql-select#SQL-UNION&quot;&gt;&lt;code&gt;UNION&lt;/code&gt; Clause&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt;&lt;code&gt;INTERSECT&lt;/code&gt; Clause&lt;/a&gt;, and &lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt;&lt;code&gt;EXCEPT&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">Используя операторы &lt;code&gt;UNION&lt;/code&gt; , &lt;code&gt;INTERSECT&lt;/code&gt; и &lt;code&gt;EXCEPT&lt;/code&gt; , выходные данные нескольких &lt;code&gt;SELECT&lt;/code&gt; могут быть объединены в единый набор результатов. Оператор &lt;code&gt;UNION&lt;/code&gt; возвращает все строки, которые находятся в одном или обоих наборах результатов. Оператор &lt;code&gt;INTERSECT&lt;/code&gt; возвращает все строки, которые находятся строго в обоих наборах результатов. Оператор &lt;code&gt;EXCEPT&lt;/code&gt; возвращает строки, которые находятся в первом наборе результатов, но не во втором. Во всех трех случаях повторяющиеся строки удаляются, если не указано &lt;code&gt;ALL&lt;/code&gt; . Шумовое слово &lt;code&gt;DISTINCT&lt;/code&gt; можно добавить, чтобы явно указать удаление повторяющихся строк. Обратите внимание, что &lt;code&gt;DISTINCT&lt;/code&gt; - это поведение по умолчанию здесь, хотя &lt;code&gt;ALL&lt;/code&gt; является значением по умолчанию для самого &lt;code&gt;SELECT&lt;/code&gt; . (См &lt;a href=&quot;sql-select#SQL-UNION&quot;&gt; &lt;code&gt;UNION&lt;/code&gt; пункт&lt;/a&gt; , &lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt; &lt;code&gt;INTERSECT&lt;/code&gt; пункт&lt;/a&gt; , а &lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt; &lt;code&gt;EXCEPT&lt;/code&gt; пункт&lt;/a&gt; ниже) .</target>
        </trans-unit>
        <trans-unit id="60ff87ccea487ea3e7de59df62d12a0091443a0c" translate="yes" xml:space="preserve">
          <source>Using the operators &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, and &lt;code&gt;EXCEPT&lt;/code&gt;, the output of more than one &lt;code&gt;SELECT&lt;/code&gt; statement can be combined to form a single result set. The &lt;code&gt;UNION&lt;/code&gt; operator returns all rows that are in one or both of the result sets. The &lt;code&gt;INTERSECT&lt;/code&gt; operator returns all rows that are strictly in both result sets. The &lt;code&gt;EXCEPT&lt;/code&gt; operator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unless &lt;code&gt;ALL&lt;/code&gt; is specified. The noise word &lt;code&gt;DISTINCT&lt;/code&gt; can be added to explicitly specify eliminating duplicate rows. Notice that &lt;code&gt;DISTINCT&lt;/code&gt; is the default behavior here, even though &lt;code&gt;ALL&lt;/code&gt; is the default for &lt;code&gt;SELECT&lt;/code&gt; itself. (See &lt;a href=&quot;sql-select#SQL-UNION&quot;&gt;UNION Clause&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt;INTERSECT Clause&lt;/a&gt;, and &lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt;EXCEPT Clause&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345d4ccffce95dcf05491c18eea8197735fd71fd" translate="yes" xml:space="preserve">
          <source>Using this command, it is possible to either add privileges or restrict one's privileges. If the session user role has the &lt;code&gt;INHERIT&lt;/code&gt; attribute, then it automatically has all the privileges of every role that it could &lt;code&gt;SET ROLE&lt;/code&gt; to; in this case &lt;code&gt;SET ROLE&lt;/code&gt; effectively drops all the privileges assigned directly to the session user and to the other roles it is a member of, leaving only the privileges available to the named role. On the other hand, if the session user role has the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute, &lt;code&gt;SET ROLE&lt;/code&gt; drops the privileges assigned directly to the session user and instead acquires the privileges available to the named role.</source>
          <target state="translated">Используя эту команду, можно либо добавить привилегии, либо ограничить свои привилегии. Если роль пользователя сеанса имеет атрибут &lt;code&gt;INHERIT&lt;/code&gt; , то она автоматически получает все привилегии каждой роли, для которой она может &lt;code&gt;SET ROLE&lt;/code&gt; ; в этом случае &lt;code&gt;SET ROLE&lt;/code&gt; эффективно отбрасывает все привилегии, назначенные непосредственно пользователю сеанса и другим ролям, членом которых он является, оставляя только привилегии, доступные для указанной роли. С другой стороны, если роль пользователя сеанса имеет атрибут &lt;code&gt;NOINHERIT&lt;/code&gt; , &lt;code&gt;SET ROLE&lt;/code&gt; ROLE отбрасывает привилегии, назначенные непосредственно пользователю сеанса, и вместо этого получает привилегии, доступные для указанной роли.</target>
        </trans-unit>
        <trans-unit id="bf3833196f5808681a4549e6dae3e11c17ff7d14" translate="yes" xml:space="preserve">
          <source>Using this option is subtly different from writing &lt;code&gt;psql &amp;lt; filename&lt;/code&gt;. In general, both will do what you expect, but using &lt;code&gt;-f&lt;/code&gt; enables some nice features such as error messages with line numbers. There is also a slight chance that using this option will reduce the start-up overhead. On the other hand, the variant using the shell's input redirection is (in theory) guaranteed to yield exactly the same output you would have received had you entered everything by hand.</source>
          <target state="translated">Использование этой опции немного отличается от записи &lt;code&gt;psql &amp;lt; filename&lt;/code&gt; . В общем, оба будут делать то, что вы ожидаете, но использование &lt;code&gt;-f&lt;/code&gt; включает некоторые полезные функции, такие как сообщения об ошибках с номерами строк. Также существует небольшая вероятность того, что использование этой опции снизит затраты на запуск. С другой стороны, вариант, использующий перенаправление ввода оболочки (теоретически), гарантированно даст точно такой же результат, который вы получили бы, если бы вводили все вручную.</target>
        </trans-unit>
        <trans-unit id="bb94658d71fedbd45e9091422be0f40e3960ad97" translate="yes" xml:space="preserve">
          <source>Usually, a row reflecting an incorrect entry will have values for only the &lt;code&gt;line_number&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; fields.</source>
          <target state="translated">Обычно строка, отражающая неправильную запись, будет иметь значения только для &lt;code&gt;line_number&lt;/code&gt; и &lt;code&gt;error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a83488e309bcd16565cc48e7357404309c680f8" translate="yes" xml:space="preserve">
          <source>VACUUM</source>
          <target state="translated">VACUUM</target>
        </trans-unit>
        <trans-unit id="615ff5ce2e5448f0eae82299f9e03df2b83f7a7d" translate="yes" xml:space="preserve">
          <source>VACUUM &amp;mdash; garbage-collect and optionally analyze a database</source>
          <target state="translated">VACUUM - сбор мусора и, при необходимости, анализ базы данных</target>
        </trans-unit>
        <trans-unit id="b3cba55338b3625665f9ea5a7e33ff9db26da1af" translate="yes" xml:space="preserve">
          <source>VALUES</source>
          <target state="translated">VALUES</target>
        </trans-unit>
        <trans-unit id="7e2bb4ebd8bb3d86c6acc1d3b34b4607a8278459" translate="yes" xml:space="preserve">
          <source>VALUES &amp;mdash; compute a set of rows</source>
          <target state="translated">ЗНАЧЕНИЯ - вычислить набор строк</target>
        </trans-unit>
        <trans-unit id="df605145d9028810fbbd6bb82ba2cbbdf49fe2f6" translate="yes" xml:space="preserve">
          <source>VALUES Lists</source>
          <target state="translated">ЦЕНЫ</target>
        </trans-unit>
        <trans-unit id="5fe15df2c7882707d49fdc0903788dfd022b02ca" translate="yes" xml:space="preserve">
          <source>Vacuum</source>
          <target state="translated">Vacuum</target>
        </trans-unit>
        <trans-unit id="49310dbe4a27690da5f29db4c406ef0b0e02e27a" translate="yes" xml:space="preserve">
          <source>Vacuum all databases.</source>
          <target state="translated">Вакуумируйте все базы данных.</target>
        </trans-unit>
        <trans-unit id="d78bc05489ae0681fdd181a90fe2d3af72c88331" translate="yes" xml:space="preserve">
          <source>Vacuum all four standard tables before running the test. With neither &lt;code&gt;-n&lt;/code&gt; nor &lt;code&gt;-v&lt;/code&gt;, pgbench will vacuum the &lt;code&gt;pgbench_tellers&lt;/code&gt; and &lt;code&gt;pgbench_branches&lt;/code&gt; tables, and will truncate &lt;code&gt;pgbench_history&lt;/code&gt;.</source>
          <target state="translated">Пропылесосьте все четыре стандартных стола перед запуском теста. Без &lt;code&gt;-n&lt;/code&gt; и &lt;code&gt;-v&lt;/code&gt; pgbench &lt;code&gt;pgbench_branches&lt;/code&gt; таблицы &lt;code&gt;pgbench_tellers&lt;/code&gt; и pgbench_branches и &lt;code&gt;pgbench_history&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="558c7ef6cec7040888bc23237bf5bc10ac6c115d" translate="yes" xml:space="preserve">
          <source>Vacuum also allows removal of old files from the &lt;code&gt;pg_xact&lt;/code&gt; subdirectory, which is why the default is a relatively low 200 million transactions. This parameter can only be set at server start, but the setting can be reduced for individual tables by changing table storage parameters. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;.</source>
          <target state="translated">Vacuum также позволяет удалять старые файлы из подкаталога &lt;code&gt;pg_xact&lt;/code&gt; , поэтому по умолчанию используется относительно низкий уровень в 200 миллионов транзакций. Этот параметр можно установить только при запуске сервера, но для отдельных таблиц его можно уменьшить, изменив параметры хранения таблиц. Для получения дополнительной информации см. &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Раздел 24.1.5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4af123f2e65a46f53e9a9ee64ca03a1079be929" translate="yes" xml:space="preserve">
          <source>Vacuum maintains a &lt;a href=&quot;storage-vm&quot;&gt;visibility map&lt;/a&gt; for each table to keep track of which pages contain only tuples that are known to be visible to all active transactions (and all future transactions, until the page is again modified). This has two purposes. First, vacuum itself can skip such pages on the next run, since there is nothing to clean up.</source>
          <target state="translated">Vacuum поддерживает &lt;a href=&quot;storage-vm&quot;&gt;карту видимости&lt;/a&gt; для каждой таблицы, чтобы отслеживать, какие страницы содержат только кортежи, о которых известно, что они видны всем активным транзакциям (и всем будущим транзакциям, пока страница не будет снова изменена). Это преследует две цели. Во-первых, сам пылесос может пропустить такие страницы при следующем запуске, так как убирать нечего.</target>
        </trans-unit>
        <trans-unit id="8fb0ba1bca8b404cfdbdb7679f9f4d296fc6f1fa" translate="yes" xml:space="preserve">
          <source>Vacuuming multixacts also allows removal of old files from the &lt;code&gt;pg_multixact/members&lt;/code&gt; and &lt;code&gt;pg_multixact/offsets&lt;/code&gt; subdirectories, which is why the default is a relatively low 400 million multixacts. This parameter can only be set at server start, but the setting can be reduced for individual tables by changing table storage parameters. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Section 24.1.5.1&lt;/a&gt;.</source>
          <target state="translated">Очистка мультиактов также позволяет удалять старые файлы из &lt;code&gt;pg_multixact/members&lt;/code&gt; и &lt;code&gt;pg_multixact/offsets&lt;/code&gt; , поэтому по умолчанию используется относительно низкий уровень в 400 миллионов мультиактов. Этот параметр можно установить только при запуске сервера, но для отдельных таблиц его можно уменьшить, изменив параметры хранения таблиц. Для получения дополнительной информации см. &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Раздел 24.1.5.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac19d033655fd012b97b53639462b257da978e6a" translate="yes" xml:space="preserve">
          <source>Valid Types</source>
          <target state="translated">допустимые типы</target>
        </trans-unit>
        <trans-unit id="c7e5f1bbc3dc93b5ff6072a3bc81757a3ed075d7" translate="yes" xml:space="preserve">
          <source>Valid input for the time stamp types consists of the concatenation of a date and a time, followed by an optional time zone, followed by an optional &lt;code&gt;AD&lt;/code&gt; or &lt;code&gt;BC&lt;/code&gt;. (Alternatively, &lt;code&gt;AD&lt;/code&gt;/&lt;code&gt;BC&lt;/code&gt; can appear before the time zone, but this is not the preferred ordering.) Thus:</source>
          <target state="translated">Допустимый ввод для типов отметок времени состоит из конкатенации даты и времени, за которыми следует необязательный часовой пояс, за которым следует необязательный &lt;code&gt;AD&lt;/code&gt; или &lt;code&gt;BC&lt;/code&gt; . (В качестве альтернативы, &lt;code&gt;AD&lt;/code&gt; / &lt;code&gt;BC&lt;/code&gt; может стоять перед часовым поясом, но это не является предпочтительным порядком.) Таким образом:</target>
        </trans-unit>
        <trans-unit id="c3fd0054c277594413eaed1c75df986510128d67" translate="yes" xml:space="preserve">
          <source>Valid input for these types consists of a time of day followed by an optional time zone. (See &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TIME-TABLE&quot;&gt;Table 8.11&lt;/a&gt; and &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONE-TABLE&quot;&gt;Table 8.12&lt;/a&gt;.) If a time zone is specified in the input for &lt;code&gt;time without time zone&lt;/code&gt;, it is silently ignored. You can also specify a date but it will be ignored, except when you use a time zone name that involves a daylight-savings rule, such as &lt;code&gt;America/New_York&lt;/code&gt;. In this case specifying the date is required in order to determine whether standard or daylight-savings time applies. The appropriate time zone offset is recorded in the &lt;code&gt;time with time zone&lt;/code&gt; value.</source>
          <target state="translated">Допустимый ввод для этих типов состоит из времени дня, за которым следует необязательный часовой пояс. (См. &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TIME-TABLE&quot;&gt;Таблицу 8.11&lt;/a&gt; и &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONE-TABLE&quot;&gt;Таблицу 8.12&lt;/a&gt; .) Если часовой пояс указан во входных данных для &lt;code&gt;time without time zone&lt;/code&gt; , он автоматически игнорируется. Вы также можете указать дату, но она будет проигнорирована, за исключением случаев, когда вы используете название часового пояса, которое включает правило перехода на летнее время, например &lt;code&gt;America/New_York&lt;/code&gt; . В этом случае необходимо указать дату, чтобы определить, применяется ли стандартное или летнее время. Соответствующее смещение часового пояса записывается во &lt;code&gt;time with time zone&lt;/code&gt; значением часового пояса .</target>
        </trans-unit>
        <trans-unit id="844edfde8ce5da216439f5cc862b141254fb9d4a" translate="yes" xml:space="preserve">
          <source>Valid memory units are &lt;code&gt;B&lt;/code&gt; (bytes), &lt;code&gt;kB&lt;/code&gt; (kilobytes), &lt;code&gt;MB&lt;/code&gt; (megabytes), &lt;code&gt;GB&lt;/code&gt; (gigabytes), and &lt;code&gt;TB&lt;/code&gt; (terabytes). The multiplier for memory units is 1024, not 1000.</source>
          <target state="translated">Допустимые единицы памяти: &lt;code&gt;B&lt;/code&gt; (байты), &lt;code&gt;kB&lt;/code&gt; (килобайты), &lt;code&gt;MB&lt;/code&gt; (мегабайты), &lt;code&gt;GB&lt;/code&gt; (гигабайты) и &lt;code&gt;TB&lt;/code&gt; (терабайты). Множитель для блоков памяти 1024, а не 1000.</target>
        </trans-unit>
        <trans-unit id="239bf25206857881980ea876d3982e5ae2994831" translate="yes" xml:space="preserve">
          <source>Valid starting points for standby queries are generated at each checkpoint on the master. If the standby is shut down while the master is in a shutdown state, it might not be possible to re-enter Hot Standby until the primary is started up, so that it generates further starting points in the WAL logs. This situation isn't a problem in the most common situations where it might happen. Generally, if the primary is shut down and not available anymore, that's likely due to a serious failure that requires the standby being converted to operate as the new primary anyway. And in situations where the primary is being intentionally taken down, coordinating to make sure the standby becomes the new primary smoothly is also standard procedure.</source>
          <target state="translated">На каждой контрольной точке ведущего устройства генерируются достоверные отправные точки для резервных запросов.Если режим ожидания отключен,пока мастер находится в выключенном состоянии,то повторный вход в режим &quot;горячего ожидания&quot; может быть невозможен до тех пор,пока не будет запущен первичный,так что он будет генерировать дальнейшие стартовые точки в журналах WAL.Эта ситуация не является проблемой в наиболее распространенных ситуациях,где это может произойти.Обычно,если первичное устройство отключено и больше не доступно,это,скорее всего,связано с серьезным сбоем,который требует,чтобы резервное устройство было преобразовано для работы в качестве нового первичного устройства в любом случае.А в ситуациях,когда первичное устройство преднамеренно выводится из строя,координация действий для того,чтобы резервное устройство стало новым первичным устройством,также является стандартной процедурой.</target>
        </trans-unit>
        <trans-unit id="36d562c59f538b4cf6287a1bc49b7023b220600a" translate="yes" xml:space="preserve">
          <source>Valid time units are &lt;code&gt;us&lt;/code&gt; (microseconds), &lt;code&gt;ms&lt;/code&gt; (milliseconds), &lt;code&gt;s&lt;/code&gt; (seconds), &lt;code&gt;min&lt;/code&gt; (minutes), &lt;code&gt;h&lt;/code&gt; (hours), and &lt;code&gt;d&lt;/code&gt; (days).</source>
          <target state="translated">Допустимые единицы времени: &lt;code&gt;us&lt;/code&gt; (микросекунды), &lt;code&gt;ms&lt;/code&gt; (миллисекунды), &lt;code&gt;s&lt;/code&gt; (секунды), &lt;code&gt;min&lt;/code&gt; (минуты), &lt;code&gt;h&lt;/code&gt; (часы) и &lt;code&gt;d&lt;/code&gt; (дни).</target>
        </trans-unit>
        <trans-unit id="dfda311a4ab9af803299c88d82467b20a4636196" translate="yes" xml:space="preserve">
          <source>Valid values for &lt;code&gt;field&lt;/code&gt; are:</source>
          <target state="translated">Допустимые значения для &lt;code&gt;field&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="10d7649316ac64615f5264b37dbb56375dda92e2" translate="yes" xml:space="preserve">
          <source>Valid variable names can contain letters, digits, and underscores. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below for details. Variable names are case-sensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e71de8159ccd805dfaf84c4abe0cc37c7fd0bef" translate="yes" xml:space="preserve">
          <source>Valid variable names can contain letters, digits, and underscores. See the section &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below for details. Variable names are case-sensitive.</source>
          <target state="translated">Допустимые имена переменных могут содержать буквы, цифры и символы подчеркивания. Подробнее см. В разделе &amp;laquo; &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Переменные&amp;raquo;&lt;/a&gt; ниже. Имена переменных чувствительны к регистру.</target>
        </trans-unit>
        <trans-unit id="6495bdc388499bc5f8ab2cec7e4d413da357e199" translate="yes" xml:space="preserve">
          <source>Validate the catalog entries for the specified operator class, so far as the access method can reasonably do that. For example, this might include testing that all required support functions are provided. The &lt;code&gt;amvalidate&lt;/code&gt; function must return false if the opclass is invalid. Problems should be reported with &lt;code&gt;ereport&lt;/code&gt; messages.</source>
          <target state="translated">Проверьте записи каталога для указанного класса операторов, если метод доступа может это сделать. Например, это может включать тестирование того, что все необходимые функции поддержки предоставляются. Функция &lt;code&gt;amvalidate&lt;/code&gt; должна возвращать false, если класс операции недействителен. О проблемах следует сообщать с помощью электронных &lt;code&gt;ereport&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89711f6e0ac15ee4534c22e657dbb299816df29f" translate="yes" xml:space="preserve">
          <source>Validates an invalid number (clears the invalid flag)</source>
          <target state="translated">Проверяет недействительное число (снимает флаг недействительности).</target>
        </trans-unit>
        <trans-unit id="589311b6a2805b6a0281872c806ce0f19f6dd7a2" translate="yes" xml:space="preserve">
          <source>Validates an invalid number (clears the invalid flag).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a914a2300c495dde9a239ee72a952fef70648b1b" translate="yes" xml:space="preserve">
          <source>Value Example</source>
          <target state="translated">Пример значения</target>
        </trans-unit>
        <trans-unit id="892634b1322b72a29145754cdb909390816e79df" translate="yes" xml:space="preserve">
          <source>Value Expressions</source>
          <target state="translated">Выражения ценностей</target>
        </trans-unit>
        <trans-unit id="b69a17e345014c4860d42b3ea12bfd1d74a98205" translate="yes" xml:space="preserve">
          <source>Value Expressions: Aggregate Expressions</source>
          <target state="translated">Выражения ценностей:Совокупность выражений</target>
        </trans-unit>
        <trans-unit id="62258d667ea100846bebdafcf33e6ba0d80bc0cf" translate="yes" xml:space="preserve">
          <source>Value Expressions: Array Constructors</source>
          <target state="translated">Выражения ценностей:Массивные конструкторы</target>
        </trans-unit>
        <trans-unit id="538d0773b42800a1dced9ebd66981d039270223a" translate="yes" xml:space="preserve">
          <source>Value Expressions: Collation Expressions</source>
          <target state="translated">Выражения ценностей:Выражения сравнения</target>
        </trans-unit>
        <trans-unit id="09b3d5a6d9bce4eae0f96433329fd2780b515b1d" translate="yes" xml:space="preserve">
          <source>Value Expressions: Column References</source>
          <target state="translated">Выражения ценностей:Ссылки на колонку</target>
        </trans-unit>
        <trans-unit id="0f5899e3893a9e71da04384ff81d2b0668b66cce" translate="yes" xml:space="preserve">
          <source>Value Expressions: Expression Evaluation Rules</source>
          <target state="translated">Выражения ценностей:Правила оценки выражений</target>
        </trans-unit>
        <trans-unit id="7a33243a5a764268dbc19c7b5d5ffb815f2b2494" translate="yes" xml:space="preserve">
          <source>Value Expressions: Field Selection</source>
          <target state="translated">Выражения ценностей:Выбор поля</target>
        </trans-unit>
        <trans-unit id="fc2734409ea30f439f8007a816c89fd5d4964498" translate="yes" xml:space="preserve">
          <source>Value Expressions: Function Calls</source>
          <target state="translated">Выражения ценностей:Вызовы функций</target>
        </trans-unit>
        <trans-unit id="06ab5a8d541c803b5a6f5f5baa72444250b7d0c9" translate="yes" xml:space="preserve">
          <source>Value Expressions: Operator Invocations</source>
          <target state="translated">Выражения ценностей:Вызовы оператора</target>
        </trans-unit>
        <trans-unit id="e5f7f7098e87803a977afb22b3e716623af90f8e" translate="yes" xml:space="preserve">
          <source>Value Expressions: Positional Parameters</source>
          <target state="translated">Выражения ценностей:Позиционные параметры</target>
        </trans-unit>
        <trans-unit id="c58f459ac2b52cf9d74d05fef53f0cf74dcac929" translate="yes" xml:space="preserve">
          <source>Value Expressions: Row Constructors</source>
          <target state="translated">Выражения ценностей:Строители рядов</target>
        </trans-unit>
        <trans-unit id="2c538998fa55638c7ded3a8a283b8e9feb0bd885" translate="yes" xml:space="preserve">
          <source>Value Expressions: Scalar Subqueries</source>
          <target state="translated">Выражения ценностей:Скалярные подзапросы</target>
        </trans-unit>
        <trans-unit id="1da69c14dd40700afb2c0a8abd86f7b740450e6f" translate="yes" xml:space="preserve">
          <source>Value Expressions: Subscripts</source>
          <target state="translated">Выражения ценностей:Подписки</target>
        </trans-unit>
        <trans-unit id="cccb4f69d3a8cb038ef6a413bb2c663923cd9fc0" translate="yes" xml:space="preserve">
          <source>Value Expressions: Type Casts</source>
          <target state="translated">Выражения ценностей:Литые заготовки</target>
        </trans-unit>
        <trans-unit id="3715da19fdcfeeba7fe50bb93e020a8b25f6a530" translate="yes" xml:space="preserve">
          <source>Value Expressions: Window Function Calls</source>
          <target state="translated">Выражения ценностей:Вызовы функций окна</target>
        </trans-unit>
        <trans-unit id="bf4f8a0decbb4b4fd4371821f1c74ba9a1594ce9" translate="yes" xml:space="preserve">
          <source>Value Storage</source>
          <target state="translated">Хранение ценностей</target>
        </trans-unit>
        <trans-unit id="2977eb7ab7cb1230619c6002ed4cbbc6cc756fa6" translate="yes" xml:space="preserve">
          <source>Value expressions are used in a variety of contexts, such as in the target list of the &lt;code&gt;SELECT&lt;/code&gt; command, as new column values in &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;, or in search conditions in a number of commands. The result of a value expression is sometimes called a &lt;em&gt;scalar&lt;/em&gt;, to distinguish it from the result of a table expression (which is a table). Value expressions are therefore also called &lt;em&gt;scalar expressions&lt;/em&gt; (or even simply &lt;em&gt;expressions&lt;/em&gt;). The expression syntax allows the calculation of values from primitive parts using arithmetic, logical, set, and other operations.</source>
          <target state="translated">Выражения значений используются в различных контекстах, например, в целевом списке команды &lt;code&gt;SELECT&lt;/code&gt; , в качестве новых значений столбцов в &lt;code&gt;INSERT&lt;/code&gt; или &lt;code&gt;UPDATE&lt;/code&gt; или в условиях поиска в ряде команд. Результат выражения значения иногда называют &lt;em&gt;скаляром&lt;/em&gt; , чтобы отличить его от результата табличного выражения (которое является таблицей). Поэтому выражения значений также называются &lt;em&gt;скалярными выражениями&lt;/em&gt; (или даже просто &lt;em&gt;выражениями&lt;/em&gt; ). Синтаксис выражения позволяет вычислять значения из примитивных частей, используя арифметические, логические, установочные и другие операции.</target>
        </trans-unit>
        <trans-unit id="114f96aeed1ddb1f81a693ccadc122b00691f706" translate="yes" xml:space="preserve">
          <source>Value that &lt;code&gt;RESET&lt;/code&gt; would reset the parameter to in the current session</source>
          <target state="translated">Значение, на которое &lt;code&gt;RESET&lt;/code&gt; сбросит параметр в текущем сеансе</target>
        </trans-unit>
        <trans-unit id="28c18b9457473dab8964985ffc208f4a1973292c" translate="yes" xml:space="preserve">
          <source>Value to be assigned to the parameter</source>
          <target state="translated">Значение,которое должно быть присвоено параметру</target>
        </trans-unit>
        <trans-unit id="f84541e98210f793e8890e82c64afbe27a9c9a73" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;false&lt;/code&gt; literal</source>
          <target state="translated">Значение, используемое для сравнения с &lt;code&gt;false&lt;/code&gt; литералом JSON</target>
        </trans-unit>
        <trans-unit id="f129faa853bacb07b12134ac4fd986301a263b11" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;null&lt;/code&gt; value</source>
          <target state="translated">Значение, используемое для сравнения с &lt;code&gt;null&lt;/code&gt; значением JSON</target>
        </trans-unit>
        <trans-unit id="8a792873148b2fe92c538941fe93212a85f960e9" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;true&lt;/code&gt; literal</source>
          <target state="translated">Значение, используемое для сравнения с &lt;code&gt;true&lt;/code&gt; литералом JSON</target>
        </trans-unit>
        <trans-unit id="e8086792911df062e24caa3131a5135743c9b16c" translate="yes" xml:space="preserve">
          <source>Value/Predicate</source>
          <target state="translated">Value/Predicate</target>
        </trans-unit>
        <trans-unit id="1f1cb2e6759dab2334119644e8cf129ac32ce11d" translate="yes" xml:space="preserve">
          <source>Values are stored internally as 64-bit floating point numbers. This means that numbers with more than about 16 significant digits will be truncated.</source>
          <target state="translated">Значения хранятся внутренне как 64-битные числа с плавающей точкой.Это означает,что числа с более чем 16 значащими цифрами будут усечены.</target>
        </trans-unit>
        <trans-unit id="6d7efb522647e3ca74917dae6abd528277b3ab9e" translate="yes" xml:space="preserve">
          <source>Values needed to run one PostgreSQL instance</source>
          <target state="translated">Значения,необходимые для запуска одного экземпляра PostgreSQL</target>
        </trans-unit>
        <trans-unit id="8d380e11f26f75eaba033d74818adbe55ddca1de" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt; data types can be cast to &lt;code&gt;money&lt;/code&gt;. Conversion from the &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; data types can be done by casting to &lt;code&gt;numeric&lt;/code&gt; first, for example:</source>
          <target state="translated">Значения типов данных &lt;code&gt;numeric&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; и &lt;code&gt;bigint&lt;/code&gt; можно преобразовать в &lt;code&gt;money&lt;/code&gt; . Преобразование из &lt;code&gt;real&lt;/code&gt; и &lt;code&gt;double precision&lt;/code&gt; типов данных может быть сделано путем литья с &lt;code&gt;numeric&lt;/code&gt; первым, например:</target>
        </trans-unit>
        <trans-unit id="6a94b34531e2a116d1ab90afc1f71919f7dc0067" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;pg_mcv_list&lt;/code&gt; can be obtained only from the &lt;code&gt;pg_statistic_ext_data.stxdmcv&lt;/code&gt; column.</source>
          <target state="translated">Значения &lt;code&gt;pg_mcv_list&lt;/code&gt; можно получить только из столбца &lt;code&gt;pg_statistic_ext_data.stxdmcv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="850035024c129e8a798d30d9fc0a41ee9af84afc" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;pg_mcv_list&lt;/code&gt; type can be obtained only from the &lt;code&gt;pg_statistic_ext_data&lt;/code&gt;.&lt;code&gt;stxdmcv&lt;/code&gt; column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b87bdbb02446940728e896c08b8825bde2b21b0" translate="yes" xml:space="preserve">
          <source>Values of this domain are allowed to be null. This is the default.</source>
          <target state="translated">Значения этого домена могут быть нулевыми.Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d29119abb7de6b63218065ed67e351db8dc51728" translate="yes" xml:space="preserve">
          <source>Values of this domain are prevented from being null (but see notes below).</source>
          <target state="translated">Значения этого домена не могут быть нулевыми (но см.примечания ниже).</target>
        </trans-unit>
        <trans-unit id="0d30cecbfdbc76e7857e49ac92bd25f13ef34d9b" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;character&lt;/code&gt; are physically padded with spaces to the specified width &lt;code&gt;n&lt;/code&gt;, and are stored and displayed that way. However, trailing spaces are treated as semantically insignificant and disregarded when comparing two values of type &lt;code&gt;character&lt;/code&gt;. In collations where whitespace is significant, this behavior can produce unexpected results; for example &lt;code&gt;SELECT 'a '::CHAR(2) collate &quot;C&quot; &amp;lt; E'a\n'::CHAR(2)&lt;/code&gt; returns true, even though &lt;code&gt;C&lt;/code&gt; locale would consider a space to be greater than a newline. Trailing spaces are removed when converting a &lt;code&gt;character&lt;/code&gt; value to one of the other string types. Note that trailing spaces &lt;em&gt;are&lt;/em&gt; semantically significant in &lt;code&gt;character varying&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt; values, and when using pattern matching, that is &lt;code&gt;LIKE&lt;/code&gt; and regular expressions.</source>
          <target state="translated">Значения типа &lt;code&gt;character&lt;/code&gt; физически дополняются пробелами до указанной ширины &lt;code&gt;n&lt;/code&gt; и сохраняются и отображаются таким образом. Однако конечные пробелы рассматриваются как семантически незначимые и игнорируются при сравнении двух значений типа &lt;code&gt;character&lt;/code&gt; . В сопоставлениях, где значительны пробелы, такое поведение может привести к неожиданным результатам; например, &lt;code&gt;SELECT 'a '::CHAR(2) collate &quot;C&quot; &amp;lt; E'a\n'::CHAR(2)&lt;/code&gt; возвращает истину, даже если языковой стандарт &lt;code&gt;C&lt;/code&gt; считает пробел больше, чем символ новой строки. Конечные пробелы удаляются при преобразовании &lt;code&gt;character&lt;/code&gt; значения в один из других строковых типов. Следует отметить , что конечные пробелы &lt;em&gt;являются&lt;/em&gt; семантически значимыми в &lt;code&gt;character varying&lt;/code&gt; и &lt;code&gt;text&lt;/code&gt; значения, а при использовании сопоставления с образцом - &lt;code&gt;LIKE&lt;/code&gt; и регулярные выражения.</target>
        </trans-unit>
        <trans-unit id="0d0e8ddc497a1b9c951f5949c5d9e1b70b9a22cd" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;path&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">Значения типа &lt;code&gt;path&lt;/code&gt; указываются с использованием любого из следующих синтаксисов:</target>
        </trans-unit>
        <trans-unit id="d80b51f9c7fc6e7a8b7e3fe299274555e9a2ae02" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;polygon&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">Значения типа &lt;code&gt;polygon&lt;/code&gt; задаются с использованием любого из следующих синтаксисов:</target>
        </trans-unit>
        <trans-unit id="e5a16467bfe399e24f49eb7fdb667ccec5d8723e" translate="yes" xml:space="preserve">
          <source>Values set with &lt;code&gt;ALTER DATABASE&lt;/code&gt; and &lt;code&gt;ALTER ROLE&lt;/code&gt; are applied only when starting a fresh database session. They override values obtained from the configuration files or server command line, and constitute defaults for the rest of the session. Note that some settings cannot be changed after server start, and so cannot be set with these commands (or the ones listed below).</source>
          <target state="translated">Значения, установленные с помощью &lt;code&gt;ALTER DATABASE&lt;/code&gt; и &lt;code&gt;ALTER ROLE&lt;/code&gt; , применяются только при запуске нового сеанса базы данных. Они переопределяют значения, полученные из файлов конфигурации или командной строки сервера, и составляют значения по умолчанию для остальной части сеанса. Обратите внимание, что некоторые настройки нельзя изменить после запуска сервера, и поэтому их нельзя настроить с помощью этих команд (или перечисленных ниже).</target>
        </trans-unit>
        <trans-unit id="818a4a9f523da08f985a8d7bb8387b916781ef1a" translate="yes" xml:space="preserve">
          <source>Values set with &lt;code&gt;ALTER SYSTEM&lt;/code&gt; will be effective after the next server configuration reload, or after the next server restart in the case of parameters that can only be changed at server start. A server configuration reload can be commanded by calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;, running &lt;code&gt;pg_ctl reload&lt;/code&gt;, or sending a SIGHUP signal to the main server process.</source>
          <target state="translated">Значения, установленные с помощью &lt;code&gt;ALTER SYSTEM&lt;/code&gt; , вступят в силу после следующей перезагрузки конфигурации сервера или после следующего перезапуска сервера в случае параметров, которые можно изменить только при запуске сервера. Командовать перезагрузкой конфигурации сервера можно, вызвав функцию SQL &lt;code&gt;pg_reload_conf()&lt;/code&gt; , запустив &lt;code&gt;pg_ctl reload&lt;/code&gt; или отправив сигнал SIGHUP основному процессу сервера.</target>
        </trans-unit>
        <trans-unit id="8e2a94acd55e77d304a8881179a17d08010c723b" translate="yes" xml:space="preserve">
          <source>Values to be inserted into a table are converted to the destination column's data type according to the following steps.</source>
          <target state="translated">Значения,которые должны быть вставлены в таблицу,преобразуются в тип данных столбца назначения в соответствии со следующими шагами.</target>
        </trans-unit>
        <trans-unit id="543a387448ddbbf661178992c3adaa7b069168fb" translate="yes" xml:space="preserve">
          <source>Values: 0 - Without salt. Dangerous! 1 - With salt but with fixed iteration count. 3 - Variable iteration count. Default: 3 Applies to: pgp_sym_encrypt</source>
          <target state="translated">Ценности:0-без соли.Опасно! 1-С солью,но с фиксированным количеством итераций.3-С переменным количеством итераций.По умолчанию:3 Применяется к:pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="e85fa17c91ce0d6924e2ed0119f352ea3f8fb549" translate="yes" xml:space="preserve">
          <source>Values: 0 - no compression 1 - ZIP compression 2 - ZLIB compression (= ZIP plus meta-data and block CRCs) Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">Ценности:0-нет сжатия 1-ZIP-сжатие 2-ZLIB-сжатие (=ZIP плюс мета-данные и контрольные суммы блока)По умолчанию:0 Применяется к:pgp_sym_encrypt,pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="52218ba89357173a5dfb8618986a1e8fdfb757a3" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt</source>
          <target state="translated">Ценности:0,1 По умолчанию:0 Применяется к:pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="922303e052dbc79ebb5e801b79cffb9186efe35c" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">Ценности:0,1 По умолчанию:0 Применяется к:pgp_sym_encrypt,pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="bbe411494b7a8541ba3eda983d9fa94b6f7dde40" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt</source>
          <target state="translated">Ценности:0,1 По умолчанию:0 Применяется к:pgp_sym_encrypt,pgp_pub_encrypt,pgp_sym_decrypt,pgp_pub_decrypt</target>
        </trans-unit>
        <trans-unit id="87f52252bc49eca143f466418a46bf231d397765" translate="yes" xml:space="preserve">
          <source>Values: 0, 1-9 Default: 6 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">Ценности:0,1-9 По умолчанию:6 Применяется к:pgp_sym_encrypt,pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="631bb9d3f376659e6d97cddb0d8676370c2c08b3" translate="yes" xml:space="preserve">
          <source>Values: bf, aes, aes128, aes192, aes256 Default: use cipher-algo Applies to: pgp_sym_encrypt</source>
          <target state="translated">Значения:bf,aes,aes128,aes192,aes256 По умолчанию:использовать шифрование Применяется к:pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="e9d1d35bfb5be3f756eb7a018b33d9e394f847ba" translate="yes" xml:space="preserve">
          <source>Values: bf, aes128, aes192, aes256 (OpenSSL-only: &lt;code&gt;3des&lt;/code&gt;, &lt;code&gt;cast5&lt;/code&gt;) Default: aes128 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">Значения: bf, aes128, aes192, aes256 (только для OpenSSL: &lt;code&gt;3des&lt;/code&gt; , &lt;code&gt;cast5&lt;/code&gt; ) По умолчанию: aes128 Применимо к: pgp_sym_encrypt, pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="777af837f1de8927748898b65d1060bc773bad7b" translate="yes" xml:space="preserve">
          <source>Values: md5, sha1 Default: sha1 Applies to: pgp_sym_encrypt</source>
          <target state="translated">Значения:md5,sha1 По умолчанию:sha1 Применяется к:pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="a0b72534c52ce05719721c1bfff6524b4aef3cf8" translate="yes" xml:space="preserve">
          <source>Variable interpolation will not be performed within quoted SQL literals and identifiers. Therefore, a construction such as &lt;code&gt;':foo'&lt;/code&gt; doesn't work to produce a quoted literal from a variable's value (and it would be unsafe if it did work, since it wouldn't correctly handle quotes embedded in the value).</source>
          <target state="translated">Интерполяция переменных не будет выполняться внутри цитируемых литералов и идентификаторов SQL. Следовательно, такая конструкция, как &lt;code&gt;':foo'&lt;/code&gt; , не работает для создания цитируемого литерала из значения переменной (и было бы небезопасно, если бы она работала, поскольку она не могла бы правильно обрабатывать кавычки, встроенные в значение).</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="f20578601408732c8ea02e8d928be3d22ba16637" translate="yes" xml:space="preserve">
          <source>Variables that control psql's behavior generally cannot be unset or set to invalid values. An &lt;code&gt;\unset&lt;/code&gt; command is allowed but is interpreted as setting the variable to its default value. A &lt;code&gt;\set&lt;/code&gt; command without a second argument is interpreted as setting the variable to &lt;code&gt;on&lt;/code&gt;, for control variables that accept that value, and is rejected for others. Also, control variables that accept the values &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;off&lt;/code&gt; will also accept other common spellings of Boolean values, such as &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Переменные, которые управляют поведением psql, обычно не могут быть сброшены или установлены на недопустимые значения. Команда &lt;code&gt;\unset&lt;/code&gt; разрешена, но интерпретируется как установка для переменной значения по умолчанию. &lt;code&gt;\set&lt;/code&gt; команд без второго аргумента интерпретируется как установка переменной в &lt;code&gt;on&lt;/code&gt; , для управляющих переменных , которые принимают это значение, и отвергается для других. Кроме того, управляющие переменные, которые принимают значения &lt;code&gt;on&lt;/code&gt; и &lt;code&gt;off&lt;/code&gt; , также будут принимать другие распространенные варианты написания логических значений, такие как &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71d1d14c3d8bef73e900f87a2c49118ec1795b0b" translate="yes" xml:space="preserve">
          <source>Various other settings related to &amp;ldquo;semaphore undo&amp;rdquo;, such as &lt;code&gt;SEMMNU&lt;/code&gt; and &lt;code&gt;SEMUME&lt;/code&gt;, do not affect PostgreSQL.</source>
          <target state="translated">Различные другие настройки, связанные с &amp;laquo;отменой семафора&amp;raquo;, такие как &lt;code&gt;SEMMNU&lt;/code&gt; и &lt;code&gt;SEMUME&lt;/code&gt; , не влияют на PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="bd6240cba4fe3aa73d43764309d30fb6d3d037a4" translate="yes" xml:space="preserve">
          <source>Various parameters have been mentioned above in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt; and &lt;a href=&quot;hot-standby#HOT-STANDBY-ADMIN&quot;&gt;Section 26.5.3&lt;/a&gt;.</source>
          <target state="translated">Различные параметры были упомянуты выше в &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Разделах 26.5.2&lt;/a&gt; и &lt;a href=&quot;hot-standby#HOT-STANDBY-ADMIN&quot;&gt;26.5.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5b3325956fac55ce90bb38fba311678783c4a5a" translate="yes" xml:space="preserve">
          <source>Verification is performed using the same procedures as those used by index scans themselves, which may be user-defined operator class code. For example, B-Tree index verification relies on comparisons made with one or more B-Tree support function 1 routines. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details of operator class support functions.</source>
          <target state="translated">Проверка выполняется с использованием тех же процедур, что и при сканировании самих индексов, которые могут быть кодом класса оператора, определяемым пользователем. Например, проверка индекса B-дерева основана на сравнениях, сделанных с одной или несколькими подпрограммами функции поддержки B-Tree 1. См. &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;Раздел 37.16.3&lt;/a&gt; для подробностей о функциях поддержки операторского класса.</target>
        </trans-unit>
        <trans-unit id="61976158db30bfdbe77805af6f5914f1244b7a45" translate="yes" xml:space="preserve">
          <source>Verification is performed using the same procedures as those used by index scans themselves, which may be user-defined operator class code. For example, B-Tree index verification relies on comparisons made with one or more B-Tree support function 1 routines. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details of operator class support functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875530bb85a9bc9a572c1b81ee549fe16ccb6d4b" translate="yes" xml:space="preserve">
          <source>Version and Platform Compatibility</source>
          <target state="translated">Совместимость версий и платформ</target>
        </trans-unit>
        <trans-unit id="1d9929f1f28bbd8834745a088bfee2450b12d5d8" translate="yes" xml:space="preserve">
          <source>Version name</source>
          <target state="translated">Название версии</target>
        </trans-unit>
        <trans-unit id="2597e3332e662024a1086db859f74acc32e53a21" translate="yes" xml:space="preserve">
          <source>Version name for the extension</source>
          <target state="translated">Имя версии для расширения</target>
        </trans-unit>
        <trans-unit id="29156f5ef29fca0492cf46682a435025e1953ccd" translate="yes" xml:space="preserve">
          <source>Version number</source>
          <target state="translated">Номер версии</target>
        </trans-unit>
        <trans-unit id="637ea0ea7f40808c77700c1c4f68ba0087e0490c" translate="yes" xml:space="preserve">
          <source>Version of SSL in use, or NULL if SSL is not in use on this connection</source>
          <target state="translated">Использованная версия SSL или NULL,если SSL не используется на данном соединении</target>
        </trans-unit>
        <trans-unit id="20a77b4ce23e6a598792ebba9c5fa53b934c43a3" translate="yes" xml:space="preserve">
          <source>Version of the server (optional)</source>
          <target state="translated">Версия сервера (опционально)</target>
        </trans-unit>
        <trans-unit id="2002aefc5b11f637b7466ee1a13c20a9e6171391" translate="yes" xml:space="preserve">
          <source>Vertical tab (ASCII 11)</source>
          <target state="translated">Вертикальная вкладка (ASCII 11)</target>
        </trans-unit>
        <trans-unit id="9fe85f9993f6a26e677373400348d89af1072a3c" translate="yes" xml:space="preserve">
          <source>Very long-lived write transactions</source>
          <target state="translated">Очень долговечные операции с записью</target>
        </trans-unit>
        <trans-unit id="30f98f07baa783307d6eeb3e956be798331b0ca1" translate="yes" xml:space="preserve">
          <source>Victor Wagner &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:vitus@cryptocom.ru&quot;&gt;vitus@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Cryptocom LTD</source>
          <target state="translated">Виктор Вагнер &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:vitus@cryptocom.ru&quot;&gt;vitus@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; , Cryptocom LTD</target>
        </trans-unit>
        <trans-unit id="1d6b8a691f0d907efa971075035a145a937381ac" translate="yes" xml:space="preserve">
          <source>Vietnamese</source>
          <target state="translated">Vietnamese</target>
        </trans-unit>
        <trans-unit id="69bd4ef9fbd0894a22759c3766b859defbdedbc8" translate="yes" xml:space="preserve">
          <source>View</source>
          <target state="translated">View</target>
        </trans-unit>
        <trans-unit id="bf0400b0f3aafc0bb49249e45dc8694f8cdb7fdb" translate="yes" xml:space="preserve">
          <source>View Name</source>
          <target state="translated">Название вида</target>
        </trans-unit>
        <trans-unit id="33ef89bbb476e8982fc98b280a43e4c9b99ae10c" translate="yes" xml:space="preserve">
          <source>View all the locks currently outstanding, all the locks on relations in a particular database, all the locks on a particular relation, or all the locks held by a particular PostgreSQL session.</source>
          <target state="translated">Просмотрите все замки,которые в настоящее время остаются незавершенными,все замки на отношениях в определенной базе данных,все замки на определенных отношениях,или все замки,удерживаемые определенным сеансом PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="cbe38ed5293f170b37453ef21637367ceda0f0b8" translate="yes" xml:space="preserve">
          <source>View definition (a reconstructed &lt;code&gt;SELECT&lt;/code&gt; query)</source>
          <target state="translated">Определение представления (реконструированный запрос &lt;code&gt;SELECT&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="94f66a08ed3a699a66860df21a573d573a238197" translate="yes" xml:space="preserve">
          <source>Viewing Locks</source>
          <target state="translated">Просмотр замков</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="c43c0cfc302cb10077693176e5e074e56b5aa3e7" translate="yes" xml:space="preserve">
          <source>Views can be used in almost any place a real table can be used. Building views upon other views is not uncommon.</source>
          <target state="translated">Представления можно использовать практически в любом месте,где можно использовать реальную таблицу.Построение представлений на других представлениях не является редкостью.</target>
        </trans-unit>
        <trans-unit id="8e39d0decda3838416b25ba5106b0efbe06c4023" translate="yes" xml:space="preserve">
          <source>Virtual ID of the transaction targeted by the lock, or null if the target is not a virtual transaction ID</source>
          <target state="translated">Виртуальный ID транзакции,на которую нацелен замок,или нулевой,если целью не является виртуальный ID транзакции</target>
        </trans-unit>
        <trans-unit id="811a0b30888086bd25c748477319220487f25d50" translate="yes" xml:space="preserve">
          <source>Virtual ID of the transaction that is holding or awaiting this lock</source>
          <target state="translated">Виртуальный идентификатор транзакции,которая содержит или ожидает этот замок.</target>
        </trans-unit>
        <trans-unit id="4e4ba211a7e69b2432d26b396c51c526655c765b" translate="yes" xml:space="preserve">
          <source>Virtual transaction ID (backendID/localXID)</source>
          <target state="translated">Идентификатор виртуальной транзакции (backendID/localXID)</target>
        </trans-unit>
        <trans-unit id="588b3f896da2cfeabe798008bfd5617b36ad005b" translate="yes" xml:space="preserve">
          <source>Visibility map (fork)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="588c142955d93338aefe3c6dd59baf541f7f60c7" translate="yes" xml:space="preserve">
          <source>WAL</source>
          <target state="translated">WAL</target>
        </trans-unit>
        <trans-unit id="1d1c95a48c1cec72e7cde457f1faf1b2311bbdfd" translate="yes" xml:space="preserve">
          <source>WAL Configuration</source>
          <target state="translated">Настройка стены</target>
        </trans-unit>
        <trans-unit id="dc7b27e2b628547b61cdbe01ad5b4d44572d2c25" translate="yes" xml:space="preserve">
          <source>WAL Internals</source>
          <target state="translated">Интернационал Стены</target>
        </trans-unit>
        <trans-unit id="cd824454d5f714596ff079dcd401902ac18dd100" translate="yes" xml:space="preserve">
          <source>WAL also makes it possible to support on-line backup and point-in-time recovery, as described in &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;. By archiving the WAL data we can support reverting to any time instant covered by the available WAL data: we simply install a prior physical backup of the database, and replay the WAL log just as far as the desired time. What's more, the physical backup doesn't have to be an instantaneous snapshot of the database state &amp;mdash; if it is made over some period of time, then replaying the WAL log for that period will fix any internal inconsistencies.</source>
          <target state="translated">WAL также позволяет поддерживать оперативное резервное копирование и восстановление на определенный момент времени, как описано в &lt;a href=&quot;continuous-archiving&quot;&gt;Разделе 25.3&lt;/a&gt; . Архивируя данные WAL, мы можем поддерживать возврат к любому моменту времени, охватываемому доступными данными WAL: мы просто устанавливаем предыдущую физическую резервную копию базы данных и воспроизводим журнал WAL до нужного времени. Более того, физическая резервная копия не обязательно должна быть мгновенным снимком состояния базы данных - если она создается в течение некоторого периода времени, то воспроизведение журнала WAL за этот период исправит все внутренние несоответствия.</target>
        </trans-unit>
        <trans-unit id="56d9842b4dd6ff8912c8130e9ac002eac147ee40" translate="yes" xml:space="preserve">
          <source>WAL archiver (process)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a8587a456d98f221f4f9bce63c226fcda62f9a" translate="yes" xml:space="preserve">
          <source>WAL file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4adb460b94535160dc5514c2f3243fad9448dc8" translate="yes" xml:space="preserve">
          <source>WAL file control commands will not work during recovery, e.g. &lt;code&gt;pg_start_backup&lt;/code&gt;, &lt;code&gt;pg_switch_wal&lt;/code&gt; etc.</source>
          <target state="translated">Команды управления файлом WAL не будут работать во время восстановления, например &lt;code&gt;pg_start_backup&lt;/code&gt; , &lt;code&gt;pg_switch_wal&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="0dc06e1a1b8ef3a3c8739d9743e015585588e2e0" translate="yes" xml:space="preserve">
          <source>WAL file control commands will not work during recovery, e.g., &lt;code&gt;pg_start_backup&lt;/code&gt;, &lt;code&gt;pg_switch_wal&lt;/code&gt; etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b2801865ae804dc7013c1520108c058b7f6c30a" translate="yes" xml:space="preserve">
          <source>WAL is automatically enabled; no action is required from the administrator except ensuring that the disk-space requirements for the WAL logs are met, and that any necessary tuning is done (see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;).</source>
          <target state="translated">WAL включается автоматически; со стороны администратора не требуется никаких действий, кроме обеспечения выполнения требований к дисковому пространству для журналов WAL и выполнения всех необходимых настроек (см. &lt;a href=&quot;wal-configuration&quot;&gt;Раздел 29.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c356b4888573bfd6af6c126f717a43c96a7d21b4" translate="yes" xml:space="preserve">
          <source>WAL location at which to start reading. The default is to start reading the first valid log record found in the earliest file found.</source>
          <target state="translated">Месторасположение стены,с которого можно начинать чтение.По умолчанию начинается чтение первой действительной записи журнала,найденной в самом раннем найденном файле.</target>
        </trans-unit>
        <trans-unit id="4873b80cfe4fe4ff618ed5cd62f9b47043675a98" translate="yes" xml:space="preserve">
          <source>WAL logs are stored in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory, as a set of segment files, normally each 16 MB in size (but the size can be changed by altering the &lt;code&gt;--wal-segsize&lt;/code&gt; initdb option). Each segment is divided into pages, normally 8 kB each (this size can be changed via the &lt;code&gt;--with-wal-blocksize&lt;/code&gt; configure option). The log record headers are described in &lt;code&gt;access/xlogrecord.h&lt;/code&gt;; the record content is dependent on the type of event that is being logged. Segment files are given ever-increasing numbers as names, starting at &lt;code&gt;000000010000000000000000&lt;/code&gt;. The numbers do not wrap, but it will take a very, very long time to exhaust the available stock of numbers.</source>
          <target state="translated">Журналы WAL хранятся в каталоге &lt;code&gt;pg_wal&lt;/code&gt; в каталоге данных в виде набора файлов сегментов, обычно каждый размером 16 МБ (но размер можно изменить, изменив параметр &lt;code&gt;--wal-segsize&lt;/code&gt; initdb). Каждый сегмент делится на страницы, обычно по 8 КБ каждая (этот размер можно изменить с помощью &lt;code&gt;--with-wal-blocksize&lt;/code&gt; конфигурации --with-wal-blocksize ). Заголовки записей журнала описаны в &lt;code&gt;access/xlogrecord.h&lt;/code&gt; ; содержание записи зависит от типа регистрируемого события. Сегментным файлам в качестве имен присваиваются постоянно увеличивающиеся номера, начиная с &lt;code&gt;000000010000000000000000&lt;/code&gt; . Цифры не переносятся, но на то, чтобы исчерпать доступный запас чисел, потребуется очень и очень много времени.</target>
        </trans-unit>
        <trans-unit id="fce41bc59a921956886daa163cc3371dfbffcdb7" translate="yes" xml:space="preserve">
          <source>WAL logs are stored in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory, as a set of segment files, normally each 16 MB in size (but the size can be changed by altering the &lt;code&gt;--wal-segsize&lt;/code&gt; initdb option). Each segment is divided into pages, normally 8 kB each (this size can be changed via the &lt;code&gt;--with-wal-blocksize&lt;/code&gt; configure option). The log record headers are described in &lt;code&gt;access/xlogrecord.h&lt;/code&gt;; the record content is dependent on the type of event that is being logged. Segment files are given ever-increasing numbers as names, starting at &lt;code&gt;000000010000000000000001&lt;/code&gt;. The numbers do not wrap, but it will take a very, very long time to exhaust the available stock of numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9cabc60b441504c082bc1d5bf727636abc5fa64" translate="yes" xml:space="preserve">
          <source>WAL record</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa55cdd1f960e02b270cbf81d5d051cfdadab50" translate="yes" xml:space="preserve">
          <source>WAL record construction can be canceled between any of the above steps by calling &lt;code&gt;GenericXLogAbort(state)&lt;/code&gt;. This will discard all changes to the page image copies.</source>
          <target state="translated">Построение записи WAL можно отменить между любыми из вышеперечисленных шагов, вызвав &lt;code&gt;GenericXLogAbort(state)&lt;/code&gt; . Это отменит все изменения копий изображений страниц.</target>
        </trans-unit>
        <trans-unit id="ec0756aa72f12460643a103d61be69d319455e3e" translate="yes" xml:space="preserve">
          <source>WAL records are appended to the WAL logs as each new record is written. The insert position is described by a Log Sequence Number (LSN) that is a byte offset into the logs, increasing monotonically with each new record. LSN values are returned as the datatype &lt;a href=&quot;datatype-pg-lsn&quot;&gt;&lt;code&gt;pg_lsn&lt;/code&gt;&lt;/a&gt;. Values can be compared to calculate the volume of WAL data that separates them, so they are used to measure the progress of replication and recovery.</source>
          <target state="translated">Записи WAL добавляются к журналам WAL по мере записи каждой новой записи. Позиция вставки описывается порядковым номером журнала (LSN), который представляет собой смещение в байтах в журналах, монотонно увеличивающееся с каждой новой записью. Значения LSN возвращаются как тип данных &lt;a href=&quot;datatype-pg-lsn&quot;&gt; &lt;code&gt;pg_lsn&lt;/code&gt; &lt;/a&gt; . Значения можно сравнивать для вычисления объема данных WAL, которые их разделяют, поэтому они используются для измерения хода репликации и восстановления.</target>
        </trans-unit>
        <trans-unit id="d60f7a41c7594f9d60365bb80cc500438858f049" translate="yes" xml:space="preserve">
          <source>WAL segment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85207d0ebcdb97d98e8f6e4d0d99438888bd2967" translate="yes" xml:space="preserve">
          <source>WAL segments that cannot be found in the archive will be sought in &lt;code&gt;pg_wal/&lt;/code&gt;; this allows use of recent un-archived segments. However, segments that are available from the archive will be used in preference to files in &lt;code&gt;pg_wal/&lt;/code&gt;.</source>
          <target state="translated">Сегменты WAL, которых нет в архиве, будут искать в &lt;code&gt;pg_wal/&lt;/code&gt; ; это позволяет использовать недавние неархивированные сегменты. Однако сегменты, доступные из архива, будут использоваться вместо файлов в &lt;code&gt;pg_wal/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a848a0c06549fd9cb5d11422d342ef502df6d940" translate="yes" xml:space="preserve">
          <source>WAL writer (process)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670936924f36e223ed7101a5577c1a95fc54d46f" translate="yes" xml:space="preserve">
          <source>WIDE Project</source>
          <target state="translated">проект WIDE</target>
        </trans-unit>
        <trans-unit id="0c238a027f49a7325c81b6fcad74df656598a8d1" translate="yes" xml:space="preserve">
          <source>WITH Queries</source>
          <target state="translated">С запросами</target>
        </trans-unit>
        <trans-unit id="62c72223105cadaf945f1907d7cca51ac5e11a9a" translate="yes" xml:space="preserve">
          <source>WITH Queries: Data-Modifying Statements in WITH</source>
          <target state="translated">С вопросами:Модифицирующие данные утверждения в С</target>
        </trans-unit>
        <trans-unit id="81a33ebe9b068dc28117b34d20aebb31ffcc15d4" translate="yes" xml:space="preserve">
          <source>WITH Queries: SELECT in WITH</source>
          <target state="translated">С вопросами:ВЫБЕРИТЕ С</target>
        </trans-unit>
        <trans-unit id="b3c1b6ed1901fdc76c7650d703ade5c43c418ba9" translate="yes" xml:space="preserve">
          <source>Wait Event Name</source>
          <target state="translated">Имя события ожидания</target>
        </trans-unit>
        <trans-unit id="cfecc9a9e7dbc0650b752c6d733646645d5d3acd" translate="yes" xml:space="preserve">
          <source>Wait Event Type</source>
          <target state="translated">Тип события ожидания</target>
        </trans-unit>
        <trans-unit id="b1541ea954698c8eaec6697e4064951737b7ac58" translate="yes" xml:space="preserve">
          <source>Wait event name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-ACTIVITY-TABLE&quot;&gt;Table 27.5&lt;/a&gt; through &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TIMEOUT-TABLE&quot;&gt;Table 27.13&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1dd06a2c6e4048cfa872860c567be1efcd7c2b" translate="yes" xml:space="preserve">
          <source>Wait event name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt; for details.</source>
          <target state="translated">Имя события ожидания, если серверная часть в настоящее время ожидает, иначе NULL. См. Подробности в &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Таблице 27.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0d176395064480d6a06595b0b0b2f5082eb7376" translate="yes" xml:space="preserve">
          <source>Wait event type name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt; for details.</source>
          <target state="translated">Имя типа события ожидания, если бэкэнд в настоящее время ожидает, иначе NULL. См. Подробности в &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Таблице 27.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d814f74425edb745c0f36dde73fdb494bc74e548" translate="yes" xml:space="preserve">
          <source>Wait for the operation to complete. This is supported for the modes &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;restart&lt;/code&gt;, &lt;code&gt;promote&lt;/code&gt;, and &lt;code&gt;register&lt;/code&gt;, and is the default for those modes.</source>
          <target state="translated">Дождитесь завершения операции. Это поддерживается для режимов &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; , &lt;code&gt;restart&lt;/code&gt; , &lt;code&gt;promote&lt;/code&gt; и &lt;code&gt;register&lt;/code&gt; и является значением по умолчанию для этих режимов.</target>
        </trans-unit>
        <trans-unit id="dd618adedec17e6469d06a5651fc5072c2cb8b33" translate="yes" xml:space="preserve">
          <source>Waiting a new WAL segment created by copying an existing one to reach stable storage.</source>
          <target state="translated">Ожидание нового сегмента WAL,созданного путем копирования существующего,для достижения стабильного хранения.</target>
        </trans-unit>
        <trans-unit id="d1f87abf987753c903a49d1bd2c679d42224c9ed" translate="yes" xml:space="preserve">
          <source>Waiting due to a call to &lt;code&gt;pg_sleep&lt;/code&gt; or a sibling function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b263c588c8a9b03696257b8f7a21247383c1982" translate="yes" xml:space="preserve">
          <source>Waiting during base backup when throttling activity.</source>
          <target state="translated">Ждать во время резервного копирования базы при дросселировании.</target>
        </trans-unit>
        <trans-unit id="af48f8ee80431258cbd39e7f8a24022d589cd2d4" translate="yes" xml:space="preserve">
          <source>Waiting during recovery when WAL data is not available from any source (&lt;code&gt;pg_wal&lt;/code&gt;, archive or stream).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62ddea7d6b1ce8c2e8479d95982f02c6ba59204" translate="yes" xml:space="preserve">
          <source>Waiting for I/O a subtransaction buffer.</source>
          <target state="translated">Жду ввода/вывода буфера субтранзакции.</target>
        </trans-unit>
        <trans-unit id="b41198be2ca46788de05f6339f5abc58ad97837a" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a &lt;code&gt;NOTIFY&lt;/code&gt; message SLRU buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b267052de8e5af8879f9629c8e82adc667c91f" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a clog (transaction status) buffer.</source>
          <target state="translated">Ожидание ввода/вывода в буфере засорения (статус транзакции).</target>
        </trans-unit>
        <trans-unit id="e58154eef4dbe4cc36348aa199353c80f25bfc90" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a commit timestamp SLRU buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbc9325a896b8fd7a70abd45c23e5faa43a813b" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a data page.</source>
          <target state="translated">Ожидание ввода/вывода на странице данных.</target>
        </trans-unit>
        <trans-unit id="b97519258b555ff83c2d8f7537b4d0c3849dc3b0" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact member SLRU buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5520e2be332ddadef5e822360efad62eedfb3753" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact offset SLRU buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a704e423e485baf39382a4b61985268bdbe9816" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact offset buffer.</source>
          <target state="translated">Ожидание ввода/вывода в многофакторном буфере со смещением.</target>
        </trans-unit>
        <trans-unit id="567d45c24a3c7adfee8a01424ebb678b04e38b31" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact_member buffer.</source>
          <target state="translated">Ожидание ввода/вывода на буфере multixact_member.</target>
        </trans-unit>
        <trans-unit id="f5580fedd445b2fc16dfac5701d5e862d784f551" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a replication slot.</source>
          <target state="translated">Жду ввода/вывода в слоте репликации.</target>
        </trans-unit>
        <trans-unit id="e6bc836d70082711faa785a87bbd568bb40a26f2" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a serializable transaction conflict SLRU buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf608c43f24f0741708f464c3bfab6ed45555c1" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a sub-transaction SLRU buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e164de805b3886359f5010f6a7deb581bdf00ae0" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a transaction status SLRU buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eda0ee8cd8803033853db58b70b41cefa970a11" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on an async (notify) buffer.</source>
          <target state="translated">Ожидание ввода/вывода в асинхронном (уведомительном)буфере.</target>
        </trans-unit>
        <trans-unit id="abba94e34c19d07b07ce80f08b906e7d03736163" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on an oldserxid buffer.</source>
          <target state="translated">Жду ввода/вывода в буфере Oldserxid.</target>
        </trans-unit>
        <trans-unit id="89be09a6258d69b36b9e65eae64f0556be147bdd" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on commit timestamp buffer.</source>
          <target state="translated">Ожидание ввода/вывода в буфере метки времени фиксации.</target>
        </trans-unit>
        <trans-unit id="785bfc0b8ad80cb03e1bb84a54b286b13aa0651d" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach durable storage during a checkpoint or database shutdown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="003d2dd01b2593677f27df1a51eb75521d66a25d" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach durable storage following a page write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4c5fd8e7b43af2a409040c541ebf56ba090a42" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach stable storage during a checkpoint or database shutdown.</source>
          <target state="translated">Ожидание данных SLRU для достижения стабильного хранения во время контрольно-пропускного пункта или отключения базы данных.</target>
        </trans-unit>
        <trans-unit id="a795b2d3551897df90d4dc06b1de18f13711e4ef" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach stable storage following a page write.</source>
          <target state="translated">Ожидание данных SLRU для достижения стабильного хранения после записи страницы.</target>
        </trans-unit>
        <trans-unit id="3f43eca07331b8b4d48d83deb11f1187e3222c57" translate="yes" xml:space="preserve">
          <source>Waiting for SSL while attempting connection.</source>
          <target state="translated">Ожидание SSL при попытке соединения.</target>
        </trans-unit>
        <trans-unit id="cea499b505dfbcd4c53729e4e78e2f60a5e0dfa9" translate="yes" xml:space="preserve">
          <source>Waiting for TBM shared iterator lock.</source>
          <target state="translated">Ждем,когда TBM разделит замок итератора.</target>
        </trans-unit>
        <trans-unit id="28f5fe1f96a90cf6f89027f31d1f8fff440aadd4" translate="yes" xml:space="preserve">
          <source>Waiting for WAL buffers to be written to disk.</source>
          <target state="translated">Ожидание записи буферов WAL на диск.</target>
        </trans-unit>
        <trans-unit id="984062f9c9b976e8df42046bfd109717db60ade5" translate="yes" xml:space="preserve">
          <source>Waiting for WAL files required for a backup to be successfully archived.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f443781f65a70ffb9eadd8d00b62bec73ed570" translate="yes" xml:space="preserve">
          <source>Waiting for WAL from a stream at recovery.</source>
          <target state="translated">Жду WAL из потока при восстановлении.</target>
        </trans-unit>
        <trans-unit id="ce0b3cbfc2a21133aecfeb0025076a64608b1920" translate="yes" xml:space="preserve">
          <source>Waiting for WAL from any kind of source (local, archive or stream) at recovery.</source>
          <target state="translated">Ожидание WAL из любого источника (локального,архивного или потокового)при восстановлении.</target>
        </trans-unit>
        <trans-unit id="c3d04b47f170d0a017b5a8840ab7fd732b861077" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to be flushed in WAL sender process.</source>
          <target state="translated">Ожидание промывки Стены в процессе отправки.</target>
        </trans-unit>
        <trans-unit id="f4a5e554d691351f284f09d8db7f55190422b270" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to reach durable storage during bootstrapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35934124d45c41b66cac20041da4f7acc6c09234" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to reach stable storage during bootstrapping.</source>
          <target state="translated">Ожидание,когда WAL достигнет стабильного хранения во время загрузки.</target>
        </trans-unit>
        <trans-unit id="b82237d07a68b8fa940123851d375627fb31efe7" translate="yes" xml:space="preserve">
          <source>Waiting for a WAL file to reach durable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2347bde945d2a1ac488cc00b97f03eb25edf886c" translate="yes" xml:space="preserve">
          <source>Waiting for a WAL file to reach stable storage.</source>
          <target state="translated">Ожидание,когда файл WAL достигнет стабильного хранилища.</target>
        </trans-unit>
        <trans-unit id="52ca09d978f55744184f7d9cdb893379dab55dfe" translate="yes" xml:space="preserve">
          <source>Waiting for a barrier event to be processed by all backends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b64554949a794fe8845162525251d4f832f615ae" translate="yes" xml:space="preserve">
          <source>Waiting for a checkpoint to complete.</source>
          <target state="translated">Жду завершения контрольно-пропускного пункта.</target>
        </trans-unit>
        <trans-unit id="fbe85ec49696086b315ad919340a19fe4137e208" translate="yes" xml:space="preserve">
          <source>Waiting for a checkpoint to start.</source>
          <target state="translated">Жду,когда начнется контрольно-пропускной пункт.</target>
        </trans-unit>
        <trans-unit id="318c8efea6418e0ce484fc89483b1eb1ff78690d" translate="yes" xml:space="preserve">
          <source>Waiting for a logical replication remote server to change state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be1a8f95aa3da64fa571808ebb5f548539f1390" translate="yes" xml:space="preserve">
          <source>Waiting for a logical replication remote server to send data for initial table synchronization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59d3373d5959bbfb7f16fd5cf3905eaaca00840" translate="yes" xml:space="preserve">
          <source>Waiting for a new WAL segment created by copying an existing one to reach durable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdee33be52627bad37addf1e4cb4de672175760f" translate="yes" xml:space="preserve">
          <source>Waiting for a newly created timeline history file to reach durable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a86020a20952ecd2adfecfb302ee0a5d59b93de9" translate="yes" xml:space="preserve">
          <source>Waiting for a newly created timeline history file to reach stable storage.</source>
          <target state="translated">Ожидание вновь созданного файла хронологической истории для стабильного хранения.</target>
        </trans-unit>
        <trans-unit id="b0cdef84441eaddf22ea692b65eccf4c082d170e" translate="yes" xml:space="preserve">
          <source>Waiting for a newly initialized WAL file to reach durable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe40708f510b2425a56df962113c332035d1ebb" translate="yes" xml:space="preserve">
          <source>Waiting for a newly initialized WAL file to reach stable storage.</source>
          <target state="translated">Ожидание нового инициализированного WAL файла для достижения стабильного хранения.</target>
        </trans-unit>
        <trans-unit id="a99635b6aefa182932d6d8ac35e0fadee6f58362" translate="yes" xml:space="preserve">
          <source>Waiting for a read during a file copy operation.</source>
          <target state="translated">Ожидание прочтения во время операции копирования файла.</target>
        </trans-unit>
        <trans-unit id="1b1c7ee0bc940e8ff954a9dc21e088de25e160e7" translate="yes" xml:space="preserve">
          <source>Waiting for a read during recheck of the data directory lock file.</source>
          <target state="translated">Ожидание чтения во время перепроверки файла блокировки каталога данных.</target>
        </trans-unit>
        <trans-unit id="9ae33919f01ffd845bcfe367fc1ce42274883982" translate="yes" xml:space="preserve">
          <source>Waiting for a read during reorder buffer management.</source>
          <target state="translated">Ожидание чтения во время управления буфером переупорядочивания.</target>
        </trans-unit>
        <trans-unit id="21b0b22bdd6995f4c8facc815a7958bc78a4df11" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a WAL file.</source>
          <target state="translated">Ждем чтения из файла WAL.</target>
        </trans-unit>
        <trans-unit id="7c0a57a09d41e3dd4b6c43069589a550983cdfbc" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a buffered file.</source>
          <target state="translated">В ожидании чтения из буферизованного файла.</target>
        </trans-unit>
        <trans-unit id="9d7f43727962110ab0f659fc3569b92c09e1e4c3" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a relation data file.</source>
          <target state="translated">Ожидание чтения из файла данных по связям.</target>
        </trans-unit>
        <trans-unit id="b5434d2dc36bc6e479cf33762dac4cdbbad013ab" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a replication slot control file.</source>
          <target state="translated">Ожидание чтения из файла управления слотом репликации.</target>
        </trans-unit>
        <trans-unit id="d17e29530adb24a2c7484307af3bcddda11a2aae" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a timeline history file during a walsender timeline command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8e0677108348e6cb25c6439df96979d79370b4" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a timeline history file during walsender timeline command.</source>
          <target state="translated">Ожидание чтения из файла хронологической истории во время команды walsender хронологическая шкала.</target>
        </trans-unit>
        <trans-unit id="b83f25adf4d23330ec82b288f382bbfe80bca47f" translate="yes" xml:space="preserve">
          <source>Waiting for a read from the &lt;code&gt;pg_control&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb87f9075b737550478460fe92ea81d5a8e44f1b" translate="yes" xml:space="preserve">
          <source>Waiting for a read from the control file.</source>
          <target state="translated">Ждем чтения из файла управления.</target>
        </trans-unit>
        <trans-unit id="b13a29b976f4d9243fad247169f0d2821ffe4aa3" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a logical mapping during reorder buffer management.</source>
          <target state="translated">Ожидание чтения логического отображения при управлении буфером переупорядочивания.</target>
        </trans-unit>
        <trans-unit id="94303f5f840422428a360dcb8cf874ed8d7188d8" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a serialized historical catalog snapshot.</source>
          <target state="translated">Жду прочтения сериализованного снимка исторического каталога.</target>
        </trans-unit>
        <trans-unit id="2ab04c92d0fda0e18fe65ce97ed4f4a6278c8bda" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a timeline history file.</source>
          <target state="translated">В ожидании прочтения файла хронологической истории.</target>
        </trans-unit>
        <trans-unit id="c0e334fe7275467445ed31f445bb0d89fc42ea11" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a two phase state file.</source>
          <target state="translated">Жду прочтения двухфазного файла состояния.</target>
        </trans-unit>
        <trans-unit id="24f5541db52af4f2f83a5aff926cb570ad37ea9a" translate="yes" xml:space="preserve">
          <source>Waiting for a read of an SLRU page.</source>
          <target state="translated">Жду прочтения страницы SLRU.</target>
        </trans-unit>
        <trans-unit id="ab3bd50798c846431f5c99cd295ac155af5c3628" translate="yes" xml:space="preserve">
          <source>Waiting for a read of the relation map file.</source>
          <target state="translated">Жду прочтения файла карты связей.</target>
        </trans-unit>
        <trans-unit id="653fed415a1560b6108907354641e1d02603af7f" translate="yes" xml:space="preserve">
          <source>Waiting for a read when creating a new WAL segment by copying an existing one.</source>
          <target state="translated">Ожидание чтения при создании нового сегмента WAL путем копирования существующего.</target>
        </trans-unit>
        <trans-unit id="8b50fdc4779713a2250434752ac096729a9b9e3d" translate="yes" xml:space="preserve">
          <source>Waiting for a read while adding a line to the data directory lock file.</source>
          <target state="translated">Ожидание чтения при добавлении строки в файл блокировки каталога данных.</target>
        </trans-unit>
        <trans-unit id="764d5f916fab0f4117b0be0cbd2e731f54a839fb" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to be extended.</source>
          <target state="translated">Ожидание расширения файла данных о связи.</target>
        </trans-unit>
        <trans-unit id="2d4550cc931e0694f7888372505856f6d3c09005" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to be truncated.</source>
          <target state="translated">Ожидание усечения файла данных о связи.</target>
        </trans-unit>
        <trans-unit id="56656077995a3c3ccd9b20b71affc54ffa5f3b73" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to reach durable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196784ad8df1886187ea3f9758445468708682d5" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to reach stable storage.</source>
          <target state="translated">Ожидание файла данных о связи для достижения стабильного хранения.</target>
        </trans-unit>
        <trans-unit id="e193dd315e3b35e9bfde686ab2df07cc942ef67f" translate="yes" xml:space="preserve">
          <source>Waiting for a replication origin to become inactive so it can be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6dd21f72774436bf4201a14e0bef224865f318" translate="yes" xml:space="preserve">
          <source>Waiting for a replication origin to become inactive to be dropped.</source>
          <target state="translated">Ожидание,когда источник репликации станет неактивным,чтобы быть сброшенным.</target>
        </trans-unit>
        <trans-unit id="a2c385c9c429e881d994641cd053fdd40d599ca4" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach durable storage while restoring it to memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="933e401eade88c4d239f909f0d7a24552c57d2a6" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach durable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51efea4b8a37a030875e22581e67a71b2c0b921b" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach stable storage while restoring it to memory.</source>
          <target state="translated">Ожидание файла управления слотом репликации для достижения стабильного хранения при восстановлении его в памяти.</target>
        </trans-unit>
        <trans-unit id="3360d7e3a23f4e402f25182926d976cf44db39f3" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach stable storage.</source>
          <target state="translated">Ожидание файла управления слотом репликации для достижения стабильного хранения.</target>
        </trans-unit>
        <trans-unit id="494ade39222b8fb62d122bed2c1029dcb97e4b7f" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot to become inactive so it can be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199501dcba57d5c5271ac74b95e191bf236cb733" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot to become inactive to be dropped.</source>
          <target state="translated">Ожидание,когда слот для репликации станет неактивным.</target>
        </trans-unit>
        <trans-unit id="6e324c985d50a900618f8748e92b810be7e79671" translate="yes" xml:space="preserve">
          <source>Waiting for a serialized historical catalog snapshot to reach durable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863f50afd3c1563b85fb65b1a42b5b1ae705dfb7" translate="yes" xml:space="preserve">
          <source>Waiting for a serialized historical catalog snapshot to reach stable storage.</source>
          <target state="translated">Ожидание сериализованного исторического снимка каталога для достижения стабильного хранения.</target>
        </trans-unit>
        <trans-unit id="b66c979e7938ef913ce663fc865d33095c21de87" translate="yes" xml:space="preserve">
          <source>Waiting for a snapshot for a &lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; transaction.</source>
          <target state="translated">Ожидание моментального снимка транзакции &lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="111cfd0a418a3a5087e98e0082a0895f0e94e2f0" translate="yes" xml:space="preserve">
          <source>Waiting for a timeline history file received via streaming replication to reach durable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e483dd61b2e17583a1594dcda6e591f3ac3e513f" translate="yes" xml:space="preserve">
          <source>Waiting for a timeline history file received via streaming replication to reach stable storage.</source>
          <target state="translated">Ожидание файла истории временной шкалы,полученного с помощью потоковой репликации для достижения стабильного хранения.</target>
        </trans-unit>
        <trans-unit id="2853dc0fde120da340c58317ae296218c97a1c94" translate="yes" xml:space="preserve">
          <source>Waiting for a transaction to finish.</source>
          <target state="translated">В ожидании завершения сделки.</target>
        </trans-unit>
        <trans-unit id="e24c900a389bc0f02e97f81a8ce41fbab7e291af" translate="yes" xml:space="preserve">
          <source>Waiting for a two phase state file to reach durable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157ed476e7697e7a1cadb6976248a98472434e0a" translate="yes" xml:space="preserve">
          <source>Waiting for a two phase state file to reach stable storage.</source>
          <target state="translated">Ожидание двухфазного файла состояния для достижения стабильного хранения.</target>
        </trans-unit>
        <trans-unit id="85a6ffd0d68eb37b547774e0919378d07b939300" translate="yes" xml:space="preserve">
          <source>Waiting for a write during a file copy operation.</source>
          <target state="translated">Ожидание записи во время операции копирования файла.</target>
        </trans-unit>
        <trans-unit id="32492adb76e65f3fe0a6e72f8951521baef55fec" translate="yes" xml:space="preserve">
          <source>Waiting for a write during reorder buffer management.</source>
          <target state="translated">Ожидание записи при управлении буфером переупорядочивания.</target>
        </trans-unit>
        <trans-unit id="ba450cd205c3dd8e5640b537d57ff27410f1253d" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a WAL page during bootstrapping.</source>
          <target state="translated">Ожидание записи страницы WAL во время загрузки.</target>
        </trans-unit>
        <trans-unit id="8705f070fa23d795eb616cd9e31b50566ca67cc3" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a newly created timeline history file.</source>
          <target state="translated">В ожидании записи вновь созданного файла хронологической истории.</target>
        </trans-unit>
        <trans-unit id="8d1760404310ebeadc931ff2c4124968d47b107a" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a serialized historical catalog snapshot.</source>
          <target state="translated">Жду записи снимка серийного исторического каталога.</target>
        </trans-unit>
        <trans-unit id="b37297f957be6d38118691421e743bea3d403b7c" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a timeline history file received via streaming replication.</source>
          <target state="translated">Ожидание записи файла хронологической истории,полученного с помощью потоковой репликации.</target>
        </trans-unit>
        <trans-unit id="be49d8c0c1b4685519fdd85850348ecd44be9749" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a two phase state file.</source>
          <target state="translated">Ожидание записи двухфазного файла состояния.</target>
        </trans-unit>
        <trans-unit id="53aeb8cdb283bc1d47f777ad7b24ec161b846ee7" translate="yes" xml:space="preserve">
          <source>Waiting for a write of an SLRU page.</source>
          <target state="translated">Ждем написания страницы SLRU.</target>
        </trans-unit>
        <trans-unit id="1465353979b7faf0b115892be0b212bb41254cd5" translate="yes" xml:space="preserve">
          <source>Waiting for a write of logical rewrite mappings.</source>
          <target state="translated">В ожидании написания логических переписываемых отображений.</target>
        </trans-unit>
        <trans-unit id="262bd0eebb54ede821d500429e0af687cc713958" translate="yes" xml:space="preserve">
          <source>Waiting for a write of mapping data during a logical rewrite.</source>
          <target state="translated">Ожидание записи картографических данных во время логической перезаписи.</target>
        </trans-unit>
        <trans-unit id="3b9bd51d9cae106255dd99b45134793e8fe5ca42" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a WAL file.</source>
          <target state="translated">Жду записи в файл WAL.</target>
        </trans-unit>
        <trans-unit id="251086a074c439cbe743d7c3bb152d463c21bb7b" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a buffered file.</source>
          <target state="translated">В ожидании записи в буферизованный файл.</target>
        </trans-unit>
        <trans-unit id="8b47e588513cf133674bba56df9090d2883dd101" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a relation data file.</source>
          <target state="translated">Ожидание записи в файл данных о связи.</target>
        </trans-unit>
        <trans-unit id="299b50c23e70d2d279fbb4a9694963e890bfee88" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a replication slot control file.</source>
          <target state="translated">Ожидание записи в файл управления слотом репликации.</target>
        </trans-unit>
        <trans-unit id="c78572013cf870b1d5b2f14bfe069a7a53092ec4" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the &lt;code&gt;pg_control&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26411046b5f9c53b1644f439224f22b40020be7" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the control file.</source>
          <target state="translated">Жду записи в управляющий файл.</target>
        </trans-unit>
        <trans-unit id="f75228f5ef22ab61abd11733484809e768dbf43c" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the relation map file.</source>
          <target state="translated">Ожидание записи в файл карты соотношений.</target>
        </trans-unit>
        <trans-unit id="49fdc5304647deaf1df0e95e8d9b82ecf63a8d41" translate="yes" xml:space="preserve">
          <source>Waiting for a write to update the &lt;code&gt;pg_control&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4dc5be0a61a88b12bee2628ecf09d1b773c4c35" translate="yes" xml:space="preserve">
          <source>Waiting for a write to update the control file.</source>
          <target state="translated">Ожидание записи для обновления файла управления.</target>
        </trans-unit>
        <trans-unit id="610d140534d98776f4ceaac82401a792839d1b45" translate="yes" xml:space="preserve">
          <source>Waiting for a write when creating a new WAL segment by copying an existing one.</source>
          <target state="translated">Ожидание записи при создании нового сегмента WAL путем копирования существующего.</target>
        </trans-unit>
        <trans-unit id="e8e6f804ba2f5656426f9c3ccd5ba5ebd95a87d4" translate="yes" xml:space="preserve">
          <source>Waiting for a write while adding a line to the data directory lock file.</source>
          <target state="translated">Ожидание записи при добавлении строки в файл блокировки каталога данных.</target>
        </trans-unit>
        <trans-unit id="0696197c3d3d4067137d8fe428f74da050d0c268" translate="yes" xml:space="preserve">
          <source>Waiting for a write while creating the data directory lock file.</source>
          <target state="translated">Ожидание записи при создании файла блокировки директории данных.</target>
        </trans-unit>
        <trans-unit id="2fa5fc8fd5be1292b1cb40d3c83b93e702c367e3" translate="yes" xml:space="preserve">
          <source>Waiting for a write while initializing a new WAL file.</source>
          <target state="translated">Ожидание записи при инициализации нового файла WAL.</target>
        </trans-unit>
        <trans-unit id="734b565bcfa5ca2fc97c773bf856a02689576213" translate="yes" xml:space="preserve">
          <source>Waiting for action on logical replication worker to finish.</source>
          <target state="translated">Ждем окончания действия по логической репликации работника.</target>
        </trans-unit>
        <trans-unit id="d26e6e2627cb32e8a27e81f318db98a11e54cd12" translate="yes" xml:space="preserve">
          <source>Waiting for activity from a child process while executing a &lt;code&gt;Gather&lt;/code&gt; plan node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1613179ffe75070217dd36a5f12906b74afc2ab" translate="yes" xml:space="preserve">
          <source>Waiting for activity from child process when executing &lt;code&gt;Gather&lt;/code&gt; node.</source>
          <target state="translated">Ожидание активности дочернего процесса при выполнении узла &lt;code&gt;Gather&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6126b8aaccca6a7a91b7220ca50f325ae2373721" translate="yes" xml:space="preserve">
          <source>Waiting for an asynchronous prefetch from a relation data file.</source>
          <target state="translated">Ожидание асинхронной предварительной выборки из файла данных отношений.</target>
        </trans-unit>
        <trans-unit id="7ceade57b19a1c5eb1845d4c821b850186cc2839" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate a hash table.</source>
          <target state="translated">Ожидание избранного участника Parallel Hash для выделения хэш-таблицы.</target>
        </trans-unit>
        <trans-unit id="7ae35732e2bfced9301c45c422a5bb06a774ed38" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate more batches.</source>
          <target state="translated">Ждем избранного участника Parallel Hash,чтобы распределить больше партий.</target>
        </trans-unit>
        <trans-unit id="fb366154c77101be0d76ea7c08df266aa7b65be9" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate the initial hash table.</source>
          <target state="translated">Ожидание избранного участника Parallel Hash для выделения исходной хэш-таблицы.</target>
        </trans-unit>
        <trans-unit id="7cf1c258cd35461c3f1727fa0a9eacebdd04769c" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to decide on future batch growth.</source>
          <target state="translated">Ожидание избранного участника Parallel Hash,который примет решение о будущем росте партии.</target>
        </trans-unit>
        <trans-unit id="07635fd669dda3c946a486e6f1b23b449441353e" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to finish allocating more buckets.</source>
          <target state="translated">Ожидание избранного участника Parallel Hash,чтобы закончить распределение больше ведер.</target>
        </trans-unit>
        <trans-unit id="5801375733f68124f62514d2e4570d9207fd757f" translate="yes" xml:space="preserve">
          <source>Waiting for an immediate synchronization of a relation data file to durable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e246fb175c5f149773d0331209040875fd42182" translate="yes" xml:space="preserve">
          <source>Waiting for an immediate synchronization of a relation data file to stable storage.</source>
          <target state="translated">Ожидание немедленной синхронизации файла данных связи со стабильным хранилищем.</target>
        </trans-unit>
        <trans-unit id="7259a212cd02dc7285b0b4c7fac8d9b3dccce991" translate="yes" xml:space="preserve">
          <source>Waiting for an update to the &lt;code&gt;pg_control&lt;/code&gt; file to reach durable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d64a2fc217b281e035d77c750609359d54019d" translate="yes" xml:space="preserve">
          <source>Waiting for an update to the control file to reach stable storage.</source>
          <target state="translated">Ожидание обновления файла управления для достижения стабильного хранения.</target>
        </trans-unit>
        <trans-unit id="77a6d736fc930334f93ec4961120d3fbb33658a7" translate="yes" xml:space="preserve">
          <source>Waiting for another process to be attached to a shared message queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf18468a43ecee10b4dea21dad9d1ae0888b697" translate="yes" xml:space="preserve">
          <source>Waiting for any activity when processing replies from WAL receiver in WAL sender process.</source>
          <target state="translated">Ожидание любой активности при обработке ответов от получателя WAL в процессе отправителя WAL.</target>
        </trans-unit>
        <trans-unit id="27bad1ed6561f03baa1813e29bc1d6a9f97d039b" translate="yes" xml:space="preserve">
          <source>Waiting for background worker to shut down.</source>
          <target state="translated">Жду,когда прикроют фонового работника.</target>
        </trans-unit>
        <trans-unit id="17b78b2404a9c8efe7417660102cb11bcbc99fa4" translate="yes" xml:space="preserve">
          <source>Waiting for background worker to start up.</source>
          <target state="translated">Жду,когда начнётся фоновый работник.</target>
        </trans-unit>
        <trans-unit id="1092cdc7eb9ee3391d3a4d79e4f2cbbadb7d2536" translate="yes" xml:space="preserve">
          <source>Waiting for changes to a relation data file to reach durable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121ce51ab6e249cf929aa9e0635dd5196c724d55" translate="yes" xml:space="preserve">
          <source>Waiting for changes to a relation data file to reach stable storage.</source>
          <target state="translated">Ожидание изменений в файле данных о связи для достижения стабильного хранения.</target>
        </trans-unit>
        <trans-unit id="06baf37c4d00743bd8f1d4776619f21e41c7e849" translate="yes" xml:space="preserve">
          <source>Waiting for confirmation from a remote server during synchronous replication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aedff25c55dbcd34ea828efe5df0cac10c04231" translate="yes" xml:space="preserve">
          <source>Waiting for confirmation from remote server during synchronous replication.</source>
          <target state="translated">Ожидание подтверждения с удаленного сервера во время синхронной репликации.</target>
        </trans-unit>
        <trans-unit id="06dd73106355257e55c5973700b35599b6ab2aa8" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach durable storage while adding a line to the data directory lock file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1a2cd56f85be8ddf428ad8cd1741cd6c232ca4" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach durable storage while assigning a new WAL sync method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7393e0800215c6dc732cf1bd3e9c0f59b66e27cf" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach durable storage while creating the data directory lock file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e096887a303519506fcd67516869ace11ad3e59e" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while adding a line to the data directory lock file.</source>
          <target state="translated">Ожидание выхода данных на стабильное хранение при добавлении строки в файл блокировки каталога данных.</target>
        </trans-unit>
        <trans-unit id="fe0ab1a16e2329bfa52c27e76aa50ab788d415cf" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while assigning WAL sync method.</source>
          <target state="translated">Ожидание достижения стабильного хранения данных при назначении метода синхронизации WAL.</target>
        </trans-unit>
        <trans-unit id="0a67fcfeb93618a5687879b86795e36261b23961" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while creating the data directory lock file.</source>
          <target state="translated">Ожидание выхода данных на стабильное хранение при создании файла блокировки каталога данных.</target>
        </trans-unit>
        <trans-unit id="1f817023f7f1aeed83afe73b277506f04bbf5f51" translate="yes" xml:space="preserve">
          <source>Waiting for group leader to clear transaction id at transaction end.</source>
          <target state="translated">Ожидание лидера группы,чтобы очистить идентификатор транзакции в конце транзакции.</target>
        </trans-unit>
        <trans-unit id="9ad12c44c511affe8e5b28dfe797e5442cb69ba2" translate="yes" xml:space="preserve">
          <source>Waiting for group leader to update transaction status at transaction end.</source>
          <target state="translated">Ожидание лидера группы для обновления статуса транзакции по окончании транзакции.</target>
        </trans-unit>
        <trans-unit id="6303bec3edc9303d1de1e17ffbef9d10deeb2ec7" translate="yes" xml:space="preserve">
          <source>Waiting for logical replication remote server to change state.</source>
          <target state="translated">Ожидание изменения состояния удаленного сервера логической репликации.</target>
        </trans-unit>
        <trans-unit id="a171ef7b847c02147b5330baa42032a3b728b099" translate="yes" xml:space="preserve">
          <source>Waiting for logical replication remote server to send data for initial table synchronization.</source>
          <target state="translated">Ожидание удаленного сервера логической репликации для отправки данных для начальной синхронизации таблиц.</target>
        </trans-unit>
        <trans-unit id="f7b87a554b163e3c4b56d071e13d3bb40ae9dcd8" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach durable storage during a checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0128fffe323c5eab36d0b583264686f6fdc14a9" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach durable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1252663514ce3e310a8ccaa53abc308558932c1" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach stable storage during a checkpoint.</source>
          <target state="translated">Ожидание логической перезаписи связок для достижения стабильного хранения во время контрольно-пропускного пункта.</target>
        </trans-unit>
        <trans-unit id="754897ce0cd2e99fe42e75806589d9d45f48b612" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach stable storage.</source>
          <target state="translated">Ожидание логической перезаписи отображений для достижения стабильного хранения.</target>
        </trans-unit>
        <trans-unit id="1012667842a00603eeb152c4741dc06b3a218b04" translate="yes" xml:space="preserve">
          <source>Waiting for mapping data to reach durable storage during a logical rewrite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddcc4581e90866cae66b033e94adc36e9d35b43d" translate="yes" xml:space="preserve">
          <source>Waiting for mapping data to reach stable storage during a logical rewrite.</source>
          <target state="translated">Ожидание отображения данных для достижения стабильного хранения во время логической перезаписи.</target>
        </trans-unit>
        <trans-unit id="b8552e94ff493c563b97bc367629ad56d62866bf" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish hashing the inner relation.</source>
          <target state="translated">Ожидание других участников Parallel Hash,чтобы закончить хеширование внутренней связи.</target>
        </trans-unit>
        <trans-unit id="e11479178e59844fd7fe15f1ce4eb490d0773d60" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish inserting tuples into new buckets.</source>
          <target state="translated">Ожидание других участников Parallel Hash,чтобы закончить вставлять кортежи в новые ведра.</target>
        </trans-unit>
        <trans-unit id="7c11b60c1a40d4f8d29e90353a8affe9075ec7f0" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish loading a hash table.</source>
          <target state="translated">Ожидание других участников Parallel Hash,чтобы закончить загрузку хеш-таблицы.</target>
        </trans-unit>
        <trans-unit id="5413b25ebacbf60f6298ddfd13544237708b4afd" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish partitioning the outer relation.</source>
          <target state="translated">Ожидание других участников Parallel Hash для завершения разбиения внешней связи.</target>
        </trans-unit>
        <trans-unit id="5d8612704b7ac31605b00f1b5ae0376a34a38614" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish repartitioning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ddf8230dce1afc618c7942a19d13a4e06fbab65" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finishing repartitioning.</source>
          <target state="translated">Ожидание других участников Parallel Hash для завершения переразметки.</target>
        </trans-unit>
        <trans-unit id="7ddcd3a1c9792343c59de081cc3c348d37cc1494" translate="yes" xml:space="preserve">
          <source>Waiting for other process to be attached in shared message queue.</source>
          <target state="translated">Ожидание прикрепления другого процесса в общей очереди сообщений.</target>
        </trans-unit>
        <trans-unit id="ea1e4d605c6dfe012718f5d6b6342a2c1167a5ba" translate="yes" xml:space="preserve">
          <source>Waiting for parallel &lt;code&gt;CREATE INDEX&lt;/code&gt; workers to finish heap scan.</source>
          <target state="translated">Ожидание, пока параллельные рабочие &lt;code&gt;CREATE INDEX&lt;/code&gt; завершат сканирование кучи.</target>
        </trans-unit>
        <trans-unit id="2c0e5b890525a78c621a8bd9247fc1bb58a1d9d0" translate="yes" xml:space="preserve">
          <source>Waiting for parallel bitmap scan to become initialized.</source>
          <target state="translated">Ожидание инициализации параллельного растрового сканирования.</target>
        </trans-unit>
        <trans-unit id="54d8ebcdd8df7afcbc1ca990a46b504e44b8711d" translate="yes" xml:space="preserve">
          <source>Waiting for parallel query dynamic shared memory allocation lock.</source>
          <target state="translated">Ожидание блокировки динамического выделения общей памяти для параллельных запросов.</target>
        </trans-unit>
        <trans-unit id="1fc906f71278562c97c85008b2e438b9bb00035c" translate="yes" xml:space="preserve">
          <source>Waiting for parallel query dynamic shared memory allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2ad8cbb3533dbd2f7a9b18414fee3c1da25764" translate="yes" xml:space="preserve">
          <source>Waiting for parallel workers to finish computing.</source>
          <target state="translated">Жду,когда параллельные работники закончат вычисления.</target>
        </trans-unit>
        <trans-unit id="be528b921033388197b955d3bbbb7b2e892893ec" translate="yes" xml:space="preserve">
          <source>Waiting for recovery conflict resolution for a vacuum cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c345abde177b384e76034b5919030c1a291113" translate="yes" xml:space="preserve">
          <source>Waiting for recovery conflict resolution for dropping a tablespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d3620b94d83d3288e29f36d6b41b0a233781347" translate="yes" xml:space="preserve">
          <source>Waiting for recovery to be resumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d884014cf602749f289dbc7c7fc61acad84fa09d" translate="yes" xml:space="preserve">
          <source>Waiting for standby promotion.</source>
          <target state="translated">Жду повышения по службе.</target>
        </trans-unit>
        <trans-unit id="8cb227e761e8b1bc97dcd2f57c98b273168fa6eb" translate="yes" xml:space="preserve">
          <source>Waiting for startup process to send initial data for streaming replication.</source>
          <target state="translated">Ожидание процесса запуска для отправки исходных данных для потоковой репликации.</target>
        </trans-unit>
        <trans-unit id="575b51c84a8a278b78f70ac32550deee0ade954c" translate="yes" xml:space="preserve">
          <source>Waiting for the &lt;code&gt;pg_control&lt;/code&gt; file to reach durable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de10813baf47bfe4c27cf4c7969243299b919ed" translate="yes" xml:space="preserve">
          <source>Waiting for the control file to reach stable storage.</source>
          <target state="translated">Ждем,когда контрольный файл достигнет стабильного хранилища.</target>
        </trans-unit>
        <trans-unit id="7dd0de4ea463c3d55bd0ecf6a2a3ba4fdd4c90a5" translate="yes" xml:space="preserve">
          <source>Waiting for the group leader to clear the transaction ID at end of a parallel operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d874537780129e3ca666a787de17aa9ba412019" translate="yes" xml:space="preserve">
          <source>Waiting for the group leader to update transaction status at end of a parallel operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681bd23f805b6da445bd3d82fc4a46addc600e13" translate="yes" xml:space="preserve">
          <source>Waiting for the page number needed to continue a parallel B-tree scan to become available.</source>
          <target state="translated">Ожидание номера страницы,необходимой для продолжения параллельного сканирования B-дерева,чтобы стать доступным.</target>
        </trans-unit>
        <trans-unit id="19a27081e7292e225f5308f76e3b7bb1b53bae9d" translate="yes" xml:space="preserve">
          <source>Waiting for the relation map file to reach durable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c939d0ba9c27dac2f7d8824016725fedd49ef586" translate="yes" xml:space="preserve">
          <source>Waiting for the relation map file to reach stable storage.</source>
          <target state="translated">Ожидание,когда файл карты соотношений достигнет стабильного хранилища.</target>
        </trans-unit>
        <trans-unit id="9e983510c142fcea08d4f84210ccfa6323d4b28e" translate="yes" xml:space="preserve">
          <source>Waiting for truncate of mapping data during a logical rewrite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7be20b27094dae3303ee1fadc67011cd3751be8" translate="yes" xml:space="preserve">
          <source>Waiting in WAL receiver to establish connection to remote server.</source>
          <target state="translated">Ожидание в WAL приемнике,чтобы установить соединение с удаленным сервером.</target>
        </trans-unit>
        <trans-unit id="8b6df6362589c923614f910bed59cf34ff945324" translate="yes" xml:space="preserve">
          <source>Waiting in WAL receiver to receive data from remote server.</source>
          <target state="translated">Ожидание в WAL приемнике для получения данных с удаленного сервера.</target>
        </trans-unit>
        <trans-unit id="cb632d8f0ca89d0c5cd00cc7485e8835401d24f7" translate="yes" xml:space="preserve">
          <source>Waiting in a cost-based vacuum delay point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb83e82efa5858b6db8ad5949e98eced2a90463a" translate="yes" xml:space="preserve">
          <source>Waiting in an extension.</source>
          <target state="translated">Жду в пристройке.</target>
        </trans-unit>
        <trans-unit id="feb270e93605e72d07d6bcedd0737f5a39e22df0" translate="yes" xml:space="preserve">
          <source>Waiting in background writer process, hibernating.</source>
          <target state="translated">Ожидание в процессе фонового написания,спячка.</target>
        </trans-unit>
        <trans-unit id="88eefbfbae399c6feea1548c69357a5e9736f5ab" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL receiver process.</source>
          <target state="translated">Ожидание в основном цикле процесса приемника WAL.</target>
        </trans-unit>
        <trans-unit id="375265f881add8dd9c33130678344167b52a9588" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL sender process.</source>
          <target state="translated">Ожидание в основном цикле процесса отправителя WAL.</target>
        </trans-unit>
        <trans-unit id="f5e173311caac73154fc23d76aed32502c099d08" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL writer process.</source>
          <target state="translated">Ожидание в основном цикле процесса записи WAL.</target>
        </trans-unit>
        <trans-unit id="3a633670f0870c8e9a937ee6b4ff3e55e43509be" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of archiver process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7acb76585737d883d007ddb658d4cfd89597eb50" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of autovacuum launcher process.</source>
          <target state="translated">Ожидание в главном контуре процесса автоматической вакуумной пусковой установки.</target>
        </trans-unit>
        <trans-unit id="7e6e41b3df7e89238ff4283ef4198a69ebe76109" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of background writer process background worker.</source>
          <target state="translated">Ожидание в основном цикле фонового рабочего процесса сценариста.</target>
        </trans-unit>
        <trans-unit id="4468be3c04a316f7404c95b5e3ff6208ba74e229" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of background writer process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d193be75953171ebbce3b3db2cde50e60c132491" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of checkpointer process.</source>
          <target state="translated">Ожидание в основном цикле процесса контрольного указателя.</target>
        </trans-unit>
        <trans-unit id="db02418c7eb01a5eb05765091cb30a31f71aa88d" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical apply process.</source>
          <target state="translated">Ожидание в основном цикле логического процесса применения.</target>
        </trans-unit>
        <trans-unit id="82a745dd84bf90f7ae367a6c7dc035147ac68293" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical launcher process.</source>
          <target state="translated">Ожидание в основном цикле логического процесса запуска.</target>
        </trans-unit>
        <trans-unit id="56edcd7dc5636046884520046ede7d834d729f36" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical replication apply process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9560c436af4a42ef660a92403ce9cdd3a8693974" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical replication launcher process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1679d413ddb6f0377771d12a5f1423b023c45511" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of startup process for WAL to arrive, during streaming recovery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3c72bbecc0f184f22e57ca78f3e93236b96e1a" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of statistics collector process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0772397293bff630517da7bd7ffb1ab81b17f5" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of syslogger process.</source>
          <target state="translated">Ожидание в основном цикле процесса syslogger.</target>
        </trans-unit>
        <trans-unit id="54f59b1a36db7407d20232e85176d4c1a23692f4" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of the archiver process.</source>
          <target state="translated">Ожидание в основном цикле процесса архиватора.</target>
        </trans-unit>
        <trans-unit id="212f0884ddfbc91689a2a97c09aafbcd3f389116" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of the statistics collector process.</source>
          <target state="translated">Ожидание в основном цикле процесса сбора статистики.</target>
        </trans-unit>
        <trans-unit id="3b4ceca9ff1b34dd3a21d5a1be2bf8a9aa711a70" translate="yes" xml:space="preserve">
          <source>Waiting in process that called &lt;code&gt;pg_sleep&lt;/code&gt;.</source>
          <target state="translated">Ожидание в процессе, который вызвал &lt;code&gt;pg_sleep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d789f564ccad610d19b36929dbb0ef518eb37c8" translate="yes" xml:space="preserve">
          <source>Waiting to access a data page in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ae79783ab5a39da6e76c4478527282bcedbc6a" translate="yes" xml:space="preserve">
          <source>Waiting to access a parallel query's information about composite types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d1b409aa03dee9b02a04e2a2e3f64452f3400a" translate="yes" xml:space="preserve">
          <source>Waiting to access a parallel query's information about type modifiers that identify anonymous record types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1030c503e3237c1219d1eea28582a6ddcbee56c" translate="yes" xml:space="preserve">
          <source>Waiting to access a shared TID bitmap during a parallel bitmap index scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eba3915c1db0580d2b281d905946603d4982aff" translate="yes" xml:space="preserve">
          <source>Waiting to access a shared tuple store during parallel query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129d2539d77dbbde3d4d4e8ea2141ca238f7d876" translate="yes" xml:space="preserve">
          <source>Waiting to access predicate lock information used by serializable transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7319b09761891c0f9227dbd3732f4b9eaeb8739" translate="yes" xml:space="preserve">
          <source>Waiting to access the &lt;code&gt;NOTIFY&lt;/code&gt; message SLRU cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1ca2e2935e52e66c06e90f2e54befc88f72df7" translate="yes" xml:space="preserve">
          <source>Waiting to access the commit timestamp SLRU cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0184a02009f44f4d2a88cbd98d9dfe8231fceb5e" translate="yes" xml:space="preserve">
          <source>Waiting to access the list of finished serializable transactions.</source>
          <target state="translated">Ожидание доступа к списку завершенных сериализуемых транзакций.</target>
        </trans-unit>
        <trans-unit id="55fba80517e3090a2255d706ee1972631c869d74" translate="yes" xml:space="preserve">
          <source>Waiting to access the list of predicate locks held by serializable transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47f83daf5272307314e793a722029f6849c834f" translate="yes" xml:space="preserve">
          <source>Waiting to access the list of predicate locks held by the current serializable transaction during a parallel query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d72c61a42652b27a772dd6eed5858254b3939df" translate="yes" xml:space="preserve">
          <source>Waiting to access the multixact member SLRU cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c797a16c61c341fd52d3f66bf04186016fb3de" translate="yes" xml:space="preserve">
          <source>Waiting to access the multixact offset SLRU cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860e2d04d5faad33e65a1c939bd5f4775f44e584" translate="yes" xml:space="preserve">
          <source>Waiting to access the serializable transaction conflict SLRU cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c61dc32e3583de9339bc9f5339255eccb847d4" translate="yes" xml:space="preserve">
          <source>Waiting to access the shared per-process data structures (typically, to get a snapshot or report a session's transaction ID).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be8feecbd6665e987b15bc5fe4b1aa15dcee557" translate="yes" xml:space="preserve">
          <source>Waiting to access the sub-transaction SLRU cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb9c50c150b703d0eb8293a5862178e36f3db67f" translate="yes" xml:space="preserve">
          <source>Waiting to access the transaction status SLRU cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="453521c4c18069faa9fd0afad3d83ca7731d1096" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a non-relation database object.</source>
          <target state="translated">Ждем,когда получим замок на объект нереляционной базы данных.</target>
        </trans-unit>
        <trans-unit id="373b1f9b0bfcc9c3b92c4d65ca011a20f7f7ee7b" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a page of a relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e200aae0e4f2353a2c19cd08c7d6ee7ce7f912" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a relation.</source>
          <target state="translated">В ожидании,чтобы получить замок на связь.</target>
        </trans-unit>
        <trans-unit id="caf9078aaa0a5a46ce631268ce4c46ea2cb0e198" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a tuple.</source>
          <target state="translated">Жду,когда получу замок на кортеж.</target>
        </trans-unit>
        <trans-unit id="20d61e9ac29e8e57ca0786825f9ae212af87d782" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on page of a relation.</source>
          <target state="translated">Ждем,когда получим замок на странице отношений.</target>
        </trans-unit>
        <trans-unit id="60529117b6f828f517a439e0152cfca12a03780e" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a pin on a buffer.</source>
          <target state="translated">Жду,когда получу штырь на буфере.</target>
        </trans-unit>
        <trans-unit id="9dff15d412549524e8b05e08b4e658a978321307" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a speculative insertion lock.</source>
          <target state="translated">Жду,когда получу фиксатор для спекулятивных вставок.</target>
        </trans-unit>
        <trans-unit id="6f1d92a10ff6e0f42c232bac9cd39b9515b5e1f1" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a user lock.</source>
          <target state="translated">Ждем,когда получим пользовательский замок.</target>
        </trans-unit>
        <trans-unit id="b864edb73d7fdb51b089c159fd2e24aac209fa44" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a virtual transaction ID lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feee645b171eddc5255ea3172e0b6eaae2f3531e" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a virtual xid lock.</source>
          <target state="translated">В ожидании получения виртуального ксид-блока.</target>
        </trans-unit>
        <trans-unit id="0cff112c15e1e7f938ee8722e01003e541c3a9b9" translate="yes" xml:space="preserve">
          <source>Waiting to acquire an advisory user lock.</source>
          <target state="translated">Ждем,когда получим консультативный пользовательский замок.</target>
        </trans-unit>
        <trans-unit id="fb4afc5fd680e2c4a5249b716bc3eb3612204493" translate="yes" xml:space="preserve">
          <source>Waiting to acquire an exclusive pin on a buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b782a596b50a85963931c1ce8ff87a36ab9e82" translate="yes" xml:space="preserve">
          <source>Waiting to add a message in shared invalidation queue.</source>
          <target state="translated">Ожидание добавления сообщения в общую очередь проверки недействительности.</target>
        </trans-unit>
        <trans-unit id="e0bc3fce7ad76f7cd0de9cfb2f8867086e1cad27" translate="yes" xml:space="preserve">
          <source>Waiting to add a message to the shared catalog invalidation queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30c5b64b9088c9bea1b788c2d9cad490d0feadc" translate="yes" xml:space="preserve">
          <source>Waiting to add or examine locks for backends, or waiting to join or exit a locking group (used by parallel query).</source>
          <target state="translated">Ожидание добавления или изучения блокировок для бэкендов,или ожидание вступления или выхода из группы блокировок (используется параллельным запросом).</target>
        </trans-unit>
        <trans-unit id="4234f3768471935481a7a5ac70e216c3b3196d0a" translate="yes" xml:space="preserve">
          <source>Waiting to add or examine predicate lock information.</source>
          <target state="translated">В ожидании добавления или изучения информации о предикатном замке.</target>
        </trans-unit>
        <trans-unit id="cd6ab73b17fc50224d6ba20de7b66c56a5168edd" translate="yes" xml:space="preserve">
          <source>Waiting to allocate a new OID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6110497bf2fb4e7dd3e567f14149228534e81be" translate="yes" xml:space="preserve">
          <source>Waiting to allocate a new transaction ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922ece807fb5d0e3eca745374502101b8e2f9883" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or assign a transaction id.</source>
          <target state="translated">Ожидание выделения или назначения идентификатора транзакции.</target>
        </trans-unit>
        <trans-unit id="4df1187e247ec9e3885764b731ccac5a81693366" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or assign an OID.</source>
          <target state="translated">Ожидание выделения или назначения OID.</target>
        </trans-unit>
        <trans-unit id="36e78f99b93b8582ddda9533616d35bad0cb3435" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or exchange a chunk of memory or update counters during Parallel Hash plan execution.</source>
          <target state="translated">Ожидание выделения или обмена фрагмента памяти или счетчиков обновлений во время выполнения плана Parallel Hash.</target>
        </trans-unit>
        <trans-unit id="aea0084a8686cdd126b6dc0b70e3bb510372f940" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or free a replication slot.</source>
          <target state="translated">Ожидание выделения или освобождения слота для репликации.</target>
        </trans-unit>
        <trans-unit id="392b0fcbf6923b50ad00d9bcdf711922567f010a" translate="yes" xml:space="preserve">
          <source>Waiting to apply WAL at recovery because it is delayed.</source>
          <target state="translated">Ожидание применения WAL при восстановлении,потому что оно задерживается.</target>
        </trans-unit>
        <trans-unit id="6a88aa7353a070ee85e5931747ec79047e6808c8" translate="yes" xml:space="preserve">
          <source>Waiting to apply WAL during recovery because of a delay setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417e2e4d470ba2ea215e899c1f2f47a808b6cd1d" translate="yes" xml:space="preserve">
          <source>Waiting to associate a data block with a buffer in the buffer pool.</source>
          <target state="translated">Ожидание ассоциирования блока данных с буфером в буферном пуле.</target>
        </trans-unit>
        <trans-unit id="441c3081779de229e60de2154d2224a6b45068d6" translate="yes" xml:space="preserve">
          <source>Waiting to begin a checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5eba1b1476e67df8c9026fe8a8423164cbbbaf" translate="yes" xml:space="preserve">
          <source>Waiting to choose the next subplan during Parallel Append plan execution.</source>
          <target state="translated">Ожидание выбора следующего подплана во время выполнения плана Parallel Append.</target>
        </trans-unit>
        <trans-unit id="ef3a63e38286ce146119c1f18cfc00a196004cf5" translate="yes" xml:space="preserve">
          <source>Waiting to create or drop a tablespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11402cb956b4c4ad7b4f3ee48f5957e1d0e2837b" translate="yes" xml:space="preserve">
          <source>Waiting to create or drop the tablespace.</source>
          <target state="translated">Ожидание,чтобы создать или бросить табличное пространство.</target>
        </trans-unit>
        <trans-unit id="33c72accbdd4730b372dab88dd65b76db73de627" translate="yes" xml:space="preserve">
          <source>Waiting to create, drop or use a replication origin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bc84d857a25120993bfa2901196e8db0fe8c4c" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate a hash table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f746425fc465e7164c9c695db3b4635155f935" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate more batches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639eee9765487a635a37650a7d0fb63770b1ca2a" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate more buckets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5677145792ffce4d3d31df1e9a789e136de6ea8" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate the initial hash table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065be077f679b5dad73d4b8a473bd2b28958e69a" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to decide on future batch growth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f5db2c59767bd472dd0b1faf70ac07aafa7a96" translate="yes" xml:space="preserve">
          <source>Waiting to ensure that a table selected for autovacuum still needs vacuuming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef13562f4466bb31b5bf871e5d3f767784c48032" translate="yes" xml:space="preserve">
          <source>Waiting to ensure that the table it has selected for a vacuum still needs vacuuming.</source>
          <target state="translated">Ждем,пока стол,выбранный для работы в вакууме,все еще нуждается в вакуумировании.</target>
        </trans-unit>
        <trans-unit id="d69f496f29eae75635234b22654119ee74ecb1dc" translate="yes" xml:space="preserve">
          <source>Waiting to execute &lt;code&gt;pg_xact_status&lt;/code&gt; or update the oldest transaction ID available to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2e90490a1d7b7d270317787f40bff2e1d72ee9" translate="yes" xml:space="preserve">
          <source>Waiting to execute &lt;code&gt;txid_status&lt;/code&gt; or update the oldest transaction id available to it.</source>
          <target state="translated">Ожидание выполнения &lt;code&gt;txid_status&lt;/code&gt; или обновления самого старого доступного идентификатора транзакции.</target>
        </trans-unit>
        <trans-unit id="905b59818613073e2e260c6b0fb7d68bf3c39843" translate="yes" xml:space="preserve">
          <source>Waiting to extend a relation.</source>
          <target state="translated">Жду продолжения отношений.</target>
        </trans-unit>
        <trans-unit id="d1ff05f0321453c7e170463f2183122fba046afb" translate="yes" xml:space="preserve">
          <source>Waiting to fill a dynamic shared memory backing file with zeroes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b7f54188ceea3dc5def955dc47ae1f28373839" translate="yes" xml:space="preserve">
          <source>Waiting to find or allocate space in shared memory.</source>
          <target state="translated">Ожидание,чтобы найти или выделить место в общей памяти.</target>
        </trans-unit>
        <trans-unit id="fb53c073cc374cfb75fd8b826e6b4d7eb6cc9003" translate="yes" xml:space="preserve">
          <source>Waiting to get a snapshot or clearing a transaction id at transaction end.</source>
          <target state="translated">В ожидании моментального снимка или очистки идентификатора транзакции в конце транзакции.</target>
        </trans-unit>
        <trans-unit id="e384d346b49ba85024e06c032fcf3ccf1737b636" translate="yes" xml:space="preserve">
          <source>Waiting to get the start location of a scan on a table for synchronized scans.</source>
          <target state="translated">Ждем,чтобы получить начальное местоположение сканирования на столе для синхронизированных сканирований.</target>
        </trans-unit>
        <trans-unit id="77a61ca13921177e3120d7941bf5fe7710333ad3" translate="yes" xml:space="preserve">
          <source>Waiting to insert WAL data into a memory buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6beee315605623099d06c2371ae56da6b46cc7" translate="yes" xml:space="preserve">
          <source>Waiting to insert WAL into a memory buffer.</source>
          <target state="translated">Ожидание,когда WAL будет вставлен в буфер памяти.</target>
        </trans-unit>
        <trans-unit id="cadbcac0880c9c035e541586388a47501c362c88" translate="yes" xml:space="preserve">
          <source>Waiting to manage an extension's space allocation in shared memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4ce59b2db271f1abfb91f4099370c7dcadc0ae" translate="yes" xml:space="preserve">
          <source>Waiting to manage fsync requests.</source>
          <target state="translated">В ожидании управления запросами fsync.</target>
        </trans-unit>
        <trans-unit id="e3141c5d05c342451c8644a34df11be83dd434ad" translate="yes" xml:space="preserve">
          <source>Waiting to manage space allocation in shared memory.</source>
          <target state="translated">Ожидание,чтобы управлять распределением пространства в общей памяти.</target>
        </trans-unit>
        <trans-unit id="fac57a518044fa2f05c64ea1dd8ce9527a59af1f" translate="yes" xml:space="preserve">
          <source>Waiting to obtain a valid snapshot for a &lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97c8584b996285f48aeab64ef02658839acbba9" translate="yes" xml:space="preserve">
          <source>Waiting to perform an operation on a list of locks held by serializable transactions.</source>
          <target state="translated">Ожидание выполнения операции по списку замков,удерживаемых сериализуемыми транзакциями.</target>
        </trans-unit>
        <trans-unit id="d8589a1b8c66d6f8e4debafdd099f1a4b71a5b13" translate="yes" xml:space="preserve">
          <source>Waiting to perform an operation on a serializable transaction in a parallel query.</source>
          <target state="translated">Ожидание выполнения операции по последовательной транзакции в параллельном запросе.</target>
        </trans-unit>
        <trans-unit id="d2ade432e382335fbb1d6fb86bda4500ee8c2cbb" translate="yes" xml:space="preserve">
          <source>Waiting to perform checkpoint.</source>
          <target state="translated">Жду,когда будет выполнен контрольно-пропускной пункт.</target>
        </trans-unit>
        <trans-unit id="3e379fd689c1e6c70aa9f8b650b7c7fb7692028c" translate="yes" xml:space="preserve">
          <source>Waiting to read data from the client while establishing a GSSAPI session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1908bfbabea7a0ab1bbde739ebc0330fc7517b79" translate="yes" xml:space="preserve">
          <source>Waiting to read data from the client.</source>
          <target state="translated">В ожидании считывания данных от клиента.</target>
        </trans-unit>
        <trans-unit id="05dd640e8c1d54ebf01054c0befd12ca4f14b63e" translate="yes" xml:space="preserve">
          <source>Waiting to read or record conflicting serializable transactions.</source>
          <target state="translated">Ожидание,чтобы прочитать или записать противоречащие друг другу сериализуемые транзакции.</target>
        </trans-unit>
        <trans-unit id="0afe38ebe7d995583b3d1a5cd94b6fbc8cf1b845" translate="yes" xml:space="preserve">
          <source>Waiting to read or truncate multixact information.</source>
          <target state="translated">В ожидании прочтения или усечения многофакторной информации.</target>
        </trans-unit>
        <trans-unit id="89e6d605086c4806a8e8361ed20ce472bcc5d0c1" translate="yes" xml:space="preserve">
          <source>Waiting to read or update &lt;code&gt;NOTIFY&lt;/code&gt; messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2ee7fba8bdd1b9ba46fd013db4148ed8d4f325" translate="yes" xml:space="preserve">
          <source>Waiting to read or update a &lt;code&gt;pg_filenode.map&lt;/code&gt; file (used to track the filenode assignments of certain system catalogs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06b28a219ba82487eff75cb07672ef51a1fba36" translate="yes" xml:space="preserve">
          <source>Waiting to read or update a &lt;code&gt;pg_internal.init&lt;/code&gt; relation cache initialization file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29aea2dafdc907848a947f9ada3488409914bca8" translate="yes" xml:space="preserve">
          <source>Waiting to read or update a process' fast-path lock information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a018a1a15593b5af23414939d50aec3fcb48c5cb" translate="yes" xml:space="preserve">
          <source>Waiting to read or update background worker state.</source>
          <target state="translated">Ожидание,чтобы прочитать или обновить фоновое состояние работника.</target>
        </trans-unit>
        <trans-unit id="98f949b18dca9797ce85a82873e92ff14c18778a" translate="yes" xml:space="preserve">
          <source>Waiting to read or update dynamic shared memory allocation information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea27617060567594092b7422c38330bfc2e5ee2" translate="yes" xml:space="preserve">
          <source>Waiting to read or update dynamic shared memory state.</source>
          <target state="translated">Ожидание чтения или обновления динамического общего состояния памяти.</target>
        </trans-unit>
        <trans-unit id="9ba9dcf3b19a57aaa5ade4bb0b3f5c3178217365" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about &amp;ldquo;heavyweight&amp;rdquo; locks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aef06dd768e3617fde4dd6b5fb7f38e7fb0ef3c" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about serializable transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b94e34a6c9a38b9de8ddbf38266ea41569caa0e" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about synchronous replicas.</source>
          <target state="translated">Ожидание прочтения или обновления информации о синхронных репликах.</target>
        </trans-unit>
        <trans-unit id="8db953a370c198b1e5b5a6d588d15d8ed6771d32" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about the state of synchronous replication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be479f3c24eeb847b5e44a9bf4f341c29d1834b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update multixact member mappings.</source>
          <target state="translated">Ожидание,чтобы прочитать или обновить многофакторные отображения членов.</target>
        </trans-unit>
        <trans-unit id="548a78a89a3c004e9ad475a70fb6f1bb50c1151e" translate="yes" xml:space="preserve">
          <source>Waiting to read or update multixact offset mappings.</source>
          <target state="translated">Ожидание чтения или обновления многофакторных отображений смещения.</target>
        </trans-unit>
        <trans-unit id="ed18ac469b6f870e80be0efbf5c76a4d5c79b754" translate="yes" xml:space="preserve">
          <source>Waiting to read or update notification messages.</source>
          <target state="translated">Ожидание прочтения или обновления уведомлений.</target>
        </trans-unit>
        <trans-unit id="76d4dfb568ccc6112df58f601dc5c426ad5d62a8" translate="yes" xml:space="preserve">
          <source>Waiting to read or update old snapshot control information.</source>
          <target state="translated">Ожидание,чтобы прочитать или обновить старую информацию управления снимком.</target>
        </trans-unit>
        <trans-unit id="6ce0cc66a076e07f94b764161b2bddd57ada2509" translate="yes" xml:space="preserve">
          <source>Waiting to read or update replication slot state.</source>
          <target state="translated">Ожидание прочтения или обновления состояния слота репликации.</target>
        </trans-unit>
        <trans-unit id="fff67315163276ff44c96c0a78a1830dd666732b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update shared multixact state.</source>
          <target state="translated">Ожидание прочтения или обновления общего многофакторного состояния.</target>
        </trans-unit>
        <trans-unit id="b79ef3c6f580409e99c1e495bc8e24c202fbe7ed" translate="yes" xml:space="preserve">
          <source>Waiting to read or update shared notification state.</source>
          <target state="translated">Ожидание прочтения или обновления общего состояния уведомления.</target>
        </trans-unit>
        <trans-unit id="af64ba8ecf87cac9594cd6dc3c61c2e7ddf060d1" translate="yes" xml:space="preserve">
          <source>Waiting to read or update sub-transaction information.</source>
          <target state="translated">Ожидание прочтения или обновления информации о подтранзакциях.</target>
        </trans-unit>
        <trans-unit id="c25e2fc156128ae3093a921e12431593e8862638" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the &lt;code&gt;pg_control&lt;/code&gt; file or create a new WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb0edf32466a645cdde40c21227abb2a0bb1f30" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the control file or creation of a new WAL file.</source>
          <target state="translated">Ожидание чтения или обновления управляющего файла или создания нового файла WAL.</target>
        </trans-unit>
        <trans-unit id="017527ae52f7de277c3c95bf02bbacf34474f0f5" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the current state of autovacuum workers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221da797b029fb896c5fbaed99fd507a4ef2a941" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the fast-path lock information.</source>
          <target state="translated">Ожидание,чтобы прочитать или обновить информацию о быстрой блокировки пути.</target>
        </trans-unit>
        <trans-unit id="744cbcf49721354a8aff1c310f4ca421dbb8db3a" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the last value set for a transaction commit timestamp.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9baf36ef5d66bb0ea1e99230d14314cf70bc406" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the last value set for the transaction timestamp.</source>
          <target state="translated">Ожидание,чтобы прочитать или обновить последнее значение,установленное для метки времени транзакции.</target>
        </trans-unit>
        <trans-unit id="e381bb78e4f640c21175ed08f51ed2c3a71544c7" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the progress of one replication origin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f6ffef563dec9ba786a7f233d5003f5ed45d14" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the replication progress.</source>
          <target state="translated">Ожидание прочтения или обновления информации о ходе репликации.</target>
        </trans-unit>
        <trans-unit id="9ed2e28217e033a2eda63210c67632651e72f60a" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the state of logical replication workers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="defd9a9d465fec9edd19efb8c557ca9acbf7364b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the state of prepared transactions.</source>
          <target state="translated">Ожидание прочтения или обновления состояния подготовленных транзакций.</target>
        </trans-unit>
        <trans-unit id="3dc7e6836006d3d5cbb7a9151c1a348063bbcc88" translate="yes" xml:space="preserve">
          <source>Waiting to read or update transaction commit timestamps.</source>
          <target state="translated">Ожидание прочтения или обновления меток времени фиксации транзакций.</target>
        </trans-unit>
        <trans-unit id="22fb7890af933754ae7b2b3d81b6bd6e23c2cc52" translate="yes" xml:space="preserve">
          <source>Waiting to read or update transaction status.</source>
          <target state="translated">Ожидание прочтения или обновления статуса транзакции.</target>
        </trans-unit>
        <trans-unit id="1691bd5ffa74ce0764d59f613b874fce42907700" translate="yes" xml:space="preserve">
          <source>Waiting to read or update vacuum-related information for a B-tree index.</source>
          <target state="translated">Ожидание,чтобы прочитать или обновить информацию,связанную с вакуумом для индекса B-дерева.</target>
        </trans-unit>
        <trans-unit id="7909f678b84800f1b2a16328d0f20ff93a738a0c" translate="yes" xml:space="preserve">
          <source>Waiting to read or write a data page in memory.</source>
          <target state="translated">Ожидание,чтобы прочитать или записать страницу данных в памяти.</target>
        </trans-unit>
        <trans-unit id="ba3f3c6d87b25a2add5f41dc054490a6748416d8" translate="yes" xml:space="preserve">
          <source>Waiting to read or write relation cache initialization file.</source>
          <target state="translated">Ожидание чтения или записи файла инициализации отношения к кэша.</target>
        </trans-unit>
        <trans-unit id="56e29e2fa37b4e49226f461d31f27cc492afa177" translate="yes" xml:space="preserve">
          <source>Waiting to read while creating the data directory lock file.</source>
          <target state="translated">Ожидание чтения при создании файла блокировки директории данных.</target>
        </trans-unit>
        <trans-unit id="22b6a17e9f6b4570d83c86bfc0b1331afbfa69c0" translate="yes" xml:space="preserve">
          <source>Waiting to receive bytes from a shared message queue.</source>
          <target state="translated">Ожидание получения байтов из общей очереди сообщений.</target>
        </trans-unit>
        <trans-unit id="9ce53a35add68653a7082475749be3845de4e91c" translate="yes" xml:space="preserve">
          <source>Waiting to replace a page in WAL buffers.</source>
          <target state="translated">В ожидании замены страницы в буферах WAL.</target>
        </trans-unit>
        <trans-unit id="c84c4a6cb5ccf93e74ddb23312f4a777174ed071" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve messages from the shared catalog invalidation queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b17dffde0ea5035f1032f34d22df0ea10ab951" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve or remove messages from shared invalidation queue.</source>
          <target state="translated">Ожидание получения или удаления сообщений из общей очереди аннулирования.</target>
        </trans-unit>
        <trans-unit id="4f507f65bfda2fa748e9dfb44f6b949cbab52bf9" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve or store information about serializable transactions.</source>
          <target state="translated">В ожидании получения или хранения информации о сериализуемых сделках.</target>
        </trans-unit>
        <trans-unit id="eda502d0abfb7f1427a080a8bf7103d25fc2176f" translate="yes" xml:space="preserve">
          <source>Waiting to select the starting location of a synchronized table scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9928fb30a8b9bafde30f4c1a7932ab2be3ad802" translate="yes" xml:space="preserve">
          <source>Waiting to send bytes to a shared message queue.</source>
          <target state="translated">Ожидание отправки байтов в общую очередь сообщений.</target>
        </trans-unit>
        <trans-unit id="352defc191b1b37d8d934ce574b79689999451d7" translate="yes" xml:space="preserve">
          <source>Waiting to setup, drop or use replication origin.</source>
          <target state="translated">Ожидание установки,сброс или использование источника репликации.</target>
        </trans-unit>
        <trans-unit id="25cb6ca2b8d634f565c4d46066dc5f3462003ea1" translate="yes" xml:space="preserve">
          <source>Waiting to synchronize workers during Parallel Hash Join plan execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9266129c75950e38bd53efc5efcc13655677392e" translate="yes" xml:space="preserve">
          <source>Waiting to update &lt;code&gt;pg_database&lt;/code&gt;.&lt;code&gt;datfrozenxid&lt;/code&gt; and &lt;code&gt;pg_database&lt;/code&gt;.&lt;code&gt;datminmxid&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb44735a3aba3220d386c9b3faf0ba38310b7b2b" translate="yes" xml:space="preserve">
          <source>Waiting to update limit on &lt;code&gt;NOTIFY&lt;/code&gt; message storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bedfd2279a25f8b35eba1268870241ba6990c56e" translate="yes" xml:space="preserve">
          <source>Waiting to update limits on transaction id and multixact consumption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b1822a05f8be538a4edd0d27d811178799d3aa" translate="yes" xml:space="preserve">
          <source>Waiting to update the &lt;code&gt;postgresql.auto.conf&lt;/code&gt; file.</source>
          <target state="translated">Ожидание обновления файла &lt;code&gt;postgresql.auto.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f7ad4b1674906a82b48581d682f5005d47dd119" translate="yes" xml:space="preserve">
          <source>Waiting to update the relation map file used to store catalog to filenode mapping.</source>
          <target state="translated">Ожидание обновления файла карты соотношений,используемого для хранения каталога для отображения файлов.</target>
        </trans-unit>
        <trans-unit id="8dc204f5803f3077a290dca7bb374395f034529e" translate="yes" xml:space="preserve">
          <source>Waiting to write a protocol message to a shared message queue.</source>
          <target state="translated">В ожидании написания протокольного сообщения в общую очередь сообщений.</target>
        </trans-unit>
        <trans-unit id="2d0728d153f9f18004a22e4fb271924454b6a556" translate="yes" xml:space="preserve">
          <source>Waiting to write data to the client.</source>
          <target state="translated">В ожидании записи данных клиенту.</target>
        </trans-unit>
        <trans-unit id="65a1974782cb646a2959736cb6599731cefd99f2" translate="yes" xml:space="preserve">
          <source>Waiting to write zero bytes to a dynamic shared memory backing file.</source>
          <target state="translated">Ожидание записи нулевых байт в файл динамической общей памяти.</target>
        </trans-unit>
        <trans-unit id="0929df55dd9f72fd6c1d910f07bdae3bd6e941bb" translate="yes" xml:space="preserve">
          <source>Warm and hot standby servers can be kept current by reading a stream of write-ahead log (WAL) records. If the main server fails, the standby contains almost all of the data of the main server, and can be quickly made the new master database server. This can be synchronous or asynchronous and can only be done for the entire database server.</source>
          <target state="translated">Серверы теплого и горячего резервирования могут поддерживаться в актуальном состоянии путем чтения потока записей журнала (WAL).В случае выхода из строя главного сервера,в режиме ожидания хранятся почти все данные главного сервера,и можно быстро сделать новый главный сервер базы данных.Это может быть синхронным или асинхронным и может быть сделано только для всего сервера БД.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="a016c375864acf9c142cbb1359e053c54d4d9438" translate="yes" xml:space="preserve">
          <source>We already saw that &lt;code&gt;ORDER BY&lt;/code&gt; can be omitted if the ordering of rows is not important. It is also possible to omit &lt;code&gt;PARTITION BY&lt;/code&gt;, in which case there is a single partition containing all rows.</source>
          <target state="translated">Мы уже видели, что &lt;code&gt;ORDER BY&lt;/code&gt; можно опустить, если порядок строк не важен. Также можно опустить &lt;code&gt;PARTITION BY&lt;/code&gt; , и в этом случае будет один раздел, содержащий все строки.</target>
        </trans-unit>
        <trans-unit id="836ee2eeb6e7ae6444006848acb871065ea3b213" translate="yes" xml:space="preserve">
          <source>We already saw the MCV information for &lt;code&gt;stringu1&lt;/code&gt;, and here is its histogram:</source>
          <target state="translated">Мы уже видели информацию MCV для &lt;code&gt;stringu1&lt;/code&gt; , и вот его гистограмма:</target>
        </trans-unit>
        <trans-unit id="4916a888ae7040005cd716f2c3e28e1930fe1e1c" translate="yes" xml:space="preserve">
          <source>We also want a guarantee that once a transaction is completed and acknowledged by the database system, it has indeed been permanently recorded and won't be lost even if a crash ensues shortly thereafter. For example, if we are recording a cash withdrawal by Bob, we do not want any chance that the debit to his account will disappear in a crash just after he walks out the bank door. A transactional database guarantees that all the updates made by a transaction are logged in permanent storage (i.e., on disk) before the transaction is reported complete.</source>
          <target state="translated">Мы также хотим получить гарантию того,что после завершения транзакции и ее подтверждения системой базы данных,она действительно была зафиксирована на постоянной основе и не будет потеряна,даже если вскоре после этого произойдет авария.Например,если мы регистрируем снятие наличных Бобом,мы не хотим,чтобы дебет его счета исчез в аварии сразу после того,как он выйдет из двери банка.База данных транзакций гарантирует,что все обновления,сделанные транзакцией,записываются в постоянное хранилище (т.е.на диске)до того,как будет сообщено о завершении транзакции.</target>
        </trans-unit>
        <trans-unit id="6743dd465747bd2e107f6841f4c88e12a10fdc63" translate="yes" xml:space="preserve">
          <source>We can also access arbitrary rectangular slices of an array, or subarrays. An array slice is denoted by writing &lt;code&gt;lower-bound:upper-bound&lt;/code&gt; for one or more array dimensions. For example, this query retrieves the first item on Bill's schedule for the first two days of the week:</source>
          <target state="translated">Мы также можем получить доступ к произвольным прямоугольным срезам массива или подмассивам. Срез массива обозначается записью &lt;code&gt;lower-bound:upper-bound&lt;/code&gt; для одного или нескольких измерений массива. Например, этот запрос извлекает первый элемент в расписании Билла на первые два дня недели:</target>
        </trans-unit>
        <trans-unit id="26d5e00c2932aa021f71e1c7987bbc84382d9b85" translate="yes" xml:space="preserve">
          <source>We can also choose to return &lt;code&gt;NULL&lt;/code&gt;, instead of the lower-cased word, if it is not found in the stop words file. This behavior is selected by setting the dictionary's &lt;code&gt;Accept&lt;/code&gt; parameter to &lt;code&gt;false&lt;/code&gt;. Continuing the example:</source>
          <target state="translated">Мы также можем выбрать возврат &lt;code&gt;NULL&lt;/code&gt; вместо слова в нижнем регистре, если оно не найдено в файле стоп-слов. Это поведение выбирается установкой для параметра &lt;code&gt;Accept&lt;/code&gt; словаря значения &lt;code&gt;false&lt;/code&gt; . Продолжая пример:</target>
        </trans-unit>
        <trans-unit id="dfd312f5fc4d67101d851237062bdba159c0ec59" translate="yes" xml:space="preserve">
          <source>We can also join a table against itself. This is called a &lt;em&gt;self join&lt;/em&gt;. As an example, suppose we wish to find all the weather records that are in the temperature range of other weather records. So we need to compare the &lt;code&gt;temp_lo&lt;/code&gt; and &lt;code&gt;temp_hi&lt;/code&gt; columns of each &lt;code&gt;weather&lt;/code&gt; row to the &lt;code&gt;temp_lo&lt;/code&gt; and &lt;code&gt;temp_hi&lt;/code&gt; columns of all other &lt;code&gt;weather&lt;/code&gt; rows. We can do this with the following query:</source>
          <target state="translated">Мы также можем присоединиться к столу против себя. Это называется &lt;em&gt;самосоединением&lt;/em&gt; . В качестве примера предположим, что мы хотим найти все погодные записи, которые находятся в температурном диапазоне других погодных записей. Поэтому нам нужно сравнить &lt;code&gt;temp_lo&lt;/code&gt; и &lt;code&gt;temp_hi&lt;/code&gt; каждой строки &lt;code&gt;weather&lt;/code&gt; со &lt;code&gt;temp_lo&lt;/code&gt; и &lt;code&gt;temp_hi&lt;/code&gt; всех других строк &lt;code&gt;weather&lt;/code&gt; . Мы можем сделать это с помощью следующего запроса:</target>
        </trans-unit>
        <trans-unit id="4dc6beb3b0e1bef62d183184143ea3d3ef810b4c" translate="yes" xml:space="preserve">
          <source>We can change the rewriting rules just by updating the table:</source>
          <target state="translated">Мы можем изменить правила переписывания,просто обновив таблицу:</target>
        </trans-unit>
        <trans-unit id="ee2618785314089b8d336377e9a207db9405d3b4" translate="yes" xml:space="preserve">
          <source>We can create a GIN index (&lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;) to speed up text searches:</source>
          <target state="translated">Мы можем создать индекс GIN ( &lt;a href=&quot;textsearch-indexes&quot;&gt;раздел 12.9&lt;/a&gt; ) для ускорения текстового поиска:</target>
        </trans-unit>
        <trans-unit id="c7821bbb704a2ac952eb9690616bfdd424400d47" translate="yes" xml:space="preserve">
          <source>We can do inheritance:</source>
          <target state="translated">Мы можем сделать наследство:</target>
        </trans-unit>
        <trans-unit id="d91685339d290a8a5e3f0243e992defd515e095f" translate="yes" xml:space="preserve">
          <source>We can then see that an administrator connecting over a network will not see any records, due to the restrictive policy:</source>
          <target state="translated">Затем мы видим,что администратор,подключающийся по сети,не увидит никаких записей из-за ограничительной политики:</target>
        </trans-unit>
        <trans-unit id="9e7ee16addc76bca0dc0a634456700165327da1e" translate="yes" xml:space="preserve">
          <source>We can update an individual subfield of a composite column:</source>
          <target state="translated">Мы можем обновить отдельное подполе составной колонки:</target>
        </trans-unit>
        <trans-unit id="dbaecdebc4248cd30d99181acc6ee4648ce55281" translate="yes" xml:space="preserve">
          <source>We choose not to index or search some token types that the built-in configuration does handle:</source>
          <target state="translated">Мы выбираем не индексировать или искать некоторые типы токенов,с которыми работает встроенная конфигурация:</target>
        </trans-unit>
        <trans-unit id="f68910847b8b293ecced82107bbdb7c9e86be5f0" translate="yes" xml:space="preserve">
          <source>We could also have written:</source>
          <target state="translated">Мы также могли бы написать:</target>
        </trans-unit>
        <trans-unit id="1af074a97ee1433a54eef949ce0f504465ee61b0" translate="yes" xml:space="preserve">
          <source>We could simplify this by creating a SQL function that inserts a label at a specified position in a path:</source>
          <target state="translated">Мы могли бы упростить это,создав функцию SQL,которая вставляет метку в указанную позицию в пути:</target>
        </trans-unit>
        <trans-unit id="10ed1bedde4f0b0f00a9838d665bf3bd179f0836" translate="yes" xml:space="preserve">
          <source>We define the synonym dictionary like this:</source>
          <target state="translated">Мы определяем синонимный словарь вот так:</target>
        </trans-unit>
        <trans-unit id="d488cdbcb41070244eeea7399c07a12ab608b66e" translate="yes" xml:space="preserve">
          <source>We do not need a perfectly consistent file system backup as the starting point. Any internal inconsistency in the backup will be corrected by log replay (this is not significantly different from what happens during crash recovery). So we do not need a file system snapshot capability, just tar or a similar archiving tool.</source>
          <target state="translated">Нам не нужна абсолютно последовательная резервная копия файловой системы в качестве отправной точки.Любое внутреннее несоответствие в резервной копии будет исправлено воспроизведением журнала (это не сильно отличается от того,что происходит во время аварийного восстановления).Поэтому нам не нужна возможность делать снимки файловой системы,только tar или аналогичный инструмент для архивирования.</target>
        </trans-unit>
        <trans-unit id="7d9a8fa7a3f06527b3bcf2908ca8717c376647ee" translate="yes" xml:space="preserve">
          <source>We have already discussed constants in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The following sections discuss the remaining options.</source>
          <target state="translated">Мы уже обсуждали константы в &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;разделе 4.1.2&lt;/a&gt; . В следующих разделах обсуждаются оставшиеся варианты.</target>
        </trans-unit>
        <trans-unit id="a1ef9ac43045748116a115e49374f363a8ba372f" translate="yes" xml:space="preserve">
          <source>We know that most queries will access just the last week's, month's or quarter's data, since the main use of this table will be to prepare online reports for management. To reduce the amount of old data that needs to be stored, we decide to only keep the most recent 3 years worth of data. At the beginning of each month we will remove the oldest month's data. In this situation we can use partitioning to help us meet all of our different requirements for the measurements table.</source>
          <target state="translated">Мы знаем,что большинство запросов будут иметь доступ только к данным за последнюю неделю,месяц или квартал,так как основное использование этой таблицы будет заключаться в подготовке онлайн-отчетов для руководства.Чтобы уменьшить количество старых данных,которые необходимо хранить,мы решили хранить только данные за последние 3 года.В начале каждого месяца мы будем удалять данные за самый старый месяц.В этой ситуации мы можем использовать разбиение на разделы,чтобы удовлетворить все наши различные требования к таблице измерений.</target>
        </trans-unit>
        <trans-unit id="8a993aca05617d8df040114000bd6876b7a6bbb8" translate="yes" xml:space="preserve">
          <source>We know that the foreign keys disallow creation of orders that do not relate to any products. But what if a product is removed after an order is created that references it? SQL allows you to handle that as well. Intuitively, we have a few options:</source>
          <target state="translated">Мы знаем,что посторонние ключи запрещают создавать заказы,которые не относятся к какой-либо продукции.Но что делать,если после создания заказа товар удаляется,что ссылается на него? SQL позволяет справиться и с этим.Интуитивно у нас есть несколько вариантов:</target>
        </trans-unit>
        <trans-unit id="afd1ca25954ba7db5e426cd93dec87fb2f18cad3" translate="yes" xml:space="preserve">
          <source>We might hope that the data would somehow be routed to the &lt;code&gt;capitals&lt;/code&gt; table, but this does not happen: &lt;code&gt;INSERT&lt;/code&gt; always inserts into exactly the table specified. In some cases it is possible to redirect the insertion using a rule (see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;). However that does not help for the above case because the &lt;code&gt;cities&lt;/code&gt; table does not contain the column &lt;code&gt;state&lt;/code&gt;, and so the command will be rejected before the rule can be applied.</source>
          <target state="translated">Мы могли бы надеяться, что данные каким-то образом будут перенаправлены в таблицу &lt;code&gt;capitals&lt;/code&gt; , но этого не происходит: &lt;code&gt;INSERT&lt;/code&gt; всегда вставляет точно в указанную таблицу. В некоторых случаях можно перенаправить вставку с помощью правила (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Главу 40&lt;/a&gt; ). Однако это не помогает в приведенном выше случае, поскольку таблица &lt;code&gt;cities&lt;/code&gt; не содержит &lt;code&gt;state&lt;/code&gt; столбца , и поэтому команда будет отклонена до применения правила.</target>
        </trans-unit>
        <trans-unit id="b41ce96b205209d5c52d43184eb3122bcf4d7162" translate="yes" xml:space="preserve">
          <source>We might hope that the data would somehow be routed to the &lt;code&gt;capitals&lt;/code&gt; table, but this does not happen: &lt;code&gt;INSERT&lt;/code&gt; always inserts into exactly the table specified. In some cases it is possible to redirect the insertion using a rule (see &lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;Chapter 40&lt;/a&gt;). However that does not help for the above case because the &lt;code&gt;cities&lt;/code&gt; table does not contain the column &lt;code&gt;state&lt;/code&gt;, and so the command will be rejected before the rule can be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668bafcded25fc8a525c39fc8ba11f8e8e98aa03" translate="yes" xml:space="preserve">
          <source>We might want to insert data and have the server automatically locate the child table into which the row should be added. We could do this with a more complex trigger function, for example:</source>
          <target state="translated">Возможно,мы захотим вставить данные и попросить сервер автоматически найти дочернюю таблицу,в которую следует добавить строку.Мы могли бы сделать это,например,с помощью более сложной триггерной функции:</target>
        </trans-unit>
        <trans-unit id="1aa4d9dcdf43d5b53cef629cb08b1cf507249faa" translate="yes" xml:space="preserve">
          <source>We must redefine the trigger function each month so that it always points to the current child table. The trigger definition does not need to be updated, however.</source>
          <target state="translated">Мы должны каждый месяц переопределять триггерную функцию таким образом,чтобы она всегда указывала на текущую дочернюю таблицу.Однако определение триггера не нуждается в обновлении.</target>
        </trans-unit>
        <trans-unit id="1597c32eb07ab6cca066ebab3e65392f57896307" translate="yes" xml:space="preserve">
          <source>We recommend that active production databases be vacuumed frequently (at least nightly), in order to remove dead rows. After adding or deleting a large number of rows, it might be a good idea to issue a &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; command for the affected table. This will update the system catalogs with the results of all recent changes, and allow the PostgreSQL query planner to make better choices in planning queries.</source>
          <target state="translated">Мы рекомендуем часто очищать активные производственные базы данных (по крайней мере, каждую ночь), чтобы удалить мертвые строки. После добавления или удаления большого количества строк может быть хорошей идеей выполнить команду &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; для затронутой таблицы. Это обновит системные каталоги с результатами всех последних изменений и позволит планировщику запросов PostgreSQL сделать лучший выбор при планировании запросов.</target>
        </trans-unit>
        <trans-unit id="4e67abf5ade818ba6d22ea4bc6d74fa648515393" translate="yes" xml:space="preserve">
          <source>We reject the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command across the board, because any module loaded could easily circumvent security policy enforcement.</source>
          <target state="translated">Мы отклоняем команду &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; по всем направлениям, потому что любой загруженный модуль может легко обойти применение политики безопасности.</target>
        </trans-unit>
        <trans-unit id="977603731abefa85626583cf9841c1f7f86bb5c7" translate="yes" xml:space="preserve">
          <source>We require the index access method to apply these tests itself, which means that it must reach into the heap to check the commit status of any row that is shown to have a duplicate key according to the index contents. This is without a doubt ugly and non-modular, but it saves redundant work: if we did a separate probe then the index lookup for a conflicting row would be essentially repeated while finding the place to insert the new row's index entry. What's more, there is no obvious way to avoid race conditions unless the conflict check is an integral part of insertion of the new index entry.</source>
          <target state="translated">Мы требуем,чтобы метод доступа к индексу применял эти тесты самостоятельно,что означает,что он должен дотянуться до кучи,чтобы проверить статус фиксации любой строки,которая,как показано,имеет дубликат ключа в соответствии с содержимым индекса.Это,без сомнения,уродливо и немодульно,но это экономит лишнюю работу:если бы мы проводили отдельную проверку,то поиск по индексу конфликтующей строки,по сути,повторялся бы при поиске места для вставки новой записи индекса строки.Более того,нет никакого очевидного способа избежать условий гонки,если только проверка на конфликт не является неотъемлемой частью вставки записи нового индекса.</target>
        </trans-unit>
        <trans-unit id="61809ffaa1e9bec3b74e00f63e536c6b27a9b1ac" translate="yes" xml:space="preserve">
          <source>We say that in this situation the orders table is the &lt;em&gt;referencing&lt;/em&gt; table and the products table is the &lt;em&gt;referenced&lt;/em&gt; table. Similarly, there are referencing and referenced columns.</source>
          <target state="translated">Мы говорим, что в этой ситуации таблица заказов является &lt;em&gt;справочной&lt;/em&gt; таблицей, а таблица продуктов - &lt;em&gt;справочной&lt;/em&gt; таблицей. Точно так же существуют ссылочные и ссылочные столбцы.</target>
        </trans-unit>
        <trans-unit id="926fa8d618ecd63d98d203881339877369fb9e8a" translate="yes" xml:space="preserve">
          <source>We say that the first two constraints are column constraints, whereas the third one is a table constraint because it is written separately from any one column definition. Column constraints can also be written as table constraints, while the reverse is not necessarily possible, since a column constraint is supposed to refer to only the column it is attached to. (PostgreSQL doesn't enforce that rule, but you should follow it if you want your table definitions to work with other database systems.) The above example could also be written as:</source>
          <target state="translated">Мы говорим,что первые два ограничения-это ограничения на столбцы,а третий-это ограничения на таблицы,потому что он записывается отдельно от любого определения одного столбца.Ограничения на столбцы также могут быть записаны как ограничения таблицы,в то время как обратное не обязательно возможно,так как ограничение столбца должно относиться только к тому столбцу,к которому оно прикреплено.(PostgreSQL не применяет это правило,но вы должны следовать ему,если хотите,чтобы определения таблиц работали с другими системами БД).Приведенный выше пример также может быть написан как:</target>
        </trans-unit>
        <trans-unit id="61ad12c01cac6b9fd7b6ff658816ff5bf8b904a2" translate="yes" xml:space="preserve">
          <source>We store these documents in a table named &lt;code&gt;api&lt;/code&gt;, in a &lt;code&gt;jsonb&lt;/code&gt; column named &lt;code&gt;jdoc&lt;/code&gt;. If a GIN index is created on this column, queries like the following can make use of the index:</source>
          <target state="translated">Мы храним эти документы в таблицу с именем &lt;code&gt;api&lt;/code&gt; , в &lt;code&gt;jsonb&lt;/code&gt; колонке под названием &lt;code&gt;jdoc&lt;/code&gt; . Если для этого столбца создается индекс GIN, запросы, подобные приведенным ниже, могут использовать этот индекс:</target>
        </trans-unit>
        <trans-unit id="c00287a4e7374c9957df5b25550d2f8b5bf2d466" translate="yes" xml:space="preserve">
          <source>We use the following terms below: The &lt;em&gt;precision&lt;/em&gt; of a &lt;code&gt;numeric&lt;/code&gt; is the total count of significant digits in the whole number, that is, the number of digits to both sides of the decimal point. The &lt;em&gt;scale&lt;/em&gt; of a &lt;code&gt;numeric&lt;/code&gt; is the count of decimal digits in the fractional part, to the right of the decimal point. So the number 23.5141 has a precision of 6 and a scale of 4. Integers can be considered to have a scale of zero.</source>
          <target state="translated">Мы используем следующие термины ниже: &lt;em&gt;точность&lt;/em&gt; из &lt;code&gt;numeric&lt;/code&gt; является общее количество значащих цифр в целое число, то есть число цифр с обеих сторон десятичной точки. &lt;em&gt;Шкала&lt;/em&gt; из &lt;code&gt;numeric&lt;/code&gt; является счетчиком десятичных цифр в дробной части, справа от десятичной точки. Таким образом, число 23,5141 имеет точность 6 и шкалу 4. Можно считать, что целые числа имеют нулевую шкалу.</target>
        </trans-unit>
        <trans-unit id="c61d0c97e5f7c008c140e2ad3c2ca5a1fbcdb590" translate="yes" xml:space="preserve">
          <source>We use the non-partitioned &lt;code&gt;measurement&lt;/code&gt; table above. To implement partitioning using inheritance, use the following steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22e103a166cab5bebeb6c6bf8216ec0f41d1ce6" translate="yes" xml:space="preserve">
          <source>We use the same &lt;code&gt;measurement&lt;/code&gt; table we used above. To implement partitioning using inheritance, use the following steps:</source>
          <target state="translated">Мы используем ту же таблицу &lt;code&gt;measurement&lt;/code&gt; которую использовали выше. Чтобы реализовать разбиение с использованием наследования, выполните следующие действия:</target>
        </trans-unit>
        <trans-unit id="87bb5356e299e65f3820ac3133d7b4e088f6bde2" translate="yes" xml:space="preserve">
          <source>We use the word &lt;em&gt;item&lt;/em&gt; to refer to a composite value that is to be indexed, and the word &lt;em&gt;key&lt;/em&gt; to refer to an element value. GIN always stores and searches for keys, not item values per se.</source>
          <target state="translated">Мы используем слово &amp;laquo; &lt;em&gt;элемент&amp;raquo;&lt;/em&gt; для обозначения составного значения, которое необходимо проиндексировать, а слово &amp;laquo; &lt;em&gt;ключ&amp;raquo; -&lt;/em&gt; для ссылки на значение элемента. GIN всегда хранит и ищет ключи, а не значения элементов как таковые.</target>
        </trans-unit>
        <trans-unit id="aaac10448fb5e7278bf16580755bd9621bfb54f1" translate="yes" xml:space="preserve">
          <source>We want our application to be able to say &lt;code&gt;INSERT INTO measurement ...&lt;/code&gt; and have the data be redirected into the appropriate child table. We can arrange that by attaching a suitable trigger function to the master table. If data will be added only to the latest child, we can use a very simple trigger function:</source>
          <target state="translated">Мы хотим, чтобы наше приложение могло сказать &lt;code&gt;INSERT INTO measurement ...&lt;/code&gt; и чтобы данные перенаправлялись в соответствующую дочернюю таблицу. Мы можем организовать это, добавив подходящую функцию триггера к главной таблице. Если данные будут добавлены только к последнему дочернему элементу, мы можем использовать очень простую функцию триггера:</target>
        </trans-unit>
        <trans-unit id="cdc05935dfdf1c41e4dbff177f8b502be331c045" translate="yes" xml:space="preserve">
          <source>We will use a PostgreSQL-specific synonym list and store it in &lt;code&gt;$SHAREDIR/tsearch_data/pg_dict.syn&lt;/code&gt;. The file contents look like:</source>
          <target state="translated">Мы будем использовать специфичный для PostgreSQL список синонимов и хранить его в &lt;code&gt;$SHAREDIR/tsearch_data/pg_dict.syn&lt;/code&gt; . Содержимое файла выглядит так:</target>
        </trans-unit>
        <trans-unit id="963adbfe40be253cf091e436ca27447ef3a470bc" translate="yes" xml:space="preserve">
          <source>Wed, Weds</source>
          <target state="translated">Свадьба,Свадьба</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="7d75266a53b99ce4d80d337862ea1edd8ba1b1a1" translate="yes" xml:space="preserve">
          <source>Weeks</source>
          <target state="translated">Weeks</target>
        </trans-unit>
        <trans-unit id="fdeddc33f6adb1db2fc6d6142f8a57019f70774f" translate="yes" xml:space="preserve">
          <source>Weights are typically used to reflect document structure, for example by marking title words differently from body words. Text search ranking functions can assign different priorities to the different weight markers.</source>
          <target state="translated">Весы обычно используются для отражения структуры документа,например,при маркировке заглавных слов,отличных от слов тела.Функции ранжирования текстового поиска могут присваивать различные приоритеты разным весовым маркерам.</target>
        </trans-unit>
        <trans-unit id="683c9370be61bfcd03e58355d7c86c6e1369d2d9" translate="yes" xml:space="preserve">
          <source>Western European</source>
          <target state="translated">западноевропейский</target>
        </trans-unit>
        <trans-unit id="e82bc7cf6e54b2e4257e788dff104c1e42da4e0b" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?</source>
          <target state="translated">Что такое сборник JIT?</target>
        </trans-unit>
        <trans-unit id="9d446878c466219c122696ab7b32c54ff789d87e" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: Inlining</source>
          <target state="translated">Что такое сборник JIT? Размещение на сайте</target>
        </trans-unit>
        <trans-unit id="ca44cc7300ef1dcac2b672637a01e3b0a0da90f7" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: JIT Accelerated Operations</source>
          <target state="translated">Что такое сборник JIT? Ускоренные операции JIT</target>
        </trans-unit>
        <trans-unit id="760d95b57cc4647ff2722b6cf5ee7f34082cc25e" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: Optimization</source>
          <target state="translated">Что такое сборник JIT? Оптимизация</target>
        </trans-unit>
        <trans-unit id="6026d88e883e805146a8bbfee4583738ccfd77d8" translate="yes" xml:space="preserve">
          <source>What Is the &amp;ldquo;Transaction&amp;rdquo; Actually Performed in pgbench?</source>
          <target state="translated">Что на самом деле &amp;laquo;транзакция&amp;raquo; выполняется в pgbench?</target>
        </trans-unit>
        <trans-unit id="6c8a97eccbb7e55f60d7659738855ee30c65e97d" translate="yes" xml:space="preserve">
          <source>What has really happened here is that the two unknown literals are resolved to &lt;code&gt;text&lt;/code&gt; by default, allowing the &lt;code&gt;||&lt;/code&gt; operator to be resolved as &lt;code&gt;text&lt;/code&gt; concatenation. Then the &lt;code&gt;text&lt;/code&gt; result of the operator is converted to &lt;code&gt;bpchar&lt;/code&gt; (&amp;ldquo;blank-padded char&amp;rdquo;, the internal name of the &lt;code&gt;character&lt;/code&gt; data type) to match the target column type. (Since the conversion from &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;bpchar&lt;/code&gt; is binary-coercible, this conversion does not insert any real function call.) Finally, the sizing function &lt;code&gt;bpchar(bpchar, integer, boolean)&lt;/code&gt; is found in the system catalog and applied to the operator's result and the stored column length. This type-specific function performs the required length check and addition of padding spaces.</source>
          <target state="translated">На самом деле здесь произошло то, что два неизвестных литерала по умолчанию &lt;code&gt;text&lt;/code&gt; в текст , разрешая &lt;code&gt;||&lt;/code&gt; оператор, который будет разрешен как объединение &lt;code&gt;text&lt;/code&gt; . Затем &lt;code&gt;text&lt;/code&gt; результат оператора преобразуется в &lt;code&gt;bpchar&lt;/code&gt; (&amp;laquo;заполненный пробелами символ&amp;raquo;, внутреннее имя &lt;code&gt;character&lt;/code&gt; типа данных), чтобы соответствовать типу целевого столбца. (Поскольку преобразование &lt;code&gt;text&lt;/code&gt; в &lt;code&gt;bpchar&lt;/code&gt; является двоичным с приведением, это преобразование не вставляет никакого реального вызова функции.) Наконец, функция определения размера &lt;code&gt;bpchar(bpchar, integer, boolean)&lt;/code&gt; находится в системном каталоге и применяется к результату оператора и длине сохраненного столбца. Эта зависящая от типа функция выполняет проверку необходимой длины и добавление пробелов.</target>
        </trans-unit>
        <trans-unit id="dfcede4e6134968fca6be5ab22337a4021df7d2f" translate="yes" xml:space="preserve">
          <source>What is a &amp;ldquo;system user&amp;rdquo; is determined at systemd compile time from the &lt;code&gt;SYS_UID_MAX&lt;/code&gt; setting in &lt;code&gt;/etc/login.defs&lt;/code&gt;.</source>
          <target state="translated">Что такое &amp;laquo;системный пользователь&amp;raquo;, определяется во время компиляции systemd из параметра &lt;code&gt;SYS_UID_MAX&lt;/code&gt; в &lt;code&gt;/etc/login.defs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3b062bdc5b358d8bc1d0ea5b87500675ecf488c" translate="yes" xml:space="preserve">
          <source>What is essentially happening here is a join between &lt;code&gt;films&lt;/code&gt; and &lt;code&gt;producers&lt;/code&gt;, with all successfully joined &lt;code&gt;films&lt;/code&gt; rows being marked for deletion. This syntax is not standard. A more standard way to do it is:</source>
          <target state="translated">По сути, здесь происходит соединение &lt;code&gt;films&lt;/code&gt; и &lt;code&gt;producers&lt;/code&gt; , при этом все успешно соединенные строки &lt;code&gt;films&lt;/code&gt; помечаются для удаления. Этот синтаксис нестандартен. Более стандартный способ сделать это:</target>
        </trans-unit>
        <trans-unit id="e6eec3dfd99f17e2a6e53d2f854ed352bd2c2826" translate="yes" xml:space="preserve">
          <source>What locales are available on your system under what names depends on what was provided by the operating system vendor and what was installed. On most Unix systems, the command &lt;code&gt;locale -a&lt;/code&gt; will provide a list of available locales. Windows uses more verbose locale names, such as &lt;code&gt;German_Germany&lt;/code&gt; or &lt;code&gt;Swedish_Sweden.1252&lt;/code&gt;, but the principles are the same.</source>
          <target state="translated">Какие языковые стандарты доступны в вашей системе под какими именами, зависит от того, что было предоставлено поставщиком операционной системы и что было установлено. В большинстве систем Unix команда &lt;code&gt;locale -a&lt;/code&gt; предоставит список доступных локалей. Windows использует более подробные имена &lt;code&gt;German_Germany&lt;/code&gt; , такие как German_Germany или &lt;code&gt;Swedish_Sweden.1252&lt;/code&gt; , но принципы те же.</target>
        </trans-unit>
        <trans-unit id="40680439c20fb6866bd543023ba55a7dbd37c92b" translate="yes" xml:space="preserve">
          <source>What this does is to record the links created by pg_upgrade's link mode that connect files in the old and new clusters on the primary server. It then finds matching files in the standby's old cluster and creates links for them in the standby's new cluster. Files that were not linked on the primary are copied from the primary to the standby. (They are usually small.) This provides rapid standby upgrades. Unfortunately, rsync needlessly copies files associated with temporary and unlogged tables because these files don't normally exist on standby servers.</source>
          <target state="translated">Это делается для записи ссылок,созданных в режиме ссылок pg_upgrade,которые соединяют файлы старого и нового кластеров на основном сервере.Затем он находит соответствующие файлы в старом резервном кластере и создает для них ссылки в новом резервном кластере.Файлы,которые не были связаны на первичном сервере,копируются с первичного на резервный.(Обычно они маленькие.)Это обеспечивает быстрое обновление в режиме ожидания.К сожалению,rsync ненужно копировать файлы,связанные с временными и незарегистрированными таблицами,потому что эти файлы обычно не существуют на резервных серверах.</target>
        </trans-unit>
        <trans-unit id="a446c8d9e480b9f0f6cbcd76fef7e2bcda6c700b" translate="yes" xml:space="preserve">
          <source>What's more, when you load data into a table with existing foreign key constraints, each new row requires an entry in the server's list of pending trigger events (since it is the firing of a trigger that checks the row's foreign key constraint). Loading many millions of rows can cause the trigger event queue to overflow available memory, leading to intolerable swapping or even outright failure of the command. Therefore it may be &lt;em&gt;necessary&lt;/em&gt;, not just desirable, to drop and re-apply foreign keys when loading large amounts of data. If temporarily removing the constraint isn't acceptable, the only other recourse may be to split up the load operation into smaller transactions.</source>
          <target state="translated">Более того, когда вы загружаете данные в таблицу с существующими ограничениями внешнего ключа, каждая новая строка требует записи в серверном списке ожидающих событий триггера (поскольку это срабатывание триггера, который проверяет ограничение внешнего ключа строки). Загрузка миллионов строк может привести к переполнению очереди событий триггера доступной памяти, что приведет к невыносимой подкачки или даже к полному отказу команды. Поэтому может быть &lt;em&gt;необходимо&lt;/em&gt; , а не только желательно, отбросить и повторно применить внешние ключи при загрузке больших объемов данных. Если временное удаление ограничения неприемлемо, единственным выходом может быть разделение операции загрузки на более мелкие транзакции.</target>
        </trans-unit>
        <trans-unit id="f0604f8d2119324fb427a16a8668c529701bc1a2" translate="yes" xml:space="preserve">
          <source>Whatever data was in the column disappears. Table constraints involving the column are dropped, too. However, if the column is referenced by a foreign key constraint of another table, PostgreSQL will not silently drop that constraint. You can authorize dropping everything that depends on the column by adding &lt;code&gt;CASCADE&lt;/code&gt;:</source>
          <target state="translated">Какие бы данные ни были в столбце, исчезнет. Ограничения таблицы, относящиеся к столбцу, также удаляются. Однако, если на столбец ссылается ограничение внешнего ключа другой таблицы, PostgreSQL не будет молча сбросить это ограничение. Вы можете разрешить удаление всего, что зависит от столбца, добавив &lt;code&gt;CASCADE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="a60fe559ad2643627bd47ea3eceb6f63037101eb" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;runtime-config-logging#GUC-LOG-LOCK-WAITS&quot;&gt;log_lock_waits&lt;/a&gt; is set, this parameter also determines the amount of time to wait before a log message is issued about the lock wait. If you are trying to investigate locking delays you might want to set a shorter than normal &lt;code&gt;deadlock_timeout&lt;/code&gt;.</source>
          <target state="translated">Если установлен параметр &lt;a href=&quot;runtime-config-logging#GUC-LOG-LOCK-WAITS&quot;&gt;log_lock_waits&lt;/a&gt; , этот параметр также определяет время ожидания, прежде чем будет выдано сообщение журнала об ожидании блокировки. Если вы пытаетесь исследовать задержки блокировки, вы можете установить более короткое, чем обычно, &lt;code&gt;deadlock_timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48421d6240bf9ea87a63b5a2373cb0ad9cf5cd58" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--include-foreign-data&lt;/code&gt; is specified, pg_dump does not check that the foreign table is writable. Therefore, there is no guarantee that the results of a foreign table dump can be successfully restored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e37b6a94a28e9acbd6287be1d60c38f8541fd8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--source-server&lt;/code&gt; option is used, pg_rewind also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">Когда &lt;code&gt;--source-server&lt;/code&gt; опция --source-server , pg_rewind также использует переменные среды, поддерживаемые libpq (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Раздел 33.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2797c2b01f0d49dcbbe6a48419d9e0d238c086dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--source-server&lt;/code&gt; option is used, pg_rewind also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1854281aa73e4f5b1f721e95b9f05123b0ade134" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-n&lt;/code&gt; is specified, pg_dump makes no attempt to dump any other database objects that the selected schema(s) might depend upon. Therefore, there is no guarantee that the results of a specific-schema dump can be successfully restored by themselves into a clean database.</source>
          <target state="translated">Если указано &lt;code&gt;-n&lt;/code&gt; , pg_dump не пытается сбросить дамп любых других объектов базы данных, от которых может зависеть выбранная схема (схемы). Следовательно, нет гарантии, что результаты дампа конкретной схемы могут быть успешно восстановлены сами по себе в чистую базу данных.</target>
        </trans-unit>
        <trans-unit id="5fef81c501efe3e088f4b73c9a697af2561cb6dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-t&lt;/code&gt; is specified, pg_dump makes no attempt to dump any other database objects that the selected table(s) might depend upon. Therefore, there is no guarantee that the results of a specific-table dump can be successfully restored by themselves into a clean database.</source>
          <target state="translated">Если указан &lt;code&gt;-t&lt;/code&gt; , pg_dump не пытается сбросить дамп любых других объектов базы данных, от которых может зависеть выбранная таблица (таблицы). Следовательно, нет гарантии, что результаты дампа конкретной таблицы могут быть успешно восстановлены сами по себе в чистую базу данных.</target>
        </trans-unit>
        <trans-unit id="8c86589858bd9989813c8435013ddbc1a41c69f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-t&lt;/code&gt; is specified, pg_restore makes no attempt to restore any other database objects that the selected table(s) might depend upon. Therefore, there is no guarantee that a specific-table restore into a clean database will succeed.</source>
          <target state="translated">Если указано &lt;code&gt;-t&lt;/code&gt; , pg_restore не пытается восстановить какие-либо другие объекты базы данных, от которых может зависеть выбранная таблица (таблицы). Следовательно, нет гарантии, что восстановление конкретной таблицы в чистую базу данных будет успешным.</target>
        </trans-unit>
        <trans-unit id="6dd3feb588f68391e70d37037327ad64b7721fd7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ALTER&lt;/code&gt; command is executed, &lt;code&gt;setattr&lt;/code&gt; will be checked on the object being modified for each object types, except for subsidiary objects such as the indexes or triggers of a table, where permissions are instead checked on the parent object. In some cases, additional permissions are required:</source>
          <target state="translated">Когда выполняется команда &lt;code&gt;ALTER&lt;/code&gt; , &lt;code&gt;setattr&lt;/code&gt; будет проверяться для изменяемого объекта для каждого типа объекта, за исключением вспомогательных объектов, таких как индексы или триггеры таблицы, где вместо этого проверяются разрешения для родительского объекта. В некоторых случаях требуются дополнительные разрешения:</target>
        </trans-unit>
        <trans-unit id="95ea06756271ccb08739b45bacb4e5cf14e003e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE INDEX&lt;/code&gt; is invoked on a partitioned table, the default behavior is to recurse to all partitions to ensure they all have matching indexes. Each partition is first checked to determine whether an equivalent index already exists, and if so, that index will become attached as a partition index to the index being created, which will become its parent index. If no matching index exists, a new index will be created and automatically attached; the name of the new index in each partition will be determined as if no index name had been specified in the command. If the &lt;code&gt;ONLY&lt;/code&gt; option is specified, no recursion is done, and the index is marked invalid. (&lt;code&gt;ALTER INDEX ... ATTACH PARTITION&lt;/code&gt; marks the index valid, once all partitions acquire matching indexes.) Note, however, that any partition that is created in the future using &lt;code&gt;CREATE TABLE ... PARTITION OF&lt;/code&gt; will automatically have a matching index, regardless of whether &lt;code&gt;ONLY&lt;/code&gt; is specified.</source>
          <target state="translated">Когда &lt;code&gt;CREATE INDEX&lt;/code&gt; вызывается для многораздельной таблицы, поведение по умолчанию заключается в рекурсии для всех секций, чтобы гарантировать, что все они имеют соответствующие индексы. Каждая секция сначала проверяется, чтобы определить, существует ли уже эквивалентный индекс, и если да, этот индекс будет присоединен в качестве индекса секции к создаваемому индексу, который станет его родительским индексом. Если соответствующего индекса не существует, будет создан и автоматически прикреплен новый индекс; имя нового индекса в каждом разделе будет определяться так, как если бы в команде не было указано имя индекса. Если указан параметр &lt;code&gt;ONLY&lt;/code&gt; , рекурсия не выполняется и индекс помечается как недопустимый. ( &lt;code&gt;ALTER INDEX ... ATTACH PARTITION&lt;/code&gt; отмечает, что индекс действителен, как только все разделы получат соответствующие индексы.) Обратите внимание, однако, что любой раздел, который будет создан в будущем с помощью &lt;code&gt;CREATE TABLE ... PARTITION OF&lt;/code&gt; будет автоматически иметь соответствующий индекс, независимо от того, указано ли &lt;code&gt;ONLY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c15e2e86d36f47a57239a8f802301f2d222dbb6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; is used to replace an existing function, the ownership and permissions of the function do not change. All other function properties are assigned the values specified or implied in the command. You must own the function to replace it (this includes being a member of the owning role).</source>
          <target state="translated">Когда &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; используется для замены существующей функции, права собственности и разрешения функции не меняются. Всем остальным свойствам функции присваиваются значения, указанные или подразумеваемые в команде. Вы должны владеть функцией, чтобы заменить ее (в том числе быть членом роли-владельца).</target>
        </trans-unit>
        <trans-unit id="db55d63efcb8b5298291fde068a29837b503dfcf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; is used to replace an existing procedure, the ownership and permissions of the procedure do not change. All other procedure properties are assigned the values specified or implied in the command. You must own the procedure to replace it (this includes being a member of the owning role).</source>
          <target state="translated">Когда &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; используется для замены существующей процедуры, права собственности и разрешения процедуры не меняются. Всем остальным свойствам процедуры присваиваются значения, указанные или подразумеваемые в команде. Вы должны владеть процедурой для ее замены (в том числе быть членом роли-владельца).</target>
        </trans-unit>
        <trans-unit id="11b7e02139c0fd56fa0d0c0d7e02cacf1863b7dd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; is used on an existing view, only the view's defining SELECT rule is changed. Other view properties, including ownership, permissions, and non-SELECT rules, remain unchanged. You must own the view to replace it (this includes being a member of the owning role).</source>
          <target state="translated">Когда &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; используется в существующем представлении, изменяется только определяющее его правило SELECT. Другие свойства представления, включая владение, разрешения и правила, не относящиеся к SELECT, остаются без изменений. Вы должны владеть представлением, чтобы заменить его (в том числе быть членом роли-владельца).</target>
        </trans-unit>
        <trans-unit id="b2b68d33a4076adb362da4bb710ac3317fb09cf8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DROP&lt;/code&gt; command is executed, &lt;code&gt;drop&lt;/code&gt; will be checked on the object being removed. Permissions will be also checked for objects dropped indirectly via &lt;code&gt;CASCADE&lt;/code&gt;. Deletion of objects contained within a particular schema (tables, views, sequences and procedures) additionally requires &lt;code&gt;remove_name&lt;/code&gt; on the schema.</source>
          <target state="translated">Когда &lt;code&gt;DROP&lt;/code&gt; выполняется команда, &lt;code&gt;drop&lt;/code&gt; будет проверяться на предмет удаления. Также будут проверяться разрешения для объектов, удаленных косвенно через &lt;code&gt;CASCADE&lt;/code&gt; . Для удаления объектов, содержащихся в определенной схеме (таблицы, представления, последовательности и процедуры), дополнительно требуется &lt;code&gt;remove_name&lt;/code&gt; в схеме.</target>
        </trans-unit>
        <trans-unit id="f47c9d6dc4a8942d1dd522d4978fe59346f8ad48" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GROUP BY&lt;/code&gt; is present, or any aggregate functions are present, it is not valid for the &lt;code&gt;SELECT&lt;/code&gt; list expressions to refer to ungrouped columns except within aggregate functions or when the ungrouped column is functionally dependent on the grouped columns, since there would otherwise be more than one possible value to return for an ungrouped column. A functional dependency exists if the grouped columns (or a subset thereof) are the primary key of the table containing the ungrouped column.</source>
          <target state="translated">Когда присутствует &lt;code&gt;GROUP BY&lt;/code&gt; или присутствуют какие-либо агрегатные функции, недопустимо, чтобы выражения списка &lt;code&gt;SELECT&lt;/code&gt; ссылались на несгруппированные столбцы, кроме как внутри агрегатных функций, или когда несгруппированный столбец функционально зависит от сгруппированных столбцов, поскольку в противном случае было бы больше более одного возможного значения для несгруппированного столбца. Функциональная зависимость существует, если сгруппированные столбцы (или их подмножество) являются первичным ключом таблицы, содержащей несгруппированный столбец.</target>
        </trans-unit>
        <trans-unit id="a61a8feeb668ae119fbcd691b6fc8464f954d0c9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;NOTIFY&lt;/code&gt; is used to signal the occurrence of changes to a particular table, a useful programming technique is to put the &lt;code&gt;NOTIFY&lt;/code&gt; in a statement trigger that is triggered by table updates. In this way, notification happens automatically when the table is changed, and the application programmer cannot accidentally forget to do it.</source>
          <target state="translated">Когда &lt;code&gt;NOTIFY&lt;/code&gt; используется, чтобы сигнализировать о возникновении изменений в конкретной таблице, полезный метод программирования состоит в том, чтобы поместить &lt;code&gt;NOTIFY&lt;/code&gt; в триггер оператора, который запускается обновлениями таблицы. Таким образом, уведомление происходит автоматически при изменении таблицы, и программист приложения не может случайно это сделать.</target>
        </trans-unit>
        <trans-unit id="693b980fbbb477839ff0fa0e6f6f64c259b4b463" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;RESTART IDENTITY&lt;/code&gt; is specified, the implied &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; operations are also done transactionally; that is, they will be rolled back if the surrounding transaction does not commit. Be aware that if any additional sequence operations are done on the restarted sequences before the transaction rolls back, the effects of these operations on the sequences will be rolled back, but not their effects on &lt;code&gt;currval()&lt;/code&gt;; that is, after the transaction &lt;code&gt;currval()&lt;/code&gt; will continue to reflect the last sequence value obtained inside the failed transaction, even though the sequence itself may no longer be consistent with that. This is similar to the usual behavior of &lt;code&gt;currval()&lt;/code&gt; after a failed transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d946d891d853517e02080ffe41ee5e79e55c40" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;RESTART IDENTITY&lt;/code&gt; is specified, the implied &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; operations are also done transactionally; that is, they will be rolled back if the surrounding transaction does not commit. This is unlike the normal behavior of &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt;. Be aware that if any additional sequence operations are done on the restarted sequences before the transaction rolls back, the effects of these operations on the sequences will be rolled back, but not their effects on &lt;code&gt;currval()&lt;/code&gt;; that is, after the transaction &lt;code&gt;currval()&lt;/code&gt; will continue to reflect the last sequence value obtained inside the failed transaction, even though the sequence itself may no longer be consistent with that. This is similar to the usual behavior of &lt;code&gt;currval()&lt;/code&gt; after a failed transaction.</source>
          <target state="translated">Если задана &lt;code&gt;RESTART IDENTITY&lt;/code&gt; , подразумеваемые операции &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; также выполняются транзакционно; то есть они будут отменены, если окружающая транзакция не зафиксируется. Это отличается от обычного поведения &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; . Имейте в виду, что если какие-либо дополнительные операции последовательности выполняются с перезапущенными последовательностями до отката транзакции, последствия этих операций для последовательностей будут &lt;code&gt;currval()&lt;/code&gt; , но не их влияние на currval () ; то есть после транзакции &lt;code&gt;currval()&lt;/code&gt; будет по-прежнему отражать последнее значение последовательности, полученное внутри неудачной транзакции, даже если сама последовательность может больше не соответствовать этому. Это похоже на обычное поведение &lt;code&gt;currval()&lt;/code&gt; после неудачной транзакции.</target>
        </trans-unit>
        <trans-unit id="1dd38b054f6c38892cf4b53376368a92afaa9614" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; changes the mode of a constraint from &lt;code&gt;DEFERRED&lt;/code&gt; to &lt;code&gt;IMMEDIATE&lt;/code&gt;, the new mode takes effect retroactively: any outstanding data modifications that would have been checked at the end of the transaction are instead checked during the execution of the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; command. If any such constraint is violated, the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; fails (and does not change the constraint mode). Thus, &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; can be used to force checking of constraints to occur at a specific point in a transaction.</source>
          <target state="translated">Когда &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; изменяет режим ограничения с &lt;code&gt;DEFERRED&lt;/code&gt; на &lt;code&gt;IMMEDIATE&lt;/code&gt; , новый режим вступает в силу задним числом: любые незавершенные изменения данных, которые были бы проверены в конце транзакции, вместо этого проверяются во время выполнения команды &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; . Если любое такое ограничение нарушается, &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; завершается с ошибкой (и не меняет режим ограничения). Таким образом, &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; может использоваться для принудительной проверки ограничений в определенном месте транзакции.</target>
        </trans-unit>
        <trans-unit id="c0b169cb5b7cb17bff71441e629815508752132d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VALUES&lt;/code&gt; is used in &lt;code&gt;INSERT&lt;/code&gt;, the values are all automatically coerced to the data type of the corresponding destination column. When it's used in other contexts, it might be necessary to specify the correct data type. If the entries are all quoted literal constants, coercing the first is sufficient to determine the assumed type for all:</source>
          <target state="translated">Когда &lt;code&gt;VALUES&lt;/code&gt; используется в &lt;code&gt;INSERT&lt;/code&gt; , все значения автоматически приводятся к типу данных соответствующего целевого столбца. Когда он используется в других контекстах, может потребоваться указать правильный тип данных. Если все записи являются литеральными константами в кавычках, принуждение первого достаточно, чтобы определить предполагаемый тип для всех:</target>
        </trans-unit>
        <trans-unit id="45ae9ff8fa95f77c4ea16390adcefafbd4f890d9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VERBOSE&lt;/code&gt; is specified, &lt;code&gt;ANALYZE&lt;/code&gt; emits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.</source>
          <target state="translated">Если задана &lt;code&gt;VERBOSE&lt;/code&gt; , &lt;code&gt;ANALYZE&lt;/code&gt; выдает сообщения о ходе выполнения, чтобы указать, какая таблица обрабатывается в данный момент. Также печатается различная статистика по таблицам.</target>
        </trans-unit>
        <trans-unit id="14f1458fcf796362f90bd6b53ff757eaee1e2939" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VERBOSE&lt;/code&gt; is specified, &lt;code&gt;VACUUM&lt;/code&gt; emits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.</source>
          <target state="translated">Когда указан &lt;code&gt;VERBOSE&lt;/code&gt; , &lt;code&gt;VACUUM&lt;/code&gt; выдает сообщения о ходе выполнения, чтобы указать, какая таблица обрабатывается в данный момент. Также печатается различная статистика по таблицам.</target>
        </trans-unit>
        <trans-unit id="f54823d23e5df73c9472414a7a83e6ba082b1ce2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\ef&lt;/code&gt;, or &lt;code&gt;\ev&lt;/code&gt; is used with a line number argument, this variable specifies the command-line argument used to pass the starting line number to the user's editor. For editors such as Emacs or vi, this is a plus sign. Include a trailing space in the value of the variable if there needs to be space between the option name and the line number. Examples:</source>
          <target state="translated">Когда &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\ef&lt;/code&gt; или &lt;code&gt;\ev&lt;/code&gt; используется с аргументом номера строки, эта переменная определяет аргумент командной строки, используемый для передачи номера начальной строки в редактор пользователя. Для редакторов, таких как Emacs или vi, это знак плюса. Включите конечный пробел в значение переменной, если между именем параметра и номером строки должен быть пробел. Примеры:</target>
        </trans-unit>
        <trans-unit id="880bf87755564e46a3f310f5734ab8ac6764465b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;archive_mode&lt;/code&gt; is enabled, completed WAL segments are sent to archive storage by setting &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. In addition to &lt;code&gt;off&lt;/code&gt;, to disable, there are two modes: &lt;code&gt;on&lt;/code&gt;, and &lt;code&gt;always&lt;/code&gt;. During normal operation, there is no difference between the two modes, but when set to &lt;code&gt;always&lt;/code&gt; the WAL archiver is enabled also during archive recovery or standby mode. In &lt;code&gt;always&lt;/code&gt; mode, all files restored from the archive or streamed with streaming replication will be archived (again). See &lt;a href=&quot;warm-standby#CONTINUOUS-ARCHIVING-IN-STANDBY&quot;&gt;Section 26.2.9&lt;/a&gt; for details.</source>
          <target state="translated">Когда &lt;code&gt;archive_mode&lt;/code&gt; включен, завершенные сегменты WAL отправляются в архивное хранилище путем установки &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; . Кроме &lt;code&gt;off&lt;/code&gt; , для отключения есть два режима: &lt;code&gt;on&lt;/code&gt; и &lt;code&gt;always&lt;/code&gt; . Во время нормальной работы между этими двумя режимами нет разницы, но при установке &lt;code&gt;always&lt;/code&gt; архиватор WAL включен также во время восстановления архива или в режиме ожидания. В &lt;code&gt;always&lt;/code&gt; режиме все файлы, восстановленные из архива или передаваемые с потоковой репликацией, будут заархивированы (снова). См &lt;a href=&quot;warm-standby#CONTINUOUS-ARCHIVING-IN-STANDBY&quot;&gt;Раздел 26.2.9&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="46cdaf5a9c68bb7dda3e95a7d23c6fce30bcf59a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;commit_delay&lt;/code&gt; is set to zero (the default), it is still possible for a form of group commit to occur, but each group will consist only of sessions that reach the point where they need to flush their commit records during the window in which the previous flush operation (if any) is occurring. At higher client counts a &amp;ldquo;gangway effect&amp;rdquo; tends to occur, so that the effects of group commit become significant even when &lt;code&gt;commit_delay&lt;/code&gt; is zero, and thus explicitly setting &lt;code&gt;commit_delay&lt;/code&gt; tends to help less. Setting &lt;code&gt;commit_delay&lt;/code&gt; can only help when (1) there are some concurrently committing transactions, and (2) throughput is limited to some degree by commit rate; but with high rotational latency this setting can be effective in increasing transaction throughput with as few as two clients (that is, a single committing client with one sibling transaction).</source>
          <target state="translated">Когда для &lt;code&gt;commit_delay&lt;/code&gt; установлено значение ноль (по умолчанию), форма групповой фиксации все еще возможна, но каждая группа будет состоять только из сеансов, которые достигают точки, когда им необходимо сбросить свои записи фиксации в течение окна, в котором предыдущая операция промывки (если таковая имеется). При более высоком числе клиентов имеет тенденцию возникать &amp;laquo;эффект сходня&amp;raquo;, так что эффекты групповой фиксации становятся значительными, даже когда &lt;code&gt;commit_delay&lt;/code&gt; равен нулю, и, следовательно, явная установка &lt;code&gt;commit_delay&lt;/code&gt; имеет тенденцию меньше помогать. Установка &lt;code&gt;commit_delay&lt;/code&gt; может помочь только тогда, когда (1) есть несколько одновременных транзакций, и (2) пропускная способность в некоторой степени ограничена скоростью фиксации; но с высокой задержкой ротации этот параметр может быть эффективным для увеличения пропускной способности транзакции всего с двумя клиентами (то есть с одним фиксирующим клиентом с одной транзакцией-братом).</target>
        </trans-unit>
        <trans-unit id="639e6544c619e9aa79e7a25d85adc789836438b5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;default_tablespace&lt;/code&gt; is set to anything but an empty string, it supplies an implicit &lt;code&gt;TABLESPACE&lt;/code&gt; clause for &lt;code&gt;CREATE TABLE&lt;/code&gt; and &lt;code&gt;CREATE INDEX&lt;/code&gt; commands that do not have an explicit one.</source>
          <target state="translated">Когда &lt;code&gt;default_tablespace&lt;/code&gt; имеет значение, отличное от пустой строки, он предоставляет неявное предложение &lt;code&gt;TABLESPACE&lt;/code&gt; для команд &lt;code&gt;CREATE TABLE&lt;/code&gt; и &lt;code&gt;CREATE INDEX&lt;/code&gt; , которые не имеют явного предложения.</target>
        </trans-unit>
        <trans-unit id="26b9fcc2ea9102afd846d23d5a3d7acf06ea6fcf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;extractQuery&lt;/code&gt; returns a null key in &lt;code&gt;queryKeys[]&lt;/code&gt;, the corresponding &lt;code&gt;check[]&lt;/code&gt; element is true if the indexed item contains a null key; that is, the semantics of &lt;code&gt;check[]&lt;/code&gt; are like &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt;. The &lt;code&gt;consistent&lt;/code&gt; function can examine the corresponding &lt;code&gt;nullFlags[]&lt;/code&gt; element if it needs to tell the difference between a regular value match and a null match.</source>
          <target state="translated">Когда &lt;code&gt;extractQuery&lt;/code&gt; возвращает нулевой ключ в &lt;code&gt;queryKeys[]&lt;/code&gt; , соответствующий элемент &lt;code&gt;check[]&lt;/code&gt; является истинным, если индексированный элемент содержит нулевой ключ; то есть семантика &lt;code&gt;check[]&lt;/code&gt; похожа на &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; . &lt;code&gt;consistent&lt;/code&gt; функции может изучить соответствующие &lt;code&gt;nullFlags[]&lt;/code&gt; элемент , если это необходимо , чтобы заметить разницу между обычным значением матчем и матчем нулевым.</target>
        </trans-unit>
        <trans-unit id="e521d3acb4576333ab5bee010106dc1a1c2bc018" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;geqo_threshold&lt;/code&gt; is exceeded, the join sequences considered are determined by heuristics, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;. Otherwise the process is the same.</source>
          <target state="translated">При превышении &lt;code&gt;geqo_threshold&lt;/code&gt; рассматриваемые последовательности соединений определяются эвристикой, как описано в &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;главе 59&lt;/a&gt; . В остальном процесс такой же.</target>
        </trans-unit>
        <trans-unit id="5dc55d7e2d48050cd0f6633337d76448e1d4e69c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;geqo_threshold&lt;/code&gt; is exceeded, the join sequences considered are determined by heuristics, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;. Otherwise the process is the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28ef38bf9e5530ece862031c842201d36ddd349" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the directory in which log files will be created. It can be specified as an absolute path, or relative to the cluster data directory. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;log&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;logging_collector&lt;/code&gt; включен, этот параметр определяет каталог, в котором будут созданы файлы журнала. Его можно указать как абсолютный путь или относительно каталога данных кластера. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера. По умолчанию это &lt;code&gt;log&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3acb8f6d64e7dee8bb588e16430447375cec4a1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the maximum amount of time to use an individual log file, after which a new log file will be created. If this value is specified without units, it is taken as minutes. The default is 24 hours. Set to zero to disable time-based creation of new log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Когда &lt;code&gt;logging_collector&lt;/code&gt; включен, этот параметр определяет максимальное количество времени для использования отдельного файла журнала, по истечении которого будет создан новый файл журнала. Если это значение указано без единиц измерения, оно принимается в минутах. По умолчанию - 24 часа. Установите в ноль, чтобы отключить создание новых файлов журнала по времени. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="6ba6806c5a61bd0e7df256b20d72936b6dfff344" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the maximum size of an individual log file. After this amount of data has been emitted into a log file, a new log file will be created. If this value is specified without units, it is taken as kilobytes. The default is 10 megabytes. Set to zero to disable size-based creation of new log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Когда &lt;code&gt;logging_collector&lt;/code&gt; включен, этот параметр определяет максимальный размер отдельного файла журнала. После того, как этот объем данных будет записан в файл журнала, будет создан новый файл журнала. Если это значение указано без единиц измерения, оно принимается в килобайтах. По умолчанию - 10 мегабайт. Установите в ноль, чтобы отключить создание новых файлов журнала на основе размера. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="33d04df6ccc65336486b417a686759bd20169c58" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter sets the file names of the created log files. The value is treated as a &lt;code&gt;strftime&lt;/code&gt; pattern, so &lt;code&gt;%&lt;/code&gt;-escapes can be used to specify time-varying file names. (Note that if there are any time-zone-dependent &lt;code&gt;%&lt;/code&gt;-escapes, the computation is done in the zone specified by &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;.) The supported &lt;code&gt;%&lt;/code&gt;-escapes are similar to those listed in the Open Group's &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt; specification. Note that the system's &lt;code&gt;strftime&lt;/code&gt; is not used directly, so platform-specific (nonstandard) extensions do not work. The default is &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;logging_collector&lt;/code&gt; включен, этот параметр устанавливает имена файлов созданных файлов журнала. Значение обрабатывается как шаблон &lt;code&gt;strftime&lt;/code&gt; , поэтому &lt;code&gt;%&lt;/code&gt; -escapes можно использовать для указания изменяющихся во времени имен файлов. (Обратите внимание, что если есть какие-либо &lt;code&gt;%&lt;/code&gt; -экраны, зависящие от часового пояса, вычисление выполняется в зоне, указанной в &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; .) Поддерживаемые &lt;code&gt;%&lt;/code&gt; -экраны аналогичны тем, которые перечислены в спецификации &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt; Open Group . Обратите внимание, что системный &lt;code&gt;strftime&lt;/code&gt; не используется напрямую, поэтому специфичные для платформы (нестандартные) расширения не работают. По умолчанию это &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de9428c551b8b57c64cfa71598ced7921a3ab10e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter sets the file names of the created log files. The value is treated as a &lt;code&gt;strftime&lt;/code&gt; pattern, so &lt;code&gt;%&lt;/code&gt;-escapes can be used to specify time-varying file names. (Note that if there are any time-zone-dependent &lt;code&gt;%&lt;/code&gt;-escapes, the computation is done in the zone specified by &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;.) The supported &lt;code&gt;%&lt;/code&gt;-escapes are similar to those listed in the Open Group's &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt; specification. Note that the system's &lt;code&gt;strftime&lt;/code&gt; is not used directly, so platform-specific (nonstandard) extensions do not work. The default is &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912a8bc2db1f94954749b8b7569bc346c69e11ee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter will cause PostgreSQL to truncate (overwrite), rather than append to, any existing log file of the same name. However, truncation will occur only when a new file is being opened due to time-based rotation, not during server startup or size-based rotation. When off, pre-existing files will be appended to in all cases. For example, using this setting in combination with a &lt;code&gt;log_filename&lt;/code&gt; like &lt;code&gt;postgresql-%H.log&lt;/code&gt; would result in generating twenty-four hourly log files and then cyclically overwriting them. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Когда &lt;code&gt;logging_collector&lt;/code&gt; включен, этот параметр заставит PostgreSQL усекать (перезаписывать), а не добавлять в любой существующий файл журнала с тем же именем. Однако усечение будет происходить только при открытии нового файла из-за ротации по времени, а не во время запуска сервера или ротации по размеру. Если выключено, во всех случаях будут добавляться уже существующие файлы. Например, использование этого параметра в сочетании с &lt;code&gt;log_filename&lt;/code&gt; ,таким как &lt;code&gt;postgresql-%H.log&lt;/code&gt; приведет к созданию файлов журналов, которые хранятся в двадцатичетырехчасовом режиме, а затем их циклической перезаписи. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="ac2a30741ea2b8dcb498e785772cf2a514f01258" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;on&lt;/code&gt; (the default), each SQL command is automatically committed upon successful completion. To postpone commit in this mode, you must enter a &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;START TRANSACTION&lt;/code&gt; SQL command. When &lt;code&gt;off&lt;/code&gt; or unset, SQL commands are not committed until you explicitly issue &lt;code&gt;COMMIT&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;. The autocommit-off mode works by issuing an implicit &lt;code&gt;BEGIN&lt;/code&gt; for you, just before any command that is not already in a transaction block and is not itself a &lt;code&gt;BEGIN&lt;/code&gt; or other transaction-control command, nor a command that cannot be executed inside a transaction block (such as &lt;code&gt;VACUUM&lt;/code&gt;).</source>
          <target state="translated">Когда &lt;code&gt;on&lt;/code&gt; (по умолчанию), каждая команда SQL автоматически фиксируется после успешного завершения. Чтобы отложить фиксацию в этом режиме, необходимо ввести SQL-команду &lt;code&gt;BEGIN&lt;/code&gt; или &lt;code&gt;START TRANSACTION&lt;/code&gt; . Когда &lt;code&gt;off&lt;/code&gt; или не установлено, команды SQL не фиксируются, пока вы явно не &lt;code&gt;COMMIT&lt;/code&gt; или &lt;code&gt;END&lt;/code&gt; . Режим autocommit-off работает путем выдачи неявного &lt;code&gt;BEGIN&lt;/code&gt; для вас непосредственно перед любой командой, которая еще не находится в блоке транзакции и сама не является &lt;code&gt;BEGIN&lt;/code&gt; или другой командой управления транзакцией, а также командой, которая не может быть выполнена внутри блока транзакции (например, &lt;code&gt;VACUUM&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c85a8f652ce31ff087a3b7cc628918aedc0afe36" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;pg_stat_statements&lt;/code&gt; is loaded, it tracks statistics across all databases of the server. To access and manipulate these statistics, the module provides a view, &lt;code&gt;pg_stat_statements&lt;/code&gt;, and the utility functions &lt;code&gt;pg_stat_statements_reset&lt;/code&gt; and &lt;code&gt;pg_stat_statements&lt;/code&gt;. These are not available globally but can be enabled for a specific database with &lt;code&gt;CREATE EXTENSION pg_stat_statements&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;pg_stat_statements&lt;/code&gt; загружен, он отслеживает статистику по всем базам данных сервера. Для доступа к этой статистике и управления &lt;code&gt;pg_stat_statements&lt;/code&gt; в модуле есть представление pg_stat_statements и служебные функции &lt;code&gt;pg_stat_statements_reset&lt;/code&gt; и &lt;code&gt;pg_stat_statements&lt;/code&gt; . Они недоступны глобально, но могут быть включены для конкретной базы данных с помощью &lt;code&gt;CREATE EXTENSION pg_stat_statements&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c48693eca5bd4dca7f7f71afdfbb3d41be3ea38" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;postgres_fdw&lt;/code&gt; encounters a join between foreign tables on the same foreign server, it sends the entire join to the foreign server, unless for some reason it believes that it will be more efficient to fetch rows from each table individually, or unless the table references involved are subject to different user mappings. While sending the &lt;code&gt;JOIN&lt;/code&gt; clauses, it takes the same precautions as mentioned above for the &lt;code&gt;WHERE&lt;/code&gt; clauses.</source>
          <target state="translated">Когда &lt;code&gt;postgres_fdw&lt;/code&gt; встречает соединение между сторонними таблицами на одном и том же внешнем сервере, он отправляет все соединение на внешний сервер, если только по какой-то причине он не считает, что будет более эффективно извлекать строки из каждой таблицы по отдельности, или если таблицы не задействованы подвержены различным сопоставлениям пользователей. При отправке предложений &lt;code&gt;JOIN&lt;/code&gt; предпринимаются те же меры предосторожности, что и упомянутые выше для &lt;code&gt;WHERE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c8497bbbc5c881081d121fdf01a588723979b05" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;program&lt;/code&gt; is specified, &lt;code&gt;command&lt;/code&gt; is executed by psql and the data passed from or to &lt;code&gt;command&lt;/code&gt; is routed between the server and the client. Again, the execution privileges are those of the local user, not the server, and no SQL superuser privileges are required.</source>
          <target state="translated">Когда указана &lt;code&gt;program&lt;/code&gt; , &lt;code&gt;command&lt;/code&gt; выполняется psql, а данные, передаваемые от или к &lt;code&gt;command&lt;/code&gt; , маршрутизируются между сервером и клиентом. Опять же, привилегии выполнения принадлежат локальному пользователю, а не серверу, и привилегии суперпользователя SQL не требуются.</target>
        </trans-unit>
        <trans-unit id="6840df87dd751c0fab0c6f46649358f6b34c5849" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;slot_name&lt;/code&gt; is set to &lt;code&gt;NONE&lt;/code&gt;, there will be no replication slot associated with the subscription. This can be used if the replication slot will be created later manually. Such subscriptions must also have both &lt;code&gt;enabled&lt;/code&gt; and &lt;code&gt;create_slot&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если для &lt;code&gt;slot_name&lt;/code&gt; установлено значение &lt;code&gt;NONE&lt;/code&gt; , с подпиской не будет никакого слота репликации. Это можно использовать, если слот репликации будет создан позже вручную. В таких подписках также должны быть &lt;code&gt;enabled&lt;/code&gt; и параметр &lt;code&gt;create_slot&lt;/code&gt; , и значение &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3788a4cfcb030ae27460c4ddd94f0d92885c664" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;temp_tablespaces&lt;/code&gt; is set interactively, specifying a nonexistent tablespace is an error, as is specifying a tablespace for which the user does not have &lt;code&gt;CREATE&lt;/code&gt; privilege. However, when using a previously set value, nonexistent tablespaces are ignored, as are tablespaces for which the user lacks &lt;code&gt;CREATE&lt;/code&gt; privilege. In particular, this rule applies when using a value set in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;temp_tablespaces&lt;/code&gt; устанавливается в интерактивном режиме, указание несуществующего табличного пространства является ошибкой, как и указание табличного пространства, для которого пользователь не имеет права &lt;code&gt;CREATE&lt;/code&gt; . Однако при использовании ранее установленного значения несуществующие табличные пространства игнорируются, как и табличные пространства, для которых пользователю не хватает привилегии &lt;code&gt;CREATE&lt;/code&gt; . В частности, это правило применяется при использовании значения, установленного в &lt;code&gt;postgresql.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c068d98cbad8e288e90e4c1dd972e7c59abbaa3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;tgconstraint&lt;/code&gt; is nonzero, &lt;code&gt;tgconstrrelid&lt;/code&gt;, &lt;code&gt;tgconstrindid&lt;/code&gt;, &lt;code&gt;tgdeferrable&lt;/code&gt;, and &lt;code&gt;tginitdeferred&lt;/code&gt; are largely redundant with the referenced &lt;code&gt;pg_constraint&lt;/code&gt; entry. However, it is possible for a non-deferrable trigger to be associated with a deferrable constraint: foreign key constraints can have some deferrable and some non-deferrable triggers.</source>
          <target state="translated">Когда &lt;code&gt;tgconstraint&lt;/code&gt; отличен от нуля, &lt;code&gt;tgconstrrelid&lt;/code&gt; , &lt;code&gt;tgconstrindid&lt;/code&gt; , &lt;code&gt;tgdeferrable&lt;/code&gt; и &lt;code&gt;tginitdeferred&lt;/code&gt; в значительной степени избыточны с &lt;code&gt;pg_constraint&lt;/code&gt; записью pg_constraint . Тем не менее, неотложный триггер может быть связан с откладываемым ограничением: ограничения внешнего ключа могут иметь некоторые откладываемые и некоторые неотложные триггеры.</target>
        </trans-unit>
        <trans-unit id="19d575b88117ece85c7a87c6ea7ead5a6532b19a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trust&lt;/code&gt; authentication is specified, PostgreSQL assumes that anyone who can connect to the server is authorized to access the database with whatever database user name they specify (even superuser names). Of course, restrictions made in the &lt;code&gt;database&lt;/code&gt; and &lt;code&gt;user&lt;/code&gt; columns still apply. This method should only be used when there is adequate operating-system-level protection on connections to the server.</source>
          <target state="translated">Если указана &lt;code&gt;trust&lt;/code&gt; аутентификация, PostgreSQL предполагает, что любой, кто может подключиться к серверу, имеет право доступа к базе данных с любым указанным им именем пользователя базы данных (даже с именами суперпользователя). Конечно, все еще действуют ограничения, установленные в &lt;code&gt;database&lt;/code&gt; и &lt;code&gt;user&lt;/code&gt; столбцах. Этот метод следует использовать только при наличии адекватной защиты на уровне операционной системы для подключений к серверу.</target>
        </trans-unit>
        <trans-unit id="966280f7c40171987c3cbc983291b38e3a71017e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use_remote_estimate&lt;/code&gt; is true, &lt;code&gt;postgres_fdw&lt;/code&gt; obtains row count and cost estimates from the remote server and then adds &lt;code&gt;fdw_startup_cost&lt;/code&gt; and &lt;code&gt;fdw_tuple_cost&lt;/code&gt; to the cost estimates. When &lt;code&gt;use_remote_estimate&lt;/code&gt; is false, &lt;code&gt;postgres_fdw&lt;/code&gt; performs local row count and cost estimation and then adds &lt;code&gt;fdw_startup_cost&lt;/code&gt; and &lt;code&gt;fdw_tuple_cost&lt;/code&gt; to the cost estimates. This local estimation is unlikely to be very accurate unless local copies of the remote table's statistics are available. Running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on the foreign table is the way to update the local statistics; this will perform a scan of the remote table and then calculate and store statistics just as though the table were local. Keeping local statistics can be a useful way to reduce per-query planning overhead for a remote table &amp;mdash; but if the remote table is frequently updated, the local statistics will soon be obsolete.</source>
          <target state="translated">Когда &lt;code&gt;use_remote_estimate&lt;/code&gt; имеет значение true, &lt;code&gt;postgres_fdw&lt;/code&gt; получает количество строк и оценки стоимости с удаленного сервера, а затем добавляет &lt;code&gt;fdw_startup_cost&lt;/code&gt; и &lt;code&gt;fdw_tuple_cost&lt;/code&gt; к оценкам стоимости. Когда &lt;code&gt;use_remote_estimate&lt;/code&gt; имеет значение false, &lt;code&gt;postgres_fdw&lt;/code&gt; выполняет локальный подсчет строк и оценку стоимости, а затем добавляет &lt;code&gt;fdw_startup_cost&lt;/code&gt; и &lt;code&gt;fdw_tuple_cost&lt;/code&gt; к оценке стоимости. Эта локальная оценка вряд ли будет очень точной, если не будут доступны локальные копии статистики удаленной таблицы. Запуск &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;на внешней таблице - способ обновления локальной статистики; это выполнит сканирование удаленной таблицы, а затем вычислит и сохранит статистику, как если бы таблица была локальной. Хранение локальной статистики может быть полезным способом уменьшить накладные расходы на планирование для удаленной таблицы, но если удаленная таблица часто обновляется, локальная статистика скоро устареет.</target>
        </trans-unit>
        <trans-unit id="fb7e09297d71df57df7c85aea76275071123b814" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; and a transaction commits after creating or rewriting a permanent relation, this setting determines how to persist the new data. If the data is smaller than this setting, write it to the WAL log; otherwise, use an fsync of affected files. Depending on the properties of your storage, raising or lowering this value might help if such commits are slowing concurrent transactions. If this value is specified without units, it is taken as kilobytes. The default is two megabytes (&lt;code&gt;2MB&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04447293cfe5a43fce5bd6f976cc350e753a232" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; some SQL commands are optimized to avoid WAL logging, as described in &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;. If archiving or streaming replication were turned on during execution of one of these statements, WAL would not contain enough information for archive recovery. (Crash recovery is unaffected.) For this reason, &lt;code&gt;wal_level&lt;/code&gt; can only be changed at server start. However, &lt;code&gt;archive_command&lt;/code&gt; can be changed with a configuration file reload. If you wish to temporarily stop archiving, one way to do it is to set &lt;code&gt;archive_command&lt;/code&gt; to the empty string (&lt;code&gt;''&lt;/code&gt;). This will cause WAL files to accumulate in &lt;code&gt;pg_wal/&lt;/code&gt; until a working &lt;code&gt;archive_command&lt;/code&gt; is re-established.</source>
          <target state="translated">Когда &lt;code&gt;wal_level&lt;/code&gt; является &lt;code&gt;minimal&lt;/code&gt; некоторые команды SQL оптимизированы , чтобы избежать WAL протоколирование, как описано в &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;разделе 14.4.7&lt;/a&gt; . Если бы архивирование или потоковая репликация были включены во время выполнения одного из этих операторов, WAL не содержал бы достаточно информации для восстановления архива. (Это не влияет на восстановление после &lt;code&gt;wal_level&lt;/code&gt; .) По этой причине wal_level можно изменить только при запуске сервера. Однако &lt;code&gt;archive_command&lt;/code&gt; можно изменить, перезагрузив файл конфигурации. Если вы хотите временно остановить архивирование, один из способов сделать это - установить &lt;code&gt;archive_command&lt;/code&gt; в пустую строку ( &lt;code&gt;''&lt;/code&gt; ). Это приведет к тому, что файлы WAL будут накапливаться в &lt;code&gt;pg_wal/&lt;/code&gt; до тех пор, пока &lt;code&gt;archive_command&lt;/code&gt; восстанавливается.</target>
        </trans-unit>
        <trans-unit id="bc54463c4a91042c587b320f65f275bd091c2193" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is performed, there is generally a greatly increased chance of detecting single-bit errors, since strict binary equality is tested, and the indexed attributes within the heap are tested.</source>
          <target state="translated">Когда &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; проверка с &lt;em&gt;индексом кучи&lt;/em&gt; , как правило, значительно повышается вероятность обнаружения однобитовых ошибок, поскольку проверяется строгое двоичное равенство и проверяются индексированные атрибуты в куче.</target>
        </trans-unit>
        <trans-unit id="668fe437dfa47692f950b23dc7849bfb4637dcda" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;loop_count&lt;/code&gt;&lt;/em&gt; is greater than one, the returned numbers should be averages expected for any one scan of the index.</source>
          <target state="translated">Когда &lt;em&gt; &lt;code&gt;loop_count&lt;/code&gt; &lt;/em&gt; больше единицы, возвращаемые числа должны быть средними значениями, ожидаемыми для любого сканирования индекса.</target>
        </trans-unit>
        <trans-unit id="36ef5495d24b79877e9b0ce1d70303e79e6501c2" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is positive, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is greater than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Conversely, when &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is negative, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is less than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Zero rows are also returned for &lt;code&gt;NULL&lt;/code&gt; inputs. It is an error for &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; to be zero. Some examples follow:</source>
          <target state="translated">Если &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; положительный, возвращаются нулевые строки, если &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; больше, чем &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt; . И наоборот, если &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; отрицательный, возвращаются нулевые строки, если &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; меньше &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt; . Нулевые строки также возвращаются для входов &lt;code&gt;NULL&lt;/code&gt; . Нулевое значение &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; является ошибкой . Ниже приведены некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="80eeda2a3957217fb0ef90a74740dda9cf0f27e8" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is positive, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is greater than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Conversely, when &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is negative, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is less than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Zero rows are also returned if any input is &lt;code&gt;NULL&lt;/code&gt;. It is an error for &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; to be zero. Some examples follow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1d230678ad6398ea1b726af7844a229cc8f13e" translate="yes" xml:space="preserve">
          <source>When Can Parallel Query Be Used?</source>
          <target state="translated">Когда можно использовать параллельный запрос?</target>
        </trans-unit>
        <trans-unit id="1ace675b775ff95ec59fcdc66447d15d12e35d34" translate="yes" xml:space="preserve">
          <source>When Color is Used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5a55e381f3b4b99fc5f9dc03b78c3fc758ed84" translate="yes" xml:space="preserve">
          <source>When GSSAPI uses Kerberos, it uses a standard principal in the format &lt;code&gt;servicename/hostname@realm&lt;/code&gt;. The PostgreSQL server will accept any principal that is included in the keytab used by the server, but care needs to be taken to specify the correct principal details when making the connection from the client using the &lt;code&gt;krbsrvname&lt;/code&gt; connection parameter. (See also &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;.) The installation default can be changed from the default &lt;code&gt;postgres&lt;/code&gt; at build time using &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt;&lt;code&gt;whatever&lt;/code&gt;. In most environments, this parameter never needs to be changed. Some Kerberos implementations might require a different service name, such as Microsoft Active Directory which requires the service name to be in upper case (&lt;code&gt;POSTGRES&lt;/code&gt;).</source>
          <target state="translated">Когда GSSAPI использует Kerberos, он использует стандартный принципал в формате &lt;code&gt;servicename/hostname@realm&lt;/code&gt; . Сервер PostgreSQL примет любого принципала, включенного в ключевую таблицу, используемую сервером, но необходимо позаботиться о том, чтобы указать правильные детали принципала при установлении соединения от клиента с использованием параметра подключения &lt;code&gt;krbsrvname&lt;/code&gt; . (Смотрите также &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;раздел 33.1.2&lt;/a&gt; .) Установка по умолчанию может быть изменено с по умолчанию &lt;code&gt;postgres&lt;/code&gt; во время сборки с помощью &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt; &lt;code&gt;whatever&lt;/code&gt; . В большинстве сред этот параметр никогда не нужно изменять. Для некоторых реализаций Kerberos может потребоваться другое имя службы, например Microsoft Active Directory, которая требует, чтобы имя службы было в верхнем регистре ( &lt;code&gt;POSTGRES&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d0d3dbcdfb1b49d79ff3ed10298c962dc04c9d92" translate="yes" xml:space="preserve">
          <source>When GSSAPI uses Kerberos, it uses a standard principal in the format &lt;code&gt;servicename/hostname@realm&lt;/code&gt;. The PostgreSQL server will accept any principal that is included in the keytab used by the server, but care needs to be taken to specify the correct principal details when making the connection from the client using the &lt;code&gt;krbsrvname&lt;/code&gt; connection parameter. (See also &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;.) The installation default can be changed from the default &lt;code&gt;postgres&lt;/code&gt; at build time using &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt;&lt;code&gt;whatever&lt;/code&gt;. In most environments, this parameter never needs to be changed. Some Kerberos implementations might require a different service name, such as Microsoft Active Directory which requires the service name to be in upper case (&lt;code&gt;POSTGRES&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb176371849755f8e3fddd6c5c7996731ba8719c" translate="yes" xml:space="preserve">
          <source>When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt;. &lt;code&gt;max_standby_archive_delay&lt;/code&gt; applies when WAL data is being read from WAL archive (and is therefore not current). If this value is specified without units, it is taken as milliseconds. The default is 30 seconds. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Когда активен горячий резерв, этот параметр определяет, как долго резервный сервер должен ждать перед отменой резервных запросов, конфликтующих с &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;готовыми к&lt;/a&gt; применению записями WAL, как описано в Разделе 26.5.2 . &lt;code&gt;max_standby_archive_delay&lt;/code&gt; применяется, когда данные WAL считываются из архива WAL (и поэтому не являются текущими). Если это значение указано без единиц измерения, оно принимается в миллисекундах. По умолчанию 30 секунд. Значение -1 позволяет резервному серверу бесконечно ждать завершения конфликтующих запросов. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="0ec8116773102304d6d7b1390f1e98f30e3bb2ff" translate="yes" xml:space="preserve">
          <source>When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt;. &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; applies when WAL data is being received via streaming replication. If this value is specified without units, it is taken as milliseconds. The default is 30 seconds. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Когда активен горячий резерв, этот параметр определяет, как долго резервный сервер должен ждать перед отменой резервных запросов, конфликтующих с &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;готовыми к&lt;/a&gt; применению записями WAL, как описано в Разделе 26.5.2 . &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; применяется, когда данные WAL принимаются через потоковую репликацию. Если это значение указано без единиц измерения, оно принимается в миллисекундах. По умолчанию 30 секунд. Значение -1 позволяет резервному серверу бесконечно ждать завершения конфликтующих запросов. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="0f0d78fac0ffb73c1a9e09c7cc14d11764cc7556" translate="yes" xml:space="preserve">
          <source>When PostgreSQL maps SQL data values to XML (as in &lt;code&gt;xmlelement&lt;/code&gt;), or XML to SQL (as in the output columns of &lt;code&gt;xmltable&lt;/code&gt;), except for a few cases treated specially, PostgreSQL simply assumes that the XML data type's XPath 1.0 string form will be valid as the text-input form of the SQL datatype, and conversely. This rule has the virtue of simplicity while producing, for many data types, results similar to the mappings specified in the standard.</source>
          <target state="translated">Когда PostgreSQL отображает значения данных SQL в XML (как в &lt;code&gt;xmlelement&lt;/code&gt; ) или XML в SQL (как в выходных столбцах &lt;code&gt;xmltable&lt;/code&gt; ), за исключением нескольких случаев, рассматриваемых специально, PostgreSQL просто предполагает, что строковая форма типа данных XML XPath 1.0 будет иметь вид действительна как форма ввода текста для типа данных SQL, и наоборот. Это правило отличается простотой и дает для многих типов данных результаты, аналогичные сопоставлениям, указанным в стандарте.</target>
        </trans-unit>
        <trans-unit id="4181958cdfd24c8fd1ab7073c5b2ff83fa0a559f" translate="yes" xml:space="preserve">
          <source>When SCRAM-SHA-256 is used in PostgreSQL, the server will ignore the user name that the client sends in the &lt;code&gt;client-first-message&lt;/code&gt;. The user name that was already sent in the startup message is used instead. PostgreSQL supports multiple character encodings, while SCRAM dictates UTF-8 to be used for the user name, so it might be impossible to represent the PostgreSQL user name in UTF-8.</source>
          <target state="translated">Когда в PostgreSQL используется SCRAM-SHA-256, сервер игнорирует имя пользователя, которое клиент отправляет в сообщении &lt;code&gt;client-first-message&lt;/code&gt; . Вместо этого используется имя пользователя, которое уже было отправлено в стартовом сообщении. PostgreSQL поддерживает несколько кодировок символов, в то время как SCRAM диктует использование UTF-8 для имени пользователя, поэтому может быть невозможно представить имя пользователя PostgreSQL в UTF-8.</target>
        </trans-unit>
        <trans-unit id="b543779d02e501d6f789fd6a94efbe4d169a8312" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; clause is present, what essentially happens is that the target table is joined to the tables mentioned in the &lt;code&gt;from_item&lt;/code&gt; list, and each output row of the join represents an update operation for the target table. When using &lt;code&gt;FROM&lt;/code&gt; you should ensure that the join produces at most one output row for each row to be modified. In other words, a target row shouldn't join to more than one row from the other table(s). If it does, then only one of the join rows will be used to update the target row, but which one will be used is not readily predictable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd20efcfa95fdaaa37532258734ec47bc3eda12" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; clause is present, what essentially happens is that the target table is joined to the tables mentioned in the &lt;code&gt;from_list&lt;/code&gt;, and each output row of the join represents an update operation for the target table. When using &lt;code&gt;FROM&lt;/code&gt; you should ensure that the join produces at most one output row for each row to be modified. In other words, a target row shouldn't join to more than one row from the other table(s). If it does, then only one of the join rows will be used to update the target row, but which one will be used is not readily predictable.</source>
          <target state="translated">Когда присутствует предложение &lt;code&gt;FROM&lt;/code&gt; , по существу происходит то, что целевая таблица присоединяется к таблицам, упомянутым в &lt;code&gt;from_list&lt;/code&gt; , и каждая выходная строка соединения представляет собой операцию обновления для целевой таблицы. При использовании &lt;code&gt;FROM&lt;/code&gt; вы должны убедиться, что объединение создает не более одной выходной строки для каждой строки, которую необходимо изменить. Другими словами, целевая строка не должна присоединяться более чем к одной строке из другой таблицы (таблиц). Если это так, то только одна из строк соединения будет использоваться для обновления целевой строки, но какая из них будет использоваться, трудно предсказать.</target>
        </trans-unit>
        <trans-unit id="0a80d67f6221f67e848e31748e5e7aded5d6746e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; item contains &lt;code&gt;LATERAL&lt;/code&gt; cross-references, evaluation proceeds as follows: for each row of the &lt;code&gt;FROM&lt;/code&gt; item providing the cross-referenced column(s), or set of rows of multiple &lt;code&gt;FROM&lt;/code&gt; items providing the columns, the &lt;code&gt;LATERAL&lt;/code&gt; item is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).</source>
          <target state="translated">Когда элемент &lt;code&gt;FROM&lt;/code&gt; содержит &lt;code&gt;LATERAL&lt;/code&gt; перекрестные ссылки, оценка происходит следующим образом: для каждой строки элемента &lt;code&gt;FROM&lt;/code&gt; , предоставляющего столбец (столбцы) с перекрестными ссылками, или набора строк из нескольких элементов &lt;code&gt;FROM&lt;/code&gt; , обеспечивающих столбцы, элемент &lt;code&gt;LATERAL&lt;/code&gt; оценивается с использованием значения столбцов этой строки или набора строк. Результирующая строка (строки), как обычно, соединяется со строками, из которых они были вычислены. Это повторяется для каждой строки или набора строк из исходной таблицы (таблиц) столбца.</target>
        </trans-unit>
        <trans-unit id="9131be6a2fce2c0e060d15eb98b8c743d3328da0" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint is not deferrable, PostgreSQL checks for uniqueness immediately whenever a row is inserted or modified. The SQL standard says that uniqueness should be enforced only at the end of the statement; this makes a difference when, for example, a single command updates multiple key values. To obtain standard-compliant behavior, declare the constraint as &lt;code&gt;DEFERRABLE&lt;/code&gt; but not deferred (i.e., &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt;). Be aware that this can be significantly slower than immediate uniqueness checking.</source>
          <target state="translated">Если ограничение &lt;code&gt;UNIQUE&lt;/code&gt; или &lt;code&gt;PRIMARY KEY&lt;/code&gt; нельзя отложить, PostgreSQL немедленно проверяет уникальность при вставке или изменении строки. Стандарт SQL говорит, что уникальность должна быть обеспечена только в конце оператора; это имеет значение, когда, например, одна команда обновляет несколько значений ключа. Чтобы получить поведение, соответствующее стандарту, объявите ограничение как &lt;code&gt;DEFERRABLE&lt;/code&gt; но не отложенное (т. &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt; ). Имейте в виду, что это может быть значительно медленнее, чем немедленная проверка уникальности.</target>
        </trans-unit>
        <trans-unit id="d7633f6759da586e80f43626088973d06a48ea56" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;pg_cast&lt;/code&gt; entry has different source and target types and a function that takes more than one argument, it represents converting from one type to another and applying a length coercion in a single step. When no such entry is available, coercion to a type that uses a type modifier involves two steps, one to convert between data types and a second to apply the modifier.</source>
          <target state="translated">Когда запись &lt;code&gt;pg_cast&lt;/code&gt; имеет разные исходные и целевые типы и функцию, которая принимает более одного аргумента, она представляет преобразование из одного типа в другой и применение приведения длины за один шаг. Когда такой записи нет, приведение к типу, использующему модификатор типа, включает два шага: один для преобразования между типами данных, а второй - для применения модификатора.</target>
        </trans-unit>
        <trans-unit id="88f0e69da747f3bb16cb53c469a234fbf587434e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;timestamp with time zone&lt;/code&gt; value is output, it is always converted from UTC to the current &lt;code&gt;timezone&lt;/code&gt; zone, and displayed as local time in that zone. To see the time in another time zone, either change &lt;code&gt;timezone&lt;/code&gt; or use the &lt;code&gt;AT TIME ZONE&lt;/code&gt; construct (see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT&quot;&gt;Section 9.9.3&lt;/a&gt;).</source>
          <target state="translated">Когда выводится &lt;code&gt;timestamp with time zone&lt;/code&gt; значением часового пояса , она всегда конвертируется из UTC в текущий &lt;code&gt;timezone&lt;/code&gt; пояс и отображается как местное время в этой зоне. Чтобы увидеть время в другом часовом поясе, либо измените &lt;code&gt;timezone&lt;/code&gt; либо используйте конструкцию &lt;code&gt;AT TIME ZONE&lt;/code&gt; (см. &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT&quot;&gt;Раздел 9.9.3&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="27629e4b11182354bc4cc1d2c2660d2bd8a7f20c" translate="yes" xml:space="preserve">
          <source>When a cast has different source and target types and a function that takes more than one argument, it supports converting from one type to another and applying a length coercion in a single step. When no such entry is available, coercion to a type that uses a type modifier involves two cast steps, one to convert between data types and a second to apply the modifier.</source>
          <target state="translated">Когда гипс имеет различные типы источников и целей и функцию,которая принимает более одного аргумента,он поддерживает преобразование из одного типа в другой и применение принуждения по длине за один шаг.Когда такая запись недоступна,принуждение к типу,который использует модификатор типа,включает два шага приведения,один для преобразования между типами данных,а второй для применения модификатора.</target>
        </trans-unit>
        <trans-unit id="49788d41c6b6cbdafb9c157dde66cc21e7ad5c8d" translate="yes" xml:space="preserve">
          <source>When a cast is applied to a value expression of a known type, it represents a run-time type conversion. The cast will succeed only if a suitable type conversion operation has been defined. Notice that this is subtly different from the use of casts with constants, as shown in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Section 4.1.2.7&lt;/a&gt;. A cast applied to an unadorned string literal represents the initial assignment of a type to a literal constant value, and so it will succeed for any type (if the contents of the string literal are acceptable input syntax for the data type).</source>
          <target state="translated">Когда приведение применяется к выражению значения известного типа, оно представляет преобразование типа во время выполнения. Приведение будет успешным только в том случае, если была определена подходящая операция преобразования типа. Обратите внимание, что это немного отличается от использования приведения типов с константами, как показано в &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Разделе 4.1.2.7&lt;/a&gt; . Приведение, применяемое к неукрашенному строковому литералу, представляет собой начальное присвоение типа буквальному константному значению, поэтому оно будет успешным для любого типа (если содержимое строкового литерала является допустимым синтаксисом ввода для типа данных).</target>
        </trans-unit>
        <trans-unit id="cf5e183edf65b04ea968b8cbec71c03d82d34814" translate="yes" xml:space="preserve">
          <source>When a character string value is cast to or from type &lt;code&gt;xml&lt;/code&gt; without going through &lt;code&gt;XMLPARSE&lt;/code&gt; or &lt;code&gt;XMLSERIALIZE&lt;/code&gt;, respectively, the choice of &lt;code&gt;DOCUMENT&lt;/code&gt; versus &lt;code&gt;CONTENT&lt;/code&gt; is determined by the &amp;ldquo;XML option&amp;rdquo;  session configuration parameter, which can be set using the standard command:</source>
          <target state="translated">Когда значение символьной строки приводится к типу &lt;code&gt;xml&lt;/code&gt; или из него без прохождения &lt;code&gt;XMLPARSE&lt;/code&gt; или &lt;code&gt;XMLSERIALIZE&lt;/code&gt; , соответственно, выбор &lt;code&gt;DOCUMENT&lt;/code&gt; или &lt;code&gt;CONTENT&lt;/code&gt; определяется параметром конфигурации сеанса &amp;laquo;XML option&amp;raquo;, который можно установить с помощью стандартной команды:</target>
        </trans-unit>
        <trans-unit id="42fc13aa34e4743bab6d0037fe542f1b13a66649" translate="yes" xml:space="preserve">
          <source>When a column is added with &lt;code&gt;ADD COLUMN&lt;/code&gt; and a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; is specified, the default is evaluated at the time of the statement and the result stored in the table's metadata. That value will be used for the column for all existing rows. If no &lt;code&gt;DEFAULT&lt;/code&gt; is specified, NULL is used. In neither case is a rewrite of the table required.</source>
          <target state="translated">Когда столбец добавляется с помощью &lt;code&gt;ADD COLUMN&lt;/code&gt; и указывается энергонезависимое значение &lt;code&gt;DEFAULT&lt;/code&gt; , значение по умолчанию оценивается во время оператора, а результат сохраняется в метаданных таблицы. Это значение будет использоваться для столбца для всех существующих строк. Если &lt;code&gt;DEFAULT&lt;/code&gt; не указан, используется NULL. Ни в том, ни в другом случае не требуется переписывать таблицу.</target>
        </trans-unit>
        <trans-unit id="4617ca746c05eccbac9e1250d759f5bd44319fcd" translate="yes" xml:space="preserve">
          <source>When a conflicting query is short, it's typically desirable to allow it to complete by delaying WAL application for a little bit; but a long delay in WAL application is usually not desirable. So the cancel mechanism has parameters, &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;, that define the maximum allowed delay in WAL application. Conflicting queries will be canceled once it has taken longer than the relevant delay setting to apply any newly-received WAL data. There are two parameters so that different delay values can be specified for the case of reading WAL data from an archive (i.e., initial recovery from a base backup or &amp;ldquo;catching up&amp;rdquo; a standby server that has fallen far behind) versus reading WAL data via streaming replication.</source>
          <target state="translated">Когда конфликтующий запрос короткий, обычно желательно позволить ему завершиться, немного отложив приложение WAL; но длительная задержка в приложении WAL обычно нежелательна. Таким образом, механизм отмены имеет параметры &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; и &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; , которые определяют максимально допустимую задержку в приложении WAL. Конфликтующие запросы будут отменены, если для применения любых вновь полученных данных WAL потребуется больше времени, чем соответствующая настройка задержки. Есть два параметра, чтобы можно было указать разные значения задержки для случая чтения данных WAL из архива (т. Е. Начального восстановления из базовой резервной копии или &amp;laquo;догонять&amp;raquo; резервный сервер, который сильно отстает) по сравнению с чтением данных WAL через потоковая репликация.</target>
        </trans-unit>
        <trans-unit id="fe9942af75508e96643f23b2bb2b19c3cb29a5d8" translate="yes" xml:space="preserve">
          <source>When a connection to the database server as database user &lt;code&gt;someuser&lt;/code&gt; is requested, PostgreSQL will attempt to bind anonymously (since &lt;code&gt;ldapbinddn&lt;/code&gt; was not specified) to the LDAP server, perform a search for &lt;code&gt;(uid=someuser)&lt;/code&gt; under the specified base DN. If an entry is found, it will then attempt to bind using that found information and the password supplied by the client. If that second connection succeeds, the database access is granted.</source>
          <target state="translated">Когда запрашивается соединение с сервером базы данных в качестве пользователя базы данных &lt;code&gt;someuser&lt;/code&gt; , PostgreSQL будет пытаться анонимно (поскольку &lt;code&gt;ldapbinddn&lt;/code&gt; не был указан) выполнить привязку к серверу LDAP, выполнить поиск &lt;code&gt;(uid=someuser)&lt;/code&gt; под указанным базовым DN. Если запись найдена, она попытается выполнить привязку, используя найденную информацию и пароль, предоставленный клиентом. Если это второе соединение успешно, доступ к базе данных предоставляется.</target>
        </trans-unit>
        <trans-unit id="48781ec5a4acd4a7481b8c8839149e95712b5009" translate="yes" xml:space="preserve">
          <source>When a connection to the database server as database user &lt;code&gt;someuser&lt;/code&gt; is requested, PostgreSQL will attempt to bind to the LDAP server using the DN &lt;code&gt;cn=someuser, dc=example, dc=net&lt;/code&gt; and the password provided by the client. If that connection succeeds, the database access is granted.</source>
          <target state="translated">Когда запрашивается соединение с сервером базы данных от имени пользователя базы данных &lt;code&gt;someuser&lt;/code&gt; , PostgreSQL попытается подключиться к серверу LDAP, используя DN &lt;code&gt;cn=someuser, dc=example, dc=net&lt;/code&gt; и пароль, предоставленный клиентом. Если это соединение установлено успешно, доступ к базе данных предоставляется.</target>
        </trans-unit>
        <trans-unit id="c225436eedb2c4fcd16a275b1ddffc50962ab028" translate="yes" xml:space="preserve">
          <source>When a constant's value has been ignored for purposes of matching the query to other queries, the constant is replaced by a parameter symbol, such as &lt;code&gt;$1&lt;/code&gt;, in the &lt;code&gt;pg_stat_statements&lt;/code&gt; display. The rest of the query text is that of the first query that had the particular &lt;code&gt;queryid&lt;/code&gt; hash value associated with the &lt;code&gt;pg_stat_statements&lt;/code&gt; entry.</source>
          <target state="translated">Когда значение константы игнорируется с целью сопоставления запроса с другими запросами, константа заменяется символом параметра, например &lt;code&gt;$1&lt;/code&gt; , в отображении &lt;code&gt;pg_stat_statements&lt;/code&gt; . Остальной текст запроса - это текст первого запроса, у которого было конкретное хеш-значение &lt;code&gt;queryid&lt;/code&gt; , связанное с &lt;code&gt;pg_stat_statements&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecb409e448668771f827d8fbf0e7974aed415eec" translate="yes" xml:space="preserve">
          <source>When a data-only dump is chosen and the option &lt;code&gt;--disable-triggers&lt;/code&gt; is used, pg_dump emits commands to disable triggers on user tables before inserting the data, and then commands to re-enable them after the data has been inserted. If the restore is stopped in the middle, the system catalogs might be left in the wrong state.</source>
          <target state="translated">Если выбран дамп только данных и используется опция &lt;code&gt;--disable-triggers&lt;/code&gt; , pg_dump выдает команды для отключения триггеров в пользовательских таблицах перед вставкой данных, а затем команды для их повторного включения после того, как данные были вставлены. Если восстановление остановлено в середине, системные каталоги могут остаться в неправильном состоянии.</target>
        </trans-unit>
        <trans-unit id="2bb4292f30931b17f0bc254f84df53dc22a84368" translate="yes" xml:space="preserve">
          <source>When a direct database connection is specified using the &lt;code&gt;-d&lt;/code&gt; option, pg_restore internally executes SQL statements. If you have problems running pg_restore, make sure you are able to select information from the database using, for example, &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">Когда прямое соединение с базой данных указано с помощью опции &lt;code&gt;-d&lt;/code&gt; , pg_restore внутренне выполняет операторы SQL. Если у вас есть проблемы с запуском pg_restore, убедитесь, что вы можете выбирать информацию из базы данных, например, с помощью &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; . Также будут применяться любые настройки подключения по умолчанию и переменные среды, используемые интерфейсной библиотекой libpq.</target>
        </trans-unit>
        <trans-unit id="70b0a551bd1d82e60af1e6e20328604ac27e04a2" translate="yes" xml:space="preserve">
          <source>When a domain has multiple &lt;code&gt;CHECK&lt;/code&gt; constraints, they will be tested in alphabetical order by name. (PostgreSQL versions before 9.5 did not honor any particular firing order for &lt;code&gt;CHECK&lt;/code&gt; constraints.)</source>
          <target state="translated">Если для домена установлено несколько ограничений &lt;code&gt;CHECK&lt;/code&gt; , они будут проверяться в алфавитном порядке по имени. (В версиях PostgreSQL до 9.5 не соблюдается какой-либо конкретный порядок &lt;code&gt;CHECK&lt;/code&gt; ограничений CHECK .)</target>
        </trans-unit>
        <trans-unit id="d2882ec668c4758898724ea8c42f8d7a46c5af40" translate="yes" xml:space="preserve">
          <source>When a function in the &lt;code&gt;FROM&lt;/code&gt; clause is suffixed by &lt;code&gt;WITH ORDINALITY&lt;/code&gt;, a &lt;code&gt;bigint&lt;/code&gt; column is appended to the function's output column(s), which starts from 1 and increments by 1 for each row of the function's output. This is most useful in the case of set returning functions such as &lt;code&gt;unnest()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ae6b8670e18414fb24938a0f2cc8a6d1070788" translate="yes" xml:space="preserve">
          <source>When a function in the &lt;code&gt;FROM&lt;/code&gt; clause is suffixed by &lt;code&gt;WITH ORDINALITY&lt;/code&gt;, a &lt;code&gt;bigint&lt;/code&gt; column is appended to the output which starts from 1 and increments by 1 for each row of the function's output. This is most useful in the case of set returning functions such as &lt;code&gt;unnest()&lt;/code&gt;.</source>
          <target state="translated">Когда функция в предложении &lt;code&gt;FROM&lt;/code&gt; имеет суффикс &lt;code&gt;WITH ORDINALITY&lt;/code&gt; , столбец &lt;code&gt;bigint&lt;/code&gt; добавляется к выводу, который начинается с 1 и увеличивается на 1 для каждой строки вывода функции. Это наиболее полезно в случае набора возвращающих функций, таких как &lt;code&gt;unnest()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc5d8fb3f4d70c3c0f1dea589130a29e4dae23e6" translate="yes" xml:space="preserve">
          <source>When a heap entry is to be deleted (by &lt;code&gt;VACUUM&lt;/code&gt;), all its index entries must be removed first.</source>
          <target state="translated">Когда запись кучи должна быть удалена (с помощью &lt;code&gt;VACUUM&lt;/code&gt; ), все ее записи индекса должны быть сначала удалены.</target>
        </trans-unit>
        <trans-unit id="00af93fe8454ff02af34b94554824196fc81e8fc" translate="yes" xml:space="preserve">
          <source>When a locking clause appears at the top level of a &lt;code&gt;SELECT&lt;/code&gt; query, the rows that are locked are exactly those that are returned by the query; in the case of a join query, the rows locked are those that contribute to returned join rows. In addition, rows that satisfied the query conditions as of the query snapshot will be locked, although they will not be returned if they were updated after the snapshot and no longer satisfy the query conditions. If a &lt;code&gt;LIMIT&lt;/code&gt; is used, locking stops once enough rows have been returned to satisfy the limit (but note that rows skipped over by &lt;code&gt;OFFSET&lt;/code&gt; will get locked). Similarly, if a locking clause is used in a cursor's query, only rows actually fetched or stepped past by the cursor will be locked.</source>
          <target state="translated">Когда предложение блокировки появляется на верхнем уровне запроса &lt;code&gt;SELECT&lt;/code&gt; , блокируются именно те строки, которые возвращаются запросом; в случае запроса соединения заблокированы строки, которые участвуют в возвращаемых строках соединения. Кроме того, строки, удовлетворяющие условиям запроса на момент снимка запроса, будут заблокированы, хотя они не будут возвращены, если они были обновлены после снимка и больше не удовлетворяют условиям запроса. Если используется &lt;code&gt;LIMIT&lt;/code&gt; , блокировка прекращается после того, как было возвращено достаточное количество строк, чтобы удовлетворить предел (но обратите внимание, что строки, пропущенные с помощью &lt;code&gt;OFFSET&lt;/code&gt; , будут заблокированы). Точно так же, если в запросе курсора используется предложение блокировки, будут заблокированы только строки, фактически выбранные или пройденные курсором.</target>
        </trans-unit>
        <trans-unit id="ef95b8a60ebd804a0c28a2e00cab45258a43a0d6" translate="yes" xml:space="preserve">
          <source>When a locking clause appears in a sub-&lt;code&gt;SELECT&lt;/code&gt;, the rows locked are those returned to the outer query by the sub-query. This might involve fewer rows than inspection of the sub-query alone would suggest, since conditions from the outer query might be used to optimize execution of the sub-query. For example,</source>
          <target state="translated">Когда предложение блокировки появляется в подзапросе &lt;code&gt;SELECT&lt;/code&gt; , заблокированы строки, возвращаемые внешнему запросу подзапросом. Это может включать меньше строк, чем можно было бы предположить при проверке только подзапроса, поскольку условия из внешнего запроса могут использоваться для оптимизации выполнения подзапроса. Например,</target>
        </trans-unit>
        <trans-unit id="bfc7a3d97debfcf5d558fe06d1809283c70c4abd" translate="yes" xml:space="preserve">
          <source>When a non-owner of an object attempts to &lt;code&gt;GRANT&lt;/code&gt; privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will grant only those privileges for which the user has grant options. The &lt;code&gt;GRANT ALL PRIVILEGES&lt;/code&gt; forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)</source>
          <target state="translated">Когда не-владелец объекта пытается &lt;code&gt;GRANT&lt;/code&gt; привилегии для объекта, команда завершится неудачно, если у пользователя нет никаких привилегий для объекта. Пока доступна какая-то привилегия, команда будет выполняться, но предоставит только те привилегии, для которых у пользователя есть параметры предоставления. В &lt;code&gt;GRANT ALL PRIVILEGES&lt;/code&gt; формы будут выдавать предупреждающее сообщение , если не проводятся никакие варианты грантов, в то время как другие формы будет выдавать предупреждение , если параметры грантов для каких - либо привилегий , специально указанных в команде не проводятся. (В принципе, эти утверждения применимы и к владельцу объекта, но поскольку владелец всегда считается владельцем всех вариантов предоставления, такие случаи никогда не могут возникнуть.)</target>
        </trans-unit>
        <trans-unit id="89d5be09265c0f260930da66e4dbc18e249c5a52" translate="yes" xml:space="preserve">
          <source>When a non-owner of an object attempts to &lt;code&gt;REVOKE&lt;/code&gt; privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will revoke only those privileges for which the user has grant options. The &lt;code&gt;REVOKE ALL PRIVILEGES&lt;/code&gt; forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)</source>
          <target state="translated">Когда не владелец объекта пытается &lt;code&gt;REVOKE&lt;/code&gt; права доступа к объекту, команда завершится с ошибкой, если у пользователя нет никаких привилегий на объект. Пока доступна какая-то привилегия, команда будет выполняться, но отменит только те привилегии, для которых у пользователя есть параметры предоставления. В &lt;code&gt;REVOKE ALL PRIVILEGES&lt;/code&gt; формы выдаст предупреждающее сообщение , если не проводятся никакие варианты грантов, в то время как другие формы будет выдавать предупреждение , если параметры грантов для каких - либо привилегий , специально указанных в команде не проводятся. (В принципе, эти утверждения применимы и к владельцу объекта, но поскольку владелец всегда считается владельцем всех вариантов предоставления, такие случаи никогда не могут возникнуть.)</target>
        </trans-unit>
        <trans-unit id="0029c76ef03f694dc7bb9ed004592d4eb27d7674" translate="yes" xml:space="preserve">
          <source>When a partitioned table is added to a publication, all of its existing and future partitions are implicitly considered to be part of the publication. So, even operations that are performed directly on a partition are also published via publications that its ancestors are part of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81fc5d42be5663314dba2e99345c9e9036540107" translate="yes" xml:space="preserve">
          <source>When a password is specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; or &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;, this parameter determines the algorithm to use to encrypt the password. The default value is &lt;code&gt;md5&lt;/code&gt;, which stores the password as an MD5 hash (&lt;code&gt;on&lt;/code&gt; is also accepted, as alias for &lt;code&gt;md5&lt;/code&gt;). Setting this parameter to &lt;code&gt;scram-sha-256&lt;/code&gt; will encrypt the password with SCRAM-SHA-256.</source>
          <target state="translated">Когда пароль указан в &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; или &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; , этот параметр определяет алгоритм, который будет использоваться для шифрования пароля. Значение по умолчанию - &lt;code&gt;md5&lt;/code&gt; , в котором пароль хранится в виде хэша MD5 ( &lt;code&gt;on&lt;/code&gt; также принимается как псевдоним для &lt;code&gt;md5&lt;/code&gt; ). Установка этого параметра в &lt;code&gt;scram-sha-256&lt;/code&gt; зашифрует пароль с помощью SCRAM-SHA-256.</target>
        </trans-unit>
        <trans-unit id="a045ad36bdf763a5564eafc812cd1f70e538ac02" translate="yes" xml:space="preserve">
          <source>When a query involves multiple window functions, it is possible to write out each one with a separate &lt;code&gt;OVER&lt;/code&gt; clause, but this is duplicative and error-prone if the same windowing behavior is wanted for several functions. Instead, each windowing behavior can be named in a &lt;code&gt;WINDOW&lt;/code&gt; clause and then referenced in &lt;code&gt;OVER&lt;/code&gt;. For example:</source>
          <target state="translated">Когда запрос включает несколько оконных функций, можно записать каждую с отдельным предложением &lt;code&gt;OVER&lt;/code&gt; , но это дублирует и подвержено ошибкам, если одинаковое поведение окна требуется для нескольких функций. Вместо этого каждое поведение окна может быть названо в предложении &lt;code&gt;WINDOW&lt;/code&gt; , а затем на него будет ссылаться в &lt;code&gt;OVER&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="6b051ff28261e8c6e18971fa6cb50736f0add4f7" translate="yes" xml:space="preserve">
          <source>When a query only involves two or three tables, there aren't many join orders to worry about. But the number of possible join orders grows exponentially as the number of tables expands. Beyond ten or so input tables it's no longer practical to do an exhaustive search of all the possibilities, and even for six or seven tables planning might take an annoyingly long time. When there are too many input tables, the PostgreSQL planner will switch from exhaustive search to a &lt;em&gt;genetic&lt;/em&gt; probabilistic search through a limited number of possibilities. (The switch-over threshold is set by the &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; run-time parameter.) The genetic search takes less time, but it won't necessarily find the best possible plan.</source>
          <target state="translated">Когда запрос включает только две или три таблицы, не нужно беспокоиться о многих порядках соединения. Но количество возможных порядков соединения растет экспоненциально по мере увеличения количества таблиц. После десяти или около того таблиц ввода уже нецелесообразно проводить исчерпывающий поиск всех возможностей, и даже планирование шести или семи таблиц может занять досадно много времени. Когда имеется слишком много входных таблиц, планировщик PostgreSQL переключится с исчерпывающего поиска на &lt;em&gt;генетический&lt;/em&gt; вероятностный поиск с использованием ограниченного числа возможностей. (Порог переключения устанавливается параметром времени выполнения &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; .) Генетический поиск занимает меньше времени, но он не обязательно найдет наилучший возможный план.</target>
        </trans-unit>
        <trans-unit id="52a265f5fc62979fde73128f8ace62054feb152e" translate="yes" xml:space="preserve">
          <source>When a schema-qualified operator name is used in the &lt;code&gt;OPERATOR&lt;/code&gt; syntax, as for example in:</source>
          <target state="translated">Когда в синтаксисе &lt;code&gt;OPERATOR&lt;/code&gt; используется имя оператора с указанием схемы , как, например, в:</target>
        </trans-unit>
        <trans-unit id="07d688620d10b715a262026cbd31ef1489999e7d" translate="yes" xml:space="preserve">
          <source>When a sequential scan and sort is used, a temporary sort file is also created, so that the peak temporary space requirement is as much as double the table size, plus the index sizes. This method is often faster than the index scan method, but if the disk space requirement is intolerable, you can disable this choice by temporarily setting &lt;a href=&quot;runtime-config-query#GUC-ENABLE-SORT&quot;&gt;enable_sort&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">Когда используются последовательное сканирование и сортировка, также создается временный файл сортировки, поэтому пиковое временное требование к пространству вдвое превышает размер таблицы плюс размеры индекса. Этот метод часто быстрее , чем сканирования индекс метод, но если требование дискового пространства является недопустимым, вы можете отключить этот выбор, временно установив &lt;a href=&quot;runtime-config-query#GUC-ENABLE-SORT&quot;&gt;enable_sort&lt;/a&gt; для &lt;code&gt;off&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0770f15e6049d266a12140bc7f33a5609b9c35a" translate="yes" xml:space="preserve">
          <source>When a single element is pushed onto either the beginning or end of a one-dimensional array, the result is an array with the same lower bound subscript as the array operand. For example:</source>
          <target state="translated">Когда один элемент нажимается на начало или конец одномерного массива,в результате получается массив с тем же самым нижним индексом,что и операнд массива.Например:</target>
        </trans-unit>
        <trans-unit id="f80cd58c4f6747cdabdfc227aecb194029c6f93d" translate="yes" xml:space="preserve">
          <source>When a standby first attaches to the primary, it will not yet be properly synchronized. This is described as &lt;code&gt;catchup&lt;/code&gt; mode. Once the lag between standby and primary reaches zero for the first time we move to real-time &lt;code&gt;streaming&lt;/code&gt; state. The catch-up duration may be long immediately after the standby has been created. If the standby is shut down, then the catch-up period will increase according to the length of time the standby has been down. The standby is only able to become a synchronous standby once it has reached &lt;code&gt;streaming&lt;/code&gt; state. This state can be viewed using the &lt;code&gt;pg_stat_replication&lt;/code&gt; view.</source>
          <target state="translated">Когда резервный сначала подключается к основному, он еще не будет правильно синхронизирован. Это называется режимом &lt;code&gt;catchup&lt;/code&gt; . Как только задержка между резервным и основным достигает нуля, мы переходим в состояние &lt;code&gt;streaming&lt;/code&gt; в реальном времени . Продолжительность наверстывания может быть большой сразу после создания резервной копии. Если резервный режим отключен, то период наверстывания будет увеличиваться в соответствии с продолжительностью времени, в течение которого резервный был отключен. Резервный режим может стать синхронным резервным только после того, как он достиг состояния &lt;code&gt;streaming&lt;/code&gt; . Это состояние можно просмотреть с помощью представления &lt;code&gt;pg_stat_replication&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad5c61ffccbfb5effcfe0a2c8686ec7385263d29" translate="yes" xml:space="preserve">
          <source>When a subscription is dropped and recreated, the synchronization information is lost. This means that the data has to be resynchronized afterwards.</source>
          <target state="translated">Когда подписка отменяется и воссоздается,информация о синхронизации теряется.Это означает,что после этого данные должны быть ресинхронизированы.</target>
        </trans-unit>
        <trans-unit id="b46a9ad23681ef38bc14d25148f1365c37846a4e" translate="yes" xml:space="preserve">
          <source>When a table has a default partition, defining a new partition changes the partition constraint for the default partition. The default partition can't contain any rows that would need to be moved to the new partition, and will be scanned to verify that none are present. This scan, like the scan of the new partition, can be avoided if an appropriate &lt;code&gt;CHECK&lt;/code&gt; constraint is present. Also like the scan of the new partition, it is always skipped when the default partition is a foreign table.</source>
          <target state="translated">Когда таблица имеет раздел по умолчанию, определение нового раздела изменяет ограничение раздела для раздела по умолчанию. Раздел по умолчанию не может содержать строк, которые необходимо переместить в новый раздел, и будет просканирован, чтобы убедиться, что их нет. Этого сканирования, как и сканирования нового раздела, можно избежать, если присутствует соответствующее ограничение &lt;code&gt;CHECK&lt;/code&gt; . Также как и сканирование нового раздела, оно всегда пропускается, если раздел по умолчанию является сторонней таблицей.</target>
        </trans-unit>
        <trans-unit id="152306185769e157a52b3f97557867eb083f11a7" translate="yes" xml:space="preserve">
          <source>When a table has an existing &lt;code&gt;DEFAULT&lt;/code&gt; partition and a new partition is added to it, the default partition must be scanned to verify that it does not contain any rows which properly belong in the new partition. If the default partition contains a large number of rows, this may be slow. The scan will be skipped if the default partition is a foreign table or if it has a constraint which proves that it cannot contain rows which should be placed in the new partition.</source>
          <target state="translated">Когда в таблице есть существующий раздел &lt;code&gt;DEFAULT&lt;/code&gt; и к нему добавляется новый раздел, необходимо просканировать раздел по умолчанию, чтобы убедиться, что он не содержит строк, которые должным образом принадлежат новому разделу. Если раздел по умолчанию содержит большое количество строк, это может быть медленным. Сканирование будет пропущено, если раздел по умолчанию является сторонней таблицей или если у него есть ограничение, которое доказывает, что он не может содержать строк, которые должны быть помещены в новый раздел.</target>
        </trans-unit>
        <trans-unit id="43b2ea07826933a7c581c975e04300af317cf31d" translate="yes" xml:space="preserve">
          <source>When a table has multiple &lt;code&gt;CHECK&lt;/code&gt; constraints, they will be tested for each row in alphabetical order by name, after checking &lt;code&gt;NOT NULL&lt;/code&gt; constraints. (PostgreSQL versions before 9.5 did not honor any particular firing order for &lt;code&gt;CHECK&lt;/code&gt; constraints.)</source>
          <target state="translated">Если таблица имеет несколько ограничений &lt;code&gt;CHECK&lt;/code&gt; , они будут проверяться для каждой строки в алфавитном порядке по имени после проверки ограничений &lt;code&gt;NOT NULL&lt;/code&gt; . (В версиях PostgreSQL до 9.5 не соблюдается какой-либо конкретный порядок &lt;code&gt;CHECK&lt;/code&gt; ограничений CHECK .)</target>
        </trans-unit>
        <trans-unit id="082c9f9ffee26ce9be34e1d589e0da24d6b1e31a" translate="yes" xml:space="preserve">
          <source>When a table is being clustered, an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock is acquired on it. This prevents any other database operations (both reads and writes) from operating on the table until the &lt;code&gt;CLUSTER&lt;/code&gt; is finished.</source>
          <target state="translated">Когда таблица кластеризуется, на нее &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; блокировка ACCESS EXCLUSIVE . Это предотвращает выполнение любых других операций с базой данных (как чтения, так и записи) над таблицей до завершения &lt;code&gt;CLUSTER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d4eb9118baea2c47a40ccbe4939e2face5ca64c" translate="yes" xml:space="preserve">
          <source>When a table is clustered, PostgreSQL remembers which index it was clustered by. The form &lt;code&gt;CLUSTER table_name&lt;/code&gt; reclusters the table using the same index as before. You can also use the &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;SET WITHOUT CLUSTER&lt;/code&gt; forms of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; to set the index to be used for future cluster operations, or to clear any previous setting.</source>
          <target state="translated">Когда таблица кластеризуется, PostgreSQL запоминает, по какому индексу она была кластеризована. Форма &lt;code&gt;CLUSTER table_name&lt;/code&gt; имя_таблицы выполняет повторную кластеризацию таблицы с использованием того же индекса, что и раньше. Вы также можете использовать формы &lt;code&gt;CLUSTER&lt;/code&gt; или &lt;code&gt;SET WITHOUT CLUSTER&lt;/code&gt; команды &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE,&lt;/a&gt; чтобы установить индекс, который будет использоваться для будущих операций с кластером, или очистить любой предыдущий параметр.</target>
        </trans-unit>
        <trans-unit id="8eb320e131f3533a19b92cb04f708af68aba5d79" translate="yes" xml:space="preserve">
          <source>When a table is clustered, it is physically reordered based on the index information. Clustering is a one-time operation: when the table is subsequently updated, the changes are not clustered. That is, no attempt is made to store new or updated rows according to their index order. (If one wishes, one can periodically recluster by issuing the command again. Also, setting the table's &lt;code&gt;fillfactor&lt;/code&gt; storage parameter to less than 100% can aid in preserving cluster ordering during updates, since updated rows are kept on the same page if enough space is available there.)</source>
          <target state="translated">Когда таблица кластеризуется, она физически переупорядочивается на основе информации индекса. Кластеризация - это разовая операция: при последующем обновлении таблицы изменения не кластеризуются. То есть не предпринимается никаких попыток сохранить новые или обновленные строки в соответствии с порядком их индекса. (При желании можно периодически проводить повторную кластеризацию, повторно вводя команду. Кроме того, установка параметра хранения таблицы &lt;code&gt;fillfactor&lt;/code&gt; на менее 100% может помочь в сохранении порядка кластеров во время обновлений, поскольку обновленные строки сохраняются на той же странице, если достаточно места доступны там.)</target>
        </trans-unit>
        <trans-unit id="49a3d5e22ae2844ff5c06f47ba492689eb79f5ba" translate="yes" xml:space="preserve">
          <source>When a table is created, it contains no data. The first thing to do before a database can be of much use is to insert data. Data is conceptually inserted one row at a time. Of course you can also insert more than one row, but there is no way to insert less than one row. Even if you know only some column values, a complete row must be created.</source>
          <target state="translated">Когда таблица создается,она не содержит данных.Первое,что нужно сделать,прежде чем база данных может принести большую пользу-это вставить данные.Данные концептуально вставляются по одной строке за раз.Конечно,можно вставлять и более одной строки,но вставить меньше одной строки невозможно.Даже если вы знаете только некоторые значения столбцов,необходимо создать полный ряд.</target>
        </trans-unit>
        <trans-unit id="85bad0d57dfc672246f13e6ad8d8a435cc923083" translate="yes" xml:space="preserve">
          <source>When a table or index exceeds 1 GB, it is divided into gigabyte-sized &lt;em&gt;segments&lt;/em&gt;. The first segment's file name is the same as the filenode; subsequent segments are named filenode.1, filenode.2, etc. This arrangement avoids problems on platforms that have file size limitations. (Actually, 1 GB is just the default segment size. The segment size can be adjusted using the configuration option &lt;code&gt;--with-segsize&lt;/code&gt; when building PostgreSQL.) In principle, free space map and visibility map forks could require multiple segments as well, though this is unlikely to happen in practice.</source>
          <target state="translated">Когда таблица или индекс превышает 1 ГБ, они делятся на &lt;em&gt;сегменты&lt;/em&gt; размером в гигабайт . Имя файла первого сегмента такое же, как и у файлового узла; последующие сегменты называются filenode.1, filenode.2 и т. д. Такое расположение позволяет избежать проблем на платформах, которые имеют ограничения на размер файла. (На самом деле 1 ГБ - это просто размер сегмента по умолчанию. Размер сегмента можно настроить с помощью параметра конфигурации &lt;code&gt;--with-segsize&lt;/code&gt; при сборке PostgreSQL.) В принципе, для вилок карты свободного пространства и карты видимости также может потребоваться несколько сегментов, хотя на практике это маловероятно.</target>
        </trans-unit>
        <trans-unit id="10a45cc60012ed72f0453155b208d80983750321" translate="yes" xml:space="preserve">
          <source>When a table reference names a table that is the parent of a table inheritance hierarchy, the table reference produces rows of not only that table but all of its descendant tables, unless the key word &lt;code&gt;ONLY&lt;/code&gt; precedes the table name. However, the reference produces only the columns that appear in the named table &amp;mdash; any columns added in subtables are ignored.</source>
          <target state="translated">Когда ссылка на таблицу называет таблицу, которая является родительской для иерархии наследования таблиц, ссылка на таблицу создает строки не только этой таблицы, но и всех ее дочерних таблиц, если только ключевое слово &lt;code&gt;ONLY&lt;/code&gt; предшествует имени таблицы. Однако ссылка создает только столбцы, которые появляются в названной таблице - любые столбцы, добавленные в подтаблицы, игнорируются.</target>
        </trans-unit>
        <trans-unit id="238107619ce9861ed394df0ebec618f90c2d4272" translate="yes" xml:space="preserve">
          <source>When a typed table is created, then the data types of the columns are determined by the underlying composite type and are not specified by the &lt;code&gt;CREATE TABLE&lt;/code&gt; command. But the &lt;code&gt;CREATE TABLE&lt;/code&gt; command can add defaults and constraints to the table and can specify storage parameters.</source>
          <target state="translated">При создании типизированной таблицы типы данных столбцов определяются лежащим в основе составным типом и не указываются командой &lt;code&gt;CREATE TABLE&lt;/code&gt; . Но команда &lt;code&gt;CREATE TABLE&lt;/code&gt; может добавить в таблицу значения по умолчанию и ограничения, а также указать параметры хранения.</target>
        </trans-unit>
        <trans-unit id="40ca1a4315d7efd053d1772d2a1868caf568479c" translate="yes" xml:space="preserve">
          <source>When a value is to be used as an SQL literal or identifier, it is safest to arrange for it to be quoted. To quote the value of a variable as an SQL literal, write a colon followed by the variable name in single quotes. To quote the value as an SQL identifier, write a colon followed by the variable name in double quotes. These constructs deal correctly with quotes and other special characters embedded within the variable value. The previous example would be more safely written this way:</source>
          <target state="translated">Когда значение должно использоваться в качестве SQL-литерала или идентификатора,безопаснее всего организовать его цитирование.Чтобы заключить значение переменной в кавычки как SQL-литерал,напишите двоеточие с последующим именем переменной в одинарных кавычках.Чтобы процитировать значение как SQL-идентификатор,напишите двоеточие с последующим именем переменной в двойных кавычках.Эти конструкции корректно работают с кавычками и другими специальными символами,встроенными в значение переменной.Предыдущий пример был бы безопаснее написать таким образом:</target>
        </trans-unit>
        <trans-unit id="55eaed5a13493b2841925c6347f0f009f1c69d52" translate="yes" xml:space="preserve">
          <source>When a view is locked, all relations appearing in the view definition query are also locked recursively with the same lock mode.</source>
          <target state="translated">Когда представление заблокировано,все отношения,появляющиеся в запросе на определение представления,также блокируются рекурсивно с тем же режимом блокировки.</target>
        </trans-unit>
        <trans-unit id="0731d9c33a2135d592b4234920022cbe73ac4232" translate="yes" xml:space="preserve">
          <source>When acquiring locks automatically for commands that reference tables, PostgreSQL always uses the least restrictive lock mode possible. &lt;code&gt;LOCK TABLE&lt;/code&gt; provides for cases when you might need more restrictive locking. For example, suppose an application runs a transaction at the &lt;code&gt;READ COMMITTED&lt;/code&gt; isolation level and needs to ensure that data in a table remains stable for the duration of the transaction. To achieve this you could obtain &lt;code&gt;SHARE&lt;/code&gt; lock mode over the table before querying. This will prevent concurrent data changes and ensure subsequent reads of the table see a stable view of committed data, because &lt;code&gt;SHARE&lt;/code&gt; lock mode conflicts with the &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; lock acquired by writers, and your &lt;code&gt;LOCK TABLE name IN SHARE MODE&lt;/code&gt; statement will wait until any concurrent holders of &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode locks commit or roll back. Thus, once you obtain the lock, there are no uncommitted writes outstanding; furthermore none can begin until you release the lock.</source>
          <target state="translated">При автоматическом установлении блокировок для команд, которые ссылаются на таблицы, PostgreSQL всегда использует режим блокировки с наименьшими ограничениями. &lt;code&gt;LOCK TABLE&lt;/code&gt; предусматривает случаи, когда вам может потребоваться более строгая блокировка. Например, предположим, что приложение выполняет транзакцию на уровне изоляции &lt;code&gt;READ COMMITTED&lt;/code&gt; и должно гарантировать, что данные в таблице остаются стабильными в течение транзакции. Для этого вы можете получить режим блокировки &lt;code&gt;SHARE&lt;/code&gt; над таблицей перед запросом. Это предотвратит одновременные изменения данных и обеспечит стабильное представление зафиксированных данных при последующих чтениях таблицы, поскольку режим блокировки &lt;code&gt;SHARE&lt;/code&gt; конфликтует с блокировкой &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; , полученной писателями, и ваш &lt;code&gt;LOCK TABLE name IN SHARE MODE&lt;/code&gt; будет ждать, пока любые одновременные держатели режима &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; заблокируют фиксацию или откат. Таким образом, как только вы получите блокировку, незавершенных операций записи не будет; более того, никто не может начаться, пока вы не снимете блокировку.</target>
        </trans-unit>
        <trans-unit id="b867fce21cdcff5c6925a3d0a1d7eb430184e42c" translate="yes" xml:space="preserve">
          <source>When adding an &lt;code&gt;interval&lt;/code&gt; value to (or subtracting an &lt;code&gt;interval&lt;/code&gt; value from) a &lt;code&gt;timestamp with time zone&lt;/code&gt; value, the days component advances or decrements the date of the &lt;code&gt;timestamp with time zone&lt;/code&gt; by the indicated number of days, keeping the time of day the same. Across daylight saving time changes (when the session time zone is set to a time zone that recognizes DST), this means &lt;code&gt;interval '1 day'&lt;/code&gt; does not necessarily equal &lt;code&gt;interval '24 hours'&lt;/code&gt;. For example, with the session time zone set to &lt;code&gt;America/Denver&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a870f6af21f8dafd4cc733a991bd99fd9d13ef" translate="yes" xml:space="preserve">
          <source>When adding an &lt;code&gt;interval&lt;/code&gt; value to (or subtracting an &lt;code&gt;interval&lt;/code&gt; value from) a &lt;code&gt;timestamp with time zone&lt;/code&gt; value, the days component advances or decrements the date of the &lt;code&gt;timestamp with time zone&lt;/code&gt; by the indicated number of days. Across daylight saving time changes (when the session time zone is set to a time zone that recognizes DST), this means &lt;code&gt;interval '1 day'&lt;/code&gt; does not necessarily equal &lt;code&gt;interval '24 hours'&lt;/code&gt;. For example, with the session time zone set to &lt;code&gt;CST7CDT&lt;/code&gt;, &lt;code&gt;timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'&lt;/code&gt; will produce &lt;code&gt;timestamp with time zone '2005-04-03 12:00-06'&lt;/code&gt;, while adding &lt;code&gt;interval '24 hours'&lt;/code&gt; to the same initial &lt;code&gt;timestamp with time zone&lt;/code&gt; produces &lt;code&gt;timestamp with time zone '2005-04-03 13:00-06'&lt;/code&gt;, as there is a change in daylight saving time at &lt;code&gt;2005-04-03 02:00&lt;/code&gt; in time zone &lt;code&gt;CST7CDT&lt;/code&gt;.</source>
          <target state="translated">При добавлении значения &lt;code&gt;interval&lt;/code&gt; (или вычитании значения &lt;code&gt;interval&lt;/code&gt; из) &lt;code&gt;timestamp with time zone&lt;/code&gt; значением часового пояса компонент дней увеличивает или уменьшает дату &lt;code&gt;timestamp with time zone&lt;/code&gt; на указанное количество дней. При переходе на летнее время (когда часовой пояс сеанса установлен на часовой пояс, который распознает летнее время), это означает, что &lt;code&gt;interval '1 day'&lt;/code&gt; не обязательно равен &lt;code&gt;interval '24 hours'&lt;/code&gt; . Например, с часовым поясом сеанса, установленным на &lt;code&gt;CST7CDT&lt;/code&gt; , &lt;code&gt;timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'&lt;/code&gt; будет создавать &lt;code&gt;timestamp with time zone '2005-04-03 12:00-06'&lt;/code&gt; ,при добавлении &lt;code&gt;interval '24 hours'&lt;/code&gt; к той же начальной &lt;code&gt;timestamp with time zone&lt;/code&gt; создает &lt;code&gt;timestamp with time zone '2005-04-03 13:00-06'&lt;/code&gt; , поскольку есть изменение летнего времени в &lt;code&gt;2005-04-03 02:00&lt;/code&gt; в часовой пояс &lt;code&gt;CST7CDT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1434d3ccf06b603b0c31a66fe4b553e885790f9" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;Append&lt;/code&gt; node is used in a parallel plan, each process will execute the child plans in the order in which they appear, so that all participating processes cooperate to execute the first child plan until it is complete and then move to the second plan at around the same time. When a &lt;code&gt;Parallel Append&lt;/code&gt; is used instead, the executor will instead spread out the participating processes as evenly as possible across its child plans, so that multiple child plans are executed simultaneously. This avoids contention, and also avoids paying the startup cost of a child plan in those processes that never execute it.</source>
          <target state="translated">Когда узел &lt;code&gt;Append&lt;/code&gt; используется в параллельном плане, каждый процесс будет выполнять дочерние планы в том порядке, в котором они появляются, так что все участвующие процессы взаимодействуют для выполнения первого дочернего плана, пока он не будет завершен, а затем перейдут ко второму плану в примерно в то же время. Когда вместо этого используется &lt;code&gt;Parallel Append&lt;/code&gt; , исполнитель будет распределять участвующие процессы как можно более равномерно по своим дочерним планам, чтобы несколько дочерних планов выполнялись одновременно. Это позволяет избежать разногласий, а также позволяет избежать оплаты начальных затрат дочернего плана в тех процессах, которые никогда его не выполняют.</target>
        </trans-unit>
        <trans-unit id="5e4864e701f86b03083b18f6c388ffa7cee629fe" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;INSERT&lt;/code&gt; command has an auxiliary &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause, if the &lt;code&gt;UPDATE&lt;/code&gt; path is taken, the row to be updated is first checked against the &lt;code&gt;USING&lt;/code&gt; expressions of any &lt;code&gt;UPDATE&lt;/code&gt; policies, and then the new updated row is checked against the &lt;code&gt;WITH CHECK&lt;/code&gt; expressions. Note, however, that unlike a standalone &lt;code&gt;UPDATE&lt;/code&gt; command, if the existing row does not pass the &lt;code&gt;USING&lt;/code&gt; expressions, an error will be thrown (the &lt;code&gt;UPDATE&lt;/code&gt; path will &lt;em&gt;never&lt;/em&gt; be silently avoided).</source>
          <target state="translated">Когда команда &lt;code&gt;INSERT&lt;/code&gt; имеет вспомогательное предложение &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; , если &lt;code&gt;UPDATE&lt;/code&gt; путь UPDATE , обновляемая строка сначала проверяется на соответствие выражениям &lt;code&gt;USING&lt;/code&gt; любых политик &lt;code&gt;UPDATE&lt;/code&gt; , а затем новая обновленная строка проверяется на соответствие выражениям &lt;code&gt;WITH CHECK&lt;/code&gt; . . Обратите внимание, однако, что в отличие от автономной команды &lt;code&gt;UPDATE&lt;/code&gt; , если существующая строка не передает выражения &lt;code&gt;USING&lt;/code&gt; , будет выдана ошибка ( путь &lt;code&gt;UPDATE&lt;/code&gt; &lt;em&gt;никогда не&lt;/em&gt; удастся незаметно избежать).</target>
        </trans-unit>
        <trans-unit id="f5ddde61a4b6e8647a9abfe81db27fb6ec9b4388" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;N&lt;/code&gt;-dimensional array is pushed onto the beginning or end of an &lt;code&gt;N+1&lt;/code&gt;-dimensional array, the result is analogous to the element-array case above. Each &lt;code&gt;N&lt;/code&gt;-dimensional sub-array is essentially an element of the &lt;code&gt;N+1&lt;/code&gt;-dimensional array's outer dimension. For example:</source>
          <target state="translated">Когда &lt;code&gt;N&lt;/code&gt; - мерный массив помещается в начало или конец &lt;code&gt;N+1&lt;/code&gt; - мерного массива, результат аналогичен случаю с массивом элементов выше. Каждый &lt;code&gt;N&lt;/code&gt; - мерный подмассив является по существу элементом внешнего измерения &lt;code&gt;N+1&lt;/code&gt; - мерного массива. Например:</target>
        </trans-unit>
        <trans-unit id="31260cf4fd42afa924c8ee13fbb974bf90d187b0" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; command affects an inheritance hierarchy, the output might look like this:</source>
          <target state="translated">Когда команда &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; влияет на иерархию наследования, вывод может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="5c47d72e8415ae2214a0b4c8ffca096b8ee4f7c5" translate="yes" xml:space="preserve">
          <source>When an aggregate expression appears in a subquery (see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;Section 4.2.11&lt;/a&gt; and &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;), the aggregate is normally evaluated over the rows of the subquery. But an exception occurs if the aggregate's arguments (and &lt;code&gt;filter_clause&lt;/code&gt; if any) contain only outer-level variables: the aggregate then belongs to the nearest such outer level, and is evaluated over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery it appears in, and acts as a constant over any one evaluation of that subquery. The restriction about appearing only in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause applies with respect to the query level that the aggregate belongs to.</source>
          <target state="translated">Когда агрегатное выражение появляется в подзапросе (см. &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;Раздел 4.2.11&lt;/a&gt; и &lt;a href=&quot;functions-subquery&quot;&gt;Раздел 9.22&lt;/a&gt; ), агрегат обычно оценивается по строкам подзапроса. Но исключение возникает, если аргументы агрегата (и &lt;code&gt;filter_clause&lt;/code&gt; , если есть) содержат только переменные внешнего уровня: тогда агрегат принадлежит к ближайшему такому внешнему уровню и оценивается по строкам этого запроса. Агрегатное выражение в целом является тогда внешней ссылкой для подзапроса, в котором оно появляется, и действует как константа для любой оценки этого подзапроса. Ограничение на отображение только в списке результатов или предложении &lt;code&gt;HAVING&lt;/code&gt; применяется к уровню запроса, к которому принадлежит агрегат.</target>
        </trans-unit>
        <trans-unit id="3611155577957d7d62aaa216921a5999dd2f0cc2" translate="yes" xml:space="preserve">
          <source>When an aggregate expression appears in a subquery (see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;Section 4.2.11&lt;/a&gt; and &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.23&lt;/a&gt;), the aggregate is normally evaluated over the rows of the subquery. But an exception occurs if the aggregate's arguments (and &lt;code&gt;filter_clause&lt;/code&gt; if any) contain only outer-level variables: the aggregate then belongs to the nearest such outer level, and is evaluated over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery it appears in, and acts as a constant over any one evaluation of that subquery. The restriction about appearing only in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause applies with respect to the query level that the aggregate belongs to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d2b87c80e1af3054e4c9d4d3c71d80a5607eb6" translate="yes" xml:space="preserve">
          <source>When an aggregate function is used as a window function, it aggregates over the rows within the current row's window frame. An aggregate used with &lt;code&gt;ORDER BY&lt;/code&gt; and the default window frame definition produces a &amp;ldquo;running sum&amp;rdquo; type of behavior, which may or may not be what's wanted. To obtain aggregation over the whole partition, omit &lt;code&gt;ORDER BY&lt;/code&gt; or use &lt;code&gt;ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING&lt;/code&gt;. Other frame specifications can be used to obtain other effects.</source>
          <target state="translated">Когда агрегатная функция используется как оконная функция, она агрегирует по строкам внутри оконного фрейма текущей строки. Агрегат, используемый с &lt;code&gt;ORDER BY&lt;/code&gt; и определением оконной рамки по умолчанию, производит поведение типа &amp;laquo;бегущая сумма&amp;raquo;, которое может быть или не соответствовать желаемому. Чтобы получить агрегирование по всему разделу, опустите &lt;code&gt;ORDER BY&lt;/code&gt; или используйте &lt;code&gt;ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING&lt;/code&gt; . Другие спецификации кадра могут использоваться для получения других эффектов.</target>
        </trans-unit>
        <trans-unit id="64b60eb6cf1570c88f1c1631b3c6e4c5824a2f8b" translate="yes" xml:space="preserve">
          <source>When an alias is applied to the output of a &lt;code&gt;JOIN&lt;/code&gt; clause, the alias hides the original name(s) within the &lt;code&gt;JOIN&lt;/code&gt;. For example:</source>
          <target state="translated">Когда псевдоним применяется к выходным данным предложения &lt;code&gt;JOIN&lt;/code&gt; , псевдоним скрывает исходное имя (имена) внутри &lt;code&gt;JOIN&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="0151521ad4c1bed3dd275586a7870760908f04a0" translate="yes" xml:space="preserve">
          <source>When an application receives this error message, it should abort the current transaction and retry the whole transaction from the beginning. The second time through, the transaction will see the previously-committed change as part of its initial view of the database, so there is no logical conflict in using the new version of the row as the starting point for the new transaction's update.</source>
          <target state="translated">Когда приложение получает это сообщение об ошибке,оно должно прервать текущую транзакцию и повторить всю транзакцию с самого начала.Во второй раз транзакция увидит ранее внесенное изменение в своем первоначальном представлении базы данных,поэтому нет логического конфликта при использовании новой версии строки в качестве отправной точки для обновления новой транзакции.</target>
        </trans-unit>
        <trans-unit id="4ee9b3bf4967c5d2fb0d054d753f418145337cf0" translate="yes" xml:space="preserve">
          <source>When an enum type is created, its members are assigned sort-order positions 1..&lt;code&gt;n&lt;/code&gt;. But members added later might be given negative or fractional values of &lt;code&gt;enumsortorder&lt;/code&gt;. The only requirement on these values is that they be correctly ordered and unique within each enum type.</source>
          <target state="translated">Когда создается перечисляемый тип, его членам назначаются позиции порядка сортировки &lt;code&gt;n&lt;/code&gt; . Но членам, добавленным позже, могут быть присвоены отрицательные или дробные значения &lt;code&gt;enumsortorder&lt;/code&gt; . Единственное требование к этим значениям - они должны быть правильно упорядочены и уникальны в пределах каждого типа перечисления.</target>
        </trans-unit>
        <trans-unit id="0950043f7233c157a718d379ee2b34585d4ee731" translate="yes" xml:space="preserve">
          <source>When an index is declared unique, multiple table rows with equal indexed values are not allowed. Null values are not considered equal. A multicolumn unique index will only reject cases where all indexed columns are equal in multiple rows.</source>
          <target state="translated">Когда индекс объявлен уникальным,не допускается использование нескольких строк таблицы с одинаковыми индексированными значениями.Нулевые значения не считаются равными.Уникальный многостолбцовый индекс отвергает только те случаи,когда все проиндексированные столбцы одинаковы в нескольких строках.</target>
        </trans-unit>
        <trans-unit id="4aa9424b6df0026312433f3f9260dd9161451961" translate="yes" xml:space="preserve">
          <source>When an index page split is necessary, this function decides which entries on the page are to stay on the old page, and which are to move to the new page.</source>
          <target state="translated">Когда необходимо разделить индексную страницу,эта функция решает,какие записи на странице должны остаться на старой,а какие перейти на новую страницу.</target>
        </trans-unit>
        <trans-unit id="d0d21498c252827ceaa7947111042a06bc38a5a5" translate="yes" xml:space="preserve">
          <source>When an index scan is used, a temporary copy of the table is created that contains the table data in the index order. Temporary copies of each index on the table are created as well. Therefore, you need free space on disk at least equal to the sum of the table size and the index sizes.</source>
          <target state="translated">При использовании индексного сканирования создается временная копия таблицы,содержащая данные таблицы в индексном порядке.Также создаются временные копии каждого индекса таблицы.Поэтому на диске необходимо свободное место,как минимум равное сумме размеров таблицы и индекса.</target>
        </trans-unit>
        <trans-unit id="dad624a33f1e64269d27c153de83dc5212addec4" translate="yes" xml:space="preserve">
          <source>When an object is created, it is assigned an owner. The owner is normally the role that executed the creation statement. For most kinds of objects, the initial state is that only the owner (or a superuser) can do anything with the object. To allow other roles to use it, &lt;em&gt;privileges&lt;/em&gt; must be granted.</source>
          <target state="translated">Когда объект создается, ему назначается владелец. Владелец обычно - это роль, выполнившая оператор создания. Для большинства типов объектов начальным состоянием является то, что только владелец (или суперпользователь) может что-либо делать с объектом. Чтобы позволить другим ролям использовать его, необходимо предоставить &lt;em&gt;привилегии&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="016db50c093e11f2c3975978fc13dbb74ccca023" translate="yes" xml:space="preserve">
          <source>When an operator or function of the underlying type is applied to a domain value, the domain is automatically down-cast to the underlying type. Thus, for example, the result of &lt;code&gt;mytable.id - 1&lt;/code&gt; is considered to be of type &lt;code&gt;integer&lt;/code&gt; not &lt;code&gt;posint&lt;/code&gt;. We could write &lt;code&gt;(mytable.id - 1)::posint&lt;/code&gt; to cast the result back to &lt;code&gt;posint&lt;/code&gt;, causing the domain's constraints to be rechecked. In this case, that would result in an error if the expression had been applied to an &lt;code&gt;id&lt;/code&gt; value of 1. Assigning a value of the underlying type to a field or variable of the domain type is allowed without writing an explicit cast, but the domain's constraints will be checked.</source>
          <target state="translated">Когда к значению домена применяется оператор или функция базового типа, домен автоматически понижается до базового типа. Таким образом, например, результат &lt;code&gt;mytable.id - 1&lt;/code&gt; считается &lt;code&gt;integer&lt;/code&gt; не &lt;code&gt;posint&lt;/code&gt; . Мы могли бы написать &lt;code&gt;(mytable.id - 1)::posint&lt;/code&gt; чтобы вернуть результат обратно в &lt;code&gt;posint&lt;/code&gt; , что приведет к повторной проверке ограничений домена. В этом случае это привело бы к ошибке, если бы выражение было применено к значению &lt;code&gt;id&lt;/code&gt; , равному 1. Присвоение значения базового типа полю или переменной типа домена разрешено без написания явного приведения, но значение домена ограничения будут проверены.</target>
        </trans-unit>
        <trans-unit id="9d220c80b589197cba0d859444da322b0880222c" translate="yes" xml:space="preserve">
          <source>When archiving WAL data, we need to capture the contents of each segment file once it is filled, and save that data somewhere before the segment file is recycled for reuse. Depending on the application and the available hardware, there could be many different ways of &amp;ldquo;saving the data somewhere&amp;rdquo;: we could copy the segment files to an NFS-mounted directory on another machine, write them onto a tape drive (ensuring that you have a way of identifying the original name of each file), or batch them together and burn them onto CDs, or something else entirely. To provide the database administrator with flexibility, PostgreSQL tries not to make any assumptions about how the archiving will be done. Instead, PostgreSQL lets the administrator specify a shell command to be executed to copy a completed segment file to wherever it needs to go. The command could be as simple as a &lt;code&gt;cp&lt;/code&gt;, or it could invoke a complex shell script &amp;mdash; it's all up to you.</source>
          <target state="translated">При архивировании данных WAL нам необходимо захватить содержимое каждого файла сегмента после его заполнения и сохранить эти данные где-нибудь до того, как файл сегмента будет переработан для повторного использования. В зависимости от приложения и доступного оборудования может быть много разных способов &amp;laquo;где-то сохранить данные&amp;raquo;: мы можем скопировать файлы сегментов в каталог, смонтированный по NFS на другом компьютере, записать их на ленточный накопитель (убедившись, что у вас есть способ определения исходного имени каждого файла), или объединить их вместе и записать на компакт-диски, или что-то еще. Чтобы предоставить администратору базы данных гибкость, PostgreSQL старается не делать никаких предположений о том, как будет выполняться архивирование. Вместо этого PostgreSQL позволяет администратору указать команду оболочки, которая будет выполняться для копирования завершенного файла сегмента туда, куда ему нужно.Команда может быть такой же простой, как &lt;code&gt;cp&lt;/code&gt; , или он может вызвать сложный сценарий оболочки - все зависит от вас.</target>
        </trans-unit>
        <trans-unit id="c3d93c6ecb33c6eb94db27d2fba2d265ff994790" translate="yes" xml:space="preserve">
          <source>When autosummarization is enabled, each time a page range is filled a request is sent to autovacuum for it to execute a targeted summarization for that range, to be fulfilled at the end of the next worker run on the same database. If the request queue is full, the request is not recorded and a message is sent to the server log:</source>
          <target state="translated">При включенной автосуммаризации каждый раз при заполнении диапазона страниц в автовакуум посылается запрос на выполнение целевого суммирования для этого диапазона,которое должно быть выполнено в конце следующего запуска работника по той же самой базе данных.Если очередь запросов заполнена,то запрос не записывается и в лог сервера отправляется сообщение:</target>
        </trans-unit>
        <trans-unit id="f660851bc52c800a20554ffeb6a7df92726f03b4" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-b&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are given, the behavior is to output large objects, when data is being dumped, see the &lt;code&gt;-b&lt;/code&gt; documentation.</source>
          <target state="translated">Когда заданы и &lt;code&gt;-b&lt;/code&gt; , и &lt;code&gt;-B&lt;/code&gt; , поведение заключается в выводе больших объектов, когда данные выгружаются, см. Документацию &lt;code&gt;-b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad45f5349fac03bd7966e305b187db06383f5ed7" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-N&lt;/code&gt; are given for the same schema name, the &lt;code&gt;-N&lt;/code&gt; switch wins and the schema is excluded.</source>
          <target state="translated">Когда и &lt;code&gt;-n&lt;/code&gt; , и &lt;code&gt;-N&lt;/code&gt; указаны для одного и того же имени схемы, используется переключатель &lt;code&gt;-N&lt;/code&gt; и схема исключается.</target>
        </trans-unit>
        <trans-unit id="ede3b8af7caafd954943fe5f04f3a1cc429ba018" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-N&lt;/code&gt; are given, the behavior is to dump just the schemas that match at least one &lt;code&gt;-n&lt;/code&gt; switch but no &lt;code&gt;-N&lt;/code&gt; switches. If &lt;code&gt;-N&lt;/code&gt; appears without &lt;code&gt;-n&lt;/code&gt;, then schemas matching &lt;code&gt;-N&lt;/code&gt; are excluded from what is otherwise a normal dump.</source>
          <target state="translated">Когда заданы оба параметра &lt;code&gt;-n&lt;/code&gt; и &lt;code&gt;-N&lt;/code&gt; , происходит сброс только тех схем, которые соответствуют хотя бы одному переключателю &lt;code&gt;-n&lt;/code&gt; , но не соответствуют переключателям &lt;code&gt;-N&lt;/code&gt; . Если &lt;code&gt;-N&lt;/code&gt; отображается без &lt;code&gt;-n&lt;/code&gt; , то схемы, соответствующие &lt;code&gt;-N&lt;/code&gt; , исключаются из обычного дампа.</target>
        </trans-unit>
        <trans-unit id="031547c5dfb59556734ca49134f210c68e4c5520" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-t&lt;/code&gt; and &lt;code&gt;-T&lt;/code&gt; are given, the behavior is to dump just the tables that match at least one &lt;code&gt;-t&lt;/code&gt; switch but no &lt;code&gt;-T&lt;/code&gt; switches. If &lt;code&gt;-T&lt;/code&gt; appears without &lt;code&gt;-t&lt;/code&gt;, then tables matching &lt;code&gt;-T&lt;/code&gt; are excluded from what is otherwise a normal dump.</source>
          <target state="translated">Когда заданы оба параметра &lt;code&gt;-t&lt;/code&gt; и &lt;code&gt;-T&lt;/code&gt; , происходит сброс только тех таблиц, которые соответствуют хотя бы одному переключателю &lt;code&gt;-t&lt;/code&gt; , но не соответствуют переключателям &lt;code&gt;-T&lt;/code&gt; . Если &lt;code&gt;-T&lt;/code&gt; отображается без &lt;code&gt;-t&lt;/code&gt; , то таблицы, соответствующие &lt;code&gt;-T&lt;/code&gt; , исключаются из обычного дампа.</target>
        </trans-unit>
        <trans-unit id="6e63ae1dfc17974e0be483ba0ff638bbea32a3b3" translate="yes" xml:space="preserve">
          <source>When casting from &lt;code&gt;EAN13&lt;/code&gt; to another type, there is a run-time check that the value is within the domain of the other type, and an error is thrown if not. The other casts are simply relabelings that will always succeed.</source>
          <target state="translated">При &lt;code&gt;EAN13&lt;/code&gt; из EAN13 в другой тип во время выполнения выполняется проверка того, что значение находится в пределах домена другого типа, и в противном случае выдается ошибка. Остальные приведения - это просто изменение меток, которое всегда будет успешным.</target>
        </trans-unit>
        <trans-unit id="9b112e4a8b6a5ae3071dcef7339526c0bc3d3e45" translate="yes" xml:space="preserve">
          <source>When changing this value, consider also adjusting &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt;, and &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt;.</source>
          <target state="translated">При изменении этого значения рассмотрите также возможность настройки &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt; , &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_main maintenance_workers&lt;/a&gt; и &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db437265a89a8152322953823332b5732e1c0d00" translate="yes" xml:space="preserve">
          <source>When choosing OIDs for a patch that is not expected to be committed immediately, best practice is to use a group of more-or-less consecutive OIDs starting with some random choice in the range 8000&amp;mdash;9999. This minimizes the risk of OID collisions with other patches being developed concurrently. To keep the 8000&amp;mdash;9999 range free for development purposes, after a patch has been committed to the master git repository its OIDs should be renumbered into available space below that range. Typically, this will be done near the end of each development cycle, moving all OIDs consumed by patches committed in that cycle at the same time. The script &lt;code&gt;renumber_oids.pl&lt;/code&gt; can be used for this purpose. If an uncommitted patch is found to have OID conflicts with some recently-committed patch, &lt;code&gt;renumber_oids.pl&lt;/code&gt; may also be useful for recovering from that situation.</source>
          <target state="translated">При выборе OID для патча, который не ожидается, будет зафиксирован немедленно, рекомендуется использовать группу более или менее последовательных OID, начиная с некоторого случайного выбора в диапазоне 8000&amp;ndash;9999. Это сводит к минимуму риск конфликтов OID с другими исправлениями, разрабатываемыми одновременно. Чтобы оставить диапазон 8000&amp;ndash;9999 свободным для целей разработки, после фиксации патча в главном репозитории git его идентификаторы OID должны быть перенумерованы в доступное пространство ниже этого диапазона. Обычно это делается ближе к концу каждого цикла разработки, одновременно перемещая все OID, использованные исправлениями, зафиксированными в этом цикле. Для этого можно использовать скрипт &lt;code&gt;renumber_oids.pl&lt;/code&gt; . Если обнаруживается, что незафиксированный патч имеет конфликт OID с некоторым недавно зафиксированным патчем, &lt;code&gt;renumber_oids.pl&lt;/code&gt; также может быть полезно для выхода из этой ситуации.</target>
        </trans-unit>
        <trans-unit id="9881b7b2a51c119b916b26c12b2f50a595bc868b" translate="yes" xml:space="preserve">
          <source>When compiled with OpenSSL, there will be more algorithms available. Also public-key encryption functions will be faster as OpenSSL has more optimized BIGNUM functions.</source>
          <target state="translated">При компиляции с OpenSSL будет доступно больше алгоритмов.Также функции шифрования с открытым ключом будут быстрее,так как OpenSSL имеет более оптимизированные функции BIGNUM.</target>
        </trans-unit>
        <trans-unit id="5f2a4f35ae5e876b04f4e8702b5ef942899c0855" translate="yes" xml:space="preserve">
          <source>When compiled with zlib, PGP encryption functions are able to compress data before encrypting.</source>
          <target state="translated">При компиляции с zlib функции шифрования PGP способны сжимать данные перед шифрованием.</target>
        </trans-unit>
        <trans-unit id="4526356cc9d2b5524d1c0613a2cac8e5545975fc" translate="yes" xml:space="preserve">
          <source>When compiling the preprocessed C code files, the compiler needs to be able to find the ECPG header files in the PostgreSQL include directory. Therefore, you might have to use the &lt;code&gt;-I&lt;/code&gt; option when invoking the compiler (e.g., &lt;code&gt;-I/usr/local/pgsql/include&lt;/code&gt;).</source>
          <target state="translated">При компиляции файлов предварительно обработанного кода C компилятор должен иметь возможность находить файлы заголовков ECPG в подключаемом каталоге PostgreSQL. Поэтому вам, возможно, придется использовать параметр &lt;code&gt;-I&lt;/code&gt; при вызове компилятора (например, &lt;code&gt;-I/usr/local/pgsql/include&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f6cfdda77ce1539f64bc346b96c3160b7466725a" translate="yes" xml:space="preserve">
          <source>When computing the selectivity for a query involving functionally dependent columns, the planner adjusts the per-condition selectivity estimates using the dependency coefficients so as not to produce an underestimate.</source>
          <target state="translated">При расчете селективности для запроса,включающего функционально зависимые столбцы,планировщик корректирует оценки селективности по каждому условию,используя коэффициенты зависимостей,чтобы не получить заниженной оценки.</target>
        </trans-unit>
        <trans-unit id="29ea042e28fa2362fa9c26ca7e49e9bd0ec5e906" translate="yes" xml:space="preserve">
          <source>When connecting to the database make sure you have a ticket for a principal matching the requested database user name. For example, for database user name &lt;code&gt;fred&lt;/code&gt;, principal &lt;code&gt;fred@EXAMPLE.COM&lt;/code&gt; would be able to connect. To also allow principal &lt;code&gt;fred/users.example.com@EXAMPLE.COM&lt;/code&gt;, use a user name map, as described in &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt;.</source>
          <target state="translated">При подключении к базе данных убедитесь, что у вас есть билет для участника, соответствующий запрошенному имени пользователя базы данных. Например, для имени пользователя базы данных &lt;code&gt;fred&lt;/code&gt; , принципал &lt;code&gt;fred@EXAMPLE.COM&lt;/code&gt; сможет подключиться. Чтобы также разрешить принципалу &lt;code&gt;fred/users.example.com@EXAMPLE.COM&lt;/code&gt; , используйте карту имен пользователей, как описано в &lt;a href=&quot;auth-username-maps&quot;&gt;Разделе 20.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fb2d529ca9e4c06995d0fca116b867907b7f0d6" translate="yes" xml:space="preserve">
          <source>When connecting to the database server, a client must specify in its connection request the name of the database it wants to connect to. It is not possible to access more than one database per connection. However, an application is not restricted in the number of connections it opens to the same or other databases. Databases are physically separated and access control is managed at the connection level. If one PostgreSQL server instance is to house projects or users that should be separate and for the most part unaware of each other, it is therefore recommended to put them into separate databases. If the projects or users are interrelated and should be able to use each other's resources, they should be put in the same database but possibly into separate schemas. Schemas are a purely logical structure and who can access what is managed by the privilege system. More information about managing schemas is in &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;.</source>
          <target state="translated">При подключении к серверу базы данных клиент должен указать в своем запросе на соединение имя базы данных, к которой он хочет подключиться. Невозможно получить доступ к более чем одной базе данных за одно соединение. Однако приложение не ограничено числом открываемых им соединений с той же или другими базами данных. Базы данных физически разделены, и управление доступом осуществляется на уровне подключения. Если один экземпляр сервера PostgreSQL предназначен для размещения проектов или пользователей, которые должны быть отдельными и по большей части не осведомлены друг о друге, рекомендуется поместить их в отдельные базы данных. Если проекты или пользователи взаимосвязаны и должны иметь возможность использовать ресурсы друг друга, их следует поместить в одну базу данных, но, возможно, в отдельные схемы.Схемы - это чисто логическая структура, и кто может получить доступ к тому, что управляется системой привилегий. Дополнительная информация об управлении схемами находится в&lt;a href=&quot;ddl-schemas&quot;&gt;Раздел 5.9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8b02ea043cf0c79a30fc9e7d7d2f7eb7a91ce38" translate="yes" xml:space="preserve">
          <source>When connecting to the database server, a client must specify the database name in its connection request. It is not possible to access more than one database per connection. However, clients can open multiple connections to the same database, or different databases. Database-level security has two components: access control (see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt;), managed at the connection level, and authorization control (see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;), managed via the grant system. Foreign data wrappers (see &lt;a href=&quot;postgres-fdw&quot;&gt;postgres_fdw&lt;/a&gt;) allow for objects within one database to act as proxies for objects in other database or clusters. The older dblink module (see &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt;) provides a similar capability. By default, all users can connect to all databases using all connection methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d0d4ecddcc515b05d012f2d76c53d27fb85b80" translate="yes" xml:space="preserve">
          <source>When continuous WAL archiving is used in a standby, there are two different scenarios: the WAL archive can be shared between the primary and the standby, or the standby can have its own WAL archive. When the standby has its own WAL archive, set &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;always&lt;/code&gt;, and the standby will call the archive command for every WAL segment it receives, whether it's by restoring from the archive or by streaming replication. The shared archive can be handled similarly, but the &lt;code&gt;archive_command&lt;/code&gt; must test if the file being archived exists already, and if the existing file has identical contents. This requires more care in the &lt;code&gt;archive_command&lt;/code&gt;, as it must be careful to not overwrite an existing file with different contents, but return success if the exactly same file is archived twice. And all that must be done free of race conditions, if two servers attempt to archive the same file at the same time.</source>
          <target state="translated">Когда непрерывное архивирование WAL используется в резервной системе, возможны два разных сценария: архив WAL может использоваться совместно между основным и резервным, или резервный может иметь свой собственный архив WAL. Когда резервный &lt;code&gt;archive_mode&lt;/code&gt; имеет свой собственный архив WAL, установите для параметра archive_mode значение &lt;code&gt;always&lt;/code&gt; , и резервный сервер будет вызывать команду архивирования для каждого полученного сегмента WAL, будь то восстановление из архива или потоковая репликация. С общим архивом можно работать аналогичным образом, но команда &lt;code&gt;archive_command&lt;/code&gt; должна проверить, существует ли уже архивируемый файл и идентично ли содержимое существующего файла. Это требует большей осторожности в &lt;code&gt;archive_command&lt;/code&gt; , так как необходимо соблюдать осторожность, чтобы не перезаписать существующий файл с другим содержимым, но вернуть успешный результат, если один и тот же файл архивируется дважды. И все это должно быть сделано без условий гонки, если два сервера попытаются архивировать один и тот же файл одновременно.</target>
        </trans-unit>
        <trans-unit id="206b825e98c6a586acace075380fd147e6696a55" translate="yes" xml:space="preserve">
          <source>When converting textual JSON input into &lt;code&gt;jsonb&lt;/code&gt;, the primitive types described by RFC 7159 are effectively mapped onto native PostgreSQL types, as shown in &lt;a href=&quot;datatype-json#JSON-TYPE-MAPPING-TABLE&quot;&gt;Table 8.23&lt;/a&gt;. Therefore, there are some minor additional constraints on what constitutes valid &lt;code&gt;jsonb&lt;/code&gt; data that do not apply to the &lt;code&gt;json&lt;/code&gt; type, nor to JSON in the abstract, corresponding to limits on what can be represented by the underlying data type. Notably, &lt;code&gt;jsonb&lt;/code&gt; will reject numbers that are outside the range of the PostgreSQL &lt;code&gt;numeric&lt;/code&gt; data type, while &lt;code&gt;json&lt;/code&gt; will not. Such implementation-defined restrictions are permitted by RFC 7159. However, in practice such problems are far more likely to occur in other implementations, as it is common to represent JSON's &lt;code&gt;number&lt;/code&gt; primitive type as IEEE 754 double precision floating point (which RFC 7159 explicitly anticipates and allows for). When using JSON as an interchange format with such systems, the danger of losing numeric precision compared to data originally stored by PostgreSQL should be considered.</source>
          <target state="translated">При преобразовании текстового ввода JSON в &lt;code&gt;jsonb&lt;/code&gt; примитивные типы, описанные в RFC 7159, эффективно отображаются на собственные типы PostgreSQL, как показано в &lt;a href=&quot;datatype-json#JSON-TYPE-MAPPING-TABLE&quot;&gt;таблице 8.23&lt;/a&gt; . Следовательно, существуют некоторые незначительные дополнительные ограничения на то, что составляет действительные данные &lt;code&gt;jsonb&lt;/code&gt; , которые не применяются ни к типу &lt;code&gt;json&lt;/code&gt; , ни к JSON в абстрактном виде, что соответствует ограничениям на то, что может быть представлено базовым типом данных. Примечательно, что &lt;code&gt;jsonb&lt;/code&gt; отклоняет числа, выходящие за пределы диапазона &lt;code&gt;numeric&lt;/code&gt; типа данных PostgreSQL , тогда как &lt;code&gt;json&lt;/code&gt; не буду. Такие ограничения, определяемые реализацией, разрешены RFC 7159. Однако на практике такие проблемы гораздо более вероятны в других реализациях, поскольку обычно &lt;code&gt;number&lt;/code&gt; примитивный тип JSON представляется как IEEE 754 с плавающей запятой двойной точности (что в RFC 7159 явно предусмотрено и позволяет). При использовании JSON в качестве формата обмена с такими системами следует учитывать опасность потери числовой точности по сравнению с данными, изначально хранящимися в PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="e063ec55d6b5085c54d075810d580142922489d3" translate="yes" xml:space="preserve">
          <source>When creating a comment on a constraint, a trigger, a rule or a policy these parameters specify the name of the table or domain on which that object is defined.</source>
          <target state="translated">При создании комментария к ограничению,триггеру,правилу или политике эти параметры указывают имя таблицы или домена,на котором определен этот объект.</target>
        </trans-unit>
        <trans-unit id="696e17ed5a7d60938c1cece83fb1d6b1c0903390" translate="yes" xml:space="preserve">
          <source>When creating a hash partition, a modulus and remainder must be specified. The modulus must be a positive integer, and the remainder must be a non-negative integer less than the modulus. Typically, when initially setting up a hash-partitioned table, you should choose a modulus equal to the number of partitions and assign every table the same modulus and a different remainder (see examples, below). However, it is not required that every partition have the same modulus, only that every modulus which occurs among the partitions of a hash-partitioned table is a factor of the next larger modulus. This allows the number of partitions to be increased incrementally without needing to move all the data at once. For example, suppose you have a hash-partitioned table with 8 partitions, each of which has modulus 8, but find it necessary to increase the number of partitions to 16. You can detach one of the modulus-8 partitions, create two new modulus-16 partitions covering the same portion of the key space (one with a remainder equal to the remainder of the detached partition, and the other with a remainder equal to that value plus 8), and repopulate them with data. You can then repeat this -- perhaps at a later time -- for each modulus-8 partition until none remain. While this may still involve a large amount of data movement at each step, it is still better than having to create a whole new table and move all the data at once.</source>
          <target state="translated">При создании хэш-раздела необходимо указать модуль и остаток.Модуль должен быть положительным целым числом,а остаток должен быть неотрицательным целым числом меньше,чем модуль.Обычно,при первоначальной настройке таблицы хэш-разметки,вы должны выбрать модуль,равный количеству разделов,и назначить каждой таблице один и тот же модуль и другой остаток (см.примеры ниже).Однако,не требуется,чтобы каждый раздел имел один и тот же модуль,только то,что каждый модуль,встречающийся среди разделов таблицы хеш-разметка,является фактором следующего большего модуля.Это позволяет увеличивать число разделов постепенно,без необходимости перемещать все данные сразу.Например,предположим,что у вас есть таблица хеш-разметка с 8 разделами,каждый из которых имеет модуль 8,но вы считаете необходимым увеличить число разделов до 16.Можно отсоединить один из разделов модуля 8,создать два новых раздела модуля 16,охватывающих одну и ту же часть ключевого пространства (один с остатком,равным остатку отсоединенного раздела,а другой с остатком,равным этому значению плюс 8),и заново заселить их данными.Затем можно повторить это --возможно,позже --для каждого раздела модуля-8 до тех пор,пока ни один из разделов не останется.Несмотря на то,что это все равно может потребовать перемещения большого количества данных на каждом шаге,это все же лучше,чем создавать целую новую таблицу и перемещать все данные сразу.</target>
        </trans-unit>
        <trans-unit id="dc592c55de3b2852cc094ece1e21e03a790645cd" translate="yes" xml:space="preserve">
          <source>When creating a list partition, &lt;code&gt;NULL&lt;/code&gt; can be specified to signify that the partition allows the partition key column to be null. However, there cannot be more than one such list partition for a given parent table. &lt;code&gt;NULL&lt;/code&gt; cannot be specified for range partitions.</source>
          <target state="translated">При создании раздела списка можно указать &lt;code&gt;NULL&lt;/code&gt; , чтобы обозначить, что раздел позволяет столбцу ключа раздела быть пустым. Однако для данной родительской таблицы не может быть более одного такого раздела списка. Для разделов диапазона нельзя указать &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="959c4be92ae7a89cd93733c9fb53bfb204d0cf54" translate="yes" xml:space="preserve">
          <source>When creating a range partition involving more than one column, it can also make sense to use &lt;code&gt;MAXVALUE&lt;/code&gt; as part of the lower bound, and &lt;code&gt;MINVALUE&lt;/code&gt; as part of the upper bound. For example, a partition defined using &lt;code&gt;FROM (0, MAXVALUE) TO (10, MAXVALUE)&lt;/code&gt; allows any rows where the first partition key column is greater than 0 and less than or equal to 10. Similarly, a partition defined using &lt;code&gt;FROM ('a', MINVALUE) TO ('b', MINVALUE)&lt;/code&gt; allows any rows where the first partition key column starts with &quot;a&quot;.</source>
          <target state="translated">При создании раздела диапазона, включающего более одного столбца, также может иметь смысл использовать &lt;code&gt;MAXVALUE&lt;/code&gt; как часть нижней границы и &lt;code&gt;MINVALUE&lt;/code&gt; как часть верхней границы. Например, раздел, определенный с помощью &lt;code&gt;FROM (0, MAXVALUE) TO (10, MAXVALUE)&lt;/code&gt; допускает любые строки, в которых первый столбец ключа раздела больше 0 и меньше или равен 10. Аналогично раздел, определенный с помощью &lt;code&gt;FROM ('a', MINVALUE) TO ('b', MINVALUE)&lt;/code&gt; разрешает любые строки, в которых первый столбец ключа раздела начинается с &amp;laquo;a&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="57bc08d42f10eaae11d2af1199ad3605b863277f" translate="yes" xml:space="preserve">
          <source>When creating a range partition, the lower bound specified with &lt;code&gt;FROM&lt;/code&gt; is an inclusive bound, whereas the upper bound specified with &lt;code&gt;TO&lt;/code&gt; is an exclusive bound. That is, the values specified in the &lt;code&gt;FROM&lt;/code&gt; list are valid values of the corresponding partition key columns for this partition, whereas those in the &lt;code&gt;TO&lt;/code&gt; list are not. Note that this statement must be understood according to the rules of row-wise comparison (&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt;). For example, given &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt;, a partition bound &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; allows &lt;code&gt;x=1&lt;/code&gt; with any &lt;code&gt;y&amp;gt;=2&lt;/code&gt;, &lt;code&gt;x=2&lt;/code&gt; with any non-null &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;x=3&lt;/code&gt; with any &lt;code&gt;y&amp;lt;4&lt;/code&gt;.</source>
          <target state="translated">При создании раздела диапазона нижняя граница, указанная с помощью &lt;code&gt;FROM&lt;/code&gt; , является включающей границей, тогда как верхняя граница, указанная с помощью &lt;code&gt;TO&lt;/code&gt; , является исключительной границей. То есть значения, указанные в списке &lt;code&gt;FROM&lt;/code&gt; , являются допустимыми значениями соответствующих столбцов ключа раздела для этого раздела, тогда как значения в списке &lt;code&gt;TO&lt;/code&gt; - нет. Обратите внимание, что этот оператор следует понимать в соответствии с правилами &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;построчного&lt;/a&gt; сравнения ( Раздел 9.23.5 ). Например, задано &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt; , граница раздела &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; допускает &lt;code&gt;x=1&lt;/code&gt; с любым &lt;code&gt;y&amp;gt;=2&lt;/code&gt; , &lt;code&gt;x=2&lt;/code&gt; с любым ненулевым &lt;code&gt;y&lt;/code&gt; , и &lt;code&gt;x=3&lt;/code&gt; при любом &lt;code&gt;y&amp;lt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7765f2e543f0af71f77765315c7b66c2db81da2" translate="yes" xml:space="preserve">
          <source>When creating a range partition, the lower bound specified with &lt;code&gt;FROM&lt;/code&gt; is an inclusive bound, whereas the upper bound specified with &lt;code&gt;TO&lt;/code&gt; is an exclusive bound. That is, the values specified in the &lt;code&gt;FROM&lt;/code&gt; list are valid values of the corresponding partition key columns for this partition, whereas those in the &lt;code&gt;TO&lt;/code&gt; list are not. Note that this statement must be understood according to the rules of row-wise comparison (&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.24.5&lt;/a&gt;). For example, given &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt;, a partition bound &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; allows &lt;code&gt;x=1&lt;/code&gt; with any &lt;code&gt;y&amp;gt;=2&lt;/code&gt;, &lt;code&gt;x=2&lt;/code&gt; with any non-null &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;x=3&lt;/code&gt; with any &lt;code&gt;y&amp;lt;4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812122c3d99be13340fb205c1949bf12eabae44b" translate="yes" xml:space="preserve">
          <source>When creating a replication slot (the default behavior), &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">При создании слота репликации (поведение по умолчанию) &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; не может выполняться внутри блока транзакции.</target>
        </trans-unit>
        <trans-unit id="de7cd6bf9e49c5d84cc8863ddd6e1c17c3e9e579" translate="yes" xml:space="preserve">
          <source>When creating a slot, use the specified logical decoding output plugin. See &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;. This option has no effect if the slot already exists.</source>
          <target state="translated">При создании слота используйте указанный модуль вывода логического декодирования. См. &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Главу 48&lt;/a&gt; . Эта опция не действует, если слот уже существует.</target>
        </trans-unit>
        <trans-unit id="1423e49aad04fb2810f02511e3e72b04f513e2b2" translate="yes" xml:space="preserve">
          <source>When creating a slot, use the specified logical decoding output plugin. See &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;. This option has no effect if the slot already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005a2c498e4cc6e0542ca9414edc2d0ef17812bb" translate="yes" xml:space="preserve">
          <source>When creating a subscription, the remote host is not reachable or in an unclear state. In that case, the subscription can be created using the &lt;code&gt;connect = false&lt;/code&gt; option. The remote host will then not be contacted at all. This is what pg_dump uses. The remote replication slot will then have to be created manually before the subscription can be activated.</source>
          <target state="translated">При создании подписки удаленный хост недоступен или находится в неясном состоянии. В этом случае подписку можно создать с помощью параметра &lt;code&gt;connect = false&lt;/code&gt; . Тогда с удаленным хостом вообще не будет связываться. Это то, что использует pg_dump. После этого слот удаленной репликации необходимо будет создать вручную, прежде чем можно будет активировать подписку.</target>
        </trans-unit>
        <trans-unit id="34ca2fb6b711dd16e241f960cfce7ef591df396f" translate="yes" xml:space="preserve">
          <source>When creating a subscription, the replication slot already exists. In that case, the subscription can be created using the &lt;code&gt;create_slot = false&lt;/code&gt; option to associate with the existing slot.</source>
          <target state="translated">При создании подписки слот репликации уже существует. В этом случае подписку можно создать с помощью параметра &lt;code&gt;create_slot = false&lt;/code&gt; для связи с существующим слотом.</target>
        </trans-unit>
        <trans-unit id="16abed6745cbdfc58355b822cc58590cd4574664" translate="yes" xml:space="preserve">
          <source>When creating an index on a partitioned table, this column is set to the number of partitions on which the index has been completed.</source>
          <target state="translated">При создании индекса в таблице простенков этот столбец задается числом простенков,на которых индекс был заполнен.</target>
        </trans-unit>
        <trans-unit id="0cf84112606c62d754e9e14623f4cabe94d1c440" translate="yes" xml:space="preserve">
          <source>When creating an index on a partitioned table, this column is set to the total number of partitions on which the index is to be created.</source>
          <target state="translated">При создании индекса в таблице простенков этот столбец задается общим количеством простенков,на которых должен быть создан индекс.</target>
        </trans-unit>
        <trans-unit id="0f225feca5ba0ff2fa1c5fa9fb76ca1ce05ad30d" translate="yes" xml:space="preserve">
          <source>When dealing with an &lt;code&gt;allTheSame&lt;/code&gt; tuple, a &lt;code&gt;choose&lt;/code&gt; result of &lt;code&gt;spgMatchNode&lt;/code&gt; is interpreted to mean that the new value can be assigned to any of the equivalent nodes; the core code will ignore the supplied &lt;code&gt;nodeN&lt;/code&gt; value and descend into one of the nodes at random (so as to keep the tree balanced). It is an error for &lt;code&gt;choose&lt;/code&gt; to return &lt;code&gt;spgAddNode&lt;/code&gt;, since that would make the nodes not all equivalent; the &lt;code&gt;spgSplitTuple&lt;/code&gt; action must be used if the value to be inserted doesn't match the existing nodes.</source>
          <target state="translated">При работе с кортежем &lt;code&gt;allTheSame&lt;/code&gt; результат &lt;code&gt;choose&lt;/code&gt; &lt;code&gt;spgMatchNode&lt;/code&gt; интерпретируется как означающий, что новое значение может быть присвоено любому из эквивалентных узлов; основной код игнорирует предоставленное значение &lt;code&gt;nodeN&lt;/code&gt; и спускается в один из узлов случайным образом (чтобы дерево оставалось сбалансированным). &lt;code&gt;choose&lt;/code&gt; возврата &lt;code&gt;spgAddNode&lt;/code&gt; является ошибкой , поскольку не все узлы будут эквивалентными; действие &lt;code&gt;spgSplitTuple&lt;/code&gt; необходимо использовать, если вставляемое значение не соответствует существующим узлам.</target>
        </trans-unit>
        <trans-unit id="cc81dfaf2529806492d6926ee92f707f3d6c4c1b" translate="yes" xml:space="preserve">
          <source>When dealing with an &lt;code&gt;allTheSame&lt;/code&gt; tuple, the &lt;code&gt;inner_consistent&lt;/code&gt; function should return either all or none of the nodes as targets for continuing the index search, since they are all equivalent. This may or may not require any special-case code, depending on how much the &lt;code&gt;inner_consistent&lt;/code&gt; function normally assumes about the meaning of the nodes.</source>
          <target state="translated">Когда имеешь дело с &lt;code&gt;allTheSame&lt;/code&gt; кортежа, то &lt;code&gt;inner_consistent&lt;/code&gt; функция должна возвращать либо все , либо ни один из узлов в качестве мишеней для продолжения поиска индекса, так как все они эквивалентны. Для этого может потребоваться или не потребоваться какой-либо специальный код, в зависимости от того, насколько функция &lt;code&gt;inner_consistent&lt;/code&gt; обычно предполагает значение узлов.</target>
        </trans-unit>
        <trans-unit id="b32b90019e8bbf81fee22cbcc2778aa7cfddfd6c" translate="yes" xml:space="preserve">
          <source>When dealing with multiple-argument aggregate functions, note that the &lt;code&gt;ORDER BY&lt;/code&gt; clause goes after all the aggregate arguments. For example, write this:</source>
          <target state="translated">При работе с агрегатными функциями с несколькими аргументами обратите внимание, что предложение &lt;code&gt;ORDER BY&lt;/code&gt; идет после всех агрегированных аргументов. Например, напишите это:</target>
        </trans-unit>
        <trans-unit id="ec8f5c244f8f3ee5e69ba2a3cc1d82f9a3714553" translate="yes" xml:space="preserve">
          <source>When dealing with outer joins, you might see join plan nodes with both &amp;ldquo;Join Filter&amp;rdquo; and plain &amp;ldquo;Filter&amp;rdquo; conditions attached. Join Filter conditions come from the outer join's &lt;code&gt;ON&lt;/code&gt; clause, so a row that fails the Join Filter condition could still get emitted as a null-extended row. But a plain Filter condition is applied after the outer-join rules and so acts to remove rows unconditionally. In an inner join there is no semantic difference between these types of filters.</source>
          <target state="translated">При работе с внешними объединениями вы можете увидеть узлы плана объединения с прикрепленными условиями &amp;laquo;Фильтр объединения&amp;raquo; и обычным &amp;laquo;Фильтром&amp;raquo;. Условия фильтра соединения исходят из предложения &lt;code&gt;ON&lt;/code&gt; внешнего соединения , поэтому строка, не удовлетворяющая условию фильтра соединения, может по-прежнему генерироваться как строка с расширенным нулем. Но простое условие фильтра применяется после правил внешнего соединения и поэтому действует для безоговорочного удаления строк. Во внутреннем соединении между этими типами фильтров нет семантической разницы.</target>
        </trans-unit>
        <trans-unit id="8a4bff252219a510e2ce0b73debb16a2f8ba45f1" translate="yes" xml:space="preserve">
          <source>When deciding what is a longer or shorter match, match lengths are measured in characters, not collating elements. An empty string is considered longer than no match at all. For example: &lt;code&gt;bb*&lt;/code&gt; matches the three middle characters of &lt;code&gt;abbbc&lt;/code&gt;; &lt;code&gt;(week|wee)(night|knights)&lt;/code&gt; matches all ten characters of &lt;code&gt;weeknights&lt;/code&gt;; when &lt;code&gt;(.*).*&lt;/code&gt; is matched against &lt;code&gt;abc&lt;/code&gt; the parenthesized subexpression matches all three characters; and when &lt;code&gt;(a*)*&lt;/code&gt; is matched against &lt;code&gt;bc&lt;/code&gt; both the whole RE and the parenthesized subexpression match an empty string.</source>
          <target state="translated">При принятии решения о том, какое совпадение является более длинным или более коротким, длина совпадений измеряется в символах, а не в элементах сортировки. Пустая строка считается длиннее, чем полное отсутствие совпадения. Например: &lt;code&gt;bb*&lt;/code&gt; соответствует трем средним символам &lt;code&gt;abbbc&lt;/code&gt; ; &lt;code&gt;(week|wee)(night|knights)&lt;/code&gt; соответствует всем десяти символам &lt;code&gt;weeknights&lt;/code&gt; ; когда &lt;code&gt;(.*).*&lt;/code&gt; сопоставляется с &lt;code&gt;abc&lt;/code&gt; , подвыражение в скобках соответствует всем трем символам; и когда &lt;code&gt;(a*)*&lt;/code&gt; сопоставляется с &lt;code&gt;bc&lt;/code&gt; , и все RE, и подвыражение в скобках соответствуют пустой строке.</target>
        </trans-unit>
        <trans-unit id="158e24683a0dfaf92eb2d2d99535563f16d12035" translate="yes" xml:space="preserve">
          <source>When defining a path, you can also use one or more &lt;em&gt;filter expressions&lt;/em&gt; that work similarly to the &lt;code&gt;WHERE&lt;/code&gt; clause in SQL. A filter expression begins with a question mark and provides a condition in parentheses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51f30bba3581f1e69eb69eac04311486d90890a" translate="yes" xml:space="preserve">
          <source>When defining the path, you can also use one or more &lt;em&gt;filter expressions&lt;/em&gt; that work similar to the &lt;code&gt;WHERE&lt;/code&gt; clause in SQL. A filter expression begins with a question mark and provides a condition in parentheses:</source>
          <target state="translated">При определении пути вы также можете использовать одно или несколько &lt;em&gt;выражений фильтра,&lt;/em&gt; которые работают аналогично &lt;code&gt;WHERE&lt;/code&gt; в SQL. Выражение фильтра начинается с вопросительного знака и предоставляет условие в круглых скобках:</target>
        </trans-unit>
        <trans-unit id="359ea83f4fdb1b7fa655731f901be35273bbf743" translate="yes" xml:space="preserve">
          <source>When dropping a subscription that is associated with a replication slot on the remote host (the normal state), &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; will connect to the remote host and try to drop the replication slot as part of its operation. This is necessary so that the resources allocated for the subscription on the remote host are released. If this fails, either because the remote host is not reachable or because the remote replication slot cannot be dropped or does not exist or never existed, the &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; command will fail. To proceed in this situation, disassociate the subscription from the replication slot by executing &lt;code&gt;ALTER SUBSCRIPTION ... SET (slot_name = NONE)&lt;/code&gt;. After that, &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; will no longer attempt any actions on a remote host. Note that if the remote replication slot still exists, it should then be dropped manually; otherwise it will continue to reserve WAL and might eventually cause the disk to fill up. See also &lt;a href=&quot;logical-replication-subscription#LOGICAL-REPLICATION-SUBSCRIPTION-SLOT&quot;&gt;Section 30.2.1&lt;/a&gt;.</source>
          <target state="translated">При отбрасывании подписки, связанной со слотом репликации на удаленном хосте (нормальное состояние), &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; будет подключаться к удаленному хосту и попытается отбросить слот репликации как часть своей операции. Это необходимо для того, чтобы освободить ресурсы, выделенные для подписки на удаленном хосте. Если это не удается, либо потому, что удаленный хост недоступен, либо потому, что слот удаленной репликации не может быть отброшен, не существует или никогда не существовал, команда &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; завершится ошибкой. Чтобы продолжить в этой ситуации, отключите подписку от слота репликации, выполнив &lt;code&gt;ALTER SUBSCRIPTION ... SET (slot_name = NONE)&lt;/code&gt; . После этого &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; больше не будет предпринимать никаких действий на удаленном хосте. Обратите внимание, что если слот удаленной репликации все еще существует, его следует удалить вручную; в противном случае он продолжит резервировать WAL и может в конечном итоге привести к заполнению диска. См. Также &lt;a href=&quot;logical-replication-subscription#LOGICAL-REPLICATION-SUBSCRIPTION-SLOT&quot;&gt;Раздел 30.2.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16b8b09fc04797b1f4bd77cb938d65220f3c98d4" translate="yes" xml:space="preserve">
          <source>When dropping a subscription, the remote host is not reachable. In that case, disassociate the slot from the subscription using &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; before attempting to drop the subscription. If the remote database instance no longer exists, no further action is then necessary. If, however, the remote database instance is just unreachable, the replication slot should then be dropped manually; otherwise it would continue to reserve WAL and might eventually cause the disk to fill up. Such cases should be carefully investigated.</source>
          <target state="translated">При отбрасывании подписки удаленный хост недоступен. В этом случае отключите слот от подписки, используя &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; , прежде чем пытаться отбросить подписку. Если удаленный экземпляр базы данных больше не существует, дальнейшие действия не требуются. Если, однако, удаленный экземпляр базы данных просто недоступен, слот репликации следует удалить вручную; в противном случае он продолжит резервировать WAL и в конечном итоге может привести к заполнению диска. Такие случаи следует тщательно расследовать.</target>
        </trans-unit>
        <trans-unit id="aef261ef51923658a5c92b355545488277ab638d" translate="yes" xml:space="preserve">
          <source>When dropping a subscription, the replication slot should be kept. This could be useful when the subscriber database is being moved to a different host and will be activated from there. In that case, disassociate the slot from the subscription using &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; before attempting to drop the subscription.</source>
          <target state="translated">При отбрасывании подписки следует сохранить слот репликации. Это может быть полезно, когда база данных подписчиков перемещается на другой хост и будет активирована оттуда. В этом случае отключите слот от подписки, используя &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; , прежде чем пытаться отбросить подписку.</target>
        </trans-unit>
        <trans-unit id="7012bb7adb09426a92f880209bcb563fe9379138" translate="yes" xml:space="preserve">
          <source>When dumping data for a table partition, make the &lt;code&gt;COPY&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt; statements target the root of the partitioning hierarchy that contains it, rather than the partition itself. This causes the appropriate partition to be re-determined for each row when the data is loaded. This may be useful when reloading data on a server where rows do not always fall into the same partitions as they did on the original server. That could happen, for example, if the partitioning column is of type text and the two systems have different definitions of the collation used to sort the partitioning column.</source>
          <target state="translated">При выгрузке данных для раздела таблицы сделайте так, чтобы операторы &lt;code&gt;COPY&lt;/code&gt; или &lt;code&gt;INSERT&lt;/code&gt; были нацелены на корень иерархии разделения, которая их содержит, а не на сам раздел. Это приводит к повторному определению соответствующего раздела для каждой строки при загрузке данных. Это может быть полезно при перезагрузке данных на сервере, где строки не всегда попадают в те же разделы, что и на исходном сервере. Это могло произойти, например, если столбец разделения имеет текстовый тип и две системы имеют разные определения параметров сортировки, используемых для сортировки столбца разделения.</target>
        </trans-unit>
        <trans-unit id="b3c4665e18254fa2583d0b9a6ca4200ef73e4faf" translate="yes" xml:space="preserve">
          <source>When dumping logical replication subscriptions, pg_dump will generate &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; commands that use the &lt;code&gt;connect = false&lt;/code&gt; option, so that restoring the subscription does not make remote connections for creating a replication slot or for initial table copy. That way, the dump can be restored without requiring network access to the remote servers. It is then up to the user to reactivate the subscriptions in a suitable way. If the involved hosts have changed, the connection information might have to be changed. It might also be appropriate to truncate the target tables before initiating a new full table copy.</source>
          <target state="translated">При выгрузке подписок логической репликации pg_dump будет генерировать команды &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; , которые используют параметр &lt;code&gt;connect = false&lt;/code&gt; , так что при восстановлении подписки не устанавливаются удаленные подключения для создания слота репликации или для начальной копии таблицы. Таким образом, дамп можно восстановить, не требуя сетевого доступа к удаленным серверам. Затем пользователь должен повторно активировать подписки подходящим способом. Если задействованные хосты изменились, возможно, придется изменить информацию о соединении. Также может оказаться целесообразным усечь целевые таблицы перед созданием новой полной копии таблицы.</target>
        </trans-unit>
        <trans-unit id="edeac7aa265daa84ac15a79b57465693d865b8ff" translate="yes" xml:space="preserve">
          <source>When either stderr or csvlog are included, the file &lt;code&gt;current_logfiles&lt;/code&gt; is created to record the location of the log file(s) currently in use by the logging collector and the associated logging destination. This provides a convenient way to find the logs currently in use by the instance. Here is an example of this file's content:</source>
          <target state="translated">Когда включены либо stderr, либо csvlog, создается файл &lt;code&gt;current_logfiles&lt;/code&gt; для записи местоположения файлов журнала, используемых в настоящее время сборщиком журналов, и связанного места назначения журналов. Это обеспечивает удобный способ найти журналы, используемые в данный момент экземпляром. Вот пример содержимого этого файла:</target>
        </trans-unit>
        <trans-unit id="0bf7e84c79ef7d8674ff36f5bd69afa904df5b94" translate="yes" xml:space="preserve">
          <source>When encrypting with a public key:</source>
          <target state="translated">При шифровании открытым ключом:</target>
        </trans-unit>
        <trans-unit id="d8c4c4accb682e67b5f8b1813c77704fe93cbcb0" translate="yes" xml:space="preserve">
          <source>When encrypting with a symmetric key (i.e., a password):</source>
          <target state="translated">При шифровании симметричным ключом (т.е.паролем):</target>
        </trans-unit>
        <trans-unit id="db0cd6f3816a8188a89deee57f710a1baaa98cf3" translate="yes" xml:space="preserve">
          <source>When entering &lt;code&gt;bytea&lt;/code&gt; values in escape format, octets of certain values &lt;em&gt;must&lt;/em&gt; be escaped, while all octet values &lt;em&gt;can&lt;/em&gt; be escaped. In general, to escape an octet, convert it into its three-digit octal value and precede it by a backslash. Backslash itself (octet decimal value 92) can alternatively be represented by double backslashes. &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt; shows the characters that must be escaped, and gives the alternative escape sequences where applicable.</source>
          <target state="translated">При вводе &lt;code&gt;bytea&lt;/code&gt; значений в escape-формате &lt;em&gt;необходимо&lt;/em&gt; экранировать октеты определенных значений , в то время как все значения октетов &lt;em&gt;могут&lt;/em&gt; быть экранированы. Обычно, чтобы избежать октета, преобразуйте его в трехзначное восьмеричное значение и поставьте перед ним обратную косую черту. Сама обратная косая черта (десятичное значение октета 92) также может быть представлена ​​двойной обратной косой чертой. &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;В таблице 8.7&lt;/a&gt; показаны символы, которые необходимо экранировать, и приведены альтернативные escape-последовательности, где это применимо.</target>
        </trans-unit>
        <trans-unit id="0b723af7e86ecb6fa9f1f4fcf436b5692ddd09fd" translate="yes" xml:space="preserve">
          <source>When establishing a unique constraint for a multi-level partition hierarchy, all the columns in the partition key of the target partitioned table, as well as those of all its descendant partitioned tables, must be included in the constraint definition.</source>
          <target state="translated">При создании уникального ограничения для многоуровневой иерархии разделов,все столбцы в ключе раздела целевой таблицы разметки,а также столбцы во всех ее дочерних таблицах разметки должны быть включены в определение ограничения.</target>
        </trans-unit>
        <trans-unit id="5828ba22818bd784c0d1de682badc9fdcf5283f1" translate="yes" xml:space="preserve">
          <source>When estimating the selectivity, the planner applies all the conditions on items in the MCV list, and then sums the frequencies of the matching ones. See &lt;code&gt;mcv_clauselist_selectivity&lt;/code&gt; in &lt;code&gt;src/backend/statistics/mcv.c&lt;/code&gt; for details.</source>
          <target state="translated">При оценке избирательности планировщик применяет все условия к элементам в списке MCV, а затем суммирует частоты совпадающих. См &lt;code&gt;mcv_clauselist_selectivity&lt;/code&gt; в &lt;code&gt;src/backend/statistics/mcv.c&lt;/code&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="716da7567a674fa423040a77262890c91b3b1491" translate="yes" xml:space="preserve">
          <source>When estimating with functional dependencies, the planner assumes that conditions on the involved columns are compatible and hence redundant. If they are incompatible, the correct estimate would be zero rows, but that possibility is not considered. For example, given a query like</source>
          <target state="translated">При оценке с функциональными зависимостями планировщик исходит из того,что условия на задействованных столбцах совместимы и,следовательно,избыточны.Если они несовместимы,то правильной оценкой будут нулевые строки,но эта возможность не учитывается.Например,если задан запрос типа</target>
        </trans-unit>
        <trans-unit id="064d226f0b61cda9a60ca08881b4d97cee01ca7a" translate="yes" xml:space="preserve">
          <source>When executed on a primary, the function also creates a backup history file in the write-ahead log archive area. The history file includes the label given to &lt;code&gt;pg_start_backup&lt;/code&gt;, the starting and ending write-ahead log locations for the backup, and the starting and ending times of the backup. The return value is the backup's ending write-ahead log location (which again can be ignored). After recording the ending location, the current write-ahead log insertion point is automatically advanced to the next write-ahead log file, so that the ending write-ahead log file can be archived immediately to complete the backup.</source>
          <target state="translated">При выполнении на первичном сервере функция также создает файл истории резервного копирования в области архива журнала упреждающей записи. Файл истории включает метку, присвоенную &lt;code&gt;pg_start_backup&lt;/code&gt; , места начала и окончания записи журнала упреждающей записи для резервного копирования, а также время начала и окончания резервного копирования. Возвращаемое значение - это конечное местоположение журнала упреждающей записи резервной копии (которое снова можно игнорировать). После записи конечного местоположения текущая точка вставки журнала упреждающей записи автоматически перемещается к следующему файлу журнала упреждающей записи, так что конечный файл журнала упреждающей записи может быть немедленно заархивирован для завершения резервного копирования.</target>
        </trans-unit>
        <trans-unit id="f889c44a7c84c84f84b08b78362ee8d2fe32a7ef" translate="yes" xml:space="preserve">
          <source>When executed on a primary, this function also creates a backup history file in the write-ahead log archive area. The history file includes the label given to &lt;code&gt;pg_start_backup&lt;/code&gt;, the starting and ending write-ahead log locations for the backup, and the starting and ending times of the backup. After recording the ending location, the current write-ahead log insertion point is automatically advanced to the next write-ahead log file, so that the ending write-ahead log file can be archived immediately to complete the backup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b575c812fb039c331ed73bad6b9599e79ed09b9b" translate="yes" xml:space="preserve">
          <source>When executed, the example D script gives output such as:</source>
          <target state="translated">При выполнении скрипт примера D выдает такие результаты:</target>
        </trans-unit>
        <trans-unit id="9b9cbbd3bd8e290879a575143872c711e1071acb" translate="yes" xml:space="preserve">
          <source>When executing a parallel plan, you can use &lt;code&gt;EXPLAIN (ANALYZE, VERBOSE)&lt;/code&gt; to display per-worker statistics for each plan node. This may be useful in determining whether the work is being evenly distributed between all plan nodes and more generally in understanding the performance characteristics of the plan.</source>
          <target state="translated">При выполнении параллельного плана вы можете использовать &lt;code&gt;EXPLAIN (ANALYZE, VERBOSE)&lt;/code&gt; для отображения статистики по работникам для каждого узла плана. Это может быть полезно для определения того, равномерно ли распределяется работа между всеми узлами плана, и в более общем плане для понимания рабочих характеристик плана.</target>
        </trans-unit>
        <trans-unit id="f5c9db9afb12cc927dcae6f85bc0fefc8f88ecba" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source which has been recently promoted, it is necessary to execute a &lt;code&gt;CHECKPOINT&lt;/code&gt; after promotion so as its control file reflects up-to-date timeline information, which is used by pg_rewind to check if the target cluster can be rewound using the designated source cluster.</source>
          <target state="translated">При выполнении pg_rewind с использованием онлайн-кластера в качестве источника, который недавно был повышен, необходимо выполнить &lt;code&gt;CHECKPOINT&lt;/code&gt; после продвижения, так как его контрольный файл отражает актуальную информацию временной шкалы, которая используется pg_rewind для проверки того, может ли целевой кластер перемотка с использованием назначенного исходного кластера.</target>
        </trans-unit>
        <trans-unit id="bc2e3d886cd659c186dac8f9dc7a3737bab777bf" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source which has been recently promoted, it is necessary to execute a &lt;code&gt;CHECKPOINT&lt;/code&gt; after promotion such that its control file reflects up-to-date timeline information, which is used by pg_rewind to check if the target cluster can be rewound using the designated source cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45578e8de56cf79c1bab7717b9b7f3794e4ce080" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source, a role having sufficient permissions to execute the functions used by pg_rewind on the source cluster can be used instead of a superuser. Here is how to create such a role, named &lt;code&gt;rewind_user&lt;/code&gt; here:</source>
          <target state="translated">При выполнении pg_rewind с использованием сетевого кластера в качестве источника вместо суперпользователя может использоваться роль, имеющая достаточные разрешения для выполнения функций, используемых pg_rewind в исходном кластере. Вот как создать такую ​​роль, названную здесь &lt;code&gt;rewind_user&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9d8da664aa55aa1d9ba572665740c9977324d898" translate="yes" xml:space="preserve">
          <source>When false, the command will not try to refresh table information. &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; should then be executed separately. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение false, команда не будет пытаться обновить информацию таблицы. &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; следует выполнять отдельно. По умолчанию это &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d12b7ebd6720c102addd509acf7a1b3a9bca1905" translate="yes" xml:space="preserve">
          <source>When host names are specified in &lt;code&gt;pg_hba.conf&lt;/code&gt;, you should make sure that name resolution is reasonably fast. It can be of advantage to set up a local name resolution cache such as &lt;code&gt;nscd&lt;/code&gt;. Also, you may wish to enable the configuration parameter &lt;code&gt;log_hostname&lt;/code&gt; to see the client's host name instead of the IP address in the log.</source>
          <target state="translated">Когда имена хостов указаны в &lt;code&gt;pg_hba.conf&lt;/code&gt; , вы должны убедиться, что разрешение имен достаточно быстрое. Может оказаться &lt;code&gt;nscd&lt;/code&gt; настроить локальный кэш разрешения имен, например nscd . Кроме того, вы можете включить параметр конфигурации &lt;code&gt;log_hostname&lt;/code&gt; , чтобы видеть имя хоста клиента вместо IP-адреса в журнале.</target>
        </trans-unit>
        <trans-unit id="72b7c985f760c5c9e2832f32ef829164b2539557" translate="yes" xml:space="preserve">
          <source>When ident is specified for a local (non-TCP/IP) connection, peer authentication (see &lt;a href=&quot;auth-peer&quot;&gt;Section 20.9&lt;/a&gt;) will be used instead.</source>
          <target state="translated">Когда идентификатор указан для локального (не TCP / IP) соединения, вместо него будет использоваться одноранговая аутентификация (см. &lt;a href=&quot;auth-peer&quot;&gt;Раздел 20.9&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="81c1aa17a38d25550246efe2b31fe8f5cb3b0dba" translate="yes" xml:space="preserve">
          <source>When indexes are not used, it can be useful for testing to force their use. There are run-time parameters that can turn off various plan types (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;Section 19.7.1&lt;/a&gt;). For instance, turning off sequential scans (&lt;code&gt;enable_seqscan&lt;/code&gt;) and nested-loop joins (&lt;code&gt;enable_nestloop&lt;/code&gt;), which are the most basic plans, will force the system to use a different plan. If the system still chooses a sequential scan or nested-loop join then there is probably a more fundamental reason why the index is not being used; for example, the query condition does not match the index. (What kind of query can use what kind of index is explained in the previous sections.)</source>
          <target state="translated">Когда индексы не используются, может быть полезно для тестирования принудительно их использовать. Существуют параметры времени выполнения, которые могут отключать различные типы планов (см. &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;Раздел 19.7.1&lt;/a&gt; ). Например, отключение последовательных сканирований ( &lt;code&gt;enable_seqscan&lt;/code&gt; ) и соединений с вложенными циклами ( &lt;code&gt;enable_nestloop&lt;/code&gt; ), которые являются наиболее простыми планами, заставит систему использовать другой план. Если система по-прежнему выбирает последовательное сканирование или соединение с вложенным циклом, то, вероятно, существует более фундаментальная причина, по которой индекс не используется; например, условие запроса не соответствует индексу. (Какой тип запроса может использовать какой индекс объясняется в предыдущих разделах.)</target>
        </trans-unit>
        <trans-unit id="9e50d0004d8680329345366b2774f5ebb4ad654f" translate="yes" xml:space="preserve">
          <source>When inserting a lot of data at the same time, consider using the &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command. It is not as flexible as the &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; command, but is more efficient. Refer to &lt;a href=&quot;populate&quot;&gt;Section 14.4&lt;/a&gt; for more information on improving bulk loading performance.</source>
          <target state="translated">При одновременной вставке большого количества данных рассмотрите возможность использования команды &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; . Она не такая гибкая, как команда &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; , но более эффективна. Обратитесь к &lt;a href=&quot;populate&quot;&gt;Разделу 14.4&lt;/a&gt; для получения дополнительной информации об улучшении производительности массовой загрузки.</target>
        </trans-unit>
        <trans-unit id="dfb95bd9b76a1aa6b1bb1f21c135d8d5ba87cb03" translate="yes" xml:space="preserve">
          <source>When issuing queries in a database where some users mistrust other users, observe security precautions from &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt; when writing function calls.</source>
          <target state="translated">При выполнении запросов в базе данных, где некоторые пользователи не доверяют другим пользователям, соблюдайте меры безопасности из &lt;a href=&quot;typeconv-func&quot;&gt;Раздела 10.3&lt;/a&gt; при написании вызовов функций.</target>
        </trans-unit>
        <trans-unit id="4ed9176dec0c08e99a6d40ec733c0b7bac5bbcf2" translate="yes" xml:space="preserve">
          <source>When it is essential to force evaluation order, a &lt;code&gt;CASE&lt;/code&gt; construct (see &lt;a href=&quot;functions-conditional&quot;&gt;Section 9.17&lt;/a&gt;) can be used. For example, this is an untrustworthy way of trying to avoid division by zero in a &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">Когда необходимо принудительно установить порядок оценки, можно использовать конструкцию &lt;code&gt;CASE&lt;/code&gt; (см. &lt;a href=&quot;functions-conditional&quot;&gt;Раздел 9.17&lt;/a&gt; ). Например, это ненадежный способ избежать деления на ноль в предложении &lt;code&gt;WHERE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f8882a94a7fafb56987fef2a0a2e2d4eb96df827" translate="yes" xml:space="preserve">
          <source>When it is essential to force evaluation order, a &lt;code&gt;CASE&lt;/code&gt; construct (see &lt;a href=&quot;functions-conditional&quot;&gt;Section 9.18&lt;/a&gt;) can be used. For example, this is an untrustworthy way of trying to avoid division by zero in a &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43ae9852bbd4e7fca0407119c0359f8ae17da03" translate="yes" xml:space="preserve">
          <source>When loading large amounts of data into an installation that uses WAL archiving or streaming replication, it might be faster to take a new base backup after the load has completed than to process a large amount of incremental WAL data. To prevent incremental WAL logging while loading, disable archiving and streaming replication, by setting &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; to &lt;code&gt;minimal&lt;/code&gt;, &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt;, and &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; to zero. But note that changing these settings requires a server restart.</source>
          <target state="translated">При загрузке больших объемов данных в установку, использующую архивирование WAL или потоковую репликацию, может быть быстрее создать новую базовую резервную копию после завершения загрузки, чем обработать большой объем инкрементных данных WAL. Чтобы предотвратить инкрементное ведение журнала WAL при загрузке, отключите архивирование и потоковую репликацию, установив для &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; значение &lt;code&gt;minimal&lt;/code&gt; , &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt; - &lt;code&gt;off&lt;/code&gt; и &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders - равное&lt;/a&gt; нулю. Но учтите, что для изменения этих настроек требуется перезапуск сервера.</target>
        </trans-unit>
        <trans-unit id="a320947bd6f8b1714ed336d766e812f876be824d" translate="yes" xml:space="preserve">
          <source>When logging to event log is enabled, this parameter determines the program name used to identify PostgreSQL messages in the log. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Если запись в журнал событий включена, этот параметр определяет имя программы, используемое для идентификации сообщений PostgreSQL в журнале. По умолчанию - &lt;code&gt;PostgreSQL&lt;/code&gt; . Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="688b202e83ca61ee5187e2a33b6d2092af8c2739" translate="yes" xml:space="preserve">
          <source>When logging to syslog and this is on (the default), then each message will be prefixed by an increasing sequence number (such as &lt;code&gt;[2]&lt;/code&gt;). This circumvents the &amp;ldquo;--- last message repeated N times ---&amp;rdquo; suppression that many syslog implementations perform by default. In more modern syslog implementations, repeated message suppression can be configured (for example, &lt;code&gt;$RepeatedMsgReduction&lt;/code&gt; in rsyslog), so this might not be necessary. Also, you could turn this off if you actually want to suppress repeated messages.</source>
          <target state="translated">При регистрации в системном журнале, когда он включен (по умолчанию), каждое сообщение будет иметь префикс с увеличивающимся порядковым номером (например, &lt;code&gt;[2]&lt;/code&gt; ). Это позволяет обойти подавление &amp;laquo;--- последнее сообщение повторяется N раз ---&amp;raquo;, которое многие реализации системного журнала выполняют по умолчанию. В более современных реализациях системного журнала можно настроить подавление повторяющихся сообщений (например, &lt;code&gt;$RepeatedMsgReduction&lt;/code&gt; RepeatedMsgReduction в rsyslog), поэтому в этом может быть нет необходимости. Кроме того, вы можете отключить это, если действительно хотите подавить повторяющиеся сообщения.</target>
        </trans-unit>
        <trans-unit id="ba8a396481d44a42fb2aa24b4ad06150638300e9" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines how messages are delivered to syslog. When on (the default), messages are split by lines, and long lines are split so that they will fit into 1024 bytes, which is a typical size limit for traditional syslog implementations. When off, PostgreSQL server log messages are delivered to the syslog service as is, and it is up to the syslog service to cope with the potentially bulky messages.</source>
          <target state="translated">Когда включена регистрация в syslog,этот параметр определяет,как сообщения доставляются в syslog.Когда он включен (по умолчанию),сообщения разбиваются на строки,а длинные строки разделяются так,что они помещаются в 1024 байта,что является типичным ограничением размера для традиционных реализаций syslog.Когда выключено,сообщения журнала сервера PostgreSQL доставляются в службу syslog как есть,и именно служба syslog справляется с потенциально громоздкими сообщениями.</target>
        </trans-unit>
        <trans-unit id="80ff0840aef3199452ea4eb2990b10a8d1c55939" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines the program name used to identify PostgreSQL messages in syslog logs. The default is &lt;code&gt;postgres&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Если ведение журнала в системный журнал включено, этот параметр определяет имя программы, используемое для идентификации сообщений PostgreSQL в журналах системного журнала. По умолчанию - &lt;code&gt;postgres&lt;/code&gt; . Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="985b03993881f4457d8f0c3b34d9b7b01342f4d8" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines the syslog &amp;ldquo;facility&amp;rdquo; to be used. You can choose from &lt;code&gt;LOCAL0&lt;/code&gt;, &lt;code&gt;LOCAL1&lt;/code&gt;, &lt;code&gt;LOCAL2&lt;/code&gt;, &lt;code&gt;LOCAL3&lt;/code&gt;, &lt;code&gt;LOCAL4&lt;/code&gt;, &lt;code&gt;LOCAL5&lt;/code&gt;, &lt;code&gt;LOCAL6&lt;/code&gt;, &lt;code&gt;LOCAL7&lt;/code&gt;; the default is &lt;code&gt;LOCAL0&lt;/code&gt;. See also the documentation of your system's syslog daemon. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Когда ведение журнала в системный журнал включено, этот параметр определяет &amp;laquo;средство&amp;raquo; системного журнала, которое будет использоваться. Вы можете выбрать &lt;code&gt;LOCAL0&lt;/code&gt; , &lt;code&gt;LOCAL1&lt;/code&gt; , &lt;code&gt;LOCAL2&lt;/code&gt; , &lt;code&gt;LOCAL3&lt;/code&gt; , &lt;code&gt;LOCAL4&lt;/code&gt; , &lt;code&gt;LOCAL5&lt;/code&gt; , &lt;code&gt;LOCAL6&lt;/code&gt; , &lt;code&gt;LOCAL7&lt;/code&gt; ; по умолчанию &lt;code&gt;LOCAL0&lt;/code&gt; . См. Также документацию к демону системного журнала вашей системы. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="6d9a3edba4451cb3d18020f74c5a06ee8a7a52bd" translate="yes" xml:space="preserve">
          <source>When managing the server directly, you can control the type of shutdown by sending different signals to the &lt;code&gt;postgres&lt;/code&gt; process:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30985843aab3e94f2bd3bce331e8a5523cabcbb" translate="yes" xml:space="preserve">
          <source>When more than one expression is specified, the later values are used to sort rows that are equal according to the earlier values. Each expression can be followed by an optional &lt;code&gt;ASC&lt;/code&gt; or &lt;code&gt;DESC&lt;/code&gt; keyword to set the sort direction to ascending or descending. &lt;code&gt;ASC&lt;/code&gt; order is the default. Ascending order puts smaller values first, where &amp;ldquo;smaller&amp;rdquo; is defined in terms of the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. Similarly, descending order is determined with the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;#ftn.id-1.5.6.9.5.10&quot;&gt;&lt;sup id=&quot;id-1.5.6.9.5.10&quot;&gt;[5]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">Если указано более одного выражения, более поздние значения используются для сортировки строк, которые равны в соответствии с более ранними значениями. За каждым выражением может следовать необязательное ключевое слово &lt;code&gt;ASC&lt;/code&gt; или &lt;code&gt;DESC&lt;/code&gt; , чтобы задать направление сортировки по возрастанию или убыванию. &lt;code&gt;ASC&lt;/code&gt; умолчанию используется порядок ASC . В порядке возрастания сначала помещаются меньшие значения, где &amp;laquo;меньшие&amp;raquo; определяются с помощью оператора &lt;code&gt;&amp;lt;&lt;/code&gt; . Точно так же порядок убывания определяется оператором &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;a href=&quot;#ftn.id-1.5.6.9.5.10&quot;&gt;&lt;sup id=&quot;id-1.5.6.9.5.10&quot;&gt;[5]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11912d8e839cffb71f2e5fc45344859e046a9cbc" translate="yes" xml:space="preserve">
          <source>When more than one row is specified, all the rows must have the same number of elements. The data types of the resulting table's columns are determined by combining the explicit or inferred types of the expressions appearing in that column, using the same rules as for &lt;code&gt;UNION&lt;/code&gt; (see &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;).</source>
          <target state="translated">Если указано более одной строки, все строки должны иметь одинаковое количество элементов. Типы данных столбцов результирующей таблицы определяются путем объединения явных или предполагаемых типов выражений, появляющихся в этом столбце, с использованием тех же правил, что и для &lt;code&gt;UNION&lt;/code&gt; (см. &lt;a href=&quot;typeconv-union-case&quot;&gt;Раздел 10.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dcff81a7a0194a63301c74dc5ce189cffc265222" translate="yes" xml:space="preserve">
          <source>When multiple policies apply to a given query, they are combined using either &lt;code&gt;OR&lt;/code&gt; (for permissive policies, which are the default) or using &lt;code&gt;AND&lt;/code&gt; (for restrictive policies). This is similar to the rule that a given role has the privileges of all roles that they are a member of. Permissive vs. restrictive policies are discussed further below.</source>
          <target state="translated">Когда к данному запросу применяется несколько политик, они объединяются либо с использованием &lt;code&gt;OR&lt;/code&gt; (для разрешающих политик, которые используются по умолчанию), либо с использованием &lt;code&gt;AND&lt;/code&gt; (для ограничительных политик). Это похоже на правило, согласно которому данная роль имеет привилегии всех ролей, членом которых она является. Разрешительные и ограничительные политики обсуждаются ниже.</target>
        </trans-unit>
        <trans-unit id="269b9ef4adee76f3240604e5767201bc6ee01e71" translate="yes" xml:space="preserve">
          <source>When multiple policies of different command types apply to the same command (for example, &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; policies applied to an &lt;code&gt;UPDATE&lt;/code&gt; command), then the user must have both types of permissions (for example, permission to select rows from the relation as well as permission to update them). Thus the expressions for one type of policy are combined with the expressions for the other type of policy using the &lt;code&gt;AND&lt;/code&gt; operator.</source>
          <target state="translated">Когда к одной команде применяется несколько политик разных типов команд (например, политики &lt;code&gt;SELECT&lt;/code&gt; и &lt;code&gt;UPDATE&lt;/code&gt; , применяемые к команде &lt;code&gt;UPDATE&lt;/code&gt; ), тогда пользователь должен иметь разрешения обоих типов (например, разрешение на выбор строк из отношения, а также разрешение на их обновление). Таким образом, выражения для одного типа политики комбинируются с выражениями для другого типа политики с помощью оператора &lt;code&gt;AND&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="556057cb09a8742cb36bd19c1657e03ac61a815b" translate="yes" xml:space="preserve">
          <source>When multiple policies of the same command type apply to the same command, then there must be at least one &lt;code&gt;PERMISSIVE&lt;/code&gt; policy granting access to the relation, and all of the &lt;code&gt;RESTRICTIVE&lt;/code&gt; policies must pass. Thus all the &lt;code&gt;PERMISSIVE&lt;/code&gt; policy expressions are combined using &lt;code&gt;OR&lt;/code&gt;, all the &lt;code&gt;RESTRICTIVE&lt;/code&gt; policy expressions are combined using &lt;code&gt;AND&lt;/code&gt;, and the results are combined using &lt;code&gt;AND&lt;/code&gt;. If there are no &lt;code&gt;PERMISSIVE&lt;/code&gt; policies, then access is denied.</source>
          <target state="translated">Если к одной команде применяется несколько политик одного и того же типа команды, тогда должна быть хотя бы одна &lt;code&gt;PERMISSIVE&lt;/code&gt; политика, предоставляющая доступ к отношению, и все &lt;code&gt;RESTRICTIVE&lt;/code&gt; политики должны пройти. Таким образом , все &lt;code&gt;PERMISSIVE&lt;/code&gt; выражения политики объединяются с помощью &lt;code&gt;OR&lt;/code&gt; , все &lt;code&gt;RESTRICTIVE&lt;/code&gt; выражения политики объединяются с помощью &lt;code&gt;AND&lt;/code&gt; и результаты объединяются с помощью &lt;code&gt;AND&lt;/code&gt; . Если политики &lt;code&gt;PERMISSIVE&lt;/code&gt; нет , доступ запрещен.</target>
        </trans-unit>
        <trans-unit id="5d6d15be5ddf45a51b853b506d5d1a1d2068106c" translate="yes" xml:space="preserve">
          <source>When multiple window functions are used, all the window functions having syntactically equivalent &lt;code&gt;PARTITION BY&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; clauses in their window definitions are guaranteed to be evaluated in a single pass over the data. Therefore they will see the same sort ordering, even if the &lt;code&gt;ORDER BY&lt;/code&gt; does not uniquely determine an ordering. However, no guarantees are made about the evaluation of functions having different &lt;code&gt;PARTITION BY&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; specifications. (In such cases a sort step is typically required between the passes of window function evaluations, and the sort is not guaranteed to preserve ordering of rows that its &lt;code&gt;ORDER BY&lt;/code&gt; sees as equivalent.)</source>
          <target state="translated">Когда используются несколько оконных функций, все оконные функции, имеющие синтаксически эквивалентные предложения &lt;code&gt;PARTITION BY&lt;/code&gt; и &lt;code&gt;ORDER BY&lt;/code&gt; в своих определениях окон, гарантированно оцениваются за один проход по данным. Поэтому они будут видеть тот же порядок сортировки, даже если &lt;code&gt;ORDER BY&lt;/code&gt; не определяет порядок однозначно. Однако не дается никаких гарантий относительно оценки функций, имеющих разные спецификации &lt;code&gt;PARTITION BY&lt;/code&gt; или &lt;code&gt;ORDER BY&lt;/code&gt; . (В таких случаях обычно требуется этап сортировки между проходами оценки оконных функций, и при сортировке не гарантируется сохранение порядка строк, который &lt;code&gt;ORDER BY&lt;/code&gt; считает эквивалентным.)</target>
        </trans-unit>
        <trans-unit id="34f31d5224ac605a926f4e92907e12ec5add9474" translate="yes" xml:space="preserve">
          <source>When multiple workers are running, the autovacuum cost delay parameters (see &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;Section 19.4.4&lt;/a&gt;) are &amp;ldquo;balanced&amp;rdquo; among all the running workers, so that the total I/O impact on the system is the same regardless of the number of workers actually running. However, any workers processing tables whose per-table &lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; or &lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; storage parameters have been set are not considered in the balancing algorithm.</source>
          <target state="translated">Когда работает несколько рабочих, параметры задержки стоимости автоочистки (см. &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;Раздел 19.4.4&lt;/a&gt; ) &amp;laquo;сбалансированы&amp;raquo; среди всех запущенных рабочих, так что общее влияние ввода-вывода на систему одинаково, независимо от количества фактически запущенных рабочих. . Однако любые рабочие, обрабатывающие таблицы, для каждой таблицы &lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; &lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; параметры хранения autovacuum_vacuum_cost_delay или autovacuum_vacuum_cost_limit , не учитываются в алгоритме балансировки.</target>
        </trans-unit>
        <trans-unit id="84f11ff5e7225ec364ea450b05da5b31bd525923" translate="yes" xml:space="preserve">
          <source>When no final &lt;code&gt;ELSE&lt;/code&gt; clause is provided to a &lt;code&gt;CASE&lt;/code&gt;, the default value is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Если для &lt;code&gt;CASE&lt;/code&gt; не указано окончательное предложение &lt;code&gt;ELSE&lt;/code&gt; , значение по умолчанию - &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb2d002b299026c6a8e3abc29ae594e572a6b112" translate="yes" xml:space="preserve">
          <source>When non-serializable writes are possible, to ensure the current validity of a row and protect it against concurrent updates one must use &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR SHARE&lt;/code&gt;, or an appropriate &lt;code&gt;LOCK TABLE&lt;/code&gt; statement. (&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; lock just the returned rows against concurrent updates, while &lt;code&gt;LOCK TABLE&lt;/code&gt; locks the whole table.) This should be taken into account when porting applications to PostgreSQL from other environments.</source>
          <target state="translated">Когда возможны несериализуемые записи, чтобы гарантировать текущую достоверность строки и защитить ее от одновременных обновлений, необходимо использовать &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; , &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; или соответствующий оператор &lt;code&gt;LOCK TABLE&lt;/code&gt; . ( &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; и &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; блокируют только возвращенные строки от одновременных обновлений, а &lt;code&gt;LOCK TABLE&lt;/code&gt; блокирует всю таблицу.) Это следует учитывать при переносе приложений на PostgreSQL из других сред.</target>
        </trans-unit>
        <trans-unit id="8d5d4ed5a8f5b52f15315d7a651b9128c1d498f8" translate="yes" xml:space="preserve">
          <source>When not all owned objects are to be transferred to the same successor owner, it's best to handle the exceptions manually and then perform the above steps to mop up.</source>
          <target state="translated">Когда не все объекты,находящиеся в собственности,должны быть переданы одному и тому же правопреемнику,лучше всего обращаться с исключениями вручную,а затем выполнить вышеописанные шаги для уборки.</target>
        </trans-unit>
        <trans-unit id="ed8afcb65f27d90b88c36a924e96931352e55b61" translate="yes" xml:space="preserve">
          <source>When not using the &lt;code&gt;ROWS FROM()&lt;/code&gt; syntax, the &lt;code&gt;column_definition&lt;/code&gt; list replaces the column alias list that could otherwise be attached to the &lt;code&gt;FROM&lt;/code&gt; item; the names in the column definitions serve as column aliases. When using the &lt;code&gt;ROWS FROM()&lt;/code&gt; syntax, a &lt;code&gt;column_definition&lt;/code&gt; list can be attached to each member function separately; or if there is only one member function and no &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause, a &lt;code&gt;column_definition&lt;/code&gt; list can be written in place of a column alias list following &lt;code&gt;ROWS FROM()&lt;/code&gt;.</source>
          <target state="translated">Если синтаксис &lt;code&gt;ROWS FROM()&lt;/code&gt; не используется , список &lt;code&gt;column_definition&lt;/code&gt; заменяет список псевдонимов столбца, который в противном случае мог бы быть присоединен к элементу &lt;code&gt;FROM&lt;/code&gt; ; имена в определениях столбцов служат псевдонимами столбцов. При использовании синтаксиса &lt;code&gt;ROWS FROM()&lt;/code&gt; список &lt;code&gt;column_definition&lt;/code&gt; может быть прикреплен к каждой функции-члену отдельно; или если есть только одна функция-член и нет предложения &lt;code&gt;WITH ORDINALITY&lt;/code&gt; , список &lt;code&gt;column_definition&lt;/code&gt; может быть записан вместо списка псевдонимов столбца, следующего за &lt;code&gt;ROWS FROM()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89c266fb8eeefdc22c382f51ddfa36d2cdf3fd08" translate="yes" xml:space="preserve">
          <source>When objects are created without specifying a particular target schema, they will be placed in the first valid schema named in &lt;code&gt;search_path&lt;/code&gt;. An error is reported if the search path is empty.</source>
          <target state="translated">Когда объекты создаются без указания конкретной целевой схемы, они будут помещены в первую действительную схему, &lt;code&gt;search_path&lt;/code&gt; в search_path . Сообщается об ошибке, если путь поиска пуст.</target>
        </trans-unit>
        <trans-unit id="99ff2ff0bf302907b157207503609b9e0138a5a9" translate="yes" xml:space="preserve">
          <source>When on, a warning is issued if a backslash (&lt;code&gt;\&lt;/code&gt;) appears in an ordinary string literal (&lt;code&gt;'...'&lt;/code&gt; syntax) and &lt;code&gt;standard_conforming_strings&lt;/code&gt; is off. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">При включении выдается предупреждение, если в обычном строковом литерале ( синтаксис &lt;code&gt;'...'&lt;/code&gt; ) появляется обратная косая черта ( &lt;code&gt;\&lt;/code&gt; ), а &lt;code&gt;standard_conforming_strings&lt;/code&gt; выключены. По умолчанию &lt;code&gt;on&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a39a26ef7d5c306f15cfec242fa1908a71ae3775" translate="yes" xml:space="preserve">
          <source>When on, expressions of the form &lt;code&gt;expr = NULL&lt;/code&gt; (or &lt;code&gt;NULL = expr&lt;/code&gt;) are treated as &lt;code&gt;expr IS NULL&lt;/code&gt;, that is, they return true if &lt;code&gt;expr&lt;/code&gt; evaluates to the null value, and false otherwise. The correct SQL-spec-compliant behavior of &lt;code&gt;expr = NULL&lt;/code&gt; is to always return null (unknown). Therefore this parameter defaults to &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">Когда включено, выражения вида &lt;code&gt;expr = NULL&lt;/code&gt; (или &lt;code&gt;NULL = expr&lt;/code&gt; ) обрабатываются как &lt;code&gt;expr IS NULL&lt;/code&gt; , то есть они возвращают true, если &lt;code&gt;expr&lt;/code&gt; оценивается как нулевое значение, и false в противном случае. Правильное поведение &lt;code&gt;expr = NULL&lt;/code&gt; в соответствии со спецификацией SQL - всегда возвращать значение null (неизвестно). Поэтому по умолчанию этот параметр &lt;code&gt;off&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd83814e734e8771d44c1de9842876866f19a1c6" translate="yes" xml:space="preserve">
          <source>When on, the parser will emit a warning for any construct that might have changed meanings since PostgreSQL 9.4 as a result of changes in operator precedence. This is useful for auditing applications to see if precedence changes have broken anything; but it is not meant to be kept turned on in production, since it will warn about some perfectly valid, standard-compliant SQL code. The default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">Если этот параметр включен, синтаксический анализатор выдаст предупреждение для любой конструкции, значение которой могло измениться после PostgreSQL 9.4 в результате изменений приоритета операторов. Это полезно для аудита приложений, чтобы увидеть, не сломались ли изменения приоритета; но он не предназначен для того, чтобы оставаться включенным в производственной среде, поскольку он будет предупреждать о некотором совершенно правильном, совместимом со стандартами коде SQL. По умолчанию &lt;code&gt;off&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f61f3e69afe30c64a291d60390d7c29326445c47" translate="yes" xml:space="preserve">
          <source>When operators and support functions are added to a family with &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt;, they are not part of any specific operator class within the family, but are just &amp;ldquo;loose&amp;rdquo; within the family. This indicates that these operators and functions are compatible with the family's semantics, but are not required for correct functioning of any specific index. (Operators and functions that are so required should be declared as part of an operator class, instead; see &lt;a href=&quot;sql-createopclass&quot;&gt;CREATE OPERATOR CLASS&lt;/a&gt;.) PostgreSQL will allow loose members of a family to be dropped from the family at any time, but members of an operator class cannot be dropped without dropping the whole class and any indexes that depend on it. Typically, single-data-type operators and functions are part of operator classes because they are needed to support an index on that specific data type, while cross-data-type operators and functions are made loose members of the family.</source>
          <target state="translated">Когда операторы и вспомогательные функции добавляются к семейству с помощью &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; , они не являются частью какого-либо определенного класса операторов в семействе, а просто &amp;laquo;свободны&amp;raquo; внутри семейства. Это указывает на то, что эти операторы и функции совместимы с семантикой семейства, но не требуются для правильного функционирования какого-либо конкретного индекса. (Вместо этого операторы и функции, которые так необходимы, следует объявлять как часть класса операторов; см. &lt;a href=&quot;sql-createopclass&quot;&gt;СОЗДАНИЕ КЛАССА ОПЕРАТОРА&lt;/a&gt;.) PostgreSQL позволяет в любое время удалять отдельные члены семейства из семейства, но нельзя удалять члены класса операторов без удаления всего класса и любых индексов, которые от него зависят. Обычно операторы и функции одного типа данных являются частью классов операторов, поскольку они необходимы для поддержки индекса для этого конкретного типа данных, в то время как операторы и функции перекрестных типов данных становятся свободными членами семейства.</target>
        </trans-unit>
        <trans-unit id="0f2ad4b5a54137b2f0c70ae82420f67c0b1b6ea3" translate="yes" xml:space="preserve">
          <source>When queries or updates access a large percentage of a single partition, performance can be improved by taking advantage of sequential scan of that partition instead of using an index and random access reads scattered across the whole table.</source>
          <target state="translated">Когда запросы или обновления обращаются к большому проценту одного раздела,производительность можно повысить,воспользовавшись последовательным сканированием этого раздела вместо использования индекса и случайного доступа к чтению,разбросанного по всей таблице.</target>
        </trans-unit>
        <trans-unit id="2540d43e50d1abeb1a847d9db340690266815c23" translate="yes" xml:space="preserve">
          <source>When relying on Serializable transactions to prevent anomalies, it is important that any data read from a permanent user table not be considered valid until the transaction which read it has successfully committed. This is true even for read-only transactions, except that data read within a &lt;em&gt;deferrable&lt;/em&gt; read-only transaction is known to be valid as soon as it is read, because such a transaction waits until it can acquire a snapshot guaranteed to be free from such problems before starting to read any data. In all other cases applications must not depend on results read during a transaction that later aborted; instead, they should retry the transaction until it succeeds.</source>
          <target state="translated">Когда вы полагаетесь на сериализуемые транзакции для предотвращения аномалий, важно, чтобы любые данные, считанные из постоянной пользовательской таблицы, не считались действительными до тех пор, пока транзакция, которая их читала, не была успешно зафиксирована. Это верно даже для транзакций только для чтения, за исключением того, что данные, считываемые в рамках &lt;em&gt;отложенной&lt;/em&gt; транзакции только для чтения, считаются действительными, как только они прочитаны, потому что такая транзакция ожидает, пока она не сможет получить моментальный снимок, гарантированно свободный от такого проблемы перед началом чтения каких-либо данных. Во всех остальных случаях приложения не должны зависеть от результатов, считанных во время транзакции, которая позже была прервана; вместо этого они должны повторять транзакцию, пока она не завершится успешно.</target>
        </trans-unit>
        <trans-unit id="0f545c1f8d440a6a74e5e5cae7b49a8321ce778e" translate="yes" xml:space="preserve">
          <source>When repeated &lt;code&gt;CREATE FUNCTION&lt;/code&gt; calls refer to the same object file, the file is only loaded once per session. To unload and reload the file (perhaps during development), start a new session.</source>
          <target state="translated">Когда повторные вызовы &lt;code&gt;CREATE FUNCTION&lt;/code&gt; относятся к одному и тому же объектному файлу, файл загружается только один раз за сеанс. Чтобы выгрузить и перезагрузить файл (возможно, во время разработки), запустите новый сеанс.</target>
        </trans-unit>
        <trans-unit id="63cb3d013e86db6ef5ef57500326cdf863814f3a" translate="yes" xml:space="preserve">
          <source>When repeated &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; calls refer to the same object file, the file is only loaded once per session. To unload and reload the file (perhaps during development), start a new session.</source>
          <target state="translated">Когда повторяющиеся вызовы &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; относятся к одному и тому же объектному файлу, файл загружается только один раз за сеанс. Чтобы выгрузить и перезагрузить файл (возможно, во время разработки), запустите новый сеанс.</target>
        </trans-unit>
        <trans-unit id="b358e9fc6a1b297fd0b37a45eac263be99236636" translate="yes" xml:space="preserve">
          <source>When replacing an existing definition, the argument types, result type, and number of direct arguments may not be changed. Also, the new definition must be of the same kind (ordinary aggregate, ordered-set aggregate, or hypothetical-set aggregate) as the old one.</source>
          <target state="translated">При замене существующего определения типы аргументов,тип результата и количество прямых аргументов не могут быть изменены.Кроме того,новое определение должно быть того же типа (обычный агрегат,упорядоченный агрегат или гипотетический агрегат),что и старое.</target>
        </trans-unit>
        <trans-unit id="bf16a952f545e26cfee0e603603bfd07e12cf881" translate="yes" xml:space="preserve">
          <source>When replacing an existing function with &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt;, there are restrictions on changing parameter names. You cannot change the name already assigned to any input parameter (although you can add names to parameters that had none before). If there is more than one output parameter, you cannot change the names of the output parameters, because that would change the column names of the anonymous composite type that describes the function's result. These restrictions are made to ensure that existing calls of the function do not stop working when it is replaced.</source>
          <target state="translated">При замене существующей функции на &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; существуют ограничения на изменение имен параметров. Вы не можете изменить имя, уже назначенное какому-либо входному параметру (хотя вы можете добавлять имена к параметрам, у которых раньше не было). Если существует более одного выходного параметра, вы не можете изменить имена выходных параметров, потому что это изменит имена столбцов анонимного составного типа, который описывает результат функции. Эти ограничения сделаны для того, чтобы существующие вызовы функции не перестали работать при ее замене.</target>
        </trans-unit>
        <trans-unit id="c4f24499d5667a6f6b8b67600774aa56a3d4c33d" translate="yes" xml:space="preserve">
          <source>When replicating between partitioned tables, the actual replication originates, by default, from the leaf partitions on the publisher, so partitions on the publisher must also exist on the subscriber as valid target tables. (They could either be leaf partitions themselves, or they could be further subpartitioned, or they could even be independent tables.) Publications can also specify that changes are to be replicated using the identity and schema of the partitioned root table instead of that of the individual leaf partitions in which the changes actually originate (see &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80773f67cc3b08f5dcb6c36638c7da08b5a16582" translate="yes" xml:space="preserve">
          <source>When requesting synchronous replication, each commit of a write transaction will wait until confirmation is received that the commit has been written to the write-ahead log on disk of both the primary and standby server. The only possibility that data can be lost is if both the primary and the standby suffer crashes at the same time. This can provide a much higher level of durability, though only if the sysadmin is cautious about the placement and management of the two servers. Waiting for confirmation increases the user's confidence that the changes will not be lost in the event of server crashes but it also necessarily increases the response time for the requesting transaction. The minimum wait time is the round-trip time between primary to standby.</source>
          <target state="translated">При запросе синхронной репликации каждый коммит транзакции записи будет ждать,пока не будет получено подтверждение,что коммит был записан в журнал записи на диске основного и резервного серверов.Единственная возможность,что данные могут быть потеряны,это если и основной,и резервный сервер пострадают от сбоя одновременно.Это может обеспечить гораздо более высокий уровень надежности,хотя только в том случае,если сисадмин осторожно подойдет к размещению и управлению двумя серверами.Ожидание подтверждения повышает уверенность пользователя в том,что изменения не будут потеряны в случае сбоя сервера,но также обязательно увеличивает время отклика для запрашивающей транзакции.Минимальное время ожидания-это время перехода от первичного к резервному.</target>
        </trans-unit>
        <trans-unit id="7cbfd2d18fb6178afa3088b0725b2bc3fcdf04fe" translate="yes" xml:space="preserve">
          <source>When restoring data to a pre-existing table and the option &lt;code&gt;--disable-triggers&lt;/code&gt; is used, pg_restore emits commands to disable triggers on user tables before inserting the data, then emits commands to re-enable them after the data has been inserted. If the restore is stopped in the middle, the system catalogs might be left in the wrong state.</source>
          <target state="translated">При восстановлении данных в уже существующей таблице и использовании опции &lt;code&gt;--disable-triggers&lt;/code&gt; triggers pg_restore выдает команды для отключения триггеров в пользовательских таблицах перед вставкой данных, а затем выдает команды для их повторного включения после того, как данные были вставлены. Если восстановление остановлено в середине, системные каталоги могут остаться в неправильном состоянии.</target>
        </trans-unit>
        <trans-unit id="ade7c8c975218ba23dcef154671330d11fa5728d" translate="yes" xml:space="preserve">
          <source>When revoking membership in a role, &lt;code&gt;GRANT OPTION&lt;/code&gt; is instead called &lt;code&gt;ADMIN OPTION&lt;/code&gt;, but the behavior is similar. Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt;.</source>
          <target state="translated">При отмене членства в роли &lt;code&gt;GRANT OPTION&lt;/code&gt; вместо этого называется &lt;code&gt;ADMIN OPTION&lt;/code&gt; , но поведение аналогично. Также обратите внимание, что эта форма команды не позволяет использовать слово &lt;code&gt;GROUP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2378e777cb7029b72a32e416964ca17fb134eb03" translate="yes" xml:space="preserve">
          <source>When revoking membership in a role, &lt;code&gt;GRANT OPTION&lt;/code&gt; is instead called &lt;code&gt;ADMIN OPTION&lt;/code&gt;, but the behavior is similar. This form of the command also allows a &lt;code&gt;GRANTED BY&lt;/code&gt; option, but that option is currently ignored (except for checking the existence of the named role). Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt; in &lt;code&gt;role_specification&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68adac31376cf57c26d631be30fdfc9650022d2" translate="yes" xml:space="preserve">
          <source>When revoking privileges on a table, the corresponding column privileges (if any) are automatically revoked on each column of the table, as well. On the other hand, if a role has been granted privileges on a table, then revoking the same privileges from individual columns will have no effect.</source>
          <target state="translated">При отзыве привилегий на таблице,соответствующие столбцы привилегий (если таковые имеются)автоматически отзываются и на каждый столбец таблицы.С другой стороны,если какая-либо роль получила привилегии на таблице,то отзыв тех же привилегий из отдельных столбцов не будет иметь никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="300dad807edac8d993f28c0997a914c75b99f4bc" translate="yes" xml:space="preserve">
          <source>When rounding values, the &lt;code&gt;numeric&lt;/code&gt; type rounds ties away from zero, while (on most machines) the &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; types round ties to the nearest even number. For example:</source>
          <target state="translated">При округлении значений &lt;code&gt;numeric&lt;/code&gt; тип округляет связи от нуля, в то время как (на большинстве машин) &lt;code&gt;real&lt;/code&gt; типы и типы &lt;code&gt;double precision&lt;/code&gt; округляют связи до ближайшего четного числа. Например:</target>
        </trans-unit>
        <trans-unit id="5f76f7c7b77ca49ded558a0639a8d27cc09a3811" translate="yes" xml:space="preserve">
          <source>When row security is enabled on a table (with &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE ... ENABLE ROW LEVEL SECURITY&lt;/a&gt;), all normal access to the table for selecting rows or modifying rows must be allowed by a row security policy. (However, the table's owner is typically not subject to row security policies.) If no policy exists for the table, a default-deny policy is used, meaning that no rows are visible or can be modified. Operations that apply to the whole table, such as &lt;code&gt;TRUNCATE&lt;/code&gt; and &lt;code&gt;REFERENCES&lt;/code&gt;, are not subject to row security.</source>
          <target state="translated">Когда в таблице включена защита строк (с помощью &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE ... ENABLE ROW LEVEL SECURITY&lt;/a&gt; ), любой нормальный доступ к таблице для выбора строк или изменения строк должен быть разрешен политикой безопасности строк. (Однако владелец таблицы обычно не подчиняется политикам безопасности строк.) Если для таблицы не существует политики, используется политика запрета по умолчанию, что означает, что строки не видны или могут быть изменены. Операции, которые применяются ко всей таблице, такие как &lt;code&gt;TRUNCATE&lt;/code&gt; и &lt;code&gt;REFERENCES&lt;/code&gt; , не подлежат безопасности строк.</target>
        </trans-unit>
        <trans-unit id="226f5e12ea7fb1c629a76bb1b3cc1943cd4502fc" translate="yes" xml:space="preserve">
          <source>When running a long test on hardware that can handle a lot of transactions, the log files can become very large. The &lt;code&gt;--sampling-rate&lt;/code&gt; option can be used to log only a random sample of transactions.</source>
          <target state="translated">При выполнении длительного теста на оборудовании, которое может обрабатывать большое количество транзакций, файлы журналов могут стать очень большими. Параметр &lt;code&gt;--sampling-rate&lt;/code&gt; может использоваться для регистрации только случайной выборки транзакций.</target>
        </trans-unit>
        <trans-unit id="4051fc47591e058546d74bee2aa79ca3ea360af8" translate="yes" xml:space="preserve">
          <source>When running a standby server, you must set this parameter to the same or higher value than on the master server. Otherwise, queries will not be allowed in the standby server.</source>
          <target state="translated">При работе с резервным сервером этот параметр должен иметь такое же или большее значение,чем на ведущем сервере.В противном случае запросы на резервном сервере будут запрещены.</target>
        </trans-unit>
        <trans-unit id="0becdbc99cfe7674fb7d475f00ec87ca3a5a28cc" translate="yes" xml:space="preserve">
          <source>When running at the &lt;code&gt;serializable&lt;/code&gt; isolation level, a deferrable read-only SQL transaction may be delayed before it is allowed to proceed. However, once it begins executing it does not incur any of the overhead required to ensure serializability; so serialization code will have no reason to force it to abort because of concurrent updates, making this option suitable for long-running read-only transactions.</source>
          <target state="translated">При работе на уровне &lt;code&gt;serializable&lt;/code&gt; изоляции откладываемая транзакция SQL только для чтения может быть отложена до того, как ей будет разрешено продолжить. Однако, как только он начинает выполнение, он не несет никаких накладных расходов, необходимых для обеспечения сериализуемости; поэтому у кода сериализации не будет причин для принудительного прерывания из-за одновременных обновлений, что делает этот вариант подходящим для длительных транзакций только для чтения.</target>
        </trans-unit>
        <trans-unit id="d1a67057ea54f0f16f47cefbf38d78344e7ecca6" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;on&lt;/code&gt;, if a statement in a transaction block generates an error, the error is ignored and the transaction continues. When set to &lt;code&gt;interactive&lt;/code&gt;, such errors are only ignored in interactive sessions, and not when reading script files. When set to &lt;code&gt;off&lt;/code&gt; (the default), a statement in a transaction block that generates an error aborts the entire transaction. The error rollback mode works by issuing an implicit &lt;code&gt;SAVEPOINT&lt;/code&gt; for you, just before each command that is in a transaction block, and then rolling back to the savepoint if the command fails.</source>
          <target state="translated">Если установлено значение &lt;code&gt;on&lt;/code&gt; , если инструкция в блоке транзакции генерирует ошибку, ошибка игнорируется и транзакция продолжается. При установке в &lt;code&gt;interactive&lt;/code&gt; такие ошибки игнорируются только в интерактивных сеансах, но не при чтении файлов сценариев. Если установлено значение &lt;code&gt;off&lt;/code&gt; (по умолчанию), оператор в блоке транзакции, который генерирует ошибку, прерывает всю транзакцию. В режиме отката при ошибке выдается неявная &lt;code&gt;SAVEPOINT&lt;/code&gt; непосредственно перед каждой командой в блоке транзакции, а затем откат к точке сохранения в случае сбоя команды.</target>
        </trans-unit>
        <trans-unit id="549604915bc0a6d5cfb5cf7a10c720e97be80363" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;remote_apply&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and applied it, so that it has become visible to queries on the standby(s), and also written to durable storage on the standbys. This will cause much larger commit delays than previous settings since it waits for WAL replay. When set to &lt;code&gt;on&lt;/code&gt;, commits wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and flushed it to durable storage. This ensures the transaction will not be lost unless both the primary and all synchronous standbys suffer corruption of their database storage. When set to &lt;code&gt;remote_write&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and written it to their file systems. This setting ensures data preservation if a standby instance of PostgreSQL crashes, but not if the standby suffers an operating-system-level crash because the data has not necessarily reached durable storage on the standby. The setting &lt;code&gt;local&lt;/code&gt; causes commits to wait for local flush to disk, but not for replication. This is usually not desirable when synchronous replication is in use, but is provided for completeness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e9cba78fc8dadeb25eba89d19fc5d8c6ee61b8" translate="yes" xml:space="preserve">
          <source>When set to off, which is the default, PostgreSQL will raise a PANIC-level error on failure to flush modified data files to the file system. This causes the database server to crash. This parameter can only be set at server start.</source>
          <target state="translated">При установке значения &quot;off&quot;,которое является значением по умолчанию,PostgreSQL выдаст ошибку PANIC-уровня о невозможности прошивки файлов с измененными данными в файловую систему.Это приводит к отказу сервера базы данных.Данный параметр может быть установлен только при запуске сервера.</target>
        </trans-unit>
        <trans-unit id="6cbaca794cc78ed3c2b124781f712501c0ff4934" translate="yes" xml:space="preserve">
          <source>When set to on, which is the default, PostgreSQL will automatically reinitialize after a backend crash. Leaving this value set to on is normally the best way to maximize the availability of the database. However, in some circumstances, such as when PostgreSQL is being invoked by clusterware, it may be useful to disable the restart so that the clusterware can gain control and take any actions it deems appropriate.</source>
          <target state="translated">Если установлено значение по умолчанию,PostgreSQL будет автоматически переинициализироваться после падения бэкэнда.Оставлять это значение включенным,как правило,лучший способ максимально увеличить доступность базы данных.Однако,в некоторых обстоятельствах,например,когда PostgreSQL вызывается кластерным ПО,может быть полезно отключить перезагрузку,чтобы кластерное ПО могло получить контроль и предпринять любые действия,которые оно сочтет необходимыми.</target>
        </trans-unit>
        <trans-unit id="a7b55871d6d7b3f171d441751dee834b0868dec6" translate="yes" xml:space="preserve">
          <source>When set, &lt;code&gt;debug_pretty_print&lt;/code&gt; indents the messages produced by &lt;code&gt;debug_print_parse&lt;/code&gt;, &lt;code&gt;debug_print_rewritten&lt;/code&gt;, or &lt;code&gt;debug_print_plan&lt;/code&gt;. This results in more readable but much longer output than the &amp;ldquo;compact&amp;rdquo; format used when it is off. It is on by default.</source>
          <target state="translated">Если установлено, &lt;code&gt;debug_pretty_print&lt;/code&gt; выполняет отступ для сообщений, созданных &lt;code&gt;debug_print_parse&lt;/code&gt; , &lt;code&gt;debug_print_rewritten&lt;/code&gt; или &lt;code&gt;debug_print_plan&lt;/code&gt; . Это приводит к более читаемому, но гораздо более продолжительному результату, чем в &amp;laquo;компактном&amp;raquo; формате, который используется, когда он выключен. По умолчанию он включен.</target>
        </trans-unit>
        <trans-unit id="9655c6cce4ab0fb89202aa42165255e7c2310c07" translate="yes" xml:space="preserve">
          <source>When setting any of these parameters, a relative path will be interpreted with respect to the directory in which &lt;code&gt;postgres&lt;/code&gt; is started.</source>
          <target state="translated">При установке любого из этих параметров относительный путь будет интерпретироваться относительно каталога, в котором запущен &lt;code&gt;postgres&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5cba5ccebd44827dbe97e5c58205ecd19cd5549" translate="yes" xml:space="preserve">
          <source>When several data types share near-identical sorting semantics, their operator classes can be grouped into an operator family. Doing so is advantageous because it allows the planner to make deductions about cross-type comparisons. Each operator class within the family should contain the single-type operators (and associated support functions) for its input data type, while cross-type comparison operators and support functions are &amp;ldquo;loose&amp;rdquo; in the family. It is recommendable that a complete set of cross-type operators be included in the family, thus ensuring that the planner can represent any comparison conditions that it deduces from transitivity.</source>
          <target state="translated">Когда несколько типов данных имеют почти идентичную семантику сортировки, их классы операторов могут быть сгруппированы в семейство операторов. Это выгодно, потому что это позволяет планировщику делать выводы о сравнениях перекрестных типов. Каждый класс операторов в семействе должен содержать однотипные операторы (и связанные с ними вспомогательные функции) для своего типа входных данных, в то время как операторы сравнения между типами и вспомогательные функции являются &amp;laquo;свободными&amp;raquo; в семействе. Рекомендуется включить в семейство полный набор операторов перекрестного типа, чтобы планировщик мог представить любые условия сравнения, которые он выводит из транзитивности.</target>
        </trans-unit>
        <trans-unit id="cb221d1e490779006a131832600e7b4ca11a22c2" translate="yes" xml:space="preserve">
          <source>When showing progress (option &lt;code&gt;-P&lt;/code&gt;), use a timestamp (Unix epoch) instead of the number of seconds since the beginning of the run. The unit is in seconds, with millisecond precision after the dot. This helps compare logs generated by various tools.</source>
          <target state="translated">При отображении прогресса (опция &lt;code&gt;-P&lt;/code&gt; ) используйте метку времени (эпоха Unix) вместо количества секунд с начала выполнения. Единица измерения - секунды с точностью до миллисекунды после точки. Это помогает сравнивать журналы, созданные различными инструментами.</target>
        </trans-unit>
        <trans-unit id="cc026cecf0c9d705d368f497265f6e7182739df8" translate="yes" xml:space="preserve">
          <source>When sorting &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; data types, IPv4 addresses will always sort before IPv6 addresses, including IPv4 addresses encapsulated or mapped to IPv6 addresses, such as ::10.2.3.4 or ::ffff:10.4.3.2.</source>
          <target state="translated">При сортировке &lt;code&gt;cidr&lt;/code&gt; данных &lt;code&gt;inet&lt;/code&gt; или cidr адреса IPv4 всегда сортируются перед адресами IPv6, включая адреса IPv4, инкапсулированные или сопоставленные с адресами IPv6, например :: 10.2.3.4 или :: ffff: 10.4.3.2.</target>
        </trans-unit>
        <trans-unit id="00112c1a0dfb2756ee57aac0f953ab1b28e8aa6b" translate="yes" xml:space="preserve">
          <source>When specified, mandates that corresponding &lt;code&gt;index_column_name&lt;/code&gt; or &lt;code&gt;index_expression&lt;/code&gt; use a particular collation in order to be matched during inference. Typically this is omitted, as collations usually do not affect whether or not a constraint violation occurs. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format.</source>
          <target state="translated">Если указано, требует, чтобы соответствующий &lt;code&gt;index_column_name&lt;/code&gt; или &lt;code&gt;index_expression&lt;/code&gt; использовал конкретное сопоставление для сопоставления во время вывода. Обычно это опускается, поскольку сопоставления обычно не влияют на то, происходит ли нарушение ограничения. Соответствует формату &lt;code&gt;CREATE INDEX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49ab9aed56a17743958b35c4487c001e52ad9448" translate="yes" xml:space="preserve">
          <source>When specified, mandates that corresponding &lt;code&gt;index_column_name&lt;/code&gt; or &lt;code&gt;index_expression&lt;/code&gt; use particular operator class in order to be matched during inference. Typically this is omitted, as the &lt;em&gt;equality&lt;/em&gt; semantics are often equivalent across a type's operator classes anyway, or because it's sufficient to trust that the defined unique indexes have the pertinent definition of equality. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format.</source>
          <target state="translated">Если указано, требует, чтобы соответствующий &lt;code&gt;index_column_name&lt;/code&gt; или &lt;code&gt;index_expression&lt;/code&gt; использовал определенный класс операторов для сопоставления во время вывода. Обычно это опускается, так как семантика &lt;em&gt;равенства&lt;/em&gt; часто в любом случае эквивалентна для всех классов операторов типа или потому, что достаточно верить, что определенные уникальные индексы имеют соответствующее определение равенства. Соответствует формату &lt;code&gt;CREATE INDEX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb6cddffb6a42656d1b6071c587cfd75339041b2" translate="yes" xml:space="preserve">
          <source>When specifying a function by name rather than by OID, the allowed input is the same as for the &lt;code&gt;regprocedure&lt;/code&gt; data type (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;). An example is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47b14844e6f65e1969fe664f76645a83ada8978" translate="yes" xml:space="preserve">
          <source>When specifying the &lt;code&gt;program&lt;/code&gt; option, keep in mind that the option string is executed by the shell. If you need to pass any arguments to the command that come from an untrusted source, you must be careful to strip or escape any characters that might have special meaning to the shell. For security reasons, it is best to use a fixed command string, or at least avoid passing any user input in it.</source>
          <target state="translated">При указании параметра &lt;code&gt;program&lt;/code&gt; имейте в виду, что строка параметра выполняется оболочкой. Если вам нужно передать команде какие-либо аргументы, которые поступают из ненадежного источника, вы должны быть осторожны, чтобы удалить или экранировать любые символы, которые могут иметь особое значение для оболочки. По соображениям безопасности лучше использовать фиксированную командную строку или, по крайней мере, избегать передачи в нее любого пользовательского ввода.</target>
        </trans-unit>
        <trans-unit id="a86f4916e3e42d9bf0f446f6ed8f6c9365f0b9b8" translate="yes" xml:space="preserve">
          <source>When starting a client session via libpq, parameter settings can be specified using the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable. Settings established in this way constitute defaults for the life of the session, but do not affect other sessions. For historical reasons, the format of &lt;code&gt;PGOPTIONS&lt;/code&gt; is similar to that used when launching the &lt;code&gt;postgres&lt;/code&gt; command; specifically, the &lt;code&gt;-c&lt;/code&gt; flag must be specified. For example,</source>
          <target state="translated">При запуске клиентского сеанса через libpq настройки параметров можно указать с помощью переменной среды &lt;code&gt;PGOPTIONS&lt;/code&gt; . Установленные таким образом настройки представляют собой значения по умолчанию на протяжении всего сеанса, но не влияют на другие сеансы. По историческим причинам формат &lt;code&gt;PGOPTIONS&lt;/code&gt; аналогичен формату , используемому при запуске команды &lt;code&gt;postgres&lt;/code&gt; ; в частности, должен быть указан флаг &lt;code&gt;-c&lt;/code&gt; . Например,</target>
        </trans-unit>
        <trans-unit id="8b3e57832327b1f4cd35e9869284543eb2583802" translate="yes" xml:space="preserve">
          <source>When starting the target, PostgreSQL replays all the required WAL, resulting in a data directory in a consistent state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80810b3a36d5394cd36078211fe98f572205f903" translate="yes" xml:space="preserve">
          <source>When suitable, query results can be shown in a crosstab representation with the &lt;code&gt;\crosstabview&lt;/code&gt; command:</source>
          <target state="translated">При необходимости результаты запроса можно отобразить в виде кросс-таблицы с помощью команды &lt;code&gt;\crosstabview&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4333b702c3660525cc0e63ef6d85c05931c74735" translate="yes" xml:space="preserve">
          <source>When tar format is used, it is the user's responsibility to unpack each tar file before starting a PostgreSQL server that uses the data. If there are additional tablespaces, the tar files for them need to be unpacked in the correct locations. In this case the symbolic links for those tablespaces will be created by the server according to the contents of the &lt;code&gt;tablespace_map&lt;/code&gt; file that is included in the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ddbde0da0e9c11c9f3ba6aaa05f9fc0b15fe03" translate="yes" xml:space="preserve">
          <source>When tar format is used, the write-ahead log files will be included in the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8dcb5224676a60278f816ad09b8db2eb2d49b5" translate="yes" xml:space="preserve">
          <source>When tar format is used, the write-ahead log files will be written to a separate file named &lt;code&gt;pg_wal.tar&lt;/code&gt; (if the server is a version earlier than 10, the file will be named &lt;code&gt;pg_xlog.tar&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46f34ffb8c110010cfd3fe050b49b5689c1e534" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, it is the user's responsibility to unpack each tar file before starting the PostgreSQL server. If there are additional tablespaces, the tar files for them need to be unpacked in the correct locations. In this case the symbolic links for those tablespaces will be created by the server according to the contents of the &lt;code&gt;tablespace_map&lt;/code&gt; file that is included in the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">Когда используется режим формата tar, ответственность за распаковку каждого файла tar перед запуском сервера PostgreSQL лежит на пользователе. Если есть дополнительные табличные пространства, их tar-файлы необходимо распаковать в правильные места. В этом случае символические ссылки для этих табличных пространств будут созданы сервером в соответствии с содержимым файла &lt;code&gt;tablespace_map&lt;/code&gt; , который включен в файл &lt;code&gt;base.tar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34c7d99e4e21933c48e46c135fcf1d89d1aca09e" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, the write-ahead log files will be written to a separate file named &lt;code&gt;pg_wal.tar&lt;/code&gt; (if the server is a version earlier than 10, the file will be named &lt;code&gt;pg_xlog.tar&lt;/code&gt;).</source>
          <target state="translated">Когда используется режим формата tar, файлы журнала упреждающей записи будут записаны в отдельный файл с именем &lt;code&gt;pg_wal.tar&lt;/code&gt; (если версия сервера ниже 10, файл будет называться &lt;code&gt;pg_xlog.tar&lt;/code&gt; ).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
