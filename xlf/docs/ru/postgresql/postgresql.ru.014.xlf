<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="debbd30b66af886f3ad4a4846dc7b2ee2e468eb1" translate="yes" xml:space="preserve">
          <source>If LLVM has the required functionality, emit the data needed to allow perf to profile functions generated by JIT. This writes out files to &lt;code&gt;$HOME/.debug/jit/&lt;/code&gt;; the user is responsible for performing cleanup when desired. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">Если LLVM обладает требуемой функциональностью, передайте данные, необходимые, чтобы позволить perf профилировать функции, созданные JIT. Это записывает файлы в &lt;code&gt;$HOME/.debug/jit/&lt;/code&gt; ; при желании пользователь несет ответственность за выполнение очистки. По умолчанию &lt;code&gt;off&lt;/code&gt; . Этот параметр можно установить только при запуске сервера.</target>
        </trans-unit>
        <trans-unit id="ef3c317e4d741dc71490a33136e9ff9dc5428c13" translate="yes" xml:space="preserve">
          <source>If LLVM has the required functionality, register generated functions with GDB. This makes debugging easier. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">Если LLVM имеет требуемую функциональность, зарегистрируйте сгенерированные функции в GDB. Это упрощает отладку. По умолчанию &lt;code&gt;off&lt;/code&gt; . Этот параметр можно установить только при запуске сервера.</target>
        </trans-unit>
        <trans-unit id="efe3f3026039f58c4fe8aa03beba8ad31146f904" translate="yes" xml:space="preserve">
          <source>If OIDs are included in the file, the OID field immediately follows the field-count word. It is a normal field except that it's not included in the field-count. Note that oid system columns are not supported in current versions of PostgreSQL.</source>
          <target state="translated">Если в файл включены OID,то поле OID сразу же следует за словом счетчика полей.Это обычное поле,за исключением того,что оно не включено в счетчик полей.Обратите внимание,что системные Oid-столбцы не поддерживаются в текущих версиях PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="8e65f986646d4bd64aa08e3d223eb8fd14aab146" translate="yes" xml:space="preserve">
          <source>If PAM is set up to read &lt;code&gt;/etc/shadow&lt;/code&gt;, authentication will fail because the PostgreSQL server is started by a non-root user. However, this is not an issue when PAM is configured to use LDAP or other authentication methods.</source>
          <target state="translated">Если PAM настроен на чтение &lt;code&gt;/etc/shadow&lt;/code&gt; , аутентификация не удастся, потому что сервер PostgreSQL запущен пользователем без полномочий root. Однако это не проблема, если PAM настроен на использование LDAP или других методов аутентификации.</target>
        </trans-unit>
        <trans-unit id="415ce588e29ad070811b2db4490099f305d07266" translate="yes" xml:space="preserve">
          <source>If PostgreSQL itself is the cause of the system running out of memory, you can avoid the problem by changing your configuration. In some cases, it may help to lower memory-related configuration parameters, particularly &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;&lt;code&gt;shared_buffers&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;&lt;code&gt;work_mem&lt;/code&gt;&lt;/a&gt;. In other cases, the problem may be caused by allowing too many connections to the database server itself. In many cases, it may be better to reduce &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;&lt;code&gt;max_connections&lt;/code&gt;&lt;/a&gt; and instead make use of external connection-pooling software.</source>
          <target state="translated">Если PostgreSQL сам является причиной нехватки памяти в системе, вы можете избежать проблемы, изменив конфигурацию. В некоторых случаях это может помочь снизить параметры конфигурации, связанные с памятью, особенно &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt; &lt;code&gt;shared_buffers&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt; &lt;code&gt;work_mem&lt;/code&gt; &lt;/a&gt; . В других случаях проблема может быть вызвана слишком большим количеством подключений к серверу базы данных. Во многих случаях может быть лучше уменьшить &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt; &lt;code&gt;max_connections&lt;/code&gt; &lt;/a&gt; и вместо этого использовать программное обеспечение для пула внешних подключений.</target>
        </trans-unit>
        <trans-unit id="6e051bc67e0a6c331eb48a8b787733592331e28c" translate="yes" xml:space="preserve">
          <source>If PostgreSQL itself is the cause of the system running out of memory, you can avoid the problem by changing your configuration. In some cases, it may help to lower memory-related configuration parameters, particularly &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;&lt;code&gt;shared_buffers&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;&lt;code&gt;work_mem&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;runtime-config-resource#GUC-HASH-MEM-MULTIPLIER&quot;&gt;&lt;code&gt;hash_mem_multiplier&lt;/code&gt;&lt;/a&gt;. In other cases, the problem may be caused by allowing too many connections to the database server itself. In many cases, it may be better to reduce &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;&lt;code&gt;max_connections&lt;/code&gt;&lt;/a&gt; and instead make use of external connection-pooling software.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5c2e1e6b44cb1c8622c0c5ffed0c31ab912017" translate="yes" xml:space="preserve">
          <source>If PostgreSQL was compiled with OpenLDAP as the LDAP client library, the &lt;code&gt;ldapserver&lt;/code&gt; setting may be omitted. In that case, a list of host names and ports is looked up via RFC 2782 DNS SRV records. The name &lt;code&gt;_ldap._tcp.DOMAIN&lt;/code&gt; is looked up, where &lt;code&gt;DOMAIN&lt;/code&gt; is extracted from &lt;code&gt;ldapbasedn&lt;/code&gt;.</source>
          <target state="translated">Если PostgreSQL был скомпилирован с OpenLDAP в качестве клиентской библиотеки LDAP, параметр &lt;code&gt;ldapserver&lt;/code&gt; может быть опущен. В этом случае список имен хостов и портов ищется через записи SRV DNS RFC 2782. &lt;code&gt;_ldap._tcp.DOMAIN&lt;/code&gt; имя _ldap._tcp.DOMAIN , где &lt;code&gt;DOMAIN&lt;/code&gt; извлекается из &lt;code&gt;ldapbasedn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f92e62044fa208f984d06131f910dfb1c21e1338" translate="yes" xml:space="preserve">
          <source>If SELinux is disabled or not installed, you must set that product up first before installing this module.</source>
          <target state="translated">Если SELinux отключен или не установлен,вы должны сначала настроить этот продукт,прежде чем устанавливать этот модуль.</target>
        </trans-unit>
        <trans-unit id="a9341d807a078bf8721a956d7df4d8eca09e01a0" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; command is executed while a base backup is being taken, and then the template database that the &lt;code&gt;CREATE DATABASE&lt;/code&gt; copied is modified while the base backup is still in progress, it is possible that recovery will cause those modifications to be propagated into the created database as well. This is of course undesirable. To avoid this risk, it is best not to modify any template databases while taking a base backup.</source>
          <target state="translated">Если команда &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; выполняется во время создания базовой резервной копии, а затем база данных шаблона, скопированная с помощью &lt;code&gt;CREATE DATABASE&lt;/code&gt; , изменяется, в то время как базовая резервная копия все еще выполняется, возможно, что восстановление приведет к распространению этих изменений в также создал базу данных. Это, конечно, нежелательно. Чтобы избежать этого риска, лучше не изменять никакие базы данных шаблонов при создании базовой резервной копии.</target>
        </trans-unit>
        <trans-unit id="fa1de3a6861be1ec1b6ec90aa7e6b3e06531f1df" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DROP&lt;/code&gt; command lists multiple objects, &lt;code&gt;CASCADE&lt;/code&gt; is only required when there are dependencies outside the specified group. For example, when saying &lt;code&gt;DROP TABLE tab1, tab2&lt;/code&gt; the existence of a foreign key referencing &lt;code&gt;tab1&lt;/code&gt; from &lt;code&gt;tab2&lt;/code&gt; would not mean that &lt;code&gt;CASCADE&lt;/code&gt; is needed to succeed.</source>
          <target state="translated">Если команда &lt;code&gt;DROP&lt;/code&gt; перечисляет несколько объектов, &lt;code&gt;CASCADE&lt;/code&gt; требуется только при наличии зависимостей вне указанной группы. Например, говоря &lt;code&gt;DROP TABLE tab1, tab2&lt;/code&gt; наличие внешнего ключа, ссылающегося на &lt;code&gt;tab1&lt;/code&gt; из &lt;code&gt;tab2&lt;/code&gt; , не будет означать, что для успеха необходим &lt;code&gt;CASCADE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92e1a30bd1d3658160c72094059d0371a401f9cd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a function, then the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; command executed inside the function for the same variable are restricted to the function: the configuration parameter's prior value is still restored at function exit. However, an ordinary &lt;code&gt;SET&lt;/code&gt; command (without &lt;code&gt;LOCAL&lt;/code&gt;) overrides the &lt;code&gt;SET&lt;/code&gt; clause, much as it would do for a previous &lt;code&gt;SET LOCAL&lt;/code&gt; command: the effects of such a command will persist after function exit, unless the current transaction is rolled back.</source>
          <target state="translated">Если к функции присоединено предложение &lt;code&gt;SET&lt;/code&gt; , то эффекты команды &lt;code&gt;SET LOCAL&lt;/code&gt; , выполняемой внутри функции для той же переменной, ограничиваются функцией: предыдущее значение параметра конфигурации все равно восстанавливается при выходе из функции. Однако обычная команда &lt;code&gt;SET&lt;/code&gt; (без &lt;code&gt;LOCAL&lt;/code&gt; ) переопределяет предложение &lt;code&gt;SET&lt;/code&gt; , как и предыдущая команда &lt;code&gt;SET LOCAL&lt;/code&gt; : эффекты такой команды сохранятся после выхода из функции, если текущая транзакция не будет отменена.</target>
        </trans-unit>
        <trans-unit id="9c0a79a4075f581261c7fcce27f70643bea75e21" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a procedure, then that procedure cannot execute transaction control statements (for example, &lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt;, depending on the language).</source>
          <target state="translated">Если к процедуре присоединено предложение &lt;code&gt;SET&lt;/code&gt; , то эта процедура не может выполнять операторы управления транзакцией (например, &lt;code&gt;COMMIT&lt;/code&gt; и &lt;code&gt;ROLLBACK&lt;/code&gt; , в зависимости от языка).</target>
        </trans-unit>
        <trans-unit id="f0bddcb97ee43256f36e19dc04e898959e413d86" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a procedure, then the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; command executed inside the procedure for the same variable are restricted to the procedure: the configuration parameter's prior value is still restored at procedure exit. However, an ordinary &lt;code&gt;SET&lt;/code&gt; command (without &lt;code&gt;LOCAL&lt;/code&gt;) overrides the &lt;code&gt;SET&lt;/code&gt; clause, much as it would do for a previous &lt;code&gt;SET LOCAL&lt;/code&gt; command: the effects of such a command will persist after procedure exit, unless the current transaction is rolled back.</source>
          <target state="translated">Если к процедуре присоединено предложение &lt;code&gt;SET&lt;/code&gt; , то эффекты команды &lt;code&gt;SET LOCAL&lt;/code&gt; , выполняемой внутри процедуры для той же переменной, ограничиваются процедурой: предыдущее значение параметра конфигурации все еще восстанавливается при выходе из процедуры. Однако обычная команда &lt;code&gt;SET&lt;/code&gt; (без &lt;code&gt;LOCAL&lt;/code&gt; ) переопределяет предложение &lt;code&gt;SET&lt;/code&gt; , как и предыдущая команда &lt;code&gt;SET LOCAL&lt;/code&gt; : эффекты такой команды сохранятся после выхода из процедуры, если текущая транзакция не будет отменена.</target>
        </trans-unit>
        <trans-unit id="902cabcc62fcf46f7c4713fa1c043b73884c956f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;filename&lt;/code&gt; or &lt;code&gt;|&lt;/code&gt;&lt;code&gt;command&lt;/code&gt; argument is given, the query's output is written to the named file or piped to the given shell command, instead of displaying it as usual. The file or command is written to only if the query successfully returns zero or more tuples, not if the query fails or is a non-data-returning SQL command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2402d507bf01ad0609465ee16a38cc42b24afe" translate="yes" xml:space="preserve">
          <source>If a check constraint, an internal representation of the expression. (It's recommended to use &lt;code&gt;pg_get_constraintdef()&lt;/code&gt; to extract the definition of a check constraint.)</source>
          <target state="translated">Если проверочное ограничение, внутреннее представление выражения. ( Для извлечения определения проверочного ограничения рекомендуется использовать &lt;code&gt;pg_get_constraintdef()&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="f25b711856ae449f9c3d73dd4473185e384f4706" translate="yes" xml:space="preserve">
          <source>If a column in the parent table is an identity column, that property is not inherited. A column in the child table can be declared identity column if desired.</source>
          <target state="translated">Если столбец в родительской таблице является идентификационным столбцом,то это свойство не наследуется.Столбец в дочерней таблице при желании может быть объявлен столбцом идентификации.</target>
        </trans-unit>
        <trans-unit id="90d9a8592c9a8387fcf3bd4a77c9762fb9a47cc1" translate="yes" xml:space="preserve">
          <source>If a column list is specified, &lt;code&gt;COPY TO&lt;/code&gt; copies only the data in the specified columns to the file. For &lt;code&gt;COPY FROM&lt;/code&gt;, each field in the file is inserted, in order, into the specified column. Table columns not specified in the &lt;code&gt;COPY FROM&lt;/code&gt; column list will receive their default values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c03e9dff51a371ecb3dbf0f3542cbc1ae0bd39" translate="yes" xml:space="preserve">
          <source>If a column list is specified, you only need &lt;code&gt;INSERT&lt;/code&gt; privilege on the listed columns. Similarly, when &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; is specified, you only need &lt;code&gt;UPDATE&lt;/code&gt; privilege on the column(s) that are listed to be updated. However, &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; also requires &lt;code&gt;SELECT&lt;/code&gt; privilege on any column whose values are read in the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; expressions or &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">Если указан список столбцов, вам нужна только привилегия &lt;code&gt;INSERT&lt;/code&gt; для перечисленных столбцов. Точно так же, когда указано &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; , вам нужна только привилегия &lt;code&gt;UPDATE&lt;/code&gt; для столбца (столбцов), которые перечислены для обновления. Однако &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; также требует привилегии &lt;code&gt;SELECT&lt;/code&gt; для любого столбца, значения которого читаются в выражениях или &lt;code&gt;condition&lt;/code&gt; &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ae12c756d83d3fa84f0842896261c6e6de98fbd" translate="yes" xml:space="preserve">
          <source>If a column result is NULL, the corresponding variable is unset rather than being set.</source>
          <target state="translated">Если результат столбца NULL,то соответствующая переменная не устанавливается,а сбрасывается.</target>
        </trans-unit>
        <trans-unit id="cd07d38bba484cac13838ebc8d7dd08509069d67" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-XML value (limited to string, boolean, or double in XPath 1.0) and the column has a PostgreSQL type other than &lt;code&gt;xml&lt;/code&gt;, the column will be set as if by assigning the value's string representation to the PostgreSQL type. (If the value is a boolean, its string representation is taken to be &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; if the output column's type category is numeric, otherwise &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.)</source>
          <target state="translated">Если выражение XPath столбца возвращает значение, отличное от XML (ограниченное строковым, логическим или двойным в XPath 1.0), и столбец имеет тип PostgreSQL, отличный от &lt;code&gt;xml&lt;/code&gt; , столбец будет установлен так, как если бы он назначал строковое представление значения переменной Тип PostgreSQL. (Если значение является логическим, его строковое представление принимается равным &lt;code&gt;1&lt;/code&gt; или &lt;code&gt;0&lt;/code&gt; , если категория типа выходного столбца является числовой, в противном случае - &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="3d86c8d327357d64a90febd0e7b2a64229fc6de1" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-XML value (which is limited to string, boolean, or double in XPath 1.0) and the column has a PostgreSQL type other than &lt;code&gt;xml&lt;/code&gt;, the column will be set as if by assigning the value's string representation to the PostgreSQL type. (If the value is a boolean, its string representation is taken to be &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; if the output column's type category is numeric, otherwise &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd49d82e6f7364358b7e1308125e6548ff45efeb" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-empty set of XML nodes and the column's PostgreSQL type is &lt;code&gt;xml&lt;/code&gt;, the column will be assigned the expression result exactly, if it is of document or content form. &lt;a href=&quot;#ftn.id-1.5.8.19.7.5.14.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.19.7.5.14.2&quot;&gt;[8]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">Если выражение XPath столбца возвращает непустой набор узлов XML, а тип PostgreSQL столбца - &lt;code&gt;xml&lt;/code&gt; , столбцу будет точно назначен результат выражения, если он имеет форму документа или содержимого. &lt;a href=&quot;#ftn.id-1.5.8.19.7.5.14.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.19.7.5.14.2&quot;&gt;[8]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f606ba5da3ce72a5b48e1fa0637f31121b0521b" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-empty set of XML nodes and the column's PostgreSQL type is &lt;code&gt;xml&lt;/code&gt;, the column will be assigned the expression result exactly, if it is of document or content form. &lt;a href=&quot;#ftn.id-1.5.8.21.7.5.15.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.21.7.5.15.2&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2001ae15ca417e0e9b4706925c6ddabecd8102f7" translate="yes" xml:space="preserve">
          <source>If a conflicting row has been inserted by an as-yet-uncommitted transaction, the would-be inserter must wait to see if that transaction commits. If it rolls back then there is no conflict. If it commits without deleting the conflicting row again, there is a uniqueness violation. (In practice we just wait for the other transaction to end and then redo the visibility check in toto.)</source>
          <target state="translated">Если конфликтующая строка была вставлена транзакцией as-yet-uncommitted,будущий вставщик должен дождаться фиксации этой транзакции.Если она откатится назад,то конфликта нет.Если она совершает ошибку,не удаляя конфликтующую строку снова,то происходит нарушение уникальности.(На практике мы просто ждем окончания другой транзакции,а затем повторим проверку видимости целиком).</target>
        </trans-unit>
        <trans-unit id="25c5a233f983a5a11d2f0ce26b28af3fbae3c56b" translate="yes" xml:space="preserve">
          <source>If a conflicting valid row has been deleted by the current transaction, it's okay. (In particular, since an UPDATE always deletes the old row version before inserting the new version, this will allow an UPDATE on a row without changing the key.)</source>
          <target state="translated">Если конфликтующая действительная строка была удалена текущей транзакцией,то это нормально (в частности,поскольку UPDATE всегда удаляет старую версию строки перед тем,как вставить новую версию,это позволит UPDATE в строке без изменения ключа).</target>
        </trans-unit>
        <trans-unit id="2370b745676126171b063e2e2d72095b349175fc" translate="yes" xml:space="preserve">
          <source>If a constraint is deferrable, this clause specifies the default time to check the constraint. If the constraint is &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt;, it is checked after each statement. This is the default. If the constraint is &lt;code&gt;INITIALLY DEFERRED&lt;/code&gt;, it is checked only at the end of the transaction. The constraint check time can be altered with the &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; command.</source>
          <target state="translated">Если ограничение можно отложить, в этом предложении указывается время по умолчанию для проверки ограничения. Если ограничение &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt; , оно проверяется после каждого оператора. Это значение по умолчанию. Если ограничение &lt;code&gt;INITIALLY DEFERRED&lt;/code&gt; , оно проверяется только в конце транзакции. Время проверки ограничения можно изменить с помощью команды &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45ddd1496c9c8970f749841790d5cc33a1ed958c" translate="yes" xml:space="preserve">
          <source>If a constraint name is provided then the index will be renamed to match the constraint name. Otherwise the constraint will be named the same as the index.</source>
          <target state="translated">Если задано имя ограничения,то индекс будет переименован в соответствии с именем ограничения.В противном случае ограничение будет названо так же,как и индекс.</target>
        </trans-unit>
        <trans-unit id="516a948273fe630c2fd2d3bb4954b014ec3a728f" translate="yes" xml:space="preserve">
          <source>If a cursor is closed after a savepoint which is later rolled back, the &lt;code&gt;CLOSE&lt;/code&gt; is not rolled back; that is, the cursor remains closed.</source>
          <target state="translated">Если курсор закрывается после точки сохранения, которая позже откатывается, &lt;code&gt;CLOSE&lt;/code&gt; не откатывается; то есть курсор остается закрытым.</target>
        </trans-unit>
        <trans-unit id="6755c4a78a3da118c77dadc78bfef40de55f4e2d" translate="yes" xml:space="preserve">
          <source>If a daylight-savings abbreviation is given but the transition &lt;code&gt;rule&lt;/code&gt; field is omitted, the fallback behavior is to use the rule &lt;code&gt;M3.2.0,M11.1.0&lt;/code&gt;, which corresponds to USA practice as of 2020 (that is, spring forward on the second Sunday of March, fall back on the first Sunday of November, both transitions occurring at 2AM prevailing time). Note that this rule does not give correct USA transition dates for years before 2007.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8ad01bd9eefe5ae6504ee533b29e5940a9bbcc" translate="yes" xml:space="preserve">
          <source>If a different escape character than backslash is desired, it can be specified using the &lt;code&gt;UESCAPE&lt;/code&gt; clause after the string, for example:</source>
          <target state="translated">Если требуется другой escape-символ, чем обратная косая черта, его можно указать с &lt;code&gt;UESCAPE&lt;/code&gt; предложения UESCAPE после строки, например:</target>
        </trans-unit>
        <trans-unit id="8c0e309df60d6b04409ae8154560e144f149154e" translate="yes" xml:space="preserve">
          <source>If a dynamically loadable module needs to be opened and the file name specified in the &lt;code&gt;CREATE FUNCTION&lt;/code&gt; or &lt;code&gt;LOAD&lt;/code&gt; command does not have a directory component (i.e., the name does not contain a slash), the system will search this path for the required file.</source>
          <target state="translated">Если необходимо открыть динамически загружаемый модуль, а имя файла, указанное в командах &lt;code&gt;CREATE FUNCTION&lt;/code&gt; или &lt;code&gt;LOAD&lt;/code&gt; , не имеет компонента каталога (т. Е. Имя не содержит косой черты), система будет искать нужный файл по этому пути.</target>
        </trans-unit>
        <trans-unit id="eead72d18dc8bb550762010fb49abdc92926fc22" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for FK = FK comparisons</source>
          <target state="translated">Если иностранный ключ,список операторов равенства для FK=FK сравнений</target>
        </trans-unit>
        <trans-unit id="f2557ac45b6d34f20af024d349a08e662002e006" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for PK = FK comparisons</source>
          <target state="translated">Если посторонний ключ,список операторов равенства для PK=FK сравнений</target>
        </trans-unit>
        <trans-unit id="65b7a7238de39c08afb78813e4651af5cc557847" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for PK = PK comparisons</source>
          <target state="translated">Если посторонний ключ,список операторов равенства для PK=PK сравнений</target>
        </trans-unit>
        <trans-unit id="84b58f81bb95714e62ab14756a76120d62320f41" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the referenced columns</source>
          <target state="translated">Если иностранный ключ,то список ссылочных колонок</target>
        </trans-unit>
        <trans-unit id="7870e560cb55fb3708abcfcfa26fc2aa507576ee" translate="yes" xml:space="preserve">
          <source>If a foreign key, the referenced table; else 0</source>
          <target state="translated">Если посторонний ключ,то таблица со ссылками;в противном случае 0</target>
        </trans-unit>
        <trans-unit id="575611ec6feb49c10dfac57d786d3e40ac55a75b" translate="yes" xml:space="preserve">
          <source>If a fractional value is specified with a unit, it will be rounded to a multiple of the next smaller unit if there is one. For example, &lt;code&gt;30.1 GB&lt;/code&gt; will be converted to &lt;code&gt;30822 MB&lt;/code&gt; not &lt;code&gt;32319628902 B&lt;/code&gt;. If the parameter is of integer type, a final rounding to integer occurs after any unit conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302fc67ef061c10f65906072775cc6ba157a3bf8" translate="yes" xml:space="preserve">
          <source>If a fractional value is specified with a unit, it will be rounded to a multiple of the next smaller unit if there is one. For example, &lt;code&gt;30.1 GB&lt;/code&gt; will be converted to &lt;code&gt;30822 MB&lt;/code&gt; not &lt;code&gt;32319628902 B&lt;/code&gt;. If the parameter is of integer type, a final rounding to integer occurs after any units conversion.</source>
          <target state="translated">Если дробное значение указано с единицей измерения, оно будет округлено до числа, кратного следующей меньшей единице, если таковая имеется. Например, &lt;code&gt;30.1 GB&lt;/code&gt; будут преобразованы в &lt;code&gt;30822 MB&lt;/code&gt; не &lt;code&gt;32319628902 B&lt;/code&gt; . Если параметр имеет целочисленный тип, окончательное округление до целого происходит после любого преобразования единиц.</target>
        </trans-unit>
        <trans-unit id="16517351d5f6d1324d494a56b7cbc1349aadbd26" translate="yes" xml:space="preserve">
          <source>If a function executed within a parallel worker acquires locks which are not held by the leader, for example by querying a table not referenced in the query, those locks will be released at worker exit, not end of transaction. If you write a function which does this, and this behavior difference is important to you, mark such functions as &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; to ensure that they execute only in the leader.</source>
          <target state="translated">Если функция, выполняемая в параллельном работнике, получает блокировки, которые не удерживаются лидером, например, запрашивая таблицу, не указанную в запросе, эти блокировки будут сняты при выходе рабочего, а не в конце транзакции. Если вы пишете функцию, которая делает это, и эта разница в поведении важна для вас, отметьте такие функции как &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; чтобы гарантировать, что они выполняются только в лидере.</target>
        </trans-unit>
        <trans-unit id="c08af80c4ec0b88bc818f2eba0deaa5cfe1fa698" translate="yes" xml:space="preserve">
          <source>If a function is declared &lt;code&gt;STRICT&lt;/code&gt; with a &lt;code&gt;VARIADIC&lt;/code&gt; argument, the strictness check tests that the variadic array &lt;em&gt;as a whole&lt;/em&gt; is non-null. The function will still be called if the array has null elements.</source>
          <target state="translated">Если функция объявляется &lt;code&gt;STRICT&lt;/code&gt; с аргументом &lt;code&gt;VARIADIC&lt;/code&gt; , проверка строгости проверяет, что массив переменных &lt;em&gt;в целом не&lt;/em&gt; равен нулю. Функция все равно будет вызываться, если в массиве есть нулевые элементы.</target>
        </trans-unit>
        <trans-unit id="3d9a8948caa2988125e4b727f3b2df8159e037f5" translate="yes" xml:space="preserve">
          <source>If a function is declared with a &lt;code&gt;VARIADIC&lt;/code&gt; array parameter, and the call does not use the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, then the function is treated as if the array parameter were replaced by one or more occurrences of its element type, as needed to match the call. After such expansion the function might have effective argument types identical to some non-variadic function. In that case the function appearing earlier in the search path is used, or if the two functions are in the same schema, the non-variadic one is preferred.</source>
          <target state="translated">Если функция объявляется с параметром массива &lt;code&gt;VARIADIC&lt;/code&gt; , а в вызове не используется ключевое слово &lt;code&gt;VARIADIC&lt;/code&gt; , то функция обрабатывается так, как если бы параметр массива был заменен одним или несколькими экземплярами своего типа элемента, необходимыми для соответствия вызову. После такого расширения функция может иметь эффективные типы аргументов, идентичные некоторой невариадной функции. В этом случае используется функция, появившаяся ранее в пути поиска, или, если две функции находятся в одной схеме, предпочтительнее не вариативная.</target>
        </trans-unit>
        <trans-unit id="29873e6b07ca3d965e9bf60280fc04e4b50e061e" translate="yes" xml:space="preserve">
          <source>If a generic plan is in use, it will contain parameter symbols &lt;code&gt;$n&lt;/code&gt;, while a custom plan will have the supplied parameter values substituted into it.</source>
          <target state="translated">Если используется общий план, он будет содержать символы параметров &lt;code&gt;$n&lt;/code&gt; , а в настраиваемый план будут подставлены значения параметров.</target>
        </trans-unit>
        <trans-unit id="b9eddb833bc9b9e1959393e089ee3b45e63b93cb" translate="yes" xml:space="preserve">
          <source>If a host name is specified (anything that is not an IP address range or a special key word is treated as a host name), that name is compared with the result of a reverse name resolution of the client's IP address (e.g., reverse DNS lookup, if DNS is used). Host name comparisons are case insensitive. If there is a match, then a forward name resolution (e.g., forward DNS lookup) is performed on the host name to check whether any of the addresses it resolves to are equal to the client's IP address. If both directions match, then the entry is considered to match. (The host name that is used in &lt;code&gt;pg_hba.conf&lt;/code&gt; should be the one that address-to-name resolution of the client's IP address returns, otherwise the line won't be matched. Some host name databases allow associating an IP address with multiple host names, but the operating system will only return one host name when asked to resolve an IP address.)</source>
          <target state="translated">Если указано имя хоста (все, что не является диапазоном IP-адресов или специальным ключевым словом, рассматривается как имя хоста), это имя сравнивается с результатом обратного разрешения имени IP-адреса клиента (например, обратный DNS поиск, если используется DNS). При сравнении имен хостов регистр не учитывается. Если есть совпадение, то для имени хоста выполняется прямое разрешение имени (например, прямой DNS-поиск), чтобы проверить, равен ли какой-либо из адресов, которые он разрешает, IP-адресу клиента. Если оба направления совпадают, запись считается совпадающей. (Имя хоста, которое используется в &lt;code&gt;pg_hba.conf&lt;/code&gt; должен быть тем, который возвращает преобразование адреса в имя IP-адреса клиента, иначе строка не будет сопоставлена. Некоторые базы данных имен хостов позволяют связывать IP-адрес с несколькими именами хостов, но операционная система будет возвращать только одно имя хоста при запросе на разрешение IP-адреса.)</target>
        </trans-unit>
        <trans-unit id="29821b670fa593b8c5ed4db6b848a4180ea0c1c3" translate="yes" xml:space="preserve">
          <source>If a limit count is given, no more than that many rows will be returned (but possibly fewer, if the query itself yields fewer rows). &lt;code&gt;LIMIT ALL&lt;/code&gt; is the same as omitting the &lt;code&gt;LIMIT&lt;/code&gt; clause, as is &lt;code&gt;LIMIT&lt;/code&gt; with a NULL argument.</source>
          <target state="translated">Если задано предельное количество строк, будет возвращено не более этого количества строк (но, возможно, меньше, если сам запрос дает меньше строк). &lt;code&gt;LIMIT ALL&lt;/code&gt; - это то же самое, что и без предложения &lt;code&gt;LIMIT&lt;/code&gt; , и &lt;code&gt;LIMIT&lt;/code&gt; с аргументом NULL.</target>
        </trans-unit>
        <trans-unit id="2e0f012a9c847bea5735587a0a262fd8fc04fc30" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the file or query buffer. Note that if a single all-digits argument is given, psql assumes it is a line number, not a file name.</source>
          <target state="translated">Если указан номер строки,то psql поместит курсор на указанную строку файла или буфера запроса.Обратите внимание,что если задан единственный всезначный аргумент,psql предполагает,что это номер строки,а не имя файла.</target>
        </trans-unit>
        <trans-unit id="989ad942cdac74f48ff0f663910b668e0bfcd851" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the function body. (Note that the function body typically does not begin on the first line of the file.)</source>
          <target state="translated">Если указан номер строки,то psql поместит курсор на указанную строку тела функции.(Обратите внимание,что тело функции обычно не начинается в первой строке файла).</target>
        </trans-unit>
        <trans-unit id="f28240e112ab05b43febc5915be398cc2c0ace7d" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the view definition.</source>
          <target state="translated">Если указан номер строки,то psql поместит курсор на указанную строку определения представления.</target>
        </trans-unit>
        <trans-unit id="e1603d0c375b802bfd8ff93da28473ffff6f9ce0" translate="yes" xml:space="preserve">
          <source>If a list of columns is specified, &lt;code&gt;COPY&lt;/code&gt; will only copy the data in the specified columns to or from the file. If there are any columns in the table that are not in the column list, &lt;code&gt;COPY FROM&lt;/code&gt; will insert the default values for those columns.</source>
          <target state="translated">Если указан список столбцов, &lt;code&gt;COPY&lt;/code&gt; будет копировать только данные из указанных столбцов в файл или из файла. Если в таблице есть столбцы, которых нет в списке столбцов, &lt;code&gt;COPY FROM&lt;/code&gt; вставит значения по умолчанию для этих столбцов.</target>
        </trans-unit>
        <trans-unit id="5d76d1bc7bed56c879e14e369962729e0bb7fe98" translate="yes" xml:space="preserve">
          <source>If a new child node must be added, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgAddNode&lt;/code&gt;. Set &lt;code&gt;nodeLabel&lt;/code&gt; to the label to be used for the new node, and set &lt;code&gt;nodeN&lt;/code&gt; to the index (from zero) at which to insert the node in the node array. After the node has been added, the &lt;code&gt;choose&lt;/code&gt; function will be called again with the modified inner tuple; that call should result in an &lt;code&gt;spgMatchNode&lt;/code&gt; result.</source>
          <target state="translated">Если необходимо добавить новый дочерний узел, установите для &lt;code&gt;resultType&lt;/code&gt; значение &lt;code&gt;spgAddNode&lt;/code&gt; . Задайте для &lt;code&gt;nodeLabel&lt;/code&gt; метку, которая будет использоваться для нового узла, и установите для &lt;code&gt;nodeN&lt;/code&gt; индекс (от нуля), в который нужно вставить узел в массив узлов. После добавления узла функция &lt;code&gt;choose&lt;/code&gt; будет вызвана снова с измененным внутренним кортежем; этот вызов должен привести к результату &lt;code&gt;spgMatchNode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="342f14a4cf8cecaaec4f439a2239828717657aec" translate="yes" xml:space="preserve">
          <source>If a parent column is a generated column, a child column must also be a generated column using the same expression. In the definition of the child column, leave off the &lt;code&gt;GENERATED&lt;/code&gt; clause, as it will be copied from the parent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7892c6f8a458e96e3334e518119041320e0ca8" translate="yes" xml:space="preserve">
          <source>If a parent column is not a generated column, a child column may be defined to be a generated column or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c9e178ba05d52398d348d0978c9f0904579a20" translate="yes" xml:space="preserve">
          <source>If a part of the plan guarantees an ordering on a prefix of the required sort keys, then the planner may instead decide to use an &lt;code&gt;incremental sort&lt;/code&gt; step:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01753c01a634660c1afc91855a2bf3e6c0a24915" translate="yes" xml:space="preserve">
          <source>If a problem arises while rebuilding the indexes, such as a uniqueness violation in a unique index, the &lt;code&gt;REINDEX&lt;/code&gt; command will fail but leave behind an &amp;ldquo;invalid&amp;rdquo; new index in addition to the pre-existing one. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. The psql &lt;code&gt;\d&lt;/code&gt; command will report such an index as &lt;code&gt;INVALID&lt;/code&gt;:</source>
          <target state="translated">Если при перестроении индексов возникает проблема, такая как нарушение уникальности в уникальном индексе, команда &lt;code&gt;REINDEX&lt;/code&gt; завершится ошибкой, но оставит &amp;laquo;недействительный&amp;raquo; новый индекс в дополнение к ранее существовавшему. Этот индекс будет проигнорирован для запросов, потому что он может быть неполным; однако он по-прежнему будет потреблять накладные расходы на обновление. Команда psql &lt;code&gt;\d&lt;/code&gt; сообщит о таком индексе как &lt;code&gt;INVALID&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fc2fcf347772c27798939c43c378ac44b8d079f9" translate="yes" xml:space="preserve">
          <source>If a problem arises while scanning the table, such as a deadlock or a uniqueness violation in a unique index, the &lt;code&gt;CREATE INDEX&lt;/code&gt; command will fail but leave behind an &amp;ldquo;invalid&amp;rdquo; index. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. The psql &lt;code&gt;\d&lt;/code&gt; command will report such an index as &lt;code&gt;INVALID&lt;/code&gt;:</source>
          <target state="translated">Если при сканировании таблицы возникает проблема, такая как взаимоблокировка или нарушение уникальности в уникальном индексе, команда &lt;code&gt;CREATE INDEX&lt;/code&gt; завершится ошибкой, но оставит &amp;laquo;недействительный&amp;raquo; индекс. Этот индекс будет проигнорирован для запросов, потому что он может быть неполным; однако он по-прежнему будет потреблять накладные расходы на обновление. Команда psql &lt;code&gt;\d&lt;/code&gt; сообщит о таком индексе как &lt;code&gt;INVALID&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="60b7f8c376b0c316858e3c03acae729e9e8e0bbd" translate="yes" xml:space="preserve">
          <source>If a problem like this arises, it may not affect each individual index that is ordered using an affected collation, simply because &lt;em&gt;indexed&lt;/em&gt; values might happen to have the same absolute ordering regardless of the behavioral inconsistency. See &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt; and &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt; for further details about how PostgreSQL uses operating system locales and collations.</source>
          <target state="translated">Если возникает такая проблема, она не может повлиять на каждый отдельный индекс, упорядоченный с использованием затронутого сопоставления, просто потому, что &lt;em&gt;индексированные&lt;/em&gt; значения могут иметь одинаковый абсолютный порядок независимо от поведенческой несогласованности. См. &lt;a href=&quot;locale&quot;&gt;Раздел 23.1&lt;/a&gt; и &lt;a href=&quot;collation&quot;&gt;Раздел 23.2&lt;/a&gt; для получения дополнительной информации о том, как PostgreSQL использует локали и сопоставления операционных систем.</target>
        </trans-unit>
        <trans-unit id="14159bc71155b473a106589680a4763fc75cdf28" translate="yes" xml:space="preserve">
          <source>If a query contains aggregate function calls, but no &lt;code&gt;GROUP BY&lt;/code&gt; clause, grouping still occurs: the result is a single group row (or perhaps no rows at all, if the single row is then eliminated by &lt;code&gt;HAVING&lt;/code&gt;). The same is true if it contains a &lt;code&gt;HAVING&lt;/code&gt; clause, even without any aggregate function calls or &lt;code&gt;GROUP BY&lt;/code&gt; clause.</source>
          <target state="translated">Если запрос содержит вызовы агрегатных функций, но не содержит предложения &lt;code&gt;GROUP BY&lt;/code&gt; , группировка все равно происходит: результатом является одна групповая строка (или, возможно, никаких строк, если эта единственная строка затем &lt;code&gt;HAVING&lt;/code&gt; ). То же самое верно, если он содержит предложение &lt;code&gt;HAVING&lt;/code&gt; , даже без каких-либо вызовов агрегированных функций или предложения &lt;code&gt;GROUP BY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2704031f22c0864166ff4a01e062f291652c11" translate="yes" xml:space="preserve">
          <source>If a query that is expected to do so does not produce a parallel plan, you can try reducing &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost&lt;/a&gt;. Of course, this plan may turn out to be slower than the serial plan which the planner preferred, but this will not always be the case. If you don't get a parallel plan even with very small values of these settings (e.g. after setting them both to zero), there may be some reason why the query planner is unable to generate a parallel plan for your query. See &lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;Section 15.2&lt;/a&gt; and &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt; for information on why this may be the case.</source>
          <target state="translated">Если ожидаемый запрос не дает параллельного плана, вы можете попробовать уменьшить &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt; или &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost&lt;/a&gt; . Конечно, этот план может оказаться более медленным, чем последовательный план, который предпочитал планировщик, но это не всегда так. Если вы не получаете параллельный план даже при очень малых значениях этих параметров (например, после установки их обоих в ноль), может быть какая-то причина, по которой планировщик запросов не может создать параллельный план для вашего запроса. См. &lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;Раздел 15.2&lt;/a&gt; и &lt;a href=&quot;parallel-safety&quot;&gt;Раздел 15.4&lt;/a&gt; для получения информации о том, почему это может быть так.</target>
        </trans-unit>
        <trans-unit id="e703ec1af7c6fe8daa3820fdcecb57bac64cdaff" translate="yes" xml:space="preserve">
          <source>If a query that is expected to do so does not produce a parallel plan, you can try reducing &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost&lt;/a&gt;. Of course, this plan may turn out to be slower than the serial plan which the planner preferred, but this will not always be the case. If you don't get a parallel plan even with very small values of these settings (e.g., after setting them both to zero), there may be some reason why the query planner is unable to generate a parallel plan for your query. See &lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;Section 15.2&lt;/a&gt; and &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt; for information on why this may be the case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78bc381604777d833daa7f8a441adef31412d42" translate="yes" xml:space="preserve">
          <source>If a query's results do not fit on the screen, they are piped through this command. Typical values are &lt;code&gt;more&lt;/code&gt; or &lt;code&gt;less&lt;/code&gt;. Use of the pager can be disabled by setting &lt;code&gt;PSQL_PAGER&lt;/code&gt; or &lt;code&gt;PAGER&lt;/code&gt; to an empty string, or by adjusting the pager-related options of the &lt;code&gt;\pset&lt;/code&gt; command. These variables are examined in the order listed; the first that is set is used. If none of them is set, the default is to use &lt;code&gt;more&lt;/code&gt; on most platforms, but &lt;code&gt;less&lt;/code&gt; on Cygwin.</source>
          <target state="translated">Если результаты запроса не помещаются на экране, они передаются через эту команду. Типичные значения &lt;code&gt;more&lt;/code&gt; или &lt;code&gt;less&lt;/code&gt; . Использование пейджера можно отключить, установив для &lt;code&gt;PSQL_PAGER&lt;/code&gt; или &lt;code&gt;PAGER&lt;/code&gt; пустую строку или изменив связанные с пейджером параметры команды &lt;code&gt;\pset&lt;/code&gt; . Эти переменные проверяются в указанном порядке; используется первый установленный. Если ни один из них не установлен, по умолчанию используется &lt;code&gt;more&lt;/code&gt; на большинстве платформ, но &lt;code&gt;less&lt;/code&gt; на Cygwin.</target>
        </trans-unit>
        <trans-unit id="3a16d1e24e65d591a8270e12d2132334cb1a5266" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE AGGREGATE myschema.myagg ...&lt;/code&gt;) then the aggregate function is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">Если указано имя схемы (например, &lt;code&gt;CREATE AGGREGATE myschema.myagg ...&lt;/code&gt; ), то агрегатная функция создается в указанной схеме. В противном случае он создается в текущей схеме.</target>
        </trans-unit>
        <trans-unit id="9221069e2f8158080f0dab328adf9a4fc4ac50a4" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE DOMAIN myschema.mydomain ...&lt;/code&gt;) then the domain is created in the specified schema. Otherwise it is created in the current schema. The domain name must be unique among the types and domains existing in its schema.</source>
          <target state="translated">Если указано имя схемы (например, &lt;code&gt;CREATE DOMAIN myschema.mydomain ...&lt;/code&gt; ), то домен создается в указанной схеме. В противном случае он создается в текущей схеме. Доменное имя должно быть уникальным среди типов и доменов, существующих в его схеме.</target>
        </trans-unit>
        <trans-unit id="2b01ea3ef0736036d56ce2802cb7af1e7ac1551f" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE FOREIGN TABLE myschema.mytable ...&lt;/code&gt;) then the table is created in the specified schema. Otherwise it is created in the current schema. The name of the foreign table must be distinct from the name of any other foreign table, table, sequence, index, view, or materialized view in the same schema.</source>
          <target state="translated">Если указано имя схемы (например, &lt;code&gt;CREATE FOREIGN TABLE myschema.mytable ...&lt;/code&gt; ), то таблица создается в указанной схеме. В противном случае он создается в текущей схеме. Имя внешней таблицы должно отличаться от имени любой другой внешней таблицы, таблицы, последовательности, индекса, представления или материализованного представления в той же схеме.</target>
        </trans-unit>
        <trans-unit id="0017dfefecb7c7d878ccd99cec2c2243eb08f548" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE STATISTICS myschema.mystat ...&lt;/code&gt;) then the statistics object is created in the specified schema. Otherwise it is created in the current schema. The name of the statistics object must be distinct from the name of any other statistics object in the same schema.</source>
          <target state="translated">Если указано имя схемы (например, &lt;code&gt;CREATE STATISTICS myschema.mystat ...&lt;/code&gt; ), то объект статистики создается в указанной схеме. В противном случае он создается в текущей схеме. Имя объекта статистики должно отличаться от имени любого другого объекта статистики в той же схеме.</target>
        </trans-unit>
        <trans-unit id="d358a0109b0b0aa95ca587460e4392925dac3d64" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE TABLE myschema.mytable ...&lt;/code&gt;) then the table is created in the specified schema. Otherwise it is created in the current schema. Temporary tables exist in a special schema, so a schema name cannot be given when creating a temporary table. The name of the table must be distinct from the name of any other table, sequence, index, view, or foreign table in the same schema.</source>
          <target state="translated">Если указано имя схемы (например, &lt;code&gt;CREATE TABLE myschema.mytable ...&lt;/code&gt; ), то таблица создается в указанной схеме. В противном случае он создается в текущей схеме. Временные таблицы существуют в специальной схеме, поэтому имя схемы нельзя указать при создании временной таблицы. Имя таблицы должно отличаться от имени любой другой таблицы, последовательности, индекса, представления или сторонней таблицы в той же схеме.</target>
        </trans-unit>
        <trans-unit id="93459b6de8914138c246c45451309801fa4eb75b" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE VIEW myschema.myview ...&lt;/code&gt;) then the view is created in the specified schema. Otherwise it is created in the current schema. Temporary views exist in a special schema, so a schema name cannot be given when creating a temporary view. The name of the view must be distinct from the name of any other view, table, sequence, index or foreign table in the same schema.</source>
          <target state="translated">Если указано имя схемы (например, &lt;code&gt;CREATE VIEW myschema.myview ...&lt;/code&gt; ), то представление создается в указанной схеме. В противном случае он создается в текущей схеме. Временные представления существуют в специальной схеме, поэтому имя схемы нельзя указать при создании временного представления. Имя представления должно отличаться от имени любого другого представления, таблицы, последовательности, индекса или сторонней таблицы в той же схеме.</target>
        </trans-unit>
        <trans-unit id="f45727194d879f2673b515b0704bca00c0cdc2be" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the operator class is created in the specified schema. Otherwise it is created in the current schema. Two operator classes in the same schema can have the same name only if they are for different index methods.</source>
          <target state="translated">Если задано имя схемы,то в указанной схеме создается класс оператора.В противном случае он создается в текущей схеме.Два класса операторов в одной схеме могут иметь одно и то же имя только в том случае,если они предназначены для разных методов индексации.</target>
        </trans-unit>
        <trans-unit id="924ee280ad5b0efe3a03d3f74bd950473afe0d2b" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the operator family is created in the specified schema. Otherwise it is created in the current schema. Two operator families in the same schema can have the same name only if they are for different index methods.</source>
          <target state="translated">Если задано имя схемы,то в указанной схеме создается семейство операторов.В противном случае оно создается в текущей схеме.Два семейства операторов в одной схеме могут иметь одно и то же имя только в том случае,если они предназначены для разных методов индексации.</target>
        </trans-unit>
        <trans-unit id="d43b98c46599ec5632b8b68a4c4aec5bc7c49e45" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the sequence is created in the specified schema. Otherwise it is created in the current schema. Temporary sequences exist in a special schema, so a schema name cannot be given when creating a temporary sequence. The sequence name must be distinct from the name of any other sequence, table, index, view, or foreign table in the same schema.</source>
          <target state="translated">Если задано имя схемы,то последовательность создается в указанной схеме.В противном случае она создается в текущей схеме.Временные последовательности существуют в специальной схеме,поэтому имя схемы не может быть задано при создании временной последовательности.Имя последовательности должно отличаться от имени любой другой последовательности,таблицы,индекса,представления или посторонней таблицы в той же схеме.</target>
        </trans-unit>
        <trans-unit id="d3a817f61150e098cf1b32f5797358f478896c39" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search configuration is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">Если задано имя схемы,то в указанной схеме создается текстовая конфигурация поиска.В противном случае она создается в текущей схеме.</target>
        </trans-unit>
        <trans-unit id="6aa5bd7767ed3e5d5d615c990a382ab4eccb349b" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search dictionary is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">Если задано имя схемы,то в указанной схеме создается текстовый поисковый словарь.В противном случае он создается в текущей схеме.</target>
        </trans-unit>
        <trans-unit id="3f275ed3d77d7d07fbadd2aeff95331926c88b60" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search parser is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">Если задано имя схемы,то в указанной схеме создается текстовый поисковый парсер.В противном случае он создается в текущей схеме.</target>
        </trans-unit>
        <trans-unit id="c90f2803121a2139271a7f1f2ab6d88702071162" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search template is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">Если задано имя схемы,то в указанной схеме создается текстовый шаблон поиска.В противном случае он создается в текущей схеме.</target>
        </trans-unit>
        <trans-unit id="3f1b270e2011c6de6a6609606ad6c64491399611" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the type is created in the specified schema. Otherwise it is created in the current schema. The type name must be distinct from the name of any existing type or domain in the same schema. (Because tables have associated data types, the type name must also be distinct from the name of any existing table in the same schema.)</source>
          <target state="translated">Если дается имя схемы,то тип создается в указанной схеме.В противном случае он создается в текущей схеме.Имя типа должно отличаться от имени любого существующего типа или домена в одной схеме.(Поскольку таблицы имеют ассоциированные типы данных,имя типа также должно отличаться от имени любой существующей таблицы в той же схеме).</target>
        </trans-unit>
        <trans-unit id="3270e8102f1d16bb2969879cc26ff629f7438593" translate="yes" xml:space="preserve">
          <source>If a schema name is included, then the function is created in the specified schema. Otherwise it is created in the current schema. The name of the new function must not match any existing function or procedure with the same input argument types in the same schema. However, functions and procedures of different argument types can share a name (this is called &lt;em&gt;overloading&lt;/em&gt;).</source>
          <target state="translated">Если имя схемы включено, функция создается в указанной схеме. В противном случае он создается в текущей схеме. Имя новой функции не должно совпадать с какой-либо существующей функцией или процедурой с такими же типами входных аргументов в той же схеме. Однако функции и процедуры с разными типами аргументов могут иметь одно имя (это называется &lt;em&gt;перегрузкой&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="fa9f9c34f552135ee16bf0e254ac4f8936e929d0" translate="yes" xml:space="preserve">
          <source>If a schema name is included, then the procedure is created in the specified schema. Otherwise it is created in the current schema. The name of the new procedure must not match any existing procedure or function with the same input argument types in the same schema. However, procedures and functions of different argument types can share a name (this is called &lt;em&gt;overloading&lt;/em&gt;).</source>
          <target state="translated">Если имя схемы включено, то процедура создается в указанной схеме. В противном случае он создается в текущей схеме. Имя новой процедуры не должно совпадать с какой-либо существующей процедурой или функцией с такими же типами входных аргументов в той же схеме. Однако процедуры и функции с разными типами аргументов могут иметь одно имя (это называется &lt;em&gt;перегрузкой&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="dacc047d6b80f30af4e1b3c075ae268658bf910d" translate="yes" xml:space="preserve">
          <source>If a separate session key is requested, a new random key will be generated. Otherwise the S2K key will be used directly as the session key.</source>
          <target state="translated">При запросе отдельного ключа сессии будет сгенерирован новый случайный ключ.В противном случае ключ S2K будет использоваться непосредственно в качестве ключа сессии.</target>
        </trans-unit>
        <trans-unit id="5829673b8ac4bdf9ef5ccbb615c82963b07e7a46" translate="yes" xml:space="preserve">
          <source>If a sequence object has been created with default parameters, successive &lt;code&gt;nextval&lt;/code&gt; calls will return successive values beginning with 1. Other behaviors can be obtained by using special parameters in the &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; command; see its command reference page for more information.</source>
          <target state="translated">Если объект последовательности был создан с параметрами по умолчанию, последовательные вызовы &lt;code&gt;nextval&lt;/code&gt; будут возвращать последовательные значения, начинающиеся с 1. Другие варианты поведения могут быть получены с помощью специальных параметров в команде &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; ; см. страницу справки по командам для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="f45a6ad1ab211a977ca7a8e8006108f711740038" translate="yes" xml:space="preserve">
          <source>If a subscription is associated with a replication slot, then &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">Если подписка связана со слотом репликации, то &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; не может выполняться внутри блока транзакции.</target>
        </trans-unit>
        <trans-unit id="4fefee0e29f8ef757e65c2ca97914e54656fff0f" translate="yes" xml:space="preserve">
          <source>If a superuser chooses to issue a &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; command, the command is performed as though it were issued by the owner of the affected object. In particular, privileges granted via such a command will appear to have been granted by the object owner. (For role membership, the membership appears to have been granted by the containing role itself.)</source>
          <target state="translated">Если суперпользователь выбирает команду &lt;code&gt;GRANT&lt;/code&gt; или &lt;code&gt;REVOKE&lt;/code&gt; , команда выполняется так, как если бы она была выдана владельцем затронутого объекта. В частности, привилегии, предоставленные с помощью такой команды, будут казаться предоставленными владельцем объекта. (Для членства в роли членство, похоже, было предоставлено самой содержащей ролью.)</target>
        </trans-unit>
        <trans-unit id="bdba0ac2d184c2c84f2cf4f8d54b0cd35c6bae22" translate="yes" xml:space="preserve">
          <source>If a superuser chooses to issue a &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; command, the command is performed as though it were issued by the owner of the affected object. Since all privileges ultimately come from the object owner (possibly indirectly via chains of grant options), it is possible for a superuser to revoke all privileges, but this might require use of &lt;code&gt;CASCADE&lt;/code&gt; as stated above.</source>
          <target state="translated">Если суперпользователь выбирает команду &lt;code&gt;GRANT&lt;/code&gt; или &lt;code&gt;REVOKE&lt;/code&gt; , команда выполняется так, как если бы она была выдана владельцем затронутого объекта. Поскольку все привилегии в конечном итоге исходят от владельца объекта (возможно, косвенно через цепочки параметров предоставления), суперпользователь может отозвать все привилегии, но для этого может потребоваться использование &lt;code&gt;CASCADE&lt;/code&gt; , как указано выше.</target>
        </trans-unit>
        <trans-unit id="3105c963db998b17d895e80efc90a4f3ec29f6b5" translate="yes" xml:space="preserve">
          <source>If a table constraint (including foreign keys, but not constraint triggers), list of the constrained columns</source>
          <target state="translated">Если ограничение таблицы (включая инородные ключи,но не ограничивающие)срабатывает,то список ограниченных столбцов</target>
        </trans-unit>
        <trans-unit id="d9d8db43e6826c95f740877ac4ab55e53bc6727a" translate="yes" xml:space="preserve">
          <source>If a table has any descendant tables, it is not permitted to add, rename, or change the type of a column in the parent table without doing the same to the descendants. This ensures that the descendants always have columns matching the parent. Similarly, a &lt;code&gt;CHECK&lt;/code&gt; constraint cannot be renamed in the parent without also renaming it in all descendants, so that &lt;code&gt;CHECK&lt;/code&gt; constraints also match between the parent and its descendants. (That restriction does not apply to index-based constraints, however.) Also, because selecting from the parent also selects from its descendants, a constraint on the parent cannot be marked valid unless it is also marked valid for those descendants. In all of these cases, &lt;code&gt;ALTER TABLE ONLY&lt;/code&gt; will be rejected.</source>
          <target state="translated">Если у таблицы есть какие-либо дочерние таблицы, не разрешается добавлять, переименовывать или изменять тип столбца в родительской таблице, не делая то же самое с потомками. Это гарантирует, что у потомков всегда будут столбцы, соответствующие родительскому. Точно так же ограничение &lt;code&gt;CHECK&lt;/code&gt; не может быть переименовано в родительском элементе, не переименовав его во всех потомках, так что ограничения &lt;code&gt;CHECK&lt;/code&gt; также совпадают между родительским элементом и его потомками. (Однако это ограничение не применяется к ограничениям на основе индекса.) Кроме того, поскольку выбор из родителя также выбирает из его потомков, ограничение для родителя не может быть помечено как действительное, если оно также не помечено как действительное для этих потомков. Во всех этих случаях &lt;code&gt;ALTER TABLE ONLY&lt;/code&gt; будет отклонен.</target>
        </trans-unit>
        <trans-unit id="f72f4b4a7dd1cbe9511c2732830698755442a3ed" translate="yes" xml:space="preserve">
          <source>If a table has been grouped using &lt;code&gt;GROUP BY&lt;/code&gt;, but only certain groups are of interest, the &lt;code&gt;HAVING&lt;/code&gt; clause can be used, much like a &lt;code&gt;WHERE&lt;/code&gt; clause, to eliminate groups from the result. The syntax is:</source>
          <target state="translated">Если таблица была сгруппирована с помощью &lt;code&gt;GROUP BY&lt;/code&gt; , но интерес представляют только определенные группы, можно использовать предложение &lt;code&gt;HAVING&lt;/code&gt; , как и &lt;code&gt;WHERE&lt;/code&gt; , для исключения групп из результата. Синтаксис:</target>
        </trans-unit>
        <trans-unit id="fd8b65709a6edce92f223fae042df5baecd19362" translate="yes" xml:space="preserve">
          <source>If a tablespace is relocated in this way, the symbolic links inside the main data directory are updated to point to the new location. So the new data directory is ready to be used for a new server instance with all tablespaces in the updated locations.</source>
          <target state="translated">Если табличное пространство перемещается таким образом,то символические ссылки внутри основного каталога данных обновляются для указания на новое местоположение.Таким образом,новый каталог данных готов к использованию для нового экземпляра сервера со всеми табличными пространствами в обновленных местоположениях.</target>
        </trans-unit>
        <trans-unit id="58895429ed60b7ffce3462e3dfc985d5ce11688f" translate="yes" xml:space="preserve">
          <source>If a transaction of this sort is going to change the data in the table, then it should use &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock mode instead of &lt;code&gt;SHARE&lt;/code&gt; mode. This ensures that only one transaction of this type runs at a time. Without this, a deadlock is possible: two transactions might both acquire &lt;code&gt;SHARE&lt;/code&gt; mode, and then be unable to also acquire &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode to actually perform their updates. (Note that a transaction's own locks never conflict, so a transaction can acquire &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode when it holds &lt;code&gt;SHARE&lt;/code&gt; mode &amp;mdash; but not if anyone else holds &lt;code&gt;SHARE&lt;/code&gt; mode.) To avoid deadlocks, make sure all transactions acquire locks on the same objects in the same order, and if multiple lock modes are involved for a single object, then transactions should always acquire the most restrictive mode first.</source>
          <target state="translated">Если транзакция такого типа собирается изменить данные в таблице, то она должна использовать режим блокировки &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; вместо режима &lt;code&gt;SHARE&lt;/code&gt; . Это гарантирует, что одновременно выполняется только одна транзакция этого типа. Без этого возможна взаимоблокировка: обе транзакции могут &lt;code&gt;SHARE&lt;/code&gt; режим SHARE , а затем также не смогут получить режим &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; для фактического выполнения своих обновлений. (Обратите внимание, что собственные блокировки транзакции никогда не конфликтуют, поэтому транзакция может получить режим &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; , когда она поддерживает режим &lt;code&gt;SHARE&lt;/code&gt; , но не, если кто-то другой владеет &lt;code&gt;SHARE&lt;/code&gt; Чтобы избежать взаимоблокировок, убедитесь, что все транзакции устанавливают блокировки для одних и тех же объектов в одном и том же порядке, и если для одного объекта задействовано несколько режимов блокировки, то транзакции всегда должны сначала получать наиболее ограничительный режим.</target>
        </trans-unit>
        <trans-unit id="2d7eb85ea844d2ba5b981dae6af94a75b4526c2e" translate="yes" xml:space="preserve">
          <source>If a user does not have the required privilege on the table or columns, then in many cases the query will ultimately receive a permission-denied error, in which case this mechanism is invisible in practice. But if the user is reading from a security-barrier view, then the planner might wish to check the statistics of an underlying table that is otherwise inaccessible to the user. In that case, the operator should be leak-proof or the statistics will not be used. There is no direct feedback about that, except that the plan might be suboptimal. If one suspects that this is the case, one could try running the query as a more privileged user, to see if a different plan results.</source>
          <target state="translated">Если пользователь не имеет требуемых привилегий на таблице или столбцах,то во многих случаях запрос в конечном итоге получит ошибку с запретом прав,и в этом случае этот механизм невидим на практике.Но если пользователь читает из представления с защитным барьером,то планировщик может захотеть проверить статистику нижележащей таблицы,которая в противном случае будет недоступна пользователю.В этом случае оператор должен быть защищен от утечек,иначе статистика не будет использоваться.Прямой обратной связи по этому поводу нет,за исключением того,что план может быть неоптимальным.Если кто-то заподозрит в этом,то можно попробовать выполнить запрос как более привилегированный пользователь,чтобы посмотреть,получится ли другой план.</target>
        </trans-unit>
        <trans-unit id="6dba31a67ed7f0ca43338760f7f94d591211dfb7" translate="yes" xml:space="preserve">
          <source>If a user holds a privilege with grant option and has granted it to other users then the privileges held by those other users are called dependent privileges. If the privilege or the grant option held by the first user is being revoked and dependent privileges exist, those dependent privileges are also revoked if &lt;code&gt;CASCADE&lt;/code&gt; is specified; if it is not, the revoke action will fail. This recursive revocation only affects privileges that were granted through a chain of users that is traceable to the user that is the subject of this &lt;code&gt;REVOKE&lt;/code&gt; command. Thus, the affected users might effectively keep the privilege if it was also granted through other users.</source>
          <target state="translated">Если пользователь имеет привилегию с опцией предоставления и предоставил ее другим пользователям, то привилегии, которыми обладают эти другие пользователи, называются зависимыми привилегиями. Если привилегия или опция предоставления, принадлежащая первому пользователю, аннулируется и зависимые привилегии существуют, эти зависимые привилегии также аннулируются, если указан &lt;code&gt;CASCADE&lt;/code&gt; ; в противном случае действие отзыва не будет выполнено. Этот рекурсивный отзыв влияет только на привилегии, которые были предоставлены через цепочку пользователей, которая прослеживается до пользователя, являющегося субъектом этой команды &lt;code&gt;REVOKE&lt;/code&gt; . Таким образом, затронутые пользователи могут эффективно сохранить привилегию, если она также была предоставлена ​​другими пользователями.</target>
        </trans-unit>
        <trans-unit id="bd5f3c1cab021783ead43914fa444508c73ceec6" translate="yes" xml:space="preserve">
          <source>If a zero byte (&lt;code&gt;''&lt;/code&gt;), then not a generated column. Otherwise, &lt;code&gt;s&lt;/code&gt; = stored. (Other values might be added in the future.)</source>
          <target state="translated">Если нулевой байт ( &lt;code&gt;''&lt;/code&gt; ), то не сгенерированный столбец. В противном случае &lt;code&gt;s&lt;/code&gt; = сохранено. (Другие значения могут быть добавлены в будущем.)</target>
        </trans-unit>
        <trans-unit id="a7c2f91a2488ff29789b7c51189ebdab420b3b17" translate="yes" xml:space="preserve">
          <source>If a zero byte (&lt;code&gt;''&lt;/code&gt;), then not an identity column. Otherwise, &lt;code&gt;a&lt;/code&gt; = generated always, &lt;code&gt;d&lt;/code&gt; = generated by default.</source>
          <target state="translated">Если нулевой байт ( &lt;code&gt;''&lt;/code&gt; ), то не столбец идентификаторов. В противном случае &lt;code&gt;a&lt;/code&gt; = генерируется всегда, &lt;code&gt;d&lt;/code&gt; = генерируется по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ff9b8990736e5c895e3ff32d995dc7be0250f86a" translate="yes" xml:space="preserve">
          <source>If activated, the process writes information about database events into the current &lt;a href=&quot;glossary#GLOSSARY-LOG-FILE&quot;&gt;log file&lt;/a&gt;. When reaching certain time- or volume-dependent criteria, a new log file is created. Also called &lt;em&gt;syslogger&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de4b09ad9373970f4d3245c8e5f5878c7360739" translate="yes" xml:space="preserve">
          <source>If all inputs are of the same type, and it is not &lt;code&gt;unknown&lt;/code&gt;, resolve as that type.</source>
          <target state="translated">Если все входы одного типа, и это не &lt;code&gt;unknown&lt;/code&gt; , разрешите как этот тип.</target>
        </trans-unit>
        <trans-unit id="2f0d22550a877dd1e7a10ea59bd4e64873db9458" translate="yes" xml:space="preserve">
          <source>If all inputs are of type &lt;code&gt;unknown&lt;/code&gt;, resolve as type &lt;code&gt;text&lt;/code&gt; (the preferred type of the string category). Otherwise, &lt;code&gt;unknown&lt;/code&gt; inputs are ignored for the purposes of the remaining rules.</source>
          <target state="translated">Если все входные данные относятся к &lt;code&gt;unknown&lt;/code&gt; типу , разрешается как &lt;code&gt;text&lt;/code&gt; типа (предпочтительный тип строковой категории). В противном случае &lt;code&gt;unknown&lt;/code&gt; входные данные игнорируются для целей остальных правил.</target>
        </trans-unit>
        <trans-unit id="aa6c40971fdf72080d58a6233c79f7c8dce2a255" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ORDER BY&lt;/code&gt; expression is a simple name that matches both an output column name and an input column name, &lt;code&gt;ORDER BY&lt;/code&gt; will interpret it as the output column name. This is the opposite of the choice that &lt;code&gt;GROUP BY&lt;/code&gt; will make in the same situation. This inconsistency is made to be compatible with the SQL standard.</source>
          <target state="translated">Если выражение &lt;code&gt;ORDER BY&lt;/code&gt; является простым именем, которое соответствует как имени выходного столбца, так и имени входного столбца, &lt;code&gt;ORDER BY&lt;/code&gt; будет интерпретировать его как имя выходного столбца. Это противоположно выбору, который &lt;code&gt;GROUP BY&lt;/code&gt; сделает в той же ситуации. Это несоответствие сделано для совместимости со стандартом SQL.</target>
        </trans-unit>
        <trans-unit id="0ad7084c5cdd9f3be36397e8c9220c13ae237d6c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;existing_window_name&lt;/code&gt; is specified it must refer to an earlier entry in the &lt;code&gt;WINDOW&lt;/code&gt; list; the new window copies its partitioning clause from that entry, as well as its ordering clause if any. In this case the new window cannot specify its own &lt;code&gt;PARTITION BY&lt;/code&gt; clause, and it can specify &lt;code&gt;ORDER BY&lt;/code&gt; only if the copied window does not have one. The new window always uses its own frame clause; the copied window must not specify a frame clause.</source>
          <target state="translated">Если указано имя &lt;code&gt;existing_window_name&lt;/code&gt; , оно должно ссылаться на более раннюю запись в списке &lt;code&gt;WINDOW&lt;/code&gt; ; новое окно копирует предложение разделения из этой записи, а также предложение упорядочивания, если оно есть. В этом случае новое окно не может указывать собственное предложение &lt;code&gt;PARTITION BY&lt;/code&gt; , и оно может указывать &lt;code&gt;ORDER BY&lt;/code&gt; , только если в скопированном окне его нет. Новое окно всегда использует собственное предложение кадра; скопированное окно не должно указывать предложение кадра.</target>
        </trans-unit>
        <trans-unit id="d9f4f0d891ac5ca27debdc2266324be50c274311" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;options&lt;/code&gt; string is specified it must consist of a comma-separated list of one or more &lt;code&gt;option&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs. The available options are:</source>
          <target state="translated">Если указана строка &lt;code&gt;options&lt;/code&gt; она должна состоять из списка, разделенного запятыми, из одной или нескольких пар &lt;code&gt;option&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; . Доступные варианты:</target>
        </trans-unit>
        <trans-unit id="7cd30de9bbf3f8180a703c4e2d6c583071ea1a34" translate="yes" xml:space="preserve">
          <source>If an OID that does not represent an existing object is passed as argument to one of the above functions, NULL is returned.</source>
          <target state="translated">Если OID,не представляющий существующий объект,передается в качестве аргумента в одну из вышеперечисленных функций,возвращается NULL.</target>
        </trans-unit>
        <trans-unit id="ffc31d26a07681f5637a04d968a3f5e70276453d" translate="yes" xml:space="preserve">
          <source>If an aggregate supports moving-aggregate mode, it will improve calculation efficiency when the aggregate is used as a window function for a window with moving frame start (that is, a frame start mode other than &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt;). Conceptually, the forward transition function adds input values to the aggregate's state when they enter the window frame from the bottom, and the inverse transition function removes them again when they leave the frame at the top. So, when values are removed, they are always removed in the same order they were added. Whenever the inverse transition function is invoked, it will thus receive the earliest added but not yet removed argument value(s). The inverse transition function can assume that at least one row will remain in the current state after it removes the oldest row. (When this would not be the case, the window function mechanism simply starts a fresh aggregation, rather than using the inverse transition function.)</source>
          <target state="translated">Если агрегат поддерживает режим движущегося агрегата, он повысит эффективность вычислений, когда агрегат используется в качестве оконной функции для окна с движущимся началом кадра (то есть в режиме начала кадра, отличном от &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; ). Концептуально функция прямого перехода добавляет входные значения к состоянию агрегата, когда они входят в рамку окна снизу, а функция обратного перехода удаляет их снова, когда они покидают рамку наверху. Таким образом, когда значения удаляются, они всегда удаляются в том же порядке, в котором они были добавлены. Таким образом, всякий раз, когда вызывается функция обратного перехода, она получает самое раннее добавленное, но еще не удаленное значение аргумента. Функция обратного перехода может предполагать, что по крайней мере одна строка останется в текущем состоянии после удаления самой старой строки. (Если это не так, механизм оконных функций просто запускает новую агрегацию, а не использует функцию обратного перехода.)</target>
        </trans-unit>
        <trans-unit id="3eaeb85716c71ac82a1780ada62bc3bcdfffa64e" translate="yes" xml:space="preserve">
          <source>If an arbitrary value expression is used in the select list, it conceptually adds a new virtual column to the returned table. The value expression is evaluated once for each result row, with the row's values substituted for any column references. But the expressions in the select list do not have to reference any columns in the table expression of the &lt;code&gt;FROM&lt;/code&gt; clause; they can be constant arithmetic expressions, for instance.</source>
          <target state="translated">Если в списке выбора используется произвольное выражение значения, оно концептуально добавляет новый виртуальный столбец в возвращаемую таблицу. Выражение значения оценивается один раз для каждой строки результата, причем значения строки заменяются ссылками на столбцы. Но выражения в списке выбора не должны ссылаться на какие-либо столбцы в табличном выражении предложения &lt;code&gt;FROM&lt;/code&gt; ; они могут быть, например, постоянными арифметическими выражениями.</target>
        </trans-unit>
        <trans-unit id="80b1d5b3ba2fcc79e9cc1eabebb22c4a831065de" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view contains a &lt;code&gt;WHERE&lt;/code&gt; condition, the condition restricts which rows of the base relation are available to be modified by &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; statements on the view. However, an &lt;code&gt;UPDATE&lt;/code&gt; is allowed to change a row so that it no longer satisfies the &lt;code&gt;WHERE&lt;/code&gt; condition, and thus is no longer visible through the view. Similarly, an &lt;code&gt;INSERT&lt;/code&gt; command can potentially insert base-relation rows that do not satisfy the &lt;code&gt;WHERE&lt;/code&gt; condition and thus are not visible through the view (&lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; may similarly affect an existing row not visible through the view). The &lt;code&gt;CHECK OPTION&lt;/code&gt; may be used to prevent &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands from creating such rows that are not visible through the view.</source>
          <target state="translated">Если автоматически обновляемое представление содержит условие &lt;code&gt;WHERE&lt;/code&gt; , условие ограничивает, какие строки базового отношения доступны для изменения операторами &lt;code&gt;UPDATE&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; в представлении. Однако &lt;code&gt;UPDATE&lt;/code&gt; разрешено изменять строку так, чтобы она больше не удовлетворяла условию &lt;code&gt;WHERE&lt;/code&gt; и, таким образом, больше не была видна в представлении. Точно так же команда &lt;code&gt;INSERT&lt;/code&gt; может потенциально вставлять строки базового отношения, которые не удовлетворяют условию &lt;code&gt;WHERE&lt;/code&gt; и, следовательно, не видны через представление ( &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; может аналогичным образом повлиять на существующую строку, не видимую через представление). &lt;code&gt;CHECK OPTION&lt;/code&gt; может использоваться для предотвращения создания такими командами &lt;code&gt;INSERT&lt;/code&gt; и &lt;code&gt;UPDATE&lt;/code&gt; строк, которые не видны в представлении.</target>
        </trans-unit>
        <trans-unit id="2404db1fa7170a324c806fd815c2c382fbb3ff70" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view is marked with the &lt;code&gt;security_barrier&lt;/code&gt; property then all the view's &lt;code&gt;WHERE&lt;/code&gt; conditions (and any conditions using operators which are marked as &lt;code&gt;LEAKPROOF&lt;/code&gt;) will always be evaluated before any conditions that a user of the view has added. See &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for full details. Note that, due to this, rows which are not ultimately returned (because they do not pass the user's &lt;code&gt;WHERE&lt;/code&gt; conditions) may still end up being locked. &lt;code&gt;EXPLAIN&lt;/code&gt; can be used to see which conditions are applied at the relation level (and therefore do not lock rows) and which are not.</source>
          <target state="translated">Если автоматически обновляемое представление помечено свойством &lt;code&gt;security_barrier&lt;/code&gt; , тогда все условия &lt;code&gt;WHERE&lt;/code&gt; представления (и любые условия, использующие операторы, помеченные как &lt;code&gt;LEAKPROOF&lt;/code&gt; ) всегда будут оцениваться перед любыми условиями, добавленными пользователем представления. См. Подробности в &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Разделе 40.5&lt;/a&gt; . Обратите внимание, что из-за этого строки, которые в конечном итоге не возвращаются (потому что они не передают пользовательские условия &lt;code&gt;WHERE&lt;/code&gt; ), все равно могут оказаться заблокированными. &lt;code&gt;EXPLAIN&lt;/code&gt; можно использовать, чтобы увидеть, какие условия применяются на уровне отношения (и, следовательно, не блокируют строки), а какие нет.</target>
        </trans-unit>
        <trans-unit id="079f47cbc1cbed10c9582aabec32812c70758e86" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view is marked with the &lt;code&gt;security_barrier&lt;/code&gt; property then all the view's &lt;code&gt;WHERE&lt;/code&gt; conditions (and any conditions using operators which are marked as &lt;code&gt;LEAKPROOF&lt;/code&gt;) will always be evaluated before any conditions that a user of the view has added. See &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for full details. Note that, due to this, rows which are not ultimately returned (because they do not pass the user's &lt;code&gt;WHERE&lt;/code&gt; conditions) may still end up being locked. &lt;code&gt;EXPLAIN&lt;/code&gt; can be used to see which conditions are applied at the relation level (and therefore do not lock rows) and which are not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5594932b933065e06b18f724dcf95bf8608f76" translate="yes" xml:space="preserve">
          <source>If an error in these files is detected at server start, the server will refuse to start. But if an error is detected during a configuration reload, the files are ignored and the old SSL configuration continues to be used. On Windows systems, if an error in these files is detected at backend start, that backend will be unable to establish an SSL connection. In all these cases, the error condition is reported in the server log.</source>
          <target state="translated">Если при запуске сервера будет обнаружена ошибка в этих файлах,то сервер откажется от запуска.Но если при перезагрузке конфигурации будет обнаружена ошибка,файлы будут проигнорированы,а старая SSL-конфигурация продолжит использоваться.На Windows-системах,если при запуске бэкэнда будет обнаружена ошибка в этих файлах,этот бэкэнд не сможет установить SSL-соединение.Во всех этих случаях состояние ошибки сообщается в журнале сервера.</target>
        </trans-unit>
        <trans-unit id="97b646bc602dad48858332961c1cd79032617933" translate="yes" xml:space="preserve">
          <source>If an error occurs while reading the time zone abbreviation set, no new value is applied and the old set is kept. If the error occurs while starting the database, startup fails.</source>
          <target state="translated">Если при чтении набора аббревиатуры часового пояса возникает ошибка,то новое значение не применяется,а старый набор сохраняется.Если ошибка возникает при запуске базы данных,то ввод в эксплуатацию не удается.</target>
        </trans-unit>
        <trans-unit id="1de87c93627deeafcb3370199aca0fb5ecf8ffbd" translate="yes" xml:space="preserve">
          <source>If an error occurs while restoring the database schema, &lt;code&gt;pg_upgrade&lt;/code&gt; will exit and you will have to revert to the old cluster as outlined in &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REVERT&quot;&gt;Step 16&lt;/a&gt; below. To try &lt;code&gt;pg_upgrade&lt;/code&gt; again, you will need to modify the old cluster so the pg_upgrade schema restore succeeds. If the problem is a &lt;code&gt;contrib&lt;/code&gt; module, you might need to uninstall the &lt;code&gt;contrib&lt;/code&gt; module from the old cluster and install it in the new cluster after the upgrade, assuming the module is not being used to store user data.</source>
          <target state="translated">Если при восстановлении схемы базы данных &lt;code&gt;pg_upgrade&lt;/code&gt; , pg_upgrade завершит работу, и вам придется вернуться к старому кластеру, как описано в &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REVERT&quot;&gt;шаге 16&lt;/a&gt; ниже. Чтобы снова попробовать &lt;code&gt;pg_upgrade&lt;/code&gt; , вам нужно будет изменить старый кластер, чтобы восстановление схемы pg_upgrade прошло успешно. Если проблема &lt;code&gt;contrib&lt;/code&gt; модулем contrib , вам может потребоваться удалить модуль &lt;code&gt;contrib&lt;/code&gt; из старого кластера и установить его в новом кластере после обновления, предполагая, что модуль не используется для хранения пользовательских данных.</target>
        </trans-unit>
        <trans-unit id="f87c733146ee0c8066dc39794ef31c58e51824d2" translate="yes" xml:space="preserve">
          <source>If an exclusion constraint, list of the per-column exclusion operators</source>
          <target state="translated">Если ограничение на исключение,список операторов исключения для каждой колонки</target>
        </trans-unit>
        <trans-unit id="5e3f8c180f35468731cc99d8e63857d68ba52649" translate="yes" xml:space="preserve">
          <source>If an expression yields a value of a composite type (row type), then a specific field of the row can be extracted by writing</source>
          <target state="translated">Если выражение дает значение составного типа (типа строки),то конкретное поле строки может быть извлечено при помощи записи</target>
        </trans-unit>
        <trans-unit id="4ecdcd8e3d88016c98e66e3a3a5e3c60d566e607" translate="yes" xml:space="preserve">
          <source>If an expression yields a value of an array type, then a specific element of the array value can be extracted by writing</source>
          <target state="translated">Если выражение дает значение типа массива,то конкретный элемент значения массива можно извлечь путем записи</target>
        </trans-unit>
        <trans-unit id="6de9a52dce84b15b69f729bccf651727ae858f41" translate="yes" xml:space="preserve">
          <source>If an index build fails with the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option, this index is left as &amp;ldquo;invalid&amp;rdquo;. Such indexes are useless but it can be convenient to use &lt;code&gt;REINDEX&lt;/code&gt; to rebuild them. Note that only &lt;code&gt;REINDEX INDEX&lt;/code&gt; is able to perform a concurrent build on an invalid index.</source>
          <target state="translated">Если при построении индекса с параметром &lt;code&gt;CONCURRENTLY&lt;/code&gt; происходит сбой , этот индекс остается &amp;laquo;недействительным&amp;raquo;. Такие индексы бесполезны, но может быть удобно использовать &lt;code&gt;REINDEX&lt;/code&gt; для их восстановления. Обратите внимание, что только &lt;code&gt;REINDEX INDEX&lt;/code&gt; может выполнять параллельную сборку для недопустимого индекса.</target>
        </trans-unit>
        <trans-unit id="b3fe0fb957d2052bc5b183b29d4175b03f7dd244" translate="yes" xml:space="preserve">
          <source>If an input file name is just &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;ecpg&lt;/code&gt; reads the program from standard input (and writes to standard output, unless that is overridden with &lt;code&gt;-o&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ce1cc9d13f2dd4c882f2d9159dd6b972278963b" translate="yes" xml:space="preserve">
          <source>If an option is specified that is valid, but not relevant to the selected operating mode, pg_ctl ignores it.</source>
          <target state="translated">Если указан параметр,который является действительным,но не имеет отношения к выбранному режиму работы,pg_ctl игнорирует его.</target>
        </trans-unit>
        <trans-unit id="848fca9ee8526b8eb2fb6fd4b08b921862d216f2" translate="yes" xml:space="preserve">
          <source>If an unquoted colon (&lt;code&gt;:&lt;/code&gt;) followed by a psql variable name appears within an argument, it is replaced by the variable's value, as described in &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL Interpolation&lt;/a&gt; below. The forms &lt;code&gt;:'variable_name'&lt;/code&gt; and &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; described there work as well. The &lt;code&gt;:{?variable_name}&lt;/code&gt; syntax allows testing whether a variable is defined. It is substituted by TRUE or FALSE. Escaping the colon with a backslash protects it from substitution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af23873c246a8a5e4a8cad331942f631fec99b40" translate="yes" xml:space="preserve">
          <source>If an unquoted colon (&lt;code&gt;:&lt;/code&gt;) followed by a psql variable name appears within an argument, it is replaced by the variable's value, as described in &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL Interpolation&lt;/a&gt;. The forms &lt;code&gt;:'variable_name'&lt;/code&gt; and &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; described there work as well. The &lt;code&gt;:{?variable_name}&lt;/code&gt; syntax allows testing whether a variable is defined. It is substituted by TRUE or FALSE. Escaping the colon with a backslash protects it from substitution.</source>
          <target state="translated">Если неупомянуто двоеточие ( &lt;code&gt;:&lt;/code&gt; ) , а затем имя переменной PSQL появляется в качестве аргумента, она заменяется значениями переменных, как описано в &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL Интерполяции&lt;/a&gt; . Формы &lt;code&gt;:'variable_name'&lt;/code&gt; и &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; , описанные там, также работают. &lt;code&gt;:{?variable_name}&lt;/code&gt; синтаксис позволяет тестирования определяется , является ли переменная. Он заменяется на ИСТИНА или ЛОЖЬ. Прекращение двоеточия с помощью обратной косой черты защищает его от подстановки.</target>
        </trans-unit>
        <trans-unit id="e21ea67d0d720310272c7536aaef9fbd409c780b" translate="yes" xml:space="preserve">
          <source>If an upstream standby server is promoted to become new master, downstream servers will continue to stream from the new master if &lt;code&gt;recovery_target_timeline&lt;/code&gt; is set to &lt;code&gt;'latest'&lt;/code&gt; (the default).</source>
          <target state="translated">Если вышестоящий резервный сервер повышается до нового главного, подчиненные серверы будут продолжать передавать поток от нового главного, если для &lt;code&gt;recovery_target_timeline&lt;/code&gt; установлено значение &lt;code&gt;'latest'&lt;/code&gt; (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="3bd7c108b9d4e211b151f51193b945c5454b1371" translate="yes" xml:space="preserve">
          <source>If any dimension is written as a slice, i.e., contains a colon, then all dimensions are treated as slices. Any dimension that has only a single number (no colon) is treated as being from 1 to the number specified. For example, &lt;code&gt;[2]&lt;/code&gt; is treated as &lt;code&gt;[1:2]&lt;/code&gt;, as in this example:</source>
          <target state="translated">Если какое-либо измерение записано как срез, т. Е. Содержит двоеточие, то все измерения обрабатываются как срезы. Любое измерение, имеющее только одно число (без двоеточия), рассматривается как значение от 1 до указанного числа. Например, &lt;code&gt;[2]&lt;/code&gt; обрабатывается как &lt;code&gt;[1:2]&lt;/code&gt; , как в этом примере:</target>
        </trans-unit>
        <trans-unit id="644d831a9e7d5bb7b9cf967c049a8eb98186cce0" translate="yes" xml:space="preserve">
          <source>If any input argument is of a domain type, treat it as being of the domain's base type for all subsequent steps. This ensures that domains act like their base types for purposes of ambiguous-function resolution.</source>
          <target state="translated">Если любой входной аргумент относится к типу домена,рассматривайте его как базовый тип домена для всех последующих шагов.Это гарантирует,что домены будут действовать как их базовые типы для целей разрешения неоднозначных функций.</target>
        </trans-unit>
        <trans-unit id="aa9d9b8570b39bd99c0391cf769b6b9a97f8cfdc" translate="yes" xml:space="preserve">
          <source>If any input argument is of a domain type, treat it as being of the domain's base type for all subsequent steps. This ensures that domains act like their base types for purposes of ambiguous-operator resolution.</source>
          <target state="translated">Если любой входной аргумент относится к типу домена,рассматривайте его как базовый тип домена для всех последующих шагов.Это гарантирует,что домены будут действовать как их базовые типы для целей разрешения неоднозначных операторов.</target>
        </trans-unit>
        <trans-unit id="f08ac7bfcc7896ec3ccba829e9cc32f16385e939" translate="yes" xml:space="preserve">
          <source>If any input arguments are &lt;code&gt;unknown&lt;/code&gt;, check the type categories accepted at those argument positions by the remaining candidates. At each position, select the &lt;code&gt;string&lt;/code&gt; category if any candidate accepts that category. (This bias towards string is appropriate since an unknown-type literal looks like a string.) Otherwise, if all the remaining candidates accept the same type category, select that category; otherwise fail because the correct choice cannot be deduced without more clues. Now discard candidates that do not accept the selected type category. Furthermore, if any candidate accepts a preferred type in that category, discard candidates that accept non-preferred types for that argument. Keep all candidates if none survive these tests. If only one candidate remains, use it; else continue to the next step.</source>
          <target state="translated">Если какие-либо входные аргументы &lt;code&gt;unknown&lt;/code&gt; , проверьте категории типов, принятые на этих позициях аргументов оставшимися кандидатами. В каждой позиции выберите &lt;code&gt;string&lt;/code&gt; категория, если какой-либо кандидат принимает эту категорию. (Этот сдвиг в сторону строки уместен, поскольку литерал неизвестного типа выглядит как строка.) В противном случае, если все оставшиеся кандидаты принимают одну и ту же категорию типа, выберите эту категорию; иначе не получится, потому что правильный выбор не может быть сделан без дополнительных подсказок. Теперь откажитесь от кандидатов, которые не принимают выбранную категорию типа. Более того, если какой-либо кандидат принимает предпочтительный тип в этой категории, отбрасывайте кандидатов, которые принимают нежелательные типы для этого аргумента. Оставьте всех кандидатов, если ни один из них не выдержит этих испытаний. Если остается только один кандидат, используйте его; иначе переходите к следующему шагу.</target>
        </trans-unit>
        <trans-unit id="88a4eb3b7b2c17b935f14a3d49969dbb3c987944" translate="yes" xml:space="preserve">
          <source>If any input expression has an explicit collation derivation, then all explicitly derived collations among the input expressions must be the same, otherwise an error is raised. If any explicitly derived collation is present, that is the result of the collation combination.</source>
          <target state="translated">Если какое-либо из входных выражений имеет явное сопоставление,то все явно производные сопоставления между входными выражениями должны быть одинаковыми,в противном случае возникает ошибка.Если какая-либо явно производная комбинация присутствует,то это результат комбинации.</target>
        </trans-unit>
        <trans-unit id="848b268c3aef8e0ec228a9fd161ed5d209cdafec" translate="yes" xml:space="preserve">
          <source>If any input is of a domain type, treat it as being of the domain's base type for all subsequent steps. &lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5b589b0a29736a2c76abe777e082206c27d9542" translate="yes" xml:space="preserve">
          <source>If any input is of a domain type, treat it as being of the domain's base type for all subsequent steps. &lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[12]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">Если какой-либо вход относится к типу домена, рассматривать его как базовый тип домена для всех последующих шагов. &lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[12]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="062ef5413f1971acdecb4ea39fded859da884ac5" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;GROUPING SETS&lt;/code&gt;, &lt;code&gt;ROLLUP&lt;/code&gt; or &lt;code&gt;CUBE&lt;/code&gt; are present as grouping elements, then the &lt;code&gt;GROUP BY&lt;/code&gt; clause as a whole defines some number of independent &lt;code&gt;grouping sets&lt;/code&gt;. The effect of this is equivalent to constructing a &lt;code&gt;UNION ALL&lt;/code&gt; between subqueries with the individual grouping sets as their &lt;code&gt;GROUP BY&lt;/code&gt; clauses. For further details on the handling of grouping sets see &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;Section 7.2.4&lt;/a&gt;.</source>
          <target state="translated">Если какой-либо из &lt;code&gt;GROUPING SETS&lt;/code&gt; , &lt;code&gt;ROLLUP&lt;/code&gt; или &lt;code&gt;CUBE&lt;/code&gt; присутствует в качестве элементов группировки, то предложение &lt;code&gt;GROUP BY&lt;/code&gt; в целом определяет некоторое количество независимых &lt;code&gt;grouping sets&lt;/code&gt; . Эффект от этого эквивалентен созданию &lt;code&gt;UNION ALL&lt;/code&gt; между подзапросами с индивидуальными наборами группировок в качестве их предложений &lt;code&gt;GROUP BY&lt;/code&gt; . Дополнительные сведения об обработке наборов группировки см. В &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;разделе 7.2.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee7daf9476f8c0077c19fa91e9fc5b6d1dd5a0b5" translate="yes" xml:space="preserve">
          <source>If any of the child tables are foreign tables whose foreign data wrappers do not support &lt;code&gt;ANALYZE&lt;/code&gt;, those child tables are ignored while gathering inheritance statistics.</source>
          <target state="translated">Если какая-либо из дочерних таблиц является сторонними таблицами, чьи оболочки сторонних данных не поддерживают &lt;code&gt;ANALYZE&lt;/code&gt; , эти дочерние таблицы игнорируются при сборе статистики наследования.</target>
        </trans-unit>
        <trans-unit id="5559a39fd47d326a14a46d78afa053af9afa62f6" translate="yes" xml:space="preserve">
          <source>If any of the columns of a table are TOAST-able, the table will have an associated TOAST table, whose OID is stored in the table's &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltoastrelid&lt;/code&gt; entry. On-disk TOASTed values are kept in the TOAST table, as described in more detail below.</source>
          <target state="translated">Если какой-либо из столбцов таблицы поддерживает TOAST, с таблицей будет связана таблица TOAST, OID которой хранится в &lt;code&gt;pg_class&lt;/code&gt; таблицы . запись &lt;code&gt;reltoastrelid&lt;/code&gt; . Значения TOAST на диске хранятся в таблице TOAST, как более подробно описано ниже.</target>
        </trans-unit>
        <trans-unit id="cf49cd2bc67ee3c3481f1ffe2933861356e2738f" translate="yes" xml:space="preserve">
          <source>If any of the tables referenced by the view are temporary, the view is created as a temporary view (whether &lt;code&gt;TEMPORARY&lt;/code&gt; is specified or not).</source>
          <target state="translated">Если какая-либо из таблиц, на которые ссылается представление, являются временными, представление создается как временное представление (независимо от того, задано ли &lt;code&gt;TEMPORARY&lt;/code&gt; или нет).</target>
        </trans-unit>
        <trans-unit id="e74c2195dcb53833cfc91730aac90c474163ed9c" translate="yes" xml:space="preserve">
          <source>If any post-upgrade processing is required, pg_upgrade will issue warnings as it completes. It will also generate script files that must be run by the administrator. The script files will connect to each database that needs post-upgrade processing. Each script should be run using:</source>
          <target state="translated">Если требуется какая-либо пост-обработка,pg_upgrade будет выдавать предупреждения по мере ее завершения.Он также сгенерирует файлы скриптов,которые должны быть запущены администратором.Файлы скриптов будут подключаться к каждой базе данных,которая нуждается в пост-обработке.Каждый скрипт должен быть запущен с использованием:</target>
        </trans-unit>
        <trans-unit id="800a2d135577a55dc7316ea712cf7f6d1165ae24" translate="yes" xml:space="preserve">
          <source>If archive storage size is a concern, you can use gzip to compress the archive files:</source>
          <target state="translated">Если размер архивного хранилища вызывает беспокойство,можно использовать gzip для сжатия архивных файлов:</target>
        </trans-unit>
        <trans-unit id="2e48896c1f0ace93b93a8656d8514a4835072596" translate="yes" xml:space="preserve">
          <source>If at all possible, &lt;em&gt;do not&lt;/em&gt; use &lt;code&gt;SIGKILL&lt;/code&gt; to kill the main &lt;code&gt;postgres&lt;/code&gt; server. Doing so will prevent &lt;code&gt;postgres&lt;/code&gt; from freeing the system resources (e.g., shared memory and semaphores) that it holds before terminating. This might cause problems for starting a fresh &lt;code&gt;postgres&lt;/code&gt; run.</source>
          <target state="translated">По возможности &lt;em&gt;не&lt;/em&gt; используйте &lt;code&gt;SIGKILL&lt;/code&gt; для уничтожения основного сервера &lt;code&gt;postgres&lt;/code&gt; . Это предотвратит освобождение &lt;code&gt;postgres&lt;/code&gt; системных ресурсов (например, разделяемой памяти и семафоров), которые он хранит перед завершением работы. Это может вызвать проблемы при запуске нового запуска &lt;code&gt;postgres&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed12d9d5c43a1c95cedd4f159ed6ce3a1940c1ed" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;OFFSET&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt; appear, then &lt;code&gt;OFFSET&lt;/code&gt; rows are skipped before starting to count the &lt;code&gt;LIMIT&lt;/code&gt; rows that are returned.</source>
          <target state="translated">Если появляются и &lt;code&gt;OFFSET&lt;/code&gt; , и &lt;code&gt;LIMIT&lt;/code&gt; , то строки &lt;code&gt;OFFSET&lt;/code&gt; пропускаются перед началом подсчета возвращаемых &lt;code&gt;LIMIT&lt;/code&gt; строк.</target>
        </trans-unit>
        <trans-unit id="d1beaf85265bd8e8de4c00a803a4295f898d6a9d" translate="yes" xml:space="preserve">
          <source>If both standard input and standard output are a terminal, then psql sets the client encoding to &amp;ldquo;auto&amp;rdquo;, which will detect the appropriate client encoding from the locale settings (&lt;code&gt;LC_CTYPE&lt;/code&gt; environment variable on Unix systems). If this doesn't work out as expected, the client encoding can be overridden using the environment variable &lt;code&gt;PGCLIENTENCODING&lt;/code&gt;.</source>
          <target state="translated">Если и стандартный ввод, и стандартный вывод являются терминалом, то psql устанавливает для клиентской кодировки значение &amp;laquo;auto&amp;raquo;, которое определит соответствующую клиентскую кодировку из настроек локали ( переменная среды &lt;code&gt;LC_CTYPE&lt;/code&gt; в системах Unix). Если это не сработает, как ожидалось, кодировку клиента можно переопределить с помощью переменной среды &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="124d332dfa6ef76e2334514ac990a431fc574564" translate="yes" xml:space="preserve">
          <source>If cascaded replication is in use the feedback is passed upstream until it eventually reaches the primary. Standbys make no other use of feedback they receive other than to pass upstream.</source>
          <target state="translated">Если используется каскадная репликация,то обратная связь передается вверх по течению до тех пор,пока в конечном итоге не достигнет первичной.Резервные устройства не используют обратную связь,кроме как для передачи данных вверх по течению.</target>
        </trans-unit>
        <trans-unit id="21ad797b1873a315d3fc0d5c790db4d1476ce970" translate="yes" xml:space="preserve">
          <source>If case-independent matching is specified, the effect is much as if all case distinctions had vanished from the alphabet. When an alphabetic that exists in multiple cases appears as an ordinary character outside a bracket expression, it is effectively transformed into a bracket expression containing both cases, e.g., &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;[xX]&lt;/code&gt;. When it appears inside a bracket expression, all case counterparts of it are added to the bracket expression, e.g., &lt;code&gt;[x]&lt;/code&gt; becomes &lt;code&gt;[xX]&lt;/code&gt; and &lt;code&gt;[^x]&lt;/code&gt; becomes &lt;code&gt;[^xX]&lt;/code&gt;.</source>
          <target state="translated">Если указано независимое от регистра совпадение, эффект такой же, как если бы все различия регистра исчезли из алфавита. Когда алфавит, который существует в нескольких случаях, появляется как обычный символ вне выражения в &lt;code&gt;[xX]&lt;/code&gt; скобках, он эффективно преобразуется в выражение в квадратных скобках, содержащее оба случая, например, &lt;code&gt;x&lt;/code&gt; становится [xX] . Когда он появляется внутри выражения в &lt;code&gt;[xX]&lt;/code&gt; скобках, все его аналоги в регистре добавляются к выражению в квадратных скобках, например, &lt;code&gt;[x]&lt;/code&gt; становится [xX], а &lt;code&gt;[^x]&lt;/code&gt; становится &lt;code&gt;[^xX]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf258208ab5152d2c12b1e28ed793831fd7c461c" translate="yes" xml:space="preserve">
          <source>If column aliases are not supplied, then for a function returning a base data type, the column name is also the same as the function name. For a function returning a composite type, the result columns get the names of the individual attributes of the type.</source>
          <target state="translated">Если псевдонимы столбцов не указаны,то для функции,возвращающей базовый тип данных,название столбца также совпадает с названием функции.Для функции,возвращающей составной тип,столбцы результата получают названия отдельных атрибутов этого типа.</target>
        </trans-unit>
        <trans-unit id="6deaaf1ae6fdc8847b55dec525d8c4461d71750b" translate="yes" xml:space="preserve">
          <source>If consistent response time is more important than update speed, use of pending entries can be disabled by turning off the &lt;code&gt;fastupdate&lt;/code&gt; storage parameter for a GIN index. See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for details.</source>
          <target state="translated">Если согласованное время отклика более важно, чем скорость обновления, использование ожидающих записей можно отключить, отключив параметр хранения &lt;code&gt;fastupdate&lt;/code&gt; для индекса GIN. См. &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="41ef4d0c1740eb702f05dcbd27c8d877f11fcd3a" translate="yes" xml:space="preserve">
          <source>If csvlog is included in &lt;code&gt;log_destination&lt;/code&gt;, log entries are output in &amp;ldquo;comma separated value&amp;rdquo; (CSV) format, which is convenient for loading logs into programs. See &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;Section 19.8.4&lt;/a&gt; for details. &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt; must be enabled to generate CSV-format log output.</source>
          <target state="translated">Если csvlog включен в &lt;code&gt;log_destination&lt;/code&gt; , записи журнала выводятся в формате &amp;laquo;значения, разделенные запятыми&amp;raquo; (CSV), который удобен для загрузки журналов в программы. См &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;Раздел 19.8.4&lt;/a&gt; для деталей. &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt; должен быть включен для создания вывода журнала в формате CSV.</target>
        </trans-unit>
        <trans-unit id="ed1042acfa5d378be31e2b80e8d7ffc7bef64f8e" translate="yes" xml:space="preserve">
          <source>If data checksums are enabled, hint bit updates are always WAL-logged and this setting is ignored. You can use this setting to test how much extra WAL-logging would occur if your database had data checksums enabled.</source>
          <target state="translated">Если контрольные суммы данных включены,то обновления битов подсказки всегда записываются в WAL-журнал,и эта настройка игнорируется.Вы можете использовать эту настройку,чтобы проверить,сколько дополнительных WAL-журналов произошло бы,если бы в вашей базе данных были включены контрольные суммы.</target>
        </trans-unit>
        <trans-unit id="9574b9b4b7b428cee25c96a3966fa8df72a24cd9" translate="yes" xml:space="preserve">
          <source>If different date/time types need to be compared, an implicit cast is applied. A &lt;code&gt;date&lt;/code&gt; value can be cast to &lt;code&gt;timestamp&lt;/code&gt; or &lt;code&gt;timestamptz&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt; can be cast to &lt;code&gt;timestamptz&lt;/code&gt;, and &lt;code&gt;time&lt;/code&gt; to &lt;code&gt;timetz&lt;/code&gt;. However, all but the first of these conversions depend on the current &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; setting, and thus can only be performed within timezone-aware &lt;code&gt;jsonpath&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0a4beca9338b9c149bc626eda6f48fc9e5c025" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;toptag&lt;/code&gt; or &lt;code&gt;itemtag&lt;/code&gt; is an empty string, the relevant tag is omitted.</source>
          <target state="translated">Если либо &lt;code&gt;toptag&lt;/code&gt; , либо &lt;code&gt;itemtag&lt;/code&gt; - пустая строка, соответствующий тег опускается.</target>
        </trans-unit>
        <trans-unit id="03df124a73c895463360e1ed34f1a74da7815fc6" translate="yes" xml:space="preserve">
          <source>If either &lt;em&gt;&lt;code&gt;toptag&lt;/code&gt;&lt;/em&gt; or &lt;em&gt;&lt;code&gt;itemtag&lt;/code&gt;&lt;/em&gt; is an empty string, the relevant tag is omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92d15119505820507c6255b9360f73a82ee471e" translate="yes" xml:space="preserve">
          <source>If executed during recovery, the &lt;code&gt;CHECKPOINT&lt;/code&gt; command will force a restartpoint (see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;) rather than writing a new checkpoint.</source>
          <target state="translated">Если выполняется во время восстановления, команда &lt;code&gt;CHECKPOINT&lt;/code&gt; вызовет точку перезапуска (см. &lt;a href=&quot;wal-configuration&quot;&gt;Раздел 29.4&lt;/a&gt; ) вместо записи новой контрольной точки.</target>
        </trans-unit>
        <trans-unit id="61ea49c86b3b55d886450b38a9cc42e4e9c69fce" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database.</source>
          <target state="translated">Если значение false,то никто не сможет подключиться к этой базе данных.</target>
        </trans-unit>
        <trans-unit id="67f61dc72a1244f231103433b1246606e94298b4" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database. The default is true, allowing connections (except as restricted by other mechanisms, such as &lt;code&gt;GRANT&lt;/code&gt;/&lt;code&gt;REVOKE CONNECT&lt;/code&gt;).</source>
          <target state="translated">Если false, то никто не сможет подключиться к этой базе данных. По умолчанию установлено значение &quot;истина&quot;, разрешающее соединения (за исключением случаев, когда они ограничены другими механизмами, такими как &lt;code&gt;GRANT&lt;/code&gt; / &lt;code&gt;REVOKE CONNECT&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="068609549b5f3904794ff7927c8befaac0ac4357" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database. This is used to protect the &lt;code&gt;template0&lt;/code&gt; database from being altered.</source>
          <target state="translated">Если false, то никто не сможет подключиться к этой базе данных. Это используется для защиты базы данных &lt;code&gt;template0&lt;/code&gt; от изменений.</target>
        </trans-unit>
        <trans-unit id="5279e693a4509d44588c8398060bdbb7e4662f3c" translate="yes" xml:space="preserve">
          <source>If false, the index is in process of being dropped, and should be ignored for all purposes (including HOT-safety decisions)</source>
          <target state="translated">В случае ложных срабатываний индекс в настоящее время сбрасывается,и его следует игнорировать для всех целей (включая решения по ГОР-безопасности).</target>
        </trans-unit>
        <trans-unit id="024b18cb2d326ba0157f9b09e5a42b7967d00fb4" translate="yes" xml:space="preserve">
          <source>If fewer column aliases are specified than the actual table has columns, the remaining columns are not renamed. This syntax is especially useful for self-joins or subqueries.</source>
          <target state="translated">Если указано меньше псевдонимов столбцов,чем в фактической таблице есть столбцы,остальные столбцы не переименовываются.Этот синтаксис особенно полезен для самообъединения или подзапросов.</target>
        </trans-unit>
        <trans-unit id="7788a3fcadf6ada52028229d6f513ec9b5a33011" translate="yes" xml:space="preserve">
          <source>If for some reason autovacuum fails to clear old XIDs from a table, the system will begin to emit warning messages like this when the database's oldest XIDs reach eleven million transactions from the wraparound point:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab96b15ba19344208a4881ae65df7268a6bcc7d" translate="yes" xml:space="preserve">
          <source>If for some reason autovacuum fails to clear old XIDs from a table, the system will begin to emit warning messages like this when the database's oldest XIDs reach ten million transactions from the wraparound point:</source>
          <target state="translated">Если по каким-то причинам автовакуум не удается очистить старые XIDs из таблицы,система начнет выдавать такие предупреждающие сообщения,когда старые XIDs базы данных достигнут десяти миллионов транзакций из точки обертывания:</target>
        </trans-unit>
        <trans-unit id="80fa6f646b83284df410a911e1de501df6e5b069" translate="yes" xml:space="preserve">
          <source>If forcing index usage does use the index, then there are two possibilities: Either the system is right and using the index is indeed not appropriate, or the cost estimates of the query plans are not reflecting reality. So you should time your query with and without indexes. The &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; command can be useful here.</source>
          <target state="translated">Если при принудительном использовании индекса используется индекс, тогда есть две возможности: либо система правильная и использование индекса действительно не подходит, либо оценки затрат планов запросов не отражают реальность. Таким образом, вы должны рассчитывать свой запрос с индексами и без них. Здесь может быть полезна команда &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="360561360313d63c949a4bb8b50e6444752b1851" translate="yes" xml:space="preserve">
          <source>If four or six digits and a year has already been read, then interpret as a time (&lt;code&gt;HHMM&lt;/code&gt; or &lt;code&gt;HHMMSS&lt;/code&gt;).</source>
          <target state="translated">Если четыре или шесть цифр и год уже были прочитаны, интерпретируйте как время ( &lt;code&gt;HHMM&lt;/code&gt; или &lt;code&gt;HHMMSS&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="42c28f0a9935826074d643ae6e75e6be762517ad" translate="yes" xml:space="preserve">
          <source>If given, createuser will issue a prompt for the password of the new user. This is not necessary if you do not plan on using password authentication.</source>
          <target state="translated">Если да,то создатель выдаст запрос на ввод пароля нового пользователя.В этом нет необходимости,если вы не планируете использовать аутентификацию паролем.</target>
        </trans-unit>
        <trans-unit id="ea4e98adccd9512cd68509c9e2207bdcbb1a1273" translate="yes" xml:space="preserve">
          <source>If greater than zero, each bind parameter value logged with a non-error statement-logging message is trimmed to this many bytes. Zero disables logging of bind parameters for non-error statement logs. &lt;code&gt;-1&lt;/code&gt; (the default) allows bind parameters to be logged in full. If this value is specified without units, it is taken as bytes. Only superusers can change this setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b5cd71938c46f540f5b875d785655ef9301be2" translate="yes" xml:space="preserve">
          <source>If greater than zero, each bind parameter value reported in error messages is trimmed to this many bytes. Zero (the default) disables including bind parameters in error messages. &lt;code&gt;-1&lt;/code&gt; allows bind parameters to be printed in full. If this value is specified without units, it is taken as bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95adc82bd644fa7ad31393ac2f57ca7d35f902fd" translate="yes" xml:space="preserve">
          <source>If greater than zero, the estimated number of distinct values in the column. If less than zero, the negative of the number of distinct values divided by the number of rows. (The negated form is used when &lt;code&gt;ANALYZE&lt;/code&gt; believes that the number of distinct values is likely to increase as the table grows; the positive form is used when the column seems to have a fixed number of possible values.) For example, -1 indicates a unique column in which the number of distinct values is the same as the number of rows.</source>
          <target state="translated">Если больше нуля, предполагаемое количество различных значений в столбце. Если меньше нуля, отрицательное значение числа различных значений, деленное на количество строк. (Отрицательная форма используется, когда &lt;code&gt;ANALYZE&lt;/code&gt; считает, что количество различных значений может увеличиваться по мере роста таблицы; положительная форма используется, когда кажется, что столбец имеет фиксированное количество возможных значений.) Например, -1 указывает на уникальный столбец, в котором количество различных значений совпадает с количеством строк.</target>
        </trans-unit>
        <trans-unit id="b21def7d275563964950f72033030facdc8caa8d" translate="yes" xml:space="preserve">
          <source>If indexing numbers, we can remove some fractional digits to reduce the range of possible numbers, so for example &lt;em&gt;3.14&lt;/em&gt;159265359, &lt;em&gt;3.14&lt;/em&gt;15926, &lt;em&gt;3.14&lt;/em&gt; will be the same after normalization if only two digits are kept after the decimal point.</source>
          <target state="translated">При индексировании чисел мы можем удалить некоторые дробные цифры, чтобы уменьшить диапазон возможных чисел, поэтому, например, &lt;em&gt;3.14&lt;/em&gt; 159265359, &lt;em&gt;3.14&lt;/em&gt; 15926, &lt;em&gt;3.14&lt;/em&gt; будут такими же после нормализации, если после десятичной точки сохранены только две цифры.</target>
        </trans-unit>
        <trans-unit id="76133018bd86f9f10167401dc275f9ef001f11b2" translate="yes" xml:space="preserve">
          <source>If inverse partial newline-sensitive matching is specified, this affects &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; as with newline-sensitive matching, but not &lt;code&gt;.&lt;/code&gt; and bracket expressions. This isn't very useful but is provided for symmetry.</source>
          <target state="translated">Если указано обратное частичное сопоставление с учетом новой строки, это влияет на &lt;code&gt;^&lt;/code&gt; и &lt;code&gt;$&lt;/code&gt; , как с сопоставлением с учетом новой строки, но не влияет &lt;code&gt;.&lt;/code&gt; и выражения в скобках. Это не очень полезно, но предусмотрено для симметрии.</target>
        </trans-unit>
        <trans-unit id="dcbd0be8463498dfec58ee2ded857848642b3788" translate="yes" xml:space="preserve">
          <source>If it is necessary to have a comma or whitespace in a RADIUS parameter value, that can be done by putting double quotes around the value, but it is tedious because two layers of double-quoting are now required. An example of putting whitespace into RADIUS secret strings is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82c509d031e15398bd7fe00861081d6405c8be4" translate="yes" xml:space="preserve">
          <source>If it turns out that the cost estimates are wrong, there are, again, two possibilities. The total cost is computed from the per-row costs of each plan node times the selectivity estimate of the plan node. The costs estimated for the plan nodes can be adjusted via run-time parameters (described in &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;). An inaccurate selectivity estimate is due to insufficient statistics. It might be possible to improve this by tuning the statistics-gathering parameters (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">Если окажется, что смета затрат неверна, опять же, есть две возможности. Общая стоимость вычисляется из затрат на строку каждого узла плана, умноженных на оценку селективности узла плана. Стоимость, оцененная для узлов плана, может быть скорректирована с помощью параметров времени выполнения (описанных в &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Разделе 19.7.2&lt;/a&gt; ). Неточная оценка селективности связана с недостаточной статистикой. Возможно, это можно улучшить, настроив параметры сбора статистики (см. &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="18729ccb1c4146c8bab4ae3596759dabf5573ab7" translate="yes" xml:space="preserve">
          <source>If locale support doesn't work according to the explanation above, check that the locale support in your operating system is correctly configured. To check what locales are installed on your system, you can use the command &lt;code&gt;locale -a&lt;/code&gt; if your operating system provides it.</source>
          <target state="translated">Если поддержка языкового стандарта не работает в соответствии с приведенным выше объяснением, убедитесь, что поддержка языкового стандарта в вашей операционной системе настроена правильно. Чтобы проверить, какие языковые стандарты установлены в вашей системе, вы можете использовать команду &lt;code&gt;locale -a&lt;/code&gt; , если она предусмотрена вашей операционной системой.</target>
        </trans-unit>
        <trans-unit id="742c773e01d7235a3ab536311ea18ceb446289e6" translate="yes" xml:space="preserve">
          <source>If making a backup, make sure that your database is not being updated. This does not affect the integrity of the backup, but the changed data would of course not be included. If necessary, edit the permissions in the file &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; (or equivalent) to disallow access from everyone except you. See &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for additional information on access control.</source>
          <target state="translated">При создании резервной копии убедитесь, что ваша база данных не обновляется. Это не влияет на целостность резервной копии, но измененные данные, конечно, не будут включены. При необходимости отредактируйте разрешения в файле &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; (или эквивалентном), чтобы запретить доступ всем, кроме вас. См. &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Главу 20&lt;/a&gt; для получения дополнительной информации об управлении доступом.</target>
        </trans-unit>
        <trans-unit id="7635b5eb0e6be90090ac67c5260cad61569c3e50" translate="yes" xml:space="preserve">
          <source>If making a backup, make sure that your database is not being updated. This does not affect the integrity of the backup, but the changed data would of course not be included. If necessary, edit the permissions in the file &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; (or equivalent) to disallow access from everyone except you. See &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for additional information on access control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a6e1d7bfcacfaf25b4fbb67794def2eb6d19f0" translate="yes" xml:space="preserve">
          <source>If more flexibility in copying the backup files is needed, a lower level process can be used for standalone hot backups as well. To prepare for low level standalone hot backups, make sure &lt;code&gt;wal_level&lt;/code&gt; is set to &lt;code&gt;replica&lt;/code&gt; or higher, &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt;, and set up an &lt;code&gt;archive_command&lt;/code&gt; that performs archiving only when a &lt;em&gt;switch file&lt;/em&gt; exists. For example:</source>
          <target state="translated">Если требуется большая гибкость в копировании файлов резервных копий, можно использовать процесс более низкого уровня для автономных горячих резервных копий. Чтобы подготовиться к низкоуровневому автономному горячему резервному копированию, убедитесь, что для &lt;code&gt;wal_level&lt;/code&gt; задано значение &lt;code&gt;replica&lt;/code&gt; или выше, &lt;code&gt;archive_mode&lt;/code&gt; для archive_mode - значение &lt;code&gt;on&lt;/code&gt; , и настройте команду &lt;code&gt;archive_command&lt;/code&gt; , которая выполняет архивирование только в том случае, если существует &lt;em&gt;файл переключения&lt;/em&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="b849cfa2234fdad4226b42e149aff052e2ec6ceb" translate="yes" xml:space="preserve">
          <source>If more than one flag bit is specified, the transformations are applied in the order listed.</source>
          <target state="translated">Если указано более одного бита флага,то преобразования применяются в указанном порядке.</target>
        </trans-unit>
        <trans-unit id="b8368877f8014c70dc2f0a265b592212cfc0ddc8" translate="yes" xml:space="preserve">
          <source>If more than one leaf tuple is supplied, it is expected that the &lt;code&gt;picksplit&lt;/code&gt; function will classify them into more than one node; otherwise it is not possible to split the leaf tuples across multiple pages, which is the ultimate purpose of this operation. Therefore, if the &lt;code&gt;picksplit&lt;/code&gt; function ends up placing all the leaf tuples in the same node, the core SP-GiST code will override that decision and generate an inner tuple in which the leaf tuples are assigned at random to several identically-labeled nodes. Such a tuple is marked &lt;code&gt;allTheSame&lt;/code&gt; to signify that this has happened. The &lt;code&gt;choose&lt;/code&gt; and &lt;code&gt;inner_consistent&lt;/code&gt; functions must take suitable care with such inner tuples. See &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt; for more information.</source>
          <target state="translated">Если предоставляется более одного кортежа листьев, ожидается, что функция &lt;code&gt;picksplit&lt;/code&gt; классифицирует их более чем на один узел; в противном случае невозможно разделить кортежи листьев на несколько страниц, что и является конечной целью этой операции. Следовательно, если функция &lt;code&gt;picksplit&lt;/code&gt; помещает все конечные кортежи в один и тот же узел, основной код SP-GiST переопределит это решение и сгенерирует внутренний кортеж, в котором конечные кортежи назначаются случайным образом нескольким идентично помеченным узлам. Такой кортеж помечен как &lt;code&gt;allTheSame&lt;/code&gt; , чтобы обозначить, что это произошло. &lt;code&gt;choose&lt;/code&gt; и &lt;code&gt;inner_consistent&lt;/code&gt; функция должна принять надлежащий уход с такими внутренними кортежами. См. &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Раздел 65.4.3.&lt;/a&gt; Чтобы получить больше информации.</target>
        </trans-unit>
        <trans-unit id="e1854b837fa3254f90682ac28255cbd702178269" translate="yes" xml:space="preserve">
          <source>If more than one option is given, the information is printed in that order, one item per line. If no options are given, all available information is printed, with labels.</source>
          <target state="translated">Если задано несколько вариантов,то информация распечатывается в этом порядке,по одному пункту на строку.Если не задан ни один из вариантов,вся доступная информация распечатывается с этикетками.</target>
        </trans-unit>
        <trans-unit id="f1a02345ba89ad66d10fbdabf34539cb6dd7d98c" translate="yes" xml:space="preserve">
          <source>If more than one table has a column of the same name, the table name must also be given, as in:</source>
          <target state="translated">Если несколько таблиц имеют столбец с одним и тем же именем,имя таблицы также должно быть дано,как и в случае с ней:</target>
        </trans-unit>
        <trans-unit id="dd5e9dbc9005fdf88d98048279bb5e957015fc29" translate="yes" xml:space="preserve">
          <source>If multiple CPUs are available in the database server, consider using pg_restore's &lt;code&gt;--jobs&lt;/code&gt; option. This allows concurrent data loading and index creation.</source>
          <target state="translated">Если на сервере базы данных доступно несколько процессоров, рассмотрите возможность использования параметра pg_restore &lt;code&gt;--jobs&lt;/code&gt; . Это позволяет одновременно загружать данные и создавать индексы.</target>
        </trans-unit>
        <trans-unit id="87fac9519c05562bef87a4e35aa2a859278b1c40" translate="yes" xml:space="preserve">
          <source>If multiple grouping items are specified in a single &lt;code&gt;GROUP BY&lt;/code&gt; clause, then the final list of grouping sets is the cross product of the individual items. For example:</source>
          <target state="translated">Если в одном предложении &lt;code&gt;GROUP BY&lt;/code&gt; указано несколько элементов группировки , то окончательный список наборов группировки представляет собой перекрестное произведение отдельных элементов. Например:</target>
        </trans-unit>
        <trans-unit id="b80b5e3c45aa43e720ac77a6f9a3ef8d195c588d" translate="yes" xml:space="preserve">
          <source>If multiple savepoints have the same name, only the one that was most recently defined is released.</source>
          <target state="translated">Если несколько точек сохранения имеют одно и то же имя,то освобождается только та,которая была определена в последний раз.</target>
        </trans-unit>
        <trans-unit id="9bb7ddb9b949ac875aa47f26b30ade97f88eab22" translate="yes" xml:space="preserve">
          <source>If multiple script files are specified, the averages are reported separately for each script file.</source>
          <target state="translated">Если указано несколько файлов скриптов,то средние значения сообщаются отдельно для каждого файла скрипта.</target>
        </trans-unit>
        <trans-unit id="e33be9af0afb6da142699266371977c598700dcd" translate="yes" xml:space="preserve">
          <source>If multiple triggers of the same kind are defined for the same event, they will be fired in alphabetical order by name.</source>
          <target state="translated">Если для одного и того же события определены несколько триггеров одного и того же типа,то они будут сбрасываться в алфавитном порядке по имени.</target>
        </trans-unit>
        <trans-unit id="65a4d92a17b0442c58eb3e977048325cf5830355" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;ALSO&lt;/code&gt; nor &lt;code&gt;INSTEAD&lt;/code&gt; is specified, &lt;code&gt;ALSO&lt;/code&gt; is the default.</source>
          <target state="translated">Если ни &lt;code&gt;ALSO&lt;/code&gt; , ни &lt;code&gt;INSTEAD&lt;/code&gt; указано, &lt;code&gt;ALSO&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="7e603a3b3a3e88af33582419d67e19ea60ef676f" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;FOR SEARCH&lt;/code&gt; nor &lt;code&gt;FOR ORDER BY&lt;/code&gt; is specified, &lt;code&gt;FOR SEARCH&lt;/code&gt; is the default.</source>
          <target state="translated">Если не указано ни &lt;code&gt;FOR SEARCH&lt;/code&gt; , ни &lt;code&gt;FOR ORDER BY&lt;/code&gt; , по умолчанию используется &lt;code&gt;FOR SEARCH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e9aa69e6e2804ffb3ebc122107e995dd5c9a00a" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;FOR TABLE&lt;/code&gt; nor &lt;code&gt;FOR ALL TABLES&lt;/code&gt; is specified, then the publication starts out with an empty set of tables. That is useful if tables are to be added later.</source>
          <target state="translated">Если ни &lt;code&gt;FOR TABLE&lt;/code&gt; , ни &lt;code&gt;FOR ALL TABLES&lt;/code&gt; не указаны, публикация начинается с пустого набора таблиц. Это полезно, если таблицы будут добавлены позже.</target>
        </trans-unit>
        <trans-unit id="89d1b1553626d39b44b8a8db61a149cf8fdc3227" translate="yes" xml:space="preserve">
          <source>If newline-sensitive matching is specified, &lt;code&gt;.&lt;/code&gt; and bracket expressions using &lt;code&gt;^&lt;/code&gt; will never match the newline character (so that matches will never cross newlines unless the RE explicitly arranges it) and &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; will match the empty string after and before a newline respectively, in addition to matching at beginning and end of string respectively. But the ARE escapes &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; continue to match beginning or end of string &lt;em&gt;only&lt;/em&gt;.</source>
          <target state="translated">Если указан символ новой строки с учетом регистра соответствия, &lt;code&gt;.&lt;/code&gt; и выражения в квадратных скобках с использованием &lt;code&gt;^&lt;/code&gt; никогда не будут соответствовать символу новой строки (так что совпадения никогда не будут пересекать новую строку, если RE явно не упорядочит ее), а &lt;code&gt;^&lt;/code&gt; и &lt;code&gt;$&lt;/code&gt; будут соответствовать пустой строке после и перед новой строкой соответственно, в дополнение к сопоставлению в начале и в конце строки соответственно. Но ARE ускользает &lt;code&gt;\A&lt;/code&gt; и &lt;code&gt;\Z&lt;/code&gt; продолжают соответствовать начало или конец строки &lt;em&gt;только&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="eec0fa542613e1975aae2a48b92903dde3eacbb8" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;table_alias&lt;/code&gt; is specified, the function name is used as the table name; in the case of a &lt;code&gt;ROWS FROM()&lt;/code&gt; construct, the first function's name is used.</source>
          <target state="translated">Если &lt;code&gt;table_alias&lt;/code&gt; не указан, имя функции используется как имя таблицы; в случае конструкции &lt;code&gt;ROWS FROM()&lt;/code&gt; используется имя первой функции.</target>
        </trans-unit>
        <trans-unit id="5c82c2225e73852e8c357908e66b1d12e66520ab" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;weights&lt;/code&gt; are provided, then these defaults are used:</source>
          <target state="translated">Если &lt;code&gt;weights&lt;/code&gt; указаны, используются следующие значения по умолчанию:</target>
        </trans-unit>
        <trans-unit id="0368275c8128ea23b2ee02837095ef288617003c" translate="yes" xml:space="preserve">
          <source>If no collation is explicitly specified, the database system either derives a collation from the columns involved in the expression, or it defaults to the default collation of the database if no column is involved in the expression.</source>
          <target state="translated">Если колонка явно не указана,то система БД либо выводит колонку из столбцов,участвующих в выражении,либо по умолчанию устанавливает колонку по умолчанию для БД,если ни один столбец не участвует в выражении.</target>
        </trans-unit>
        <trans-unit id="21307971878d081789f53c6ec3a32e0fa2a71500" translate="yes" xml:space="preserve">
          <source>If no default value is declared explicitly, the default value is the null value. This usually makes sense because a null value can be considered to represent unknown data.</source>
          <target state="translated">Если значение по умолчанию не объявлено явно,то значение по умолчанию является нулевым.Обычно это имеет смысл,поскольку нулевое значение можно считать представляющим неизвестные данные.</target>
        </trans-unit>
        <trans-unit id="e6bbf77c4f367e9f49f3db1ca226b2a952882830" translate="yes" xml:space="preserve">
          <source>If no exact match is found, see if the function call appears to be a special type conversion request. This happens if the function call has just one argument and the function name is the same as the (internal) name of some data type. Furthermore, the function argument must be either an unknown-type literal, or a type that is binary-coercible to the named data type, or a type that could be converted to the named data type by applying that type's I/O functions (that is, the conversion is either to or from one of the standard string types). When these conditions are met, the function call is treated as a form of &lt;code&gt;CAST&lt;/code&gt; specification. &lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35149dcf4bfae750a59efc48da69e479e9799355" translate="yes" xml:space="preserve">
          <source>If no exact match is found, see if the function call appears to be a special type conversion request. This happens if the function call has just one argument and the function name is the same as the (internal) name of some data type. Furthermore, the function argument must be either an unknown-type literal, or a type that is binary-coercible to the named data type, or a type that could be converted to the named data type by applying that type's I/O functions (that is, the conversion is either to or from one of the standard string types). When these conditions are met, the function call is treated as a form of &lt;code&gt;CAST&lt;/code&gt; specification. &lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">Если точное совпадение не найдено, проверьте, не является ли вызов функции запросом преобразования специального типа. Это происходит, если вызов функции имеет только один аргумент и имя функции совпадает с (внутренним) именем некоторого типа данных. Кроме того, аргумент функции должен быть либо литералом неизвестного типа, либо типом, который может быть двоично-приведен к именованному типу данных, либо типом, который можно преобразовать в именованный тип данных путем применения функций ввода-вывода этого типа ( есть преобразование в один из стандартных строковых типов или из него). Когда эти условия выполнены, вызов функции рассматривается как форма спецификации &lt;code&gt;CAST&lt;/code&gt; . &lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93b5e5aff6e0171effd161da742f968f9068eee6" translate="yes" xml:space="preserve">
          <source>If no explicit provision is made for a sign in &lt;code&gt;to_char()&lt;/code&gt;'s pattern, one column will be reserved for the sign, and it will be anchored to (appear just left of) the number. If &lt;code&gt;S&lt;/code&gt; appears just left of some &lt;code&gt;9&lt;/code&gt;'s, it will likewise be anchored to the number.</source>
          <target state="translated">Если не предусмотрено явное положение для входа в &lt;code&gt;to_char()&lt;/code&gt; , один столбец будет зарезервирован для знака, и он будет привязан к номеру (появится слева от него). Если &lt;code&gt;S&lt;/code&gt; появляется только слева от некоторых &lt;code&gt;9&lt;/code&gt; -х, он также будет привязан к номеру.</target>
        </trans-unit>
        <trans-unit id="6e409b417f72efc6d96ed16a0afc9bdc881a346a" translate="yes" xml:space="preserve">
          <source>If no function is specified, a blank &lt;code&gt;CREATE FUNCTION&lt;/code&gt; template is presented for editing.</source>
          <target state="translated">Если функция не указана, для редактирования предоставляется пустой шаблон &lt;code&gt;CREATE FUNCTION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfdbba53034a54f85542008e5a3f670d8b001aa1" translate="yes" xml:space="preserve">
          <source>If no lock mode is specified, then &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt;, the most restrictive mode, is used.</source>
          <target state="translated">Если режим блокировки не указан, то используется &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; , наиболее ограничительный режим.</target>
        </trans-unit>
        <trans-unit id="e62fb9f6836054022a0013bdbc9afb997f69a82f" translate="yes" xml:space="preserve">
          <source>If no moving-aggregate implementation is supplied, the aggregate can still be used with moving frames, but PostgreSQL will recompute the whole aggregation whenever the start of the frame moves. Note that whether or not the aggregate supports moving-aggregate mode, PostgreSQL can handle a moving frame end without recalculation; this is done by continuing to add new values to the aggregate's state. This is why use of an aggregate as a window function requires that the final function be read-only: it must not damage the aggregate's state value, so that the aggregation can be continued even after an aggregate result value has been obtained for one set of frame boundaries.</source>
          <target state="translated">Если не поставляется реализация группировки перемещений,агрегат все равно может использоваться с перемещаемыми фреймами,но PostgreSQL будет пересчитывать всю агрегированность всякий раз,когда начинается перемещение фрейма.Обратите внимание,что независимо от того,поддерживает ли агрегат режим группировки перемещений,PostgreSQL может обрабатывать конец скользящего фрейма без пересчета;это делается путем дальнейшего добавления новых значений в состояние агрегата.Поэтому использование агрегата в качестве оконной функции требует,чтобы итоговая функция была доступна только для чтения:она не должна повреждать значение состояния агрегата,чтобы агрегация могла продолжаться даже после получения значения агрегированного результата для одного набора границ кадра.</target>
        </trans-unit>
        <trans-unit id="f9d74d492594986bfbf1fc1386e105965c9b3fc3" translate="yes" xml:space="preserve">
          <source>If no output column name is specified using &lt;code&gt;AS&lt;/code&gt;, the system assigns a default column name. For simple column references, this is the name of the referenced column. For function calls, this is the name of the function. For complex expressions, the system will generate a generic name.</source>
          <target state="translated">Если имя выходного столбца не указано с помощью &lt;code&gt;AS&lt;/code&gt; , система назначает имя столбца по умолчанию. Для простых ссылок на столбцы это имя столбца, на который указывает ссылка. Для вызовов функций это имя функции. Для сложных выражений система сгенерирует общее имя.</target>
        </trans-unit>
        <trans-unit id="46eb45e8cda4a2fa8f3f15869002e910f361619b" translate="yes" xml:space="preserve">
          <source>If no role is specified, or the special user name &lt;code&gt;PUBLIC&lt;/code&gt; is used, then the policy applies to all users on the system. To allow all users to access only their own row in a &lt;code&gt;users&lt;/code&gt; table, a simple policy can be used:</source>
          <target state="translated">Если роль не указана или используется специальное имя пользователя &lt;code&gt;PUBLIC&lt;/code&gt; , политика применяется ко всем пользователям в системе. Чтобы разрешить всем пользователям доступ только к их собственной строке в таблице &lt;code&gt;users&lt;/code&gt; , можно использовать простую политику:</target>
        </trans-unit>
        <trans-unit id="6d6b57e5927a5bed9026e109eaaf60a10bd5032f" translate="yes" xml:space="preserve">
          <source>If no synchronous standby names are specified here, then synchronous replication is not enabled and transaction commits will not wait for replication. This is the default configuration. Even when synchronous replication is enabled, individual transactions can be configured not to wait for replication by setting the &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; parameter to &lt;code&gt;local&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">Если здесь не указаны имена синхронных резервных серверов, то синхронная репликация не включена, и транзакции не будут ждать репликации. Это конфигурация по умолчанию. Даже когда синхронная репликация включена, отдельные транзакции можно настроить так, чтобы они не ожидали репликации, установив для параметра &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; значение &lt;code&gt;local&lt;/code&gt; или &lt;code&gt;off&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b499f250be4863620a8af2772b67aa546566a3ec" translate="yes" xml:space="preserve">
          <source>If no table name is available, that is, when mapping a query or a cursor, the string &lt;code&gt;table&lt;/code&gt; is used in the first format, &lt;code&gt;row&lt;/code&gt; in the second format.</source>
          <target state="translated">Если имя таблицы недоступно, то есть при отображении запроса или курсора, &lt;code&gt;table&lt;/code&gt; строк используется в первом формате, а &lt;code&gt;row&lt;/code&gt; во втором формате.</target>
        </trans-unit>
        <trans-unit id="31cbf099df48b49708d8e3fe1c5398bc9eb2b4ff" translate="yes" xml:space="preserve">
          <source>If no tuples were deleted from the heap, B-tree indexes are still scanned at the &lt;code&gt;VACUUM&lt;/code&gt; cleanup stage when at least one of the following conditions is met: the index statistics are stale, or the index contains deleted pages that can be recycled during cleanup. Index statistics are considered to be stale if the number of newly inserted tuples exceeds the &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; fraction of the total number of heap tuples detected by the previous statistics collection. The total number of heap tuples is stored in the index meta-page. Note that the meta-page does not include this data until &lt;code&gt;VACUUM&lt;/code&gt; finds no dead tuples, so B-tree index scan at the cleanup stage can only be skipped if the second and subsequent &lt;code&gt;VACUUM&lt;/code&gt; cycles detect no dead tuples.</source>
          <target state="translated">Если кортежи не были удалены из кучи, индексы B-дерева по-прежнему сканируются на этапе очистки &lt;code&gt;VACUUM&lt;/code&gt; , если выполняется хотя бы одно из следующих условий: статистика индекса устарела или индекс содержит удаленные страницы, которые могут быть переработаны во время очистки. . Статистика индекса считается устаревшей, если количество вновь вставленных кортежей превышает долю &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; от общего числа кортежей кучи, обнаруженных предыдущим сбором статистики. Общее количество кортежей кучи хранится на мета-странице индекса. Обратите внимание, что мета-страница не включает эти данные до тех пор, пока &lt;code&gt;VACUUM&lt;/code&gt; не обнаружит мертвых кортежей, поэтому сканирование индекса B-дерева на этапе очистки можно пропустить, только если второй и последующие &lt;code&gt;VACUUM&lt;/code&gt; циклы не обнаруживают мертвых кортежей.</target>
        </trans-unit>
        <trans-unit id="a50a96a1efd9e9515cc7402b6a1585dcf6707637" translate="yes" xml:space="preserve">
          <source>If no view is specified, a blank &lt;code&gt;CREATE VIEW&lt;/code&gt; template is presented for editing.</source>
          <target state="translated">Если представление не указано, для редактирования предоставляется пустой шаблон &lt;code&gt;CREATE VIEW&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b168c695895a81115afb54900077dcd6394dd9a3" translate="yes" xml:space="preserve">
          <source>If not found, search an internal table to match the token as either a special string (e.g., &lt;code&gt;today&lt;/code&gt;), day (e.g., &lt;code&gt;Thursday&lt;/code&gt;), month (e.g., &lt;code&gt;January&lt;/code&gt;), or noise word (e.g., &lt;code&gt;at&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;).</source>
          <target state="translated">Если не найден, выполните поиск во внутренней таблице, чтобы найти токен в виде специальной строки (например, &lt;code&gt;today&lt;/code&gt; ), дня (например, &lt;code&gt;Thursday&lt;/code&gt; ), месяца (например, &lt;code&gt;January&lt;/code&gt; ) или шумового слова (например, &lt;code&gt;at&lt;/code&gt; , &lt;code&gt;on&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dc5b189453f6a7ea6efcd19711a7a024dd08877c" translate="yes" xml:space="preserve">
          <source>If not null, an error message indicating why this entry could not be applied</source>
          <target state="translated">Если она не является нулевой,то выдается сообщение об ошибке,указывающее на то,почему эта запись не может быть применена.</target>
        </trans-unit>
        <trans-unit id="8da51845e78e415599c49039ce6e56d900436b63" translate="yes" xml:space="preserve">
          <source>If not null, an error message indicating why this line could not be processed</source>
          <target state="translated">Если она не нулевая,то выдается сообщение об ошибке,указывающее на то,почему эта строка не может быть обработана.</target>
        </trans-unit>
        <trans-unit id="96520540e7decec105d922c1561ef9f2b1d6ac9b" translate="yes" xml:space="preserve">
          <source>If on, any error will terminate the current session. By default, this is set to off, so that only FATAL errors will terminate the session.</source>
          <target state="translated">Если она включена,любая ошибка завершит текущую сессию.По умолчанию эта опция выключена,так что только ФАТАЛЬНЫЕ ошибки завершат сеанс.</target>
        </trans-unit>
        <trans-unit id="22cc3fdc7c909051830d32f3a9f4757f2bc2a2b3" translate="yes" xml:space="preserve">
          <source>If on, emit WAL-related debugging output. This parameter is only available if the &lt;code&gt;WAL_DEBUG&lt;/code&gt; macro was defined when PostgreSQL was compiled.</source>
          <target state="translated">Если включено, выводить отладочную информацию, относящуюся к WAL. Этот параметр доступен, только если макрос &lt;code&gt;WAL_DEBUG&lt;/code&gt; был определен при компиляции PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="ea0ac9e4d18cd146b0646e9f1eaaad11f3441b88" translate="yes" xml:space="preserve">
          <source>If on, emit information about lightweight lock usage. Lightweight locks are intended primarily to provide mutual exclusion of access to shared-memory data structures.</source>
          <target state="translated">Если включено,сообщите информацию об использовании облегченного замка.Легковесные замки предназначены,прежде всего,для обеспечения взаимного исключения доступа к структурам данных с общей памятью.</target>
        </trans-unit>
        <trans-unit id="108192b0a0e55fbd6c757081d9b7601d8b8f83e2" translate="yes" xml:space="preserve">
          <source>If on, emit information about lock usage. Information dumped includes the type of lock operation, the type of lock and the unique identifier of the object being locked or unlocked. Also included are bit masks for the lock types already granted on this object as well as for the lock types awaited on this object. For each lock type a count of the number of granted locks and waiting locks is also dumped as well as the totals. An example of the log file output is shown here:</source>
          <target state="translated">Если включено,сообщите информацию об использовании замка.Выдаваемая информация включает в себя тип работы блокировки,тип блокировки и уникальный идентификатор блокируемого или разблокируемого объекта.Также включаются битовые маски для типов блокировок,уже присвоенных данному объекту,а также для типов блокировок,ожидающих на данном объекте.Для каждого типа блокировки сбрасывается также количество предоставленных и ожидающих блокировок,а также итоговые значения.Пример вывода лог-файла показан здесь:</target>
        </trans-unit>
        <trans-unit id="fb4d7f85e50d03eb97a6b576612fc80288cfa67e" translate="yes" xml:space="preserve">
          <source>If on, emit information about resource usage during sort operations. This parameter is only available if the &lt;code&gt;TRACE_SORT&lt;/code&gt; macro was defined when PostgreSQL was compiled. (However, &lt;code&gt;TRACE_SORT&lt;/code&gt; is currently defined by default.)</source>
          <target state="translated">Если включен, выводить информацию об использовании ресурсов во время операций сортировки. Этот параметр доступен, только если макрос &lt;code&gt;TRACE_SORT&lt;/code&gt; был определен при компиляции PostgreSQL. (Однако &lt;code&gt;TRACE_SORT&lt;/code&gt; в настоящее время определен по умолчанию.)</target>
        </trans-unit>
        <trans-unit id="2d6e32677420949906412ec403c3421f5aa432cd" translate="yes" xml:space="preserve">
          <source>If on, emit information about user lock usage. Output is the same as for &lt;code&gt;trace_locks&lt;/code&gt;, only for advisory locks.</source>
          <target state="translated">Если включен, выводить информацию об использовании блокировки пользователем. Вывод такой же, как и для &lt;code&gt;trace_locks&lt;/code&gt; , только для рекомендательных блокировок.</target>
        </trans-unit>
        <trans-unit id="4f521f40c917171fc7c2808f83dd0cac811f61dc" translate="yes" xml:space="preserve">
          <source>If one PostgreSQL server cluster is planned to contain unrelated projects or users that should be, for the most part, unaware of each other, it is recommended to put them into separate databases and adjust authorizations and access controls accordingly. If the projects or users are interrelated, and thus should be able to use each other's resources, they should be put in the same database but probably into separate schemas; this provides a modular structure with namespace isolation and authorization control. More information about managing schemas is in &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa31b9c1a7b9373a56b5ac2143c494c8a9df5d88" translate="yes" xml:space="preserve">
          <source>If one argument of a binary operator invocation is of the &lt;code&gt;unknown&lt;/code&gt; type and the other is of a domain type, next check to see if there is an operator accepting exactly the domain's base type on both sides; if so, use it.</source>
          <target state="translated">Если один аргумент вызова бинарного оператора имеет &lt;code&gt;unknown&lt;/code&gt; тип, а другой - тип домена, затем проверьте, есть ли оператор, принимающий точно базовый тип домена с обеих сторон; если да, используйте его.</target>
        </trans-unit>
        <trans-unit id="f194f32ef831d4b3157a47fd2652de25dffaf886" translate="yes" xml:space="preserve">
          <source>If one argument of a binary operator invocation is of the &lt;code&gt;unknown&lt;/code&gt; type, then assume it is the same type as the other argument for this check. Invocations involving two &lt;code&gt;unknown&lt;/code&gt; inputs, or a unary operator with an &lt;code&gt;unknown&lt;/code&gt; input, will never find a match at this step.</source>
          <target state="translated">Если один аргумент вызова бинарного оператора имеет &lt;code&gt;unknown&lt;/code&gt; тип, тогда предположим, что это тот же тип, что и другой аргумент для этой проверки. Вызовы, включающие два &lt;code&gt;unknown&lt;/code&gt; входа или унарный оператор с &lt;code&gt;unknown&lt;/code&gt; входом, никогда не найдут совпадения на этом этапе.</target>
        </trans-unit>
        <trans-unit id="b3677d43219ced3f6fdb380478ec70536347404f" translate="yes" xml:space="preserve">
          <source>If one explicitly casts a bit-string value to &lt;code&gt;bit(n)&lt;/code&gt;, it will be truncated or zero-padded on the right to be exactly &lt;code&gt;n&lt;/code&gt; bits, without raising an error. Similarly, if one explicitly casts a bit-string value to &lt;code&gt;bit varying(n)&lt;/code&gt;, it will be truncated on the right if it is more than &lt;code&gt;n&lt;/code&gt; bits.</source>
          <target state="translated">Если кто-то явно приводит значение битовой строки к &lt;code&gt;bit(n)&lt;/code&gt; , оно будет усечено или дополнено нулями справа, чтобы быть ровно &lt;code&gt;n&lt;/code&gt; битами, без возникновения ошибки. Точно так же, если кто-то явно приводит значение битовой строки к &lt;code&gt;bit varying(n)&lt;/code&gt; , оно будет усечено справа, если оно больше, чем &lt;code&gt;n&lt;/code&gt; бит.</target>
        </trans-unit>
        <trans-unit id="7d503789d22d34918cc5945f90261d6c003a05f3" translate="yes" xml:space="preserve">
          <source>If one explicitly casts a value to &lt;code&gt;character varying(n)&lt;/code&gt; or &lt;code&gt;character(n)&lt;/code&gt;, then an over-length value will be truncated to &lt;code&gt;n&lt;/code&gt; characters without raising an error. (This too is required by the SQL standard.)</source>
          <target state="translated">Если кто-то явно приводит значение к &lt;code&gt;character varying(n)&lt;/code&gt; или к &lt;code&gt;character(n)&lt;/code&gt; , то слишком длинное значение будет усечено до &lt;code&gt;n&lt;/code&gt; символов без возникновения ошибки. (Это тоже требуется стандартом SQL.)</target>
        </trans-unit>
        <trans-unit id="1de7610e41ebab1a246a8c49a8f76058b712b92e" translate="yes" xml:space="preserve">
          <source>If one of the list items is the special name &lt;code&gt;$user&lt;/code&gt;, then the schema having the name returned by &lt;code&gt;CURRENT_USER&lt;/code&gt; is substituted, if there is such a schema and the user has &lt;code&gt;USAGE&lt;/code&gt; permission for it. (If not, &lt;code&gt;$user&lt;/code&gt; is ignored.)</source>
          <target state="translated">Если одним из элементов списка является специальное имя &lt;code&gt;$user&lt;/code&gt; , то подставляется схема с именем, возвращаемым &lt;code&gt;CURRENT_USER&lt;/code&gt; , если такая схема существует и пользователь имеет для нее разрешение &lt;code&gt;USAGE&lt;/code&gt; . (В противном случае &lt;code&gt;$user&lt;/code&gt; игнорируется.)</target>
        </trans-unit>
        <trans-unit id="19441d8efa255c5a903fe7f3e4cb160f4e49f55a" translate="yes" xml:space="preserve">
          <source>If only the parser is specified, then the new text search configuration initially has no mappings from token types to dictionaries, and therefore will ignore all words. Subsequent &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; commands must be used to create mappings to make the configuration useful. Alternatively, an existing text search configuration can be copied.</source>
          <target state="translated">Если указан только синтаксический анализатор, тогда новая конфигурация текстового поиска изначально не имеет сопоставлений от типов токенов к словарям и, следовательно, будет игнорировать все слова. Последующие команды &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; должны использоваться для создания сопоставлений, чтобы сделать конфигурацию полезной. В качестве альтернативы можно скопировать существующую конфигурацию текстового поиска.</target>
        </trans-unit>
        <trans-unit id="f8ecaaa3f305e080c140c9a79731fd19853d9256" translate="yes" xml:space="preserve">
          <source>If parentheses appear after &lt;code&gt;\g&lt;/code&gt;, they surround a space-separated list of &lt;code&gt;option&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; formatting-option clauses, which are interpreted in the same way as &lt;code&gt;\pset&lt;/code&gt;&lt;code&gt;option&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; commands, but take effect only for the duration of this query. In this list, spaces are not allowed around &lt;code&gt;=&lt;/code&gt; signs, but are required between option clauses. If &lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; is omitted, the named &lt;code&gt;option&lt;/code&gt; is changed in the same way as for &lt;code&gt;\pset&lt;/code&gt;&lt;code&gt;option&lt;/code&gt; with no explicit &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1317b8ae94e1b0f60e57dbb20e11b92a9f8c5a7" translate="yes" xml:space="preserve">
          <source>If partial newline-sensitive matching is specified, this affects &lt;code&gt;.&lt;/code&gt; and bracket expressions as with newline-sensitive matching, but not &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">Если указано частичное совпадение с учетом новой строки, это влияет &lt;code&gt;.&lt;/code&gt; и выражения в квадратных скобках, как при сопоставлении с учетом новой строки, но не &lt;code&gt;^&lt;/code&gt; и &lt;code&gt;$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5535f2a09b6cea90f6f2421f76ccf57b35834ee5" translate="yes" xml:space="preserve">
          <source>If pg_checksums is aborted or killed while enabling or disabling checksums, the cluster's data checksum configuration remains unchanged, and pg_checksums can be re-run to perform the same operation.</source>
          <target state="translated">Если при включении или выключении контрольных сумм pg_checksums прерывается или убивается,конфигурация контрольных сумм в кластере остается неизменной,и pg_checksums может быть повторно запущен для выполнения той же операции.</target>
        </trans-unit>
        <trans-unit id="329ffa5a3154cd15ee165233a8d448dbe8dc1875" translate="yes" xml:space="preserve">
          <source>If pg_rewind fails while processing, then the data folder of the target is likely not in a state that can be recovered. In such a case, taking a new fresh backup is recommended.</source>
          <target state="translated">Если во время обработки pg_rewind не удается,то,скорее всего,папка с данными цели не находится в состоянии,которое может быть восстановлено.В этом случае рекомендуется сделать новую свежую резервную копию.</target>
        </trans-unit>
        <trans-unit id="928868bbd3ab201faf3713aebe691a864c3216eb" translate="yes" xml:space="preserve">
          <source>If present, the operator class will become the default operator class for its data type. At most one operator class can be the default for a specific data type and index method.</source>
          <target state="translated">Если он присутствует,то класс оператора становится классом оператора по умолчанию для своего типа данных.Самым большим классом оператора может быть класс по умолчанию для конкретного типа данных и метода индекса.</target>
        </trans-unit>
        <trans-unit id="dce8d13840c91deea2eabbef36d881ff8d4820b8" translate="yes" xml:space="preserve">
          <source>If primary restarts while commits are waiting for acknowledgment, those waiting transactions will be marked fully committed once the primary database recovers. There is no way to be certain that all standbys have received all outstanding WAL data at time of the crash of the primary. Some transactions may not show as committed on the standby, even though they show as committed on the primary. The guarantee we offer is that the application will not receive explicit acknowledgment of the successful commit of a transaction until the WAL data is known to be safely received by all the synchronous standbys.</source>
          <target state="translated">Если первичные перезагрузки во время фиксации ожидают подтверждения,то эти ожидающие транзакции будут помечены как полностью зафиксированные после восстановления первичной базы данных.Невозможно быть уверенным в том,что все резервные копии получили все нерассмотренные данные WAL на момент сбоя первичной базы данных.Некоторые транзакции могут не отображаться как зафиксированные в режиме ожидания,даже если они отображаются как зафиксированные в первичной базе данных.Гарантия,которую мы предлагаем,заключается в том,что приложение не получит явного подтверждения успешного фиксации транзакции до тех пор,пока данные WAL не будут безопасно получены всеми синхронными резервными устройствами.</target>
        </trans-unit>
        <trans-unit id="cabf4b566b843e529d70b87d853fee3f06c7f4bf" translate="yes" xml:space="preserve">
          <source>If queries are simply broadcast unmodified, functions like &lt;code&gt;random()&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, and sequences can have different values on different servers. This is because each server operates independently, and because SQL queries are broadcast (and not actual modified rows). If this is unacceptable, either the middleware or the application must query such values from a single server and then use those values in write queries. Another option is to use this replication option with a traditional master-standby setup, i.e. data modification queries are sent only to the master and are propagated to the standby servers via master-standby replication, not by the replication middleware. Care must also be taken that all transactions either commit or abort on all servers, perhaps using two-phase commit (&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; and &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;). Pgpool-II and Continuent Tungsten are examples of this type of replication.</source>
          <target state="translated">Если запросы просто транслируются без изменений, такие функции, как &lt;code&gt;random()&lt;/code&gt; , &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; , и последовательности могут иметь разные значения на разных серверах. Это связано с тем, что каждый сервер работает независимо, а также потому, что запросы SQL транслируются (а не фактически измененные строки). Если это неприемлемо, промежуточное программное обеспечение или приложение должно запрашивать такие значения с одного сервера, а затем использовать эти значения в запросах на запись. Другой вариант - использовать эту опцию репликации с традиционной настройкой главный-резервный, то есть запросы на изменение данных отправляются только главному серверу и распространяются на резервные серверы через репликацию главный-резервный, а не промежуточным программным обеспечением репликации. Также необходимо следить за тем, чтобы все транзакции были зафиксированы или прерваны на всех серверах, возможно, с использованием двухфазной фиксации ( &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; и &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;). Pgpool-II и Continuent Tungsten являются примерами такого типа репликации.</target>
        </trans-unit>
        <trans-unit id="493b00be39141f1a1aeb09adbc6c889957fa4153" translate="yes" xml:space="preserve">
          <source>If queries are simply broadcast unmodified, functions like &lt;code&gt;random()&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, and sequences can have different values on different servers. This is because each server operates independently, and because SQL queries are broadcast (and not actual modified rows). If this is unacceptable, either the middleware or the application must query such values from a single server and then use those values in write queries. Another option is to use this replication option with a traditional master-standby setup, i.e., data modification queries are sent only to the master and are propagated to the standby servers via master-standby replication, not by the replication middleware. Care must also be taken that all transactions either commit or abort on all servers, perhaps using two-phase commit (&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; and &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;). Pgpool-II and Continuent Tungsten are examples of this type of replication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f63cea3b2db7baf929d271a8512ae9d2283784c6" translate="yes" xml:space="preserve">
          <source>If recovery finds corrupted WAL data, recovery will halt at that point and the server will not start. In such a case the recovery process could be re-run from the beginning, specifying a &amp;ldquo;recovery target&amp;rdquo; before the point of corruption so that recovery can complete normally. If recovery fails for an external reason, such as a system crash or if the WAL archive has become inaccessible, then the recovery can simply be restarted and it will restart almost from where it failed. Recovery restart works much like checkpointing in normal operation: the server periodically forces all its state to disk, and then updates the &lt;code&gt;pg_control&lt;/code&gt; file to indicate that the already-processed WAL data need not be scanned again.</source>
          <target state="translated">Если при восстановлении будут обнаружены поврежденные данные WAL, восстановление остановится на этом этапе и сервер не запустится. В таком случае процесс восстановления можно запустить заново с самого начала, указав &amp;laquo;цель восстановления&amp;raquo; до точки повреждения, чтобы восстановление могло завершиться нормально. Если восстановление не удается по внешней причине, например, из-за сбоя системы или если архив WAL стал недоступен, то восстановление можно просто перезапустить, и оно будет перезапущено почти с того места, где оно не удалось. Восстановительный перезапуск работает так же, как контрольная точка при нормальной работе: сервер периодически &lt;code&gt;pg_control&lt;/code&gt; все свое состояние на диск, а затем обновляет файл pg_control, чтобы указать, что уже обработанные данные WAL не нуждаются в повторном сканировании.</target>
        </trans-unit>
        <trans-unit id="28dab788b6122ef3bd1cdbda4da4f94cd1b6e630" translate="yes" xml:space="preserve">
          <source>If restoring from backup, rename or delete the old installation directory if it is not version-specific. It is a good idea to rename the directory, rather than delete it, in case you have trouble and need to revert to it. Keep in mind the directory might consume significant disk space. To rename the directory, use a command like this:</source>
          <target state="translated">При восстановлении из резервной копии переименуйте или удалите старый установочный каталог,если он не зависит от версии.Хорошей идеей будет переименовать каталог,а не удалять его,если у вас возникли проблемы и вам необходимо вернуться к нему.Помните,что каталог может потреблять значительное дисковое пространство.Чтобы переименовать каталог,используйте команду,подобную этой:</target>
        </trans-unit>
        <trans-unit id="e309c571c391be62f34e7db7a0c0dec41e3362c4" translate="yes" xml:space="preserve">
          <source>If role can log in, this specifies how many concurrent connections the role can make. -1 (the default) means no limit. Note that only normal connections are counted towards this limit. Neither prepared transactions nor background worker connections are counted towards this limit.</source>
          <target state="translated">Если роль может войти в систему,это определяет,сколько одновременных подключений может сделать эта роль.-1 (по умолчанию)означает отсутствие ограничений.Обратите внимание,что только обычные соединения засчитываются в этот предел.Ни подготовленные транзакции,ни фоновые соединения рабочих не засчитываются в этот предел.</target>
        </trans-unit>
        <trans-unit id="62496fbde4961b27e361cbfa11a352d993b40959" translate="yes" xml:space="preserve">
          <source>If row-level security is enabled for a table, but no applicable policies exist, a &amp;ldquo;default deny&amp;rdquo; policy is assumed, so that no rows will be visible or updatable.</source>
          <target state="translated">Если для таблицы включена защита на уровне строк, но не существует применимых политик, предполагается политика запрета по умолчанию, так что никакие строки не будут видимыми или обновляемыми.</target>
        </trans-unit>
        <trans-unit id="fe157e3ff3573012872e8150157f95ab8031e531" translate="yes" xml:space="preserve">
          <source>If row-level security is enabled for the table, the relevant &lt;code&gt;SELECT&lt;/code&gt; policies will apply to &lt;code&gt;COPY table TO&lt;/code&gt; statements. Currently, &lt;code&gt;COPY FROM&lt;/code&gt; is not supported for tables with row-level security. Use equivalent &lt;code&gt;INSERT&lt;/code&gt; statements instead.</source>
          <target state="translated">Если для таблицы включена защита на уровне строк, к &lt;code&gt;SELECT&lt;/code&gt; &lt;code&gt;COPY table TO&lt;/code&gt; будут применяться соответствующие политики SELECT . В настоящее время &lt;code&gt;COPY FROM&lt;/code&gt; не поддерживается для таблиц с безопасностью на уровне строк. Вместо этого используйте эквивалентные &lt;code&gt;INSERT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6aa638ed0fa1c0e796268aac030545b317ec979" translate="yes" xml:space="preserve">
          <source>If running in FreeBSD jails by enabling sysctl's &lt;code&gt;security.jail.sysvipc_allowed&lt;/code&gt;, postmasters running in different jails should be run by different operating system users. This improves security because it prevents non-root users from interfering with shared memory or semaphores in different jails, and it allows the PostgreSQL IPC cleanup code to function properly. (In FreeBSD 6.0 and later the IPC cleanup code does not properly detect processes in other jails, preventing the running of postmasters on the same port in different jails.)</source>
          <target state="translated">При запуске в тюрьмах FreeBSD с включением sysctl &lt;code&gt;security.jail.sysvipc_allowed&lt;/code&gt; почтовые мастера , работающие в разных тюрьмах, должны запускаться разными пользователями операционной системы. Это повышает безопасность, поскольку предотвращает вмешательство пользователей без полномочий root в общую память или семафоры в разных тюрьмах, а также позволяет коду очистки PostgreSQL IPC работать должным образом. (В FreeBSD 6.0 и более поздних версиях код очистки IPC неправильно определяет процессы в других тюрьмах, что препятствует запуску почтовых мастеров на одном и том же порте в разных тюрьмах.)</target>
        </trans-unit>
        <trans-unit id="3d60f2762027b6b57c372852caf475ebc7475d90" translate="yes" xml:space="preserve">
          <source>If running in a FreeBSD jail, you should set its &lt;code&gt;sysvshm&lt;/code&gt; parameter to &lt;code&gt;new&lt;/code&gt;, so that it has its own separate System V shared memory namespace. (Before FreeBSD 11.0, it was necessary to enable shared access to the host's IPC namespace from jails, and take measures to avoid collisions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abdee92b42312c6177118cbed677697bf85b5620" translate="yes" xml:space="preserve">
          <source>If set to 0, the realm name from the authenticated user principal is stripped off before being passed through the user name mapping (&lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt;). This is discouraged and is primarily available for backwards compatibility, as it is not secure in multi-realm environments unless &lt;code&gt;krb_realm&lt;/code&gt; is also used. It is recommended to leave &lt;code&gt;include_realm&lt;/code&gt; set to the default (1) and to provide an explicit mapping in &lt;code&gt;pg_ident.conf&lt;/code&gt; to convert principal names to PostgreSQL user names.</source>
          <target state="translated">Если установлено значение 0, имя области от аутентифицированного пользователя-участника удаляется перед передачей через отображение имени пользователя ( &lt;a href=&quot;auth-username-maps&quot;&gt;раздел 20.2&lt;/a&gt; ). Это не рекомендуется и в основном доступно для обратной совместимости, так как это небезопасно в средах с несколькими &lt;code&gt;krb_realm&lt;/code&gt; если также не используется krb_realm . Рекомендуется оставить для &lt;code&gt;include_realm&lt;/code&gt; значение по умолчанию (1) и предоставить явное отображение в &lt;code&gt;pg_ident.conf&lt;/code&gt; для преобразования основных имен в имена пользователей PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="752bcd0b9281c38894ddeb4c193f0b06ac531341" translate="yes" xml:space="preserve">
          <source>If set to 1 or less, sending an EOF character (usually &lt;strong&gt;Control&lt;/strong&gt;+&lt;strong&gt;D&lt;/strong&gt;) to an interactive session of psql will terminate the application. If set to a larger numeric value, that many consecutive EOF characters must be typed to make an interactive session terminate. If the variable is set to a non-numeric value, it is interpreted as 10. The default is 0.</source>
          <target state="translated">Если установлено значение 1 или меньше, отправка символа EOF (обычно &lt;strong&gt;Control&lt;/strong&gt; + &lt;strong&gt;D&lt;/strong&gt; ) в интерактивный сеанс psql завершит работу приложения. Если установлено большее числовое значение, необходимо набрать такое количество последовательных символов EOF, чтобы интерактивный сеанс завершился. Если для переменной задано нечисловое значение, оно интерпретируется как 10. Значение по умолчанию - 0.</target>
        </trans-unit>
        <trans-unit id="f150c6b9d3460dc605d8aac9efe72846ba7bd56d" translate="yes" xml:space="preserve">
          <source>If set to 1, the domain's SAM-compatible name (also known as the NetBIOS name) is used for the &lt;code&gt;include_realm&lt;/code&gt; option. This is the default. If set to 0, the true realm name from the Kerberos user principal name is used.</source>
          <target state="translated">Если установлено значение 1, SAM-совместимое имя домена (также известное как имя NetBIOS) используется для параметра &lt;code&gt;include_realm&lt;/code&gt; . Это значение по умолчанию. Если установлено значение 0, используется истинное имя области из основного имени пользователя Kerberos.</target>
        </trans-unit>
        <trans-unit id="82302c2f8409896da1eb7439e9dc154b96d3a8b4" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;all&lt;/code&gt;, all nonempty input lines are printed to standard output as they are read. (This does not apply to lines read interactively.) To select this behavior on program start-up, use the switch &lt;code&gt;-a&lt;/code&gt;. If set to &lt;code&gt;queries&lt;/code&gt;, psql prints each query to standard output as it is sent to the server. The switch to select this behavior is &lt;code&gt;-e&lt;/code&gt;. If set to &lt;code&gt;errors&lt;/code&gt;, then only failed queries are displayed on standard error output. The switch for this behavior is &lt;code&gt;-b&lt;/code&gt;. If set to &lt;code&gt;none&lt;/code&gt; (the default), then no queries are displayed.</source>
          <target state="translated">Если установлено значение &lt;code&gt;all&lt;/code&gt; , все непустые строки ввода выводятся на стандартный вывод по мере чтения. (Это не относится к строкам, читаемым в интерактивном режиме.) Чтобы выбрать это поведение при запуске программы, используйте переключатель &lt;code&gt;-a&lt;/code&gt; . Если установлено на &lt;code&gt;queries&lt;/code&gt; , psql выводит каждый запрос на стандартный вывод по мере его отправки на сервер. Переключатель для выбора этого поведения - &lt;code&gt;-e&lt;/code&gt; . Если установлено значение &lt;code&gt;errors&lt;/code&gt; , в стандартном выводе ошибок отображаются только неудавшиеся запросы. Переключатель для этого поведения - &lt;code&gt;-b&lt;/code&gt; . Если установлено значение &amp;laquo; &lt;code&gt;none&lt;/code&gt; (по умолчанию), запросы не отображаются.</target>
        </trans-unit>
        <trans-unit id="4e8e09a59b4bf762d85ca1f3a58b8a4dd3ab9bc9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;off&lt;/code&gt; (the default), detection of WAL records having references to invalid pages during recovery causes PostgreSQL to raise a PANIC-level error, aborting the recovery. Setting &lt;code&gt;ignore_invalid_pages&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt; causes the system to ignore invalid page references in WAL records (but still report a warning), and continue the recovery. This behavior may &lt;em&gt;cause crashes, data loss, propagate or hide corruption, or other serious problems&lt;/em&gt;. However, it may allow you to get past the PANIC-level error, to finish the recovery, and to cause the server to start up. The parameter can only be set at server start. It only has effect during recovery or in standby mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9981243abcd6bfa6b05982c27d6e7ff810b5e4a9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;on&lt;/code&gt; (the default), this option causes WAL files to be recycled by renaming them, avoiding the need to create new ones. On COW file systems, it may be faster to create new ones, so the option is given to disable this behavior.</source>
          <target state="translated">Если установлено значение &amp;laquo; &lt;code&gt;on&lt;/code&gt; (по умолчанию), эта опция вызывает переработку файлов WAL путем их переименования, избегая необходимости создавать новые. В файловых системах COW создание новых может быть быстрее, поэтому можно отключить это поведение.</target>
        </trans-unit>
        <trans-unit id="813f1fb7e134b84c20368173806332413bb9e2ea" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;on&lt;/code&gt; (the default), this option causes new WAL files to be filled with zeroes. On some file systems, this ensures that space is allocated before we need to write WAL records. However, &lt;em&gt;Copy-On-Write&lt;/em&gt; (COW) file systems may not benefit from this technique, so the option is given to skip the unnecessary work. If set to &lt;code&gt;off&lt;/code&gt;, only the final byte is written when the file is created so that it has the expected size.</source>
          <target state="translated">Если установлено значение &amp;laquo; &lt;code&gt;on&lt;/code&gt; (по умолчанию), этот параметр заставляет новые файлы WAL заполняться нулями. В некоторых файловых системах это обеспечивает выделение пространства до того, как нам понадобится записывать WAL-записи. Однако файловые системы с &lt;em&gt;копированием при записи&lt;/em&gt; (COW) могут не использовать этот метод, поэтому предоставляется возможность пропустить ненужную работу. Если установлено значение &lt;code&gt;off&lt;/code&gt; , при создании файла записывается только последний байт, чтобы он имел ожидаемый размер.</target>
        </trans-unit>
        <trans-unit id="0fba393e4d7deed9cb85ba465e5b27c9e3ab7dd3" translate="yes" xml:space="preserve">
          <source>If set to a non-existent library, JIT will not be available, but no error will be raised. This allows JIT support to be installed separately from the main PostgreSQL package.</source>
          <target state="translated">Если установить несуществующую библиотеку,JIT не будет доступен,но ошибка не будет поднята.Это позволяет установить поддержку JIT отдельно от основного пакета PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="b3b3af4f011e1d63d9b8223219828980a0583602" translate="yes" xml:space="preserve">
          <source>If set to on, PostgreSQL will instead report an error but continue to run so that the data flushing operation can be retried in a later checkpoint. Only set it to on after investigating the operating system's treatment of buffered data in case of write-back failure.</source>
          <target state="translated">Если эта опция включена,PostgreSQL вместо этого сообщит об ошибке,но продолжит работу,чтобы можно было повторить операцию промывки данных в более поздней контрольной точке.Включайте ее только после изучения обработки операционной системой буферизированных данных в случае отказа обратной записи.</target>
        </trans-unit>
        <trans-unit id="bbcf79a2d604d4a130bf67d3aa6808540ca830ba" translate="yes" xml:space="preserve">
          <source>If set, do not trace locks for tables below this OID (used to avoid output on system tables).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7ecf1b7610990cb56a543c68a5259c46df2a63" translate="yes" xml:space="preserve">
          <source>If set, do not trace locks for tables below this OID. (use to avoid output on system tables)</source>
          <target state="translated">Если установлено,не отслеживайте блокировки для таблиц ниже этого OID.(используйте,чтобы избежать вывода на системные таблицы)</target>
        </trans-unit>
        <trans-unit id="41deca852e6fe629c05086ec201225e618efe1c2" translate="yes" xml:space="preserve">
          <source>If set, dumps information about all current locks when a deadlock timeout occurs.</source>
          <target state="translated">Если установлено,то при наступлении тайм-аута блокировки сбрасывает информацию обо всех текущих блокировках.</target>
        </trans-unit>
        <trans-unit id="18ea3580271535268c36ef5f8d3f6aa2461f7a29" translate="yes" xml:space="preserve">
          <source>If set, logs system resource usage statistics (memory and CPU) on various B-tree operations.</source>
          <target state="translated">Если установлено,то регистрируется статистика использования системных ресурсов (памяти и процессора)при различных операциях с B-деревом.</target>
        </trans-unit>
        <trans-unit id="8cd44fecb272ef12a9372f7353f761fae8a5a0b8" translate="yes" xml:space="preserve">
          <source>If set, the name of the database to create, unless overridden on the command line.</source>
          <target state="translated">Если установлено,то имя БД для создания,если только оно не переопределено в командной строке.</target>
        </trans-unit>
        <trans-unit id="451271dfdfad4c754e04924937d10fe2728cec15" translate="yes" xml:space="preserve">
          <source>If several large tables all become eligible for vacuuming in a short amount of time, all autovacuum workers might become occupied with vacuuming those tables for a long period. This would result in other tables and databases not being vacuumed until a worker becomes available. There is no limit on how many workers might be in a single database, but workers do try to avoid repeating work that has already been done by other workers. Note that the number of running workers does not count towards &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; or &lt;a href=&quot;runtime-config-connection#GUC-SUPERUSER-RESERVED-CONNECTIONS&quot;&gt;superuser_reserved_connections&lt;/a&gt; limits.</source>
          <target state="translated">Если несколько больших столов станут подходящими для очистки за короткий промежуток времени, все рабочие, работающие с автовакуумом, могут быть заняты очисткой этих столов в течение длительного периода. Это приведет к тому, что другие таблицы и базы данных не будут очищены до тех пор, пока рабочий не станет доступен. Не существует ограничений на количество воркеров в одной базе данных, но воркеры стараются избегать повторения работы, которая уже была сделана другими воркерами. Обратите внимание, что количество работающих воркеров не учитывается в ограничениях &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; или &lt;a href=&quot;runtime-config-connection#GUC-SUPERUSER-RESERVED-CONNECTIONS&quot;&gt;superuser_reserved_connections&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c0765d00a52dbd937ed1bff59efeb02a5ce2381" translate="yes" xml:space="preserve">
          <source>If simultaneous snapshots are not possible, one option is to shut down the database server long enough to establish all the frozen snapshots. Another option is to perform a continuous archiving base backup (&lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;Section 25.3.2&lt;/a&gt;) because such backups are immune to file system changes during the backup. This requires enabling continuous archiving just during the backup process; restore is done using continuous archive recovery (&lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Section 25.3.4&lt;/a&gt;).</source>
          <target state="translated">Если одновременное создание моментальных снимков невозможно, один из вариантов - выключить сервер базы данных на время, достаточное для создания всех замороженных моментальных снимков. Другой вариант - выполнить непрерывное архивирование базовой резервной копии ( &lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;Раздел 25.3.2&lt;/a&gt; ), поскольку такие резервные копии невосприимчивы к изменениям файловой системы во время резервного копирования. Для этого необходимо включить непрерывное архивирование только во время процесса резервного копирования; восстановление выполняется с помощью непрерывного восстановления архива ( &lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Раздел 25.3.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7b56d1af18915d5bc67acc7e5f67cf1743ccd0db" translate="yes" xml:space="preserve">
          <source>If specific tables are named in a locking clause, then only rows coming from those tables are locked; any other tables used in the &lt;code&gt;SELECT&lt;/code&gt; are simply read as usual. A locking clause without a table list affects all tables used in the statement. If a locking clause is applied to a view or sub-query, it affects all tables used in the view or sub-query. However, these clauses do not apply to &lt;code&gt;WITH&lt;/code&gt; queries referenced by the primary query. If you want row locking to occur within a &lt;code&gt;WITH&lt;/code&gt; query, specify a locking clause within the &lt;code&gt;WITH&lt;/code&gt; query.</source>
          <target state="translated">Если определенные таблицы названы в предложении блокировки, то блокируются только строки, поступающие из этих таблиц; любые другие таблицы, используемые в &lt;code&gt;SELECT&lt;/code&gt; , просто читаются как обычно. Предложение блокировки без списка таблиц влияет на все таблицы, используемые в операторе. Если предложение блокировки применяется к представлению или подзапросу, оно влияет на все таблицы, используемые в представлении или подзапросе. Однако эти предложения не применяются к запросам &lt;code&gt;WITH&lt;/code&gt; ,на которые ссылается основной запрос. Если вы хотите, чтобы в запросе &lt;code&gt;WITH&lt;/code&gt; выполнялась блокировка строк , укажите предложение блокировки в запросе &lt;code&gt;WITH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="beba3aa15b0f31c93cbfaa613e20da31b4d61852" translate="yes" xml:space="preserve">
          <source>If specified, the sequence object is created only for this session, and is automatically dropped on session exit. Existing permanent sequences with the same name are not visible (in this session) while the temporary sequence exists, unless they are referenced with schema-qualified names.</source>
          <target state="translated">Если указано,то объект последовательности создается только для данной сессии,и автоматически сбрасывается при выходе из сессии.Существующие постоянные последовательности с одним и тем же именем не видны (в данной сессии),пока существует временная последовательность,если только на них не ссылаются с именами,заданными в схеме.</target>
        </trans-unit>
        <trans-unit id="96e1f90a66af2b7d727620148bca6f42e74b9d62" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as a temporary table. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">Если указано, таблица создается как временная таблица. Обратитесь к &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; за подробностями.</target>
        </trans-unit>
        <trans-unit id="a93d62c01130cfe765292bae429e3354023ac5a8" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as a temporary table. Temporary tables are automatically dropped at the end of a session, or optionally at the end of the current transaction (see &lt;code&gt;ON COMMIT&lt;/code&gt; below). Existing permanent tables with the same name are not visible to the current session while the temporary table exists, unless they are referenced with schema-qualified names. Any indexes created on a temporary table are automatically temporary as well.</source>
          <target state="translated">Если указано, таблица создается как временная таблица. Временные таблицы автоматически удаляются в конце сеанса или, необязательно, в конце текущей транзакции (см. &lt;code&gt;ON COMMIT&lt;/code&gt; ниже). Существующие постоянные таблицы с тем же именем не видны в текущем сеансе, пока существует временная таблица, если на них нет ссылок с именами, определенными схемой. Любые индексы, созданные во временной таблице, также автоматически становятся временными.</target>
        </trans-unit>
        <trans-unit id="e56b4bad12a19e93500049e2da8fe4abf56f18b0" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Data written to unlogged tables is not written to the write-ahead log (see &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;Chapter 29&lt;/a&gt;), which makes them considerably faster than ordinary tables. However, they are not crash-safe: an unlogged table is automatically truncated after a crash or unclean shutdown. The contents of an unlogged table are also not replicated to standby servers. Any indexes created on an unlogged table are automatically unlogged as well.</source>
          <target state="translated">Если указано, таблица создается как незарегистрированная. Данные, записываемые в незарегистрированные таблицы, не записываются в журнал упреждающей записи (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;Главу 29&lt;/a&gt; ), что делает их значительно быстрее, чем обычные таблицы. Однако они небезопасны: незарегистрированная таблица автоматически усекается после сбоя или нечистого завершения работы. Содержимое незарегистрированной таблицы также не реплицируется на резервные серверы. Любые индексы, созданные для незарегистрированной таблицы, также автоматически удаляются из журнала.</target>
        </trans-unit>
        <trans-unit id="a8596f70e4f839c2549fada82806079e6705f6bb" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Data written to unlogged tables is not written to the write-ahead log (see &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;Chapter 29&lt;/a&gt;), which makes them considerably faster than ordinary tables. However, they are not crash-safe: an unlogged table is automatically truncated after a crash or unclean shutdown. The contents of an unlogged table are also not replicated to standby servers. Any indexes created on an unlogged table are automatically unlogged as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498ade4fa6d89cb5e928b12b79fbd85a2d4b6bc5" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">Если указано, таблица создается как незарегистрированная. Обратитесь к &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; за подробностями.</target>
        </trans-unit>
        <trans-unit id="55118ee1dbd9adb1bf85c53f18502dc86e8b6ddb" translate="yes" xml:space="preserve">
          <source>If specified, the view is created as a temporary view. Temporary views are automatically dropped at the end of the current session. Existing permanent relations with the same name are not visible to the current session while the temporary view exists, unless they are referenced with schema-qualified names.</source>
          <target state="translated">Если указано,то вид создается как временный вид.Временные представления автоматически удаляются в конце текущего сеанса.Существующие постоянные отношения с одним и тем же названием не видны в текущем сеансе,пока существует временный вид,если только на них не ссылаются со схемными названиями.</target>
        </trans-unit>
        <trans-unit id="6b5dcbb0812dddc20d9371b9207b1cdb23e05524" translate="yes" xml:space="preserve">
          <source>If still not found, throw an error.</source>
          <target state="translated">Если все еще не найдено,бросьте ошибку.</target>
        </trans-unit>
        <trans-unit id="47cfc3e95fb2a4c5ace1abe2c232997982b636d2" translate="yes" xml:space="preserve">
          <source>If streaming replication is disabled, the paused state may continue indefinitely without a problem. If streaming replication is in progress then WAL records will continue to be received, which will eventually fill available disk space, depending upon the duration of the pause, the rate of WAL generation and available disk space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07af580d9fd90f0744560609d17c425a1c0582ea" translate="yes" xml:space="preserve">
          <source>If streaming replication is disabled, the paused state may continue indefinitely without problem. While streaming replication is in progress WAL records will continue to be received, which will eventually fill available disk space, depending upon the duration of the pause, the rate of WAL generation and available disk space.</source>
          <target state="translated">Если потоковая репликация отключена,состояние паузы может продолжаться бесконечно без проблем.Пока идет потоковая репликация,записи WAL будут продолжать поступать,что в конечном итоге заполнит доступное дисковое пространство,в зависимости от продолжительности паузы,скорости генерации WAL и доступного дискового пространства.</target>
        </trans-unit>
        <trans-unit id="226224ac165619e504532207642e17cb378b9939" translate="yes" xml:space="preserve">
          <source>If syslog is ultimately logging to a text file, then the effect will be the same either way, and it is best to leave the setting on, since most syslog implementations either cannot handle large messages or would need to be specially configured to handle them. But if syslog is ultimately writing into some other medium, it might be necessary or more useful to keep messages logically together.</source>
          <target state="translated">Если syslog в конечном итоге регистрируется в текстовом файле,то эффект будет одинаковым в любом случае,и лучше оставить настройку включенной,так как большинство реализаций syslog либо не могут обрабатывать большие сообщения,либо должны быть специально настроены для работы с ними.Но если syslog в конце концов записывается в какой-нибудь другой носитель,то,возможно,будет необходимо или более полезно сохранять сообщения логически вместе.</target>
        </trans-unit>
        <trans-unit id="5afa6f87265a39e1ce0df6a7d2ec06e5f9b70a1e" translate="yes" xml:space="preserve">
          <source>If systemd is in use, some care must be taken that IPC resources (including shared memory) are not prematurely removed by the operating system. This is especially of concern when installing PostgreSQL from source. Users of distribution packages of PostgreSQL are less likely to be affected, as the &lt;code&gt;postgres&lt;/code&gt; user is then normally created as a system user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c9f61d1e280ce039975396a48eef3020a367753" translate="yes" xml:space="preserve">
          <source>If systemd is in use, some care must be taken that IPC resources (shared memory and semaphores) are not prematurely removed by the operating system. This is especially of concern when installing PostgreSQL from source. Users of distribution packages of PostgreSQL are less likely to be affected, as the &lt;code&gt;postgres&lt;/code&gt; user is then normally created as a system user.</source>
          <target state="translated">Если используется systemd, необходимо позаботиться о том, чтобы ресурсы IPC (общая память и семафоры) не были преждевременно удалены операционной системой. Это особенно важно при установке PostgreSQL из исходников. Пользователи дистрибутивов PostgreSQL вряд ли пострадают, поскольку пользователь &lt;code&gt;postgres&lt;/code&gt; обычно создается как системный пользователь.</target>
        </trans-unit>
        <trans-unit id="0cc78b460318c43d7e2a2ae058784201d032436a" translate="yes" xml:space="preserve">
          <source>If table is a partition (see &lt;code&gt;relispartition&lt;/code&gt;), internal representation of the partition bound</source>
          <target state="translated">Если таблица является разделом (см. &lt;code&gt;relispartition&lt;/code&gt; ), внутреннее представление границы раздела</target>
        </trans-unit>
        <trans-unit id="2f2df2648f2943188802b9abf232f2ee4f995a24" translate="yes" xml:space="preserve">
          <source>If the &amp;ldquo;Access privileges&amp;rdquo; column is empty for a given object, it means the object has default privileges (that is, its privileges entry in the relevant system catalog is null). Default privileges always include all privileges for the owner, and can include some privileges for &lt;code&gt;PUBLIC&lt;/code&gt; depending on the object type, as explained above. The first &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; on an object will instantiate the default privileges (producing, for example, &lt;code&gt;miriam=arwdDxt/miriam&lt;/code&gt;) and then modify them per the specified request. Similarly, entries are shown in &amp;ldquo;Column privileges&amp;rdquo; only for columns with nondefault privileges. (Note: for this purpose, &amp;ldquo;default privileges&amp;rdquo; always means the built-in default privileges for the object's type. An object whose privileges have been affected by an &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; command will always be shown with an explicit privilege entry that includes the effects of the &lt;code&gt;ALTER&lt;/code&gt;.)</source>
          <target state="translated">Если столбец &amp;laquo;Привилегии доступа&amp;raquo; для данного объекта пуст, это означает, что объект имеет привилегии по умолчанию (то есть его запись о привилегиях в соответствующем системном каталоге пуста). Привилегии по умолчанию всегда включают все привилегии для владельца и могут включать некоторые привилегии для &lt;code&gt;PUBLIC&lt;/code&gt; в зависимости от типа объекта, как описано выше. Первый &lt;code&gt;GRANT&lt;/code&gt; или &lt;code&gt;REVOKE&lt;/code&gt; для объекта создаст экземпляр привилегий по умолчанию (например, &lt;code&gt;miriam=arwdDxt/miriam&lt;/code&gt; ), а затем измените их в соответствии с указанным запросом. Точно так же записи отображаются в &amp;laquo;Правах столбца&amp;raquo; только для столбцов с правами, отличными от заданных по умолчанию. (Примечание: для этой цели &amp;laquo;привилегии по умолчанию&amp;raquo; всегда означают встроенные привилегии по умолчанию для типа объекта. Объект, на привилегии которого повлияла команда &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; , всегда будет отображаться с явной записью привилегий, которая включает эффекты из &lt;code&gt;ALTER&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="ef8285ef018dbe08eadaac46ca6f457ffb7737a0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--check&lt;/code&gt; option was used, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">Если &lt;code&gt;--check&lt;/code&gt; опция --check , старый кластер не был изменен; его можно перезапустить.</target>
        </trans-unit>
        <trans-unit id="5231ab37a455b02818813f84dceafd365dc3d243" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--link&lt;/code&gt; option was &lt;em&gt;not&lt;/em&gt; used, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">Если опция &lt;code&gt;--link&lt;/code&gt; &lt;em&gt;не&lt;/em&gt; использовалась, старый кластер не был изменен; его можно перезапустить.</target>
        </trans-unit>
        <trans-unit id="9eaa5641cd34b4f83c2c8d2f48ba3f445ae08243" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--link&lt;/code&gt; option was used, the data files might be shared between the old and new cluster:</source>
          <target state="translated">Если &lt;code&gt;--link&lt;/code&gt; опция --link , файлы данных могли бы использоваться совместно старым и новым кластером:</target>
        </trans-unit>
        <trans-unit id="e5bb770bf0c6c53be90a08f4aadc13d0d045351b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;DELETE&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) deleted by the command.</source>
          <target state="translated">Если команда &lt;code&gt;DELETE&lt;/code&gt; содержит предложение &lt;code&gt;RETURNING&lt;/code&gt; , результат будет аналогичен результату &lt;code&gt;SELECT&lt;/code&gt; содержащего столбцы и значения, определенные в списке &lt;code&gt;RETURNING&lt;/code&gt; , вычисленном для строки (строк), удаленной командой.</target>
        </trans-unit>
        <trans-unit id="3edf0bee0b1a18174b6275c32dcc72778ff7f983" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GROUP BY&lt;/code&gt; clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If the &lt;code&gt;HAVING&lt;/code&gt; clause is present, it eliminates groups that do not satisfy the given condition. (See &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt; Clause&lt;/a&gt; and &lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt;&lt;code&gt;HAVING&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">Если указано предложение &lt;code&gt;GROUP BY&lt;/code&gt; или есть вызовы агрегатных функций, выходные данные объединяются в группы строк, которые соответствуют одному или нескольким значениям, и вычисляются результаты агрегатных функций. Если присутствует предложение &lt;code&gt;HAVING&lt;/code&gt; , оно удаляет группы, не удовлетворяющие данному условию. (См &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt; &lt;code&gt;GROUP BY&lt;/code&gt; пункт&lt;/a&gt; и &lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt; &lt;code&gt;HAVING&lt;/code&gt; пункта&lt;/a&gt; ниже) .</target>
        </trans-unit>
        <trans-unit id="8cba5ea5fe4b174dd3b26b5824e3815a353de168" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GROUP BY&lt;/code&gt; clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If the &lt;code&gt;HAVING&lt;/code&gt; clause is present, it eliminates groups that do not satisfy the given condition. (See &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;GROUP BY Clause&lt;/a&gt; and &lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt;HAVING Clause&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e73996306e544b116d96395fc6c635fa64541db1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;INSERT&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) inserted or updated by the command.</source>
          <target state="translated">Если команда &lt;code&gt;INSERT&lt;/code&gt; содержит предложение &lt;code&gt;RETURNING&lt;/code&gt; , результат будет аналогичен результату &lt;code&gt;SELECT&lt;/code&gt; содержащего столбцы и значения, определенные в списке &lt;code&gt;RETURNING&lt;/code&gt; , вычисленном для строк, вставленных или обновленных командой.</target>
        </trans-unit>
        <trans-unit id="0cef0ec98d8f962ff98a56a4b6b305bd357183c5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LIMIT&lt;/code&gt; (or &lt;code&gt;FETCH FIRST&lt;/code&gt;) or &lt;code&gt;OFFSET&lt;/code&gt; clause is specified, the &lt;code&gt;SELECT&lt;/code&gt; statement only returns a subset of the result rows. (See &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">Если указано предложение &lt;code&gt;LIMIT&lt;/code&gt; (или &lt;code&gt;FETCH FIRST&lt;/code&gt; ) или &lt;code&gt;OFFSET&lt;/code&gt; , &lt;code&gt;SELECT&lt;/code&gt; возвращает только подмножество строк результатов. (См. &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;Пункт &lt;/a&gt; &lt;code&gt;LIMIT&lt;/code&gt; ниже.)</target>
        </trans-unit>
        <trans-unit id="4a75230035fa0b522f04007a43794f1e0d2bb911" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LIMIT&lt;/code&gt; (or &lt;code&gt;FETCH FIRST&lt;/code&gt;) or &lt;code&gt;OFFSET&lt;/code&gt; clause is specified, the &lt;code&gt;SELECT&lt;/code&gt; statement only returns a subset of the result rows. (See &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d3a656a8d2961c5ae7c07dee89a103497dda43" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ORDER BY&lt;/code&gt; clause is specified, the returned rows are sorted in the specified order. If &lt;code&gt;ORDER BY&lt;/code&gt; is not given, the rows are returned in whatever order the system finds fastest to produce. (See &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">Если указано предложение &lt;code&gt;ORDER BY&lt;/code&gt; , возвращаемые строки сортируются в указанном порядке. Если &lt;code&gt;ORDER BY&lt;/code&gt; не указан, строки возвращаются в том порядке, который система считает наиболее быстрым для создания. (См. &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;Пункт &lt;/a&gt; &lt;code&gt;ORDER BY&lt;/code&gt; ниже.)</target>
        </trans-unit>
        <trans-unit id="d8ea2efbcef004128bc9ee33fa0b309eb98d431a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ORDER BY&lt;/code&gt; clause is specified, the returned rows are sorted in the specified order. If &lt;code&gt;ORDER BY&lt;/code&gt; is not given, the rows are returned in whatever order the system finds fastest to produce. (See &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY Clause&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc9caa8fd8396a40199c537204044cd80b03fd9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; command fails for any reason, it becomes a &lt;code&gt;ROLLBACK&lt;/code&gt;: the current transaction is canceled.</source>
          <target state="translated">Если команда &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; не выполняется по какой-либо причине, она становится &lt;code&gt;ROLLBACK&lt;/code&gt; : текущая транзакция отменяется.</target>
        </trans-unit>
        <trans-unit id="049a6b3315aa2fcc9292bf280d3fbac8f17f8faa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PREPARE&lt;/code&gt; statement that created the statement specified some parameters, a compatible set of parameters must be passed to the &lt;code&gt;EXECUTE&lt;/code&gt; statement, or else an error is raised. Note that (unlike functions) prepared statements are not overloaded based on the type or number of their parameters; the name of a prepared statement must be unique within a database session.</source>
          <target state="translated">Если оператор &lt;code&gt;PREPARE&lt;/code&gt; , создавший этот оператор, указывал некоторые параметры, совместимый набор параметров должен быть передан оператору &lt;code&gt;EXECUTE&lt;/code&gt; , в противном случае возникает ошибка. Обратите внимание, что (в отличие от функций) подготовленные операторы не перегружаются в зависимости от типа или количества их параметров; имя подготовленного оператора должно быть уникальным в рамках сеанса базы данных.</target>
        </trans-unit>
        <trans-unit id="4e671e1df94a35c63462372f63dbaab316b08304" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;UPDATE&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) updated by the command.</source>
          <target state="translated">Если команда &lt;code&gt;UPDATE&lt;/code&gt; содержит предложение &lt;code&gt;RETURNING&lt;/code&gt; , результат будет аналогичен результату &lt;code&gt;SELECT&lt;/code&gt; содержащего столбцы и значения, определенные в списке &lt;code&gt;RETURNING&lt;/code&gt; , вычисленные для строк, обновленных командой.</target>
        </trans-unit>
        <trans-unit id="e2d169320d1dac51b305dc4371af2fd872eb335a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WHERE&lt;/code&gt; clause is specified, all rows that do not satisfy the condition are eliminated from the output. (See &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;&lt;code&gt;WHERE&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">Если указано &lt;code&gt;WHERE&lt;/code&gt; , все строки, которые не удовлетворяют условию, удаляются из вывода. (См. &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;Пункт &lt;/a&gt; &lt;code&gt;WHERE&lt;/code&gt; ниже.)</target>
        </trans-unit>
        <trans-unit id="4af20d29d9d1228c78339d28ff758ffb08bbfc49" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WHERE&lt;/code&gt; clause is specified, all rows that do not satisfy the condition are eliminated from the output. (See &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;WHERE Clause&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b918e82e1dbdff8d47052fc332ee8551811a46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause is specified, an additional column of type &lt;code&gt;bigint&lt;/code&gt; will be added to the function result columns. This column numbers the rows of the function result set, starting from 1. (This is a generalization of the SQL-standard syntax for &lt;code&gt;UNNEST ... WITH ORDINALITY&lt;/code&gt;.) By default, the ordinal column is called &lt;code&gt;ordinality&lt;/code&gt;, but a different column name can be assigned to it using an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">Если &lt;code&gt;WITH ORDINALITY&lt;/code&gt; предложение WITH ORDINALITY , к столбцам результатов &lt;code&gt;bigint&lt;/code&gt; будет добавлен дополнительный столбец типа bigint . Это число столбцов в строки результирующего набора функций, начиная с 1. (Это обобщение SQL-стандартный синтаксис для &lt;code&gt;UNNEST ... WITH ORDINALITY&lt;/code&gt; .) По умолчанию, порядковый номер столбца называется &lt;code&gt;ordinality&lt;/code&gt; , но другое имя столбца может быть назначен ему с помощью предложения &lt;code&gt;AS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a9a2b1e5b5de3befe9a4b97f742aa542e0145cb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;count&lt;/code&gt; expression evaluates to NULL, it is treated as &lt;code&gt;LIMIT ALL&lt;/code&gt;, i.e., no limit. If &lt;code&gt;start&lt;/code&gt; evaluates to NULL, it is treated the same as &lt;code&gt;OFFSET 0&lt;/code&gt;.</source>
          <target state="translated">Если выражение &lt;code&gt;count&lt;/code&gt; оценивается как NULL, оно рассматривается как &lt;code&gt;LIMIT ALL&lt;/code&gt; , т. Е. Без ограничения. Если &lt;code&gt;start&lt;/code&gt; оценивается как NULL, он обрабатывается так же, как &lt;code&gt;OFFSET 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b469c74a0f6fb197601cf70011bbae3b5c0a8cbf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;dictionary&lt;/code&gt; argument is omitted, the text search dictionary named &lt;code&gt;unaccent&lt;/code&gt; and appearing in the same schema as the &lt;code&gt;unaccent()&lt;/code&gt; function itself is used.</source>
          <target state="translated">Если аргумент &lt;code&gt;dictionary&lt;/code&gt; опущен, используется словарь текстового поиска с именем &lt;code&gt;unaccent&lt;/code&gt; , который присутствует в той же схеме, что и сама функция &lt;code&gt;unaccent()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e92f2cba043fc31ab92cbc203c691c2c492c8d7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;expression&lt;/code&gt; is row-valued, then &lt;code&gt;IS NULL&lt;/code&gt; is true when the row expression itself is null or when all the row's fields are null, while &lt;code&gt;IS NOT NULL&lt;/code&gt; is true when the row expression itself is non-null and all the row's fields are non-null. Because of this behavior, &lt;code&gt;IS NULL&lt;/code&gt; and &lt;code&gt;IS NOT NULL&lt;/code&gt; do not always return inverse results for row-valued expressions; in particular, a row-valued expression that contains both null and non-null fields will return false for both tests. In some cases, it may be preferable to write &lt;code&gt;row&lt;/code&gt;&lt;code&gt;IS DISTINCT FROM NULL&lt;/code&gt; or &lt;code&gt;row&lt;/code&gt;&lt;code&gt;IS NOT DISTINCT FROM NULL&lt;/code&gt;, which will simply check whether the overall row value is null without any additional tests on the row fields.</source>
          <target state="translated">Если &lt;code&gt;expression&lt;/code&gt; имеет значение строки, то &lt;code&gt;IS NULL&lt;/code&gt; истинно, когда само выражение строки равно нулю или когда все поля строки равны нулю, а &lt;code&gt;IS NOT NULL&lt;/code&gt; истинно, когда само выражение строки не равно нулю и все поля строки равны нулю. ненулевой. Из-за этого поведения &lt;code&gt;IS NULL&lt;/code&gt; и &lt;code&gt;IS NOT NULL&lt;/code&gt; не всегда возвращают обратные результаты для выражений со строковыми значениями; в частности, выражение со значением строки, которое содержит как пустые, так и ненулевые поля, вернет false для обоих тестов. В некоторых случаях может быть предпочтительнее написать &lt;code&gt;row&lt;/code&gt; &lt;code&gt;IS DISTINCT FROM NULL&lt;/code&gt; или &lt;code&gt;row&lt;/code&gt; &lt;code&gt;IS NOT DISTINCT FROM NULL&lt;/code&gt; , который просто проверит, является ли общее значение строки нулевым без каких-либо дополнительных тестов в полях строки.</target>
        </trans-unit>
        <trans-unit id="8a9d5cf7323804505a12a8a728eb4b811573a010" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;system-username&lt;/code&gt; field starts with a slash (&lt;code&gt;/&lt;/code&gt;), the remainder of the field is treated as a regular expression. (See &lt;a href=&quot;functions-matching#POSIX-SYNTAX-DETAILS&quot;&gt;Section 9.7.3.1&lt;/a&gt; for details of PostgreSQL's regular expression syntax.) The regular expression can include a single capture, or parenthesized subexpression, which can then be referenced in the &lt;code&gt;database-username&lt;/code&gt; field as &lt;code&gt;\1&lt;/code&gt; (backslash-one). This allows the mapping of multiple user names in a single line, which is particularly useful for simple syntax substitutions. For example, these entries</source>
          <target state="translated">Если поле &lt;code&gt;system-username&lt;/code&gt; начинается с косой черты ( &lt;code&gt;/&lt;/code&gt; ), оставшаяся часть поля рассматривается как регулярное выражение. (Подробную информацию о синтаксисе регулярных выражений PostgreSQL см. В &lt;a href=&quot;functions-matching#POSIX-SYNTAX-DETAILS&quot;&gt;Разделе 9.7.3.1&lt;/a&gt; .) Регулярное выражение может включать одиночный захват или заключенное в скобки подвыражение, на которое затем можно ссылаться в поле &lt;code&gt;database-username&lt;/code&gt; как &lt;code&gt;\1&lt;/code&gt; (обратная косая черта). Это позволяет отображать несколько имен пользователей в одной строке, что особенно полезно для простых синтаксических замен. Например, эти записи</target>
        </trans-unit>
        <trans-unit id="482a504d7c75e328098ffe22edcbb1378a3f6faa" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;values&lt;/code&gt;&lt;/em&gt; arrays are specified, an &lt;em&gt;armor header&lt;/em&gt; is added to the armored format for each key/value pair. Both arrays must be single-dimensional, and they must be of the same length. The keys and values cannot contain any non-ASCII characters.</source>
          <target state="translated">Если указаны массивы &lt;em&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/em&gt; и &lt;em&gt; &lt;code&gt;values&lt;/code&gt; &lt;/em&gt; , &lt;em&gt;заголовок брони&lt;/em&gt; добавляется к армированному формату для каждой пары ключ / значение. Оба массива должны быть одномерными и иметь одинаковую длину. Ключи и значения не могут содержать символы, отличные от ASCII.</target>
        </trans-unit>
        <trans-unit id="7327537568cbffaa257fef6fbd8b81996eaef858" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;silent&lt;/code&gt;&lt;/em&gt; argument is specified and has the &lt;code&gt;true&lt;/code&gt; value, these functions suppress the same errors as the &lt;code&gt;@?&lt;/code&gt; and &lt;code&gt;@@&lt;/code&gt; operators.</source>
          <target state="translated">Если аргумент &lt;em&gt; &lt;code&gt;silent&lt;/code&gt; &lt;/em&gt; указан и имеет &lt;code&gt;true&lt;/code&gt; значение, эти функции подавляют те же ошибки, что и &lt;code&gt;@?&lt;/code&gt; и операторы &lt;code&gt;@@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceede46190dd53d528fe2b583d1ccadb6cf588b2" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; argument is specified, it provides an object containing named variables to be substituted into a &lt;code&gt;jsonpath&lt;/code&gt; expression.</source>
          <target state="translated">Если &lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt; аргумент &lt;em&gt;vars&lt;/em&gt; , он предоставляет объект, содержащий именованные переменные, которые нужно подставить в выражение &lt;code&gt;jsonpath&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a173c623ff67d4c364c8db6dbe6ae6c5c5c1b9dd" translate="yes" xml:space="preserve">
          <source>If the S2K key is to be used directly, then only S2K settings will be put into the session key packet. Otherwise the session key will be encrypted with the S2K key and put into the session key packet.</source>
          <target state="translated">Если ключ S2K будет использоваться напрямую,то в пакет ключей сеанса будут вставлены только настройки S2K.В противном случае ключ сеанса будет зашифрован с помощью ключа S2K и помещен в пакет ключей сеанса.</target>
        </trans-unit>
        <trans-unit id="cd334923ca7f6a61f76d5cc9802fe6d4f79f8249" translate="yes" xml:space="preserve">
          <source>If the Serializable transaction isolation level is used for all writes and for all reads which need a consistent view of the data, no other effort is required to ensure consistency. Software from other environments which is written to use serializable transactions to ensure consistency should &amp;ldquo;just work&amp;rdquo; in this regard in PostgreSQL.</source>
          <target state="translated">Если уровень изоляции транзакции Serializable используется для всех операций записи и чтения, для которых требуется согласованное представление данных, никаких других усилий для обеспечения согласованности не требуется. Программное обеспечение из других сред, написанное для использования сериализуемых транзакций для обеспечения согласованности, должно &amp;laquo;просто работать&amp;raquo; в этом отношении в PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="b3a85d8941e78b61fa6dfe5e13735d5c695c638d" translate="yes" xml:space="preserve">
          <source>If the argument begins with &lt;code&gt;|&lt;/code&gt;, then the entire remainder of the line is taken to be the &lt;code&gt;command&lt;/code&gt; to execute, and neither variable interpolation nor backquote expansion are performed in it. The rest of the line is simply passed literally to the shell.</source>
          <target state="translated">Если аргумент начинается с &lt;code&gt;|&lt;/code&gt; , то вся оставшаяся часть строки считается &lt;code&gt;command&lt;/code&gt; для выполнения, и в ней не выполняется ни интерполяция переменных, ни обратные кавычки. Остальная часть строки просто передается оболочке буквально.</target>
        </trans-unit>
        <trans-unit id="c120a5d678ef79b9fdd905518c659ce62747d5d3" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;json_strip_nulls&lt;/code&gt; contains duplicate field names in any object, the result could be semantically somewhat different, depending on the order in which they occur. This is not an issue for &lt;code&gt;jsonb_strip_nulls&lt;/code&gt; since &lt;code&gt;jsonb&lt;/code&gt; values never have duplicate object field names.</source>
          <target state="translated">Если аргумент &lt;code&gt;json_strip_nulls&lt;/code&gt; содержит повторяющиеся имена полей в каком-либо объекте, результат может быть семантически несколько другим, в зависимости от порядка, в котором они встречаются. Это не проблема для &lt;code&gt;jsonb_strip_nulls&lt;/code&gt; , поскольку значения &lt;code&gt;jsonb&lt;/code&gt; никогда не имеют повторяющихся имен полей объекта.</target>
        </trans-unit>
        <trans-unit id="da41d6b70ef3eb6374e923e599dfca0a856e8010" translate="yes" xml:space="preserve">
          <source>If the array expression yields a null array, the result of &lt;code&gt;ALL&lt;/code&gt; will be null. If the left-hand expression yields null, the result of &lt;code&gt;ALL&lt;/code&gt; is ordinarily null (though a non-strict comparison operator could possibly yield a different result). Also, if the right-hand array contains any null elements and no false comparison result is obtained, the result of &lt;code&gt;ALL&lt;/code&gt; will be null, not true (again, assuming a strict comparison operator). This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">Если выражение массива дает нулевой массив, результатом &lt;code&gt;ALL&lt;/code&gt; будет NULL. Если левое выражение дает значение null, результат &lt;code&gt;ALL&lt;/code&gt; обычно равен нулю (хотя оператор нестрогого сравнения может дать другой результат). Кроме того, если правый массив содержит какие-либо нулевые элементы и не получен ложный результат сравнения, результат &lt;code&gt;ALL&lt;/code&gt; будет нулевым, а не истинным (опять же, при условии строгого оператора сравнения). Это соответствует обычным правилам SQL для логических комбинаций нулевых значений.</target>
        </trans-unit>
        <trans-unit id="ae942e08ca17c439fb984995bab2b3f4a2ace54c" translate="yes" xml:space="preserve">
          <source>If the array expression yields a null array, the result of &lt;code&gt;ANY&lt;/code&gt; will be null. If the left-hand expression yields null, the result of &lt;code&gt;ANY&lt;/code&gt; is ordinarily null (though a non-strict comparison operator could possibly yield a different result). Also, if the right-hand array contains any null elements and no true comparison result is obtained, the result of &lt;code&gt;ANY&lt;/code&gt; will be null, not false (again, assuming a strict comparison operator). This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">Если выражение массива дает нулевой массив, результатом &lt;code&gt;ANY&lt;/code&gt; будет NULL. Если левое выражение дает null, результат &lt;code&gt;ANY&lt;/code&gt; обычно равен нулю (хотя оператор нестрогого сравнения может дать другой результат). Кроме того, если правый массив содержит какие-либо нулевые элементы и истинный результат сравнения не получен, результат &lt;code&gt;ANY&lt;/code&gt; будет нулевым, а не ложным (опять же, при условии строгого оператора сравнения). Это соответствует обычным правилам SQL для логических комбинаций нулевых значений.</target>
        </trans-unit>
        <trans-unit id="f33f8fbf54f510b9f47b6952f447521e0e216bb8" translate="yes" xml:space="preserve">
          <source>If the backup process monitors and ensures that all WAL segment files required for the backup are successfully archived then the &lt;code&gt;wait_for_archive&lt;/code&gt; parameter (which defaults to true) can be set to false to have &lt;code&gt;pg_stop_backup&lt;/code&gt; return as soon as the stop backup record is written to the WAL. By default, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait until all WAL has been archived, which can take some time. This option must be used with caution: if WAL archiving is not monitored correctly then the backup might not include all of the WAL files and will therefore be incomplete and not able to be restored.</source>
          <target state="translated">Если процесс резервного копирования отслеживает и гарантирует, что все файлы сегментов WAL, необходимые для резервного копирования, успешно заархивированы, тогда для параметра &lt;code&gt;wait_for_archive&lt;/code&gt; (по умолчанию установлено значение true) можно установить значение false, чтобы &lt;code&gt;pg_stop_backup&lt;/code&gt; возвращался, как только запись остановки резервного копирования будет записана в WAL. . По умолчанию &lt;code&gt;pg_stop_backup&lt;/code&gt; будет ждать, пока весь WAL не будет заархивирован, что может занять некоторое время. Эту опцию следует использовать с осторожностью: если архивирование WAL не контролируется должным образом, резервная копия может не включать все файлы WAL и поэтому будет неполной и не сможет быть восстановлена.</target>
        </trans-unit>
        <trans-unit id="c791af34bd6ddf53748d0f35d1bff063098edcb5" translate="yes" xml:space="preserve">
          <source>If the backup was taken with file checksums enabled, the following keys will be present:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38dbd4a01a3f520d833ada1c842bc701e68bca1c" translate="yes" xml:space="preserve">
          <source>If the cast is marked &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; then it can be invoked implicitly when assigning a value to a column of the target data type. For example, supposing that &lt;code&gt;foo.f1&lt;/code&gt; is a column of type &lt;code&gt;text&lt;/code&gt;, then:</source>
          <target state="translated">Если приведение помечено как &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; оно может быть вызвано неявно при присвоении значения столбцу целевого типа данных. Например, предположим, что &lt;code&gt;foo.f1&lt;/code&gt; - это столбец с типом &lt;code&gt;text&lt;/code&gt; , тогда:</target>
        </trans-unit>
        <trans-unit id="a854dcb7d27eca4b3717769b2da567eec36f84ca" translate="yes" xml:space="preserve">
          <source>If the cast is marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; then it can be invoked implicitly in any context, whether assignment or internally in an expression. (We generally use the term &lt;em&gt;implicit cast&lt;/em&gt; to describe this kind of cast.) For example, consider this query:</source>
          <target state="translated">Если приведение помечено как &lt;code&gt;AS IMPLICIT&lt;/code&gt; то оно может быть вызвано неявно в любом контексте, будь то присваивание или внутреннее выражение в выражении. (Обычно мы используем термин &lt;em&gt;неявное приведение&lt;/em&gt; для описания такого типа приведения.) Например, рассмотрим следующий запрос:</target>
        </trans-unit>
        <trans-unit id="61cd1b288599e699dce186b3244d616ce3ce9c86" translate="yes" xml:space="preserve">
          <source>If the catalog's &lt;code&gt;.h&lt;/code&gt; file specifies a default value for a column, and a data entry has that same value, &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; will omit it from the data file. This keeps the data representation compact.</source>
          <target state="translated">Если в файле &lt;code&gt;.h&lt;/code&gt; каталога указано значение по умолчанию для столбца, и запись данных имеет такое же значение, то файл с &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; файла. Это сохраняет компактность представления данных.</target>
        </trans-unit>
        <trans-unit id="e457eb8bdc9731b8c1605b478c130085944e5e2a" translate="yes" xml:space="preserve">
          <source>If the client character set is defined as &lt;code&gt;SQL_ASCII&lt;/code&gt;, encoding conversion is disabled, regardless of the server's character set. (However, if the server's character set is not &lt;code&gt;SQL_ASCII&lt;/code&gt;, the server will still check that incoming data is valid for that encoding; so the net effect is as though the client character set were the same as the server's.) Just as for the server, use of &lt;code&gt;SQL_ASCII&lt;/code&gt; is unwise unless you are working with all-ASCII data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae7f3745b8c55d9daa52727f8674ef5381e42f5" translate="yes" xml:space="preserve">
          <source>If the client character set is defined as &lt;code&gt;SQL_ASCII&lt;/code&gt;, encoding conversion is disabled, regardless of the server's character set. Just as for the server, use of &lt;code&gt;SQL_ASCII&lt;/code&gt; is unwise unless you are working with all-ASCII data.</source>
          <target state="translated">Если набор символов клиента определен как &lt;code&gt;SQL_ASCII&lt;/code&gt; , преобразование кодировки отключено, независимо от набора символов сервера. Как и в случае с сервером, использование &lt;code&gt;SQL_ASCII&lt;/code&gt; неразумно, если вы не работаете с данными, состоящими только из ASCII.</target>
        </trans-unit>
        <trans-unit id="0c4deed9a95ca57073b155e9cb8a0f5097708705" translate="yes" xml:space="preserve">
          <source>If the command is written as &lt;code&gt;ALTER FOREIGN TABLE IF EXISTS ...&lt;/code&gt; and the foreign table does not exist, no error is thrown. A notice is issued in this case.</source>
          <target state="translated">Если команда записана как &lt;code&gt;ALTER FOREIGN TABLE IF EXISTS ...&lt;/code&gt; и сторонняя таблица не существует, ошибка не возникает. В этом случае выдается уведомление.</target>
        </trans-unit>
        <trans-unit id="63d051a50066f7b8f700301bed696001489f1857" translate="yes" xml:space="preserve">
          <source>If the command returns a nonzero exit status then a warning log message will be written and the database will proceed to start up anyway. An exception is that if the command was terminated by a signal or an error by the shell (such as command not found), the database will not proceed with startup.</source>
          <target state="translated">Если команда вернет ненулевой статус выхода,то будет записано предупреждающее лог-сообщение,и БД все равно начнет работу.Исключением является то,что если команда была прервана сигналом или ошибкой оболочки (например,команда не найдена),то БД не будет продолжать загрузку.</target>
        </trans-unit>
        <trans-unit id="557bcc8e46db9e939ccd6eb079fcf5557fc3e866" translate="yes" xml:space="preserve">
          <source>If the command returns a nonzero exit status then a warning log message will be written. An exception is that if the command was terminated by a signal or an error by the shell (such as command not found), a fatal error will be raised.</source>
          <target state="translated">Если команда возвращает ненулевое состояние выхода,то будет записано предупреждающее сообщение журнала.Исключением является то,что если команда была прервана сигналом или ошибкой оболочки (например,команда не найдена),то будет поднята фатальная ошибка.</target>
        </trans-unit>
        <trans-unit id="6a74eec2662a9cc1d1ed60748980c12a4bf53d33" translate="yes" xml:space="preserve">
          <source>If the commands themselves contain &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;COMMIT&lt;/code&gt;, or &lt;code&gt;ROLLBACK&lt;/code&gt;, this option will not have the desired effects. Also, if an individual command cannot be executed inside a transaction block, specifying this option will cause the whole transaction to fail.</source>
          <target state="translated">Если сами команды содержат &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;COMMIT&lt;/code&gt; или &lt;code&gt;ROLLBACK&lt;/code&gt; , этот параметр не даст желаемых результатов. Кроме того, если отдельная команда не может быть выполнена внутри блока транзакции, указание этой опции приведет к сбою всей транзакции.</target>
        </trans-unit>
        <trans-unit id="02b4ea2a996ab5d0d7b4386241306a8c9bd92e8f" translate="yes" xml:space="preserve">
          <source>If the compared values are of a collatable data type, the appropriate collation OID will be passed to the comparison support function, using the standard &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; mechanism.</source>
          <target state="translated">Если сравниваемые значения относятся к сортируемому типу данных, соответствующий OID сопоставления будет передан в функцию поддержки сравнения с использованием стандартного механизма &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29c5e362afd4a1ac0e7c03190fce4c0374d970bb" translate="yes" xml:space="preserve">
          <source>If the compress method is lossy for leaf entries, the operator class cannot support index-only scans, and must not define a &lt;code&gt;fetch&lt;/code&gt; function.</source>
          <target state="translated">Если метод сжатия работает с потерями для конечных записей, класс оператора не может поддерживать сканирование только индекса и не должен определять функцию &lt;code&gt;fetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7447741114d4403590357da345ba571953f8d76" translate="yes" xml:space="preserve">
          <source>If the configuration file contains syntax errors or invalid parameter names, the server will not attempt to apply any settings from it, and therefore all the &lt;code&gt;applied&lt;/code&gt; fields will read as false. In such a case there will be one or more rows with non-null &lt;code&gt;error&lt;/code&gt; fields indicating the problem(s). Otherwise, individual settings will be applied if possible. If an individual setting cannot be applied (e.g., invalid value, or the setting cannot be changed after server start) it will have an appropriate message in the &lt;code&gt;error&lt;/code&gt; field. Another way that an entry might have &lt;code&gt;applied&lt;/code&gt; = false is that it is overridden by a later entry for the same parameter name; this case is not considered an error so nothing appears in the &lt;code&gt;error&lt;/code&gt; field.</source>
          <target state="translated">Если файл конфигурации содержит синтаксические ошибки или недопустимые имена параметров, сервер не будет пытаться применить какие-либо настройки из него, и поэтому все &lt;code&gt;applied&lt;/code&gt; поля будут считаться ложными. В таком случае будет одна или несколько строк с ненулевыми полями &lt;code&gt;error&lt;/code&gt; указывающими на проблему (ы). В противном случае, если возможно, будут применены индивидуальные настройки. Если отдельная настройка не может быть применена (например, недопустимое значение или настройка не может быть изменена после запуска сервера), в поле &lt;code&gt;error&lt;/code&gt; будет отображаться соответствующее сообщение . Другой способ, которым запись может &lt;code&gt;applied&lt;/code&gt; = false, состоит в том, что она заменяется более поздней записью с тем же именем параметра; этот случай не считается ошибкой , поэтому ничего не появляется в &lt;code&gt;error&lt;/code&gt; поле.</target>
        </trans-unit>
        <trans-unit id="6846426f89420f86ff7e1053a00d20ad214d1c83" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; is &lt;code&gt;off&lt;/code&gt;, then PostgreSQL recognizes backslash escapes in both regular and escape string constants. However, as of PostgreSQL 9.1, the default is &lt;code&gt;on&lt;/code&gt;, meaning that backslash escapes are recognized only in escape string constants. This behavior is more standards-compliant, but might break applications which rely on the historical behavior, where backslash escapes were always recognized. As a workaround, you can set this parameter to &lt;code&gt;off&lt;/code&gt;, but it is better to migrate away from using backslash escapes. If you need to use a backslash escape to represent a special character, write the string constant with an &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">Если конфигурация параметров &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; является &lt;code&gt;off&lt;/code&gt; , то PostgreSQL распознает обратный слеш в регулярных и эвакуационных строковых констант. Однако, как в PostgreSQL 9.1, по умолчанию &lt;code&gt;on&lt;/code&gt; , а это означает , что обратный слэш ускользает распознаются только в побеге строковых констант. Такое поведение больше соответствует стандартам, но может нарушить работу приложений, которые полагаются на историческое поведение, где всегда распознавались экранированные символы обратной косой черты. В качестве обходного пути вы можете &lt;code&gt;off&lt;/code&gt; этот параметр , но лучше отказаться от использования escape-символов обратной косой черты. Если вам необходимо использовать обратный косой побег представлять особый характер, писать постоянную строку с &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2bc2b10438374418a16365e82e01c5a0e70ba5" translate="yes" xml:space="preserve">
          <source>If the connection could not be made for any reason (e.g., insufficient privileges, server is not running on the targeted host, etc.), psql will return an error and terminate.</source>
          <target state="translated">Если соединение не удалось установить по какой-либо причине (например,недостаточные привилегии,сервер не работает на целевом хосте и т.д.),psql вернет ошибку и прервется.</target>
        </trans-unit>
        <trans-unit id="02930b22f9d6ca1f7733ab529d9a22a91b3fe5c0" translate="yes" xml:space="preserve">
          <source>If the connection is lost, or if it cannot be initially established, with a non-fatal error, pg_receivewal will retry the connection indefinitely, and reestablish streaming as soon as possible. To avoid this behavior, use the &lt;code&gt;-n&lt;/code&gt; parameter.</source>
          <target state="translated">Если соединение потеряно или если оно не может быть установлено изначально, из-за нефатальной ошибки, pg_receivewal будет повторять соединение на неопределенный срок и восстановит потоковую передачу как можно скорее. Чтобы избежать такого поведения, используйте параметр &lt;code&gt;-n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e7cb7e5b7e9cfa96c974efa30e7317e321f657f" translate="yes" xml:space="preserve">
          <source>If the conversion of a particular character is not possible &amp;mdash; suppose you chose &lt;code&gt;EUC_JP&lt;/code&gt; for the server and &lt;code&gt;LATIN1&lt;/code&gt; for the client, and some Japanese characters are returned that do not have a representation in &lt;code&gt;LATIN1&lt;/code&gt; &amp;mdash; an error is reported.</source>
          <target state="translated">Если преобразование определенного символа невозможно - предположим, вы выбрали &lt;code&gt;EUC_JP&lt;/code&gt; для сервера и &lt;code&gt;LATIN1&lt;/code&gt; для клиента, и возвращаются некоторые японские символы, не представленные в &lt;code&gt;LATIN1&lt;/code&gt; - выдается сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="5a6f84dd517ea12fd77c796a6737968d24f658ee" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is described instead.</source>
          <target state="translated">Если буфер текущего запроса пуст,то вместо него описывается последний отправленный запрос.</target>
        </trans-unit>
        <trans-unit id="2c57feb4352b9d0e5fa18cf7867721a0200da9c9" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead.</source>
          <target state="translated">Если буфер текущего запроса пуст,то вместо него повторно выполняется последний отправленный запрос.</target>
        </trans-unit>
        <trans-unit id="b8dce5eee9d2655efdc5121439aeb8029c6a8bb6" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead. Except for that behavior, &lt;code&gt;\g&lt;/code&gt; without an argument is essentially equivalent to a semicolon. A &lt;code&gt;\g&lt;/code&gt; with argument is a &amp;ldquo;one-shot&amp;rdquo; alternative to the &lt;code&gt;\o&lt;/code&gt; command.</source>
          <target state="translated">Если текущий буфер запроса пуст, вместо него повторно выполняется последний отправленный запрос. За исключением этого поведения, &lt;code&gt;\g&lt;/code&gt; без аргумента по сути эквивалентен точке с запятой. &lt;code&gt;\g&lt;/code&gt; с аргументом является &amp;laquo;один выстрел&amp;raquo; альтернатива &lt;code&gt;\o&lt;/code&gt; команде.</target>
        </trans-unit>
        <trans-unit id="8f856d88c69c6abc126b1520b07a26de33c6da81" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead. Except for that behavior, &lt;code&gt;\g&lt;/code&gt; without any arguments is essentially equivalent to a semicolon. With arguments, &lt;code&gt;\g&lt;/code&gt; provides a &amp;ldquo;one-shot&amp;rdquo; alternative to the &lt;code&gt;\o&lt;/code&gt; command, and additionally allows one-shot adjustments of the output formatting options normally set by &lt;code&gt;\pset&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1be77262ade382bd3daec36a4b4f5dfa260c3f" translate="yes" xml:space="preserve">
          <source>If the current table output format is unaligned, it is switched to aligned. If it is not unaligned, it is set to unaligned. This command is kept for backwards compatibility. See &lt;code&gt;\pset&lt;/code&gt; for a more general solution.</source>
          <target state="translated">Если текущий формат вывода таблицы не выровнен, он переключается на выровненный. Если он не выровнен, он устанавливается как невыровненный. Эта команда сохранена для обратной совместимости. См. &lt;code&gt;\pset&lt;/code&gt; для более общего решения.</target>
        </trans-unit>
        <trans-unit id="e6fb10bfb27f2916d0fe2c64c42424fe0e7351c4" translate="yes" xml:space="preserve">
          <source>If the cursor's query includes &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt;, then returned rows are locked at the time they are first fetched, in the same way as for a regular &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command with these options. In addition, the returned rows will be the most up-to-date versions; therefore these options provide the equivalent of what the SQL standard calls a &amp;ldquo;sensitive cursor&amp;rdquo;. (Specifying &lt;code&gt;INSENSITIVE&lt;/code&gt; together with &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt; is an error.)</source>
          <target state="translated">Если запрос курсора включает &lt;code&gt;FOR UPDATE&lt;/code&gt; или &lt;code&gt;FOR SHARE&lt;/code&gt; , то возвращаемые строки блокируются во время их первой выборки, так же, как для обычной команды &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; с этими параметрами. Кроме того, возвращенные строки будут самыми последними версиями; поэтому эти параметры обеспечивают эквивалент того, что в стандарте SQL называется &amp;laquo;чувствительный курсор&amp;raquo;. (Указание &lt;code&gt;INSENSITIVE&lt;/code&gt; вместе с &lt;code&gt;FOR UPDATE&lt;/code&gt; или &lt;code&gt;FOR SHARE&lt;/code&gt; является ошибкой.)</target>
        </trans-unit>
        <trans-unit id="41b7137b15f53bed5b5687626dcf24e407280bf1" translate="yes" xml:space="preserve">
          <source>If the data directory allows group read access then certificate files may need to be located outside of the data directory in order to conform to the security requirements outlined above. Generally, group access is enabled to allow an unprivileged user to backup the database, and in that case the backup software will not be able to read the certificate files and will likely error.</source>
          <target state="translated">Если каталог данных позволяет доступ к групповому считыванию,то файлы сертификатов,возможно,придется размещать вне каталога данных,чтобы соответствовать требованиям безопасности,описанным выше.Как правило,групповой доступ разрешен для того,чтобы позволить непривилегированному пользователю создать резервную копию базы данных,и в этом случае программа резервного копирования не сможет прочитать файлы сертификатов и,скорее всего,допустит ошибку.</target>
        </trans-unit>
        <trans-unit id="a675fdbbcb3f3826a4060560a5255875fb5f5fae" translate="yes" xml:space="preserve">
          <source>If the database crashes during the risk window between an asynchronous commit and the writing of the transaction's WAL records, then changes made during that transaction &lt;em&gt;will&lt;/em&gt; be lost. The duration of the risk window is limited because a background process (the &amp;ldquo;WAL writer&amp;rdquo;) flushes unwritten WAL records to disk every &lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay&lt;/a&gt; milliseconds. The actual maximum duration of the risk window is three times &lt;code&gt;wal_writer_delay&lt;/code&gt; because the WAL writer is designed to favor writing whole pages at a time during busy periods.</source>
          <target state="translated">Если база данных выйдет из строя во время окна риска между асинхронной фиксацией и записью записей WAL транзакции, то изменения, сделанные во время этой транзакции, &lt;em&gt;будут&lt;/em&gt; потеряны. Продолжительность окна риска ограничена, потому что фоновый процесс (&amp;laquo;писатель WAL&amp;raquo;) сбрасывает незаписанные записи WAL на диск каждые &lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay&lt;/a&gt; миллисекунды. Фактическая максимальная продолжительность окна риска в три раза больше &lt;code&gt;wal_writer_delay&lt;/code&gt; , потому что средство записи WAL разработано так, чтобы поддерживать запись целых страниц за раз в периоды занятости.</target>
        </trans-unit>
        <trans-unit id="74cf7d60a58d8b38555b75db3e52ebabab25c716" translate="yes" xml:space="preserve">
          <source>If the distance function returns &lt;code&gt;*recheck = true&lt;/code&gt; for any leaf node, the original ordering operator's return type must be &lt;code&gt;float8&lt;/code&gt; or &lt;code&gt;float4&lt;/code&gt;, and the distance function's result values must be comparable to those of the original ordering operator, since the executor will sort using both distance function results and recalculated ordering-operator results. Otherwise, the distance function's result values can be any finite &lt;code&gt;float8&lt;/code&gt; values, so long as the relative order of the result values matches the order returned by the ordering operator. (Infinity and minus infinity are used internally to handle cases such as nulls, so it is not recommended that &lt;code&gt;distance&lt;/code&gt; functions return these values.)</source>
          <target state="translated">Если функция расстояния возвращает &lt;code&gt;*recheck = true&lt;/code&gt; для любого листового узла, тип возврата исходного оператора упорядочивания должен быть &lt;code&gt;float8&lt;/code&gt; или &lt;code&gt;float4&lt;/code&gt; , а значения результата функции расстояния должны быть сопоставимы со значениями исходного оператора упорядочивания, поскольку исполнитель будет выполнять сортировку с использованием обоих результаты функции расстояния и пересчитанные результаты оператора упорядочения. В противном случае значения результата функции расстояния могут быть любыми конечными значениями типа &lt;code&gt;float8&lt;/code&gt; при условии, что относительный порядок значений результата соответствует порядку, возвращаемому оператором упорядочивания. (Бесконечность и минус бесконечность используются внутри для обработки таких случаев, как нули, поэтому не рекомендуется, чтобы функции &lt;code&gt;distance&lt;/code&gt; возвращали эти значения.)</target>
        </trans-unit>
        <trans-unit id="ad60be7600e8f04e894b95d59df12f985784fcd2" translate="yes" xml:space="preserve">
          <source>If the expression for any column is not of the correct data type, automatic type conversion will be attempted.</source>
          <target state="translated">Если выражение для какого-либо столбца не имеет правильного типа данных,будет предпринята попытка автоматического приведения типа.</target>
        </trans-unit>
        <trans-unit id="fd093b6fb186aee51925fae308b6305eb633a2c9" translate="yes" xml:space="preserve">
          <source>If the extension specifies a &lt;code&gt;schema&lt;/code&gt; parameter in its control file, then that schema cannot be overridden with a &lt;code&gt;SCHEMA&lt;/code&gt; clause. Normally, an error will be raised if a &lt;code&gt;SCHEMA&lt;/code&gt; clause is given and it conflicts with the extension's &lt;code&gt;schema&lt;/code&gt; parameter. However, if the &lt;code&gt;CASCADE&lt;/code&gt; clause is also given, then &lt;code&gt;schema_name&lt;/code&gt; is ignored when it conflicts. The given &lt;code&gt;schema_name&lt;/code&gt; will be used for installation of any needed extensions that do not specify &lt;code&gt;schema&lt;/code&gt; in their control files.</source>
          <target state="translated">Если расширение указывает параметр &lt;code&gt;schema&lt;/code&gt; в своем управляющем файле, то эту схему нельзя переопределить с помощью предложения &lt;code&gt;SCHEMA&lt;/code&gt; . Обычно ошибка возникает, если &lt;code&gt;SCHEMA&lt;/code&gt; предложение SCHEMA , которое конфликтует с параметром &lt;code&gt;schema&lt;/code&gt; расширения . Однако, если также указано предложение &lt;code&gt;CASCADE&lt;/code&gt; , тогда &lt;code&gt;schema_name&lt;/code&gt; игнорируется, когда оно конфликтует. Данное &lt;code&gt;schema_name&lt;/code&gt; будет использоваться для установки любых необходимых расширений, которые не указывают &lt;code&gt;schema&lt;/code&gt; в своих управляющих файлах.</target>
        </trans-unit>
        <trans-unit id="a4e9fcc86b43f21a64730501e9eaf321852f905e" translate="yes" xml:space="preserve">
          <source>If the file name is not an absolute path, it is taken as relative to the directory containing the referencing configuration file. Inclusions can be nested.</source>
          <target state="translated">Если имя файла не является абсолютным путем,то оно принимается относительно директории,содержащей файл конфигурации со ссылкой.Вложения могут быть вложены.</target>
        </trans-unit>
        <trans-unit id="932910bcbd5980a518e91a591612aedc56d65e69" translate="yes" xml:space="preserve">
          <source>If the final function is declared &amp;ldquo;strict&amp;rdquo;, then it will not be called when the ending state value is null; instead a null result will be returned automatically. (Of course this is just the normal behavior of strict functions.) In any case the final function has the option of returning a null value. For example, the final function for &lt;code&gt;avg&lt;/code&gt; returns null when it sees there were zero input rows.</source>
          <target state="translated">Если последняя функция объявлена ​​&amp;laquo;строгой&amp;raquo;, она не будет вызываться, когда значение конечного состояния равно нулю; вместо этого автоматически будет возвращен нулевой результат. (Конечно, это нормальное поведение строгих функций.) В любом случае последняя функция может возвращать нулевое значение. Например, последняя функция для &lt;code&gt;avg&lt;/code&gt; возвращает null, когда видит, что входных строк нет.</target>
        </trans-unit>
        <trans-unit id="8ca5420e4e4f7f8c6273c3bc64bbb9997a4e67c8" translate="yes" xml:space="preserve">
          <source>If the first argument is an unquoted &lt;code&gt;-n&lt;/code&gt; the trailing newline is not written (nor is the first argument).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a7650c2a7562a29717aee3a080c7db1eba72918" translate="yes" xml:space="preserve">
          <source>If the first argument is an unquoted &lt;code&gt;-n&lt;/code&gt; the trailing newline is not written.</source>
          <target state="translated">Если первый аргумент не заключен в кавычки &lt;code&gt;-n&lt;/code&gt; , завершающий символ новой строки не записывается.</target>
        </trans-unit>
        <trans-unit id="62fe782183ded831fa81846fd49b8967105614ff" translate="yes" xml:space="preserve">
          <source>If the function has been defined as returning the &lt;code&gt;record&lt;/code&gt; data type, then an alias or the key word &lt;code&gt;AS&lt;/code&gt; must be present, followed by a column definition list in the form &lt;code&gt;( column_name data_type [, ... ])&lt;/code&gt;. The column definition list must match the actual number and types of columns returned by the function.</source>
          <target state="translated">Если функция была определена как возвращающая тип данных &lt;code&gt;record&lt;/code&gt; , тогда должен присутствовать псевдоним или ключевое слово &lt;code&gt;AS&lt;/code&gt; , за которым следует список определений столбца в форме &lt;code&gt;( column_name data_type [, ... ])&lt;/code&gt; . Список определений столбцов должен соответствовать фактическому количеству и типам столбцов, возвращаемых функцией.</target>
        </trans-unit>
        <trans-unit id="dbc510e12f6154bfb8e0fdb71a70e5f4d7892b1d" translate="yes" xml:space="preserve">
          <source>If the function name is unique in its schema, it can be referred to without an argument list:</source>
          <target state="translated">Если имя функции уникально в ее схеме,на нее можно ссылаться без списка аргументов:</target>
        </trans-unit>
        <trans-unit id="02e65f28de3d6ebb00042e2e3e922f9485dd13f2" translate="yes" xml:space="preserve">
          <source>If the index AM wishes to cache data across successive index insertions within a SQL statement, it can allocate space in &lt;code&gt;indexInfo-&amp;gt;ii_Context&lt;/code&gt; and store a pointer to the data in &lt;code&gt;indexInfo-&amp;gt;ii_AmCache&lt;/code&gt; (which will be NULL initially).</source>
          <target state="translated">Если индексный AM желает кэшировать данные между последовательными вставками индекса в операторе SQL, он может выделить место в &lt;code&gt;indexInfo-&amp;gt;ii_Context&lt;/code&gt; и сохранить указатель на данные в &lt;code&gt;indexInfo-&amp;gt;ii_AmCache&lt;/code&gt; (который изначально будет NULL).</target>
        </trans-unit>
        <trans-unit id="152cfa54f1f6aaa3c6f3e246889a7fbd92291904" translate="yes" xml:space="preserve">
          <source>If the index marked &lt;code&gt;INVALID&lt;/code&gt; is suffixed &lt;code&gt;ccnew&lt;/code&gt;, then it corresponds to the transient index created during the concurrent operation, and the recommended recovery method is to drop it using &lt;code&gt;DROP INDEX&lt;/code&gt;, then attempt &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; again. If the invalid index is instead suffixed &lt;code&gt;ccold&lt;/code&gt;, it corresponds to the original index which could not be dropped; the recommended recovery method is to just drop said index, since the rebuild proper has been successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ff53fe7f3af3df2bf9787931d50cb513ad0685" translate="yes" xml:space="preserve">
          <source>If the index stores the original indexed data values (and not some lossy representation of them), it is useful to support &lt;a href=&quot;indexes-index-only-scans&quot;&gt;index-only scans&lt;/a&gt;, in which the index returns the actual data not just the TID of the heap tuple. This will only avoid I/O if the visibility map shows that the TID is on an all-visible page; else the heap tuple must be visited anyway to check MVCC visibility. But that is no concern of the access method's.</source>
          <target state="translated">Если индекс хранит исходные значения индексированных данных (а не их представление с потерями), полезно поддерживать &lt;a href=&quot;indexes-index-only-scans&quot;&gt;сканирование только индекса&lt;/a&gt; , при котором индекс возвращает фактические данные, а не только TID кортежа кучи. Это позволит избежать ввода-вывода, только если карта видимости показывает, что TID находится на полностью видимой странице; иначе кортеж кучи должен быть посещен в любом случае, чтобы проверить видимость MVCC. Но это не касается метода доступа.</target>
        </trans-unit>
        <trans-unit id="b10149280f25e55a72b1c339ba61c4a0b943ec93" translate="yes" xml:space="preserve">
          <source>If the index supports &lt;a href=&quot;indexes-index-only-scans&quot;&gt;index-only scans&lt;/a&gt; (i.e., &lt;code&gt;amcanreturn&lt;/code&gt; returns true for it), then on success the AM must also check &lt;code&gt;scan-&amp;gt;xs_want_itup&lt;/code&gt;, and if that is true it must return the originally indexed data for the index entry. The data can be returned in the form of an &lt;code&gt;IndexTuple&lt;/code&gt; pointer stored at &lt;code&gt;scan-&amp;gt;xs_itup&lt;/code&gt;, with tuple descriptor &lt;code&gt;scan-&amp;gt;xs_itupdesc&lt;/code&gt;; or in the form of a &lt;code&gt;HeapTuple&lt;/code&gt; pointer stored at &lt;code&gt;scan-&amp;gt;xs_hitup&lt;/code&gt;, with tuple descriptor &lt;code&gt;scan-&amp;gt;xs_hitupdesc&lt;/code&gt;. (The latter format should be used when reconstructing data that might possibly not fit into an &lt;code&gt;IndexTuple&lt;/code&gt;.) In either case, management of the data referenced by the pointer is the access method's responsibility. The data must remain good at least until the next &lt;code&gt;amgettuple&lt;/code&gt;, &lt;code&gt;amrescan&lt;/code&gt;, or &lt;code&gt;amendscan&lt;/code&gt; call for the scan.</source>
          <target state="translated">Если индекс поддерживает &lt;a href=&quot;indexes-index-only-scans&quot;&gt;сканирование только индекса&lt;/a&gt; (т. &lt;code&gt;amcanreturn&lt;/code&gt; возвращает для него true), то в случае успеха AM также должен проверить &lt;code&gt;scan-&amp;gt;xs_want_itup&lt;/code&gt; , и если это верно, он должен вернуть исходно проиндексированные данные для записи индекса. Данные могут быть возвращены в виде указателя &lt;code&gt;IndexTuple&lt;/code&gt; , хранящегося в &lt;code&gt;scan-&amp;gt;xs_itup&lt;/code&gt; , с дескриптором кортежа &lt;code&gt;scan-&amp;gt;xs_itupdesc&lt;/code&gt; ; или в виде указателя &lt;code&gt;HeapTuple&lt;/code&gt; , хранящегося в &lt;code&gt;scan-&amp;gt;xs_hitup&lt;/code&gt; , с дескриптором кортежа &lt;code&gt;scan-&amp;gt;xs_hitupdesc&lt;/code&gt; . (Последний формат следует использовать при восстановлении данных, которые могут не поместиться в &lt;code&gt;IndexTuple&lt;/code&gt; ..) В любом случае управление данными, на которые ссылается указатель, является обязанностью метода доступа. Данные должны оставаться в порядке, по крайней мере, до следующего &lt;code&gt;amgettuple&lt;/code&gt; , &lt;code&gt;amrescan&lt;/code&gt; или &lt;code&gt;amendscan&lt;/code&gt; для сканирования.</target>
        </trans-unit>
        <trans-unit id="5e5145a56a8fb3d00823c8f07c0c1ff1ea7857b4" translate="yes" xml:space="preserve">
          <source>If the indexed column is of a collatable data type, the index collation will be passed to all the support methods, using the standard &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; mechanism.</source>
          <target state="translated">Если индексированный столбец имеет упорядочиваемый тип данных, сопоставление индекса будет передано всем методам поддержки с использованием стандартного механизма &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d0af38ac011e98a3b87862ced9f4ed1d8303136" translate="yes" xml:space="preserve">
          <source>If the installation process completes without error, you can now start the server normally.</source>
          <target state="translated">Если процесс установки завершается без ошибок,теперь вы можете запустить сервер в нормальном режиме.</target>
        </trans-unit>
        <trans-unit id="801fad259abb36ce1c379ee710b758c893dc848e" translate="yes" xml:space="preserve">
          <source>If the internal structure of &lt;code&gt;box&lt;/code&gt; were an array of four &lt;code&gt;float4&lt;/code&gt; elements, we might instead use:</source>
          <target state="translated">Если бы внутренняя структура &lt;code&gt;box&lt;/code&gt; была массивом из четырех элементов &lt;code&gt;float4&lt;/code&gt; , мы могли бы вместо этого использовать:</target>
        </trans-unit>
        <trans-unit id="e0cb06bd991e3803ab381ac962733573ec921a97" translate="yes" xml:space="preserve">
          <source>If the isolation level, read/write mode, or deferrable mode is specified, the new transaction has those characteristics, as if &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; was executed.</source>
          <target state="translated">Если указан уровень изоляции, режим чтения / записи или отложенный режим, новая транзакция будет иметь эти характеристики, как если бы была выполнена &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="635140eb0238daad7904445c051be894be230f98" translate="yes" xml:space="preserve">
          <source>If the item to retrieve is an element of an array, you have to unnest this array using the &lt;code&gt;[*]&lt;/code&gt; operator. For example, the following path will return location coordinates for all the available track segments:</source>
          <target state="translated">Если извлекаемый элемент является элементом массива, вы должны удалить этот массив с помощью оператора &lt;code&gt;[*]&lt;/code&gt; . Например, следующий путь вернет координаты местоположения для всех доступных сегментов трека:</target>
        </trans-unit>
        <trans-unit id="97c86aa6976c29ec1d54566b16ef172364cf2f75" translate="yes" xml:space="preserve">
          <source>If the key is larger than the hash block size it will first be hashed and the result will be used as key.</source>
          <target state="translated">Если размер ключа больше,чем размер хеш-блока,то сначала он будет хэшироваться,а результат будет использоваться в качестве ключа.</target>
        </trans-unit>
        <trans-unit id="1aa8d866b0b556edb093be4c9a0ab389395324da" translate="yes" xml:space="preserve">
          <source>If the last path item is an object key, it will be created if it is absent and given the new value. If the last path item is an array index, if it is positive the item to set is found by counting from the left, and if negative by counting from the right - &lt;code&gt;-1&lt;/code&gt; designates the rightmost element, and so on. If the item is out of the range -array_length .. array_length -1, and create_missing is true, the new value is added at the beginning of the array if the item is negative, and at the end of the array if it is positive.</source>
          <target state="translated">Если последний элемент пути является ключом объекта, он будет создан, если он отсутствует, и ему будет присвоено новое значение. Если последний элемент пути является индексом массива, если он положительный, элемент для установки находится путем отсчета слева, а если отрицательный, путем отсчета справа - &lt;code&gt;-1&lt;/code&gt; обозначает крайний правый элемент и т. Д. Если элемент находится за пределами диапазона -длина_массива .. длина_массива -1 и create_missing истинно, новое значение добавляется в начало массива, если элемент отрицательный, и в конец массива, если он положительный.</target>
        </trans-unit>
        <trans-unit id="2188ba6147e78aaca8d5a46e0dc7277dd7c3324b" translate="yes" xml:space="preserve">
          <source>If the modifier &lt;code&gt;n&lt;/code&gt; (&amp;ldquo;nested&amp;rdquo;) is used, or a pattern is specified, then non-root partitioned relations are included, and a column is shown displaying the parent of each partitioned relation.</source>
          <target state="translated">Если используется модификатор &lt;code&gt;n&lt;/code&gt; (&amp;laquo;вложенный&amp;raquo;) или указан шаблон, то включаются некорневые секционированные отношения, и отображается столбец, отображающий родительский элемент каждого секционированного отношения.</target>
        </trans-unit>
        <trans-unit id="954bfa7fec82935e3cdcd8281374d6651335948e" translate="yes" xml:space="preserve">
          <source>If the new connection is successfully made, the previous connection is closed. If the connection attempt failed (wrong user name, access denied, etc.), the previous connection will only be kept if psql is in interactive mode. When executing a non-interactive script, processing will immediately stop with an error. This distinction was chosen as a user convenience against typos on the one hand, and a safety mechanism that scripts are not accidentally acting on the wrong database on the other hand.</source>
          <target state="translated">Если новое соединение успешно выполнено,предыдущее соединение закрывается.Если попытка соединения не увенчалась успехом (неверное имя пользователя,отказ в доступе и т.д.),предыдущее соединение будет сохранено только в том случае,если psql находится в интерактивном режиме.При выполнении неинтерактивного скрипта обработка немедленно прекращается с ошибкой.Это различие было выбрано в качестве удобства для пользователя против опечаток,с одной стороны,и в качестве защитного механизма,при котором скрипты не действуют случайно по неправильной базе данных,с другой стороны.</target>
        </trans-unit>
        <trans-unit id="f53d72a1eae9ceb05fc2fcc17f8301adebb27e79" translate="yes" xml:space="preserve">
          <source>If the new connection is successfully made, the previous connection is closed. If the connection attempt fails (wrong user name, access denied, etc.), the previous connection will be kept if psql is in interactive mode. But when executing a non-interactive script, processing will immediately stop with an error. This distinction was chosen as a user convenience against typos on the one hand, and a safety mechanism that scripts are not accidentally acting on the wrong database on the other hand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a5e26aea388ddd76a8f217c381769165be706df" translate="yes" xml:space="preserve">
          <source>If the new partition is a foreign table, nothing is done to verify that all the rows in the foreign table obey the partition constraint. (See the discussion in &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; about constraints on the foreign table.)</source>
          <target state="translated">Если новый раздел является сторонней таблицей, ничего не делается для проверки того, что все строки в сторонней таблице подчиняются ограничению разделения. (См. Обсуждение ограничений для сторонней таблицы в &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="f277321bdd9057205b2810a53bafd6facd91f266" translate="yes" xml:space="preserve">
          <source>If the new partition is a regular table, a full table scan is performed to check that existing rows in the table do not violate the partition constraint. It is possible to avoid this scan by adding a valid &lt;code&gt;CHECK&lt;/code&gt; constraint to the table that allows only rows satisfying the desired partition constraint before running this command. The &lt;code&gt;CHECK&lt;/code&gt; constraint will be used to determine that the table need not be scanned to validate the partition constraint. This does not work, however, if any of the partition keys is an expression and the partition does not accept &lt;code&gt;NULL&lt;/code&gt; values. If attaching a list partition that will not accept &lt;code&gt;NULL&lt;/code&gt; values, also add &lt;code&gt;NOT NULL&lt;/code&gt; constraint to the partition key column, unless it's an expression.</source>
          <target state="translated">Если новый раздел является обычной таблицей, выполняется полное сканирование таблицы, чтобы убедиться, что существующие строки в таблице не нарушают ограничение разделения. Можно избежать этого сканирования, добавив в таблицу допустимое ограничение &lt;code&gt;CHECK&lt;/code&gt; , которое допускает только строки, удовлетворяющие желаемому ограничению раздела, перед запуском этой команды. &lt;code&gt;CHECK&lt;/code&gt; ограничение будет использоваться , чтобы определить , что таблица не должен быть отсканирована для проверки ограничения раздела. Однако это не работает, если какой-либо из ключей раздела является выражением и раздел не принимает значения &lt;code&gt;NULL&lt;/code&gt; . При присоединении раздела списка, который не принимает значения &lt;code&gt;NULL&lt;/code&gt; , также добавьте &lt;code&gt;NOT NULL&lt;/code&gt; ограничение столбца ключа раздела, если это не выражение.</target>
        </trans-unit>
        <trans-unit id="48a04ec2659d2ed3b669f8d3fed6c4aa6cc05212" translate="yes" xml:space="preserve">
          <source>If the new value is inconsistent with the tuple prefix, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgSplitTuple&lt;/code&gt;. This action moves all the existing nodes into a new lower-level inner tuple, and replaces the existing inner tuple with a tuple having a single downlink pointing to the new lower-level inner tuple. Set &lt;code&gt;prefixHasPrefix&lt;/code&gt; to indicate whether the new upper tuple should have a prefix, and if so set &lt;code&gt;prefixPrefixDatum&lt;/code&gt; to the prefix value. This new prefix value must be sufficiently less restrictive than the original to accept the new value to be indexed. Set &lt;code&gt;prefixNNodes&lt;/code&gt; to the number of nodes needed in the new tuple, and set &lt;code&gt;prefixNodeLabels&lt;/code&gt; to a palloc'd array holding their labels, or to NULL if node labels are not required. Note that the total size of the new upper tuple must be no more than the total size of the tuple it is replacing; this constrains the lengths of the new prefix and new labels. Set &lt;code&gt;childNodeN&lt;/code&gt; to the index (from zero) of the node that will downlink to the new lower-level inner tuple. Set &lt;code&gt;postfixHasPrefix&lt;/code&gt; to indicate whether the new lower-level inner tuple should have a prefix, and if so set &lt;code&gt;postfixPrefixDatum&lt;/code&gt; to the prefix value. The combination of these two prefixes and the downlink node's label (if any) must have the same meaning as the original prefix, because there is no opportunity to alter the node labels that are moved to the new lower-level tuple, nor to change any child index entries. After the node has been split, the &lt;code&gt;choose&lt;/code&gt; function will be called again with the replacement inner tuple. That call may return an &lt;code&gt;spgAddNode&lt;/code&gt; result, if no suitable node was created by the &lt;code&gt;spgSplitTuple&lt;/code&gt; action. Eventually &lt;code&gt;choose&lt;/code&gt; must return &lt;code&gt;spgMatchNode&lt;/code&gt; to allow the insertion to descend to the next level.</source>
          <target state="translated">Если новое значение несовместимо с префиксом кортежа, установите для &lt;code&gt;resultType&lt;/code&gt; значение &lt;code&gt;spgSplitTuple&lt;/code&gt; . Это действие перемещает все существующие узлы в новый внутренний кортеж нижнего уровня и заменяет существующий внутренний кортеж на кортеж, имеющий единственную нисходящую ссылку, указывающую на новый внутренний кортеж нижнего уровня. Установите &lt;code&gt;prefixHasPrefix&lt;/code&gt; , чтобы указать, должен ли новый верхний кортеж иметь префикс, и если да, установите &lt;code&gt;prefixPrefixDatum&lt;/code&gt; в значение префикса. Это новое значение префикса должно быть достаточно менее ограничительным, чем исходное, чтобы можно было индексировать новое значение. Установите &lt;code&gt;prefixNNodes&lt;/code&gt; на количество узлов, необходимых в новом кортеже, и установите &lt;code&gt;prefixNodeLabels&lt;/code&gt; в массив palloc, содержащий их метки, или в NULL, если метки узлов не требуются. Обратите внимание, что общий размер нового верхнего кортежа не должен быть больше, чем общий размер заменяемого кортежа; это ограничивает длину нового префикса и новых меток. Установите для &lt;code&gt;childNodeN&lt;/code&gt; индекс (от нуля) узла, который будет подключаться к новому внутреннему кортежу нижнего уровня. Установите &lt;code&gt;postfixHasPrefix&lt;/code&gt; , чтобы указать, должен ли новый внутренний кортеж нижнего уровня иметь префикс, и если да, установите &lt;code&gt;postfixPrefixDatum&lt;/code&gt; к значению префикса. Комбинация этих двух префиксов и метки нисходящего узла (если есть) должна иметь то же значение, что и исходный префикс, потому что нет возможности ни изменить метки узла, которые перемещаются в новый кортеж нижнего уровня, ни изменить какой-либо записи дочернего индекса. После разделения узла функция &lt;code&gt;choose&lt;/code&gt; будет вызвана снова с заменяющим внутренним кортежем. Этот вызов может вернуть результат &lt;code&gt;spgAddNode&lt;/code&gt; , если с &lt;code&gt;spgSplitTuple&lt;/code&gt; действия spgSplitTuple не был создан подходящий узел . В конце концов , &lt;code&gt;choose&lt;/code&gt; должен вернуться &lt;code&gt;spgMatchNode&lt;/code&gt; , чтобы позволить вставку спуститься на следующий уровень.</target>
        </trans-unit>
        <trans-unit id="cad207ddb2eaf025fe9a90fd7f853c4606a19762" translate="yes" xml:space="preserve">
          <source>If the new value matches one of the existing child nodes, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgMatchNode&lt;/code&gt;. Set &lt;code&gt;nodeN&lt;/code&gt; to the index (from zero) of that node in the node array. Set &lt;code&gt;levelAdd&lt;/code&gt; to the increment in &lt;code&gt;level&lt;/code&gt; caused by descending through that node, or leave it as zero if the operator class does not use levels. Set &lt;code&gt;restDatum&lt;/code&gt; to equal &lt;code&gt;leafDatum&lt;/code&gt; if the operator class does not modify datums from one level to the next, or otherwise set it to the modified value to be used as &lt;code&gt;leafDatum&lt;/code&gt; at the next level.</source>
          <target state="translated">Если новое значение соответствует одному из существующих дочерних узлов, установите для &lt;code&gt;resultType&lt;/code&gt; значение &lt;code&gt;spgMatchNode&lt;/code&gt; . Установите &lt;code&gt;nodeN&lt;/code&gt; на индекс (с нуля) этого узла в массиве узлов. Установите &lt;code&gt;levelAdd&lt;/code&gt; к приращению &lt;code&gt;level&lt;/code&gt; вызванному спуском через этот узел, или оставьте его равным нулю, если класс оператора не использует уровни. Установите &lt;code&gt;restDatum&lt;/code&gt; равным &lt;code&gt;leafDatum&lt;/code&gt; , если класс оператора не изменяет данные с одного уровня на другой, или в противном случае установите его на измененное значение, которое будет использоваться как &lt;code&gt;leafDatum&lt;/code&gt; на следующем уровне.</target>
        </trans-unit>
        <trans-unit id="b192c266d3e1a4a0032d805a8345acd4fec22c20" translate="yes" xml:space="preserve">
          <source>If the non-unknown inputs are not all of the same type category, fail.</source>
          <target state="translated">Если неизвестные входы не все относятся к одной и той же категории типа,откажитесь.</target>
        </trans-unit>
        <trans-unit id="21b9de4f5d381ca1caadda7c1730c20093d98952" translate="yes" xml:space="preserve">
          <source>If the numeric token contains a colon (&lt;code&gt;:&lt;/code&gt;), this is a time string. Include all subsequent digits and colons.</source>
          <target state="translated">Если числовая лексема содержит двоеточие ( &lt;code&gt;:&lt;/code&gt; ), это время строка. Включите все последующие цифры и двоеточия.</target>
        </trans-unit>
        <trans-unit id="31a587270029792d925fa073ce1717b2b1a5ee50" translate="yes" xml:space="preserve">
          <source>If the numeric token contains a dash (&lt;code&gt;-&lt;/code&gt;), slash (&lt;code&gt;/&lt;/code&gt;), or two or more dots (&lt;code&gt;.&lt;/code&gt;), this is a date string which might have a text month. If a date token has already been seen, it is instead interpreted as a time zone name (e.g., &lt;code&gt;America/New_York&lt;/code&gt;).</source>
          <target state="translated">Если числовой маркер содержит тире ( &lt;code&gt;-&lt;/code&gt; ), косую черту ( &lt;code&gt;/&lt;/code&gt; ) или две или более точки ( &lt;code&gt;.&lt;/code&gt; ), Это строка даты, которая может содержать текстовый месяц. Если маркер даты уже был замечен, он вместо этого интерпретируется как имя часового пояса (например, &lt;code&gt;America/New_York&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ee076bf4dbead171f4fb25426abca0b1193f6e2" translate="yes" xml:space="preserve">
          <source>If the operating system provides support for using multiple locales within a single program (&lt;code&gt;newlocale&lt;/code&gt; and related functions), or if support for ICU is configured, then when a database cluster is initialized, &lt;code&gt;initdb&lt;/code&gt; populates the system catalog &lt;code&gt;pg_collation&lt;/code&gt; with collations based on all the locales it finds in the operating system at the time.</source>
          <target state="translated">Если операционная система поддерживает использование нескольких локалей в одной программе ( &lt;code&gt;newlocale&lt;/code&gt; и связанные функции) или если настроена поддержка ICU, то при инициализации кластера базы данных &lt;code&gt;initdb&lt;/code&gt; заполняет системный каталог &lt;code&gt;pg_collation&lt;/code&gt; параметрами сортировки на основе всех локалей. он находит в операционной системе в то время.</target>
        </trans-unit>
        <trans-unit id="ac5399d971a7de7c9b73abf76e58c0bf1b2aae3d" translate="yes" xml:space="preserve">
          <source>If the operation does not complete within the timeout (see option &lt;code&gt;-t&lt;/code&gt;), then &lt;code&gt;pg_ctl&lt;/code&gt; exits with a nonzero exit status. But note that the operation might continue in the background and eventually succeed.</source>
          <target state="translated">Если операция не завершается в течение тайм-аута (см. Параметр &lt;code&gt;-t&lt;/code&gt; ), тогда &lt;code&gt;pg_ctl&lt;/code&gt; завершает работу с ненулевым статусом выхода. Но учтите, что операция может продолжаться в фоновом режиме и в конечном итоге завершиться успешно.</target>
        </trans-unit>
        <trans-unit id="14ab0f7eed5fb08edbafe519f61a48bda6216b85" translate="yes" xml:space="preserve">
          <source>If the optional &lt;code&gt;NO CYCLE&lt;/code&gt; key word is specified, any calls to &lt;code&gt;nextval&lt;/code&gt; after the sequence has reached its maximum value will return an error. If neither &lt;code&gt;CYCLE&lt;/code&gt; or &lt;code&gt;NO CYCLE&lt;/code&gt; are specified, the old cycle behavior will be maintained.</source>
          <target state="translated">Если указано необязательное ключевое слово &lt;code&gt;NO CYCLE&lt;/code&gt; , любые вызовы &lt;code&gt;nextval&lt;/code&gt; после того, как последовательность достигла своего максимального значения, вернут ошибку. Если ни &lt;code&gt;CYCLE&lt;/code&gt; , ни &lt;code&gt;NO CYCLE&lt;/code&gt; не указаны, поведение старого цикла будет сохранено.</target>
        </trans-unit>
        <trans-unit id="2dc933189fc3de8b16aa112ce975759af1f0b257" translate="yes" xml:space="preserve">
          <source>If the optional Boolean parameter &lt;code&gt;collatable&lt;/code&gt; is true, column definitions and expressions of the type may carry collation information through use of the &lt;code&gt;COLLATE&lt;/code&gt; clause. It is up to the implementations of the functions operating on the type to actually make use of the collation information; this does not happen automatically merely by marking the type collatable.</source>
          <target state="translated">Если необязательный логический параметр &lt;code&gt;collatable&lt;/code&gt; имеет значение true, определения столбцов и выражения типа могут нести информацию сопоставления с помощью предложения &lt;code&gt;COLLATE&lt;/code&gt; . Реализации функций, работающих с типом, должны фактически использовать информацию о сопоставлении; это не происходит автоматически, просто помечая тип как сопоставимый.</target>
        </trans-unit>
        <trans-unit id="bdfeb01a261949b7092b2cbd814cde7a65edc244" translate="yes" xml:space="preserve">
          <source>If the ordering of siblings of the same parent is important, include the &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; parameter to specify which field to order siblings by. This field can be of any sortable data type. The output column list must include a final integer serial-number column, if and only if &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; is specified.</source>
          <target state="translated">Если порядок братьев и сестер одного и того же родителя важен, &lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt; параметр &lt;em&gt;orderby_fld,&lt;/em&gt; чтобы указать, по какому полю упорядочивать братьев и сестер. Это поле может иметь любой сортируемый тип данных. Список выходных столбцов должен включать последний целочисленный столбец с серийным номером, если и только если &lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3ed5ab7fc15ec983050d9cabedbfee6290fa8126" translate="yes" xml:space="preserve">
          <source>If the output column is a composite (row) type, and the JSON value is a JSON object, the fields of the object are converted to columns of the output row type by recursive application of these rules.</source>
          <target state="translated">Если выходной столбец является составным (строчным)типом,а значение JSON является JSON-объектом,то поля объекта преобразуются в столбцы выходного типа строки путем рекурсивного применения этих правил.</target>
        </trans-unit>
        <trans-unit id="c25ff23eb72be3bfb20da8609dc04d07dc26b478" translate="yes" xml:space="preserve">
          <source>If the output column is of type &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt;, the JSON value is just reproduced exactly.</source>
          <target state="translated">Если выходной столбец имеет тип &lt;code&gt;json&lt;/code&gt; или &lt;code&gt;jsonb&lt;/code&gt; , значение JSON просто воспроизводится точно.</target>
        </trans-unit>
        <trans-unit id="50b9656459eac8e751efab8869d145ae99f220b8" translate="yes" xml:space="preserve">
          <source>If the password is encrypted with SCRAM-SHA-256, it has the format:</source>
          <target state="translated">Если пароль зашифрован с помощью SCRAM-SHA-256,то он имеет формат:</target>
        </trans-unit>
        <trans-unit id="d0f9a0afdced3c84c5a56565915bd16c67d24a36" translate="yes" xml:space="preserve">
          <source>If the path expression returns an empty node-set (typically, when it does not match) for a given row, the column will be set to &lt;code&gt;NULL&lt;/code&gt;, unless a &lt;code&gt;default_expression&lt;/code&gt; is specified; then the value resulting from evaluating that expression is used.</source>
          <target state="translated">Если выражение пути возвращает пустой набор узлов (обычно, когда он не совпадает) для данной строки, столбец будет установлен в &lt;code&gt;NULL&lt;/code&gt; , если не указано &lt;code&gt;default_expression&lt;/code&gt; ; затем используется значение, полученное в результате вычисления этого выражения.</target>
        </trans-unit>
        <trans-unit id="e0c947f55da31c1d5c1555adf98bd354dc366c84" translate="yes" xml:space="preserve">
          <source>If the primary is isolated from remaining standby servers you should fail over to the best candidate of those other remaining standby servers.</source>
          <target state="translated">Если первичный сервер изолирован от остальных резервных серверов,то вы должны отказаться от лучшего кандидата из оставшихся резервных серверов.</target>
        </trans-unit>
        <trans-unit id="fa67ddcebd2151f0eb68edd839f12d39677af43a" translate="yes" xml:space="preserve">
          <source>If the primary server fails and the standby server becomes the new primary, and then the old primary restarts, you must have a mechanism for informing the old primary that it is no longer the primary. This is sometimes known as STONITH (Shoot The Other Node In The Head), which is necessary to avoid situations where both systems think they are the primary, which will lead to confusion and ultimately data loss.</source>
          <target state="translated">Если первичный сервер выходит из строя и резервный сервер становится новым первичным,а затем старый первичный перезагружается,у вас должен быть механизм информирования старого первичного сервера о том,что он больше не является первичным.Иногда это называется STONITH (Shoot The Other Node In The Head-Стреляй по другому узлу в голову),что необходимо для того,чтобы избежать ситуаций,когда обе системы думают,что они являются первичными,что приведет к путанице и,в конечном счете,потере данных.</target>
        </trans-unit>
        <trans-unit id="5ef10647b0698fbedd9383d4669217342caae5e0" translate="yes" xml:space="preserve">
          <source>If the primary server fails then the standby server should begin failover procedures.</source>
          <target state="translated">Если основной сервер выходит из строя,то резервный сервер должен начать процедуру обхода отказа.</target>
        </trans-unit>
        <trans-unit id="3c8481924c3ba4dda86247ddbf4dd7292be6f835" translate="yes" xml:space="preserve">
          <source>If the private key is protected with a passphrase, the server will prompt for the passphrase and will not start until it has been entered. Using a passphrase by default disables the ability to change the server's SSL configuration without a server restart, but see &lt;a href=&quot;runtime-config-connection#GUC-SSL-PASSPHRASE-COMMAND-SUPPORTS-RELOAD&quot;&gt;ssl_passphrase_command_supports_reload&lt;/a&gt;. Furthermore, passphrase-protected private keys cannot be used at all on Windows.</source>
          <target state="translated">Если закрытый ключ защищен парольной фразой, сервер запросит парольную фразу и не запустится, пока она не будет введена. Использование кодовой фразы по умолчанию отключает возможность изменения конфигурации SSL сервера без перезапуска сервера, но см. &lt;a href=&quot;runtime-config-connection#GUC-SSL-PASSPHRASE-COMMAND-SUPPORTS-RELOAD&quot;&gt;Ssl_passphrase_command_supports_reload&lt;/a&gt; . Более того, закрытые ключи, защищенные парольной фразой, вообще не могут использоваться в Windows.</target>
        </trans-unit>
        <trans-unit id="48f80ecbcca6b903e77ef9cdbab43d62afcd07ee" translate="yes" xml:space="preserve">
          <source>If the procedure has any output parameters, then a result row will be returned, containing the values of those parameters.</source>
          <target state="translated">Если процедура имеет какие-либо выходные параметры,то будет возвращена строка результата,содержащая значения этих параметров.</target>
        </trans-unit>
        <trans-unit id="1290513a0720d5678ce9e07e692a24b4a58d5efd" translate="yes" xml:space="preserve">
          <source>If the products table is set up so that, say, &lt;code&gt;product_id&lt;/code&gt; is the primary key, then it would be enough to group by &lt;code&gt;product_id&lt;/code&gt; in the above example, since name and price would be &lt;em&gt;functionally dependent&lt;/em&gt; on the product ID, and so there would be no ambiguity about which name and price value to return for each product ID group.</source>
          <target state="translated">Если таблица продуктов настроена так, что, скажем, &lt;code&gt;product_id&lt;/code&gt; является первичным ключом, тогда будет достаточно сгруппировать по &lt;code&gt;product_id&lt;/code&gt; в приведенном выше примере, поскольку имя и цена будут &lt;em&gt;функционально зависеть&lt;/em&gt; от идентификатора продукта, и поэтому будет нет двусмысленности в том, какое имя и значение цены возвращать для каждой группы идентификаторов продуктов.</target>
        </trans-unit>
        <trans-unit id="e03a5d6f408539b4e08801b317931a00ecee94a9" translate="yes" xml:space="preserve">
          <source>If the query contains any window functions (see &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt; and &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;), these functions are evaluated after any grouping, aggregation, and &lt;code&gt;HAVING&lt;/code&gt; filtering is performed. That is, if the query uses any aggregates, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;HAVING&lt;/code&gt;, then the rows seen by the window functions are the group rows instead of the original table rows from &lt;code&gt;FROM&lt;/code&gt;/&lt;code&gt;WHERE&lt;/code&gt;.</source>
          <target state="translated">Если запрос содержит какие-либо оконные функции (см. &lt;a href=&quot;tutorial-window&quot;&gt;Раздел 3.5&lt;/a&gt; , &lt;a href=&quot;functions-window&quot;&gt;Раздел 9.21&lt;/a&gt; и &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Раздел 4.2.8&lt;/a&gt; ), эти функции оцениваются после выполнения любой группировки, агрегации и фильтрации &lt;code&gt;HAVING&lt;/code&gt; . То есть, если в запросе используются какие-либо агрегаты, &lt;code&gt;GROUP BY&lt;/code&gt; или &lt;code&gt;HAVING&lt;/code&gt; , то строки, видимые оконными функциями, являются строками группы, а не исходными строками таблицы из &lt;code&gt;FROM&lt;/code&gt; / &lt;code&gt;WHERE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a48d893df2efd76b2d73680b987bd53b81b2adad" translate="yes" xml:space="preserve">
          <source>If the query contains any window functions (see &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.22&lt;/a&gt; and &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;), these functions are evaluated after any grouping, aggregation, and &lt;code&gt;HAVING&lt;/code&gt; filtering is performed. That is, if the query uses any aggregates, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;HAVING&lt;/code&gt;, then the rows seen by the window functions are the group rows instead of the original table rows from &lt;code&gt;FROM&lt;/code&gt;/&lt;code&gt;WHERE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e83ebc0874906fce6a1aa2d76fdc21590b6b98b1" translate="yes" xml:space="preserve">
          <source>If the query fails or does not return one row, no variables are changed.</source>
          <target state="translated">Если запрос не удается или не возвращает одну строку,переменные не изменяются.</target>
        </trans-unit>
        <trans-unit id="baf42f0acc3f09fcc4a0d0dd54cac78d65c286a5" translate="yes" xml:space="preserve">
          <source>If the query requires joining two or more relations, plans for joining relations are considered after all feasible plans have been found for scanning single relations. The three available join strategies are:</source>
          <target state="translated">Если запрос требует присоединения двух или более отношений,планы присоединения рассматриваются после того,как будут найдены все возможные планы для сканирования одного отношения.Доступны три стратегии присоединения:</target>
        </trans-unit>
        <trans-unit id="2e9c3a0d6f1b6d02143aa6739bb627c7730a051b" translate="yes" xml:space="preserve">
          <source>If the query uses fewer than &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; relations, a near-exhaustive search is conducted to find the best join sequence. The planner preferentially considers joins between any two relations for which there exist a corresponding join clause in the &lt;code&gt;WHERE&lt;/code&gt; qualification (i.e., for which a restriction like &lt;code&gt;where rel1.attr1=rel2.attr2&lt;/code&gt; exists). Join pairs with no join clause are considered only when there is no other choice, that is, a particular relation has no available join clauses to any other relation. All possible plans are generated for every join pair considered by the planner, and the one that is (estimated to be) the cheapest is chosen.</source>
          <target state="translated">Если в запросе используется меньше, чем &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; отношений, выполняется почти полный поиск, чтобы найти лучшую последовательность соединения. Планировщик предпочтительно рассматривает соединения между любыми двумя отношениями, для которых существует соответствующее предложение соединения в квалификации &lt;code&gt;WHERE&lt;/code&gt; (т. &lt;code&gt;where rel1.attr1=rel2.attr2&lt;/code&gt; Для которых существует ограничение, например, where rel1.attr1 = rel2.attr2 ). Пары соединения без предложения соединения рассматриваются только тогда, когда нет другого выбора, то есть конкретное отношение не имеет доступных предложений соединения с любым другим отношением. Все возможные планы генерируются для каждой пары соединений, рассматриваемой планировщиком, и выбирается тот, который (оценивается как самый дешевый).</target>
        </trans-unit>
        <trans-unit id="fcb1910db08273fa485c28070ee9179ceccf3c73" translate="yes" xml:space="preserve">
          <source>If the referenced column(s) are changed frequently, it might be wise to add an index to the referencing column(s) so that referential actions associated with the foreign key constraint can be performed more efficiently.</source>
          <target state="translated">Если ссылающиеся столбцы часто меняются,то,возможно,было бы разумно добавить индекс в ссылающиеся столбцы,чтобы ссылочные действия,связанные с ограничением постороннего ключа,могли выполняться более эффективно.</target>
        </trans-unit>
        <trans-unit id="2e6cbc38cc65944231eb0e20f1c30488fbd5652a" translate="yes" xml:space="preserve">
          <source>If the role executing &lt;code&gt;GRANT&lt;/code&gt; holds the required privileges indirectly via more than one role membership path, it is unspecified which containing role will be recorded as having done the grant. In such cases it is best practice to use &lt;code&gt;SET ROLE&lt;/code&gt; to become the specific role you want to do the &lt;code&gt;GRANT&lt;/code&gt; as.</source>
          <target state="translated">Если роль, выполняющая &lt;code&gt;GRANT&lt;/code&gt; , имеет требуемые привилегии косвенно, через несколько путей членства в ролях, не указано, какая содержащая роль будет записана как выполнившая предоставление. В таких случаях лучше всего использовать &lt;code&gt;SET ROLE&lt;/code&gt; , чтобы стать конкретной ролью, от которой вы хотите выполнять &lt;code&gt;GRANT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24d9b80ef7c6da193a9a22333ae220223fd8b0ac" translate="yes" xml:space="preserve">
          <source>If the role executing &lt;code&gt;REVOKE&lt;/code&gt; holds privileges indirectly via more than one role membership path, it is unspecified which containing role will be used to perform the command. In such cases it is best practice to use &lt;code&gt;SET ROLE&lt;/code&gt; to become the specific role you want to do the &lt;code&gt;REVOKE&lt;/code&gt; as. Failure to do so might lead to revoking privileges other than the ones you intended, or not revoking anything at all.</source>
          <target state="translated">Если роль, выполняющая &lt;code&gt;REVOKE&lt;/code&gt; , имеет привилегии косвенно через несколько путей членства в ролях, не указано, какая содержащая роль будет использоваться для выполнения команды. В таких случаях лучше всего использовать &lt;code&gt;SET ROLE&lt;/code&gt; , чтобы стать конкретной ролью, от которой вы хотите выполнять &lt;code&gt;REVOKE&lt;/code&gt; . Невыполнение этого требования может привести к отмене привилегий, отличных от тех, которые вы намеревались сделать, или вообще ничего не отозвать.</target>
        </trans-unit>
        <trans-unit id="9127d1a2bf0d40475f431a0daa0c09f299f8d847" translate="yes" xml:space="preserve">
          <source>If the same channel name is signaled multiple times from the same transaction with identical payload strings, the database server can decide to deliver a single notification only. On the other hand, notifications with distinct payload strings will always be delivered as distinct notifications. Similarly, notifications from different transactions will never get folded into one notification. Except for dropping later instances of duplicate notifications, &lt;code&gt;NOTIFY&lt;/code&gt; guarantees that notifications from the same transaction get delivered in the order they were sent. It is also guaranteed that messages from different transactions are delivered in the order in which the transactions committed.</source>
          <target state="translated">Если одно и то же имя канала передается несколько раз из одной и той же транзакции с идентичными строками полезной нагрузки, сервер базы данных может решить доставить только одно уведомление. С другой стороны, уведомления с отдельными строками полезной нагрузки всегда будут доставляться как отдельные уведомления. Точно так же уведомления от разных транзакций никогда не будут объединены в одно уведомление. За исключением отбрасывания более поздних экземпляров повторяющихся уведомлений, &lt;code&gt;NOTIFY&lt;/code&gt; гарантирует, что уведомления из той же транзакции будут доставлены в том порядке, в котором они были отправлены. Также гарантируется, что сообщения от разных транзакций доставляются в том порядке, в котором транзакции были совершены.</target>
        </trans-unit>
        <trans-unit id="eed847052fd81f5459f65863d508269d92317295" translate="yes" xml:space="preserve">
          <source>If the same channel name is signaled multiple times with identical payload strings within the same transaction, only one instance of the notification event is delivered to listeners. On the other hand, notifications with distinct payload strings will always be delivered as distinct notifications. Similarly, notifications from different transactions will never get folded into one notification. Except for dropping later instances of duplicate notifications, &lt;code&gt;NOTIFY&lt;/code&gt; guarantees that notifications from the same transaction get delivered in the order they were sent. It is also guaranteed that messages from different transactions are delivered in the order in which the transactions committed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d36a41307a4d14aa722349a681e2f2a7b7eb16" translate="yes" xml:space="preserve">
          <source>If the same column name exists in more than one parent table, an error is reported unless the data types of the columns match in each of the parent tables. If there is no conflict, then the duplicate columns are merged to form a single column in the new table. If the column name list of the new table contains a column name that is also inherited, the data type must likewise match the inherited column(s), and the column definitions are merged into one. If the new table explicitly specifies a default value for the column, this default overrides any defaults from inherited declarations of the column. Otherwise, any parents that specify default values for the column must all specify the same default, or an error will be reported.</source>
          <target state="translated">Если одно и то же имя столбца существует в более чем одной родительской таблице,сообщается об ошибке,если типы данных столбцов не совпадают в каждой из родительских таблиц.Если конфликта нет,то дублирующие друг друга столбцы объединяются в единственный столбец в новой таблице.Если список имен столбцов новой таблицы содержит имя столбца,которое также наследуется,то тип данных должен также совпадать с наследуемыми столбцами,и определения столбцов объединяются в один.Если в новой таблице явно указано значение по умолчанию для столбца,то это значение по умолчанию отменяет любые значения по умолчанию из унаследованных деклараций столбца.В противном случае,все родители,которые указывают значения по умолчанию для столбца,должны указать одно и то же значение по умолчанию,иначе будет сообщено об ошибке.</target>
        </trans-unit>
        <trans-unit id="52777f31338be443c8719518578a441085b3242b" translate="yes" xml:space="preserve">
          <source>If the scale of a value to be stored is greater than the declared scale of the column, the system will round the value to the specified number of fractional digits. Then, if the number of digits to the left of the decimal point exceeds the declared precision minus the declared scale, an error is raised.</source>
          <target state="translated">Если масштаб хранимого значения больше,чем объявленный масштаб столбца,то система округлит значение до указанного количества дробных цифр.Затем,если количество цифр слева от десятичной запятой превышает объявленную точность минус объявленный масштаб,то ошибка возрастает.</target>
        </trans-unit>
        <trans-unit id="02e920dfe841eca3127cd2deda87b1b0038bf35c" translate="yes" xml:space="preserve">
          <source>If the search path finds multiple functions of identical argument types, only the one appearing earliest in the path is considered. Functions of different argument types are considered on an equal footing regardless of search path position.</source>
          <target state="translated">Если в пути поиска найдено несколько функций с одинаковыми типами аргументов,то учитывается только та,которая появляется в пути раньше.Функции различных типов аргументов рассматриваются на равных основаниях независимо от позиции пути поиска.</target>
        </trans-unit>
        <trans-unit id="846c48a5a96c2f9f31d852fa93bd025a2ae37209" translate="yes" xml:space="preserve">
          <source>If the search path finds multiple operators with identical argument types, only the one appearing earliest in the path is considered. Operators with different argument types are considered on an equal footing regardless of search path position.</source>
          <target state="translated">Если путь поиска находит несколько операторов с одинаковыми типами аргументов,то учитывается только тот,который появляется в пути раньше.Операторы с различными типами аргументов считаются равными вне зависимости от позиции пути поиска.</target>
        </trans-unit>
        <trans-unit id="2b252638ccabfce3f83bfcd21c45870e0c2d0f5f" translate="yes" xml:space="preserve">
          <source>If the server encoding is not UTF-8, the Unicode code point identified by one of these escape sequences is converted to the actual server encoding; an error is reported if that's not possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d768fe47d52ad5a0b026e7ffb256e492ca409f05" translate="yes" xml:space="preserve">
          <source>If the server requires password authentication and a password is not available from other sources such as a &lt;code&gt;.pgpass&lt;/code&gt; file, psql will prompt for a password in any case. However, psql will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9b16d6feb91ed4af38eb28e886ad3416c7d722" translate="yes" xml:space="preserve">
          <source>If the session user is a database superuser, then a &lt;code&gt;#&lt;/code&gt;, otherwise a &lt;code&gt;&amp;gt;&lt;/code&gt;. (The expansion of this value might change during a database session as the result of the command &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt;.)</source>
          <target state="translated">Если пользователь сеанса является суперпользователем базы данных, то &lt;code&gt;#&lt;/code&gt; , иначе &lt;code&gt;&amp;gt;&lt;/code&gt; . (Расширение этого значения может измениться во время сеанса базы данных в результате выполнения команды &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="21d4dfd38c56bb0f6178a7f714085ed7cf4b3207" translate="yes" xml:space="preserve">
          <source>If the specified table is a partitioned table, each row is routed to the appropriate partition and inserted into it. If the specified table is a partition, an error will occur if one of the input rows violates the partition constraint.</source>
          <target state="translated">Если указанная таблица является таблицей разметки,то каждая строка направляется на соответствующий простенок и вставляется в него.Если указанная таблица является простенком,то возникает ошибка,если одна из строк ввода нарушает ограничение простенка.</target>
        </trans-unit>
        <trans-unit id="1b245f2cb2a99bf0f8cbbb31a4d055f1ead828c3" translate="yes" xml:space="preserve">
          <source>If the standard and predefined collations are not sufficient, users can create their own collation objects using the SQL command &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt;.</source>
          <target state="translated">Если стандартных и предопределенных параметров сопоставления недостаточно, пользователи могут создавать свои собственные объекты сопоставления с помощью команды SQL &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b1c783904332e93ac1d7897a9080ae105b88d5b" translate="yes" xml:space="preserve">
          <source>If the standby is promoted to be primary during backup, the backup fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae6c2a2f4f7ec1ece5d1140f847b0d38361211e2" translate="yes" xml:space="preserve">
          <source>If the standby is promoted to the master during online backup, the backup fails.</source>
          <target state="translated">Если во время онлайнового резервного копирования резервная копия перейдет в режим ожидания,то резервное копирование будет неудачным.</target>
        </trans-unit>
        <trans-unit id="170908acbec1d5cb0f56e23febc172e3426f4e91" translate="yes" xml:space="preserve">
          <source>If the standby server fails then no failover need take place. If the standby server can be restarted, even some time later, then the recovery process can also be restarted immediately, taking advantage of restartable recovery. If the standby server cannot be restarted, then a full new standby server instance should be created.</source>
          <target state="translated">Если аварийный сервер выходит из строя,то обхода отказа не требуется.Если резервный сервер можно перезапустить,даже через некоторое время,то процесс восстановления также можно перезапустить немедленно,воспользовавшись возможностью перезапуска.Если аварийный сервер не может быть перезапущен,необходимо создать новый полный резервный экземпляр сервера.</target>
        </trans-unit>
        <trans-unit id="05b0c76b7db4a1477637a64b2d47050fce69810a" translate="yes" xml:space="preserve">
          <source>If the standby servers are still running, stop them now using the above instructions.</source>
          <target state="translated">Если резервные серверы все еще работают,остановите их сейчас,воспользовавшись приведенными выше инструкциями.</target>
        </trans-unit>
        <trans-unit id="6049edf261150bf348be6f8bb80514f565d9d8f9" translate="yes" xml:space="preserve">
          <source>If the state transition function is declared &amp;ldquo;strict&amp;rdquo;, then it cannot be called with null inputs. With such a transition function, aggregate execution behaves as follows. Rows with any null input values are ignored (the function is not called and the previous state value is retained). If the initial state value is null, then at the first row with all-nonnull input values, the first argument value replaces the state value, and the transition function is invoked at each subsequent row with all-nonnull input values. This is handy for implementing aggregates like &lt;code&gt;max&lt;/code&gt;. Note that this behavior is only available when &lt;code&gt;state_data_type&lt;/code&gt; is the same as the first &lt;code&gt;arg_data_type&lt;/code&gt;. When these types are different, you must supply a nonnull initial condition or use a nonstrict transition function.</source>
          <target state="translated">Если функция перехода между состояниями объявлена ​​&amp;laquo;строгой&amp;raquo;, то ее нельзя вызвать с нулевыми входными данными. С такой функцией перехода агрегатное выполнение ведет себя следующим образом. Строки с любыми нулевыми входными значениями игнорируются (функция не вызывается, а предыдущее значение состояния сохраняется). Если начальное значение состояния равно нулю, то в первой строке с полностью ненулевыми входными значениями первое значение аргумента заменяет значение состояния, а функция перехода вызывается в каждой последующей строке с полностью ненулевыми входными значениями. Это удобно для реализации таких агрегатов, как &lt;code&gt;max&lt;/code&gt; . Обратите внимание, что это поведение доступно только тогда, когда &lt;code&gt;state_data_type&lt;/code&gt; совпадает с первым &lt;code&gt;arg_data_type&lt;/code&gt; .. Если эти типы различаются, необходимо указать начальное условие, отличное от нуля, или использовать функцию нестрогого перехода.</target>
        </trans-unit>
        <trans-unit id="b6d30b33fa764833043e35a291ca75c71eaca53e" translate="yes" xml:space="preserve">
          <source>If the state transition function is not strict, then it will be called unconditionally at each input row, and must deal with null inputs and null state values for itself. This allows the aggregate author to have full control over the aggregate's handling of null values.</source>
          <target state="translated">Если функция перехода в состояние не является строгой,то она будет вызываться безоговорочно на каждой входной строке и должна сама для себя иметь дело с нулевыми входами и значениями нулевых состояний.Это позволяет автору агрегата полностью контролировать обработку нулевых значений агрегатом.</target>
        </trans-unit>
        <trans-unit id="244bd5a12cbdca1f48ebb0a6febfdca5da532447" translate="yes" xml:space="preserve">
          <source>If the string is declared to be of type &lt;code&gt;varchar&lt;/code&gt;, as might be the case if it comes from a table, then the parser will try to convert it to become &lt;code&gt;text&lt;/code&gt;:</source>
          <target state="translated">Если объявлено, что строка имеет тип &lt;code&gt;varchar&lt;/code&gt; , что может иметь место, если она поступает из таблицы, то синтаксический анализатор попытается преобразовать ее в &lt;code&gt;text&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2dcfcecbf90e5089ccafce06b4b0be1f8904c94c" translate="yes" xml:space="preserve">
          <source>If the subtype is considered to have discrete rather than continuous values, the &lt;code&gt;CREATE TYPE&lt;/code&gt; command should specify a &lt;code&gt;canonical&lt;/code&gt; function. The canonicalization function takes an input range value, and must return an equivalent range value that may have different bounds and formatting. The canonical output for two ranges that represent the same set of values, for example the integer ranges &lt;code&gt;[1, 7]&lt;/code&gt; and &lt;code&gt;[1, 8)&lt;/code&gt;, must be identical. It doesn't matter which representation you choose to be the canonical one, so long as two equivalent values with different formattings are always mapped to the same value with the same formatting. In addition to adjusting the inclusive/exclusive bounds format, a canonicalization function might round off boundary values, in case the desired step size is larger than what the subtype is capable of storing. For instance, a range type over &lt;code&gt;timestamp&lt;/code&gt; could be defined to have a step size of an hour, in which case the canonicalization function would need to round off bounds that weren't a multiple of an hour, or perhaps throw an error instead.</source>
          <target state="translated">Если считается, что подтип имеет дискретные, а не непрерывные значения, команда &lt;code&gt;CREATE TYPE&lt;/code&gt; должна указывать &lt;code&gt;canonical&lt;/code&gt; функцию. Функция канонизации принимает значение входного диапазона и должна возвращать эквивалентное значение диапазона, которое может иметь разные границы и форматирование. Канонический вывод для двух диапазонов, которые представляют один и тот же набор значений, например целочисленные диапазоны &lt;code&gt;[1, 7]&lt;/code&gt; и &lt;code&gt;[1, 8)&lt;/code&gt; , должны быть идентичными. Неважно, какое представление вы выберете в качестве канонического, если два эквивалентных значения с разным форматированием всегда сопоставляются с одним и тем же значением с одинаковым форматированием. В дополнение к настройке формата включающих / исключающих границ функция канонизации может округлять граничные значения в случае, если желаемый размер шага больше, чем то, что подтип может хранить. Например, тип диапазона по &lt;code&gt;timestamp&lt;/code&gt; может быть определен так, чтобы иметь размер шага в час, и в этом случае функции канонизации потребуется округлять границы, которые не кратны часу, или, возможно, вместо этого выдать ошибку.</target>
        </trans-unit>
        <trans-unit id="417d560f70c3f29f36f195f746fd3ca8a01a2c42" translate="yes" xml:space="preserve">
          <source>If the system administrator for the server's machine cannot be trusted, it is necessary for the client to encrypt the data; this way, unencrypted data never appears on the database server. Data is encrypted on the client before being sent to the server, and database results have to be decrypted on the client before being used.</source>
          <target state="translated">Если системному администратору машины сервера нельзя доверять,то клиенту необходимо зашифровать данные,таким образом,незашифрованные данные никогда не появятся на сервере баз данных.Данные шифруются на клиенте перед отправкой на сервер,а результаты работы БД необходимо расшифровать на клиенте перед использованием.</target>
        </trans-unit>
        <trans-unit id="2b3f5f95bd715dfe464206f06b66a58f56802c50" translate="yes" xml:space="preserve">
          <source>If the table as a whole is exclusive-locked by someone else, &lt;code&gt;pgrowlocks&lt;/code&gt; will be blocked.</source>
          <target state="translated">Если таблица в целом заблокирована кем-то еще, &lt;code&gt;pgrowlocks&lt;/code&gt; будет заблокирована.</target>
        </trans-unit>
        <trans-unit id="b50348338bc555a4ab7d45126bfb8dabd633e20f" translate="yes" xml:space="preserve">
          <source>If the table being analyzed has one or more children, &lt;code&gt;ANALYZE&lt;/code&gt; will gather statistics twice: once on the rows of the parent table only, and a second time on the rows of the parent table with all of its children. This second set of statistics is needed when planning queries that traverse the entire inheritance tree. The autovacuum daemon, however, will only consider inserts or updates on the parent table itself when deciding whether to trigger an automatic analyze for that table. If that table is rarely inserted into or updated, the inheritance statistics will not be up to date unless you run &lt;code&gt;ANALYZE&lt;/code&gt; manually.</source>
          <target state="translated">Если у анализируемой таблицы есть один или несколько дочерних &lt;code&gt;ANALYZE&lt;/code&gt; , ANALYZE будет собирать статистику дважды: один раз только по строкам родительской таблицы, а второй раз по строкам родительской таблицы со всеми ее дочерними элементами. Этот второй набор статистики необходим при планировании запросов, которые проходят через все дерево наследования. Однако демон автоочистки будет учитывать только вставки или обновления в самой родительской таблице при принятии решения о запуске автоматического анализа для этой таблицы. Если эта таблица редко вставляется или обновляется, статистика наследования не будет актуальной, если вы не запустите &lt;code&gt;ANALYZE&lt;/code&gt; вручную.</target>
        </trans-unit>
        <trans-unit id="b96d4460f730e99ad2f5da4b8998b3d561a93287" translate="yes" xml:space="preserve">
          <source>If the table being analyzed is completely empty, &lt;code&gt;ANALYZE&lt;/code&gt; will not record new statistics for that table. Any existing statistics will be retained.</source>
          <target state="translated">Если анализируемая таблица полностью пуста, &lt;code&gt;ANALYZE&lt;/code&gt; не будет записывать новую статистику для этой таблицы. Любая существующая статистика будет сохранена.</target>
        </trans-unit>
        <trans-unit id="52dc63831209a4c7bb3899cf1fb2ddca1ef42d36" translate="yes" xml:space="preserve">
          <source>If the table is being scanned using an index, this is the OID of the index being used; otherwise, it is zero.</source>
          <target state="translated">Если таблица сканируется с использованием индекса,то это OID используемого индекса;в противном случае он равен нулю.</target>
        </trans-unit>
        <trans-unit id="dd0fa542dae151db3f272ca82de26368bfb9872f" translate="yes" xml:space="preserve">
          <source>If the target directory is specified as &lt;code&gt;-&lt;/code&gt; (dash), the tar contents will be written to standard output, suitable for piping to (for example) gzip. This is only allowed if the cluster has no additional tablespaces and WAL streaming is not used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfb9ffd9573334faeebb68db3d3df9b1f1f0724" translate="yes" xml:space="preserve">
          <source>If the token is an alphabetic string, match up with possible strings:</source>
          <target state="translated">Если токен является алфавитной строкой,сопоставьте его с возможными строками:</target>
        </trans-unit>
        <trans-unit id="4f40be80901959628e05aea1c30e86478bf9dbb2" translate="yes" xml:space="preserve">
          <source>If the token is numeric only, then it is either a single field or an ISO 8601 concatenated date (e.g., &lt;code&gt;19990113&lt;/code&gt; for January 13, 1999) or time (e.g., &lt;code&gt;141516&lt;/code&gt; for 14:15:16).</source>
          <target state="translated">Если маркер является только числовым, то это либо отдельное поле, либо объединенная дата ISO 8601 (например, &lt;code&gt;19990113&lt;/code&gt; для 13 января 1999 г.) или время (например, &lt;code&gt;141516&lt;/code&gt; для 14:15:16).</target>
        </trans-unit>
        <trans-unit id="003398a89e69d2198b671a9677907bb24f534582" translate="yes" xml:space="preserve">
          <source>If the token is three digits and a year has already been read, then interpret as day of year.</source>
          <target state="translated">Если токен состоит из трех цифр,а год уже прочитан,то интерпретируйте его как день года.</target>
        </trans-unit>
        <trans-unit id="d3ac616dded1315bedadfd2b91efaa1cf49163f8" translate="yes" xml:space="preserve">
          <source>If the token starts with a plus (&lt;code&gt;+&lt;/code&gt;) or minus (&lt;code&gt;-&lt;/code&gt;), then it is either a numeric time zone or a special field.</source>
          <target state="translated">Если токен начинается с плюса ( &lt;code&gt;+&lt;/code&gt; ) или минуса ( &lt;code&gt;-&lt;/code&gt; ), то это либо числовой часовой пояс, либо специальное поле.</target>
        </trans-unit>
        <trans-unit id="611739a43cf34a105bb65434365f4074cf8756df" translate="yes" xml:space="preserve">
          <source>If the transaction modified any run-time parameters with &lt;code&gt;SET&lt;/code&gt; (without the &lt;code&gt;LOCAL&lt;/code&gt; option), those effects persist after &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, and will not be affected by any later &lt;code&gt;COMMIT PREPARED&lt;/code&gt; or &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt;. Thus, in this one respect &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; acts more like &lt;code&gt;COMMIT&lt;/code&gt; than &lt;code&gt;ROLLBACK&lt;/code&gt;.</source>
          <target state="translated">Если транзакция изменила какие-либо параметры времени выполнения с помощью &lt;code&gt;SET&lt;/code&gt; (без опции &lt;code&gt;LOCAL&lt;/code&gt; ), эти эффекты сохранятся после &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; и не будут затронуты последующими &lt;code&gt;COMMIT PREPARED&lt;/code&gt; или &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; . Таким образом, в этом отношении &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; действует больше как &lt;code&gt;COMMIT&lt;/code&gt; , чем &lt;code&gt;ROLLBACK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07ad8422becd50d9414841f3815863dc01f955f6" translate="yes" xml:space="preserve">
          <source>If the type being ordered (&lt;code&gt;type1&lt;/code&gt;) is collatable, the appropriate collation OID will be passed to the &lt;code&gt;in_range&lt;/code&gt; function, using the standard PG_GET_COLLATION() mechanism.</source>
          <target state="translated">Если упорядочиваемый тип ( &lt;code&gt;type1&lt;/code&gt; ) является сопоставимым, соответствующий OID сопоставления будет передан в функцию &lt;code&gt;in_range&lt;/code&gt; с использованием стандартного механизма PG_GET_COLLATION ().</target>
        </trans-unit>
        <trans-unit id="0affc2c3fcf33ac8518f76b37e69d5d8764c5216" translate="yes" xml:space="preserve">
          <source>If the unique constraint is deferrable, there is additional complexity: we need to be able to insert an index entry for a new row, but defer any uniqueness-violation error until end of statement or even later. To avoid unnecessary repeat searches of the index, the index access method should do a preliminary uniqueness check during the initial insertion. If this shows that there is definitely no conflicting live tuple, we are done. Otherwise, we schedule a recheck to occur when it is time to enforce the constraint. If, at the time of the recheck, both the inserted tuple and some other tuple with the same key are live, then the error must be reported. (Note that for this purpose, &amp;ldquo;live&amp;rdquo; actually means &amp;ldquo;any tuple in the index entry's HOT chain is live&amp;rdquo;.) To implement this, the &lt;code&gt;aminsert&lt;/code&gt; function is passed a &lt;code&gt;checkUnique&lt;/code&gt; parameter having one of the following values:</source>
          <target state="translated">Если ограничение уникальности откладывается, возникает дополнительная сложность: нам нужно иметь возможность вставлять запись индекса для новой строки, но откладывать любую ошибку нарушения уникальности до конца оператора или даже позже. Чтобы избежать ненужных повторных поисков индекса, метод доступа к индексу должен выполнить предварительную проверку уникальности во время первоначальной вставки. Если это показывает, что конфликтующего живого кортежа определенно нет, все готово. В противном случае мы планируем провести повторную проверку, когда придет время применить ограничение. Если во время повторной проверки и вставленный кортеж, и какой-то другой кортеж с тем же ключом активны, то необходимо сообщить об ошибке. (Обратите внимание, что для этой цели &amp;laquo;live&amp;raquo; на самом деле означает &amp;laquo;активен любой кортеж в цепочке HOT записи индекса&amp;raquo;.) Для реализации этого функции &lt;code&gt;aminsert&lt;/code&gt; передается &lt;code&gt;checkUnique&lt;/code&gt; Параметр checkUnique, имеющий одно из следующих значений:</target>
        </trans-unit>
        <trans-unit id="0ccba0a1dbc7e9db8732870253e268a51ede19e4" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;-&lt;/code&gt; (dash) is specified as target directory, the tar contents will be written to standard output, suitable for piping to for example gzip. This is only possible if the cluster has no additional tablespaces and WAL streaming is not used.</source>
          <target state="translated">Если значение &lt;code&gt;-&lt;/code&gt; (тире) указано в качестве целевого каталога, содержимое tar будет записано в стандартный вывод, подходящий для конвейерной передачи, например, в gzip. Это возможно только в том случае, если в кластере нет дополнительных табличных пространств и не используется потоковая передача WAL.</target>
        </trans-unit>
        <trans-unit id="444b2da78b5aef7c45b208ec5e7f996fc4602364" translate="yes" xml:space="preserve">
          <source>If the value is 1 (the default) or above, float values are output in shortest-precise format; see &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;Section 8.1.3&lt;/a&gt;. The actual number of digits generated depends only on the value being output, not on the value of this parameter. At most 17 digits are required for &lt;code&gt;float8&lt;/code&gt; values, and 9 for &lt;code&gt;float4&lt;/code&gt; values. This format is both fast and precise, preserving the original binary float value exactly when correctly read. For historical compatibility, values up to 3 are permitted.</source>
          <target state="translated">Если значение равно 1 (по умолчанию) или больше, значения с плавающей запятой выводятся в кратчайшем-точном формате; см. &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;раздел 8.1.3&lt;/a&gt; . Фактическое количество сгенерированных цифр зависит только от выводимого значения, а не от значения этого параметра. &lt;code&gt;float8&lt;/code&gt; значений типа float8 требуется не более 17 цифр , а для значений типа &lt;code&gt;float4&lt;/code&gt; - 9 . Этот формат является быстрым и точным, сохраняя исходное двоичное значение с плавающей запятой точно при правильном чтении. Для исторической совместимости разрешены значения до 3.</target>
        </trans-unit>
        <trans-unit id="7b8c00d10368663be17d060a1553cbcac67af360" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;always&lt;/code&gt;, then color is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3241b1b5ac7bee371703180a8744c53db79636d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;auto&lt;/code&gt; and the standard error stream is associated with a terminal device, then color is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0cc84e480979f938d4633f92cd03d8f6fccf694" translate="yes" xml:space="preserve">
          <source>If the value is zero or negative, then the output is rounded to a given decimal precision. The precision used is the standard number of digits for the type (&lt;code&gt;FLT_DIG&lt;/code&gt; or &lt;code&gt;DBL_DIG&lt;/code&gt; as appropriate) reduced according to the value of this parameter. (For example, specifying -1 will cause &lt;code&gt;float4&lt;/code&gt; values to be output rounded to 5 significant digits, and &lt;code&gt;float8&lt;/code&gt; values rounded to 14 digits.) This format is slower and does not preserve all the bits of the binary float value, but may be more human-readable.</source>
          <target state="translated">Если значение равно нулю или отрицательно, результат округляется до заданной десятичной точности. Используемая точность - это стандартное количество цифр для типа ( &lt;code&gt;FLT_DIG&lt;/code&gt; или &lt;code&gt;DBL_DIG&lt;/code&gt; , в зависимости от ситуации), уменьшенное в соответствии со значением этого параметра. (Например, указание -1 приведет к &lt;code&gt;float4&lt;/code&gt; значения float4 будут округлены до 5 значащих цифр, а значения &lt;code&gt;float8&lt;/code&gt; округлены до 14 цифр.) Этот формат медленнее и не сохраняет все биты двоичного значения с плавающей запятой, но может быть больше человек читаемый.</target>
        </trans-unit>
        <trans-unit id="1bde8627196fca1b915cdbfcafe6a9bc91cc16ce" translate="yes" xml:space="preserve">
          <source>If the value written for an element is &lt;code&gt;NULL&lt;/code&gt; (in any case variant), the element is taken to be NULL. The presence of any quotes or backslashes disables this and allows the literal string value &amp;ldquo;NULL&amp;rdquo; to be entered. Also, for backward compatibility with pre-8.2 versions of PostgreSQL, the &lt;a href=&quot;runtime-config-compatible#GUC-ARRAY-NULLS&quot;&gt;array_nulls&lt;/a&gt; configuration parameter can be turned &lt;code&gt;off&lt;/code&gt; to suppress recognition of &lt;code&gt;NULL&lt;/code&gt; as a NULL.</source>
          <target state="translated">Если значение, записанное для элемента, равно &lt;code&gt;NULL&lt;/code&gt; (в любом варианте), элемент принимается равным NULL. Наличие любых кавычек или обратных косых черт отключает это и позволяет вводить буквальное строковое значение &amp;laquo;NULL&amp;raquo;. Кроме того, для обратной совместимости с версиями PostgreSQL до &lt;a href=&quot;runtime-config-compatible#GUC-ARRAY-NULLS&quot;&gt;8.2&lt;/a&gt; параметр конфигурации array_nulls можно &lt;code&gt;off&lt;/code&gt; чтобы подавить распознавание &lt;code&gt;NULL&lt;/code&gt; как NULL.</target>
        </trans-unit>
        <trans-unit id="c41c4c976de57b5cc72ea9d7bfdcc6564b8b256b" translate="yes" xml:space="preserve">
          <source>If the view is automatically updatable the system will convert any &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; statement on the view into the corresponding statement on the underlying base relation. &lt;code&gt;INSERT&lt;/code&gt; statements that have an &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; clause are fully supported.</source>
          <target state="translated">Если представление обновляется автоматически, система преобразует любой оператор &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; в представлении в соответствующий оператор базового отношения. Операторы &lt;code&gt;INSERT&lt;/code&gt; , содержащие предложение &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; , полностью поддерживаются.</target>
        </trans-unit>
        <trans-unit id="650d690f75ae406d20b34e538980576f232072f4" translate="yes" xml:space="preserve">
          <source>If the width comes from a function argument, that argument is consumed before the argument that is used for the format specifier's value. If the width argument is negative, the result is left aligned (as if the &lt;code&gt;-&lt;/code&gt; flag had been specified) within a field of length &lt;code&gt;abs&lt;/code&gt;(&lt;code&gt;width&lt;/code&gt;).</source>
          <target state="translated">Если ширина берется из аргумента функции, этот аргумент используется перед аргументом, который используется для значения спецификатора формата. Если аргумент ширины отрицательный, результат выравнивается по левому краю (как если бы был указан флаг &lt;code&gt;-&lt;/code&gt; ) в пределах поля длины &lt;code&gt;abs&lt;/code&gt; ( &lt;code&gt;width&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8438b6c9a8a0c469032906dcee3641b321408b8e" translate="yes" xml:space="preserve">
          <source>If the width comes from a function argument, that argument is consumed before the argument that is used for the format specifier's value. If the width argument is negative, the result is left aligned (as if the &lt;code&gt;-&lt;/code&gt; flag had been specified) within a field of length &lt;code&gt;abs&lt;/code&gt;(&lt;em&gt;&lt;code&gt;width&lt;/code&gt;&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee835cdf2017b10d24cc5c26f6abffc684a96735" translate="yes" xml:space="preserve">
          <source>If there are both &lt;code&gt;unknown&lt;/code&gt; and known-type arguments, and all the known-type arguments have the same type, assume that the &lt;code&gt;unknown&lt;/code&gt; arguments are also of that type, and check which candidates can accept that type at the &lt;code&gt;unknown&lt;/code&gt;-argument positions. If exactly one candidate passes this test, use it. Otherwise, fail.</source>
          <target state="translated">Если существуют аргументы и &lt;code&gt;unknown&lt;/code&gt; и известного типа, и все аргументы известного типа имеют один и тот же тип, предположите, что &lt;code&gt;unknown&lt;/code&gt; аргументы также относятся к этому типу, и проверьте, какие кандидаты могут принять этот тип в позициях &lt;code&gt;unknown&lt;/code&gt; аргумента. Если этот тест проходит ровно один кандидат, используйте его. В противном случае потерпите неудачу.</target>
        </trans-unit>
        <trans-unit id="13cac4b83f93f0a857eb5390b899f2b2b2cbf1c2" translate="yes" xml:space="preserve">
          <source>If there are conflicting non-default implicit collations among the input expressions, then the combination is deemed to have indeterminate collation. This is not an error condition unless the particular function being invoked requires knowledge of the collation it should apply. If it does, an error will be raised at run-time.</source>
          <target state="translated">Если между входными выражениями имеются конфликтующие неявные неявные сопоставления,то считается,что комбинация имеет неопределенное сопоставление.Это не является условием ошибки,если только вызываемая функция не требует знания того,какое сравнение она должна применять.Если это так,то ошибка будет поднята во время выполнения.</target>
        </trans-unit>
        <trans-unit id="28d65a2d08624ffa80deb6c7246a1682969ee379" translate="yes" xml:space="preserve">
          <source>If there are eight or six digits, and if no other date fields have been previously read, then interpret as a &amp;ldquo;concatenated date&amp;rdquo; (e.g., &lt;code&gt;19990118&lt;/code&gt; or &lt;code&gt;990118&lt;/code&gt;). The interpretation is &lt;code&gt;YYYYMMDD&lt;/code&gt; or &lt;code&gt;YYMMDD&lt;/code&gt;.</source>
          <target state="translated">Если есть восемь или шесть цифр, и если никакие другие поля даты ранее не считывались, интерпретируйте как &amp;laquo;объединенную дату&amp;raquo; (например, &lt;code&gt;19990118&lt;/code&gt; или &lt;code&gt;990118&lt;/code&gt; ). Интерпретация &lt;code&gt;YYYYMMDD&lt;/code&gt; или &lt;code&gt;YYMMDD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06c3232f6496ea373f86e0b58b23d8cc590947a5" translate="yes" xml:space="preserve">
          <source>If there are separate indexes on several of the columns referenced in &lt;code&gt;WHERE&lt;/code&gt;, the planner might choose to use an AND or OR combination of the indexes:</source>
          <target state="translated">Если есть отдельные индексы для нескольких столбцов, указанных в &lt;code&gt;WHERE&lt;/code&gt; , планировщик может выбрать комбинацию индексов И или ИЛИ:</target>
        </trans-unit>
        <trans-unit id="99c2725fb0d24809952a5ff770d9ef79057a3c26" translate="yes" xml:space="preserve">
          <source>If there are triggers (&lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;Chapter 38&lt;/a&gt;) on the target table, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as modified by the triggers. Thus, inspecting columns computed by triggers is another common use-case for &lt;code&gt;RETURNING&lt;/code&gt;.</source>
          <target state="translated">Если в целевой таблице есть триггеры ( &lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;глава 38&lt;/a&gt; ), данные, доступные для &lt;code&gt;RETURNING&lt;/code&gt; , представляют собой строку, измененную триггерами. Таким образом, проверка столбцов, вычисляемых триггерами, является еще одним распространенным вариантом использования &lt;code&gt;RETURNING&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="531c18479c37e8661718c4bf106b66a87df84c58" translate="yes" xml:space="preserve">
          <source>If there are triggers (&lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;Chapter 38&lt;/a&gt;) on the target table, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as modified by the triggers. Thus, inspecting columns computed by triggers is another common use-case for &lt;code&gt;RETURNING&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b8c31e042fe2150c30030dae6c6269655420443" translate="yes" xml:space="preserve">
          <source>If there is a need to filter or group rows after the window calculations are performed, you can use a sub-select. For example:</source>
          <target state="translated">Если после выполнения вычислений окна необходимо отфильтровать или сгруппировать строки,можно воспользоваться подвыбором.Например:</target>
        </trans-unit>
        <trans-unit id="cffa77db1a4b360ae7233f9c0f0ce7a0bc209389" translate="yes" xml:space="preserve">
          <source>If there is a record with LSN exactly equal to &lt;code&gt;lsn&lt;/code&gt;, the record will be processed.</source>
          <target state="translated">Если существует запись с номером LSN, точно равным &lt;code&gt;lsn&lt;/code&gt; , запись будет обработана.</target>
        </trans-unit>
        <trans-unit id="83cce96057188d3a7386156bf2623596a5029da8" translate="yes" xml:space="preserve">
          <source>If there is an index and we use a query with an indexable &lt;code&gt;WHERE&lt;/code&gt; condition, &lt;code&gt;EXPLAIN&lt;/code&gt; might show a different plan:</source>
          <target state="translated">Если есть индекс, и мы используем запрос с индексируемым условием &lt;code&gt;WHERE&lt;/code&gt; , &lt;code&gt;EXPLAIN&lt;/code&gt; может показать другой план:</target>
        </trans-unit>
        <trans-unit id="ed6480e8e6205c3cafadde0e83045f72ff5c9888" translate="yes" xml:space="preserve">
          <source>If there is more than one direct parent for a child table (multiple inheritance), this number tells the order in which the inherited columns are to be arranged. The count starts at 1.</source>
          <target state="translated">Если для дочерней таблицы (множественное наследование)имеется более одного прямого родителя,то это число говорит о порядке расположения наследуемых столбцов.Счет начинается с 1.</target>
        </trans-unit>
        <trans-unit id="b83d35fcbb1d8a1926cc7ad31b3e2d51f2485b81" translate="yes" xml:space="preserve">
          <source>If there is no setting named &lt;em&gt;&lt;code&gt;setting_name&lt;/code&gt;&lt;/em&gt;, &lt;code&gt;current_setting&lt;/code&gt; throws an error unless &lt;em&gt;&lt;code&gt;missing_ok&lt;/code&gt;&lt;/em&gt; is supplied and is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если параметр с именем &lt;em&gt; &lt;code&gt;setting_name&lt;/code&gt; отсутствует&lt;/em&gt; , &lt;code&gt;current_setting&lt;/code&gt; выдает ошибку, если только &lt;em&gt; &lt;code&gt;missing_ok&lt;/code&gt; &lt;/em&gt; не указан и не имеет значения &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="993f6bab11125bc0a23a8d9c66d2ae0ec051d5b8" translate="yes" xml:space="preserve">
          <source>If there's a record with LSN exactly equal to &lt;code&gt;lsn&lt;/code&gt;, the record will be output.</source>
          <target state="translated">Если есть запись с LSN, точно равным &lt;code&gt;lsn&lt;/code&gt; , запись будет выведена.</target>
        </trans-unit>
        <trans-unit id="51e95a5e2098ab1866ec414690874be8c0926635" translate="yes" xml:space="preserve">
          <source>If these two fundamental requirements are met, then all the data values required by the query are available from the index, so an index-only scan is physically possible. But there is an additional requirement for any table scan in PostgreSQL: it must verify that each retrieved row be &amp;ldquo;visible&amp;rdquo; to the query's MVCC snapshot, as discussed in &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;. Visibility information is not stored in index entries, only in heap entries; so at first glance it would seem that every row retrieval would require a heap access anyway. And this is indeed the case, if the table row has been modified recently. However, for seldom-changing data there is a way around this problem. PostgreSQL tracks, for each page in a table's heap, whether all rows stored in that page are old enough to be visible to all current and future transactions. This information is stored in a bit in the table's &lt;em&gt;visibility map&lt;/em&gt;. An index-only scan, after finding a candidate index entry, checks the visibility map bit for the corresponding heap page. If it's set, the row is known visible and so the data can be returned with no further work. If it's not set, the heap entry must be visited to find out whether it's visible, so no performance advantage is gained over a standard index scan. Even in the successful case, this approach trades visibility map accesses for heap accesses; but since the visibility map is four orders of magnitude smaller than the heap it describes, far less physical I/O is needed to access it. In most situations the visibility map remains cached in memory all the time.</source>
          <target state="translated">Если эти два основных требования соблюдены, то все значения данных, требуемые запросом, доступны из индекса, поэтому сканирование только индекса физически возможно. Но есть дополнительное требование для любого сканирования таблицы в PostgreSQL: он должен проверять, что каждая извлеченная строка &amp;laquo;видима&amp;raquo; для снимка MVCC запроса, как описано в &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;главе 13.&lt;/a&gt;. Информация о видимости хранится не в записях указателя, а только в записях кучи; поэтому на первый взгляд может показаться, что для получения каждой строки в любом случае потребуется доступ к куче. И это действительно так, если строка таблицы была недавно изменена. Однако для редко меняющихся данных есть способ обойти эту проблему. PostgreSQL отслеживает для каждой страницы в куче таблицы, все ли строки, хранящиеся на этой странице, достаточно стары, чтобы быть видимыми для всех текущих и будущих транзакций. Эта информация хранится в биту на &lt;em&gt;карте видимости&lt;/em&gt; таблицы.&lt;em&gt;&lt;/em&gt;. При сканировании только индекса после нахождения кандидата в запись индекса проверяется бит карты видимости для соответствующей страницы кучи. Если он установлен, строка считается видимой, и поэтому данные могут быть возвращены без дальнейшей работы. Если он не установлен, запись в куче должна быть посещена, чтобы узнать, видна ли она, поэтому не будет получено никакого преимущества в производительности по сравнению со стандартным сканированием индекса. Даже в успешном случае этот подход меняет доступ к карте видимости на доступ к куче; но поскольку карта видимости на четыре порядка меньше описываемой кучи, для доступа к ней требуется гораздо меньше физических операций ввода-вывода. В большинстве случаев карта видимости все время остается кэшированной в памяти.</target>
        </trans-unit>
        <trans-unit id="56f8e9d448a32277ad7decf19037ed4798402174" translate="yes" xml:space="preserve">
          <source>If these two fundamental requirements are met, then all the data values required by the query are available from the index, so an index-only scan is physically possible. But there is an additional requirement for any table scan in PostgreSQL: it must verify that each retrieved row be &amp;ldquo;visible&amp;rdquo; to the query's MVCC snapshot, as discussed in &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;. Visibility information is not stored in index entries, only in heap entries; so at first glance it would seem that every row retrieval would require a heap access anyway. And this is indeed the case, if the table row has been modified recently. However, for seldom-changing data there is a way around this problem. PostgreSQL tracks, for each page in a table's heap, whether all rows stored in that page are old enough to be visible to all current and future transactions. This information is stored in a bit in the table's &lt;em&gt;visibility map&lt;/em&gt;. An index-only scan, after finding a candidate index entry, checks the visibility map bit for the corresponding heap page. If it's set, the row is known visible and so the data can be returned with no further work. If it's not set, the heap entry must be visited to find out whether it's visible, so no performance advantage is gained over a standard index scan. Even in the successful case, this approach trades visibility map accesses for heap accesses; but since the visibility map is four orders of magnitude smaller than the heap it describes, far less physical I/O is needed to access it. In most situations the visibility map remains cached in memory all the time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eca355b7b540d6c38ac123a39e5c7bfe77f82a8" translate="yes" xml:space="preserve">
          <source>If this clause is specified, then any values supplied for identity columns are ignored and the default sequence-generated values are applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c547d5a570870983467a7ef7a622b57db3de5cb6" translate="yes" xml:space="preserve">
          <source>If this clause is specified, then any values supplied for identity columns defined as &lt;code&gt;GENERATED BY DEFAULT&lt;/code&gt; are ignored and the default sequence-generated values are applied.</source>
          <target state="translated">Если это предложение указано, то любые значения, предоставленные для столбцов идентификаторов, определенных как &lt;code&gt;GENERATED BY DEFAULT&lt;/code&gt; , игнорируются и применяются значения по умолчанию, созданные последовательностью.</target>
        </trans-unit>
        <trans-unit id="33eceb951fc008dd28e5a104ea6147dca30fa083" translate="yes" xml:space="preserve">
          <source>If this clause is specified, then any values supplied for identity columns will override the default sequence-generated values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc20641c7b7db884166e9f2d507911850e3a7612" translate="yes" xml:space="preserve">
          <source>If this file exists in the data directory, pg_ctl (in &lt;code&gt;restart&lt;/code&gt; mode) will pass the contents of the file as options to postgres, unless overridden by the &lt;code&gt;-o&lt;/code&gt; option. The contents of this file are also displayed in &lt;code&gt;status&lt;/code&gt; mode.</source>
          <target state="translated">Если этот файл существует в каталоге данных, pg_ctl (в режиме &lt;code&gt;restart&lt;/code&gt; ) передаст содержимое файла в качестве параметров в postgres, если это не будет отменено параметром &lt;code&gt;-o&lt;/code&gt; . Содержимое этого файла также отображается в режиме &lt;code&gt;status&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50767742cba8dcb6350d1c58ae8e0156ac5a9fe6" translate="yes" xml:space="preserve">
          <source>If this happens, you will see a kernel message that looks like this (consult your system documentation and configuration on where to look for such a message):</source>
          <target state="translated">Если это случится,вы увидите сообщение ядра,которое выглядит так (обратитесь к системной документации и настройкам,где искать такое сообщение):</target>
        </trans-unit>
        <trans-unit id="2441da5aa28be6dd0d7fce7180a9ead106be298e" translate="yes" xml:space="preserve">
          <source>If this is a composite type (see &lt;code&gt;typtype&lt;/code&gt;), then this column points to the &lt;code&gt;pg_class&lt;/code&gt; entry that defines the corresponding table. (For a free-standing composite type, the &lt;code&gt;pg_class&lt;/code&gt; entry doesn't really represent a table, but it is needed anyway for the type's &lt;code&gt;pg_attribute&lt;/code&gt; entries to link to.) Zero for non-composite types.</source>
          <target state="translated">Если это составной тип (см. &lt;code&gt;typtype&lt;/code&gt; ), то этот столбец указывает на запись &lt;code&gt;pg_class&lt;/code&gt; , которая определяет соответствующую таблицу. (Для автономного составного типа запись &lt;code&gt;pg_class&lt;/code&gt; на самом деле не представляет собой таблицу, но в любом случае она необходима для &lt;code&gt;pg_attribute&lt;/code&gt; записи типа pg_attribute .) Ноль для несоставных типов.</target>
        </trans-unit>
        <trans-unit id="e7bc989c1a71dcf27e6c15912a9e239eb02b9ff1" translate="yes" xml:space="preserve">
          <source>If this is a domain (see &lt;code&gt;typtype&lt;/code&gt;), then &lt;code&gt;typbasetype&lt;/code&gt; identifies the type that this one is based on. Zero if this type is not a domain.</source>
          <target state="translated">Если это домен (см. &lt;code&gt;typtype&lt;/code&gt; ), тогда &lt;code&gt;typbasetype&lt;/code&gt; определяет тип, на котором он основан. Ноль, если этот тип не является доменом.</target>
        </trans-unit>
        <trans-unit id="69cd51fd1807ea0656502f0a70cd88e1db17db63" translate="yes" xml:space="preserve">
          <source>If this is a table or an index, the access method used (heap, B-tree, hash, etc.)</source>
          <target state="translated">Если это таблица или индекс,то используется метод доступа (куча,B-дерево,хэш и т.д.).</target>
        </trans-unit>
        <trans-unit id="a337fd1770acfe173207c700a1060f857464ec35" translate="yes" xml:space="preserve">
          <source>If this is enabled, &lt;code&gt;TRUNCATE&lt;/code&gt; operations performed directly on partitions are not replicated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6657b3960fa7e0cd88d2aa8dcc3b355ae7df8c2d" translate="yes" xml:space="preserve">
          <source>If this is on, you should create users as &lt;code&gt;username@dbname&lt;/code&gt;. When &lt;code&gt;username&lt;/code&gt; is passed by a connecting client, &lt;code&gt;@&lt;/code&gt; and the database name are appended to the user name and that database-specific user name is looked up by the server. Note that when you create users with names containing &lt;code&gt;@&lt;/code&gt; within the SQL environment, you will need to quote the user name.</source>
          <target state="translated">Если он включен, вы должны создавать пользователей как &lt;code&gt;username@dbname&lt;/code&gt; . Когда &lt;code&gt;username&lt;/code&gt; передается подключающимся клиентом, к имени пользователя добавляются &lt;code&gt;@&lt;/code&gt; и имя базы данных , и это имя пользователя, зависящее от базы данных, просматривается сервером. Обратите внимание, что когда вы создаете пользователей с именами, содержащими &lt;code&gt;@&lt;/code&gt; , в среде SQL, вам нужно будет указать имя пользователя в кавычках.</target>
        </trans-unit>
        <trans-unit id="8483faa9a2017341557263992633a169be114a21" translate="yes" xml:space="preserve">
          <source>If this option is enabled along with &lt;code&gt;compat_realm&lt;/code&gt;, the user name from the Kerberos UPN is used for authentication. If it is disabled (the default), the SAM-compatible user name is used. By default, these two names are identical for new user accounts.</source>
          <target state="translated">Если этот параметр включен вместе с &lt;code&gt;compat_realm&lt;/code&gt; , имя пользователя из Kerberos UPN используется для аутентификации. Если он отключен (по умолчанию), используется SAM-совместимое имя пользователя. По умолчанию эти два имени идентичны для новых учетных записей пользователей.</target>
        </trans-unit>
        <trans-unit id="371ee180f233c6aad73716af3849b71651b391c0" translate="yes" xml:space="preserve">
          <source>If this option is not specified and the server supports temporary replication slots (version 10 and later), then a temporary replication slot is automatically used for WAL streaming.</source>
          <target state="translated">Если эта опция не указана и сервер поддерживает слоты временной репликации (версии 10 и выше),то для потоковой передачи WAL автоматически используется слот временной репликации.</target>
        </trans-unit>
        <trans-unit id="2f8215b3963efef20de5d0e001e32b15d0b1fd74" translate="yes" xml:space="preserve">
          <source>If this parameter contains an &lt;code&gt;=&lt;/code&gt; sign or starts with a valid URI prefix (&lt;code&gt;postgresql://&lt;/code&gt; or &lt;code&gt;postgres://&lt;/code&gt;), it is treated as a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html&quot;&gt;Section 33.1&lt;/a&gt; for more information.</source>
          <target state="translated">Если этот параметр содержит знак &lt;code&gt;=&lt;/code&gt; или начинается с допустимого префикса URI ( &lt;code&gt;postgresql://&lt;/code&gt; или &lt;code&gt;postgres://&lt;/code&gt; ), он рассматривается как строка &lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt; . См. &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html&quot;&gt;Раздел 33.1&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="eb980e2e2f9be562491c46b5659937146807845b" translate="yes" xml:space="preserve">
          <source>If this parameter contains an &lt;code&gt;=&lt;/code&gt; sign or starts with a valid URI prefix (&lt;code&gt;postgresql://&lt;/code&gt; or &lt;code&gt;postgres://&lt;/code&gt;), it is treated as a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt; for more information.</source>
          <target state="translated">Если этот параметр содержит знак &lt;code&gt;=&lt;/code&gt; или начинается с допустимого префикса URI ( &lt;code&gt;postgresql://&lt;/code&gt; или &lt;code&gt;postgres://&lt;/code&gt; ), он рассматривается как строка &lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt; . См. &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Раздел 33.1.1&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="e5a94a371e1e757fb5a74a0f350e7a31fdc8b2c2" translate="yes" xml:space="preserve">
          <source>If this parameter is on, the PostgreSQL server will try to make sure that updates are physically written to disk, by issuing &lt;code&gt;fsync()&lt;/code&gt; system calls or various equivalent methods (see &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt;). This ensures that the database cluster can recover to a consistent state after an operating system or hardware crash.</source>
          <target state="translated">Если этот параметр включен, сервер PostgreSQL будет пытаться убедиться, что обновления физически записаны на диск, путем выполнения системных вызовов &lt;code&gt;fsync()&lt;/code&gt; или различных эквивалентных методов (см. &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;Wal_sync_method&lt;/a&gt; ). Это гарантирует, что кластер базы данных может восстановиться до согласованного состояния после сбоя операционной системы или оборудования.</target>
        </trans-unit>
        <trans-unit id="fdad70218c14320d183b5258a94b057b0b9b82eb" translate="yes" xml:space="preserve">
          <source>If this produces no response then this step was successful and you can skip over the remainder of this section.</source>
          <target state="translated">Если это не дает ответа,то этот шаг был успешным,и вы можете пропустить оставшуюся часть этого раздела.</target>
        </trans-unit>
        <trans-unit id="3214ef4d2c8d678533f9cd4aff300140581f95e6" translate="yes" xml:space="preserve">
          <source>If this table is a partition, one cannot perform &lt;code&gt;DROP NOT NULL&lt;/code&gt; on a column if it is marked &lt;code&gt;NOT NULL&lt;/code&gt; in the parent table. To drop the &lt;code&gt;NOT NULL&lt;/code&gt; constraint from all the partitions, perform &lt;code&gt;DROP NOT NULL&lt;/code&gt; on the parent table. Even if there is no &lt;code&gt;NOT NULL&lt;/code&gt; constraint on the parent, such a constraint can still be added to individual partitions, if desired; that is, the children can disallow nulls even if the parent allows them, but not the other way around.</source>
          <target state="translated">Если эта таблица является разделом, нельзя выполнить &lt;code&gt;DROP NOT NULL&lt;/code&gt; для столбца, если он помечен как &lt;code&gt;NOT NULL&lt;/code&gt; в родительской таблице. Чтобы удалить ограничение &lt;code&gt;NOT NULL&lt;/code&gt; из всех разделов, выполните &lt;code&gt;DROP NOT NULL&lt;/code&gt; для родительской таблицы. Даже если для родительского &lt;code&gt;NOT NULL&lt;/code&gt; ограничения NOT NULL , такое ограничение все равно можно добавить к отдельным разделам, если это необходимо; то есть дочерние элементы могут запрещать пустые значения, даже если родитель разрешает их, но не наоборот.</target>
        </trans-unit>
        <trans-unit id="8738e67f4faaa26be7e54ea9f241452e99abdc6a" translate="yes" xml:space="preserve">
          <source>If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">Если это значение указано без единиц,то оно принимается за миллисекунды.Значение нуля (по умолчанию)отключает тайм-аут.</target>
        </trans-unit>
        <trans-unit id="f32c0180b724efe2a022fcb4332eb4cf7431bae9" translate="yes" xml:space="preserve">
          <source>If this value is specified without units, it is taken as minutes. A value of &lt;code&gt;-1&lt;/code&gt; (the default) disables this feature, effectively setting the snapshot age limit to infinity. This parameter can only be set at server start.</source>
          <target state="translated">Если это значение указано без единиц измерения, оно принимается в минутах. Значение &lt;code&gt;-1&lt;/code&gt; (по умолчанию) отключает эту функцию, фактически устанавливая предел возраста моментального снимка до бесконечности. Этот параметр можно установить только при запуске сервера.</target>
        </trans-unit>
        <trans-unit id="a8ab1040fa10ec473399bfff4fa508c435a17bc0" translate="yes" xml:space="preserve">
          <source>If this variable is set to &lt;code&gt;ignorespace&lt;/code&gt;, lines which begin with a space are not entered into the history list. If set to a value of &lt;code&gt;ignoredups&lt;/code&gt;, lines matching the previous history line are not entered. A value of &lt;code&gt;ignoreboth&lt;/code&gt; combines the two options. If set to &lt;code&gt;none&lt;/code&gt; (the default), all lines read in interactive mode are saved on the history list.</source>
          <target state="translated">Если для этой переменной задано значение &lt;code&gt;ignorespace&lt;/code&gt; , строки, начинающиеся с пробела, не вводятся в список истории. Если установлено значение &lt;code&gt;ignoredups&lt;/code&gt; , строки, соответствующие предыдущей строке истории, не вводятся. Значение &lt;code&gt;ignoreboth&lt;/code&gt; объединяет две опции. Если установлено значение &lt;code&gt;none&lt;/code&gt; (по умолчанию), все строки, прочитанные в интерактивном режиме, сохраняются в списке истории.</target>
        </trans-unit>
        <trans-unit id="7d49403e63b47e4513b7ffed0983ad8f1cca01fe" translate="yes" xml:space="preserve">
          <source>If this variable is set to &lt;code&gt;true&lt;/code&gt;, a table's access method details are not displayed. This is mainly useful for regression tests.</source>
          <target state="translated">Если для этой переменной установлено значение &lt;code&gt;true&lt;/code&gt; , сведения о методе доступа к таблице не отображаются. Это в основном полезно для регрессионных тестов.</target>
        </trans-unit>
        <trans-unit id="a5769546d2d4414640c8fa6c471f59d18a32f49e" translate="yes" xml:space="preserve">
          <source>If this variable is set to an integer value greater than zero, the results of &lt;code&gt;SELECT&lt;/code&gt; queries are fetched and displayed in groups of that many rows, rather than the default behavior of collecting the entire result set before display. Therefore only a limited amount of memory is used, regardless of the size of the result set. Settings of 100 to 1000 are commonly used when enabling this feature. Keep in mind that when using this feature, a query might fail after having already displayed some rows.</source>
          <target state="translated">Если для этой переменной задано целочисленное значение больше нуля, результаты запросов &lt;code&gt;SELECT&lt;/code&gt; выбираются и отображаются в группах из такого количества строк, а не по умолчанию, когда собирают весь набор результатов перед отображением. Поэтому используется только ограниченный объем памяти, независимо от размера набора результатов. При включении этой функции обычно используются настройки от 100 до 1000. Имейте в виду, что при использовании этой функции запрос может завершиться ошибкой после того, как уже отображаются некоторые строки.</target>
        </trans-unit>
        <trans-unit id="76778bde620595af53b04af23a5daa5bc5441843" translate="yes" xml:space="preserve">
          <source>If three or more digits and no date fields have yet been found, interpret as a year (this forces yy-mm-dd ordering of the remaining date fields).</source>
          <target state="translated">Если три или более цифры и ни одного поля даты еще не найдены,интерпретируйте как год (это приводит к порядку следования оставшихся полей даты по гжи-мм-ддд).</target>
        </trans-unit>
        <trans-unit id="81e3a3432036cda1be2139bb1761dc976c1a75c5" translate="yes" xml:space="preserve">
          <source>If true this index has been chosen as &amp;ldquo;replica identity&amp;rdquo; using &lt;code&gt;ALTER TABLE ... REPLICA IDENTITY USING INDEX ...&lt;/code&gt;</source>
          <target state="translated">Если true, то этот индекс был выбран в качестве &amp;laquo;идентичности реплики&amp;raquo; с помощью &lt;code&gt;ALTER TABLE ... REPLICA IDENTITY USING INDEX ...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb3a87dcd25f91900b7d1fcaa4ea022c5ef4621a" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;DELETE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">Если true, операции &lt;code&gt;DELETE&lt;/code&gt; реплицируются для таблиц в публикации.</target>
        </trans-unit>
        <trans-unit id="31ebf4870608c0167855b7d0283c52cc09a7d931" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;INSERT&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">Если true, операции &lt;code&gt;INSERT&lt;/code&gt; реплицируются для таблиц в публикации.</target>
        </trans-unit>
        <trans-unit id="16194e2fdde132d1c172f912b491836e60827cdc" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;TRUNCATE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">Если true, операции &lt;code&gt;TRUNCATE&lt;/code&gt; реплицируются для таблиц в публикации.</target>
        </trans-unit>
        <trans-unit id="1ad3497d81a37523e3d7068e040be2588a6f2a7f" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;UPDATE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">Если true, операции &lt;code&gt;UPDATE&lt;/code&gt; реплицируются для таблиц в публикации.</target>
        </trans-unit>
        <trans-unit id="f3f8473e6cf008d85556519e04a9be2df3d673dd" translate="yes" xml:space="preserve">
          <source>If true, operations on a leaf partition are replicated using the identity and schema of its topmost partitioned ancestor mentioned in the publication instead of its own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6d4eb0a14744c8cf642983fb247ca8af2c665e" translate="yes" xml:space="preserve">
          <source>If true, queries must not use the index until the &lt;code&gt;xmin&lt;/code&gt; of this &lt;code&gt;pg_index&lt;/code&gt; row is below their &lt;code&gt;TransactionXmin&lt;/code&gt; event horizon, because the table may contain broken HOT chains with incompatible rows that they can see</source>
          <target state="translated">Если true, запросы не должны использовать индекс, пока &lt;code&gt;xmin&lt;/code&gt; этой строки &lt;code&gt;pg_index&lt;/code&gt; не окажется ниже их горизонта событий &lt;code&gt;TransactionXmin&lt;/code&gt; , потому что таблица может содержать разорванные цепочки HOT с несовместимыми строками, которые они могут видеть.</target>
        </trans-unit>
        <trans-unit id="e8ec7f29c2269b6f390b904f6368378dd35f78e8" translate="yes" xml:space="preserve">
          <source>If true, the index is currently ready for inserts. False means the index must be ignored by &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt; operations.</source>
          <target state="translated">Если true, индекс в настоящее время готов для вставки. False означает, что индекс должен игнорироваться операциями &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c0fcf74070493f9e01640902cbfc0c6b38f7360" translate="yes" xml:space="preserve">
          <source>If true, the index is currently valid for queries. False means the index is possibly incomplete: it must still be modified by &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt; operations, but it cannot safely be used for queries. If it is unique, the uniqueness property is not guaranteed true either.</source>
          <target state="translated">Если true, индекс в настоящее время действителен для запросов. False означает, что индекс, возможно, неполный: он все еще должен быть изменен операциями &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; , но его нельзя безопасно использовать для запросов. Если он уникален, свойство уникальности также не гарантируется.</target>
        </trans-unit>
        <trans-unit id="ab6de0df41664d3b3675c49edb64211adc3a12b2" translate="yes" xml:space="preserve">
          <source>If true, the stats include inheritance child columns, not just the values in the specified relation</source>
          <target state="translated">Если значение установлено в true,то статистика включает дочерние столбцы наследования,а не только значения в указанном соотношении</target>
        </trans-unit>
        <trans-unit id="ee7718b7881ae44cc98ca7be7fa2735272d5a098" translate="yes" xml:space="preserve">
          <source>If true, the subscription is enabled and should be replicating.</source>
          <target state="translated">Если это так,то подписка включена и должна быть реплицирована.</target>
        </trans-unit>
        <trans-unit id="aa9a0941d117d4d0d6546de8ecf8d6c048b76081" translate="yes" xml:space="preserve">
          <source>If true, the table was last clustered on this index</source>
          <target state="translated">Если это правда,то таблица была последней сгруппирована по этому индексу.</target>
        </trans-unit>
        <trans-unit id="0629da4ff91f39f869bbe66ce6c66a0e0b5d1ffd" translate="yes" xml:space="preserve">
          <source>If true, the uniqueness check is enforced immediately on insertion (irrelevant if &lt;code&gt;indisunique&lt;/code&gt; is not true)</source>
          <target state="translated">Если true, проверка уникальности принудительно выполняется сразу после вставки (не имеет значения, если &lt;code&gt;indisunique&lt;/code&gt; не истинно)</target>
        </trans-unit>
        <trans-unit id="588ebeeb8e4b96440c5bf3cc0c1bd5854026d4e7" translate="yes" xml:space="preserve">
          <source>If true, then this database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if false (the default), then only superusers or the owner of the database can clone it.</source>
          <target state="translated">Если true, то эту базу данных может клонировать любой пользователь с привилегиями &lt;code&gt;CREATEDB&lt;/code&gt; ; если false (по умолчанию), то только суперпользователи или владелец базы данных могут клонировать ее.</target>
        </trans-unit>
        <trans-unit id="7d71cd9fec73126b99ae1f7d42db7f62a2b72e24" translate="yes" xml:space="preserve">
          <source>If true, then this database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if false, then only superusers or the owner of the database can clone it.</source>
          <target state="translated">Если true, то эту базу данных может клонировать любой пользователь с привилегиями &lt;code&gt;CREATEDB&lt;/code&gt; ; если false, то только суперпользователи или владелец базы данных могут клонировать ее.</target>
        </trans-unit>
        <trans-unit id="1accbb6daee5f69b5c0f42943992a092e4ba1074" translate="yes" xml:space="preserve">
          <source>If true, this index represents the primary key of the table (&lt;code&gt;indisunique&lt;/code&gt; should always be true when this is true)</source>
          <target state="translated">Если истина, этот индекс представляет первичный ключ таблицы ( &lt;code&gt;indisunique&lt;/code&gt; всегда должен быть истиной, когда это правда)</target>
        </trans-unit>
        <trans-unit id="0f6e2116d6074f49b9f7bdf86e12bdd873ed8149" translate="yes" xml:space="preserve">
          <source>If true, this index supports an exclusion constraint</source>
          <target state="translated">Если верно,то этот индекс поддерживает ограничение на исключение.</target>
        </trans-unit>
        <trans-unit id="eb9d897ba2f316e5badcbcf694b6980e5d7c7ad0" translate="yes" xml:space="preserve">
          <source>If true, this is a unique index</source>
          <target state="translated">Если это так,то это уникальный индекс</target>
        </trans-unit>
        <trans-unit id="6763aa747866133b7f56f2197fde582b044036d1" translate="yes" xml:space="preserve">
          <source>If true, this publication automatically includes all tables in the database, including any that will be created in the future.</source>
          <target state="translated">Если это так,то данная публикация автоматически включает в себя все таблицы в базе данных,в том числе и те,которые будут созданы в будущем.</target>
        </trans-unit>
        <trans-unit id="2b4a0e4917a40fa5601228c6bffce7ba0283b004" translate="yes" xml:space="preserve">
          <source>If true, this row includes inheritance child columns, not just the values in the specified table</source>
          <target state="translated">Если переменная имеет значение true,то эта строка включает дочерние столбцы наследования,а не только значения в указанной таблице</target>
        </trans-unit>
        <trans-unit id="b5af22ae5132cfdb3c63b86048053d7c0759cd52" translate="yes" xml:space="preserve">
          <source>If two such transactions concurrently try to change the balance of account 12345, we clearly want the second transaction to start with the updated version of the account's row. Because each command is affecting only a predetermined row, letting it see the updated version of the row does not create any troublesome inconsistency.</source>
          <target state="translated">Если две такие транзакции одновременно пытаются изменить баланс счета 12345,то мы явно хотим,чтобы вторая транзакция начиналась с обновленной версии строки счета.Поскольку каждая команда воздействует только на предопределенный ряд,разрешение ему видеть обновленную версию ряда не создает никаких проблемных противоречий.</target>
        </trans-unit>
        <trans-unit id="286da9748bbda59905be5dc346e8fae92aa0edfb" translate="yes" xml:space="preserve">
          <source>If untrusted users have access to a database that has not adopted a &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;secure schema usage pattern&lt;/a&gt;, begin your session by removing publicly-writable schemas from &lt;code&gt;search_path&lt;/code&gt;. One can add &lt;code&gt;options=-csearch_path=&lt;/code&gt; to the connection string or issue &lt;code&gt;SELECT pg_catalog.set_config('search_path', '', false)&lt;/code&gt; before other SQL commands. This consideration is not specific to psql; it applies to every interface for executing arbitrary SQL commands.</source>
          <target state="translated">Если ненадежные пользователи имеют доступ к базе данных, которая не приняла &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;шаблон использования безопасной схемы&lt;/a&gt; , начните сеанс с удаления общедоступных для записи схем из &lt;code&gt;search_path&lt;/code&gt; . Можно добавить &lt;code&gt;options=-csearch_path=&lt;/code&gt; в строку подключения или выполнить &lt;code&gt;SELECT pg_catalog.set_config('search_path', '', false)&lt;/code&gt; перед другими командами SQL. Это соображение не относится к psql; он применяется ко всем интерфейсам для выполнения произвольных команд SQL.</target>
        </trans-unit>
        <trans-unit id="768ed7df41fe42c9b25945d5dff896541bf55b4f" translate="yes" xml:space="preserve">
          <source>If untrusted users have access to a database that has not adopted a &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;secure schema usage pattern&lt;/a&gt;, do not run pgbench in that database. pgbench uses unqualified names and does not manipulate the search path.</source>
          <target state="translated">Если ненадежные пользователи имеют доступ к базе данных, которая не приняла &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;шаблон использования защищенной схемы&lt;/a&gt; , не запускайте pgbench в этой базе данных. pgbench использует неполные имена и не изменяет путь поиска.</target>
        </trans-unit>
        <trans-unit id="91d0d0478151e73c50542244d9425b00c1130633" translate="yes" xml:space="preserve">
          <source>If using WAL archiving or streaming replication, consider disabling them during the restore. To do that, set &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;wal_level&lt;/code&gt; to &lt;code&gt;minimal&lt;/code&gt;, and &lt;code&gt;max_wal_senders&lt;/code&gt; to zero before loading the dump. Afterwards, set them back to the right values and take a fresh base backup.</source>
          <target state="translated">Если вы используете архивирование WAL или потоковую репликацию, рассмотрите возможность их отключения во время восстановления. Для этого перед загрузкой дампа установите для &lt;code&gt;archive_mode&lt;/code&gt; значение &lt;code&gt;off&lt;/code&gt; , &lt;code&gt;wal_level&lt;/code&gt; - &lt;code&gt;minimal&lt;/code&gt; и &lt;code&gt;max_wal_senders&lt;/code&gt; - ноль. После этого установите для них правильные значения и сделайте новую резервную копию базы.</target>
        </trans-unit>
        <trans-unit id="82f833ab3393a0e44827283b4406b6a15d35b9df" translate="yes" xml:space="preserve">
          <source>If using a pre-9.1 old server that is using a non-default Unix-domain socket directory or a default that differs from the default of the new cluster, set &lt;code&gt;PGHOST&lt;/code&gt; to point to the old server's socket location. (This is not relevant on Windows.)</source>
          <target state="translated">Если используется старый сервер до 9.1, который использует нестандартный каталог сокетов домена Unix или значение по умолчанию, которое отличается от значения по умолчанию для нового кластера, установите &lt;code&gt;PGHOST&lt;/code&gt; так, чтобы он указывал на расположение сокета старого сервера. (Это не относится к Windows.)</target>
        </trans-unit>
        <trans-unit id="1fc1fe1aaf9532782aa2ed49cabaa7db59b86f4e" translate="yes" xml:space="preserve">
          <source>If waiting is disabled, the requested action is triggered, but there is no feedback about its success. In that case, the server log file or an external monitoring system would have to be used to check the progress and success of the operation.</source>
          <target state="translated">Если ожидание отключено,запрашиваемое действие срабатывает,но обратной связи о его успешности нет.В этом случае лог-файл сервера или внешняя система мониторинга должна будет использоваться для проверки хода и успешности выполнения операции.</target>
        </trans-unit>
        <trans-unit id="7b03befc0afa9f43bd61408ea6224efc69f041cf" translate="yes" xml:space="preserve">
          <source>If we change the query's selectivity a bit, we might get a very different join plan:</source>
          <target state="translated">Если мы немного изменим селективность запроса,то можем получить совсем другой план соединения:</target>
        </trans-unit>
        <trans-unit id="3514492aa3ac15aedee53bae788660dc8e748122" translate="yes" xml:space="preserve">
          <source>If we continuously feed the series of WAL files to another machine that has been loaded with the same base backup file, we have a &lt;em&gt;warm standby&lt;/em&gt; system: at any point we can bring up the second machine and it will have a nearly-current copy of the database.</source>
          <target state="translated">Если мы постоянно кормить серию WAL файлов на другую машину , которая была загружена с тем же файлом база резервного копирования, мы имеем &lt;em&gt;теплое ожидание&lt;/em&gt; системы: в любой момент мы можем вывести вторую машину , и она будет иметь почти-текущую копию база данных.</target>
        </trans-unit>
        <trans-unit id="a739f17951b6e075a348a61e8bb0affec3a10686" translate="yes" xml:space="preserve">
          <source>If we declared &lt;code&gt;cities&lt;/code&gt;.&lt;code&gt;name&lt;/code&gt; to be &lt;code&gt;UNIQUE&lt;/code&gt; or a &lt;code&gt;PRIMARY KEY&lt;/code&gt;, this would not stop the &lt;code&gt;capitals&lt;/code&gt; table from having rows with names duplicating rows in &lt;code&gt;cities&lt;/code&gt;. And those duplicate rows would by default show up in queries from &lt;code&gt;cities&lt;/code&gt;. In fact, by default &lt;code&gt;capitals&lt;/code&gt; would have no unique constraint at all, and so could contain multiple rows with the same name. You could add a unique constraint to &lt;code&gt;capitals&lt;/code&gt;, but this would not prevent duplication compared to &lt;code&gt;cities&lt;/code&gt;.</source>
          <target state="translated">Если мы объявили &lt;code&gt;cities&lt;/code&gt; . &lt;code&gt;name&lt;/code&gt; должно быть &lt;code&gt;UNIQUE&lt;/code&gt; или &lt;code&gt;PRIMARY KEY&lt;/code&gt; , это не помешает таблице &lt;code&gt;capitals&lt;/code&gt; иметь строки с именами, дублирующими строки в &lt;code&gt;cities&lt;/code&gt; . И эти повторяющиеся строки по умолчанию будут отображаться в запросах из &lt;code&gt;cities&lt;/code&gt; . Фактически, по умолчанию &lt;code&gt;capitals&lt;/code&gt; буквы вообще не будут иметь уникального ограничения и, следовательно, могут содержать несколько строк с одним и тем же именем. Вы можете добавить уникальное ограничение к &lt;code&gt;capitals&lt;/code&gt; , но это не предотвратит дублирование по сравнению с &lt;code&gt;cities&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="347337a04b51d83bd4c64fbb8fed60949423b25a" translate="yes" xml:space="preserve">
          <source>If we wanted to know what city (or cities) that reading occurred in, we might try:</source>
          <target state="translated">Если бы мы хотели узнать,в каком городе (или городах)произошло чтение,мы могли бы попробовать:</target>
        </trans-unit>
        <trans-unit id="d101ff564aae9ba45b998f26d6b5819ae89be6cf" translate="yes" xml:space="preserve">
          <source>If we were to declare this index &lt;code&gt;UNIQUE&lt;/code&gt;, it would prevent creation of rows whose &lt;code&gt;col1&lt;/code&gt; values differ only in case, as well as rows whose &lt;code&gt;col1&lt;/code&gt; values are actually identical. Thus, indexes on expressions can be used to enforce constraints that are not definable as simple unique constraints.</source>
          <target state="translated">Если бы мы объявили этот индекс &lt;code&gt;UNIQUE&lt;/code&gt; , это предотвратило бы создание строк, значения &lt;code&gt;col1&lt;/code&gt; которых отличаются только регистром, а также строк, значения &lt;code&gt;col1&lt;/code&gt; которых фактически идентичны. Таким образом, индексы в выражениях могут использоваться для обеспечения ограничений, которые нельзя определить как простые уникальные ограничения.</target>
        </trans-unit>
        <trans-unit id="26385616d9682a5e8b9897f0b99ebecc8622b226" translate="yes" xml:space="preserve">
          <source>If what you desire is a one-time check against other rows at row insertion, rather than a continuously-maintained consistency guarantee, a custom &lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;trigger&lt;/a&gt; can be used to implement that. (This approach avoids the dump/reload problem because pg_dump does not reinstall triggers until after reloading data, so that the check will not be enforced during a dump/reload.)</source>
          <target state="translated">Если вам нужна однократная проверка других строк при вставке строки, а не постоянно поддерживаемая гарантия согласованности, для этого можно использовать настраиваемый &lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;триггер&lt;/a&gt; . (Этот подход позволяет избежать проблемы дампа / перезагрузки, поскольку pg_dump не переустанавливает триггеры до тех пор, пока не будет перезагружены данные, поэтому проверка не будет выполняться принудительно во время дампа / перезагрузки.)</target>
        </trans-unit>
        <trans-unit id="bccf2a93440f14e5520a966b4714acd9fc9f1297" translate="yes" xml:space="preserve">
          <source>If what you desire is a one-time check against other rows at row insertion, rather than a continuously-maintained consistency guarantee, a custom &lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;trigger&lt;/a&gt; can be used to implement that. (This approach avoids the dump/reload problem because pg_dump does not reinstall triggers until after reloading data, so that the check will not be enforced during a dump/reload.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a14ecb62361bc225683313f20ed64062f67ccd0" translate="yes" xml:space="preserve">
          <source>If you already have, or suspect you have, orphaned large objects, see the &lt;a href=&quot;https://www.postgresql.org/docs/12/vacuumlo.html&quot;&gt;vacuumlo&lt;/a&gt; module to help you clean them up. It's a good idea to run vacuumlo occasionally as a back-stop to the &lt;code&gt;lo_manage&lt;/code&gt; trigger.</source>
          <target state="translated">Если у вас уже есть или вы подозреваете, что у вас есть осиротевшие большие объекты, см. Модуль &amp;laquo; &lt;a href=&quot;https://www.postgresql.org/docs/12/vacuumlo.html&quot;&gt;Вакуумло&lt;/a&gt; &amp;raquo;, который поможет вам их очистить. Рекомендуется время от времени запускать Vacuumlo как остановку для триггера &lt;code&gt;lo_manage&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d59e957767c53445cccc5f8621efd7719624cb5" translate="yes" xml:space="preserve">
          <source>If you already have, or suspect you have, orphaned large objects, see the &lt;a href=&quot;https://www.postgresql.org/docs/13/vacuumlo.html&quot;&gt;vacuumlo&lt;/a&gt; module to help you clean them up. It's a good idea to run vacuumlo occasionally as a back-stop to the &lt;code&gt;lo_manage&lt;/code&gt; trigger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f390f29503d5d3e24b107064bb2a33c6ee6ea964" translate="yes" xml:space="preserve">
          <source>If you are adding large amounts of data to an existing table, it might be a win to drop the indexes, load the table, and then recreate the indexes. Of course, the database performance for other users might suffer during the time the indexes are missing. One should also think twice before dropping a unique index, since the error checking afforded by the unique constraint will be lost while the index is missing.</source>
          <target state="translated">Если вы добавляете большие объемы данных в существующую таблицу,это может быть выигрышем,если вы откажетесь от индексов,загрузите таблицу,а затем заново создадите индексы.Конечно,производительность базы данных для других пользователей может пострадать во время отсутствия индексов.Следует также подумать дважды,прежде чем сбрасывать уникальный индекс,так как проверка на ошибки,предоставляемые уникальным ограничением будет потеряна в то время как индекс отсутствует.</target>
        </trans-unit>
        <trans-unit id="f9e2dec1d154e8ddecdda1dfc7964b3ebcabb443" translate="yes" xml:space="preserve">
          <source>If you are installing PostgreSQL yourself, then refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for instructions on installation, and return to this guide when the installation is complete. Be sure to follow closely the section about setting up the appropriate environment variables.</source>
          <target state="translated">Если вы устанавливаете PostgreSQL самостоятельно, обратитесь к &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;главе 16&lt;/a&gt; за инструкциями по установке и вернитесь к этому руководству, когда установка будет завершена. Обязательно внимательно следите за разделом о настройке соответствующих переменных среды.</target>
        </trans-unit>
        <trans-unit id="cd8e24142c807e0a347a699916b6cae27e9af283" translate="yes" xml:space="preserve">
          <source>If you are installing PostgreSQL yourself, then refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for instructions on installation, and return to this guide when the installation is complete. Be sure to follow closely the section about setting up the appropriate environment variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb64bee8b7a2efcbeba6cf8a6dff70e83085729" translate="yes" xml:space="preserve">
          <source>If you are loading a freshly created table, the fastest method is to create the table, bulk load the table's data using &lt;code&gt;COPY&lt;/code&gt;, then create any indexes needed for the table. Creating an index on pre-existing data is quicker than updating it incrementally as each row is loaded.</source>
          <target state="translated">Если вы загружаете только что созданную таблицу, самым быстрым методом является создание таблицы, массовая загрузка данных таблицы с помощью &lt;code&gt;COPY&lt;/code&gt; , а затем создание любых индексов, необходимых для таблицы. Создание индекса для уже существующих данных происходит быстрее, чем его постепенное обновление по мере загрузки каждой строки.</target>
        </trans-unit>
        <trans-unit id="d87d9e34c581612e87603daaced88774ab9fe111" translate="yes" xml:space="preserve">
          <source>If you are not planning to use prepared transactions, this parameter should be set to zero to prevent accidental creation of prepared transactions. If you are using prepared transactions, you will probably want &lt;code&gt;max_prepared_transactions&lt;/code&gt; to be at least as large as &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;, so that every session can have a prepared transaction pending.</source>
          <target state="translated">Если вы не планируете использовать подготовленные транзакции, этот параметр следует установить в ноль, чтобы предотвратить случайное создание подготовленных транзакций. Если вы используете подготовленные транзакции, вы, вероятно, захотите, чтобы &lt;code&gt;max_prepared_transactions&lt;/code&gt; было не меньше &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; , чтобы в каждом сеансе могла быть подготовленная ожидающая транзакция.</target>
        </trans-unit>
        <trans-unit id="ca7f65648bc353887b727a182f8f612fdb9429de" translate="yes" xml:space="preserve">
          <source>If you are not sure whether PostgreSQL is already available or whether you can use it for your experimentation then you can install it yourself. Doing so is not hard and it can be a good exercise. PostgreSQL can be installed by any unprivileged user; no superuser (root) access is required.</source>
          <target state="translated">Если вы не уверены,доступен ли уже PostgreSQL или вы можете использовать его для экспериментов,вы можете установить его самостоятельно.Сделать это не сложно,и это может быть хорошим упражнением.PostgreSQL может быть установлен любым непривилегированным пользователем;никакого суперпользовательского (корневого)доступа не требуется.</target>
        </trans-unit>
        <trans-unit id="6c854ded65666fb7e53665772a506fafbd718961" translate="yes" xml:space="preserve">
          <source>If you are running file-based log shipping (&quot;warm standby&quot;), you might need to wait until the next WAL file arrives, which could be as long as the &lt;code&gt;archive_timeout&lt;/code&gt; setting on the primary.</source>
          <target state="translated">Если вы используете доставку журналов на основе файлов (&amp;laquo;теплый резерв&amp;raquo;), вам может потребоваться подождать, пока не прибудет следующий файл WAL, который может иметь длину, &lt;code&gt;archive_timeout&lt;/code&gt; параметру archive_timeout на первичном сервере .</target>
        </trans-unit>
        <trans-unit id="100df6210b436366664b5674494d353d329c78c1" translate="yes" xml:space="preserve">
          <source>If you are upgrading a pre-PostgreSQL 9.2 cluster that uses a configuration-file-only directory, you must pass the real data directory location to pg_upgrade, and pass the configuration directory location to the server, e.g. &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt;.</source>
          <target state="translated">Если вы обновляете кластер до PostgreSQL 9.2, который использует каталог только для файла конфигурации, вы должны передать реальное местоположение каталога данных в pg_upgrade и передать местоположение каталога конфигурации серверу, например &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc55bda54288eb26294b0ebbfc29f843e85f5f66" translate="yes" xml:space="preserve">
          <source>If you are upgrading a pre-PostgreSQL 9.2 cluster that uses a configuration-file-only directory, you must pass the real data directory location to pg_upgrade, and pass the configuration directory location to the server, e.g., &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6433dfa1c8ec93408de2c79d0f13ec3cb038d812" translate="yes" xml:space="preserve">
          <source>If you are upgrading standby servers using methods outlined in section &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;Step 10&lt;/a&gt;, verify that the old standby servers are caught up by running pg_controldata against the old primary and standby clusters. Verify that the &amp;ldquo;Latest checkpoint location&amp;rdquo; values match in all clusters. (There will be a mismatch if old standby servers were shut down before the old primary or if the old standby servers are still running.) Also, change &lt;code&gt;wal_level&lt;/code&gt; to &lt;code&gt;replica&lt;/code&gt; in the &lt;code&gt;postgresql.conf&lt;/code&gt; file on the new primary cluster.</source>
          <target state="translated">Если вы обновляете резервные серверы, используя методы, описанные в разделе &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;Шаг 10&lt;/a&gt; , убедитесь, что старые резервные серверы подключены, запустив pg_controldata на старом основном и резервном кластерах. Убедитесь, что значения &amp;laquo;Расположение последней контрольной точки&amp;raquo; совпадают во всех кластерах. (Несовпадение будет, если старые резервные серверы были выключены раньше старого основного или старые резервные серверы все еще работают.) Кроме того, измените &lt;code&gt;wal_level&lt;/code&gt; на &lt;code&gt;replica&lt;/code&gt; в файле &lt;code&gt;postgresql.conf&lt;/code&gt; на новом основном кластере.</target>
        </trans-unit>
        <trans-unit id="a25fedf0ac6ffff68a2762449d5371eee093e033" translate="yes" xml:space="preserve">
          <source>If you are upgrading standby servers using methods outlined in section &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;Step 10&lt;/a&gt;, verify that the old standby servers are caught up by running pg_controldata against the old primary and standby clusters. Verify that the &amp;ldquo;Latest checkpoint location&amp;rdquo; values match in all clusters. (There will be a mismatch if old standby servers were shut down before the old primary or if the old standby servers are still running.) Also, make sure &lt;code&gt;wal_level&lt;/code&gt; is not set to &lt;code&gt;minimal&lt;/code&gt; in the &lt;code&gt;postgresql.conf&lt;/code&gt; file on the new primary cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f73d78215cef8d2ef14222445477bdca411ef71" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;-X none&lt;/code&gt;, there is no guarantee that all WAL files required for the backup are archived at the end of backup.</source>
          <target state="translated">Если вы используете &lt;code&gt;-X none&lt;/code&gt; , нет гарантии, что все файлы WAL, необходимые для резервного копирования, будут заархивированы в конце резервного копирования.</target>
        </trans-unit>
        <trans-unit id="9d0f772d8182283e7e8eeabb4a80f986e054e96a" translate="yes" xml:space="preserve">
          <source>If you are using a pre-packaged version of PostgreSQL, and you used its provisions for starting the server, then you should also use its provisions for stopping the server. Consult the package-level documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc432d389e68b3790013be9ab641ccb60838ff96" translate="yes" xml:space="preserve">
          <source>If you are using a pre-packaged version of PostgreSQL, it almost certainly includes provisions for running the server as a background task according to the conventions of your operating system. Using the package's infrastructure to start the server will be much less work than figuring out how to do this yourself. Consult the package-level documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec81265be63b85cd110675b546ea20c69a22e29" translate="yes" xml:space="preserve">
          <source>If you are using a pre-packaged version of PostgreSQL, it may well have a specific convention for where to place the data directory, and it may also provide a script for creating the data directory. In that case you should use that script in preference to running &lt;code&gt;initdb&lt;/code&gt; directly. Consult the package-level documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87540bbfb46f5ca553285a02a78a4413f99dfe1" translate="yes" xml:space="preserve">
          <source>If you are using a version-specific installation directory, e.g. &lt;code&gt;/opt/PostgreSQL/12&lt;/code&gt;, you do not need to move the old cluster. The graphical installers all use version-specific installation directories.</source>
          <target state="translated">Если вы используете каталог установки для конкретной версии, например &lt;code&gt;/opt/PostgreSQL/12&lt;/code&gt; , вам не нужно перемещать старый кластер. Все графические установщики используют каталоги установки для конкретных версий.</target>
        </trans-unit>
        <trans-unit id="d8bbcc7b0eac5395154e7966b802a1726a037170" translate="yes" xml:space="preserve">
          <source>If you are using a version-specific installation directory, e.g., &lt;code&gt;/opt/PostgreSQL/13&lt;/code&gt;, you do not need to move the old cluster. The graphical installers all use version-specific installation directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb6b5bbb35f9c84113d155adac8b2ce50841366" translate="yes" xml:space="preserve">
          <source>If you are using manual &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;ANALYZE&lt;/code&gt; commands, don't forget that you need to run them on each child table individually. A command like:</source>
          <target state="translated">Если вы используете ручные команды &lt;code&gt;VACUUM&lt;/code&gt; или &lt;code&gt;ANALYZE&lt;/code&gt; , не забывайте, что вам нужно запускать их для каждой дочерней таблицы индивидуально. Команда вроде:</target>
        </trans-unit>
        <trans-unit id="657742cf08661b004524bce37cea4f60251b3473" translate="yes" xml:space="preserve">
          <source>If you believe a 90% cache rate is an incorrect assumption for your workload, you can increase random_page_cost to better reflect the true cost of random storage reads. Correspondingly, if your data is likely to be completely in cache, such as when the database is smaller than the total server memory, decreasing random_page_cost can be appropriate. Storage that has a low random read cost relative to sequential, e.g. solid-state drives, might also be better modeled with a lower value for random_page_cost.</source>
          <target state="translated">Если вы считаете,что 90%-ная скорость кэширования является неверным предположением для вашей рабочей нагрузки,вы можете увеличить значение параметра random_page_cost,чтобы лучше отразить истинную стоимость чтения случайных записей в системе хранения данных.Соответственно,если ваши данные,скорее всего,полностью находятся в кэше,например,когда база данных меньше общей памяти сервера,уменьшение random_page_cost может быть уместно.Хранилище с низкой стоимостью случайного чтения по сравнению с последовательными,например,твердотельные накопители,также может быть лучше смоделировано с меньшим значением для random_page_cost.</target>
        </trans-unit>
        <trans-unit id="01590de3b1a45b503095ec546feb704e9b7a0246" translate="yes" xml:space="preserve">
          <source>If you believe a 90% cache rate is an incorrect assumption for your workload, you can increase random_page_cost to better reflect the true cost of random storage reads. Correspondingly, if your data is likely to be completely in cache, such as when the database is smaller than the total server memory, decreasing random_page_cost can be appropriate. Storage that has a low random read cost relative to sequential, e.g., solid-state drives, might also be better modeled with a lower value for random_page_cost, e.g., &lt;code&gt;1.1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de352785d4d320deb71e5335924b75625cf49620" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;\set&lt;/code&gt; without a second argument, the variable is set to an empty-string value. To unset (i.e., delete) a variable, use the command &lt;code&gt;\unset&lt;/code&gt;. To show the values of all variables, call &lt;code&gt;\set&lt;/code&gt; without any argument.</source>
          <target state="translated">Если вы вызываете &lt;code&gt;\set&lt;/code&gt; без второго аргумента, для переменной устанавливается значение пустой строки. Чтобы сбросить (т.е. удалить) переменную, используйте команду &lt;code&gt;\unset&lt;/code&gt; . Чтобы показать значения всех переменных, вызовите &lt;code&gt;\set&lt;/code&gt; без аргументов.</target>
        </trans-unit>
        <trans-unit id="0259699cb6f3b30e1cd0e413c4e39248024e19a0" translate="yes" xml:space="preserve">
          <source>If you cannot free up additional space on the disk by deleting other things, you can move some of the database files to other file systems by making use of tablespaces. See &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt; for more information about that.</source>
          <target state="translated">Если вы не можете освободить дополнительное пространство на диске, удалив другие вещи, вы можете переместить некоторые файлы базы данных в другие файловые системы, используя табличные пространства. См. &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Раздел 22.6&lt;/a&gt; для получения дополнительной информации об этом.</target>
        </trans-unit>
        <trans-unit id="a6b2ee409cca3f880cf89818705f66642823737c" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;code&gt;COPY&lt;/code&gt;, it might help to use &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; to create a prepared &lt;code&gt;INSERT&lt;/code&gt; statement, and then use &lt;code&gt;EXECUTE&lt;/code&gt; as many times as required. This avoids some of the overhead of repeatedly parsing and planning &lt;code&gt;INSERT&lt;/code&gt;. Different interfaces provide this facility in different ways; look for &amp;ldquo;prepared statements&amp;rdquo; in the interface documentation.</source>
          <target state="translated">Если вы не можете использовать &lt;code&gt;COPY&lt;/code&gt; , может быть &lt;a href=&quot;sql-prepare&quot;&gt;полезно&lt;/a&gt; использовать PREPARE для создания подготовленного оператора &lt;code&gt;INSERT&lt;/code&gt; , а затем использовать &lt;code&gt;EXECUTE&lt;/code&gt; столько раз, сколько потребуется. Это позволяет избежать некоторых накладных расходов на многократный синтаксический анализ и планирование &lt;code&gt;INSERT&lt;/code&gt; . Различные интерфейсы предоставляют эту возможность по-разному; ищите &amp;laquo;подготовленные операторы&amp;raquo; в документации по интерфейсу.</target>
        </trans-unit>
        <trans-unit id="f74f5e82fb19007ba8087ea69c4af7c169641fbd" translate="yes" xml:space="preserve">
          <source>If you cannot, then better do crypto inside client application.</source>
          <target state="translated">Если вы не можете,то лучше сделать крипто внутри клиентского приложения.</target>
        </trans-unit>
        <trans-unit id="c6938a67160fbaea3812e5c1afc009d637ef7fc7" translate="yes" xml:space="preserve">
          <source>If you declare a column as &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt;, the implicitly generated index is case-sensitive. So it's useless for case-insensitive searches, and it won't enforce uniqueness case-insensitively.</source>
          <target state="translated">Если вы объявляете столбец как &lt;code&gt;UNIQUE&lt;/code&gt; или &lt;code&gt;PRIMARY KEY&lt;/code&gt; , неявно сгенерированный индекс чувствителен к регистру. Таким образом, он бесполезен для поиска без учета регистра, и он не будет обеспечивать уникальность без учета регистра.</target>
        </trans-unit>
        <trans-unit id="bab8b24944cb37a1a0e9e93c41e90f5a2cb6ccb4" translate="yes" xml:space="preserve">
          <source>If you did &lt;em&gt;not&lt;/em&gt; start the new cluster, the old cluster was unmodified except that, when linking started, a &lt;code&gt;.old&lt;/code&gt; suffix was appended to &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt;. To reuse the old cluster, remove the &lt;code&gt;.old&lt;/code&gt; suffix from &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt;; you can then restart the old cluster.</source>
          <target state="translated">Если вы &lt;em&gt;не&lt;/em&gt; запускали новый кластер, старый кластер не был изменен, за исключением того, что при запуске связывания суффикс &lt;code&gt;.old&lt;/code&gt; был добавлен к &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt; . Чтобы повторно использовать старый кластер, удалите суффикс &lt;code&gt;.old&lt;/code&gt; из &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt; ; затем вы можете перезапустить старый кластер.</target>
        </trans-unit>
        <trans-unit id="62b2adb362a08de49cfa1c83dea8a83d9bb2213c" translate="yes" xml:space="preserve">
          <source>If you did &lt;em&gt;not&lt;/em&gt; use link mode, do not have or do not want to use rsync, or want an easier solution, skip the instructions in this section and simply recreate the standby servers once pg_upgrade completes and the new primary is running.</source>
          <target state="translated">Если вы &lt;em&gt;не&lt;/em&gt; использовали режим связи, у вас нет или вы не хотите использовать rsync или хотите более простое решение, пропустите инструкции в этом разделе и просто воссоздайте резервные серверы после завершения pg_upgrade и запуска нового основного.</target>
        </trans-unit>
        <trans-unit id="90981d7a01c90cf36de6cae3508f26abcc450f7b" translate="yes" xml:space="preserve">
          <source>If you did start the new cluster, it has written to shared files and it is unsafe to use the old cluster. The old cluster will need to be restored from backup in this case.</source>
          <target state="translated">Если вы запустили новый кластер,он был записан в общие файлы,и использовать старый кластер небезопасно.В этом случае старый кластер нужно будет восстановить из резервной копии.</target>
        </trans-unit>
        <trans-unit id="47fd87d8debe284e9f481467ae1affc261e54ea8" translate="yes" xml:space="preserve">
          <source>If you do not like the output format for &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; values, try the functions &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt;, and &lt;code&gt;abbrev&lt;/code&gt;.</source>
          <target state="translated">Если вам не нравится выходной формат для значений &lt;code&gt;inet&lt;/code&gt; или &lt;code&gt;cidr&lt;/code&gt; , попробуйте функции &lt;code&gt;host&lt;/code&gt; , &lt;code&gt;text&lt;/code&gt; и &lt;code&gt;abbrev&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f96a8ec302a42bc03e998712a66f544972ee1509" translate="yes" xml:space="preserve">
          <source>If you do not succeed in adjusting the costs to be more appropriate, then you might have to resort to forcing index usage explicitly. You might also want to contact the PostgreSQL developers to examine the issue.</source>
          <target state="translated">Если вам не удастся скорректировать расходы таким образом,чтобы они были более подходящими,то вам,возможно,придется прибегнуть к явному принуждению к использованию индекса.Вы также можете обратиться к разработчикам PostgreSQL для изучения этой проблемы.</target>
        </trans-unit>
        <trans-unit id="b4cd7de986e411178ee91fc3fe47680a23518cd4" translate="yes" xml:space="preserve">
          <source>If you do not supply the database name then it will default to your user account name. You already discovered this scheme in the previous section using &lt;code&gt;createdb&lt;/code&gt;.</source>
          <target state="translated">Если вы не укажете имя базы данных, по умолчанию будет использоваться имя вашей учетной записи. Вы уже обнаружили эту схему в предыдущем разделе, используя &lt;code&gt;createdb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be339a6a88d4d2b9b65bab603b8e3c0d2fd399fd" translate="yes" xml:space="preserve">
          <source>If you do not want to use your database anymore you can remove it. For example, if you are the owner (creator) of the database &lt;code&gt;mydb&lt;/code&gt;, you can destroy it using the following command:</source>
          <target state="translated">Если вы больше не хотите использовать свою базу данных, вы можете удалить ее. Например, если вы являетесь владельцем (создателем) базы данных &lt;code&gt;mydb&lt;/code&gt; , вы можете уничтожить ее, используя следующую команду:</target>
        </trans-unit>
        <trans-unit id="08e08381cd8f923213bb0bae5a2a61f673142186" translate="yes" xml:space="preserve">
          <source>If you don't have values for all the columns, you can omit some of them. In that case, the columns will be filled with their default values. For example:</source>
          <target state="translated">Если у вас нет значений для всех колонок,вы можете опустить некоторые из них.В этом случае столбцы будут заполнены значениями по умолчанию.Например:</target>
        </trans-unit>
        <trans-unit id="404e82d0a58303983c4b5022b612f1fb6248be48" translate="yes" xml:space="preserve">
          <source>If you drop and then recreate a function, the new function is not the same entity as the old; you will have to drop existing rules, views, triggers, etc. that refer to the old function. Use &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; to change a function definition without breaking objects that refer to the function. Also, &lt;code&gt;ALTER FUNCTION&lt;/code&gt; can be used to change most of the auxiliary properties of an existing function.</source>
          <target state="translated">Если вы удалите, а затем воссоздадите функцию, новая функция будет отличаться от старой; вам придется отбросить существующие правила, представления, триггеры и т. д., которые относятся к старой функции. Используйте &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; , чтобы изменить определение функции, не нарушая объекты, которые ссылаются на функцию. Кроме того, &lt;code&gt;ALTER FUNCTION&lt;/code&gt; можно использовать для изменения большинства вспомогательных свойств существующей функции.</target>
        </trans-unit>
        <trans-unit id="be307ca6bbc030429d0d787ca8543b0973b17c65" translate="yes" xml:space="preserve">
          <source>If you encounter problems starting &lt;code&gt;psql&lt;/code&gt; then go back to the previous section. The diagnostics of &lt;code&gt;createdb&lt;/code&gt; and &lt;code&gt;psql&lt;/code&gt; are similar, and if the former worked the latter should work as well.</source>
          <target state="translated">Если вы столкнулись с проблемами при запуске &lt;code&gt;psql&lt;/code&gt; , вернитесь к предыдущему разделу. Диагностика &lt;code&gt;createdb&lt;/code&gt; и &lt;code&gt;psql&lt;/code&gt; аналогична, и если первая сработала, вторая тоже должна работать.</target>
        </trans-unit>
        <trans-unit id="b13cd3cf02514f3a86f3431f0fe84ad64d68a6f3" translate="yes" xml:space="preserve">
          <source>If you feel you need more introductory material, please visit the PostgreSQL &lt;a href=&quot;https://www.postgresql.org&quot;&gt;web site&lt;/a&gt; for links to more resources.</source>
          <target state="translated">Если вы чувствуете, что вам нужны дополнительные вводные материалы, посетите &lt;a href=&quot;https://www.postgresql.org&quot;&gt;веб-сайт&lt;/a&gt; PostgreSQL, чтобы найти ссылки на дополнительные ресурсы.</target>
        </trans-unit>
        <trans-unit id="27223facca9dbba24447f51ca3cc46e2a4d4b2ed" translate="yes" xml:space="preserve">
          <source>If you get an &amp;ldquo;illegal system call&amp;rdquo; error, it is likely that shared memory or semaphores are not supported in your kernel at all. In that case your only option is to reconfigure the kernel to enable these features.</source>
          <target state="translated">Если вы получаете ошибку &amp;laquo;недопустимый системный вызов&amp;raquo;, вполне вероятно, что разделяемая память или семафоры вообще не поддерживаются вашим ядром. В этом случае ваш единственный вариант - перенастроить ядро ​​для включения этих функций.</target>
        </trans-unit>
        <trans-unit id="7aa554ad85b0e28436475081421e4e00eaf4dd3c" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; turned off, any backslashes you write in literal string constants will need to be doubled. See &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt; for more information.</source>
          <target state="translated">Если у вас отключен &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; , любые обратные косые черты, которые вы пишете в буквальных строковых константах, должны быть удвоены. См. &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Раздел 4.1.2.1&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="f61cc65bca02db4eb1ea500b6eae076fd93f0491" translate="yes" xml:space="preserve">
          <source>If you have a dedicated database server with 1GB or more of RAM, a reasonable starting value for &lt;code&gt;shared_buffers&lt;/code&gt; is 25% of the memory in your system. There are some workloads where even larger settings for &lt;code&gt;shared_buffers&lt;/code&gt; are effective, but because PostgreSQL also relies on the operating system cache, it is unlikely that an allocation of more than 40% of RAM to &lt;code&gt;shared_buffers&lt;/code&gt; will work better than a smaller amount. Larger settings for &lt;code&gt;shared_buffers&lt;/code&gt; usually require a corresponding increase in &lt;code&gt;max_wal_size&lt;/code&gt;, in order to spread out the process of writing large quantities of new or changed data over a longer period of time.</source>
          <target state="translated">Если у вас есть выделенный сервер базы данных с 1 ГБ или более оперативной памяти, разумное начальное значение &lt;code&gt;shared_buffers&lt;/code&gt; составляет 25% памяти в вашей системе. Есть некоторые рабочие нагрузки, в которых эффективны даже большие настройки &lt;code&gt;shared_buffers&lt;/code&gt; , но поскольку PostgreSQL также полагается на кеш операционной системы, маловероятно, что выделение более 40% RAM для &lt;code&gt;shared_buffers&lt;/code&gt; будет работать лучше, чем меньшее количество. Большие настройки &lt;code&gt;shared_buffers&lt;/code&gt; обычно требуют соответствующего увеличения &lt;code&gt;max_wal_size&lt;/code&gt; , чтобы распределить процесс записи больших объемов новых или измененных данных на более длительный период времени.</target>
        </trans-unit>
        <trans-unit id="5955ce4878872fc7d42a5cf4a3feceaf0ce085c2" translate="yes" xml:space="preserve">
          <source>If you have a table that contains both billed and unbilled orders, where the unbilled orders take up a small fraction of the total table and yet those are the most-accessed rows, you can improve performance by creating an index on just the unbilled rows. The command to create the index would look like this:</source>
          <target state="translated">Если у вас есть таблица,содержащая как биллинговые,так и не биллинговые поручения,где не биллинговые поручения занимают небольшую часть общей таблицы,и при этом являются самыми доступными строками,вы можете повысить производительность,создав индекс только по не биллинговым строкам.Команда для создания индекса будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="3db868f1aa52b4182eabc5a6aaef64ca58b29be3" translate="yes" xml:space="preserve">
          <source>If you have a table whose entire contents are deleted on a periodic basis, consider doing it with &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; rather than using &lt;code&gt;DELETE&lt;/code&gt; followed by &lt;code&gt;VACUUM&lt;/code&gt;. &lt;code&gt;TRUNCATE&lt;/code&gt; removes the entire content of the table immediately, without requiring a subsequent &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; to reclaim the now-unused disk space. The disadvantage is that strict MVCC semantics are violated.</source>
          <target state="translated">Если у вас есть таблица, все содержимое которой периодически удаляется, подумайте о том, чтобы делать это с помощью &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE,&lt;/a&gt; а не с помощью &lt;code&gt;DELETE&lt;/code&gt; с последующим &lt;code&gt;VACUUM&lt;/code&gt; . &lt;code&gt;TRUNCATE&lt;/code&gt; немедленно удаляет все содержимое таблицы, не требуя последующего &lt;code&gt;VACUUM&lt;/code&gt; или &lt;code&gt;VACUUM FULL&lt;/code&gt; для освобождения теперь неиспользуемого дискового пространства. Недостатком является нарушение строгой семантики MVCC.</target>
        </trans-unit>
        <trans-unit id="edada2f4a0ea8a1fe6f35435a51d724440a997b9" translate="yes" xml:space="preserve">
          <source>If you have a user account but it does not have the privileges required to create a database, you will see the following:</source>
          <target state="translated">Если у вас есть учетная запись пользователя,но она не имеет привилегий,необходимых для создания базы данных,вы увидите следующее:</target>
        </trans-unit>
        <trans-unit id="6e1ffd7834998be91b2b3ef3885c4c95ac1fca94" translate="yes" xml:space="preserve">
          <source>If you have an embedded SQL C source file named &lt;code&gt;prog1.pgc&lt;/code&gt;, you can create an executable program using the following sequence of commands:</source>
          <target state="translated">Если у вас есть встроенный исходный файл SQL C с именем &lt;code&gt;prog1.pgc&lt;/code&gt; , вы можете создать исполняемую программу, используя следующую последовательность команд:</target>
        </trans-unit>
        <trans-unit id="3a617edae0e90918be65ecbfa41a4edb3f6fbb0d" translate="yes" xml:space="preserve">
          <source>If you have dug into the details of the file system layout of the database, you might be tempted to try to back up or restore only certain individual tables or databases from their respective files or directories. This will &lt;em&gt;not&lt;/em&gt; work because the information contained in these files is not usable without the commit log files, &lt;code&gt;pg_xact/*&lt;/code&gt;, which contain the commit status of all transactions. A table file is only usable with this information. Of course it is also impossible to restore only a table and the associated &lt;code&gt;pg_xact&lt;/code&gt; data because that would render all other tables in the database cluster useless. So file system backups only work for complete backup and restoration of an entire database cluster.</source>
          <target state="translated">Если вы вникли в подробности структуры файловой системы базы данных, у вас может возникнуть соблазн попробовать создать резервную копию или восстановить только определенные отдельные таблицы или базы данных из соответствующих файлов или каталогов. Это &lt;em&gt;не&lt;/em&gt; сработает, потому что информация, содержащаяся в этих файлах, не может использоваться без файлов журнала фиксации, &lt;code&gt;pg_xact/*&lt;/code&gt; , которые содержат статус фиксации всех транзакций. Табличный файл можно использовать только с этой информацией. Конечно, также невозможно восстановить только таблицу и связанные с &lt;code&gt;pg_xact&lt;/code&gt; данные pg_xact, потому что это сделает все другие таблицы в кластере базы данных бесполезными. Таким образом, резервное копирование файловой системы работает только для полного резервного копирования и восстановления всего кластера базы данных.</target>
        </trans-unit>
        <trans-unit id="b1fdfd0de9a85f5bba1c48c08c54c2308c8c0754" translate="yes" xml:space="preserve">
          <source>If you have not set up an external transaction manager to track prepared transactions and ensure they get closed out promptly, it is best to keep the prepared-transaction feature disabled by setting &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt; to zero. This will prevent accidental creation of prepared transactions that might then be forgotten and eventually cause problems.</source>
          <target state="translated">Если вы не настроили внешний менеджер транзакций для отслеживания подготовленных транзакций и обеспечения их быстрого закрытия, лучше всего оставить функцию подготовленной транзакции отключенной, установив для &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt; значение нуля. Это предотвратит случайное создание подготовленных транзакций, которые затем могут быть забыты и в конечном итоге вызвать проблемы.</target>
        </trans-unit>
        <trans-unit id="4113594099b8ceaba5516ae6559f67b321dd3f1a" translate="yes" xml:space="preserve">
          <source>If you have pattern matching needs that go beyond this, consider writing a user-defined function in Perl or Tcl.</source>
          <target state="translated">Если у вас есть потребности в совпадении с образцами,которые выходят за рамки этого,подумайте о написании пользовательской функции на Perl или Tcl.</target>
        </trans-unit>
        <trans-unit id="aedcf3e1663bdb52e36d3e2d02ae7396863fa330" translate="yes" xml:space="preserve">
          <source>If you have relocated &lt;code&gt;pg_wal&lt;/code&gt; outside the data directories, rsync must be run on those directories too.</source>
          <target state="translated">Если вы переместили &lt;code&gt;pg_wal&lt;/code&gt; за пределы каталогов данных, rsync должен быть запущен и в этих каталогах.</target>
        </trans-unit>
        <trans-unit id="66e124e77e26c68b2716b8eb55653604cd884707" translate="yes" xml:space="preserve">
          <source>If you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;, you might also want to configure your kernel to lock System V shared memory into RAM and prevent it from being paged out to swap. This can be accomplished using the &lt;code&gt;sysctl&lt;/code&gt; setting &lt;code&gt;kern.ipc.shm_use_phys&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a07426ce8ecfc80c9d7a4edfcb98cf0ba611138f" translate="yes" xml:space="preserve">
          <source>If you have tablespaces, you will need to run a similar rsync command for each tablespace directory, e.g.:</source>
          <target state="translated">Если у вас есть табличные пространства,вам нужно запустить аналогичную команду rsync для каждого каталога табличных пространств,например:</target>
        </trans-unit>
        <trans-unit id="74d92589027830b748d75a72665251c799371e5f" translate="yes" xml:space="preserve">
          <source>If you have the space to do so, copy the whole cluster data directory and any tablespaces to a temporary location in case you need them later. Note that this precaution will require that you have enough free space on your system to hold two copies of your existing database. If you do not have enough space, you should at least save the contents of the cluster's &lt;code&gt;pg_wal&lt;/code&gt; subdirectory, as it might contain logs which were not archived before the system went down.</source>
          <target state="translated">Если у вас есть для этого место, скопируйте весь каталог данных кластера и любые табличные пространства во временное место на случай, если они вам понадобятся позже. Обратите внимание, что эта мера предосторожности потребует, чтобы в вашей системе было достаточно свободного места для хранения двух копий существующей базы данных. Если у вас недостаточно места, вы должны, по крайней мере, сохранить содержимое подкаталога &lt;code&gt;pg_wal&lt;/code&gt; кластера , так как он может содержать журналы, которые не были заархивированы до отказа системы.</target>
        </trans-unit>
        <trans-unit id="c405c350a4bec28b591f01ed6531218b06904979" translate="yes" xml:space="preserve">
          <source>If you have to &amp;ldquo;hop&amp;rdquo; to the database server via some login host, one possible setup could look like this:</source>
          <target state="translated">Если вам нужно &amp;laquo;перепрыгнуть&amp;raquo; на сервер базы данных через какой-либо хост для входа в систему, одна из возможных настроек может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="e1467a82f0f1d2aed2302c816a743bd03ff5d6fe" translate="yes" xml:space="preserve">
          <source>If you have turned off &lt;a href=&quot;runtime-config-logging#GUC-UPDATE-PROCESS-TITLE&quot;&gt;update_process_title&lt;/a&gt; then the activity indicator is not updated; the process title is set only once when a new process is launched. On some platforms this saves a measurable amount of per-command overhead; on others it's insignificant.</source>
          <target state="translated">Если вы отключили &lt;a href=&quot;runtime-config-logging#GUC-UPDATE-PROCESS-TITLE&quot;&gt;update_process_title,&lt;/a&gt; то индикатор активности не обновляется; название процесса задается только один раз при запуске нового процесса. На некоторых платформах это позволяет сэкономить измеримое количество накладных расходов на команду; на других это несущественно.</target>
        </trans-unit>
        <trans-unit id="cdc8af27dd93a99e3339ed60a27d59629c7d68fb" translate="yes" xml:space="preserve">
          <source>If you have unarchived WAL segment files that you saved in step 2, copy them into &lt;code&gt;pg_wal/&lt;/code&gt;. (It is best to copy them, not move them, so you still have the unmodified files if a problem occurs and you have to start over.)</source>
          <target state="translated">Если у вас есть разархивированные файлы сегментов WAL, которые вы сохранили на шаге 2, скопируйте их в &lt;code&gt;pg_wal/&lt;/code&gt; . (Лучше скопировать их, а не перемещать, чтобы у вас остались неизмененные файлы, если возникнет проблема, и вам придется начинать заново.)</target>
        </trans-unit>
        <trans-unit id="f602421c44c7955b1682bc7b3fca54acb52d429c" translate="yes" xml:space="preserve">
          <source>If you modified &lt;code&gt;pg_hba.conf&lt;/code&gt;, restore its original settings. It might also be necessary to adjust other configuration files in the new cluster to match the old cluster, e.g. &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">Если вы изменили &lt;code&gt;pg_hba.conf&lt;/code&gt; , восстановите его исходные настройки. Также может потребоваться настроить другие файлы конфигурации в новом кластере, чтобы они соответствовали старому кластеру, например &lt;code&gt;postgresql.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbf1fa6cfeb52f4146529fb315f1682db9559aaa" translate="yes" xml:space="preserve">
          <source>If you modified &lt;code&gt;pg_hba.conf&lt;/code&gt;, restore its original settings. It might also be necessary to adjust other configuration files in the new cluster to match the old cluster, e.g., &lt;code&gt;postgresql.conf&lt;/code&gt; (and any files included by it), &lt;code&gt;postgresql.auto.conf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9316b03fae64e8c508527fbd0a6b640ef4256fda" translate="yes" xml:space="preserve">
          <source>If you modify files in &lt;code&gt;.../share/timezonesets/&lt;/code&gt;, it is up to you to make backups &amp;mdash; a normal database dump will not include this directory.</source>
          <target state="translated">Если вы изменяете файлы в &lt;code&gt;.../share/timezonesets/&lt;/code&gt; , вы должны делать резервные копии - обычный дамп базы данных не будет включать этот каталог.</target>
        </trans-unit>
        <trans-unit id="a80020f6d5771b4994b2b6087bde0a758b0dbcc3" translate="yes" xml:space="preserve">
          <source>If you need to modify a table that already exists, see &lt;a href=&quot;ddl-alter&quot;&gt;Section 5.6&lt;/a&gt; later in this chapter.</source>
          <target state="translated">Если вам нужно изменить уже существующую таблицу, см. &lt;a href=&quot;ddl-alter&quot;&gt;Раздел 5.6&lt;/a&gt; далее в этой главе.</target>
        </trans-unit>
        <trans-unit id="2efd34e960254e7fbc24d4c21228c55d47bceff1" translate="yes" xml:space="preserve">
          <source>If you need to re-create a standby server while transactions are waiting, make sure that the commands pg_start_backup() and pg_stop_backup() are run in a session with &lt;code&gt;synchronous_commit&lt;/code&gt; = &lt;code&gt;off&lt;/code&gt;, otherwise those requests will wait forever for the standby to appear.</source>
          <target state="translated">Если вам нужно воссоздать резервный сервер во время ожидания транзакций, убедитесь, что команды pg_start_backup () и pg_stop_backup () выполняются в сеансе с &lt;code&gt;synchronous_commit&lt;/code&gt; = &lt;code&gt;off&lt;/code&gt; , иначе эти запросы будут вечно ждать появления резервного.</target>
        </trans-unit>
        <trans-unit id="335eb5a28fe752ac43ab7d0bdb87c591351c3327" translate="yes" xml:space="preserve">
          <source>If you no longer need a table, you can remove it using the &lt;a href=&quot;sql-droptable&quot;&gt;DROP TABLE&lt;/a&gt; command. For example:</source>
          <target state="translated">Если вам больше не нужна таблица, вы можете удалить ее с помощью команды &lt;a href=&quot;sql-droptable&quot;&gt;DROP TABLE&lt;/a&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="4b094a7de4e477575e2b8864dd2a1871a2ac7be9" translate="yes" xml:space="preserve">
          <source>If you only need randomly-generated (version 4) UUIDs, consider using the &lt;code&gt;gen_random_uuid()&lt;/code&gt; function from the &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module instead.</source>
          <target state="translated">Если вам нужны только случайно сгенерированные (версия 4) UUID, рассмотрите возможность использования &lt;code&gt;gen_random_uuid()&lt;/code&gt; функции gen_random_uuid () из модуля &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7ec64742024abd88ac376b90c1b4516681087ea" translate="yes" xml:space="preserve">
          <source>If you really cannot keep as many synchronous standbys as requested then you should decrease the number of synchronous standbys that transaction commits must wait for responses from in &lt;code&gt;synchronous_standby_names&lt;/code&gt; (or disable it) and reload the configuration file on the primary server.</source>
          <target state="translated">Если вы действительно не можете сохранить столько синхронных резервных серверов, сколько требуется, вам следует уменьшить количество синхронных резервных серверов, которые фиксируются транзакцией, должны ждать ответов от в &lt;code&gt;synchronous_standby_names&lt;/code&gt; (или отключить его) и перезагрузить файл конфигурации на основном сервере.</target>
        </trans-unit>
        <trans-unit id="afb9b1746ef64ef43e1c6a611287b8838f8bab6f" translate="yes" xml:space="preserve">
          <source>If you really need to do something like that, you can either write a custom operator or add explicit casts to your query:</source>
          <target state="translated">Если вам действительно нужно сделать что-то подобное,вы можете либо написать пользовательский оператор,либо добавить явные касты к вашему запросу:</target>
        </trans-unit>
        <trans-unit id="4c6cec6fc682547181945340072f15c49a175a52" translate="yes" xml:space="preserve">
          <source>If you require exact storage and calculations (such as for monetary amounts), use the &lt;code&gt;numeric&lt;/code&gt; type instead.</source>
          <target state="translated">Если вам требуется точное хранение и вычисления (например, для денежных сумм), используйте вместо этого &lt;code&gt;numeric&lt;/code&gt; тип.</target>
        </trans-unit>
        <trans-unit id="dda0ebbf2c21ed8ce369ceb9f7962ccab8e8d4c2" translate="yes" xml:space="preserve">
          <source>If you see a message similar to:</source>
          <target state="translated">Если вы видите подобное сообщение:</target>
        </trans-unit>
        <trans-unit id="5944bf42cb7e9bed827543dce0bb5da3eb25aaf4" translate="yes" xml:space="preserve">
          <source>If you select the &lt;code&gt;select-only&lt;/code&gt; built-in (also &lt;code&gt;-S&lt;/code&gt;), only the &lt;code&gt;SELECT&lt;/code&gt; is issued.</source>
          <target state="translated">Если вы выбираете встроенный &lt;code&gt;select-only&lt;/code&gt; (также &lt;code&gt;-S&lt;/code&gt; ), выдается только &lt;code&gt;SELECT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c440cbb3c75274ef5533f9dc20d09bc792bb4404" translate="yes" xml:space="preserve">
          <source>If you select the &lt;code&gt;simple-update&lt;/code&gt; built-in (also &lt;code&gt;-N&lt;/code&gt;), steps 4 and 5 aren't included in the transaction. This will avoid update contention on these tables, but it makes the test case even less like TPC-B.</source>
          <target state="translated">Если вы выберете встроенное &lt;code&gt;simple-update&lt;/code&gt; (также &lt;code&gt;-N&lt;/code&gt; ), шаги 4 и 5 не будут включены в транзакцию. Это позволит избежать конфликтов при обновлении этих таблиц, но сделает тестовый пример еще менее похожим на TPC-B.</target>
        </trans-unit>
        <trans-unit id="2410e185ebe01d4bbafd07fc62d71b97897582e4" translate="yes" xml:space="preserve">
          <source>If you set a nonempty value for &lt;code&gt;log_line_prefix&lt;/code&gt;, you should usually make its last character be a space, to provide visual separation from the rest of the log line. A punctuation character can be used too.</source>
          <target state="translated">Если вы устанавливаете непустое значение для &lt;code&gt;log_line_prefix&lt;/code&gt; , вам обычно следует сделать его последним символом пробел, чтобы обеспечить визуальное разделение от остальной части строки журнала. Также можно использовать знаки препинания.</target>
        </trans-unit>
        <trans-unit id="293043269744dfe0b2be9f58f146808d29c819d1" translate="yes" xml:space="preserve">
          <source>If you simply direct the stderr of &lt;code&gt;postgres&lt;/code&gt; into a file, you will have log output, but the only way to truncate the log file is to stop and restart the server. This might be acceptable if you are using PostgreSQL in a development environment, but few production servers would find this behavior acceptable.</source>
          <target state="translated">Если вы просто направите stderr &lt;code&gt;postgres&lt;/code&gt; в файл, у вас будет вывод журнала, но единственный способ усечь файл журнала - это остановить и перезапустить сервер. Это может быть приемлемо, если вы используете PostgreSQL в среде разработки, но немногие производственные серверы сочтут такое поведение приемлемым.</target>
        </trans-unit>
        <trans-unit id="9ce920b3e4b27527a0945161fb81196b0962a822" translate="yes" xml:space="preserve">
          <source>If you simply write:</source>
          <target state="translated">Если ты просто напишешь:</target>
        </trans-unit>
        <trans-unit id="86278d59973a9bff1da8685bc91d01d4bca2172c" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;prefix&lt;/code&gt;, that string is prepended to the query's column names to create the variable names to use:</source>
          <target state="translated">Если вы указываете &lt;code&gt;prefix&lt;/code&gt; , эта строка добавляется к именам столбцов запроса, чтобы создать имена переменных для использования:</target>
        </trans-unit>
        <trans-unit id="4293f633ad719b6229d97888e7c493efba01b4c4" translate="yes" xml:space="preserve">
          <source>If you specify a file name without escapes, you should plan to use a log rotation utility to avoid eventually filling the entire disk. In releases prior to 8.4, if no &lt;code&gt;%&lt;/code&gt; escapes were present, PostgreSQL would append the epoch of the new log file's creation time, but this is no longer the case.</source>
          <target state="translated">Если вы указываете имя файла без экранирования, вам следует запланировать использование утилиты ротации журналов, чтобы в конечном итоге избежать заполнения всего диска. В выпусках до 8.4, если не было &lt;code&gt;%&lt;/code&gt; escape-последовательностей, PostgreSQL добавлял бы эпоху времени создания нового файла журнала, но это уже не так.</target>
        </trans-unit>
        <trans-unit id="cd2bed205787104a93fce03bc6421721af1bc122" translate="yes" xml:space="preserve">
          <source>If you specify columns, you probably have to escape the parentheses from the shell. (See examples below.)</source>
          <target state="translated">Если вы указываете столбцы,вам,вероятно,придется убрать скобки из оболочки.(См.примеры ниже).</target>
        </trans-unit>
        <trans-unit id="c697983f7b5aa306c7f0f7a672c31b1b3cec3536" translate="yes" xml:space="preserve">
          <source>If you suspect corruption of an index on a user table, you can simply rebuild that index, or all indexes on the table, using &lt;code&gt;REINDEX INDEX&lt;/code&gt; or &lt;code&gt;REINDEX TABLE&lt;/code&gt;.</source>
          <target state="translated">Если вы подозреваете повреждение индекса в пользовательской таблице, вы можете просто перестроить этот индекс или все индексы в таблице, используя &lt;code&gt;REINDEX INDEX&lt;/code&gt; или &lt;code&gt;REINDEX TABLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="634ba98da8d49a37a8349e78baa14c6e91b78095" translate="yes" xml:space="preserve">
          <source>If you use link mode, the upgrade will be much faster (no file copying) and use less disk space, but you will not be able to access your old cluster once you start the new cluster after the upgrade. Link mode also requires that the old and new cluster data directories be in the same file system. (Tablespaces and &lt;code&gt;pg_wal&lt;/code&gt; can be on different file systems.) Clone mode provides the same speed and disk space advantages but does not cause the old cluster to be unusable once the new cluster is started. Clone mode also requires that the old and new data directories be in the same file system. This mode is only available on certain operating systems and file systems.</source>
          <target state="translated">Если вы используете режим связывания, обновление будет намного быстрее (без копирования файлов) и будет использовать меньше дискового пространства, но вы не сможете получить доступ к своему старому кластеру после запуска нового кластера после обновления. В режиме связывания также требуется, чтобы старый и новый каталоги данных кластера находились в одной файловой системе. (Табличные пространства и &lt;code&gt;pg_wal&lt;/code&gt; могут находиться в разных файловых системах.) Режим клонирования обеспечивает те же преимущества в скорости и дисковом пространстве, но не приводит к невозможности использования старого кластера после запуска нового кластера. Режим клонирования также требует, чтобы старый и новый каталоги данных находились в одной файловой системе. Этот режим доступен только в определенных операционных системах и файловых системах.</target>
        </trans-unit>
        <trans-unit id="fe9e0a997d4a5f8ab6d05deb3608c7b48d1004eb" translate="yes" xml:space="preserve">
          <source>If you use streaming replication without file-based continuous archiving, the server might recycle old WAL segments before the standby has received them. If this occurs, the standby will need to be reinitialized from a new base backup. You can avoid this by setting &lt;code&gt;wal_keep_segments&lt;/code&gt; to a value large enough to ensure that WAL segments are not recycled too early, or by configuring a replication slot for the standby. If you set up a WAL archive that's accessible from the standby, these solutions are not required, since the standby can always use the archive to catch up provided it retains enough segments.</source>
          <target state="translated">Если вы используете потоковую репликацию без непрерывного файлового архивирования, сервер может повторно использовать старые сегменты WAL до того, как резервный сервер получит их. Если это произойдет, необходимо будет повторно инициализировать резервную копию из новой базовой резервной копии. Вы можете избежать этого, установив для &lt;code&gt;wal_keep_segments&lt;/code&gt; значение, достаточно большое, чтобы гарантировать, что сегменты WAL не будут перезапущены слишком рано, или настроив слот репликации для резервного. Если вы настроили архив WAL, доступный из резервного, эти решения не требуются, поскольку резервный всегда может использовать архив для наверстывания при условии, что он сохраняет достаточное количество сегментов.</target>
        </trans-unit>
        <trans-unit id="3198519c857584cca4870e5482467b87f1de4701" translate="yes" xml:space="preserve">
          <source>If you use streaming replication without file-based continuous archiving, the server might recycle old WAL segments before the standby has received them. If this occurs, the standby will need to be reinitialized from a new base backup. You can avoid this by setting &lt;code&gt;wal_keep_size&lt;/code&gt; to a value large enough to ensure that WAL segments are not recycled too early, or by configuring a replication slot for the standby. If you set up a WAL archive that's accessible from the standby, these solutions are not required, since the standby can always use the archive to catch up provided it retains enough segments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410c6fd96b75590acd8e3654ea56e9babc9667ce" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\o&lt;/code&gt; command to redirect your query output you might wish to use &lt;code&gt;\qecho&lt;/code&gt; instead of this command.</source>
          <target state="translated">Если вы используете команду &lt;code&gt;\o&lt;/code&gt; для перенаправления вывода вашего запроса, вы можете использовать &lt;code&gt;\qecho&lt;/code&gt; вместо этой команды.</target>
        </trans-unit>
        <trans-unit id="0373a56e2165e1341cdef2084a1dbcf9d28e7801" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\o&lt;/code&gt; command to redirect your query output you might wish to use &lt;code&gt;\qecho&lt;/code&gt; instead of this command. See also &lt;code&gt;\warn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dacf2afd67d1d9e6693b9e34a44e3f31343f07b9" translate="yes" xml:space="preserve">
          <source>If you used link mode and have Streaming Replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;) or Log-Shipping (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;) standby servers, you can follow these steps to quickly upgrade them. You will not be running pg_upgrade on the standby servers, but rather rsync on the primary. Do not start any servers yet.</source>
          <target state="translated">Если вы использовали режим связи и имеете резервные серверы Streaming Replication (см. &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Раздел 26.2.5&lt;/a&gt; ) или Log-Shipping (см. &lt;a href=&quot;warm-standby&quot;&gt;Раздел 26.2&lt;/a&gt; ), вы можете выполнить следующие действия, чтобы быстро обновить их. Вы не будете запускать pg_upgrade на резервных серверах, а скорее будете запускать rsync на основном. Пока не запускайте никакие серверы.</target>
        </trans-unit>
        <trans-unit id="46579b8a1d951df62d56dbc7236dffbdfa323aee" translate="yes" xml:space="preserve">
          <source>If you want an empty string rather than NULL, write double quotes:</source>
          <target state="translated">Если вы хотите пустую строку,а не NULL,пишите двойные кавычки:</target>
        </trans-unit>
        <trans-unit id="e23816131f85edfcf8ebf4baf1b8f5a4f82e1a1c" translate="yes" xml:space="preserve">
          <source>If you want the digest as a hexadecimal string, use &lt;code&gt;encode()&lt;/code&gt; on the result. For example:</source>
          <target state="translated">Если вы хотите получить дайджест в виде шестнадцатеричной строки, используйте &lt;code&gt;encode()&lt;/code&gt; для результата. Например:</target>
        </trans-unit>
        <trans-unit id="c7212923c1936242a3a328b31eba624a84bab3c5" translate="yes" xml:space="preserve">
          <source>If you want the system to behave as if it had no locale support, use the special locale name &lt;code&gt;C&lt;/code&gt;, or equivalently &lt;code&gt;POSIX&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите, чтобы система вела себя так, как если бы она не поддерживала языковой стандарт, используйте специальное имя языкового стандарта &lt;code&gt;C&lt;/code&gt; или эквивалентно &lt;code&gt;POSIX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f51609486b727fbe8393280c5551d1122917313" translate="yes" xml:space="preserve">
          <source>If you want to add a new method of making the data representation smaller, you must implement it in &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; and also teach &lt;code&gt;Catalog::ParseData()&lt;/code&gt; how to expand the data back into the full representation.</source>
          <target state="translated">Если вы хотите добавить новый метод делает представление данных меньше, вы должны реализовать ее в &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; , а также диспут &lt;code&gt;Catalog::ParseData()&lt;/code&gt; как расширить данные обратно в полное представление.</target>
        </trans-unit>
        <trans-unit id="7f058b6974f7c4fc1a4fda33213fb953c4c820d2" translate="yes" xml:space="preserve">
          <source>If you want to do complicated calculations with these types for anything important, especially if you rely on certain behavior in boundary cases (infinity, underflow), you should evaluate the implementation carefully.</source>
          <target state="translated">Если вы хотите делать сложные вычисления с этими типами для чего-то важного,особенно если вы полагаетесь на определенное поведение в граничных случаях (бесконечность,недолив),то вы должны внимательно оценить реализацию.</target>
        </trans-unit>
        <trans-unit id="f8d0dd9f6c3474fc520b6c68678cb5772392894d" translate="yes" xml:space="preserve">
          <source>If you want to have a double quote in the output you must precede it with a backslash, for example &lt;code&gt;'\&quot;YYYY Month\&quot;'&lt;/code&gt;. Backslashes are not otherwise special outside of double-quoted strings. Within a double-quoted string, a backslash causes the next character to be taken literally, whatever it is (but this has no special effect unless the next character is a double quote or another backslash).</source>
          <target state="translated">Если вы хотите, чтобы в выводе были двойные кавычки, вы должны поставить перед ним обратную косую черту, например &lt;code&gt;'\&quot;YYYY Month\&quot;'&lt;/code&gt; . Обратные косые черты не являются чем-то особенным, кроме строк в двойных кавычках. Внутри строки, заключенной в двойные кавычки, обратная косая черта приводит к тому, что следующий символ воспринимается буквально, каким бы он ни был (но это не имеет особого эффекта, если следующий символ не является двойной кавычкой или другой обратной косой чертой).</target>
        </trans-unit>
        <trans-unit id="b08912c8afafc035000c2b91395d4762ff623ba7" translate="yes" xml:space="preserve">
          <source>If you want to recover to some previous point in time (say, right before the junior DBA dropped your main transaction table), just specify the required &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;stopping point&lt;/a&gt;. You can specify the stop point, known as the &amp;ldquo;recovery target&amp;rdquo;, either by date/time, named restore point or by completion of a specific transaction ID. As of this writing only the date/time and named restore point options are very usable, since there are no tools to help you identify with any accuracy which transaction ID to use.</source>
          <target state="translated">Если вы хотите вернуться к некоторому предыдущему моменту времени (скажем, прямо перед тем, как младший администратор базы данных сбросил вашу основную таблицу транзакций), просто укажите необходимую &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;точку остановки&lt;/a&gt; . Вы можете указать точку остановки, известную как &amp;laquo;цель восстановления&amp;raquo;, либо по дате / времени, названной точке восстановления, либо по завершению определенного идентификатора транзакции. На момент написания этой статьи можно было использовать только параметры даты / времени и именованной точки восстановления, поскольку не было инструментов, которые помогли бы с какой-либо точностью определить, какой идентификатор транзакции использовать.</target>
        </trans-unit>
        <trans-unit id="f2799eac42b252d1fdead69c5594bb2d3a2059fa" translate="yes" xml:space="preserve">
          <source>If you want to run a parallel dump of a pre-9.2 server, you need to make sure that the database content doesn't change from between the time the master connects to the database until the last worker job has connected to the database. The easiest way to do this is to halt any data modifying processes (DDL and DML) accessing the database before starting the backup. You also need to specify the &lt;code&gt;--no-synchronized-snapshots&lt;/code&gt; parameter when running &lt;code&gt;pg_dump -j&lt;/code&gt; against a pre-9.2 PostgreSQL server.</source>
          <target state="translated">Если вы хотите запустить параллельный дамп сервера до версии 9.2, вам необходимо убедиться, что содержимое базы данных не меняется с момента подключения мастера к базе данных до момента подключения последнего рабочего задания к базе данных. Самый простой способ сделать это - остановить любые процессы изменения данных (DDL и DML), обращающиеся к базе данных, перед запуском резервного копирования. Вам также необходимо указать параметр &lt;code&gt;--no-synchronized-snapshots&lt;/code&gt; при запуске &lt;code&gt;pg_dump -j&lt;/code&gt; для сервера PostgreSQL до версии 9.2.</target>
        </trans-unit>
        <trans-unit id="1235d6c60bdf10ad9cf9d8bf29ece023d11255aa" translate="yes" xml:space="preserve">
          <source>If you want to see the lines on the screen as they are read you must set the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите видеть строки на экране по мере их чтения, вы должны установить для переменной &lt;code&gt;ECHO&lt;/code&gt; значение &lt;code&gt;all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d777fa853e95af192514bf1aeb804e6308b39ad2" translate="yes" xml:space="preserve">
          <source>If you want to use link mode and you do not want your old cluster to be modified when the new cluster is started, consider using the clone mode. If that is not available, make a copy of the old cluster and upgrade that in link mode. To make a valid copy of the old cluster, use &lt;code&gt;rsync&lt;/code&gt; to create a dirty copy of the old cluster while the server is running, then shut down the old server and run &lt;code&gt;rsync --checksum&lt;/code&gt; again to update the copy with any changes to make it consistent. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) You might want to exclude some files, e.g. &lt;code&gt;postmaster.pid&lt;/code&gt;, as documented in &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;. If your file system supports file system snapshots or copy-on-write file copies, you can use that to make a backup of the old cluster and tablespaces, though the snapshot and copies must be created simultaneously or while the database server is down.</source>
          <target state="translated">Если вы хотите использовать режим связи и не хотите, чтобы ваш старый кластер изменялся при запуске нового кластера, рассмотрите возможность использования режима клонирования. Если это недоступно, сделайте копию старого кластера и обновите его в режиме связи. Чтобы сделать действительную копию старого кластера, используйте &lt;code&gt;rsync&lt;/code&gt; для создания грязной копии старого кластера во время работы сервера, затем выключите старый сервер и снова запустите &lt;code&gt;rsync --checksum&lt;/code&gt; , чтобы обновить копию любыми изменениями, чтобы сделать ее последовательный. ( &lt;code&gt;--checksum&lt;/code&gt; необходим, потому что &lt;code&gt;rsync&lt;/code&gt; имеет гранулярность времени изменения файла только в одну секунду.) Вы можете исключить некоторые файлы, например &lt;code&gt;postmaster.pid&lt;/code&gt; , как &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;описано&lt;/a&gt; в Разделе 25.3.3.. Если ваша файловая система поддерживает моментальные снимки файловой системы или копии файлов с функцией копирования при записи, вы можете использовать это для создания резервной копии старого кластера и табличных пространств, хотя моментальный снимок и копии должны создаваться одновременно или когда сервер базы данных не работает.</target>
        </trans-unit>
        <trans-unit id="a968160add8cfcbfd7bfae07842aa9c1a4f8617c" translate="yes" xml:space="preserve">
          <source>If you want to use link mode and you do not want your old cluster to be modified when the new cluster is started, consider using the clone mode. If that is not available, make a copy of the old cluster and upgrade that in link mode. To make a valid copy of the old cluster, use &lt;code&gt;rsync&lt;/code&gt; to create a dirty copy of the old cluster while the server is running, then shut down the old server and run &lt;code&gt;rsync --checksum&lt;/code&gt; again to update the copy with any changes to make it consistent. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) You might want to exclude some files, e.g., &lt;code&gt;postmaster.pid&lt;/code&gt;, as documented in &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;. If your file system supports file system snapshots or copy-on-write file copies, you can use that to make a backup of the old cluster and tablespaces, though the snapshot and copies must be created simultaneously or while the database server is down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548498a07974c2669fa7d265bb5ed01fd29f2726" translate="yes" xml:space="preserve">
          <source>If you want to use psql to connect to several servers of different major versions, it is recommended that you use the newest version of psql. Alternatively, you can keep around a copy of psql from each major version and be sure to use the version that matches the respective server. But in practice, this additional complication should not be necessary.</source>
          <target state="translated">Если вы хотите использовать psql для подключения к нескольким серверам разных мажорных версий,рекомендуется использовать последнюю версию psql.Кроме того,вы можете хранить копию psql каждой мажорной версии и обязательно использовать ту версию,которая совпадает с соответствующим сервером.Но на практике в этом дополнительном осложнении нет необходимости.</target>
        </trans-unit>
        <trans-unit id="c83197bfbed6d42e302edf49770400c3bb7ffc90" translate="yes" xml:space="preserve">
          <source>If you want to use streaming replication, fill in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; with a libpq connection string, including the host name (or IP address) and any additional details needed to connect to the primary server. If the primary needs a password for authentication, the password needs to be specified in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; as well.</source>
          <target state="translated">Если вы хотите использовать потоковую репликацию, заполните &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; строкой подключения libpq, включая имя хоста (или IP-адрес) и любые дополнительные сведения, необходимые для подключения к основному серверу. Если первичному серверу требуется пароль для аутентификации, его также необходимо указать в &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8304e11449eef667491dd46bf0e842007ab0620d" translate="yes" xml:space="preserve">
          <source>If you want to use streaming replication, set up authentication on the primary server to allow replication connections from the standby server(s); that is, create a role and provide a suitable entry or entries in &lt;code&gt;pg_hba.conf&lt;/code&gt; with the database field set to &lt;code&gt;replication&lt;/code&gt;. Also ensure &lt;code&gt;max_wal_senders&lt;/code&gt; is set to a sufficiently large value in the configuration file of the primary server. If replication slots will be used, ensure that &lt;code&gt;max_replication_slots&lt;/code&gt; is set sufficiently high as well.</source>
          <target state="translated">Если вы хотите использовать потоковую репликацию, настройте аутентификацию на первичном сервере, чтобы разрешить репликационные соединения с резервного сервера (ов); то есть создать роль и предоставить подходящую запись или записи в &lt;code&gt;pg_hba.conf&lt;/code&gt; с полем базы данных, установленным для &lt;code&gt;replication&lt;/code&gt; . Также убедитесь, что &lt;code&gt;max_wal_senders&lt;/code&gt; имеет достаточно большое значение в файле конфигурации первичного сервера. Если будут использоваться слоты репликации, убедитесь, что &lt;code&gt;max_replication_slots&lt;/code&gt; также установлен достаточно высоким.</target>
        </trans-unit>
        <trans-unit id="d505643f0e154d892e49d0ce311315a8a63b86fd" translate="yes" xml:space="preserve">
          <source>If you wish to create a new superuser, you must connect as a superuser, not merely with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege. Being a superuser implies the ability to bypass all access permission checks within the database, so superuserdom should not be granted lightly.</source>
          <target state="translated">Если вы хотите создать нового суперпользователя, вы должны подключиться как суперпользователь, а не просто с привилегией &lt;code&gt;CREATEROLE&lt;/code&gt; . Статус суперпользователя предполагает возможность обхода всех проверок прав доступа в базе данных, поэтому права суперпользователя не следует предоставлять легкомысленно.</target>
        </trans-unit>
        <trans-unit id="dba6f63305bb053e32c8873d900ab4a929146d0b" translate="yes" xml:space="preserve">
          <source>If you wish to drop a role for which the default privileges have been altered, it is necessary to reverse the changes in its default privileges or use &lt;code&gt;DROP OWNED BY&lt;/code&gt; to get rid of the default privileges entry for the role.</source>
          <target state="translated">Если вы хотите удалить роль, для которой были изменены привилегии по умолчанию, необходимо отменить изменения в ее привилегиях по умолчанию или использовать &lt;code&gt;DROP OWNED BY&lt;/code&gt; , чтобы избавиться от записи о привилегиях по умолчанию для роли.</target>
        </trans-unit>
        <trans-unit id="fe513e6fe150eda65f8a240b4c5ab71cf30d3ea3" translate="yes" xml:space="preserve">
          <source>If you wish to keep the configuration files elsewhere than the data directory, the &lt;code&gt;postgres&lt;/code&gt;&lt;code&gt;-D&lt;/code&gt; command-line option or &lt;code&gt;PGDATA&lt;/code&gt; environment variable must point to the directory containing the configuration files, and the &lt;code&gt;data_directory&lt;/code&gt; parameter must be set in &lt;code&gt;postgresql.conf&lt;/code&gt; (or on the command line) to show where the data directory is actually located. Notice that &lt;code&gt;data_directory&lt;/code&gt; overrides &lt;code&gt;-D&lt;/code&gt; and &lt;code&gt;PGDATA&lt;/code&gt; for the location of the data directory, but not for the location of the configuration files.</source>
          <target state="translated">Если вы хотите сохранить файлы конфигурации в другом месте, кроме каталога данных, параметр командной строки &lt;code&gt;postgres&lt;/code&gt; &lt;code&gt;-D&lt;/code&gt; или переменная среды &lt;code&gt;PGDATA&lt;/code&gt; должны указывать на каталог, содержащий файлы конфигурации, а параметр &lt;code&gt;data_directory&lt;/code&gt; должен быть установлен в &lt;code&gt;postgresql.conf&lt;/code&gt; (или на в командной строке), чтобы показать, где на самом деле находится каталог данных. Обратите внимание, что &lt;code&gt;data_directory&lt;/code&gt; переопределяет &lt;code&gt;-D&lt;/code&gt; и &lt;code&gt;PGDATA&lt;/code&gt; для расположения каталога данных, но не для расположения файлов конфигурации.</target>
        </trans-unit>
        <trans-unit id="5e43ef9c20e530883e37f2ea188b5ba2ab7b89db" translate="yes" xml:space="preserve">
          <source>If you wish, you can specify the configuration file names and locations individually using the parameters &lt;code&gt;config_file&lt;/code&gt;, &lt;code&gt;hba_file&lt;/code&gt; and/or &lt;code&gt;ident_file&lt;/code&gt;. &lt;code&gt;config_file&lt;/code&gt; can only be specified on the &lt;code&gt;postgres&lt;/code&gt; command line, but the others can be set within the main configuration file. If all three parameters plus &lt;code&gt;data_directory&lt;/code&gt; are explicitly set, then it is not necessary to specify &lt;code&gt;-D&lt;/code&gt; or &lt;code&gt;PGDATA&lt;/code&gt;.</source>
          <target state="translated">При желании вы можете указать имена и расположение файлов конфигурации индивидуально, используя параметры &lt;code&gt;config_file&lt;/code&gt; , &lt;code&gt;hba_file&lt;/code&gt; и / или &lt;code&gt;ident_file&lt;/code&gt; . &lt;code&gt;config_file&lt;/code&gt; можно указать только в командной строке &lt;code&gt;postgres&lt;/code&gt; , а остальные можно задать в основном файле конфигурации. Если все три параметра плюс &lt;code&gt;data_directory&lt;/code&gt; явно, то указывать &lt;code&gt;-D&lt;/code&gt; или &lt;code&gt;PGDATA&lt;/code&gt; необязательно .</target>
        </trans-unit>
        <trans-unit id="32daceaa2cf366c2fe6d0715c4458443ee88a963" translate="yes" xml:space="preserve">
          <source>If you're setting up the standby server for high availability purposes, set up WAL archiving, connections and authentication like the primary server, because the standby server will work as a primary server after failover.</source>
          <target state="translated">Если вы настраиваете резервный сервер в целях высокой доступности,настройте WAL архивирование,соединения и аутентификацию,как и основной сервер,потому что резервный сервер будет работать в качестве основного после обхода отказа.</target>
        </trans-unit>
        <trans-unit id="c5ac9027a677c31c54f143f0fe38940b45904e3a" translate="yes" xml:space="preserve">
          <source>If you're using a WAL archive, its size can be minimized using the &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt; parameter to remove files that are no longer required by the standby server. The pg_archivecleanup utility is designed specifically to be used with &lt;code&gt;archive_cleanup_command&lt;/code&gt; in typical single-standby configurations, see &lt;a href=&quot;pgarchivecleanup&quot;&gt;pg_archivecleanup&lt;/a&gt;. Note however, that if you're using the archive for backup purposes, you need to retain files needed to recover from at least the latest base backup, even if they're no longer needed by the standby.</source>
          <target state="translated">Если вы используете архив WAL, его размер можно минимизировать с &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;помощью&lt;/a&gt; параметра archive_cleanup_command, чтобы удалить файлы, которые больше не требуются резервному серверу. Утилита pg_archivecleanup разработана специально для использования с &lt;code&gt;archive_cleanup_command&lt;/code&gt; в типичных конфигурациях с одним резервным, см. &lt;a href=&quot;pgarchivecleanup&quot;&gt;Pg_archivecleanup&lt;/a&gt; . Однако обратите внимание, что если вы используете архив для резервного копирования, вам необходимо сохранить файлы, необходимые для восстановления, по крайней мере, из последней базовой резервной копии, даже если они больше не нужны резервному серверу.</target>
        </trans-unit>
        <trans-unit id="eede8f4eab7ac7c7f42522f0f50f00f83f33b103" translate="yes" xml:space="preserve">
          <source>If your application needs to use other forms of partitioning not listed above, alternative methods such as inheritance and &lt;code&gt;UNION ALL&lt;/code&gt; views can be used instead. Such methods offer flexibility but do not have some of the performance benefits of built-in declarative partitioning.</source>
          <target state="translated">Если вашему приложению необходимо использовать другие формы разделения, не перечисленные выше, вместо них можно использовать альтернативные методы, такие как наследование и представления &lt;code&gt;UNION ALL&lt;/code&gt; . Такие методы предлагают гибкость, но не имеют некоторых преимуществ производительности встроенного декларативного секционирования.</target>
        </trans-unit>
        <trans-unit id="693883e4d7e5062d3b1b4e420d1dcd21d56fe252" translate="yes" xml:space="preserve">
          <source>If your database cluster has any local additions to the &lt;code&gt;template1&lt;/code&gt; database, be careful to restore the output of pg_dump into a truly empty database; otherwise you are likely to get errors due to duplicate definitions of the added objects. To make an empty database without any local additions, copy from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, for example:</source>
          <target state="translated">Если в вашем кластере базы данных есть какие-либо локальные дополнения к базе данных &lt;code&gt;template1&lt;/code&gt; , будьте осторожны, чтобы восстановить вывод pg_dump в действительно пустую базу данных; в противном случае вы, вероятно, получите ошибки из-за повторяющихся определений добавленных объектов. Чтобы создать пустую базу данных без каких-либо локальных дополнений, скопируйте из &lt;code&gt;template0&lt;/code&gt; ,а не из &lt;code&gt;template1&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="bfe8c7a1e0073145cfd43127c90a639a57c975f4" translate="yes" xml:space="preserve">
          <source>If your database is spread across multiple file systems, there might not be any way to obtain exactly-simultaneous frozen snapshots of all the volumes. For example, if your data files and WAL log are on different disks, or if tablespaces are on different file systems, it might not be possible to use snapshot backup because the snapshots &lt;em&gt;must&lt;/em&gt; be simultaneous. Read your file system documentation very carefully before trusting the consistent-snapshot technique in such situations.</source>
          <target state="translated">Если ваша база данных распределена по нескольким файловым системам, возможно, не существует способа получить точно одновременные замороженные снимки всех томов. Например, если ваши файлы данных и журнал WAL находятся на разных дисках или если табличные пространства находятся в разных файловых системах, может оказаться невозможным использовать резервное копирование моментальных снимков, так как моментальные снимки &lt;em&gt;должны&lt;/em&gt; быть одновременными. Внимательно прочтите документацию по файловой системе, прежде чем в таких ситуациях доверять методу согласованного снимка.</target>
        </trans-unit>
        <trans-unit id="89affde528d7a785d4590b760f08553f5fba2e5e" translate="yes" xml:space="preserve">
          <source>If your installation directory is not version-specific, e.g. &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, it is necessary to move the current PostgreSQL install directory so it does not interfere with the new PostgreSQL installation. Once the current PostgreSQL server is shut down, it is safe to rename the PostgreSQL installation directory; assuming the old directory is &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, you can do:</source>
          <target state="translated">Если ваш установочный каталог не зависит от версии, например &lt;code&gt;/usr/local/pgsql&lt;/code&gt; , необходимо переместить текущий установочный каталог PostgreSQL, чтобы он не мешал новой установке PostgreSQL. После выключения текущего сервера PostgreSQL можно безопасно переименовать установочный каталог PostgreSQL; предполагая, что старый каталог &lt;code&gt;/usr/local/pgsql&lt;/code&gt; , вы можете сделать:</target>
        </trans-unit>
        <trans-unit id="b225941ba48c705a72d951ae004bd3007fba63eb" translate="yes" xml:space="preserve">
          <source>If your installation directory is not version-specific, e.g., &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, it is necessary to move the current PostgreSQL install directory so it does not interfere with the new PostgreSQL installation. Once the current PostgreSQL server is shut down, it is safe to rename the PostgreSQL installation directory; assuming the old directory is &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, you can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd01544b621df2f2698aa331ec7e1d502c246c7e" translate="yes" xml:space="preserve">
          <source>If your installation has any local additions to the &lt;code&gt;template1&lt;/code&gt; database, be careful to load the output of pg_restore into a truly empty database; otherwise you are likely to get errors due to duplicate definitions of the added objects. To make an empty database without any local additions, copy from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, for example:</source>
          <target state="translated">Если в вашей установке есть какие-либо локальные дополнения к базе данных &lt;code&gt;template1&lt;/code&gt; , будьте осторожны, чтобы загрузить вывод pg_restore в действительно пустую базу данных; в противном случае вы, вероятно, получите ошибки из-за повторяющихся определений добавленных объектов. Чтобы создать пустую базу данных без каких-либо локальных дополнений, скопируйте из &lt;code&gt;template0&lt;/code&gt; ,а не из &lt;code&gt;template1&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="fb5ad20ebf8b8594ba828c2e14073cc42a290699" translate="yes" xml:space="preserve">
          <source>If your needs go beyond the capabilities of these conditional expressions, you might want to consider writing a server-side function in a more expressive programming language.</source>
          <target state="translated">Если ваши потребности выходят за рамки возможностей этих условных выражений,вы можете подумать о написании серверной функции на более выразительном языке программирования.</target>
        </trans-unit>
        <trans-unit id="092f5bf3a3fbeb060b8f061dfe4479d40fe497ca" translate="yes" xml:space="preserve">
          <source>If your site administrator has not set things up in the default way, you might have some more work to do. For example, if the database server machine is a remote machine, you will need to set the &lt;code&gt;PGHOST&lt;/code&gt; environment variable to the name of the database server machine. The environment variable &lt;code&gt;PGPORT&lt;/code&gt; might also have to be set. The bottom line is this: if you try to start an application program and it complains that it cannot connect to the database, you should consult your site administrator or, if that is you, the documentation to make sure that your environment is properly set up. If you did not understand the preceding paragraph then read the next section.</source>
          <target state="translated">Если администратор вашего сайта не настроил все по умолчанию, вам, возможно, придется поработать. Например, если машина сервера базы данных является удаленной машиной, вам нужно будет установить в переменной среды &lt;code&gt;PGHOST&lt;/code&gt; имя машины сервера базы данных. Также может потребоваться установить переменную среды &lt;code&gt;PGPORT&lt;/code&gt; . Суть в следующем: если вы пытаетесь запустить прикладную программу, и она жалуется, что не может подключиться к базе данных, вам следует проконсультироваться с администратором сайта или, если это вы, с документацией, чтобы убедиться, что ваша среда правильно настроена. . Если вы не поняли предыдущий абзац, прочтите следующий.</target>
        </trans-unit>
        <trans-unit id="0e26c0628db89c4d17246b09878aa1c2d36a0d98" translate="yes" xml:space="preserve">
          <source>If your system supports per-user disk quotas, then the database will naturally be subject to whatever quota is placed on the user the server runs as. Exceeding the quota will have the same bad effects as running out of disk space entirely.</source>
          <target state="translated">Если ваша система поддерживает дисковые квоты для каждого пользователя,то база данных,естественно,будет подчиняться любой квоте,установленной для пользователя,от имени которого работает сервер.Превышение квоты будет иметь такие же плохие последствия,как и полное исчерпание дискового пространства.</target>
        </trans-unit>
        <trans-unit id="e7e317a782d39f676e51dc31fbaf9497cd40b79f" translate="yes" xml:space="preserve">
          <source>If your table is large enough that a single index really is a bad idea, you should look into using partitioning instead (see &lt;a href=&quot;ddl-partitioning&quot;&gt;Section 5.11&lt;/a&gt;). With that mechanism, the system does understand that the tables and indexes are non-overlapping, so far better performance is possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db517070c58b7073cbfea804db0649d1169a5342" translate="yes" xml:space="preserve">
          <source>If, after running &lt;code&gt;pg_upgrade&lt;/code&gt;, you wish to revert to the old cluster, there are several options:</source>
          <target state="translated">Если после запуска &lt;code&gt;pg_upgrade&lt;/code&gt; вы захотите вернуться к старому кластеру, есть несколько вариантов:</target>
        </trans-unit>
        <trans-unit id="1101febd9e8e65c65ae1f196aecd9bf8175188c4" translate="yes" xml:space="preserve">
          <source>If, partway through the transaction, we decide we do not want to commit (perhaps we just noticed that Alice's balance went negative), we can issue the command &lt;code&gt;ROLLBACK&lt;/code&gt; instead of &lt;code&gt;COMMIT&lt;/code&gt;, and all our updates so far will be canceled.</source>
          <target state="translated">Если в ходе транзакции мы решаем, что не хотим фиксировать (возможно, мы только что заметили, что баланс Алисы стал отрицательным), мы можем выполнить команду &lt;code&gt;ROLLBACK&lt;/code&gt; вместо &lt;code&gt;COMMIT&lt;/code&gt; , и все наши обновления на данный момент будут отменены.</target>
        </trans-unit>
        <trans-unit id="f5024d286e4914e76d806049ed9ed5a9adde6b60" translate="yes" xml:space="preserve">
          <source>Ignore system indexes when reading system tables (but still update the indexes when modifying the tables). This is useful when recovering from damaged system indexes. This parameter cannot be changed after session start.</source>
          <target state="translated">Игнорировать системные индексы при чтении системных таблиц (но при этом обновлять индексы при модификации таблиц).Это полезно при восстановлении после повреждения системных индексов.Этот параметр не может быть изменен после начала сеанса.</target>
        </trans-unit>
        <trans-unit id="71db18d1300170d2010c351c48755c19862c8762" translate="yes" xml:space="preserve">
          <source>Ignore system indexes when reading system tables, but still update the indexes when modifying the tables. This is useful when recovering from damaged system indexes.</source>
          <target state="translated">Игнорируйте системные индексы при чтении системных таблиц,но все равно обновляйте индексы при модификации таблиц.Это полезно при восстановлении после повреждения системных индексов.</target>
        </trans-unit>
        <trans-unit id="e6a48d212210667b487bb3381daba46c6747f8cd" translate="yes" xml:space="preserve">
          <source>Ignore the specified file or directory, which should be expressed as a relative path name, when comparing the list of data files actually present in the backup to those listed in the &lt;code&gt;backup_manifest&lt;/code&gt; file. If a directory is specified, this option affects the entire subtree rooted at that location. Complaints about extra files, missing files, file size differences, or checksum mismatches will be suppressed if the relative path name matches the specified path name. This option can be specified multiple times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78fee1435d74666b84850cd5e82c18229351da5d" translate="yes" xml:space="preserve">
          <source>Ignored</source>
          <target state="translated">Ignored</target>
        </trans-unit>
        <trans-unit id="0bbd8cc216c54e73f7ea687a30b566c0b2c97cbb" translate="yes" xml:space="preserve">
          <source>Ignored for compatibility. Use of these keywords is deprecated; refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">Игнорируется для совместимости. Использование этих ключевых слов не рекомендуется; см. &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="b3a3e33cda0750b99611590eb50e57574fe1fbbc" translate="yes" xml:space="preserve">
          <source>Ignored for conformance with the SQL standard.</source>
          <target state="translated">Игнорируется за соответствие стандарту SQL.</target>
        </trans-unit>
        <trans-unit id="007d15b16f1f1a7b26e745777a0d9b8f646f2090" translate="yes" xml:space="preserve">
          <source>Illustrations of how these different formats look can be seen in &lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;Examples&lt;/a&gt;, below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61522d42e0f29a20214f69c85ea7d7e480669670" translate="yes" xml:space="preserve">
          <source>Illustrations of how these different formats look can be seen in the &lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;Examples&lt;/a&gt; section.</source>
          <target state="translated">Иллюстрации того, как выглядят эти разные форматы, можно увидеть в разделе &amp;laquo; &lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;Примеры&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ce170f0162eadf29cca12cc3cb0e2275dc4e6504" translate="yes" xml:space="preserve">
          <source>Image equality is &lt;em&gt;almost&lt;/em&gt; the same condition as simple bitwise equality. There is one subtle difference: When indexing a varlena data type, the on-disk representation of two image equal datums may not be bitwise equal due to inconsistent application of TOAST compression on input. Formally, when an operator class's &lt;code&gt;equalimage&lt;/code&gt; function returns &lt;code&gt;true&lt;/code&gt;, it is safe to assume that the &lt;code&gt;datum_image_eq()&lt;/code&gt; C function will always agree with the operator class's &lt;code&gt;order&lt;/code&gt; function (provided that the same collation OID is passed to both the &lt;code&gt;equalimage&lt;/code&gt; and &lt;code&gt;order&lt;/code&gt; functions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf50e138c7fa8f736f41cea1cb795eaf265d80f2" translate="yes" xml:space="preserve">
          <source>Immediately after connecting as role &lt;code&gt;joe&lt;/code&gt;, a database session will have use of privileges granted directly to &lt;code&gt;joe&lt;/code&gt; plus any privileges granted to &lt;code&gt;admin&lt;/code&gt;, because &lt;code&gt;joe&lt;/code&gt;&amp;ldquo;inherits&amp;rdquo;&lt;code&gt;admin&lt;/code&gt;'s privileges. However, privileges granted to &lt;code&gt;wheel&lt;/code&gt; are not available, because even though &lt;code&gt;joe&lt;/code&gt; is indirectly a member of &lt;code&gt;wheel&lt;/code&gt;, the membership is via &lt;code&gt;admin&lt;/code&gt; which has the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute. After:</source>
          <target state="translated">Сразу после подключения в качестве роли &lt;code&gt;joe&lt;/code&gt; , сеанс базы данных будет использовать привилегии, предоставленные непосредственно &lt;code&gt;joe&lt;/code&gt; , а также любые привилегии, предоставленные &lt;code&gt;admin&lt;/code&gt; , потому что &lt;code&gt;joe&lt;/code&gt; &amp;laquo;наследует&amp;raquo; привилегии &lt;code&gt;admin&lt;/code&gt; . Однако привилегии, предоставленные &lt;code&gt;wheel&lt;/code&gt; , недоступны, потому что, хотя &lt;code&gt;joe&lt;/code&gt; косвенно является членом &lt;code&gt;wheel&lt;/code&gt; , членство осуществляется через &lt;code&gt;admin&lt;/code&gt; который имеет атрибут &lt;code&gt;NOINHERIT&lt;/code&gt; . После:</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="23167d1539b634954643857fda589f9a1f99fc34" translate="yes" xml:space="preserve">
          <source>Implementation language or call interface of this function</source>
          <target state="translated">Язык реализации или интерфейс вызова этой функции</target>
        </trans-unit>
        <trans-unit id="41f7b8a75bd6e29a246db5c9ce4b0884fc5122fa" translate="yes" xml:space="preserve">
          <source>Implementation: B-Tree Structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd8f1da2c7641aff5a1e24cb79dcae5ba805a8b" translate="yes" xml:space="preserve">
          <source>Implementation: Deduplication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="261a75d84276a41b101b0b0b2ac4d845072c8241" translate="yes" xml:space="preserve">
          <source>Implicit conversions should never have surprising or unpredictable outcomes.</source>
          <target state="translated">Неявные преобразования никогда не должны иметь неожиданных или непредсказуемых результатов.</target>
        </trans-unit>
        <trans-unit id="4a78c79f95926318ef6fec9862a700583e71fbd0" translate="yes" xml:space="preserve">
          <source>Implicit unit of the parameter</source>
          <target state="translated">Неявная единица параметра</target>
        </trans-unit>
        <trans-unit id="60fa0aba1042461c4c2f1fe75e803d3f36549dc2" translate="yes" xml:space="preserve">
          <source>Import only foreign tables matching one of the given table names. Other tables existing in the foreign schema will be ignored.</source>
          <target state="translated">Импортируйте только иностранные таблицы,соответствующие одному из названий таблиц.Другие таблицы,существующие в зарубежной схеме,будут проигнорированы.</target>
        </trans-unit>
        <trans-unit id="2775c7ad42c3e8d71ae7e18124278fff473728e1" translate="yes" xml:space="preserve">
          <source>Import operating system collations</source>
          <target state="translated">Импорт корреляций операционной системы</target>
        </trans-unit>
        <trans-unit id="bd09d7d5cbde0f6a55b8befe57d5d6baee4d6f2b" translate="yes" xml:space="preserve">
          <source>Import table definitions from a remote schema &lt;code&gt;foreign_films&lt;/code&gt; on server &lt;code&gt;film_server&lt;/code&gt;, creating the foreign tables in local schema &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">Импортируйте определения таблиц из удаленной схемы &lt;code&gt;foreign_films&lt;/code&gt; на сервере &lt;code&gt;film_server&lt;/code&gt; , создавая внешние таблицы в &lt;code&gt;films&lt;/code&gt; локальной схемы :</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="40baa6b48d8c1dc060a4acaef47611a694c99ef3" translate="yes" xml:space="preserve">
          <source>Importing behavior can be customized with the following options (given in the &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; command):</source>
          <target state="translated">Поведение при импорте можно настроить с помощью следующих параметров (заданных в команде &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="6cdac824d2a40a7779c6dcbb8d843dee4847ebb5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;Table F.26&lt;/a&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;delta&lt;/code&gt; denote floating-point numbers. &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, but not &lt;code&gt;delta&lt;/code&gt;, can be preceded by a certainty indicator.</source>
          <target state="translated">В &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;таблице F.26&lt;/a&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , и &lt;code&gt;delta&lt;/code&gt; обозначают числа с плавающей точкой. &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , но не &lt;code&gt;delta&lt;/code&gt; , может предшествовать индикатор уверенности.</target>
        </trans-unit>
        <trans-unit id="42729a410f5a9327e00095fef5d98f4dbb7419a2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;Table C.1&lt;/a&gt; in the column for PostgreSQL we classify as &amp;ldquo;non-reserved&amp;rdquo; those key words that are explicitly known to the parser but are allowed as column or table names. Some key words that are otherwise non-reserved cannot be used as function or data type names and are marked accordingly. (Most of these words represent built-in functions or data types with special syntax. The function or type is still available but it cannot be redefined by the user.) Labeled &amp;ldquo;reserved&amp;rdquo; are those tokens that are not allowed as column or table names. Some reserved key words are allowable as names for functions or data types; this is also shown in the table. If not so marked, a reserved key word is only allowed as an &amp;ldquo;AS&amp;rdquo; column label name.</source>
          <target state="translated">В &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;таблице C.1&lt;/a&gt; в столбце для PostgreSQL мы классифицируем как &amp;laquo;незарезервированные&amp;raquo; ключевые слова, которые явно известны синтаксическому анализатору, но разрешены как имена столбцов или таблиц. Некоторые ключевые слова, которые иначе не зарезервированы, не могут использоваться в качестве имен функций или типов данных и отмечены соответствующим образом. (Большинство этих слов представляют встроенные функции или типы данных со специальным синтаксисом. Функция или тип все еще доступны, но не могут быть переопределены пользователем.) Помеченные как &amp;laquo;зарезервированные&amp;raquo; - это те токены, которые не допускаются в качестве имен столбцов или таблиц. . Некоторые зарезервированные ключевые слова допустимы в качестве имен для функций или типов данных; это также показано в таблице. Если это не отмечено, зарезервированное ключевое слово разрешено только как имя метки столбца &amp;laquo;AS&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="5fee127e33ba4c6342d0b89b7e063498409c73cb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, automatically stop replication and exit with normal exit status 0 when receiving reaches the specified LSN. If specified when not in &lt;code&gt;--start&lt;/code&gt; mode, an error is raised.</source>
          <target state="translated">В режиме &lt;code&gt;--start&lt;/code&gt; автоматическая остановка репликации и выход с нормальным статусом выхода 0, когда прием достигает указанного LSN. Если он указан не в режиме &lt;code&gt;--start&lt;/code&gt; , возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="3bfcd6bf2f68dc3b43c9cf872d41f5d653495d00" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, start replication from the given LSN. For details on the effect of this, see the documentation in &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;. Ignored in other modes.</source>
          <target state="translated">В режиме &lt;code&gt;--start&lt;/code&gt; запустить репликацию с заданного LSN. Подробнее о последствиях этого см. Документацию в &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Глава 48&lt;/a&gt; и &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Раздел 52.4&lt;/a&gt; . Игнорируется в других режимах.</target>
        </trans-unit>
        <trans-unit id="0f9c2a488b212b2dfc605f566bbd946f2f95b3b7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, start replication from the given LSN. For details on the effect of this, see the documentation in &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;. Ignored in other modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12bbea7ca03f59c395276fdbf0ca262376507500" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, use the existing logical replication slot named &lt;code&gt;slot_name&lt;/code&gt;. In &lt;code&gt;--create-slot&lt;/code&gt; mode, create the slot with this name. In &lt;code&gt;--drop-slot&lt;/code&gt; mode, delete the slot with this name.</source>
          <target state="translated">В режиме &lt;code&gt;--start&lt;/code&gt; используйте существующий слот логической репликации с именем &lt;code&gt;slot_name&lt;/code&gt; . В режиме &lt;code&gt;--create-slot&lt;/code&gt; создайте слот с этим именем. В режиме &lt;code&gt;--drop-slot&lt;/code&gt; удалите слот с этим именем.</target>
        </trans-unit>
        <trans-unit id="18d7da29e783f36fa5dffa6644b2287183a78875" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;CSV&lt;/code&gt; format, all characters are significant. A quoted value surrounded by white space, or any characters other than &lt;code&gt;DELIMITER&lt;/code&gt;, will include those characters. This can cause errors if you import data from a system that pads &lt;code&gt;CSV&lt;/code&gt; lines with white space out to some fixed width. If such a situation arises you might need to preprocess the &lt;code&gt;CSV&lt;/code&gt; file to remove the trailing white space, before importing the data into PostgreSQL.</source>
          <target state="translated">В &lt;code&gt;CSV&lt;/code&gt; все символы значимы. Цитируемое значение, окруженное пробелом, или любые символы, кроме &lt;code&gt;DELIMITER&lt;/code&gt; , будут включать эти символы. Это может вызвать ошибки, если вы импортируете данные из системы, которая &lt;code&gt;CSV&lt;/code&gt; строки CSV пробелами до некоторой фиксированной ширины. Если возникает такая ситуация, вам может потребоваться предварительная обработка &lt;code&gt;CSV&lt;/code&gt; - файла для удаления конечного пробела перед импортом данных в PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="0153f75e36e8f0039d3aa08af5bcc40422e9783b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;FROM&lt;/code&gt; items, both the standard and PostgreSQL allow &lt;code&gt;AS&lt;/code&gt; to be omitted before an alias that is an unreserved keyword. But this is impractical for output column names, because of syntactic ambiguities.</source>
          <target state="translated">В элементах &lt;code&gt;FROM&lt;/code&gt; и стандартный, и PostgreSQL позволяют опускать &lt;code&gt;AS&lt;/code&gt; перед псевдонимом, который является незарезервированным ключевым словом. Но это непрактично для имен выходных столбцов из-за синтаксической неоднозначности.</target>
        </trans-unit>
        <trans-unit id="0a49988bfaefe7a720bbc33d73d20e3ed846b39f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;GROUPS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; again must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of &lt;em&gt;peer groups&lt;/em&gt; before or after the current row's peer group, where a peer group is a set of rows that are equivalent in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering. (There must be an &lt;code&gt;ORDER BY&lt;/code&gt; clause in the window definition to use &lt;code&gt;GROUPS&lt;/code&gt; mode.)</source>
          <target state="translated">В режиме &lt;code&gt;GROUPS&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; снова должно давать ненулевое неотрицательное целое число, и опция означает, что кадр начинается или заканчивается указанное количество &lt;em&gt;одноранговых групп&lt;/em&gt; до или после одноранговой группы текущей строки, где одноранговая группа является набор строк, эквивалентных в порядке &lt;code&gt;ORDER BY&lt;/code&gt; . (Для использования режима &lt;code&gt;GROUPS&lt;/code&gt; в определении окна должно быть предложение &lt;code&gt;ORDER BY&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="948c542b2b357818bb888566376ebb0a4005a123" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;RANGE&lt;/code&gt; mode, these options require that the &lt;code&gt;ORDER BY&lt;/code&gt; clause specify exactly one column. The &lt;code&gt;offset&lt;/code&gt; specifies the maximum difference between the value of that column in the current row and its value in preceding or following rows of the frame. The data type of the &lt;code&gt;offset&lt;/code&gt; expression varies depending on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an &lt;code&gt;interval&lt;/code&gt;. For example, if the ordering column is of type &lt;code&gt;date&lt;/code&gt; or &lt;code&gt;timestamp&lt;/code&gt;, one could write &lt;code&gt;RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING&lt;/code&gt;. The &lt;code&gt;offset&lt;/code&gt; is still required to be non-null and non-negative, though the meaning of &amp;ldquo;non-negative&amp;rdquo; depends on its data type.</source>
          <target state="translated">В режиме &lt;code&gt;RANGE&lt;/code&gt; эти параметры требуют, чтобы в предложении &lt;code&gt;ORDER BY&lt;/code&gt; был указан ровно один столбец. В &lt;code&gt;offset&lt;/code&gt; указывает максимальную разность между значением этого столбца в текущей строке и ее значение в предыдущей или последующей строки кадра. Тип данных выражения &lt;code&gt;offset&lt;/code&gt; зависит от типа данных столбца упорядочивания. Для числовых столбцов упорядочивания он обычно того же типа, что и столбец упорядочивания, но для столбцов упорядочивания по дате и &lt;code&gt;interval&lt;/code&gt; это интервал . Например, если столбец упорядочивания имеет тип &lt;code&gt;date&lt;/code&gt; или &lt;code&gt;timestamp&lt;/code&gt; , можно написать &lt;code&gt;RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING&lt;/code&gt; . В &lt;code&gt;offset&lt;/code&gt; по-прежнему должно быть ненулевым и неотрицательным, хотя значение &amp;laquo;неотрицательного&amp;raquo; зависит от его типа данных.</target>
        </trans-unit>
        <trans-unit id="1408d5e7e21bd209b1b9bfad149903cd4485729a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;RANGE&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode, a &lt;code&gt;frame_start&lt;/code&gt; of &lt;code&gt;CURRENT ROW&lt;/code&gt; means the frame starts with the current row's first &lt;em&gt;peer&lt;/em&gt; row (a row that the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause sorts as equivalent to the current row), while a &lt;code&gt;frame_end&lt;/code&gt; of &lt;code&gt;CURRENT ROW&lt;/code&gt; means the frame ends with the current row's last peer row. In &lt;code&gt;ROWS&lt;/code&gt; mode, &lt;code&gt;CURRENT ROW&lt;/code&gt; simply means the current row.</source>
          <target state="translated">В &lt;code&gt;RANGE&lt;/code&gt; или &lt;code&gt;GROUPS&lt;/code&gt; режиме, A &lt;code&gt;frame_start&lt;/code&gt; из &lt;code&gt;CURRENT ROW&lt;/code&gt; означает , что кадр начинается с первой текущей строки в &lt;em&gt;экспертной&lt;/em&gt; строке (строке , что окна &lt;code&gt;ORDER BY&lt;/code&gt; статье представлены сорта как эквивалент текущей строки), в то время как &lt;code&gt;frame_end&lt;/code&gt; из &lt;code&gt;CURRENT ROW&lt;/code&gt; означает , что концы рамы с последней одноранговой строкой текущей строки. В режиме &lt;code&gt;ROWS&lt;/code&gt; &lt;code&gt;CURRENT ROW&lt;/code&gt; просто означает текущую строку.</target>
        </trans-unit>
        <trans-unit id="30675f2bd0c7573e3e074baf89463cecdcac064e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ROWS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of rows before or after the current row.</source>
          <target state="translated">В режиме &lt;code&gt;ROWS&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; должно давать ненулевое неотрицательное целое число, а опция означает, что кадр начинается или заканчивается на указанное количество строк до или после текущей строки.</target>
        </trans-unit>
        <trans-unit id="8f056c7130dbabcd038c08071d28f6253ddeb0d1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_position&lt;/code&gt; and &lt;code&gt;array_positions&lt;/code&gt;, each array element is compared to the searched value using &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; semantics.</source>
          <target state="translated">В &lt;code&gt;array_position&lt;/code&gt; и &lt;code&gt;array_positions&lt;/code&gt; каждый элемент массива сравнивается с искомым значением с использованием семантики &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58eb966bf75cf56a14e39b6e0b483088ba13994e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_position&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; is returned if the value is not found.</source>
          <target state="translated">В &lt;code&gt;array_position&lt;/code&gt; , &lt;code&gt;NULL&lt;/code&gt; возвращается , если значение не найдено.</target>
        </trans-unit>
        <trans-unit id="6fb1576a237f50776165c9127d1d61a80997b7ea" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_positions&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; is returned only if the array is &lt;code&gt;NULL&lt;/code&gt;; if the value is not found in the array, an empty array is returned instead.</source>
          <target state="translated">В &lt;code&gt;array_positions&lt;/code&gt; , &lt;code&gt;NULL&lt;/code&gt; возвращается только если массив &lt;code&gt;NULL&lt;/code&gt; ; если значение не найдено в массиве, вместо него возвращается пустой массив.</target>
        </trans-unit>
        <trans-unit id="42867f00aff6799a35548d7b4a45bb429b8b6f41" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;encrypt_iv&lt;/code&gt; and &lt;code&gt;decrypt_iv&lt;/code&gt;, the &lt;em&gt;&lt;code&gt;iv&lt;/code&gt;&lt;/em&gt; parameter is the initial value for the CBC mode; it is ignored for ECB. It is clipped or padded with zeroes if not exactly block size. It defaults to all zeroes in the functions without this parameter.</source>
          <target state="translated">В &lt;code&gt;encrypt_iv&lt;/code&gt; и &lt;code&gt;decrypt_iv&lt;/code&gt; , то &lt;em&gt; &lt;code&gt;iv&lt;/code&gt; &lt;/em&gt; параметр является начальным значением для режима CBC; он игнорируется для ЕЦБ. Если размер блока не совсем точный, он обрезается или дополняется нулями. По умолчанию все нули в функциях без этого параметра.</target>
        </trans-unit>
        <trans-unit id="74b9c4f74b2383573102ae88dc002c3f78bfc6aa" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;init&lt;/code&gt; mode, this option analogously specifies the location of the &lt;code&gt;initdb&lt;/code&gt; executable.</source>
          <target state="translated">В режиме &lt;code&gt;init&lt;/code&gt; этот параметр аналогичным образом указывает расположение исполняемого файла &lt;code&gt;initdb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b893445cf37926dce5c6e98df69fc0726a60722" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latex-longtable&lt;/code&gt; format, this controls the proportional width of each column containing a left-aligned data type. It is specified as a whitespace-separated list of values, e.g. &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt;. Unspecified output columns use the last specified value.</source>
          <target state="translated">В формате &lt;code&gt;latex-longtable&lt;/code&gt; это контролирует пропорциональную ширину каждого столбца, содержащего выровненный по левому краю тип данных. Он указывается в виде списка значений, разделенных пробелами, например &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt; . Неуказанные выходные столбцы используют последнее указанное значение.</target>
        </trans-unit>
        <trans-unit id="cf4911342f242c7e8a426e1e90cc4a102540577f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latex-longtable&lt;/code&gt; format, this controls the proportional width of each column containing a left-aligned data type. It is specified as a whitespace-separated list of values, e.g., &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt;. Unspecified output columns use the last specified value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9860fa02b7dab9c5038f80534079df8148445840" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;logical&lt;/code&gt; level, the same information is logged as with &lt;code&gt;replica&lt;/code&gt;, plus information needed to allow extracting logical change sets from the WAL. Using a level of &lt;code&gt;logical&lt;/code&gt; will increase the WAL volume, particularly if many tables are configured for &lt;code&gt;REPLICA IDENTITY FULL&lt;/code&gt; and many &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; statements are executed.</source>
          <target state="translated">На &lt;code&gt;logical&lt;/code&gt; уровне регистрируется та же информация, что и в случае &lt;code&gt;replica&lt;/code&gt; , плюс информация, необходимая для извлечения наборов логических изменений из WAL. Использование &lt;code&gt;logical&lt;/code&gt; уровня увеличит объем WAL, особенно если многие таблицы настроены на &lt;code&gt;REPLICA IDENTITY FULL&lt;/code&gt; и выполняются многие операторы &lt;code&gt;UPDATE&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19415b9e6aa0d531e04e643500bbdc24d23674cf" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;minimal&lt;/code&gt; level, WAL-logging of some bulk operations can be safely skipped, which can make those operations much faster (see &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;). Operations in which this optimization can be applied include:</source>
          <target state="translated">На &lt;code&gt;minimal&lt;/code&gt; уровне ведение журнала WAL для некоторых массовых операций можно безопасно пропустить, что может сделать эти операции намного быстрее (см. &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Раздел 14.4.7&lt;/a&gt; ). Операции, в которых может применяться эта оптимизация, включают:</target>
        </trans-unit>
        <trans-unit id="4b6bdb288d87683bcb61f09bf26e72e3f74194ad" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;minimal&lt;/code&gt; level, no information is logged for permanent relations for the remainder of a transaction that creates or rewrites them. This can make operations much faster (see &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;). Operations that initiate this optimization include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61bcfc364ae05487e8e54b4d5f3e06b75ec150ff" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;psql&lt;/code&gt;, you will be greeted with the following message:</source>
          <target state="translated">В &lt;code&gt;psql&lt;/code&gt; вас встретит следующее сообщение:</target>
        </trans-unit>
        <trans-unit id="d81bf71ad3ee9adb26530d123722b695887e96a2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;string_to_array&lt;/code&gt;, if the delimiter parameter is NULL, each character in the input string will become a separate element in the resulting array. If the delimiter is an empty string, then the entire input string is returned as a one-element array. Otherwise the input string is split at each occurrence of the delimiter string.</source>
          <target state="translated">В &lt;code&gt;string_to_array&lt;/code&gt; , если параметр разделителя равен NULL, каждый символ входной строки станет отдельным элементом в результирующем массиве. Если разделитель - пустая строка, то вся входная строка возвращается как одноэлементный массив. В противном случае входная строка разделяется при каждом появлении строки-разделителя.</target>
        </trans-unit>
        <trans-unit id="ecd995c62df4a3324cc5c0dfdf5609bb28cc962a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;string_to_array&lt;/code&gt;, if the null-string parameter is omitted or NULL, none of the substrings of the input will be replaced by NULL. In &lt;code&gt;array_to_string&lt;/code&gt;, if the null-string parameter is omitted or NULL, any null elements in the array are simply skipped and not represented in the output string.</source>
          <target state="translated">В &lt;code&gt;string_to_array&lt;/code&gt; , если параметр нулевой строки опущен или равен NULL, ни одна из подстрок ввода не будет заменена на NULL. В &lt;code&gt;array_to_string&lt;/code&gt; , если параметр нулевой строки опущен или равен NULL, любые нулевые элементы в массиве просто пропускаются и не представлены в выходной строке.</target>
        </trans-unit>
        <trans-unit id="b1222507b269ef568691d0a9d753a3eda5a5d8e5" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_number&lt;/code&gt;, if non-data template patterns such as &lt;code&gt;L&lt;/code&gt; or &lt;code&gt;TH&lt;/code&gt; are used, the corresponding number of input characters are skipped, whether or not they match the template pattern, unless they are data characters (that is, digits, sign, decimal point, or comma). For example, &lt;code&gt;TH&lt;/code&gt; would skip two non-data characters.</source>
          <target state="translated">В &lt;code&gt;to_number&lt;/code&gt; , если используются шаблоны, не являющиеся шаблонами данных, такие как &lt;code&gt;L&lt;/code&gt; или &lt;code&gt;TH&lt;/code&gt; , соответствующее количество входных символов пропускается независимо от того, соответствуют они шаблону шаблона или нет, если только они не являются символами данных (то есть цифрами, знаком, десятичной точкой , или запятая). Например, &lt;code&gt;TH&lt;/code&gt; пропустит два символа, не являющихся данными.</target>
        </trans-unit>
        <trans-unit id="da01a26180a4b78ca506a4e26d673346bc64efee" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, an ISO 8601 week-numbering date (as distinct from a Gregorian date) can be specified in one of two ways:</source>
          <target state="translated">В &lt;code&gt;to_timestamp&lt;/code&gt; и &lt;code&gt;to_date&lt;/code&gt; дата нумерации недель ISO 8601 (в отличие от даты по григорианскому календарю ) может быть указана одним из двух способов:</target>
        </trans-unit>
        <trans-unit id="f9d931e068d7388b5b9791ba73a39ccc4330b961" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, if the year format specification is less than four digits, e.g. &lt;code&gt;YYY&lt;/code&gt;, and the supplied year is less than four digits, the year will be adjusted to be nearest to the year 2020, e.g. &lt;code&gt;95&lt;/code&gt; becomes 1995.</source>
          <target state="translated">В &lt;code&gt;to_timestamp&lt;/code&gt; и &lt;code&gt;to_date&lt;/code&gt; , если в спецификации формата года меньше четырех цифр, например &lt;code&gt;YYY&lt;/code&gt; , а указанный год меньше четырех цифр, год будет скорректирован так, чтобы он был ближайшим к 2020 году, например &lt;code&gt;95&lt;/code&gt; становится 1995.</target>
        </trans-unit>
        <trans-unit id="d8f4914c4ba597d9e2b92d0c671f4d7641758160" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, if the year format specification is less than four digits, e.g., &lt;code&gt;YYY&lt;/code&gt;, and the supplied year is less than four digits, the year will be adjusted to be nearest to the year 2020, e.g., &lt;code&gt;95&lt;/code&gt; becomes 1995.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551a2fa16ad6836b39b0369ec3903da168ff58bb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, negative years are treated as signifying BC. If you write both a negative year and an explicit &lt;code&gt;BC&lt;/code&gt; field, you get AD again. An input of year zero is treated as 1 BC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dcc47dcfb30c72df039620b4818cb5cae63885b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, the &lt;code&gt;CC&lt;/code&gt; (century) field is accepted but ignored if there is a &lt;code&gt;YYY&lt;/code&gt;, &lt;code&gt;YYYY&lt;/code&gt; or &lt;code&gt;Y,YYY&lt;/code&gt; field. If &lt;code&gt;CC&lt;/code&gt; is used with &lt;code&gt;YY&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt; then the result is computed as that year in the specified century. If the century is specified but the year is not, the first year of the century is assumed.</source>
          <target state="translated">В &lt;code&gt;to_timestamp&lt;/code&gt; и &lt;code&gt;to_date&lt;/code&gt; поле &lt;code&gt;CC&lt;/code&gt; (век) принимается, но игнорируется, если есть поле &lt;code&gt;YYY&lt;/code&gt; , &lt;code&gt;YYYY&lt;/code&gt; или &lt;code&gt;Y,YYY&lt;/code&gt; . Если &lt;code&gt;CC&lt;/code&gt; используется с &lt;code&gt;YY&lt;/code&gt; или &lt;code&gt;Y&lt;/code&gt; , то результат вычисляется как год в указанном столетии. Если указан век, а год нет, предполагается, что это первый год века.</target>
        </trans-unit>
        <trans-unit id="34928f49bb5512bad729a0eba587c351c3b66a70" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, the &lt;code&gt;YYYY&lt;/code&gt; conversion has a restriction when processing years with more than 4 digits. You must use some non-digit character or template after &lt;code&gt;YYYY&lt;/code&gt;, otherwise the year is always interpreted as 4 digits. For example (with the year 20000): &lt;code&gt;to_date('200001131', 'YYYYMMDD')&lt;/code&gt; will be interpreted as a 4-digit year; instead use a non-digit separator after the year, like &lt;code&gt;to_date('20000-1131', 'YYYY-MMDD')&lt;/code&gt; or &lt;code&gt;to_date('20000Nov31', 'YYYYMonDD')&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;to_timestamp&lt;/code&gt; и &lt;code&gt;to_date&lt;/code&gt; , то &lt;code&gt;YYYY&lt;/code&gt; преобразование имеет ограничение при обработке лет с более чем 4 -х цифр. Вы должны использовать какой-либо нецифровой символ или шаблон после &lt;code&gt;YYYY&lt;/code&gt; , иначе год всегда интерпретируется как 4 цифры. Например (с годом 20000): &lt;code&gt;to_date('200001131', 'YYYYMMDD')&lt;/code&gt; будет интерпретироваться как год из 4 цифр; вместо этого используйте нецифровой разделитель после года, например &lt;code&gt;to_date('20000-1131', 'YYYY-MMDD')&lt;/code&gt; или &lt;code&gt;to_date('20000Nov31', 'YYYYMonDD')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="544ec57993b0d566b29bfdeb2a8cf47932beafef" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, weekday names or numbers (&lt;code&gt;DAY&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, and related field types) are accepted but are ignored for purposes of computing the result. The same is true for quarter (&lt;code&gt;Q&lt;/code&gt;) fields.</source>
          <target state="translated">В &lt;code&gt;to_timestamp&lt;/code&gt; и &lt;code&gt;to_date&lt;/code&gt; имена или числа дней недели ( &lt;code&gt;DAY&lt;/code&gt; , &lt;code&gt;D&lt;/code&gt; и связанные типы полей) принимаются, но игнорируются для целей вычисления результата. То же самое и с четвертью ( &lt;code&gt;Q&lt;/code&gt; ) полей.</target>
        </trans-unit>
        <trans-unit id="8902e096eb8211a3103ef8a03507a1e1c0b7839c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt;, millisecond (&lt;code&gt;MS&lt;/code&gt;) or microsecond (&lt;code&gt;US&lt;/code&gt;) fields are used as the seconds digits after the decimal point. For example &lt;code&gt;to_timestamp('12.3', 'SS.MS')&lt;/code&gt; is not 3 milliseconds, but 300, because the conversion treats it as 12 + 0.3 seconds. So, for the format &lt;code&gt;SS.MS&lt;/code&gt;, the input values &lt;code&gt;12.3&lt;/code&gt;, &lt;code&gt;12.30&lt;/code&gt;, and &lt;code&gt;12.300&lt;/code&gt; specify the same number of milliseconds. To get three milliseconds, one must write &lt;code&gt;12.003&lt;/code&gt;, which the conversion treats as 12 + 0.003 = 12.003 seconds.</source>
          <target state="translated">В &lt;code&gt;to_timestamp&lt;/code&gt; поля миллисекунды ( &lt;code&gt;MS&lt;/code&gt; ) или микросекунды ( &lt;code&gt;US&lt;/code&gt; ) используются в качестве цифр секунд после десятичной точки. Например, &lt;code&gt;to_timestamp('12.3', 'SS.MS')&lt;/code&gt; не 3 миллисекунды, а 300, потому что преобразование обрабатывает его как 12 + 0,3 секунды. Итак, для формата &lt;code&gt;SS.MS&lt;/code&gt; входные значения &lt;code&gt;12.3&lt;/code&gt; , &lt;code&gt;12.30&lt;/code&gt; и &lt;code&gt;12.300&lt;/code&gt; указывают одинаковое количество миллисекунд. Чтобы получить три миллисекунды, нужно написать &lt;code&gt;12.003&lt;/code&gt; , что при преобразовании трактуется как 12 + 0,003 = 12,003 секунды.</target>
        </trans-unit>
        <trans-unit id="64a9c48229747c676385712712a92e7a02f4a20e" translate="yes" xml:space="preserve">
          <source>In AREs, &lt;code&gt;\&lt;/code&gt; followed by an alphanumeric character is either an escape or an error, while in previous releases, it was just another way of writing the alphanumeric. This should not be much of a problem because there was no reason to write such a sequence in earlier releases.</source>
          <target state="translated">В ARE символ &lt;code&gt;\&lt;/code&gt; , за которым следует буквенно-цифровой символ, является либо escape-последовательностью, либо ошибкой, тогда как в предыдущих выпусках это был просто другой способ записи буквенно-цифрового символа. Это не должно быть большой проблемой, потому что в более ранних выпусках не было причин писать такую ​​последовательность.</target>
        </trans-unit>
        <trans-unit id="9fd039b2f7ce31cb27cef33f4f533a9fac0c1fbd" translate="yes" xml:space="preserve">
          <source>In AREs, &lt;code&gt;\&lt;/code&gt; remains a special character within &lt;code&gt;[]&lt;/code&gt;, so a literal &lt;code&gt;\&lt;/code&gt; within a bracket expression must be written &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">В ARE &lt;code&gt;\&lt;/code&gt; остается специальным символом внутри &lt;code&gt;[]&lt;/code&gt; , поэтому литерал &lt;code&gt;\&lt;/code&gt; в выражении в квадратных скобках должен быть записан &lt;code&gt;\\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb3ffc95899379ce4e17b50af19efa046a482415" translate="yes" xml:space="preserve">
          <source>In HTML format, this specifies attributes to be placed inside the &lt;code&gt;table&lt;/code&gt; tag. This could for example be &lt;code&gt;cellpadding&lt;/code&gt; or &lt;code&gt;bgcolor&lt;/code&gt;. Note that you probably don't want to specify &lt;code&gt;border&lt;/code&gt; here, as that is already taken care of by &lt;code&gt;\pset border&lt;/code&gt;. If no &lt;code&gt;value&lt;/code&gt; is given, the table attributes are unset.</source>
          <target state="translated">В формате HTML это определяет атрибуты, которые должны быть помещены в тег &lt;code&gt;table&lt;/code&gt; . Например, это может быть &lt;code&gt;cellpadding&lt;/code&gt; или &lt;code&gt;bgcolor&lt;/code&gt; . Обратите внимание, что вы, вероятно, не хотите указывать здесь &lt;code&gt;border&lt;/code&gt; , так как это уже позаботилось о &lt;code&gt;\pset border&lt;/code&gt; . Если &lt;code&gt;value&lt;/code&gt; не указано, атрибуты таблицы не установлены.</target>
        </trans-unit>
        <trans-unit id="814a324a3771e36f5c269dff83adcdc2f6482fa5" translate="yes" xml:space="preserve">
          <source>In Linux 2.4 and later, the default virtual memory behavior is not optimal for PostgreSQL. Because of the way that the kernel implements memory overcommit, the kernel might terminate the PostgreSQL postmaster (the master server process) if the memory demands of either PostgreSQL or another process cause the system to run out of virtual memory.</source>
          <target state="translated">В Linux 2.4 и более поздних версиях,поведение виртуальной памяти по умолчанию не является оптимальным для PostgreSQL.Из-за того,как ядро реализует избыток памяти,ядро может завершить работу PostgreSQL postmaster (процесс на главном сервере),если требования памяти к PostgreSQL или другому процессу приводят к исчерпанию виртуальной памяти в системе.</target>
        </trans-unit>
        <trans-unit id="f9db993d9ed52b850a8119db5ab8d068b60a0509" translate="yes" xml:space="preserve">
          <source>In NetBSD 5.0 and later, IPC parameters can be adjusted using &lt;code&gt;sysctl&lt;/code&gt;, for example:</source>
          <target state="translated">В NetBSD 5.0 ​​и новее параметры IPC можно настроить с помощью &lt;code&gt;sysctl&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="33cf5a32119e2012e85b594bd01ed746ff893ad5" translate="yes" xml:space="preserve">
          <source>In OpenBSD 3.3 and later, IPC parameters can be adjusted using &lt;code&gt;sysctl&lt;/code&gt;, for example:</source>
          <target state="translated">В OpenBSD 3.3 и новее параметры IPC можно настроить с помощью &lt;code&gt;sysctl&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="d469c640f950b7673c7ae58a9ecc0f315265b7c1" translate="yes" xml:space="preserve">
          <source>In PostgreSQL releases prior to 9.0, large objects did not have access privileges and were, therefore, always readable and writable by all users. Setting this variable to &lt;code&gt;on&lt;/code&gt; disables the new privilege checks, for compatibility with prior releases. The default is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">В выпусках PostgreSQL до 9.0 большие объекты не имели прав доступа и поэтому всегда были доступны для чтения и записи всем пользователям. Установка для этой переменной значения &lt;code&gt;on&lt;/code&gt; отключает новые проверки привилегий для совместимости с предыдущими выпусками. По умолчанию &lt;code&gt;off&lt;/code&gt; . Только суперпользователи могут изменять этот параметр.</target>
        </trans-unit>
        <trans-unit id="22cd8a67509e8ca7db080a3ecd0b854c45395a98" translate="yes" xml:space="preserve">
          <source>In PostgreSQL releases prior to 9.3, &lt;code&gt;commit_delay&lt;/code&gt; behaved differently and was much less effective: it affected only commits, rather than all WAL flushes, and waited for the entire configured delay even if the WAL flush was completed sooner. Beginning in PostgreSQL 9.3, the first process that becomes ready to flush waits for the configured interval, while subsequent processes wait only until the leader completes the flush operation.</source>
          <target state="translated">В выпусках PostgreSQL до 9.3 &lt;code&gt;commit_delay&lt;/code&gt; вела себя иначе и была гораздо менее эффективной: она влияла только на фиксации, а не на все сбросы WAL, и ждала всю настроенную задержку, даже если сброс WAL был завершен раньше. Начиная с PostgreSQL 9.3, первый процесс, который становится готовым к сбросу, ожидает в течение заданного интервала, в то время как последующие процессы ждут только до тех пор, пока лидер не завершит операцию сброса.</target>
        </trans-unit>
        <trans-unit id="b3a09d320c0eb1af5ebf6fc539b70645d7fbc828" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions 8.0 through 8.2, the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; would be canceled by releasing an earlier savepoint, or by successful exit from a PL/pgSQL exception block. This behavior has been changed because it was deemed unintuitive.</source>
          <target state="translated">В PostgreSQL версий 8.0&amp;ndash;8.2 действие &lt;code&gt;SET LOCAL&lt;/code&gt; отменялось освобождением более ранней точки сохранения или успешным выходом из блока исключений PL / pgSQL. Это поведение было изменено, поскольку оно было сочтено не интуитивным.</target>
        </trans-unit>
        <trans-unit id="a2a2f1f614c98ca12a5b32b40e076079264d9c76" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was customary to avoid creating a shell type at all, by replacing the functions' forward references to the type name with the placeholder pseudo-type &lt;code&gt;opaque&lt;/code&gt;. The &lt;code&gt;cstring&lt;/code&gt; arguments and results also had to be declared as &lt;code&gt;opaque&lt;/code&gt; before 7.3. To support loading of old dump files, &lt;code&gt;CREATE TYPE&lt;/code&gt; will accept I/O functions declared using &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function declarations to use the correct types.</source>
          <target state="translated">В версиях PostgreSQL до 7.3 было принято вообще избегать создания типа оболочки, заменяя прямые ссылки функций на имя типа &lt;code&gt;opaque&lt;/code&gt; псевдотипом заполнителя . В &lt;code&gt;cstring&lt;/code&gt; аргументов и результаты также должны были быть объявлены как &lt;code&gt;opaque&lt;/code&gt; , прежде чем 7.3. Для поддержки загрузки старых файлов дампа &lt;code&gt;CREATE TYPE&lt;/code&gt; будет принимать функции ввода-вывода, объявленные с использованием &lt;code&gt;opaque&lt;/code&gt; , но будет выдавать уведомление и изменять объявления функций для использования правильных типов.</target>
        </trans-unit>
        <trans-unit id="b355acb666b0ad4cd57d90f2927cbffb2b6ed9ef" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was necessary to declare handler functions as returning the placeholder type &lt;code&gt;opaque&lt;/code&gt;, rather than &lt;code&gt;language_handler&lt;/code&gt;. To support loading of old dump files, &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; will accept a function declared as returning &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function's declared return type to &lt;code&gt;language_handler&lt;/code&gt;.</source>
          <target state="translated">В версиях PostgreSQL до 7.3 было необходимо объявлять функции-обработчики как возвращающие &lt;code&gt;opaque&lt;/code&gt; тип заполнителя , а не &lt;code&gt;language_handler&lt;/code&gt; . Для поддержки загрузки старых файлов дампа &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; примет функцию, объявленную как возвращающую &lt;code&gt;opaque&lt;/code&gt; , но выдаст уведомление и изменит объявленный возвращаемый тип функции на &lt;code&gt;language_handler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c16c4aa970c78b968d9f432a8088edb5d24051d5" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was necessary to declare trigger functions as returning the placeholder type &lt;code&gt;opaque&lt;/code&gt;, rather than &lt;code&gt;trigger&lt;/code&gt;. To support loading of old dump files, &lt;code&gt;CREATE TRIGGER&lt;/code&gt; will accept a function declared as returning &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function's declared return type to &lt;code&gt;trigger&lt;/code&gt;.</source>
          <target state="translated">В версиях PostgreSQL до 7.3 было необходимо объявлять функции триггеров как возвращающие &lt;code&gt;opaque&lt;/code&gt; тип заполнителя , а не &lt;code&gt;trigger&lt;/code&gt; . Для поддержки загрузки старых файлов дампа &lt;code&gt;CREATE TRIGGER&lt;/code&gt; примет функцию, объявленную как возвращающую &lt;code&gt;opaque&lt;/code&gt; , но выдаст уведомление и изменит объявленный возвращаемый тип функции на &lt;code&gt;trigger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c68aa880bfe2dcd90559cbb12f6681d9282ddb1" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 9.4, freezing was implemented by actually replacing a row's insertion XID with &lt;code&gt;FrozenTransactionId&lt;/code&gt;, which was visible in the row's &lt;code&gt;xmin&lt;/code&gt; system column. Newer versions just set a flag bit, preserving the row's original &lt;code&gt;xmin&lt;/code&gt; for possible forensic use. However, rows with &lt;code&gt;xmin&lt;/code&gt; equal to &lt;code&gt;FrozenTransactionId&lt;/code&gt; (2) may still be found in databases pg_upgrade'd from pre-9.4 versions.</source>
          <target state="translated">В версиях PostgreSQL до 9.4 замораживание было реализовано путем фактической замены XID вставки строки на &lt;code&gt;FrozenTransactionId&lt;/code&gt; , который был виден в системном столбце строки &lt;code&gt;xmin&lt;/code&gt; . Более новые версии просто устанавливают бит флага, сохраняя исходный &lt;code&gt;xmin&lt;/code&gt; строки для возможного судебного использования. Однако строки с &lt;code&gt;xmin&lt;/code&gt; , равным &lt;code&gt;FrozenTransactionId&lt;/code&gt; (2), все еще могут быть найдены в базах данных pg_upgrade'd из версий до 9.4.</target>
        </trans-unit>
        <trans-unit id="671f1f8fc18839cfcffc25653d6a82f0e2f7003b" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, &lt;em&gt;Class&lt;/em&gt; is an archaic synonym for &lt;em&gt;relation&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eadad43cc831b2ff40334680f58601d4f7a10c43" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a reference to a table name (or alias) in a query is effectively a reference to the composite value of the table's current row. For example, if we had a table &lt;code&gt;inventory_item&lt;/code&gt; as shown &lt;a href=&quot;rowtypes#ROWTYPES-DECLARING&quot;&gt;above&lt;/a&gt;, we could write:</source>
          <target state="translated">В PostgreSQL ссылка на имя (или псевдоним) таблицы в запросе фактически является ссылкой на составное значение текущей строки таблицы. Например, если бы у нас была таблица &lt;code&gt;inventory_item&lt;/code&gt; , как показано &lt;a href=&quot;rowtypes#ROWTYPES-DECLARING&quot;&gt;выше&lt;/a&gt; , мы могли бы написать:</target>
        </trans-unit>
        <trans-unit id="4a86fbee986217732dc6e120d53c8e8d4a6c9100" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a table can inherit from zero or more other tables, and a query can reference either all rows of a table or all rows of a table plus all of its descendant tables. The latter behavior is the default. For example, the following query finds the names of all cities, including state capitals, that are located at an altitude over 500 feet:</source>
          <target state="translated">В PostgreSQL таблица может наследовать от нуля и более других таблиц,а запрос может ссылаться как на все строки таблицы,так и на все строки таблицы плюс на все таблицы-потомки.Последнее поведение является поведением по умолчанию.Например,следующий запрос находит названия всех городов,включая столицы штатов,которые расположены на высоте более 500 футов:</target>
        </trans-unit>
        <trans-unit id="5bbc940645cf942038016bf2339fe7d4f2c180e0" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a table can inherit from zero or more other tables, and a query can reference either all rows of a table or all rows of a table plus all of its descendant tables. The latter behavior is the default. For example, the following query finds the names of all cities, including state capitals, that are located at an elevation over 500 feet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74efdce9636de27e76a8b8265ce6cb497dd89fdf" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a transaction is set up by surrounding the SQL commands of the transaction with &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;COMMIT&lt;/code&gt; commands. So our banking transaction would actually look like:</source>
          <target state="translated">В PostgreSQL транзакция настраивается путем окружения команд SQL транзакции командами &lt;code&gt;BEGIN&lt;/code&gt; и &lt;code&gt;COMMIT&lt;/code&gt; . Итак, наша банковская транзакция на самом деле будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="ba3eb2b425968ebc072af7dd5475bc71e9126bfd" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; of a row does not immediately remove the old version of the row. This approach is necessary to gain the benefits of multiversion concurrency control (MVCC, see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;): the row version must not be deleted while it is still potentially visible to other transactions. But eventually, an outdated or deleted row version is no longer of interest to any transaction. The space it occupies must then be reclaimed for reuse by new rows, to avoid unbounded growth of disk space requirements. This is done by running &lt;code&gt;VACUUM&lt;/code&gt;.</source>
          <target state="translated">В PostgreSQL &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; строки не удаляет сразу старую версию строки. Этот подход необходим для получения преимуществ управления параллелизмом с несколькими версиями (MVCC, см. &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Главу 13&lt;/a&gt; ): версию строки нельзя удалять, пока она все еще потенциально видна другим транзакциям. Но в конечном итоге устаревшая или удаленная версия строки больше не представляет интереса для какой-либо транзакции. Затем занимаемое им пространство необходимо освободить для повторного использования новыми строками, чтобы избежать неограниченного роста требований к дисковому пространству. Это делается путем запуска &lt;code&gt;VACUUM&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6391c36f8926e9d031902999f670ae49ff9d23c6" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; of a row does not immediately remove the old version of the row. This approach is necessary to gain the benefits of multiversion concurrency control (MVCC, see &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;): the row version must not be deleted while it is still potentially visible to other transactions. But eventually, an outdated or deleted row version is no longer of interest to any transaction. The space it occupies must then be reclaimed for reuse by new rows, to avoid unbounded growth of disk space requirements. This is done by running &lt;code&gt;VACUUM&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b304e14a0ece97ffe0ae3c2773ba82b02c4d00d4" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, the term &lt;em&gt;cluster&lt;/em&gt; is also sometimes used to refer to an instance. (Don't confuse this term with the SQL command &lt;code&gt;CLUSTER&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbda6fce7f63ccb95f1398e8c5c8a9c6bb83f492" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, you can request any of the four standard transaction isolation levels, but internally only three distinct isolation levels are implemented, i.e. PostgreSQL's Read Uncommitted mode behaves like Read Committed. This is because it is the only sensible way to map the standard isolation levels to PostgreSQL's multiversion concurrency control architecture.</source>
          <target state="translated">В PostgreSQL можно запросить любой из четырех стандартных уровней изоляции транзакций,но внутри PostgreSQL реализовано только три различных уровня изоляции,т.е.режим PostgreSQL &quot;Read Uncommitted&quot; (Чтение без фиксации)ведет себя как &quot;Read Committed&quot; (Чтение с фиксацией).Это связано с тем,что это единственный разумный способ сопоставить стандартные уровни изоляции с мультиверсионной архитектурой управления параллельными транзакциями PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="83cd5c09f1c331276300cecbfba985d6b8844acd" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, you can request any of the four standard transaction isolation levels, but internally only three distinct isolation levels are implemented, i.e., PostgreSQL's Read Uncommitted mode behaves like Read Committed. This is because it is the only sensible way to map the standard isolation levels to PostgreSQL's multiversion concurrency control architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759eb406805a5a1c000f22431f41b882c8790352" translate="yes" xml:space="preserve">
          <source>In SCRAM without channel binding, the server chooses a random number that is transmitted to the client to be mixed with the user-supplied password in the transmitted password hash. While this prevents the password hash from being successfully retransmitted in a later session, it does not prevent a fake server between the real server and client from passing through the server's random value and successfully authenticating.</source>
          <target state="translated">В SCRAM без привязки каналов сервер выбирает случайное число,которое передается клиенту для смешивания с предоставленным пользователем паролем в передаваемом хэше пароля.Хотя это предотвращает успешную ретрансляцию хэша пароля в последующем сеансе,это не мешает фальшивому серверу между реальным сервером и клиентом пройти через случайное значение сервера и успешно аутентифицироваться.</target>
        </trans-unit>
        <trans-unit id="bbe3d8277f59658a3be0c65846387947fe489961" translate="yes" xml:space="preserve">
          <source>In SQL:2006 and later, both directions of conversion between standard SQL data types and the XML Schema types are specified precisely. However, the rules are expressed using the types and semantics of XQuery/XPath, and have no direct application to the different data model of XPath 1.0.</source>
          <target state="translated">В SQL:2006 и более поздних версиях точно указаны оба направления преобразования между стандартными типами данных SQL и типами XML-схем.Однако правила выражены с использованием типов и семантики XQuery/XPath и не имеют прямого применения к различным моделям данных XPath 1.0.</target>
        </trans-unit>
        <trans-unit id="1cddd15d85853fd05a956af5b4c400072d8cd616" translate="yes" xml:space="preserve">
          <source>In Solaris 10 and later, and OpenSolaris, the default shared memory and semaphore settings are good enough for most PostgreSQL applications. Solaris now defaults to a &lt;code&gt;SHMMAX&lt;/code&gt; of one-quarter of system RAM. To further adjust this setting, use a project setting associated with the &lt;code&gt;postgres&lt;/code&gt; user. For example, run the following as &lt;code&gt;root&lt;/code&gt;:</source>
          <target state="translated">В Solaris 10 и более поздних версиях и OpenSolaris параметры разделяемой памяти и семафоров по умолчанию достаточно хороши для большинства приложений PostgreSQL. В Solaris теперь по умолчанию &lt;code&gt;SHMMAX&lt;/code&gt; составляет четверть системной RAM. Для дальнейшей настройки этого параметра используйте параметр проекта, связанный с пользователем &lt;code&gt;postgres&lt;/code&gt; . Например, запустите от имени &lt;code&gt;root&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f2711fad286d67111c91bf5304258de9bff55609" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;BEFORE&lt;/code&gt; trigger, the &lt;code&gt;WHEN&lt;/code&gt; condition is evaluated just before the function is or would be executed, so using &lt;code&gt;WHEN&lt;/code&gt; is not materially different from testing the same condition at the beginning of the trigger function. Note in particular that the &lt;code&gt;NEW&lt;/code&gt; row seen by the condition is the current value, as possibly modified by earlier triggers. Also, a &lt;code&gt;BEFORE&lt;/code&gt; trigger's &lt;code&gt;WHEN&lt;/code&gt; condition is not allowed to examine the system columns of the &lt;code&gt;NEW&lt;/code&gt; row (such as &lt;code&gt;ctid&lt;/code&gt;), because those won't have been set yet.</source>
          <target state="translated">В триггере &lt;code&gt;BEFORE&lt;/code&gt; условие &lt;code&gt;WHEN&lt;/code&gt; оценивается непосредственно перед тем, как функция будет выполнена или будет выполнена, поэтому использование &lt;code&gt;WHEN&lt;/code&gt; существенно не отличается от проверки того же условия в начале функции триггера. Обратите внимание, в частности, что строка &lt;code&gt;NEW&lt;/code&gt; , отображаемая условием, является текущим значением, которое может быть изменено более ранними триггерами. Кроме того, условие &lt;code&gt;WHEN&lt;/code&gt; триггера &lt;code&gt;BEFORE&lt;/code&gt; не может проверять системные столбцы строки &lt;code&gt;NEW&lt;/code&gt; (например, &lt;code&gt;ctid&lt;/code&gt; ), потому что они еще не были установлены.</target>
        </trans-unit>
        <trans-unit id="9ce810944c17541339c741b40b793201537de044" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;DELETE&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the content of the deleted row. For example:</source>
          <target state="translated">В &lt;code&gt;DELETE&lt;/code&gt; данные, доступные для &lt;code&gt;RETURNING&lt;/code&gt; , являются содержимым удаленной строки. Например:</target>
        </trans-unit>
        <trans-unit id="0d3bf14e9dc0493ac82721df4faae7ba81c88992" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;DROP FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support must be specified.</source>
          <target state="translated">В предложении &lt;code&gt;DROP FUNCTION&lt;/code&gt; необходимо указать тип (ы) данных операнда, для поддержки которых предназначена функция.</target>
        </trans-unit>
        <trans-unit id="85532f42163c3739d7f5a6244714ead077b8baea" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function (for B-tree comparison functions and hash functions) or the class's data type (for B-tree sort support functions and all functions in GiST, SP-GiST, GIN and BRIN operator classes). These defaults are correct, and so &lt;code&gt;op_type&lt;/code&gt; need not be specified in &lt;code&gt;FUNCTION&lt;/code&gt; clauses, except for the case of a B-tree sort support function that is meant to support cross-data-type comparisons.</source>
          <target state="translated">В предложении &lt;code&gt;FUNCTION&lt;/code&gt; тип (ы) данных операнда, которые функция предназначена для поддержки, если он отличается от типа (ов) входных данных функции (для функций сравнения B-дерева и хэш-функций) или типа данных класса (для Функции поддержки сортировки B-дерева и все функции в классах операторов GiST, SP-GiST, GIN и BRIN). Эти значения по умолчанию верны, поэтому &lt;code&gt;op_type&lt;/code&gt; не нужно указывать в предложениях &lt;code&gt;FUNCTION&lt;/code&gt; , за исключением случая функции поддержки сортировки B-дерева, которая предназначена для поддержки сравнений между типами данных.</target>
        </trans-unit>
        <trans-unit id="48b115e1e3ffc8870fd0440011ed57528dd63c06" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function (for B-tree comparison functions and hash functions) or the class's data type (for B-tree sort support functions, B-tree equal image functions, and all functions in GiST, SP-GiST, GIN and BRIN operator classes). These defaults are correct, and so &lt;code&gt;op_type&lt;/code&gt; need not be specified in &lt;code&gt;FUNCTION&lt;/code&gt; clauses, except for the case of a B-tree sort support function that is meant to support cross-data-type comparisons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f9bb9a1e74c73e631d5463da369a9644506e4f0" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;SELECT&lt;/code&gt; command, these two policies are combined using &lt;code&gt;OR&lt;/code&gt;, with the net effect being that all rows can be selected. In other command types, only the second policy applies, so that the effects are the same as before.</source>
          <target state="translated">В команде &lt;code&gt;SELECT&lt;/code&gt; эти две политики объединяются с помощью &lt;code&gt;OR&lt;/code&gt; , в результате чего можно выбрать все строки. В других типах команд применяется только вторая политика, так что эффекты такие же, как и раньше.</target>
        </trans-unit>
        <trans-unit id="300ce212406203fa6b094fb383bde2b25f44a159" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;pg_hba.conf&lt;/code&gt; record specifying certificate authentication, the authentication option &lt;code&gt;clientcert&lt;/code&gt; is assumed to be &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;, and it cannot be turned off since a client certificate is necessary for this method. What the &lt;code&gt;cert&lt;/code&gt; method adds to the basic &lt;code&gt;clientcert&lt;/code&gt; certificate validity test is a check that the &lt;code&gt;cn&lt;/code&gt; attribute matches the database user name.</source>
          <target state="translated">В записи &lt;code&gt;pg_hba.conf&lt;/code&gt; , определяющей аутентификацию сертификата, предполагается , что параметр аутентификации &lt;code&gt;clientcert&lt;/code&gt; имеет значение verify &lt;code&gt;verify-ca&lt;/code&gt; или verify &lt;code&gt;verify-full&lt;/code&gt; , и его нельзя отключить, так как для этого метода необходим сертификат клиента. Что &lt;code&gt;cert&lt;/code&gt; метод добавляет к основному &lt;code&gt;clientcert&lt;/code&gt; тесту действия сертификата является проверкой , что &lt;code&gt;cn&lt;/code&gt; атрибут совпадает с именем пользователя базы данных.</target>
        </trans-unit>
        <trans-unit id="f05e815aa51edd32e8f243de544f1a7fed6f4907" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;to_char&lt;/code&gt; output template string, there are certain patterns that are recognized and replaced with appropriately-formatted data based on the given value. Any text that is not a template pattern is simply copied verbatim. Similarly, in an input template string (for the other functions), template patterns identify the values to be supplied by the input data string. If there are characters in the template string that are not template patterns, the corresponding characters in the input data string are simply skipped over (whether or not they are equal to the template string characters).</source>
          <target state="translated">В &lt;code&gt;to_char&lt;/code&gt; выходного шаблона to_char есть определенные шаблоны, которые распознаются и заменяются соответствующим образом отформатированными данными на основе заданного значения. Любой текст, не являющийся шаблоном, просто копируется дословно. Точно так же в строке входного шаблона (для других функций) шаблоны шаблона идентифицируют значения, которые должны быть предоставлены строкой входных данных. Если в строке шаблона есть символы, которые не являются шаблонами шаблона, соответствующие символы в строке входных данных просто пропускаются (независимо от того, равны ли они символам строки шаблона).</target>
        </trans-unit>
        <trans-unit id="78e3bba2064f9d9c2fee2733a54ca75d990eba66" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;hash join&lt;/em&gt; (without the &quot;parallel&quot; prefix), the inner side is executed in full by every cooperating process to build identical copies of the hash table. This may be inefficient if the hash table is large or the plan is expensive. In a &lt;em&gt;parallel hash join&lt;/em&gt;, the inner side is a &lt;em&gt;parallel hash&lt;/em&gt; that divides the work of building a shared hash table over the cooperating processes.</source>
          <target state="translated">В &lt;em&gt;хэш-соединении&lt;/em&gt; (без префикса &amp;laquo;параллельный&amp;raquo;) внутренняя сторона полностью выполняется каждым взаимодействующим процессом для создания идентичных копий хеш-таблицы. Это может быть неэффективно, если хэш-таблица большая или план дорогостоящий. В &lt;em&gt;параллельном хеш-соединении&lt;/em&gt; внутренняя сторона - это &lt;em&gt;параллельный хеш,&lt;/em&gt; который разделяет работу по созданию общей хеш-таблицы на взаимодействующие процессы.</target>
        </trans-unit>
        <trans-unit id="3480286d445961d6181c445c4ffd40322b928fd9" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;merge join&lt;/em&gt;, the inner side is always a non-parallel plan and therefore executed in full. This may be inefficient, especially if a sort must be performed, because the work and resulting data are duplicated in every cooperating process.</source>
          <target state="translated">В &lt;em&gt;объединении слиянием&lt;/em&gt; внутренняя сторона всегда является непараллельным планом и поэтому выполняется полностью. Это может быть неэффективным, особенно если необходимо выполнить сортировку, потому что работа и результирующие данные дублируются в каждом взаимодействующем процессе.</target>
        </trans-unit>
        <trans-unit id="400e7c200fdc3546ddf00f5c7ed10cb2ab42e4c0" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;nested loop join&lt;/em&gt;, the inner side is always non-parallel. Although it is executed in full, this is efficient if the inner side is an index scan, because the outer tuples and thus the loops that look up values in the index are divided over the cooperating processes.</source>
          <target state="translated">В соединении с &lt;em&gt;вложенным циклом&lt;/em&gt; внутренняя сторона всегда непараллельна. Хотя он выполняется полностью, это эффективно, если внутренняя сторона представляет собой сканирование индекса, поскольку внешние кортежи и, следовательно, циклы, которые ищут значения в индексе, делятся между взаимодействующими процессами.</target>
        </trans-unit>
        <trans-unit id="dea6a7ade41e8f01fb686c080220d4159b567183" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel bitmap heap scan&lt;/em&gt;, one process is chosen as the leader. That process performs a scan of one or more indexes and builds a bitmap indicating which table blocks need to be visited. These blocks are then divided among the cooperating processes as in a parallel sequential scan. In other words, the heap scan is performed in parallel, but the underlying index scan is not.</source>
          <target state="translated">При &lt;em&gt;параллельном сканировании кучи битовой карты&lt;/em&gt; в качестве ведущего выбирается один процесс. Этот процесс выполняет сканирование одного или нескольких индексов и строит битовую карту, указывающую, какие блоки таблицы необходимо посетить. Затем эти блоки разделяются между взаимодействующими процессами, как при параллельном последовательном сканировании. Другими словами, сканирование кучи выполняется параллельно, а базовое сканирование индекса - нет.</target>
        </trans-unit>
        <trans-unit id="8227deba10aefb19ed8caa11f69ff745de460ae7" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel index scan&lt;/em&gt; or &lt;em&gt;parallel index-only scan&lt;/em&gt;, the cooperating processes take turns reading data from the index. Currently, parallel index scans are supported only for btree indexes. Each process will claim a single index block and will scan and return all tuples referenced by that block; other process can at the same time be returning tuples from a different index block. The results of a parallel btree scan are returned in sorted order within each worker process.</source>
          <target state="translated">При &lt;em&gt;параллельном сканировании индекса&lt;/em&gt; или &lt;em&gt;параллельном сканировании только индекса&lt;/em&gt; взаимодействующие процессы по очереди считывают данные из индекса. В настоящее время параллельное сканирование индексов поддерживается только для индексов btree. Каждый процесс будет требовать один индексный блок и будет сканировать и возвращать все кортежи, на которые ссылается этот блок; другой процесс может одновременно возвращать кортежи из другого индексного блока. Результаты параллельного сканирования btree возвращаются в отсортированном порядке в каждом рабочем процессе.</target>
        </trans-unit>
        <trans-unit id="76601edb0fbc4f9ce17e08d79102a74db01983a7" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel index scan&lt;/em&gt; or &lt;em&gt;parallel index-only scan&lt;/em&gt;, the cooperating processes take turns reading data from the index. Currently, parallel index scans are supported only for btree indexes. Each process will claim a single index block and will scan and return all tuples referenced by that block; other processes can at the same time be returning tuples from a different index block. The results of a parallel btree scan are returned in sorted order within each worker process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9434bbdc8aace98fbdb811c879672bca3c9b835e" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel sequential scan&lt;/em&gt;, the table's blocks will be divided among the cooperating processes. Blocks are handed out one at a time, so that access to the table remains sequential.</source>
          <target state="translated">При &lt;em&gt;параллельном последовательном сканировании&lt;/em&gt; блоки таблицы будут разделены между взаимодействующими процессами. Блоки выдаются по одному, поэтому доступ к таблице остается последовательным.</target>
        </trans-unit>
        <trans-unit id="f3fefb800e2db94c9c9a41bf996e2bc5c5260e63" translate="yes" xml:space="preserve">
          <source>In a B-tree leaf page, &lt;code&gt;ctid&lt;/code&gt; points to a heap tuple. In an internal page, the block number part of &lt;code&gt;ctid&lt;/code&gt; points to another page in the index itself, while the offset part (the second number) is ignored and is usually 1.</source>
          <target state="translated">На листовой странице B-дерева &lt;code&gt;ctid&lt;/code&gt; указывает на кортеж кучи. На внутренней странице часть номера блока в &lt;code&gt;ctid&lt;/code&gt; указывает на другую страницу в самом индексе, в то время как часть смещения (второе число) игнорируется и обычно равна 1.</target>
        </trans-unit>
        <trans-unit id="d0a6087a10f85c3bb150e6308e3861061574aa67" translate="yes" xml:space="preserve">
          <source>In a concurrent index build, the index is actually entered into the system catalogs in one transaction, then two table scans occur in two more transactions. Before each table scan, the index build must wait for existing transactions that have modified the table to terminate. After the second scan, the index build must wait for any transactions that have a snapshot (see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;) predating the second scan to terminate. Then finally the index can be marked ready for use, and the &lt;code&gt;CREATE INDEX&lt;/code&gt; command terminates. Even then, however, the index may not be immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build.</source>
          <target state="translated">При параллельном построении индекса индекс фактически вводится в системные каталоги за одну транзакцию, затем два сканирования таблицы выполняются еще в двух транзакциях. Перед каждым сканированием таблицы построение индекса должно ожидать завершения существующих транзакций, которые изменили таблицу. После второго сканирования построение индекса должно дождаться завершения любых транзакций, у которых есть моментальный снимок (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Главу 13&lt;/a&gt; ), предшествующий второму сканированию. Затем, наконец, индекс можно пометить как готовый к использованию, и команда &lt;code&gt;CREATE INDEX&lt;/code&gt; завершится. Однако даже в этом случае индекс не может быть немедленно использован для запросов: в худшем случае его нельзя использовать, пока существуют транзакции, предшествующие началу построения индекса.</target>
        </trans-unit>
        <trans-unit id="c15278182867851c1af83a8c951f5ef55e2fcbe1" translate="yes" xml:space="preserve">
          <source>In a concurrent index build, the index is actually entered into the system catalogs in one transaction, then two table scans occur in two more transactions. Before each table scan, the index build must wait for existing transactions that have modified the table to terminate. After the second scan, the index build must wait for any transactions that have a snapshot (see &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;) predating the second scan to terminate. Then finally the index can be marked ready for use, and the &lt;code&gt;CREATE INDEX&lt;/code&gt; command terminates. Even then, however, the index may not be immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a542d58c1d654f7da71e85731698e5120795a1" translate="yes" xml:space="preserve">
          <source>In a default installation, none of the above parameters are set explicitly. Instead, the data directory is specified by the &lt;code&gt;-D&lt;/code&gt; command-line option or the &lt;code&gt;PGDATA&lt;/code&gt; environment variable, and the configuration files are all found within the data directory.</source>
          <target state="translated">При установке по умолчанию ни один из вышеперечисленных параметров не задан явно. Вместо этого каталог данных указывается параметром командной строки &lt;code&gt;-D&lt;/code&gt; или переменной среды &lt;code&gt;PGDATA&lt;/code&gt; , и все файлы конфигурации находятся в каталоге данных.</target>
        </trans-unit>
        <trans-unit id="ade0e33e559fe0711e0dbe8eb460618e29475014" translate="yes" xml:space="preserve">
          <source>In a dropped column's &lt;code&gt;pg_attribute&lt;/code&gt; entry, &lt;code&gt;atttypid&lt;/code&gt; is reset to zero, but &lt;code&gt;attlen&lt;/code&gt; and the other fields copied from &lt;code&gt;pg_type&lt;/code&gt; are still valid. This arrangement is needed to cope with the situation where the dropped column's data type was later dropped, and so there is no &lt;code&gt;pg_type&lt;/code&gt; row anymore. &lt;code&gt;attlen&lt;/code&gt; and the other fields can be used to interpret the contents of a row of the table.</source>
          <target state="translated">В записи &lt;code&gt;atttypid&lt;/code&gt; отброшенного столбца &lt;code&gt;pg_attribute&lt;/code&gt; сбрасывается до нуля, но &lt;code&gt;attlen&lt;/code&gt; и другие поля, скопированные из &lt;code&gt;pg_type&lt;/code&gt; , остаются действительными. Такое расположение необходимо, чтобы справиться с ситуацией, когда тип данных отброшенного столбца был позже &lt;code&gt;pg_type&lt;/code&gt; , и поэтому строки pg_type больше нет. &lt;code&gt;attlen&lt;/code&gt; и другие поля могут использоваться для интерпретации содержимого строки таблицы.</target>
        </trans-unit>
        <trans-unit id="919410546242ad36460212f72d578356bff6291e" translate="yes" xml:space="preserve">
          <source>In a literal that has been determined to be &lt;code&gt;timestamp without time zone&lt;/code&gt;, PostgreSQL will silently ignore any time zone indication. That is, the resulting value is derived from the date/time fields in the input value, and is not adjusted for time zone.</source>
          <target state="translated">В литерале, который был определен как &lt;code&gt;timestamp without time zone&lt;/code&gt; , PostgreSQL будет молча игнорировать любое указание часового пояса. Таким образом, результирующее значение получается из полей даты / времени во входном значении и не корректируется по часовому поясу.</target>
        </trans-unit>
        <trans-unit id="fe8c5382c7df4fd888e297e6990fce336207e731" translate="yes" xml:space="preserve">
          <source>In a priority-based synchronous replication, the standbys whose names appear earlier in the list will be used as synchronous standbys. Standbys listed after these will take over the role of synchronous standby if one of current ones should fail.</source>
          <target state="translated">В синхронной репликации,основанной на приоритете,в качестве синхронных подставок будут использоваться подставки,имена которых появляются в списке ранее.Резервные устройства,перечисленные после них,возьмут на себя роль синхронных резервных устройств,если один из них в данный момент не работает.</target>
        </trans-unit>
        <trans-unit id="6be13ad3386e50cb4bfa2ce22e78dd04cec9a6ab" translate="yes" xml:space="preserve">
          <source>In a quorum-based synchronous replication, all the standbys appearing in the list will be used as candidates for synchronous standbys. Even if one of them should fail, the other standbys will keep performing the role of candidates of synchronous standby.</source>
          <target state="translated">При синхронной репликации,основанной на кворуме,все трибуны,появляющиеся в списке,будут использоваться в качестве кандидатов на синхронные трибуны.Даже если один из них выйдет из строя,остальные будут продолжать выполнять роль кандидатов на синхронный режим ожидания.</target>
        </trans-unit>
        <trans-unit id="a6cdb6331798b6847433d71683fa652dae3c0858" translate="yes" xml:space="preserve">
          <source>In a rule for &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; on a view, you can add a &lt;code&gt;RETURNING&lt;/code&gt; clause that emits the view's columns. This clause will be used to compute the outputs if the rule is triggered by an &lt;code&gt;INSERT RETURNING&lt;/code&gt;, &lt;code&gt;UPDATE RETURNING&lt;/code&gt;, or &lt;code&gt;DELETE RETURNING&lt;/code&gt; command respectively. When the rule is triggered by a command without &lt;code&gt;RETURNING&lt;/code&gt;, the rule's &lt;code&gt;RETURNING&lt;/code&gt; clause will be ignored. The current implementation allows only unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rules to contain &lt;code&gt;RETURNING&lt;/code&gt;; furthermore there can be at most one &lt;code&gt;RETURNING&lt;/code&gt; clause among all the rules for the same event. (This ensures that there is only one candidate &lt;code&gt;RETURNING&lt;/code&gt; clause to be used to compute the results.) &lt;code&gt;RETURNING&lt;/code&gt; queries on the view will be rejected if there is no &lt;code&gt;RETURNING&lt;/code&gt; clause in any available rule.</source>
          <target state="translated">В правиле для &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; для представления вы можете добавить предложение &lt;code&gt;RETURNING&lt;/code&gt; , которое генерирует столбцы представления. Это предложение будет использоваться для вычисления выходных данных, если правило запускается командами &lt;code&gt;INSERT RETURNING&lt;/code&gt; , &lt;code&gt;UPDATE RETURNING&lt;/code&gt; или &lt;code&gt;DELETE RETURNING&lt;/code&gt; соответственно. Когда правило запускаются командой без &lt;code&gt;RETURNING&lt;/code&gt; , в правиле &lt;code&gt;RETURNING&lt;/code&gt; пункт будет игнорироваться. Текущая реализация позволяет только безусловным правилам &lt;code&gt;INSTEAD&lt;/code&gt; содержать &lt;code&gt;RETURNING&lt;/code&gt; ; кроме того, может быть не более одного &lt;code&gt;RETURNING&lt;/code&gt; пункт среди всех правил для одного и того же события. (Это гарантирует, что существует только одно предложение &lt;code&gt;RETURNING&lt;/code&gt; - кандидата , которое будет использоваться для вычисления результатов.) Запросы &lt;code&gt;RETURNING&lt;/code&gt; для представления будут отклонены, если в любом доступном правиле нет предложения &lt;code&gt;RETURNING&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b30170def17c750dae562bb19e988c5bae9da5a7" translate="yes" xml:space="preserve">
          <source>In a simple join query, such as:</source>
          <target state="translated">В простом совместном запросе,например:</target>
        </trans-unit>
        <trans-unit id="3e1f4464d1af94cd74998edaeff888eee6d91174" translate="yes" xml:space="preserve">
          <source>In a standby server that exists primarily for high availability, it's best to set the delay parameters relatively short, so that the server cannot fall far behind the primary due to delays caused by standby queries. However, if the standby server is meant for executing long-running queries, then a high or even infinite delay value may be preferable. Keep in mind however that a long-running query could cause other sessions on the standby server to not see recent changes on the primary, if it delays application of WAL records.</source>
          <target state="translated">В резервном сервере,который существует в основном для высокой доступности,лучше всего устанавливать параметры задержки относительно коротко,чтобы сервер не мог сильно отставать от основного из-за задержек,вызванных резервными запросами.Однако,если резервный сервер предназначен для выполнения длительных запросов,то высокое или даже бесконечное значение задержки может быть предпочтительнее.Помните,однако,что длительный запрос может привести к тому,что другие сеансы на резервном сервере не увидят последних изменений на первичном,если это задержит применение записей WAL.</target>
        </trans-unit>
        <trans-unit id="0a9a7bd917eb1db2204b6427584eda8a4fd3adfe" translate="yes" xml:space="preserve">
          <source>In a table definition, default values are listed after the column data type. For example:</source>
          <target state="translated">В определении таблицы после типа данных столбца указываются значения по умолчанию.Например:</target>
        </trans-unit>
        <trans-unit id="ea0511eba225911c6d4bd1330fecc7bed6e9ecc3" translate="yes" xml:space="preserve">
          <source>In addition these settings can be preserved between reboots in the file &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;. Doing that is highly recommended.</source>
          <target state="translated">Кроме того, эти настройки могут быть сохранены между перезагрузками в файле &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; . Это настоятельно рекомендуется.</target>
        </trans-unit>
        <trans-unit id="096299b269c3119f5fd70cea143f131c4bf07844" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;postgresql.conf&lt;/code&gt;, a PostgreSQL data directory contains a file &lt;code&gt;postgresql.auto.conf&lt;/code&gt;, which has the same format as &lt;code&gt;postgresql.conf&lt;/code&gt; but is intended to be edited automatically, not manually. This file holds settings provided through the &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; command. This file is read whenever &lt;code&gt;postgresql.conf&lt;/code&gt; is, and its settings take effect in the same way. Settings in &lt;code&gt;postgresql.auto.conf&lt;/code&gt; override those in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">В дополнение к &lt;code&gt;postgresql.conf&lt;/code&gt; каталог данных PostgreSQL содержит файл &lt;code&gt;postgresql.auto.conf&lt;/code&gt; , который имеет тот же формат, что и &lt;code&gt;postgresql.conf&lt;/code&gt; , но предназначен для автоматического редактирования, а не вручную. Этот файл содержит настройки, предоставленные с помощью команды &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; . Этот файл читается всякий раз, когда &lt;code&gt;postgresql.conf&lt;/code&gt; , и его настройки действуют таким же образом. Настройки в &lt;code&gt;postgresql.auto.conf&lt;/code&gt; переопределяют настройки в &lt;code&gt;postgresql.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b72ebbfc32b5c7dc9d476e5e61c36ae4f704bc0" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;public&lt;/code&gt; and user-created schemas, each database contains a &lt;code&gt;pg_catalog&lt;/code&gt; schema, which contains the system tables and all the built-in data types, functions, and operators. &lt;code&gt;pg_catalog&lt;/code&gt; is always effectively part of the search path. If it is not named explicitly in the path then it is implicitly searched &lt;em&gt;before&lt;/em&gt; searching the path's schemas. This ensures that built-in names will always be findable. However, you can explicitly place &lt;code&gt;pg_catalog&lt;/code&gt; at the end of your search path if you prefer to have user-defined names override built-in names.</source>
          <target state="translated">В дополнение к &lt;code&gt;public&lt;/code&gt; и созданным пользователем схемам каждая база данных содержит схему &lt;code&gt;pg_catalog&lt;/code&gt; , которая содержит системные таблицы и все встроенные типы данных, функции и операторы. &lt;code&gt;pg_catalog&lt;/code&gt; всегда является частью пути поиска. Если он не назван явно в пути, то &lt;em&gt;перед&lt;/em&gt; поиском в схемах пути выполняется неявный поиск . Это гарантирует, что встроенные имена всегда можно будет найти. Однако вы можете явно разместить &lt;code&gt;pg_catalog&lt;/code&gt; в конце пути поиска, если вы предпочитаете, чтобы пользовательские имена переопределяли встроенные имена.</target>
        </trans-unit>
        <trans-unit id="f70bc34b6f3d01fe499b2933dfc1efba4688427d" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;standard_conforming_strings&lt;/code&gt;, the configuration parameters &lt;a href=&quot;runtime-config-compatible#GUC-ESCAPE-STRING-WARNING&quot;&gt;escape_string_warning&lt;/a&gt; and &lt;a href=&quot;runtime-config-compatible#GUC-BACKSLASH-QUOTE&quot;&gt;backslash_quote&lt;/a&gt; govern treatment of backslashes in string constants.</source>
          <target state="translated">В дополнение к &lt;code&gt;standard_conforming_strings&lt;/code&gt; параметры конфигурации &lt;a href=&quot;runtime-config-compatible#GUC-ESCAPE-STRING-WARNING&quot;&gt;escape_string_warning&lt;/a&gt; и &lt;a href=&quot;runtime-config-compatible#GUC-BACKSLASH-QUOTE&quot;&gt;backslash_quote&lt;/a&gt; управляют обработкой обратной косой черты в строковых константах.</target>
        </trans-unit>
        <trans-unit id="ca198320ff48380e299bcbd7319925ded5a95535" translate="yes" xml:space="preserve">
          <source>In addition to individual parameter settings, the &lt;code&gt;postgresql.conf&lt;/code&gt; file can contain &lt;em&gt;include directives&lt;/em&gt;, which specify another file to read and process as if it were inserted into the configuration file at this point. This feature allows a configuration file to be divided into physically separate parts. Include directives simply look like:</source>
          <target state="translated">В дополнение к настройкам отдельных параметров файл &lt;code&gt;postgresql.conf&lt;/code&gt; может содержать &lt;em&gt;директивы include&lt;/em&gt; , которые определяют другой файл для чтения и обработки, как если бы он был вставлен в файл конфигурации на этом этапе. Эта функция позволяет разделить файл конфигурации на физически отдельные части. Директивы Include выглядят просто так:</target>
        </trans-unit>
        <trans-unit id="e670e7bf52fa0455274db822ce4cd6907d528db9" translate="yes" xml:space="preserve">
          <source>In addition to ordinary numeric values, the &lt;code&gt;numeric&lt;/code&gt; type allows the special value &lt;code&gt;NaN&lt;/code&gt;, meaning &amp;ldquo;not-a-number&amp;rdquo;. Any operation on &lt;code&gt;NaN&lt;/code&gt; yields another &lt;code&gt;NaN&lt;/code&gt;. When writing this value as a constant in an SQL command, you must put quotes around it, for example &lt;code&gt;UPDATE table SET x = 'NaN'&lt;/code&gt;. On input, the string &lt;code&gt;NaN&lt;/code&gt; is recognized in a case-insensitive manner.</source>
          <target state="translated">В дополнение к обычным числовым значениям &lt;code&gt;numeric&lt;/code&gt; тип позволяет использовать специальное значение &lt;code&gt;NaN&lt;/code&gt; , что означает &amp;laquo;не число&amp;raquo;. Любая операция с &lt;code&gt;NaN&lt;/code&gt; дает еще одно &lt;code&gt;NaN&lt;/code&gt; . При записи этого значения как константы в команде SQL вы должны заключить его в кавычки, например, &lt;code&gt;UPDATE table SET x = 'NaN'&lt;/code&gt; . При вводе строка &lt;code&gt;NaN&lt;/code&gt; распознается без учета регистра.</target>
        </trans-unit>
        <trans-unit id="e4bbcc684e36efbca1c2d0b6de3932866401bc9a" translate="yes" xml:space="preserve">
          <source>In addition to ordinary numeric values, the floating-point types have several special values:</source>
          <target state="translated">Помимо обычных числовых значений,типы с плавающей точкой имеют несколько специальных значений:</target>
        </trans-unit>
        <trans-unit id="19311d87cac186ad5be7afccb28d88535be2bd00" translate="yes" xml:space="preserve">
          <source>In addition to setting global defaults or attaching overrides at the database or role level, you can pass settings to PostgreSQL via shell facilities. Both the server and libpq client library accept parameter values via the shell.</source>
          <target state="translated">В дополнение к установке глобальных настроек по умолчанию или прикреплению переопределений на уровне базы данных или ролей,вы можете передать настройки PostgreSQL через оболочку оболочки.Как сервер,так и клиентская библиотека libpq принимают значения параметров через оболочку.</target>
        </trans-unit>
        <trans-unit id="a22166b5786a29ccaf8b6526c1e48730c5b76cde" translate="yes" xml:space="preserve">
          <source>In addition to simply finding the rows to be returned by a query, an index may be able to deliver them in a specific sorted order. This allows a query's &lt;code&gt;ORDER BY&lt;/code&gt; specification to be honored without a separate sorting step. Of the index types currently supported by PostgreSQL, only B-tree can produce sorted output &amp;mdash; the other index types return matching rows in an unspecified, implementation-dependent order.</source>
          <target state="translated">Помимо простого поиска строк, возвращаемых запросом, индекс может доставлять их в определенном порядке сортировки. Это позволяет выполнять спецификацию &lt;code&gt;ORDER BY&lt;/code&gt; запроса без отдельного шага сортировки. Из типов индексов, поддерживаемых в настоящее время PostgreSQL, только B-дерево может производить отсортированный вывод - другие типы индексов возвращают совпадающие строки в неопределенном, зависящем от реализации порядке.</target>
        </trans-unit>
        <trans-unit id="4ba1e6913eefc780040c670e81ceade68f518709" translate="yes" xml:space="preserve">
          <source>In addition to supporting ordinary index scans, some types of index may wish to support &lt;em&gt;parallel index scans&lt;/em&gt;, which allow multiple backends to cooperate in performing an index scan. The index access method should arrange things so that each cooperating process returns a subset of the tuples that would be performed by an ordinary, non-parallel index scan, but in such a way that the union of those subsets is equal to the set of tuples that would be returned by an ordinary, non-parallel index scan. Furthermore, while there need not be any global ordering of tuples returned by a parallel scan, the ordering of that subset of tuples returned within each cooperating backend must match the requested ordering. The following functions may be implemented to support parallel index scans:</source>
          <target state="translated">Помимо поддержки обычных сканирований индекса, некоторые типы индексов могут захотеть поддерживать &lt;em&gt;параллельное сканирование индексов&lt;/em&gt; , что позволяет нескольким серверным процессам взаимодействовать при выполнении сканирования индекса. Метод доступа к индексу должен организовать вещи так, чтобы каждый взаимодействующий процесс возвращал подмножество кортежей, которое будет выполнено обычным непараллельным сканированием индекса, но таким образом, чтобы объединение этих подмножеств было равно набору кортежей. который будет возвращен обычным непараллельным сканированием индекса. Кроме того, хотя не требуется никакого глобального упорядочивания кортежей, возвращаемых параллельным сканированием, порядок этого подмножества кортежей, возвращаемых в каждом взаимодействующем бэкэнде, должен соответствовать запрошенному порядку. Следующие функции могут быть реализованы для поддержки параллельного сканирования индексов:</target>
        </trans-unit>
        <trans-unit id="2240e6efaaf6aaec400aa311d695b65a5cb9013d" translate="yes" xml:space="preserve">
          <source>In addition to table and row locks, page-level share/exclusive locks are used to control read/write access to table pages in the shared buffer pool. These locks are released immediately after a row is fetched or updated. Application developers normally need not be concerned with page-level locks, but they are mentioned here for completeness.</source>
          <target state="translated">В дополнение к блокировке таблиц и строк,для управления доступом к чтению/записи страниц таблицы в общем буферном пуле используются разделяемые/исключительные блокировки на уровне страниц.Эти блокировки освобождаются сразу же после получения или обновления строки.Разработчикам приложений обычно не нужно заботиться о блокировках на уровне страниц,но они упоминаются здесь для полноты.</target>
        </trans-unit>
        <trans-unit id="87509ac7479eedd6c62071274770036abf56ee4c" translate="yes" xml:space="preserve">
          <source>In addition to table-level locks, there are row-level locks, which are listed as below with the contexts in which they are used automatically by PostgreSQL. See &lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;Table 13.3&lt;/a&gt; for a complete table of row-level lock conflicts. Note that a transaction can hold conflicting locks on the same row, even in different subtransactions; but other than that, two transactions can never hold conflicting locks on the same row. Row-level locks do not affect data querying; they block only &lt;em&gt;writers and lockers&lt;/em&gt; to the same row.</source>
          <target state="translated">Помимо блокировок на уровне таблицы, существуют блокировки на уровне строк, которые перечислены ниже с контекстами, в которых они автоматически используются PostgreSQL. В &lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;Таблице 13.3&lt;/a&gt; приведена полная таблица конфликтов блокировок на уровне строк. Обратите внимание, что транзакция может удерживать конфликтующие блокировки в одной и той же строке даже в разных частичных транзакциях; но кроме этого, две транзакции никогда не могут удерживать конфликтующие блокировки в одной строке. Блокировки на уровне строк не влияют на запросы данных; они блокируют только &lt;em&gt;писатели и шкафчики&lt;/em&gt; в одной строке.</target>
        </trans-unit>
        <trans-unit id="af43dbc6cfa4c0067d413cdf9c6cdab394d34e58" translate="yes" xml:space="preserve">
          <source>In addition to table-level locks, there are row-level locks, which are listed as below with the contexts in which they are used automatically by PostgreSQL. See &lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;Table 13.3&lt;/a&gt; for a complete table of row-level lock conflicts. Note that a transaction can hold conflicting locks on the same row, even in different subtransactions; but other than that, two transactions can never hold conflicting locks on the same row. Row-level locks do not affect data querying; they block only &lt;em&gt;writers and lockers&lt;/em&gt; to the same row. Row-level locks are released at transaction end or during savepoint rollback, just like table-level locks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eefa082a90a01551ee9f7be83fe0ecef6e330ce1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;postgresql.conf&lt;/code&gt; file already mentioned, PostgreSQL uses two other manually-edited configuration files, which control client authentication (their use is discussed in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;). By default, all three configuration files are stored in the database cluster's data directory. The parameters described in this section allow the configuration files to be placed elsewhere. (Doing so can ease administration. In particular it is often easier to ensure that the configuration files are properly backed-up when they are kept separate.)</source>
          <target state="translated">Помимо уже упомянутого файла &lt;code&gt;postgresql.conf&lt;/code&gt; , PostgreSQL использует два других редактируемых вручную файла конфигурации, которые контролируют аутентификацию клиента (их использование обсуждается в &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;главе 20&lt;/a&gt; ). По умолчанию все три файла конфигурации хранятся в каталоге данных кластера базы данных. Параметры, описанные в этом разделе, позволяют размещать файлы конфигурации в другом месте. (Это может упростить администрирование. В частности, часто бывает проще обеспечить правильное резервное копирование файлов конфигурации, если они хранятся отдельно.)</target>
        </trans-unit>
        <trans-unit id="c048077d9e3551a271c60d45220784829e1b676a" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;postgresql.conf&lt;/code&gt; file already mentioned, PostgreSQL uses two other manually-edited configuration files, which control client authentication (their use is discussed in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;). By default, all three configuration files are stored in the database cluster's data directory. The parameters described in this section allow the configuration files to be placed elsewhere. (Doing so can ease administration. In particular it is often easier to ensure that the configuration files are properly backed-up when they are kept separate.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a5b24df3b5e27969bb36917a3a17ae8bb1189b" translate="yes" xml:space="preserve">
          <source>In addition to the SQL-standard &lt;a href=&quot;ddl-priv&quot;&gt;privilege system&lt;/a&gt; available through &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;, tables can have &lt;em&gt;row security policies&lt;/em&gt; that restrict, on a per-user basis, which rows can be returned by normal queries or inserted, updated, or deleted by data modification commands. This feature is also known as &lt;em&gt;Row-Level Security&lt;/em&gt;. By default, tables do not have any policies, so that if a user has access privileges to a table according to the SQL privilege system, all rows within it are equally available for querying or updating.</source>
          <target state="translated">В дополнение к стандартной &lt;a href=&quot;ddl-priv&quot;&gt;системе привилегий&lt;/a&gt; SQL, доступной через &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; , таблицы могут иметь &lt;em&gt;политики безопасности строк,&lt;/em&gt; которые ограничивают для каждого пользователя, какие строки могут быть возвращены обычными запросами или вставлены, обновлены или удалены командами изменения данных. Эта функция также известна как &lt;em&gt;безопасность на уровне строк&lt;/em&gt; . По умолчанию таблицы не имеют никаких политик, поэтому, если у пользователя есть права доступа к таблице в соответствии с системой привилегий SQL, все строки в ней одинаково доступны для запроса или обновления.</target>
        </trans-unit>
        <trans-unit id="d446f6389cb4793dfefdac41ed8ee8243d8cf0f3" translate="yes" xml:space="preserve">
          <source>In addition to the above operators, the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for type &lt;code&gt;cube&lt;/code&gt;. These operators first compare the first coordinates, and if those are equal, compare the second coordinates, etc. They exist mainly to support the b-tree index operator class for &lt;code&gt;cube&lt;/code&gt;, which can be useful for example if you would like a UNIQUE constraint on a &lt;code&gt;cube&lt;/code&gt; column. Otherwise, this ordering is not of much practical use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9f075e58ee1768924e20835361c077d43e9c97" translate="yes" xml:space="preserve">
          <source>In addition to the above operators, the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for type &lt;code&gt;seg&lt;/code&gt;. These operators first compare (a) to (c), and if these are equal, compare (b) to (d). That results in reasonably good sorting in most cases, which is useful if you want to use ORDER BY with this type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a68bf9280d646b1a85ebb074d2b6ecfecda3df" translate="yes" xml:space="preserve">
          <source>In addition to the format specifiers described above, the special sequence &lt;code&gt;%%&lt;/code&gt; may be used to output a literal &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">В дополнении к формату спецификаторы , описанные выше, специальная последовательность &lt;code&gt;%%&lt;/code&gt; может быть использован для вывода буквального &lt;code&gt;%&lt;/code&gt; характер.</target>
        </trans-unit>
        <trans-unit id="8bfea922b7478af1fb30846a7ffdd145169e7fe7" translate="yes" xml:space="preserve">
          <source>In addition to the functions listed in this section, there are a number of functions related to the statistics system that also provide system information. See &lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS&quot;&gt;Section 27.2.2&lt;/a&gt; for more information.</source>
          <target state="translated">Помимо функций, перечисленных в этом разделе, существует ряд функций, связанных со статистической системой, которые также предоставляют системную информацию. См &lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS&quot;&gt;Раздел 27.2.2&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="2dc53d9aa025a55feab0c728607a475dd6480573" translate="yes" xml:space="preserve">
          <source>In addition to the generic lookup mechanisms, there is a special convention that &lt;code&gt;PGNSP&lt;/code&gt; is replaced by the OID of the &lt;code&gt;pg_catalog&lt;/code&gt; schema, and &lt;code&gt;PGUID&lt;/code&gt; is replaced by the OID of the bootstrap superuser role. These usages are somewhat historical but so far there hasn't been a need to generalize them.</source>
          <target state="translated">В дополнение к общим механизмам поиска существует специальное соглашение, &lt;code&gt;PGNSP&lt;/code&gt; которому PGNSP заменяется OID схемы &lt;code&gt;pg_catalog&lt;/code&gt; , а &lt;code&gt;PGUID&lt;/code&gt; заменяется OID роли начального суперпользователя. Эти обычаи в некоторой степени исторические, но пока нет необходимости их обобщать.</target>
        </trans-unit>
        <trans-unit id="671caebf932d9cdddfa02cea4a21319996df3fc1" translate="yes" xml:space="preserve">
          <source>In addition to the main syntax described above, there are some special forms and miscellaneous syntactic facilities available.</source>
          <target state="translated">В дополнение к основному синтаксису,описанному выше,существуют некоторые специальные формы и различные синтаксические средства.</target>
        </trans-unit>
        <trans-unit id="cfdcb8c233fbe99bb0dea34235cb119f257b9a78" translate="yes" xml:space="preserve">
          <source>In addition to the method-specific options listed below, there is one method-independent authentication option &lt;code&gt;clientcert&lt;/code&gt;, which can be specified in any &lt;code&gt;hostssl&lt;/code&gt; record. This option can be set to &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;. Both options require the client to present a valid (trusted) SSL certificate, while &lt;code&gt;verify-full&lt;/code&gt; additionally enforces that the &lt;code&gt;cn&lt;/code&gt; (Common Name) in the certificate matches the username or an applicable mapping. This behavior is similar to the &lt;code&gt;cert&lt;/code&gt; authentication method (see &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt;) but enables pairing the verification of client certificates with any authentication method that supports &lt;code&gt;hostssl&lt;/code&gt; entries.</source>
          <target state="translated">В дополнение к параметрам, зависящим от метода, перечисленным ниже, существует одна независимая от метода опция аутентификации &lt;code&gt;clientcert&lt;/code&gt; , которую можно указать в любой записи &lt;code&gt;hostssl&lt;/code&gt; . Этот параметр может быть установлен на &lt;code&gt;verify-ca&lt;/code&gt; или &lt;code&gt;verify-full&lt;/code&gt; . Оба варианта требуют, чтобы клиент представил действительный (доверенный) SSL-сертификат, в то время как &lt;code&gt;verify-full&lt;/code&gt; дополнительно обеспечивает соответствие &lt;code&gt;cn&lt;/code&gt; (Common Name) в сертификате имени пользователя или применимому сопоставлению. Это поведение аналогично методу проверки подлинности &lt;code&gt;cert&lt;/code&gt; (см. &lt;a href=&quot;auth-cert&quot;&gt;Раздел 20.12&lt;/a&gt; ), но позволяет объединить проверку сертификатов клиентов с любым методом проверки подлинности, который поддерживает &lt;code&gt;hostssl&lt;/code&gt; . записи.</target>
        </trans-unit>
        <trans-unit id="ddf91010c34fa3b26374dd73b3df519e9da0fd2a" translate="yes" xml:space="preserve">
          <source>In addition to the operators shown in the table, the ordinary B-tree comparison operators (&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, etc) are defined for types &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;. These are not very useful for text searching but allow, for example, unique indexes to be built on columns of these types.</source>
          <target state="translated">В дополнение к операторам, показанным в таблице, для типов &lt;code&gt;tsvector&lt;/code&gt; и &lt;code&gt;tsquery&lt;/code&gt; определены обычные операторы сравнения B-дерева ( &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; и т.д.) . Они не очень полезны для поиска текста, но позволяют, например, создавать уникальные индексы для столбцов этих типов.</target>
        </trans-unit>
        <trans-unit id="31c46db92025ad200f49ee2517827b67ca69ce01" translate="yes" xml:space="preserve">
          <source>In addition to the socket file itself, which is named &lt;code&gt;.s.PGSQL.nnnn&lt;/code&gt; where &lt;code&gt;nnnn&lt;/code&gt; is the server's port number, an ordinary file named &lt;code&gt;.s.PGSQL.nnnn.lock&lt;/code&gt; will be created in each of the &lt;code&gt;unix_socket_directories&lt;/code&gt; directories. Neither file should ever be removed manually.</source>
          <target state="translated">В дополнение к самому файлу сокета, который называется &lt;code&gt;.s.PGSQL.nnnn&lt;/code&gt; , где &lt;code&gt;nnnn&lt;/code&gt; является номером порта сервера, обычный файл с именем &lt;code&gt;.s.PGSQL.nnnn.lock&lt;/code&gt; будет создан в каждом из &lt;code&gt;unix_socket_directories&lt;/code&gt; каталогов. Ни один файл никогда не следует удалять вручную.</target>
        </trans-unit>
        <trans-unit id="f961899526c4ec4b91a471972a05e3809476d8c4" translate="yes" xml:space="preserve">
          <source>In addition to the system catalogs, PostgreSQL provides a number of built-in views. Some system views provide convenient access to some commonly used queries on the system catalogs. Other views provide access to internal server state.</source>
          <target state="translated">В дополнение к системным каталогам PostgreSQL предоставляет ряд встроенных представлений.Некоторые системные представления обеспечивают удобный доступ к некоторым часто используемым запросам по системным каталогам.Другие представления обеспечивают доступ к состоянию внутреннего сервера.</target>
        </trans-unit>
        <trans-unit id="3e99de7dbe2b503398057fb045bf3c995d4ba6e3" translate="yes" xml:space="preserve">
          <source>In addition to the timezone names and abbreviations, PostgreSQL will accept POSIX-style time zone specifications of the form &lt;code&gt;STD&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;STD&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;DST&lt;/code&gt;, where &lt;code&gt;STD&lt;/code&gt; is a zone abbreviation, &lt;code&gt;offset&lt;/code&gt; is a numeric offset in hours west from UTC, and &lt;code&gt;DST&lt;/code&gt; is an optional daylight-savings zone abbreviation, assumed to stand for one hour ahead of the given offset. For example, if &lt;code&gt;EST5EDT&lt;/code&gt; were not already a recognized zone name, it would be accepted and would be functionally equivalent to United States East Coast time. In this syntax, a zone abbreviation can be a string of letters, or an arbitrary string surrounded by angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;). When a daylight-savings zone abbreviation is present, it is assumed to be used according to the same daylight-savings transition rules used in the IANA time zone database's &lt;code&gt;posixrules&lt;/code&gt; entry. In a standard PostgreSQL installation, &lt;code&gt;posixrules&lt;/code&gt; is the same as &lt;code&gt;US/Eastern&lt;/code&gt;, so that POSIX-style time zone specifications follow USA daylight-savings rules. If needed, you can adjust this behavior by replacing the &lt;code&gt;posixrules&lt;/code&gt; file.</source>
          <target state="translated">В дополнение к именам часовых поясов и сокращений, PostgreSQL будет принимать спецификации часовых поясов POSIX-стилевые формы &lt;code&gt;STD&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; или &lt;code&gt;STD&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;DST&lt;/code&gt; , где &lt;code&gt;STD&lt;/code&gt; является зона аббревиатура, &lt;code&gt;offset&lt;/code&gt; представляет собой числовое смещение в часах западу от UTC, и &lt;code&gt;DST&lt;/code&gt; является необязательное сокращение зоны перехода на летнее время, которое предполагается на один час раньше указанного смещения. Например, если &lt;code&gt;EST5EDT&lt;/code&gt; еще не был признанным именем зоны, оно будет принято и будет функционально эквивалентно времени Восточного побережья США. В этом синтаксисе аббревиатура зоны может быть строкой букв или произвольной строкой, заключенной в угловые скобки ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ). Когда присутствует аббревиатура зоны перехода на летнее время, предполагается, что она используется в соответствии с теми же правилами перехода на летнее время, которые используются в записи &lt;code&gt;posixrules&lt;/code&gt; базы данных часовых поясов IANA . В стандартной установке PostgreSQL &lt;code&gt;posixrules&lt;/code&gt; такие же, как &lt;code&gt;US/Eastern&lt;/code&gt; , поэтому спецификации часовых поясов в стиле POSIX соответствуют правилам перехода на летнее время в США. При необходимости вы можете изменить это поведение, заменив файл &lt;code&gt;posixrules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fea3b58443a344cc0a50c8d3b3c320b181f8be81" translate="yes" xml:space="preserve">
          <source>In addition to the timezone names and abbreviations, PostgreSQL will accept POSIX-style time zone specifications, as described in &lt;a href=&quot;datetime-posix-timezone-specs&quot;&gt;Section B.5&lt;/a&gt;. This option is not normally preferable to using a named time zone, but it may be necessary if no suitable IANA time zone entry is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5639f9b8e3c76507298cdef9442456212dc91a3a" translate="yes" xml:space="preserve">
          <source>In addition to the typical B-tree search operators, &lt;code&gt;btree_gist&lt;/code&gt; also provides index support for &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; (&amp;ldquo;not equals&amp;rdquo;). This may be useful in combination with an &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;exclusion constraint&lt;/a&gt;, as described below.</source>
          <target state="translated">В дополнение к типичным операторам поиска в B-дереве, &lt;code&gt;btree_gist&lt;/code&gt; также обеспечивает поддержку индекса для &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; (&amp;laquo;не равно&amp;raquo;). Это может быть полезно в сочетании с &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;ограничением исключения&lt;/a&gt; , как описано ниже.</target>
        </trans-unit>
        <trans-unit id="b7456acfa95fcaf383cf25fda8119cc53ab8322a" translate="yes" xml:space="preserve">
          <source>In addition to the usual (&lt;em&gt;tight&lt;/em&gt;) RE syntax, in which all characters are significant, there is an &lt;em&gt;expanded&lt;/em&gt; syntax, available by specifying the embedded &lt;code&gt;x&lt;/code&gt; option. In the expanded syntax, white-space characters in the RE are ignored, as are all characters between a &lt;code&gt;#&lt;/code&gt; and the following newline (or the end of the RE). This permits paragraphing and commenting a complex RE. There are three exceptions to that basic rule:</source>
          <target state="translated">В дополнение к обычному ( &lt;em&gt;плотному&lt;/em&gt; ) синтаксису RE, в котором все символы значимы, есть &lt;em&gt;расширенный&lt;/em&gt; синтаксис, доступный путем указания встроенной опции &lt;code&gt;x&lt;/code&gt; . В расширенном синтаксисе символы пробела в RE игнорируются, как и все символы между &lt;code&gt;#&lt;/code&gt; и следующей новой строкой (или концом RE). Это позволяет разбивать на абзацы и комментировать сложные RE. Из этого основного правила есть три исключения:</target>
        </trans-unit>
        <trans-unit id="da522f31f6ebf1b8a6e0efd3ead6600864945861" translate="yes" xml:space="preserve">
          <source>In addition to these facilities borrowed from &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt; supports these pattern-matching metacharacters borrowed from POSIX regular expressions:</source>
          <target state="translated">В дополнение к этим средствам, заимствованным из &lt;code&gt;LIKE&lt;/code&gt; , &lt;code&gt;SIMILAR TO&lt;/code&gt; поддерживает эти метасимволы сопоставления с образцом, заимствованные из регулярных выражений POSIX:</target>
        </trans-unit>
        <trans-unit id="d5ad168deb41cb8cd3104e11c297f4193822a79b" translate="yes" xml:space="preserve">
          <source>In addition to these functions, any built-in or user-defined general-purpose or statistical aggregate (i.e., not ordered-set or hypothetical-set aggregates) can be used as a window function; see &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt; for a list of the built-in aggregates. Aggregate functions act as window functions only when an &lt;code&gt;OVER&lt;/code&gt; clause follows the call; otherwise they act as non-window aggregates and return a single row for the entire set.</source>
          <target state="translated">В дополнение к этим функциям в качестве оконной функции может использоваться любой встроенный или определяемый пользователем агрегат общего назначения или статистический агрегат (т. Е. Агрегаты не упорядоченного набора или гипотетического набора); список встроенных агрегатов см. в &lt;a href=&quot;functions-aggregate&quot;&gt;Разделе 9.20&lt;/a&gt; . Агрегатные функции действуют как оконные только тогда, когда за вызовом следует предложение &lt;code&gt;OVER&lt;/code&gt; ; в противном случае они действуют как агрегаты без окон и возвращают одну строку для всего набора.</target>
        </trans-unit>
        <trans-unit id="ac449e0956beab252b7444b739cfec2b77010587" translate="yes" xml:space="preserve">
          <source>In addition to these functions, any built-in or user-defined ordinary aggregate (i.e., not ordered-set or hypothetical-set aggregates) can be used as a window function; see &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt; for a list of the built-in aggregates. Aggregate functions act as window functions only when an &lt;code&gt;OVER&lt;/code&gt; clause follows the call; otherwise they act as plain aggregates and return a single row for the entire set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b254c4c7b10faf7e76791fc77c4b40ffb55a623" translate="yes" xml:space="preserve">
          <source>In addition to these functions, the SQL &lt;code&gt;OVERLAPS&lt;/code&gt; operator is supported:</source>
          <target state="translated">В дополнение к этим функциям &lt;code&gt;OVERLAPS&lt;/code&gt; оператор SQL OVERLAPS :</target>
        </trans-unit>
        <trans-unit id="8ce6df37789f3f1d085846c8faae3d98a71b95bb" translate="yes" xml:space="preserve">
          <source>In addition to these specialized operators, the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for types &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;. These are not very useful for text searching but allow, for example, unique indexes to be built on columns of these types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918debfa135a3ee3b32c08e005bfe3898a987217" translate="yes" xml:space="preserve">
          <source>In addition to this list, there are a number of constructs that can be classified as an expression but do not follow any general syntax rules. These generally have the semantics of a function or operator and are explained in the appropriate location in &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. An example is the &lt;code&gt;IS NULL&lt;/code&gt; clause.</source>
          <target state="translated">В дополнение к этому списку существует ряд конструкций, которые можно классифицировать как выражения, но не подчиняются никаким общим правилам синтаксиса. Обычно они имеют семантику функции или оператора и объясняются в соответствующем месте &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;главы 9&lt;/a&gt; . Примером является предложение &lt;code&gt;IS NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81a1f6a58eced1ed99e15fcd136cfd9bbcd242dd" translate="yes" xml:space="preserve">
          <source>In addition to this list, there are a number of constructs that can be classified as an expression but do not follow any general syntax rules. These generally have the semantics of a function or operator and are explained in the appropriate location in &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. An example is the &lt;code&gt;IS NULL&lt;/code&gt; clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eea807026cd270d625f43d7ed3f99bcbf28a0f1" translate="yes" xml:space="preserve">
          <source>In addition, B-tree and hash indexes can be created for table columns of range types. For these index types, basically the only useful range operation is equality. There is a B-tree sort ordering defined for range values, with corresponding &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; operators, but the ordering is rather arbitrary and not usually useful in the real world. Range types' B-tree and hash support is primarily meant to allow sorting and hashing internally in queries, rather than creation of actual indexes.</source>
          <target state="translated">Кроме того, B-дерево и хеш-индексы могут быть созданы для столбцов таблицы типов диапазонов. Для этих типов индексов единственная полезная операция диапазона - это равенство. Для значений диапазона определен порядок сортировки B-дерева с соответствующими операторами &lt;code&gt;&amp;lt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&lt;/code&gt; , но порядок сортировки довольно произвольный и обычно не используется в реальном мире. Поддержка B-дерева и хеширования типов диапазонов в первую очередь предназначена для внутренней сортировки и хеширования в запросах, а не для создания реальных индексов.</target>
        </trans-unit>
        <trans-unit id="ec168afc08cf14d67db79d5a556441966649b178" translate="yes" xml:space="preserve">
          <source>In addition, GIN must have a way to sort the key values stored in the index. The operator class can define the sort ordering by specifying a comparison method:</source>
          <target state="translated">Кроме того,GIN должен иметь возможность сортировать значения ключей,хранящихся в индексе.Класс оператора может определить порядок сортировки,указав метод сравнения:</target>
        </trans-unit>
        <trans-unit id="9f602065328e166c6745869bc0a8f779ad09a07b" translate="yes" xml:space="preserve">
          <source>In addition, PostgreSQL provides the &lt;code&gt;text&lt;/code&gt; type, which stores strings of any length. Although the type &lt;code&gt;text&lt;/code&gt; is not in the SQL standard, several other SQL database management systems have it as well.</source>
          <target state="translated">Кроме того, PostgreSQL предоставляет &lt;code&gt;text&lt;/code&gt; тип, в котором хранятся строки любой длины. Хотя &lt;code&gt;text&lt;/code&gt; типа не входит в стандарт SQL, он также есть в нескольких других системах управления базами данных SQL.</target>
        </trans-unit>
        <trans-unit id="17853e1fa32c480ecb510d4ac68c8ac2c772dace" translate="yes" xml:space="preserve">
          <source>In addition, a &lt;code&gt;cube&lt;/code&gt; GiST index can be used to find nearest neighbors using the metric operators &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;#&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; in &lt;code&gt;ORDER BY&lt;/code&gt; clauses. For example, the nearest neighbor of the 3-D point (0.5, 0.5, 0.5) could be found efficiently with:</source>
          <target state="translated">Кроме того, &lt;code&gt;cube&lt;/code&gt; индекс GiST можно использовать для поиска ближайших соседей с помощью метрических операторов &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;#&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; в предложениях &lt;code&gt;ORDER BY&lt;/code&gt; . Например, ближайшего соседа трехмерной точки (0,5, 0,5, 0,5) можно эффективно найти с помощью:</target>
        </trans-unit>
        <trans-unit id="cd5ace0daf0d94ba630977ad9ab486e9b148c9ae" translate="yes" xml:space="preserve">
          <source>In addition, any range type that is meant to be used with GiST or SP-GiST indexes should define a subtype difference, or &lt;code&gt;subtype_diff&lt;/code&gt;, function. (The index will still work without &lt;code&gt;subtype_diff&lt;/code&gt;, but it is likely to be considerably less efficient than if a difference function is provided.) The subtype difference function takes two input values of the subtype, and returns their difference (i.e., &lt;code&gt;X&lt;/code&gt; minus &lt;code&gt;Y&lt;/code&gt;) represented as a &lt;code&gt;float8&lt;/code&gt; value. In our example above, the function &lt;code&gt;float8mi&lt;/code&gt; that underlies the regular &lt;code&gt;float8&lt;/code&gt; minus operator can be used; but for any other subtype, some type conversion would be necessary. Some creative thought about how to represent differences as numbers might be needed, too. To the greatest extent possible, the &lt;code&gt;subtype_diff&lt;/code&gt; function should agree with the sort ordering implied by the selected operator class and collation; that is, its result should be positive whenever its first argument is greater than its second according to the sort ordering.</source>
          <target state="translated">Кроме того, любой тип диапазона, который предназначен для использования с индексами GiST или SP-GiST, должен определять функцию различия подтипов или &lt;code&gt;subtype_diff&lt;/code&gt; . (Индекс по-прежнему будет работать без &lt;code&gt;subtype_diff&lt;/code&gt; , но, вероятно, будет значительно менее эффективным, чем если бы была предоставлена ​​функция различия.) Функция различия подтипов принимает два входных значения подтипа и возвращает их разницу (т. Е. &lt;code&gt;X&lt;/code&gt; минус &lt;code&gt;Y&lt;/code&gt; ) представлен как значение &lt;code&gt;float8&lt;/code&gt; . В нашем примере выше функция &lt;code&gt;float8mi&lt;/code&gt; , лежащая в основе обычного &lt;code&gt;float8&lt;/code&gt; можно использовать оператор минус; но для любого другого подтипа потребуется некоторое преобразование типа. Также может потребоваться некоторая творческая мысль о том, как представить различия в виде чисел. В максимально возможной &lt;code&gt;subtype_diff&lt;/code&gt; функция subtype_diff должна согласовываться с порядком сортировки, подразумеваемым выбранным классом оператора и сопоставлением; то есть его результат должен быть положительным всякий раз, когда его первый аргумент больше второго в соответствии с порядком сортировки.</target>
        </trans-unit>
        <trans-unit id="f89a62ed614652316ac7f29133e1961a27612ba6" translate="yes" xml:space="preserve">
          <source>In addition, it is possible to cast integral values to and from type &lt;code&gt;bit&lt;/code&gt;. Casting an integer to &lt;code&gt;bit(n)&lt;/code&gt; copies the rightmost &lt;code&gt;n&lt;/code&gt; bits. Casting an integer to a bit string width wider than the integer itself will sign-extend on the left. Some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64cf011fc0c858e7c59c2382a3c5f7cd4046f0f4" translate="yes" xml:space="preserve">
          <source>In addition, it is possible to cast integral values to and from type &lt;code&gt;bit&lt;/code&gt;. Some examples:</source>
          <target state="translated">Кроме того, можно приводить целые значения к типу &lt;code&gt;bit&lt;/code&gt; и от него . Некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="326abf040e9ce0b0f36784412502b6466458ab9f" translate="yes" xml:space="preserve">
          <source>In addition, the following functions are available to produce analogous mappings of entire schemas or the entire current database:</source>
          <target state="translated">Кроме того,доступны следующие функции для создания аналоговых отображений целых схем или всей текущей базы данных:</target>
        </trans-unit>
        <trans-unit id="63461f5526d594ea86f45b63caca8ffcfa146455" translate="yes" xml:space="preserve">
          <source>In addition, the system must not be running in single-user mode. Since the entire database system is running in single process in this situation, no background workers will be available.</source>
          <target state="translated">Кроме того,система не должна работать в однопользовательском режиме.Так как в этой ситуации вся система базы данных работает в однопользовательском режиме,никаких фоновых сотрудников не будет.</target>
        </trans-unit>
        <trans-unit id="860432a001dab9d2b568ed0f1f81316664226bda" translate="yes" xml:space="preserve">
          <source>In addition, the system view &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; can be used to view and change session-local values:</source>
          <target state="translated">Кроме того, системное представление &lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt; можно использовать для просмотра и изменения локальных значений сеанса:</target>
        </trans-unit>
        <trans-unit id="22f9e194dfe6bf7349c8ee21bf8580964a36a952" translate="yes" xml:space="preserve">
          <source>In addition, triggers may be defined to fire for &lt;code&gt;TRUNCATE&lt;/code&gt;, though only &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt;.</source>
          <target state="translated">Кроме того, могут быть определены триггеры для срабатывания &lt;code&gt;TRUNCATE&lt;/code&gt; , но только &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4414e8f828cfe6654891bf2913265775446349f" translate="yes" xml:space="preserve">
          <source>In addition, when the data in the referenced columns is changed, certain actions are performed on the data in this table's columns. The &lt;code&gt;ON DELETE&lt;/code&gt; clause specifies the action to perform when a referenced row in the referenced table is being deleted. Likewise, the &lt;code&gt;ON UPDATE&lt;/code&gt; clause specifies the action to perform when a referenced column in the referenced table is being updated to a new value. If the row is updated, but the referenced column is not actually changed, no action is done. Referential actions other than the &lt;code&gt;NO ACTION&lt;/code&gt; check cannot be deferred, even if the constraint is declared deferrable. There are the following possible actions for each clause:</source>
          <target state="translated">Кроме того, когда данные в указанных столбцах изменяются, определенные действия выполняются с данными в столбцах этой таблицы. Предложение &lt;code&gt;ON DELETE&lt;/code&gt; определяет действие, выполняемое при удалении указанной строки в указанной таблице. Точно так же предложение &lt;code&gt;ON UPDATE&lt;/code&gt; определяет действие, которое необходимо выполнить, когда столбец, на который указывает ссылка, в указанной таблице обновляется до нового значения. Если строка обновлена, но столбец, на который указывает ссылка, фактически не изменился, никаких действий не выполняется. Ссылочные действия, кроме проверки &lt;code&gt;NO ACTION&lt;/code&gt; , нельзя отложить, даже если ограничение объявлено откладываемым. Для каждого пункта возможны следующие действия:</target>
        </trans-unit>
        <trans-unit id="1b40467991cf35c44406fccb1f30c153b6ab6d3c" translate="yes" xml:space="preserve">
          <source>In addition, you can define your own range types; see &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; for more information.</source>
          <target state="translated">Кроме того, вы можете определять свои собственные типы диапазонов; см. &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="b2973b0fbaf7ec1930d4939e2d5982623781db68" translate="yes" xml:space="preserve">
          <source>In addition, you can find rows where the array has all values equal to 10000 with:</source>
          <target state="translated">Кроме того,можно найти строки,в которых все значения массива равны 10000:</target>
        </trans-unit>
        <trans-unit id="0f950ca6f038e5a1c55d020b4e0e3f34ce9c10d7" translate="yes" xml:space="preserve">
          <source>In all binary operations on differently-dimensioned cubes, I assume the lower-dimensional one to be a Cartesian projection, i. e., having zeroes in place of coordinates omitted in the string representation. The above examples are equivalent to:</source>
          <target state="translated">Во всех бинарных операциях над разноразмерными кубами я предполагаю,что нижнеразмерная является декартовой проекцией,т.е.имеет нули вместо координат,опущенных в строковом представлении.Приведенные выше примеры эквивалентны:</target>
        </trans-unit>
        <trans-unit id="c1f9a66372442ec0201db0ed9f98b148d01d359a" translate="yes" xml:space="preserve">
          <source>In all but the simplest applications, there are various combinations of indexes that might be useful, and the database developer must make trade-offs to decide which indexes to provide. Sometimes multicolumn indexes are best, but sometimes it's better to create separate indexes and rely on the index-combination feature. For example, if your workload includes a mix of queries that sometimes involve only column &lt;code&gt;x&lt;/code&gt;, sometimes only column &lt;code&gt;y&lt;/code&gt;, and sometimes both columns, you might choose to create two separate indexes on &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, relying on index combination to process the queries that use both columns. You could also create a multicolumn index on &lt;code&gt;(x, y)&lt;/code&gt;. This index would typically be more efficient than index combination for queries involving both columns, but as discussed in &lt;a href=&quot;indexes-multicolumn&quot;&gt;Section 11.3&lt;/a&gt;, it would be almost useless for queries involving only &lt;code&gt;y&lt;/code&gt;, so it should not be the only index. A combination of the multicolumn index and a separate index on &lt;code&gt;y&lt;/code&gt; would serve reasonably well. For queries involving only &lt;code&gt;x&lt;/code&gt;, the multicolumn index could be used, though it would be larger and hence slower than an index on &lt;code&gt;x&lt;/code&gt; alone. The last alternative is to create all three indexes, but this is probably only reasonable if the table is searched much more often than it is updated and all three types of query are common. If one of the types of query is much less common than the others, you'd probably settle for creating just the two indexes that best match the common types.</source>
          <target state="translated">Во всех приложениях, кроме простейших, существуют различные комбинации индексов, которые могут быть полезны, и разработчик базы данных должен идти на компромисс, чтобы решить, какие индексы предоставить. Иногда лучше использовать многоколоночные индексы, но иногда лучше создавать отдельные индексы и полагаться на функцию комбинирования индексов. Например, если ваша рабочая нагрузка включает сочетание запросов, которые иногда включают только столбец &lt;code&gt;x&lt;/code&gt; , иногда только столбец &lt;code&gt;y&lt;/code&gt; , а иногда и оба столбца, вы можете создать два отдельных индекса по &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , полагаясь на комбинацию индексов для обработки запросов, которые используйте оба столбца. Вы также можете создать многоколоночный индекс для &lt;code&gt;(x, y)&lt;/code&gt; . Этот индекс обычно будет более эффективным, чем комбинация индексов для запросов, включающих оба столбца, но, как обсуждалось в &lt;a href=&quot;indexes-multicolumn&quot;&gt;Разделе 11.3&lt;/a&gt; , он был бы почти бесполезен для запросов, включающих только &lt;code&gt;y&lt;/code&gt; , поэтому он не должен быть единственным индексом. Достаточно хорошо подойдет комбинация многоколоночного индекса и отдельного индекса по &lt;code&gt;y&lt;/code&gt; . Для запросов, включающих только &lt;code&gt;x&lt;/code&gt; , можно использовать многоколоночный индекс, хотя он будет больше и, следовательно, медленнее, чем индекс по &lt;code&gt;x&lt;/code&gt; в одиночестве. Последней альтернативой является создание всех трех индексов, но это, вероятно, имеет смысл только в том случае, если поиск в таблице выполняется гораздо чаще, чем обновляется, и все три типа запросов являются общими. Если один из типов запросов встречается гораздо реже, чем другие, вы, вероятно, согласитесь создать только два индекса, которые лучше всего соответствуют распространенным типам.</target>
        </trans-unit>
        <trans-unit id="56df2ff3801249dc12f58c24112c401131ecca16" translate="yes" xml:space="preserve">
          <source>In all cases, a &lt;code&gt;pg_depend&lt;/code&gt; entry indicates that the referenced object cannot be dropped without also dropping the dependent object. However, there are several subflavors identified by &lt;code&gt;deptype&lt;/code&gt;:</source>
          <target state="translated">Во всех случаях запись &lt;code&gt;pg_depend&lt;/code&gt; указывает, что объект, на который имеется ссылка, нельзя отбросить без удаления зависимого объекта. Однако есть несколько подобластей, идентифицируемых по &lt;code&gt;deptype&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05533c0a7856fcfbbc14bb309ca83a1575bf0034" translate="yes" xml:space="preserve">
          <source>In all cases, a &lt;code&gt;pg_shdepend&lt;/code&gt; entry indicates that the referenced object cannot be dropped without also dropping the dependent object. However, there are several subflavors identified by &lt;code&gt;deptype&lt;/code&gt;:</source>
          <target state="translated">Во всех случаях запись &lt;code&gt;pg_shdepend&lt;/code&gt; указывает, что объект, на который имеется ссылка, нельзя отбросить, не отбросив также и зависимый объект. Однако есть несколько подобластей, идентифицируемых по &lt;code&gt;deptype&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dbd9abe4557bc81e394c2c9fabde17d6899807f9" translate="yes" xml:space="preserve">
          <source>In all cases, the &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node will have exactly one child plan, which is the portion of the plan that will be executed in parallel. If the &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node is at the very top of the plan tree, then the entire query will execute in parallel. If it is somewhere else in the plan tree, then only the portion of the plan below it will run in parallel. In the example above, the query accesses only one table, so there is only one plan node other than the &lt;code&gt;Gather&lt;/code&gt; node itself; since that plan node is a child of the &lt;code&gt;Gather&lt;/code&gt; node, it will run in parallel.</source>
          <target state="translated">Во всех случаях узел &lt;code&gt;Gather&lt;/code&gt; или &lt;code&gt;Gather Merge&lt;/code&gt; будет иметь ровно один дочерний план, который является частью плана, который будет выполняться параллельно. Если узел &lt;code&gt;Gather&lt;/code&gt; или &lt;code&gt;Gather Merge&lt;/code&gt; находится на самом верху дерева плана, то весь запрос будет выполняться параллельно. Если он находится где-то еще в дереве плана, то только часть плана под ним будет выполняться параллельно. В приведенном выше примере запрос обращается только к одной таблице, поэтому есть только один узел плана, кроме самого узла &lt;code&gt;Gather&lt;/code&gt; ; поскольку этот узел плана является дочерним по отношению к узлу &lt;code&gt;Gather&lt;/code&gt; , он будет работать параллельно.</target>
        </trans-unit>
        <trans-unit id="d4cf1068a339ca5023c2d3ccdb75130df4a1abc8" translate="yes" xml:space="preserve">
          <source>In all cases, the UTC offset associated with a timestamp can be specified explicitly, using either a numeric UTC offset or a time zone abbreviation that corresponds to a fixed UTC offset. The rule just given applies only when it is necessary to infer a UTC offset for a time zone in which the offset varies.</source>
          <target state="translated">Во всех случаях UTC-смещение,связанное с меткой времени,может быть указано явно,используя либо числовое UTC-смещение,либо аббревиатуру часового пояса,которая соответствует фиксированному UTC-смещению.Только что данное правило применяется только в том случае,когда необходимо сделать вывод о UTC-смещении для часового пояса,в котором это смещение изменяется.</target>
        </trans-unit>
        <trans-unit id="14ea16f2c03b44cd074521f1c44532d0da377b9a" translate="yes" xml:space="preserve">
          <source>In all cases, timezone names and abbreviations are recognized case-insensitively. (This is a change from PostgreSQL versions prior to 8.2, which were case-sensitive in some contexts but not others.)</source>
          <target state="translated">Во всех случаях названия часовых поясов и аббревиатуры распознаются без учета регистра.(Это изменение по сравнению с версиями PostgreSQL до 8.2,которые в некоторых контекстах были чувствительны к регистру,но не в других).</target>
        </trans-unit>
        <trans-unit id="e488767cd28888258245f00283eb8b0744ce50a3" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;ADD FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function. For B-tree comparison functions and hash functions it is not necessary to specify &lt;code&gt;op_type&lt;/code&gt; since the function's input data type(s) are always the correct ones to use. For B-tree sort support functions and all functions in GiST, SP-GiST and GIN operator classes, it is necessary to specify the operand data type(s) the function is to be used with.</source>
          <target state="translated">В предложении &lt;code&gt;ADD FUNCTION&lt;/code&gt; - тип (ы) данных операнда, поддерживаемый функцией, если он отличается от типа (ов) входных данных функции. Для функций сравнения B-дерева и хэш-функций необязательно указывать &lt;code&gt;op_type&lt;/code&gt; , поскольку тип (ы) входных данных функции всегда являются правильными для использования. Для функций поддержки сортировки B-дерева и всех функций в классах операторов GiST, SP-GiST и GIN необходимо указать тип (ы) данных операнда, с которыми должна использоваться функция.</target>
        </trans-unit>
        <trans-unit id="6fcb4d0603695c9c5c79f801a2ccda42d2230338" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;ADD FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function. For B-tree comparison functions and hash functions it is not necessary to specify &lt;code&gt;op_type&lt;/code&gt; since the function's input data type(s) are always the correct ones to use. For B-tree sort support functions, B-Tree equal image functions, and all functions in GiST, SP-GiST and GIN operator classes, it is necessary to specify the operand data type(s) the function is to be used with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe60e9f5f727af57aa7582cb64633b2e4aa0e193" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;AFTER&lt;/code&gt; trigger, the &lt;code&gt;WHEN&lt;/code&gt; condition is evaluated just after the row update occurs, and it determines whether an event is queued to fire the trigger at the end of statement. So when an &lt;code&gt;AFTER&lt;/code&gt; trigger's &lt;code&gt;WHEN&lt;/code&gt; condition does not return true, it is not necessary to queue an event nor to re-fetch the row at end of statement. This can result in significant speedups in statements that modify many rows, if the trigger only needs to be fired for a few of the rows.</source>
          <target state="translated">В триггере &lt;code&gt;AFTER&lt;/code&gt; условие &lt;code&gt;WHEN&lt;/code&gt; оценивается сразу после обновления строки и определяет, стоит ли событие в очереди для запуска триггера в конце оператора. Поэтому, когда условие &lt;code&gt;WHEN&lt;/code&gt; триггера &lt;code&gt;AFTER&lt;/code&gt; не возвращает true, нет необходимости ставить событие в очередь или повторно получать строку в конце оператора. Это может привести к значительному ускорению выполнения операторов, изменяющих множество строк, если триггер нужно активировать только для нескольких строк.</target>
        </trans-unit>
        <trans-unit id="9e75cc4e94385e5f68a8354a430b322f15ebd9bc" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;INSERT&lt;/code&gt; command, if &lt;code&gt;ALWAYS&lt;/code&gt; is selected, a user-specified value is only accepted if the &lt;code&gt;INSERT&lt;/code&gt; statement specifies &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt;. If &lt;code&gt;BY DEFAULT&lt;/code&gt; is selected, then the user-specified value takes precedence. See &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; for details. (In the &lt;code&gt;COPY&lt;/code&gt; command, user-specified values are always used regardless of this setting.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d94f7fbda5ba6b714c8d7012a6a4025037bb6e" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;INSERT&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as it was inserted. This is not so useful in trivial inserts, since it would just repeat the data provided by the client. But it can be very handy when relying on computed default values. For example, when using a &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;&lt;code&gt;serial&lt;/code&gt;&lt;/a&gt; column to provide unique identifiers, &lt;code&gt;RETURNING&lt;/code&gt; can return the ID assigned to a new row:</source>
          <target state="translated">В &lt;code&gt;INSERT&lt;/code&gt; данные, доступные для &lt;code&gt;RETURNING&lt;/code&gt; , - это строка, в которой она была вставлена. Это не так полезно в тривиальных вставках, так как просто повторяет данные, предоставленные клиентом. Но это может быть очень удобно, если полагаться на вычисленные значения по умолчанию. Например, при использовании &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt; &lt;code&gt;serial&lt;/code&gt; &lt;/a&gt; столбца для предоставления уникальных идентификаторов &lt;code&gt;RETURNING&lt;/code&gt; может вернуть идентификатор, присвоенный новой строке:</target>
        </trans-unit>
        <trans-unit id="1b88536e851b3251cb15ede193475eddbb40caec" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;OPERATOR&lt;/code&gt; clause, the operand data type(s) of the operator, or &lt;code&gt;NONE&lt;/code&gt; to signify a left-unary or right-unary operator. The operand data types can be omitted in the normal case where they are the same as the operator class's data type.</source>
          <target state="translated">В предложении &lt;code&gt;OPERATOR&lt;/code&gt; - тип (ы) данных операнда оператора или &lt;code&gt;NONE&lt;/code&gt; для обозначения унарного слева или справа унарного оператора. Типы данных операндов можно опустить в обычном случае, если они совпадают с типом данных класса оператора.</target>
        </trans-unit>
        <trans-unit id="3136757e2f5b87e470c589e7ef9c299933261292" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;OPERATOR&lt;/code&gt; clause, the operand data type(s) of the operator, or &lt;code&gt;NONE&lt;/code&gt; to signify a left-unary or right-unary operator. Unlike the comparable syntax in &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt;, the operand data types must always be specified.</source>
          <target state="translated">В предложении &lt;code&gt;OPERATOR&lt;/code&gt; - тип (ы) данных операнда оператора или &lt;code&gt;NONE&lt;/code&gt; для обозначения унарного слева или справа унарного оператора. В отличие от аналогичного синтаксиса в &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; , типы данных операндов должны быть указаны всегда.</target>
        </trans-unit>
        <trans-unit id="ec2c43425fabe719ab28338af92c22c87b424e40" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;UPDATE&lt;/code&gt; command, if &lt;code&gt;ALWAYS&lt;/code&gt; is selected, any update of the column to any value other than &lt;code&gt;DEFAULT&lt;/code&gt; will be rejected. If &lt;code&gt;BY DEFAULT&lt;/code&gt; is selected, the column can be updated normally. (There is no &lt;code&gt;OVERRIDING&lt;/code&gt; clause for the &lt;code&gt;UPDATE&lt;/code&gt; command.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f4865a4556be6b18a0efd231e79cc53e7a18167" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;UPDATE&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the new content of the modified row. For example:</source>
          <target state="translated">В &lt;code&gt;UPDATE&lt;/code&gt; данные, доступные для &lt;code&gt;RETURNING&lt;/code&gt; , - это новое содержимое измененной строки. Например:</target>
        </trans-unit>
        <trans-unit id="a9d42b6946ae8752c916da7ef8c706a7f5db4d3a" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;amgetbitmap&lt;/code&gt; index scan, the access method does not keep an index pin on any of the returned tuples. Therefore it is only safe to use such scans with MVCC-compliant snapshots.</source>
          <target state="translated">При &lt;code&gt;amgetbitmap&lt;/code&gt; индекса amgetbitmap метод доступа не сохраняет индексный контакт ни в одном из возвращенных кортежей. Поэтому безопасно использовать такое сканирование только со снимками состояния, совместимыми с MVCC.</target>
        </trans-unit>
        <trans-unit id="565ae755fcf3f7ba63623b03ac7404b46ed4ecef" translate="yes" xml:space="preserve">
          <source>In an abstract sense, a running PostgreSQL system produces an indefinitely long sequence of WAL records. The system physically divides this sequence into WAL &lt;em&gt;segment files&lt;/em&gt;, which are normally 16MB apiece (although the segment size can be altered during initdb). The segment files are given numeric names that reflect their position in the abstract WAL sequence. When not using WAL archiving, the system normally creates just a few segment files and then &amp;ldquo;recycles&amp;rdquo; them by renaming no-longer-needed segment files to higher segment numbers. It's assumed that segment files whose contents precede the last checkpoint are no longer of interest and can be recycled.</source>
          <target state="translated">В абстрактном смысле работающая система PostgreSQL производит неограниченно длинную последовательность записей WAL. Система физически разделяет эту последовательность на &lt;em&gt;файлы сегментов&lt;/em&gt; WAL , размер которых обычно составляет 16 МБ (хотя размер сегмента можно изменить во время initdb). Файлы сегментов получают числовые имена, которые отражают их положение в абстрактной последовательности WAL. Если архивирование WAL не используется, система обычно создает всего несколько файлов сегментов, а затем &amp;laquo;перерабатывает&amp;raquo; их, переименовывая ненужные файлы сегментов в сегменты с более высокими номерами. Предполагается, что файлы сегментов, содержимое которых предшествует последней контрольной точке, больше не представляют интереса и могут быть переработаны.</target>
        </trans-unit>
        <trans-unit id="f8ac0a1e1d2b4929b34c74cce531be5f95182b00" translate="yes" xml:space="preserve">
          <source>In an exclusive backup, &lt;code&gt;pg_stop_backup&lt;/code&gt; removes the label file and, if it exists, the &lt;code&gt;tablespace_map&lt;/code&gt; file created by &lt;code&gt;pg_start_backup&lt;/code&gt;. In a non-exclusive backup, the contents of the &lt;code&gt;backup_label&lt;/code&gt; and &lt;code&gt;tablespace_map&lt;/code&gt; are returned in the result of the function, and should be written to files in the backup (and not in the data directory). There is an optional second parameter of type &lt;code&gt;boolean&lt;/code&gt;. If false, the &lt;code&gt;pg_stop_backup&lt;/code&gt; will return immediately after the backup is completed without waiting for WAL to be archived. This behavior is only useful for backup software which independently monitors WAL archiving. Otherwise, WAL required to make the backup consistent might be missing and make the backup useless. When this parameter is set to true, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait for WAL to be archived when archiving is enabled; on the standby, this means that it will wait only when &lt;code&gt;archive_mode = always&lt;/code&gt;. If write activity on the primary is low, it may be useful to run &lt;code&gt;pg_switch_wal&lt;/code&gt; on the primary in order to trigger an immediate segment switch.</source>
          <target state="translated">В эксклюзивной резервной копии &lt;code&gt;pg_stop_backup&lt;/code&gt; удаляет файл метки и, если он существует, файл &lt;code&gt;tablespace_map&lt;/code&gt; , созданный &lt;code&gt;pg_start_backup&lt;/code&gt; . В неисключительном резервном копировании содержимое &lt;code&gt;backup_label&lt;/code&gt; и &lt;code&gt;tablespace_map&lt;/code&gt; возвращается в результате функции и должно быть записано в файлы в резервной копии (а не в каталог данных). Есть необязательный второй параметр типа &lt;code&gt;boolean&lt;/code&gt; . Если false, &lt;code&gt;pg_stop_backup&lt;/code&gt; вернется сразу после завершения резервного копирования, не дожидаясь архивации WAL. Такое поведение полезно только для программного обеспечения резервного копирования, которое независимо контролирует архивирование WAL. В противном случае WAL, необходимый для обеспечения согласованности резервной копии, может отсутствовать и сделать резервную копию бесполезной. Если для этого параметра установлено значение true, &lt;code&gt;pg_stop_backup&lt;/code&gt; будет ждать, пока WAL будет заархивирован, когда архивирование включено; в режиме ожидания это означает, что он будет ждать только тогда, когда &lt;code&gt;archive_mode = always&lt;/code&gt; . Если активность записи на первичном &lt;code&gt;pg_switch_wal&lt;/code&gt; низка, может быть полезно запустить pg_switch_wal на первичном, чтобы немедленно запустить переключение сегмента.</target>
        </trans-unit>
        <trans-unit id="e7db342c2003b24a0078e3f7501e15f251fcabd3" translate="yes" xml:space="preserve">
          <source>In an index scan, the index access method is responsible for regurgitating the TIDs of all the tuples it has been told about that match the &lt;em&gt;scan keys&lt;/em&gt;. The access method is &lt;em&gt;not&lt;/em&gt; involved in actually fetching those tuples from the index's parent table, nor in determining whether they pass the scan's visibility test or other conditions.</source>
          <target state="translated">При сканировании индекса метод доступа к индексу отвечает за регургитацию TID всех кортежей, которые, как ему было сказано, совпадают с &lt;em&gt;ключами сканирования&lt;/em&gt; . Метод доступа &lt;em&gt;не&lt;/em&gt; участвует ни в фактическом извлечении этих кортежей из родительской таблицы индекса, ни в определении того, проходят ли они проверку видимости сканирования или другие условия.</target>
        </trans-unit>
        <trans-unit id="2aea61eca91fb7f3cae5718d047d4ef52faf5a35" translate="yes" xml:space="preserve">
          <source>In an internal page (not shown), the block number part of &lt;code&gt;ctid&lt;/code&gt; is a &amp;ldquo;downlink&amp;rdquo;, which is a block number of another page in the index itself. The offset part (the second number) of &lt;code&gt;ctid&lt;/code&gt; stores encoded information about the tuple, such as the number of columns present (suffix truncation may have removed unneeded suffix columns). Truncated columns are treated as having the value &amp;ldquo;minus infinity&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28fd11104e5b0da0e35b4fc535d8db587de4795" translate="yes" xml:space="preserve">
          <source>In an unmodified installation, the file &lt;code&gt;Default&lt;/code&gt; contains all the non-conflicting time zone abbreviations for most of the world. Additional files &lt;code&gt;Australia&lt;/code&gt; and &lt;code&gt;India&lt;/code&gt; are provided for those regions: these files first include the &lt;code&gt;Default&lt;/code&gt; file and then add or modify abbreviations as needed.</source>
          <target state="translated">В немодифицированной установке файл &lt;code&gt;Default&lt;/code&gt; содержит все неконфликтующие сокращения часовых поясов для большинства стран мира. Для этих регионов предусмотрены дополнительные файлы &lt;code&gt;Australia&lt;/code&gt; и &lt;code&gt;India&lt;/code&gt; : эти файлы сначала включают файл по &lt;code&gt;Default&lt;/code&gt; а затем при необходимости добавляют или изменяют сокращения.</target>
        </trans-unit>
        <trans-unit id="f4e4ae3ee0675010eaef475c4b41d41082a6a6e7" translate="yes" xml:space="preserve">
          <source>In any case, if a recovery target is configured but the archive recovery ends before the target is reached, the server will shut down with a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6faf2b1db0e643ecf8d471d0c7a2c045089265e3" translate="yes" xml:space="preserve">
          <source>In any case, the distance to the end of the frame is limited by the distance to the end of the partition, so that for rows near the partition ends the frame might contain fewer rows than elsewhere.</source>
          <target state="translated">В любом случае,расстояние до конца рамки ограничивается расстоянием до конца простенка,так что для строк,расположенных рядом с концами простенка,рамка может содержать меньше строк,чем в других местах.</target>
        </trans-unit>
        <trans-unit id="25a8baad62a92191ed853f5bfffb689d16144b1a" translate="yes" xml:space="preserve">
          <source>In archive recovery or standby mode, the server periodically performs &lt;em&gt;restartpoints&lt;/em&gt;, which are similar to checkpoints in normal operation: the server forces all its state to disk, updates the &lt;code&gt;pg_control&lt;/code&gt; file to indicate that the already-processed WAL data need not be scanned again, and then recycles any old log segment files in the &lt;code&gt;pg_wal&lt;/code&gt; directory. Restartpoints can't be performed more frequently than checkpoints in the master because restartpoints can only be performed at checkpoint records. A restartpoint is triggered when a checkpoint record is reached if at least &lt;code&gt;checkpoint_timeout&lt;/code&gt; seconds have passed since the last restartpoint, or if WAL size is about to exceed &lt;code&gt;max_wal_size&lt;/code&gt;. However, because of limitations on when a restartpoint can be performed, &lt;code&gt;max_wal_size&lt;/code&gt; is often exceeded during recovery, by up to one checkpoint cycle's worth of WAL. (&lt;code&gt;max_wal_size&lt;/code&gt; is never a hard limit anyway, so you should always leave plenty of headroom to avoid running out of disk space.)</source>
          <target state="translated">В режиме восстановления архива или в режиме ожидания сервер периодически выполняет точки &lt;em&gt;перезапуска&lt;/em&gt; , которые аналогичны контрольным точкам при нормальной работе: сервер &lt;code&gt;pg_control&lt;/code&gt; все свое состояние на диск, обновляет файл pg_control, чтобы указать, что уже обработанные данные WAL не нужно сканировать снова, а затем перерабатывает все старые файлы сегментов журнала в каталоге &lt;code&gt;pg_wal&lt;/code&gt; . Точки перезапуска не могут выполняться чаще, чем контрольные точки на главном сервере, потому что точки перезапуска могут выполняться только в записях контрольных точек. Точка перезапуска запускается при достижении записи контрольной точки, если с момента последней точки перезапуска прошло не менее &lt;code&gt;checkpoint_timeout&lt;/code&gt; секунд или если размер WAL вот-вот превысит &lt;code&gt;max_wal_size&lt;/code&gt; . Однако из-за ограничений на то, когда может быть выполнена &lt;code&gt;max_wal_size&lt;/code&gt; , max_wal_size часто превышается во время восстановления на величину WAL до одного цикла контрольной точки. ( &lt;code&gt;max_wal_size&lt;/code&gt; в любом случае никогда не является жестким пределом, поэтому вы всегда должны оставлять достаточно места, чтобы избежать нехватки места на диске.)</target>
        </trans-unit>
        <trans-unit id="e983613b50e43472d70dff9ae2842d52027c35fe" translate="yes" xml:space="preserve">
          <source>In autocommit-off mode, you must explicitly abandon any failed transaction by entering &lt;code&gt;ABORT&lt;/code&gt; or &lt;code&gt;ROLLBACK&lt;/code&gt;. Also keep in mind that if you exit the session without committing, your work will be lost.</source>
          <target state="translated">В режиме автоматической фиксации вы должны явно отказаться от любой неудачной транзакции, введя &lt;code&gt;ABORT&lt;/code&gt; или &lt;code&gt;ROLLBACK&lt;/code&gt; . Также имейте в виду, что если вы выйдете из сеанса без фиксации, ваша работа будет потеряна.</target>
        </trans-unit>
        <trans-unit id="b247fa1a8bf50d6b99053c3d0eeaa42c7ba06baa" translate="yes" xml:space="preserve">
          <source>In both cases, the current row of &lt;code&gt;inventory_item&lt;/code&gt; is passed to the function as a single composite-valued argument. Even though &lt;code&gt;.*&lt;/code&gt; does nothing in such cases, using it is good style, since it makes clear that a composite value is intended. In particular, the parser will consider &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;c.*&lt;/code&gt; to refer to a table name or alias, not to a column name, so that there is no ambiguity; whereas without &lt;code&gt;.*&lt;/code&gt;, it is not clear whether &lt;code&gt;c&lt;/code&gt; means a table name or a column name, and in fact the column-name interpretation will be preferred if there is a column named &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">В обоих случаях текущая строка &lt;code&gt;inventory_item&lt;/code&gt; передается функции как один аргумент с составным значением. Несмотря на то, что &lt;code&gt;.*&lt;/code&gt; Ничего не делает в таких случаях, его использование является хорошим стилем, поскольку ясно дает понять, что предполагается составное значение. В частности, синтаксический анализатор будет рассматривать &lt;code&gt;c&lt;/code&gt; в &lt;code&gt;c.*&lt;/code&gt; Для ссылки на имя или псевдоним таблицы, а не на имя столбца, чтобы не было двусмысленности; тогда как без &lt;code&gt;.*&lt;/code&gt; неясно, означает ли &lt;code&gt;c&lt;/code&gt; имя таблицы или имя столбца, и фактически интерпретация имени столбца будет предпочтительнее, если есть столбец с именем &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f76739639f03e7f45a4a9297ea3a846e096a82c7" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">В случае затруднений см. &lt;a href=&quot;sql-cluster&quot;&gt;КЛАСТЕР&lt;/a&gt; и &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; для обсуждения потенциальных проблем и сообщений об ошибках. Сервер базы данных должен работать на целевом хосте. Кроме того, будут применяться любые настройки подключения по умолчанию и переменные среды, используемые интерфейсной библиотекой libpq.</target>
        </trans-unit>
        <trans-unit id="5db2bd59ec0063d8b571ff86647485295dec81a2" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">В случае затруднений см. &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; и &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; для обсуждения потенциальных проблем и сообщений об ошибках. Сервер базы данных должен работать на целевом хосте. Кроме того, будут применяться любые настройки подключения по умолчанию и переменные среды, используемые интерфейсной библиотекой libpq.</target>
        </trans-unit>
        <trans-unit id="9ba5e7fcf43f6a46fa23c849e18652c98a11d276" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">В случае возникновения проблем см. &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; и &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; для обсуждения потенциальных проблем и сообщений об ошибках. Сервер базы данных должен работать на целевом хосте. Кроме того, будут применяться любые настройки подключения по умолчанию и переменные среды, используемые интерфейсной библиотекой libpq.</target>
        </trans-unit>
        <trans-unit id="6eaaf99e6c52738ae42a85a2ea51714fc0796916" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">В случае затруднений см. &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; и &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; для обсуждения потенциальных проблем и сообщений об ошибках. Сервер базы данных должен работать на целевом хосте. Кроме того, будут применяться любые настройки подключения по умолчанию и переменные среды, используемые интерфейсной библиотекой libpq.</target>
        </trans-unit>
        <trans-unit id="94b403e1d0cfae4a4d06e5a4c5a48eb222d916e0" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">В случае затруднений см. &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; и &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; для обсуждения потенциальных проблем и сообщений об ошибках. Сервер базы данных должен работать на целевом хосте. Кроме того, будут применяться любые настройки подключения по умолчанию и переменные среды, используемые интерфейсной библиотекой libpq.</target>
        </trans-unit>
        <trans-unit id="e7c380013a6560b8ccf88c49ec21236d61ed865e" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">В случае затруднений см. &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; и &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; для обсуждения потенциальных проблем и сообщений об ошибках. Сервер базы данных должен работать на целевом хосте. Кроме того, будут применяться любые настройки подключения по умолчанию и переменные среды, используемые интерфейсной библиотекой libpq.</target>
        </trans-unit>
        <trans-unit id="a390aa69b768b09463593395199c846120ecabb8" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">В случае возникновения затруднений см. &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; и &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; для обсуждения потенциальных проблем и сообщений об ошибках. Сервер базы данных должен работать на целевом хосте. Кроме того, будут применяться любые настройки подключения по умолчанию и переменные среды, используемые интерфейсной библиотекой libpq.</target>
        </trans-unit>
        <trans-unit id="2030ab1905e77cb31a87a361f54b214bc88ef0f8" translate="yes" xml:space="preserve">
          <source>In case of multiple inheritance, if one parent column is a generated column, then all parent columns must be generated columns and with the same expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93f46ad3e6977f8b4097e1a0c73d806eccff9805" translate="yes" xml:space="preserve">
          <source>In cases where you are accessing single rows randomly within a table, the actual order of the data in the table is unimportant. However, if you tend to access some data more than others, and there is an index that groups them together, you will benefit from using &lt;code&gt;CLUSTER&lt;/code&gt;. If you are requesting a range of indexed values from a table, or a single indexed value that has multiple rows that match, &lt;code&gt;CLUSTER&lt;/code&gt; will help because once the index identifies the table page for the first row that matches, all other rows that match are probably already on the same table page, and so you save disk accesses and speed up the query.</source>
          <target state="translated">В случаях, когда вы произвольно обращаетесь к отдельным строкам в таблице, фактический порядок данных в таблице не имеет значения. Однако, если вы склонны обращаться к одним данным больше, чем к другим, и есть индекс, который группирует их вместе, вам будет полезно использовать &lt;code&gt;CLUSTER&lt;/code&gt; . Если вы запрашиваете диапазон индексированных значений из таблицы или одно индексированное значение, которое имеет несколько совпадающих строк, &lt;code&gt;CLUSTER&lt;/code&gt; поможет, потому что, как только индекс идентифицирует страницу таблицы для первой совпадающей строки, все остальные совпадающие строки, вероятно, будут уже на той же странице таблицы, поэтому вы сохраняете доступ к диску и ускоряете запрос.</target>
        </trans-unit>
        <trans-unit id="74c2cf6ed852f4b751c92fd9888cb548968dc00d" translate="yes" xml:space="preserve">
          <source>In certain cases using advisory locking methods, especially in queries involving explicit ordering and &lt;code&gt;LIMIT&lt;/code&gt; clauses, care must be taken to control the locks acquired because of the order in which SQL expressions are evaluated. For example:</source>
          <target state="translated">В некоторых случаях, когда используются рекомендательные методы блокировки, особенно в запросах, включающих явное упорядочение и предложения &lt;code&gt;LIMIT&lt;/code&gt; , необходимо соблюдать осторожность, чтобы контролировать полученные блокировки из-за порядка, в котором вычисляются выражения SQL. Например:</target>
        </trans-unit>
        <trans-unit id="a44c40b70d09319f4150cf272b9356e9931bfa6f" translate="yes" xml:space="preserve">
          <source>In combination with the &lt;code&gt;convert_from&lt;/code&gt; function, this function can be used to read a text file in a specified encoding and convert to the database's encoding:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c672c01926d5e97ed50c99a3d3247bc55643b756" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, &lt;code&gt;SELECT INTO&lt;/code&gt; does not allow to specify properties like a table's access method with &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-METHOD&quot;&gt;&lt;code&gt;USING method&lt;/code&gt;&lt;/a&gt; or the table's tablespace with &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-TABLESPACE&quot;&gt;&lt;code&gt;TABLESPACE tablespace_name&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;sql-createtableas&quot;&gt;CREATE TABLE AS&lt;/a&gt; if necessary. Therefore, the default table access method is chosen for the new table. See &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt; for more information.</source>
          <target state="translated">В отличие от &lt;code&gt;CREATE TABLE AS&lt;/code&gt; , &lt;code&gt;SELECT INTO&lt;/code&gt; не позволяет указывать такие свойства, как метод доступа к таблице с методом &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-METHOD&quot;&gt; &lt;code&gt;USING method&lt;/code&gt; &lt;/a&gt; или табличное пространство таблицы с &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-TABLESPACE&quot;&gt; &lt;code&gt;TABLESPACE tablespace_name&lt;/code&gt; &lt;/a&gt; . При необходимости используйте &lt;a href=&quot;sql-createtableas&quot;&gt;CREATE TABLE AS&lt;/a&gt; . Поэтому для новой таблицы выбирается метод доступа к таблице по умолчанию. См. &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;Default_table_access_method&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="61279093682c79c9f5568d5da222628b6973c973" translate="yes" xml:space="preserve">
          <source>In contrast to a &lt;code&gt;setval&lt;/code&gt; call, a &lt;code&gt;RESTART&lt;/code&gt; operation on a sequence is transactional and blocks concurrent transactions from obtaining numbers from the same sequence. If that's not the desired mode of operation, &lt;code&gt;setval&lt;/code&gt; should be used.</source>
          <target state="translated">В отличие от вызова &lt;code&gt;setval&lt;/code&gt; , операция &lt;code&gt;RESTART&lt;/code&gt; над последовательностью является транзакционной и блокирует одновременные транзакции от получения чисел из той же последовательности. Если это не желаемый режим работы, следует использовать &lt;code&gt;setval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8047479f58f45c6933e1e0d8cbc566b58e46ed0" translate="yes" xml:space="preserve">
          <source>In database jargon, PostgreSQL uses a client/server model. A PostgreSQL session consists of the following cooperating processes (programs):</source>
          <target state="translated">На жаргоне БД PostgreSQL использует модель клиент/сервер.Сессия PostgreSQL состоит из следующих взаимодействующих процессов (программ):</target>
        </trans-unit>
        <trans-unit id="4ebcdbe0c3b4b06ac68e78641d8a5ee88bcf9f9b" translate="yes" xml:space="preserve">
          <source>In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. (Note that checkpoints, which are managed by a separate, dedicated auxiliary process, are unaffected.) The default value is 100 buffers. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">В каждом раунде фоновый писатель записывает не более указанного количества буферов. Установка этого значения в ноль отключает фоновую запись. (Обратите внимание, что контрольные точки, которыми управляет отдельный, выделенный вспомогательный процесс, не затрагиваются.) Значение по умолчанию - 100 буферов. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="ccd9c3c470f6cf3a148b1b2c45132bef7b97eb77" translate="yes" xml:space="preserve">
          <source>In either case the data to be encrypted is processed as follows:</source>
          <target state="translated">В любом случае,шифрованные данные обрабатываются следующим образом:</target>
        </trans-unit>
        <trans-unit id="306aa7e6b40f133245f13ca709da9e87be03e6ed" translate="yes" xml:space="preserve">
          <source>In either input mode, if you type a semicolon that is not just before or part of a command entry terminator, it is considered a command separator. When you do type a command entry terminator, the multiple statements you've entered will be executed as a single transaction.</source>
          <target state="translated">В любом режиме ввода,если вы вводите точку с запятой,которая не является точкой с запятой перед или частью терминатора ввода команды,она считается разделителем команд.Когда Вы набираете терминатор ввода команды,несколько введенных Вами операторов будут выполняться как одна транзакция.</target>
        </trans-unit>
        <trans-unit id="52ebde367582fd620a8c225e745609692ba01e89" translate="yes" xml:space="preserve">
          <source>In either notation, parameters that have default values given in the function declaration need not be written in the call at all. But this is particularly useful in named notation, since any combination of parameters can be omitted; while in positional notation parameters can only be omitted from right to left.</source>
          <target state="translated">В любой нотации параметры,которые имеют значения по умолчанию,заданные в объявлении функции,вообще не нужно записывать при вызове.Но это особенно полезно в именованной нотации,так как любая комбинация параметров может быть опущена,в то время как в позиционной нотации параметры могут быть опущены только справа налево.</target>
        </trans-unit>
        <trans-unit id="d831af293a1db32dece4f56906f01bbc94d110b4" translate="yes" xml:space="preserve">
          <source>In fact all the options that can be applied to a column description in &lt;code&gt;CREATE TABLE&lt;/code&gt; can be used here. Keep in mind however that the default value must satisfy the given constraints, or the &lt;code&gt;ADD&lt;/code&gt; will fail. Alternatively, you can add constraints later (see below) after you've filled in the new column correctly.</source>
          <target state="translated">Фактически, здесь можно использовать все параметры, которые можно применить к описанию столбца в &lt;code&gt;CREATE TABLE&lt;/code&gt; . Однако имейте в виду, что значение по умолчанию должно удовлетворять заданным ограничениям, иначе &lt;code&gt;ADD&lt;/code&gt; не удастся. Кроме того, вы можете добавить ограничения позже (см. Ниже) после того, как правильно заполните новый столбец.</target>
        </trans-unit>
        <trans-unit id="783e59eb801df832fa056e21e4887ace28a8cded" translate="yes" xml:space="preserve">
          <source>In file system terms, a database cluster is a single directory under which all data will be stored. We call this the &lt;em&gt;data directory&lt;/em&gt; or &lt;em&gt;data area&lt;/em&gt;. It is completely up to you where you choose to store your data. There is no default, although locations such as &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; or &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; are popular. The data directory must be initialized before being used, using the program &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; which is installed with PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5989a14e7d9d5d4126144b5b3e9ac84c1a4ebc4b" translate="yes" xml:space="preserve">
          <source>In file system terms, a database cluster is a single directory under which all data will be stored. We call this the &lt;em&gt;data directory&lt;/em&gt; or &lt;em&gt;data area&lt;/em&gt;. It is completely up to you where you choose to store your data. There is no default, although locations such as &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; or &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; are popular. To initialize a database cluster, use the command &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;, which is installed with PostgreSQL. The desired file system location of your database cluster is indicated by the &lt;code&gt;-D&lt;/code&gt; option, for example:</source>
          <target state="translated">С точки зрения файловой системы кластер базы данных - это единый каталог, в котором будут храниться все данные. Мы называем это &lt;em&gt;каталогом &lt;/em&gt;&lt;em&gt;данных&lt;/em&gt; или &lt;em&gt;областью данных&lt;/em&gt; . Выбор места для хранения данных полностью зависит от вас. По умолчанию нет, хотя популярны такие места, как &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; или &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; . Для инициализации кластера базы данных используйте команду &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; , которая устанавливается вместе с PostgreSQL. Желаемое расположение файловой системы кластера базы данных указывается параметром &lt;code&gt;-D&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="c6dec459ff41edebdbf286e5c7e7fa61bacc87ff" translate="yes" xml:space="preserve">
          <source>In general it is unsafe to access tables referenced in rebuild scripts until the rebuild scripts have run to completion; doing so could yield incorrect results or poor performance. Tables not referenced in rebuild scripts can be accessed immediately.</source>
          <target state="translated">В целом небезопасно получать доступ к таблицам,на которые ссылаются в скриптах реконструкции,до тех пор,пока скрипты реконструкции не завершат свою работу;это может привести к неправильным результатам или низкой производительности.К таблицам,на которые нет ссылок в сценариях реконструкции,можно получить доступ немедленно.</target>
        </trans-unit>
        <trans-unit id="d3d408ce8d9c6617962a7ddfab014057b11931d1" translate="yes" xml:space="preserve">
          <source>In general the array &lt;code&gt;expression&lt;/code&gt; must be parenthesized, but the parentheses can be omitted when the expression to be subscripted is just a column reference or positional parameter. Also, multiple subscripts can be concatenated when the original array is multidimensional. For example:</source>
          <target state="translated">Как правило, &lt;code&gt;expression&lt;/code&gt; массива должно быть заключено в круглые скобки, но скобки можно опустить, если индексируемое выражение является просто ссылкой на столбец или позиционным параметром. Кроме того, несколько индексов могут быть объединены, если исходный массив является многомерным. Например:</target>
        </trans-unit>
        <trans-unit id="a233c74a23b1b0f950c13008071a2c4108299433" translate="yes" xml:space="preserve">
          <source>In general the row &lt;code&gt;expression&lt;/code&gt; must be parenthesized, but the parentheses can be omitted when the expression to be selected from is just a table reference or positional parameter. For example:</source>
          <target state="translated">Как правило, &lt;code&gt;expression&lt;/code&gt; строки должно быть заключено в круглые скобки, но скобки можно опустить, когда выбираемое выражение является просто ссылкой на таблицу или позиционным параметром. Например:</target>
        </trans-unit>
        <trans-unit id="8c0b63d62e29b9c5a3a626356a3b517fe18e88f9" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;amcheck&lt;/code&gt; can only prove the presence of corruption; it cannot prove its absence.</source>
          <target state="translated">В общем, &lt;code&gt;amcheck&lt;/code&gt; может доказать только наличие коррупции; он не может доказать его отсутствие.</target>
        </trans-unit>
        <trans-unit id="9e2bc9fd37cc10d6d4e2c0ce13c42250e4fbbee6" translate="yes" xml:space="preserve">
          <source>In general, a unique constraint is violated if there is more than one row in the table where the values of all of the columns included in the constraint are equal. However, two null values are never considered equal in this comparison. That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns. This behavior conforms to the SQL standard, but we have heard that other SQL databases might not follow this rule. So be careful when developing applications that are intended to be portable.</source>
          <target state="translated">В общем случае,уникальное ограничение нарушается,если в таблице присутствует более одной строки,где значения всех столбцов,входящих в ограничение,равны.Однако при таком сравнении два нулевых значения никогда не считаются равными.Это означает,что даже при наличии уникального ограничения можно хранить дубликаты строк,которые содержат нулевое значение хотя бы в одном из ограниченных столбцов.Такое поведение соответствует стандарту SQL,но мы слышали,что другие базы данных SQL могут не следовать этому правилу.Поэтому будьте осторожны при разработке приложений,которые предназначены для переноски.</target>
        </trans-unit>
        <trans-unit id="2348b93b2ef61033a339bed35843085ef2b630c2" translate="yes" xml:space="preserve">
          <source>In general, if a function is labeled as being safe when it is restricted or unsafe, or if it is labeled as being restricted when it is in fact unsafe, it may throw errors or produce wrong answers when used in a parallel query. C-language functions could in theory exhibit totally undefined behavior if mislabeled, since there is no way for the system to protect itself against arbitrary C code, but in most likely cases the result will be no worse than for any other function. If in doubt, it is probably best to label functions as &lt;code&gt;UNSAFE&lt;/code&gt;.</source>
          <target state="translated">В общем, если функция помечена как безопасная, когда она ограничена или небезопасна, или если она помечена как ограниченная, когда она на самом деле небезопасна, она может вызывать ошибки или давать неправильные ответы при использовании в параллельном запросе. Теоретически функции языка C могут демонстрировать полностью неопределенное поведение при неправильной маркировке, поскольку система не может защитить себя от произвольного кода C, но в наиболее вероятных случаях результат будет не хуже, чем для любой другой функции. В случае сомнений, вероятно, лучше обозначить функции как &lt;code&gt;UNSAFE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7edd5220f4e78ad60a17c1f93de6471bf8d5e1f" translate="yes" xml:space="preserve">
          <source>In general, if a table is grouped, columns that are not listed in &lt;code&gt;GROUP BY&lt;/code&gt; cannot be referenced except in aggregate expressions. An example with aggregate expressions is:</source>
          <target state="translated">Как правило, если таблица сгруппирована, на столбцы, не перечисленные в &lt;code&gt;GROUP BY&lt;/code&gt; , нельзя ссылаться, кроме как в агрегатных выражениях. Пример с агрегатными выражениями:</target>
        </trans-unit>
        <trans-unit id="d1c3c9f3417fc6beedd0acdb2d294853319e6a73" translate="yes" xml:space="preserve">
          <source>In general, log shipping between servers running different major PostgreSQL release levels is not possible. It is the policy of the PostgreSQL Global Development Group not to make changes to disk formats during minor release upgrades, so it is likely that running different minor release levels on primary and standby servers will work successfully. However, no formal support for that is offered and you are advised to keep primary and standby servers at the same release level as much as possible. When updating to a new minor release, the safest policy is to update the standby servers first &amp;mdash; a new minor release is more likely to be able to read WAL files from a previous minor release than vice versa.</source>
          <target state="translated">Как правило, доставка журналов между серверами, на которых работают разные основные уровни выпуска PostgreSQL, невозможна. Политика глобальной группы разработчиков PostgreSQL заключается в том, чтобы не вносить изменения в форматы дисков во время обновлений второстепенных выпусков, поэтому вполне вероятно, что запуск разных уровней второстепенных выпусков на основном и резервном серверах будет работать успешно. Однако формальная поддержка для этого не предлагается, и вам рекомендуется как можно чаще поддерживать основной и резервный серверы на одном уровне выпуска. При обновлении до нового второстепенного выпуска самая безопасная политика - сначала обновить резервные серверы - новый второстепенный выпуск с большей вероятностью сможет читать файлы WAL из предыдущего второстепенного выпуска, чем наоборот.</target>
        </trans-unit>
        <trans-unit id="379f9f035821f16216f7bd05e1c59664a2c062ce" translate="yes" xml:space="preserve">
          <source>In general, most applications should prefer to store JSON data as &lt;code&gt;jsonb&lt;/code&gt;, unless there are quite specialized needs, such as legacy assumptions about ordering of object keys.</source>
          <target state="translated">В общем, большинство приложений должны предпочесть хранить данные JSON как &lt;code&gt;jsonb&lt;/code&gt; , если нет достаточно специализированных требований, таких как устаревшие предположения о порядке ключей объектов.</target>
        </trans-unit>
        <trans-unit id="b5f07f22b350f8a6e38078060fd0e008a551cf3e" translate="yes" xml:space="preserve">
          <source>In general, refer to the documentation of a specific module for the recommended way to load that module.</source>
          <target state="translated">В целом,рекомендуемый способ загрузки этого модуля см.в документации к конкретному модулю.</target>
        </trans-unit>
        <trans-unit id="ee2e987300579f41179429fff2833d7671d0a6f4" translate="yes" xml:space="preserve">
          <source>In general, these operator classes will not outperform the equivalent standard B-tree index methods, and they lack one major feature of the standard B-tree code: the ability to enforce uniqueness. However, they are useful for GIN testing and as a base for developing other GIN operator classes. Also, for queries that test both a GIN-indexable column and a B-tree-indexable column, it might be more efficient to create a multicolumn GIN index that uses one of these operator classes than to create two separate indexes that would have to be combined via bitmap ANDing.</source>
          <target state="translated">В целом,эти операторские классы не будут превосходить эквивалентные стандартные методы индекса B-дерева,и им не хватает одной главной особенности стандартного кода B-дерева-способности навязывать уникальность.Однако они полезны для тестирования GIN и как основа для разработки других классов операторов GIN.Кроме того,для запросов,которые проверяют как GIN-индексируемый столбец,так и B-дерево-индексируемый столбец,было бы более эффективно создавать многостолбцовый GIN-индекс,использующий один из этих классов операторов,чем создавать два отдельных индекса,которые пришлось бы комбинировать с помощью растровой карты ANDing.</target>
        </trans-unit>
        <trans-unit id="d2aa893456da765ab903af76d8c63108ae26c6ce" translate="yes" xml:space="preserve">
          <source>In general, these operator classes will not outperform the equivalent standard B-tree index methods, and they lack one major feature of the standard B-tree code: the ability to enforce uniqueness. However, they provide some other features that are not available with a B-tree index, as described below. Also, these operator classes are useful when a multicolumn GiST index is needed, wherein some of the columns are of data types that are only indexable with GiST but other columns are just simple data types. Lastly, these operator classes are useful for GiST testing and as a base for developing other GiST operator classes.</source>
          <target state="translated">В целом,эти операторские классы не будут превосходить эквивалентные стандартные методы индекса B-дерева,и им не хватает одной главной особенности стандартного кода B-дерева-способности навязывать уникальность.Однако они предоставляют и некоторые другие возможности,которые недоступны при использовании индекса B-дерева,как описано ниже.Кроме того,эти операторские классы полезны в тех случаях,когда требуется многостолбцовый индекс GiST,где некоторые столбцы представляют собой типы данных,которые индексируются только с помощью GiST,а другие столбцы являются просто простыми типами данных.Наконец,эти классы операторов полезны для тестирования GiST и в качестве базы для разработки других классов операторов GiST.</target>
        </trans-unit>
        <trans-unit id="050ef9f5f9df87b4cced8b5539a1b041812d5f42" translate="yes" xml:space="preserve">
          <source>In large tables, performance will be poor unless there is an index on the parent-key field.</source>
          <target state="translated">В больших таблицах производительность будет низкой,если в поле с родительским ключом не будет указан индекс.</target>
        </trans-unit>
        <trans-unit id="4765e35412cfd4a863f019aa0033f2c20c5f4705" translate="yes" xml:space="preserve">
          <source>In lieu of using replication slots, it is possible to prevent the removal of old WAL segments using &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt;, or by storing the segments in an archive using &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. However, these methods often result in retaining more WAL segments than required, whereas replication slots retain only the number of segments known to be needed. An advantage of these methods is that they bound the space requirement for &lt;code&gt;pg_wal&lt;/code&gt;; there is currently no way to do this using replication slots.</source>
          <target state="translated">Вместо использования слотов репликации можно предотвратить удаление старых сегментов WAL с помощью &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; или путем сохранения сегментов в архиве с помощью &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; . Однако эти методы часто приводят к сохранению большего количества сегментов WAL, чем требуется, в то время как слоты репликации сохраняют только то количество сегментов, которое, как известно, необходимо. Преимущество этих методов в том, что они ограничивают пространство, необходимое для &lt;code&gt;pg_wal&lt;/code&gt; ; в настоящее время нет возможности сделать это с помощью слотов репликации.</target>
        </trans-unit>
        <trans-unit id="29c3b7a7ac22ed19dd75a4554e5969e671d90aa0" translate="yes" xml:space="preserve">
          <source>In lieu of using replication slots, it is possible to prevent the removal of old WAL segments using &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt;, or by storing the segments in an archive using &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. However, these methods often result in retaining more WAL segments than required, whereas replication slots retain only the number of segments known to be needed. On the other hand, replication slots can retain so many WAL segments that they fill up the space allocated for &lt;code&gt;pg_wal&lt;/code&gt;; &lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt; limits the size of WAL files retained by replication slots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84baf4a0766c72c5ea2542a507182c8520343dbe" translate="yes" xml:space="preserve">
          <source>In macOS 10.2 and earlier, instead edit these commands in the file &lt;code&gt;/System/Library/StartupItems/SystemTuning/SystemTuning&lt;/code&gt;.</source>
          <target state="translated">В macOS 10.2 и более ранних &lt;code&gt;/System/Library/StartupItems/SystemTuning/SystemTuning&lt;/code&gt; вместо этого отредактируйте эти команды в файле / System / Library / StartupItems / SystemTuning / SystemTuning .</target>
        </trans-unit>
        <trans-unit id="6203855ca7fcb59eaeec22abadb1b2a4087a8203" translate="yes" xml:space="preserve">
          <source>In many practical situations, this assumption is usually satisfied; for example, there might be a GUI in the application that only allows selecting compatible city and ZIP code values to use in a query. But if that's not the case, functional dependencies may not be a viable option.</source>
          <target state="translated">Во многих практических ситуациях это предположение обычно выполняется;например,в приложении может быть GUI,который позволяет выбирать только совместимые значения городских и ZIP кодов для использования в запросе.Но если это не так,то функциональные зависимости могут оказаться нецелесообразным вариантом.</target>
        </trans-unit>
        <trans-unit id="4b1075485e703bf16e8ab73df82eb829ce78c033" translate="yes" xml:space="preserve">
          <source>In many situations, turning off &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; for noncritical transactions can provide much of the potential performance benefit of turning off &lt;code&gt;fsync&lt;/code&gt;, without the attendant risks of data corruption.</source>
          <target state="translated">Во многих ситуациях отключение &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; для некритических транзакций может обеспечить большую часть потенциального выигрыша в производительности от отключения &lt;code&gt;fsync&lt;/code&gt; без сопутствующих рисков повреждения данных.</target>
        </trans-unit>
        <trans-unit id="194f1c0784b754fb38f29c78dc946b25933f09f6" translate="yes" xml:space="preserve">
          <source>In most cases &lt;code&gt;regexp_matches()&lt;/code&gt; should be used with the &lt;code&gt;g&lt;/code&gt; flag, since if you only want the first match, it's easier and more efficient to use &lt;code&gt;regexp_match()&lt;/code&gt;. However, &lt;code&gt;regexp_match()&lt;/code&gt; only exists in PostgreSQL version 10 and up. When working in older versions, a common trick is to place a &lt;code&gt;regexp_matches()&lt;/code&gt; call in a sub-select, for example:</source>
          <target state="translated">В большинстве случаев &lt;code&gt;regexp_matches()&lt;/code&gt; следует использовать с флагом &lt;code&gt;g&lt;/code&gt; , поскольку, если вам нужно только первое совпадение, проще и эффективнее использовать &lt;code&gt;regexp_match()&lt;/code&gt; . Однако &lt;code&gt;regexp_match()&lt;/code&gt; существует только в PostgreSQL версии 10 и выше. При работе с более старыми версиями распространенным приемом является размещение &lt;code&gt;regexp_matches()&lt;/code&gt; в подвыборке, например:</target>
        </trans-unit>
        <trans-unit id="d60a20da168de2a263b74b28aa44a9c52da8b217" translate="yes" xml:space="preserve">
          <source>In most cases a &lt;code&gt;DELETE&lt;/code&gt; command also needs to read data from columns in the relation that it is deleting from (e.g., in a &lt;code&gt;WHERE&lt;/code&gt; clause or a &lt;code&gt;RETURNING&lt;/code&gt; clause). In this case, &lt;code&gt;SELECT&lt;/code&gt; rights are also required on the relation, and the appropriate &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policies will be applied in addition to the &lt;code&gt;DELETE&lt;/code&gt; policies. Thus the user must have access to the row(s) being deleted through a &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy in addition to being granted permission to delete the row(s) via a &lt;code&gt;DELETE&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy.</source>
          <target state="translated">В большинстве случаев команде &lt;code&gt;DELETE&lt;/code&gt; также необходимо считывать данные из столбцов в отношении, из которого выполняется удаление (например, в предложении &lt;code&gt;WHERE&lt;/code&gt; или &lt;code&gt;RETURNING&lt;/code&gt; ). В этом случае для отношения также требуются права &lt;code&gt;SELECT&lt;/code&gt; , и в дополнение к политикам &lt;code&gt;DELETE&lt;/code&gt; будут применяться соответствующие политики &lt;code&gt;SELECT&lt;/code&gt; или &lt;code&gt;ALL&lt;/code&gt; . Таким образом, пользователь должен иметь доступ к строке (строкам), удаляемой с помощью политики &lt;code&gt;SELECT&lt;/code&gt; или &lt;code&gt;ALL&lt;/code&gt; , в дополнение к предоставлению разрешения на удаление строки (строк) с помощью политики &lt;code&gt;DELETE&lt;/code&gt; или &lt;code&gt;ALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82c5561a0275adcd2a2a51ebef8a40a5f37109da" translate="yes" xml:space="preserve">
          <source>In most database designs the majority of columns should be marked not null.</source>
          <target state="translated">В большинстве конструкций баз данных большинство столбцов должно быть помечено не как ноль.</target>
        </trans-unit>
        <trans-unit id="158c99420a44bba9aff343cb614d9616cbae7fa4" translate="yes" xml:space="preserve">
          <source>In most implementations of the &amp;ldquo;not-a-number&amp;rdquo; concept, &lt;code&gt;NaN&lt;/code&gt; is not considered equal to any other numeric value (including &lt;code&gt;NaN&lt;/code&gt;). In order to allow &lt;code&gt;numeric&lt;/code&gt; values to be sorted and used in tree-based indexes, PostgreSQL treats &lt;code&gt;NaN&lt;/code&gt; values as equal, and greater than all non-&lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">В большинстве реализаций концепции &amp;laquo;не-числа&amp;raquo; &lt;code&gt;NaN&lt;/code&gt; не считается равным любому другому числовому значению (включая &lt;code&gt;NaN&lt;/code&gt; ). Чтобы разрешить сортировку &lt;code&gt;numeric&lt;/code&gt; значений и их использование в древовидных индексах, PostgreSQL обрабатывает значения &lt;code&gt;NaN&lt;/code&gt; как равные и большие, чем все значения, отличные от &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd61e39655eeef5b9bf240531ec53c538d27ed8e" translate="yes" xml:space="preserve">
          <source>In named notation, each argument's name is specified using &lt;code&gt;=&amp;gt;&lt;/code&gt; to separate it from the argument expression. For example:</source>
          <target state="translated">В именованной нотации имя каждого аргумента указывается с помощью &lt;code&gt;=&amp;gt;&lt;/code&gt; , чтобы отделить его от выражения аргумента. Например:</target>
        </trans-unit>
        <trans-unit id="3a49a039bda09447cda5b6ba6fb7b5f06a1662cb" translate="yes" xml:space="preserve">
          <source>In nearly all cases, you'll need some options to make a useful test. The most important options are &lt;code&gt;-c&lt;/code&gt; (number of clients), &lt;code&gt;-t&lt;/code&gt; (number of transactions), &lt;code&gt;-T&lt;/code&gt; (time limit), and &lt;code&gt;-f&lt;/code&gt; (specify a custom script file). See below for a full list.</source>
          <target state="translated">Практически во всех случаях для проведения полезного теста вам понадобятся некоторые параметры. Наиболее важными параметрами являются &lt;code&gt;-c&lt;/code&gt; (количество клиентов), &lt;code&gt;-t&lt;/code&gt; (количество транзакций), &lt;code&gt;-T&lt;/code&gt; (ограничение по времени) и &lt;code&gt;-f&lt;/code&gt; (указание файла настраиваемого сценария). См. Полный список ниже.</target>
        </trans-unit>
        <trans-unit id="5a8686c8bc573efc7c7f314b50a2faaa5e4253e1" translate="yes" xml:space="preserve">
          <source>In non-fragment-based headline generation, &lt;code&gt;ts_headline&lt;/code&gt; locates matches for the given &lt;code&gt;query&lt;/code&gt; and chooses a single one to display, preferring matches that have more query words within the allowed headline length. In fragment-based headline generation, &lt;code&gt;ts_headline&lt;/code&gt; locates the query matches and splits each match into &amp;ldquo;fragments&amp;rdquo; of no more than &lt;code&gt;MaxWords&lt;/code&gt; words each, preferring fragments with more query words, and when possible &amp;ldquo;stretching&amp;rdquo; fragments to include surrounding words. The fragment-based mode is thus more useful when the query matches span large sections of the document, or when it's desirable to display multiple matches. In either mode, if no query matches can be identified, then a single fragment of the first &lt;code&gt;MinWords&lt;/code&gt; words in the document will be displayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac5d16972792c7bd805065c712c623a51151c8c" translate="yes" xml:space="preserve">
          <source>In none of these cases is there any provision for schema-qualification; all objects created during bootstrap are expected to be in the &lt;code&gt;pg_catalog&lt;/code&gt; schema.</source>
          <target state="translated">Ни в одном из этих случаев нет положений о квалификации схемы; все объекты, созданные во время начальной загрузки, должны быть в схеме &lt;code&gt;pg_catalog&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2409be7cd8d4efc7e947e3b436a132ef0c47174" translate="yes" xml:space="preserve">
          <source>In normal (non-recovery) mode, if you issue &lt;code&gt;DROP USER&lt;/code&gt; or &lt;code&gt;DROP ROLE&lt;/code&gt; for a role with login capability while that user is still connected then nothing happens to the connected user &amp;mdash; they remain connected. The user cannot reconnect however. This behavior applies in recovery also, so a &lt;code&gt;DROP USER&lt;/code&gt; on the primary does not disconnect that user on the standby.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="909fab97f09523721a77cc835152b274f406d63c" translate="yes" xml:space="preserve">
          <source>In normal (non-recovery) mode, if you issue &lt;code&gt;DROP USER&lt;/code&gt; or &lt;code&gt;DROP ROLE&lt;/code&gt; for a role with login capability while that user is still connected then nothing happens to the connected user - they remain connected. The user cannot reconnect however. This behavior applies in recovery also, so a &lt;code&gt;DROP USER&lt;/code&gt; on the primary does not disconnect that user on the standby.</source>
          <target state="translated">В обычном (без восстановления) режиме, если вы вводите &lt;code&gt;DROP USER&lt;/code&gt; или &lt;code&gt;DROP ROLE&lt;/code&gt; для роли с возможностью входа в систему, когда этот пользователь все еще подключен, с подключенным пользователем ничего не происходит - они остаются подключенными. Однако пользователь не может повторно подключиться. Это поведение применимо и к восстановлению, поэтому &lt;code&gt;DROP USER&lt;/code&gt; на основном сервере не отключает этого пользователя от резервного.</target>
        </trans-unit>
        <trans-unit id="b1729ae1f718e0b63bffb08ae3066f0eb0e77ca2" translate="yes" xml:space="preserve">
          <source>In normal operation, &amp;ldquo;read-only&amp;rdquo; transactions are allowed to use &lt;code&gt;LISTEN&lt;/code&gt; and &lt;code&gt;NOTIFY&lt;/code&gt;, so Hot Standby sessions operate under slightly tighter restrictions than ordinary read-only sessions. It is possible that some of these restrictions might be loosened in a future release.</source>
          <target state="translated">При нормальной работе транзакциям &amp;laquo;только для чтения&amp;raquo; разрешено использовать &lt;code&gt;LISTEN&lt;/code&gt; и &lt;code&gt;NOTIFY&lt;/code&gt; , поэтому сеансы горячего резервирования работают с немного более жесткими ограничениями, чем обычные сеансы только для чтения. Возможно, что некоторые из этих ограничений будут сняты в будущем выпуске.</target>
        </trans-unit>
        <trans-unit id="d3560745e5e4a4c446630441931abacb2898af6f" translate="yes" xml:space="preserve">
          <source>In normal operation, psql provides a prompt with the name of the database to which psql is currently connected, followed by the string &lt;code&gt;=&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">При нормальной работе psql выдает подсказку с именем базы данных, к которой в настоящее время подключен psql, за которым следует строка &lt;code&gt;=&amp;gt;&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="cd286c2214fff2e0be18b3ddfb09dfdd0278ddbf" translate="yes" xml:space="preserve">
          <source>In older OpenBSD versions, you will need to build a custom kernel to change the IPC parameters. Make sure that the options &lt;code&gt;SYSVSHM&lt;/code&gt; and &lt;code&gt;SYSVSEM&lt;/code&gt; are enabled, too. (They are by default.) The following shows an example of how to set the various parameters in the kernel configuration file:</source>
          <target state="translated">В более старых версиях OpenBSD вам нужно будет создать собственное ядро ​​для изменения параметров IPC. Убедитесь, что параметры &lt;code&gt;SYSVSHM&lt;/code&gt; и &lt;code&gt;SYSVSEM&lt;/code&gt; также включены. (Они по умолчанию.) Ниже показан пример того, как установить различные параметры в файле конфигурации ядра:</target>
        </trans-unit>
        <trans-unit id="43d5f374be9ab2b9f725372748b33884cde122b3" translate="yes" xml:space="preserve">
          <source>In older macOS versions, you will need to reboot to have changes in the shared memory parameters take effect. As of 10.5 it is possible to change all but &lt;code&gt;SHMMNI&lt;/code&gt; on the fly, using sysctl. But it's still best to set up your preferred values via &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, so that the values will be kept across reboots.</source>
          <target state="translated">В более старых версиях macOS вам потребуется перезагрузка, чтобы изменения в параметрах общей памяти вступили в силу. Начиная с версии 10.5, можно изменять все, кроме &lt;code&gt;SHMMNI&lt;/code&gt; , на лету, используя sysctl. Но все же лучше установить предпочтительные значения через &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; , чтобы значения сохранялись при перезагрузках.</target>
        </trans-unit>
        <trans-unit id="882a1a9442374dfd65845651f73b92d43f44074e" translate="yes" xml:space="preserve">
          <source>In order for the tunnel setup to succeed you must be allowed to connect via &lt;code&gt;ssh&lt;/code&gt; as &lt;code&gt;joe@foo.com&lt;/code&gt;, just as if you had attempted to use &lt;code&gt;ssh&lt;/code&gt; to create a terminal session.</source>
          <target state="translated">Для успешной настройки туннеля вам должно быть разрешено подключаться через &lt;code&gt;ssh&lt;/code&gt; как &lt;code&gt;joe@foo.com&lt;/code&gt; , как если бы вы пытались использовать &lt;code&gt;ssh&lt;/code&gt; для создания сеанса терминала.</target>
        </trans-unit>
        <trans-unit id="d646fc6f64023e87f7f5096950ae7ce2f2e80423" translate="yes" xml:space="preserve">
          <source>In order to access any schema object, &lt;code&gt;db_schema:search&lt;/code&gt; permission is required on the containing schema. When an object is referenced without schema qualification, schemas on which this permission is not present will not be searched (just as if the user did not have &lt;code&gt;USAGE&lt;/code&gt; privilege on the schema). If an explicit schema qualification is present, an error will occur if the user does not have the requisite permission on the named schema.</source>
          <target state="translated">Для доступа к любому объекту схемы &lt;code&gt;db_schema:search&lt;/code&gt; разрешение db_schema: search на содержащую схему. Когда объект ссылается без квалификации схемы, схемы, для которых это разрешение отсутствует, не будут просматриваться (как если бы у пользователя не было привилегии &lt;code&gt;USAGE&lt;/code&gt; для схемы). Если присутствует явная квалификация схемы, произойдет ошибка, если у пользователя нет необходимого разрешения на указанную схему.</target>
        </trans-unit>
        <trans-unit id="233299fd5dfd7550c24147ba5661abe08d2d0d86" translate="yes" xml:space="preserve">
          <source>In order to allow the PostgreSQL query planner to make reasonably informed decisions when optimizing queries, the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; data should be up-to-date for all tables used in the query. Normally the &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;autovacuum daemon&lt;/a&gt; will take care of that automatically. But if a table has recently had substantial changes in its contents, you might need to do a manual &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; rather than wait for autovacuum to catch up with the changes.</source>
          <target state="translated">Чтобы планировщик запросов PostgreSQL мог принимать обоснованно обоснованные решения при оптимизации запросов, данные &lt;a href=&quot;catalog-pg-statistic&quot;&gt; &lt;code&gt;pg_statistic&lt;/code&gt; &lt;/a&gt; должны быть актуальными для всех таблиц, используемых в запросе. Обычно &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;демон автоочистки&lt;/a&gt; позаботится об этом автоматически. Но если таблица в последнее время имела существенные изменения в его содержании, возможно , придется сделать вручную &lt;a href=&quot;sql-analyze&quot;&gt;ПРОАНАЛИЗИРУЙТЕ&lt;/a&gt; , а не ждать автовакууминг , чтобы догнать изменения.</target>
        </trans-unit>
        <trans-unit id="5bbf891d4248cf5667df821377cc8cc7768e14e9" translate="yes" xml:space="preserve">
          <source>In order to be able to copy the initial table data, the role used for the replication connection must have the &lt;code&gt;SELECT&lt;/code&gt; privilege on a published table (or be a superuser).</source>
          <target state="translated">Чтобы иметь возможность копировать исходные данные таблицы, роль, используемая для соединения репликации, должна иметь привилегию &lt;code&gt;SELECT&lt;/code&gt; для опубликованной таблицы (или быть суперпользователем).</target>
        </trans-unit>
        <trans-unit id="fcaf64f5cce00b8df1baf8d751f9011467d9dba7" translate="yes" xml:space="preserve">
          <source>In order to bootstrap the database system, a freshly initialized system always contains one predefined role. This role is always a &amp;ldquo;superuser&amp;rdquo;, and by default (unless altered when running &lt;code&gt;initdb&lt;/code&gt;) it will have the same name as the operating system user that initialized the database cluster. Customarily, this role will be named &lt;code&gt;postgres&lt;/code&gt;. In order to create more roles you first have to connect as this initial role.</source>
          <target state="translated">Для начальной загрузки системы базы данных только что инициализированная система всегда содержит одну предопределенную роль. Эта роль всегда является &amp;laquo;суперпользователем&amp;raquo;, и по умолчанию (если она не была изменена при запуске &lt;code&gt;initdb&lt;/code&gt; ) она будет иметь то же имя, что и пользователь операционной системы, инициализировавший кластер базы данных. Обычно эта роль будет называться &lt;code&gt;postgres&lt;/code&gt; . Чтобы создать больше ролей, вы сначала должны подключиться в качестве этой начальной роли.</target>
        </trans-unit>
        <trans-unit id="c0b6ace4aa733c9f867afeaddbd70b1a3a0b54f3" translate="yes" xml:space="preserve">
          <source>In order to calculate the union, intersection, or difference of two queries, the two queries must be &amp;ldquo;union compatible&amp;rdquo;, which means that they return the same number of columns and the corresponding columns have compatible data types, as described in &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;.</source>
          <target state="translated">Чтобы вычислить объединение, пересечение или разность двух запросов, два запроса должны быть &amp;laquo;совместимыми по объединению&amp;raquo;, что означает, что они возвращают одинаковое количество столбцов, а соответствующие столбцы имеют совместимые типы данных, как описано в &lt;a href=&quot;typeconv-union-case&quot;&gt;Разделе 10.5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4415b6dbba894170e74bcc6996dbfa1fb24cd8d1" translate="yes" xml:space="preserve">
          <source>In order to create a database, the PostgreSQL server must be up and running (see &lt;a href=&quot;server-start&quot;&gt;Section 18.3&lt;/a&gt;).</source>
          <target state="translated">Чтобы создать базу данных, сервер PostgreSQL должен быть запущен и работать (см. &lt;a href=&quot;server-start&quot;&gt;Раздел 18.3&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3f22ae189397eeb8d6d5706a9610e0f700d2bec8" translate="yes" xml:space="preserve">
          <source>In order to emulate a case-insensitive collation as closely as possible, there are &lt;code&gt;citext&lt;/code&gt;-specific versions of a number of string-processing operators and functions. So, for example, the regular expression operators &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; exhibit the same behavior when applied to &lt;code&gt;citext&lt;/code&gt;: they both match case-insensitively. The same is true for &lt;code&gt;!~&lt;/code&gt; and &lt;code&gt;!~*&lt;/code&gt;, as well as for the &lt;code&gt;LIKE&lt;/code&gt; operators &lt;code&gt;~~&lt;/code&gt; and &lt;code&gt;~~*&lt;/code&gt;, and &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt;. If you'd like to match case-sensitively, you can cast the operator's arguments to &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">Чтобы как можно &lt;code&gt;citext&lt;/code&gt; , существуют специфичные для citext версии ряда операторов и функций обработки строк. Так, например, операторы регулярного выражения &lt;code&gt;~&lt;/code&gt; и &lt;code&gt;~*&lt;/code&gt; демонстрируют одно и то же поведение при применении к &lt;code&gt;citext&lt;/code&gt; : они оба соответствуют без учета регистра. То же самое верно для &lt;code&gt;!~&lt;/code&gt; И &lt;code&gt;!~*&lt;/code&gt; , А также для операторов &lt;code&gt;LIKE&lt;/code&gt; &lt;code&gt;~~&lt;/code&gt; и &lt;code&gt;~~*&lt;/code&gt; и &lt;code&gt;!~~&lt;/code&gt; и &lt;code&gt;!~~*&lt;/code&gt; . Если вы хотите найти соответствие с учетом регистра, вы можете &lt;code&gt;text&lt;/code&gt; аргументы оператора в текст .</target>
        </trans-unit>
        <trans-unit id="13c4603c579f552910275f0bbcb4deae55ef3a7a" translate="yes" xml:space="preserve">
          <source>In order to function, this module must be loaded via &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">Для работы этот модуль должен быть загружен через &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; в &lt;code&gt;postgresql.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d81c2662b5a84aa8d5b82fab0b4d606e39ebda86" translate="yes" xml:space="preserve">
          <source>In order to measure the run-time cost of each node in the execution plan, the current implementation of &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; adds profiling overhead to query execution. As a result, running &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; on a query can sometimes take significantly longer than executing the query normally. The amount of overhead depends on the nature of the query, as well as the platform being used. The worst case occurs for plan nodes that in themselves require very little time per execution, and on machines that have relatively slow operating system calls for obtaining the time of day.</source>
          <target state="translated">Чтобы измерить затраты времени выполнения каждого узла в плане выполнения, текущая реализация &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; добавляет накладные расходы на профилирование для выполнения запроса. В результате выполнение &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; для запроса иногда может занимать значительно больше времени, чем его выполнение в обычном режиме. Сумма накладных расходов зависит от характера запроса, а также от используемой платформы. Наихудший случай имеет место для узлов плана, которые сами по себе требуют очень мало времени на выполнение, и на машинах, которые имеют относительно медленные вызовы операционной системы для получения времени суток.</target>
        </trans-unit>
        <trans-unit id="8ef25cb15d96bc5ee47cb922c3476dbfcb096c17" translate="yes" xml:space="preserve">
          <source>In order to prevent this, the following applies to all built-in selectivity estimation functions. When planning a query, in order to be able to use stored statistics, the current user must either have &lt;code&gt;SELECT&lt;/code&gt; privilege on the table or the involved columns, or the operator used must be &lt;code&gt;LEAKPROOF&lt;/code&gt; (more accurately, the function that the operator is based on). If not, then the selectivity estimator will behave as if no statistics are available, and the planner will proceed with default or fall-back assumptions.</source>
          <target state="translated">Чтобы предотвратить это, следующее применяется ко всем встроенным функциям оценки селективности. При планировании запроса, чтобы иметь возможность использовать сохраненную статистику, текущий пользователь должен либо иметь привилегию &lt;code&gt;SELECT&lt;/code&gt; для таблицы или задействованных столбцов, либо используемый оператор должен быть &lt;code&gt;LEAKPROOF&lt;/code&gt; (точнее, функция, на которой основан оператор ). Если нет, то оценщик селективности будет вести себя так, как если бы статистика недоступна, и планировщик продолжит работу с предположениями по умолчанию или с запасными предположениями.</target>
        </trans-unit>
        <trans-unit id="6b9560d0a190cd0915dff71499a691135e350ab1" translate="yes" xml:space="preserve">
          <source>In ordinary usage, these parameters are set in &lt;code&gt;postgresql.conf&lt;/code&gt;, although superusers can alter them on-the-fly within their own sessions. Typical usage might be:</source>
          <target state="translated">При обычном использовании эти параметры устанавливаются в &lt;code&gt;postgresql.conf&lt;/code&gt; , хотя суперпользователи могут изменять их на лету в рамках своих собственных сеансов. Типичное использование может быть:</target>
        </trans-unit>
        <trans-unit id="70a9b455eedcd0013740b57c24d0da08e7b71441" translate="yes" xml:space="preserve">
          <source>In parameters that specify support function names, you can write a schema name if needed, for example &lt;code&gt;SFUNC = public.sum&lt;/code&gt;. Do not write argument types there, however &amp;mdash; the argument types of the support functions are determined from other parameters.</source>
          <target state="translated">В параметрах, определяющих имена функций поддержки, при необходимости можно указать имя схемы, например &lt;code&gt;SFUNC = public.sum&lt;/code&gt; . Однако не записывайте здесь типы аргументов - типы аргументов вспомогательных функций определяются из других параметров.</target>
        </trans-unit>
        <trans-unit id="e6503b355c17e530acb3ce1cf1b630a12d5c662a" translate="yes" xml:space="preserve">
          <source>In particular, if there's an index on &lt;code&gt;key&lt;/code&gt;, it will probably be used to fetch just the rows having &lt;code&gt;key = 123&lt;/code&gt;. On the other hand, in</source>
          <target state="translated">В частности, если есть индекс для &lt;code&gt;key&lt;/code&gt; , он, вероятно, будет использоваться для выборки только строк с &lt;code&gt;key = 123&lt;/code&gt; . С другой стороны, в</target>
        </trans-unit>
        <trans-unit id="e4a5dbfbe9955b3dd014a081adfefb7a2337bd07" translate="yes" xml:space="preserve">
          <source>In particular, when a superuser chooses to &lt;code&gt;SET ROLE&lt;/code&gt; to a non-superuser role, they lose their superuser privileges.</source>
          <target state="translated">В частности, когда суперпользователь выбирает &lt;code&gt;SET ROLE&lt;/code&gt; для роли не суперпользователя, он теряет свои привилегии суперпользователя.</target>
        </trans-unit>
        <trans-unit id="f584b379c3631dcc4c7bd92f0443efdccb5ba563" translate="yes" xml:space="preserve">
          <source>In plain format, tablespaces will be backed up to the same path they have on the source server, unless the option &lt;code&gt;--tablespace-mapping&lt;/code&gt; is used. Without this option, running a plain format base backup on the same host as the server will not work if tablespaces are in use, because the backup would have to be written to the same directory locations as the original tablespaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc733581aa12ac8119d8135b89e36cf1d9d3b31b" translate="yes" xml:space="preserve">
          <source>In practice one usually relies on the search path for operators, so as not to have to write anything so ugly as that.</source>
          <target state="translated">На практике обычно полагаются на путь поиска операторов,чтобы не пришлось писать что-нибудь настолько уродливое.</target>
        </trans-unit>
        <trans-unit id="a48f8184fbeadfd296ca8b91bd2766492182e822" translate="yes" xml:space="preserve">
          <source>In practice the &lt;em&gt;&lt;code&gt;source_sql&lt;/code&gt;&lt;/em&gt; query should always specify &lt;code&gt;ORDER BY 1&lt;/code&gt; to ensure that values with the same &lt;code&gt;row_name&lt;/code&gt; are brought together. However, ordering of the categories within a group is not important. Also, it is essential to be sure that the order of the &lt;em&gt;&lt;code&gt;category_sql&lt;/code&gt;&lt;/em&gt; query's output matches the specified output column order.</source>
          <target state="translated">На практике запрос &lt;em&gt; &lt;code&gt;source_sql&lt;/code&gt; &lt;/em&gt; всегда должен указывать &lt;code&gt;ORDER BY 1&lt;/code&gt; , чтобы гарантировать, что значения с одинаковым &lt;code&gt;row_name&lt;/code&gt; объединяются. Однако порядок категорий в группе не важен. Кроме того, важно убедиться, что порядок вывода запроса &lt;em&gt; &lt;code&gt;category_sql&lt;/code&gt; &lt;/em&gt; соответствует указанному порядку выходных столбцов.</target>
        </trans-unit>
        <trans-unit id="1937c987be0e7b4e7465a2a7029e3f9255be3a60" translate="yes" xml:space="preserve">
          <source>In practice the SQL query should always specify &lt;code&gt;ORDER BY 1,2&lt;/code&gt; to ensure that the input rows are properly ordered, that is, values with the same &lt;code&gt;row_name&lt;/code&gt; are brought together and correctly ordered within the row. Notice that &lt;code&gt;crosstab&lt;/code&gt; itself does not pay any attention to the second column of the query result; it's just there to be ordered by, to control the order in which the third-column values appear across the page.</source>
          <target state="translated">На практике SQL-запрос всегда должен указывать &lt;code&gt;ORDER BY 1,2&lt;/code&gt; , чтобы гарантировать, что входные строки правильно упорядочены, то есть значения с одинаковым &lt;code&gt;row_name&lt;/code&gt; объединяются и правильно упорядочиваются в строке. Обратите внимание, что сама &lt;code&gt;crosstab&lt;/code&gt; не обращает внимания на второй столбец результата запроса; они просто должны быть упорядочены, чтобы контролировать порядок, в котором значения третьего столбца появляются на странице.</target>
        </trans-unit>
        <trans-unit id="81fbb389dcb4a22896ff56ba2f6a26d52f9a0053" translate="yes" xml:space="preserve">
          <source>In practice, it might be best to check the newest child first, if most inserts go into that child. For simplicity, we have shown the trigger's tests in the same order as in other parts of this example.</source>
          <target state="translated">На практике,возможно,лучше всего сначала проверить самого нового ребенка,если большинство вставок попадут в него.Для простоты,мы показали тесты триггеров в том же порядке,что и в других частях этого примера.</target>
        </trans-unit>
        <trans-unit id="06e0b2a62cd9f4eb01f119bc558152c7a9b61c4c" translate="yes" xml:space="preserve">
          <source>In practice, these commands would be wrapped up in an extension.</source>
          <target state="translated">На практике эти команды будут завернуты в расширение.</target>
        </trans-unit>
        <trans-unit id="79f48feff09a5e6beb49de65d5ed928eb6a28410" translate="yes" xml:space="preserve">
          <source>In principle, cross-references from one initial catalog row to another could be written just by writing the preassigned OID of the referenced row in the referencing field. However, that is against project policy, because it is error-prone, hard to read, and subject to breakage if a newly-assigned OID is renumbered. Therefore &lt;code&gt;genbki.pl&lt;/code&gt; provides mechanisms to write symbolic references instead. The rules are as follows:</source>
          <target state="translated">В принципе, перекрестные ссылки из одной исходной строки каталога в другую можно записать, просто записав предварительно назначенный OID ссылочной строки в поле ссылки. Однако это противоречит политике проекта, потому что он подвержен ошибкам, его трудно читать и может выйти из строя, если перенумеровать вновь назначенный OID. Поэтому &lt;code&gt;genbki.pl&lt;/code&gt; вместо этого предоставляет механизмы для записи символьных ссылок. Правила следующие:</target>
        </trans-unit>
        <trans-unit id="760cef4da4decce6f6d9b7cb2f206b14f10f3fa4" translate="yes" xml:space="preserve">
          <source>In principle, index-only scans can be used with expression indexes. For example, given an index on &lt;code&gt;f(x)&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is a table column, it should be possible to execute</source>
          <target state="translated">В принципе, сканирование только индекса можно использовать с индексами выражений. Например, учитывая индекс для &lt;code&gt;f(x)&lt;/code&gt; где &lt;code&gt;x&lt;/code&gt; - столбец таблицы, должно быть возможно выполнить</target>
        </trans-unit>
        <trans-unit id="50939af3586cb58faf973e37d044bc572b91198e" translate="yes" xml:space="preserve">
          <source>In principle, one can use &lt;code&gt;to_tsquery&lt;/code&gt; if you quote the argument:</source>
          <target state="translated">В принципе, можно использовать &lt;code&gt;to_tsquery&lt;/code&gt; , если вы процитируете аргумент:</target>
        </trans-unit>
        <trans-unit id="25c4a2a950655d8b26ffa359e0be687cbb7c81cd" translate="yes" xml:space="preserve">
          <source>In principle, we could do an index-only scan on this index to satisfy a query like</source>
          <target state="translated">В принципе,мы могли бы выполнить сканирование по этому индексу только для того,чтобы удовлетворить такой запрос,как</target>
        </trans-unit>
        <trans-unit id="5a138e4bb79a7d66b0d4bfaffdffcdcbb5964acf" translate="yes" xml:space="preserve">
          <source>In prior releases of PostgreSQL, this was the default except for the &lt;code&gt;stop&lt;/code&gt; mode.</source>
          <target state="translated">В предыдущих выпусках PostgreSQL это было по умолчанию, за исключением режима &lt;code&gt;stop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75324ba26fc4965d2196117750a2a1059aac25a6" translate="yes" xml:space="preserve">
          <source>In prompt 1 normally &lt;code&gt;=&lt;/code&gt;, but &lt;code&gt;@&lt;/code&gt; if the session is in an inactive branch of a conditional block, or &lt;code&gt;^&lt;/code&gt; if in single-line mode, or &lt;code&gt;!&lt;/code&gt; if the session is disconnected from the database (which can happen if &lt;code&gt;\connect&lt;/code&gt; fails). In prompt 2 &lt;code&gt;%R&lt;/code&gt; is replaced by a character that depends on why psql expects more input: &lt;code&gt;-&lt;/code&gt; if the command simply wasn't terminated yet, but &lt;code&gt;*&lt;/code&gt; if there is an unfinished &lt;code&gt;/* ... */&lt;/code&gt; comment, a single quote if there is an unfinished quoted string, a double quote if there is an unfinished quoted identifier, a dollar sign if there is an unfinished dollar-quoted string, or &lt;code&gt;(&lt;/code&gt; if there is an unmatched left parenthesis. In prompt 3 &lt;code&gt;%R&lt;/code&gt; doesn't produce anything.</source>
          <target state="translated">В приглашении 1 обычно &lt;code&gt;=&lt;/code&gt; , но &lt;code&gt;@&lt;/code&gt; , если сеанс находится в неактивной ветви условного блока, или &lt;code&gt;^&lt;/code&gt; , если в однострочном режиме, или &lt;code&gt;!&lt;/code&gt; если сеанс отключен от базы данных (что может произойти в случае сбоя &lt;code&gt;\connect&lt;/code&gt; ). В приглашении 2 &lt;code&gt;%R&lt;/code&gt; заменяется символом, который зависит от того, почему psql ожидает ввода дополнительных данных: &lt;code&gt;-&lt;/code&gt; если команда просто еще не завершена, но &lt;code&gt;*&lt;/code&gt; если есть незаконченный &lt;code&gt;/* ... */&lt;/code&gt; комментарий, одинарная кавычка, если есть незавершенная строка в кавычках, двойная кавычка, если есть незавершенный идентификатор в кавычках, знак доллара, если есть незаконченная строка в кавычках, или &lt;code&gt;(&lt;/code&gt; если есть несогласованная левая скобка. В подсказке 3 &lt;code&gt;%R&lt;/code&gt; ничего не производит.</target>
        </trans-unit>
        <trans-unit id="55492f505092f7907e8e04b3d9f069e610e9bef1" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-DATUM&quot;&gt;datum&lt;/a&gt;: the fact that its value cannot be broken down into smaller components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2af2f18b8bb379f6a3aaec125d379cfd0547daa" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-PARTITIONED-TABLE&quot;&gt;partitioned table&lt;/a&gt;: One of the tables that each contain part of the data of the partitioned table, which is said to be the &lt;em&gt;parent&lt;/em&gt;. The partition is itself a table, so it can also be queried directly; at the same time, a partition can sometimes be a partitioned table, allowing hierarchies to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c9e089ab97a2e09bac9e2f25d906ab6733e4ee0" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;database transaction&lt;/a&gt;: see &lt;a href=&quot;glossary#GLOSSARY-ATOMICITY&quot;&gt;atomicity&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06a3856f982e3b72fb625608048db8b0f9e532d" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-WINDOW-FUNCTION&quot;&gt;window function&lt;/a&gt; in a &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;query&lt;/a&gt;, a partition is a user-defined criterion that identifies which neighboring &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; of the &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;query's result set&lt;/a&gt; can be considered by the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce53e0d0da47b411803cd409013625a3f9ae5431" translate="yes" xml:space="preserve">
          <source>In releases of PostgreSQL before 13 there was no &lt;code&gt;xid8&lt;/code&gt; type, so variants of these functions were provided that used &lt;code&gt;bigint&lt;/code&gt; to represent a 64-bit XID, with a correspondingly distinct snapshot data type &lt;code&gt;txid_snapshot&lt;/code&gt;. These older functions have &lt;code&gt;txid&lt;/code&gt; in their names. They are still supported for backward compatibility, but may be removed from a future release. See &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;Table 9.76&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a64129f0b1da1e51ed964ad4579c4ce899b50b" translate="yes" xml:space="preserve">
          <source>In releases prior to 9.6, this parameter also allowed the values &lt;code&gt;archive&lt;/code&gt; and &lt;code&gt;hot_standby&lt;/code&gt;. These are still accepted but mapped to &lt;code&gt;replica&lt;/code&gt;.</source>
          <target state="translated">В выпусках до 9.6 этот параметр также разрешал &lt;code&gt;archive&lt;/code&gt; значения и &lt;code&gt;hot_standby&lt;/code&gt; . Они по-прежнему принимаются, но отображаются на &lt;code&gt;replica&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa88d3807e10330acdc1940359127a25a966338d" translate="yes" xml:space="preserve">
          <source>In short then, the most general recipe for removing a role that has been used to own objects is:</source>
          <target state="translated">Короче говоря,наиболее общий рецепт удаления роли,которая использовалась для владения объектами:</target>
        </trans-unit>
        <trans-unit id="d436b991362b7fed721dd789926c009b129d872d" translate="yes" xml:space="preserve">
          <source>In short, this is the difference between abbreviations and full names: abbreviations represent a specific offset from UTC, whereas many of the full names imply a local daylight-savings time rule, and so have two possible UTC offsets. As an example, &lt;code&gt;2014-06-04 12:00 America/New_York&lt;/code&gt; represents noon local time in New York, which for this particular date was Eastern Daylight Time (UTC-4). So &lt;code&gt;2014-06-04 12:00 EDT&lt;/code&gt; specifies that same time instant. But &lt;code&gt;2014-06-04 12:00 EST&lt;/code&gt; specifies noon Eastern Standard Time (UTC-5), regardless of whether daylight savings was nominally in effect on that date.</source>
          <target state="translated">Короче говоря, в этом разница между сокращениями и полными именами: сокращения представляют собой конкретное смещение от UTC, тогда как многие из полных имен подразумевают местное правило перехода на летнее время и поэтому имеют два возможных смещения UTC. Например, &lt;code&gt;2014-06-04 12:00 America/New_York&lt;/code&gt; представляет полдень по местному времени в Нью-Йорке, которое для этой конкретной даты было восточным летним временем (UTC-4). Таким образом, &lt;code&gt;2014-06-04 12:00 EDT&lt;/code&gt; указывает тот же самый момент времени. Но &lt;code&gt;2014-06-04 12:00 EST&lt;/code&gt; указывает полдень по восточному стандартному времени (UTC-5), независимо от того, действовало ли летнее время номинально в эту дату.</target>
        </trans-unit>
        <trans-unit id="6f11576d9f6f09df7ddccd8a08208061f234c7e9" translate="yes" xml:space="preserve">
          <source>In short, when an RE contains both greedy and non-greedy subexpressions, the total match length is either as long as possible or as short as possible, according to the attribute assigned to the whole RE. The attributes assigned to the subexpressions only affect how much of that match they are allowed to &amp;ldquo;eat&amp;rdquo; relative to each other.</source>
          <target state="translated">Короче говоря, когда RE содержит как жадные, так и не жадные подвыражения, общая длина совпадения либо максимально возможная, либо минимально возможная, в соответствии с атрибутом, назначенным всему RE. Атрибуты, назначенные подвыражениям, влияют только на то, какую часть совпадения им разрешено &amp;laquo;съесть&amp;raquo; относительно друг друга.</target>
        </trans-unit>
        <trans-unit id="aee830ec2c7b69b7f24b10ee81fb051f88d3ea9e" translate="yes" xml:space="preserve">
          <source>In short, while an index-only scan is possible given the two fundamental requirements, it will be a win only if a significant fraction of the table's heap pages have their all-visible map bits set. But tables in which a large fraction of the rows are unchanging are common enough to make this type of scan very useful in practice.</source>
          <target state="translated">Короче говоря,несмотря на то,что сканирование только по индексу возможно при соблюдении двух фундаментальных требований,победа будет только в том случае,если значительная часть кучи страниц таблицы будет иметь набор всех видимых битов карты.Но таблицы,в которых большая часть строк не меняется,достаточно распространены,чтобы сделать этот тип сканирования очень полезным на практике.</target>
        </trans-unit>
        <trans-unit id="81308d755ee35ef99db2fb46ff2f6ea4fdc54a8b" translate="yes" xml:space="preserve">
          <source>In simple cases, the concatenation operator discussed above is preferred over direct use of these functions. However, because the concatenation operator is overloaded to serve all three cases, there are situations where use of one of the functions is helpful to avoid ambiguity. For example consider:</source>
          <target state="translated">В простых случаях рассмотренный выше оператор конкатенации предпочтительнее прямого использования этих функций.Однако,поскольку оператор конкатенация перегружен для обслуживания всех трех случаев,возникают ситуации,когда использование одной из функций помогает избежать двусмысленности.Например,рассмотрим:</target>
        </trans-unit>
        <trans-unit id="4e5a889e9ac805b7a61b2cef1759227b4c01dc82" translate="yes" xml:space="preserve">
          <source>In some cases &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; shows additional execution statistics beyond the plan node execution times and row counts. For example, Sort and Hash nodes provide extra information:</source>
          <target state="translated">В некоторых случаях &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; показывает дополнительную статистику выполнения помимо времени выполнения узла плана и количества строк. Например, узлы сортировки и хеширования предоставляют дополнительную информацию:</target>
        </trans-unit>
        <trans-unit id="e8c81b00bcb69c8ee6819bdd31891ee097641a10" translate="yes" xml:space="preserve">
          <source>In some cases it is possible for a single SQL command to fire more than one kind of trigger. For instance an &lt;code&gt;INSERT&lt;/code&gt; with an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause may cause both insert and update operations, so it will fire both kinds of triggers as needed. The transition relations supplied to triggers are specific to their event type; thus an &lt;code&gt;INSERT&lt;/code&gt; trigger will see only the inserted rows, while an &lt;code&gt;UPDATE&lt;/code&gt; trigger will see only the updated rows.</source>
          <target state="translated">В некоторых случаях одна команда SQL может запускать несколько типов триггеров. Например, &lt;code&gt;INSERT&lt;/code&gt; с предложением &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; может вызывать как операции вставки, так и обновления, поэтому он будет запускать оба типа триггеров по мере необходимости. Отношения перехода, предоставляемые триггерам, зависят от их типа события; таким образом, триггер &lt;code&gt;INSERT&lt;/code&gt; будет видеть только вставленные строки, а триггер &lt;code&gt;UPDATE&lt;/code&gt; будет видеть только обновленные строки.</target>
        </trans-unit>
        <trans-unit id="f8731dce3dc14a003f46fc2608e777589eba29c9" translate="yes" xml:space="preserve">
          <source>In some cases it is useful to define table functions that can return different column sets depending on how they are invoked. To support this, the table function can be declared as returning the pseudo-type &lt;code&gt;record&lt;/code&gt; with no &lt;code&gt;OUT&lt;/code&gt; parameters. When such a function is used in a query, the expected row structure must be specified in the query itself, so that the system can know how to parse and plan the query. This syntax looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200831069c2086edb298c7a6b5677910ac8d156b" translate="yes" xml:space="preserve">
          <source>In some cases it is useful to define table functions that can return different column sets depending on how they are invoked. To support this, the table function can be declared as returning the pseudo-type &lt;code&gt;record&lt;/code&gt;. When such a function is used in a query, the expected row structure must be specified in the query itself, so that the system can know how to parse and plan the query. This syntax looks like:</source>
          <target state="translated">В некоторых случаях полезно определять табличные функции, которые могут возвращать разные наборы столбцов в зависимости от того, как они вызываются. Для поддержки этого табличную функцию можно объявить как возвращающую &lt;code&gt;record&lt;/code&gt; псевдотипа . Когда такая функция используется в запросе, ожидаемая структура строк должна быть указана в самом запросе, чтобы система могла знать, как анализировать и планировать запрос. Этот синтаксис выглядит так:</target>
        </trans-unit>
        <trans-unit id="6d89a4f32e25e9b6f4b0aae8fa4c3b33eb2b87fd" translate="yes" xml:space="preserve">
          <source>In some cases it might also be necessary to increase &lt;code&gt;SEMMAP&lt;/code&gt; to be at least on the order of &lt;code&gt;SEMMNS&lt;/code&gt;. If the system has this parameter (many do not), it defines the size of the semaphore resource map, in which each contiguous block of available semaphores needs an entry. When a semaphore set is freed it is either added to an existing entry that is adjacent to the freed block or it is registered under a new map entry. If the map is full, the freed semaphores get lost (until reboot). Fragmentation of the semaphore space could over time lead to fewer available semaphores than there should be.</source>
          <target state="translated">В некоторых случаях также может потребоваться увеличить &lt;code&gt;SEMMAP&lt;/code&gt; как минимум до уровня &lt;code&gt;SEMMNS&lt;/code&gt; . Если в системе есть этот параметр (у многих его нет), он определяет размер карты ресурсов семафоров, в которой каждому непрерывному блоку доступных семафоров требуется запись. Когда набор семафоров освобождается, он либо добавляется к существующей записи, которая находится рядом с освобожденным блоком, либо регистрируется под новой записью карты. Если карта заполнена, освобожденные семафоры теряются (до перезагрузки). Фрагментация пространства семафоров может со временем привести к меньшему количеству доступных семафоров, чем должно быть.</target>
        </trans-unit>
        <trans-unit id="c2c835a0ebddfd298ae5463818241acfed988912" translate="yes" xml:space="preserve">
          <source>In some cases several distinct distributions are needed which don't correlate with each other and this is when implicit seed parameter comes in handy:</source>
          <target state="translated">В некоторых случаях требуется несколько различных распределений,которые не коррелируют друг с другом,и это в тех случаях,когда пригодится неявный параметр семени:</target>
        </trans-unit>
        <trans-unit id="b659c8baf607682082fc2a028333f1abc817539f" translate="yes" xml:space="preserve">
          <source>In some cases the join style is easier to write or faster to execute than the sub-select style.</source>
          <target state="translated">В некоторых случаях стиль соединения легче написать или быстрее выполнить,чем стиль подвыбора.</target>
        </trans-unit>
        <trans-unit id="cc280a2801256511a801ad6396d782aaf11a1fd5" translate="yes" xml:space="preserve">
          <source>In some cases the planner will prefer a &amp;ldquo;simple&amp;rdquo; index scan plan:</source>
          <target state="translated">В некоторых случаях планировщик предпочтет &amp;laquo;простой&amp;raquo; план сканирования индекса:</target>
        </trans-unit>
        <trans-unit id="0752bfbb1e8e2f35c9e16d26381cb349bc520d2f" translate="yes" xml:space="preserve">
          <source>In some cases you might wish to know which table a particular row originated from. There is a system column called &lt;code&gt;tableoid&lt;/code&gt; in each table which can tell you the originating table:</source>
          <target state="translated">В некоторых случаях вы можете захотеть узнать, из какой таблицы возникла конкретная строка. В каждой таблице есть системный столбец под названием &lt;code&gt;tableoid&lt;/code&gt; , который может указать вам исходную таблицу:</target>
        </trans-unit>
        <trans-unit id="85aa180babf965f446d9b4ca6c81be1df71986fd" translate="yes" xml:space="preserve">
          <source>In some cases, a user will know that a given XPath query will return only a single result (perhaps a unique document identifier) &amp;mdash; if used alongside an XPath query returning multiple results, the single-valued result will appear only on the first row of the result. The solution to this is to use the key field as part of a join against a simpler XPath query. As an example:</source>
          <target state="translated">В некоторых случаях пользователь будет знать, что данный запрос XPath вернет только один результат (возможно, уникальный идентификатор документа) - при использовании вместе с запросом XPath, возвращающим несколько результатов, однозначный результат будет отображаться только в первой строке результат. Решение этой проблемы - использовать ключевое поле как часть соединения с более простым запросом XPath. Например:</target>
        </trans-unit>
        <trans-unit id="ca377880ca6732de73ffe88d7d610d10f88a2a04" translate="yes" xml:space="preserve">
          <source>In some cases, an external storage product can be accessed either via NFS or a lower-level protocol such as iSCSI. In the latter case, the storage appears as a block device and any available file system can be created on it. That approach might relieve the DBA from having to deal with some of the idiosyncrasies of NFS, but of course the complexity of managing remote storage then happens at other levels.</source>
          <target state="translated">В некоторых случаях доступ к внешнему запоминающему устройству можно получить либо через NFS,либо через протокол нижнего уровня,например iSCSI.В последнем случае хранилище выглядит как блочное устройство,на котором можно создать любую доступную файловую систему.Такой подход может избавить DBA от необходимости иметь дело с некоторыми идиосинкразиями NFS,но,конечно же,сложность управления удаленным хранилищем возникает и на других уровнях.</target>
        </trans-unit>
        <trans-unit id="4cdce5fe180ac016fd38728542336a4cccb6659d" translate="yes" xml:space="preserve">
          <source>In some cases, queries with visibly different texts might get merged into a single &lt;code&gt;pg_stat_statements&lt;/code&gt; entry. Normally this will happen only for semantically equivalent queries, but there is a small chance of hash collisions causing unrelated queries to be merged into one entry. (This cannot happen for queries belonging to different users or databases, however.)</source>
          <target state="translated">В некоторых случаях запросы с явно разными текстами могут быть объединены в одну запись &lt;code&gt;pg_stat_statements&lt;/code&gt; . Обычно это происходит только для семантически эквивалентных запросов, но существует небольшая вероятность коллизии хешей, вызывающих слияние несвязанных запросов в одну запись. (Однако этого не может произойти для запросов, принадлежащих разным пользователям или базам данных.)</target>
        </trans-unit>
        <trans-unit id="3587765c2705ba8328ac5e625d50c99ae816e4fe" translate="yes" xml:space="preserve">
          <source>In some contexts it is important to be sure that row security is not being applied. For example, when taking a backup, it could be disastrous if row security silently caused some rows to be omitted from the backup. In such a situation, you can set the &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; configuration parameter to &lt;code&gt;off&lt;/code&gt;. This does not in itself bypass row security; what it does is throw an error if any query's results would get filtered by a policy. The reason for the error can then be investigated and fixed.</source>
          <target state="translated">В некоторых случаях важно убедиться, что безопасность строк не применяется. Например, при создании резервной копии может быть катастрофой, если система безопасности строк автоматически вынудит некоторые строки быть исключены из резервной копии. В такой ситуации, вы можете установить &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; параметр конфигурации для &lt;code&gt;off&lt;/code&gt; . Само по себе это не обходит защиту строк; он выдает ошибку, если результаты любого запроса будут отфильтрованы политикой. После этого можно выяснить причину ошибки и устранить ее.</target>
        </trans-unit>
        <trans-unit id="b9ce77934cf9885a03a2ac3b7887461d3a1cb010" translate="yes" xml:space="preserve">
          <source>In some contexts, backslashes must be doubled compared to what is shown above, because the generic string-literal parser will also reduce pairs of backslashes to one data character; see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt;.</source>
          <target state="translated">В некоторых контекстах обратная косая черта должна быть удвоена по сравнению с тем, что показано выше, потому что общий синтаксический анализатор строкового литерала также сокращает пары обратной косой черты до одного символа данных; см. &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;раздел 4.1.2.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad2914b6fce7d3aa951198848f0bae1a566122fb" translate="yes" xml:space="preserve">
          <source>In some query plans, it is possible for a subplan node to be executed more than once. For example, the inner index scan will be executed once per outer row in the above nested-loop plan. In such cases, the &lt;code&gt;loops&lt;/code&gt; value reports the total number of executions of the node, and the actual time and rows values shown are averages per-execution. This is done to make the numbers comparable with the way that the cost estimates are shown. Multiply by the &lt;code&gt;loops&lt;/code&gt; value to get the total time actually spent in the node. In the above example, we spent a total of 0.220 milliseconds executing the index scans on &lt;code&gt;tenk2&lt;/code&gt;.</source>
          <target state="translated">В некоторых планах запросов возможно выполнение узла подплана более одного раза. Например, сканирование внутреннего индекса будет выполняться один раз для каждой внешней строки в приведенном выше плане вложенного цикла. В таких случаях &lt;code&gt;loops&lt;/code&gt; значение сообщает общее количество выполнений узла, а фактическое время и значение строк показаны средние за-исполнения. Это сделано для того, чтобы цифры были сопоставимы с тем, как отображается смета расходов. Умножение с помощью &lt;code&gt;loops&lt;/code&gt; дорожит , чтобы получить общее время фактически проведенное в узле. В приведенном выше примере мы потратили в общей сложности 0,220 миллисекунды на выполнение сканирования индекса на &lt;code&gt;tenk2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="225981494667f7eae039a8f3a624ead9ac2ba414" translate="yes" xml:space="preserve">
          <source>In some situations it is worthwhile to rebuild indexes periodically with the &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; command or a series of individual rebuilding steps.</source>
          <target state="translated">В некоторых ситуациях целесообразно периодически перестраивать индексы с &lt;a href=&quot;sql-reindex&quot;&gt;помощью&lt;/a&gt; команды REINDEX или серии отдельных шагов перестроения.</target>
        </trans-unit>
        <trans-unit id="c7e0f45ec00183e0785ecaf537d621d39641ace7" translate="yes" xml:space="preserve">
          <source>In some situations, examining each possible way in which a query can be executed would take an excessive amount of time and memory space. In particular, this occurs when executing queries involving large numbers of join operations. In order to determine a reasonable (not necessarily optimal) query plan in a reasonable amount of time, PostgreSQL uses a &lt;em&gt;Genetic Query Optimizer&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;) when the number of joins exceeds a threshold (see &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;).</source>
          <target state="translated">В некоторых ситуациях изучение каждого возможного способа выполнения запроса потребует чрезмерного количества времени и места в памяти. В частности, это происходит при выполнении запросов, включающих большое количество операций соединения. Чтобы определить разумный (не обязательно оптимальный) план запроса за разумный промежуток времени, PostgreSQL использует &lt;em&gt;генетический оптимизатор запросов&lt;/em&gt; (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Главу 59&lt;/a&gt; ), когда количество соединений превышает пороговое значение (см. &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;Geqo_threshold&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="02656e92c47f92204fc3dc37bed1c7e28f95de50" translate="yes" xml:space="preserve">
          <source>In some situations, examining each possible way in which a query can be executed would take an excessive amount of time and memory space. In particular, this occurs when executing queries involving large numbers of join operations. In order to determine a reasonable (not necessarily optimal) query plan in a reasonable amount of time, PostgreSQL uses a &lt;em&gt;Genetic Query Optimizer&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;) when the number of joins exceeds a threshold (see &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44a40fdd52559ad494c2c8c248a6de473d41182" translate="yes" xml:space="preserve">
          <source>In standby mode, the server continuously applies WAL received from the master server. The standby server can read WAL from a WAL archive (see &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt;) or directly from the master over a TCP connection (streaming replication). The standby server will also attempt to restore any WAL found in the standby cluster's &lt;code&gt;pg_wal&lt;/code&gt; directory. That typically happens after a server restart, when the standby replays again WAL that was streamed from the master before the restart, but you can also manually copy files to &lt;code&gt;pg_wal&lt;/code&gt; at any time to have them replayed.</source>
          <target state="translated">В режиме ожидания сервер постоянно применяет WAL, полученный от главного сервера. Резервный сервер может читать WAL из архива WAL (см. &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;Restore_command&lt;/a&gt; ) или напрямую с главного по TCP-соединению (потоковая репликация). Резервный сервер также попытается восстановить любой WAL, обнаруженный в каталоге &lt;code&gt;pg_wal&lt;/code&gt; резервного кластера . Обычно это происходит после перезапуска сервера, когда резервный снова воспроизводит WAL, который был передан с ведущего устройства перед перезапуском, но вы также можете вручную скопировать файлы в &lt;code&gt;pg_wal&lt;/code&gt; в любое время для их воспроизведения.</target>
        </trans-unit>
        <trans-unit id="fe531d3ac4f289af249052c7bd344a8eccac974a" translate="yes" xml:space="preserve">
          <source>In strict SQL, &lt;code&gt;GROUP BY&lt;/code&gt; can only group by columns of the source table but PostgreSQL extends this to also allow &lt;code&gt;GROUP BY&lt;/code&gt; to group by columns in the select list. Grouping by value expressions instead of simple column names is also allowed.</source>
          <target state="translated">В строгом SQL &lt;code&gt;GROUP BY&lt;/code&gt; может группироваться только по столбцам исходной таблицы, но PostgreSQL расширяет это, чтобы также позволить &lt;code&gt;GROUP BY&lt;/code&gt; группировать по столбцам в списке выбора. Также допускается группировка по выражениям значений вместо простых имен столбцов.</target>
        </trans-unit>
        <trans-unit id="925d63461b4ad93eaf09cda8debcd8a2f6185160" translate="yes" xml:space="preserve">
          <source>In such a column, all entries must use the symbolic format except when writing &lt;code&gt;0&lt;/code&gt; for InvalidOid. (If the column is declared &lt;code&gt;regproc&lt;/code&gt;, you can optionally write &lt;code&gt;-&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt;.) &lt;code&gt;genbki.pl&lt;/code&gt; will warn about unrecognized names.</source>
          <target state="translated">В таком столбце все записи должны использовать символический формат, за исключением записи &lt;code&gt;0&lt;/code&gt; для InvalidOid. (Если столбец объявлен как &lt;code&gt;regproc&lt;/code&gt; , вы можете по желанию написать &lt;code&gt;-&lt;/code&gt; вместо &lt;code&gt;0&lt;/code&gt; . ) &lt;code&gt;genbki.pl&lt;/code&gt; предупредит о нераспознанных именах.</target>
        </trans-unit>
        <trans-unit id="f44470ab677292f080ad629e5021dd422bb50329" translate="yes" xml:space="preserve">
          <source>In synchronous multimaster replication, each server can accept write requests, and modified data is transmitted from the original server to every other server before each transaction commits. Heavy write activity can cause excessive locking and commit delays, leading to poor performance. Read requests can be sent to any server. Some implementations use shared disk to reduce the communication overhead. Synchronous multimaster replication is best for mostly read workloads, though its big advantage is that any server can accept write requests &amp;mdash; there is no need to partition workloads between master and standby servers, and because the data changes are sent from one server to another, there is no problem with non-deterministic functions like &lt;code&gt;random()&lt;/code&gt;.</source>
          <target state="translated">При синхронной репликации с несколькими хозяевами каждый сервер может принимать запросы на запись, и измененные данные передаются с исходного сервера на каждый другой сервер до того, как каждая транзакция будет зафиксирована. Активная запись может вызвать чрезмерную блокировку и задержки фиксации, что приведет к снижению производительности. Запросы на чтение можно отправлять на любой сервер. В некоторых реализациях используется общий диск для уменьшения накладных расходов на связь. Синхронная многомастерная репликация лучше всего подходит для рабочих нагрузок чтения, хотя ее большим преимуществом является то, что любой сервер может принимать запросы на запись - нет необходимости разделять рабочие нагрузки между главным и резервным серверами, и поскольку изменения данных отправляются с одного сервера на другой, не проблема с недетерминированными функциями, такими как &lt;code&gt;random()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c4b878fdf07a28c13f143cacc8a5bb3f8880019" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;.affix&lt;/code&gt; file every affix flag is described in the following format:</source>
          <target state="translated">В файле &lt;code&gt;.affix&lt;/code&gt; каждый флаг аффикса описывается в следующем формате:</target>
        </trans-unit>
        <trans-unit id="08a1ad04eb220026fbfc94b398836d4cbc2cae8c" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; frame options, the &lt;code&gt;offset&lt;/code&gt; must be an expression not containing any variables, aggregate functions, or window functions. The meaning of the &lt;code&gt;offset&lt;/code&gt; depends on the frame mode:</source>
          <target state="translated">В параметрах кадра &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;PRECEDING&lt;/code&gt; и &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;FOLLOWING&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; должно быть выражением, не содержащим никаких переменных, агрегатных функций или оконных функций. Значение &lt;code&gt;offset&lt;/code&gt; зависит от режима кадра:</target>
        </trans-unit>
        <trans-unit id="27bf78dd19410e50d81449e21eeb4a9c340ecbaa" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;prepared&lt;/code&gt; mode, pgbench reuses the parse analysis result starting from the second query iteration, so pgbench runs faster than in other modes.</source>
          <target state="translated">В &lt;code&gt;prepared&lt;/code&gt; режиме pgbench повторно использует результат анализа синтаксического анализа, начиная со второй итерации запроса, поэтому pgbench работает быстрее, чем в других режимах.</target>
        </trans-unit>
        <trans-unit id="7dd20a44a8914e7e3854e6b8cc2dd765d950b1b2" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;template0&lt;/code&gt; database, it could be useful to create collations whose encoding does not match the database encoding, since they could match the encodings of databases later cloned from &lt;code&gt;template0&lt;/code&gt;. This would currently have to be done manually.</source>
          <target state="translated">В базе данных &lt;code&gt;template0&lt;/code&gt; может быть полезно создавать сопоставления, кодировка которых не соответствует кодировке базы данных, поскольку они могут соответствовать кодировкам баз данных, позже клонированных из &lt;code&gt;template0&lt;/code&gt; . В настоящее время это нужно делать вручную.</target>
        </trans-unit>
        <trans-unit id="ee7442c19df868ba3ec76972f6eb3be85838007a" translate="yes" xml:space="preserve">
          <source>In the ISO week-numbering system, it is possible for early-January dates to be part of the 52nd or 53rd week of the previous year, and for late-December dates to be part of the first week of the next year. For example, &lt;code&gt;2005-01-01&lt;/code&gt; is part of the 53rd week of year 2004, and &lt;code&gt;2006-01-01&lt;/code&gt; is part of the 52nd week of year 2005, while &lt;code&gt;2012-12-31&lt;/code&gt; is part of the first week of 2013. It's recommended to use the &lt;code&gt;isoyear&lt;/code&gt; field together with &lt;code&gt;week&lt;/code&gt; to get consistent results.</source>
          <target state="translated">В системе нумерации недель ISO даты начала января могут быть частью 52-й или 53-й недели предыдущего года, а даты конца декабря - частью первой недели следующего года. Например, &lt;code&gt;2005-01-01&lt;/code&gt; является частью 53-й недели 2004 года, а &lt;code&gt;2006-01-01&lt;/code&gt; - частью 52-й недели 2005 года, а &lt;code&gt;2012-12-31&lt;/code&gt; - частью первой недели 2013 года. рекомендуется использовать поле &lt;code&gt;isoyear&lt;/code&gt; вместе с &lt;code&gt;week&lt;/code&gt; для получения стабильных результатов.</target>
        </trans-unit>
        <trans-unit id="e2cd521bd47287d9192e9d5c00cd5e2a6b143afe" translate="yes" xml:space="preserve">
          <source>In the PostgreSQL parser life is a bit more complicated. There are several different classes of tokens ranging from those that can never be used as an identifier to those that have absolutely no special status in the parser as compared to an ordinary identifier. (The latter is usually the case for functions specified by SQL.) Even reserved key words are not completely reserved in PostgreSQL, but can be used as column labels (for example, &lt;code&gt;SELECT 55 AS CHECK&lt;/code&gt;, even though &lt;code&gt;CHECK&lt;/code&gt; is a reserved key word).</source>
          <target state="translated">В парсере PostgreSQL жизнь немного сложнее. Существует несколько различных классов токенов, от тех, которые никогда не могут использоваться в качестве идентификатора, до тех, которые не имеют абсолютно никакого особого статуса в анализаторе по сравнению с обычным идентификатором. (Последнее обычно относится к функциям, указанным в SQL.) Даже зарезервированные ключевые слова не полностью зарезервированы в PostgreSQL, но могут использоваться как метки столбцов (например, &lt;code&gt;SELECT 55 AS CHECK&lt;/code&gt; , даже если &lt;code&gt;CHECK&lt;/code&gt; является зарезервированным ключевым словом) .</target>
        </trans-unit>
        <trans-unit id="c06a771ae535ebcc1c02437d6d6edcaa369ff63e" translate="yes" xml:space="preserve">
          <source>In the SQL and POSTGRES styles, day appears before month if DMY field ordering has been specified, otherwise month appears before day. (See &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-INPUT&quot;&gt;Section 8.5.1&lt;/a&gt; for how this setting also affects interpretation of input values.) &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT2-TABLE&quot;&gt;Table 8.15&lt;/a&gt; shows examples.</source>
          <target state="translated">В стилях SQL и POSTGRES день отображается перед месяцем, если задан порядок полей DMY, в противном случае месяц отображается перед днем. (См. &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-INPUT&quot;&gt;Раздел 8.5.1,&lt;/a&gt; чтобы узнать, как этот параметр также влияет на интерпретацию входных значений.) В &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT2-TABLE&quot;&gt;таблице 8.15&lt;/a&gt; приведены примеры.</target>
        </trans-unit>
        <trans-unit id="84b70dca4dd2a2a4e41665aeb47157cc98221d20" translate="yes" xml:space="preserve">
          <source>In the SQL standard, sequences only have a &lt;code&gt;USAGE&lt;/code&gt; privilege, which controls the use of the &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; expression, which is equivalent to the function &lt;code&gt;nextval&lt;/code&gt; in PostgreSQL. The sequence privileges &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; are PostgreSQL extensions. The application of the sequence &lt;code&gt;USAGE&lt;/code&gt; privilege to the &lt;code&gt;currval&lt;/code&gt; function is also a PostgreSQL extension (as is the function itself).</source>
          <target state="translated">В стандарте SQL последовательности имеют только привилегию &lt;code&gt;USAGE&lt;/code&gt; , которая контролирует использование выражения &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; , которое эквивалентно функции &lt;code&gt;nextval&lt;/code&gt; в PostgreSQL. Привилегии последовательности &lt;code&gt;SELECT&lt;/code&gt; и &lt;code&gt;UPDATE&lt;/code&gt; являются расширениями PostgreSQL. Применение привилегии &lt;code&gt;USAGE&lt;/code&gt; к последовательности для функции &lt;code&gt;currval&lt;/code&gt; также является расширением PostgreSQL (как и сама функция).</target>
        </trans-unit>
        <trans-unit id="fcd4626eefede972e087ae6e07462757a1b0e1ce" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the &lt;code&gt;xmlexists&lt;/code&gt; function evaluates an expression in the XML Query language, but PostgreSQL allows only an XPath 1.0 expression, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;Section D.3.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d7a869224d4569093b25b6e2276773eb285b56" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the &lt;code&gt;xmltable&lt;/code&gt; function evaluates expressions in the XML Query language, but PostgreSQL allows only XPath 1.0 expressions, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;Section D.3.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9660d94d0a1b58a81d974d699a1bce336010b697" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the notion of objects in the same schema being owned by different users does not exist. Moreover, some implementations do not allow you to create schemas that have a different name than their owner. In fact, the concepts of schema and user are nearly equivalent in a database system that implements only the basic schema support specified in the standard. Therefore, many users consider qualified names to really consist of &lt;code&gt;user_name.table_name&lt;/code&gt;. This is how PostgreSQL will effectively behave if you create a per-user schema for every user.</source>
          <target state="translated">В стандарте SQL не существует понятия, что объекты в одной схеме принадлежат разным пользователям. Более того, некоторые реализации не позволяют создавать схемы с именем, отличным от имени владельца. Фактически, концепции схемы и пользователя почти эквивалентны в системе баз данных, которая реализует только базовую поддержку схемы, указанную в стандарте. Поэтому многие пользователи считают, что полные имена действительно состоят из &lt;code&gt;user_name.table_name&lt;/code&gt; . Вот как будет эффективно себя вести PostgreSQL, если вы создадите схему для каждого пользователя.</target>
        </trans-unit>
        <trans-unit id="bce55523e60490fd9a9b255e77d45bae3da990ba" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the optional key word &lt;code&gt;AS&lt;/code&gt; can be omitted before an output column name whenever the new column name is a valid column name (that is, not the same as any reserved keyword). PostgreSQL is slightly more restrictive: &lt;code&gt;AS&lt;/code&gt; is required if the new column name matches any keyword at all, reserved or not. Recommended practice is to use &lt;code&gt;AS&lt;/code&gt; or double-quote output column names, to prevent any possible conflict against future keyword additions.</source>
          <target state="translated">В стандарте SQL необязательное ключевое слово &lt;code&gt;AS&lt;/code&gt; может быть опущено перед именем выходного столбца, если новое имя столбца является допустимым именем столбца (то есть не таким, как любое зарезервированное ключевое слово). PostgreSQL немного более строгий: &lt;code&gt;AS&lt;/code&gt; требуется, если новое имя столбца совпадает с каким-либо ключевым словом, зарезервированным или нет. Рекомендуемая практика - использовать &lt;code&gt;AS&lt;/code&gt; или имена выходных столбцов в двойных кавычках, чтобы предотвратить любой возможный конфликт с будущими добавлениями ключевых слов.</target>
        </trans-unit>
        <trans-unit id="60fb33ea7714daeb182a1d8cf938445a4efd08dd" translate="yes" xml:space="preserve">
          <source>In the SQL standard, there is a clear distinction between users and roles, and users do not automatically inherit privileges while roles do. This behavior can be obtained in PostgreSQL by giving roles being used as SQL roles the &lt;code&gt;INHERIT&lt;/code&gt; attribute, while giving roles being used as SQL users the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute. However, PostgreSQL defaults to giving all roles the &lt;code&gt;INHERIT&lt;/code&gt; attribute, for backward compatibility with pre-8.1 releases in which users always had use of permissions granted to groups they were members of.</source>
          <target state="translated">В стандарте SQL существует четкое различие между пользователями и ролями, и пользователи не наследуют привилегии автоматически, в отличие от ролей. Такое поведение можно получить в PostgreSQL, задав для ролей, используемых в качестве ролей SQL, атрибут &lt;code&gt;INHERIT&lt;/code&gt; , а для ролей, используемых в качестве пользователей SQL, - атрибут &lt;code&gt;NOINHERIT&lt;/code&gt; . Однако PostgreSQL по умолчанию предоставляет всем ролям атрибут &lt;code&gt;INHERIT&lt;/code&gt; для обратной совместимости с выпусками до 8.1, в которых пользователи всегда использовали разрешения, предоставленные группам, членами которых они были.</target>
        </trans-unit>
        <trans-unit id="4d55ecfda5316639c09ff6bb19e9602eb2f98338" translate="yes" xml:space="preserve">
          <source>In the SQL standard, there is one other transaction characteristic that can be set with these commands: the size of the diagnostics area. This concept is specific to embedded SQL, and therefore is not implemented in the PostgreSQL server.</source>
          <target state="translated">В стандарте SQL есть еще одна характеристика транзакции,которую можно задать с помощью этих команд:размер области диагностики.Эта концепция специфична для встроенного SQL,и поэтому не реализована на сервере PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="ed36ad7d98cb4d8fee32b855fb6fed744837b0e0" translate="yes" xml:space="preserve">
          <source>In the SQL-92 standard, an &lt;code&gt;ORDER BY&lt;/code&gt; clause can only use output column names or numbers, while a &lt;code&gt;GROUP BY&lt;/code&gt; clause can only use expressions based on input column names. PostgreSQL extends each of these clauses to allow the other choice as well (but it uses the standard's interpretation if there is ambiguity). PostgreSQL also allows both clauses to specify arbitrary expressions. Note that names appearing in an expression will always be taken as input-column names, not as output-column names.</source>
          <target state="translated">В стандарте SQL-92 предложение &lt;code&gt;ORDER BY&lt;/code&gt; может использовать только имена или числа выходных столбцов, тогда как предложение &lt;code&gt;GROUP BY&lt;/code&gt; может использовать только выражения, основанные на именах входных столбцов. PostgreSQL расширяет каждое из этих предложений, чтобы разрешить и другой выбор (но он использует стандартную интерпретацию, если есть двусмысленность). PostgreSQL также позволяет в обоих предложениях указывать произвольные выражения. Обратите внимание, что имена, появляющиеся в выражении, всегда будут восприниматься как имена входных столбцов, а не как имена выходных столбцов.</target>
        </trans-unit>
        <trans-unit id="b054bfec2bce610e705197d361e44d3c2768bb83" translate="yes" xml:space="preserve">
          <source>In the XQuery/XPath data model, a &lt;em&gt;document node&lt;/em&gt; can have either document form (i.e., exactly one top-level element, with only comments and processing instructions outside of it) or content form (with those constraints relaxed). Its equivalent in XPath 1.0, the &lt;em&gt;root node&lt;/em&gt;, can only be in document form. This is part of the reason an &lt;code&gt;xml&lt;/code&gt; value passed as the context item to any PostgreSQL XPath-based function must be in document form.</source>
          <target state="translated">В модели данных XQuery / XPath &lt;em&gt;узел документа&lt;/em&gt; может иметь либо форму документа (т. Е. Ровно один элемент верхнего уровня, только с комментариями и инструкциями по обработке вне его), либо форму содержимого (с ослабленными ограничениями). Его эквивалент в XPath 1.0, &lt;em&gt;корневой узел&lt;/em&gt; , может быть только в форме документа. Это одна из причин, по которой значение &lt;code&gt;xml&lt;/code&gt; , передаваемое в качестве элемента контекста любой функции PostgreSQL на основе XPath, должно быть в форме документа.</target>
        </trans-unit>
        <trans-unit id="907c04147bb1d71b5f0459b5e753db080d794777" translate="yes" xml:space="preserve">
          <source>In the above example we would be creating a new partition each month, so it might be wise to write a script that generates the required DDL automatically.</source>
          <target state="translated">В приведенном выше примере мы бы создавали новый раздел каждый месяц,так что,возможно,было бы разумно написать скрипт,который автоматически генерирует требуемую DDL.</target>
        </trans-unit>
        <trans-unit id="652407089ebdeac3fe06a048bf54ac1385a35fc9" translate="yes" xml:space="preserve">
          <source>In the above example, the new password isn't actually echoed when typed, but we show what was typed for clarity. As you see, the password is encrypted before it is sent to the client.</source>
          <target state="translated">В вышеприведенном примере новый пароль на самом деле не повторяется при наборе,но мы показываем,что было набрано для большей ясности.Как видите,пароль зашифрован перед отправкой клиенту.</target>
        </trans-unit>
        <trans-unit id="a28671e837ffe13c54dd539a74a6f7de604de65e" translate="yes" xml:space="preserve">
          <source>In the above output, the free space figures may not match the &lt;code&gt;pgstattuple&lt;/code&gt; output exactly, because the free space map gives us an exact figure, but is not guaranteed to be accurate to the byte.</source>
          <target state="translated">В приведенном выше выводе цифры свободного пространства могут не совпадать в &lt;code&gt;pgstattuple&lt;/code&gt; выводом pgstattuple , потому что карта свободного пространства дает нам точную цифру, но не гарантирует точность до байта.</target>
        </trans-unit>
        <trans-unit id="cfee998fb713aa32e0b0a461f86fb14fa87aa018" translate="yes" xml:space="preserve">
          <source>In the above queries, the second form is dangerous because the &lt;code&gt;LIMIT&lt;/code&gt; is not guaranteed to be applied before the locking function is executed. This might cause some locks to be acquired that the application was not expecting, and hence would fail to release (until it ends the session). From the point of view of the application, such locks would be dangling, although still viewable in &lt;code&gt;pg_locks&lt;/code&gt;.</source>
          <target state="translated">В приведенных выше запросах вторая форма опасна, потому что не гарантируется применение &lt;code&gt;LIMIT&lt;/code&gt; до выполнения функции блокировки. Это может привести к получению некоторых блокировок, которых приложение не ожидало, и, следовательно, не сможет освободиться (пока не завершит сеанс). С точки зрения приложения, такие блокировки будут &lt;code&gt;pg_locks&lt;/code&gt; , хотя их можно будет просмотреть в pg_locks .</target>
        </trans-unit>
        <trans-unit id="0422400fe004db1267465196296a34921629ca1c" translate="yes" xml:space="preserve">
          <source>In the above query, the arguments &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are specified positionally, while &lt;code&gt;uppercase&lt;/code&gt; is specified by name. In this example, that adds little except documentation. With a more complex function having numerous parameters that have default values, named or mixed notation can save a great deal of writing and reduce chances for error.</source>
          <target state="translated">В приведенном выше запросе аргументы &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; указаны позиционно, а &lt;code&gt;uppercase&lt;/code&gt; - по имени. В этом примере это не добавляет ничего, кроме документации. В более сложной функции, имеющей множество параметров, имеющих значения по умолчанию, именованная или смешанная нотация может сэкономить много времени на написание и снизить вероятность ошибки.</target>
        </trans-unit>
        <trans-unit id="523e1fdbf28526b9fd09539320b970501acbeb30" translate="yes" xml:space="preserve">
          <source>In the absence of any explicit quantifier, the default for a star symbol is to match any number of labels (that is, &lt;code&gt;{,}&lt;/code&gt;) while the default for a non-star item is to match exactly once (that is, &lt;code&gt;{1}&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12fe4f57925256d624bd6eb274cf2330b45da284" translate="yes" xml:space="preserve">
          <source>In the absence of fatal errors, pg_receivewal will run until terminated by the SIGINT signal (&lt;strong&gt;Control&lt;/strong&gt;+&lt;strong&gt;C&lt;/strong&gt;).</source>
          <target state="translated">При отсутствии фатальных ошибок pg_receivewal будет выполняться до тех пор, пока не будет завершена сигналом SIGINT ( &lt;strong&gt;Control&lt;/strong&gt; + &lt;strong&gt;C&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="e6c9650fa107be76e508c9f6a766e1575673cf8c" translate="yes" xml:space="preserve">
          <source>In the alternative format:</source>
          <target state="translated">В альтернативном формате:</target>
        </trans-unit>
        <trans-unit id="c2e1ceee33301b36828cf2caae1f68eec137b740" translate="yes" xml:space="preserve">
          <source>In the case of a parallel dump, the snapshot name defined by this option is used rather than taking a new snapshot.</source>
          <target state="translated">В случае параллельного дампа используется имя снимка,определенное данной опцией,а не делается новый снимок.</target>
        </trans-unit>
        <trans-unit id="2a04ddae39deed0bb63ddc81c6701d5c2ad86b55" translate="yes" xml:space="preserve">
          <source>In the case of a partitioned table, updating a row might cause it to no longer satisfy the partition constraint of the containing partition. In that case, if there is some other partition in the partition tree for which this row satisfies its partition constraint, then the row is moved to that partition. If there is no such partition, an error will occur. Behind the scenes, the row movement is actually a &lt;code&gt;DELETE&lt;/code&gt; and &lt;code&gt;INSERT&lt;/code&gt; operation.</source>
          <target state="translated">В случае секционированной таблицы обновление строки может привести к тому, что она больше не будет удовлетворять ограничению секционирования содержащей ее секции. В этом случае, если в дереве разделов есть другой раздел, для которого эта строка удовлетворяет ограничению разделения, то строка перемещается в этот раздел. Если такого раздела нет, возникнет ошибка. За кулисами перемещение строки на самом деле является операцией &lt;code&gt;DELETE&lt;/code&gt; и &lt;code&gt;INSERT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5544906e3d293a0a9ad12a92567f1204d11f1dd6" translate="yes" xml:space="preserve">
          <source>In the case of an exclusion constraint, &lt;code&gt;conkey&lt;/code&gt; is only useful for constraint elements that are simple column references. For other cases, a zero appears in &lt;code&gt;conkey&lt;/code&gt; and the associated index must be consulted to discover the expression that is constrained. (&lt;code&gt;conkey&lt;/code&gt; thus has the same contents as &lt;code&gt;pg_index&lt;/code&gt;.&lt;code&gt;indkey&lt;/code&gt; for the index.)</source>
          <target state="translated">В случае ограничения исключения &lt;code&gt;conkey&lt;/code&gt; полезно только для элементов ограничения, которые являются простыми ссылками на столбцы. В других случаях в &lt;code&gt;conkey&lt;/code&gt; появляется ноль, и необходимо обращаться к соответствующему индексу, чтобы обнаружить выражение, которое ограничено. ( &lt;code&gt;conkey&lt;/code&gt; образом, conkey имеет то же содержимое, что и &lt;code&gt;pg_index&lt;/code&gt; . &lt;code&gt;indkey&lt;/code&gt; для индекса.)</target>
        </trans-unit>
        <trans-unit id="e4fef774ebd3ff2e38db3236bd03a350ace1f35c" translate="yes" xml:space="preserve">
          <source>In the common case where you just want the whole matching substring or &lt;code&gt;NULL&lt;/code&gt; for no match, write something like</source>
          <target state="translated">В общем случае, когда вам просто нужна вся совпадающая подстрока или &lt;code&gt;NULL&lt;/code&gt; ,если совпадения нет, напишите что-нибудь вроде</target>
        </trans-unit>
        <trans-unit id="d8de3d9b49ffb3cc570c884fc7d3dde953f8a262" translate="yes" xml:space="preserve">
          <source>In the context of &lt;code&gt;INSERT&lt;/code&gt;, entries of a &lt;code&gt;VALUES&lt;/code&gt; list can be &lt;code&gt;DEFAULT&lt;/code&gt; to indicate that the column default should be used here instead of specifying a value:</source>
          <target state="translated">В контексте &lt;code&gt;INSERT&lt;/code&gt; записи списка &lt;code&gt;VALUES&lt;/code&gt; могут иметь значение &lt;code&gt;DEFAULT&lt;/code&gt; , чтобы указать, что здесь следует использовать значение по умолчанию для столбца вместо указания значения:</target>
        </trans-unit>
        <trans-unit id="0a8a6bb89f9ea4433f27de55629e036adfed0508" translate="yes" xml:space="preserve">
          <source>In the current implementation, the fitness of each candidate join sequence is estimated by running the standard planner's join selection and cost estimation code from scratch. To the extent that different candidates use similar sub-sequences of joins, a great deal of work will be repeated. This could be made significantly faster by retaining cost estimates for sub-joins. The problem is to avoid expending unreasonable amounts of memory on retaining that state.</source>
          <target state="translated">В текущей реализации,пригодность каждой последовательности соединения кандидатов оценивается путем запуска стандартного кода выбора соединения планировщика и оценки стоимости с нуля.До тех пор,пока различные кандидаты будут использовать одинаковые последовательности соединений,будет выполнен большой объем работы.Это можно сделать значительно быстрее,сохранив смету расходов на суб-соединение.Проблема заключается в том,чтобы не тратить неоправданные объемы памяти на сохранение этого состояния.</target>
        </trans-unit>
        <trans-unit id="7b88d112fefbb18a9a94530a4a12e322eca2805d" translate="yes" xml:space="preserve">
          <source>In the default PostgreSQL configuration, the autovacuum daemon (see &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt;) takes care of automatic analyzing of tables when they are first loaded with data, and as they change throughout regular operation. When autovacuum is disabled, it is a good idea to run &lt;code&gt;ANALYZE&lt;/code&gt; periodically, or just after making major changes in the contents of a table. Accurate statistics will help the planner to choose the most appropriate query plan, and thereby improve the speed of query processing. A common strategy for read-mostly databases is to run &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; once a day during a low-usage time of day. (This will not be sufficient if there is heavy update activity.)</source>
          <target state="translated">В конфигурации PostgreSQL по умолчанию демон автоочистки (см. &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Раздел 24.1.6&lt;/a&gt; ) заботится об автоматическом анализе таблиц, когда они впервые загружаются с данными, а также по мере их изменения во время обычной работы. Когда автоочистка отключена, рекомендуется запускать &lt;code&gt;ANALYZE&lt;/code&gt; периодически или сразу после внесения значительных изменений в содержимое таблицы. Точная статистика поможет планировщику выбрать наиболее подходящий план запроса и тем самым повысить скорость обработки запроса. Распространенной стратегией для баз данных, предназначенных в основном для чтения, является запуск &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; и &lt;code&gt;ANALYZE&lt;/code&gt; один раз в день в течение дня с низкой загрузкой. (Этого будет недостаточно при большой активности обновлений.)</target>
        </trans-unit>
        <trans-unit id="4ce2b63a8b5343bbf7125e0114e2a04ce0d2bde8" translate="yes" xml:space="preserve">
          <source>In the default setup this returns:</source>
          <target state="translated">В настройках по умолчанию это возвращается:</target>
        </trans-unit>
        <trans-unit id="596bcd2b70e5eeabccdcbaf0d79d2c517c798e21" translate="yes" xml:space="preserve">
          <source>In the event of a binary upgrade, upward compatibility is maintained by having the new code recognize old-format data. This will entail a slight performance penalty when processing data that has not yet been modified by the new code. It is possible to force an upgrade of all values in a table column by doing an &lt;code&gt;UPDATE&lt;/code&gt; statement as follows:</source>
          <target state="translated">В случае двоичного обновления совместимость снизу вверх поддерживается за счет того, что новый код распознает данные старого формата. Это повлечет за собой небольшое снижение производительности при обработке данных, которые еще не были изменены новым кодом. Можно принудительно обновить все значения в столбце таблицы, выполнив &lt;code&gt;UPDATE&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="b3a7ad5f630b85b752ae07e66abff996aa3b1a24" translate="yes" xml:space="preserve">
          <source>In the event that an RE could match more than one substring of a given string, the RE matches the one starting earliest in the string. If the RE could match more than one substring starting at that point, either the longest possible match or the shortest possible match will be taken, depending on whether the RE is &lt;em&gt;greedy&lt;/em&gt; or &lt;em&gt;non-greedy&lt;/em&gt;.</source>
          <target state="translated">В случае, если RE может соответствовать более чем одной подстроке данной строки, RE соответствует той, которая начинается раньше в строке. Если RE может соответствовать более чем одной подстроке, начинающейся в этой точке, будет выбрано либо самое длинное возможное совпадение, либо самое короткое возможное совпадение, в зависимости от того, является ли RE &lt;em&gt;жадным&lt;/em&gt; или &lt;em&gt;не жадным&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="474b9960977cbbea61dc4ac5b333f0b736c6264c" translate="yes" xml:space="preserve">
          <source>In the example above we see that the resulting &lt;code&gt;tsvector&lt;/code&gt; does not contain the words &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, or &lt;code&gt;it&lt;/code&gt;, the word &lt;code&gt;rats&lt;/code&gt; became &lt;code&gt;rat&lt;/code&gt;, and the punctuation sign &lt;code&gt;-&lt;/code&gt; was ignored.</source>
          <target state="translated">В приведенном выше примере мы видим, что полученный &lt;code&gt;tsvector&lt;/code&gt; не содержит слов &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;on&lt;/code&gt; или &lt;code&gt;it&lt;/code&gt; , слово &lt;code&gt;rats&lt;/code&gt; превратилось в &lt;code&gt;rat&lt;/code&gt; , а знак препинания &lt;code&gt;-&lt;/code&gt; было проигнорировано.</target>
        </trans-unit>
        <trans-unit id="200ce56337643046a5aa2dd5558bb50f57584421" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;WHERE&lt;/code&gt; clause is selecting rows by a column that is not grouped (the expression is only true for sales during the last four weeks), while the &lt;code&gt;HAVING&lt;/code&gt; clause restricts the output to groups with total gross sales over 5000. Note that the aggregate expressions do not necessarily need to be the same in all parts of the query.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;WHERE&lt;/code&gt; выбирает строки по столбцу, который не сгруппирован (выражение верно только для продаж в течение последних четырех недель), а предложение &lt;code&gt;HAVING&lt;/code&gt; ограничивает вывод группами с общим валовым объемом продаж более 5000. Примечание. что агрегатные выражения не обязательно должны быть одинаковыми во всех частях запроса.</target>
        </trans-unit>
        <trans-unit id="31c0dc4f6c95bec1ccb804da7ba6806c38ecea92" translate="yes" xml:space="preserve">
          <source>In the example above, the working table has just a single row in each step, and it takes on the values from 1 through 100 in successive steps. In the 100th step, there is no output because of the &lt;code&gt;WHERE&lt;/code&gt; clause, and so the query terminates.</source>
          <target state="translated">В приведенном выше примере рабочая таблица имеет только одну строку на каждом шаге, и она принимает значения от 1 до 100 на последовательных шагах. На 100-м шаге нет вывода из-за &lt;code&gt;WHERE&lt;/code&gt; , поэтому запрос завершается.</target>
        </trans-unit>
        <trans-unit id="652a8b18a910fe23a9af73c94ce5d441558f1e6b" translate="yes" xml:space="preserve">
          <source>In the examples above, the parser sees an integer array on one side of the concatenation operator, and a constant of undetermined type on the other. The heuristic it uses to resolve the constant's type is to assume it's of the same type as the operator's other input &amp;mdash; in this case, integer array. So the concatenation operator is presumed to represent &lt;code&gt;array_cat&lt;/code&gt;, not &lt;code&gt;array_append&lt;/code&gt;. When that's the wrong choice, it could be fixed by casting the constant to the array's element type; but explicit use of &lt;code&gt;array_append&lt;/code&gt; might be a preferable solution.</source>
          <target state="translated">В приведенных выше примерах парсер видит целочисленный массив с одной стороны от оператора конкатенации и константу неопределенного типа с другой. Эвристика, которую он использует для определения типа константы, заключается в предположении, что она того же типа, что и другой ввод оператора - в данном случае целочисленный массив. Таким образом, предполагается, что оператор конкатенации представляет &lt;code&gt;array_cat&lt;/code&gt; , а не &lt;code&gt;array_append&lt;/code&gt; . Если это неправильный выбор, его можно исправить, приведя константу к типу элемента массива; но явное использование &lt;code&gt;array_append&lt;/code&gt; может быть предпочтительным решением.</target>
        </trans-unit>
        <trans-unit id="cfb28c6ea0190f478c6d1ce0ce5ab123177f2281" translate="yes" xml:space="preserve">
          <source>In the examples above, the policy expressions consider only the current values in the row to be accessed or updated. This is the simplest and best-performing case; when possible, it's best to design row security applications to work this way. If it is necessary to consult other rows or other tables to make a policy decision, that can be accomplished using sub-&lt;code&gt;SELECT&lt;/code&gt;s, or functions that contain &lt;code&gt;SELECT&lt;/code&gt;s, in the policy expressions. Be aware however that such accesses can create race conditions that could allow information leakage if care is not taken. As an example, consider the following table design:</source>
          <target state="translated">В приведенных выше примерах выражения политики рассматривают только текущие значения в строке для доступа или обновления. Это самый простой и эффективный случай; по возможности лучше разрабатывать приложения для защиты строк, работающие таким образом. Если необходимо обратиться к другим строкам или другим таблицам для принятия решения о политике, это может быть выполнено с помощью вложенных &lt;code&gt;SELECT&lt;/code&gt; или функций, содержащих &lt;code&gt;SELECT&lt;/code&gt; в выражениях политики. Однако имейте в виду, что такой доступ может создать условия гонки, которые могут привести к утечке информации, если не будут приняты меры. В качестве примера рассмотрим следующий дизайн таблицы:</target>
        </trans-unit>
        <trans-unit id="2808c388963b5d35c9a7c014fc0aef8465d89479" translate="yes" xml:space="preserve">
          <source>In the examples that follow, we assume that you have created a database named &lt;code&gt;mydb&lt;/code&gt;, as described in the previous chapter, and have been able to start psql.</source>
          <target state="translated">В следующих примерах мы предполагаем, что вы создали базу данных с именем &lt;code&gt;mydb&lt;/code&gt; , как описано в предыдущей главе, и смогли запустить psql.</target>
        </trans-unit>
        <trans-unit id="4bb59306b891fbea63056e89cb36560d344851b8" translate="yes" xml:space="preserve">
          <source>In the first case, the RE as a whole is greedy because &lt;code&gt;Y*&lt;/code&gt; is greedy. It can match beginning at the &lt;code&gt;Y&lt;/code&gt;, and it matches the longest possible string starting there, i.e., &lt;code&gt;Y123&lt;/code&gt;. The output is the parenthesized part of that, or &lt;code&gt;123&lt;/code&gt;. In the second case, the RE as a whole is non-greedy because &lt;code&gt;Y*?&lt;/code&gt; is non-greedy. It can match beginning at the &lt;code&gt;Y&lt;/code&gt;, and it matches the shortest possible string starting there, i.e., &lt;code&gt;Y1&lt;/code&gt;. The subexpression &lt;code&gt;[0-9]{1,3}&lt;/code&gt; is greedy but it cannot change the decision as to the overall match length; so it is forced to match just &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">В первом случае RE в целом жадно, потому что &lt;code&gt;Y*&lt;/code&gt; жадно. Он может совпадать, начиная с &lt;code&gt;Y&lt;/code&gt; , и он соответствует самой длинной строке, начинающейся с этого места, то есть &lt;code&gt;Y123&lt;/code&gt; . Результат - это часть в скобках, или &lt;code&gt;123&lt;/code&gt; . Во втором случае RE в целом не является жадным, потому что &lt;code&gt;Y*?&lt;/code&gt; не жадный. Он может совпадать, начиная с &lt;code&gt;Y&lt;/code&gt; , и соответствует самой короткой строке, начинающейся с этого места, то есть &lt;code&gt;Y1&lt;/code&gt; . Подвыражение &lt;code&gt;[0-9]{1,3}&lt;/code&gt; является жадным, но оно не может изменить решение относительно общей длины соответствия; поэтому он вынужден соответствовать только &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0afff82ca92cc5d65344944313d08b5825c3e875" translate="yes" xml:space="preserve">
          <source>In the first place, &lt;em&gt;never&lt;/em&gt; believe any test that runs for only a few seconds. Use the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;-T&lt;/code&gt; option to make the run last at least a few minutes, so as to average out noise. In some cases you could need hours to get numbers that are reproducible. It's a good idea to try the test run a few times, to find out if your numbers are reproducible or not.</source>
          <target state="translated">Во-первых, &lt;em&gt;никогда не&lt;/em&gt; верьте ни одному тесту, который длится всего несколько секунд. Используйте опцию &lt;code&gt;-t&lt;/code&gt; или &lt;code&gt;-T&lt;/code&gt; , чтобы продлить запуск хотя бы несколько минут, чтобы усреднить шум. В некоторых случаях вам могут потребоваться часы, чтобы получить воспроизводимые числа. Хорошая идея - попробовать запустить тест несколько раз, чтобы узнать, воспроизводимы ли ваши числа или нет.</target>
        </trans-unit>
        <trans-unit id="d312d02ebaa05f528de247ffd592135c96644932" translate="yes" xml:space="preserve">
          <source>In the first string, the set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rd &quot;}&lt;/code&gt;. In the second string, the ordered set of trigrams is &lt;code&gt;{&quot; t&quot;,&quot; tw&quot;,&quot;two&quot;,&quot;wo &quot;,&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;. The most similar extent of an ordered set of trigrams in the second string is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;}&lt;/code&gt;, and the similarity is &lt;code&gt;0.8&lt;/code&gt;.</source>
          <target state="translated">В первой строке набор триграмм: &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rd &quot;}&lt;/code&gt; . Во второй строке упорядоченный набор триграмм: &lt;code&gt;{&quot; t&quot;,&quot; tw&quot;,&quot;two&quot;,&quot;wo &quot;,&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt; . Наиболее похожая степень упорядоченного набора триграмм во второй строке - это &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;}&lt;/code&gt; , а сходство - &lt;code&gt;0.8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56225072f8eae4ad3b64ee516719e58b357f9e0a" translate="yes" xml:space="preserve">
          <source>In the following explanation, a &lt;em&gt;byte&lt;/em&gt; is assumed to contain 8 bits. In addition, the term &lt;em&gt;item&lt;/em&gt; refers to an individual data value that is stored on a page. In a table, an item is a row; in an index, an item is an index entry.</source>
          <target state="translated">В следующем пояснении предполагается , что &lt;em&gt;байт&lt;/em&gt; содержит 8 бит. Кроме того, термин &lt;em&gt;элемент&lt;/em&gt; относится к индивидуальному значению данных, которое хранится на странице. В таблице элементом является строка; в индексе элемент является записью индекса.</target>
        </trans-unit>
        <trans-unit id="fe808d43052245254bcdc480fec58d6c194f111b" translate="yes" xml:space="preserve">
          <source>In the following sections we will cover each of the above listed items in more detail to give a better understanding of PostgreSQL's internal control and data structures.</source>
          <target state="translated">В следующих разделах мы рассмотрим каждый из вышеперечисленных пунктов более подробно,чтобы лучше понять внутренний контроль и структуры данных PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="f022f75654e730419aa401f110023452d899d615" translate="yes" xml:space="preserve">
          <source>In the following we describe the implementation of a &lt;em&gt;genetic algorithm&lt;/em&gt; to solve the join ordering problem in a manner that is efficient for queries involving large numbers of joins.</source>
          <target state="translated">Далее мы описываем реализацию &lt;em&gt;генетического алгоритма&lt;/em&gt; для решения проблемы упорядочивания соединений способом, который эффективен для запросов, включающих большое количество соединений.</target>
        </trans-unit>
        <trans-unit id="294ebe645001a682897e9beebf5caf16a1bf1ca5" translate="yes" xml:space="preserve">
          <source>In the general case where more than one field needs to be checked to recognize a cycle, use an array of rows. For example, if we needed to compare fields &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;:</source>
          <target state="translated">В общем случае, когда необходимо проверить более одного поля для распознавания цикла, используйте массив строк. Например, если нам нужно сравнить поля &lt;code&gt;f1&lt;/code&gt; и &lt;code&gt;f2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="919090babfd7b1e0453e16ae1bb909dd12feef28" translate="yes" xml:space="preserve">
          <source>In the old syntax for &lt;code&gt;CREATE AGGREGATE&lt;/code&gt;, the input data type is specified by a &lt;code&gt;basetype&lt;/code&gt; parameter rather than being written next to the aggregate name. Note that this syntax allows only one input parameter. To define a zero-argument aggregate function with this syntax, specify the &lt;code&gt;basetype&lt;/code&gt; as &lt;code&gt;&quot;ANY&quot;&lt;/code&gt; (not &lt;code&gt;*&lt;/code&gt;). Ordered-set aggregates cannot be defined with the old syntax.</source>
          <target state="translated">В старом синтаксисе &lt;code&gt;CREATE AGGREGATE&lt;/code&gt; &lt;code&gt;basetype&lt;/code&gt; тип входных данных определяется параметром базового типа, а не записывается рядом с именем агрегата. Обратите внимание, что этот синтаксис допускает только один входной параметр. Чтобы определить агрегатную функцию с нулевым аргументом с помощью этого синтаксиса, укажите &lt;code&gt;basetype&lt;/code&gt; как &lt;code&gt;&quot;ANY&quot;&lt;/code&gt; (не &lt;code&gt;*&lt;/code&gt; ). Агрегаты упорядоченного набора не могут быть определены с использованием старого синтаксиса.</target>
        </trans-unit>
        <trans-unit id="405922ab6e8351d0cf2aca13f11379b1afd63c78" translate="yes" xml:space="preserve">
          <source>In the previous chapter we have covered the basics of using SQL to store and access your data in PostgreSQL. We will now discuss some more advanced features of SQL that simplify management and prevent loss or corruption of your data. Finally, we will look at some PostgreSQL extensions.</source>
          <target state="translated">В предыдущей главе мы рассмотрели основы использования SQL для хранения и доступа к данным в PostgreSQL.Теперь мы обсудим некоторые более продвинутые возможности SQL,которые упрощают управление и предотвращают потерю или повреждение ваших данных.Наконец,мы рассмотрим некоторые расширения PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="a8c0fa4c3a367177ef284ccecde1c150bc096697" translate="yes" xml:space="preserve">
          <source>In the previous example, we can apply the city name restriction in &lt;code&gt;WHERE&lt;/code&gt;, since it needs no aggregate. This is more efficient than adding the restriction to &lt;code&gt;HAVING&lt;/code&gt;, because we avoid doing the grouping and aggregate calculations for all rows that fail the &lt;code&gt;WHERE&lt;/code&gt; check.</source>
          <target state="translated">В предыдущем примере мы можем применить ограничение названия города в &lt;code&gt;WHERE&lt;/code&gt; , поскольку для него не требуется агрегирование. Это более эффективно, чем добавление ограничения к &lt;code&gt;HAVING&lt;/code&gt; , потому что мы избегаем группирования и агрегирования вычислений для всех строк, которые не &lt;code&gt;WHERE&lt;/code&gt; проверку WHERE .</target>
        </trans-unit>
        <trans-unit id="9f29ede0900e9fd39d495275c897cbd33557a707" translate="yes" xml:space="preserve">
          <source>In the previous sections we created tables without specifying any schema names. By default such tables (and other objects) are automatically put into a schema named &amp;ldquo;public&amp;rdquo;. Every new database contains such a schema. Thus, the following are equivalent:</source>
          <target state="translated">В предыдущих разделах мы создавали таблицы без указания имен схем. По умолчанию такие таблицы (и другие объекты) автоматически помещаются в схему с именем &amp;laquo;public&amp;raquo;. Каждая новая база данных содержит такую ​​схему. Таким образом, следующие эквиваленты:</target>
        </trans-unit>
        <trans-unit id="0e8d742b91769afdfb8fcfcc89d91cd8ba42839b" translate="yes" xml:space="preserve">
          <source>In the remote sessions opened by &lt;code&gt;postgres_fdw&lt;/code&gt;, the &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; parameter is set to just &lt;code&gt;pg_catalog&lt;/code&gt;, so that only built-in objects are visible without schema qualification. This is not an issue for queries generated by &lt;code&gt;postgres_fdw&lt;/code&gt; itself, because it always supplies such qualification. However, this can pose a hazard for functions that are executed on the remote server via triggers or rules on remote tables. For example, if a remote table is actually a view, any functions used in that view will be executed with the restricted search path. It is recommended to schema-qualify all names in such functions, or else attach &lt;code&gt;SET search_path&lt;/code&gt; options (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;) to such functions to establish their expected search path environment.</source>
          <target state="translated">В удаленных сеансах, открытых &lt;code&gt;postgres_fdw&lt;/code&gt; , для параметра &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; установлено значение &lt;code&gt;pg_catalog&lt;/code&gt; , так что без уточнения схемы видны только встроенные объекты. Это не проблема для запросов, созданных самим &lt;code&gt;postgres_fdw&lt;/code&gt; , потому что он всегда предоставляет такую ​​квалификацию. Однако это может представлять опасность для функций, которые выполняются на удаленном сервере через триггеры или правила для удаленных таблиц. Например, если удаленная таблица на самом деле является представлением, любые функции, используемые в этом представлении, будут выполняться с ограниченным путем поиска. Рекомендуется &lt;code&gt;SET search_path&lt;/code&gt; в схеме все имена в таких функциях или добавить параметры SET search_path (см. &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;) таким функциям, чтобы установить их ожидаемую среду пути поиска.</target>
        </trans-unit>
        <trans-unit id="251756f685410e433b657f5b30520cf41b101c14" translate="yes" xml:space="preserve">
          <source>In the same connection as before, issue the command:</source>
          <target state="translated">В том же соединении,что и раньше,отправьте команду:</target>
        </trans-unit>
        <trans-unit id="9a85cd84a5c1ae886a05b3cc6a64ec7fb7c99a58" translate="yes" xml:space="preserve">
          <source>In the second form of &lt;code&gt;ALTER POLICY&lt;/code&gt;, the role list, &lt;code&gt;using_expression&lt;/code&gt;, and &lt;code&gt;check_expression&lt;/code&gt; are replaced independently if specified. When one of those clauses is omitted, the corresponding part of the policy is unchanged.</source>
          <target state="translated">Во второй форме &lt;code&gt;ALTER POLICY&lt;/code&gt; список ролей, &lt;code&gt;using_expression&lt;/code&gt; и &lt;code&gt;check_expression&lt;/code&gt; заменяются независимо, если они указаны. Если один из этих пунктов опущен, соответствующая часть политики не изменяется.</target>
        </trans-unit>
        <trans-unit id="2c142401003467ed2967cc5251153e2a0bab24fa" translate="yes" xml:space="preserve">
          <source>In the second mode, which we will call the search+bind mode, the server first binds to the LDAP directory with a fixed user name and password, specified with &lt;code&gt;ldapbinddn&lt;/code&gt; and &lt;code&gt;ldapbindpasswd&lt;/code&gt;, and performs a search for the user trying to log in to the database. If no user and password is configured, an anonymous bind will be attempted to the directory. The search will be performed over the subtree at &lt;code&gt;ldapbasedn&lt;/code&gt;, and will try to do an exact match of the attribute specified in &lt;code&gt;ldapsearchattribute&lt;/code&gt;. Once the user has been found in this search, the server disconnects and re-binds to the directory as this user, using the password specified by the client, to verify that the login is correct. This mode is the same as that used by LDAP authentication schemes in other software, such as Apache &lt;code&gt;mod_authnz_ldap&lt;/code&gt; and &lt;code&gt;pam_ldap&lt;/code&gt;. This method allows for significantly more flexibility in where the user objects are located in the directory, but will cause two separate connections to the LDAP server to be made.</source>
          <target state="translated">Во втором режиме, который мы назовем режимом поиска + привязки, сервер сначала привязывается к каталогу LDAP с фиксированным именем пользователя и паролем, указанным с помощью &lt;code&gt;ldapbinddn&lt;/code&gt; и &lt;code&gt;ldapbindpasswd&lt;/code&gt; , и выполняет поиск пользователя, пытающегося войти в систему. база данных. Если пользователь и пароль не настроены, будет предпринята попытка анонимной привязки к каталогу. Поиск будет выполняться по поддереву на &lt;code&gt;ldapbasedn&lt;/code&gt; и будет пытаться найти точное совпадение атрибута, указанного в &lt;code&gt;ldapsearchattribute&lt;/code&gt; .. Как только пользователь был найден в этом поиске, сервер отключается и повторно связывается с каталогом как этот пользователь, используя пароль, указанный клиентом, чтобы проверить правильность входа в систему. Этот режим такой же , как используются схемы аутентификации LDAP , в другом программном обеспечении, таких как Apache &lt;code&gt;mod_authnz_ldap&lt;/code&gt; и &lt;code&gt;pam_ldap&lt;/code&gt; . Этот метод обеспечивает значительно большую гибкость в выборе расположения пользовательских объектов в каталоге, но при этом будет выполнено два отдельных подключения к серверу LDAP.</target>
        </trans-unit>
        <trans-unit id="138833bfe13a3d8412530f69bb62c741e625ccde" translate="yes" xml:space="preserve">
          <source>In the second query, we could not have written &lt;code&gt;SELECT * FROM test1 GROUP BY x&lt;/code&gt;, because there is no single value for the column &lt;code&gt;y&lt;/code&gt; that could be associated with each group. The grouped-by columns can be referenced in the select list since they have a single value in each group.</source>
          <target state="translated">Во втором запросе мы не могли написать &lt;code&gt;SELECT * FROM test1 GROUP BY x&lt;/code&gt; , потому что нет единственного значения для столбца &lt;code&gt;y&lt;/code&gt; , которое могло бы быть связано с каждой группой. На сгруппированные по столбцам можно ссылаться в списке выбора, поскольку они имеют одно значение в каждой группе.</target>
        </trans-unit>
        <trans-unit id="a3f53fb06ae3c0e076406bae29678cb14017000e" translate="yes" xml:space="preserve">
          <source>In the standard, it is not necessary to issue &lt;code&gt;START TRANSACTION&lt;/code&gt; to start a transaction block: any SQL command implicitly begins a block. PostgreSQL's behavior can be seen as implicitly issuing a &lt;code&gt;COMMIT&lt;/code&gt; after each command that does not follow &lt;code&gt;START TRANSACTION&lt;/code&gt; (or &lt;code&gt;BEGIN&lt;/code&gt;), and it is therefore often called &amp;ldquo;autocommit&amp;rdquo;. Other relational database systems might offer an autocommit feature as a convenience.</source>
          <target state="translated">В стандарте нет необходимости вводить &lt;code&gt;START TRANSACTION&lt;/code&gt; для запуска блока транзакции: любая команда SQL неявно начинает блок. Поведение PostgreSQL можно рассматривать как неявное выполнение &lt;code&gt;COMMIT&lt;/code&gt; после каждой команды, которая не следует за &lt;code&gt;START TRANSACTION&lt;/code&gt; (или &lt;code&gt;BEGIN&lt;/code&gt; ), и поэтому это часто называется &amp;laquo;autocommit&amp;raquo;. Другие системы реляционных баз данных могут для удобства предлагать функцию автоматической фиксации.</target>
        </trans-unit>
        <trans-unit id="127829a1cca08de1cd77d4d1d0c73fe0bf22ed39" translate="yes" xml:space="preserve">
          <source>In the standard, the &lt;code&gt;WITH [ NO ] DATA&lt;/code&gt; clause is required; in PostgreSQL it is optional.</source>
          <target state="translated">В стандарте требуется предложение &lt;code&gt;WITH [ NO ] DATA&lt;/code&gt; ; в PostgreSQL это необязательно.</target>
        </trans-unit>
        <trans-unit id="7f27aa8e0141e367b925aa8c528ef6250799f203" translate="yes" xml:space="preserve">
          <source>In the strict mode, the specified path must exactly match the structure of the queried JSON document to return an SQL/JSON item, so using this path expression will cause an error. To get the same result as in the lax mode, you have to explicitly unwrap the &lt;code&gt;segments&lt;/code&gt; array:</source>
          <target state="translated">В строгом режиме указанный путь должен точно соответствовать структуре запрашиваемого документа JSON для возврата элемента SQL / JSON, поэтому использование этого выражения пути приведет к ошибке. Чтобы получить тот же результат, что и в слабом режиме, вы должны явно развернуть массив &lt;code&gt;segments&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="351d4063e5553403441da5e92374ad1230527978" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">В синтаксисе &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt; ключевые слова &lt;code&gt;FUNCTION&lt;/code&gt; и &lt;code&gt;PROCEDURE&lt;/code&gt; эквивалентны, но указанная функция в любом случае должна быть функцией, а не процедурой. Использование ключевого слова &lt;code&gt;PROCEDURE&lt;/code&gt; здесь является устаревшим и устаревшим.</target>
        </trans-unit>
        <trans-unit id="78472b8a63814954829d3aaff5becf4efc83edf2" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE OPERATOR&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">В синтаксисе &lt;code&gt;CREATE OPERATOR&lt;/code&gt; ключевые слова &lt;code&gt;FUNCTION&lt;/code&gt; и &lt;code&gt;PROCEDURE&lt;/code&gt; эквивалентны, но указанная функция в любом случае должна быть функцией, а не процедурой. Использование ключевого слова &lt;code&gt;PROCEDURE&lt;/code&gt; здесь является устаревшим и устаревшим.</target>
        </trans-unit>
        <trans-unit id="57ba8dd34e548ca54ffce2f60f391e867e594c9e" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE TRIGGER&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">В синтаксисе &lt;code&gt;CREATE TRIGGER&lt;/code&gt; ключевые слова &lt;code&gt;FUNCTION&lt;/code&gt; и &lt;code&gt;PROCEDURE&lt;/code&gt; эквивалентны, но указанная функция в любом случае должна быть функцией, а не процедурой. Использование ключевого слова &lt;code&gt;PROCEDURE&lt;/code&gt; здесь исторически и не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="e9e4c8cc0471f863f66674a10b7573f32e28c279" translate="yes" xml:space="preserve">
          <source>In the text form of a range, an inclusive lower bound is represented by &amp;ldquo;&lt;code&gt;[&lt;/code&gt;&amp;rdquo; while an exclusive lower bound is represented by &amp;ldquo;&lt;code&gt;(&lt;/code&gt;&amp;rdquo;. Likewise, an inclusive upper bound is represented by &amp;ldquo;&lt;code&gt;]&lt;/code&gt;&amp;rdquo;, while an exclusive upper bound is represented by &amp;ldquo;&lt;code&gt;)&lt;/code&gt;&amp;rdquo;. (See &lt;a href=&quot;rangetypes#RANGETYPES-IO&quot;&gt;Section 8.17.5&lt;/a&gt; for more details.)</source>
          <target state="translated">В текстовой форме диапазона включающая нижняя граница представлена ​​символом &amp;laquo; &lt;code&gt;[&lt;/code&gt; &amp;raquo;, а исключительная нижняя граница представлена ​​символом &amp;laquo; &lt;code&gt;(&lt;/code&gt; &amp;raquo;. Точно так же включающая верхняя граница представлена ​​символом &amp;laquo; &lt;code&gt;]&lt;/code&gt; &amp;raquo;, в то время как исключительная верхняя граница представлена пользователем &amp;laquo; &lt;code&gt;)&lt;/code&gt; &amp;raquo;. (За подробностями &lt;a href=&quot;rangetypes#RANGETYPES-IO&quot;&gt;обратитесь&lt;/a&gt; к Разделу 8.17.5 .)</target>
        </trans-unit>
        <trans-unit id="87e71fe4fdbdcfebf301c0661fd38f3ccfa52a22" translate="yes" xml:space="preserve">
          <source>In the verbose input format, and in some fields of the more compact input formats, field values can have fractional parts; for example &lt;code&gt;'1.5 week'&lt;/code&gt; or &lt;code&gt;'01:02:03.45'&lt;/code&gt;. Such input is converted to the appropriate number of months, days, and seconds for storage. When this would result in a fractional number of months or days, the fraction is added to the lower-order fields using the conversion factors 1 month = 30 days and 1 day = 24 hours. For example, &lt;code&gt;'1.5 month'&lt;/code&gt; becomes 1 month and 15 days. Only seconds will ever be shown as fractional on output.</source>
          <target state="translated">В подробном формате ввода и в некоторых полях более компактных форматов ввода значения полей могут иметь дробные части; например &lt;code&gt;'1.5 week'&lt;/code&gt; или &quot; &lt;code&gt;'01:02:03.45'&lt;/code&gt; . Такой ввод преобразуется в соответствующее количество месяцев, дней и секунд для хранения. Когда это приведет к дробному количеству месяцев или дней, эта дробь добавляется в поля более низкого порядка с использованием коэффициентов преобразования 1 месяц = ​​30 дней и 1 день = 24 часа. Например, &lt;code&gt;'1.5 month'&lt;/code&gt; превращается в 1 месяц и 15 дней. Только секунды будут отображаться на выходе как дробные.</target>
        </trans-unit>
        <trans-unit id="352c1b7bd2689ed0c741aae1f8598e4432b2e419" translate="yes" xml:space="preserve">
          <source>In the world of measurements, 6.50 is not the same as 6.5. It may sometimes be critically different. The experimenters usually write down (and publish) the digits they trust. 6.50 is actually a fuzzy interval contained within a bigger and even fuzzier interval, 6.5, with their center points being (probably) the only common feature they share. We definitely do not want such different data items to appear the same.</source>
          <target state="translated">В мире измерений 6,50-это не то же самое,что 6,5.Иногда она может критично отличаться.Экспериментаторы обычно записывают (и публикуют)цифры,которым они доверяют.6.50 на самом деле является нечетким интервалом,содержащимся в большом и даже более нечетком интервале,6.5,при этом их центральные точки являются (возможно)единственной общей чертой,которую они разделяют.Мы определенно не хотим,чтобы такие разные элементы данных выглядели одинаково.</target>
        </trans-unit>
        <trans-unit id="d16185ffce558efd6646fae1f89738ca57d3dd9c" translate="yes" xml:space="preserve">
          <source>In these expressions, the desired time zone &lt;code&gt;zone&lt;/code&gt; can be specified either as a text string (e.g., &lt;code&gt;'America/Los_Angeles'&lt;/code&gt;) or as an interval (e.g., &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt;). In the text case, a time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;.</source>
          <target state="translated">В этих выражениях нужный часовой пояс &lt;code&gt;zone&lt;/code&gt; могут быть указаны либо в виде текстовой строки (например, &lt;code&gt;'America/Los_Angeles'&lt;/code&gt; ) или как интервал (например, &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt; ). В текстовом случае имя часового пояса можно указать любым из способов, описанных в &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Разделе 8.5.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccebf94cbd61b9484dc9b7fa83da6e0dd760a88b" translate="yes" xml:space="preserve">
          <source>In these expressions, the desired time zone &lt;code&gt;zone&lt;/code&gt; can be specified either as a text value (e.g., &lt;code&gt;'America/Los_Angeles'&lt;/code&gt;) or as an interval (e.g., &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt;). In the text case, a time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;. The interval case is only useful for zones that have fixed offsets from UTC, so it is not very common in practice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d5bca14d2cfde080255e10973a28114214ea10" translate="yes" xml:space="preserve">
          <source>In this case the parser looks to see if there is an operator taking &lt;code&gt;text&lt;/code&gt; for both arguments. Since there is, it assumes that the second argument should be interpreted as type &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">В этом случае анализатор проверяет, есть ли оператор, принимающий &lt;code&gt;text&lt;/code&gt; для обоих аргументов. Поскольку есть, предполагается, что второй аргумент следует интерпретировать как &lt;code&gt;text&lt;/code&gt; типа .</target>
        </trans-unit>
        <trans-unit id="d2822670753f6c1107e46ff79d0892389494ad1a" translate="yes" xml:space="preserve">
          <source>In this case there is no MCV information for &lt;code&gt;unique2&lt;/code&gt; because all the values appear to be unique, so we use an algorithm that relies only on the number of distinct values for both relations together with their null fractions:</source>
          <target state="translated">В этом случае нет информации MCV для &lt;code&gt;unique2&lt;/code&gt; , потому что все значения кажутся уникальными, поэтому мы используем алгоритм, который полагается только на количество различных значений для обоих отношений вместе с их нулевыми дробями:</target>
        </trans-unit>
        <trans-unit id="454dfb68a36b15232f0a47fef88c353fb8b457de" translate="yes" xml:space="preserve">
          <source>In this case there is no initial hint for which type to use, since no types are specified in the query. So, the parser looks for all candidate operators and finds that there are candidates accepting both string-category and bit-string-category inputs. Since string category is preferred when available, that category is selected, and then the preferred type for strings, &lt;code&gt;text&lt;/code&gt;, is used as the specific type to resolve the unknown-type literals as.</source>
          <target state="translated">В этом случае нет начального указания, какой тип использовать, поскольку в запросе не указаны типы. Таким образом, синтаксический анализатор ищет все операторы-кандидаты и обнаруживает, что есть кандидаты, принимающие входные данные как строковой категории, так и категории битовой строки. Поскольку строковая категория является предпочтительной, если она доступна, выбирается эта категория, а затем предпочтительный тип для строк, &lt;code&gt;text&lt;/code&gt; , используется как конкретный тип для разрешения литералов неизвестного типа как.</target>
        </trans-unit>
        <trans-unit id="643fc82591ff3cc1a1f002cde4bff205b2405706" translate="yes" xml:space="preserve">
          <source>In this case, a regular user cannot reference &lt;code&gt;customer.credit&lt;/code&gt; directly, but a trusted procedure &lt;code&gt;show_credit&lt;/code&gt; allows the user to print the credit card numbers of customers with some of the digits masked out.</source>
          <target state="translated">В этом случае обычный пользователь не может напрямую ссылаться на &lt;code&gt;customer.credit&lt;/code&gt; , но доверенная процедура &lt;code&gt;show_credit&lt;/code&gt; позволяет пользователю распечатывать номера кредитных карт клиентов с замаскированными некоторыми цифрами.</target>
        </trans-unit>
        <trans-unit id="d737c289d22cb958cf827fb7f26271e5be10a1e7" translate="yes" xml:space="preserve">
          <source>In this case, a row of &lt;code&gt;capitals&lt;/code&gt;&lt;em&gt;inherits&lt;/em&gt; all columns (&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;population&lt;/code&gt;, and &lt;code&gt;altitude&lt;/code&gt;) from its &lt;em&gt;parent&lt;/em&gt;, &lt;code&gt;cities&lt;/code&gt;. The type of the column &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;text&lt;/code&gt;, a native PostgreSQL type for variable length character strings. State capitals have an extra column, &lt;code&gt;state&lt;/code&gt;, that shows their state. In PostgreSQL, a table can inherit from zero or more other tables.</source>
          <target state="translated">В этом случае строка &lt;code&gt;capitals&lt;/code&gt; &lt;em&gt;наследует&lt;/em&gt; все столбцы ( &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;population&lt;/code&gt; и &lt;code&gt;altitude&lt;/code&gt; ) от своего &lt;em&gt;родительского&lt;/em&gt; , &lt;code&gt;cities&lt;/code&gt; . Тип столбца &lt;code&gt;name&lt;/code&gt; является &lt;code&gt;text&lt;/code&gt; , родной тип PostgreSQL для символьных строк переменной длины. В столицах штатов есть дополнительный столбец, &lt;code&gt;state&lt;/code&gt; , который показывает их состояние. В PostgreSQL таблица может наследовать от нуля или более других таблиц.</target>
        </trans-unit>
        <trans-unit id="a5c8500d7c402e7f06456adc9676ed53904411ff" translate="yes" xml:space="preserve">
          <source>In this case, a row of &lt;code&gt;capitals&lt;/code&gt;&lt;em&gt;inherits&lt;/em&gt; all columns (&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;population&lt;/code&gt;, and &lt;code&gt;elevation&lt;/code&gt;) from its &lt;em&gt;parent&lt;/em&gt;, &lt;code&gt;cities&lt;/code&gt;. The type of the column &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;text&lt;/code&gt;, a native PostgreSQL type for variable length character strings. The &lt;code&gt;capitals&lt;/code&gt; table has an additional column, &lt;code&gt;state&lt;/code&gt;, which shows its state abbreviation. In PostgreSQL, a table can inherit from zero or more other tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613ba4c32d099503d94bd47a030a2a2ad44892dd" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;capitals&lt;/code&gt; table &lt;em&gt;inherits&lt;/em&gt; all the columns of its parent table, &lt;code&gt;cities&lt;/code&gt;. State capitals also have an extra column, &lt;code&gt;state&lt;/code&gt;, that shows their state.</source>
          <target state="translated">В этом случае таблица &lt;code&gt;capitals&lt;/code&gt; &lt;em&gt;наследует&lt;/em&gt; все столбцы своей родительской таблицы &lt;code&gt;cities&lt;/code&gt; . В столицах штатов также есть дополнительный столбец &lt;code&gt;state&lt;/code&gt; , который показывает их состояние.</target>
        </trans-unit>
        <trans-unit id="af318a98fb799d225d9e923e2e4473ff3043a3f6" translate="yes" xml:space="preserve">
          <source>In this configuration, the sample &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; above takes 115.9 ms. That's 1061 ns of timing overhead, again a small multiple of what's measured directly by this utility. That much timing overhead means the actual query itself is only taking a tiny fraction of the accounted for time, most of it is being consumed in overhead instead. In this configuration, any &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; totals involving many timed operations would be inflated significantly by timing overhead.</source>
          <target state="translated">В этой конфигурации приведенный выше пример &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; занимает 115,9 мс. Это 1061 нс накладных расходов по времени, что опять же немного кратно тому, что измеряется непосредственно этой утилитой. Такие большие временные издержки означают, что сам фактический запрос занимает лишь крошечную часть учтенного времени, вместо этого большая часть его расходуется на накладные расходы. В этой конфигурации любые итоги &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; , включающие множество синхронизированных операций, будут значительно завышены из-за временных затрат.</target>
        </trans-unit>
        <trans-unit id="abed36bdd05542db8e718c1091a76817a77d802e" translate="yes" xml:space="preserve">
          <source>In this example above we were allowed to switch from the larger MCS range &lt;code&gt;c1.c1023&lt;/code&gt; to the smaller range &lt;code&gt;c1.c4&lt;/code&gt;, but switching back was denied.</source>
          <target state="translated">В приведенном выше примере нам разрешили переключиться с большего диапазона MCS &lt;code&gt;c1.c1023&lt;/code&gt; на меньший диапазон &lt;code&gt;c1.c4&lt;/code&gt; , но обратное переключение было запрещено.</target>
        </trans-unit>
        <trans-unit id="e7326012a121c41d2c47ed971d8505d7a7de76bf" translate="yes" xml:space="preserve">
          <source>In this example the Update node needs to consider three child tables as well as the originally-mentioned parent table. So there are four input scanning subplans, one per table. For clarity, the Update node is annotated to show the specific target tables that will be updated, in the same order as the corresponding subplans. (These annotations are new as of PostgreSQL 9.5; in prior versions the reader had to intuit the target tables by inspecting the subplans.)</source>
          <target state="translated">В данном примере узел Update должен учитывать три дочерние таблицы,а также изначально упомянутую родительскую таблицу.Таким образом,существует четыре входных подплана сканирования,по одной на каждую таблицу.Для наглядности,узел Update аннотируется,чтобы показать конкретные целевые таблицы,которые будут обновляться,в том же порядке,что и соответствующие подпланы.(Эти аннотации являются новыми,начиная с PostgreSQL 9.5;в предыдущих версиях читателю приходилось вводить целевые таблицы,осматривая подпланы).</target>
        </trans-unit>
        <trans-unit id="90020459ceef361caea70168cdc85c26559a0eb6" translate="yes" xml:space="preserve">
          <source>In this example the join's output row count is the same as the product of the two scans' row counts, but that's not true in all cases because there can be additional &lt;code&gt;WHERE&lt;/code&gt; clauses that mention both tables and so can only be applied at the join point, not to either input scan. Here's an example:</source>
          <target state="translated">В этом примере счетчик выходных строк соединения совпадает с произведением счетчиков строк двух сканирований, но это не так во всех случаях, потому что могут быть дополнительные &lt;code&gt;WHERE&lt;/code&gt; которые упоминают обе таблицы и поэтому могут применяться только в точке соединения. , а не сканирование ввода. Вот пример:</target>
        </trans-unit>
        <trans-unit id="f68e5dbd48ccbde70e786ec3f6ee97430aeb6b1e" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;(none)&lt;/code&gt;, null is returned, otherwise the value of &lt;code&gt;value&lt;/code&gt; is returned.</source>
          <target state="translated">В этом примере, если &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;(none)&lt;/code&gt; , возвращается значение null, в противном случае возвращается значение &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6956c57a06842052520c448c372cfcf4ca7298a5" translate="yes" xml:space="preserve">
          <source>In this example, if four standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; are running, the two standbys &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; will be chosen as synchronous standbys because their names appear early in the list of standby names. &lt;code&gt;s3&lt;/code&gt; is a potential synchronous standby and will take over the role of synchronous standby when either of &lt;code&gt;s1&lt;/code&gt; or &lt;code&gt;s2&lt;/code&gt; fails. &lt;code&gt;s4&lt;/code&gt; is an asynchronous standby since its name is not in the list.</source>
          <target state="translated">В этом примере, если работают четыре резервных сервера &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; , &lt;code&gt;s3&lt;/code&gt; и &lt;code&gt;s4&lt;/code&gt; , два резервных сервера &lt;code&gt;s1&lt;/code&gt; и &lt;code&gt;s2&lt;/code&gt; будут выбраны как синхронные резервные, потому что их имена появляются в начале списка имен резервных. &lt;code&gt;s3&lt;/code&gt; является потенциальным синхронным резервным и возьмет на себя роль синхронного резервного при выходе из строя одного из &lt;code&gt;s1&lt;/code&gt; или &lt;code&gt;s2&lt;/code&gt; . &lt;code&gt;s4&lt;/code&gt; - это асинхронный резервный сервер, поскольку его имени нет в списке.</target>
        </trans-unit>
        <trans-unit id="5ecb1dc9291b661bf70c843bbe812e41c22f83de" translate="yes" xml:space="preserve">
          <source>In this example, if four standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; are running, transaction commits will wait for replies from at least any two standbys of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt; and &lt;code&gt;s3&lt;/code&gt;. &lt;code&gt;s4&lt;/code&gt; is an asynchronous standby since its name is not in the list.</source>
          <target state="translated">В этом примере, если работают четыре резервных сервера &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; , &lt;code&gt;s3&lt;/code&gt; и &lt;code&gt;s4&lt;/code&gt; , фиксация транзакции будет ожидать ответов по крайней мере от любых двух резервных серверов &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; и &lt;code&gt;s3&lt;/code&gt; . &lt;code&gt;s4&lt;/code&gt; - это асинхронный резервный сервер, поскольку его имени нет в списке.</target>
        </trans-unit>
        <trans-unit id="52a2cd0a65091e20d376dc71b4672a80c22c4d96" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;TEMPLATE template0&lt;/code&gt; clause is required if the specified locale is different from the one in &lt;code&gt;template1&lt;/code&gt;. (If it is not, then specifying the locale explicitly is redundant.)</source>
          <target state="translated">В этом примере предложение &lt;code&gt;TEMPLATE template0&lt;/code&gt; требуется, если указанный языковой стандарт отличается от языкового стандарта &lt;code&gt;template1&lt;/code&gt; . (Если это не так, то указание языкового стандарта явно излишне.)</target>
        </trans-unit>
        <trans-unit id="8c5f7d8e9b592b4d5a3f718483f7acd727a00e09" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;len&lt;/code&gt; column is omitted and therefore it will have the default value:</source>
          <target state="translated">В этом примере столбец &lt;code&gt;len&lt;/code&gt; опущен, поэтому он будет иметь значение по умолчанию:</target>
        </trans-unit>
        <trans-unit id="3694c54d9cfcf70eda6933c152be42b7c937c601" translate="yes" xml:space="preserve">
          <source>In this example, the columns &lt;code&gt;product_id&lt;/code&gt;, &lt;code&gt;p.name&lt;/code&gt;, and &lt;code&gt;p.price&lt;/code&gt; must be in the &lt;code&gt;GROUP BY&lt;/code&gt; clause since they are referenced in the query select list (but see below). The column &lt;code&gt;s.units&lt;/code&gt; does not have to be in the &lt;code&gt;GROUP BY&lt;/code&gt; list since it is only used in an aggregate expression (&lt;code&gt;sum(...)&lt;/code&gt;), which represents the sales of a product. For each product, the query returns a summary row about all sales of the product.</source>
          <target state="translated">В этом примере столбцы &lt;code&gt;product_id&lt;/code&gt; , &lt;code&gt;p.name&lt;/code&gt; и &lt;code&gt;p.price&lt;/code&gt; должны быть в предложении &lt;code&gt;GROUP BY&lt;/code&gt; , поскольку на них есть ссылка в списке выбора запроса (но см. Ниже). Столбец &lt;code&gt;s.units&lt;/code&gt; не обязательно должен быть в списке &lt;code&gt;GROUP BY&lt;/code&gt; , поскольку он используется только в агрегированном выражении ( &lt;code&gt;sum(...)&lt;/code&gt; ), которое представляет продажи продукта. Для каждого продукта запрос возвращает итоговую строку обо всех продажах продукта.</target>
        </trans-unit>
        <trans-unit id="08a0e2d4d5bc94672e2506daf9e09dfe471fae09" translate="yes" xml:space="preserve">
          <source>In this example, the data type of the second parameter is not specified, so it is inferred from the context in which &lt;code&gt;$2&lt;/code&gt; is used.</source>
          <target state="translated">В этом примере тип данных второго параметра не указан, поэтому он выводится из контекста, в котором используется &lt;code&gt;$2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ecac118ba12d038d39cec07567975d6d66efcef" translate="yes" xml:space="preserve">
          <source>In this example, the sort order isn't fully specified, and so you might get the San Francisco rows in either order. But you'd always get the results shown above if you do:</source>
          <target state="translated">В данном примере порядок сортировки указан не полностью,поэтому вы можете получить строки Сан-Франциско в любом порядке.Но вы всегда получите результаты,показанные выше:</target>
        </trans-unit>
        <trans-unit id="afe2100b24dbf1294da5f781636d42d62e4bc563" translate="yes" xml:space="preserve">
          <source>In this example, the word &lt;code&gt;Brightest&lt;/code&gt; was recognized by the parser as an &lt;code&gt;ASCII word&lt;/code&gt; (alias &lt;code&gt;asciiword&lt;/code&gt;). For this token type the dictionary list is &lt;code&gt;english_ispell&lt;/code&gt; and &lt;code&gt;english_stem&lt;/code&gt;. The word was recognized by &lt;code&gt;english_ispell&lt;/code&gt;, which reduced it to the noun &lt;code&gt;bright&lt;/code&gt;. The word &lt;code&gt;supernovaes&lt;/code&gt; is unknown to the &lt;code&gt;english_ispell&lt;/code&gt; dictionary so it was passed to the next dictionary, and, fortunately, was recognized (in fact, &lt;code&gt;english_stem&lt;/code&gt; is a Snowball dictionary which recognizes everything; that is why it was placed at the end of the dictionary list).</source>
          <target state="translated">В этом примере слово &lt;code&gt;Brightest&lt;/code&gt; было распознано анализатором как &lt;code&gt;ASCII word&lt;/code&gt; (псевдоним &lt;code&gt;asciiword&lt;/code&gt; ). Для этого типа токена список словарей - &lt;code&gt;english_ispell&lt;/code&gt; и &lt;code&gt;english_stem&lt;/code&gt; . Слово было распознано &lt;code&gt;english_ispell&lt;/code&gt; , которое сократило его до существительного &lt;code&gt;bright&lt;/code&gt; . Слово &lt;code&gt;supernovaes&lt;/code&gt; неизвестно словарю &lt;code&gt;english_ispell&lt;/code&gt; , поэтому оно было передано в следующий словарь и, к счастью, было распознано (на самом деле &lt;code&gt;english_stem&lt;/code&gt; - это словарь Snowball, который распознает все, поэтому он был помещен в конец списка словарей. ).</target>
        </trans-unit>
        <trans-unit id="3c50776020e0abdc78addf8fd7c7082700a16f21" translate="yes" xml:space="preserve">
          <source>In this example, transaction 82 was late, because its latency (6.173 ms) was over the 5 ms limit. The next two transactions were skipped, because they were already late before they were even started.</source>
          <target state="translated">В данном примере сделка 82 была совершена с опозданием,так как ее задержка (6,173 мс)превысила лимит в 5 мс.Следующие две сделки были пропущены,так как они уже были поздно,еще до того,как они были начаты.</target>
        </trans-unit>
        <trans-unit id="25785dae89df6c58b5b98e5a8b5a16cf8ba5c166" translate="yes" xml:space="preserve">
          <source>In this form, &lt;code&gt;n&lt;/code&gt; counts from 1 to 365, and February 29 is not counted even if it is present. (Thus, a transition occurring on February 29 could not be specified this way. However, days after February have the same numbers whether it's a leap year or not, so that this form is usually more useful than the plain-integer form for transitions on fixed dates.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630dd124cc8b0f85590f44f07e341462147cb0a6" translate="yes" xml:space="preserve">
          <source>In this group of commands, the letters &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; stand for foreign table, index, materialized view, sequence, table, and view, respectively. You can specify any or all of these letters, in any order, to obtain a listing of objects of these types. For example, &lt;code&gt;\dit&lt;/code&gt; lists indexes and tables. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its physical size on disk and its associated description, if any. If &lt;code&gt;pattern&lt;/code&gt; is specified, only objects whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">В этой группе команд буквы &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; и &lt;code&gt;v&lt;/code&gt; обозначают стороннюю таблицу, индекс, материализованное представление, последовательность, таблицу и представление соответственно. Вы можете указать любую или все эти буквы в любом порядке, чтобы получить список объектов этих типов. Например, &lt;code&gt;\dit&lt;/code&gt; перечисляет индексы и таблицы. Если к имени команды добавлен &lt;code&gt;+&lt;/code&gt; , каждый объект перечисляется с указанием его физического размера на диске и соответствующего описания, если таковое имеется. Если &lt;code&gt;pattern&lt;/code&gt; указан, только объекты , чьи имена совпадают с шаблоном в списке. По умолчанию отображаются только объекты, созданные пользователем; поставьте узор или &lt;code&gt;S&lt;/code&gt; модификатор для включения системных объектов.</target>
        </trans-unit>
        <trans-unit id="e1a2b0abebbac2543bf7c44bb0372db4d5e5c034" translate="yes" xml:space="preserve">
          <source>In this group of commands, the letters &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; stand for foreign table, index, materialized view, sequence, table, and view, respectively. You can specify any or all of these letters, in any order, to obtain a listing of objects of these types. For example, &lt;code&gt;\dti&lt;/code&gt; lists tables and indexes. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its persistence status (permanent, temporary, or unlogged), physical size on disk, and associated description if any. If &lt;code&gt;pattern&lt;/code&gt; is specified, only objects whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a2e5dcbe213e98e1493b7e930a93660a65d1fc" translate="yes" xml:space="preserve">
          <source>In this module, the Earth is assumed to be perfectly spherical. (If that's too inaccurate for you, you might want to look at the &lt;a href=&quot;http://postgis.net/&quot;&gt;PostGIS&lt;/a&gt; project.)</source>
          <target state="translated">В этом модуле предполагается, что Земля имеет идеально сферическую форму. (Если это для вас слишком неточно, вы можете взглянуть на проект &lt;a href=&quot;http://postgis.net/&quot;&gt;PostGIS&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="d0ed0a5a7df9c6e41189a38e83864f5642c8ac48" translate="yes" xml:space="preserve">
          <source>In this module, the Earth is assumed to be perfectly spherical. (If that's too inaccurate for you, you might want to look at the &lt;a href=&quot;https://postgis.net/&quot;&gt;PostGIS&lt;/a&gt; project.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdbad3a8ee3be25a94e567ee2f1c55ff6b62875e" translate="yes" xml:space="preserve">
          <source>In this particular example, the correction from the MCV list is fairly small, because the column distribution is actually quite flat (the statistics showing these particular values as being more common than others are mostly due to sampling error). In a more typical case where some values are significantly more common than others, this complicated process gives a useful improvement in accuracy because the selectivity for the most common values is found exactly.</source>
          <target state="translated">В данном конкретном примере коррекция из списка MCV довольно мала,так как распределение столбцов на самом деле довольно плоское (статистика,показывающая эти конкретные значения как более распространенные,чем другие,в основном обусловлена ошибкой выборки).В более типичном случае,когда одни значения значительно более распространены,чем другие,этот сложный процесс дает полезное повышение точности,так как точно найдена селективность для наиболее распространенных значений.</target>
        </trans-unit>
        <trans-unit id="35b50273596d3b9b0a5ab879d1dff2a027177930" translate="yes" xml:space="preserve">
          <source>In this plan, we have a nested-loop join node with two table scans as inputs, or children. The indentation of the node summary lines reflects the plan tree structure. The join's first, or &amp;ldquo;outer&amp;rdquo;, child is a bitmap scan similar to those we saw before. Its cost and row count are the same as we'd get from &lt;code&gt;SELECT ... WHERE unique1 &amp;lt; 10&lt;/code&gt; because we are applying the &lt;code&gt;WHERE&lt;/code&gt; clause &lt;code&gt;unique1 &amp;lt; 10&lt;/code&gt; at that node. The &lt;code&gt;t1.unique2 = t2.unique2&lt;/code&gt; clause is not relevant yet, so it doesn't affect the row count of the outer scan. The nested-loop join node will run its second, or &amp;ldquo;inner&amp;rdquo; child once for each row obtained from the outer child. Column values from the current outer row can be plugged into the inner scan; here, the &lt;code&gt;t1.unique2&lt;/code&gt; value from the outer row is available, so we get a plan and costs similar to what we saw above for a simple &lt;code&gt;SELECT ... WHERE t2.unique2 = constant&lt;/code&gt; case. (The estimated cost is actually a bit lower than what was seen above, as a result of caching that's expected to occur during the repeated index scans on &lt;code&gt;t2&lt;/code&gt;.) The costs of the loop node are then set on the basis of the cost of the outer scan, plus one repetition of the inner scan for each outer row (10 * 7.91, here), plus a little CPU time for join processing.</source>
          <target state="translated">В этом плане у нас есть узел соединения с вложенным циклом с двумя сканированными таблицами в качестве входных или дочерних. Отступ итоговых строк узлов отражает древовидную структуру плана. Первый, или &amp;laquo;внешний&amp;raquo;, дочерний элемент соединения - это сканирование растрового изображения, подобное тем, что мы видели ранее. Его стоимость и количество строк такие же , как мы получим от &lt;code&gt;SELECT ... WHERE unique1 &amp;lt; 10&lt;/code&gt; , потому что мы применяем в &lt;code&gt;WHERE&lt;/code&gt; дизъюнкцию &lt;code&gt;unique1 &amp;lt; 10&lt;/code&gt; в этом узле. Предложение &lt;code&gt;t1.unique2 = t2.unique2&lt;/code&gt; пока не актуально, поэтому оно не влияет на количество строк внешнего сканирования. Узел соединения с вложенным циклом будет запускать свой второй или &amp;laquo;внутренний&amp;raquo; дочерний элемент один раз для каждой строки, полученной от внешнего дочернего элемента. Значения столбцов из текущей внешней строки могут быть вставлены во внутреннее сканирование; здесь &lt;code&gt;t1.unique2&lt;/code&gt; доступно значение из внешней строки, поэтому мы получаем план и стоимость, аналогичные тем, которые мы видели выше для простого &lt;code&gt;SELECT ... WHERE t2.unique2 = constant&lt;/code&gt; case. (Ориентировочная стоимость на самом деле немного ниже, чем то, что было показано выше, в результате кэширования, которое, как ожидается, произойдет во время повторных сканирований индекса на &lt;code&gt;t2&lt;/code&gt; .) Затраты на узел цикла затем устанавливаются на основе стоимости внешнее сканирование, плюс одно повторение внутреннего сканирования для каждой внешней строки (здесь 10 * 7.91), плюс немного процессорного времени для обработки соединения.</target>
        </trans-unit>
        <trans-unit id="92ba779e5f5f15aa09f4dc327e10902ae3870fba" translate="yes" xml:space="preserve">
          <source>In this syntax, a zone abbreviation can be a string of letters, such as &lt;code&gt;EST&lt;/code&gt;, or an arbitrary string surrounded by angle brackets, such as &lt;code&gt;&amp;lt;UTC-05&amp;gt;&lt;/code&gt;. Note that the zone abbreviations given here are only used for output, and even then only in some timestamp output formats. The zone abbreviations recognized in timestamp input are determined as explained in &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a65ed7368072bf4eca944cd69c42b40f3442c1c" translate="yes" xml:space="preserve">
          <source>In this syntax, the &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; value is required by the standard to be a literal constant, a parameter, or a variable name; as a PostgreSQL extension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. If &lt;code&gt;count&lt;/code&gt; is omitted in a &lt;code&gt;FETCH&lt;/code&gt; clause, it defaults to 1. &lt;code&gt;ROW&lt;/code&gt; and &lt;code&gt;ROWS&lt;/code&gt; as well as &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;NEXT&lt;/code&gt; are noise words that don't influence the effects of these clauses. According to the standard, the &lt;code&gt;OFFSET&lt;/code&gt; clause must come before the &lt;code&gt;FETCH&lt;/code&gt; clause if both are present; but PostgreSQL is laxer and allows either order.</source>
          <target state="translated">В этом синтаксисе стандарт требует , чтобы &lt;code&gt;start&lt;/code&gt; значение или значение &lt;code&gt;count&lt;/code&gt; было буквальной константой, параметром или именем переменной; в качестве расширения PostgreSQL разрешены другие выражения, но, как правило, их нужно заключать в круглые скобки, чтобы избежать двусмысленности. Если &lt;code&gt;count&lt;/code&gt; опущено в предложении &lt;code&gt;FETCH&lt;/code&gt; , оно по умолчанию равно 1. &lt;code&gt;ROW&lt;/code&gt; и &lt;code&gt;ROWS&lt;/code&gt; , а также &lt;code&gt;FIRST&lt;/code&gt; и &lt;code&gt;NEXT&lt;/code&gt; - это шумовые слова, которые не влияют на действие этих предложений. Согласно стандарту, предложение &lt;code&gt;OFFSET&lt;/code&gt; должно стоять перед предложением &lt;code&gt;FETCH&lt;/code&gt; , если присутствуют оба; но PostgreSQL более слабый и допускает любой порядок.</target>
        </trans-unit>
        <trans-unit id="1aad7367e4cf00d23ec40e47a1df35bb1446273c" translate="yes" xml:space="preserve">
          <source>In this syntax, the &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; value is required by the standard to be a literal constant, a parameter, or a variable name; as a PostgreSQL extension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. If &lt;code&gt;count&lt;/code&gt; is omitted in a &lt;code&gt;FETCH&lt;/code&gt; clause, it defaults to 1. The &lt;code&gt;WITH TIES&lt;/code&gt; option is used to return any additional rows that tie for the last place in the result set according to the &lt;code&gt;ORDER BY&lt;/code&gt; clause; &lt;code&gt;ORDER BY&lt;/code&gt; is mandatory in this case. &lt;code&gt;ROW&lt;/code&gt; and &lt;code&gt;ROWS&lt;/code&gt; as well as &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;NEXT&lt;/code&gt; are noise words that don't influence the effects of these clauses. According to the standard, the &lt;code&gt;OFFSET&lt;/code&gt; clause must come before the &lt;code&gt;FETCH&lt;/code&gt; clause if both are present; but PostgreSQL is laxer and allows either order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9893e81c5b40e27434e52e7429139f563d867e" translate="yes" xml:space="preserve">
          <source>In this type of plan the table rows are fetched in index order, which makes them even more expensive to read, but there are so few that the extra cost of sorting the row locations is not worth it. You'll most often see this plan type for queries that fetch just a single row. It's also often used for queries that have an &lt;code&gt;ORDER BY&lt;/code&gt; condition that matches the index order, because then no extra sorting step is needed to satisfy the &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">В этом типе плана строки таблицы выбираются в порядке индекса, что делает их даже более дорогими для чтения, но их так мало, что дополнительные затраты на сортировку местоположений строк не окупаются. Чаще всего вы увидите этот тип плана для запросов, которые выбирают только одну строку. Он также часто используется для запросов, у которых есть условие &lt;code&gt;ORDER BY&lt;/code&gt; , которое соответствует порядку индекса, потому что тогда для удовлетворения &lt;code&gt;ORDER BY&lt;/code&gt; не требуется дополнительного шага сортировки .</target>
        </trans-unit>
        <trans-unit id="f14120df06086beebf2309a0093abef8ae36a3dc" translate="yes" xml:space="preserve">
          <source>In this type of plan the table rows are fetched in index order, which makes them even more expensive to read, but there are so few that the extra cost of sorting the row locations is not worth it. You'll most often see this plan type for queries that fetch just a single row. It's also often used for queries that have an &lt;code&gt;ORDER BY&lt;/code&gt; condition that matches the index order, because then no extra sorting step is needed to satisfy the &lt;code&gt;ORDER BY&lt;/code&gt;. In this example, adding &lt;code&gt;ORDER BY unique1&lt;/code&gt; would use the same plan because the index already implicitly provides the requested ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84eb5898e8d8ec4083399d85009281a59b8ba4c6" translate="yes" xml:space="preserve">
          <source>In versions prior to PostgreSQL 9.6, this flag matched only tables, not any other type of relation.</source>
          <target state="translated">В версиях до PostgreSQL 9.6 этот флаг соответствовал только таблицам,а не любому другому типу отношений.</target>
        </trans-unit>
        <trans-unit id="cccb2030fa433816cbfff6cfc31e7b85686eadc9" translate="yes" xml:space="preserve">
          <source>In writing your archive command, you should assume that the file names to be archived can be up to 64 characters long and can contain any combination of ASCII letters, digits, and dots. It is not necessary to preserve the original relative path (&lt;code&gt;%p&lt;/code&gt;) but it is necessary to preserve the file name (&lt;code&gt;%f&lt;/code&gt;).</source>
          <target state="translated">При написании команды архивирования вы должны предполагать, что имена архивируемых файлов могут иметь длину до 64 символов и могут содержать любую комбинацию букв, цифр и точек ASCII. Нет необходимости сохранять исходный относительный путь ( &lt;code&gt;%p&lt;/code&gt; ), но необходимо сохранить имя файла ( &lt;code&gt;%f&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="faddf9df2a3466cccf3377b581482849c1fd5256" translate="yes" xml:space="preserve">
          <source>Inaccurate time keeping can result in system instability. Test any change to the clock source very carefully. Operating system defaults are sometimes made to favor reliability over best accuracy. And if you are using a virtual machine, look into the recommended time sources compatible with it. Virtual hardware faces additional difficulties when emulating timers, and there are often per operating system settings suggested by vendors.</source>
          <target state="translated">Неточное соблюдение времени может привести к нестабильности системы.Тщательно проверяйте любое изменение источника часов.По умолчанию операционной системы иногда предпочтение отдается надежности,а не точности.А если вы используете виртуальную машину,обратите внимание на рекомендованные источники времени,совместимые с ней.Виртуальное оборудование сталкивается с дополнительными трудностями при эмуляции таймеров,и часто в операционной системе есть настройки,предложенные производителями.</target>
        </trans-unit>
        <trans-unit id="b4bae0608aa0bb22c524d2d34a5bb2a1f5386f27" translate="yes" xml:space="preserve">
          <source>Incidentally, the &lt;code&gt;BEGIN&lt;/code&gt; key word is used for a different purpose in embedded SQL. You are advised to be careful about the transaction semantics when porting database applications.</source>
          <target state="translated">Между прочим, ключевое слово &lt;code&gt;BEGIN&lt;/code&gt; во встроенном SQL используется для другой цели. Рекомендуется внимательно относиться к семантике транзакций при переносе приложений баз данных.</target>
        </trans-unit>
        <trans-unit id="f56a8df3508e9ed5684baab06fa5e61cef26eebf" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;pg_trace.h&lt;/code&gt; if it is not already present in the module(s) containing the probe points, and insert &lt;code&gt;TRACE_POSTGRESQL&lt;/code&gt; probe macros at the desired locations in the source code</source>
          <target state="translated">Включите &lt;code&gt;pg_trace.h&lt;/code&gt; , если он еще не присутствует в модулях, содержащих точки проверки, и вставьте &lt;code&gt;TRACE_POSTGRESQL&lt;/code&gt; проверки TRACE_POSTGRESQL в нужные места в исходном коде.</target>
        </trans-unit>
        <trans-unit id="2d8b7df7f5c4b05fc8f7d8518fd909017b7c32d2" translate="yes" xml:space="preserve">
          <source>Include SQL commands to clean (drop) databases before recreating them. &lt;code&gt;DROP&lt;/code&gt; commands for roles and tablespaces are added as well.</source>
          <target state="translated">Включите команды SQL для очистки (удаления) баз данных перед их воссозданием. &lt;code&gt;DROP&lt;/code&gt; добавлены команды DROP для ролей и табличных пространств.</target>
        </trans-unit>
        <trans-unit id="15af567ab13e6ebab28e457206713f05e4dcc212" translate="yes" xml:space="preserve">
          <source>Include actual startup time and time spent in each node in the output. The overhead of repeatedly reading the system clock can slow down the query significantly on some systems, so it may be useful to set this parameter to &lt;code&gt;FALSE&lt;/code&gt; when only actual row counts, and not exact times, are needed. Run time of the entire statement is always measured, even when node-level timing is turned off with this option. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">Включите фактическое время запуска и время, потраченное на каждый узел в выводе. Накладные расходы на многократное считывание системных часов могут значительно замедлить запрос в некоторых системах, поэтому может быть полезно установить для этого параметра значение &lt;code&gt;FALSE&lt;/code&gt; , когда требуется только фактическое количество строк, а не точное время. Время выполнения всего оператора всегда измеряется, даже если с помощью этой опции отключено время на уровне узла. Этот параметр можно использовать, только если также включен &lt;code&gt;ANALYZE&lt;/code&gt; . По умолчанию это &lt;code&gt;TRUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69fd997380e1370b3a2e3a89721390495f72294b" translate="yes" xml:space="preserve">
          <source>Include files or directories can be used to logically separate portions of the database configuration, rather than having a single large &lt;code&gt;postgresql.conf&lt;/code&gt; file. Consider a company that has two database servers, each with a different amount of memory. There are likely elements of the configuration both will share, for things such as logging. But memory-related parameters on the server will vary between the two. And there might be server specific customizations, too. One way to manage this situation is to break the custom configuration changes for your site into three files. You could add this to the end of your &lt;code&gt;postgresql.conf&lt;/code&gt; file to include them:</source>
          <target state="translated">Включаемые файлы или каталоги могут использоваться для логического разделения частей конфигурации базы данных, вместо того, чтобы иметь один большой файл &lt;code&gt;postgresql.conf&lt;/code&gt; . Рассмотрим компанию, у которой есть два сервера баз данных, каждый с разным объемом памяти. Скорее всего, есть элементы конфигурации, которые будут использоваться обоими, например, для ведения журнала. Но параметры, связанные с памятью на сервере, будут разными. Также могут быть настройки для конкретного сервера. Один из способов справиться с этой ситуацией - разбить пользовательские изменения конфигурации для вашего сайта на три файла. Вы можете добавить это в конец файла &lt;code&gt;postgresql.conf&lt;/code&gt; , чтобы включить их:</target>
        </trans-unit>
        <trans-unit id="12ee2acead9dafe36942e1a0338b4e8cb8ee012c" translate="yes" xml:space="preserve">
          <source>Include information on WAL record generation. Specifically, include the number of records, number of full page images (fpi) and amount of WAL bytes generated. In text format, only non-zero values are printed. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b7156430746d586783036a5e783795b65f9965" translate="yes" xml:space="preserve">
          <source>Include information on buffer usage. Specifically, include the number of shared blocks hit, read, dirtied, and written, the number of local blocks hit, read, dirtied, and written, and the number of temp blocks read and written. A &lt;em&gt;hit&lt;/em&gt; means that a read was avoided because the block was found already in cache when needed. Shared blocks contain data from regular tables and indexes; local blocks contain data from temporary tables and indexes; while temp blocks contain short-term working data used in sorts, hashes, Materialize plan nodes, and similar cases. The number of blocks &lt;em&gt;dirtied&lt;/em&gt; indicates the number of previously unmodified blocks that were changed by this query; while the number of blocks &lt;em&gt;written&lt;/em&gt; indicates the number of previously-dirtied blocks evicted from cache by this backend during query processing. The number of blocks shown for an upper-level node includes those used by all its child nodes. In text format, only non-zero values are printed. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">Включите информацию об использовании буфера. В частности, включите количество общих блоков, которые были выполнены, прочитаны, загрязнены и записаны, количество локальных блоков, найденных, прочитанных, загрязненных и записанных, а также количество временных блоков, прочитанных и записанных. &lt;em&gt;Удар&lt;/em&gt; означает , что прочитанный удалось избежать , потому что блок был найден в кэше , когда это необходимо. Общие блоки содержат данные из обычных таблиц и индексов; локальные блоки содержат данные из временных таблиц и индексов; в то время как временные блоки содержат краткосрочные рабочие данные, используемые в сортировках, хэшах, узлах плана материализации и подобных случаях. Количество &lt;em&gt;загрязненных&lt;/em&gt; блоков указывает количество ранее немодифицированных блоков, которые были изменены этим запросом; а количество &lt;em&gt;записанных&lt;/em&gt; блоков&lt;em&gt;&lt;/em&gt;указывает количество ранее загрязненных блоков, вытесненных из кеша этим сервером во время обработки запроса. Количество блоков, показанных для узла верхнего уровня, включает блоки, используемые всеми его дочерними узлами. В текстовом формате печатаются только ненулевые значения. Этот параметр можно использовать, только если также включен &lt;code&gt;ANALYZE&lt;/code&gt; . По умолчанию &lt;code&gt;FALSE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42e6828248f4c65573605405eae9a72feadb86b8" translate="yes" xml:space="preserve">
          <source>Include information on buffer usage. Specifically, include the number of shared blocks hit, read, dirtied, and written, the number of local blocks hit, read, dirtied, and written, the number of temp blocks read and written, and the time spent reading and writing data file blocks (in milliseconds) if &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; is enabled. A &lt;em&gt;hit&lt;/em&gt; means that a read was avoided because the block was found already in cache when needed. Shared blocks contain data from regular tables and indexes; local blocks contain data from temporary tables and indexes; while temp blocks contain short-term working data used in sorts, hashes, Materialize plan nodes, and similar cases. The number of blocks &lt;em&gt;dirtied&lt;/em&gt; indicates the number of previously unmodified blocks that were changed by this query; while the number of blocks &lt;em&gt;written&lt;/em&gt; indicates the number of previously-dirtied blocks evicted from cache by this backend during query processing. The number of blocks shown for an upper-level node includes those used by all its child nodes. In text format, only non-zero values are printed. It defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf950011b674c52ed53fd1187206feef3854c98" translate="yes" xml:space="preserve">
          <source>Include information on configuration parameters. Specifically, include options affecting query planning with value different from the built-in default value. This parameter defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">Включите информацию о параметрах конфигурации. В частности, включите параметры, влияющие на планирование запроса, со значением, отличным от встроенного значения по умолчанию. По умолчанию этот параметр имеет значение &lt;code&gt;FALSE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd7df900c420c99916abebaeb86bc9b9487e3ff6" translate="yes" xml:space="preserve">
          <source>Include information on the estimated startup and total cost of each plan node, as well as the estimated number of rows and the estimated width of each row. This parameter defaults to &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">Включите информацию о предполагаемом запуске и общей стоимости каждого узла плана, а также о предполагаемом количестве строк и предполагаемой ширине каждой строки. По умолчанию этот параметр имеет значение &lt;code&gt;TRUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5b5e034a15e397016c3928803cda54f49c8fb74" translate="yes" xml:space="preserve">
          <source>Include large objects in the dump. This is the default behavior except when &lt;code&gt;--schema&lt;/code&gt;, &lt;code&gt;--table&lt;/code&gt;, or &lt;code&gt;--schema-only&lt;/code&gt; is specified. The &lt;code&gt;-b&lt;/code&gt; switch is therefore only useful to add large objects to dumps where a specific schema or table has been requested. Note that blobs are considered data and therefore will be included when &lt;code&gt;--data-only&lt;/code&gt; is used, but not when &lt;code&gt;--schema-only&lt;/code&gt; is.</source>
          <target state="translated">Включайте в свалку крупные предметы. Это поведение по умолчанию, за исключением случаев, когда &lt;code&gt;--schema&lt;/code&gt; , &lt;code&gt;--table&lt;/code&gt; или &lt;code&gt;--schema-only&lt;/code&gt; . Поэтому ключ &lt;code&gt;-b&lt;/code&gt; полезен только для добавления больших объектов в дампы, где была запрошена конкретная схема или таблица. Обратите внимание, что &lt;code&gt;--schema-only&lt;/code&gt; считаются данными и поэтому будут включены, когда используется &lt;code&gt;--data-only&lt;/code&gt; , но не когда --schema-only .</target>
        </trans-unit>
        <trans-unit id="08c7d11c8d4a8d10c948989b5a35951818754be1" translate="yes" xml:space="preserve">
          <source>Include summary information (e.g., totaled timing information) after the query plan. Summary information is included by default when &lt;code&gt;ANALYZE&lt;/code&gt; is used but otherwise is not included by default, but can be enabled using this option. Planning time in &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; includes the time required to fetch the plan from the cache and the time required for re-planning, if necessary.</source>
          <target state="translated">Включите сводную информацию (например, общую информацию о времени) после плана запроса. Сводная информация включается по умолчанию, когда используется &lt;code&gt;ANALYZE&lt;/code&gt; , но в остальном не включается по умолчанию, но может быть включена с помощью этой опции. Время планирования в &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; включает время, необходимое для извлечения плана из кеша, и время, необходимое для перепланирования, если это необходимо.</target>
        </trans-unit>
        <trans-unit id="2f2cb48cc7645d02e5f49dead86862d11be771ed" translate="yes" xml:space="preserve">
          <source>Includes the required WAL (write-ahead log) files in the backup. This will include all write-ahead logs generated during the backup. Unless the method &lt;code&gt;none&lt;/code&gt; is specified, it is possible to start a postmaster in the target directory without the need to consult the log archive, thus making the output a completely standalone backup.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
