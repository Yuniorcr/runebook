<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="13bf3c4060b6a548c1c5420c5acc0dd3edcdfdfa" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, the write-ahead log files will be written to the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">Когда используется режим формата tar, файлы журнала упреждающей записи будут записаны в файл &lt;code&gt;base.tar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f11ae7cfc9d8e7c9709340ffb2024d1b68d62efb" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; parameter is set to true on a standby server, it will begin accepting connections once the recovery has brought the system to a consistent state. All such connections are strictly read-only; not even temporary tables may be written.</source>
          <target state="translated">Если для параметра &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; установлено значение true на резервном сервере, он начнет принимать соединения, как только восстановление приведет систему в согласованное состояние. Все такие подключения доступны только для чтения; нельзя писать даже временные таблицы.</target>
        </trans-unit>
        <trans-unit id="7959e96ecaba15e9d39e3fc41cafc94b8dcfae7f" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;CONSTRAINT&lt;/code&gt; option is specified, this command creates a &lt;em&gt;constraint trigger&lt;/em&gt;. This is the same as a regular trigger except that the timing of the trigger firing can be adjusted using &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt;. Constraint triggers must be &lt;code&gt;AFTER ROW&lt;/code&gt; triggers on plain tables (not foreign tables). They can be fired either at the end of the statement causing the triggering event, or at the end of the containing transaction; in the latter case they are said to be &lt;em&gt;deferred&lt;/em&gt;. A pending deferred-trigger firing can also be forced to happen immediately by using &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;. Constraint triggers are expected to raise an exception when the constraints they implement are violated.</source>
          <target state="translated">Когда &lt;code&gt;CONSTRAINT&lt;/code&gt; опция CONSTRAINT , эта команда создает &lt;em&gt;триггер ограничения&lt;/em&gt; . Это то же самое, что и обычный триггер, за исключением того, что время срабатывания триггера можно настроить с помощью &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; . Триггеры ограничения должны быть триггерами &lt;code&gt;AFTER ROW&lt;/code&gt; для простых таблиц (не сторонних таблиц). Они могут быть активированы либо в конце оператора, вызывающего инициирующее событие, либо в конце содержащей транзакции; в последнем случае они считаются &lt;em&gt;отложенными&lt;/em&gt; . Отложенное срабатывание отложенного триггера также может быть принудительно выполнено немедленно с помощью &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; . Ожидается, что триггеры ограничения вызовут исключение при нарушении реализуемых ими ограничений.</target>
        </trans-unit>
        <trans-unit id="df5c7d4a7ad0b452626a13ac455de82c0906adea" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;SELECT&lt;/code&gt; is one arm of a &lt;code&gt;UNION&lt;/code&gt; (or &lt;code&gt;INTERSECT&lt;/code&gt; or &lt;code&gt;EXCEPT&lt;/code&gt;) construct, or when it appears within &lt;code&gt;INSERT ... SELECT&lt;/code&gt;, this rule is not applied since rules given in preceding sections take precedence. The type of an unspecified-type literal can be taken from the other &lt;code&gt;UNION&lt;/code&gt; arm in the first case, or from the destination column in the second case.</source>
          <target state="translated">Когда &lt;code&gt;SELECT&lt;/code&gt; является одним из &lt;code&gt;INTERSECT&lt;/code&gt; конструкции &lt;code&gt;UNION&lt;/code&gt; (или INTERSECT, или &lt;code&gt;EXCEPT&lt;/code&gt; ) или когда он появляется в &lt;code&gt;INSERT ... SELECT&lt;/code&gt; , это правило не применяется, поскольку правила, приведенные в предыдущих разделах, имеют приоритет. Тип литерала неопределенного типа может быть взят из другого плеча &lt;code&gt;UNION&lt;/code&gt; в первом случае или из целевого столбца во втором случае.</target>
        </trans-unit>
        <trans-unit id="7f2ffb48d56de0e4aaa18bb9efa3e04da4e9e279" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;WHERE&lt;/code&gt; clause is present, a &lt;em&gt;partial index&lt;/em&gt; is created. A partial index is an index that contains entries for only a portion of a table, usually a portion that is more useful for indexing than the rest of the table. For example, if you have a table that contains both billed and unbilled orders where the unbilled orders take up a small fraction of the total table and yet that is an often used section, you can improve performance by creating an index on just that portion. Another possible application is to use &lt;code&gt;WHERE&lt;/code&gt; with &lt;code&gt;UNIQUE&lt;/code&gt; to enforce uniqueness over a subset of a table. See &lt;a href=&quot;indexes-partial&quot;&gt;Section 11.8&lt;/a&gt; for more discussion.</source>
          <target state="translated">Когда присутствует &lt;code&gt;WHERE&lt;/code&gt; , создается &lt;em&gt;частичный индекс&lt;/em&gt; . Частичный индекс - это индекс, который содержит записи только для части таблицы, обычно той части, которая более полезна для индексации, чем остальная часть таблицы. Например, если у вас есть таблица, содержащая как выставленные, так и невыплаченные заказы, где невыплаченные заказы занимают небольшую долю от общей таблицы, но при этом это часто используемый раздел, вы можете повысить производительность, создав индекс только для этой части. Другое возможное применение - использование &lt;code&gt;WHERE&lt;/code&gt; с &lt;code&gt;UNIQUE&lt;/code&gt; для обеспечения уникальности для подмножества таблицы. См. &lt;a href=&quot;indexes-partial&quot;&gt;Раздел 11.8&lt;/a&gt; для более подробного обсуждения.</target>
        </trans-unit>
        <trans-unit id="4116b168926d645beb5cdf62d04cc02528b0adbd" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;\aset&lt;/code&gt; command is used, all combined SQL queries (separated by &lt;code&gt;\;&lt;/code&gt;) have their columns stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided. If a query returns no row, no assignment is made and the variable can be tested for existence to detect this. If a query returns more than one row, the last value is kept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="438baff021646797a12e7710aeb9b4212d4a00b5" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;\gset&lt;/code&gt; command is used, the preceding SQL query is expected to return one row, the columns of which are stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c185ac9497904ca6d14d82c8dc0a0e1690d4901" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ampredlocks&lt;/code&gt; flag is not set, any scan using that index access method within a serializable transaction will acquire a nonblocking predicate lock on the full index. This will generate a read-write conflict with the insert of any tuple into that index by a concurrent serializable transaction. If certain patterns of read-write conflicts are detected among a set of concurrent serializable transactions, one of those transactions may be canceled to protect data integrity. When the flag is set, it indicates that the index access method implements finer-grained predicate locking, which will tend to reduce the frequency of such transaction cancellations.</source>
          <target state="translated">Если флаг &lt;code&gt;ampredlocks&lt;/code&gt; не установлен, любое сканирование с использованием этого метода доступа к индексу в сериализуемой транзакции получит неблокирующую блокировку предиката для полного индекса. Это вызовет конфликт чтения-записи при вставке любого кортежа в этот индекс параллельной сериализуемой транзакцией. Если среди набора параллельных сериализуемых транзакций обнаруживаются определенные шаблоны конфликтов чтения-записи, одна из этих транзакций может быть отменена для защиты целостности данных. Когда этот флаг установлен, это указывает на то, что метод доступа к индексу реализует более детальную блокировку предикатов, которая будет иметь тенденцию уменьшать частоту таких отмен транзакций.</target>
        </trans-unit>
        <trans-unit id="32c110466857121d054324f74c8a38f9bb5212e4" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;border&lt;/code&gt; setting is greater than zero, the &lt;code&gt;linestyle&lt;/code&gt; option also determines the characters with which the border lines are drawn. Plain ASCII characters work everywhere, but Unicode characters look nicer on displays that recognize them.</source>
          <target state="translated">Когда параметр &lt;code&gt;border&lt;/code&gt; больше нуля, параметр &lt;code&gt;linestyle&lt;/code&gt; также определяет символы, с помощью которых рисуются линии границы. Обычные символы ASCII работают везде, но символы Unicode лучше смотрятся на дисплеях, которые их распознают.</target>
        </trans-unit>
        <trans-unit id="00d6a0dfb20c2e25ada6bca76d0486b409be8ef1" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pager&lt;/code&gt; option is &lt;code&gt;off&lt;/code&gt;, the pager program is not used. When the &lt;code&gt;pager&lt;/code&gt; option is &lt;code&gt;on&lt;/code&gt;, the pager is used when appropriate, i.e., when the output is to a terminal and will not fit on the screen. The &lt;code&gt;pager&lt;/code&gt; option can also be set to &lt;code&gt;always&lt;/code&gt;, which causes the pager to be used for all terminal output regardless of whether it fits on the screen. &lt;code&gt;\pset pager&lt;/code&gt; without a &lt;code&gt;value&lt;/code&gt; toggles pager use on and off.</source>
          <target state="translated">Когда опция &lt;code&gt;pager&lt;/code&gt; &lt;code&gt;off&lt;/code&gt; , программа пейджера не используется. Когда &lt;code&gt;pager&lt;/code&gt; опция &lt;code&gt;on&lt;/code&gt; пейджер используется , когда это необходимо, т.е., когда выход в терминал и не помещается на экране. Параметр &lt;code&gt;pager&lt;/code&gt; также может быть установлен на &lt;code&gt;always&lt;/code&gt; , в результате чего пейджер будет использоваться для всего вывода терминала, независимо от того, умещается ли он на экране. &lt;code&gt;\pset pager&lt;/code&gt; без &lt;code&gt;value&lt;/code&gt; включает и выключает использование пейджера.</target>
        </trans-unit>
        <trans-unit id="81a140433737ca4c23a575624ce695fcc511dede" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pg_buffercache&lt;/code&gt; view is accessed, internal buffer manager locks are taken for long enough to copy all the buffer state data that the view will display. This ensures that the view produces a consistent set of results, while not blocking normal buffer activity longer than necessary. Nonetheless there could be some impact on database performance if this view is read often.</source>
          <target state="translated">Когда осуществляется &lt;code&gt;pg_buffercache&lt;/code&gt; представлению pg_buffercache , блокировки внутреннего диспетчера буферов принимаются на достаточно долгое время, чтобы скопировать все данные о состоянии буфера, которые будет отображать представление. Это гарантирует, что представление дает последовательный набор результатов, не блокируя при этом нормальную активность буфера дольше, чем необходимо. Тем не менее, частое чтение этого представления может оказать некоторое влияние на производительность базы данных.</target>
        </trans-unit>
        <trans-unit id="cd60a2856753e705f8fe475e92d422e142a5a733" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pg_prepared_xacts&lt;/code&gt; view is accessed, the internal transaction manager data structures are momentarily locked, and a copy is made for the view to display. This ensures that the view produces a consistent set of results, while not blocking normal operations longer than necessary. Nonetheless there could be some impact on database performance if this view is frequently accessed.</source>
          <target state="translated">При &lt;code&gt;pg_prepared_xacts&lt;/code&gt; представлению pg_prepared_xacts внутренние структуры данных менеджера транзакций на мгновение блокируются, и создается копия для отображения представления. Это гарантирует, что представление дает согласованный набор результатов, не блокируя нормальные операции дольше, чем необходимо. Тем не менее, частое обращение к этому представлению может оказать некоторое влияние на производительность базы данных.</target>
        </trans-unit>
        <trans-unit id="7ee8be71b9dbdb6fe9839b8abd30a5d0ca45b722" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;text&lt;/code&gt; format is used, the data read or written is a text file with one line per table row. Columns in a row are separated by the delimiter character. The column values themselves are strings generated by the output function, or acceptable to the input function, of each attribute's data type. The specified null string is used in place of columns that are null. &lt;code&gt;COPY FROM&lt;/code&gt; will raise an error if any line of the input file contains more or fewer columns than are expected.</source>
          <target state="translated">Когда используется &lt;code&gt;text&lt;/code&gt; формат, считываемые или записываемые данные представляют собой текстовый файл с одной строкой на строку таблицы. Столбцы в строке разделяются символом-разделителем. Сами значения столбцов представляют собой строки, генерируемые функцией вывода или приемлемые для функции ввода, каждого типа данных атрибута. Указанная пустая строка используется вместо пустых столбцов. &lt;code&gt;COPY FROM&lt;/code&gt; вызовет ошибку, если какая-либо строка входного файла содержит больше или меньше столбцов, чем ожидается.</target>
        </trans-unit>
        <trans-unit id="1c4c47cbbcff114da7b14a508ba7d65a0b19eac7" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; argument to verification functions is &lt;code&gt;true&lt;/code&gt;, an additional phase of verification is performed against the table associated with the target index relation. This consists of a &amp;ldquo;dummy&amp;rdquo;&lt;code&gt;CREATE INDEX&lt;/code&gt; operation, which checks for the presence of all hypothetical new index tuples against a temporary, in-memory summarizing structure (this is built when needed during the basic first phase of verification). The summarizing structure &amp;ldquo;fingerprints&amp;rdquo; every tuple found within the target index. The high level principle behind &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is that a new index that is equivalent to the existing, target index must only have entries that can be found in the existing structure.</source>
          <target state="translated">Когда аргумент &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; для функций проверки &lt;code&gt;true&lt;/code&gt; , выполняется дополнительная фаза проверки для таблицы, связанной с отношением целевого индекса. Он состоит из &amp;laquo;фиктивной&amp;raquo; операции &lt;code&gt;CREATE INDEX&lt;/code&gt; , которая проверяет наличие всех гипотетических новых кортежей индекса по временной суммирующей структуре в памяти (она создается, когда это необходимо, во время основной первой фазы проверки). Резюмирующая структура &amp;laquo;отпечатывает&amp;raquo; каждый кортеж, найденный в целевом индексе. Принцип высокого уровня, лежащий в &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; проверки &lt;em&gt;heapallindexed,&lt;/em&gt; заключается в том, что новый индекс, эквивалентный существующему целевому индексу, должен иметь только записи, которые можно найти в существующей структуре.</target>
        </trans-unit>
        <trans-unit id="40b2d91686c90899997e62b0858a7f4eb03cb150" translate="yes" xml:space="preserve">
          <source>When the backup is in tar format, the target directory may be specified as &lt;code&gt;-&lt;/code&gt; (dash), causing the tar file to be written to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4898e6eb712c6c928410a4432225d77730464bb" translate="yes" xml:space="preserve">
          <source>When the backup is in tar mode, and the directory is specified as &lt;code&gt;-&lt;/code&gt; (dash), the tar file will be written to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">Когда резервная копия находится в режиме tar, а каталог указан как &lt;code&gt;-&lt;/code&gt; (тире), файл tar будет записан в стандартный &lt;code&gt;stdout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bf62b247e8d0c8ddb36cb4a11374b1155c5b650" translate="yes" xml:space="preserve">
          <source>When the client application uses the &amp;ldquo;extended query&amp;rdquo; protocol to issue a &lt;code&gt;FETCH&lt;/code&gt; command, the Bind protocol message specifies whether data is to be retrieved in text or binary format. This choice overrides the way that the cursor is defined. The concept of a binary cursor as such is thus obsolete when using extended query protocol &amp;mdash; any cursor can be treated as either text or binary.</source>
          <target state="translated">Когда клиентское приложение использует протокол &amp;laquo;расширенного запроса&amp;raquo; для выдачи команды &lt;code&gt;FETCH&lt;/code&gt; , сообщение протокола Bind указывает, должны ли данные извлекаться в текстовом или двоичном формате. Этот выбор отменяет способ определения курсора. Таким образом, концепция двоичного курсора как такового устарела при использовании расширенного протокола запросов - любой курсор можно рассматривать как текстовый или двоичный.</target>
        </trans-unit>
        <trans-unit id="cef2bc6393c8c4a9107edf2302ecf0f071877452" translate="yes" xml:space="preserve">
          <source>When the connection to the server is lost, do not retry in a loop, just exit.</source>
          <target state="translated">Когда соединение с сервером потеряно,не делайте повторных попыток в цикле,а просто выйдите из него.</target>
        </trans-unit>
        <trans-unit id="c8229aa8ad36a0b0c5e6146511e976844f24d945" translate="yes" xml:space="preserve">
          <source>When the database generates SQL, force all identifiers to be quoted, even if they are not (currently) keywords. This will affect the output of &lt;code&gt;EXPLAIN&lt;/code&gt; as well as the results of functions like &lt;code&gt;pg_get_viewdef&lt;/code&gt;. See also the &lt;code&gt;--quote-all-identifiers&lt;/code&gt; option of &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; and &lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt;.</source>
          <target state="translated">Когда база данных генерирует SQL, принудительно заключайте в кавычки все идентификаторы, даже если они (в настоящее время) не являются ключевыми словами. Это повлияет на вывод &lt;code&gt;EXPLAIN&lt;/code&gt; , а также на результаты таких функций, как &lt;code&gt;pg_get_viewdef&lt;/code&gt; . См. Также параметр &lt;code&gt;--quote-all-identifiers&lt;/code&gt; для &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; и &lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea2bc8f44657321dd80c423b48806c42005dbc7a" translate="yes" xml:space="preserve">
          <source>When the database system has to perform an ordering or a character classification, it uses the collation of the input expression. This happens, for example, with &lt;code&gt;ORDER BY&lt;/code&gt; clauses and function or operator calls such as &lt;code&gt;&amp;lt;&lt;/code&gt;. The collation to apply for an &lt;code&gt;ORDER BY&lt;/code&gt; clause is simply the collation of the sort key. The collation to apply for a function or operator call is derived from the arguments, as described below. In addition to comparison operators, collations are taken into account by functions that convert between lower and upper case letters, such as &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, and &lt;code&gt;initcap&lt;/code&gt;; by pattern matching operators; and by &lt;code&gt;to_char&lt;/code&gt; and related functions.</source>
          <target state="translated">Когда системе базы данных необходимо выполнить упорядочение или классификацию символов, она использует сопоставление входного выражения. Это происходит, например, с предложениями &lt;code&gt;ORDER BY&lt;/code&gt; и вызовами функций или операторов, таких как &lt;code&gt;&amp;lt;&lt;/code&gt; . Сопоставление, применяемое для предложения &lt;code&gt;ORDER BY&lt;/code&gt; , - это просто сопоставление ключа сортировки. Параметры сортировки, применяемые для вызова функции или оператора, производятся на основе аргументов, как описано ниже. В дополнение к операторам сравнения, сопоставления учитываются функциями, которые преобразуют буквы нижнего и верхнего регистра, например &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; и &lt;code&gt;initcap&lt;/code&gt; ; операторами сопоставления с образцом; и &lt;code&gt;to_char&lt;/code&gt; и связанные с ним функции.</target>
        </trans-unit>
        <trans-unit id="cf20c03f9a438d0f6675629396820f040d752814" translate="yes" xml:space="preserve">
          <source>When the defaults aren't quite right, you can save yourself some typing by setting the environment variables &lt;code&gt;PGDATABASE&lt;/code&gt;, &lt;code&gt;PGHOST&lt;/code&gt;, &lt;code&gt;PGPORT&lt;/code&gt; and/or &lt;code&gt;PGUSER&lt;/code&gt; to appropriate values. (For additional environment variables, see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;.) It is also convenient to have a &lt;code&gt;~/.pgpass&lt;/code&gt; file to avoid regularly having to type in passwords. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt; for more information.</source>
          <target state="translated">Если значения по умолчанию не совсем правильные, вы можете сэкономить время на вводе текста, установив для переменных среды &lt;code&gt;PGDATABASE&lt;/code&gt; , &lt;code&gt;PGHOST&lt;/code&gt; , &lt;code&gt;PGPORT&lt;/code&gt; и / или &lt;code&gt;PGUSER&lt;/code&gt; соответствующие значения. (О дополнительных переменных среды см. &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Раздел 33.14&lt;/a&gt; .) Также удобно иметь файл &lt;code&gt;~/.pgpass&lt;/code&gt; , чтобы избежать регулярного ввода паролей. См &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;раздел 33.15&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="6f26c72fbc997c040dd4a76409d282497125e57c" translate="yes" xml:space="preserve">
          <source>When the defaults aren't quite right, you can save yourself some typing by setting the environment variables &lt;code&gt;PGDATABASE&lt;/code&gt;, &lt;code&gt;PGHOST&lt;/code&gt;, &lt;code&gt;PGPORT&lt;/code&gt; and/or &lt;code&gt;PGUSER&lt;/code&gt; to appropriate values. (For additional environment variables, see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;.) It is also convenient to have a &lt;code&gt;~/.pgpass&lt;/code&gt; file to avoid regularly having to type in passwords. See &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58644d348761a861122023ab84e086a5de61b1bd" translate="yes" xml:space="preserve">
          <source>When the input value is +/-Infinity, &lt;code&gt;extract&lt;/code&gt; returns +/-Infinity for monotonically-increasing fields (&lt;code&gt;epoch&lt;/code&gt;, &lt;code&gt;julian&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;isoyear&lt;/code&gt;, &lt;code&gt;decade&lt;/code&gt;, &lt;code&gt;century&lt;/code&gt;, and &lt;code&gt;millennium&lt;/code&gt;). For other fields, NULL is returned. PostgreSQL versions before 9.6 returned zero for all cases of infinite input.</source>
          <target state="translated">Когда входное значение равно +/- Infinity, &lt;code&gt;extract&lt;/code&gt; возвращает +/- Infinity для монотонно возрастающих полей ( &lt;code&gt;epoch&lt;/code&gt; , &lt;code&gt;julian&lt;/code&gt; , &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;isoyear&lt;/code&gt; , &lt;code&gt;decade&lt;/code&gt; , &lt;code&gt;century&lt;/code&gt; и &lt;code&gt;millennium&lt;/code&gt; ). Для других полей возвращается NULL. Версии PostgreSQL до 9.6 возвращали ноль для всех случаев бесконечного ввода.</target>
        </trans-unit>
        <trans-unit id="ca7b95a2bfd76e66a3b9a3c283932ae7ceb9d1f3" translate="yes" xml:space="preserve">
          <source>When the input value is of type &lt;code&gt;timestamp with time zone&lt;/code&gt;, the truncation is performed with respect to a particular time zone; for example, truncation to &lt;code&gt;day&lt;/code&gt; produces a value that is midnight in that zone. By default, truncation is done with respect to the current &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; setting, but the optional &lt;code&gt;time_zone&lt;/code&gt; argument can be provided to specify a different time zone. The time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;.</source>
          <target state="translated">Когда входное значение имеет тип &lt;code&gt;timestamp with time zone&lt;/code&gt; , усечение выполняется относительно определенного часового пояса; например, при усечении до &lt;code&gt;day&lt;/code&gt; получается значение, равное полуночи в этой зоне. По умолчанию усечение выполняется относительно текущего параметра &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; , но можно указать необязательный аргумент &lt;code&gt;time_zone&lt;/code&gt; , чтобы указать другой часовой пояс. Имя часового пояса можно указать любым из способов, описанных в &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Разделе 8.5.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9861851aff8e3d639ce4f8c2222c534c2772377" translate="yes" xml:space="preserve">
          <source>When the last argument begins with &lt;code&gt;|&lt;/code&gt;, the entire remainder of the line is taken to be the &lt;code&gt;command&lt;/code&gt; to execute, and neither variable interpolation nor backquote expansion are performed in it. The rest of the line is simply passed literally to the shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb992423a64d9af4e9c24a6d03361c5985029c38" translate="yes" xml:space="preserve">
          <source>When the node at the top of the parallel portion of the plan is &lt;code&gt;Gather Merge&lt;/code&gt; rather than &lt;code&gt;Gather&lt;/code&gt;, it indicates that each process executing the parallel portion of the plan is producing tuples in sorted order, and that the leader is performing an order-preserving merge. In contrast, &lt;code&gt;Gather&lt;/code&gt; reads tuples from the workers in whatever order is convenient, destroying any sort order that may have existed.</source>
          <target state="translated">Когда узел в верхней части параллельной части плана - это &lt;code&gt;Gather Merge&lt;/code&gt; , а не &lt;code&gt;Gather&lt;/code&gt; , это означает, что каждый процесс, выполняющий параллельную часть плана, создает кортежи в отсортированном порядке, и что лидер выполняет слияние с сохранением порядка . Напротив, &lt;code&gt;Gather&lt;/code&gt; считывает кортежи из рабочих в любом удобном порядке, уничтожая любой порядок сортировки, который мог существовать.</target>
        </trans-unit>
        <trans-unit id="3c8d54f7450d49b82cd5a8da77194f4c25e5cdb1" translate="yes" xml:space="preserve">
          <source>When the operating system sends a write request to the storage hardware, there is little it can do to make sure the data has arrived at a truly non-volatile storage area. Rather, it is the administrator's responsibility to make certain that all storage components ensure integrity for both data and file-system metadata. Avoid disk controllers that have non-battery-backed write caches. At the drive level, disable write-back caching if the drive cannot guarantee the data will be written before shutdown. If you use SSDs, be aware that many of these do not honor cache flush commands by default. You can test for reliable I/O subsystem behavior using &lt;a href=&quot;https://brad.livejournal.com/2116715.html&quot;&gt;&lt;code&gt;diskchecker.pl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда операционная система отправляет запрос на запись в аппаратное обеспечение хранения, она мало что может сделать, чтобы убедиться, что данные прибыли в действительно энергонезависимую область хранения. Скорее, ответственность за то, чтобы все компоненты хранилища обеспечивали целостность как данных, так и метаданных файловой системы, лежит на администраторе. Избегайте использования дисковых контроллеров с кэшем записи без резервного питания от батареи. На уровне диска отключите кэширование с обратной записью, если диск не может гарантировать, что данные будут записаны перед выключением. Если вы используете твердотельные накопители, имейте в виду, что многие из них по умолчанию не поддерживают команды очистки кеша. Вы можете проверить надежность работы подсистемы ввода-вывода с помощью &lt;a href=&quot;https://brad.livejournal.com/2116715.html&quot;&gt; &lt;code&gt;diskchecker.pl&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d33bb04f73c12f42af37757660638f7bf07dd0c" translate="yes" xml:space="preserve">
          <source>When the optimizer determines that parallel query is the fastest execution strategy for a particular query, it will create a query plan which includes a &lt;em&gt;Gather&lt;/em&gt; or &lt;em&gt;Gather Merge&lt;/em&gt; node. Here is a simple example:</source>
          <target state="translated">Когда оптимизатор определяет, что параллельный запрос является самой быстрой стратегией выполнения для конкретного запроса, он создает план запроса, который включает узел &lt;em&gt;Gather&lt;/em&gt; или &lt;em&gt;Gather Merge&lt;/em&gt; . Вот простой пример:</target>
        </trans-unit>
        <trans-unit id="01b643d7a7954ad91561b8c24a008664f59d15dd" translate="yes" xml:space="preserve">
          <source>When the option list is surrounded by parentheses, the options can be written in any order. The parenthesized syntax was added in PostgreSQL 11; the unparenthesized syntax is deprecated.</source>
          <target state="translated">Когда список опций окружен круглыми скобками,опции могут быть записаны в любом порядке.Синтаксис в круглых скобках был добавлен в PostgreSQL 11;синтаксис в неполных скобках устарел.</target>
        </trans-unit>
        <trans-unit id="abee5df8a890efa75529bd092cf02d64e5f74e41" translate="yes" xml:space="preserve">
          <source>When the option list is surrounded by parentheses, the options can be written in any order. Without parentheses, options must be specified in exactly the order shown above. The parenthesized syntax was added in PostgreSQL 9.0; the unparenthesized syntax is deprecated.</source>
          <target state="translated">Когда список опций окружен круглыми скобками,опции могут быть записаны в любом порядке.Без скобок,опционы должны быть указаны именно в том порядке,который показан выше.Синтаксис в круглых скобках был добавлен в PostgreSQL 9.0;синтаксис без скобок устарел.</target>
        </trans-unit>
        <trans-unit id="0e9dc738f4097cde58c9e8bf1cce2f13a3e0faff" translate="yes" xml:space="preserve">
          <source>When the query executor is running a statement using &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;, individual operations are timed as well as showing a summary. The overhead of your system can be checked by counting rows with the psql program:</source>
          <target state="translated">Когда исполнитель запроса запускает оператор с использованием &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; , отдельные операции рассчитываются по времени, а также отображается сводка. Накладные расходы вашей системы можно проверить, посчитав строки с помощью программы psql:</target>
        </trans-unit>
        <trans-unit id="a4efc71382094156bb1e14ebb8922c4bbfee26e8" translate="yes" xml:space="preserve">
          <source>When the query involves more than two relations, the final result must be built up by a tree of join steps, each with two inputs. The planner examines different possible join sequences to find the cheapest one.</source>
          <target state="translated">Когда запрос включает в себя более двух отношений,конечный результат должен быть построен по дереву объединенных шагов,каждый из которых имеет два входа.Планировщик исследует различные возможные последовательности соединений,чтобы найти самую дешевую.</target>
        </trans-unit>
        <trans-unit id="f91c3e21cf6bd9480dad3eeeece86758f55a90e3" translate="yes" xml:space="preserve">
          <source>When the query involves outer joins, the planner has less freedom than it does for plain (inner) joins. For example, consider:</source>
          <target state="translated">Когда запрос касается внешних соединений,планировщик имеет меньше свободы,чем при простых (внутренних)соединениях.Например,рассмотрим:</target>
        </trans-unit>
        <trans-unit id="53d57a11c26095ca3bee53a6ad82668d9cd1b948" translate="yes" xml:space="preserve">
          <source>When the replication client of pg_receivewal is configured on the server as a synchronous standby, then using a replication slot will report the flush position to the server, but only when a WAL file is closed. Therefore, that configuration will cause transactions on the primary to wait for a long time and effectively not work satisfactorily. The option &lt;code&gt;--synchronous&lt;/code&gt; (see below) must be specified in addition to make this work correctly.</source>
          <target state="translated">Когда клиент репликации pg_receivewal настроен на сервере как синхронный резервный, тогда использование слота репликации будет сообщать серверу позицию сброса, но только когда файл WAL закрыт. Следовательно, такая конфигурация приведет к тому, что транзакции на первичном сервере будут ждать долгое время и эффективно не работать удовлетворительно. Для &lt;code&gt;--synchronous&lt;/code&gt; необходимо указать параметр --synchronous (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="6e97e877617ee50758f9c1ed0038c82401b37ff4" translate="yes" xml:space="preserve">
          <source>When the server finds an entry in the &lt;code&gt;pg_pltemplate&lt;/code&gt; catalog for the given language name, it will use the catalog data even if the command includes language parameters. This behavior simplifies loading of old dump files, which are likely to contain out-of-date information about language support functions.</source>
          <target state="translated">Когда сервер находит запись в каталоге &lt;code&gt;pg_pltemplate&lt;/code&gt; для данного имени языка, он будет использовать данные каталога, даже если команда включает языковые параметры. Такое поведение упрощает загрузку старых файлов дампа, которые могут содержать устаревшую информацию о функциях поддержки языка.</target>
        </trans-unit>
        <trans-unit id="826ce26725107a5df987e11185041fdbac70af26" translate="yes" xml:space="preserve">
          <source>When the standby is started and &lt;code&gt;primary_conninfo&lt;/code&gt; is set correctly, the standby will connect to the primary after replaying all WAL files available in the archive. If the connection is established successfully, you will see a &lt;code&gt;walreceiver&lt;/code&gt; in the standby, and a corresponding &lt;code&gt;walsender&lt;/code&gt; process in the primary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5acf91c2009ea693cf720914c5dcc7ec25263a3f" translate="yes" xml:space="preserve">
          <source>When the standby is started and &lt;code&gt;primary_conninfo&lt;/code&gt; is set correctly, the standby will connect to the primary after replaying all WAL files available in the archive. If the connection is established successfully, you will see a walreceiver process in the standby, and a corresponding walsender process in the primary.</source>
          <target state="translated">Когда резервный запущен и &lt;code&gt;primary_conninfo&lt;/code&gt; установлен правильно, резервный подключится к основному после воспроизведения всех файлов WAL, доступных в архиве. Если соединение установлено успешно, вы увидите процесс walreceiver в режиме ожидания и соответствующий процесс walsender в основном сервере.</target>
        </trans-unit>
        <trans-unit id="eedf68c3267fbf09aabeff8e3149a2fc6e02e4a5" translate="yes" xml:space="preserve">
          <source>When the system is forced to combine multiple page-level predicate locks into a single relation-level predicate lock because the predicate lock table is short of memory, an increase in the rate of serialization failures may occur. You can avoid this by increasing &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt;, &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-RELATION&quot;&gt;max_pred_locks_per_relation&lt;/a&gt;, and/or &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-PAGE&quot;&gt;max_pred_locks_per_page&lt;/a&gt;.</source>
          <target state="translated">Когда система вынуждена объединить несколько блокировок предикатов на уровне страниц в одну блокировку предикатов на уровне отношений из-за нехватки памяти в таблице блокировок предикатов, может произойти увеличение частоты сбоев сериализации. Вы можете избежать этого, увеличив &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt; , &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-RELATION&quot;&gt;max_pred_locks_per_relation&lt;/a&gt; и / или &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-PAGE&quot;&gt;max_pred_locks_per_page&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e5d69b735badff5a43514c3f20c29f9fa27a5a4" translate="yes" xml:space="preserve">
          <source>When the target server is started for the first time after running pg_rewind, it will go into recovery mode and replay all WAL generated in the source server after the point of divergence. If some of the WAL was no longer available in the source server when pg_rewind was run, and therefore could not be copied by the pg_rewind session, it must be made available when the target server is started. This can be done by creating a &lt;code&gt;recovery.signal&lt;/code&gt; file in the target data directory and configuring suitable &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">Когда целевой сервер запускается в первый раз после запуска pg_rewind, он переходит в режим восстановления и воспроизводит весь WAL, сгенерированный на исходном сервере после точки расхождения. Если часть WAL больше не была доступна на исходном сервере при запуске pg_rewind и, следовательно, не могла быть скопирована сеансом pg_rewind, она должна быть доступна при запуске целевого сервера. Это можно сделать, создав файл &lt;code&gt;recovery.signal&lt;/code&gt; в целевом каталоге данных и настроив подходящую &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;команду restore_command&lt;/a&gt; в &lt;code&gt;postgresql.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46d8ca3256e28b3a76b80a636c768a65a62af8f1" translate="yes" xml:space="preserve">
          <source>When the token is a number or number field:</source>
          <target state="translated">Когда маркер является числовым или числовым полем:</target>
        </trans-unit>
        <trans-unit id="13de437cb552624377cc1efe8012608874203a3b" translate="yes" xml:space="preserve">
          <source>When there are &lt;code&gt;OUT&lt;/code&gt; or &lt;code&gt;INOUT&lt;/code&gt; parameters, the &lt;code&gt;RETURNS&lt;/code&gt; clause can be omitted. If present, it must agree with the result type implied by the output parameters: &lt;code&gt;RECORD&lt;/code&gt; if there are multiple output parameters, or the same type as the single output parameter.</source>
          <target state="translated">Если есть параметры &lt;code&gt;OUT&lt;/code&gt; или &lt;code&gt;INOUT&lt;/code&gt; , предложение &lt;code&gt;RETURNS&lt;/code&gt; можно опустить. Если он присутствует, он должен соответствовать типу результата, подразумеваемому выходными параметрами: &lt;code&gt;RECORD&lt;/code&gt; если имеется несколько выходных параметров, или того же типа, что и единственный выходной параметр.</target>
        </trans-unit>
        <trans-unit id="3cbc021b4d99bd0fb8948c27e6c55ec68fedb0d0" translate="yes" xml:space="preserve">
          <source>When there are multiple queries in the &lt;code&gt;WITH&lt;/code&gt; clause, &lt;code&gt;RECURSIVE&lt;/code&gt; should be written only once, immediately after &lt;code&gt;WITH&lt;/code&gt;. It applies to all queries in the &lt;code&gt;WITH&lt;/code&gt; clause, though it has no effect on queries that do not use recursion or forward references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="086da7e4c8252cf99eea2a26d212bfca20a89638" translate="yes" xml:space="preserve">
          <source>When there are no &lt;code&gt;GIN_MAYBE&lt;/code&gt; values in the &lt;code&gt;check&lt;/code&gt; vector, a &lt;code&gt;GIN_MAYBE&lt;/code&gt; return value is the equivalent of setting the &lt;code&gt;recheck&lt;/code&gt; flag in the Boolean &lt;code&gt;consistent&lt;/code&gt; function.</source>
          <target state="translated">Когда нет &lt;code&gt;GIN_MAYBE&lt;/code&gt; значения в &lt;code&gt;check&lt;/code&gt; векторе, &lt;code&gt;GIN_MAYBE&lt;/code&gt; возвращаемого значением является эквивалентом установки &lt;code&gt;recheck&lt;/code&gt; флаг в булевой &lt;code&gt;consistent&lt;/code&gt; функции.</target>
        </trans-unit>
        <trans-unit id="6d0ae32f2046467b15848b335dcbaffbcaf195f8" translate="yes" xml:space="preserve">
          <source>When this command is used, the preceding SQL query is expected to return one row, the columns of which are stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided.</source>
          <target state="translated">При использовании этой команды ожидается, что предыдущий запрос SQL вернет одну строку, столбцы которой хранятся в переменных, названных по именам столбцов, с &lt;code&gt;prefix&lt;/code&gt; если он предоставлен.</target>
        </trans-unit>
        <trans-unit id="d01a63b618f24f934c421a450096ebe3b2d3fb7a" translate="yes" xml:space="preserve">
          <source>When this feature is enabled, freed space at the end of a relation cannot be released to the operating system, since that could remove information needed to detect the &amp;ldquo;snapshot too old&amp;rdquo; condition. All space allocated to a relation remains associated with that relation for reuse only within that relation unless explicitly freed (for example, with &lt;code&gt;VACUUM FULL&lt;/code&gt;).</source>
          <target state="translated">Когда эта функция включена, освобожденное пространство в конце отношения не может быть передано операционной системе, поскольку это может удалить информацию, необходимую для обнаружения состояния &amp;laquo;слишком старый моментальный снимок&amp;raquo;. Все пространство, выделенное для отношения, остается связанным с этим отношением для повторного использования только внутри этого отношения, если оно явно не освобождено (например, с помощью &lt;code&gt;VACUUM FULL&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="edeb5910da7722ed71fd344bba96eef32a3f6641" translate="yes" xml:space="preserve">
          <source>When this happens, the range will be summarized normally during the next regular vacuum of the table.</source>
          <target state="translated">Когда это произойдет,диапазон будет нормально суммирован во время следующего регулярного вакуума стола.</target>
        </trans-unit>
        <trans-unit id="e4570af0f67cc29537d90c659afba5db93e8b7f0" translate="yes" xml:space="preserve">
          <source>When this is enabled, the backup will start by enumerating the size of the entire database, and then go back and send the actual contents. This may make the backup take slightly longer, and in particular it will take longer before the first data is sent.</source>
          <target state="translated">Когда эта функция включена,резервное копирование начнется с перечисления размера всей базы данных,а затем вернется назад и отправит действительное содержимое.Это может привести к тому,что резервное копирование займет немного больше времени,в частности,до отправки первых данных.</target>
        </trans-unit>
        <trans-unit id="ba484c59ded97840ba63ed48a33d5adcad782f3b" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index build locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;Building Indexes Concurrently&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c1776ab93887297f059584c258d507675ecdfe" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index build locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;Building Indexes Concurrently&lt;/a&gt;.</source>
          <target state="translated">Когда используется эта опция, PostgreSQL будет строить индекс без каких-либо блокировок, предотвращающих одновременные вставки, обновления или удаления в таблице; тогда как стандартное построение индекса блокирует записи (но не чтение) в таблице, пока это не будет выполнено. При использовании этой опции следует помнить о нескольких предостережениях - см. &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;Построение индексов одновременно&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9cfbc756ec0e3884dc8a6bdc957bf776447f05d6" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will rebuild the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index rebuild locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;Rebuilding Indexes Concurrently&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469c5b3c25ebc28298d0a68f767fa4e6b9232f83" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will rebuild the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index rebuild locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;Rebuilding Indexes Concurrently&lt;/a&gt;.</source>
          <target state="translated">Когда используется эта опция, PostgreSQL перестроит индекс без каких-либо блокировок, которые предотвращают одновременные вставки, обновления или удаления в таблице; тогда как стандартное перестроение индекса блокирует запись (но не чтение) таблицы, пока это не будет выполнено. При использовании этой опции следует помнить о нескольких предостережениях - см. &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;Перестройка индексов одновременно&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c3757e4ca86742c07911d6404be9ee33ce2c815" translate="yes" xml:space="preserve">
          <source>When this option is used, psql will connect to the database &lt;code&gt;postgres&lt;/code&gt;, unless a different database is named on the command line (option &lt;code&gt;-d&lt;/code&gt; or non-option argument, possibly via a service entry, but not via an environment variable).</source>
          <target state="translated">Когда используется этот параметр, psql будет подключаться к базе данных &lt;code&gt;postgres&lt;/code&gt; , если в командной строке не &lt;code&gt;-d&lt;/code&gt; другая база данных (параметр -d или аргумент без параметра, возможно, через запись службы, но не через переменную среды).</target>
        </trans-unit>
        <trans-unit id="2bc222201723d0a9f83d166df5e42c7cf99836b6" translate="yes" xml:space="preserve">
          <source>When this option is used, the database named with &lt;code&gt;-d&lt;/code&gt; is used only to issue the initial &lt;code&gt;DROP DATABASE&lt;/code&gt; and &lt;code&gt;CREATE DATABASE&lt;/code&gt; commands. All data is restored into the database name that appears in the archive.</source>
          <target state="translated">Когда используется эта опция, база данных с именем &lt;code&gt;-d&lt;/code&gt; используется только для выполнения начальных команд &lt;code&gt;DROP DATABASE&lt;/code&gt; и &lt;code&gt;CREATE DATABASE&lt;/code&gt; . Все данные восстанавливаются в имя базы данных, которое появляется в архиве.</target>
        </trans-unit>
        <trans-unit id="3390cee1b88ac1d254da2a22a816a53421d2e870" translate="yes" xml:space="preserve">
          <source>When this parameter allows it for a particular table, the planner compares query conditions with the table's &lt;code&gt;CHECK&lt;/code&gt; constraints, and omits scanning tables for which the conditions contradict the constraints. For example:</source>
          <target state="translated">Когда этот параметр разрешает это для конкретной таблицы, планировщик сравнивает условия запроса с ограничениями &lt;code&gt;CHECK&lt;/code&gt; таблицы и пропускает сканирование таблиц, для которых условия противоречат ограничениям. Например:</target>
        </trans-unit>
        <trans-unit id="70be33b4f92d88452bcc535d531cf8223b72afbc" translate="yes" xml:space="preserve">
          <source>When this parameter is &lt;code&gt;on&lt;/code&gt;, the PostgreSQL server compresses a full page image written to WAL when &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is on or during a base backup. A compressed page image will be decompressed during WAL replay. The default value is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">Когда этот параметр &lt;code&gt;on&lt;/code&gt; сервере PostgreSQL сжимает полную страницу изображения записывается в WAL , когда &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; находится на или во время базовой резервной копии. Сжатое изображение страницы будет распаковано во время воспроизведения WAL. Значение по умолчанию &lt;code&gt;off&lt;/code&gt; . Только суперпользователи могут изменять этот параметр.</target>
        </trans-unit>
        <trans-unit id="095a2e6ccc43e3049250993f0343788b4a6a861a" translate="yes" xml:space="preserve">
          <source>When this parameter is &lt;code&gt;on&lt;/code&gt;, the PostgreSQL server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint, even for non-critical modifications of so-called hint bits.</source>
          <target state="translated">Когда этот параметр &lt;code&gt;on&lt;/code&gt; сервере PostgreSQL записывает все содержимое каждого диска страницы в WAL во время первой модификации этой страницы после контрольной точки, даже для некритичных модификаций так называемых бит подсказок.</target>
        </trans-unit>
        <trans-unit id="ff47b09b0654ad59cedec7d15e17e9fba55f3e2b" translate="yes" xml:space="preserve">
          <source>When this parameter is on, &lt;code&gt;sepgsql&lt;/code&gt; functions in permissive mode, even if SELinux in general is working in enforcing mode. This parameter is primarily useful for testing purposes.</source>
          <target state="translated">Когда этот параметр &lt;code&gt;sepgsql&lt;/code&gt; , sepgsql работает в разрешающем режиме, даже если SELinux в целом работает в принудительном режиме. Этот параметр в первую очередь полезен для целей тестирования.</target>
        </trans-unit>
        <trans-unit id="b664e492ac1b6b5bd7bf06b57282c7f341a60102" translate="yes" xml:space="preserve">
          <source>When this parameter is on, per-plan-node timing occurs for all statements executed, whether or not they run long enough to actually get logged. This can have an extremely negative impact on performance. Turning off &lt;code&gt;auto_explain.log_timing&lt;/code&gt; ameliorates the performance cost, at the price of obtaining less information.</source>
          <target state="translated">Когда этот параметр включен, синхронизация для каждого узла плана выполняется для всех выполняемых операторов, независимо от того, выполняются ли они достаточно долго, чтобы фактически войти в журнал. Это может оказать крайне негативное влияние на производительность. Отключение &lt;code&gt;auto_explain.log_timing&lt;/code&gt; снижает затраты на производительность за счет получения меньшего количества информации.</target>
        </trans-unit>
        <trans-unit id="d4e134d46721d701b088fe76d2d53da371f96514" translate="yes" xml:space="preserve">
          <source>When this parameter is on, the PostgreSQL server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint. This is needed because a page write that is in process during an operating system crash might be only partially completed, leading to an on-disk page that contains a mix of old and new data. The row-level change data normally stored in WAL will not be enough to completely restore such a page during post-crash recovery. Storing the full page image guarantees that the page can be correctly restored, but at the price of increasing the amount of data that must be written to WAL. (Because WAL replay always starts from a checkpoint, it is sufficient to do this during the first change of each page after a checkpoint. Therefore, one way to reduce the cost of full-page writes is to increase the checkpoint interval parameters.)</source>
          <target state="translated">Когда этот параметр включен,PostgreSQL-сервер записывает все содержимое каждой страницы диска в WAL во время первой модификации этой страницы после контрольной точки.Это необходимо,потому что запись страницы,которая происходит во время сбоя операционной системы,может быть выполнена только частично,что приведет к появлению страницы на диске,содержащей смесь старых и новых данных.Обычно данных об изменении на уровне строк,хранящихся в WAL,будет недостаточно для полного восстановления такой страницы во время восстановления после сбоя.Хранение полного образа страницы гарантирует,что страница может быть правильно восстановлена,но за счет увеличения объема данных,которые должны быть записаны в WAL.(Поскольку воспроизведение WAL всегда начинается с контрольно-пропускного пункта,этого достаточно при первом изменении каждой страницы после контрольно-пропускного пункта.Следовательно,одним из способов снижения стоимости записи полной страницы является увеличение параметров интервала между контрольно-пропускными пунктами).</target>
        </trans-unit>
        <trans-unit id="5a1902b314fccc53fa419bb9d1c5d0a54674b4cd" translate="yes" xml:space="preserve">
          <source>When this variable is set to &lt;code&gt;on&lt;/code&gt; and a backslash command queries the database, the query is first shown. This feature helps you to study PostgreSQL internals and provide similar functionality in your own programs. (To select this behavior on program start-up, use the switch &lt;code&gt;-E&lt;/code&gt;.) If you set this variable to the value &lt;code&gt;noexec&lt;/code&gt;, the queries are just shown but are not actually sent to the server and executed. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">Когда для этой переменной установлено значение &lt;code&gt;on&lt;/code&gt; и команда с обратной косой чертой запрашивает базу данных, запрос отображается первым. Эта функция помогает вам изучить внутреннее устройство PostgreSQL и обеспечить аналогичные функции в ваших собственных программах. (Чтобы выбрать это поведение при запуске программы, используйте переключатель &lt;code&gt;-E&lt;/code&gt; .) Если вы установите для этой переменной значение &lt;code&gt;noexec&lt;/code&gt; , запросы просто отображаются, но фактически не отправляются на сервер и не выполняются. Значение по умолчанию &lt;code&gt;off&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a31ece5bfbb183043ca04edf566185c4d24f24d" translate="yes" xml:space="preserve">
          <source>When throttling is active, the transaction latency reported at the end of the run is calculated from the scheduled start times, so it includes the time each transaction had to wait for the previous transaction to finish. The wait time is called the schedule lag time, and its average and maximum are also reported separately. The transaction latency with respect to the actual transaction start time, i.e. the time spent executing the transaction in the database, can be computed by subtracting the schedule lag time from the reported latency.</source>
          <target state="translated">Когда дросселирование активно,задержка транзакций,сообщаемая в конце выполнения,рассчитывается из запланированного времени начала,поэтому она включает время,в течение которого каждой транзакции пришлось ждать завершения предыдущей транзакции.Время ожидания называется временем задержки по расписанию,и его среднее и максимальное значение также сообщается отдельно.Задержку транзакции относительно фактического времени начала транзакции,т.е.времени,затраченного на выполнение транзакции в БД,можно рассчитать путем вычитания времени запаздывания по расписанию из указанного в отчете времени запаздывания.</target>
        </trans-unit>
        <trans-unit id="bf9d744865a36adaaaa98eb0ce0a8d0e8d495ea9" translate="yes" xml:space="preserve">
          <source>When throttling is active, the transaction latency reported at the end of the run is calculated from the scheduled start times, so it includes the time each transaction had to wait for the previous transaction to finish. The wait time is called the schedule lag time, and its average and maximum are also reported separately. The transaction latency with respect to the actual transaction start time, i.e., the time spent executing the transaction in the database, can be computed by subtracting the schedule lag time from the reported latency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a5ce62fea33e48d7ca4dcdb6fc1d49b58833f9" translate="yes" xml:space="preserve">
          <source>When throttling is used (&lt;code&gt;--rate=...&lt;/code&gt;), transactions that lag behind schedule by more than &lt;code&gt;limit&lt;/code&gt; ms, and thus have no hope of meeting the latency limit, are not sent to the server at all. They are counted and reported separately as &lt;em&gt;skipped&lt;/em&gt;.</source>
          <target state="translated">Когда используется дросселирование ( &lt;code&gt;--rate=...&lt;/code&gt; ), транзакции, которые отстают от расписания более чем на &lt;code&gt;limit&lt;/code&gt; миллисекунд и, таким образом, не имеют надежды на соблюдение лимита задержки, вообще не отправляются на сервер. Они подсчитываются и сообщаются отдельно как &lt;em&gt;пропущенные&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b0431d629c5fa2195a09522dc9eddb52b7d7ef5d" translate="yes" xml:space="preserve">
          <source>When to JIT?</source>
          <target state="translated">Когда в JIT?</target>
        </trans-unit>
        <trans-unit id="c212a8c30b6a166bd84fdfc048fb956853e7ba65" translate="yes" xml:space="preserve">
          <source>When two arrays with an equal number of dimensions are concatenated, the result retains the lower bound subscript of the left-hand operand's outer dimension. The result is an array comprising every element of the left-hand operand followed by every element of the right-hand operand. For example:</source>
          <target state="translated">Когда два массива с одинаковым количеством размеров соединены,результат сохраняет нижний индекс внешнего измерения левого операндов.В результате получается массив,состоящий из каждого элемента левого операнда,за которым следует каждый элемент правого операнда.Например:</target>
        </trans-unit>
        <trans-unit id="75c057cb6b39ec5ed6fcfc1f9fbef6e3ffe333d8" translate="yes" xml:space="preserve">
          <source>When two or more &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;databases&lt;/a&gt; are linked via &lt;a href=&quot;glossary#GLOSSARY-REPLICATION&quot;&gt;replication&lt;/a&gt;, the &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; that is considered the authoritative source of information is called the &lt;em&gt;primary&lt;/em&gt;, also known as a &lt;em&gt;master&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09c4eb9b4b598594720766db600d02893739065" translate="yes" xml:space="preserve">
          <source>When used as a standalone program all WAL files logically preceding the &lt;code&gt;oldestkeptwalfile&lt;/code&gt; will be removed from &lt;code&gt;archivelocation&lt;/code&gt;. In this mode, if you specify a &lt;code&gt;.partial&lt;/code&gt; or &lt;code&gt;.backup&lt;/code&gt; file name, then only the file prefix will be used as the &lt;code&gt;oldestkeptwalfile&lt;/code&gt;. This treatment of &lt;code&gt;.backup&lt;/code&gt; file name allows you to remove all WAL files archived prior to a specific base backup without error. For example, the following example will remove all files older than WAL file name &lt;code&gt;000000010000003700000010&lt;/code&gt;:</source>
          <target state="translated">При использовании в качестве отдельной программы все файлы WAL, логически предшествующие &lt;code&gt;oldestkeptwalfile&lt;/code&gt; будут удалены из &lt;code&gt;archivelocation&lt;/code&gt; . В этом режиме, если вы укажете &lt;code&gt;.partial&lt;/code&gt; файла .partial или &lt;code&gt;.backup&lt;/code&gt; , то только префикс файла будет использоваться в качестве самого &lt;code&gt;oldestkeptwalfile&lt;/code&gt; . Такая обработка &lt;code&gt;.backup&lt;/code&gt; файла .backup позволяет без ошибок удалить все файлы WAL, заархивированные до создания конкретной базовой резервной копии. Например, в следующем примере будут удалены все файлы старше имени файла WAL &lt;code&gt;000000010000003700000010&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="54ce62d903f7c6555c73f41594c6b595d712ec4b" translate="yes" xml:space="preserve">
          <source>When used in exclusive mode, this function writes a backup label file (&lt;code&gt;backup_label&lt;/code&gt;) and, if there are any links in the &lt;code&gt;pg_tblspc/&lt;/code&gt; directory, a tablespace map file (&lt;code&gt;tablespace_map&lt;/code&gt;) into the database cluster's data directory, then performs a checkpoint, and then returns the backup's starting write-ahead log location. (The user can ignore this result value, but it is provided in case it is useful.) When used in non-exclusive mode, the contents of these files are instead returned by the &lt;code&gt;pg_stop_backup&lt;/code&gt; function, and should be copied to the backup area by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f92bbabc1b26d77780494bcd623901f19d77be" translate="yes" xml:space="preserve">
          <source>When used with one of the archive file formats and combined with pg_restore, pg_dump provides a flexible archival and transfer mechanism. pg_dump can be used to backup an entire database, then pg_restore can be used to examine the archive and/or select which parts of the database are to be restored. The most flexible output file formats are the &amp;ldquo;custom&amp;rdquo; format (&lt;code&gt;-Fc&lt;/code&gt;) and the &amp;ldquo;directory&amp;rdquo; format (&lt;code&gt;-Fd&lt;/code&gt;). They allow for selection and reordering of all archived items, support parallel restoration, and are compressed by default. The &amp;ldquo;directory&amp;rdquo; format is the only format that supports parallel dumps.</source>
          <target state="translated">При использовании с одним из форматов архивных файлов и в сочетании с pg_restore, pg_dump обеспечивает гибкий механизм архивирования и передачи. pg_dump можно использовать для резервного копирования всей базы данных, затем pg_restore можно использовать для проверки архива и / или выбора частей базы данных для восстановления. Наиболее гибкими форматами выходных файлов являются &amp;laquo;пользовательский&amp;raquo; формат ( &lt;code&gt;-Fc&lt;/code&gt; ) и формат &amp;laquo;каталог&amp;raquo; ( &lt;code&gt;-Fd&lt;/code&gt; ). Они позволяют выбирать и переупорядочивать все заархивированные элементы, поддерживают параллельное восстановление и по умолчанию сжимаются. Формат &amp;laquo;каталога&amp;raquo; - единственный формат, поддерживающий параллельные дампы.</target>
        </trans-unit>
        <trans-unit id="7fe14a6b317961785cf4d152bc27d49064bcda5a" translate="yes" xml:space="preserve">
          <source>When used within &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt;, all WAL files logically preceding the value of the &lt;code&gt;%r&lt;/code&gt; argument will be removed from &lt;code&gt;archivelocation&lt;/code&gt;. This minimizes the number of files that need to be retained, while preserving crash-restart capability. Use of this parameter is appropriate if the &lt;code&gt;archivelocation&lt;/code&gt; is a transient staging area for this particular standby server, but &lt;em&gt;not&lt;/em&gt; when the &lt;code&gt;archivelocation&lt;/code&gt; is intended as a long-term WAL archive area, or when multiple standby servers are recovering from the same archive location.</source>
          <target state="translated">При использовании в &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt; все файлы WAL, логически предшествующие значению аргумента &lt;code&gt;%r&lt;/code&gt; будут удалены из &lt;code&gt;archivelocation&lt;/code&gt; . Это сводит к минимуму количество файлов, которые необходимо сохранить, сохраняя при этом возможность аварийного перезапуска. Использование этого параметра уместно, если расположение &lt;code&gt;archivelocation&lt;/code&gt; является временной промежуточной областью для этого конкретного резервного сервера, но &lt;em&gt;не&lt;/em&gt; тогда, когда расположение &lt;code&gt;archivelocation&lt;/code&gt; предназначено как долговременная область архива WAL, или когда несколько резервных серверов восстанавливаются из одного и того же расположения архива.</target>
        </trans-unit>
        <trans-unit id="7051b09dcb61945ea4e0d3beb1e52e65c9014732" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;COPY FROM&lt;/code&gt;, any data item that matches this string will be stored as a null value, so you should make sure that you use the same string as you used with &lt;code&gt;COPY TO&lt;/code&gt;.</source>
          <target state="translated">При использовании &lt;code&gt;COPY FROM&lt;/code&gt; любой элемент данных, соответствующий этой строке, будет сохранен как нулевое значение, поэтому вы должны убедиться, что вы используете ту же строку, что и при &lt;code&gt;COPY TO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8b5d7a27b46e73dc32c1b851c7dfef0ad7fe8a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;LIMIT&lt;/code&gt;, it is a good idea to use an &lt;code&gt;ORDER BY&lt;/code&gt; clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows &amp;mdash; you might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don't know what ordering unless you specify &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">При использовании &lt;code&gt;LIMIT&lt;/code&gt; рекомендуется использовать предложение &lt;code&gt;ORDER BY&lt;/code&gt; , которое ограничивает строки результатов в уникальном порядке. В противном случае вы получите непредсказуемое подмножество строк запроса - вы можете запрашивать строки с десятой по двадцатую, но с десятой по двадцатую в каком порядке? Вы не знаете, какой порядок, если не укажете &lt;code&gt;ORDER BY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="481c23a58e8db851baee87afbfd06f8aa525bda9" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;LIMIT&lt;/code&gt;, it is important to use an &lt;code&gt;ORDER BY&lt;/code&gt; clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows. You might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? The ordering is unknown, unless you specified &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">При использовании &lt;code&gt;LIMIT&lt;/code&gt; важно использовать предложение &lt;code&gt;ORDER BY&lt;/code&gt; , которое ограничивает строки результатов в уникальном порядке. В противном случае вы получите непредсказуемое подмножество строк запроса. Возможно, вы просите строки с десятого по двадцатый, но в каком порядке? Порядок неизвестен, если вы не указали &lt;code&gt;ORDER BY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f85dc3be9cb7f009d076c5eedd8386addcb8b584" translate="yes" xml:space="preserve">
          <source>When using Kerberos authentication, SSPI works the same way GSSAPI does; see &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt; for details.</source>
          <target state="translated">При использовании аутентификации Kerberos SSPI работает так же, как GSSAPI; подробности см. в &lt;a href=&quot;gssapi-auth&quot;&gt;Разделе 20.6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc80b0e9ed4294e8911057b0a0a50261a196de62" translate="yes" xml:space="preserve">
          <source>When using POSIX semaphores, the number of semaphores needed is the same as for System V, that is one semaphore per allowed connection (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), allowed autovacuum worker process (&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;) and allowed background process (&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;). On the platforms where this option is preferred, there is no specific kernel limit on the number of POSIX semaphores.</source>
          <target state="translated">При использовании семафоров POSIX количество необходимых семафоров такое же, как в System V, то есть один семафор на разрешенное соединение ( &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; ), разрешенный рабочий процесс &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;автоочистки&lt;/a&gt; ( autovacuum_max_workers ) и разрешенный фоновый процесс ( &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt; ). На платформах, где этот параметр является предпочтительным, нет определенного ограничения ядра на количество семафоров POSIX.</target>
        </trans-unit>
        <trans-unit id="8579cb5fcd4b92d72b4fadb397cff9f7dbbdad05" translate="yes" xml:space="preserve">
          <source>When using RADIUS authentication, an Access Request message will be sent to the configured RADIUS server. This request will be of type &lt;code&gt;Authenticate Only&lt;/code&gt;, and include parameters for &lt;code&gt;user name&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt; (encrypted) and &lt;code&gt;NAS Identifier&lt;/code&gt;. The request will be encrypted using a secret shared with the server. The RADIUS server will respond to this request with either &lt;code&gt;Access Accept&lt;/code&gt; or &lt;code&gt;Access Reject&lt;/code&gt;. There is no support for RADIUS accounting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d87a93d2de1be22dab32dcbbc5446297da3c6d5" translate="yes" xml:space="preserve">
          <source>When using RADIUS authentication, an Access Request message will be sent to the configured RADIUS server. This request will be of type &lt;code&gt;Authenticate Only&lt;/code&gt;, and include parameters for &lt;code&gt;user name&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt; (encrypted) and &lt;code&gt;NAS Identifier&lt;/code&gt;. The request will be encrypted using a secret shared with the server. The RADIUS server will respond to this server with either &lt;code&gt;Access Accept&lt;/code&gt; or &lt;code&gt;Access Reject&lt;/code&gt;. There is no support for RADIUS accounting.</source>
          <target state="translated">При использовании аутентификации RADIUS на настроенный сервер RADIUS будет отправлено сообщение запроса доступа. Этот запрос будет иметь тип &lt;code&gt;Authenticate Only&lt;/code&gt; и включать параметры для &lt;code&gt;user name&lt;/code&gt; , &lt;code&gt;password&lt;/code&gt; (зашифрованный) и &lt;code&gt;NAS Identifier&lt;/code&gt; . Запрос будет зашифрован с использованием секрета, предоставленного серверу. Сервер RADIUS ответит этому серверу либо &lt;code&gt;Access Accept&lt;/code&gt; либо &lt;code&gt;Access Reject&lt;/code&gt; . Нет поддержки для учета RADIUS.</target>
        </trans-unit>
        <trans-unit id="df1ce6f4ba5a71b98d3f24da1f9c50898361216d" translate="yes" xml:space="preserve">
          <source>When using System V semaphores, PostgreSQL uses one semaphore per allowed connection (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), allowed autovacuum worker process (&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;) and allowed background process (&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;), in sets of 16. Each such set will also contain a 17th semaphore which contains a &amp;ldquo;magic number&amp;rdquo;, to detect collision with semaphore sets used by other applications. The maximum number of semaphores in the system is set by &lt;code&gt;SEMMNS&lt;/code&gt;, which consequently must be at least as high as &lt;code&gt;max_connections&lt;/code&gt; plus &lt;code&gt;autovacuum_max_workers&lt;/code&gt; plus &lt;code&gt;max_wal_senders&lt;/code&gt;, plus &lt;code&gt;max_worker_processes&lt;/code&gt;, plus one extra for each 16 allowed connections plus workers (see the formula in &lt;a href=&quot;kernel-resources#SYSVIPC-PARAMETERS&quot;&gt;Table 18.1&lt;/a&gt;). The parameter &lt;code&gt;SEMMNI&lt;/code&gt; determines the limit on the number of semaphore sets that can exist on the system at one time. Hence this parameter must be at least &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt;. Lowering the number of allowed connections is a temporary workaround for failures, which are usually confusingly worded &amp;ldquo;No space left on device&amp;rdquo;, from the function &lt;code&gt;semget&lt;/code&gt;.</source>
          <target state="translated">При использовании семафоров System V PostgreSQL использует один семафор на каждое разрешенное соединение ( &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; ), разрешенный рабочий процесс &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;автоочистки&lt;/a&gt; ( autovacuum_max_workers ) и разрешенный фоновый процесс ( &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt; ) в наборах по 16. Каждый такой набор также будет содержать 17-й семафор, который содержит &amp;ldquo; магическое число &amp;raquo;для обнаружения коллизии с наборами семафоров, используемыми другими приложениями. Максимальное количество семафоров в системе устанавливается &lt;code&gt;SEMMNS&lt;/code&gt; , которое, следовательно, должно быть не ниже &lt;code&gt;max_connections&lt;/code&gt; плюс &lt;code&gt;autovacuum_max_workers&lt;/code&gt; плюс &lt;code&gt;max_wal_senders&lt;/code&gt; , плюс &lt;code&gt;max_worker_processes&lt;/code&gt; , плюс одно дополнительное на каждые 16 разрешенных подключений плюс рабочие (см. формулу в &lt;a href=&quot;kernel-resources#SYSVIPC-PARAMETERS&quot;&gt;таблице 18.1&lt;/a&gt; ). Параметр &lt;code&gt;SEMMNI&lt;/code&gt; определяет ограничение на количество наборов семафоров, которые могут существовать в системе одновременно. Следовательно, этот параметр должен быть не меньше &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt; . Уменьшение количества разрешенных подключений - это временный обходной путь для сбоев, которые обычно сбивают с толку: &amp;laquo;На устройстве не осталось места&amp;raquo; из функции &lt;code&gt;semget&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8382eef968bcd1841af0a45f03df20722ebed18" translate="yes" xml:space="preserve">
          <source>When using a replication setup with tools which perform direct copies of relation file blocks (for example &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt;), enabling or disabling checksums can lead to page corruptions in the shape of incorrect checksums if the operation is not done consistently across all nodes. When enabling or disabling checksums in a replication setup, it is thus recommended to stop all the clusters before switching them all consistently. Destroying all standbys, performing the operation on the primary and finally recreating the standbys from scratch is also safe.</source>
          <target state="translated">При использовании настройки репликации с инструментами, которые выполняют прямые копии блоков файлов отношений (например, &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt; ), включение или отключение контрольных сумм может привести к повреждению страницы в виде неправильных контрольных сумм, если операция не выполняется последовательно на всех узлах. Таким образом, при включении или отключении контрольных сумм в настройке репликации рекомендуется остановить все кластеры перед их последовательным переключением. Уничтожение всех резервных, выполнение операции на основном и, наконец, воссоздание резервных с нуля также безопасно.</target>
        </trans-unit>
        <trans-unit id="eac93956f94fd1f4ae45bb87df2631e194bcbe28" translate="yes" xml:space="preserve">
          <source>When using a separate column to store the &lt;code&gt;tsvector&lt;/code&gt; representation of your documents, it is necessary to create a trigger to update the &lt;code&gt;tsvector&lt;/code&gt; column when the document content columns change. Two built-in trigger functions are available for this, or you can write your own.</source>
          <target state="translated">При использовании отдельного столбца для хранения представления ваших документов в &lt;code&gt;tsvector&lt;/code&gt; необходимо создать триггер для обновления столбца &lt;code&gt;tsvector&lt;/code&gt; при изменении столбцов содержимого документа. Для этого доступны две встроенные триггерные функции, или вы можете написать свою собственную.</target>
        </trans-unit>
        <trans-unit id="9150f1a85447666f80a11e9912230df80685449c" translate="yes" xml:space="preserve">
          <source>When using an &lt;code&gt;archive_command&lt;/code&gt; script, it's desirable to enable &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt;. Any messages written to stderr from the script will then appear in the database server log, allowing complex configurations to be diagnosed easily if they fail.</source>
          <target state="translated">При использовании сценария &lt;code&gt;archive_command&lt;/code&gt; желательно включить &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt; . Любые сообщения, записанные в stderr из сценария, затем появятся в журнале сервера базы данных, что позволит легко диагностировать сложные конфигурации в случае их сбоя.</target>
        </trans-unit>
        <trans-unit id="953b500ebbfdd4983d6d154f36b232db63c79506" translate="yes" xml:space="preserve">
          <source>When using an external authentication system such as Ident or GSSAPI, the name of the operating system user that initiated the connection might not be the same as the database user (role) that is to be used. In this case, a user name map can be applied to map the operating system user name to a database user. To use user name mapping, specify &lt;code&gt;map&lt;/code&gt;=&lt;code&gt;map-name&lt;/code&gt; in the options field in &lt;code&gt;pg_hba.conf&lt;/code&gt;. This option is supported for all authentication methods that receive external user names. Since different mappings might be needed for different connections, the name of the map to be used is specified in the &lt;code&gt;map-name&lt;/code&gt; parameter in &lt;code&gt;pg_hba.conf&lt;/code&gt; to indicate which map to use for each individual connection.</source>
          <target state="translated">При использовании внешней системы аутентификации, такой как Ident или GSSAPI, имя пользователя операционной системы, инициировавшего соединение, может не совпадать с именем пользователя (роли) базы данных, который будет использоваться. В этом случае можно применить карту имен пользователей для сопоставления имени пользователя операционной системы с пользователем базы данных. Чтобы использовать сопоставление имен пользователей, укажите &lt;code&gt;map&lt;/code&gt; = &lt;code&gt;map-name&lt;/code&gt; в поле параметров в &lt;code&gt;pg_hba.conf&lt;/code&gt; . Эта опция поддерживается для всех методов аутентификации, которые получают имена внешних пользователей. Поскольку для разных подключений могут потребоваться разные сопоставления, имя используемой карты указывается в параметре &lt;code&gt;map-name&lt;/code&gt; в &lt;code&gt;pg_hba.conf&lt;/code&gt; , чтобы указать, какую карту использовать для каждого отдельного подключения.</target>
        </trans-unit>
        <trans-unit id="492838d017254285805f7e847c1bb4763dffb265" translate="yes" xml:space="preserve">
          <source>When using binary mode to pass query parameters to the server and query results back to the client, no encoding conversion is performed, so the situation is different. In this case, an encoding declaration in the XML data will be observed, and if it is absent, the data will be assumed to be in UTF-8 (as required by the XML standard; note that PostgreSQL does not support UTF-16). On output, data will have an encoding declaration specifying the client encoding, unless the client encoding is UTF-8, in which case it will be omitted.</source>
          <target state="translated">При использовании бинарного режима для передачи параметров запроса к серверу и результатов запроса обратно клиенту,преобразование кодировки не выполняется,поэтому ситуация иная.В этом случае будет соблюдена декларация кодировки в данных XML,а если она отсутствует,то данные будут приняты в кодировке UTF-8 (как того требует стандарт XML;обратите внимание,что PostgreSQL не поддерживает UTF-16).На выходе данные будут иметь кодировочную декларацию с указанием клиентской кодировки,если только клиентская кодировка не в кодировке UTF-8,в этом случае она будет опущена.</target>
        </trans-unit>
        <trans-unit id="5c43830d30560b418ee227f739bdeb1afbb63531" translate="yes" xml:space="preserve">
          <source>When using collations provided by &lt;code&gt;libc&lt;/code&gt; and PostgreSQL was built with the GNU C library, the C library's version is used as a collation version. Since collation definitions typically change only with GNU C library releases, this provides some defense against corruption, but it is not completely reliable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56607247aff04e4e074b7797ef04095046172c94" translate="yes" xml:space="preserve">
          <source>When using collations provided by the ICU library, the ICU-specific version of the collator is recorded in the system catalog when the collation object is created. When the collation is used, the current version is checked against the recorded version, and a warning is issued when there is a mismatch, for example:</source>
          <target state="translated">При использовании коллизий,предоставляемых библиотекой ICU,при создании объекта коллизии в системном каталоге записывается версия коллектора,специфичная для ICU.При использовании коллизии текущая версия проверяется на соответствие записанной версии,и при наличии несовпадения,например,выдается предупреждение:</target>
        </trans-unit>
        <trans-unit id="de5896493e8d94d607ede6725d8b75b29f2f0f82" translate="yes" xml:space="preserve">
          <source>When using cost-based vacuuming, appropriate values for &lt;code&gt;vacuum_cost_delay&lt;/code&gt; are usually quite small, perhaps less than 1 millisecond. While &lt;code&gt;vacuum_cost_delay&lt;/code&gt; can be set to fractional-millisecond values, such delays may not be measured accurately on older platforms. On such platforms, increasing &lt;code&gt;VACUUM&lt;/code&gt;'s throttled resource consumption above what you get at 1ms will require changing the other vacuum cost parameters. You should, nonetheless, keep &lt;code&gt;vacuum_cost_delay&lt;/code&gt; as small as your platform will consistently measure; large delays are not helpful.</source>
          <target state="translated">При использовании вакуумирования на основе затрат подходящие значения для &lt;code&gt;vacuum_cost_delay&lt;/code&gt; обычно довольно малы, возможно, менее 1 миллисекунды. Хотя для &lt;code&gt;vacuum_cost_delay&lt;/code&gt; можно задать значения в долях миллисекунд, такие задержки могут быть неточно измерены на более старых платформах. На таких платформах увеличение &lt;code&gt;VACUUM&lt;/code&gt; потребления ресурсов VACUUM сверх того, что вы получаете на 1 мс, потребует изменения других параметров стоимости вакуума. Тем не менее, вы должны поддерживать &lt;code&gt;vacuum_cost_delay&lt;/code&gt; настолько малым, насколько ваша платформа будет постоянно измерять; большие задержки не помогают.</target>
        </trans-unit>
        <trans-unit id="75aee5f97d42018467b21311d706aa5a647707a9" translate="yes" xml:space="preserve">
          <source>When using exclusive backup mode, it is absolutely imperative to ensure that &lt;code&gt;pg_stop_backup&lt;/code&gt; completes successfully at the end of the backup. Even if the backup itself fails, for example due to lack of disk space, failure to call &lt;code&gt;pg_stop_backup&lt;/code&gt; will leave the server in backup mode indefinitely, causing future backups to fail and increasing the risk of a restart failure during the time that &lt;code&gt;backup_label&lt;/code&gt; exists.</source>
          <target state="translated">При использовании монопольного режима резервного копирования абсолютно необходимо убедиться, что &lt;code&gt;pg_stop_backup&lt;/code&gt; успешно завершится в конце резервного копирования. Даже если само резервное копирование не удается, например, из-за нехватки места на диске, отказ от вызова &lt;code&gt;pg_stop_backup&lt;/code&gt; оставит сервер в режиме резервного копирования на неопределенный срок, что приведет к сбою будущих резервных копий и увеличению риска сбоя перезапуска во время существования &lt;code&gt;backup_label&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec73be80732f41a040847bc00566e73f63c25a96" translate="yes" xml:space="preserve">
          <source>When using link mode, standby servers can be quickly upgraded using rsync. To accomplish this, from a directory on the primary server that is above the old and new database cluster directories, run this on the &lt;em&gt;primary&lt;/em&gt; for each standby server:</source>
          <target state="translated">При использовании режима связи резервные серверы можно быстро обновить с помощью rsync. Для этого из каталога на первичном сервере, который находится над старым и новым каталогами кластера баз данных, запустите это на &lt;em&gt;первичном&lt;/em&gt; сервере для каждого резервного сервера:</target>
        </trans-unit>
        <trans-unit id="7d1e98ef020032cfb9faf29c2d74acac7b1c192c" translate="yes" xml:space="preserve">
          <source>When using multiple &lt;code&gt;INSERT&lt;/code&gt;s, turn off autocommit and just do one commit at the end. (In plain SQL, this means issuing &lt;code&gt;BEGIN&lt;/code&gt; at the start and &lt;code&gt;COMMIT&lt;/code&gt; at the end. Some client libraries might do this behind your back, in which case you need to make sure the library does it when you want it done.) If you allow each insertion to be committed separately, PostgreSQL is doing a lot of work for each row that is added. An additional benefit of doing all insertions in one transaction is that if the insertion of one row were to fail then the insertion of all rows inserted up to that point would be rolled back, so you won't be stuck with partially loaded data.</source>
          <target state="translated">При использовании нескольких &lt;code&gt;INSERT&lt;/code&gt; отключите автоматическую фиксацию и просто сделайте одну фиксацию в конце. (В простом SQL это означает выполнение &lt;code&gt;BEGIN&lt;/code&gt; в начале и &lt;code&gt;COMMIT&lt;/code&gt; в конце. Некоторые клиентские библиотеки могут делать это за вашей спиной, и в этом случае вам нужно убедиться, что библиотека делает это, когда вы этого хотите.) Если вы разрешите каждая вставка фиксируется отдельно, PostgreSQL выполняет много работы для каждой добавляемой строки. Дополнительным преимуществом выполнения всех вставок в одной транзакции является то, что в случае сбоя вставки одной строки вставка всех строк, вставленных до этой точки, будет отменена, поэтому вы не застрянете с частично загруженными данными.</target>
        </trans-unit>
        <trans-unit id="8692847b55239c8542d72c31d947ca1f69e8f98c" translate="yes" xml:space="preserve">
          <source>When using pg_receivewal instead of &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; as the main WAL backup method, it is strongly recommended to use replication slots. Otherwise, the server is free to recycle or remove write-ahead log files before they are backed up, because it does not have any information, either from &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; or the replication slots, about how far the WAL stream has been archived. Note, however, that a replication slot will fill up the server's disk space if the receiver does not keep up with fetching the WAL data.</source>
          <target state="translated">При использовании pg_receivewal вместо &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; в качестве основного метода резервного копирования WAL настоятельно рекомендуется использовать слоты репликации. В противном случае сервер может переработать или удалить файлы журнала упреждающей записи перед их резервным копированием, поскольку он не имеет никакой информации ни из &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; , ни из слотов репликации, о том, как далеко был заархивирован поток WAL. Обратите внимание, однако, что слот репликации заполнит дисковое пространство сервера, если получатель не успевает за выборкой данных WAL.</target>
        </trans-unit>
        <trans-unit id="7805e078bb69ca14f943ca44e9ff4b57cc0c775e" translate="yes" xml:space="preserve">
          <source>When using search+bind mode, the search can be performed using a single attribute specified with &lt;code&gt;ldapsearchattribute&lt;/code&gt;, or using a custom search filter specified with &lt;code&gt;ldapsearchfilter&lt;/code&gt;. Specifying &lt;code&gt;ldapsearchattribute=foo&lt;/code&gt; is equivalent to specifying &lt;code&gt;ldapsearchfilter=&quot;(foo=$username)&quot;&lt;/code&gt;. If neither option is specified the default is &lt;code&gt;ldapsearchattribute=uid&lt;/code&gt;.</source>
          <target state="translated">При использовании режима поиска + привязки поиск может выполняться с использованием одного атрибута, указанного с помощью &lt;code&gt;ldapsearchattribute&lt;/code&gt; , или с использованием настраиваемого фильтра поиска, указанного с помощью &lt;code&gt;ldapsearchfilter&lt;/code&gt; . Указание &lt;code&gt;ldapsearchattribute=foo&lt;/code&gt; эквивалентно указанию &lt;code&gt;ldapsearchfilter=&quot;(foo=$username)&quot;&lt;/code&gt; . Если ни один параметр не указан, по умолчанию используется &lt;code&gt;ldapsearchattribute=uid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="135e97cd9c471619bb69517b95ef6da4e4340a4c" translate="yes" xml:space="preserve">
          <source>When using static log file names, the server might fail to reopen the log file if the max open file limit is reached or a file table overflow occurs. In this case, log messages are sent to the old log file until a successful log rotation. If logrotate is configured to compress the log file and delete it, the server may lose the messages logged in this time frame. To avoid this issue, you can configure the logging collector to dynamically assign log file names and use a &lt;code&gt;prerotate&lt;/code&gt; script to ignore open log files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf2c531c08aa10ba699a8b190067e047b3e70bf" translate="yes" xml:space="preserve">
          <source>When using static log file names, the server might fail to reopen the log file if the max open file limit is reached or a file table overflow occurs. In this case, log messages are sent to the old log file until a successful log rotation. If logrotate is configured to compress the log file and delete it, the server may lose the messages logged in this timeframe. To avoid this issue, you can configure the logging collector to dynamically assign log file names and use a &lt;code&gt;prerotate&lt;/code&gt; script to ignore open log files.</source>
          <target state="translated">При использовании статических имен файлов журнала серверу может не удастся повторно открыть файл журнала, если будет достигнуто максимальное количество открытых файлов или произойдет переполнение таблицы файлов. В этом случае сообщения журнала отправляются в старый файл журнала до успешной ротации журнала. Если logrotate настроен на сжатие файла журнала и его удаление, сервер может потерять сообщения, зарегистрированные в этот период времени. Чтобы избежать этой проблемы, вы можете настроить сборщик журналов для динамического назначения имен файлов журналов и использовать сценарий предварительного &lt;code&gt;prerotate&lt;/code&gt; для игнорирования открытых файлов журналов.</target>
        </trans-unit>
        <trans-unit id="ddcdbf5154b4eb280778c5288af6f89414cb4462" translate="yes" xml:space="preserve">
          <source>When using systemd, you can use the following service unit file (e.g., at &lt;code&gt;/etc/systemd/system/postgresql.service&lt;/code&gt;):</source>
          <target state="translated">При использовании systemd вы можете использовать следующий файл служебной единицы (например, в &lt;code&gt;/etc/systemd/system/postgresql.service&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="aa4f4b5954d77c90199a922670870bbe00993316" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; module, a foreign server's name can be used as an argument of the &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; function to indicate the connection parameters. It is necessary to have the &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server to be able to use it in this way.</source>
          <target state="translated">При использовании &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;DBLink&lt;/a&gt; модуля, имя иностранного сервера может быть использовано в качестве аргумента &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; функции , чтобы указать параметры соединения. Чтобы использовать его таким образом, необходимо иметь право &lt;code&gt;USAGE&lt;/code&gt; на внешнем сервере.</target>
        </trans-unit>
        <trans-unit id="2a1340434fcccdcd8d13b6480e2a087b4c7cd975" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt; module, a foreign server's name can be used as an argument of the &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; function to indicate the connection parameters. It is necessary to have the &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server to be able to use it in this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd246a1d45857b9944b119a71ad8342fdd069e69" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; syntax, if one of the functions requires a column definition list, it's preferred to put the column definition list after the function call inside &lt;code&gt;ROWS FROM( ... )&lt;/code&gt;. A column definition list can be placed after the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; construct only if there's just a single function and no &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause.</source>
          <target state="translated">При использовании &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; , если для одной из функций требуется список определений столбцов, рекомендуется поместить список определений столбцов после вызова функции внутри &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; . Список определений столбцов может быть помещен после конструкции &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; только если есть только одна функция и нет предложения &lt;code&gt;WITH ORDINALITY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98b68f1005505d22ba3f1b802a0a0796977dd397" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;extensions&lt;/code&gt; option, &lt;em&gt;it is the user's responsibility&lt;/em&gt; that the listed extensions exist and behave identically on both the local and remote servers. Otherwise, remote queries may fail or behave unexpectedly.</source>
          <target state="translated">При использовании опции &lt;code&gt;extensions&lt;/code&gt; &lt;em&gt;ответственность за&lt;/em&gt; то, чтобы перечисленные расширения существовали и работали одинаково как на локальном, так и на удаленном серверах , &lt;em&gt;является обязанностью пользователя&lt;/em&gt; . В противном случае удаленные запросы могут завершиться ошибкой или вести себя неожиданно.</target>
        </trans-unit>
        <trans-unit id="e797775100fdafb459cefc34e37395f8e226c9b6" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;libc&lt;/code&gt; collation provider, the locale must be applicable to the current database encoding. See &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; for the precise rules.</source>
          <target state="translated">При использовании поставщика сопоставления &lt;code&gt;libc&lt;/code&gt; локаль должна быть применима к текущей кодировке базы данных. См. Точные правила в &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33347a458dabb91eee87e22ef8743db48a2953ba" translate="yes" xml:space="preserve">
          <source>When using the statistics to monitor collected data, it is important to realize that the information does not update instantaneously. Each individual server process transmits new statistical counts to the collector just before going idle; so a query or transaction still in progress does not affect the displayed totals. Also, the collector itself emits a new report at most once per &lt;code&gt;PGSTAT_STAT_INTERVAL&lt;/code&gt; milliseconds (500 ms unless altered while building the server). So the displayed information lags behind actual activity. However, current-query information collected by &lt;code&gt;track_activities&lt;/code&gt; is always up-to-date.</source>
          <target state="translated">При использовании статистики для мониторинга собранных данных важно понимать, что информация не обновляется мгновенно. Каждый отдельный серверный процесс передает новые статистические данные сборщику непосредственно перед переходом в режим ожидания; поэтому запрос или транзакция, которые все еще выполняются, не влияют на отображаемые итоги. Кроме того, сам сборщик генерирует новый отчет не чаще одного раза за миллисекунды &lt;code&gt;PGSTAT_STAT_INTERVAL&lt;/code&gt; (500 мс, если не были изменены при построении сервера). Таким образом, отображаемая информация отстает от реальной активности. Однако информация о текущем запросе, собираемая &lt;code&gt;track_activities&lt;/code&gt; , всегда актуальна.</target>
        </trans-unit>
        <trans-unit id="869040936f3cd63714aedfeb674cbbcb51ecde9f" translate="yes" xml:space="preserve">
          <source>When using this option together with &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt;, the text of statements that are logged because of &lt;code&gt;log_statement&lt;/code&gt; will not be repeated in the duration log message. If you are not using syslog, it is recommended that you log the PID or session ID using &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt; so that you can link the statement message to the later duration message using the process ID or session ID.</source>
          <target state="translated">При использовании этой опции вместе с &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt; текст операторов, которые регистрируются из-за &lt;code&gt;log_statement&lt;/code&gt; , не будет повторяться в сообщении журнала продолжительности. Если вы не используете системный журнал, рекомендуется регистрировать PID или идентификатор сеанса с помощью &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix,&lt;/a&gt; чтобы вы могли связать сообщение оператора с сообщением более поздней продолжительности, используя идентификатор процесса или идентификатор сеанса.</target>
        </trans-unit>
        <trans-unit id="f56584dae166e0f5d41c03bae8959fb67da882b7" translate="yes" xml:space="preserve">
          <source>When using this technique, it will avoid creating an unnecessary burden for application programmers if the application software goes through a framework which automatically retries transactions which are rolled back with a serialization failure. It may be a good idea to set &lt;code&gt;default_transaction_isolation&lt;/code&gt; to &lt;code&gt;serializable&lt;/code&gt;. It would also be wise to take some action to ensure that no other transaction isolation level is used, either inadvertently or to subvert integrity checks, through checks of the transaction isolation level in triggers.</source>
          <target state="translated">При использовании этого метода это позволит избежать ненужного бремени для прикладных программистов, если прикладное программное обеспечение проходит через платформу, которая автоматически повторяет транзакции, которые откатываются с ошибкой сериализации. Может быть хорошей идеей установить &lt;code&gt;default_transaction_isolation&lt;/code&gt; как &lt;code&gt;serializable&lt;/code&gt; . Также было бы разумно предпринять некоторые действия, чтобы гарантировать, что никакой другой уровень изоляции транзакции не используется случайно или для нарушения проверок целостности, посредством проверок уровня изоляции транзакции в триггерах.</target>
        </trans-unit>
        <trans-unit id="a2c852145ce2448ef43e1a7c8c990a843033f4d6" translate="yes" xml:space="preserve">
          <source>When verifying checksums, every file in the cluster is scanned. When enabling checksums, every file in the cluster is rewritten in-place. Disabling checksums only updates the file &lt;code&gt;pg_control&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e33ed6ffb66e09afb90b2aa31b40f235c917227" translate="yes" xml:space="preserve">
          <source>When verifying checksums, every file in the cluster is scanned. When enabling checksums, every file in the cluster is rewritten. Disabling checksums only updates the file &lt;code&gt;pg_control&lt;/code&gt;.</source>
          <target state="translated">При проверке контрольных сумм проверяется каждый файл в кластере. При включении контрольных сумм каждый файл в кластере перезаписывается. Отключение контрольных сумм обновляет только файл &lt;code&gt;pg_control&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fda53778d06f68bfde32b3023f6347b2be67790d" translate="yes" xml:space="preserve">
          <source>When waiting, &lt;code&gt;pg_ctl&lt;/code&gt; repeatedly checks the server's PID file, sleeping for a short amount of time between checks. Startup is considered complete when the PID file indicates that the server is ready to accept connections. Shutdown is considered complete when the server removes the PID file. &lt;code&gt;pg_ctl&lt;/code&gt; returns an exit code based on the success of the startup or shutdown.</source>
          <target state="translated">Во время ожидания &lt;code&gt;pg_ctl&lt;/code&gt; повторно проверяет файл PID сервера, засыпая на короткое время между проверками. Запуск считается завершенным, если файл PID указывает, что сервер готов принимать соединения. Завершение работы считается завершенным, когда сервер удаляет файл PID. &lt;code&gt;pg_ctl&lt;/code&gt; возвращает код выхода в зависимости от успеха запуска или завершения работы.</target>
        </trans-unit>
        <trans-unit id="319a6ac32ba7d37c93ad8b3aed41a7b25d9cd283" translate="yes" xml:space="preserve">
          <source>When we speak of inheriting the locale from the execution environment, this means the following on most operating systems: For a given locale category, say the collation, the following environment variables are consulted in this order until one is found to be set: &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_COLLATE&lt;/code&gt; (or the variable corresponding to the respective category), &lt;code&gt;LANG&lt;/code&gt;. If none of these environment variables are set then the locale defaults to &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">Когда мы говорим о наследовании языкового стандарта из среды выполнения, в большинстве операционных систем это означает следующее: Для данной категории языкового стандарта, скажем, сопоставления, следующие переменные среды &lt;code&gt;LC_ALL&lt;/code&gt; в этом порядке, пока не будет обнаружена одна установленная: LC_ALL , &lt;code&gt;LC_COLLATE&lt;/code&gt; (или переменная, соответствующая соответствующей категории), &lt;code&gt;LANG&lt;/code&gt; . Если ни одна из этих переменных окружения не установлены , то локали по умолчанию в &lt;code&gt;C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09870d0ba2815a6a474afa8adde88701322779a5" translate="yes" xml:space="preserve">
          <source>When we write</source>
          <target state="translated">Когда мы пишем</target>
        </trans-unit>
        <trans-unit id="5f55fad869d686971a61de9989dadab77ae5eb95" translate="yes" xml:space="preserve">
          <source>When working with an inner tuple having unlabeled nodes, it is an error for &lt;code&gt;choose&lt;/code&gt; to return &lt;code&gt;spgAddNode&lt;/code&gt;, since the set of nodes is supposed to be fixed in such cases.</source>
          <target state="translated">При работе с внутренним кортежем, имеющим непомеченные узлы, &lt;code&gt;choose&lt;/code&gt; возврата &lt;code&gt;spgAddNode&lt;/code&gt; является ошибкой , поскольку в таких случаях предполагается, что набор узлов должен быть фиксированным.</target>
        </trans-unit>
        <trans-unit id="513c84ce8934fc59619703510a7a572aaca0c319" translate="yes" xml:space="preserve">
          <source>When working with multiple tables, it can also be useful to ask for all the columns of a particular table:</source>
          <target state="translated">При работе с несколькими таблицами также может быть полезным запросить все столбцы конкретной таблицы:</target>
        </trans-unit>
        <trans-unit id="3f387116d6a98de65f13445ebf4c25f94df15576" translate="yes" xml:space="preserve">
          <source>When working with non-SQL-standard operator names, you will usually need to separate adjacent operators with spaces to avoid ambiguity. For example, if you have defined a left unary operator named &lt;code&gt;@&lt;/code&gt;, you cannot write &lt;code&gt;X*@Y&lt;/code&gt;; you must write &lt;code&gt;X* @Y&lt;/code&gt; to ensure that PostgreSQL reads it as two operator names not one.</source>
          <target state="translated">При работе с именами операторов, не соответствующими стандарту SQL, вам обычно нужно разделять соседние операторы пробелами, чтобы избежать двусмысленности. Например, если вы определили левый унарный оператор с именем &lt;code&gt;@&lt;/code&gt; , вы не можете писать &lt;code&gt;X*@Y&lt;/code&gt; ; вы должны написать &lt;code&gt;X* @Y&lt;/code&gt; чтобы PostgreSQL считал его как два имени оператора, а не как одно.</target>
        </trans-unit>
        <trans-unit id="ec3a2849e7e7665d1ef0586b393970fa38e06c50" translate="yes" xml:space="preserve">
          <source>When working with recursive queries it is important to be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. Sometimes, using &lt;code&gt;UNION&lt;/code&gt; instead of &lt;code&gt;UNION ALL&lt;/code&gt; can accomplish this by discarding rows that duplicate previous output rows. However, often a cycle does not involve output rows that are completely duplicate: it may be necessary to check just one or a few fields to see if the same point has been reached before. The standard method for handling such situations is to compute an array of the already-visited values. For example, consider the following query that searches a table &lt;code&gt;graph&lt;/code&gt; using a &lt;code&gt;link&lt;/code&gt; field:</source>
          <target state="translated">При работе с рекурсивными запросами важно быть уверенным, что рекурсивная часть запроса в конечном итоге не вернет кортежи, иначе запрос будет повторяться бесконечно. Иногда, используя &lt;code&gt;UNION&lt;/code&gt; вместо &lt;code&gt;UNION ALL&lt;/code&gt; , можно добиться этого, отбросив строки, которые дублируют предыдущие выходные строки. Однако часто цикл не включает в себя полностью повторяющиеся выходные строки: может потребоваться проверить только одно или несколько полей, чтобы увидеть, достигалась ли такая же точка раньше. Стандартный метод обработки таких ситуаций - вычисление массива уже посещенных значений. Например, рассмотрим следующий запрос, который выполняет поиск в табличном &lt;code&gt;graph&lt;/code&gt; с использованием поля &lt;code&gt;link&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e5718cfeb2fe2d91286009aaf2e77c006f835bbe" translate="yes" xml:space="preserve">
          <source>When writing an interval constant with a &lt;code&gt;fields&lt;/code&gt; specification, or when assigning a string to an interval column that was defined with a &lt;code&gt;fields&lt;/code&gt; specification, the interpretation of unmarked quantities depends on the &lt;code&gt;fields&lt;/code&gt;. For example &lt;code&gt;INTERVAL '1' YEAR&lt;/code&gt; is read as 1 year, whereas &lt;code&gt;INTERVAL '1'&lt;/code&gt; means 1 second. Also, field values &amp;ldquo;to the right&amp;rdquo; of the least significant field allowed by the &lt;code&gt;fields&lt;/code&gt; specification are silently discarded. For example, writing &lt;code&gt;INTERVAL '1 day 2:03:04' HOUR TO MINUTE&lt;/code&gt; results in dropping the seconds field, but not the day field.</source>
          <target state="translated">При записи константы интервала со спецификацией &lt;code&gt;fields&lt;/code&gt; или при назначении строки столбцу интервала, который был определен с помощью спецификации &lt;code&gt;fields&lt;/code&gt; , интерпретация немаркированных величин зависит от &lt;code&gt;fields&lt;/code&gt; . Например, &lt;code&gt;INTERVAL '1' YEAR&lt;/code&gt; читается как 1 год, тогда как &lt;code&gt;INTERVAL '1'&lt;/code&gt; означает 1 секунду. Кроме того, значения поля &amp;laquo;справа&amp;raquo; от наименее значимого поля, разрешенного спецификацией &lt;code&gt;fields&lt;/code&gt; , автоматически отбрасываются. Например, запись &lt;code&gt;INTERVAL '1 day 2:03:04' HOUR TO MINUTE&lt;/code&gt; приведет к удалению поля секунд, но не поля дня.</target>
        </trans-unit>
        <trans-unit id="988ef8be5d9c8af4c97d0fc59910f990922134e4" translate="yes" xml:space="preserve">
          <source>When you create a table and you realize that you made a mistake, or the requirements of the application change, you can drop the table and create it again. But this is not a convenient option if the table is already filled with data, or if the table is referenced by other database objects (for instance a foreign key constraint). Therefore PostgreSQL provides a family of commands to make modifications to existing tables. Note that this is conceptually distinct from altering the data contained in the table: here we are interested in altering the definition, or structure, of the table.</source>
          <target state="translated">Когда вы создаете таблицу и понимаете,что вы допустили ошибку,или требования приложения меняются,вы можете опустить таблицу и создать ее снова.Но это неудобный вариант,если таблица уже заполнена данными,или на нее ссылаются другие объекты БД (например,ограничение постороннего ключа).Поэтому PostgreSQL предоставляет семейство команд для внесения изменений в существующие таблицы.Обратите внимание,что это концептуально отличается от изменения данных,содержащихся в таблице:здесь мы заинтересованы в изменении определения или структуры таблицы.</target>
        </trans-unit>
        <trans-unit id="63a09c13346cb20d8d1dd7186def1b2a2f01cbc1" translate="yes" xml:space="preserve">
          <source>When you create complex database structures involving many tables with foreign key constraints, views, triggers, functions, etc. you implicitly create a net of dependencies between the objects. For instance, a table with a foreign key constraint depends on the table it references.</source>
          <target state="translated">При создании сложных структур БД,включающих множество таблиц с посторонними ключевыми ограничениями,представлениями,триггерами,функциями и т.д.,вы неявно создаете сеть зависимостей между объектами.Например,таблица с ограничениями по внешнему ключу зависит от таблицы,на которую она ссылается.</target>
        </trans-unit>
        <trans-unit id="b9a5344aa581794cb8d710e210bdb65e511f2134" translate="yes" xml:space="preserve">
          <source>When you create many interrelated tables it is wise to choose a consistent naming pattern for the tables and columns. For instance, there is a choice of using singular or plural nouns for table names, both of which are favored by some theorist or other.</source>
          <target state="translated">При создании множества взаимосвязанных таблиц целесообразно выбрать последовательный шаблон именования таблиц и столбцов.Например,для названий таблиц можно использовать единственное или множественное число существительных,оба из которых являются предпочтительными для того или иного теоретика.</target>
        </trans-unit>
        <trans-unit id="593e96c33f6f0aab676c4ca184c4ca854f13bc97" translate="yes" xml:space="preserve">
          <source>When you insert invalid numbers in a table using the weak mode, the number will be inserted with the corrected check digit, but it will be displayed with an exclamation mark (&lt;code&gt;!&lt;/code&gt;) at the end, for example &lt;code&gt;0-11-000322-5!&lt;/code&gt;. This invalid marker can be checked with the &lt;code&gt;is_valid&lt;/code&gt; function and cleared with the &lt;code&gt;make_valid&lt;/code&gt; function.</source>
          <target state="translated">Когда вы вставляете недопустимые числа в таблицу, используя слабый режим, номер будет вставлен с исправленной контрольной цифрой, но будет отображаться с восклицательным знаком ( &lt;code&gt;!&lt;/code&gt; ) В конце, например &lt;code&gt;0-11-000322-5!&lt;/code&gt; . Этот недопустимый маркер можно проверить с &lt;code&gt;is_valid&lt;/code&gt; функции is_valid и очистить с &lt;code&gt;make_valid&lt;/code&gt; функции make_valid .</target>
        </trans-unit>
        <trans-unit id="1bf59c49779a368d436367de404fed33cad74dcd" translate="yes" xml:space="preserve">
          <source>When you query JSON data, the path expression may not match the actual JSON data structure. An attempt to access a non-existent member of an object or element of an array results in a structural error. SQL/JSON path expressions have two modes of handling structural errors:</source>
          <target state="translated">Когда вы запрашиваете JSON-данные,выражение пути может не соответствовать действительной структуре JSON-данных.Попытка получить доступ к несуществующему члену объекта или элемента массива приводит к структурной ошибке.Выражения пути SQL/JSON имеют два режима работы со структурными ошибками:</target>
        </trans-unit>
        <trans-unit id="d3780caf73c39bd4ac2d31b375fc0dd6e1923bd0" translate="yes" xml:space="preserve">
          <source>When you write the argument of a sequence function as an unadorned literal string, it becomes a constant of type &lt;code&gt;regclass&lt;/code&gt;. Since this is really just an OID, it will track the originally identified sequence despite later renaming, schema reassignment, etc. This &amp;ldquo;early binding&amp;rdquo; behavior is usually desirable for sequence references in column defaults and views. But sometimes you might want &amp;ldquo;late binding&amp;rdquo; where the sequence reference is resolved at run time. To get late-binding behavior, force the constant to be stored as a &lt;code&gt;text&lt;/code&gt; constant instead of &lt;code&gt;regclass&lt;/code&gt;:</source>
          <target state="translated">Когда вы пишете аргумент функции последовательности в виде простой буквальной строки, он становится константой типа &lt;code&gt;regclass&lt;/code&gt; . Поскольку на самом деле это всего лишь OID, он будет отслеживать первоначально идентифицированную последовательность, несмотря на последующее переименование, переназначение схемы и т. Д. Такое поведение &amp;laquo;раннего связывания&amp;raquo; обычно желательно для ссылок на последовательности в значениях по умолчанию для столбцов и представлениях. Но иногда вам может понадобиться &amp;laquo;позднее связывание&amp;raquo;, когда ссылка на последовательность разрешается во время выполнения. Чтобы получить поведение с поздним связыванием, принудительно сохраните константу как &lt;code&gt;text&lt;/code&gt; константу вместо &lt;code&gt;regclass&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0deb417e3efe2ecd61376860b861e35f77f81d08" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;ANALYZE&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_analyze&lt;/code&gt; view will contain a row for each backend that is currently running that command. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2507ec70331a5deab93cd40d826b1bdba44ecbc3" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; view will contain a row for each backend that is currently running either command. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">Каждый раз, когда выполняется &lt;code&gt;CLUSTER&lt;/code&gt; или &lt;code&gt;VACUUM FULL&lt;/code&gt; , представление &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; будет содержать строку для каждого внутреннего модуля, который в данный момент выполняет любую команду. В таблицах ниже описывается информация, которая будет сообщена, и представлена ​​информация о том, как ее интерпретировать.</target>
        </trans-unit>
        <trans-unit id="51b73a7d0ff3b39db66ff19d5f58e0f20613bb45" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_create_index&lt;/code&gt; view will contain one row for each backend that is currently creating indexes. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">Каждый раз, когда &lt;code&gt;REINDEX&lt;/code&gt; &lt;code&gt;CREATE INDEX&lt;/code&gt; или REINDEX , представление &lt;code&gt;pg_stat_progress_create_index&lt;/code&gt; будет содержать по одной строке для каждого бэкэнда, который в данный момент создает индексы. В таблицах ниже описывается информация, которая будет сообщена, и представлена ​​информация о том, как ее интерпретировать.</target>
        </trans-unit>
        <trans-unit id="0da2e4c266065ef5b47dc244d1142646be363723" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; view will contain one row for each backend (including autovacuum worker processes) that is currently vacuuming. The tables below describe the information that will be reported and provide information about how to interpret it. Progress for &lt;code&gt;VACUUM FULL&lt;/code&gt; commands is reported via &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; because both &lt;code&gt;VACUUM FULL&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt; rewrite the table, while regular &lt;code&gt;VACUUM&lt;/code&gt; only modifies it in place. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="translated">Каждый раз, когда &lt;code&gt;VACUUM&lt;/code&gt; запущен, представление &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; будет содержать по одной строке для каждого внутреннего интерфейса (включая рабочие процессы автоочистки), который в данный момент выполняет очистку. В таблицах ниже описывается информация, которая будет сообщена, и представлена ​​информация о том, как ее интерпретировать. О ходе выполнения команд &lt;code&gt;VACUUM FULL&lt;/code&gt; сообщается через &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; , потому что и &lt;code&gt;VACUUM FULL&lt;/code&gt; , и &lt;code&gt;CLUSTER&lt;/code&gt; перезаписывают таблицу, в то время как обычный &lt;code&gt;VACUUM&lt;/code&gt; изменяет ее только на месте. См. &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Раздел 27.4.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fb8592a09f7a3ed7d4104db7d0d68ac3ee490fb" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; view will contain one row for each backend (including autovacuum worker processes) that is currently vacuuming. The tables below describe the information that will be reported and provide information about how to interpret it. Progress for &lt;code&gt;VACUUM FULL&lt;/code&gt; commands is reported via &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; because both &lt;code&gt;VACUUM FULL&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt; rewrite the table, while regular &lt;code&gt;VACUUM&lt;/code&gt; only modifies it in place. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d664025546cdeafdfe0701b9fa38130d919c75" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; scans any part of a table, it will replace any multixact ID it encounters which is older than &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt; by a different value, which can be the zero value, a single transaction ID, or a newer multixact ID. For each table, &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; stores the oldest possible multixact ID still appearing in any tuple of that table. If this value is older than &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt;, an aggressive vacuum is forced. As discussed in the previous section, an aggressive vacuum means that only those pages which are known to be all-frozen will be skipped. &lt;code&gt;mxid_age()&lt;/code&gt; can be used on &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; to find its age.</source>
          <target state="translated">Всякий раз, когда &lt;code&gt;VACUUM&lt;/code&gt; сканирует любую часть таблицы, он заменяет любой встреченный мультиплексный идентификатор, который старше, чем &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;вакуум_multixact_freeze_min_age&lt;/a&gt; , другим значением, которое может быть нулевым значением, одним идентификатором транзакции или новым идентификатором мультиплексирования. Для каждой таблицы &lt;code&gt;pg_class&lt;/code&gt; . &lt;code&gt;relminmxid&lt;/code&gt; хранит самый старый из возможных идентификаторов мультиплексирования, который все еще присутствует в любом кортеже этой таблицы. Если это значение более &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;раннее&lt;/a&gt; , чем Vacuum_multixact_freeze_table_age , принудительно выполняется агрессивная очистка . Как обсуждалось в предыдущем разделе, агрессивный вакуум означает, что будут пропущены только те страницы, которые заведомо полностью заморожены. &lt;code&gt;mxid_age()&lt;/code&gt; можно использовать с &lt;code&gt;pg_class&lt;/code&gt; . &lt;code&gt;relminmxid&lt;/code&gt; чтобы узнать свой возраст.</target>
        </trans-unit>
        <trans-unit id="5f844cc225201cbe85cbdde3d905d07e347e61a8" translate="yes" xml:space="preserve">
          <source>Whenever PostgreSQL needs to combine rows from multiple sources into a single result set, it uses an &lt;code&gt;Append&lt;/code&gt; or &lt;code&gt;MergeAppend&lt;/code&gt; plan node. This commonly happens when implementing &lt;code&gt;UNION ALL&lt;/code&gt; or when scanning a partitioned table. Such nodes can be used in parallel plans just as they can in any other plan. However, in a parallel plan, the planner may instead use a &lt;code&gt;Parallel Append&lt;/code&gt; node.</source>
          <target state="translated">Каждый раз, когда PostgreSQL требуется объединить строки из нескольких источников в единый набор результатов, он использует узел плана &lt;code&gt;Append&lt;/code&gt; или &lt;code&gt;MergeAppend&lt;/code&gt; . Обычно это происходит при реализации &lt;code&gt;UNION ALL&lt;/code&gt; или при сканировании многораздельной таблицы. Такие узлы можно использовать в параллельных планах так же, как и в любом другом плане. Однако в параллельном плане планировщик может вместо этого использовать узел &lt;code&gt;Parallel Append&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85e82d59ea38cfaea7777dbbbcc2b327247984a8" translate="yes" xml:space="preserve">
          <source>Whenever a command is executed, psql also polls for asynchronous notification events generated by &lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt; and &lt;a href=&quot;sql-notify&quot;&gt;NOTIFY&lt;/a&gt;.</source>
          <target state="translated">Каждый раз, когда выполняется команда, psql также опрашивает события асинхронного уведомления, сгенерированные &lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt; и &lt;a href=&quot;sql-notify&quot;&gt;NOTIFY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe283c15f98e1d6878cfeeadd5bbfd6c5078c552" translate="yes" xml:space="preserve">
          <source>Whenever a user-defined type is created, PostgreSQL automatically creates an associated array type, whose name consists of the element type's name prepended with an underscore, and truncated if necessary to keep it less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; bytes long. (If the name so generated collides with an existing type name, the process is repeated until a non-colliding name is found.) This implicitly-created array type is variable length and uses the built-in input and output functions &lt;code&gt;array_in&lt;/code&gt; and &lt;code&gt;array_out&lt;/code&gt;. The array type tracks any changes in its element type's owner or schema, and is dropped if the element type is.</source>
          <target state="translated">Каждый раз, когда создается пользовательский тип, PostgreSQL автоматически создает связанный тип массива, имя которого состоит из имени типа элемента с добавлением символа подчеркивания и усекается, если необходимо, чтобы его &lt;code&gt;NAMEDATALEN&lt;/code&gt; не превышала NAMEDATALEN байтов. (Если сгенерированное таким образом имя сталкивается с существующим именем типа, процесс повторяется до тех пор, пока не будет найдено несовпадающее имя.) Этот неявно созданный тип массива имеет переменную длину и использует встроенные функции ввода и вывода &lt;code&gt;array_in&lt;/code&gt; и &lt;code&gt;array_out&lt;/code&gt; . Тип массива отслеживает любые изменения в владельце или схеме его типа элемента и удаляется, если тип элемента равен.</target>
        </trans-unit>
        <trans-unit id="7c3ae7e94c74ecafe04f858b486a7a8022aa32dd" translate="yes" xml:space="preserve">
          <source>Whenever an application like pg_basebackup is taking a base backup, the &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; view will contain a row for each WAL sender process that is currently running the &lt;code&gt;BASE_BACKUP&lt;/code&gt; replication command and streaming the backup. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c317e2f18ac74c5065186374d831c55658598512" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written by a single backend, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;0&lt;/code&gt;, i.e., no forced writeback. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the maximum value scales proportionally to it.)</source>
          <target state="translated">Каждый раз, когда один бэкэнд записал больше этого количества данных, попытайтесь заставить ОС выполнить эти записи в базовое хранилище. Это ограничит количество грязных данных в кэше страниц ядра, уменьшая вероятность зависаний, когда &lt;code&gt;fsync&lt;/code&gt; выдается в конце контрольной точки или когда ОС записывает данные обратно большими партиями в фоновом режиме. Часто это приводит к значительному уменьшению задержки транзакции, но также есть некоторые случаи, особенно с рабочими нагрузками, которые больше, чем &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; , но меньше, чем кеш страницы ОС, где производительность может снизиться. Этот параметр может не действовать на некоторых платформах. Если это значение указано без единиц, оно принимается как блоки, то есть &lt;code&gt;BLCKSZ&lt;/code&gt; байтов, обычно 8 КБ. Допустимый диапазон - от &lt;code&gt;0&lt;/code&gt; , что отключает принудительную обратную запись, до &lt;code&gt;2MB&lt;/code&gt; . По умолчанию - &lt;code&gt;0&lt;/code&gt; , т. Е. Принудительная обратная запись отсутствует. (Если &lt;code&gt;BLCKSZ&lt;/code&gt; не 8 КБ, максимальное значение масштабируется пропорционально ему.)</target>
        </trans-unit>
        <trans-unit id="de89b6016c756123d6b9441e22d55848a32a9ab3" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;512kB&lt;/code&gt; on Linux, &lt;code&gt;0&lt;/code&gt; elsewhere. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default and maximum values scale proportionally to it.) This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Каждый раз, когда фоновой записью было записано больше, чем это количество данных, попытайтесь заставить ОС выполнять эти записи в базовое хранилище. Это ограничит количество грязных данных в кэше страниц ядра, уменьшая вероятность зависаний, когда &lt;code&gt;fsync&lt;/code&gt; выдается в конце контрольной точки или когда ОС записывает данные обратно большими партиями в фоновом режиме. Часто это приводит к значительному уменьшению задержки транзакции, но также есть некоторые случаи, особенно с рабочими нагрузками, которые больше, чем &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; , но меньше, чем кеш страницы ОС, где производительность может снизиться. Этот параметр может не действовать на некоторых платформах. Если это значение указано без единиц, оно принимается как блоки, то есть &lt;code&gt;BLCKSZ&lt;/code&gt; байтов, обычно 8 КБ. Допустимый диапазон - от &lt;code&gt;0&lt;/code&gt; , что отключает принудительную обратную запись, до &lt;code&gt;2MB&lt;/code&gt; . По умолчанию в Linux - &lt;code&gt;512kB&lt;/code&gt; , в других - &lt;code&gt;0&lt;/code&gt; . (Если &lt;code&gt;BLCKSZ&lt;/code&gt; не 8 КБ, значения по умолчанию и максимальное масштабируются пропорционально ему.) Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="41035af23763d236bc43d7713084261d3a812120" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written while performing a checkpoint, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of the checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;256kB&lt;/code&gt; on Linux, &lt;code&gt;0&lt;/code&gt; elsewhere. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default and maximum values scale proportionally to it.) This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Каждый раз, когда во время выполнения контрольной точки было записано больше этого количества данных, попытайтесь заставить ОС выполнить эти записи в базовое хранилище. Это ограничит количество грязных данных в кэше страниц ядра, уменьшая вероятность остановок, когда &lt;code&gt;fsync&lt;/code&gt; выдается в конце контрольной точки или когда ОС записывает данные обратно большими партиями в фоновом режиме. Часто это приводит к значительному уменьшению задержки транзакции, но также есть некоторые случаи, особенно с рабочими нагрузками, которые больше, чем &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; , но меньше, чем кеш страницы ОС, где производительность может снизиться. Этот параметр может не действовать на некоторых платформах. Если это значение указано без единиц, оно принимается как блоки, то есть &lt;code&gt;BLCKSZ&lt;/code&gt; байтов, обычно 8 КБ. Допустимый диапазон - от &lt;code&gt;0&lt;/code&gt; , что отключает принудительную обратную запись, до &lt;code&gt;2MB&lt;/code&gt; . По умолчанию в Linux установлено &lt;code&gt;256kB&lt;/code&gt; , а в других - &lt;code&gt;0&lt;/code&gt; . (Если &lt;code&gt;BLCKSZ&lt;/code&gt; не 8 КБ, значения по умолчанию и максимальное масштабируются пропорционально ему.) Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="103203b2b9af3babb0455dacf44200f8d0e1dba1" translate="yes" xml:space="preserve">
          <source>Whenever pg_basebackup is taking a base backup, the server's &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; view will report the progress of the backup. See &lt;a href=&quot;progress-reporting#BASEBACKUP-PROGRESS-REPORTING&quot;&gt;Section 27.4.5&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cafdfe0e40c272ef5695922c2a975f51df9e1cea" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;code&gt;pattern&lt;/code&gt; parameter is omitted completely, the &lt;code&gt;\d&lt;/code&gt; commands display all objects that are visible in the current schema search path &amp;mdash; this is equivalent to using &lt;code&gt;*&lt;/code&gt; as the pattern. (An object is said to be &lt;em&gt;visible&lt;/em&gt; if its containing schema is in the search path and no object of the same kind and name appears earlier in the search path. This is equivalent to the statement that the object can be referenced by name without explicit schema qualification.) To see all objects in the database regardless of visibility, use &lt;code&gt;*.*&lt;/code&gt; as the pattern.</source>
          <target state="translated">Всякий раз, когда параметр &lt;code&gt;pattern&lt;/code&gt; полностью опускается, команды &lt;code&gt;\d&lt;/code&gt; отображают все объекты, видимые в текущем пути поиска схемы - это эквивалентно использованию &lt;code&gt;*&lt;/code&gt; в качестве шаблона. (Объект считается &lt;em&gt;видимым,&lt;/em&gt; если содержащая его схема находится в пути поиска и ни один объект того же вида и имени не появляется ранее в пути поиска. Это эквивалентно утверждению, что объект может быть указан по имени без явной схемы квалификация.) Чтобы увидеть все объекты в базе данных независимо от видимости, используйте &lt;code&gt;*.*&lt;/code&gt; в качестве шаблона.</target>
        </trans-unit>
        <trans-unit id="2dffd7d6d50f37b1f139649fc2afe46f33411c06" translate="yes" xml:space="preserve">
          <source>Whenever the command &lt;code&gt;NOTIFY channel&lt;/code&gt; is invoked, either by this session or another one connected to the same database, all the sessions currently listening on that notification channel are notified, and each will in turn notify its connected client application.</source>
          <target state="translated">Всякий раз, когда вызывается команда &lt;code&gt;NOTIFY channel&lt;/code&gt; , либо этим сеансом, либо другим, подключенным к той же базе данных, все сеансы, в настоящее время прослушивающие этот канал уведомления, уведомляются, и каждый, в свою очередь, уведомляет свое подключенное клиентское приложение.</target>
        </trans-unit>
        <trans-unit id="464c9a84b9274c416e8217076cf62d6ce77919b2" translate="yes" xml:space="preserve">
          <source>Whenever the role subsequently starts a new session, the specified value becomes the session default, overriding whatever setting is present in &lt;code&gt;postgresql.conf&lt;/code&gt; or has been received from the &lt;code&gt;postgres&lt;/code&gt; command line. This only happens at login time; executing &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; or &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt; does not cause new configuration values to be set. Settings set for all databases are overridden by database-specific settings attached to a role. Settings for specific databases or specific roles override settings for all roles.</source>
          <target state="translated">Каждый раз, когда роль впоследствии запускает новый сеанс, указанное значение становится значением сеанса по умолчанию, переопределяя любой параметр, присутствующий в &lt;code&gt;postgresql.conf&lt;/code&gt; или полученный из командной строки &lt;code&gt;postgres&lt;/code&gt; . Это происходит только во время входа в систему; выполнение &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; или &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt; не приводит к установке новых значений конфигурации. Настройки, установленные для всех баз данных, переопределяются настройками конкретной базы данных, привязанными к роли. Настройки для определенных баз данных или определенных ролей переопределяют настройки для всех ролей.</target>
        </trans-unit>
        <trans-unit id="1cb07a399aec26555c15e193c16effe1e79f48af" translate="yes" xml:space="preserve">
          <source>Whenever you create a table, a composite type is also automatically created, with the same name as the table, to represent the table's row type. For example, had we said:</source>
          <target state="translated">Всякий раз,когда вы создаете таблицу,составной тип также создается автоматически,с тем же именем,что и таблица,для представления типа строки таблицы.Например,как мы уже говорили:</target>
        </trans-unit>
        <trans-unit id="72417af150626f41547b564cc2af3102889d282f" translate="yes" xml:space="preserve">
          <source>Whenever you have significantly altered the distribution of data within a table, running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; is strongly recommended. This includes bulk loading large amounts of data into the table. Running &lt;code&gt;ANALYZE&lt;/code&gt; (or &lt;code&gt;VACUUM ANALYZE&lt;/code&gt;) ensures that the planner has up-to-date statistics about the table. With no statistics or obsolete statistics, the planner might make poor decisions during query planning, leading to poor performance on any tables with inaccurate or nonexistent statistics. Note that if the autovacuum daemon is enabled, it might run &lt;code&gt;ANALYZE&lt;/code&gt; automatically; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">Всякий раз, когда вы значительно изменили распределение данных в таблице, настоятельно рекомендуется запустить &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; . Это включает массовую загрузку больших объемов данных в таблицу. Запуск &lt;code&gt;ANALYZE&lt;/code&gt; (или &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; ) гарантирует, что у планировщика будет актуальная статистика по таблице. Без статистики или устаревшей статистики планировщик может принять неверные решения во время планирования запроса, что приведет к снижению производительности любых таблиц с неточной или несуществующей статистикой. Обратите внимание, что если включен демон автоочистки, он может запускать &lt;code&gt;ANALYZE&lt;/code&gt; автоматически; см. &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Раздел 24.1.3&lt;/a&gt; и &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Раздел 24.1.6&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="70267c330cb08a0ff5a2a298e316262a59a144c4" translate="yes" xml:space="preserve">
          <source>Where interoperability with other systems is a concern, for some data types, it may be necessary to use data type formatting functions (such as those in &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;) explicitly to produce the standard mappings.</source>
          <target state="translated">Если взаимодействие с другими системами является проблемой, для некоторых типов данных может потребоваться явное использование функций форматирования типов данных (например, в &lt;a href=&quot;functions-formatting&quot;&gt;Разделе 9.8&lt;/a&gt; ) для создания стандартных отображений.</target>
        </trans-unit>
        <trans-unit id="de87765a2f74958f3598da9f1ae5cd4df124304a" translate="yes" xml:space="preserve">
          <source>Where the command omits database name, user, host, or port, the new connection can reuse values from the previous connection. By default, values from the previous connection are reused except when processing a &lt;code&gt;conninfo&lt;/code&gt; string. Passing a first argument of &lt;code&gt;-reuse-previous=on&lt;/code&gt; or &lt;code&gt;-reuse-previous=off&lt;/code&gt; overrides that default. When the command neither specifies nor reuses a particular parameter, the libpq default is used. Specifying any of &lt;code&gt;dbname&lt;/code&gt;, &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; as &lt;code&gt;-&lt;/code&gt; is equivalent to omitting that parameter. If &lt;code&gt;hostaddr&lt;/code&gt; was specified in the original connection's &lt;code&gt;conninfo&lt;/code&gt;, that address is reused for the new connection (disregarding any other host specification).</source>
          <target state="translated">Если команда опускает имя базы данных, пользователя, хост или порт, новое соединение может повторно использовать значения из предыдущего соединения. По умолчанию повторно используются значения из предыдущего соединения, за исключением обработки строки &lt;code&gt;conninfo&lt;/code&gt; . Передача первого аргумента &lt;code&gt;-reuse-previous=on&lt;/code&gt; или &lt;code&gt;-reuse-previous=off&lt;/code&gt; отменяет это значение по умолчанию. Если команда не задает и не повторно использует конкретный параметр, используется значение по умолчанию libpq. Указание любого из &lt;code&gt;dbname&lt;/code&gt; , &lt;code&gt;username&lt;/code&gt; , &lt;code&gt;host&lt;/code&gt; или &lt;code&gt;port&lt;/code&gt; as &lt;code&gt;-&lt;/code&gt; эквивалентно пропуску этого параметра. Если &lt;code&gt;hostaddr&lt;/code&gt; был указан в &lt;code&gt;conninfo&lt;/code&gt; исходного соединения, этот адрес повторно используется для нового соединения (без учета любой другой спецификации хоста).</target>
        </trans-unit>
        <trans-unit id="f9b1968453a400f5fd07425f7b52ed24d9c6b52b" translate="yes" xml:space="preserve">
          <source>Where the current standard provides a family of XML data types to hold &amp;ldquo;document&amp;rdquo; or &amp;ldquo;content&amp;rdquo; in untyped or XML Schema-typed variants, and a type &lt;code&gt;XML(SEQUENCE)&lt;/code&gt; to hold arbitrary pieces of XML content, PostgreSQL provides the single &lt;code&gt;xml&lt;/code&gt; type, which can hold &amp;ldquo;document&amp;rdquo; or &amp;ldquo;content&amp;rdquo;. There is no equivalent of the standard's &amp;ldquo;sequence&amp;rdquo; type.</source>
          <target state="translated">В то время как текущий стандарт предоставляет семейство типов данных XML для хранения &amp;laquo;документа&amp;raquo; или &amp;laquo;содержимого&amp;raquo; в нетипизированных вариантах или вариантах, типизированных для схемы XML, и тип &lt;code&gt;XML(SEQUENCE)&lt;/code&gt; для хранения произвольных фрагментов содержимого XML, PostgreSQL предоставляет единственный тип &lt;code&gt;xml&lt;/code&gt; , который может содержать &amp;laquo;документ&amp;raquo; или &amp;laquo;контент&amp;raquo;. Не существует эквивалента стандартного типа &amp;laquo;последовательность&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9be0ce89e49423198dedc7c03fd710b9a77c7468" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;pgstattuple&lt;/code&gt; always performs a full-table scan and returns an exact count of live and dead tuples (and their sizes) and free space, &lt;code&gt;pgstattuple_approx&lt;/code&gt; tries to avoid the full-table scan and returns exact dead tuple statistics along with an approximation of the number and size of live tuples and free space.</source>
          <target state="translated">В то время как &lt;code&gt;pgstattuple&lt;/code&gt; всегда выполняет сканирование всей таблицы и возвращает точное количество живых и мертвых кортежей (и их размеры), а также свободное пространство, &lt;code&gt;pgstattuple_approx&lt;/code&gt; пытается избежать сканирования всей таблицы и возвращает точную статистику мертвых кортежей вместе с приблизительным количеством размер живых кортежей и свободного места.</target>
        </trans-unit>
        <trans-unit id="9ec341d8bc6b0b4825eb80f0ff91c4f3ae8eee3b" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;aggfinalfn&lt;/code&gt; modifies the transition state value: &lt;code&gt;r&lt;/code&gt; if it is read-only, &lt;code&gt;s&lt;/code&gt; if the &lt;code&gt;aggtransfn&lt;/code&gt; cannot be applied after the &lt;code&gt;aggfinalfn&lt;/code&gt;, or &lt;code&gt;w&lt;/code&gt; if it writes on the value</source>
          <target state="translated">&lt;code&gt;aggfinalfn&lt;/code&gt; ли aggfinalfn значение переходного состояния: &lt;code&gt;r&lt;/code&gt; , если он &lt;code&gt;aggtransfn&lt;/code&gt; только для чтения, &lt;code&gt;s&lt;/code&gt; , если agtransfn не может быть применен после &lt;code&gt;aggfinalfn&lt;/code&gt; , или &lt;code&gt;w&lt;/code&gt; , если он записывает значение</target>
        </trans-unit>
        <trans-unit id="b63ddfd6a1548ba35d00a888f441158a5e09419b" translate="yes" xml:space="preserve">
          <source>Whether an RE is greedy or not is determined by the following rules:</source>
          <target state="translated">Является ли РЭ жадным или нет,определяется следующими правилами:</target>
        </trans-unit>
        <trans-unit id="a052d21cc109877e0a34f6fceb8177147b8e054e" translate="yes" xml:space="preserve">
          <source>Whether the sequence cycles</source>
          <target state="translated">Циклы последовательности</target>
        </trans-unit>
        <trans-unit id="099ca603e257bb42c8d0080a36e8a200732df4c1" translate="yes" xml:space="preserve">
          <source>Whether to convert &lt;code&gt;\n&lt;/code&gt; into &lt;code&gt;\r\n&lt;/code&gt; when encrypting and &lt;code&gt;\r\n&lt;/code&gt; to &lt;code&gt;\n&lt;/code&gt; when decrypting. RFC 4880 specifies that text data should be stored using &lt;code&gt;\r\n&lt;/code&gt; line-feeds. Use this to get fully RFC-compliant behavior.</source>
          <target state="translated">Преобразовывать ли &lt;code&gt;\n&lt;/code&gt; в &lt;code&gt;\r\n&lt;/code&gt; при шифровании и &lt;code&gt;\r\n&lt;/code&gt; в &lt;code&gt;\n&lt;/code&gt; при дешифровании. RFC 4880 указывает, что текстовые данные должны храниться с использованием &lt;code&gt;\r\n&lt;/code&gt; строки. Используйте это, чтобы получить поведение, полностью совместимое с RFC.</target>
        </trans-unit>
        <trans-unit id="6a913bec72a9d1cd9190d3ca3274a90d4c381b09" translate="yes" xml:space="preserve">
          <source>Whether to convert textual data from database internal encoding to UTF-8 and back. If your database already is UTF-8, no conversion will be done, but the message will be tagged as UTF-8. Without this option it will not be.</source>
          <target state="translated">Преобразовывать ли текстовые данные из внутренней кодировки БД в UTF-8 и обратно.Если ваша база данных уже имеет кодировку UTF-8,преобразование не будет выполнено,но сообщение будет помечено как UTF-8.Без этой опции это не будет сделано.</target>
        </trans-unit>
        <trans-unit id="5d0908bbd26e431175b3928caa067e2b55410af7" translate="yes" xml:space="preserve">
          <source>Which S2K algorithm to use.</source>
          <target state="translated">Какой S2K алгоритм использовать.</target>
        </trans-unit>
        <trans-unit id="1b435ac17c99f4ed78933b5d05d5b47d3dfdd820" translate="yes" xml:space="preserve">
          <source>Which cipher algorithm to use.</source>
          <target state="translated">Какой алгоритм шифрования использовать.</target>
        </trans-unit>
        <trans-unit id="4215d6c5a786cf08cc1b93732554ac25c2ba7716" translate="yes" xml:space="preserve">
          <source>Which cipher to use for encrypting separate session key.</source>
          <target state="translated">Какой шифр использовать для шифрования отдельного ключа сеанса.</target>
        </trans-unit>
        <trans-unit id="8c9643312802b96a36d211d4bd8a2d4fbec5df7d" translate="yes" xml:space="preserve">
          <source>Which compression algorithm to use. Only available if PostgreSQL was built with zlib.</source>
          <target state="translated">Какой алгоритм компрессии использовать.Доступен только в том случае,если PostgreSQL был построен с использованием zlib.</target>
        </trans-unit>
        <trans-unit id="36178694d36e0d8b9b4d6953d14f4cb84f698946" translate="yes" xml:space="preserve">
          <source>Which digest algorithm to use in S2K calculation.</source>
          <target state="translated">Какой алгоритм дайджеста использовать при расчете S2K.</target>
        </trans-unit>
        <trans-unit id="5b9d8c9d7eb5636216a755086b48fa5a8cd067ff" translate="yes" xml:space="preserve">
          <source>Which one of these you use is mainly a matter of style. The &lt;code&gt;JOIN&lt;/code&gt; syntax in the &lt;code&gt;FROM&lt;/code&gt; clause is probably not as portable to other SQL database management systems, even though it is in the SQL standard. For outer joins there is no choice: they must be done in the &lt;code&gt;FROM&lt;/code&gt; clause. The &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;USING&lt;/code&gt; clause of an outer join is &lt;em&gt;not&lt;/em&gt; equivalent to a &lt;code&gt;WHERE&lt;/code&gt; condition, because it results in the addition of rows (for unmatched input rows) as well as the removal of rows in the final result.</source>
          <target state="translated">Какой из них вы будете использовать, в основном вопрос стиля. &lt;code&gt;JOIN&lt;/code&gt; синтаксис в &lt;code&gt;FROM&lt;/code&gt; статьи, вероятно , не как для других систем управления базами данных SQL, несмотря на то, что в стандарте SQL. Для внешних соединений нет выбора: они должны выполняться в предложении &lt;code&gt;FROM&lt;/code&gt; . Предложение &lt;code&gt;ON&lt;/code&gt; или &lt;code&gt;USING&lt;/code&gt; внешнего соединения &lt;em&gt;не&lt;/em&gt; эквивалентно условию &lt;code&gt;WHERE&lt;/code&gt; , поскольку оно приводит к добавлению строк (для несопоставленных входных строк), а также к удалению строк в окончательном результате.</target>
        </trans-unit>
        <trans-unit id="f207dff92fd241726ec3f780d5ff085d75648337" translate="yes" xml:space="preserve">
          <source>Which particular operators exist and whether they are unary or binary depends on what operators have been defined by the system or the user. &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt; describes the built-in operators.</source>
          <target state="translated">Какие именно операторы существуют и являются ли они унарными или двоичными, зависит от того, какие операторы были определены системой или пользователем. &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;В главе 9&lt;/a&gt; описаны встроенные операторы.</target>
        </trans-unit>
        <trans-unit id="6b60d8de1898a75db9c84423bdbee981b013228e" translate="yes" xml:space="preserve">
          <source>Which particular operators exist and whether they are unary or binary depends on what operators have been defined by the system or the user. &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt; describes the built-in operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8189028b5d12d59cd50147d702e5a513253a68c3" translate="yes" xml:space="preserve">
          <source>Which row(s) to update</source>
          <target state="translated">Какие строки обновить</target>
        </trans-unit>
        <trans-unit id="a8a5e55dc1620d200691892efc7a7c676cbd8264" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;CREATE INDEX&lt;/code&gt; with the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option supports parallel builds without special restrictions, only the first table scan is actually performed in parallel.</source>
          <target state="translated">Хотя &lt;code&gt;CREATE INDEX&lt;/code&gt; с параметром &lt;code&gt;CONCURRENTLY&lt;/code&gt; поддерживает параллельную сборку без особых ограничений, фактически параллельно выполняется только первое сканирование таблицы.</target>
        </trans-unit>
        <trans-unit id="714b73638a1ef948dee8dfe7820683df70955357" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;UNIQUE&lt;/code&gt; is a natural constraint for scalar values, it is usually unsuitable for range types. Instead, an exclusion constraint is often more appropriate (see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;CREATE TABLE ... CONSTRAINT ... EXCLUDE&lt;/a&gt;). Exclusion constraints allow the specification of constraints such as &amp;ldquo;non-overlapping&amp;rdquo; on a range type. For example:</source>
          <target state="translated">Хотя &lt;code&gt;UNIQUE&lt;/code&gt; является естественным ограничением для скалярных значений, обычно оно не подходит для типов диапазона. Вместо этого часто более подходящим является ограничение исключения (см. &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;CREATE TABLE ... CONSTRAINT ... EXCLUDE&lt;/a&gt; ). Ограничения исключения позволяют специфицировать такие ограничения, как &amp;laquo;неперекрытие&amp;raquo; для типа диапазона. Например:</target>
        </trans-unit>
        <trans-unit id="4a9577e86cf0dfccc12f0ecf60188a3b6040e454" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;pg_resetwal&lt;/code&gt; will set the WAL starting address beyond the latest existing WAL segment file, some segment size changes can cause previous WAL file names to be reused. It is recommended to use &lt;code&gt;-l&lt;/code&gt; together with this option to manually set the WAL starting address if WAL file name overlap will cause problems with your archiving strategy.</source>
          <target state="translated">Хотя &lt;code&gt;pg_resetwal&lt;/code&gt; устанавливает начальный адрес WAL за пределами последнего существующего файла сегмента WAL, некоторые изменения размера сегмента могут привести к повторному использованию предыдущих имен файлов WAL. Рекомендуется использовать &lt;code&gt;-l&lt;/code&gt; вместе с этой опцией, чтобы вручную установить начальный адрес WAL, если перекрытие имен файлов WAL вызовет проблемы с вашей стратегией архивирования.</target>
        </trans-unit>
        <trans-unit id="01708a73847573f321d3d2da0f455cb9f949df75" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;to_date&lt;/code&gt; will reject a mixture of Gregorian and ISO week-numbering date fields, &lt;code&gt;to_char&lt;/code&gt; will not, since output format specifications like &lt;code&gt;YYYY-MM-DD (IYYY-IDDD)&lt;/code&gt; can be useful. But avoid writing something like &lt;code&gt;IYYY-MM-DD&lt;/code&gt;; that would yield surprising results near the start of the year. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt; for more information.)</source>
          <target state="translated">В то время как &lt;code&gt;to_date&lt;/code&gt; отклоняет сочетание полей даты с нумерацией недель по григорианскому и ISO, &lt;code&gt;to_char&lt;/code&gt; - нет, поскольку могут быть полезны спецификации формата вывода, такие как &lt;code&gt;YYYY-MM-DD (IYYY-IDDD)&lt;/code&gt; . Но избегайте написания чего-то вроде &lt;code&gt;IYYY-MM-DD&lt;/code&gt; ; это даст удивительные результаты к началу года. ( За дополнительными сведениями &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;обратитесь&lt;/a&gt; к Разделу 9.9.1 .)</target>
        </trans-unit>
        <trans-unit id="e362e9f328b5aa2d887a4c59191ea1b7f9721dc4" translate="yes" xml:space="preserve">
          <source>While C-style block comments are passed to the server for processing and removal, SQL-standard comments are removed by psql.</source>
          <target state="translated">В то время как комментарии к блокам в стиле C передаются на сервер для обработки и удаления,комментарии по стандарту SQL удаляются с помощью psql.</target>
        </trans-unit>
        <trans-unit id="5d725442e0975d9459afb2abfae7302730928d6f" translate="yes" xml:space="preserve">
          <source>While PostgreSQL's Serializable transaction isolation level only allows concurrent transactions to commit if it can prove there is a serial order of execution that would produce the same effect, it doesn't always prevent errors from being raised that would not occur in true serial execution. In particular, it is possible to see unique constraint violations caused by conflicts with overlapping Serializable transactions even after explicitly checking that the key isn't present before attempting to insert it. This can be avoided by making sure that &lt;em&gt;all&lt;/em&gt; Serializable transactions that insert potentially conflicting keys explicitly check if they can do so first. For example, imagine an application that asks the user for a new key and then checks that it doesn't exist already by trying to select it first, or generates a new key by selecting the maximum existing key and adding one. If some Serializable transactions insert new keys directly without following this protocol, unique constraints violations might be reported even in cases where they could not occur in a serial execution of the concurrent transactions.</source>
          <target state="translated">Хотя уровень изоляции транзакций PostgreSQL Serializable позволяет выполнять фиксацию одновременных транзакций только в том случае, если он может доказать, что существует последовательный порядок выполнения, который дает такой же эффект, он не всегда предотвращает возникновение ошибок, которые не возникли бы при истинном последовательном выполнении. В частности, можно увидеть нарушения уникальных ограничений, вызванные конфликтами с перекрывающимися сериализуемыми транзакциями, даже после явной проверки отсутствия ключа перед попыткой его вставки. Этого можно избежать, убедившись, что &lt;em&gt;все&lt;/em&gt;Сериализуемые транзакции, которые вставляют потенциально конфликтующие ключи, сначала явно проверяют, могут ли они это сделать. Например, представьте себе приложение, которое запрашивает у пользователя новый ключ, а затем проверяет, что он еще не существует, пытаясь сначала выбрать его, или генерирует новый ключ, выбирая максимальный существующий ключ и добавляя его. Если некоторые сериализуемые транзакции вставляют новые ключи напрямую, не следуя этому протоколу, нарушения уникальных ограничений могут сообщаться даже в тех случаях, когда они не могут произойти при последовательном выполнении параллельных транзакций.</target>
        </trans-unit>
        <trans-unit id="594dab457c5441b59c42227020751df6f6f62a48" translate="yes" xml:space="preserve">
          <source>While XQuery/XPath provides all of the types defined in XML Schema and many operators and functions over those types, XPath 1.0 has only node-sets and the three atomic types &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">В то время как XQuery / XPath предоставляет все типы, определенные в XML-схеме, а также множество операторов и функций для этих типов, XPath 1.0 имеет только наборы узлов и три атомарных типа: &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; и &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a627fd0ca096f765ec57a0f53e97d18839b3a4e" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;LIKE&lt;/code&gt; clause exists in the SQL standard, many of the options that PostgreSQL accepts for it are not in the standard, and some of the standard's options are not implemented by PostgreSQL.</source>
          <target state="translated">Хотя предложение &lt;code&gt;LIKE&lt;/code&gt; существует в стандарте SQL, многие параметры, которые PostgreSQL принимает для него, отсутствуют в стандарте, а некоторые параметры стандарта PostgreSQL не реализованы.</target>
        </trans-unit>
        <trans-unit id="bcdd2fd3f430f1ca01d2b3670c0f594bdee786bb" translate="yes" xml:space="preserve">
          <source>While a Repeatable Read transaction has a stable view of the data throughout its execution, there is a subtle issue with using MVCC snapshots for data consistency checks, involving something known as &lt;em&gt;read/write conflicts&lt;/em&gt;. If one transaction writes data and a concurrent transaction attempts to read the same data (whether before or after the write), it cannot see the work of the other transaction. The reader then appears to have executed first regardless of which started first or which committed first. If that is as far as it goes, there is no problem, but if the reader also writes data which is read by a concurrent transaction there is now a transaction which appears to have run before either of the previously mentioned transactions. If the transaction which appears to have executed last actually commits first, it is very easy for a cycle to appear in a graph of the order of execution of the transactions. When such a cycle appears, integrity checks will not work correctly without some help.</source>
          <target state="translated">Хотя транзакция с повторяющимся чтением имеет стабильное представление данных на протяжении всего выполнения, существует тонкая проблема с использованием моментальных снимков MVCC для проверки согласованности данных, включая так называемые &lt;em&gt;конфликты чтения / записи.&lt;/em&gt;. Если одна транзакция записывает данные, а параллельная транзакция пытается прочитать одни и те же данные (до или после записи), она не может видеть работу другой транзакции. Таким образом, читатель, кажется, выполнил первым, независимо от того, какой из них был запущен первым, а какой совершил первым. Если это так, то проблем нет, но если считыватель также записывает данные, которые считываются параллельной транзакцией, теперь есть транзакция, которая, по-видимому, была запущена до любой из ранее упомянутых транзакций. Если транзакция, которая казалась выполненной последней, на самом деле фиксируется первой, цикл очень легко отобразится на графике порядка выполнения транзакций. Когда появляется такой цикл, без посторонней помощи проверки целостности работать не будут.</target>
        </trans-unit>
        <trans-unit id="6a87fa7f9afe44920c1e825c81201c0429df3a1c" translate="yes" xml:space="preserve">
          <source>While a self-signed certificate can be used for testing, a certificate signed by a certificate authority (CA) (usually an enterprise-wide root CA) should be used in production.</source>
          <target state="translated">В то время как для тестирования можно использовать самоподписанный сертификат,в производстве следует использовать сертификат,подписанный центром сертификации (certificate authority-CA)(обычно это корневой центр сертификации по всему предприятию).</target>
        </trans-unit>
        <trans-unit id="cdc31b216171332e350cb9df34dfb0418ab3630e" translate="yes" xml:space="preserve">
          <source>While designing your archiving setup, consider what will happen if the archive command fails repeatedly because some aspect requires operator intervention or the archive runs out of space. For example, this could occur if you write to tape without an autochanger; when the tape fills, nothing further can be archived until the tape is swapped. You should ensure that any error condition or request to a human operator is reported appropriately so that the situation can be resolved reasonably quickly. The &lt;code&gt;pg_wal/&lt;/code&gt; directory will continue to fill with WAL segment files until the situation is resolved. (If the file system containing &lt;code&gt;pg_wal/&lt;/code&gt; fills up, PostgreSQL will do a PANIC shutdown. No committed transactions will be lost, but the database will remain offline until you free some space.)</source>
          <target state="translated">При проектировании настройки архивирования подумайте, что произойдет, если команда архивирования неоднократно терпит неудачу, потому что какой-то аспект требует вмешательства оператора или в архиве заканчивается место. Например, это могло произойти, если вы записываете на ленту без авточейнджера; когда лента заполняется, ничего больше нельзя архивировать, пока лента не будет заменена местами. Вы должны убедиться, что о любом состоянии ошибки или запросе оператору сообщается надлежащим образом, чтобы ситуация могла быть разрешена достаточно быстро. &lt;code&gt;pg_wal/&lt;/code&gt; каталог будет продолжать наполняться файлы сегмента WAL , пока ситуация не будет решена. (Если файловая система, содержащая &lt;code&gt;pg_wal/&lt;/code&gt; заполнится, PostgreSQL выполнит PANIC-завершение. Никакие зафиксированные транзакции не будут потеряны, но база данных останется в автономном режиме, пока вы не освободите место.)</target>
        </trans-unit>
        <trans-unit id="ed48d255fcc854a30e92ea66bfc2714ea9b2abf4" translate="yes" xml:space="preserve">
          <source>While forcing data to the disk platters periodically might seem like a simple operation, it is not. Because disk drives are dramatically slower than main memory and CPUs, several layers of caching exist between the computer's main memory and the disk platters. First, there is the operating system's buffer cache, which caches frequently requested disk blocks and combines disk writes. Fortunately, all operating systems give applications a way to force writes from the buffer cache to disk, and PostgreSQL uses those features. (See the &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt; parameter to adjust how this is done.)</source>
          <target state="translated">Хотя принудительное размещение данных на дисках периодически может показаться простой операцией, это не так. Поскольку дисковые накопители значительно медленнее, чем основная память и процессоры, между основной памятью компьютера и дисковыми пластинами существует несколько уровней кэширования. Во-первых, это буферный кеш операционной системы, который кэширует часто запрашиваемые блоки диска и объединяет операции записи на диск. К счастью, все операционные системы предоставляют приложениям способ принудительной записи из буферного кеша на диск, и PostgreSQL использует эти возможности. (См. Параметр &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method,&lt;/a&gt; чтобы настроить, как это делается.)</target>
        </trans-unit>
        <trans-unit id="ae2f9725af5b866105aef02d826c3c21674b82a5" translate="yes" xml:space="preserve">
          <source>While it is possible to obtain information about which processes block which other processes by joining &lt;code&gt;pg_locks&lt;/code&gt; against itself, this is very difficult to get right in detail. Such a query would have to encode knowledge about which lock modes conflict with which others. Worse, the &lt;code&gt;pg_locks&lt;/code&gt; view does not expose information about which processes are ahead of which others in lock wait queues, nor information about which processes are parallel workers running on behalf of which other client sessions. It is better to use the &lt;code&gt;pg_blocking_pids()&lt;/code&gt; function (see &lt;a href=&quot;functions-info#FUNCTIONS-INFO-SESSION-TABLE&quot;&gt;Table 9.63&lt;/a&gt;) to identify which process(es) a waiting process is blocked behind.</source>
          <target state="translated">Хотя можно получить информацию о том, какие процессы блокируют другие процессы, объединив &lt;code&gt;pg_locks&lt;/code&gt; против самого себя, это очень сложно получить в деталях. Такой запрос должен закодировать информацию о том, какие режимы блокировки конфликтуют с другими. Хуже того, представление &lt;code&gt;pg_locks&lt;/code&gt; не предоставляет информацию о том, какие процессы опережают другие в очередях ожидания блокировки, а также информацию о том, какие процессы являются параллельными рабочими процессами, выполняющимися от имени каких других клиентских сеансов. Лучше использовать &lt;code&gt;pg_blocking_pids()&lt;/code&gt; (см. &lt;a href=&quot;functions-info#FUNCTIONS-INFO-SESSION-TABLE&quot;&gt;Таблицу 9.63&lt;/a&gt; ), чтобы определить, какой процесс (а) ожидающий процесс заблокирован.</target>
        </trans-unit>
        <trans-unit id="17d114999ab92dc3c41f0deae7314e26f77d91d6" translate="yes" xml:space="preserve">
          <source>While most regular-expression searches can be executed very quickly, regular expressions can be contrived that take arbitrary amounts of time and memory to process. Be wary of accepting regular-expression search patterns from hostile sources. If you must do so, it is advisable to impose a statement timeout.</source>
          <target state="translated">В то время как большинство поисков регулярных выражений может быть выполнено очень быстро,можно придумать регулярные выражения,для обработки которых требуется произвольное количество времени и памяти.Остерегайтесь принимать шаблоны поиска регулярных выражений из враждебных источников.В этом случае рекомендуется установить тайм-аут для выражений.</target>
        </trans-unit>
        <trans-unit id="4544bbaee7531ef45a0e42c59e09a0908293364f" translate="yes" xml:space="preserve">
          <source>While most timezone abbreviations represent fixed offsets from UTC, there are some that have historically varied in value (see &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt; for more information). In such cases this view presents their current meaning.</source>
          <target state="translated">Хотя большинство сокращений часовых поясов представляют собой фиксированные смещения от всемирного координированного времени, некоторые из них исторически различались по значению ( дополнительную информацию см. В &lt;a href=&quot;datetime-config-files&quot;&gt;разделе B.4&lt;/a&gt; ). В таких случаях эта точка зрения представляет их текущее значение.</target>
        </trans-unit>
        <trans-unit id="eb000322f7d40100b6e53cb7562cee4c2935cc07" translate="yes" xml:space="preserve">
          <source>While multiple databases can be created within a single cluster, it is advised to consider carefully whether the benefits outweigh the risks and limitations. In particular, the impact that having a shared WAL (see &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;Chapter 29&lt;/a&gt;) has on backup and recovery options. While individual databases in the cluster are isolated when considered from the user's perspective, they are closely bound from the database administrator's point-of-view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e20acb9a4d1b2d1994838c4133180e7c30312a" translate="yes" xml:space="preserve">
          <source>While not required, it is recommended that you continue to follow this old convention of naming cast implementation functions after the target data type. Many users are used to being able to cast data types using a function-style notation, that is &lt;code&gt;typename&lt;/code&gt;(&lt;code&gt;x&lt;/code&gt;). This notation is in fact nothing more nor less than a call of the cast implementation function; it is not specially treated as a cast. If your conversion functions are not named to support this convention then you will have surprised users. Since PostgreSQL allows overloading of the same function name with different argument types, there is no difficulty in having multiple conversion functions from different types that all use the target type's name.</source>
          <target state="translated">Хотя это и не обязательно, рекомендуется продолжать следовать этому старому соглашению об именовании функций реализации приведения после целевого типа данных. Многие пользователи привыкли приводить типы данных с использованием нотации в стиле функции, то есть &lt;code&gt;typename&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; ). Эта запись на самом деле является не чем иным, как вызовом функции реализации приведения; он специально не рассматривается как гипс. Если ваши функции преобразования не названы так, чтобы поддерживать это соглашение, вы удивите пользователей. Поскольку PostgreSQL допускает перегрузку одного и того же имени функции с разными типами аргументов, нетрудно получить несколько функций преобразования из разных типов, которые все используют имя целевого типа.</target>
        </trans-unit>
        <trans-unit id="9e3fedf4b54ce85919b4142394d398f5b611a696" translate="yes" xml:space="preserve">
          <source>While policies will be applied for explicit queries against tables in the database, they are not applied when the system is performing internal referential integrity checks or validating constraints. This means there are indirect ways to determine that a given value exists. An example of this is attempting to insert a duplicate value into a column that is a primary key or has a unique constraint. If the insert fails then the user can infer that the value already exists. (This example assumes that the user is permitted by policy to insert records which they are not allowed to see.) Another example is where a user is allowed to insert into a table which references another, otherwise hidden table. Existence can be determined by the user inserting values into the referencing table, where success would indicate that the value exists in the referenced table. These issues can be addressed by carefully crafting policies to prevent users from being able to insert, delete, or update records at all which might possibly indicate a value they are not otherwise able to see, or by using generated values (e.g., surrogate keys) instead of keys with external meanings.</source>
          <target state="translated">Хотя политики будут применяться для явных запросов к таблицам в базе данных,они не применяются,когда система выполняет внутреннюю проверку ссылочной целостности или валидацию ограничений.Это означает,что существуют косвенные способы определить существование заданного значения.Примером этого является попытка вставить дублирующее значение в столбец,который является первичным ключом или имеет уникальное ограничение.Если вставка не удается,то пользователь может сделать вывод,что значение уже существует.(Этот пример предполагает,что пользователю разрешено политикой вставлять записи,которые он не имеет права видеть).Другим примером является то,что пользователю разрешено вставлять записи в таблицу,которая ссылается на другую,в противном случае скрытую,таблицу.Существование может быть определено путем вставки пользователем значений в таблицу ссылок,где успех будет означать,что значение существует в таблице ссылок.Эти проблемы могут быть решены путем тщательной разработки политики,не позволяющей пользователям вставлять,удалять или обновлять записи вообще,которые могут указывать на значение,которое они иначе не смогут увидеть,или путем использования сгенерированных значений (например,суррогатных ключей)вместо ключей с внешними значениями.</target>
        </trans-unit>
        <trans-unit id="5fbe4c0896d37fe14f081d1ac25be59617f075b0" translate="yes" xml:space="preserve">
          <source>While recovery is paused no further database changes are applied. If in hot standby, all new queries will see the same consistent snapshot of the database, and no further query conflicts will be generated until recovery is resumed.</source>
          <target state="translated">Во время паузы восстановления больше никаких изменений в базе данных не происходит.Если все новые запросы находятся в горячем режиме ожидания,то все новые запросы будут видеть один и тот же последовательный снимок базы данных,и никаких дальнейших конфликтов запросов не будет генерироваться до тех пор,пока восстановление не будет возобновлено.</target>
        </trans-unit>
        <trans-unit id="67bee53c255823e86d8c23b4190b410627254abc" translate="yes" xml:space="preserve">
          <source>While rows can be moved from local partitions to a foreign-table partition (provided the foreign data wrapper supports tuple routing), they cannot be moved from a foreign-table partition to another partition.</source>
          <target state="translated">В то время как строки можно перемещать с локальных разделов на посторонний раздел (при условии,что посторонняя обёртка данных поддерживает маршрутизацию кортежей),их нельзя перемещать с постороннего раздела на другой раздел.</target>
        </trans-unit>
        <trans-unit id="7158e641e335f398bdfc35c274f36a1760cfa0bc" translate="yes" xml:space="preserve">
          <source>While running pg_dump, one should examine the output for any warnings (printed on standard error), especially in light of the limitations listed below.</source>
          <target state="translated">При запуске pg_dump следует проверять вывод на наличие любых предупреждений (распечатанных по стандартной ошибке),особенно в свете ограничений,перечисленных ниже.</target>
        </trans-unit>
        <trans-unit id="891b0584891eb2794e238a1971ed31f1c215e841" translate="yes" xml:space="preserve">
          <source>While that doesn't look all that bad by itself, it's still oversimplified. A far more complicated sub-select would be needed to select the right OID if there are multiple tables named &lt;code&gt;mytable&lt;/code&gt; in different schemas. The &lt;code&gt;regclass&lt;/code&gt; input converter handles the table lookup according to the schema path setting, and so it does the &amp;ldquo;right thing&amp;rdquo; automatically. Similarly, casting a table's OID to &lt;code&gt;regclass&lt;/code&gt; is handy for symbolic display of a numeric OID.</source>
          <target state="translated">Хотя это само по себе выглядит не так уж плохо, все же это упрощено. Если есть несколько таблиц с именем &lt;code&gt;mytable&lt;/code&gt; в разных схемах, потребуется гораздо более сложный подвыбор, чтобы выбрать правильный OID . &lt;code&gt;regclass&lt;/code&gt; входной преобразователь управляет поиском таблицы в соответствии с настройкой пути схемы, и поэтому он делает &amp;laquo;правильно&amp;raquo; автоматически. Точно так же &lt;code&gt;regclass&lt;/code&gt; OID таблицы в regclass удобно для символьного отображения числового OID.</target>
        </trans-unit>
        <trans-unit id="d982cd814f64616912cda4d88166e9a69d28b85b" translate="yes" xml:space="preserve">
          <source>While that particular example might seem silly, related cases that don't obviously involve constants can occur in queries executed within functions, since the values of function arguments and local variables can be inserted into queries as constants for planning purposes. Within PL/pgSQL functions, for example, using an &lt;code&gt;IF&lt;/code&gt;-&lt;code&gt;THEN&lt;/code&gt;-&lt;code&gt;ELSE&lt;/code&gt; statement to protect a risky computation is much safer than just nesting it in a &lt;code&gt;CASE&lt;/code&gt; expression.</source>
          <target state="translated">Хотя этот конкретный пример может показаться глупым, связанные случаи, которые явно не связаны с константами, могут возникать в запросах, выполняемых внутри функций, поскольку значения аргументов функции и локальных переменных могут быть вставлены в запросы как константы для целей планирования. В функциях PL / pgSQL, например, использование оператора &lt;code&gt;IF&lt;/code&gt; - &lt;code&gt;THEN&lt;/code&gt; - &lt;code&gt;ELSE&lt;/code&gt; для защиты рискованных вычислений намного безопаснее, чем просто вложение его в выражение &lt;code&gt;CASE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfcd6cf6959e988635a363ac7fbe48c4622cc9ea" translate="yes" xml:space="preserve">
          <source>While the built-in declarative partitioning is suitable for most common use cases, there are some circumstances where a more flexible approach may be useful. Partitioning can be implemented using table inheritance, which allows for several features not supported by declarative partitioning, such as:</source>
          <target state="translated">В то время как встроенное декларативное разбиение подходит для большинства распространенных случаев использования,есть некоторые обстоятельства,при которых более гибкий подход может быть полезен.Разметка может быть реализована с помощью табличного наследования,что позволяет использовать несколько функций,не поддерживаемых декларативной разметкой,например:</target>
        </trans-unit>
        <trans-unit id="f761cf19de1d987297c4bdb87e576a9e8ef5e265" translate="yes" xml:space="preserve">
          <source>While the default index for future &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; operations is retained, &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; does not order the generated rows based on this property. If you want the data to be ordered upon generation, you must use an &lt;code&gt;ORDER BY&lt;/code&gt; clause in the backing query.</source>
          <target state="translated">Хотя индекс по умолчанию для будущих операций &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; сохраняется, &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; не упорядочивает сгенерированные строки на основе этого свойства. Если вы хотите, чтобы данные были упорядочены при генерации, вы должны использовать предложение &lt;code&gt;ORDER BY&lt;/code&gt; в запросе поддержки.</target>
        </trans-unit>
        <trans-unit id="89bb80c5dc369e5a7b8dcef839df901e5b397bf5" translate="yes" xml:space="preserve">
          <source>While the details of the new type's internal representation are only known to the I/O functions and other functions you create to work with the type, there are several properties of the internal representation that must be declared to PostgreSQL. Foremost of these is &lt;code&gt;internallength&lt;/code&gt;. Base data types can be fixed-length, in which case &lt;code&gt;internallength&lt;/code&gt; is a positive integer, or variable-length, indicated by setting &lt;code&gt;internallength&lt;/code&gt; to &lt;code&gt;VARIABLE&lt;/code&gt;. (Internally, this is represented by setting &lt;code&gt;typlen&lt;/code&gt; to -1.) The internal representation of all variable-length types must start with a 4-byte integer giving the total length of this value of the type. (Note that the length field is often encoded, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt;; it's unwise to access it directly.)</source>
          <target state="translated">Хотя детали внутреннего представления нового типа известны только функциям ввода-вывода и другим функциям, которые вы создаете для работы с типом, есть несколько свойств внутреннего представления, которые должны быть объявлены в PostgreSQL. Прежде всего, это &lt;code&gt;internallength&lt;/code&gt; . Базовые типы данных могут быть фиксированной длины, в этом случае &lt;code&gt;internallength&lt;/code&gt; является положительным целым числом, или переменной длины, указывается путем установки &lt;code&gt;internallength&lt;/code&gt; к &lt;code&gt;VARIABLE&lt;/code&gt; . (Внутренне это представлено установкой &lt;code&gt;typlen&lt;/code&gt; в -1.) Внутреннее представление всех типов переменной длины должно начинаться с 4-байтового целого числа, дающего общую длину этого значения типа. (Обратите внимание, что поле длины часто кодируется, как описано в&lt;a href=&quot;storage-toast&quot;&gt;Раздел 68.2&lt;/a&gt; ; неразумно обращаться к нему напрямую.)</target>
        </trans-unit>
        <trans-unit id="e2a6eda1b3f1244604b394ad1d7fc00d1fb05fef" translate="yes" xml:space="preserve">
          <source>While the example below uses a constant JSON value, typical use would be to reference a &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt; column laterally from another table in the query's &lt;code&gt;FROM&lt;/code&gt; clause. Writing &lt;code&gt;json_populate_record&lt;/code&gt; in the &lt;code&gt;FROM&lt;/code&gt; clause is good practice, since all of the extracted columns are available for use without duplicate function calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915068b5c9a0a4207ecd95ee0a72471b7e35a59c" translate="yes" xml:space="preserve">
          <source>While the examples for these functions use constants, the typical use would be to reference a table in the &lt;code&gt;FROM&lt;/code&gt; clause and use one of its &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt; columns as an argument to the function. Extracted key values can then be referenced in other parts of the query, like &lt;code&gt;WHERE&lt;/code&gt; clauses and target lists. Extracting multiple values in this way can improve performance over extracting them separately with per-key operators.</source>
          <target state="translated">Хотя в примерах для этих функций используются константы, типичным использованием будет ссылка на таблицу в предложении &lt;code&gt;FROM&lt;/code&gt; и использование одного из ее столбцов &lt;code&gt;json&lt;/code&gt; или &lt;code&gt;jsonb&lt;/code&gt; в качестве аргумента функции. Затем на извлеченные значения ключей можно ссылаться в других частях запроса, например в &lt;code&gt;WHERE&lt;/code&gt; и целевых списках. Такое извлечение нескольких значений может повысить производительность по сравнению с их раздельным извлечением с помощью операторов для каждого ключа.</target>
        </trans-unit>
        <trans-unit id="5c45fc673d90d93e24f91fea428d0f8a94bae39e" translate="yes" xml:space="preserve">
          <source>While the input strings &lt;code&gt;now&lt;/code&gt;, &lt;code&gt;today&lt;/code&gt;, &lt;code&gt;tomorrow&lt;/code&gt;, and &lt;code&gt;yesterday&lt;/code&gt; are fine to use in interactive SQL commands, they can have surprising behavior when the command is saved to be executed later, for example in prepared statements, views, and function definitions. The string can be converted to a specific time value that continues to be used long after it becomes stale. Use one of the SQL functions instead in such contexts. For example, &lt;code&gt;CURRENT_DATE + 1&lt;/code&gt; is safer than &lt;code&gt;'tomorrow'::date&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c09c1945f14d262f5a989a6b1b7f78a8869fb1b" translate="yes" xml:space="preserve">
          <source>While the server is running, it is not possible for a malicious user to take the place of the normal database server. However, when the server is down, it is possible for a local user to spoof the normal server by starting their own server. The spoof server could read passwords and queries sent by clients, but could not return any data because the &lt;code&gt;PGDATA&lt;/code&gt; directory would still be secure because of directory permissions. Spoofing is possible because any user can start a database server; a client cannot identify an invalid server unless it is specially configured.</source>
          <target state="translated">Пока сервер работает, злоумышленник не может заменить обычный сервер базы данных. Однако, когда сервер не работает, локальный пользователь может подделать обычный сервер, запустив свой собственный. Сервер подделки мог читать пароли и запросы, отправленные клиентами, но не мог возвращать никаких данных, потому что каталог &lt;code&gt;PGDATA&lt;/code&gt; все еще был бы безопасным из-за разрешений каталога. Спуфинг возможен, потому что любой пользователь может запустить сервер базы данных; клиент не может идентифицировать недопустимый сервер, если он не настроен специально.</target>
        </trans-unit>
        <trans-unit id="a8b90c7536148bdec5e290019a51b2379ecb8d63" translate="yes" xml:space="preserve">
          <source>While the server is running, its PID is stored in the file &lt;code&gt;postmaster.pid&lt;/code&gt; in the data directory. This is used to prevent multiple server instances from running in the same data directory and can also be used for shutting down the server.</source>
          <target state="translated">Пока сервер работает, его PID сохраняется в файле &lt;code&gt;postmaster.pid&lt;/code&gt; в каталоге данных. Это используется для предотвращения запуска нескольких экземпляров сервера в одном каталоге данных, а также может использоваться для выключения сервера.</target>
        </trans-unit>
        <trans-unit id="a03c807444bf3594110c4d388ec7b0a59f62a431" translate="yes" xml:space="preserve">
          <source>While the standard syntax for specifying string constants is usually convenient, it can be difficult to understand when the desired string contains many single quotes or backslashes, since each of those must be doubled. To allow more readable queries in such situations, PostgreSQL provides another way, called &amp;ldquo;dollar quoting&amp;rdquo;, to write string constants. A dollar-quoted string constant consists of a dollar sign (&lt;code&gt;$&lt;/code&gt;), an optional &amp;ldquo;tag&amp;rdquo; of zero or more characters, another dollar sign, an arbitrary sequence of characters that makes up the string content, a dollar sign, the same tag that began this dollar quote, and a dollar sign. For example, here are two different ways to specify the string &amp;ldquo;Dianne's horse&amp;rdquo; using dollar quoting:</source>
          <target state="translated">Хотя стандартный синтаксис для указания строковых констант обычно удобен, бывает сложно понять, когда желаемая строка содержит много одинарных кавычек или обратных косых черт, поскольку каждая из них должна быть удвоена. Чтобы сделать запросы в таких ситуациях более удобочитаемыми, PostgreSQL предоставляет другой способ, называемый &amp;laquo;долларовые кавычки&amp;raquo;, для записи строковых констант. Строковая константа в кавычках в долларах состоит из знака доллара ( &lt;code&gt;$&lt;/code&gt; ), необязательного &amp;laquo;тега&amp;raquo; из нуля или более символов, другого знака доллара, произвольной последовательности символов, составляющих содержимое строки, знака доллара и того же тега, который началась эта долларовая цитата и знак доллара. Например, вот два разных способа указать строку &amp;laquo;Лошадь Дайанны&amp;raquo; с использованием долларовых кавычек:</target>
        </trans-unit>
        <trans-unit id="97a03d15b6274d3b06d93b14cfe041b66ef2af72" translate="yes" xml:space="preserve">
          <source>While this function is more complex than the single-month case, it doesn't need to be updated as often, since branches can be added in advance of being needed.</source>
          <target state="translated">Хотя эта функция более сложна,чем одномесячный случай,ее не нужно обновлять так часто,так как ветки можно добавлять заранее,до того,как они понадобятся.</target>
        </trans-unit>
        <trans-unit id="eb917c6d1ba7f34837342b8b023d8fdc99add536" translate="yes" xml:space="preserve">
          <source>While this is the only way to convert character strings into XML values according to the SQL standard, the PostgreSQL-specific syntaxes:</source>
          <target state="translated">Хотя это единственный способ преобразования символьных строк в XML-значения в соответствии со стандартом SQL,специфическим для PostgreSQL синтаксисом:</target>
        </trans-unit>
        <trans-unit id="13b118c29b5eac33252cf8f05a41900068035eae" translate="yes" xml:space="preserve">
          <source>While transition table names for &lt;code&gt;AFTER&lt;/code&gt; triggers are specified using the &lt;code&gt;REFERENCING&lt;/code&gt; clause in the standard way, the row variables used in &lt;code&gt;FOR EACH ROW&lt;/code&gt; triggers may not be specified in a &lt;code&gt;REFERENCING&lt;/code&gt; clause. They are available in a manner that is dependent on the language in which the trigger function is written, but is fixed for any one language. Some languages effectively behave as though there is a &lt;code&gt;REFERENCING&lt;/code&gt; clause containing &lt;code&gt;OLD ROW AS OLD NEW ROW AS NEW&lt;/code&gt;.</source>
          <target state="translated">Хотя имена таблиц переходов для триггеров &lt;code&gt;AFTER&lt;/code&gt; указываются с помощью предложения &lt;code&gt;REFERENCING&lt;/code&gt; стандартным способом, переменные строки, используемые в триггерах &lt;code&gt;FOR EACH ROW&lt;/code&gt; , не могут быть указаны в предложении &lt;code&gt;REFERENCING&lt;/code&gt; . Они доступны в зависимости от языка, на котором написана функция триггера, но являются фиксированными для любого языка. Некоторые языки эффективно ведут себя так, как если бы есть предложение &lt;code&gt;REFERENCING&lt;/code&gt; , содержащее &lt;code&gt;OLD ROW AS OLD NEW ROW AS NEW&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0775e3a82644839414e547fda3c53cda5989eee1" translate="yes" xml:space="preserve">
          <source>While turning off &lt;code&gt;fsync&lt;/code&gt; is often a performance benefit, this can result in unrecoverable data corruption in the event of a power failure or system crash. Thus it is only advisable to turn off &lt;code&gt;fsync&lt;/code&gt; if you can easily recreate your entire database from external data.</source>
          <target state="translated">Хотя отключение &lt;code&gt;fsync&lt;/code&gt; часто улучшает производительность, это может привести к безвозвратному повреждению данных в случае сбоя питания или сбоя системы. Таким образом, рекомендуется отключать &lt;code&gt;fsync&lt;/code&gt; только в том случае, если вы можете легко воссоздать всю базу данных из внешних данных.</target>
        </trans-unit>
        <trans-unit id="5d9f7345f5e4a9cecb1d3a73e9e82a30d0080279" translate="yes" xml:space="preserve">
          <source>White space (i.e., spaces, tabs, and newlines) can be used freely in SQL commands. That means you can type the command aligned differently than above, or even all on one line. Two dashes (&amp;ldquo;&lt;code&gt;--&lt;/code&gt;&amp;rdquo;) introduce comments. Whatever follows them is ignored up to the end of the line. SQL is case insensitive about key words and identifiers, except when identifiers are double-quoted to preserve the case (not done above).</source>
          <target state="translated">Пробелы (например, пробелы, табуляции и символы новой строки) можно свободно использовать в командах SQL. Это означает, что вы можете ввести команду, выровненную иначе, чем указано выше, или даже все в одной строке. Два тире (&amp;laquo; &lt;code&gt;--&lt;/code&gt; &amp;raquo;) обозначают комментарии. Все, что следует за ними, игнорируется до конца строки. SQL не чувствителен к регистру ключевых слов и идентификаторов, за исключением случаев, когда идентификаторы заключаются в двойные кавычки для сохранения регистра (не сделано выше).</target>
        </trans-unit>
        <trans-unit id="58bd91fff64a844973a8238af97e34efc8a5c324" translate="yes" xml:space="preserve">
          <source>White space is ignored on input, so &lt;code&gt;[(x),(y)]&lt;/code&gt; is the same as &lt;code&gt;[ ( x ), ( y ) ]&lt;/code&gt;.</source>
          <target state="translated">Пробелы игнорируются при вводе, поэтому &lt;code&gt;[(x),(y)]&lt;/code&gt; совпадает с &lt;code&gt;[ ( x ), ( y ) ]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac41fe428645044123abfe95a020b4d162465d70" translate="yes" xml:space="preserve">
          <source>Whitespace is allowed before and after the range value, but any whitespace between the parentheses or brackets is taken as part of the lower or upper bound value. (Depending on the element type, it might or might not be significant.)</source>
          <target state="translated">Пробельные символы допускаются до и после значения диапазона,но любой пробел между скобками или скобками принимается как часть нижнего или верхнего значения диапазона.(В зависимости от типа элемента,он может быть значительным,а может и нет).</target>
        </trans-unit>
        <trans-unit id="78d976901748b052cce834685b15a7dd1749e3bc" translate="yes" xml:space="preserve">
          <source>Whitespace of the same width as the most recent output of &lt;code&gt;PROMPT1&lt;/code&gt;. This can be used as a &lt;code&gt;PROMPT2&lt;/code&gt; setting, so that multi-line statements are aligned with the first line, but there is no visible secondary prompt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc40c3d855977fc828d35a4c20284c43f252dc0" translate="yes" xml:space="preserve">
          <source>Why would you want to use the weak mode? Well, it could be that you have a huge collection of ISBN numbers, and that there are so many of them that for weird reasons some have the wrong check digit (perhaps the numbers were scanned from a printed list and the OCR got the numbers wrong, perhaps the numbers were manually captured... who knows). Anyway, the point is you might want to clean the mess up, but you still want to be able to have all the numbers in your database and maybe use an external tool to locate the invalid numbers in the database so you can verify the information and validate it more easily; so for example you'd want to select all the invalid numbers in the table.</source>
          <target state="translated">Почему вы хотите использовать слабый режим? Ну,может быть,у вас огромная коллекция ISBN-номеров,и их так много,что по странным причинам у некоторых из них неправильная контрольная цифра (возможно,номера были отсканированы из распечатанного списка,и OCR ошибся с номерами,возможно,номера были перехвачены вручную...кто знает).В любом случае,суть в том,что вы,возможно,захотите все исправить,но вы все равно хотите иметь все номера в вашей базе данных и,возможно,использовать внешний инструмент для поиска недействительных номеров в базе данных,чтобы вы могли проверить информацию и проще ее проверить;так что,например,вы захотите выбрать все недействительные номера в таблице.</target>
        </trans-unit>
        <trans-unit id="70a7ce99eb76502ad0a6210d94039f0b40c3419d" translate="yes" xml:space="preserve">
          <source>Wildcard array element accessor that returns all array elements.</source>
          <target state="translated">Доступ к элементам массива Wildcard,который возвращает все элементы массива.</target>
        </trans-unit>
        <trans-unit id="cd2106ae04d09a5386f20710a015aa4219dc3f6c" translate="yes" xml:space="preserve">
          <source>Wildcard member accessor that returns the values of all members located at the top level of the current object.</source>
          <target state="translated">Аксессуар для членов Wildcard,который возвращает значения всех членов,расположенных на верхнем уровне текущего объекта.</target>
        </trans-unit>
        <trans-unit id="68fe8f958724479a101c0326f7607d389d321758" translate="yes" xml:space="preserve">
          <source>Window Functions</source>
          <target state="translated">Оконные функции</target>
        </trans-unit>
        <trans-unit id="927627d12746803cbdee2462dc2d4d29bab17c5e" translate="yes" xml:space="preserve">
          <source>Window function (routine)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01267df331f99498a90196b34760cb7aa229a46d" translate="yes" xml:space="preserve">
          <source>Window function calls are permitted only in the &lt;code&gt;SELECT&lt;/code&gt; list and the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the query.</source>
          <target state="translated">Вызов оконных функций разрешен только в списке &lt;code&gt;SELECT&lt;/code&gt; и предложении &lt;code&gt;ORDER BY&lt;/code&gt; запроса.</target>
        </trans-unit>
        <trans-unit id="c367a920e4a4ea3efbe3a1a798085a3a023e6741" translate="yes" xml:space="preserve">
          <source>Window functions are described in detail in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="translated">Оконные функции подробно описаны в &lt;a href=&quot;tutorial-window&quot;&gt;Разделе 3.5&lt;/a&gt; , &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Разделе 4.2.8&lt;/a&gt; и &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Разделе 7.2.5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f451b621911f3a41da7c18da4aff7cdb55589c1" translate="yes" xml:space="preserve">
          <source>Window functions are permitted only in the &lt;code&gt;SELECT&lt;/code&gt; list and the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the query. They are forbidden elsewhere, such as in &lt;code&gt;GROUP BY&lt;/code&gt;, &lt;code&gt;HAVING&lt;/code&gt; and &lt;code&gt;WHERE&lt;/code&gt; clauses. This is because they logically execute after the processing of those clauses. Also, window functions execute after non-window aggregate functions. This means it is valid to include an aggregate function call in the arguments of a window function, but not vice versa.</source>
          <target state="translated">Оконные функции разрешены только в списке &lt;code&gt;SELECT&lt;/code&gt; и предложении &lt;code&gt;ORDER BY&lt;/code&gt; запроса. Они запрещены в других местах, например в предложениях &lt;code&gt;GROUP BY&lt;/code&gt; , &lt;code&gt;HAVING&lt;/code&gt; и &lt;code&gt;WHERE&lt;/code&gt; . Это потому, что они логически выполняются после обработки этих предложений. Кроме того, оконные функции выполняются после не оконных агрегатных функций. Это означает, что можно включать вызов агрегатной функции в аргументы оконной функции, но не наоборот.</target>
        </trans-unit>
        <trans-unit id="79e789d251d694ff69667eed3b6a1eef1b73bc73" translate="yes" xml:space="preserve">
          <source>Window: cume_dist</source>
          <target state="translated">Окно:cume_dist</target>
        </trans-unit>
        <trans-unit id="1e7f6a60bbd5fd2e82c3412bbb88bea212c4bdb7" translate="yes" xml:space="preserve">
          <source>Window: dense_rank</source>
          <target state="translated">Окно:dense_rank</target>
        </trans-unit>
        <trans-unit id="08d36b418003a8b9c0e9b2dd2a6f2bff70e5a8ac" translate="yes" xml:space="preserve">
          <source>Window: first_value</source>
          <target state="translated">Окно:first_value</target>
        </trans-unit>
        <trans-unit id="b5f178a106cd7cba1da80bdc71ec514eea37f26d" translate="yes" xml:space="preserve">
          <source>Window: lag</source>
          <target state="translated">Окно:задержка</target>
        </trans-unit>
        <trans-unit id="fabaa17e6490da4ec5451b3b47ee388b70cf91b0" translate="yes" xml:space="preserve">
          <source>Window: last_value</source>
          <target state="translated">Окно:последнее_значение</target>
        </trans-unit>
        <trans-unit id="994efd60b559fadbd405573c301089b7cf18f884" translate="yes" xml:space="preserve">
          <source>Window: lead</source>
          <target state="translated">Окно:свинец</target>
        </trans-unit>
        <trans-unit id="757db4a854089f2de8d98fd39c8889ef5116458d" translate="yes" xml:space="preserve">
          <source>Window: nth_value</source>
          <target state="translated">Окно:nth_value</target>
        </trans-unit>
        <trans-unit id="e7f90d6e0544bf0f16ab443f5e02ee4cd6fe42bc" translate="yes" xml:space="preserve">
          <source>Window: ntile</source>
          <target state="translated">Окно:плетень</target>
        </trans-unit>
        <trans-unit id="bb901cf4a6350aa408d137094086445ef7a0cf50" translate="yes" xml:space="preserve">
          <source>Window: percent_rank</source>
          <target state="translated">Окно:percent_rank</target>
        </trans-unit>
        <trans-unit id="c0ecbc78e1223c489bcdc839303f81579d301dbd" translate="yes" xml:space="preserve">
          <source>Window: rank</source>
          <target state="translated">Окно:рейтинг</target>
        </trans-unit>
        <trans-unit id="31c13454a2137d228d57d97a95bb16f2559129e2" translate="yes" xml:space="preserve">
          <source>Window: row_number</source>
          <target state="translated">Окно:номер_строки</target>
        </trans-unit>
        <trans-unit id="afb3a4bfc7eab0371f71e7828e71cca0cb17b3c3" translate="yes" xml:space="preserve">
          <source>Windows CP1250</source>
          <target state="translated">Windows CP1250</target>
        </trans-unit>
        <trans-unit id="9a2c00b8e44a047e41a03f1caab3a7b4b6689695" translate="yes" xml:space="preserve">
          <source>Windows CP1251</source>
          <target state="translated">Windows CP1251</target>
        </trans-unit>
        <trans-unit id="ee9d69428625d1ff5f15b6e3dcde936a0fd1f094" translate="yes" xml:space="preserve">
          <source>Windows CP1252</source>
          <target state="translated">Windows CP1252</target>
        </trans-unit>
        <trans-unit id="cc78a0c32f91f66c55ae633ccbcefebb486eb07a" translate="yes" xml:space="preserve">
          <source>Windows CP1253</source>
          <target state="translated">Windows CP1253</target>
        </trans-unit>
        <trans-unit id="5f231ed423cb65bf660816b30028087f1a8e8ce5" translate="yes" xml:space="preserve">
          <source>Windows CP1254</source>
          <target state="translated">Windows CP1254</target>
        </trans-unit>
        <trans-unit id="a23b534f177679e438c10751dd8cd9af7ceda942" translate="yes" xml:space="preserve">
          <source>Windows CP1255</source>
          <target state="translated">Windows CP1255</target>
        </trans-unit>
        <trans-unit id="6790dc03b7d5b6e6f32fcb36c60e23323fb868ac" translate="yes" xml:space="preserve">
          <source>Windows CP1256</source>
          <target state="translated">Windows CP1256</target>
        </trans-unit>
        <trans-unit id="2de6d342a6a1f91fe73d1aed1c38e985a216e16e" translate="yes" xml:space="preserve">
          <source>Windows CP1257</source>
          <target state="translated">Windows CP1257</target>
        </trans-unit>
        <trans-unit id="640bb2a94fe66a43ea03427875c71fa7af756764" translate="yes" xml:space="preserve">
          <source>Windows CP1258</source>
          <target state="translated">Windows CP1258</target>
        </trans-unit>
        <trans-unit id="e95532249be79aa59a141ea1dc6d988132a7c104" translate="yes" xml:space="preserve">
          <source>Windows CP866</source>
          <target state="translated">Windows CP866</target>
        </trans-unit>
        <trans-unit id="69925dc2d1afa064badeb7131e0815ad04126da3" translate="yes" xml:space="preserve">
          <source>Windows CP874</source>
          <target state="translated">Windows CP874</target>
        </trans-unit>
        <trans-unit id="c6d589f8c6c9e727468855e6a54c0d6dfb5cce47" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create&lt;/code&gt;, pg_restore also restores the database's comment if any, and any configuration variable settings that are specific to this database, that is, any &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; and &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; commands that mention this database. Access privileges for the database itself are also restored, unless &lt;code&gt;--no-acl&lt;/code&gt; is specified.</source>
          <target state="translated">С &lt;code&gt;--create&lt;/code&gt; , pg_restore также восстанавливает комментарий базы данных, если таковой имеется, и любые настройки переменных конфигурации, относящиеся к этой базе данных, то есть любые &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; и &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; которые упоминают эту базу данных. Также восстанавливаются права доступа к самой базе данных, если не указан &lt;code&gt;--no-acl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fdece12f1fb080c2dbfd8709cabeca4afb1d172" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create&lt;/code&gt;, the output also includes the database's comment if any, and any configuration variable settings that are specific to this database, that is, any &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; and &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; commands that mention this database. Access privileges for the database itself are also dumped, unless &lt;code&gt;--no-acl&lt;/code&gt; is specified.</source>
          <target state="translated">С &lt;code&gt;--create&lt;/code&gt; вывод также включает комментарий базы данных, если таковой имеется, и любые настройки переменных конфигурации, которые относятся к этой базе данных, то есть любые &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; и &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; команды, которые упоминают эту базу данных. Права доступа к самой базе данных также сбрасываются, если не указан &lt;code&gt;--no-acl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1abf8b357cf8a269c4c68a487360b4810c28399" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;G&lt;/code&gt; (server-side data generation), only small queries are sent from the &lt;code&gt;pgbench&lt;/code&gt; client and then data is actually generated in the server. No significant bandwidth is required for this variant, but the server will do more work. Using &lt;code&gt;G&lt;/code&gt; causes logging not to print any progress message while generating data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8bd1c0f7d38dd3394b226a28acc604884d1615" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;g&lt;/code&gt; (client-side data generation), data is generated in &lt;code&gt;pgbench&lt;/code&gt; client and then sent to the server. This uses the client/server bandwidth extensively through a &lt;code&gt;COPY&lt;/code&gt;. Using &lt;code&gt;g&lt;/code&gt; causes logging to print one message every 100,000 rows while generating data for the &lt;code&gt;pgbench_accounts&lt;/code&gt; table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f453a9fafc8b310f8a3de3fda65ed4c38e9ca283" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;join_collapse_limit&lt;/code&gt; = 1, this forces the planner to join A to B before joining them to other tables, but doesn't constrain its choices otherwise. In this example, the number of possible join orders is reduced by a factor of 5.</source>
          <target state="translated">При &lt;code&gt;join_collapse_limit&lt;/code&gt; = 1 это заставляет планировщика присоединяться к A и B перед их присоединением к другим таблицам, но в противном случае не ограничивает его выбор. В этом примере количество возможных порядков соединения уменьшено в 5 раз.</target>
        </trans-unit>
        <trans-unit id="fe49ef2ae18f846d2f24144892dcb7436b22edbb" translate="yes" xml:space="preserve">
          <source>With ICU, it is not sensible to enumerate all possible locale names. ICU uses a particular naming system for locales, but there are many more ways to name a locale than there are actually distinct locales. &lt;code&gt;initdb&lt;/code&gt; uses the ICU APIs to extract a set of distinct locales to populate the initial set of collations. Collations provided by ICU are created in the SQL environment with names in BCP 47 language tag format, with a &amp;ldquo;private use&amp;rdquo; extension &lt;code&gt;-x-icu&lt;/code&gt; appended, to distinguish them from libc locales.</source>
          <target state="translated">В ICU нет смысла перечислять все возможные имена локалей. ICU использует определенную систему именования для локалей, но существует гораздо больше способов дать имя языку, чем есть фактически отдельные локали. &lt;code&gt;initdb&lt;/code&gt; использует интерфейсы API ICU для извлечения набора различных локалей для заполнения начального набора сопоставлений. Сопоставления, предоставляемые ICU, создаются в среде SQL с именами в формате языковых тегов BCP 47 с добавленным расширением &amp;laquo;частного использования&amp;raquo; &lt;code&gt;-x-icu&lt;/code&gt; , чтобы отличить их от локалей libc.</target>
        </trans-unit>
        <trans-unit id="cc0ce6e945d75c0e017cd4582a6ce07fb85c72b6" translate="yes" xml:space="preserve">
          <source>With OpenSSL</source>
          <target state="translated">С OpenSSL</target>
        </trans-unit>
        <trans-unit id="2a51bd6ec05106a3703acb2d25cff0f482de5c76" translate="yes" xml:space="preserve">
          <source>With SQL-based replication middleware, a program intercepts every SQL query and sends it to one or all servers. Each server operates independently. Read-write queries must be sent to all servers, so that every server receives any changes. But read-only queries can be sent to just one server, allowing the read workload to be distributed among them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa1343fb87dfb28347c1e7e66e33ba69c59c2ca" translate="yes" xml:space="preserve">
          <source>With SSL support compiled in, the PostgreSQL server can be started with SSL enabled by setting the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;ssl&lt;/a&gt; to &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. The server will listen for both normal and SSL connections on the same TCP port, and will negotiate with any connecting client on whether to use SSL. By default, this is at the client's option; see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about how to set up the server to require use of SSL for some or all connections.</source>
          <target state="translated">При вкомпилированной поддержке SSL сервер PostgreSQL можно запустить с включенным SSL, установив для параметра &lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;ssl&lt;/a&gt; значение &lt;code&gt;on&lt;/code&gt; в &lt;code&gt;postgresql.conf&lt;/code&gt; . Сервер будет прослушивать как обычные, так и SSL-соединения на одном и том же TCP-порту и согласовывать с любым подключающимся клиентом, использовать ли SSL. По умолчанию это остается на усмотрение клиента; см. &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Раздел 20.1&lt;/a&gt; о том, как настроить сервер так, чтобы он требовал использования SSL для некоторых или всех соединений.</target>
        </trans-unit>
        <trans-unit id="1d13ab27fd57668592221b667df2e40b0bb1e2e4" translate="yes" xml:space="preserve">
          <source>With a cluster distributed across multiple geographic locations, using different values per location brings more flexibility in the cluster management. A smaller value is useful for faster failure detection with a standby having a low-latency network connection, and a larger value helps in judging better the health of a standby if located on a remote location, with a high-latency network connection.</source>
          <target state="translated">Благодаря кластеру,распределенному по нескольким географическим точкам,использование различных значений для каждой точки дает большую гибкость в управлении кластером.Меньшие значения полезны для более быстрого обнаружения сбоев при подключении к сети с низкой задержкой,а большие значения помогают лучше оценить состояние готовности,если она расположена на удаленном местоположении,при подключении к сети с высокой задержкой.</target>
        </trans-unit>
        <trans-unit id="2817eb5fe50b4283e89c69a97c63500ae24da2d7" translate="yes" xml:space="preserve">
          <source>With a parameter, turns displaying of how long each SQL statement takes on or off. Without a parameter, toggles the display between on and off. The display is in milliseconds; intervals longer than 1 second are also shown in minutes:seconds format, with hours and days fields added if needed.</source>
          <target state="translated">С параметром,включает отображение того,как долго каждый SQL оператор будет включаться или выключаться.Без параметра переключает отображение между включением и выключением.Дисплей отображается в миллисекундах;интервалы более 1 секунды также отображаются в формате минуты:секунды,при необходимости добавляются поля часов и дней.</target>
        </trans-unit>
        <trans-unit id="862b8683e39578b4e7d997552333b9aad19243ce" translate="yes" xml:space="preserve">
          <source>With constraint exclusion enabled, this &lt;code&gt;SELECT&lt;/code&gt; will not scan &lt;code&gt;child1000&lt;/code&gt; at all, improving performance.</source>
          <target state="translated">Если включено исключение ограничений, этот &lt;code&gt;SELECT&lt;/code&gt; вообще не будет сканировать &lt;code&gt;child1000&lt;/code&gt; ,что повысит производительность.</target>
        </trans-unit>
        <trans-unit id="281288184f75c730f93254833c37347e0fc29fe4" translate="yes" xml:space="preserve">
          <source>With data warehouse type workloads, it can make sense to use a larger number of partitions than with an OLTP type workload. Generally, in data warehouses, query planning time is less of a concern as the majority of processing time is spent during query execution. With either of these two types of workload, it is important to make the right decisions early, as re-partitioning large quantities of data can be painfully slow. Simulations of the intended workload are often beneficial for optimizing the partitioning strategy. Never assume that more partitions are better than fewer partitions and vice-versa.</source>
          <target state="translated">С рабочими нагрузками типа хранилища данных имеет смысл использовать большее количество разделов,чем с рабочими нагрузками типа OLTP.Обычно в хранилищах данных время,затрачиваемое на планирование запросов,меньше,так как большая часть времени на обработку приходится на выполнение запросов.При любом из этих двух типов нагрузки важно принимать правильные решения на ранней стадии,так как переразметка больших объемов данных может быть болезненно медленной.Моделирование предполагаемой рабочей нагрузки часто полезно для оптимизации стратегии разметки.Никогда не думайте,что большее количество разделов лучше,чем меньшее количество разделов и наоборот.</target>
        </trans-unit>
        <trans-unit id="3766650cc974cf1ed93fe99df3e842788c554914" translate="yes" xml:space="preserve">
          <source>With no advance preparation, the system would have to scan the entire &lt;code&gt;test1&lt;/code&gt; table, row by row, to find all matching entries. If there are many rows in &lt;code&gt;test1&lt;/code&gt; and only a few rows (perhaps zero or one) that would be returned by such a query, this is clearly an inefficient method. But if the system has been instructed to maintain an index on the &lt;code&gt;id&lt;/code&gt; column, it can use a more efficient method for locating matching rows. For instance, it might only have to walk a few levels deep into a search tree.</source>
          <target state="translated">Без предварительной подготовки системе придется сканировать всю таблицу &lt;code&gt;test1&lt;/code&gt; , строка за строкой, чтобы найти все совпадающие записи. Если в &lt;code&gt;test1&lt;/code&gt; много строк и только несколько строк (возможно, ноль или одна), которые могут быть возвращены таким запросом, это явно неэффективный метод. Но если система получила указание поддерживать индекс в столбце &lt;code&gt;id&lt;/code&gt; , она может использовать более эффективный метод поиска совпадающих строк. Например, ему может потребоваться пройти всего несколько уровней в глубину дерева поиска.</target>
        </trans-unit>
        <trans-unit id="d718f6eccff45185b0a45095de6fde081eea1bba" translate="yes" xml:space="preserve">
          <source>With no argument, escapes to a sub-shell; psql resumes when the sub-shell exits. With an argument, executes the shell command &lt;code&gt;command&lt;/code&gt;.</source>
          <target state="translated">Без аргументов, переход во вложенную оболочку; psql возобновляет работу при выходе из под-оболочки. С аргументом, выполняет команды оболочек &lt;code&gt;command&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9514950fe011b56b473f75097880ade2b163bceb" translate="yes" xml:space="preserve">
          <source>With statement-based replication middleware, a program intercepts every SQL query and sends it to one or all servers. Each server operates independently. Read-write queries must be sent to all servers, so that every server receives any changes. But read-only queries can be sent to just one server, allowing the read workload to be distributed among them.</source>
          <target state="translated">С помощью промежуточного программного обеспечения,основанного на операторах репликации,программа перехватывает каждый SQL-запрос и отправляет его на один или все серверы.Каждый сервер работает независимо.Запросы на чтение и запись должны быть отправлены на все серверы,чтобы каждый сервер получил изменения.Но запросы только на чтение могут быть отправлены только на один сервер,что позволяет распределить нагрузку на чтение между ними.</target>
        </trans-unit>
        <trans-unit id="4094d09ba0d0f0a9849aa3ea46bb7d77a767e980" translate="yes" xml:space="preserve">
          <source>With synchronous replication options specified at the application level (on the primary) we can offer synchronous replication for the most important changes, without slowing down the bulk of the total workload. Application level options are an important and practical tool for allowing the benefits of synchronous replication for high performance applications.</source>
          <target state="translated">С помощью опций синхронной репликации,указанных на уровне приложения (на основном),мы можем предложить синхронную репликацию для наиболее важных изменений,не замедляя основную часть общей рабочей нагрузки.Опции уровня приложения являются важным и практичным инструментом,позволяющим воспользоваться преимуществами синхронной репликации для высокопроизводительных приложений.</target>
        </trans-unit>
        <trans-unit id="e625f82083935e0517f3c7cf1a804070d41f41f5" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--aggregate-interval&lt;/code&gt; option, a different format is used for the log files:</source>
          <target state="translated">С параметром &lt;code&gt;--aggregate-interval&lt;/code&gt; для файлов журнала используется другой формат:</target>
        </trans-unit>
        <trans-unit id="21c13395c6ff50aca429bd803e2b410319037881" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-l&lt;/code&gt; option (but without the &lt;code&gt;--aggregate-interval&lt;/code&gt; option), pgbench writes information about each transaction to a log file. The log file will be named &lt;code&gt;prefix.nnn&lt;/code&gt;, where &lt;code&gt;prefix&lt;/code&gt; defaults to &lt;code&gt;pgbench_log&lt;/code&gt;, and &lt;code&gt;nnn&lt;/code&gt; is the PID of the pgbench process. The prefix can be changed by using the &lt;code&gt;--log-prefix&lt;/code&gt; option. If the &lt;code&gt;-j&lt;/code&gt; option is 2 or higher, so that there are multiple worker threads, each will have its own log file. The first worker will use the same name for its log file as in the standard single worker case. The additional log files for the other workers will be named &lt;code&gt;prefix.nnn.mmm&lt;/code&gt;, where &lt;code&gt;mmm&lt;/code&gt; is a sequential number for each worker starting with 1.</source>
          <target state="translated">С параметром &lt;code&gt;-l&lt;/code&gt; (но без параметра &lt;code&gt;--aggregate-interval&lt;/code&gt; ) pgbench записывает информацию о каждой транзакции в файл журнала. Файл журнала будет называться &lt;code&gt;prefix.nnn&lt;/code&gt; , где по умолчанию используется &lt;code&gt;prefix&lt;/code&gt; &lt;code&gt;pgbench_log&lt;/code&gt; , а &lt;code&gt;nnn&lt;/code&gt; - это PID процесса pgbench. Префикс можно изменить с помощью параметра &lt;code&gt;--log-prefix&lt;/code&gt; . Если параметр &lt;code&gt;-j&lt;/code&gt; равен 2 или выше, так что есть несколько рабочих потоков, каждый будет иметь свой собственный файл журнала. Первый рабочий будет использовать то же имя для своего файла журнала, что и в стандартном случае одного рабочего. Дополнительные файлы журнала для других рабочих &lt;code&gt;prefix.nnn.mmm&lt;/code&gt; будут называться prefix.nnn.mmm , где &lt;code&gt;mmm&lt;/code&gt; - порядковый номер для каждого рабочего, начиная с 1.</target>
        </trans-unit>
        <trans-unit id="dea12aa8ce2a4f9481a6f03ad5ce52c7d1882b2a" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-r&lt;/code&gt; option, pgbench collects the elapsed transaction time of each statement executed by every client. It then reports an average of those values, referred to as the latency for each statement, after the benchmark has finished.</source>
          <target state="translated">С параметром &lt;code&gt;-r&lt;/code&gt; pgbench собирает истекшее время транзакции для каждого оператора, выполненного каждым клиентом. Затем он сообщает среднее значение этих значений, называемое задержкой для каждого оператора, после завершения теста.</target>
        </trans-unit>
        <trans-unit id="b0d0adcb9fc8fc9dddac0cfadc06d179ba840172" translate="yes" xml:space="preserve">
          <source>With the default setting of &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt;, it is only useful to place a &lt;code&gt;simple&lt;/code&gt; dictionary at the end of a list of dictionaries, since it will never pass on any token to a following dictionary. Conversely, &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; is only useful when there is at least one following dictionary.</source>
          <target state="translated">При настройке по умолчанию &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; полезно только разместить &lt;code&gt;simple&lt;/code&gt; словарь в конце списка словарей, так как он никогда не будет передавать какой-либо токен в следующий словарь. И наоборот, &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; полезен только тогда, когда есть хотя бы один следующий словарь.</target>
        </trans-unit>
        <trans-unit id="1679a02524be37201556be412a6d701fa1ad4ae3" translate="yes" xml:space="preserve">
          <source>With the tools discussed so far you can create fully functional tables. The remainder of this chapter is concerned with adding features to the table definition to ensure data integrity, security, or convenience. If you are eager to fill your tables with data now you can skip ahead to &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt; and read the rest of this chapter later.</source>
          <target state="translated">С помощью инструментов, рассмотренных до сих пор, вы можете создавать полностью функциональные таблицы. Остальная часть этой главы посвящена добавлению функций к определению таблицы для обеспечения целостности, безопасности или удобства данных. Если вы хотите заполнить свои таблицы данными сейчас, вы можете сразу перейти к &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;главе 6&lt;/a&gt; и прочитать остальную часть этой главы позже.</target>
        </trans-unit>
        <trans-unit id="65bded40379a6ac67a03a08a9d131c48acd1a16a" translate="yes" xml:space="preserve">
          <source>With the tools discussed so far you can create fully functional tables. The remainder of this chapter is concerned with adding features to the table definition to ensure data integrity, security, or convenience. If you are eager to fill your tables with data now you can skip ahead to &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;Chapter 6&lt;/a&gt; and read the rest of this chapter later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37674f638cca87d9f8a3c6dc8d132c3743ff6b7c" translate="yes" xml:space="preserve">
          <source>With this parameter enabled, you can still create ordinary global users. Simply append &lt;code&gt;@&lt;/code&gt; when specifying the user name in the client, e.g. &lt;code&gt;joe@&lt;/code&gt;. The &lt;code&gt;@&lt;/code&gt; will be stripped off before the user name is looked up by the server.</source>
          <target state="translated">Если этот параметр включен, вы все еще можете создавать обычных глобальных пользователей. Просто добавьте &lt;code&gt;@&lt;/code&gt; при указании имени пользователя в клиенте, например &lt;code&gt;joe@&lt;/code&gt; . Символ &lt;code&gt;@&lt;/code&gt; будет удален до того, как сервер найдет имя пользователя.</target>
        </trans-unit>
        <trans-unit id="5c255d5e2ff800e00e81014aac8b22d43990196d" translate="yes" xml:space="preserve">
          <source>With this parameter enabled, you can still create ordinary global users. Simply append &lt;code&gt;@&lt;/code&gt; when specifying the user name in the client, e.g., &lt;code&gt;joe@&lt;/code&gt;. The &lt;code&gt;@&lt;/code&gt; will be stripped off before the user name is looked up by the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de39e9b44ca28bac2cf5d078925f7311c5e84abb" translate="yes" xml:space="preserve">
          <source>With this preparation, a backup can be taken using a script like the following:</source>
          <target state="translated">При такой подготовке можно сделать резервную копию,используя следующий скрипт:</target>
        </trans-unit>
        <trans-unit id="d7d93925105d3192c92e0036610fccacd28a3de6" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;condition&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;, the special table names &lt;code&gt;NEW&lt;/code&gt; and &lt;code&gt;OLD&lt;/code&gt; can be used to refer to values in the referenced table. &lt;code&gt;NEW&lt;/code&gt; is valid in &lt;code&gt;ON INSERT&lt;/code&gt; and &lt;code&gt;ON UPDATE&lt;/code&gt; rules to refer to the new row being inserted or updated. &lt;code&gt;OLD&lt;/code&gt; is valid in &lt;code&gt;ON UPDATE&lt;/code&gt; and &lt;code&gt;ON DELETE&lt;/code&gt; rules to refer to the existing row being updated or deleted.</source>
          <target state="translated">В пределах &lt;code&gt;condition&lt;/code&gt; и &lt;code&gt;command&lt;/code&gt; специальные имена таблиц &lt;code&gt;NEW&lt;/code&gt; и &lt;code&gt;OLD&lt;/code&gt; могут использоваться для ссылки на значения в указанной таблице. &lt;code&gt;NEW&lt;/code&gt; действительно в правилах &lt;code&gt;ON INSERT&lt;/code&gt; и &lt;code&gt;ON UPDATE&lt;/code&gt; для ссылки на новую вставляемую или обновляемую строку. &lt;code&gt;OLD&lt;/code&gt; действует в правилах &lt;code&gt;ON UPDATE&lt;/code&gt; и &lt;code&gt;ON DELETE&lt;/code&gt; для ссылки на существующую строку, обновляемую или удаляемую.</target>
        </trans-unit>
        <trans-unit id="b7c7983937789ea59f666ccaa3b6dc10f18e4489" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;tsquery&lt;/code&gt;, the &lt;code&gt;&amp;amp;&lt;/code&gt; (AND) operator specifies that both its arguments must appear in the document to have a match. Similarly, the &lt;code&gt;|&lt;/code&gt; (OR) operator specifies that at least one of its arguments must appear, while the &lt;code&gt;!&lt;/code&gt; (NOT) operator specifies that its argument must &lt;em&gt;not&lt;/em&gt; appear in order to have a match. For example, the query &lt;code&gt;fat &amp;amp; ! rat&lt;/code&gt; matches documents that contain &lt;code&gt;fat&lt;/code&gt; but not &lt;code&gt;rat&lt;/code&gt;.</source>
          <target state="translated">В пределах &lt;code&gt;tsquery&lt;/code&gt; , то &lt;code&gt;&amp;amp;&lt;/code&gt; (AND) оператор указывает , что оба его аргументы должны появиться в документе , чтобы матч. Аналогичным образом &lt;code&gt;|&lt;/code&gt; Оператор (ИЛИ) указывает, что должен появиться хотя бы один из его аргументов, а оператор &lt;code&gt;!&lt;/code&gt; Оператор (НЕ) указывает, что его аргумент &lt;em&gt;не&lt;/em&gt; должен появляться, чтобы было совпадение. Например, запрос &lt;code&gt;fat &amp;amp; ! rat&lt;/code&gt; соответствует документам, содержащим &lt;code&gt;fat&lt;/code&gt; но не содержит &lt;code&gt;rat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2368cc4cb5a919d014b1e03cda4cf0d9819b781" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, a collating element (a character, a multiple-character sequence that collates as if it were a single character, or a collating-sequence name for either) enclosed in &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt; stands for the sequence of characters of that collating element. The sequence is treated as a single element of the bracket expression's list. This allows a bracket expression containing a multiple-character collating element to match more than one character, e.g., if the collating sequence includes a &lt;code&gt;ch&lt;/code&gt; collating element, then the RE &lt;code&gt;[[.ch.]]*c&lt;/code&gt; matches the first five characters of &lt;code&gt;chchcc&lt;/code&gt;.</source>
          <target state="translated">Внутри выражения в скобках элемент сортировки (символ, последовательность из нескольких символов, которая сопоставляется, как если бы это был один символ, или имя последовательности для каждого из них), заключенный в &lt;code&gt;[.&lt;/code&gt; и &lt;code&gt;.]&lt;/code&gt; обозначает последовательность символов этого элемента сопоставления. Последовательность рассматривается как отдельный элемент списка выражений в квадратных скобках. Это позволяет выражению в скобках, содержащему элемент сопоставления из нескольких символов, соответствовать более чем одному символу, например, если последовательность сопоставления включает элемент сопоставления &lt;code&gt;ch&lt;/code&gt; , то RE &lt;code&gt;[[.ch.]]*c&lt;/code&gt; соответствует первым пяти символам &lt;code&gt;chchcc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e1fe750b2061555e551fa7ddfd0d60d1ac81517" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, a collating element enclosed in &lt;code&gt;[=&lt;/code&gt; and &lt;code&gt;=]&lt;/code&gt; is an &lt;em&gt;equivalence class&lt;/em&gt;, standing for the sequences of characters of all collating elements equivalent to that one, including itself. (If there are no other equivalent collating elements, the treatment is as if the enclosing delimiters were &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt;.) For example, if &lt;code&gt;o&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt; are the members of an equivalence class, then &lt;code&gt;[[=o=]]&lt;/code&gt;, &lt;code&gt;[[=^=]]&lt;/code&gt;, and &lt;code&gt;[o^]&lt;/code&gt; are all synonymous. An equivalence class cannot be an endpoint of a range.</source>
          <target state="translated">Внутри выражения в скобках элемент сортировки, заключенный в &lt;code&gt;[=&lt;/code&gt; и &lt;code&gt;=]&lt;/code&gt; , является &lt;em&gt;классом эквивалентности&lt;/em&gt; , обозначающим последовательности символов всех элементов сортировки, эквивалентных этому, включая его самого. (Если нет других эквивалентных элементов упорядочения, лечение , как если бы ограждающих разделители были &lt;code&gt;[.&lt;/code&gt; И &lt;code&gt;.]&lt;/code&gt; .) Например, если &lt;code&gt;o&lt;/code&gt; и &lt;code&gt;^&lt;/code&gt; являются членами класса эквивалентности, то &lt;code&gt;[[=o=]]&lt;/code&gt; , &lt;code&gt;[[=^=]]&lt;/code&gt; и &lt;code&gt;[o^]&lt;/code&gt; являются синонимами. Класс эквивалентности не может быть конечной точкой диапазона.</target>
        </trans-unit>
        <trans-unit id="abb82d076f25a7be9aee0f56365d178b74a1a2ff" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, the name of a character class enclosed in &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; stands for the list of all characters belonging to that class. A character class cannot be used as an endpoint of a range. The POSIX standard defines these character class names: &lt;code&gt;alnum&lt;/code&gt; (letters and numeric digits), &lt;code&gt;alpha&lt;/code&gt; (letters), &lt;code&gt;blank&lt;/code&gt; (space and tab), &lt;code&gt;cntrl&lt;/code&gt; (control characters), &lt;code&gt;digit&lt;/code&gt; (numeric digits), &lt;code&gt;graph&lt;/code&gt; (printable characters except space), &lt;code&gt;lower&lt;/code&gt; (lower-case letters), &lt;code&gt;print&lt;/code&gt; (printable characters including space), &lt;code&gt;punct&lt;/code&gt; (punctuation), &lt;code&gt;space&lt;/code&gt; (any white space), &lt;code&gt;upper&lt;/code&gt; (upper-case letters), and &lt;code&gt;xdigit&lt;/code&gt; (hexadecimal digits). The behavior of these standard character classes is generally consistent across platforms for characters in the 7-bit ASCII set. Whether a given non-ASCII character is considered to belong to one of these classes depends on the &lt;em&gt;collation&lt;/em&gt; that is used for the regular-expression function or operator (see &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;), or by default on the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; locale setting (see &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt;). The classification of non-ASCII characters can vary across platforms even in similarly-named locales. (But the &lt;code&gt;C&lt;/code&gt; locale never considers any non-ASCII characters to belong to any of these classes.) In addition to these standard character classes, PostgreSQL defines the &lt;code&gt;ascii&lt;/code&gt; character class, which contains exactly the 7-bit ASCII set.</source>
          <target state="translated">В выражении в квадратных скобках имя класса символов, заключенное в &lt;code&gt;[:&lt;/code&gt; и &lt;code&gt;:]&lt;/code&gt; , обозначает список всех символов, принадлежащих этому классу. Класс символов не может использоваться в качестве конечной точки диапазона. Стандарт POSIX определяет эти имена классов символов: &lt;code&gt;alnum&lt;/code&gt; (буквы и цифровые цифры), &lt;code&gt;alpha&lt;/code&gt; (буквы), &lt;code&gt;blank&lt;/code&gt; (пробел и табуляция), &lt;code&gt;cntrl&lt;/code&gt; (управляющие символы), &lt;code&gt;digit&lt;/code&gt; (числовые цифры), &lt;code&gt;graph&lt;/code&gt; (печатаемые символы, кроме пробела), &lt;code&gt;lower&lt;/code&gt; (строчные буквы), &lt;code&gt;print&lt;/code&gt; (печатаемые символы включая пробел), &lt;code&gt;punct&lt;/code&gt; (знаки препинания), &lt;code&gt;space&lt;/code&gt; (любой пробел), &lt;code&gt;upper&lt;/code&gt; (прописные буквы) и &lt;code&gt;xdigit&lt;/code&gt; (шестнадцатеричные цифры). Поведение этих стандартных классов символов обычно одинаково на разных платформах для символов в 7-битном наборе ASCII. Считается, что данный не-ASCII символ принадлежит к одному из этих классов, зависит от &lt;em&gt;сопоставления&lt;/em&gt; , которое используется для функции или оператора регулярного выражения (см. &lt;a href=&quot;collation&quot;&gt;Раздел 23.2&lt;/a&gt; ), или по умолчанию от настройки локали базы данных &lt;code&gt;LC_CTYPE&lt;/code&gt; (см. &lt;a href=&quot;locale&quot;&gt;Раздел 23.1).&lt;/a&gt; ). Классификация символов, отличных от ASCII, может различаться на разных платформах даже в странах с одинаковыми названиями. (Но &lt;code&gt;C&lt;/code&gt; locale никогда не считает, что символы, отличные от ASCII, принадлежат какому-либо из этих классов.) В дополнение к этим стандартным классам символов PostgreSQL определяет класс символов &lt;code&gt;ascii&lt;/code&gt; , который содержит в точности 7-битный набор ASCII.</target>
        </trans-unit>
        <trans-unit id="d35bef27a0203dd6547cf96a8cb6d957c5595d5c" translate="yes" xml:space="preserve">
          <source>Within a pattern, &lt;code&gt;*&lt;/code&gt; matches any sequence of characters (including no characters) and &lt;code&gt;?&lt;/code&gt; matches any single character. (This notation is comparable to Unix shell file name patterns.) For example, &lt;code&gt;\dt int*&lt;/code&gt; displays tables whose names begin with &lt;code&gt;int&lt;/code&gt;. But within double quotes, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; lose these special meanings and are just matched literally.</source>
          <target state="translated">В шаблоне &lt;code&gt;*&lt;/code&gt; соответствует любой последовательности символов (включая отсутствие символов) и &lt;code&gt;?&lt;/code&gt; соответствует любому одиночному символу. (Эта нотация сопоставима с шаблонами имен файлов оболочки Unix.) Например, &lt;code&gt;\dt int*&lt;/code&gt; отображает таблицы, имена которых начинаются с &lt;code&gt;int&lt;/code&gt; . Но в двойных кавычках &lt;code&gt;*&lt;/code&gt; и &lt;code&gt;?&lt;/code&gt; теряют эти особые значения и просто совпадают буквально.</target>
        </trans-unit>
        <trans-unit id="323b9b12ce6cec030c2782c77172b386cffa6487" translate="yes" xml:space="preserve">
          <source>Within an argument, text that is enclosed in backquotes (&lt;code&gt;`&lt;/code&gt;) is taken as a command line that is passed to the shell. The output of the command (with any trailing newline removed) replaces the backquoted text. Within the text enclosed in backquotes, no special quoting or other processing occurs, except that appearances of &lt;code&gt;:variable_name&lt;/code&gt; where &lt;code&gt;variable_name&lt;/code&gt; is a psql variable name are replaced by the variable's value. Also, appearances of &lt;code&gt;:'variable_name'&lt;/code&gt; are replaced by the variable's value suitably quoted to become a single shell command argument. (The latter form is almost always preferable, unless you are very sure of what is in the variable.) Because carriage return and line feed characters cannot be safely quoted on all platforms, the &lt;code&gt;:'variable_name'&lt;/code&gt; form prints an error message and does not substitute the variable value when such characters appear in the value.</source>
          <target state="translated">Внутри аргумента текст, заключенный в обратные кавычки ( &lt;code&gt;`&lt;/code&gt; ), воспринимается как командная строка, которая передается в оболочку. Вывод команды (с удаленным завершающим символом новой строки) заменяет текст в обратных кавычках. Внутри текста, заключенного в обратные кавычки, не происходит никаких специальных кавычек или другой обработки, за исключением того, что появление &lt;code&gt;:variable_name&lt;/code&gt; где &lt;code&gt;variable_name&lt;/code&gt; - имя переменной psql, заменяется значением переменной. Кроме того, появление &lt;code&gt;:'variable_name'&lt;/code&gt; заменяются соответствующим образом кавычками значения переменной, чтобы стать единственным аргументом команды оболочки. (Последняя форма почти всегда предпочтительнее, если вы не очень уверены в том, что находится в переменной.) Поскольку символы возврата каретки и перевода строки не могут безопасно цитироваться на всех платформах, форма &lt;code&gt;:'variable_name'&lt;/code&gt; выводит сообщение об ошибке и не заменяйте значение переменной, когда такие символы появляются в значении.</target>
        </trans-unit>
        <trans-unit id="02446a7929ab10f300f87f18642a172ae6a7fbfe" translate="yes" xml:space="preserve">
          <source>Within any particular database, only collations that use that database's encoding are of interest. Other entries in &lt;code&gt;pg_collation&lt;/code&gt; are ignored. Thus, a stripped collation name such as &lt;code&gt;de_DE&lt;/code&gt; can be considered unique within a given database even though it would not be unique globally. Use of the stripped collation names is recommended, since it will make one less thing you need to change if you decide to change to another database encoding. Note however that the &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;POSIX&lt;/code&gt; collations can be used regardless of the database encoding.</source>
          <target state="translated">В любой конкретной базе данных интерес представляют только сопоставления, в которых используется кодировка этой базы данных. Другие записи в &lt;code&gt;pg_collation&lt;/code&gt; игнорируются. Таким образом, &lt;code&gt;de_DE&lt;/code&gt; имя сопоставления, такое как de_DE, можно считать уникальным в данной базе данных, даже если оно не будет уникальным в глобальном масштабе. Рекомендуется использовать разделенные имена параметров сортировки, поскольку это уменьшит на одну вещь, которую вам нужно будет изменить, если вы решите перейти на другую кодировку базы данных. Однако обратите внимание, что &lt;code&gt;default&lt;/code&gt; сортировки по умолчанию , &lt;code&gt;C&lt;/code&gt; и &lt;code&gt;POSIX&lt;/code&gt; могут использоваться независимо от кодировки базы данных.</target>
        </trans-unit>
        <trans-unit id="4a80b578691f1b5a7af0065fe86a5cb4aa2ce86a" translate="yes" xml:space="preserve">
          <source>Within bracket expressions, &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; lose their outer brackets, and &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt; are illegal. (So, for example, &lt;code&gt;[a-c\d]&lt;/code&gt; is equivalent to &lt;code&gt;[a-c[:digit:]]&lt;/code&gt;. Also, &lt;code&gt;[a-c\D]&lt;/code&gt;, which is equivalent to &lt;code&gt;[a-c^[:digit:]]&lt;/code&gt;, is illegal.)</source>
          <target state="translated">В выражениях в квадратных скобках &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; и &lt;code&gt;\w&lt;/code&gt; теряют свои внешние скобки, а &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; и &lt;code&gt;\W&lt;/code&gt; недопустимы. (Так, например, &lt;code&gt;[a-c\d]&lt;/code&gt; эквивалентно &lt;code&gt;[a-c[:digit:]]&lt;/code&gt; . Кроме того, &lt;code&gt;[a-c\D]&lt;/code&gt; , который эквивалентен &lt;code&gt;[a-c^[:digit:]]&lt;/code&gt; , является недопустимым.)</target>
        </trans-unit>
        <trans-unit id="2542957abf2f09b64545fb48b800de1036c8c62f" translate="yes" xml:space="preserve">
          <source>Within each FSM page is a binary tree, stored in an array with one byte per node. Each leaf node represents a heap page, or a lower level FSM page. In each non-leaf node, the higher of its children's values is stored. The maximum value in the leaf nodes is therefore stored at the root.</source>
          <target state="translated">Внутри каждой страницы FSM находится двоичное дерево,хранящееся в массиве по одному байту на узел.Каждый узел листа представляет собой кучу страниц или страницу FSM нижнего уровня.В каждом нелистовом узле хранится наибольшее из его дочерних значений.Поэтому максимальное значение в узлах листа хранится в корневом каталоге.</target>
        </trans-unit>
        <trans-unit id="eb8d6e1ae92682e55948b9d998dc41d07bd4d9ee" translate="yes" xml:space="preserve">
          <source>Within each catalog row, write comma-separated &lt;code&gt;key&lt;/code&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs. The allowed &lt;code&gt;key&lt;/code&gt;s are the names of the catalog's columns, plus the metadata keys &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;oid_symbol&lt;/code&gt;, &lt;code&gt;array_type_oid&lt;/code&gt;, and &lt;code&gt;descr&lt;/code&gt;. (The use of &lt;code&gt;oid&lt;/code&gt; and &lt;code&gt;oid_symbol&lt;/code&gt; is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-ASSIGNMENT&quot;&gt;Section 69.2.2&lt;/a&gt; below, while &lt;code&gt;array_type_oid&lt;/code&gt; is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-AUTO-ARRAY-TYPES&quot;&gt;Section 69.2.4&lt;/a&gt;. &lt;code&gt;descr&lt;/code&gt; supplies a description string for the object, which will be inserted into &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_shdescription&lt;/code&gt; as appropriate.) While the metadata keys are optional, the catalog's defined columns must all be provided, except when the catalog's &lt;code&gt;.h&lt;/code&gt; file specifies a default value for the column. (In the example above, the &lt;code&gt;datdba&lt;/code&gt; field has been omitted because &lt;code&gt;pg_database.h&lt;/code&gt; supplies a suitable default value for it.)</source>
          <target state="translated">В каждой строке каталога запишите пары &lt;code&gt;key&lt;/code&gt; &lt;code&gt;=&amp;gt;&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; разделенные запятыми . Допустимые &lt;code&gt;key&lt;/code&gt; s имена столбцов в каталог, в плюс ключи метаданных &lt;code&gt;oid&lt;/code&gt; , &lt;code&gt;oid_symbol&lt;/code&gt; , &lt;code&gt;array_type_oid&lt;/code&gt; и &lt;code&gt;descr&lt;/code&gt; . (Использование &lt;code&gt;oid&lt;/code&gt; и &lt;code&gt;oid_symbol&lt;/code&gt; описано в &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-ASSIGNMENT&quot;&gt;Разделе 69.2.2&lt;/a&gt; ниже, в то время как &lt;code&gt;array_type_oid&lt;/code&gt; описан в &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-AUTO-ARRAY-TYPES&quot;&gt;Разделе 69.2.4&lt;/a&gt; . &lt;code&gt;descr&lt;/code&gt; поставка описания строка для объекта, который будет вставлен в &lt;code&gt;pg_description&lt;/code&gt; или &lt;code&gt;pg_shdescription&lt;/code&gt; в зависимости от обстоятельств.) Хотя ключи метаданных являются необязательными, все столбцы, определенные в каталоге, должны быть указаны , за исключением случаев, когда в файле &lt;code&gt;.h&lt;/code&gt; каталога указано значение по умолчанию для столбца. (В приведенном выше &lt;code&gt;datdba&lt;/code&gt; поле datdba было опущено, поскольку &lt;code&gt;pg_database.h&lt;/code&gt; предоставляет для него подходящее значение по умолчанию.)</target>
        </trans-unit>
        <trans-unit id="3b70f85093aa93c4bd37783889d55ab04e575f61" translate="yes" xml:space="preserve">
          <source>Within each pair of curly braces, the metadata fields &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;oid_symbol&lt;/code&gt;, &lt;code&gt;array_type_oid&lt;/code&gt;, and &lt;code&gt;descr&lt;/code&gt; (if present) come first, in that order, then the catalog's own fields appear in their defined order.</source>
          <target state="translated">Внутри каждой пару фигурных скобок, поле метаданных &lt;code&gt;oid&lt;/code&gt; , &lt;code&gt;oid_symbol&lt;/code&gt; , &lt;code&gt;array_type_oid&lt;/code&gt; и &lt;code&gt;descr&lt;/code&gt; (если он присутствует) пришла первую, в таком порядке, а затем собственные поля в каталоге появляются в их определенном порядке.</target>
        </trans-unit>
        <trans-unit id="7877c1484b515b178eb13d5365bc7aee43c3498f" translate="yes" xml:space="preserve">
          <source>Within larger commands, &lt;code&gt;VALUES&lt;/code&gt; is syntactically allowed anywhere that &lt;code&gt;SELECT&lt;/code&gt; is. Because it is treated like a &lt;code&gt;SELECT&lt;/code&gt; by the grammar, it is possible to use the &lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt; (or equivalently &lt;code&gt;FETCH FIRST&lt;/code&gt;), and &lt;code&gt;OFFSET&lt;/code&gt; clauses with a &lt;code&gt;VALUES&lt;/code&gt; command.</source>
          <target state="translated">В более крупных командах &lt;code&gt;VALUES&lt;/code&gt; синтаксически разрешено везде, где есть &lt;code&gt;SELECT&lt;/code&gt; . Поскольку грамматика обрабатывает его как &lt;code&gt;SELECT&lt;/code&gt; , можно использовать предложения &lt;code&gt;ORDER BY&lt;/code&gt; , &lt;code&gt;LIMIT&lt;/code&gt; (или эквивалентно &lt;code&gt;FETCH FIRST&lt;/code&gt; ) и &lt;code&gt;OFFSET&lt;/code&gt; с командой &lt;code&gt;VALUES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85b2c20b975865db54e88c092240735063656bf9" translate="yes" xml:space="preserve">
          <source>Without a &lt;code&gt;table_and_columns&lt;/code&gt; list, &lt;code&gt;ANALYZE&lt;/code&gt; processes every table and materialized view in the current database that the current user has permission to analyze. With a list, &lt;code&gt;ANALYZE&lt;/code&gt; processes only those table(s). It is further possible to give a list of column names for a table, in which case only the statistics for those columns are collected.</source>
          <target state="translated">Без списка &lt;code&gt;table_and_columns&lt;/code&gt; &lt;code&gt;ANALYZE&lt;/code&gt; обрабатывает каждую таблицу и материализованное представление в текущей базе данных, на анализ которой у текущего пользователя есть разрешение. Со списком &lt;code&gt;ANALYZE&lt;/code&gt; обрабатывает только эти таблицы. Кроме того, можно указать список имен столбцов для таблицы, и в этом случае собирается статистика только для этих столбцов.</target>
        </trans-unit>
        <trans-unit id="0bd2342b55fa6fe36f0fd7dea1e8abcfbe35286d" translate="yes" xml:space="preserve">
          <source>Without a &lt;code&gt;table_and_columns&lt;/code&gt; list, &lt;code&gt;VACUUM&lt;/code&gt; processes every table and materialized view in the current database that the current user has permission to vacuum. With a list, &lt;code&gt;VACUUM&lt;/code&gt; processes only those table(s).</source>
          <target state="translated">Без списка &lt;code&gt;table_and_columns&lt;/code&gt; &lt;code&gt;VACUUM&lt;/code&gt; обрабатывает каждую таблицу и материализованное представление в текущей базе данных, на очистку которой у текущего пользователя есть разрешение. Со списком &lt;code&gt;VACUUM&lt;/code&gt; обрабатывает только эти таблицы.</target>
        </trans-unit>
        <trans-unit id="2564642da39c57e6f0da0af32cec7b221b00e6cf" translate="yes" xml:space="preserve">
          <source>Without a qualification, &lt;code&gt;DELETE&lt;/code&gt; will remove &lt;em&gt;all&lt;/em&gt; rows from the given table, leaving it empty. The system will not request confirmation before doing this!</source>
          <target state="translated">Без квалификации &lt;code&gt;DELETE&lt;/code&gt; удалит &lt;em&gt;все&lt;/em&gt; строки из данной таблицы, оставив ее пустой. Перед этим система не запрашивает подтверждения!</target>
        </trans-unit>
        <trans-unit id="63fcdcc5d8356bd3ccce31a7a0f56d4a3af85303" translate="yes" xml:space="preserve">
          <source>Without functional-dependency statistics, the planner would assume that the two &lt;code&gt;WHERE&lt;/code&gt; conditions are independent, and would multiply their selectivities together to arrive at a much-too-small row count estimate. With such statistics, the planner recognizes that the &lt;code&gt;WHERE&lt;/code&gt; conditions are redundant and does not underestimate the row count.</source>
          <target state="translated">Без статистики функциональной зависимости планировщик предположил бы, что два условия &lt;code&gt;WHERE&lt;/code&gt; независимы, и умножил бы их избирательность вместе, чтобы получить слишком маленькую оценку количества строк. С такой статистикой планировщик признает, что условия &lt;code&gt;WHERE&lt;/code&gt; избыточны, и не недооценивает количество строк.</target>
        </trans-unit>
        <trans-unit id="dc783547ace7f2e9e22e7b50a67f3d97784d6474" translate="yes" xml:space="preserve">
          <source>Without partition pruning, the above query would scan each of the partitions of the &lt;code&gt;measurement&lt;/code&gt; table. With partition pruning enabled, the planner will examine the definition of each partition and prove that the partition need not be scanned because it could not contain any rows meeting the query's &lt;code&gt;WHERE&lt;/code&gt; clause. When the planner can prove this, it excludes (&lt;em&gt;prunes&lt;/em&gt;) the partition from the query plan.</source>
          <target state="translated">Без сокращения разделов вышеуказанный запрос будет сканировать каждый из разделов таблицы &lt;code&gt;measurement&lt;/code&gt; . При включенном сокращении секций планировщик проверит определение каждой секции и докажет, что секция не требует сканирования, поскольку она не может содержать строк, соответствующих условию &lt;code&gt;WHERE&lt;/code&gt; запроса . Когда планировщик может это доказать, он исключает ( &lt;em&gt;отсекает&lt;/em&gt; ) секцию из плана запроса.</target>
        </trans-unit>
        <trans-unit id="23034486b72d6e700160ee9f0facdf636985eee4" translate="yes" xml:space="preserve">
          <source>Without quotes, &lt;code&gt;to_tsquery&lt;/code&gt; will generate a syntax error for tokens that are not separated by an AND, OR, or FOLLOWED BY operator.</source>
          <target state="translated">Без кавычек &lt;code&gt;to_tsquery&lt;/code&gt; будет генерировать синтаксическую ошибку для токенов, которые не разделены операторами AND, OR или FOLLOWED BY.</target>
        </trans-unit>
        <trans-unit id="8d1c012acaa571247fa7393ff98695c754cfacba" translate="yes" xml:space="preserve">
          <source>Without the extra parentheses, this will generate a syntax error.</source>
          <target state="translated">Без лишних скобок это приведет к синтаксической ошибке.</target>
        </trans-unit>
        <trans-unit id="3003268a98f289ec381313920f30367739bc175f" translate="yes" xml:space="preserve">
          <source>Without the third rule, it is possible for an index reader to see an index entry just before it is removed by &lt;code&gt;VACUUM&lt;/code&gt;, and then to arrive at the corresponding heap entry after that was removed by &lt;code&gt;VACUUM&lt;/code&gt;. This creates no serious problems if that item number is still unused when the reader reaches it, since an empty item slot will be ignored by &lt;code&gt;heap_fetch()&lt;/code&gt;. But what if a third backend has already re-used the item slot for something else? When using an MVCC-compliant snapshot, there is no problem because the new occupant of the slot is certain to be too new to pass the snapshot test. However, with a non-MVCC-compliant snapshot (such as &lt;code&gt;SnapshotAny&lt;/code&gt;), it would be possible to accept and return a row that does not in fact match the scan keys. We could defend against this scenario by requiring the scan keys to be rechecked against the heap row in all cases, but that is too expensive. Instead, we use a pin on an index page as a proxy to indicate that the reader might still be &amp;ldquo;in flight&amp;rdquo; from the index entry to the matching heap entry. Making &lt;code&gt;ambulkdelete&lt;/code&gt; block on such a pin ensures that &lt;code&gt;VACUUM&lt;/code&gt; cannot delete the heap entry before the reader is done with it. This solution costs little in run time, and adds blocking overhead only in the rare cases where there actually is a conflict.</source>
          <target state="translated">Без третьего правила читатель индекса может увидеть запись индекса непосредственно перед ее удалением с помощью &lt;code&gt;VACUUM&lt;/code&gt; , а затем достичь соответствующей записи в куче после того, как она была удалена с помощью &lt;code&gt;VACUUM&lt;/code&gt; . Это не создает серьезных проблем, если этот номер элемента все еще не используется, когда считыватель достигает его, поскольку пустой слот элемента будет игнорироваться &lt;code&gt;heap_fetch()&lt;/code&gt; . Но что, если третий сервер уже повторно использовал слот элемента для чего-то другого? При использовании снимка, совместимого с MVCC, проблем не возникает, потому что новый владелец слота наверняка слишком новичок для прохождения теста снимка. Однако с моментальным снимком, не совместимым с MVCC (например, &lt;code&gt;SnapshotAny&lt;/code&gt; ), можно было бы принять и вернуть строку, которая фактически не соответствует ключам сканирования. Мы могли бы защититься от этого сценария, потребовав во всех случаях повторной проверки ключей сканирования по строке кучи, но это слишком дорого. Вместо этого мы используем булавку на странице индекса в качестве прокси, чтобы указать, что читатель все еще может быть &amp;laquo;в движении&amp;raquo; от записи индекса до соответствующей записи в куче. Создание &lt;code&gt;ambulkdelete&lt;/code&gt; блока на такой штифт гарантирует , что &lt;code&gt;VACUUM&lt;/code&gt; не может удалить запись кучи перед читателем делается с ним. Это решение не требует больших затрат времени выполнения и добавляет накладные расходы на блокировку только в тех редких случаях, когда действительно существует конфликт.</target>
        </trans-unit>
        <trans-unit id="fdba0729d7141c4dc983525f28420a370b378b16" translate="yes" xml:space="preserve">
          <source>Without this clause, it is an error to specify an explicit value (other than &lt;code&gt;DEFAULT&lt;/code&gt;) for an identity column defined as &lt;code&gt;GENERATED ALWAYS&lt;/code&gt;. This clause overrides that restriction.</source>
          <target state="translated">Без этого предложения будет ошибкой указывать явное значение (отличное от &lt;code&gt;DEFAULT&lt;/code&gt; ) для столбца идентификации, определенного как &lt;code&gt;GENERATED ALWAYS&lt;/code&gt; . Этот пункт отменяет это ограничение.</target>
        </trans-unit>
        <trans-unit id="77f4e928561a920783857c04bc4af1f2750cf7f5" translate="yes" xml:space="preserve">
          <source>Without this option, the backup will start by enumerating the size of the entire database, and then go back and send the actual contents. This may make the backup take slightly longer, and in particular it will take longer before the first data is sent. This option is useful to avoid such estimation time if it's too long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de5c631615b4050dbf3abcb11bda852949d1d49" translate="yes" xml:space="preserve">
          <source>Word, all ASCII letters</source>
          <target state="translated">Словом,все письма ASCII</target>
        </trans-unit>
        <trans-unit id="cd638519c2bb50f94881c41d59edcf0f4b988187" translate="yes" xml:space="preserve">
          <source>Word, all letters</source>
          <target state="translated">Словом,все письма</target>
        </trans-unit>
        <trans-unit id="d929261f89fb5edc0a55361dccd5a42cfafc1e28" translate="yes" xml:space="preserve">
          <source>Word, letters and digits</source>
          <target state="translated">Слово,буквы и цифры</target>
        </trans-unit>
        <trans-unit id="1c821c5f35490070199526bcafeccdc95331fb80" translate="yes" xml:space="preserve">
          <source>Work is still needed to improve the genetic algorithm parameter settings. In file &lt;code&gt;src/backend/optimizer/geqo/geqo_main.c&lt;/code&gt;, routines &lt;code&gt;gimme_pool_size&lt;/code&gt; and &lt;code&gt;gimme_number_generations&lt;/code&gt;, we have to find a compromise for the parameter settings to satisfy two competing demands:</source>
          <target state="translated">Еще требуется работа по улучшению настроек параметров генетического алгоритма. В файле &lt;code&gt;src/backend/optimizer/geqo/geqo_main.c&lt;/code&gt; , в подпрограммах &lt;code&gt;gimme_pool_size&lt;/code&gt; и &lt;code&gt;gimme_number_generations&lt;/code&gt; мы должны найти компромисс для настроек параметров, чтобы удовлетворить два конкурирующих требования:</target>
        </trans-unit>
        <trans-unit id="3ae6871c604e1194dadbdf1baf868fa3278d7cc4" translate="yes" xml:space="preserve">
          <source>Write Ahead Log</source>
          <target state="translated">Написать передний журнал</target>
        </trans-unit>
        <trans-unit id="3f9793b6786fb282a995505c49ca5c8dab4849b1" translate="yes" xml:space="preserve">
          <source>Write a message to the server log if checkpoints caused by the filling of WAL segment files happen closer together than this amount of time (which suggests that &lt;code&gt;max_wal_size&lt;/code&gt; ought to be raised). If this value is specified without units, it is taken as seconds. The default is 30 seconds (&lt;code&gt;30s&lt;/code&gt;). Zero disables the warning. No warnings will be generated if &lt;code&gt;checkpoint_timeout&lt;/code&gt; is less than &lt;code&gt;checkpoint_warning&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Запишите сообщение в журнал сервера, если контрольные точки, вызванные заполнением файлов сегментов WAL, происходят ближе друг к другу, чем это время (что предполагает, что &lt;code&gt;max_wal_size&lt;/code&gt; следует поднять). Если это значение указано без единиц измерения, оно принимается в секундах. Значение по умолчанию составляет 30 секунд ( &lt;code&gt;30s&lt;/code&gt; ). Ноль отключает предупреждение. Никаких предупреждений не будет, если &lt;code&gt;checkpoint_timeout&lt;/code&gt; меньше, чем &lt;code&gt;checkpoint_warning&lt;/code&gt; . Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="79f29b256742ae32a7ee610c6c80dec55fe4bb44" translate="yes" xml:space="preserve">
          <source>Write all query output into file &lt;code&gt;filename&lt;/code&gt;, in addition to the normal output destination.</source>
          <target state="translated">Записывать весь вывод запроса в файл &lt;code&gt;filename&lt;/code&gt; в дополнение к обычному месту назначения вывода.</target>
        </trans-unit>
        <trans-unit id="ced9f94f9040a73c60549d122b831459c11a3fbf" translate="yes" xml:space="preserve">
          <source>Write information about each transaction to a log file. See below for details.</source>
          <target state="translated">Запишите информацию о каждой транзакции в лог-файл.Подробности см.ниже.</target>
        </trans-unit>
        <trans-unit id="e33b6c1a70b5c50c6203011bb22d6394a5061934" translate="yes" xml:space="preserve">
          <source>Write received and decoded transaction data into this file. Use &lt;code&gt;-&lt;/code&gt; for stdout.</source>
          <target state="translated">Записать полученные и декодированные данные транзакции в этот файл. Используйте &lt;code&gt;-&lt;/code&gt; для стандартного вывода.</target>
        </trans-unit>
        <trans-unit id="660438e8219803d5c64d3c38fd0601dbee576ac1" translate="yes" xml:space="preserve">
          <source>Write the output as plain files, with the same layout as the current data directory and tablespaces. When the cluster has no additional tablespaces, the whole database will be placed in the target directory. If the cluster contains additional tablespaces, the main data directory will be placed in the target directory, but all other tablespaces will be placed in the same absolute path as they have on the server.</source>
          <target state="translated">Записывайте выходные данные в виде простых файлов,с той же компоновкой,что и в текущем каталоге данных и табличных пространствах.Когда в кластере не будет дополнительных табличных пространств,вся БД будет помещена в целевую директорию.Если в кластере есть дополнительные табличные пространства,то основной каталог данных будет помещен в целевую директорию,а все остальные табличные пространства будут размещены по тому же абсолютному пути,что и на сервере.</target>
        </trans-unit>
        <trans-unit id="6b1ff15d67ddd19c1531e3e1b72239d7b15119da" translate="yes" xml:space="preserve">
          <source>Write the output as plain files, with the same layout as the source server's data directory and tablespaces. When the cluster has no additional tablespaces, the whole database will be placed in the target directory. If the cluster contains additional tablespaces, the main data directory will be placed in the target directory, but all other tablespaces will be placed in the same absolute path as they have on the source server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc92c3f4b6de8494f22f127e95dec8313f91169" translate="yes" xml:space="preserve">
          <source>Write the output as tar files in the target directory. The main data directory will be written to a file named &lt;code&gt;base.tar&lt;/code&gt;, and all other tablespaces will be named after the tablespace OID.</source>
          <target state="translated">Запишите вывод в виде файлов tar в целевой каталог. Каталог основных данных будет записан в файл с именем &lt;code&gt;base.tar&lt;/code&gt; , а все остальные табличные пространства будут названы в соответствии с OID табличного пространства.</target>
        </trans-unit>
        <trans-unit id="a1016f820515616448d3af03f5c6cb584f20f3bd" translate="yes" xml:space="preserve">
          <source>Write the output as tar files in the target directory. The main data directory's contents will be written to a file named &lt;code&gt;base.tar&lt;/code&gt;, and each other tablespace will be written to a separate tar file named after that tablespace's OID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12aba288e98df3f05ebad1cf7143b1a4df822af8" translate="yes" xml:space="preserve">
          <source>Write, or append to, a text file</source>
          <target state="translated">Напишите или добавьте к текстовому файлу.</target>
        </trans-unit>
        <trans-unit id="73694598d4f6dd9ae50f65c44a8d5357103fbda0" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log</source>
          <target state="translated">Журнал записи</target>
        </trans-unit>
        <trans-unit id="32219ea741aab08cd4b2cc75491ff92cd882b3c1" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log Shipping</source>
          <target state="translated">Доставка журнала на запись</target>
        </trans-unit>
        <trans-unit id="bd375d03897609b092749de9e582ed65e566d377" translate="yes" xml:space="preserve">
          <source>Write-ahead log</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab8077ca2cb9e3834b524a783525c97b082b885" translate="yes" xml:space="preserve">
          <source>Write-heavy workloads that don't benefit from deduplication due to having few or no duplicate values in indexes will incur a small, fixed performance penalty (unless deduplication is explicitly disabled). The &lt;code&gt;deduplicate_items&lt;/code&gt; storage parameter can be used to disable deduplication within individual indexes. There is never any performance penalty with read-only workloads, since reading posting list tuples is at least as efficient as reading the standard tuple representation. Disabling deduplication isn't usually helpful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674bcf8c81a59458958b21d0660da76f6ba332b5" translate="yes" xml:space="preserve">
          <source>Writes the current query buffer to the file &lt;code&gt;filename&lt;/code&gt; or pipes it to the shell command &lt;code&gt;command&lt;/code&gt;. If the current query buffer is empty, the most recently executed query is written instead.</source>
          <target state="translated">Записывает текущий буфер запроса в файл &lt;code&gt;filename&lt;/code&gt; или передает его команде &lt;code&gt;command&lt;/code&gt; оболочки . Если текущий буфер запроса пуст, вместо него записывается последний выполненный запрос.</target>
        </trans-unit>
        <trans-unit id="b84228914215a42dbe6fe7e926dad3ab9b4cf367" translate="yes" xml:space="preserve">
          <source>Writes the generated LLVM IR out to the file system, inside &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;. This is only useful for working on the internals of the JIT implementation. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be changed by a superuser.</source>
          <target state="translated">Записывает сгенерированный IR LLVM в файловую систему внутри &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt; . Это полезно только для работы с внутренней частью реализации JIT. По умолчанию &lt;code&gt;off&lt;/code&gt; . Этот параметр может быть изменен только суперпользователем.</target>
        </trans-unit>
        <trans-unit id="682768582621701d8f61b9c4bbc3b649ebde2e19" translate="yes" xml:space="preserve">
          <source>Writes, or appends to, a text file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5af6404c7f764d57f9d5c62315cdf9f310e1309" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;*&lt;/code&gt; is not necessary, since this behavior is always the default. However, this syntax is still supported for compatibility with older releases where the default could be changed.</source>
          <target state="translated">Писать &lt;code&gt;*&lt;/code&gt; не обязательно, так как это всегда по умолчанию. Однако этот синтаксис по-прежнему поддерживается для совместимости со старыми выпусками, где значение по умолчанию можно было изменить.</target>
        </trans-unit>
        <trans-unit id="6151e701c60f047c7b832b2686813d1310a12fca" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;ALL&lt;/code&gt; in place of a specific privilege grants all privileges that are relevant for the object type.</source>
          <target state="translated">Запись &lt;code&gt;ALL&lt;/code&gt; вместо определенной привилегии предоставляет все привилегии, относящиеся к типу объекта.</target>
        </trans-unit>
        <trans-unit id="f43277b6f1b770dadde2ceed80f27334202f924f" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;SECURITY DEFINER&lt;/code&gt; Functions Safely</source>
          <target state="translated">Запись &lt;code&gt;SECURITY DEFINER&lt;/code&gt; функции Safely</target>
        </trans-unit>
        <trans-unit id="ffbf328be37b139670f7ef37c6af175473c5c705" translate="yes" xml:space="preserve">
          <source>Writing a custom application, using one of the several available language bindings. These possibilities are discussed further in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-interfaces.html&quot;&gt;Part IV&lt;/a&gt;.</source>
          <target state="translated">Написание собственного приложения с использованием одной из нескольких доступных языковых привязок. Эти возможности обсуждаются далее в &lt;a href=&quot;https://www.postgresql.org/docs/12/client-interfaces.html&quot;&gt;Части IV&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2f9ec6d7e0edde20b9de31e1198d1816d564790" translate="yes" xml:space="preserve">
          <source>Writing a custom application, using one of the several available language bindings. These possibilities are discussed further in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-interfaces.html&quot;&gt;Part IV&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5165fc57d1f9a5e5c5994fec1932df3a128a9e" translate="yes" xml:space="preserve">
          <source>Writing the actual numeric value of any OID in C code is considered very bad form; always use a macro, instead. Direct references to &lt;code&gt;pg_proc&lt;/code&gt; OIDs are common enough that there's a special mechanism to create the necessary macros automatically; see &lt;code&gt;src/backend/utils/Gen_fmgrtab.pl&lt;/code&gt;. Similarly &amp;mdash; but, for historical reasons, not done the same way &amp;mdash; there's an automatic method for creating macros for &lt;code&gt;pg_type&lt;/code&gt; OIDs. &lt;code&gt;oid_symbol&lt;/code&gt; entries are therefore not necessary in those two catalogs. Likewise, macros for the &lt;code&gt;pg_class&lt;/code&gt; OIDs of system catalogs and indexes are set up automatically. For all other system catalogs, you have to manually specify any macros you need via &lt;code&gt;oid_symbol&lt;/code&gt; entries.</source>
          <target state="translated">Запись действительного числового значения любого OID в коде C считается очень плохим тоном; вместо этого всегда используйте макрос. Прямые ссылки на OID &lt;code&gt;pg_proc&lt;/code&gt; достаточно распространены, поэтому существует специальный механизм для автоматического создания необходимых макросов; см. &lt;code&gt;src/backend/utils/Gen_fmgrtab.pl&lt;/code&gt; . Точно так же - но по историческим причинам - не так - существует автоматический метод создания макросов для OID &lt;code&gt;pg_type&lt;/code&gt; . &lt;code&gt;oid_symbol&lt;/code&gt; записи oid_symbol в этих двух каталогах не нужны. Аналогично, макросы для OID &lt;code&gt;pg_class&lt;/code&gt; системных каталогов и индексов устанавливаются автоматически. Для всех остальных системных каталогов вы должны вручную указать любые нужные макросы через записи &lt;code&gt;oid_symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="d5409f1461aa5b5298ee6d5c93002f7a27e50654" translate="yes" xml:space="preserve">
          <source>XID</source>
          <target state="translated">XID</target>
        </trans-unit>
        <trans-unit id="70fc167721857c5174dbbe545fe597100e840cd6" translate="yes" xml:space="preserve">
          <source>XID for VACUUM operation moving a row version</source>
          <target state="translated">XID для операции VACUUM перемещение версии ряда</target>
        </trans-unit>
        <trans-unit id="c0aa9ef764d832b80428d756a731a94251b0e3a1" translate="yes" xml:space="preserve">
          <source>XML</source>
          <target state="translated">XML</target>
        </trans-unit>
        <trans-unit id="6dbc2e3a95bd424284a60fab71bfd99ecc6aa480" translate="yes" xml:space="preserve">
          <source>XML Functions</source>
          <target state="translated">XML-функции</target>
        </trans-unit>
        <trans-unit id="677fbcd727fb96243fff280b768de17534da204d" translate="yes" xml:space="preserve">
          <source>XML Limits and Conformance to SQL/XML</source>
          <target state="translated">Ограничения XML и соответствие SQL/XML</target>
        </trans-unit>
        <trans-unit id="be1200e7280e074bb09cc29b489d7736fa9c3b13" translate="yes" xml:space="preserve">
          <source>XML Type</source>
          <target state="translated">тип XML</target>
        </trans-unit>
        <trans-unit id="72f6e6e18c4cf2cdf2736a3171665401b5f531b0" translate="yes" xml:space="preserve">
          <source>XML data</source>
          <target state="translated">XML-данные</target>
        </trans-unit>
        <trans-unit id="9bc2b7976718250ab1463410139c7c00b0f2e7ce" translate="yes" xml:space="preserve">
          <source>XML declarations, if present, are combined as follows. If all argument values have the same XML version declaration, that version is used in the result, else no version is used. If all argument values have the standalone declaration value &amp;ldquo;yes&amp;rdquo;, then that value is used in the result. If all argument values have a standalone declaration value and at least one is &amp;ldquo;no&amp;rdquo;, then that is used in the result. Else the result will have no standalone declaration. If the result is determined to require a standalone declaration but no version declaration, a version declaration with version 1.0 will be used because XML requires an XML declaration to contain a version declaration. Encoding declarations are ignored and removed in all cases.</source>
          <target state="translated">Объявления XML, если они есть, объединяются следующим образом. Если все значения аргументов имеют одно и то же объявление версии XML, эта версия используется в результате, иначе версия не используется. Если все значения аргументов имеют значение автономного объявления &amp;laquo;да&amp;raquo;, то это значение используется в результате. Если все значения аргументов имеют значение отдельного объявления и хотя бы одно из них - &amp;laquo;нет&amp;raquo;, то оно используется в результате. В противном случае результат не будет иметь отдельного объявления. Если в результате определено, что требуется отдельное объявление, но не объявление версии, будет использоваться объявление версии с версией 1.0, поскольку XML требует, чтобы объявление XML содержало объявление версии. Объявления кодировки игнорируются и удаляются во всех случаях.</target>
        </trans-unit>
        <trans-unit id="93db77a518a3a65df06b8910ae3df05493323aa8" translate="yes" xml:space="preserve">
          <source>XML entity</source>
          <target state="translated">объект XML</target>
        </trans-unit>
        <trans-unit id="41d948a6e01de6c3d4845c4fb6a9cd77bb4a345f" translate="yes" xml:space="preserve">
          <source>XML format is left as an exercise for the reader.</source>
          <target state="translated">Формат XML оставлен в качестве упражнения для читателя.</target>
        </trans-unit>
        <trans-unit id="c648229e46576f92e57966e5bb6a169947ab07af" translate="yes" xml:space="preserve">
          <source>XML tag</source>
          <target state="translated">XML-тег</target>
        </trans-unit>
        <trans-unit id="b7b6740d5d3d1f4067adb9c002cd0cc814ec4855" translate="yes" xml:space="preserve">
          <source>XML: IS DOCUMENT</source>
          <target state="translated">XML:ЕСТЬ ДОКУМЕНТ</target>
        </trans-unit>
        <trans-unit id="863fe78f50c66a6f7d93b18bf787a5d0aa670b5c" translate="yes" xml:space="preserve">
          <source>XML: IS NOT DOCUMENT</source>
          <target state="translated">XML:НЕ ЯВЛЯЕТСЯ ДОКУМЕНТОМ</target>
        </trans-unit>
        <trans-unit id="708b35917f64aea4aecf43902f9f6861b388f0a3" translate="yes" xml:space="preserve">
          <source>XML: XMLEXISTS</source>
          <target state="translated">XML:XMLEXISTS</target>
        </trans-unit>
        <trans-unit id="7aea648b2b4e07c316d48e040a2dfe07aea119ed" translate="yes" xml:space="preserve">
          <source>XML: xml_is_well_formed</source>
          <target state="translated">XML:xml_is_well_formed</target>
        </trans-unit>
        <trans-unit id="3eca7373df1b8e0c5ed4c506c73dcc360d0c1000" translate="yes" xml:space="preserve">
          <source>XML: xmlagg</source>
          <target state="translated">XML:xmlag</target>
        </trans-unit>
        <trans-unit id="31986b6f48c236780bb28b6f7a97cd2e7fe2fbbc" translate="yes" xml:space="preserve">
          <source>XML: xmlcomment</source>
          <target state="translated">XML:xml комментарий</target>
        </trans-unit>
        <trans-unit id="3336319324aa48adbaa76e0cbbf9934042dd41f7" translate="yes" xml:space="preserve">
          <source>XML: xmlconcat</source>
          <target state="translated">XML:xmlconcat</target>
        </trans-unit>
        <trans-unit id="c269b1860c6e177984dcd77f1f2f9180f500a7b1" translate="yes" xml:space="preserve">
          <source>XML: xmlelement</source>
          <target state="translated">XML:xmlelement</target>
        </trans-unit>
        <trans-unit id="f6f6cd60dad73c2efa2b22421846170fa537daf4" translate="yes" xml:space="preserve">
          <source>XML: xmlforest</source>
          <target state="translated">XML:xmlforest</target>
        </trans-unit>
        <trans-unit id="b4c3ab3b44e0a9d5e8cf4d618e5fb213a70446ae" translate="yes" xml:space="preserve">
          <source>XML: xmlpi</source>
          <target state="translated">XML:xmlpi</target>
        </trans-unit>
        <trans-unit id="2cb9abaad07f3be72c6b803b64719f6ad9373b8b" translate="yes" xml:space="preserve">
          <source>XML: xmlroot</source>
          <target state="translated">XML:xmlroot</target>
        </trans-unit>
        <trans-unit id="fe1c1afeea56eb4d61a6d5854b178d21b29bd194" translate="yes" xml:space="preserve">
          <source>XML: xmltable</source>
          <target state="translated">XML:xmltable</target>
        </trans-unit>
        <trans-unit id="943bcc21921946abacf747784b147601338c43bb" translate="yes" xml:space="preserve">
          <source>XML: xpath</source>
          <target state="translated">XML:xpath</target>
        </trans-unit>
        <trans-unit id="112eb0200c63c2f0de87632cdeab3a1c8a706831" translate="yes" xml:space="preserve">
          <source>XML: xpath_exists</source>
          <target state="translated">XML:xpath_exists</target>
        </trans-unit>
        <trans-unit id="a417f6430ccc4b644617c160b0d4f1b2c80cd5e2" translate="yes" xml:space="preserve">
          <source>XPath 1.0 blurs the distinction between &lt;em&gt;value comparisons&lt;/em&gt; and &lt;em&gt;general comparisons&lt;/em&gt; as XQuery/XPath define them. Both &lt;code&gt;sale/@hatsize = 7&lt;/code&gt; and &lt;code&gt;sale/@customer = &quot;alice&quot;&lt;/code&gt; are existentially quantified comparisons, true if there is any &lt;code&gt;sale&lt;/code&gt; with the given value for the attribute, but &lt;code&gt;sale/@taxable = false()&lt;/code&gt; is a value comparison to the &lt;em&gt;effective boolean value&lt;/em&gt; of a whole node-set. It is true only if no &lt;code&gt;sale&lt;/code&gt; has a &lt;code&gt;taxable&lt;/code&gt; attribute at all.</source>
          <target state="translated">XPath 1.0 стирает различие между &lt;em&gt;сравнением значений&lt;/em&gt; и &lt;em&gt;общим сравнением,&lt;/em&gt; поскольку XQuery / XPath определяет их. Как &lt;code&gt;sale/@hatsize = 7&lt;/code&gt; и &lt;code&gt;sale/@customer = &quot;alice&quot;&lt;/code&gt; являются экзистенциально определяемыми количественными сравнениями, true, если есть какая-либо &lt;code&gt;sale&lt;/code&gt; с заданным значением атрибута, но &lt;code&gt;sale/@taxable = false()&lt;/code&gt; - это сравнение значений с &lt;em&gt;эффективное логическое значение&lt;/em&gt; всего набора узлов. Это верно только в том случае, если никакая &lt;code&gt;sale&lt;/code&gt; имеет &lt;code&gt;taxable&lt;/code&gt; атрибута.</target>
        </trans-unit>
        <trans-unit id="f37617c0d5dc43deba6ebd523a1e7daa408818b2" translate="yes" xml:space="preserve">
          <source>XPath 1.0 does not specify an order for nodes in a node-set, so code that relies on a particular order of the results will be implementation-dependent. Details can be found in &lt;a href=&quot;xml-limits-conformance#XML-XPATH-1-SPECIFICS&quot;&gt;Section D.3.1.2&lt;/a&gt;.</source>
          <target state="translated">XPath 1.0 не определяет порядок узлов в наборе узлов, поэтому код, основанный на определенном порядке результатов, будет зависеть от реализации. Подробности можно найти в &lt;a href=&quot;xml-limits-conformance#XML-XPATH-1-SPECIFICS&quot;&gt;Разделе D.3.1.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccec9b819d48fea6e95ee65b1f2c2363e5212016" translate="yes" xml:space="preserve">
          <source>XPath 1.0 has no conditional operator. An XQuery/XPath expression such as &lt;code&gt;if ( hat ) then hat/@size else &quot;no hat&quot;&lt;/code&gt; has no XPath 1.0 equivalent.</source>
          <target state="translated">XPath 1.0 не имеет условного оператора. Выражение XQuery / XPath, такое как &lt;code&gt;if ( hat ) then hat/@size else &quot;no hat&quot;&lt;/code&gt; не имеет эквивалента XPath 1.0.</target>
        </trans-unit>
        <trans-unit id="575a5727a0aaf2dc929963572ab31f3a07d3b31b" translate="yes" xml:space="preserve">
          <source>XPath 1.0 has no ordering comparison operator for strings. Both &lt;code&gt;&quot;cat&quot; &amp;lt; &quot;dog&quot;&lt;/code&gt; and &lt;code&gt;&quot;cat&quot; &amp;gt; &quot;dog&quot;&lt;/code&gt; are false, because each is a numeric comparison of two &lt;code&gt;NaN&lt;/code&gt;s. In contrast, &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; do compare the strings as strings.</source>
          <target state="translated">XPath 1.0 не имеет оператора сравнения порядка для строк. Оба слова &lt;code&gt;&quot;cat&quot; &amp;lt; &quot;dog&quot;&lt;/code&gt; и &lt;code&gt;&quot;cat&quot; &amp;gt; &quot;dog&quot;&lt;/code&gt; ложны, потому что каждое из них представляет собой числовое сравнение двух &lt;code&gt;NaN&lt;/code&gt; . Напротив, &lt;code&gt;=&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; Сравнивают строки как строки.</target>
        </trans-unit>
        <trans-unit id="8c4149ee47a54aa2c037b2786d8549ef1627ad8e" translate="yes" xml:space="preserve">
          <source>XQuery allows declaration and use of local functions.</source>
          <target state="translated">XQuery позволяет объявлять и использовать локальные функции.</target>
        </trans-unit>
        <trans-unit id="818970bcffceb4be8cc185fddd03719babd24f42" translate="yes" xml:space="preserve">
          <source>XQuery character class elements using &lt;code&gt;\p{UnicodeProperty}&lt;/code&gt; or the inverse &lt;code&gt;\P{UnicodeProperty}&lt;/code&gt; are not supported.</source>
          <target state="translated">Элементы класса символов XQuery, использующие &lt;code&gt;\p{UnicodeProperty}&lt;/code&gt; или обратный &lt;code&gt;\P{UnicodeProperty}&lt;/code&gt; , не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="6f9675f91b1bee552c1436f5af897518b9d66036" translate="yes" xml:space="preserve">
          <source>XQuery character class shorthands &lt;code&gt;\c&lt;/code&gt;, &lt;code&gt;\C&lt;/code&gt;, &lt;code&gt;\i&lt;/code&gt;, and &lt;code&gt;\I&lt;/code&gt; are not supported.</source>
          <target state="translated">Сокращения классов символов XQuery &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\C&lt;/code&gt; , &lt;code&gt;\i&lt;/code&gt; и &lt;code&gt;\I&lt;/code&gt; не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="e05d40877e991191e09256daf83989a5f47e5557" translate="yes" xml:space="preserve">
          <source>XQuery character class subtraction is not supported. An example of this feature is using the following to match only English consonants: &lt;code&gt;[a-z-[aeiou]]&lt;/code&gt;.</source>
          <target state="translated">Вычитание класса символов XQuery не поддерживается. Примером этой функции является использование следующего для соответствия только английским согласным: &lt;code&gt;[a-z-[aeiou]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7ba7fb2ffaaf928a3568f9854442e7071379dc9" translate="yes" xml:space="preserve">
          <source>XQuery does not have lookahead or lookbehind constraints, nor any of the constraint escapes described in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;.</source>
          <target state="translated">XQuery не имеет ограничений просмотра вперед или назад, а также каких-либо экранирований ограничений, описанных в &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Таблице 9.21&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb9c8b3c7792b9cf1dc2ef58684f3e70a06da1d2" translate="yes" xml:space="preserve">
          <source>XQuery does not have lookahead or lookbehind constraints, nor any of the constraint escapes described in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.22&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41577214ab7c5c54db475c958675a49fbb00b4a6" translate="yes" xml:space="preserve">
          <source>XQuery does not support the &lt;code&gt;[:name:]&lt;/code&gt; syntax for character classes within bracket expressions.</source>
          <target state="translated">XQuery не поддерживает синтаксис &lt;code&gt;[:name:]&lt;/code&gt; для классов символов в выражениях в квадратных скобках.</target>
        </trans-unit>
        <trans-unit id="2e0c3c6ff5da1ba3d8311b799d1cf51c7385d7c2" translate="yes" xml:space="preserve">
          <source>XQuery expressions can construct and return new XML nodes, in addition to all possible XPath values. XPath can create and return values of the atomic types (numbers, strings, and so on) but can only return XML nodes that were already present in documents supplied as input to the expression.</source>
          <target state="translated">Выражения XQuery могут создавать и возвращать новые XML-узлы в дополнение ко всем возможным значениям XPath.XPath может создавать и возвращать значения атомных типов (числа,строки и т.д.),но может возвращать только те XML-узлы,которые уже присутствовали в документах,предоставленных в качестве входных для выражения.</target>
        </trans-unit>
        <trans-unit id="7d07dea26dd7592af4147bb1ae9d21c709ece2a7" translate="yes" xml:space="preserve">
          <source>XQuery has control constructs for iteration, sorting, and grouping.</source>
          <target state="translated">XQuery имеет конструкции управления для итерации,сортировки и группировки.</target>
        </trans-unit>
        <trans-unit id="9add350a4eb532be8a2c9c9d393be8bd03cceb66" translate="yes" xml:space="preserve">
          <source>XQuery's &lt;code&gt;s&lt;/code&gt; (allow dot to match newline) and &lt;code&gt;m&lt;/code&gt; (allow &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to match at newlines) flags provide access to the same behaviors as POSIX's &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; flags, but they do &lt;em&gt;not&lt;/em&gt; match the behavior of POSIX's &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; flags. Note in particular that dot-matches-newline is the default behavior in POSIX but not XQuery.</source>
          <target state="translated">Флаги XQuery &lt;code&gt;s&lt;/code&gt; (разрешить точку совпадать с новой строкой) и &lt;code&gt;m&lt;/code&gt; (разрешить &lt;code&gt;^&lt;/code&gt; и &lt;code&gt;$&lt;/code&gt; совпадать с новой строкой) обеспечивают доступ к тому же поведению, что и флаги POSIX &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; и &lt;code&gt;w&lt;/code&gt; , но они &lt;em&gt;не&lt;/em&gt; соответствуют поведению флагов POSIX &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;m&lt;/code&gt; . Обратите внимание, в частности, что точка-совпадение-новая строка является поведением по умолчанию в POSIX, но не в XQuery.</target>
        </trans-unit>
        <trans-unit id="0fbdf61430816231b42e0b59499fabbec39b5ae3" translate="yes" xml:space="preserve">
          <source>XQuery's &lt;code&gt;x&lt;/code&gt; (ignore whitespace in pattern) flag is noticeably different from POSIX's expanded-mode flag. POSIX's &lt;code&gt;x&lt;/code&gt; flag also allows &lt;code&gt;#&lt;/code&gt; to begin a comment in the pattern, and POSIX will not ignore a whitespace character after a backslash.</source>
          <target state="translated">Флаг XQuery &lt;code&gt;x&lt;/code&gt; (игнорировать пробелы в шаблоне) заметно отличается от флага расширенного режима POSIX. Флаг &lt;code&gt;x&lt;/code&gt; POSIX также позволяет &lt;code&gt;#&lt;/code&gt; начинать комментарий в шаблоне, и POSIX не будет игнорировать пробельный символ после обратной косой черты.</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="cb29757e458776404c0d0c4f5c75b0740d559b1c" translate="yes" xml:space="preserve">
          <source>Year and day of year: for example &lt;code&gt;to_date('2006-291', 'IYYY-IDDD')&lt;/code&gt; also returns &lt;code&gt;2006-10-19&lt;/code&gt;.</source>
          <target state="translated">Год и день года: например, &lt;code&gt;to_date('2006-291', 'IYYY-IDDD')&lt;/code&gt; также возвращает &lt;code&gt;2006-10-19&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc5a18c267810c3dc6c5d4fdd0b02c9e146fd0f1" translate="yes" xml:space="preserve">
          <source>Year, week number, and weekday: for example &lt;code&gt;to_date('2006-42-4', 'IYYY-IW-ID')&lt;/code&gt; returns the date &lt;code&gt;2006-10-19&lt;/code&gt;. If you omit the weekday it is assumed to be 1 (Monday).</source>
          <target state="translated">Год, номер недели и день недели: например, &lt;code&gt;to_date('2006-42-4', 'IYYY-IW-ID')&lt;/code&gt; возвращает дату &lt;code&gt;2006-10-19&lt;/code&gt; . Если вы не укажете день недели, он будет равен 1 (понедельник).</target>
        </trans-unit>
        <trans-unit id="7abdb2567a06fc713cd1d6b57e90f634441b367e" translate="yes" xml:space="preserve">
          <source>Year-Month Interval</source>
          <target state="translated">Интервал в месяц</target>
        </trans-unit>
        <trans-unit id="96f997bcecb36502ed4b296a795f72aff9d6bfe7" translate="yes" xml:space="preserve">
          <source>Years</source>
          <target state="translated">Years</target>
        </trans-unit>
        <trans-unit id="3cfd5c7e576642a9c9f3bbe4db929041cea0177f" translate="yes" xml:space="preserve">
          <source>Years in the 1900s are in the second millennium. The third millennium started January 1, 2001.</source>
          <target state="translated">Годы 1900-х годов-во втором тысячелетии.Третье тысячелетие началось 1 января 2001 года.</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="6dd15150afde3fb668c9c37b5570c9f350a42483" translate="yes" xml:space="preserve">
          <source>You can (and, for most purposes, probably should) increase the number of rows by using the &lt;code&gt;-s&lt;/code&gt; (scale factor) option. The &lt;code&gt;-F&lt;/code&gt; (fillfactor) option might also be used at this point.</source>
          <target state="translated">Вы можете (и, вероятно, должны) увеличить количество строк, используя параметр &lt;code&gt;-s&lt;/code&gt; (коэффициент масштабирования). Здесь также можно использовать параметр &lt;code&gt;-F&lt;/code&gt; (коэффициент заполнения).</target>
        </trans-unit>
        <trans-unit id="145c00d5953681c62f21c82b058caafeee2a8310" translate="yes" xml:space="preserve">
          <source>You can adapt this module to your needs by changing the source code. For example, you can use &lt;a href=&quot;https://sourceforge.net/projects/cracklib/&quot;&gt;CrackLib&lt;/a&gt; to check passwords &amp;mdash; this only requires uncommenting two lines in the &lt;code&gt;Makefile&lt;/code&gt; and rebuilding the module. (We cannot include CrackLib by default for license reasons.) Without CrackLib, the module enforces a few simple rules for password strength, which you can modify or extend as you see fit.</source>
          <target state="translated">Вы можете адаптировать этот модуль к своим потребностям, изменив исходный код. Например, вы можете использовать &lt;a href=&quot;https://sourceforge.net/projects/cracklib/&quot;&gt;CrackLib&lt;/a&gt; для проверки паролей - для этого нужно только раскомментировать две строки в &lt;code&gt;Makefile&lt;/code&gt; и перестроить модуль. (Мы не можем включать CrackLib по умолчанию по причинам лицензии.) Без CrackLib модуль применяет несколько простых правил для надежности пароля, которые вы можете изменять или расширять по своему усмотрению.</target>
        </trans-unit>
        <trans-unit id="28dae3ce662983a3720ca411f5e625f764893bf1" translate="yes" xml:space="preserve">
          <source>You can add whitespace before a left brace or after a right brace. You can also add whitespace before or after any individual item string. In all of these cases the whitespace will be ignored. However, whitespace within double-quoted elements, or surrounded on both sides by non-whitespace characters of an element, is not ignored.</source>
          <target state="translated">Вы можете добавить пробел перед левой или после правой скобкой.Вы также можете добавить пробелы до или после любой отдельной строки элемента.Во всех этих случаях пробельные символы будут проигнорированы.Однако пробельные символы внутри элементов в двойных кавычках или окруженные с обеих сторон не пробельными символами элемента,не игнорируются.</target>
        </trans-unit>
        <trans-unit id="569893ff6c39724a565a145b8a3ad3a0b9606463" translate="yes" xml:space="preserve">
          <source>You can adjust the ordering of a B-tree index by including the options &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt;, &lt;code&gt;NULLS FIRST&lt;/code&gt;, and/or &lt;code&gt;NULLS LAST&lt;/code&gt; when creating the index; for example:</source>
          <target state="translated">Вы можете настроить порядок индекса B-дерева, включив при создании индекса параметры &lt;code&gt;ASC&lt;/code&gt; , &lt;code&gt;DESC&lt;/code&gt; , &lt;code&gt;NULLS FIRST&lt;/code&gt; и / или &lt;code&gt;NULLS LAST&lt;/code&gt; ; например:</target>
        </trans-unit>
        <trans-unit id="4b7d9d02889a217be36bf8f71750c721f9d62b3a" translate="yes" xml:space="preserve">
          <source>You can also control the order in which rows are processed by window functions using &lt;code&gt;ORDER BY&lt;/code&gt; within &lt;code&gt;OVER&lt;/code&gt;. (The window &lt;code&gt;ORDER BY&lt;/code&gt; does not even have to match the order in which the rows are output.) Here is an example:</source>
          <target state="translated">Вы также можете контролировать порядок, в котором строки обрабатываются оконными функциями, используя &lt;code&gt;ORDER BY&lt;/code&gt; внутри &lt;code&gt;OVER&lt;/code&gt; . (Окно &lt;code&gt;ORDER BY&lt;/code&gt; даже не обязательно должно соответствовать порядку вывода строк.) Вот пример:</target>
        </trans-unit>
        <trans-unit id="d8031e0a82c5477e58a31c17656bff548035b193" translate="yes" xml:space="preserve">
          <source>You can also create databases with other names. PostgreSQL allows you to create any number of databases at a given site. Database names must have an alphabetic first character and are limited to 63 bytes in length. A convenient choice is to create a database with the same name as your current user name. Many tools assume that database name as the default, so it can save you some typing. To create that database, simply type:</source>
          <target state="translated">Вы также можете создавать базы данных с другими именами.PostgreSQL позволяет создавать любое количество баз данных на данном сайте.Имена баз данных должны иметь алфавитный первый символ и ограничены 63 байтами в длину.Удобным выбором является создание базы данных с тем же именем,что и ваше текущее имя пользователя.Многие инструменты предполагают,что имя базы данных является именем по умолчанию,так что это может сэкономить вам немного времени на набор текста.Чтобы создать эту базу данных,просто напечатайте:</target>
        </trans-unit>
        <trans-unit id="2855332ddeec7909c633615734e0f09916910215" translate="yes" xml:space="preserve">
          <source>You can also define constraints on the column at the same time, using the usual syntax:</source>
          <target state="translated">Вы также можете одновременно определить ограничения на колонку,используя обычный синтаксис:</target>
        </trans-unit>
        <trans-unit id="ee1e40e96d3d99c788ff89c86039beb4c7ae5ad3" translate="yes" xml:space="preserve">
          <source>You can also force the insertion of invalid numbers even when not in the weak mode, by appending the &lt;code&gt;!&lt;/code&gt; character at the end of the number.</source>
          <target state="translated">Вы также можете принудительно вставить недопустимые числа, даже если не в слабом режиме, добавив &lt;code&gt;!&lt;/code&gt; символ в конце номера.</target>
        </trans-unit>
        <trans-unit id="e92dd9f79aa93357545022991d035db8fa3c697a" translate="yes" xml:space="preserve">
          <source>You can also give the constraint a separate name. This clarifies error messages and allows you to refer to the constraint when you need to change it. The syntax is:</source>
          <target state="translated">Вы также можете дать этому ограничению отдельное имя.Это уточняет сообщения об ошибках и позволяет ссылаться на ограничение,когда необходимо его изменить.Синтаксис таков:</target>
        </trans-unit>
        <trans-unit id="5c0e733bb8f77339cb0554d27f0faf1999d777b7" translate="yes" xml:space="preserve">
          <source>You can also nest filter expressions within each other:</source>
          <target state="translated">Вы также можете вложить выражения фильтров друг в друга:</target>
        </trans-unit>
        <trans-unit id="540c7cc55f43958519f25aa973c9e5a2c6dcb66b" translate="yes" xml:space="preserve">
          <source>You can also search an array using the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator, which checks whether the left operand overlaps with the right operand. For instance:</source>
          <target state="translated">Вы также можете искать в массиве с помощью оператора &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , который проверяет, перекрывается ли левый операнд с правым операндом. Например:</target>
        </trans-unit>
        <trans-unit id="7317ad78770ade20f7fc205d1692cc3871b32860" translate="yes" xml:space="preserve">
          <source>You can also search for specific values in an array using the &lt;code&gt;array_position&lt;/code&gt; and &lt;code&gt;array_positions&lt;/code&gt; functions. The former returns the subscript of the first occurrence of a value in an array; the latter returns an array with the subscripts of all occurrences of the value in the array. For example:</source>
          <target state="translated">Вы также можете искать определенные значения в массиве, используя функции &lt;code&gt;array_position&lt;/code&gt; и &lt;code&gt;array_positions&lt;/code&gt; . Первый возвращает индекс первого вхождения значения в массив; последний возвращает массив с индексами всех вхождений значения в массиве. Например:</target>
        </trans-unit>
        <trans-unit id="72011efb5669336e4615ad697b69c64d57f8e812" translate="yes" xml:space="preserve">
          <source>You can also shorten the above command to:</source>
          <target state="translated">Вы также можете сократить вышеприведенную команду до:</target>
        </trans-unit>
        <trans-unit id="362c18912cf35df18fb18daa4743d6a04f75f78b" translate="yes" xml:space="preserve">
          <source>You can also write &lt;code&gt;all&lt;/code&gt; to match any IP address, &lt;code&gt;samehost&lt;/code&gt; to match any of the server's own IP addresses, or &lt;code&gt;samenet&lt;/code&gt; to match any address in any subnet that the server is directly connected to.</source>
          <target state="translated">Вы также можете написать &lt;code&gt;all&lt;/code&gt; для соответствия любому IP-адресу, &lt;code&gt;samehost&lt;/code&gt; для соответствия любому из собственных IP-адресов сервера или &lt;code&gt;samenet&lt;/code&gt; для соответствия любому адресу в любой подсети, к которой сервер напрямую подключен.</target>
        </trans-unit>
        <trans-unit id="81719f677a0ec0af21aab7f90315c40b111bfbd1" translate="yes" xml:space="preserve">
          <source>You can also write the table name with a trailing &lt;code&gt;*&lt;/code&gt; to explicitly specify that descendant tables are included:</source>
          <target state="translated">Вы также можете написать имя таблицы с завершающим &lt;code&gt;*&lt;/code&gt; , чтобы явно указать, что дочерние таблицы включены:</target>
        </trans-unit>
        <trans-unit id="5703517ac040c492127e1fb49e5ced3da0debc99" translate="yes" xml:space="preserve">
          <source>You can ask for all fields of a composite value by writing &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">Вы можете запросить все поля составного значения, написав &lt;code&gt;.*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3fc07d5e0044a9e8829c097c35614fb4ad2ee919" translate="yes" xml:space="preserve">
          <source>You can assign your own name for a foreign key constraint, in the usual way.</source>
          <target state="translated">Вы можете присвоить собственное имя для ограничения постороннего ключа обычным способом.</target>
        </trans-unit>
        <trans-unit id="78537f8a74bec7b625797355864a6e8b33eb27d6" translate="yes" xml:space="preserve">
          <source>You can assign your own name for a unique constraint, in the usual way:</source>
          <target state="translated">Вы можете присвоить собственное имя уникальному ограничению,как обычно:</target>
        </trans-unit>
        <trans-unit id="2e4029bdb8227766d867d39118fde7beadbd5eab" translate="yes" xml:space="preserve">
          <source>You can avoid always having to write out a &lt;code&gt;FROM&lt;/code&gt; clause to define the output columns, by setting up a custom crosstab function that has the desired output row type wired into its definition. This is described in the next section. Another possibility is to embed the required &lt;code&gt;FROM&lt;/code&gt; clause in a view definition.</source>
          <target state="translated">Вы можете избежать необходимости всегда записывать предложение &lt;code&gt;FROM&lt;/code&gt; для определения выходных столбцов, настроив настраиваемую функцию кросс-таблицы, которая имеет желаемый тип выходной строки, связанный с ее определением. Это описано в следующем разделе. Другая возможность - встроить требуемое предложение &lt;code&gt;FROM&lt;/code&gt; в определение представления.</target>
        </trans-unit>
        <trans-unit id="91ab32b5c2f6769faecc52b84a69c2005aae2685" translate="yes" xml:space="preserve">
          <source>You can change default privileges only for objects that will be created by yourself or by roles that you are a member of. The privileges can be set globally (i.e., for all objects created in the current database), or just for objects created in specified schemas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="564b000e3befed57b182cb04e1dbb1e1574bf5b5" translate="yes" xml:space="preserve">
          <source>You can change default privileges only for objects that will be created by yourself or by roles that you are a member of. The privileges can be set globally (i.e., for all objects created in the current database), or just for objects created in specified schemas. Default privileges that are specified per-schema are added to whatever the global default privileges are for the particular object type.</source>
          <target state="translated">Привилегии по умолчанию можно изменить только для объектов,которые будут созданы вами самими или для ролей,в которых вы участвуете.Привилегии могут быть установлены глобально (т.е.для всех объектов,созданных в текущей БД),или только для объектов,созданных в указанных схемах.Привилегии по умолчанию,которые заданы для каждой схемы,добавляются к любым глобальным привилегиям по умолчанию для конкретного типа объектов.</target>
        </trans-unit>
        <trans-unit id="9ce7b82cbd1c40e5d5b3f5f38a6fd3d98a532714" translate="yes" xml:space="preserve">
          <source>You can combine these approaches by setting up logrotate to collect log files produced by PostgreSQL built-in logging collector. In this case, the logging collector defines the names and location of the log files, while logrotate periodically archives these files. When initiating log rotation, logrotate must ensure that the application sends further output to the new file. This is commonly done with a &lt;code&gt;postrotate&lt;/code&gt; script that sends a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the application, which then reopens the log file. In PostgreSQL, you can run &lt;code&gt;pg_ctl&lt;/code&gt; with the &lt;code&gt;logrotate&lt;/code&gt; option instead. When the server receives this command, the server either switches to a new log file or reopens the existing file, depending on the logging configuration (see &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;Section 19.8.1&lt;/a&gt;).</source>
          <target state="translated">Вы можете комбинировать эти подходы, настроив logrotate для сбора файлов журналов, созданных встроенным сборщиком журналов PostgreSQL. В этом случае сборщик журналов определяет имена и расположение файлов журналов, а logrotate периодически архивирует эти файлы. При запуске ротации журнала logrotate должен гарантировать, что приложение отправляет дальнейшие выходные данные в новый файл. Обычно это делается с помощью сценария &lt;code&gt;postrotate&lt;/code&gt; , который отправляет сигнал &lt;code&gt;SIGHUP&lt;/code&gt; приложению, которое затем повторно открывает файл журнала. В PostgreSQL вместо этого вы можете запустить &lt;code&gt;pg_ctl&lt;/code&gt; с параметром &lt;code&gt;logrotate&lt;/code&gt; . Когда сервер получает эту команду, сервер либо переключается на новый файл журнала, либо повторно открывает существующий файл, в зависимости от конфигурации ведения журнала (см.&lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;Раздел 19.8.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5b0f94e4408c19791436a634fd6c150fbb5fd164" translate="yes" xml:space="preserve">
          <source>You can construct an empty array, but since it's impossible to have an array with no type, you must explicitly cast your empty array to the desired type. For example:</source>
          <target state="translated">Можно построить пустой массив,но так как невозможно иметь массив без типа,то необходимо явно привести пустой массив к нужному типу.Например:</target>
        </trans-unit>
        <trans-unit id="769ef112866ecb5c170f43630a2adb624d294a3a" translate="yes" xml:space="preserve">
          <source>You can convert an epoch value back to a time stamp with &lt;code&gt;to_timestamp&lt;/code&gt;:</source>
          <target state="translated">Вы можете преобразовать значение эпохи обратно в &lt;code&gt;to_timestamp&lt;/code&gt; времени с помощью to_timestamp :</target>
        </trans-unit>
        <trans-unit id="6ea1e38b69360026f2565a2133b9cc41f674fbe6" translate="yes" xml:space="preserve">
          <source>You can create a new table by specifying the table name, along with all column names and their types:</source>
          <target state="translated">Вы можете создать новую таблицу,указав имя таблицы,а также имена всех столбцов и их типы:</target>
        </trans-unit>
        <trans-unit id="2293b489a80bd69ba669dbf459fa76acfff7a213" translate="yes" xml:space="preserve">
          <source>You can create a replication slot like this:</source>
          <target state="translated">Вы можете создать такой слот для репликации:</target>
        </trans-unit>
        <trans-unit id="e3025b62033e69c38fff841b12fa1dec6f73605a" translate="yes" xml:space="preserve">
          <source>You can create predefined functions to avoid having to write out the result column names and types in each query. See the examples in the previous section. The underlying C function for this form of &lt;code&gt;crosstab&lt;/code&gt; is named &lt;code&gt;crosstab_hash&lt;/code&gt;.</source>
          <target state="translated">Вы можете создавать предопределенные функции, чтобы избежать необходимости записывать имена и типы столбцов результатов в каждом запросе. См. Примеры в предыдущем разделе. Базовая функция C для этой формы &lt;code&gt;crosstab&lt;/code&gt; называется &lt;code&gt;crosstab_hash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05fb579365a5f238d0a6df67c0b79ce59d0a29c6" translate="yes" xml:space="preserve">
          <source>You can create the illusion of an updatable view by defining &lt;code&gt;ON INSERT&lt;/code&gt;, &lt;code&gt;ON UPDATE&lt;/code&gt;, and &lt;code&gt;ON DELETE&lt;/code&gt; rules (or any subset of those that's sufficient for your purposes) to replace update actions on the view with appropriate updates on other tables. If you want to support &lt;code&gt;INSERT RETURNING&lt;/code&gt; and so on, then be sure to put a suitable &lt;code&gt;RETURNING&lt;/code&gt; clause into each of these rules.</source>
          <target state="translated">Вы можете создать иллюзию обновляемого представления, определив правила &lt;code&gt;ON INSERT&lt;/code&gt; , &lt;code&gt;ON UPDATE&lt;/code&gt; и &lt;code&gt;ON DELETE&lt;/code&gt; (или любое их подмножество, достаточное для ваших целей), чтобы заменить действия обновления в представлении соответствующими обновлениями в других таблицах. Если вы хотите поддерживать &lt;code&gt;INSERT RETURNING&lt;/code&gt; и т. Д., Не забудьте добавить подходящее предложение &lt;code&gt;RETURNING&lt;/code&gt; в каждое из этих правил.</target>
        </trans-unit>
        <trans-unit id="a0fd26f2da3bc0e528eb70dd91043a00be53f7e3" translate="yes" xml:space="preserve">
          <source>You can define a cast as an &lt;em&gt;I/O conversion cast&lt;/em&gt; by using the &lt;code&gt;WITH INOUT&lt;/code&gt; syntax. An I/O conversion cast is performed by invoking the output function of the source data type, and passing the resulting string to the input function of the target data type. In many common cases, this feature avoids the need to write a separate cast function for conversion. An I/O conversion cast acts the same as a regular function-based cast; only the implementation is different.</source>
          <target state="translated">Вы можете определить приведение как &lt;em&gt;преобразование ввода-вывода&lt;/em&gt; с помощью синтаксиса &lt;code&gt;WITH INOUT&lt;/code&gt; . Приведение преобразования ввода-вывода выполняется путем вызова функции вывода исходного типа данных и передачи результирующей строки функции ввода целевого типа данных. Во многих распространенных случаях эта функция позволяет избежать написания отдельной функции приведения для преобразования. Приведение преобразования ввода-вывода действует так же, как обычное приведение на основе функций; только реализация отличается.</target>
        </trans-unit>
        <trans-unit id="986b5339acb3c76e9d88ad629ad134c8af474edf" translate="yes" xml:space="preserve">
          <source>You can display tables in different ways by using the &lt;code&gt;\pset&lt;/code&gt; command:</source>
          <target state="translated">Вы можете отображать таблицы по-разному, используя команду &lt;code&gt;\pset&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="16683852e12279f72c19abb8cc240108de7e38a2" translate="yes" xml:space="preserve">
          <source>You can do the same thing more verbosely with an explicitly named composite type:</source>
          <target state="translated">Вы можете сделать то же самое более многословно с явным именем составного типа:</target>
        </trans-unit>
        <trans-unit id="647bf3e05906b80225fe1b4782288902652983a3" translate="yes" xml:space="preserve">
          <source>You can easily display index sizes, too:</source>
          <target state="translated">Вы также можете легко отобразить размеры индекса:</target>
        </trans-unit>
        <trans-unit id="a376faf67a062024c4f071a8c440875731b4314a" translate="yes" xml:space="preserve">
          <source>You can enter this into &lt;code&gt;psql&lt;/code&gt; with the line breaks. &lt;code&gt;psql&lt;/code&gt; will recognize that the command is not terminated until the semicolon.</source>
          <target state="translated">Вы можете ввести это в &lt;code&gt;psql&lt;/code&gt; с переносом строки. &lt;code&gt;psql&lt;/code&gt; распознает, что команда не завершается до точки с запятой.</target>
        </trans-unit>
        <trans-unit id="b7e2b6740f842ed6fc3ff802c0860722cdf6db76" translate="yes" xml:space="preserve">
          <source>You can even omit the schema name, in which case the schema name will be the same as the user name. See &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;Section 5.9.6&lt;/a&gt; for how this can be useful.</source>
          <target state="translated">Вы даже можете опустить имя схемы, и в этом случае имя схемы будет таким же, как имя пользователя. См. &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;Раздел 5.9.6,&lt;/a&gt; чтобы узнать, как это может быть полезно.</target>
        </trans-unit>
        <trans-unit id="cc36ec902ca8c0ca398f503d160c7bcb9cae5a08" translate="yes" xml:space="preserve">
          <source>You can grant membership to other group roles, too (since there isn't really any distinction between group roles and non-group roles). The database will not let you set up circular membership loops. Also, it is not permitted to grant membership in a role to &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">Вы также можете предоставить членство другим групповым ролям (поскольку на самом деле нет никакого различия между групповыми ролями и негрупповыми ролями). База данных не позволит вам создавать циклические циклы членства. Кроме того, не разрешается предоставлять членство в роли для &lt;code&gt;PUBLIC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1855de10627c59aa70817e07d54ec85b68d5f2a6" translate="yes" xml:space="preserve">
          <source>You can have any number of standby servers, but if you use streaming replication, make sure you set &lt;code&gt;max_wal_senders&lt;/code&gt; high enough in the primary to allow them to be connected simultaneously.</source>
          <target state="translated">У вас может быть любое количество резервных серверов, но если вы используете потоковую репликацию, убедитесь, что вы установили &lt;code&gt;max_wal_senders&lt;/code&gt; достаточно высоко на основном, чтобы они могли подключаться одновременно.</target>
        </trans-unit>
        <trans-unit id="fd1cb07de1f7e656292c8ca30e0d8e6b56ad41dd" translate="yes" xml:space="preserve">
          <source>You can insert multiple rows in a single command:</source>
          <target state="translated">Вы можете вставить несколько строк в одну команду:</target>
        </trans-unit>
        <trans-unit id="42ba202e5611e6787a856f8be8ec1439c95a1b90" translate="yes" xml:space="preserve">
          <source>You can list the columns in a different order if you wish or even omit some columns, e.g., if the precipitation is unknown:</source>
          <target state="translated">Вы можете перечислить столбцы в другом порядке,если хотите,или даже опустить некоторые столбцы,например,если осадки неизвестны:</target>
        </trans-unit>
        <trans-unit id="3d6ecf73216b6b457189a453d966978eb4171c2e" translate="yes" xml:space="preserve">
          <source>You can monitor disk space in three ways: using the SQL functions listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.89&lt;/a&gt;, using the &lt;a href=&quot;https://www.postgresql.org/docs/12/oid2name.html&quot;&gt;oid2name&lt;/a&gt; module, or using manual inspection of the system catalogs. The SQL functions are the easiest to use and are generally recommended. The remainder of this section shows how to do it by inspection of the system catalogs.</source>
          <target state="translated">Вы можете контролировать дисковое пространство тремя способами: используя функции SQL, перечисленные в &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Таблице 9.89&lt;/a&gt; , используя модуль &lt;a href=&quot;https://www.postgresql.org/docs/12/oid2name.html&quot;&gt;oid2name&lt;/a&gt; или используя ручную проверку системных каталогов. Функции SQL наиболее просты в использовании и обычно рекомендуются. В оставшейся части этого раздела показано, как это сделать, просмотрев системные каталоги.</target>
        </trans-unit>
        <trans-unit id="fc43586ff2149aed2e36a6059af6a439ca36056f" translate="yes" xml:space="preserve">
          <source>You can monitor disk space in three ways: using the SQL functions listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.90&lt;/a&gt;, using the &lt;a href=&quot;https://www.postgresql.org/docs/13/oid2name.html&quot;&gt;oid2name&lt;/a&gt; module, or using manual inspection of the system catalogs. The SQL functions are the easiest to use and are generally recommended. The remainder of this section shows how to do it by inspection of the system catalogs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41216c0546ef7a2b57fe5526f609434095e7579" translate="yes" xml:space="preserve">
          <source>You can reduce the width of the output by explicitly specifying which columns you want to see:</source>
          <target state="translated">Вы можете уменьшить ширину вывода,явно указав,какие колонки вы хотите видеть:</target>
        </trans-unit>
        <trans-unit id="8331a990fbd5bf29d20b7859a75677eec31adfb9" translate="yes" xml:space="preserve">
          <source>You can request that duplicate rows be removed from the result of a query:</source>
          <target state="translated">Вы можете запросить удаление дублирующих друг друга строк из результата запроса:</target>
        </trans-unit>
        <trans-unit id="3fcea913f233f38e0ca5df494ac39fe2b0977a56" translate="yes" xml:space="preserve">
          <source>You can request that the results of a query be returned in sorted order:</source>
          <target state="translated">Вы можете запросить,чтобы результаты запроса были возвращены в отсортированном порядке:</target>
        </trans-unit>
        <trans-unit id="7eb5aec5733f23b6d31556d97f7864bf4f3ef3fd" translate="yes" xml:space="preserve">
          <source>You can retrieve a list of WAL sender processes via the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-REPLICATION-VIEW&quot;&gt;&lt;code&gt;pg_stat_replication&lt;/code&gt;&lt;/a&gt; view. Large differences between &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; and the view's &lt;code&gt;sent_lsn&lt;/code&gt; field might indicate that the master server is under heavy load, while differences between &lt;code&gt;sent_lsn&lt;/code&gt; and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby might indicate network delay, or that the standby is under heavy load.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa31e230282587f91ce67696a7ae247357fc3c92" translate="yes" xml:space="preserve">
          <source>You can retrieve a list of WAL sender processes via the &lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt; view. Large differences between &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; and the view's &lt;code&gt;sent_lsn&lt;/code&gt; field might indicate that the master server is under heavy load, while differences between &lt;code&gt;sent_lsn&lt;/code&gt; and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby might indicate network delay, or that the standby is under heavy load.</source>
          <target state="translated">Вы можете получить список процессов-отправителей WAL через представление &lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt; . Большие различия между &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; и полем &lt;code&gt;sent_lsn&lt;/code&gt; представления могут указывать на то, что главный сервер находится под большой нагрузкой, тогда как различия между &lt;code&gt;sent_lsn&lt;/code&gt; и &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; на резервном сервере могут указывать на задержку в сети или на то, что резервный сервер находится под большой нагрузкой.</target>
        </trans-unit>
        <trans-unit id="8d913910be5bfeaa10ff530630e730b9ef488370" translate="yes" xml:space="preserve">
          <source>You can see all available cursors by querying the &lt;a href=&quot;view-pg-cursors&quot;&gt;&lt;code&gt;pg_cursors&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">Вы можете увидеть все доступные курсоры, &lt;a href=&quot;view-pg-cursors&quot;&gt; &lt;code&gt;pg_cursors&lt;/code&gt; &lt;/a&gt; системное представление pg_cursors .</target>
        </trans-unit>
        <trans-unit id="3d1e44f9701af9c1191f1ae4aa31b23f502dc3b9" translate="yes" xml:space="preserve">
          <source>You can see all prepared statements available in the session by querying the &lt;a href=&quot;view-pg-prepared-statements&quot;&gt;&lt;code&gt;pg_prepared_statements&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">Вы можете увидеть все подготовленные операторы, доступные в сеансе, &lt;a href=&quot;view-pg-prepared-statements&quot;&gt; &lt;code&gt;pg_prepared_statements&lt;/code&gt; &lt;/a&gt; системное представление pg_prepared_statements .</target>
        </trans-unit>
        <trans-unit id="a1851e47d03f25069a58e8ba84744ebf9f76c67c" translate="yes" xml:space="preserve">
          <source>You can specify a non-default encoding at database creation time, provided that the encoding is compatible with the selected locale:</source>
          <target state="translated">Вы можете указать кодировку не по умолчанию во время создания базы данных,при условии,что кодировка совместима с выбранной локалью:</target>
        </trans-unit>
        <trans-unit id="429c21ef7f32890bc18b9fd73f1ebb90743874ca" translate="yes" xml:space="preserve">
          <source>You can unlisten something you were not listening for; no warning or error will appear.</source>
          <target state="translated">Вы можете удалить из списка то,что не слушали;никаких предупреждений или ошибок не появится.</target>
        </trans-unit>
        <trans-unit id="0f0825c19fa74c86ea4fde39915a5f442a1301c8" translate="yes" xml:space="preserve">
          <source>You can update existing rows using the &lt;code&gt;UPDATE&lt;/code&gt; command. Suppose you discover the temperature readings are all off by 2 degrees after November 28. You can correct the data as follows:</source>
          <target state="translated">Вы можете обновить существующие строки с помощью команды &lt;code&gt;UPDATE&lt;/code&gt; . Предположим, вы обнаружите, что после 28 ноября вы обнаружите, что все показания температуры отклоняются на 2 градуса. Вы можете исправить данные следующим образом:</target>
        </trans-unit>
        <trans-unit id="e9d9d610480d842b7b4dae95f084d8c480dea21a" translate="yes" xml:space="preserve">
          <source>You can update more than one column in an &lt;code&gt;UPDATE&lt;/code&gt; command by listing more than one assignment in the &lt;code&gt;SET&lt;/code&gt; clause. For example:</source>
          <target state="translated">Вы можете обновить более одного столбца в команде &lt;code&gt;UPDATE&lt;/code&gt; , указав более одного назначения в предложении &lt;code&gt;SET&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="afbd81cf7abf6e1ee5aed73e857469d9b19d9be7" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;pg_restore -j&lt;/code&gt; to restore a dump in parallel. This will work for any archive of either the &quot;custom&quot; or the &quot;directory&quot; archive mode, whether or not it has been created with &lt;code&gt;pg_dump -j&lt;/code&gt;.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;pg_restore -j&lt;/code&gt; для параллельного восстановления дампа. Это будет работать для любого архива в режиме архива &quot;custom&quot; или &quot;directory&quot;, независимо от того, был ли он создан с помощью &lt;code&gt;pg_dump -j&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e548ce622037cda7095c1bcbf3f92886d139cb4c" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;pg_walfile_name_offset&lt;/code&gt; to extract the corresponding write-ahead log file name and byte offset from a &lt;code&gt;pg_lsn&lt;/code&gt; value. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b820c01225164f2d5b985f5de0dcbc0100e250a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;pg_walfile_name_offset&lt;/code&gt; to extract the corresponding write-ahead log file name and byte offset from the results of any of the above functions. For example:</source>
          <target state="translated">Вы можете использовать &lt;code&gt;pg_walfile_name_offset&lt;/code&gt; для извлечения соответствующего имени файла журнала упреждающей записи и байтового смещения из результатов любой из вышеуказанных функций. Например:</target>
        </trans-unit>
        <trans-unit id="c69d101f435a1744fb1dd6c3be27758cb46e4777" translate="yes" xml:space="preserve">
          <source>You can use data-modifying statements (&lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;) in &lt;code&gt;WITH&lt;/code&gt;. This allows you to perform several different operations in the same query. An example is:</source>
          <target state="translated">В &lt;code&gt;WITH&lt;/code&gt; можно использовать операторы изменения данных ( &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; ) . Это позволяет выполнять несколько разных операций в одном запросе. Пример:</target>
        </trans-unit>
        <trans-unit id="0ab93f9848617cd1c9b0e1e4c6fbe5e015dc7f2a" translate="yes" xml:space="preserve">
          <source>You can use several filter expressions in sequence, if required. For example, the following expression selects start times of all segments that contain locations with relevant coordinates and high heart rate values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aecc1927f70a57ed9583d45287b1db5300bd7af" translate="yes" xml:space="preserve">
          <source>You can use several filter expressions on the same nesting level, if required. For example, the following expression selects all segments that contain locations with relevant coordinates and high heart rate values:</source>
          <target state="translated">При необходимости можно использовать несколько фильтрующих выражений на одном и том же уровне вложенности.Например,в следующем выражении выбираются все сегменты,содержащие местоположения с соответствующими координатами и высокими значениями пульса:</target>
        </trans-unit>
        <trans-unit id="cfeaa68d3d1e02bb6f35ba750e012709276d477e" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;btree-gist&quot;&gt;&lt;code&gt;btree_gist&lt;/code&gt;&lt;/a&gt; extension to define exclusion constraints on plain scalar data types, which can then be combined with range exclusions for maximum flexibility. For example, after &lt;code&gt;btree_gist&lt;/code&gt; is installed, the following constraint will reject overlapping ranges only if the meeting room numbers are equal:</source>
          <target state="translated">Вы можете использовать расширение &lt;a href=&quot;btree-gist&quot;&gt; &lt;code&gt;btree_gist&lt;/code&gt; &lt;/a&gt; для определения ограничений исключения для простых скалярных типов данных, которые затем можно комбинировать с исключениями диапазона для максимальной гибкости. Например, после установки &lt;code&gt;btree_gist&lt;/code&gt; следующее ограничение будет отклонять перекрывающиеся диапазоны, только если номера конференц-залов равны:</target>
        </trans-unit>
        <trans-unit id="002e817c446bf19265c623a41f235f06765b50f1" translate="yes" xml:space="preserve">
          <source>You can verify what the command will do using rsync's &lt;code&gt;--dry-run&lt;/code&gt; option. While rsync must be run on the primary for at least one standby, it is possible to run rsync on an upgraded standby to upgrade other standbys, as long as the upgraded standby has not been started.</source>
          <target state="translated">Вы можете проверить, что будет делать команда, используя параметр rsync &lt;code&gt;--dry-run&lt;/code&gt; . Хотя rsync должен запускаться на первичном по крайней мере для одного резервного, можно запустить rsync на модернизированном резервном для обновления других резервных, пока обновленный резервный не запущен.</target>
        </trans-unit>
        <trans-unit id="92d48e271b4c23101cd376b3231b8d00d43b6839" translate="yes" xml:space="preserve">
          <source>You can write expressions, not just simple column references, in the select list. For example, you can do:</source>
          <target state="translated">В списке выбора можно писать выражения,а не просто ссылки на колонки.Например,можно:</target>
        </trans-unit>
        <trans-unit id="0b204489972744de11c0eeded07bbc813914aafd" translate="yes" xml:space="preserve">
          <source>You can:</source>
          <target state="translated">Ты можешь:</target>
        </trans-unit>
        <trans-unit id="de82188f9fe7e2d788196205280b0985f84081cc" translate="yes" xml:space="preserve">
          <source>You cannot drop the &lt;code&gt;NOT NULL&lt;/code&gt; constraint on a partition's column if the constraint is present in the parent table.</source>
          <target state="translated">Вы не можете сбросить ограничение &lt;code&gt;NOT NULL&lt;/code&gt; для столбца раздела, если ограничение присутствует в родительской таблице.</target>
        </trans-unit>
        <trans-unit id="093c2a9d5eef8843d884253372bdbca71ca3f136" translate="yes" xml:space="preserve">
          <source>You cannot execute the &lt;code&gt;DROP DATABASE&lt;/code&gt; command while connected to the victim database. You can, however, be connected to any other database, including the &lt;code&gt;template1&lt;/code&gt; database. &lt;code&gt;template1&lt;/code&gt; would be the only option for dropping the last user database of a given cluster.</source>
          <target state="translated">Вы не можете выполнить команду &lt;code&gt;DROP DATABASE&lt;/code&gt; , когда подключены к базе данных жертвы. Однако вы можете подключиться к любой другой базе данных, включая базу данных &lt;code&gt;template1&lt;/code&gt; . &lt;code&gt;template1&lt;/code&gt; будет единственным вариантом для удаления последней пользовательской базы данных данного кластера.</target>
        </trans-unit>
        <trans-unit id="7a936475d5b2fe8219655a01b86bcd035950ef3f" translate="yes" xml:space="preserve">
          <source>You could also have set up port forwarding as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8854264af301815bd4c143e497bc4039dd4ee05" translate="yes" xml:space="preserve">
          <source>You could also have set up the port forwarding as</source>
          <target state="translated">Вы также могли бы настроить переадресацию порта как</target>
        </trans-unit>
        <trans-unit id="00192154b86c5479e232f9339dfec14280fa9591" translate="yes" xml:space="preserve">
          <source>You could also have used &lt;code&gt;COPY&lt;/code&gt; to load large amounts of data from flat-text files. This is usually faster because the &lt;code&gt;COPY&lt;/code&gt; command is optimized for this application while allowing less flexibility than &lt;code&gt;INSERT&lt;/code&gt;. An example would be:</source>
          <target state="translated">Вы также могли использовать &lt;code&gt;COPY&lt;/code&gt; для загрузки больших объемов данных из файлов с плоским текстом. Обычно это быстрее, потому что команда &lt;code&gt;COPY&lt;/code&gt; оптимизирована для этого приложения, но допускает меньшую гибкость, чем &lt;code&gt;INSERT&lt;/code&gt; . Примером может быть:</target>
        </trans-unit>
        <trans-unit id="db5bb918efb1956e14366be6e4e8492955095b0f" translate="yes" xml:space="preserve">
          <source>You do not need to constrain the join order completely in order to cut search time, because it's OK to use &lt;code&gt;JOIN&lt;/code&gt; operators within items of a plain &lt;code&gt;FROM&lt;/code&gt; list. For example, consider:</source>
          <target state="translated">Вам не нужно полностью ограничивать порядок соединения, чтобы сократить время поиска, потому что можно использовать операторы &lt;code&gt;JOIN&lt;/code&gt; в элементах простого списка &lt;code&gt;FROM&lt;/code&gt; . Например, рассмотрите:</target>
        </trans-unit>
        <trans-unit id="cb9759ceb3a93faeeed42501a60a856539a7fb24" translate="yes" xml:space="preserve">
          <source>You do not want to use the third form when specifying a &lt;code&gt;DEFAULT&lt;/code&gt; clause while creating a table. The system will convert &lt;code&gt;now&lt;/code&gt; to a &lt;code&gt;timestamp&lt;/code&gt; as soon as the constant is parsed, so that when the default value is needed, the time of the table creation would be used! The first two forms will not be evaluated until the default value is used, because they are function calls. Thus they will give the desired behavior of defaulting to the time of row insertion.</source>
          <target state="translated">Вы не хотите использовать третью форму при указании предложения &lt;code&gt;DEFAULT&lt;/code&gt; при создании таблицы. Система преобразует &lt;code&gt;now&lt;/code&gt; в &lt;code&gt;timestamp&lt;/code&gt; , как только константа обрабатывается, так что , когда требуется значение по умолчанию, время создания таблицы будет использоваться! Первые две формы не будут оцениваться, пока не будет использовано значение по умолчанию, поскольку они являются вызовами функций. Таким образом, они дадут желаемое поведение по умолчанию во время вставки строки.</target>
        </trans-unit>
        <trans-unit id="82ae0883f7a2deb13919a7b51525df4e84881170" translate="yes" xml:space="preserve">
          <source>You have altered a storage parameter (such as fillfactor) for an index, and wish to ensure that the change has taken full effect.</source>
          <target state="translated">Вы изменили параметр хранения (например,коэффициент заполнения)для индекса и хотите убедиться,что изменение вступило в силу в полном объеме.</target>
        </trans-unit>
        <trans-unit id="9105126c4b98c9abf43cead14144e7c73642eea6" translate="yes" xml:space="preserve">
          <source>You have to adapt &lt;code&gt;compressed_data_type&lt;/code&gt; to the specific type you're converting to in order to compress your leaf nodes, of course.</source>
          <target state="translated">Вы должны адаптировать &lt;code&gt;compressed_data_type&lt;/code&gt; к конкретному типу, в который вы конвертируете, чтобы, конечно, сжать ваши листовые узлы.</target>
        </trans-unit>
        <trans-unit id="c6ec9a715c152149c664d288cf7e25e03ec9494f" translate="yes" xml:space="preserve">
          <source>You may decide to use multiple columns in the partition key for range partitioning, if desired. Of course, this will often result in a larger number of partitions, each of which is individually smaller. On the other hand, using fewer columns may lead to a coarser-grained partitioning criteria with smaller number of partitions. A query accessing the partitioned table will have to scan fewer partitions if the conditions involve some or all of these columns. For example, consider a table range partitioned using columns &lt;code&gt;lastname&lt;/code&gt; and &lt;code&gt;firstname&lt;/code&gt; (in that order) as the partition key.</source>
          <target state="translated">При желании вы можете решить использовать несколько столбцов в ключе раздела для разделения по диапазонам. Конечно, это часто приводит к большему количеству разделов, каждый из которых индивидуально меньше. С другой стороны, использование меньшего количества столбцов может привести к более грубому критерию разделения с меньшим количеством разделов. Запрос, обращающийся к многораздельной таблице, должен будет сканировать меньшее количество разделов, если условия включают некоторые или все эти столбцы. Например, рассмотрим диапазон таблицы, разделенный с использованием столбцов &lt;code&gt;lastname&lt;/code&gt; и &lt;code&gt;firstname&lt;/code&gt; (в указанном порядке) в качестве ключа раздела.</target>
        </trans-unit>
        <trans-unit id="cf47ba3690a812065d027e7932a77588e377659a" translate="yes" xml:space="preserve">
          <source>You might also want to configure your kernel to lock System V shared memory into RAM and prevent it from being paged out to swap. This can be accomplished using the &lt;code&gt;sysctl&lt;/code&gt; setting &lt;code&gt;kern.ipc.shm_use_phys&lt;/code&gt;.</source>
          <target state="translated">Вы также можете настроить ядро ​​для блокировки разделяемой памяти System V в ОЗУ и предотвращения ее выгружения для подкачки. Это может быть достигнуто с помощью &lt;code&gt;sysctl&lt;/code&gt; настройки &lt;code&gt;kern.ipc.shm_use_phys&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a62a7a5cf401923b709acdb0497028fe1fd4d2f" translate="yes" xml:space="preserve">
          <source>You might be tempted to create a large set of non-overlapping partial indexes, for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118dd6812b30292a1fcd4d319831dc8ec3a9335e" translate="yes" xml:space="preserve">
          <source>You might instead use this approach to naming the files descriptively:</source>
          <target state="translated">Вместо этого можно использовать этот подход для описательного именования файлов:</target>
        </trans-unit>
        <trans-unit id="149e9ef120e49f8ae119951c604cd065ab893c33" translate="yes" xml:space="preserve">
          <source>You might prefer to remove the &lt;code&gt;sepgsql-regtest&lt;/code&gt; policy entirely:</source>
          <target state="translated">Возможно, вы предпочтете полностью удалить &lt;code&gt;sepgsql-regtest&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a34411202b4ded0e9449c6d67415d0bad4541f5b" translate="yes" xml:space="preserve">
          <source>You might reasonably ask why there is an &lt;code&gt;ELEMENT&lt;/code&gt; option, if the system makes the correct array type automatically. The only case where it's useful to use &lt;code&gt;ELEMENT&lt;/code&gt; is when you are making a fixed-length type that happens to be internally an array of a number of identical things, and you want to allow these things to be accessed directly by subscripting, in addition to whatever operations you plan to provide for the type as a whole. For example, type &lt;code&gt;point&lt;/code&gt; is represented as just two floating-point numbers, which can be accessed using &lt;code&gt;point[0]&lt;/code&gt; and &lt;code&gt;point[1]&lt;/code&gt;. Note that this facility only works for fixed-length types whose internal form is exactly a sequence of identical fixed-length fields. A subscriptable variable-length type must have the generalized internal representation used by &lt;code&gt;array_in&lt;/code&gt; and &lt;code&gt;array_out&lt;/code&gt;. For historical reasons (i.e., this is clearly wrong but it's far too late to change it), subscripting of fixed-length array types starts from zero, rather than from one as for variable-length arrays.</source>
          <target state="translated">Вы можете разумно спросить, зачем &lt;code&gt;ELEMENT&lt;/code&gt; опция ELEMENT , если система автоматически устанавливает правильный тип массива. Единственный случай, когда полезно использовать &lt;code&gt;ELEMENT&lt;/code&gt; , - это когда вы создаете тип фиксированной длины, который оказывается внутренне массивом из нескольких идентичных вещей, и вы хотите разрешить доступ к этим вещам напрямую по индексу в дополнение к любые операции, которые вы планируете выполнять для типа в целом. Например, тип &lt;code&gt;point&lt;/code&gt; представлен всего двумя числами с плавающей запятой, к которым можно получить доступ, используя &lt;code&gt;point[0]&lt;/code&gt; и &lt;code&gt;point[1]&lt;/code&gt; . Обратите внимание, что эта возможность работает только для типов фиксированной длины, внутренняя форма которых представляет собой последовательность идентичных полей фиксированной длины. Тип переменной длины с индексами должен иметь обобщенное внутреннее представление, используемое &lt;code&gt;array_in&lt;/code&gt; и &lt;code&gt;array_out&lt;/code&gt; . По историческим причинам (т. Е. Это явно неверно, но уже слишком поздно менять это), индексирование типов массивов фиксированной длины начинается с нуля, а не с единицы, как для массивов переменной длины.</target>
        </trans-unit>
        <trans-unit id="e76fa113e33e26d7d8bdc7061b1bdc78af7c35cf" translate="yes" xml:space="preserve">
          <source>You might want to reset &lt;code&gt;parallel_workers&lt;/code&gt; after setting it as part of tuning an index build. This avoids inadvertent changes to query plans, since &lt;code&gt;parallel_workers&lt;/code&gt; affects &lt;em&gt;all&lt;/em&gt; parallel table scans.</source>
          <target state="translated">Возможно, вы захотите сбросить &lt;code&gt;parallel_workers&lt;/code&gt; после его настройки в рамках настройки построения индекса. Это позволяет избежать непреднамеренных изменений в планах запросов, поскольку &lt;code&gt;parallel_workers&lt;/code&gt; влияет на &lt;em&gt;все&lt;/em&gt; параллельные просмотры таблиц.</target>
        </trans-unit>
        <trans-unit id="16c3ec0adfcebb8df4d8276a101b477163d7255e" translate="yes" xml:space="preserve">
          <source>You might wonder why bother providing all four options, when two options together with the possibility of backward scan would cover all the variants of &lt;code&gt;ORDER BY&lt;/code&gt;. In single-column indexes the options are indeed redundant, but in multicolumn indexes they can be useful. Consider a two-column index on &lt;code&gt;(x, y)&lt;/code&gt;: this can satisfy &lt;code&gt;ORDER BY x, y&lt;/code&gt; if we scan forward, or &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; if we scan backward. But it might be that the application frequently needs to use &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt;. There is no way to get that ordering from a plain index, but it is possible if the index is defined as &lt;code&gt;(x ASC, y DESC)&lt;/code&gt; or &lt;code&gt;(x DESC, y ASC)&lt;/code&gt;.</source>
          <target state="translated">Вы можете задаться вопросом, зачем беспокоиться о предоставлении всех четырех вариантов, когда два варианта вместе с возможностью обратного сканирования охватывают все варианты &lt;code&gt;ORDER BY&lt;/code&gt; . В индексах с одним столбцом параметры действительно избыточны, но в индексах с несколькими столбцами они могут быть полезны. Рассмотрим двухколоночный индекс на &lt;code&gt;(x, y)&lt;/code&gt; : он может удовлетворять &lt;code&gt;ORDER BY x, y&lt;/code&gt; если мы просматриваем вперед, или &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; если мы просматриваем назад. Но может случиться так, что приложению часто требуется использовать &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt; . Невозможно получить такой порядок из простого индекса, но это возможно, если индекс определен как &lt;code&gt;(x ASC, y DESC)&lt;/code&gt; или &lt;code&gt;(x DESC, y ASC)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a96b7a75456662c5aa3c61f0b2bf6c8181936405" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt;. (This restriction is made because an erroneous operator family definition could confuse or even crash the server.)</source>
          <target state="translated">Чтобы использовать &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; , вы должны быть суперпользователем . (Это ограничение сделано потому, что ошибочное определение семейства операторов может запутать или даже привести к сбою сервера.)</target>
        </trans-unit>
        <trans-unit id="f2c54ba09d5b62548914418dced24b83c29f8192" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt;.</source>
          <target state="translated">Чтобы использовать &lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt; , вы должны быть суперпользователем .</target>
        </trans-unit>
        <trans-unit id="b1c6e4d091898d0c808adc78af3decbefdf7c390" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt;.</source>
          <target state="translated">Чтобы использовать &lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt; , вы должны быть суперпользователем .</target>
        </trans-unit>
        <trans-unit id="4112b2d8f8d95b2e2b447d1ab817d0a272e11d27" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt;. (This restriction is made because an erroneous text search parser definition could confuse or even crash the server.)</source>
          <target state="translated">Чтобы использовать &lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt; , вы должны быть суперпользователем . (Это ограничение сделано потому, что ошибочное определение парсера текстового поиска может запутать или даже привести к сбою сервера.)</target>
        </trans-unit>
        <trans-unit id="6ab7f85ecb54195b79adfabb967e5f95ee6fb3b3" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt;. This restriction is made because an erroneous text search template definition could confuse or even crash the server. The reason for separating templates from dictionaries is that a template encapsulates the &amp;ldquo;unsafe&amp;rdquo; aspects of defining a dictionary. The parameters that can be set when defining a dictionary are safe for unprivileged users to set, and so creating a dictionary need not be a privileged operation.</source>
          <target state="translated">Для использования &lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt; вы должны быть суперпользователем . Это ограничение сделано потому, что ошибочное определение шаблона текстового поиска может запутать или даже привести к сбою сервера. Причина отделения шаблонов от словарей заключается в том, что шаблон инкапсулирует &amp;laquo;небезопасные&amp;raquo; аспекты определения словаря. Параметры, которые могут быть установлены при определении словаря, безопасны для установки непривилегированными пользователями, поэтому создание словаря не обязательно должно быть привилегированной операцией.</target>
        </trans-unit>
        <trans-unit id="d6ba0fbc9ee76ec30e6a734cc139602ed5f74a38" translate="yes" xml:space="preserve">
          <source>You must be superuser to alter an event trigger.</source>
          <target state="translated">Вы должны быть суперпользователем,чтобы изменить триггер события.</target>
        </trans-unit>
        <trans-unit id="d2778f188a2bae6cf3e02c68a508357eae34c9bc" translate="yes" xml:space="preserve">
          <source>You must be the owner of a table to create a statistics object reading it. Once created, however, the ownership of the statistics object is independent of the underlying table(s).</source>
          <target state="translated">Вы должны быть владельцем таблицы,чтобы создать объект статистики,читающий ее.Однако,после создания,право собственности на объект статистики не зависит от базовой таблицы (таблиц).</target>
        </trans-unit>
        <trans-unit id="b18eb66aae7b37aaff80a2a943d09edee67a5cd6" translate="yes" xml:space="preserve">
          <source>You must be the owner of a table to create or change policies for it.</source>
          <target state="translated">Вы должны быть владельцем таблицы,чтобы создавать или изменять политики для нее.</target>
        </trans-unit>
        <trans-unit id="dd98593a661bbd8265aa519e6846bcf6a1a65a93" translate="yes" xml:space="preserve">
          <source>You must be the owner of a table to create or change rules for it.</source>
          <target state="translated">Вы должны быть владельцем таблицы,чтобы создавать или изменять правила для нее.</target>
        </trans-unit>
        <trans-unit id="fb2285ad531d2e07d6d7c86c0203500d7139806c" translate="yes" xml:space="preserve">
          <source>You must be the owner of the configuration to use &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt;.</source>
          <target state="translated">Для использования &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; вы должны быть владельцем конфигурации .</target>
        </trans-unit>
        <trans-unit id="90b9a22d759305d6fe1fa47e1f5ffd11756e94a9" translate="yes" xml:space="preserve">
          <source>You must be the owner of the dictionary to use &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt;.</source>
          <target state="translated">Чтобы использовать &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; , вы должны быть владельцем словаря .</target>
        </trans-unit>
        <trans-unit id="1e259c4dd1968568dc3fb80e1b6efb5689d6bdb9" translate="yes" xml:space="preserve">
          <source>You must have &lt;code&gt;INSERT&lt;/code&gt; privilege on a table in order to insert into it. If &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; is present, &lt;code&gt;UPDATE&lt;/code&gt; privilege on the table is also required.</source>
          <target state="translated">У вас должна быть привилегия &lt;code&gt;INSERT&lt;/code&gt; для таблицы, чтобы выполнять вставку в нее. Если присутствует &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; , также требуется привилегия &lt;code&gt;UPDATE&lt;/code&gt; для таблицы.</target>
        </trans-unit>
        <trans-unit id="bb31803ee937f757ae783b41d67981c9d86f3e9e" translate="yes" xml:space="preserve">
          <source>You must have &lt;code&gt;SELECT&lt;/code&gt; privilege on each column used in a &lt;code&gt;SELECT&lt;/code&gt; command. The use of &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;FOR UPDATE&lt;/code&gt;, &lt;code&gt;FOR SHARE&lt;/code&gt; or &lt;code&gt;FOR KEY SHARE&lt;/code&gt; requires &lt;code&gt;UPDATE&lt;/code&gt; privilege as well (for at least one column of each table so selected).</source>
          <target state="translated">У вас должна быть привилегия &lt;code&gt;SELECT&lt;/code&gt; для каждого столбца, используемого в команде &lt;code&gt;SELECT&lt;/code&gt; . Использование &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; , &lt;code&gt;FOR UPDATE&lt;/code&gt; , &lt;code&gt;FOR SHARE&lt;/code&gt; или &lt;code&gt;FOR KEY SHARE&lt;/code&gt; также требует права &lt;code&gt;UPDATE&lt;/code&gt; (по крайней мере, для одного столбца каждой выбранной таблицы).</target>
        </trans-unit>
        <trans-unit id="d02911fbcb07608d5d71771e387bdf240b881b98" translate="yes" xml:space="preserve">
          <source>You must have select privilege on the table whose values are read by &lt;code&gt;COPY TO&lt;/code&gt;, and insert privilege on the table into which values are inserted by &lt;code&gt;COPY FROM&lt;/code&gt;. It is sufficient to have column privileges on the column(s) listed in the command.</source>
          <target state="translated">У вас должно быть право выбора для таблицы, значения которой считываются с помощью &lt;code&gt;COPY TO&lt;/code&gt; , и привилегия вставки в таблицу, в которую значения вставляются с помощью &lt;code&gt;COPY FROM&lt;/code&gt; . Достаточно иметь привилегии столбца для столбца (столбцов), перечисленных в команде.</target>
        </trans-unit>
        <trans-unit id="f7e79121fed35518353fce9ebea22091560488e8" translate="yes" xml:space="preserve">
          <source>You must have the &lt;code&gt;DELETE&lt;/code&gt; privilege on the table to delete from it, as well as the &lt;code&gt;SELECT&lt;/code&gt; privilege for any table in the &lt;code&gt;USING&lt;/code&gt; clause or whose values are read in the &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">У вас должна быть привилегия &lt;code&gt;DELETE&lt;/code&gt; для таблицы, чтобы удалить из нее, а также привилегию &lt;code&gt;SELECT&lt;/code&gt; для любой таблицы в предложении &lt;code&gt;USING&lt;/code&gt; или чьи значения считываются в &lt;code&gt;condition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a1c02ef145014df727c0bbfa9c3ff89cf785dd1" translate="yes" xml:space="preserve">
          <source>You must have the &lt;code&gt;TRUNCATE&lt;/code&gt; privilege on a table to truncate it.</source>
          <target state="translated">У вас должна быть привилегия &lt;code&gt;TRUNCATE&lt;/code&gt; для таблицы, чтобы ее обрезать.</target>
        </trans-unit>
        <trans-unit id="77a7a29185db04a6a9d2e4452098a88fd3c7b7ea" translate="yes" xml:space="preserve">
          <source>You must have the &lt;code&gt;UPDATE&lt;/code&gt; privilege on the table, or at least on the column(s) that are listed to be updated. You must also have the &lt;code&gt;SELECT&lt;/code&gt; privilege on any column whose values are read in the &lt;code&gt;expressions&lt;/code&gt; or &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">У вас должна быть привилегия &lt;code&gt;UPDATE&lt;/code&gt; для таблицы или, по крайней мере, для столбцов, перечисленных для обновления. У вас также должна быть привилегия &lt;code&gt;SELECT&lt;/code&gt; для любого столбца, значения которого читаются в &lt;code&gt;expressions&lt;/code&gt; или &lt;code&gt;condition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6be4ee2e09272568e1f74da88776799e39f34a3" translate="yes" xml:space="preserve">
          <source>You must own the aggregate function to use &lt;code&gt;ALTER AGGREGATE&lt;/code&gt;. To change the schema of an aggregate function, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the aggregate function's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the aggregate function. However, a superuser can alter ownership of any aggregate function anyway.)</source>
          <target state="translated">Чтобы использовать &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; , вы должны владеть агрегатной функцией . Чтобы изменить схему агрегатной функции, вы также должны иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; для новой схемы. Чтобы изменить владельца, вы также должны быть прямым или косвенным членом новой роли-владельца, и эта роль должна иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; в схеме агрегатной функции. (Эти ограничения предписывают, что изменение владельца не приводит к тому, что вы не могли бы сделать, отбрасывая и воссоздавая агрегатную функцию. Однако суперпользователь в любом случае может изменить владение любой агрегатной функцией.)</target>
        </trans-unit>
        <trans-unit id="a5408e4e6a9f4b7999bf20809f4af3f8dff4cea5" translate="yes" xml:space="preserve">
          <source>You must own the collation to use &lt;code&gt;ALTER COLLATION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the collation's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the collation. However, a superuser can alter ownership of any collation anyway.)</source>
          <target state="translated">Чтобы использовать &lt;code&gt;ALTER COLLATION&lt;/code&gt; , вы должны владеть сопоставлением . Чтобы изменить владельца, вы также должны быть прямым или косвенным членом новой роли-владельца, и эта роль должна иметь право &lt;code&gt;CREATE&lt;/code&gt; в схеме сопоставления. (Эти ограничения предписывают, что изменение владельца не приводит к тому, что вы не могли бы сделать, отбрасывая и воссоздавая сопоставление. Однако суперпользователь в любом случае может изменить владение любым сопоставлением.)</target>
        </trans-unit>
        <trans-unit id="d3b0175f69dcf313a89dcb0b18357a030f315c24" translate="yes" xml:space="preserve">
          <source>You must own the conversion to use &lt;code&gt;ALTER CONVERSION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the conversion's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the conversion. However, a superuser can alter ownership of any conversion anyway.)</source>
          <target state="translated">Чтобы использовать &lt;code&gt;ALTER CONVERSION&lt;/code&gt; , вы должны быть владельцем преобразования . Чтобы изменить владельца, вы также должны быть прямым или косвенным членом новой роли-владельца, и эта роль должна иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; в схеме преобразования. (Эти ограничения предписывают, что изменение владельца не приводит к тому, что вы не смогли бы сделать, отбросив и воссоздав преобразование. Однако суперпользователь в любом случае может изменить владельца любого преобразования.)</target>
        </trans-unit>
        <trans-unit id="b3c900b3d4c912ff5e4ebc53ea79d5d20107d085" translate="yes" xml:space="preserve">
          <source>You must own the domain to use &lt;code&gt;ALTER DOMAIN&lt;/code&gt;. To change the schema of a domain, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the domain's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the domain. However, a superuser can alter ownership of any domain anyway.)</source>
          <target state="translated">Чтобы использовать &lt;code&gt;ALTER DOMAIN&lt;/code&gt; , вы должны владеть доменом . Чтобы изменить схему домена, вы также должны иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; для новой схемы. Чтобы изменить владельца, вы также должны быть прямым или косвенным членом новой роли-владельца, и эта роль должна иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; в схеме домена. (Эти ограничения предписывают, что смена владельца не приводит к тому, что вы не могли бы сделать, отбрасывая и воссоздавая домен. Однако суперпользователь в любом случае может изменить владение любым доменом.)</target>
        </trans-unit>
        <trans-unit id="cb1bc5a4738dcb26a0f29902f3cbbe388057acc0" translate="yes" xml:space="preserve">
          <source>You must own the extension to use &lt;code&gt;ALTER EXTENSION&lt;/code&gt;. The &lt;code&gt;ADD&lt;/code&gt;/&lt;code&gt;DROP&lt;/code&gt; forms require ownership of the added/dropped object as well.</source>
          <target state="translated">Для использования &lt;code&gt;ALTER EXTENSION&lt;/code&gt; вы должны владеть расширением . В &lt;code&gt;ADD&lt;/code&gt; / &lt;code&gt;DROP&lt;/code&gt; формы требуют права собственности на добавленную / упал объект , а также.</target>
        </trans-unit>
        <trans-unit id="a6dffb3cd3b426a1dfeb4f3d4a34d04b92502381" translate="yes" xml:space="preserve">
          <source>You must own the extension to use &lt;code&gt;DROP EXTENSION&lt;/code&gt;.</source>
          <target state="translated">Для использования &lt;code&gt;DROP EXTENSION&lt;/code&gt; вы должны владеть расширением .</target>
        </trans-unit>
        <trans-unit id="9424f801bf04776e94b23d25a246b419d9f806fc" translate="yes" xml:space="preserve">
          <source>You must own the function to use &lt;code&gt;ALTER FUNCTION&lt;/code&gt;. To change a function's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the function's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the function. However, a superuser can alter ownership of any function anyway.)</source>
          <target state="translated">Для использования &lt;code&gt;ALTER FUNCTION&lt;/code&gt; вы должны владеть функцией . Чтобы изменить схему функции, вы также должны иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; для новой схемы. Чтобы изменить владельца, вы также должны быть прямым или косвенным членом новой роли-владельца, и эта роль должна иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; в схеме функции. (Эти ограничения предписывают, что изменение владельца не приводит к тому, что вы не смогли бы сделать, отбросив и воссоздав функцию. Однако суперпользователь в любом случае может изменить владельца любой функции.)</target>
        </trans-unit>
        <trans-unit id="2c5eaf93b84b8e16b7b4075e87568743bd5c26dc" translate="yes" xml:space="preserve">
          <source>You must own the large object to use &lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role. (However, a superuser can alter any large object anyway.) Currently, the only functionality is to assign a new owner, so both restrictions always apply.</source>
          <target state="translated">Чтобы использовать &lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt; , вы должны владеть большим объектом . Чтобы изменить владельца, вы также должны быть прямым или косвенным участником новой роли владельца. (Однако суперпользователь в любом случае может изменить любой большой объект.) В настоящее время единственная функция - назначить нового владельца, поэтому всегда применяются оба ограничения.</target>
        </trans-unit>
        <trans-unit id="c749af14eff465f32f3ae73b6015d4eb8f90f209" translate="yes" xml:space="preserve">
          <source>You must own the materialized view to use &lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt;. To change a materialized view's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the materialized view's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the materialized view. However, a superuser can alter ownership of any view anyway.)</source>
          <target state="translated">Для использования &lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt; вы должны владеть материализованным представлением . Чтобы изменить схему материализованного представления, вы также должны иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; для новой схемы. Чтобы изменить владельца, вы также должны быть прямым или косвенным участником новой роли-владельца, и эта роль должна иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; в схеме материализованного представления. (Эти ограничения предписывают, что изменение владельца не приводит к тому, что вы не могли бы сделать, отбрасывая и воссоздавая материализованное представление. Однако суперпользователь в любом случае может изменить владельца любого представления.)</target>
        </trans-unit>
        <trans-unit id="c551fec90f0914ad71d1aabc9e18e3244b6d6bf8" translate="yes" xml:space="preserve">
          <source>You must own the operator class to use &lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the operator class's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the operator class. However, a superuser can alter ownership of any operator class anyway.)</source>
          <target state="translated">Чтобы использовать &lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt; , вы должны владеть классом оператора . Чтобы изменить владельца, вы также должны быть прямым или косвенным членом новой роли-владельца, и эта роль должна иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; в схеме класса операторов. (Эти ограничения приводят к тому, что изменение владельца не приводит к тому, что вы не смогли бы сделать, отбросив и воссоздав класс операторов. Однако суперпользователь в любом случае может изменить владение любым классом операторов.)</target>
        </trans-unit>
        <trans-unit id="289cb9ff5358010db129ab37edd147b9711820ba" translate="yes" xml:space="preserve">
          <source>You must own the operator to use &lt;code&gt;ALTER OPERATOR&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the operator's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the operator. However, a superuser can alter ownership of any operator anyway.)</source>
          <target state="translated">Чтобы использовать &lt;code&gt;ALTER OPERATOR&lt;/code&gt; , вы должны владеть оператором . Чтобы изменить владельца, вы также должны быть прямым или косвенным участником новой роли-владельца, и эта роль должна иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; в схеме оператора. (Эти ограничения предписывают, что смена владельца не приводит к тому, что вы не могли бы сделать, отбрасывая и воссоздавая оператора. Однако суперпользователь в любом случае может изменить владельца любого оператора.)</target>
        </trans-unit>
        <trans-unit id="aa32bd3d71baaa7969581d0d0f33bf13710aaa54" translate="yes" xml:space="preserve">
          <source>You must own the procedure to use &lt;code&gt;ALTER PROCEDURE&lt;/code&gt;. To change a procedure's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the procedure's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the procedure. However, a superuser can alter ownership of any procedure anyway.)</source>
          <target state="translated">Чтобы использовать &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; , вы должны владеть процедурой . Чтобы изменить схему процедуры, вы также должны иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; для новой схемы. Чтобы изменить владельца, вы также должны быть прямым или косвенным участником новой роли-владельца, и эта роль должна иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; в схеме процедуры. (Эти ограничения предписывают, что изменение владельца не приводит к тому, что вы не смогли бы сделать, отбросив и воссоздав процедуру. Однако суперпользователь в любом случае может изменить владельца любой процедуры.)</target>
        </trans-unit>
        <trans-unit id="8c5dd2c9f09fa4613a78c896a4d8ff93764043b0" translate="yes" xml:space="preserve">
          <source>You must own the publication to use &lt;code&gt;ALTER PUBLICATION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role. The new owner must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the database. Also, the new owner of a &lt;code&gt;FOR ALL TABLES&lt;/code&gt; publication must be a superuser. However, a superuser can change the ownership of a publication while circumventing these restrictions.</source>
          <target state="translated">Чтобы использовать &lt;code&gt;ALTER PUBLICATION&lt;/code&gt; , вы должны быть владельцем публикации . Чтобы изменить владельца, вы также должны быть прямым или косвенным участником новой роли владельца. Новый владелец должен иметь право &lt;code&gt;CREATE&lt;/code&gt; для базы данных. Кроме того, новый владелец публикации &lt;code&gt;FOR ALL TABLES&lt;/code&gt; должен быть суперпользователем. Однако суперпользователь может изменить владельца публикации, обойдя эти ограничения.</target>
        </trans-unit>
        <trans-unit id="0ebd09d1ba00b2c43b82e29c8fd88f155f0cc3ea" translate="yes" xml:space="preserve">
          <source>You must own the schema to use &lt;code&gt;ALTER SCHEMA&lt;/code&gt;. To rename a schema you must also have the &lt;code&gt;CREATE&lt;/code&gt; privilege for the database. To alter the owner, you must also be a direct or indirect member of the new owning role, and you must have the &lt;code&gt;CREATE&lt;/code&gt; privilege for the database. (Note that superusers have all these privileges automatically.)</source>
          <target state="translated">Для использования &lt;code&gt;ALTER SCHEMA&lt;/code&gt; вы должны владеть схемой . Чтобы переименовать схему, вы также должны иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; для базы данных. Чтобы изменить владельца, вы также должны быть прямым или косвенным участником новой роли-владельца и иметь право &lt;code&gt;CREATE&lt;/code&gt; для базы данных. (Обратите внимание, что суперпользователи получают все эти привилегии автоматически.)</target>
        </trans-unit>
        <trans-unit id="06321f48b26cbb2ac459fd0a6dc711be8eab0c9e" translate="yes" xml:space="preserve">
          <source>You must own the sequence to use &lt;code&gt;ALTER SEQUENCE&lt;/code&gt;. To change a sequence's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the sequence's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the sequence. However, a superuser can alter ownership of any sequence anyway.)</source>
          <target state="translated">Чтобы использовать &lt;code&gt;ALTER SEQUENCE&lt;/code&gt; , вы должны владеть последовательностью . Чтобы изменить схему последовательности, вы также должны иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; для новой схемы. Чтобы изменить владельца, вы также должны быть прямым или косвенным участником новой роли-владельца, и эта роль должна иметь право &lt;code&gt;CREATE&lt;/code&gt; в схеме последовательности. (Эти ограничения предписывают, что изменение владельца не приводит к тому, что вы не могли бы сделать, отбрасывая и воссоздавая последовательность. Однако суперпользователь в любом случае может изменить владельца любой последовательности.)</target>
        </trans-unit>
        <trans-unit id="43effe8f1154a0915e8a351241bc95aed6ecd629" translate="yes" xml:space="preserve">
          <source>You must own the statistics object to use &lt;code&gt;ALTER STATISTICS&lt;/code&gt;. To change a statistics object's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the statistics object's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the statistics object. However, a superuser can alter ownership of any statistics object anyway.)</source>
          <target state="translated">Чтобы использовать &lt;code&gt;ALTER STATISTICS&lt;/code&gt; , вы должны владеть объектом статистики . Чтобы изменить схему объекта статистики, вы также должны иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; для новой схемы. Чтобы изменить владельца, вы также должны быть прямым или косвенным участником новой роли-владельца, и эта роль должна иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; в схеме объекта статистики. (Эти ограничения предписывают, что изменение владельца не приводит к тому, что вы не могли бы сделать, отбрасывая и воссоздавая объект статистики. Однако суперпользователь в любом случае может изменить владельца любого объекта статистики.)</target>
        </trans-unit>
        <trans-unit id="407b57125ead1fe2313dbe8d95fd59c9276cf527" translate="yes" xml:space="preserve">
          <source>You must own the subscription to use &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role. The new owner has to be a superuser. (Currently, all subscription owners must be superusers, so the owner checks will be bypassed in practice. But this might change in the future.)</source>
          <target state="translated">Для использования &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; вы должны владеть подпиской . Чтобы изменить владельца, вы также должны быть прямым или косвенным участником новой роли владельца. Новый владелец должен быть суперпользователем. (В настоящее время все владельцы подписки должны быть суперпользователями, поэтому проверки владельцев на практике будут обходиться. Но это может измениться в будущем.)</target>
        </trans-unit>
        <trans-unit id="fcf405f07e7e1cd6574b23914c55360281a218b4" translate="yes" xml:space="preserve">
          <source>You must own the table on which the trigger acts to be allowed to change its properties.</source>
          <target state="translated">Вы должны владеть таблицей,на которой действует триггер,чтобы иметь возможность изменять его свойства.</target>
        </trans-unit>
        <trans-unit id="b3ea6ee180cd5e6ed5b2a16c0c2bbd450f2133e6" translate="yes" xml:space="preserve">
          <source>You must own the table to use &lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt;. To change the schema of a foreign table, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the table's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the table. However, a superuser can alter ownership of any table anyway.) To add a column or alter a column type, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the data type.</source>
          <target state="translated">Для использования &lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt; вы должны владеть таблицей . Чтобы изменить схему сторонней таблицы, вы также должны иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; для новой схемы. Чтобы изменить владельца, вы также должны быть прямым или косвенным участником новой роли-владельца, и эта роль должна иметь право &lt;code&gt;CREATE&lt;/code&gt; в схеме таблицы. (Эти ограничения предусматривают, что изменение владельца не приводит к тому, что вы не могли бы сделать, отбрасывая и воссоздавая таблицу. Однако суперпользователь в любом случае может изменить владельца любой таблицы.) Чтобы добавить столбец или изменить тип столбца, вы должны также имеют право &lt;code&gt;USAGE&lt;/code&gt; для данного типа данных.</target>
        </trans-unit>
        <trans-unit id="0ec11d641723946e6db98f0517abce2857c0ddb6" translate="yes" xml:space="preserve">
          <source>You must own the table to use &lt;code&gt;ALTER TABLE&lt;/code&gt;. To change the schema or tablespace of a table, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema or tablespace. To add the table as a new child of a parent table, you must own the parent table as well. Also, to attach a table as a new partition of the table, you must own the table being attached. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the table's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the table. However, a superuser can alter ownership of any table anyway.) To add a column or alter a column type or use the &lt;code&gt;OF&lt;/code&gt; clause, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the data type.</source>
          <target state="translated">Вы должны владеть таблицей, чтобы использовать &lt;code&gt;ALTER TABLE&lt;/code&gt; . Чтобы изменить схему или табличное пространство таблицы, вы также должны иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; для новой схемы или табличного пространства. Чтобы добавить таблицу в качестве нового потомка родительской таблицы, вы также должны владеть родительской таблицей. Кроме того, чтобы присоединить таблицу в качестве нового раздела таблицы, вы должны владеть присоединяемой таблицей. Чтобы изменить владельца, вы также должны быть прямым или косвенным участником новой роли-владельца, и эта роль должна иметь право &lt;code&gt;CREATE&lt;/code&gt; в схеме таблицы. (Эти ограничения предусматривают, что изменение владельца не приводит к тому, что вы не могли бы сделать, отбрасывая и воссоздавая таблицу. Однако суперпользователь в любом случае может изменить владельца любой таблицы.) Чтобы добавить столбец или изменить тип столбца или использовать &lt;code&gt;OF&lt;/code&gt; Вы также должны иметь право &lt;code&gt;USAGE&lt;/code&gt; для этого типа данных.</target>
        </trans-unit>
        <trans-unit id="b208c35edf5cc5dc00f7bfea3242b7d2ef5016a5" translate="yes" xml:space="preserve">
          <source>You must own the tablespace to change the definition of a tablespace. To alter the owner, you must also be a direct or indirect member of the new owning role. (Note that superusers have these privileges automatically.)</source>
          <target state="translated">Вы должны владеть табличным пространством,чтобы изменить определение табличного пространства.Чтобы изменить владельца,вы также должны быть прямым или косвенным членом новой роли владельца.(Обратите внимание,что суперпользователи имеют эти привилегии автоматически).</target>
        </trans-unit>
        <trans-unit id="bb0b957526a357fbf1b5dba72d0747095b82b01d" translate="yes" xml:space="preserve">
          <source>You must own the type to use &lt;code&gt;ALTER TYPE&lt;/code&gt;. To change the schema of a type, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the type's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the type. However, a superuser can alter ownership of any type anyway.) To add an attribute or alter an attribute type, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the attribute's data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a595550cf8e4892a3f9ade890ea91fd323c045" translate="yes" xml:space="preserve">
          <source>You must own the type to use &lt;code&gt;ALTER TYPE&lt;/code&gt;. To change the schema of a type, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the type's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the type. However, a superuser can alter ownership of any type anyway.) To add an attribute or alter an attribute type, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the data type.</source>
          <target state="translated">Для использования &lt;code&gt;ALTER TYPE&lt;/code&gt; вы должны владеть типом . Чтобы изменить схему типа, вы также должны иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; для новой схемы. Чтобы изменить владельца, вы также должны быть прямым или косвенным членом новой роли-владельца, и эта роль должна иметь право &lt;code&gt;CREATE&lt;/code&gt; в схеме типа. (Эти ограничения предписывают, что изменение владельца не приводит к тому, что вы не могли бы сделать, отбрасывая и воссоздавая тип. Однако суперпользователь в любом случае может изменить владение любым типом.) Чтобы добавить атрибут или изменить тип атрибута, вы должны также имеют право &lt;code&gt;USAGE&lt;/code&gt; для данного типа данных.</target>
        </trans-unit>
        <trans-unit id="fcbfaecbde4a2455af73d870203e3398469ff416" translate="yes" xml:space="preserve">
          <source>You must own the view to use &lt;code&gt;ALTER VIEW&lt;/code&gt;. To change a view's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the view's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the view. However, a superuser can alter ownership of any view anyway.)</source>
          <target state="translated">Вы должны владеть представлением, чтобы использовать &lt;code&gt;ALTER VIEW&lt;/code&gt; . Чтобы изменить схему представления, вы также должны иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; для новой схемы. Чтобы изменить владельца, вы также должны быть прямым или косвенным членом новой роли-владельца, и эта роль должна иметь право &lt;code&gt;CREATE&lt;/code&gt; в схеме представления. (Эти ограничения предписывают, что изменение владельца не приводит к тому, что вы не могли бы сделать, отбрасывая и воссоздавая представление. Однако суперпользователь в любом случае может изменить владельца любого представления.)</target>
        </trans-unit>
        <trans-unit id="4911aa708898e67357c9d052b13bb6ead7673cb0" translate="yes" xml:space="preserve">
          <source>You need to reboot for the changes to take effect. See also &lt;a href=&quot;http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html&quot;&gt;http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html&lt;/a&gt; for information on shared memory under older versions of Solaris.</source>
          <target state="translated">Вам необходимо перезагрузиться, чтобы изменения вступили в силу. См. Также &lt;a href=&quot;http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html&quot;&gt;http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html&lt;/a&gt; для получения информации об общей памяти в старых версиях Solaris.</target>
        </trans-unit>
        <trans-unit id="fab91ed3926641d5859d776177b64f5776bb444d" translate="yes" xml:space="preserve">
          <source>You need to use &lt;code&gt;dearmor()&lt;/code&gt; on these keys before giving them to the PGP functions. Or if you can handle binary data, you can drop &lt;code&gt;-a&lt;/code&gt; from the command.</source>
          <target state="translated">Вам необходимо использовать &lt;code&gt;dearmor()&lt;/code&gt; для этих клавиш, прежде чем передавать их функциям PGP. Или, если вы можете обрабатывать двоичные данные, вы можете удалить &lt;code&gt;-a&lt;/code&gt; из команды.</target>
        </trans-unit>
        <trans-unit id="329e6d57552f34bb2c8cbc84c71a4150ac977a8a" translate="yes" xml:space="preserve">
          <source>You probably want to start up &lt;code&gt;psql&lt;/code&gt; to try the examples in this tutorial. It can be activated for the &lt;code&gt;mydb&lt;/code&gt; database by typing the command:</source>
          <target state="translated">Возможно, вы захотите запустить &lt;code&gt;psql&lt;/code&gt; , чтобы попробовать примеры из этого руководства. Его можно активировать для базы данных &lt;code&gt;mydb&lt;/code&gt; , набрав команду:</target>
        </trans-unit>
        <trans-unit id="6e22ef5923c1fd5594bbdb16bda1e16d0fcc7df3" translate="yes" xml:space="preserve">
          <source>You should also consider setting &lt;code&gt;hot_standby_feedback&lt;/code&gt; on standby server(s) as an alternative to using this parameter.</source>
          <target state="translated">Вам также следует рассмотреть возможность установки &lt;code&gt;hot_standby_feedback&lt;/code&gt; на резервных серверах в качестве альтернативы использованию этого параметра.</target>
        </trans-unit>
        <trans-unit id="abf0f469a9c924ec822fbdcdda37276bcd973b00" translate="yes" xml:space="preserve">
          <source>You should at this point be wondering how the input and output functions can be declared to have results or arguments of the new type, when they have to be created before the new type can be created. The answer is that the type should first be defined as a &lt;em&gt;shell type&lt;/em&gt;, which is a placeholder type that has no properties except a name and an owner. This is done by issuing the command &lt;code&gt;CREATE TYPE name&lt;/code&gt;, with no additional parameters. Then the C I/O functions can be defined referencing the shell type. Finally, &lt;code&gt;CREATE TYPE&lt;/code&gt; with a full definition replaces the shell entry with a complete, valid type definition, after which the new type can be used normally.</source>
          <target state="translated">В этот момент вам должно быть интересно, как можно объявить функции ввода и вывода, чтобы они имели результаты или аргументы нового типа, когда они должны быть созданы до того, как можно будет создать новый тип. Ответ заключается в том, что тип сначала должен быть определен как &lt;em&gt;тип оболочки&lt;/em&gt; , который является типом-заполнителем, не имеющим свойств, кроме имени и владельца. Это делается с помощью команды &lt;code&gt;CREATE TYPE name&lt;/code&gt; без дополнительных параметров. Затем можно определить функции CI / O со ссылкой на тип оболочки. Наконец, &lt;code&gt;CREATE TYPE&lt;/code&gt; с полным определением заменяет запись оболочки полным допустимым определением типа, после чего новый тип можно использовать в обычном режиме.</target>
        </trans-unit>
        <trans-unit id="62998832a31a93f392b8c5c32a45b2a0ab95bec2" translate="yes" xml:space="preserve">
          <source>You should consider that the network bandwidth must be higher than the rate of generation of WAL data.</source>
          <target state="translated">Следует учитывать,что пропускная способность сети должна быть выше,чем скорость генерации данных WAL.</target>
        </trans-unit>
        <trans-unit id="43179d16a3a417045be109f728f3b3a1fb7c1178" translate="yes" xml:space="preserve">
          <source>You should remember that DTrace scripts need to be carefully written and debugged, otherwise the trace information collected might be meaningless. In most cases where problems are found it is the instrumentation that is at fault, not the underlying system. When discussing information found using dynamic tracing, be sure to enclose the script used to allow that too to be checked and discussed.</source>
          <target state="translated">Вы должны помнить,что DTrace скрипты должны быть тщательно написаны и отлажены,в противном случае собранная информация о трассировке может быть бессмысленной.В большинстве случаев,когда обнаруживаются проблемы,виноват прибор,а не лежащая в его основе система.При обсуждении информации,найденной с помощью динамической трассировки,не забудьте приложить сценарий,используемый для того,чтобы его тоже можно было проверить и обсудить.</target>
        </trans-unit>
        <trans-unit id="3bf69a6d0ffb8bac8b279e39a485a02a700714e9" translate="yes" xml:space="preserve">
          <source>You should take care that the data types specified for a probe's parameters match the data types of the variables used in the macro. Otherwise, you will get compilation errors.</source>
          <target state="translated">Следует позаботиться о том,чтобы типы данных,указанные для параметров зонда,совпадали с типами данных переменных,используемых в макросе.В противном случае вы получите ошибки компиляции.</target>
        </trans-unit>
        <trans-unit id="d04a892bbd8087c24b67b0ef9b1ba084ecd5f255" translate="yes" xml:space="preserve">
          <source>You should, however, omit from the backup the files within the cluster's &lt;code&gt;pg_wal/&lt;/code&gt; subdirectory. This slight adjustment is worthwhile because it reduces the risk of mistakes when restoring. This is easy to arrange if &lt;code&gt;pg_wal/&lt;/code&gt; is a symbolic link pointing to someplace outside the cluster directory, which is a common setup anyway for performance reasons. You might also want to exclude &lt;code&gt;postmaster.pid&lt;/code&gt; and &lt;code&gt;postmaster.opts&lt;/code&gt;, which record information about the running postmaster, not about the postmaster which will eventually use this backup. (These files can confuse pg_ctl.)</source>
          <target state="translated">Однако вам следует исключить из резервной копии файлы в подкаталоге &lt;code&gt;pg_wal/&lt;/code&gt; кластера . Эта небольшая корректировка стоит того, потому что снижает риск ошибок при восстановлении. Это легко организовать, если &lt;code&gt;pg_wal/&lt;/code&gt; - это символическая ссылка, указывающая на какое-то место за пределами каталога кластера, что в любом случае является обычной настройкой по соображениям производительности. Вы также можете исключить &lt;code&gt;postmaster.pid&lt;/code&gt; и &lt;code&gt;postmaster.opts&lt;/code&gt; , которые записывают информацию о запущенном postmaster, а не о postmaster, который в конечном итоге будет использовать эту резервную копию. (Эти файлы могут сбивать с толку pg_ctl.)</target>
        </trans-unit>
        <trans-unit id="f688c2bcf87c6522b972dcd5d1a0d98122829c3b" translate="yes" xml:space="preserve">
          <source>You use the &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; command to remove rows; the syntax is very similar to the &lt;code&gt;UPDATE&lt;/code&gt; command. For instance, to remove all rows from the products table that have a price of 10, use:</source>
          <target state="translated">Вы используете команду &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; для удаления строк; синтаксис очень похож на команду &lt;code&gt;UPDATE&lt;/code&gt; . Например, чтобы удалить все строки из таблицы продуктов с ценой 10, используйте:</target>
        </trans-unit>
        <trans-unit id="c8d44004f1a1375d285a996132364e5a09cd0aa9" translate="yes" xml:space="preserve">
          <source>You usually only need to set this parameter in complex re-recovery situations, where you need to return to a state that itself was reached after a point-in-time recovery. See &lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;Section 25.3.5&lt;/a&gt; for discussion.</source>
          <target state="translated">Обычно вам нужно установить этот параметр только в сложных ситуациях повторного восстановления, когда вам нужно вернуться в состояние, которое само было достигнуто после восстановления на определенный момент времени. См. &lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;Обсуждение в Разделе 25.3.5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c0b4770f607d09fa317c5dc06f4c40416fa8fa6" translate="yes" xml:space="preserve">
          <source>You will encounter this style of abbreviating quite frequently.</source>
          <target state="translated">Вы довольно часто будете сталкиваться с этим стилем сокращения.</target>
        </trans-unit>
        <trans-unit id="f2689ccc464a2d160017022cb703ee291e2f949e" translate="yes" xml:space="preserve">
          <source>You will sometimes need to add parentheses when using combinations of binary and unary operators. For instance:</source>
          <target state="translated">Иногда при использовании комбинаций двоичных и одинарных операторов необходимо добавлять круглые скобки.Например:</target>
        </trans-unit>
        <trans-unit id="4f96b903666683fcb600721163b7537153b2acf3" translate="yes" xml:space="preserve">
          <source>You will then need to use gunzip during recovery:</source>
          <target state="translated">Тогда вам нужно будет использовать пистолет-пулемет во время восстановления:</target>
        </trans-unit>
        <trans-unit id="76a9773cd5b34137343c2a3db898da05e9e5088f" translate="yes" xml:space="preserve">
          <source>You will usually want to increase &lt;code&gt;kern.ipc.semmni&lt;/code&gt; and &lt;code&gt;kern.ipc.semmns&lt;/code&gt;, as NetBSD's default settings for these are uncomfortably small.</source>
          <target state="translated">Обычно вам нужно увеличить &lt;code&gt;kern.ipc.semmni&lt;/code&gt; и &lt;code&gt;kern.ipc.semmns&lt;/code&gt; , поскольку настройки NetBSD по умолчанию для них слишком малы.</target>
        </trans-unit>
        <trans-unit id="4d7dd316d288d7dc8cab74686babd6da0f71907c" translate="yes" xml:space="preserve">
          <source>You will usually want to increase &lt;code&gt;kern.seminfo.semmni&lt;/code&gt; and &lt;code&gt;kern.seminfo.semmns&lt;/code&gt;, as OpenBSD's default settings for these are uncomfortably small.</source>
          <target state="translated">Обычно вам нужно увеличить &lt;code&gt;kern.seminfo.semmni&lt;/code&gt; и &lt;code&gt;kern.seminfo.semmns&lt;/code&gt; , поскольку настройки OpenBSD по умолчанию для них слишком малы.</target>
        </trans-unit>
        <trans-unit id="2609a6d5763d68ee7a0a0d2d4b45f307e6ae5ffd" translate="yes" xml:space="preserve">
          <source>Zero-Column Tables</source>
          <target state="translated">Столбцы с нулевой колонкой</target>
        </trans-unit>
        <trans-unit id="30c11554a2b9e71795733af27503dd2000ac35f9" translate="yes" xml:space="preserve">
          <source>Zipfian-distributed random integer in &lt;code&gt;[lb, ub]&lt;/code&gt;, see below</source>
          <target state="translated">Случайное целое число, распределенное по Ципфиану в &lt;code&gt;[lb, ub]&lt;/code&gt; , см. Ниже</target>
        </trans-unit>
        <trans-unit id="329669d49d5a7c00789e68977fd4b07da1d077c8" translate="yes" xml:space="preserve">
          <source>[ &lt;code&gt;ENCRYPTED&lt;/code&gt; ] &lt;code&gt;PASSWORD&lt;/code&gt; '&lt;code&gt;password&lt;/code&gt;'&lt;code&gt;PASSWORD NULL&lt;/code&gt;</source>
          <target state="translated">[ &lt;code&gt;ENCRYPTED&lt;/code&gt; ] &lt;code&gt;PASSWORD&lt;/code&gt; ' &lt;code&gt;password&lt;/code&gt; ' &lt;code&gt;PASSWORD NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="689b11d9bddde6c1d7ee8e5eb112418a0978460f" translate="yes" xml:space="preserve">
          <source>[(x1,y1),...]</source>
          <target state="translated">[(x1,y1),...]</target>
        </trans-unit>
        <trans-unit id="56bed60529c445af77ea7362851c52890ef3de9a" translate="yes" xml:space="preserve">
          <source>[a, b] is entirely to the left of [c, d]. That is, [a, b] &amp;lt;&amp;lt; [c, d] is true if b &amp;lt; c and false otherwise.</source>
          <target state="translated">[a, b] полностью слева от [c, d]. То есть [a, b] &amp;lt;&amp;lt; [c, d] истинно, если b &amp;lt;c, и ложно в противном случае.</target>
        </trans-unit>
        <trans-unit id="46347467de76083a1f3b3ab7c5a273c56dcfd8f4" translate="yes" xml:space="preserve">
          <source>[a, b] is entirely to the right of [c, d]. That is, [a, b] &amp;gt;&amp;gt; [c, d] is true if a &amp;gt; d and false otherwise.</source>
          <target state="translated">[a, b] полностью справа от [c, d]. То есть [a, b] &amp;gt;&amp;gt; [c, d] истинно, если a&amp;gt; d, и ложно в противном случае.</target>
        </trans-unit>
        <trans-unit id="038cf8dbb178850257e9230060d8fcef7ddfb5a0" translate="yes" xml:space="preserve">
          <source>[elma04]</source>
          <target state="translated">[elma04]</target>
        </trans-unit>
        <trans-unit id="2b5f5b947ce4c4c7f099a0a2d735357e09310b58" translate="yes" xml:space="preserve">
          <source>[fong]</source>
          <target state="translated">[fong]</target>
        </trans-unit>
        <trans-unit id="5c07a6ad2db9480747f4d609fb47951588166180" translate="yes" xml:space="preserve">
          <source>a &lt;em&gt;bracket expression&lt;/em&gt;, matching any one of the &lt;code&gt;chars&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-BRACKET-EXPRESSIONS&quot;&gt;Section 9.7.3.2&lt;/a&gt; for more detail)</source>
          <target state="translated">&lt;em&gt;выражение кронштейн&lt;/em&gt; , соответствующий любому одному из &lt;code&gt;chars&lt;/code&gt; (см &lt;a href=&quot;functions-matching#POSIX-BRACKET-EXPRESSIONS&quot;&gt;раздел 9.7.3.2&lt;/a&gt; для более подробно)</target>
        </trans-unit>
        <trans-unit id="5c2a04f8a25082f47f2b1b62420d51d9e2586092" translate="yes" xml:space="preserve">
          <source>a closed path?</source>
          <target state="translated">закрытый путь?</target>
        </trans-unit>
        <trans-unit id="4f837508b52bb0f6f0c188e3d8239bb66f7f30b3" translate="yes" xml:space="preserve">
          <source>a label beginning with the case-insensitive prefix &lt;code&gt;sport&lt;/code&gt;</source>
          <target state="translated">метка, начинающаяся с префикса &lt;code&gt;sport&lt;/code&gt; без учета регистра</target>
        </trans-unit>
        <trans-unit id="8b52f02d3dbf1419017e235881c6561ac7603288" translate="yes" xml:space="preserve">
          <source>a sequence of 0 or 1 matches of the atom</source>
          <target state="translated">последовательность 0 или 1 совпадений атома</target>
        </trans-unit>
        <trans-unit id="c789ac60ffb3a4856f62a0cc113a4a9eb99a3e78" translate="yes" xml:space="preserve">
          <source>a sequence of 0 or more matches of the atom</source>
          <target state="translated">последовательность 0 или более совпадений атома</target>
        </trans-unit>
        <trans-unit id="37235ff249a4a2dc93bed2d89eba1468f3102441" translate="yes" xml:space="preserve">
          <source>a sequence of 1 or more matches of the atom</source>
          <target state="translated">последовательность 1 или более совпадений атома</target>
        </trans-unit>
        <trans-unit id="f4d6892681b0f2c2f68672a4ea2ebea56a26fb7c" translate="yes" xml:space="preserve">
          <source>a sequence of &lt;code&gt;m&lt;/code&gt; or more matches of the atom</source>
          <target state="translated">последовательность &lt;code&gt;m&lt;/code&gt; или более совпадений атома</target>
        </trans-unit>
        <trans-unit id="d6eb7a7a662e02de4e455a3d9cb22b1e5cbc9fd0" translate="yes" xml:space="preserve">
          <source>a sequence of &lt;code&gt;m&lt;/code&gt; through &lt;code&gt;n&lt;/code&gt; (inclusive) matches of the atom; &lt;code&gt;m&lt;/code&gt; cannot exceed &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">последовательность от &lt;code&gt;m&lt;/code&gt; до &lt;code&gt;n&lt;/code&gt; (включительно) совпадений атома; &lt;code&gt;m&lt;/code&gt; не может превышать &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a1befdcf13a2caa739dbb24cca880bbc955a58b" translate="yes" xml:space="preserve">
          <source>a sequence of exactly &lt;code&gt;m&lt;/code&gt; matches of the atom</source>
          <target state="translated">последовательность ровно &lt;code&gt;m&lt;/code&gt; совпадений атома</target>
        </trans-unit>
        <trans-unit id="42e244f289cb2901a2850fc0e292f5c6110aec21" translate="yes" xml:space="preserve">
          <source>a single lexeme with the &lt;code&gt;TSL_FILTER&lt;/code&gt; flag set, to replace the original token with a new token to be passed to subsequent dictionaries (a dictionary that does this is called a &lt;em&gt;filtering dictionary&lt;/em&gt;)</source>
          <target state="translated">единственная лексема с &lt;code&gt;TSL_FILTER&lt;/code&gt; флагом TSL_FILTER , чтобы заменить исходный токен новым токеном, который будет передан в последующие словари (словарь, который делает это, называется &lt;em&gt;словарем фильтрации&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="39c985af6407cb40e9f21b877cb2f14f1ab7445e" translate="yes" xml:space="preserve">
          <source>a white-space character or &lt;code&gt;#&lt;/code&gt; preceded by &lt;code&gt;\&lt;/code&gt; is retained</source>
          <target state="translated">символ пробела или &lt;code&gt;#&lt;/code&gt; , которому предшествует &lt;code&gt;\&lt;/code&gt; , сохраняется</target>
        </trans-unit>
        <trans-unit id="c79c0a316e1b5d5dfe7325f52987831549fe62de" translate="yes" xml:space="preserve">
          <source>abbreviated capitalized day name (3 chars in English, localized lengths vary)</source>
          <target state="translated">сокращенное название дня с заглавными буквами (3 символа на английском языке,локальная длина варьируется)</target>
        </trans-unit>
        <trans-unit id="264cda486a8f189eb4b75e086f6d14582addebc5" translate="yes" xml:space="preserve">
          <source>abbreviated capitalized month name (3 chars in English, localized lengths vary)</source>
          <target state="translated">сокращенное название месяца с заглавными буквами (3 символа на английском языке,локальная длина варьируется)</target>
        </trans-unit>
        <trans-unit id="ece4f8ac5a0911464c77304a7d93e8b052502ee1" translate="yes" xml:space="preserve">
          <source>abbreviated display format as text</source>
          <target state="translated">сокращённый формат отображения в виде текста</target>
        </trans-unit>
        <trans-unit id="88b965dacddbd5c3be3568170a1a398601e53a48" translate="yes" xml:space="preserve">
          <source>abbreviated lower case day name (3 chars in English, localized lengths vary)</source>
          <target state="translated">сокращенное название дня в нижнем регистре (3 символа на английском языке,локализованная длина варьируется)</target>
        </trans-unit>
        <trans-unit id="9186b18dd65f270c46192797d4cb755071c05c1e" translate="yes" xml:space="preserve">
          <source>abbreviated lower case month name (3 chars in English, localized lengths vary)</source>
          <target state="translated">сокращенное название месяца в нижнем регистре (3 символа на английском языке,локализованная длина варьируется)</target>
        </trans-unit>
        <trans-unit id="a3f61c541f5db806cb405bf2892b6722718fec31" translate="yes" xml:space="preserve">
          <source>abbreviated upper case day name (3 chars in English, localized lengths vary)</source>
          <target state="translated">сокращенное название дня в верхнем регистре (3 символа на английском языке,локализованная длина варьируется)</target>
        </trans-unit>
        <trans-unit id="7577f3a97383fa6c0292570407f15fbf40857e56" translate="yes" xml:space="preserve">
          <source>abbreviated upper case month name (3 chars in English, localized lengths vary)</source>
          <target state="translated">сокращенное название месяца в верхнем регистре (3 символа на английском языке,локализованная длина варьируется)</target>
        </trans-unit>
        <trans-unit id="33f31413199ddb62fc17b8f2bed78e9d010e94da" translate="yes" xml:space="preserve">
          <source>absolute value</source>
          <target state="translated">абсолютная ценность</target>
        </trans-unit>
        <trans-unit id="de8436d989e265b7b258d6602654167f651db67b" translate="yes" xml:space="preserve">
          <source>access method operator classes</source>
          <target state="translated">операторские классы методов доступа</target>
        </trans-unit>
        <trans-unit id="639212fb06d8ccc51f13d82301ca6b66a2deb947" translate="yes" xml:space="preserve">
          <source>access method operator families</source>
          <target state="translated">семейства операторов способов доступа</target>
        </trans-unit>
        <trans-unit id="a5886a24a9cd7f64cdec22dc5f1b0dad9949c443" translate="yes" xml:space="preserve">
          <source>access method operators</source>
          <target state="translated">операторы метода доступа</target>
        </trans-unit>
        <trans-unit id="cce1015f8d299b67b710b93d76b497f49fa98565" translate="yes" xml:space="preserve">
          <source>access method support functions</source>
          <target state="translated">функции поддержки метода доступа</target>
        </trans-unit>
        <trans-unit id="b9cfb8c8675bb466671371ec06207e1c430329f4" translate="yes" xml:space="preserve">
          <source>adding affix</source>
          <target state="translated">добавление аффикса</target>
        </trans-unit>
        <trans-unit id="c3805175370d19c334b59f45b87343b9f2b7f5e1" translate="yes" xml:space="preserve">
          <source>addition</source>
          <target state="translated">addition</target>
        </trans-unit>
        <trans-unit id="9118866496dfbc2e597505390a41e74349ab5152" translate="yes" xml:space="preserve">
          <source>addition, subtraction</source>
          <target state="translated">сложение,вычитание</target>
        </trans-unit>
        <trans-unit id="aaf09a4b156ac6da8c98f72704c7cee1497e7d6f" translate="yes" xml:space="preserve">
          <source>additional foreign table information</source>
          <target state="translated">дополнительная информация в иностранной таблице</target>
        </trans-unit>
        <trans-unit id="1a32619c4b1c2c834145f692705708f779bed83a" translate="yes" xml:space="preserve">
          <source>additional index information</source>
          <target state="translated">дополнительная индексная информация</target>
        </trans-unit>
        <trans-unit id="de48f56b01bcd91fd19904d21fc567f7aeb73b16" translate="yes" xml:space="preserve">
          <source>address of the local connection</source>
          <target state="translated">адрес локальной связи</target>
        </trans-unit>
        <trans-unit id="95dd78f31f2d2267d2022e6763c1fb744bbf23ea" translate="yes" xml:space="preserve">
          <source>address of the remote connection</source>
          <target state="translated">адрес удалённого подключения</target>
        </trans-unit>
        <trans-unit id="0e18d863cc787a1080e11d6aad8c84c3d163b704" translate="yes" xml:space="preserve">
          <source>adminpack</source>
          <target state="translated">adminpack</target>
        </trans-unit>
        <trans-unit id="bccf7370fc6bc7e65ebb00bcd447b407dc6e3ec1" translate="yes" xml:space="preserve">
          <source>aggregate functions</source>
          <target state="translated">совокупные функции</target>
        </trans-unit>
        <trans-unit id="5707e56794034492e28fb802f0929edc22148ae3" translate="yes" xml:space="preserve">
          <source>aggregates name/value pairs as a JSON object; values can be null, but not names</source>
          <target state="translated">агрегирует пары имя/значение как JSON-объект;значения могут быть нулевыми,но не имена</target>
        </trans-unit>
        <trans-unit id="100b0a2fce8f87a6bf417e59568b60def0dd95ed" translate="yes" xml:space="preserve">
          <source>aggregates values, including nulls, as a JSON array</source>
          <target state="translated">агрегирует значения,включая нули,в виде массива JSON</target>
        </trans-unit>
        <trans-unit id="27428a051111f05b13f941652832e7ba4a594fed" translate="yes" xml:space="preserve">
          <source>alert (bell) character, as in C</source>
          <target state="translated">предупреждающий (звонок)персонаж,как в C</target>
        </trans-unit>
        <trans-unit id="8a97bf0012dbebc5bcefd88a6e6ca0df50de1524" translate="yes" xml:space="preserve">
          <source>alias for &lt;code&gt;hash_murmur2()&lt;/code&gt;</source>
          <target state="translated">псевдоним для &lt;code&gt;hash_murmur2()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3acb7916bd347d132eed28f72c60ded2aae1942" translate="yes" xml:space="preserve">
          <source>all other native and user-defined operators</source>
          <target state="translated">все остальные родные и определяемые пользователем операторы</target>
        </trans-unit>
        <trans-unit id="15100289fd2a2926dbfc0362c8c82f216aafdb18" translate="yes" xml:space="preserve">
          <source>amcheck</source>
          <target state="translated">amcheck</target>
        </trans-unit>
        <trans-unit id="663bae22b8d6ed1b0c5424f47e75478c4fc96f3e" translate="yes" xml:space="preserve">
          <source>an array of lexemes if the input token is known to the dictionary (notice that one token can produce more than one lexeme)</source>
          <target state="translated">массив лексем,если входная лексема известна по словарю (обратите внимание,что одна лексема может выдавать более одной лексемы)</target>
        </trans-unit>
        <trans-unit id="232a7414ddb1870267de0ac5d074d426c7090d4d" translate="yes" xml:space="preserve">
          <source>an empty array if the dictionary knows the token, but it is a stop word</source>
          <target state="translated">пустой массив,если словарь знает токен,но это стоп-слово.</target>
        </trans-unit>
        <trans-unit id="4a50c2a4d787c9ec20847e24d511e5f7edd971bf" translate="yes" xml:space="preserve">
          <source>an integer between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt;</source>
          <target state="translated">целое число от &lt;code&gt;1&lt;/code&gt; до &lt;code&gt;10&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b6686e81b37171a7ea6080018ce0ae5e675c63c" translate="yes" xml:space="preserve">
          <source>an open path?</source>
          <target state="translated">открытый путь?</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="195ca7bc7f18fd5ef1b0e2c3a54dd46b02d4927d" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;frame_exclusion&lt;/code&gt; can be one of</source>
          <target state="translated">и &lt;code&gt;frame_exclusion&lt;/code&gt; может быть одним из</target>
        </trans-unit>
        <trans-unit id="b061bc6b05f4e30ad67fd83ca835fa19bda9bb24" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;mode&lt;/code&gt; is one of:</source>
          <target state="translated">и один из &lt;code&gt;mode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dfcc9edf53bd479c53a758f8cd20ae723fac9500" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;padding&lt;/code&gt; is one of:</source>
          <target state="translated">а &lt;code&gt;padding&lt;/code&gt; - одно из:</target>
        </trans-unit>
        <trans-unit id="1f043826d65c29cd9d06435f4c3f4c44886caf1f" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;psql&lt;/code&gt; will quit and return you to your command shell. (For more internal commands, type &lt;code&gt;\?&lt;/code&gt; at the &lt;code&gt;psql&lt;/code&gt; prompt.) The full capabilities of &lt;code&gt;psql&lt;/code&gt; are documented in &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;. In this tutorial we will not use these features explicitly, but you can use them yourself when it is helpful.</source>
          <target state="translated">и &lt;code&gt;psql&lt;/code&gt; завершит работу и вернет вас в командную оболочку. (Для получения дополнительных внутренних команд введите &lt;code&gt;\?&lt;/code&gt; В &lt;code&gt;psql&lt;/code&gt; строке psql .) Полные возможности &lt;code&gt;psql&lt;/code&gt; задокументированы в &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; . В этом руководстве мы не будем использовать эти функции явно, но вы можете использовать их самостоятельно, когда это будет полезно.</target>
        </trans-unit>
        <trans-unit id="3badfcd96666510617917bc44cf260ce650da948" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;t2&lt;/code&gt;:</source>
          <target state="translated">и &lt;code&gt;t2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="64f54598fc8b10700b447590aedbe9802f2cf914" translate="yes" xml:space="preserve">
          <source>and Collations</source>
          <target state="translated">и переводы</target>
        </trans-unit>
        <trans-unit id="097ca12344ffcd3926b70cf91232fc017a3d35e9" translate="yes" xml:space="preserve">
          <source>and ORDER BY</source>
          <target state="translated">и ЗАКАЗАТЬСЯ</target>
        </trans-unit>
        <trans-unit id="a41a99f30db5c8c73bb765ef058446c9ffe876c5" translate="yes" xml:space="preserve">
          <source>and all the dependent objects will be removed, as will any objects that depend on them, recursively. In this case, it doesn't remove the orders table, it only removes the foreign key constraint. It stops there because nothing depends on the foreign key constraint. (If you want to check what &lt;code&gt;DROP ... CASCADE&lt;/code&gt; will do, run &lt;code&gt;DROP&lt;/code&gt; without &lt;code&gt;CASCADE&lt;/code&gt; and read the &lt;code&gt;DETAIL&lt;/code&gt; output.)</source>
          <target state="translated">и все зависимые объекты будут удалены, как и все объекты, которые от них зависят, рекурсивно. В этом случае он не удаляет таблицу заказов, а только удаляет ограничение внешнего ключа. На этом все заканчивается, потому что от ограничения внешнего ключа ничего не зависит. (Если вы хотите проверить, что будет делать &lt;code&gt;DROP ... CASCADE&lt;/code&gt; , запустите &lt;code&gt;DROP&lt;/code&gt; без &lt;code&gt;CASCADE&lt;/code&gt; и прочтите вывод &lt;code&gt;DETAIL&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="91ded08e1c2fb163ac112ff991a147382d928feb" translate="yes" xml:space="preserve">
          <source>and can appear anywhere a &lt;code&gt;SELECT&lt;/code&gt; can. For example, you can use it as part of a &lt;code&gt;UNION&lt;/code&gt;, or attach a &lt;code&gt;sort_specification&lt;/code&gt; (&lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt;, and/or &lt;code&gt;OFFSET&lt;/code&gt;) to it. &lt;code&gt;VALUES&lt;/code&gt; is most commonly used as the data source in an &lt;code&gt;INSERT&lt;/code&gt; command, and next most commonly as a subquery.</source>
          <target state="translated">и может появиться везде, где может быть &lt;code&gt;SELECT&lt;/code&gt; . Например, вы можете использовать его как часть &lt;code&gt;UNION&lt;/code&gt; или присоединить к нему &lt;code&gt;sort_specification&lt;/code&gt; ( &lt;code&gt;ORDER BY&lt;/code&gt; , &lt;code&gt;LIMIT&lt;/code&gt; и / или &lt;code&gt;OFFSET&lt;/code&gt; ). &lt;code&gt;VALUES&lt;/code&gt; чаще всего используется в качестве источника данных в команде &lt;code&gt;INSERT&lt;/code&gt; , а затем чаще всего используется как подзапрос.</target>
        </trans-unit>
        <trans-unit id="463a6cd589d2223d499014d12a55159d1281075e" translate="yes" xml:space="preserve">
          <source>and her transaction is in &lt;code&gt;READ COMMITTED&lt;/code&gt; mode, it is possible for her to see &amp;ldquo;secret from mallory&amp;rdquo;. That happens if her transaction reaches the &lt;code&gt;information&lt;/code&gt; row just after &lt;code&gt;alice&lt;/code&gt;'s does. It blocks waiting for &lt;code&gt;alice&lt;/code&gt;'s transaction to commit, then fetches the updated row contents thanks to the &lt;code&gt;FOR UPDATE&lt;/code&gt; clause. However, it does &lt;em&gt;not&lt;/em&gt; fetch an updated row for the implicit &lt;code&gt;SELECT&lt;/code&gt; from &lt;code&gt;users&lt;/code&gt;, because that sub-&lt;code&gt;SELECT&lt;/code&gt; did not have &lt;code&gt;FOR UPDATE&lt;/code&gt;; instead the &lt;code&gt;users&lt;/code&gt; row is read with the snapshot taken at the start of the query. Therefore, the policy expression tests the old value of &lt;code&gt;mallory&lt;/code&gt;'s privilege level and allows her to see the updated row.</source>
          <target state="translated">и ее транзакция находится в режиме &lt;code&gt;READ COMMITTED&lt;/code&gt; , она может увидеть &amp;laquo;секрет из магазина&amp;raquo;. Это происходит, если ее транзакция достигает &lt;code&gt;information&lt;/code&gt; строки сразу после транзакции &lt;code&gt;alice&lt;/code&gt; . Он блокирует ожидание &lt;code&gt;alice&lt;/code&gt; сделки &amp;laquo;s совершить, а затем извлекает обновленное содержимое строки благодаря &lt;code&gt;FOR UPDATE&lt;/code&gt; пункта. Однако, это &lt;em&gt;не&lt;/em&gt; получать обновленную строку для неявного &lt;code&gt;SELECT&lt;/code&gt; , от &lt;code&gt;users&lt;/code&gt; , потому что суб- &lt;code&gt;SELECT&lt;/code&gt; не было &lt;code&gt;FOR UPDATE&lt;/code&gt; ; вместо этого &lt;code&gt;users&lt;/code&gt; Считывается строка со снимком, сделанным в начале запроса. Следовательно, выражение политики проверяет старое значение &lt;code&gt;mallory&lt;/code&gt; привилегий mallory и позволяет ей видеть обновленную строку.</target>
        </trans-unit>
        <trans-unit id="2ddf7473848fa4907e6ee0ff26623f75dfed1f01" translate="yes" xml:space="preserve">
          <source>and next has zero to two labels before</source>
          <target state="translated">и следующая имеет от нуля до двух этикеток до того.</target>
        </trans-unit>
        <trans-unit id="d723326824a3836a81d727940bbbaebfea441ace" translate="yes" xml:space="preserve">
          <source>and obtains the result 300, which it inserts in a new row with &lt;code&gt;class&lt;/code&gt;&lt;code&gt;= 1&lt;/code&gt;. Then both transactions try to commit. If either transaction were running at the Repeatable Read isolation level, both would be allowed to commit; but since there is no serial order of execution consistent with the result, using Serializable transactions will allow one transaction to commit and will roll the other back with this message:</source>
          <target state="translated">и получает результат 300, который вставляет в новую строку с &lt;code&gt;class&lt;/code&gt; &lt;code&gt;= 1&lt;/code&gt; . Затем обе транзакции пытаются зафиксировать. Если бы любая транзакция выполнялась на уровне изоляции Repeatable Read, обеим было бы разрешено зафиксировать; но поскольку нет последовательного порядка выполнения, согласованного с результатом, использование сериализуемых транзакций позволит одной транзакции зафиксировать и откатит другую с помощью этого сообщения:</target>
        </trans-unit>
        <trans-unit id="abd292e64f5762adf92489151f65db3a2d25c4cf" translate="yes" xml:space="preserve">
          <source>and overriding the collation of a function or operator call that has locale-sensitive results, for example:</source>
          <target state="translated">и переопределение сопоставления вызова функции или оператора,который имеет,например,чувствительные к локали результаты:</target>
        </trans-unit>
        <trans-unit id="4472b3d78f22b89c61f97b762041a5148f6b86b3" translate="yes" xml:space="preserve">
          <source>and the application issues many queries of the form:</source>
          <target state="translated">и заявка выдает много запросов формы:</target>
        </trans-unit>
        <trans-unit id="519bfeab6436137fc4443c937b4e2a57a5222950" translate="yes" xml:space="preserve">
          <source>and then ends with a label beginning with &lt;code&gt;Russ&lt;/code&gt; or exactly matching &lt;code&gt;Spain&lt;/code&gt;.</source>
          <target state="translated">а затем заканчивается этикеткой, начинающейся с &lt;code&gt;Russ&lt;/code&gt; или точно соответствующей &lt;code&gt;Spain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da0d7e15413e88d505f96b30393006166f82a571" translate="yes" xml:space="preserve">
          <source>and then insert the &lt;code&gt;NOT&lt;/code&gt; key word where desired.</source>
          <target state="translated">а затем вставьте ключевое слово &lt;code&gt;NOT&lt;/code&gt; нужное место.</target>
        </trans-unit>
        <trans-unit id="f550ff82765c7c77442e312860d5c5a6aa4ec136" translate="yes" xml:space="preserve">
          <source>and then inserts the result (30) as the &lt;code&gt;value&lt;/code&gt; in a new row with &lt;code&gt;class&lt;/code&gt;&lt;code&gt;= 2&lt;/code&gt;. Concurrently, serializable transaction B computes:</source>
          <target state="translated">а затем вставляет результат (30) как &lt;code&gt;value&lt;/code&gt; в новую строку с &lt;code&gt;class&lt;/code&gt; &lt;code&gt;= 2&lt;/code&gt; . Одновременно сериализуемая транзакция B вычисляет:</target>
        </trans-unit>
        <trans-unit id="d17266916c8a994f2881eb849993c9875639d0c1" translate="yes" xml:space="preserve">
          <source>and then run pg_upgrade with quoted directories, e.g.:</source>
          <target state="translated">а затем запустите pg_upgrade с цитируемыми каталогами,например:</target>
        </trans-unit>
        <trans-unit id="146d654592d3bdf49836fb607a26abdff8dc565f" translate="yes" xml:space="preserve">
          <source>and these representations for the &amp;ldquo;false&amp;rdquo; state:</source>
          <target state="translated">и эти представления для &amp;laquo;ложного&amp;raquo; состояния:</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="c5fe0200d1c7a5139bd18fd22268c4ca8bf45e90" translate="yes" xml:space="preserve">
          <source>any</source>
          <target state="translated">any</target>
        </trans-unit>
        <trans-unit id="f0d8476cddfcece7be214ceeeb87fed56a99c5be" translate="yes" xml:space="preserve">
          <source>any OID column</source>
          <target state="translated">любая колонка OID</target>
        </trans-unit>
        <trans-unit id="776b72d37856a0495e69540bbde0cf0ff74423cc" translate="yes" xml:space="preserve">
          <source>any array type</source>
          <target state="translated">любой тип массива</target>
        </trans-unit>
        <trans-unit id="c8fdfd5cb246da542aaeb9979987b47c98e64395" translate="yes" xml:space="preserve">
          <source>any non-array type</source>
          <target state="translated">любой нелассирующий тип</target>
        </trans-unit>
        <trans-unit id="72433658efe8a2e649ce354eaceeb1954b3d6706" translate="yes" xml:space="preserve">
          <source>any numeric, string, date/time, network, or enum type, or arrays of these types</source>
          <target state="translated">любой числовой,строковый,дата/время,сетевой или перечислительный тип,или массивы этих типов</target>
        </trans-unit>
        <trans-unit id="1d1ab32371b3accbfb7ecab87204e63142da53d2" translate="yes" xml:space="preserve">
          <source>any range type</source>
          <target state="translated">любой вид диапазона</target>
        </trans-unit>
        <trans-unit id="17b1f448b91caed36d022289e6bc4c20cb8cb1bf" translate="yes" xml:space="preserve">
          <source>any sortable type</source>
          <target state="translated">любой сортируемый тип</target>
        </trans-unit>
        <trans-unit id="fc497c9667b2d21c95e0422a7a79489a554110d8" translate="yes" xml:space="preserve">
          <source>append an element to the beginning of an array</source>
          <target state="translated">добавить элемент в начало массива</target>
        </trans-unit>
        <trans-unit id="8510099a899e6e19ffcdc41786dd5bee38c2a170" translate="yes" xml:space="preserve">
          <source>append an element to the end of an array</source>
          <target state="translated">добавить элемент в конец массива</target>
        </trans-unit>
        <trans-unit id="9a48ebf2c2867a717af59a3d046f96e76db2e70a" translate="yes" xml:space="preserve">
          <source>are also of interest, an additional index could be created that supports the &lt;code&gt;&quot;y&quot;&lt;/code&gt; collation, like this:</source>
          <target state="translated">также представляют интерес, можно создать дополнительный индекс, поддерживающий сортировку &lt;code&gt;&quot;y&quot;&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="aa4b0695d2fd6cd9abbff5f407b06b97863d61bd" translate="yes" xml:space="preserve">
          <source>are the addresses from the same family?</source>
          <target state="translated">это адреса из одной семьи?</target>
        </trans-unit>
        <trans-unit id="0ae7b878964a32c5aa151b7336192d99e50b6fa5" translate="yes" xml:space="preserve">
          <source>are valid values, which follow the ISO 8601 standard. In addition, the common format:</source>
          <target state="translated">являются действительными значениями,которые следуют стандарту ISO 8601.Кроме того,общий формат:</target>
        </trans-unit>
        <trans-unit id="699e8ae92ca31d0753b1eacb9fbc3f555d78fbd6" translate="yes" xml:space="preserve">
          <source>area</source>
          <target state="translated">area</target>
        </trans-unit>
        <trans-unit id="b572d4fbffd87db31a54fcc4b02fd6c33f9b05c2" translate="yes" xml:space="preserve">
          <source>array concatenation (right array added to the end of left one)</source>
          <target state="translated">конкатенация массивов (правый массив добавлен в конец левого)</target>
        </trans-unit>
        <trans-unit id="1f16a17f620eb69917c63399a0983d0af0fc74f5" translate="yes" xml:space="preserve">
          <source>array element selection</source>
          <target state="translated">выбор элементов массива</target>
        </trans-unit>
        <trans-unit id="195b3de97f0176b7d1d976b97a073f956d949127" translate="yes" xml:space="preserve">
          <source>array of sort expression's type</source>
          <target state="translated">тип выражения типа массива</target>
        </trans-unit>
        <trans-unit id="a9cce9638686dc89b3132c8f4d5d6e72457ed9a4" translate="yes" xml:space="preserve">
          <source>array of the argument type</source>
          <target state="translated">массив типа аргумента</target>
        </trans-unit>
        <trans-unit id="c368852a549cff62f53f0d0deed89bc97c0d743b" translate="yes" xml:space="preserve">
          <source>array-to-array concatenation</source>
          <target state="translated">конкатенация массивов</target>
        </trans-unit>
        <trans-unit id="f88f7ee63beb76da63ba7e7001aa8cd4317f04f4" translate="yes" xml:space="preserve">
          <source>array-to-element concatenation</source>
          <target state="translated">конкатенация массивов элементов</target>
        </trans-unit>
        <trans-unit id="2c4cd6638cd2c3a0b7a8372b993390a30fda1d5e" translate="yes" xml:space="preserve">
          <source>as a more complicated example. Of course, you could wrap all of this in a view for convenience.</source>
          <target state="translated">как более сложный пример.Конечно,для удобства можно все это обернуть в вид.</target>
        </trans-unit>
        <trans-unit id="c3946fc8e2b3dea5bb756fef7515425b6a069b26" translate="yes" xml:space="preserve">
          <source>as above, but the match is not noted for reporting (a &amp;ldquo;non-capturing&amp;rdquo; set of parentheses) (AREs only)</source>
          <target state="translated">как указано выше, но совпадение не отмечается для отчетов (набор скобок &amp;laquo;не захватывающий&amp;raquo;) (только для ARE)</target>
        </trans-unit>
        <trans-unit id="44737fbeead1f9bddc0c69fc725d8ac03c45707a" translate="yes" xml:space="preserve">
          <source>as an index-only scan; and this is very attractive if &lt;code&gt;f()&lt;/code&gt; is an expensive-to-compute function. However, PostgreSQL's planner is currently not very smart about such cases. It considers a query to be potentially executable by index-only scan only when all &lt;em&gt;columns&lt;/em&gt; needed by the query are available from the index. In this example, &lt;code&gt;x&lt;/code&gt; is not needed except in the context &lt;code&gt;f(x)&lt;/code&gt;, but the planner does not notice that and concludes that an index-only scan is not possible. If an index-only scan seems sufficiently worthwhile, this can be worked around by adding &lt;code&gt;x&lt;/code&gt; as an included column, for example</source>
          <target state="translated">как сканирование только индекса; и это очень привлекательно, если &lt;code&gt;f()&lt;/code&gt; - дорогостоящая функция. Однако планировщик PostgreSQL в настоящее время не очень разбирается в таких случаях. Он считает, что запрос потенциально может быть выполнен с помощью сканирования только индекса, только если все &lt;em&gt;столбцы,&lt;/em&gt; необходимые для запроса, доступны из индекса. В этом примере &lt;code&gt;x&lt;/code&gt; не требуется, кроме контекста &lt;code&gt;f(x)&lt;/code&gt; , но планировщик этого не замечает и приходит к выводу, что сканирование только по индексу невозможно. Если сканирование только индекса кажется достаточно полезным, это можно обойти, добавив &lt;code&gt;x&lt;/code&gt; в качестве включенного столбца, например</target>
        </trans-unit>
        <trans-unit id="8fcfdc695e360dde8446f7425d95888b6550157a" translate="yes" xml:space="preserve">
          <source>as if the query were</source>
          <target state="translated">как будто запрос</target>
        </trans-unit>
        <trans-unit id="a7261a75560cee1649f6ecc0f31279f94dba2bcf" translate="yes" xml:space="preserve">
          <source>assign &lt;code&gt;weight&lt;/code&gt; to each element of &lt;code&gt;vector&lt;/code&gt;</source>
          <target state="translated">присвоить &lt;code&gt;weight&lt;/code&gt; каждому элементу &lt;code&gt;vector&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f3de199d97e97e8e060913f33b95d03a4f06c7e" translate="yes" xml:space="preserve">
          <source>assign &lt;code&gt;weight&lt;/code&gt; to elements of &lt;code&gt;vector&lt;/code&gt; that are listed in &lt;code&gt;lexemes&lt;/code&gt;</source>
          <target state="translated">присвоить &lt;code&gt;weight&lt;/code&gt; элементам &lt;code&gt;vector&lt;/code&gt; , перечисленным в &lt;code&gt;lexemes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43ede3444dff3e595fe1c6f01b6c9f4950cb71df" translate="yes" xml:space="preserve">
          <source>at least 1000 (The default is often 32767; do not change unless necessary)</source>
          <target state="translated">не менее 1000 (по умолчанию часто 32767;не меняйте,если нет необходимости)</target>
        </trans-unit>
        <trans-unit id="5439e16ae06517bfbf55405bc08c2e92863bf5ea" translate="yes" xml:space="preserve">
          <source>at least 17</source>
          <target state="translated">как минимум 17</target>
        </trans-unit>
        <trans-unit id="443e099bc3b684e0db01a5fa2add4d3ea2882a4a" translate="yes" xml:space="preserve">
          <source>at least 1kB, but the default is usually much higher</source>
          <target state="translated">по крайней мере 1 кБ,но по умолчанию обычно гораздо выше.</target>
        </trans-unit>
        <trans-unit id="b54a445594f650278b14b942cc8d8778f01c797e" translate="yes" xml:space="preserve">
          <source>at least &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt; plus room for other applications</source>
          <target state="translated">как минимум &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt; плюс место для других приложений</target>
        </trans-unit>
        <trans-unit id="72b7c9e2eb3bd23a8fd3c8e377b81389e5a528cf" translate="yes" xml:space="preserve">
          <source>auth_delay</source>
          <target state="translated">auth_delay</target>
        </trans-unit>
        <trans-unit id="ad397fd87c3e39210986b3c99c01e01ebcf26995" translate="yes" xml:space="preserve">
          <source>authorization identifier membership relationships</source>
          <target state="translated">идентификатор авторизации членские отношения</target>
        </trans-unit>
        <trans-unit id="d2896d216ff2416211d2a0e36e3d0a7b13db82ff" translate="yes" xml:space="preserve">
          <source>authorization identifiers (roles)</source>
          <target state="translated">идентификаторы авторизации (роли)</target>
        </trans-unit>
        <trans-unit id="b483ffa7f9b4926c39834e971e056d9afed0e3b7" translate="yes" xml:space="preserve">
          <source>auto_explain</source>
          <target state="translated">auto_explain</target>
        </trans-unit>
        <trans-unit id="3286d9c6ac632aa037945fb31c0e37f0dd633546" translate="yes" xml:space="preserve">
          <source>autoincrementing eight-byte integer</source>
          <target state="translated">восьмибайтовое целое число с автоинкрементом</target>
        </trans-unit>
        <trans-unit id="1e4abd38ff5fb04fd9cc6e1989de0864a83533bd" translate="yes" xml:space="preserve">
          <source>autoincrementing four-byte integer</source>
          <target state="translated">автоинкрементирующее четырёхбайтовое целое число</target>
        </trans-unit>
        <trans-unit id="2162f05f39e1f496096d2494f2a79d5030c2b804" translate="yes" xml:space="preserve">
          <source>autoincrementing integer</source>
          <target state="translated">автоинкрементирующее целое число</target>
        </trans-unit>
        <trans-unit id="954cc0f6e210f639b3c9f9351202ace47d52913a" translate="yes" xml:space="preserve">
          <source>autoincrementing two-byte integer</source>
          <target state="translated">двухбайтовое целое число с автоинкрементом</target>
        </trans-unit>
        <trans-unit id="8d3a645cd2a324f0617182d92fe36ab22475ce17" translate="yes" xml:space="preserve">
          <source>available extensions</source>
          <target state="translated">доступные расширения</target>
        </trans-unit>
        <trans-unit id="0cc0f41b2e69a6e8bf4387c1a1ce9ef5e7d390b0" translate="yes" xml:space="preserve">
          <source>available versions of extensions</source>
          <target state="translated">доступные варианты расширений</target>
        </trans-unit>
        <trans-unit id="9a6de5e0d48d7fb642bda1b378500dd99c53f1dd" translate="yes" xml:space="preserve">
          <source>average of the dependent variable (&lt;code&gt;sum(Y)/N&lt;/code&gt;)</source>
          <target state="translated">среднее значение зависимой переменной ( &lt;code&gt;sum(Y)/N&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f20b015e8a66fb8ce9b0949ef84f41895f7b022b" translate="yes" xml:space="preserve">
          <source>average of the independent variable (&lt;code&gt;sum(X)/N&lt;/code&gt;)</source>
          <target state="translated">среднее значение независимой переменной ( &lt;code&gt;sum(X)/N&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3853072116a861ff4c871d3e96a9cac7da78b7d2" translate="yes" xml:space="preserve">
          <source>backslash</source>
          <target state="translated">backslash</target>
        </trans-unit>
        <trans-unit id="4930eb3f60df3a6a61e8d44178feb2b8f820a153" translate="yes" xml:space="preserve">
          <source>backspace</source>
          <target state="translated">backspace</target>
        </trans-unit>
        <trans-unit id="66cdf1600430f705cc4d8f5e11204829f8383256" translate="yes" xml:space="preserve">
          <source>backspace, as in C</source>
          <target state="translated">заднее пространство,как в C</target>
        </trans-unit>
        <trans-unit id="7f0d7679eb22f81f891057708c71dfb599a38184" translate="yes" xml:space="preserve">
          <source>base 10 logarithm</source>
          <target state="translated">базовый логарифм 10</target>
        </trans-unit>
        <trans-unit id="b749c20d2998dde8c54f69e19a74da9a0e84fc42" translate="yes" xml:space="preserve">
          <source>base frequency of this MCV item</source>
          <target state="translated">базовая частота этого предмета MCV</target>
        </trans-unit>
        <trans-unit id="8095e159699116466e36cbafd09e1d845f29f2b9" translate="yes" xml:space="preserve">
          <source>base64</source>
          <target state="translated">base64</target>
        </trans-unit>
        <trans-unit id="9965fcf7de748d3c770146162736f22b09a2ffad" translate="yes" xml:space="preserve">
          <source>because &lt;code&gt;postgres&lt;/code&gt; gets stemmed to &lt;code&gt;postgr&lt;/code&gt;:</source>
          <target state="translated">потому что &lt;code&gt;postgres&lt;/code&gt; получает стебли в &lt;code&gt;postgr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="af23afc243510d2615878774b81457104ad38f78" translate="yes" xml:space="preserve">
          <source>because a repeatable read transaction cannot modify or lock rows changed by other transactions after the repeatable read transaction began.</source>
          <target state="translated">потому что операция повторного чтения не может изменить или заблокировать строки,измененные другими транзакциями после начала операции повторного чтения.</target>
        </trans-unit>
        <trans-unit id="cbcbd26ed5be476f354422d6b658763c38b229f1" translate="yes" xml:space="preserve">
          <source>because in absence of a column list the primary key of the referenced table is used as the referenced column(s).</source>
          <target state="translated">потому что при отсутствии списка столбцов в качестве основного ключа таблицы,на которую делаются ссылки,используется основной ключ таблицы,на которую делаются ссылки.</target>
        </trans-unit>
        <trans-unit id="2d96d3c2be8f36cf4d125d8a4ee9c4468f5d1613" translate="yes" xml:space="preserve">
          <source>because it attempts to apply a collation to the result of the &lt;code&gt;&amp;gt;&lt;/code&gt; operator, which is of the non-collatable data type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">потому что он пытается применить сопоставление к результату оператора &lt;code&gt;&amp;gt;&lt;/code&gt; , который имеет &lt;code&gt;boolean&lt;/code&gt; тип данных без сопоставления .</target>
        </trans-unit>
        <trans-unit id="5d39b947f257995ccfde497491739ecd566455f0" translate="yes" xml:space="preserve">
          <source>because the parser has no idea &amp;mdash; until it is too late &amp;mdash; that &lt;code&gt;!&lt;/code&gt; is defined as a postfix operator, not an infix one. To get the desired behavior in this case, you must write:</source>
          <target state="translated">потому что синтаксический анализатор понятия не имеет - пока не станет слишком поздно - об этом &lt;code&gt;!&lt;/code&gt; определяется как постфиксный, а не инфиксный оператор. Чтобы добиться желаемого поведения в этом случае, необходимо написать:</target>
        </trans-unit>
        <trans-unit id="dc3a884c6b37262fcaf12532a1f9c235ecbf4b6d" translate="yes" xml:space="preserve">
          <source>because the server will reject the file if its permissions are more liberal than this. For more details on how to create your server private key and certificate, refer to the OpenSSL documentation.</source>
          <target state="translated">потому что сервер отклонит файл,если его разрешения более либеральны,чем это.Более подробную информацию о том,как создать приватный ключ и сертификат вашего сервера,смотрите в документации OpenSSL.</target>
        </trans-unit>
        <trans-unit id="bd03a44af506549f106aba97d42f455d1fa7455f" translate="yes" xml:space="preserve">
          <source>begins with the label &lt;code&gt;Top&lt;/code&gt;</source>
          <target state="translated">начинается с лейбла &lt;code&gt;Top&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="709634051471385aada32356842983beeff4b065" translate="yes" xml:space="preserve">
          <source>between</source>
          <target state="translated">between</target>
        </trans-unit>
        <trans-unit id="2ec6bc31b898e16ec539ddbd405a5a171a3df210" translate="yes" xml:space="preserve">
          <source>between, after sorting the comparison values</source>
          <target state="translated">между,после сортировки значений сравнения</target>
        </trans-unit>
        <trans-unit id="5f9c9d32d71f1ef8b8014c350a5f8aec50c577ec" translate="yes" xml:space="preserve">
          <source>bigint</source>
          <target state="translated">bigint</target>
        </trans-unit>
        <trans-unit id="77277e00630649e46e2738e754d21819c7bc1bf5" translate="yes" xml:space="preserve">
          <source>bigserial</source>
          <target state="translated">bigserial</target>
        </trans-unit>
        <trans-unit id="e52bf437dfb9f0dadee4cb21fac3d9c8ada93bb1" translate="yes" xml:space="preserve">
          <source>binary JSON data, decomposed</source>
          <target state="translated">бинарные JSON-данные,разложенные</target>
        </trans-unit>
        <trans-unit id="02ab455c076e6f4b354b1446757e9a4b0a79445f" translate="yes" xml:space="preserve">
          <source>binary data (&amp;ldquo;byte array&amp;rdquo;)</source>
          <target state="translated">двоичные данные (&amp;laquo;байтовый массив&amp;raquo;)</target>
        </trans-unit>
        <trans-unit id="892a67172f0a564c168e95647e62558366e70470" translate="yes" xml:space="preserve">
          <source>bit varying</source>
          <target state="translated">немного варьирующийся</target>
        </trans-unit>
        <trans-unit id="4ba5b46e332d373dfdfa248036598eb70f831d32" translate="yes" xml:space="preserve">
          <source>bitwise AND</source>
          <target state="translated">растрово И</target>
        </trans-unit>
        <trans-unit id="898900a45561d4f119a2ed52510f1ace0fda7e60" translate="yes" xml:space="preserve">
          <source>bitwise NOT</source>
          <target state="translated">битумногим НЕ</target>
        </trans-unit>
        <trans-unit id="7d5bb4d1e43ddd2b7554d5d7d0b44fa8e15c9b68" translate="yes" xml:space="preserve">
          <source>bitwise OR</source>
          <target state="translated">битумная операция ИЛИ</target>
        </trans-unit>
        <trans-unit id="8f0757e0ba4c22c9e209a79597f6b1dc188081e0" translate="yes" xml:space="preserve">
          <source>bitwise XOR</source>
          <target state="translated">битумный XOR</target>
        </trans-unit>
        <trans-unit id="e8be396aab93c1fef2fc7e54326638d41fd49ba3" translate="yes" xml:space="preserve">
          <source>bitwise shift left</source>
          <target state="translated">битовый сдвиг влево</target>
        </trans-unit>
        <trans-unit id="ee3a57994d0683b1945f1e65426a85e401e290c1" translate="yes" xml:space="preserve">
          <source>bitwise shift right</source>
          <target state="translated">битовый сдвиг вправо</target>
        </trans-unit>
        <trans-unit id="5812e2b7356193b66b6555bd2fa41ed3da124f67" translate="yes" xml:space="preserve">
          <source>bloom</source>
          <target state="translated">bloom</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="65fc5cc5f306627f2ee258292e0df90691c67af1" translate="yes" xml:space="preserve">
          <source>both date and time (no time zone)</source>
          <target state="translated">как дата,так и время (без часового пояса)</target>
        </trans-unit>
        <trans-unit id="a27279f9f262e5ba8cd291de1630ce7357a275c8" translate="yes" xml:space="preserve">
          <source>both date and time, with time zone</source>
          <target state="translated">как дата,так и время,с часовым поясом</target>
        </trans-unit>
        <trans-unit id="33ca9adbe02fe4b2c1b14995a225396cc073c647" translate="yes" xml:space="preserve">
          <source>both of which sort by the first output column. Note that an output column name has to stand alone, that is, it cannot be used in an expression &amp;mdash; for example, this is &lt;em&gt;not&lt;/em&gt; correct:</source>
          <target state="translated">оба сортируются по первому выходному столбцу. Обратите внимание , что имя выходного столбца должен стоять один, то есть, оно не может быть использовано в выражении - например, это &lt;em&gt;не&lt;/em&gt; правильно:</target>
        </trans-unit>
        <trans-unit id="8cde009a0af187221e6f6dd025a6cf362c599c99" translate="yes" xml:space="preserve">
          <source>box diagonal to line segment</source>
          <target state="translated">бокс по диагонали к отрезку прямой</target>
        </trans-unit>
        <trans-unit id="6f5d0d15c57b74089e23ebb9522965d12a29230c" translate="yes" xml:space="preserve">
          <source>box to 4-point polygon</source>
          <target state="translated">коробка до 4-х точечного полигона</target>
        </trans-unit>
        <trans-unit id="96b6dbd46e1f666fe3c50b034ebe2000e41de085" translate="yes" xml:space="preserve">
          <source>box to circle</source>
          <target state="translated">коробка к кругу</target>
        </trans-unit>
        <trans-unit id="1ca211a26e16f8cade4a85971d5852f1c33fff52" translate="yes" xml:space="preserve">
          <source>boxes to bounding box</source>
          <target state="translated">боксы к обрешётке</target>
        </trans-unit>
        <trans-unit id="7e65a745a42ef9c805310b0bccb5bfa33fa4d8e9" translate="yes" xml:space="preserve">
          <source>broadcast address for network</source>
          <target state="translated">широковещательный адрес для сети</target>
        </trans-unit>
        <trans-unit id="7e429fb710b1bd41375b836cf8242f042f2393a6" translate="yes" xml:space="preserve">
          <source>btree_gin</source>
          <target state="translated">btree_gin</target>
        </trans-unit>
        <trans-unit id="d4fc5c2b17c1dc2564aad5782a24ec87dbb33485" translate="yes" xml:space="preserve">
          <source>btree_gist</source>
          <target state="translated">btree_gist</target>
        </trans-unit>
        <trans-unit id="59d8e37e115d9900867db7d20d223db479f6ea75" translate="yes" xml:space="preserve">
          <source>build an &lt;code&gt;aclitem&lt;/code&gt; from input</source>
          <target state="translated">создать &lt;code&gt;aclitem&lt;/code&gt; из ввода</target>
        </trans-unit>
        <trans-unit id="0c70d21c53edbb94215b7aa66f5ea7d3aa0b789c" translate="yes" xml:space="preserve">
          <source>built-in logical repl., pglogical</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6310070850ba6f8f16435b6767ef6e3d84d1b51c" translate="yes" xml:space="preserve">
          <source>built-in logical replication, pglogical</source>
          <target state="translated">встроенная логическая репликация,пглогический</target>
        </trans-unit>
        <trans-unit id="0a4f60411d00d9bc19c78893536c661c6bb4cbb3" translate="yes" xml:space="preserve">
          <source>built-in streaming repl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8c9efbbdae1b8096b4be992666e1f2306047c9" translate="yes" xml:space="preserve">
          <source>built-in streaming replication</source>
          <target state="translated">встроенная потоковая репликация</target>
        </trans-unit>
        <trans-unit id="d9b843a298d5353ed2a7fe506917dc36463cf904" translate="yes" xml:space="preserve">
          <source>but not all type names can be used in this way; see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;Section 4.2.9&lt;/a&gt; for details.</source>
          <target state="translated">но не все имена типов можно использовать таким образом; подробности см. в &lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;разделе 4.2.9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f09f88b6f29fee99798bea8929b062956fb7df58" translate="yes" xml:space="preserve">
          <source>but real-world usage will involve including it in a text search configuration as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;. That might look like this:</source>
          <target state="translated">но в реальной жизни его нужно будет включить в конфигурацию текстового поиска, как описано в &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;главе 12&lt;/a&gt; . Это может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="931bb3d7295a22ba60e407c439a2751b6a2e54c6" translate="yes" xml:space="preserve">
          <source>but real-world usage will involve including it in a text search configuration as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;. That might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b8dd0ef1d9374c938682dcc12763e6b91b0511" translate="yes" xml:space="preserve">
          <source>but that approach is less flexible, and often less efficient as well.</source>
          <target state="translated">но этот подход менее гибкий и часто менее эффективный.</target>
        </trans-unit>
        <trans-unit id="777c2dee3f742dec7bfd8f0986b9928f96755335" translate="yes" xml:space="preserve">
          <source>but then the database server will see the connection as coming in on its &lt;code&gt;foo.com&lt;/code&gt; bind address, which is not opened by the default setting &lt;code&gt;listen_addresses = 'localhost'&lt;/code&gt;. This is usually not what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2c835e71e434c69308497a09a58270d6b3eddb" translate="yes" xml:space="preserve">
          <source>but then the database server will see the connection as coming in on its &lt;code&gt;foo.com&lt;/code&gt; interface, which is not opened by the default setting &lt;code&gt;listen_addresses = 'localhost'&lt;/code&gt;. This is usually not what you want.</source>
          <target state="translated">но тогда сервер базы данных увидит, что соединение поступает на его интерфейс &lt;code&gt;foo.com&lt;/code&gt; , который не открывается по умолчанию &lt;code&gt;listen_addresses = 'localhost'&lt;/code&gt; . Обычно это не то, что вам нужно.</target>
        </trans-unit>
        <trans-unit id="254eff7ff12131042b7e5d6791570b4b68f6d612" translate="yes" xml:space="preserve">
          <source>but these queries could not:</source>
          <target state="translated">но эти запросы не могли:</target>
        </trans-unit>
        <trans-unit id="f051e659481b1bdec5c2a7ae3f0ba578a9c5a900" translate="yes" xml:space="preserve">
          <source>but this does:</source>
          <target state="translated">но это так:</target>
        </trans-unit>
        <trans-unit id="0b6affe425ac3cac0ecdcc4b798bd2ce34e6c9ad" translate="yes" xml:space="preserve">
          <source>but this will not work since the aggregate &lt;code&gt;max&lt;/code&gt; cannot be used in the &lt;code&gt;WHERE&lt;/code&gt; clause. (This restriction exists because the &lt;code&gt;WHERE&lt;/code&gt; clause determines which rows will be included in the aggregate calculation; so obviously it has to be evaluated before aggregate functions are computed.) However, as is often the case the query can be restated to accomplish the desired result, here by using a &lt;em&gt;subquery&lt;/em&gt;:</source>
          <target state="translated">но это не сработает, поскольку совокупный &lt;code&gt;max&lt;/code&gt; нельзя использовать в &lt;code&gt;WHERE&lt;/code&gt; . (Это ограничение существует, потому что &lt;code&gt;WHERE&lt;/code&gt; определяет, какие строки будут включены в агрегатное вычисление; поэтому очевидно, что оно должно быть оценено до вычисления агрегатных функций.) Однако, как это часто бывает, запрос может быть переформулирован для достижения желаемого результата. , здесь с помощью &lt;em&gt;подзапроса&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="b94da3599274cc93c9ee4f4d4dce4fea875b2503" translate="yes" xml:space="preserve">
          <source>but:</source>
          <target state="translated">but:</target>
        </trans-unit>
        <trans-unit id="ca4a2057bd9e261b071397023cf198c3db0688ef" translate="yes" xml:space="preserve">
          <source>calendar date (year, month, day)</source>
          <target state="translated">дата календаря (год,месяц,день)</target>
        </trans-unit>
        <trans-unit id="3f5ae5c8becacd92f5b89cba285014d49fe90e2c" translate="yes" xml:space="preserve">
          <source>can also be used.</source>
          <target state="translated">также может быть использован.</target>
        </trans-unit>
        <trans-unit id="4a9f2d676dd4658059a5f07359111b9cc42edcba" translate="yes" xml:space="preserve">
          <source>can be increased by recompiling PostgreSQL</source>
          <target state="translated">может быть увеличена путем перекомпиляции PostgreSQL</target>
        </trans-unit>
        <trans-unit id="07b307ab5d0c778628385e3d5dbb950c4bbe7a5d" translate="yes" xml:space="preserve">
          <source>can be used too, but at present this is just for &lt;em&gt;pro forma&lt;/em&gt; compliance with the SQL standard. If you write a database name, it must be the same as the database you are connected to.</source>
          <target state="translated">также можно использовать, но в настоящее время это только для &lt;em&gt;формального&lt;/em&gt; соответствия стандарту SQL. Если вы пишете имя базы данных, оно должно совпадать с именем базы данных, к которой вы подключены.</target>
        </trans-unit>
        <trans-unit id="45514644f4621795d582e24c02cb7cf058d26351" translate="yes" xml:space="preserve">
          <source>can equivalently be written as:</source>
          <target state="translated">может быть эквивалентно написано как:</target>
        </trans-unit>
        <trans-unit id="6e9f192b79a14968d26f70ab1aa8e21b65e3df64" translate="yes" xml:space="preserve">
          <source>carriage return</source>
          <target state="translated">возврат каретки</target>
        </trans-unit>
        <trans-unit id="def334c5877ea4f63b5575fa4cc2f60305278d07" translate="yes" xml:space="preserve">
          <source>carriage return, as in C</source>
          <target state="translated">возврат каретки,как в C</target>
        </trans-unit>
        <trans-unit id="f99b34b4fa1fea2ca07ad8897d13ba6b1206cc37" translate="yes" xml:space="preserve">
          <source>case-insensitive matching (see &lt;a href=&quot;functions-matching#POSIX-MATCHING-RULES&quot;&gt;Section 9.7.3.5&lt;/a&gt;) (overrides operator type)</source>
          <target state="translated">сопоставление без &lt;a href=&quot;functions-matching#POSIX-MATCHING-RULES&quot;&gt;учета&lt;/a&gt; регистра (см. Раздел 9.7.3.5 ) (переопределяет тип оператора)</target>
        </trans-unit>
        <trans-unit id="3e82d968dc00f833dad374e757a334e4a040c90c" translate="yes" xml:space="preserve">
          <source>case-sensitive matching (overrides operator type)</source>
          <target state="translated">согласование с регистром (переопределяет тип оператора)</target>
        </trans-unit>
        <trans-unit id="5bf41021d1e013cdbe5336b032060b46fb810232" translate="yes" xml:space="preserve">
          <source>cast &lt;code&gt;ltree&lt;/code&gt; to &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">литая &lt;code&gt;ltree&lt;/code&gt; к &lt;code&gt;text&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed1123013c2bd604bb0d461547480f74dc473e37" translate="yes" xml:space="preserve">
          <source>cast &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;ltree&lt;/code&gt;</source>
          <target state="translated">отбрасывать &lt;code&gt;text&lt;/code&gt; в &lt;code&gt;ltree&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a283f70188863d91855937695daa6c350cfcf558" translate="yes" xml:space="preserve">
          <source>cast to double</source>
          <target state="translated">литьё в двойном размере</target>
        </trans-unit>
        <trans-unit id="34472e7f0cad05f2b2dd139e2a7581cfa2e2f29a" translate="yes" xml:space="preserve">
          <source>cast to int</source>
          <target state="translated">бросать на произвол судьбы</target>
        </trans-unit>
        <trans-unit id="542ab67ef49ce56f684a8718e87598af02f5d74b" translate="yes" xml:space="preserve">
          <source>casts (data type conversions)</source>
          <target state="translated">слепки (преобразование типов данных)</target>
        </trans-unit>
        <trans-unit id="305047e96ec089021660ee5965f893ac80268731" translate="yes" xml:space="preserve">
          <source>center</source>
          <target state="translated">center</target>
        </trans-unit>
        <trans-unit id="1c324c54487e53c22fd01ca907a0c848c8a583d9" translate="yes" xml:space="preserve">
          <source>center and radius to circle</source>
          <target state="translated">центр и радиус до окружности</target>
        </trans-unit>
        <trans-unit id="81a86dca1152d33417863c0f5f4e6cf2b16480a6" translate="yes" xml:space="preserve">
          <source>center of box</source>
          <target state="translated">центр коробки</target>
        </trans-unit>
        <trans-unit id="2ec0ff924735c49e81d70e8e2c7d6dfe9d7d60bc" translate="yes" xml:space="preserve">
          <source>center of circle</source>
          <target state="translated">центр окружности</target>
        </trans-unit>
        <trans-unit id="525b6f618cb47140c2374dbe02a53765c3c85c24" translate="yes" xml:space="preserve">
          <source>center of line segment</source>
          <target state="translated">центр отрезка прямой</target>
        </trans-unit>
        <trans-unit id="33d628e71b8e6a1a2c384ae970e47570fc0b9a61" translate="yes" xml:space="preserve">
          <source>center of polygon</source>
          <target state="translated">центр многоугольника</target>
        </trans-unit>
        <trans-unit id="21957663c4fb58419a0c98a3724294cbfdbf1a7f" translate="yes" xml:space="preserve">
          <source>century (2 digits) (the twenty-first century starts on 2001-01-01)</source>
          <target state="translated">век (2 цифры)(XXI век начинается с 2001-01-01 гг.)</target>
        </trans-unit>
        <trans-unit id="370ecf2ad70a13142bf3174e9abe256169452bd0" translate="yes" xml:space="preserve">
          <source>certificates revoked by certificate authorities</source>
          <target state="translated">сертификаты,аннулированные центрами сертификации</target>
        </trans-unit>
        <trans-unit id="932784433f85ba8abc6f12c517aaf96068258f16" translate="yes" xml:space="preserve">
          <source>channel names that the session is currently listening on</source>
          <target state="translated">названия каналов,которые сейчас прослушивает сессия</target>
        </trans-unit>
        <trans-unit id="f0db3fa401aea04b711d6f1f3630552eaaee8e59" translate="yes" xml:space="preserve">
          <source>character</source>
          <target state="translated">character</target>
        </trans-unit>
        <trans-unit id="d0eb7b3b4e386ffe76f12fc6f7502ffde2a5b1ca" translate="yes" xml:space="preserve">
          <source>character varying</source>
          <target state="translated">изменение характера</target>
        </trans-unit>
        <trans-unit id="eea64a15c7c41d6cf7da5318bba35b0dfa86b13f" translate="yes" xml:space="preserve">
          <source>check clusters only, don't change any data</source>
          <target state="translated">проверять только кластеры,не изменять никаких данных.</target>
        </trans-unit>
        <trans-unit id="a29a96de4ab639d87155b423113f741d6b399fca" translate="yes" xml:space="preserve">
          <source>check constraints, unique constraints, primary key constraints, foreign key constraints</source>
          <target state="translated">проверка ограничений,уникальные ограничения,первичные ключевые ограничения,иностранные ключевые ограничения</target>
        </trans-unit>
        <trans-unit id="4b91f9d8b975eee622772ea62a86896ef4ef61ce" translate="yes" xml:space="preserve">
          <source>checks that client certificate is signed by a trusted certificate authority</source>
          <target state="translated">проверяет,что клиентский сертификат подписан доверенным центром сертификации.</target>
        </trans-unit>
        <trans-unit id="00b7b8118efde44c546b69243ec15b21cd64c9d9" translate="yes" xml:space="preserve">
          <source>circle</source>
          <target state="translated">circle</target>
        </trans-unit>
        <trans-unit id="bfac9bc25b5fb8f2fa83ccb26e83e30c35a3a06c" translate="yes" xml:space="preserve">
          <source>circle on a plane</source>
          <target state="translated">вращаться в плоскости</target>
        </trans-unit>
        <trans-unit id="fe2bd0ef7b1249d0169c74005f37ca2fd5a93734" translate="yes" xml:space="preserve">
          <source>circle to 12-point polygon</source>
          <target state="translated">окружность до 12-ти балльного полигона</target>
        </trans-unit>
        <trans-unit id="ddf50c7158a693b8ba86924c5d88bec2f50e83aa" translate="yes" xml:space="preserve">
          <source>circle to &lt;code&gt;npts&lt;/code&gt;-point polygon</source>
          <target state="translated">круг в многоугольник &lt;code&gt;npts&lt;/code&gt; -point</target>
        </trans-unit>
        <trans-unit id="ad3b153d9429c109e68ce6ced77c4260d4c34577" translate="yes" xml:space="preserve">
          <source>circle to box</source>
          <target state="translated">круг к кругу</target>
        </trans-unit>
        <trans-unit id="e241ce9d9ce43d18211ad61727ab59139118a131" translate="yes" xml:space="preserve">
          <source>citext</source>
          <target state="translated">citext</target>
        </trans-unit>
        <trans-unit id="751266a7fa555fd650fe60f7bd15324008f60eaf" translate="yes" xml:space="preserve">
          <source>client certificate must not be on this list</source>
          <target state="translated">сертификат клиента не должен быть в этом списке</target>
        </trans-unit>
        <trans-unit id="12c22af93332ba93d2c7d1b12c8c3a6239448f8b" translate="yes" xml:space="preserve">
          <source>client character set representation</source>
          <target state="translated">представление набора символов клиента</target>
        </trans-unit>
        <trans-unit id="fe3b3f96eb8a29aa95ee6742e5391daa5a853668" translate="yes" xml:space="preserve">
          <source>closed geometric path on a plane</source>
          <target state="translated">замкнутая геометрическая траектория на плоскости</target>
        </trans-unit>
        <trans-unit id="9d2a05384389e39e55a9fb33419864a52dc20579" translate="yes" xml:space="preserve">
          <source>cluster's install user name; environment variable &lt;code&gt;PGUSER&lt;/code&gt;</source>
          <target state="translated">имя пользователя установки кластера; переменная окружения &lt;code&gt;PGUSER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39f2375a466659e991122be876571fa32e1c3224" translate="yes" xml:space="preserve">
          <source>clusterdb</source>
          <target state="translated">clusterdb</target>
        </trans-unit>
        <trans-unit id="823fd4756652ecc890aa45a56776dffb0e59f612" translate="yes" xml:space="preserve">
          <source>clusterdb &amp;mdash; cluster a PostgreSQL database</source>
          <target state="translated">clusterdb - кластеризовать базу данных PostgreSQL</target>
        </trans-unit>
        <trans-unit id="d5bb141c39226c781b730bc7a91ab0f06285e4f0" translate="yes" xml:space="preserve">
          <source>clusterdb accepts the following command-line arguments:</source>
          <target state="translated">clusterdb принимает следующие аргументы командной строки:</target>
        </trans-unit>
        <trans-unit id="cf3ac3c5cfb26bd0e1f0c4ae38487d9d7c314d08" translate="yes" xml:space="preserve">
          <source>clusterdb also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">clusterdb также принимает следующие аргументы командной строки для параметров соединения:</target>
        </trans-unit>
        <trans-unit id="e2fe317f2e4ea451e21fc774dc0d79619e64edfd" translate="yes" xml:space="preserve">
          <source>clusterdb is a utility for reclustering tables in a PostgreSQL database. It finds tables that have previously been clustered, and clusters them again on the same index that was last used. Tables that have never been clustered are not affected.</source>
          <target state="translated">clusterdb-это утилита для рекультивации таблиц в базе данных PostgreSQL.Она находит таблицы,которые ранее были сгруппированы,и снова кластеризует их по тому же индексу,который использовался в последний раз.Таблицы,которые никогда не были кластеризованы,не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="fd2735ad5e6a19ac7e1140a224c1c24a97fc9e17" translate="yes" xml:space="preserve">
          <source>clusterdb is a wrapper around the SQL command &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;. There is no effective difference between clustering databases via this utility and via other methods for accessing the server.</source>
          <target state="translated">clusterdb - это оболочка для SQL-команды &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; . Эффективной разницы между кластеризацией баз данных с помощью этой утилиты и других методов доступа к серверу нет.</target>
        </trans-unit>
        <trans-unit id="1f1784fa738e6d5473ab5f43d736a5f44fb259b0" translate="yes" xml:space="preserve">
          <source>collation name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea494244f54b23f44820cb069f810bb4eca7c7b" translate="yes" xml:space="preserve">
          <source>collations (locale information)</source>
          <target state="translated">закуски (местная информация)</target>
        </trans-unit>
        <trans-unit id="f6e81a8e1f0b533eb70f9ceeb98b3f99d57e7764" translate="yes" xml:space="preserve">
          <source>column default values</source>
          <target state="translated">значения столбцов по умолчанию</target>
        </trans-unit>
        <trans-unit id="fe7f2cdd0d102e4f8a30abbef55f21da4b2ba7d9" translate="yes" xml:space="preserve">
          <source>columns per index</source>
          <target state="translated">столбцы на индекс</target>
        </trans-unit>
        <trans-unit id="ff07f44a4127edb55f44386b09eae02d54daca39" translate="yes" xml:space="preserve">
          <source>columns per table</source>
          <target state="translated">столбцы на стол</target>
        </trans-unit>
        <trans-unit id="f34c9877f2bf68c0333fc87b9e95a52bc11e5b67" translate="yes" xml:space="preserve">
          <source>comments on shared objects</source>
          <target state="translated">комментарии к разделяемым объектам</target>
        </trans-unit>
        <trans-unit id="7b66eba0b67c3b9e73cc97b3d1b94a251d742d90" translate="yes" xml:space="preserve">
          <source>comparison operators</source>
          <target state="translated">операторы сравнения</target>
        </trans-unit>
        <trans-unit id="8154454006381d49284649c66b2403f81afb118d" translate="yes" xml:space="preserve">
          <source>compile-time configuration parameters</source>
          <target state="translated">параметры конфигурации на этапе компиляции</target>
        </trans-unit>
        <trans-unit id="55a34178d77f1c51b211c756f759f8cf161a23d4" translate="yes" xml:space="preserve">
          <source>concatenate &lt;code&gt;hstore&lt;/code&gt;s</source>
          <target state="translated">конкатенация &lt;code&gt;hstore&lt;/code&gt; s</target>
        </trans-unit>
        <trans-unit id="8e1ad14ad4374d48d20d7479ab315932269fbff4" translate="yes" xml:space="preserve">
          <source>concatenate &lt;code&gt;ltree&lt;/code&gt; paths</source>
          <target state="translated">Соединить &lt;code&gt;ltree&lt;/code&gt; пути</target>
        </trans-unit>
        <trans-unit id="29b58ef42868498f9fead6297c0c68588c926edf" translate="yes" xml:space="preserve">
          <source>concatenate &lt;code&gt;tsvector&lt;/code&gt;s</source>
          <target state="translated">конкатенация &lt;code&gt;tsvector&lt;/code&gt; s</target>
        </trans-unit>
        <trans-unit id="2c4447d1d44ee3c074941b8c08ca342d23d066f6" translate="yes" xml:space="preserve">
          <source>concatenate two arrays</source>
          <target state="translated">конкатенатные два массива</target>
        </trans-unit>
        <trans-unit id="22d0551615cf0d8546cc1c9c81d271b5e72e2fda" translate="yes" xml:space="preserve">
          <source>concatenates array elements using supplied delimiter and optional null string</source>
          <target state="translated">конкатенует элементы массива,используя поставляемый разделитель и необязательную нулевую строку</target>
        </trans-unit>
        <trans-unit id="5c93b563298b75fc6d2f4fcfedc5ca6dd370b747" translate="yes" xml:space="preserve">
          <source>concatenation</source>
          <target state="translated">concatenation</target>
        </trans-unit>
        <trans-unit id="5fff9a64a91f5155fd20f1f5322675919eba1779" translate="yes" xml:space="preserve">
          <source>concatenation of non-null XML values (see also &lt;a href=&quot;functions-xml#FUNCTIONS-XML-XMLAGG&quot;&gt;Section 9.14.1.7&lt;/a&gt;)</source>
          <target state="translated">конкатенация ненулевых значений XML (см. также &lt;a href=&quot;functions-xml#FUNCTIONS-XML-XMLAGG&quot;&gt;Раздел 9.14.1.7&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="cab21417f26804f2821e9cba7ec02b3d22bb0dcb" translate="yes" xml:space="preserve">
          <source>condition that has a format similar to the format of regular expressions.</source>
          <target state="translated">условие,которое имеет формат,аналогичный формату регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="bdd9e092f915a4d94a6a2f20a48a3e86b741db40" translate="yes" xml:space="preserve">
          <source>configuration load time</source>
          <target state="translated">время загрузки конфигурации</target>
        </trans-unit>
        <trans-unit id="d1fa507954b44038b5d98dbdafb2b36374cc6386" translate="yes" xml:space="preserve">
          <source>constrained by maximum relations per database</source>
          <target state="translated">ограниченное максимальным соотношением для каждой базы данных</target>
        </trans-unit>
        <trans-unit id="242491a8bd7940610b5e65d571dcdb5c72e647a2" translate="yes" xml:space="preserve">
          <source>construct an &lt;code&gt;hstore&lt;/code&gt; from a record or row</source>
          <target state="translated">построить &lt;code&gt;hstore&lt;/code&gt; из записи или строки</target>
        </trans-unit>
        <trans-unit id="c929167cb94b880f0746653e53959fc18c0bf793" translate="yes" xml:space="preserve">
          <source>construct an &lt;code&gt;hstore&lt;/code&gt; from an array, which may be either a key/value array, or a two-dimensional array</source>
          <target state="translated">создать &lt;code&gt;hstore&lt;/code&gt; из массива, который может быть либо массивом ключ / значение, либо двумерным массивом</target>
        </trans-unit>
        <trans-unit id="bbd40f04098912d0ba742a8bc5af223e27c7adda" translate="yes" xml:space="preserve">
          <source>construct an &lt;code&gt;hstore&lt;/code&gt; from separate key and value arrays</source>
          <target state="translated">создать &lt;code&gt;hstore&lt;/code&gt; из отдельных массивов ключей и значений</target>
        </trans-unit>
        <trans-unit id="3cc74499a516b13f15e51d5c826818942c36a609" translate="yes" xml:space="preserve">
          <source>construct host mask for network</source>
          <target state="translated">построить маску хоста для сети</target>
        </trans-unit>
        <trans-unit id="b01b9cfc44c043d7e34a6cc2f5c24aa8c879193c" translate="yes" xml:space="preserve">
          <source>construct netmask for network</source>
          <target state="translated">построить сетевую маску для сети</target>
        </trans-unit>
        <trans-unit id="14dd4fbbe8eed4db88e77a3d9dee637dfc2d10c4" translate="yes" xml:space="preserve">
          <source>construct point</source>
          <target state="translated">точка конструирования</target>
        </trans-unit>
        <trans-unit id="b75f26d172a89e83c2261d72cb9d9e1b5ef7769c" translate="yes" xml:space="preserve">
          <source>contained &amp;mdash; &lt;code&gt;true&lt;/code&gt; if left array is contained in right array</source>
          <target state="translated">Содержится - &lt;code&gt;true&lt;/code&gt; если левый массив содержится в правом массиве</target>
        </trans-unit>
        <trans-unit id="caeb909ae4ff4ee25a0ff0d476946ed256f2aee1" translate="yes" xml:space="preserve">
          <source>contains</source>
          <target state="translated">contains</target>
        </trans-unit>
        <trans-unit id="0957a97cac9a10ebe40f435c740cc3345b2efc3f" translate="yes" xml:space="preserve">
          <source>contains &amp;mdash; &lt;code&gt;true&lt;/code&gt; if left array contains right array</source>
          <target state="translated">contains - &lt;code&gt;true&lt;/code&gt; если левый массив содержит правый массив</target>
        </trans-unit>
        <trans-unit id="007f7efed9b7619cf2555d2be05833ff839d3962" translate="yes" xml:space="preserve">
          <source>contains element</source>
          <target state="translated">содержащий элемент</target>
        </trans-unit>
        <trans-unit id="e74dd6ca81a7e2eecc18f2ec9e65ec0ea5be7ef4" translate="yes" xml:space="preserve">
          <source>contains or equals</source>
          <target state="translated">содержит или равняется</target>
        </trans-unit>
        <trans-unit id="ce904d2429dea4c4cd6a0c965103aaf0e346da09" translate="yes" xml:space="preserve">
          <source>contains or is contained by</source>
          <target state="translated">содержит или содержится в</target>
        </trans-unit>
        <trans-unit id="e75b7119f1d5d414ff82917ba2603bf9e5b45df6" translate="yes" xml:space="preserve">
          <source>contains range</source>
          <target state="translated">диапазон</target>
        </trans-unit>
        <trans-unit id="19f826ba869b2fee68bf1f114b8e677ae0c0d856" translate="yes" xml:space="preserve">
          <source>continuous percentile: returns a value corresponding to the specified fraction in the ordering, interpolating between adjacent input items if needed</source>
          <target state="translated">непрерывный процентиль:возвращает значение,соответствующее заданной доле в заказе,при необходимости интерполируя между соседними входными позициями</target>
        </trans-unit>
        <trans-unit id="36c18c788db3f3304d051679f1b40f05f59e4471" translate="yes" xml:space="preserve">
          <source>convert &lt;code&gt;hstore&lt;/code&gt; to array of alternating keys and values</source>
          <target state="translated">преобразовать &lt;code&gt;hstore&lt;/code&gt; в массив чередующихся ключей и значений</target>
        </trans-unit>
        <trans-unit id="a10418c81af1657f4831a46624d04836bc50be5c" translate="yes" xml:space="preserve">
          <source>convert &lt;code&gt;hstore&lt;/code&gt; to two-dimensional key/value array</source>
          <target state="translated">преобразовать &lt;code&gt;hstore&lt;/code&gt; в двумерный массив ключей / значений</target>
        </trans-unit>
        <trans-unit id="602cf0e08612bf183b6a1d481640a135b45b733b" translate="yes" xml:space="preserve">
          <source>convert &lt;code&gt;tsvector&lt;/code&gt; to array of lexemes</source>
          <target state="translated">преобразовать &lt;code&gt;tsvector&lt;/code&gt; в массив лексем</target>
        </trans-unit>
        <trans-unit id="6d582c6dfa728d8842a0e41ff985c05950fcac9e" translate="yes" xml:space="preserve">
          <source>convert array of lexemes to &lt;code&gt;tsvector&lt;/code&gt;</source>
          <target state="translated">преобразовать массив лексем в &lt;code&gt;tsvector&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="042e1227ee9efe77eb7cf25e971dd091316797bb" translate="yes" xml:space="preserve">
          <source>convert integer to string</source>
          <target state="translated">преобразовывать целое число в строку</target>
        </trans-unit>
        <trans-unit id="8883e03ee79e5b7ca0bcc6c68d4b71517843c875" translate="yes" xml:space="preserve">
          <source>convert interval to string</source>
          <target state="translated">преобразовывать интервал в строку</target>
        </trans-unit>
        <trans-unit id="2c348d29e84f0505a741faf5cd29979ee0784eb6" translate="yes" xml:space="preserve">
          <source>convert numeric to string</source>
          <target state="translated">преобразовывать числа в строки</target>
        </trans-unit>
        <trans-unit id="e58b5696e1ecb535182f8da0e55ea16d3ba9714b" translate="yes" xml:space="preserve">
          <source>convert path to closed</source>
          <target state="translated">преобразовать путь в замкнутый</target>
        </trans-unit>
        <trans-unit id="e8c6b63ef451acece45e4a2472ed3246d96680fa" translate="yes" xml:space="preserve">
          <source>convert path to open</source>
          <target state="translated">преобразовать путь к открытию</target>
        </trans-unit>
        <trans-unit id="b4e06a2b81ef98774ce30290d2c91fbe2ee0a163" translate="yes" xml:space="preserve">
          <source>convert real/double precision to string</source>
          <target state="translated">преобразование реальной/двойной точности в строку</target>
        </trans-unit>
        <trans-unit id="16630f62d1ae61b7816445e29898565307e22a6f" translate="yes" xml:space="preserve">
          <source>convert string to date</source>
          <target state="translated">строка преобразования в дату</target>
        </trans-unit>
        <trans-unit id="77457ad94d28223c821b4d450456f45b1fe1f3c5" translate="yes" xml:space="preserve">
          <source>convert string to numeric</source>
          <target state="translated">преобразовывать строку в числовой</target>
        </trans-unit>
        <trans-unit id="d592ee6202ef0abdfa519a7ee4c6978379812ba5" translate="yes" xml:space="preserve">
          <source>convert string to time stamp</source>
          <target state="translated">преобразовывать строку в метку времени</target>
        </trans-unit>
        <trans-unit id="7554307f0c7cf7f9b6e803a9465e3e2cd2090bfa" translate="yes" xml:space="preserve">
          <source>convert text to &lt;code&gt;ltree&lt;/code&gt; and concatenate</source>
          <target state="translated">преобразовать текст в &lt;code&gt;ltree&lt;/code&gt; и объединить</target>
        </trans-unit>
        <trans-unit id="176526ef5504731e3313035b22ba3c0b5c8f498b" translate="yes" xml:space="preserve">
          <source>convert time stamp to string</source>
          <target state="translated">преобразовывать метку времени в строку</target>
        </trans-unit>
        <trans-unit id="a3d85881749badcc411aff88ce02fb6973926ade" translate="yes" xml:space="preserve">
          <source>converts the integer constant 42 to type &lt;code&gt;float8&lt;/code&gt; by invoking a previously specified function, in this case &lt;code&gt;float8(int4)&lt;/code&gt;. (If no suitable cast has been defined, the conversion fails.)</source>
          <target state="translated">преобразует целочисленную константу 42 в тип &lt;code&gt;float8&lt;/code&gt; , вызывая ранее заданную функцию, в данном случае &lt;code&gt;float8(int4)&lt;/code&gt; . (Если подходящее приведение не было определено, преобразование не выполняется.)</target>
        </trans-unit>
        <trans-unit id="9156629cfbed20d63d58fec30d0c098f0e19d25d" translate="yes" xml:space="preserve">
          <source>copy files to the &lt;code&gt;$SHAREDIR/tsearch_data&lt;/code&gt; directory</source>
          <target state="translated">копировать файлы в &lt;code&gt;$SHAREDIR/tsearch_data&lt;/code&gt; каталог</target>
        </trans-unit>
        <trans-unit id="6f5d0356cf2bf7c83124fef63669f30215a05eee" translate="yes" xml:space="preserve">
          <source>correlation coefficient</source>
          <target state="translated">коэффициент корреляции</target>
        </trans-unit>
        <trans-unit id="76b5d4c037174657db2ef3d6849098ed26c598c7" translate="yes" xml:space="preserve">
          <source>cosine</source>
          <target state="translated">cosine</target>
        </trans-unit>
        <trans-unit id="92c39d6b13445a5705c2f7b251a21f0fb971660d" translate="yes" xml:space="preserve">
          <source>cotangent</source>
          <target state="translated">cotangent</target>
        </trans-unit>
        <trans-unit id="e3b7cc2c1242a390854b610b0efc253303b2b6fd" translate="yes" xml:space="preserve">
          <source>could be used as input to pg_restore and would only restore items 10 and 6, in that order:</source>
          <target state="translated">может использоваться в качестве входа в pg_restore и будет восстанавливать только пункты 10 и 6,в этом порядке:</target>
        </trans-unit>
        <trans-unit id="fa3275b435c87e20aa8f38ceb77beb1839950e18" translate="yes" xml:space="preserve">
          <source>could handle these queries as index-only scans, because &lt;code&gt;y&lt;/code&gt; can be obtained from the index without visiting the heap.</source>
          <target state="translated">может обрабатывать эти запросы как сканирование только индекса, потому что &lt;code&gt;y&lt;/code&gt; можно получить из индекса без посещения кучи.</target>
        </trans-unit>
        <trans-unit id="6d4415f60a15671f449844424b8af6b0eb46e52d" translate="yes" xml:space="preserve">
          <source>could use the index, because the comparison will by default use the collation of the column. However, this index cannot accelerate queries that involve some other collation. So if queries of the form, say,</source>
          <target state="translated">может использовать индекс,так как по умолчанию при сравнении будет использоваться сверка столбца.Однако этот индекс не может ускорить запросы,которые связаны с каким-либо другим сопоставлением.Так что если запросы формы,скажем,</target>
        </trans-unit>
        <trans-unit id="0bac556c5d3bb14c1fede879eb302b107d254487" translate="yes" xml:space="preserve">
          <source>createdb</source>
          <target state="translated">createdb</target>
        </trans-unit>
        <trans-unit id="6b407470937a987ede5e1a0f6201cc8aa6dfebd1" translate="yes" xml:space="preserve">
          <source>createdb &amp;mdash; create a new PostgreSQL database</source>
          <target state="translated">createdb - создать новую базу данных PostgreSQL</target>
        </trans-unit>
        <trans-unit id="ddafc0b5a0df99cf7efa3a37dabf9dc9fc318b1d" translate="yes" xml:space="preserve">
          <source>createdb accepts the following command-line arguments:</source>
          <target state="translated">createb принимает следующие аргументы командной строки:</target>
        </trans-unit>
        <trans-unit id="bbf7672a9395c4080a0583f706be79ec1c196ff7" translate="yes" xml:space="preserve">
          <source>createdb also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">createb также принимает следующие аргументы командной строки для параметров соединения:</target>
        </trans-unit>
        <trans-unit id="9470bae91f4b1b94fa4d30d94087484824b0dc48" translate="yes" xml:space="preserve">
          <source>createdb creates a new PostgreSQL database.</source>
          <target state="translated">createb создает новую базу данных PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="048a808c9479ad0cf4813cdc85239ab9acdb44e2" translate="yes" xml:space="preserve">
          <source>createdb is a wrapper around the SQL command &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;. There is no effective difference between creating databases via this utility and via other methods for accessing the server.</source>
          <target state="translated">createdb - это оболочка для команды SQL &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; . Эффективной разницы между созданием баз данных с помощью этой утилиты и других методов доступа к серверу нет.</target>
        </trans-unit>
        <trans-unit id="df58b9eb4912cb4f51a557c31f280002a97c1cba" translate="yes" xml:space="preserve">
          <source>createuser</source>
          <target state="translated">createuser</target>
        </trans-unit>
        <trans-unit id="b3fcd1b75b88d9bb09cc16243ed746793c22b9e2" translate="yes" xml:space="preserve">
          <source>createuser &amp;mdash; define a new PostgreSQL user account</source>
          <target state="translated">createuser - определить новую учетную запись пользователя PostgreSQL</target>
        </trans-unit>
        <trans-unit id="d10ac2835716c1122f4b67809fce50fe94a29e90" translate="yes" xml:space="preserve">
          <source>createuser accepts the following command-line arguments:</source>
          <target state="translated">создатель принимает следующие аргументы командной строки:</target>
        </trans-unit>
        <trans-unit id="6a28423b7c898a6be61a407aeecb01d59a5820bb" translate="yes" xml:space="preserve">
          <source>createuser also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">Создатель также принимает следующие аргументы командной строки для параметров соединения:</target>
        </trans-unit>
        <trans-unit id="d2a84b3f8857986e6dd89f160acf7f9e638227ea" translate="yes" xml:space="preserve">
          <source>createuser creates a new PostgreSQL user (or more precisely, a role). Only superusers and users with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can create new users, so createuser must be invoked by someone who can connect as a superuser or a user with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege.</source>
          <target state="translated">createuser создает нового пользователя PostgreSQL (точнее, роль). Только суперпользователи и пользователи с привилегией &lt;code&gt;CREATEROLE&lt;/code&gt; могут создавать новых пользователей, поэтому createuser должен вызываться кем-то, кто может подключиться как суперпользователь или пользователь с привилегией &lt;code&gt;CREATEROLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e447ff571994f9f3e3ba25c8d7ecf9fb22fbb73" translate="yes" xml:space="preserve">
          <source>createuser is a wrapper around the SQL command &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. There is no effective difference between creating users via this utility and via other methods for accessing the server.</source>
          <target state="translated">createuser - это оболочка для SQL-команды &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; . Эффективной разницы между созданием пользователей с помощью этой утилиты и других методов доступа к серверу нет.</target>
        </trans-unit>
        <trans-unit id="55f7d1f71091501a0205fba94258266031264150" translate="yes" xml:space="preserve">
          <source>cube</source>
          <target state="translated">cube</target>
        </trans-unit>
        <trans-unit id="a7b0a72c320ec18ab3059928fd9784a02afb8268" translate="yes" xml:space="preserve">
          <source>cube root</source>
          <target state="translated">корень кубика</target>
        </trans-unit>
        <trans-unit id="12f7353964de624d3d4543c138e1761bcfdc57f8" translate="yes" xml:space="preserve">
          <source>cumulative distribution: (number of partition rows preceding or peer with current row) / total partition rows</source>
          <target state="translated">кумулятивное распределение:(количество рядов простенков,предшествующих или равных текущей строке)/общие ряды простенков</target>
        </trans-unit>
        <trans-unit id="64607b5d8e4412896465575375d94f0725abe039" translate="yes" xml:space="preserve">
          <source>currency amount</source>
          <target state="translated">сумма валюты</target>
        </trans-unit>
        <trans-unit id="b81619f92b172ce2f6fa0a84df042cb5fd37a50f" translate="yes" xml:space="preserve">
          <source>currency symbol (uses locale)</source>
          <target state="translated">валютный символ (используется локаль)</target>
        </trans-unit>
        <trans-unit id="4f4406b4ea462b2d1ce31fff99c629ac6a9ecade" translate="yes" xml:space="preserve">
          <source>current TID of this or newer row version</source>
          <target state="translated">текущий TID этой или более новой версии ряда</target>
        </trans-unit>
        <trans-unit id="ccae96815d506bcc8eb6b9e7ef48a9c48d733f5f" translate="yes" xml:space="preserve">
          <source>current nesting level of PostgreSQL triggers (0 if not called, directly or indirectly, from inside a trigger)</source>
          <target state="translated">текущий уровень вложенности триггеров PostgreSQL (0,если не вызывается,прямо или косвенно,изнутри триггера)</target>
        </trans-unit>
        <trans-unit id="779b51a546eca5f4d60da79d0ec7ada57a18e13f" translate="yes" xml:space="preserve">
          <source>current scale factor</source>
          <target state="translated">коэффициент масштабирования</target>
        </trans-unit>
        <trans-unit id="056ca10ef8889b41faa742d26656a471608732e4" translate="yes" xml:space="preserve">
          <source>current transaction's start time</source>
          <target state="translated">время начала текущей операции</target>
        </trans-unit>
        <trans-unit id="3ccfd1fb04d76ca6fa36faf318d4bbbe6e019e62" translate="yes" xml:space="preserve">
          <source>current user is a superuser</source>
          <target state="translated">текущий пользователь является суперпользователем</target>
        </trans-unit>
        <trans-unit id="e76746f9f64ea77f86d57b4affc2e26c70e97db1" translate="yes" xml:space="preserve">
          <source>current user is the server owner and mapping is for &lt;code&gt;PUBLIC&lt;/code&gt;</source>
          <target state="translated">текущий пользователь является владельцем сервера, а отображение предназначено для &lt;code&gt;PUBLIC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56acd550331e29f863c4189d4f0d3e7d6050a758" translate="yes" xml:space="preserve">
          <source>current user is the user being mapped, and owns the server or holds &lt;code&gt;USAGE&lt;/code&gt; privilege on it</source>
          <target state="translated">текущий пользователь - это отображаемый пользователь, который владеет сервером или имеет на нем право &lt;code&gt;USAGE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="251e17f62ca5a0bad33a4794560b84bff241ddd2" translate="yes" xml:space="preserve">
          <source>dartmouth.edu/~sting/sw/imath</source>
          <target state="translated">dartmouth.edu/~sting/sw/imath</target>
        </trans-unit>
        <trans-unit id="248361612d1d3c64585c3817d26796e95c11dece" translate="yes" xml:space="preserve">
          <source>data pages for large objects</source>
          <target state="translated">страницы данных для крупных объектов</target>
        </trans-unit>
        <trans-unit id="c429160164cb02d0618b1e822bdab4bf43fbb586" translate="yes" xml:space="preserve">
          <source>data type name</source>
          <target state="translated">имя типа данных</target>
        </trans-unit>
        <trans-unit id="1bd41877f2856c4d7b5bc551b1c51509f9f61a5b" translate="yes" xml:space="preserve">
          <source>data types</source>
          <target state="translated">виды данных</target>
        </trans-unit>
        <trans-unit id="9dbbcafe5430392decd61d26126df6cde3ef6b46" translate="yes" xml:space="preserve">
          <source>database creation</source>
          <target state="translated">разработка базы данных</target>
        </trans-unit>
        <trans-unit id="564babd5efa4c177e7fbceca3d3d19ecd02f9665" translate="yes" xml:space="preserve">
          <source>database roles</source>
          <target state="translated">роли в базе данных</target>
        </trans-unit>
        <trans-unit id="4167ac168b132ec514ae402ff3cd6a698a1a72b2" translate="yes" xml:space="preserve">
          <source>database size</source>
          <target state="translated">размер базы данных</target>
        </trans-unit>
        <trans-unit id="9ac69b495c64616d7b51aad907a1b0a02e1e82e1" translate="yes" xml:space="preserve">
          <source>database users</source>
          <target state="translated">пользователи базы данных</target>
        </trans-unit>
        <trans-unit id="cb7adbeff69aceed0bcbedf307c65b93eee9ad75" translate="yes" xml:space="preserve">
          <source>databases within this database cluster</source>
          <target state="translated">базы данных в рамках данного кластера баз данных</target>
        </trans-unit>
        <trans-unit id="d202efb306923275367bde19b04202628d0810f8" translate="yes" xml:space="preserve">
          <source>date (no time of day)</source>
          <target state="translated">дата (без времени суток)</target>
        </trans-unit>
        <trans-unit id="1b3873d4c20bb95e93889a9abb13b9714bb3aebb" translate="yes" xml:space="preserve">
          <source>date and time (no time zone)</source>
          <target state="translated">дата и время (без часового пояса)</target>
        </trans-unit>
        <trans-unit id="eec85f3a0d545b904948082d0843118f704b1d8d" translate="yes" xml:space="preserve">
          <source>date and time, including time zone</source>
          <target state="translated">дата и время,включая часовой пояс</target>
        </trans-unit>
        <trans-unit id="a8317cc31a263bf0df643e148f49a9ce920f53ce" translate="yes" xml:space="preserve">
          <source>day of ISO 8601 week-numbering year (001&amp;ndash;371; day 1 of the year is Monday of the first ISO week)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d8e3721b3534cc276e29fdaeef31b7178dcae1" translate="yes" xml:space="preserve">
          <source>day of ISO 8601 week-numbering year (001-371; day 1 of the year is Monday of the first ISO week)</source>
          <target state="translated">день недели по стандарту ISO 8601 (001-371;первый день года-понедельник первой недели по стандарту ISO)</target>
        </trans-unit>
        <trans-unit id="090f8b3f331eb935f525922409bffea8e09b7d95" translate="yes" xml:space="preserve">
          <source>day of month (01&amp;ndash;31)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad17a3576b304f060bc744adbfaf1cfd97c0b9f" translate="yes" xml:space="preserve">
          <source>day of month (01-31)</source>
          <target state="translated">день месяца (01-31)</target>
        </trans-unit>
        <trans-unit id="469af68e3866ca6a9deafcaeae3928c434d4b3e1" translate="yes" xml:space="preserve">
          <source>day of the week, Sunday (&lt;code&gt;1&lt;/code&gt;) to Saturday (&lt;code&gt;7&lt;/code&gt;)</source>
          <target state="translated">день недели, с воскресенья ( &lt;code&gt;1&lt;/code&gt; ) по субботу ( &lt;code&gt;7&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0edf11eeeb832dd1b17b8e28879ed7531aa362ac" translate="yes" xml:space="preserve">
          <source>day of year (001&amp;ndash;366)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a71c2096de47fbc8680000b32ef705fe832913e" translate="yes" xml:space="preserve">
          <source>day of year (001-366)</source>
          <target state="translated">день года (001-366)</target>
        </trans-unit>
        <trans-unit id="700a54df2e790245f9dcd527f33cd998af18e65f" translate="yes" xml:space="preserve">
          <source>dblink_build_sql_update</source>
          <target state="translated">dblink_build_sql_update</target>
        </trans-unit>
        <trans-unit id="a03c4c4da450b6b78f166172cdfad6685ad457cd" translate="yes" xml:space="preserve">
          <source>de-summarize the page range covering the given block, if summarized</source>
          <target state="translated">де-суммаризация диапазона страниц,охватывающих данный блок,если суммировать</target>
        </trans-unit>
        <trans-unit id="cbb374265aa2a00ae1a935c1b66a5a8765c5a8db" translate="yes" xml:space="preserve">
          <source>decimal point</source>
          <target state="translated">десятичная запятая</target>
        </trans-unit>
        <trans-unit id="f0dcabf47a6adda5ccdca5499ec11830a3bb794d" translate="yes" xml:space="preserve">
          <source>decimal point (uses locale)</source>
          <target state="translated">десятичная запятая (использует локаль)</target>
        </trans-unit>
        <trans-unit id="d9f9f3ca28421c771e69ddc796196abbfc38261a" translate="yes" xml:space="preserve">
          <source>decompile internal form of an expression, assuming that any Vars in it refer to the relation indicated by the second parameter</source>
          <target state="translated">декомпилировать внутреннюю форму выражения,предполагая,что любые Vars в нем ссылаются на отношение,указанное вторым параметром</target>
        </trans-unit>
        <trans-unit id="5d0f59b9287cc99be12e3adc0a5ed8bb3aa30762" translate="yes" xml:space="preserve">
          <source>default privileges for object types</source>
          <target state="translated">права по умолчанию для типов объектов</target>
        </trans-unit>
        <trans-unit id="7ab389d535d69add8b20d71d3316df0764149116" translate="yes" xml:space="preserve">
          <source>degrees to radians</source>
          <target state="translated">градусы до радиан</target>
        </trans-unit>
        <trans-unit id="76a1d7b09f9d708126885250c26d9a7c5662a26e" translate="yes" xml:space="preserve">
          <source>delete XID stamp</source>
          <target state="translated">удалить печать XID</target>
        </trans-unit>
        <trans-unit id="4e7d874e194c57e56c6808bda722d6e762a82d75" translate="yes" xml:space="preserve">
          <source>delete key from left operand</source>
          <target state="translated">удалить ключ из левого операндов</target>
        </trans-unit>
        <trans-unit id="5994ddb3d5afc39677fe0d3e53b41199d5e46887" translate="yes" xml:space="preserve">
          <source>delete keys from left operand</source>
          <target state="translated">удалять ключи левого операндов</target>
        </trans-unit>
        <trans-unit id="e872e58a377017a736cf1e1ab4ff236790275777" translate="yes" xml:space="preserve">
          <source>delete matching pairs from left operand</source>
          <target state="translated">удалять соответствующие пары из левого операндов</target>
        </trans-unit>
        <trans-unit id="eae96a435f5bdb0c81e63fb0c70854998629b631" translate="yes" xml:space="preserve">
          <source>delete pair with matching key</source>
          <target state="translated">удалить пару с помощью соответствующего ключа</target>
        </trans-unit>
        <trans-unit id="b1c7a2750dfb5f36480871a2e5c6e4567af9e887" translate="yes" xml:space="preserve">
          <source>delete pairs matching those in the second argument</source>
          <target state="translated">удалять пары,совпадающие со вторым аргументом</target>
        </trans-unit>
        <trans-unit id="3efddac41d9ff2c5cb13d8732824f2be0263e5fa" translate="yes" xml:space="preserve">
          <source>delete pairs with matching keys</source>
          <target state="translated">удалять пары с помощью соответствующих ключей</target>
        </trans-unit>
        <trans-unit id="1039b55fb5734d3d36060d3f7c0dffed078f3f5d" translate="yes" xml:space="preserve">
          <source>dependencies between database objects</source>
          <target state="translated">зависимости между объектами БД</target>
        </trans-unit>
        <trans-unit id="bcf260757062336d168e0b854a6bfec054320982" translate="yes" xml:space="preserve">
          <source>dependencies on shared objects</source>
          <target state="translated">зависимости от совместно используемых объектов</target>
        </trans-unit>
        <trans-unit id="643b64fb4c981ee959710c294a989bd23751dfb6" translate="yes" xml:space="preserve">
          <source>depending on your system. If you are certain that no conflicting server is running, you can remove the lock file mentioned in the message and try again.</source>
          <target state="translated">в зависимости от вашей системы.Если вы уверены,что конфликтующий сервер не запущен,вы можете удалить файл блокировки,упомянутый в сообщении,и попробовать еще раз.</target>
        </trans-unit>
        <trans-unit id="74b0f36995620769c56ddd2cbff3cada94967a2b" translate="yes" xml:space="preserve">
          <source>deprecated synonym for &lt;code&gt;@@&lt;/code&gt;</source>
          <target state="translated">устаревший синоним &lt;code&gt;@@&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfeb202c643a0ab0c62a61acbeda3c7ce92fcd15" translate="yes" xml:space="preserve">
          <source>descriptions or comments on database objects</source>
          <target state="translated">описания или комментарии к объектам базы данных</target>
        </trans-unit>
        <trans-unit id="13c1d29555b21e921b0a3aedc5e4ff745b633b81" translate="yes" xml:space="preserve">
          <source>diameter of circle</source>
          <target state="translated">диаметр окружности</target>
        </trans-unit>
        <trans-unit id="ff9ccbf023e1d5c01856ab64c92fc6a9f9161e07" translate="yes" xml:space="preserve">
          <source>dict_int</source>
          <target state="translated">dict_int</target>
        </trans-unit>
        <trans-unit id="08bafab9b334b62e4fc9fb37bf107442495772df" translate="yes" xml:space="preserve">
          <source>dict_xsyn</source>
          <target state="translated">dict_xsyn</target>
        </trans-unit>
        <trans-unit id="48d53c6e22192bbaaff43be3456d5f6f5d82da6f" translate="yes" xml:space="preserve">
          <source>difference</source>
          <target state="translated">difference</target>
        </trans-unit>
        <trans-unit id="85ee40d69e337d51248f4aebee5d12dd412aef01" translate="yes" xml:space="preserve">
          <source>digit position (can be dropped if insignificant)</source>
          <target state="translated">положение цифры (может быть опущено,если незначительно)</target>
        </trans-unit>
        <trans-unit id="a724a4d536d891e4bd851b3b127513c5cac870e7" translate="yes" xml:space="preserve">
          <source>digit position (will not be dropped, even if insignificant)</source>
          <target state="translated">позиция цифры (не будет опускаться,даже если она незначительна)</target>
        </trans-unit>
        <trans-unit id="58e4fb37fdcbe481209c5e401fac9ed4117d48b5" translate="yes" xml:space="preserve">
          <source>directory to use for postmaster sockets during upgrade; default is current working directory; environment variable &lt;code&gt;PGSOCKETDIR&lt;/code&gt;</source>
          <target state="translated">каталог, используемый для сокетов postmaster во время обновления; по умолчанию - текущий рабочий каталог; переменная среды &lt;code&gt;PGSOCKETDIR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="302710649278eb0883ce3392069d7e99b6dfb8f9" translate="yes" xml:space="preserve">
          <source>dirty read</source>
          <target state="translated">непристойное чтение</target>
        </trans-unit>
        <trans-unit id="24d5fc5c766af09ab08d7bfd916da7e70bb52c5e" translate="yes" xml:space="preserve">
          <source>discrete percentile: returns the first input value whose position in the ordering equals or exceeds the specified fraction</source>
          <target state="translated">дискретный процентиль:возвращает первое входное значение,позиция которого в заказе равна или превышает указанную дробь</target>
        </trans-unit>
        <trans-unit id="2090e17cbce163da2ce919466e3fd2175625ec32" translate="yes" xml:space="preserve">
          <source>disk blocks</source>
          <target state="translated">дисковые блоки</target>
        </trans-unit>
        <trans-unit id="c96264e7d87a9178b70f95d33581e0839e385c5a" translate="yes" xml:space="preserve">
          <source>display a query match</source>
          <target state="translated">отобразить запросное совпадение</target>
        </trans-unit>
        <trans-unit id="7a1ad48b2e1eb83707513d8a4c172844610b0eac" translate="yes" xml:space="preserve">
          <source>display version information, then exit</source>
          <target state="translated">отобразить информацию о версии,затем выйти</target>
        </trans-unit>
        <trans-unit id="314b330f1a69b0d1e908c495db3cf5b21621f484" translate="yes" xml:space="preserve">
          <source>division (integer division truncates the result)</source>
          <target state="translated">деление (целочисленное деление усекает результат)</target>
        </trans-unit>
        <trans-unit id="030d8c79e8db0778a98b5c136a1d9a70816df62e" translate="yes" xml:space="preserve">
          <source>division (integer truncates the results)</source>
          <target state="translated">деление (целое число усекает результаты)</target>
        </trans-unit>
        <trans-unit id="4cb6cafbb6abf82018a9534f90701e2e42fca638" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain all specified keys?</source>
          <target state="translated">содержит ли &lt;code&gt;hstore&lt;/code&gt; все указанные ключи?</target>
        </trans-unit>
        <trans-unit id="bafd763d733c6d384cfadd48039c1c94b64a5057" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain any of the specified keys?</source>
          <target state="translated">содержит ли &lt;code&gt;hstore&lt;/code&gt; какой-либо из указанных ключей?</target>
        </trans-unit>
        <trans-unit id="16f67fbb1f9b0ce89c412fa9f9c91ed03c52ef42" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain key?</source>
          <target state="translated">делает &lt;code&gt;hstore&lt;/code&gt; содержит ключ?</target>
        </trans-unit>
        <trans-unit id="6d66dc3d673440da44d129cf30dafe0627587c75" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain non-&lt;code&gt;NULL&lt;/code&gt; value for key?</source>
          <target state="translated">это &lt;code&gt;hstore&lt;/code&gt; содержит не- &lt;code&gt;NULL&lt;/code&gt; значение для ключа?</target>
        </trans-unit>
        <trans-unit id="c33f0d5d452e89fd44dcdef1104e34e2460df71f" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; array contain any path matching any &lt;code&gt;lquery&lt;/code&gt;?</source>
          <target state="translated">делает &lt;code&gt;ltree&lt;/code&gt; массив содержит какой - либо путь , соответствующий любой &lt;code&gt;lquery&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="1c53b57b8ca3d240b9dc88085af96b6dbab6fa68" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; match &lt;code&gt;lquery&lt;/code&gt;?</source>
          <target state="translated">делает &lt;code&gt;ltree&lt;/code&gt; матч &lt;code&gt;lquery&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="3648ad67b9d0438df764a00aa33a91ea0f51da62" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; match &lt;code&gt;ltxtquery&lt;/code&gt;?</source>
          <target state="translated">делает &lt;code&gt;ltree&lt;/code&gt; матч &lt;code&gt;ltxtquery&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="bee15116149fbb94972f0f1f0a198543b5d86fe4" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; match any &lt;code&gt;lquery&lt;/code&gt; in array?</source>
          <target state="translated">соответствует ли &lt;code&gt;ltree&lt;/code&gt; любому &lt;code&gt;lquery&lt;/code&gt; в массиве?</target>
        </trans-unit>
        <trans-unit id="6daa1a6ed3cacf7a57ce4c941eea23a2076c5480" translate="yes" xml:space="preserve">
          <source>does &lt;em&gt;not&lt;/em&gt; mean you've run out of disk space. It means your kernel's limit on the number of System V semaphores is smaller than the number PostgreSQL wants to create. As above, you might be able to work around the problem by starting the server with a reduced number of allowed connections (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), but you'll eventually want to increase the kernel limit.</source>
          <target state="translated">вовсе &lt;em&gt;не&lt;/em&gt; означает , что вы бежите из дискового пространства. Это означает, что ограничение вашего ядра на количество семафоров System V меньше, чем количество, которое PostgreSQL хочет создать. Как и выше, вы можете обойти проблему, запустив сервер с уменьшенным количеством разрешенных соединений ( &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; ), но в конечном итоге вы захотите увеличить лимит ядра.</target>
        </trans-unit>
        <trans-unit id="64868bbf0f6334a11707f036779fce59caac51fe" translate="yes" xml:space="preserve">
          <source>does array contain a descendant of &lt;code&gt;ltree&lt;/code&gt;?</source>
          <target state="translated">содержит ли массив потомка &lt;code&gt;ltree&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="a301dc21d55ea9fa1daaf587093b7b700878a61f" translate="yes" xml:space="preserve">
          <source>does array contain an ancestor of &lt;code&gt;ltree&lt;/code&gt;?</source>
          <target state="translated">содержит ли массив предка &lt;code&gt;ltree&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="567bff233f20cf454c16349c2b002f100e4644d2" translate="yes" xml:space="preserve">
          <source>does array contain any path matching &lt;code&gt;lquery&lt;/code&gt;?</source>
          <target state="translated">содержит ли массив какой-либо &lt;code&gt;lquery&lt;/code&gt; соответствия пути ?</target>
        </trans-unit>
        <trans-unit id="7d7b1ca647e0b44d6a318e89c4b79d80dec00662" translate="yes" xml:space="preserve">
          <source>does array contain any path matching &lt;code&gt;ltxtquery&lt;/code&gt;?</source>
          <target state="translated">содержит ли массив какой-либо путь, соответствующий &lt;code&gt;ltxtquery&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="d0e93f199be58627d5290fb7e295a3883e34de0e" translate="yes" xml:space="preserve">
          <source>does current user have privilege for any column of table</source>
          <target state="translated">имеет ли текущий пользователь привилегии для любого столбца таблицы</target>
        </trans-unit>
        <trans-unit id="923f34e72b54c44d587b74dfe716fb9e7a0b69f3" translate="yes" xml:space="preserve">
          <source>does current user have privilege for column</source>
          <target state="translated">имеет ли текущий пользователь привилегии на столбец</target>
        </trans-unit>
        <trans-unit id="8eebefcd3db5e0fd1f67f23a742c8cbdb52ca488" translate="yes" xml:space="preserve">
          <source>does current user have privilege for database</source>
          <target state="translated">имеет ли текущий пользователь привилегии для базы данных</target>
        </trans-unit>
        <trans-unit id="d5d20390d72f10839e55e755a41622b4e83aaad2" translate="yes" xml:space="preserve">
          <source>does current user have privilege for foreign server</source>
          <target state="translated">имеет ли текущий пользователь привилегии для зарубежного сервера</target>
        </trans-unit>
        <trans-unit id="76e06765244ec4f69ad0edf35314e91668644688" translate="yes" xml:space="preserve">
          <source>does current user have privilege for foreign-data wrapper</source>
          <target state="translated">имеет ли текущий пользователь привилегию на обертку зарубежных данных</target>
        </trans-unit>
        <trans-unit id="14cf9981a77c04be078c13991b9209c61e42b19f" translate="yes" xml:space="preserve">
          <source>does current user have privilege for function</source>
          <target state="translated">имеет ли текущий пользователь привилегию на выполнение функции</target>
        </trans-unit>
        <trans-unit id="e53afcf7f590b1f341c771ee932c34274218fee2" translate="yes" xml:space="preserve">
          <source>does current user have privilege for language</source>
          <target state="translated">имеет ли текущий пользователь привилегии на язык</target>
        </trans-unit>
        <trans-unit id="d392178c73923ceb61788ee59e66cfc98b85b093" translate="yes" xml:space="preserve">
          <source>does current user have privilege for role</source>
          <target state="translated">имеет ли текущий пользователь привилегии на роль</target>
        </trans-unit>
        <trans-unit id="3ce043cb41e01186d5429925060d21732a8a9b01" translate="yes" xml:space="preserve">
          <source>does current user have privilege for schema</source>
          <target state="translated">имеет ли текущий пользователь привилегии для схемы</target>
        </trans-unit>
        <trans-unit id="44e2c7a7969b5280a9ac5e18312a1a719915e5c8" translate="yes" xml:space="preserve">
          <source>does current user have privilege for sequence</source>
          <target state="translated">имеет ли текущий пользователь привилегию на последовательность</target>
        </trans-unit>
        <trans-unit id="a8553aada6aa07a63b9fb14a123e6eb5d6132d87" translate="yes" xml:space="preserve">
          <source>does current user have privilege for table</source>
          <target state="translated">имеет ли текущий пользователь привилегию на таблицу</target>
        </trans-unit>
        <trans-unit id="aa74612a59a28280141be932e93980e9b80f16c8" translate="yes" xml:space="preserve">
          <source>does current user have privilege for tablespace</source>
          <target state="translated">имеет ли текущий пользователь привилегии на табличное пространство</target>
        </trans-unit>
        <trans-unit id="dd7e9d6b9c5d3197cefad7a4260eb463901b4b09" translate="yes" xml:space="preserve">
          <source>does current user have privilege for type</source>
          <target state="translated">имеет ли текущий пользователь привилегию на тип</target>
        </trans-unit>
        <trans-unit id="65119e338c802227733d23f560577b1f92332234" translate="yes" xml:space="preserve">
          <source>does current user have row level security active for table</source>
          <target state="translated">есть ли у текущего пользователя защита на уровне строк,активная для таблицы.</target>
        </trans-unit>
        <trans-unit id="b12d604405828eb6355ba772e8353d7dff5c090e" translate="yes" xml:space="preserve">
          <source>does left operand contain right?</source>
          <target state="translated">левый операнд содержит право?</target>
        </trans-unit>
        <trans-unit id="756c9771ba43bfeb3fc0b27733143e509011767d" translate="yes" xml:space="preserve">
          <source>does not contradict common sense, neither does the intersection</source>
          <target state="translated">не противоречит здравому смыслу,как и перекресток.</target>
        </trans-unit>
        <trans-unit id="b36715a10925245466a61b1c713e5e53614f7d3c" translate="yes" xml:space="preserve">
          <source>does not extend to the left of</source>
          <target state="translated">не распространяется слева от</target>
        </trans-unit>
        <trans-unit id="7d4052eb9215bde986d065d712fe5d1ea63cb4dd" translate="yes" xml:space="preserve">
          <source>does not extend to the right of</source>
          <target state="translated">не распространяется на право</target>
        </trans-unit>
        <trans-unit id="f7f46d46a353213d12fe0e106cd32be9a96a313c" translate="yes" xml:space="preserve">
          <source>does not result in an error, because the &lt;code&gt;||&lt;/code&gt; operator does not care about collations: its result is the same regardless of the collation.</source>
          <target state="translated">не приводит к ошибке, потому что &lt;code&gt;||&lt;/code&gt; Оператор не заботится о сопоставлениях: его результат одинаков независимо от сопоставления.</target>
        </trans-unit>
        <trans-unit id="75e4c1b191e5aba3fca713359bb284f3bba53197" translate="yes" xml:space="preserve">
          <source>does user have privilege for any column of table</source>
          <target state="translated">имеет ли пользователь привилегии для любого столбца таблицы</target>
        </trans-unit>
        <trans-unit id="3e3a02344dffd3279b448eb7d8ae2788f7b6be07" translate="yes" xml:space="preserve">
          <source>does user have privilege for column</source>
          <target state="translated">имеет ли пользователь привилегии на столбец</target>
        </trans-unit>
        <trans-unit id="e98b58c4f0fc14060c4884df933960d9628f8716" translate="yes" xml:space="preserve">
          <source>does user have privilege for database</source>
          <target state="translated">имеет ли пользователь привилегии для базы данных</target>
        </trans-unit>
        <trans-unit id="765c96c7f8619408b3a2ef1d6a65be4c1cacb9c9" translate="yes" xml:space="preserve">
          <source>does user have privilege for foreign server</source>
          <target state="translated">имеет ли пользователь привилегии для иностранного сервера</target>
        </trans-unit>
        <trans-unit id="a1aad5c71dcb9de7b0ebfe1791764c821ee31f90" translate="yes" xml:space="preserve">
          <source>does user have privilege for foreign-data wrapper</source>
          <target state="translated">имеет ли пользователь привилегию на обертку иностранных данных</target>
        </trans-unit>
        <trans-unit id="c225f178288924737bfa6e4b6a297dd843498dd4" translate="yes" xml:space="preserve">
          <source>does user have privilege for function</source>
          <target state="translated">имеет ли пользователь привилегии для работы</target>
        </trans-unit>
        <trans-unit id="d470907c424695bcabb45adae12569de1bad3b0d" translate="yes" xml:space="preserve">
          <source>does user have privilege for language</source>
          <target state="translated">имеет ли пользователь привилегии языка</target>
        </trans-unit>
        <trans-unit id="a0ba62c173d0bc0e7a46899574360820b2bc2f9f" translate="yes" xml:space="preserve">
          <source>does user have privilege for role</source>
          <target state="translated">имеет ли пользователь привилегию на роль</target>
        </trans-unit>
        <trans-unit id="bed67dbbf088b4b1ffec5c7180d7d0ec267b5df8" translate="yes" xml:space="preserve">
          <source>does user have privilege for schema</source>
          <target state="translated">имеет ли пользователь привилегии для схемы</target>
        </trans-unit>
        <trans-unit id="fda3d32d403e4d198f5f4e5703028831a30fe866" translate="yes" xml:space="preserve">
          <source>does user have privilege for sequence</source>
          <target state="translated">имеет ли пользователь привилегию на последовательность</target>
        </trans-unit>
        <trans-unit id="0b3c10883f54a4a3a8e9b7a17c728cb3f9c09b6a" translate="yes" xml:space="preserve">
          <source>does user have privilege for table</source>
          <target state="translated">имеет ли пользователь привилегию на таблицу</target>
        </trans-unit>
        <trans-unit id="d616ba1bcc2173d55dc3b40b681e7e2c83c7625d" translate="yes" xml:space="preserve">
          <source>does user have privilege for tablespace</source>
          <target state="translated">имеет ли пользователь привилегии на табличное пространство</target>
        </trans-unit>
        <trans-unit id="f37310ea7053667a4967493d91089148515177e4" translate="yes" xml:space="preserve">
          <source>does user have privilege for type</source>
          <target state="translated">имеет ли пользователь привилегию на тип</target>
        </trans-unit>
        <trans-unit id="bdb36bb22deb169275b3094ba9005a29eeddd195" translate="yes" xml:space="preserve">
          <source>double</source>
          <target state="translated">double</target>
        </trans-unit>
        <trans-unit id="f70c61055e7cd930e448a61146df9dcec538dae5" translate="yes" xml:space="preserve">
          <source>double if any &lt;code&gt;a&lt;/code&gt; is double, else integer</source>
          <target state="translated">double, если любое &lt;code&gt;a&lt;/code&gt; равно double, иначе целое</target>
        </trans-unit>
        <trans-unit id="a9d7d2a5b010ce1408927d410711b2b9b2dcf630" translate="yes" xml:space="preserve">
          <source>double precision</source>
          <target state="translated">двойная точность</target>
        </trans-unit>
        <trans-unit id="7bd1b3d84f60bc411ebad0e502e786bfb5dff6b4" translate="yes" xml:space="preserve">
          <source>double precision floating-point number (8 bytes)</source>
          <target state="translated">номер с плавающей точкой двойной точности (8 байт)</target>
        </trans-unit>
        <trans-unit id="2b0e335cd50db4422abd071d794ce8250a0af460" translate="yes" xml:space="preserve">
          <source>download dictionary configuration files. OpenOffice extension files have the &lt;code&gt;.oxt&lt;/code&gt; extension. It is necessary to extract &lt;code&gt;.aff&lt;/code&gt; and &lt;code&gt;.dic&lt;/code&gt; files, change extensions to &lt;code&gt;.affix&lt;/code&gt; and &lt;code&gt;.dict&lt;/code&gt;. For some dictionary files it is also needed to convert characters to the UTF-8 encoding with commands (for example, for a Norwegian language dictionary):</source>
          <target state="translated">скачать файлы конфигурации словаря. Файлы расширения OpenOffice имеют расширение &lt;code&gt;.oxt&lt;/code&gt; . Необходимо извлечь &lt;code&gt;.aff&lt;/code&gt; и &lt;code&gt;.dic&lt;/code&gt; , поменять расширения на &lt;code&gt;.affix&lt;/code&gt; и &lt;code&gt;.dict&lt;/code&gt; . Для некоторых файлов словарей также необходимо преобразовать символы в кодировку UTF-8 с помощью команд (например, для словаря норвежского языка):</target>
        </trans-unit>
        <trans-unit id="6cbe8eee2be1493251c74aba3d14ce090704c314" translate="yes" xml:space="preserve">
          <source>dropdb</source>
          <target state="translated">dropdb</target>
        </trans-unit>
        <trans-unit id="da2f55f30903093b88b2abe2ff1d8c8878785d4d" translate="yes" xml:space="preserve">
          <source>dropdb &amp;mdash; remove a PostgreSQL database</source>
          <target state="translated">dropdb - удалить базу данных PostgreSQL</target>
        </trans-unit>
        <trans-unit id="cee0a709ed144356dd15d656bc6b22fb78c87ab6" translate="yes" xml:space="preserve">
          <source>dropdb accepts the following command-line arguments:</source>
          <target state="translated">dropdb принимает следующие аргументы командной строки:</target>
        </trans-unit>
        <trans-unit id="6f5dc55cde4d56805bce8487bd823396755fbd8f" translate="yes" xml:space="preserve">
          <source>dropdb also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">dropdb также принимает следующие аргументы командной строки для параметров соединения:</target>
        </trans-unit>
        <trans-unit id="b2c63240befa5a55623102754bbe3f06e330117d" translate="yes" xml:space="preserve">
          <source>dropdb destroys an existing PostgreSQL database. The user who executes this command must be a database superuser or the owner of the database.</source>
          <target state="translated">dropdb уничтожает существующую базу данных PostgreSQL.Пользователь,выполняющий эту команду,должен быть суперпользователем БД или ее владельцем.</target>
        </trans-unit>
        <trans-unit id="5fdb4e6dd14831ab684970c9656f06e02410c343" translate="yes" xml:space="preserve">
          <source>dropdb is a wrapper around the SQL command &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt;. There is no effective difference between dropping databases via this utility and via other methods for accessing the server.</source>
          <target state="translated">dropdb - это оболочка для SQL-команды &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; . Эффективной разницы между удалением баз данных с помощью этой утилиты и других методов доступа к серверу нет.</target>
        </trans-unit>
        <trans-unit id="61f8d2eb809b42145cb0c2cc59455f90ae6b39d4" translate="yes" xml:space="preserve">
          <source>dropuser</source>
          <target state="translated">dropuser</target>
        </trans-unit>
        <trans-unit id="3d4f5569f58e7a7d09eb7133d2210c8728567a77" translate="yes" xml:space="preserve">
          <source>dropuser &amp;mdash; remove a PostgreSQL user account</source>
          <target state="translated">dropuser - удалить учетную запись пользователя PostgreSQL</target>
        </trans-unit>
        <trans-unit id="1077aba6c2b30bf419021fbb806b212443ec339c" translate="yes" xml:space="preserve">
          <source>dropuser accepts the following command-line arguments:</source>
          <target state="translated">выпадающий принимает следующие аргументы командной строки:</target>
        </trans-unit>
        <trans-unit id="2671207f049e22f4b10b3fd2b9765935cf20ee06" translate="yes" xml:space="preserve">
          <source>dropuser also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">дроплюсер также принимает следующие аргументы командной строки для параметров соединения:</target>
        </trans-unit>
        <trans-unit id="c9d1416783a863b7c532e14663d3712fc1f90804" translate="yes" xml:space="preserve">
          <source>dropuser is a wrapper around the SQL command &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;. There is no effective difference between dropping users via this utility and via other methods for accessing the server.</source>
          <target state="translated">dropuser - это оболочка для SQL-команды &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; . Эффективной разницы между удалением пользователей с помощью этой утилиты и других методов доступа к серверу нет.</target>
        </trans-unit>
        <trans-unit id="4c08c2e0100e4eb26441eea8482accbff764a871" translate="yes" xml:space="preserve">
          <source>dropuser removes an existing PostgreSQL user. Only superusers and users with the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can remove PostgreSQL users. (To remove a superuser, you must yourself be a superuser.)</source>
          <target state="translated">dropuser удаляет существующего пользователя PostgreSQL. Только суперпользователи и пользователи с привилегией &lt;code&gt;CREATEROLE&lt;/code&gt; могут удалять пользователей PostgreSQL. (Чтобы удалить суперпользователя, вы сами должны быть суперпользователем.)</target>
        </trans-unit>
        <trans-unit id="2d1c3f7cb60beb3d49e3f4e046f5ea896f8b0a5d" translate="yes" xml:space="preserve">
          <source>earlier than all other time stamps</source>
          <target state="translated">раньше всех остальных штампов времени</target>
        </trans-unit>
        <trans-unit id="d00152028f9066049bf52b54717487fea14124ea" translate="yes" xml:space="preserve">
          <source>earthdistance</source>
          <target state="translated">earthdistance</target>
        </trans-unit>
        <trans-unit id="d13f9c0d833baac358fedb3d5d5130ba389408d4" translate="yes" xml:space="preserve">
          <source>ecpg</source>
          <target state="translated">ecpg</target>
        </trans-unit>
        <trans-unit id="ee8426e3ae205f6a4fbf14400afc72dbe65a18e6" translate="yes" xml:space="preserve">
          <source>ecpg &amp;mdash; embedded SQL C preprocessor</source>
          <target state="translated">ecpg - встроенный препроцессор SQL C</target>
        </trans-unit>
        <trans-unit id="431fd257c42ba97d31ee98637d51749f58818b72" translate="yes" xml:space="preserve">
          <source>element is contained by</source>
          <target state="translated">элемент содержится в</target>
        </trans-unit>
        <trans-unit id="7fd8de61bf0672691fbb98aab87cd593aeaf89f4" translate="yes" xml:space="preserve">
          <source>element-to-array concatenation</source>
          <target state="translated">конкатенация &quot;слон-к-машине</target>
        </trans-unit>
        <trans-unit id="ab2afe87d80f8f35bf989060afa3c6ac12a43886" translate="yes" xml:space="preserve">
          <source>enable verbose internal logging</source>
          <target state="translated">подробный внутренний журнал</target>
        </trans-unit>
        <trans-unit id="7cbe751985c35402c31394cb0929695fc5649328" translate="yes" xml:space="preserve">
          <source>encoding conversion information</source>
          <target state="translated">информация о преобразовании кодировки</target>
        </trans-unit>
        <trans-unit id="1671ca77906f61454bce6768a91e2e8e821e8948" translate="yes" xml:space="preserve">
          <source>enum label and value definitions</source>
          <target state="translated">метка перечисления и определения значений</target>
        </trans-unit>
        <trans-unit id="f57b2d312d9efe8fe993c8eb1f3e19d41ad04030" translate="yes" xml:space="preserve">
          <source>equal</source>
          <target state="translated">equal</target>
        </trans-unit>
        <trans-unit id="44040a02784585bdd6249b4edd2dd94238188e6f" translate="yes" xml:space="preserve">
          <source>equal, treating null like an ordinary value</source>
          <target state="translated">равное,рассматривая ноль как обычную величину</target>
        </trans-unit>
        <trans-unit id="80b2f559a14748525776894e12e1216b49b5b558" translate="yes" xml:space="preserve">
          <source>equals</source>
          <target state="translated">equals</target>
        </trans-unit>
        <trans-unit id="f18bd7a51999b2b1d95efa4274723b39e0ac6b39" translate="yes" xml:space="preserve">
          <source>equivalent to &lt;code&gt;bool_and&lt;/code&gt;</source>
          <target state="translated">эквивалент &lt;code&gt;bool_and&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4232efd7b52fa7af1f07ed9b444c78b5cec9a81" translate="yes" xml:space="preserve">
          <source>equivalent to &lt;code&gt;current_user&lt;/code&gt;</source>
          <target state="translated">эквивалент &lt;code&gt;current_user&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65b09de7c4f948564eb4e9f8a8c8ad7481598866" translate="yes" xml:space="preserve">
          <source>era indicator (with periods)</source>
          <target state="translated">индикатор эры (с периодами)</target>
        </trans-unit>
        <trans-unit id="24e96aa5ab5679037b391de37b4ce482d43684f1" translate="yes" xml:space="preserve">
          <source>era indicator (without periods)</source>
          <target state="translated">индикатор эры (без периодов)</target>
        </trans-unit>
        <trans-unit id="cdecabe1520a398e4e46deff9d55b19bed6d6457" translate="yes" xml:space="preserve">
          <source>escape</source>
          <target state="translated">escape</target>
        </trans-unit>
        <trans-unit id="be464074e84929b3edb1afc53993489c2a50213d" translate="yes" xml:space="preserve">
          <source>even though there will really be zero rows satisfying this query. Functional dependency statistics do not provide enough information to conclude that, however.</source>
          <target state="translated">несмотря на то,что в этом запросе действительно будут нулевые строки,удовлетворяющие этому запросу.Однако статистика функциональных зависимостей не дает достаточной информации для того,чтобы сделать вывод об этом.</target>
        </trans-unit>
        <trans-unit id="b2fe05583b44066ff5424d20e6314b48bc6e0ea7" translate="yes" xml:space="preserve">
          <source>even though they had no intention of ever using &lt;code&gt;y&lt;/code&gt; as part of a &lt;code&gt;WHERE&lt;/code&gt; clause. This works fine as long as the extra columns are trailing columns; making them be leading columns is unwise for the reasons explained in &lt;a href=&quot;indexes-multicolumn&quot;&gt;Section 11.3&lt;/a&gt;. However, this method doesn't support the case where you want the index to enforce uniqueness on the key column(s).</source>
          <target state="translated">даже если у них не было намерения когда-либо использовать &lt;code&gt;y&lt;/code&gt; как часть &lt;code&gt;WHERE&lt;/code&gt; . Это прекрасно работает, пока дополнительные столбцы являются конечными столбцами; делать их ведущими столбцами неразумно по причинам, описанным в &lt;a href=&quot;indexes-multicolumn&quot;&gt;Разделе 11.3&lt;/a&gt; . Однако этот метод не поддерживает случай, когда вы хотите, чтобы индекс обеспечивал уникальность ключевого столбца (столбцов).</target>
        </trans-unit>
        <trans-unit id="7833e7d391c504aee68e45dea9634b1c53821bff" translate="yes" xml:space="preserve">
          <source>event triggers</source>
          <target state="translated">триггеры событий</target>
        </trans-unit>
        <trans-unit id="f5caa8594147ec7c253638db4988e8f1141145c5" translate="yes" xml:space="preserve">
          <source>eventlog</source>
          <target state="translated">eventlog</target>
        </trans-unit>
        <trans-unit id="a1369004de61926651324b802d6bf7dde40d8308" translate="yes" xml:space="preserve">
          <source>exact numeric of selectable precision</source>
          <target state="translated">точное число выбираемой точности</target>
        </trans-unit>
        <trans-unit id="910088c467ddca75f7465dd40037d50a4b1024d5" translate="yes" xml:space="preserve">
          <source>exactly one of &lt;code&gt;A&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;B&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;A&lt;/code&gt; is true (&lt;em&gt;trichotomy law&lt;/em&gt;)</source>
          <target state="translated">ровно одно из &lt;code&gt;A&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; истинно ( &lt;em&gt;закон трихотомии&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="98585ed8f50402fa8abbe3b11d352d8c7b352517" translate="yes" xml:space="preserve">
          <source>expand a &lt;code&gt;tsvector&lt;/code&gt; to a set of rows</source>
          <target state="translated">развернуть &lt;code&gt;tsvector&lt;/code&gt; до набора строк</target>
        </trans-unit>
        <trans-unit id="f1b33fd39221d674e864b833837123f8c9c566a5" translate="yes" xml:space="preserve">
          <source>expand an array to a set of rows</source>
          <target state="translated">расширить массив до набора рядов</target>
        </trans-unit>
        <trans-unit id="b4177b3fdd9f1dcef4246133756c7d4295ee3473" translate="yes" xml:space="preserve">
          <source>expand multiple arrays (possibly of different types) to a set of rows. This is only allowed in the FROM clause; see &lt;a href=&quot;queries-table-expressions#QUERIES-TABLEFUNCTIONS&quot;&gt;Section 7.2.1.4&lt;/a&gt;</source>
          <target state="translated">развернуть несколько массивов (возможно, разных типов) до набора строк. Это разрешено только в предложении FROM; см. &lt;a href=&quot;queries-table-expressions#QUERIES-TABLEFUNCTIONS&quot;&gt;Раздел 7.2.1.4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4500e56b5a24d60ce7b2499c19162fb567e578b4" translate="yes" xml:space="preserve">
          <source>expanded syntax (see below)</source>
          <target state="translated">расширенный синтаксис (см.ниже)</target>
        </trans-unit>
        <trans-unit id="51a433a570f5960fccaccfbfa93909e78f841178" translate="yes" xml:space="preserve">
          <source>exponent for scientific notation</source>
          <target state="translated">экспонент для научной нотации</target>
        </trans-unit>
        <trans-unit id="dc606218848a18d5c34862a175d29c1fe03c13d9" translate="yes" xml:space="preserve">
          <source>exponential</source>
          <target state="translated">exponential</target>
        </trans-unit>
        <trans-unit id="1e78ce1a1f32081b3133e35ca2ce8f4369be90ee" translate="yes" xml:space="preserve">
          <source>exponentially-distributed random integer in &lt;code&gt;[lb, ub]&lt;/code&gt;, see below</source>
          <target state="translated">экспоненциально распределенное случайное целое число в &lt;code&gt;[lb, ub]&lt;/code&gt; , см. ниже</target>
        </trans-unit>
        <trans-unit id="1d422390c5a3d1333fb7f5d97621fa0f6e7f0d6c" translate="yes" xml:space="preserve">
          <source>exponentiation</source>
          <target state="translated">exponentiation</target>
        </trans-unit>
        <trans-unit id="0db5a9a232a6935699542e335a56a8df9f43d2e9" translate="yes" xml:space="preserve">
          <source>exponentiation (associates left to right)</source>
          <target state="translated">экспоненциация (партнёры слева направо)</target>
        </trans-unit>
        <trans-unit id="5d7f1bff34ea278c6c5a2fc91295c8a87607dc57" translate="yes" xml:space="preserve">
          <source>extended planner statistics</source>
          <target state="translated">расширенная статистика планирования</target>
        </trans-unit>
        <trans-unit id="cc65f5c101ab8b09f58273801d736b9e9677d0e8" translate="yes" xml:space="preserve">
          <source>extended planner statistics (built statistics)</source>
          <target state="translated">расширенная статистика планирования (построенная статистика)</target>
        </trans-unit>
        <trans-unit id="6d557d048a3b2c532f56398c201f9c70fcd3184e" translate="yes" xml:space="preserve">
          <source>extended planner statistics (definition)</source>
          <target state="translated">расширенная статистика планирования (определение)</target>
        </trans-unit>
        <trans-unit id="b56ba1d1de71303ba9e7ac7e6d37ccee335d2140" translate="yes" xml:space="preserve">
          <source>external node identifier</source>
          <target state="translated">внешний идентификатор узла</target>
        </trans-unit>
        <trans-unit id="8cea632a3c2f5380e27bf9754368859382f731f4" translate="yes" xml:space="preserve">
          <source>extract IP address and netmask length as text</source>
          <target state="translated">извлечение IP-адреса и длина маски сети в виде текста</target>
        </trans-unit>
        <trans-unit id="1adf6634d9f5912d39aae24816f962b74dbd1d3d" translate="yes" xml:space="preserve">
          <source>extract IP address as text</source>
          <target state="translated">IP-адрес извлечения в виде текста</target>
        </trans-unit>
        <trans-unit id="52224bb43ff5437ccb717a45646600f74c89bca0" translate="yes" xml:space="preserve">
          <source>extract a subset of an &lt;code&gt;hstore&lt;/code&gt;</source>
          <target state="translated">извлечь подмножество &lt;code&gt;hstore&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6a0f78ab60fe16f14c77cc85e268514510fb939e" translate="yes" xml:space="preserve">
          <source>extract family of address; &lt;code&gt;4&lt;/code&gt; for IPv4, &lt;code&gt;6&lt;/code&gt; for IPv6</source>
          <target state="translated">извлечь семейство адреса; &lt;code&gt;4&lt;/code&gt; для IPv4, &lt;code&gt;6&lt;/code&gt; для IPv6</target>
        </trans-unit>
        <trans-unit id="63b60e17da1c01c315490ec61d92c6ae1b9cfac1" translate="yes" xml:space="preserve">
          <source>extract netmask length</source>
          <target state="translated">длина маски экстракта</target>
        </trans-unit>
        <trans-unit id="8eb7d749717b314ca4b624308f167fb8f0536c57" translate="yes" xml:space="preserve">
          <source>extract network part of address</source>
          <target state="translated">извлечение сетевой части адреса</target>
        </trans-unit>
        <trans-unit id="cf2f15ec5a30d6402b8a8b59c0f122369583dbf1" translate="yes" xml:space="preserve">
          <source>f(x) = PHI(2.0 * parameter * (x - mu) / (max - min + 1)) / (2.0 * PHI(parameter) - 1)</source>
          <target state="translated">f(x)=PHI(2.0*параметр*(x-mu)/(максимум-мин+1))/(2.0*PHI(параметр)-1)</target>
        </trans-unit>
        <trans-unit id="d8ecaf8c657a2b137edff4403d3015c673733131" translate="yes" xml:space="preserve">
          <source>f(x) = exp(-parameter * (x - min) / (max - min + 1)) / (1 - exp(-parameter))</source>
          <target state="translated">f(x)=exp(-параметр*(x-мин)/(макс-мин+1))/(1-exp(-параметр))</target>
        </trans-unit>
        <trans-unit id="2bd70faaff2dc3145c4f93d20179cef8d5fd1bdd" translate="yes" xml:space="preserve">
          <source>factorial</source>
          <target state="translated">factorial</target>
        </trans-unit>
        <trans-unit id="30d4e08f4264897498d5f939d1ac8e6b0526d163" translate="yes" xml:space="preserve">
          <source>factorial (prefix operator)</source>
          <target state="translated">факториал (оператор префикса)</target>
        </trans-unit>
        <trans-unit id="519c2566cb819aa98f00c389f875acd6c2f82fd8" translate="yes" xml:space="preserve">
          <source>field size</source>
          <target state="translated">размер поля</target>
        </trans-unit>
        <trans-unit id="3a88b38ae3a3604d3f1af4ad93ba5fe6fb9f87bc" translate="yes" xml:space="preserve">
          <source>file_fdw</source>
          <target state="translated">file_fdw</target>
        </trans-unit>
        <trans-unit id="983401d0e918dc765c97b567a565058e6af554ed" translate="yes" xml:space="preserve">
          <source>fill mode (suppress leading zeroes and padding blanks)</source>
          <target state="translated">режим заполнения (подавление наводящих нулей и пустот набивки)</target>
        </trans-unit>
        <trans-unit id="a5e4a7072f8551b572a1cee1a88417461488e2a7" translate="yes" xml:space="preserve">
          <source>fill mode (suppress trailing zeroes and padding blanks)</source>
          <target state="translated">режим заправки (подавление замыкающих нулей и пустот набивки)</target>
        </trans-unit>
        <trans-unit id="32003507876dacdf67e2131262acee891800afea" translate="yes" xml:space="preserve">
          <source>first array entry that is a descendant of &lt;code&gt;ltree&lt;/code&gt;; NULL if none</source>
          <target state="translated">первая запись массива, которая является потомком &lt;code&gt;ltree&lt;/code&gt; ; NULL, если нет</target>
        </trans-unit>
        <trans-unit id="515013b791f433a9eae1982ebea0e32381eccb14" translate="yes" xml:space="preserve">
          <source>first array entry that is an ancestor of &lt;code&gt;ltree&lt;/code&gt;; NULL if none</source>
          <target state="translated">первая запись в массиве, которая является предком &lt;code&gt;ltree&lt;/code&gt; ; NULL, если нет</target>
        </trans-unit>
        <trans-unit id="5a3fdedfab8428272c62bd9bbab1aa027083b860" translate="yes" xml:space="preserve">
          <source>first array entry that matches &lt;code&gt;lquery&lt;/code&gt;; NULL if none</source>
          <target state="translated">первая запись массива, соответствующая &lt;code&gt;lquery&lt;/code&gt; ; NULL, если нет</target>
        </trans-unit>
        <trans-unit id="086d1f932d7df2500f28084d6285586dd205f44c" translate="yes" xml:space="preserve">
          <source>first array entry that matches &lt;code&gt;ltxtquery&lt;/code&gt;; NULL if none</source>
          <target state="translated">первая запись массива, соответствующая &lt;code&gt;ltxtquery&lt;/code&gt; ; NULL, если нет</target>
        </trans-unit>
        <trans-unit id="25970e09bd0194f53db323fdee569ecc5ee9d06a" translate="yes" xml:space="preserve">
          <source>fixed format global option (see usage notes)</source>
          <target state="translated">глобальная опция фиксированного формата (см.примечания по использованию)</target>
        </trans-unit>
        <trans-unit id="f6a11edd2a4d248a530de4d7e132bac84862a375" translate="yes" xml:space="preserve">
          <source>fixed-length bit string</source>
          <target state="translated">битовая строка фиксированной длины</target>
        </trans-unit>
        <trans-unit id="dcb97d9db2463758f31c0de9d3bce9df50408dfb" translate="yes" xml:space="preserve">
          <source>fixed-length character string</source>
          <target state="translated">строка символов фиксированной длины</target>
        </trans-unit>
        <trans-unit id="223f2208f7d4b1043c7e491f40e2e2d8ed03ae8b" translate="yes" xml:space="preserve">
          <source>fixed-length, blank padded</source>
          <target state="translated">фиксированной длины,пустой мягкий</target>
        </trans-unit>
        <trans-unit id="42f81371a9d58223349ec7034da245db8ada9ccd" translate="yes" xml:space="preserve">
          <source>flag (name of the affix class)</source>
          <target state="translated">флаг (имя класса аффиксов)</target>
        </trans-unit>
        <trans-unit id="b0163776e81d6187e8b5cfa662418933736608b6" translate="yes" xml:space="preserve">
          <source>flags identifying &lt;code&gt;NULL&lt;/code&gt; values</source>
          <target state="translated">флаги, идентифицирующие значения &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="93d9feb10aec6e36f31762cbd4d5259b39c8aceb" translate="yes" xml:space="preserve">
          <source>foreign server definitions</source>
          <target state="translated">определения иностранных серверов</target>
        </trans-unit>
        <trans-unit id="0d25df728aebb140e50bd8e011aaf8a6c6258f90" translate="yes" xml:space="preserve">
          <source>foreign-data wrapper definitions</source>
          <target state="translated">определения обёртки иностранных данных</target>
        </trans-unit>
        <trans-unit id="cacfbd40505fff5a97d7effce15468bbc881b94d" translate="yes" xml:space="preserve">
          <source>form feed</source>
          <target state="translated">подача формы</target>
        </trans-unit>
        <trans-unit id="e03c80c93af95df14136862d42780c28c008d0cd" translate="yes" xml:space="preserve">
          <source>form feed, as in C</source>
          <target state="translated">форма подачи,как в C</target>
        </trans-unit>
        <trans-unit id="170f5a3f34787c6aab8fa71dfbca18211e9264aa" translate="yes" xml:space="preserve">
          <source>fraction of the asynchronous notification queue currently occupied (0-1)</source>
          <target state="translated">часть асинхронной очереди уведомлений,занятой в данный момент (0-1).</target>
        </trans-unit>
        <trans-unit id="b5b60b504526b12a5eff5f8bd8a0e84a7249041e" translate="yes" xml:space="preserve">
          <source>frequency of this MCV item</source>
          <target state="translated">частота этого предмета MCV</target>
        </trans-unit>
        <trans-unit id="0fd4434dbd8cb20c8f7359b16e3d296dc62d764e" translate="yes" xml:space="preserve">
          <source>from the SQL environment, or:</source>
          <target state="translated">из среды SQL,или:</target>
        </trans-unit>
        <trans-unit id="ba98c5a979f1d430811c4a4f29ea3a0721cf65fc" translate="yes" xml:space="preserve">
          <source>from the shell.</source>
          <target state="translated">из панциря.</target>
        </trans-unit>
        <trans-unit id="280f7dd2055e25f7e89bbec785c710da22de8e5a" translate="yes" xml:space="preserve">
          <source>from the shell. Only the superuser is allowed to create a database for someone else (that is, for a role you are not a member of).</source>
          <target state="translated">из панциря.Только суперпользователю разрешено создавать базу данных для кого-то еще (то есть для роли,в которой вы не участвуете).</target>
        </trans-unit>
        <trans-unit id="15af0e8bf417a69fca0c301e28c0685d91c4b491" translate="yes" xml:space="preserve">
          <source>full capitalized day name (blank-padded to 9 chars)</source>
          <target state="translated">полное название дня с заглавной буквы (пустое,до 9 символов)</target>
        </trans-unit>
        <trans-unit id="c4a997d97658b2cf2b8d26ebdf86435fc5ee3692" translate="yes" xml:space="preserve">
          <source>full capitalized month name (blank-padded to 9 chars)</source>
          <target state="translated">полное название месяца с заглавными буквами (с пустыми кнопками до 9 символов)</target>
        </trans-unit>
        <trans-unit id="5a16a10dfdd5e4a2703b7455bf1f1425a37e5980" translate="yes" xml:space="preserve">
          <source>full lower case day name (blank-padded to 9 chars)</source>
          <target state="translated">полное название дня в нижнем регистре (с пустыми кнопками до 9 символов)</target>
        </trans-unit>
        <trans-unit id="f00512a393e028490b88f3aa5ebbe3549d7e487f" translate="yes" xml:space="preserve">
          <source>full lower case month name (blank-padded to 9 chars)</source>
          <target state="translated">полное название месяца в нижнем регистре (с пустыми кнопками до 9 символов)</target>
        </trans-unit>
        <trans-unit id="42477234123d86e358924810115cf7e4102d895a" translate="yes" xml:space="preserve">
          <source>full upper case day name (blank-padded to 9 chars)</source>
          <target state="translated">полное название дня в верхнем регистре (с пустыми кнопками до 9 символов)</target>
        </trans-unit>
        <trans-unit id="6d1edcedc94dd056218887a634de10777f3b1f06" translate="yes" xml:space="preserve">
          <source>full upper case month name (blank-padded to 9 chars)</source>
          <target state="translated">полное название месяца в верхнем регистре (с пустыми кнопками до 9 символов)</target>
        </trans-unit>
        <trans-unit id="1105c0cc10eb74d7fc4c164ddb5ce386bb49d61b" translate="yes" xml:space="preserve">
          <source>function name</source>
          <target state="translated">название функции</target>
        </trans-unit>
        <trans-unit id="79337461ae50346a3c64aedc6576d26f07d2da99" translate="yes" xml:space="preserve">
          <source>function to merge two elements</source>
          <target state="translated">функция объединения двух элементов</target>
        </trans-unit>
        <trans-unit id="381ba103b087ce725ad29d6fb3167623521eab03" translate="yes" xml:space="preserve">
          <source>function with argument types</source>
          <target state="translated">функция с типами аргументов</target>
        </trans-unit>
        <trans-unit id="d68671ea551cf0ba52601309c38f48f032157b66" translate="yes" xml:space="preserve">
          <source>functions and operators for processing and creating JSON data</source>
          <target state="translated">функции и операторы для обработки и создания данных JSON</target>
        </trans-unit>
        <trans-unit id="2b9a1162c90a10eaa1c1d22357b7148a2281502d" translate="yes" xml:space="preserve">
          <source>functions and procedures</source>
          <target state="translated">функции и процедуры</target>
        </trans-unit>
        <trans-unit id="eb3a477dc4afde1f163053db118d49c3a03b5564" translate="yes" xml:space="preserve">
          <source>further limited by tuple size fitting on a single page; see note below</source>
          <target state="translated">дополнительно ограничивается установкой кортежей на одной странице;см.примечание ниже.</target>
        </trans-unit>
        <trans-unit id="a52bca9149e86a7c11c1c387784ebae5aaedd68c" translate="yes" xml:space="preserve">
          <source>fuzzystrmatch</source>
          <target state="translated">fuzzystrmatch</target>
        </trans-unit>
        <trans-unit id="8c0aaf10dcd6bcacc121f7b404cf2264a1048fdc" translate="yes" xml:space="preserve">
          <source>generation of ancestors at a time t</source>
          <target state="translated">поколение предков одновременно</target>
        </trans-unit>
        <trans-unit id="e9092fbeebad65d675ea2563bb6ea87d206977be" translate="yes" xml:space="preserve">
          <source>generation of descendants at a time t</source>
          <target state="translated">поколение потомков за раз t</target>
        </trans-unit>
        <trans-unit id="8f26ec92a3e06fc1bd67c0ec5e3b881f007ba31d" translate="yes" xml:space="preserve">
          <source>geometric path on a plane</source>
          <target state="translated">геометрическая траектория на плоскости</target>
        </trans-unit>
        <trans-unit id="5ae39128635d531b866a9705ccff8372c2803a08" translate="yes" xml:space="preserve">
          <source>geometric point on a plane</source>
          <target state="translated">геометрическая точка на плоскости</target>
        </trans-unit>
        <trans-unit id="3c5902d9d1907e1e688e601d8dea2602b582cd8e" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE INDEX&lt;/code&gt; command for index</source>
          <target state="translated">получить команду &lt;code&gt;CREATE INDEX&lt;/code&gt; для индекса</target>
        </trans-unit>
        <trans-unit id="a3ec23c0e08fffde0bbe5f680221fb2baaef5bd5" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE INDEX&lt;/code&gt; command for index, or definition of just one index column when &lt;em&gt;&lt;code&gt;column_no&lt;/code&gt;&lt;/em&gt; is not zero</source>
          <target state="translated">получить команду &lt;code&gt;CREATE INDEX&lt;/code&gt; для индекса или определение только одного столбца индекса, если &lt;em&gt; &lt;code&gt;column_no&lt;/code&gt; &lt;/em&gt; не равно нулю</target>
        </trans-unit>
        <trans-unit id="196b69b47830d30e71241d4bd8b0fab2ca945d23" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE RULE&lt;/code&gt; command for rule</source>
          <target state="translated">получить команду &lt;code&gt;CREATE RULE&lt;/code&gt; для правила</target>
        </trans-unit>
        <trans-unit id="2bd218c54320163748989ae51ee788d92b994ad7" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE STATISTICS&lt;/code&gt; command for extended statistics object</source>
          <target state="translated">получить команду &lt;code&gt;CREATE STATISTICS&lt;/code&gt; для объекта расширенной статистики</target>
        </trans-unit>
        <trans-unit id="2dce21084875e338db2211be806cce40af161367" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE [ CONSTRAINT ] TRIGGER&lt;/code&gt; command for trigger</source>
          <target state="translated">получить &lt;code&gt;CREATE [ CONSTRAINT ] TRIGGER&lt;/code&gt; для триггера</target>
        </trans-unit>
        <trans-unit id="af0a1a4c510167b0be953ce464e30ebb21bbb406" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;RETURNS&lt;/code&gt; clause for function (returns null for a procedure)</source>
          <target state="translated">получить предложение &lt;code&gt;RETURNS&lt;/code&gt; для функции (возвращает null для процедуры)</target>
        </trans-unit>
        <trans-unit id="22f30c887b27700ca538951254039e1464d1cdd5" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;aclitem&lt;/code&gt; array as tuples</source>
          <target state="translated">получить массив &lt;code&gt;aclitem&lt;/code&gt; как кортежи</target>
        </trans-unit>
        <trans-unit id="937dcfc31310a1d87c64ad58c35d643c3dbb2cef" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;json&lt;/code&gt; value, but attempt to distinguish numerical and Boolean values so they are unquoted in the JSON</source>
          <target state="translated">получить &lt;code&gt;hstore&lt;/code&gt; как значение &lt;code&gt;json&lt;/code&gt; , но попытаться различать числовые и логические значения, чтобы они не заключались в кавычки в JSON</target>
        </trans-unit>
        <trans-unit id="fe0b67a6cd7df0e277a3dcb3562abb8976f3d94c" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;json&lt;/code&gt; value, converting all non-null values to JSON strings</source>
          <target state="translated">получить &lt;code&gt;hstore&lt;/code&gt; как значение &lt;code&gt;json&lt;/code&gt; , преобразовав все ненулевые значения в строки JSON</target>
        </trans-unit>
        <trans-unit id="6ae7444ae534490ab8b85dfd69c23426f2b097e0" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;jsonb&lt;/code&gt; value, but attempt to distinguish numerical and Boolean values so they are unquoted in the JSON</source>
          <target state="translated">получить &lt;code&gt;hstore&lt;/code&gt; как значение &lt;code&gt;jsonb&lt;/code&gt; , но попытаться различать числовые и логические значения, чтобы они не заключались в кавычки в JSON</target>
        </trans-unit>
        <trans-unit id="e18937d566312b9c933716239bd0a1b2cab0e0bf" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;jsonb&lt;/code&gt; value, converting all non-null values to JSON strings</source>
          <target state="translated">получить &lt;code&gt;hstore&lt;/code&gt; как значение &lt;code&gt;jsonb&lt;/code&gt; , преобразовав все ненулевые значения в строки JSON</target>
        </trans-unit>
        <trans-unit id="9d860c2d98eb0770214f44f458048681c29c6293" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys and values as a set</source>
          <target state="translated">получить ключи и значения &lt;code&gt;hstore&lt;/code&gt; в виде набора</target>
        </trans-unit>
        <trans-unit id="8b81abcbdffa1d36be6f3db92afd0c712b05149f" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys and values as a two-dimensional array</source>
          <target state="translated">получить ключи и значения &lt;code&gt;hstore&lt;/code&gt; в виде двумерного массива</target>
        </trans-unit>
        <trans-unit id="7732475b39d72d6d44dd2efd78c07a49212ac801" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys and values as an array of alternating keys and values</source>
          <target state="translated">получить ключи и значения &lt;code&gt;hstore&lt;/code&gt; в виде массива чередующихся ключей и значений</target>
        </trans-unit>
        <trans-unit id="3f21a27616331d2636099cf4cc88b18f8e29a805" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys as a set</source>
          <target state="translated">получить &lt;code&gt;hstore&lt;/code&gt; в комплекте</target>
        </trans-unit>
        <trans-unit id="dc9a8f1f8f4ef349c79e43b0211eead30fe502f3" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys as an array</source>
          <target state="translated">получить &lt;code&gt;hstore&lt;/code&gt; в виде массива</target>
        </trans-unit>
        <trans-unit id="536f1dece096291af39df61eb1a0b2a7eaf9983d" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s values as a set</source>
          <target state="translated">получить значения &lt;code&gt;hstore&lt;/code&gt; как набор</target>
        </trans-unit>
        <trans-unit id="5251a2aba056bba63a67d56fc4203ed79712e3e4" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s values as an array</source>
          <target state="translated">получить значения &lt;code&gt;hstore&lt;/code&gt; в виде массива</target>
        </trans-unit>
        <trans-unit id="ad8730c72dc5b463ea8cac770153712d6576278e" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;xmax&lt;/code&gt; of snapshot</source>
          <target state="translated">получить &lt;code&gt;xmax&lt;/code&gt; снимка</target>
        </trans-unit>
        <trans-unit id="3ed704a6f174339573cf0c434a1db7a555f66cec" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;xmin&lt;/code&gt; of snapshot</source>
          <target state="translated">получить &lt;code&gt;xmin&lt;/code&gt; снимка</target>
        </trans-unit>
        <trans-unit id="337b585e11d46bb402f4a4cec72193fc16d86d74" translate="yes" xml:space="preserve">
          <source>get SQL name of a data type</source>
          <target state="translated">получить SQL имя типа данных</target>
        </trans-unit>
        <trans-unit id="c2ee42154b8befeb7b402a3997c784dac4cdd3a2" translate="yes" xml:space="preserve">
          <source>get address of a database object from its external representation</source>
          <target state="translated">получить адрес объекта базы данных из его внешнего представления</target>
        </trans-unit>
        <trans-unit id="05dd67a0eb2fea988f4c7bff60b25d5bcfd72760" translate="yes" xml:space="preserve">
          <source>get argument list of function's or procedure's definition (with default values)</source>
          <target state="translated">получить список аргументов определения функции или процедуры (со значениями по умолчанию)</target>
        </trans-unit>
        <trans-unit id="c519a3e8267da358402769c054226a03635c67ee" translate="yes" xml:space="preserve">
          <source>get argument list to identify a function or procedure (without default values)</source>
          <target state="translated">получить список аргументов для идентификации функции или процедуры (без значений по умолчанию)</target>
        </trans-unit>
        <trans-unit id="6b32a6038832e813790af0776307cf7b231fbb8e" translate="yes" xml:space="preserve">
          <source>get comment for a database object</source>
          <target state="translated">получить комментарий к объекту базы данных</target>
        </trans-unit>
        <trans-unit id="362276384bf1063fb473a3d69cd61ec994e9c173" translate="yes" xml:space="preserve">
          <source>get comment for a database object (&lt;em&gt;deprecated&lt;/em&gt;)</source>
          <target state="translated">получить комментарий к объекту базы данных ( &lt;em&gt;устарело&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="fb86807e0f1bd4d25c9ec5a1d13bea140bc18075" translate="yes" xml:space="preserve">
          <source>get comment for a shared database object</source>
          <target state="translated">получить комментарий для объекта общей базы данных</target>
        </trans-unit>
        <trans-unit id="ff9969c90af75d2566e6867dd12ee5fce7632f50" translate="yes" xml:space="preserve">
          <source>get comment for a table column</source>
          <target state="translated">получить комментарий к столбцу таблицы</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
