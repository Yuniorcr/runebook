<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="eac57a1de8acde9c46e58fb564a5c63eef8c02df" translate="yes" xml:space="preserve">
          <source>Some of these new methods do not define bodies.  Servers MUST examine
   all requests for a body, even when a body was not expected.  In cases
   where a request body is present but would be ignored by a server, the
   server MUST reject the request with 415 (Unsupported Media Type).
   This informs the client (which may have been attempting to use an
   extension) that the body could not be processed as the client
   intended.</source>
          <target state="translated">Некоторые из этих новых методов не определяют тела.Серверы ДОЛЖНЫ рассматривать все запросы к телу,даже когда тело не ожидалось.В тех случаях,когда тело запроса присутствует,но сервер игнорирует его,сервер ДОЛЖЕН отклонить запрос с помощью 415 (Unsupported Media Type).Это информирует клиента (который,возможно,пытался использовать расширение)о том,что тело не может быть обработано так,как предполагалось клиентом.</target>
        </trans-unit>
        <trans-unit id="4e4cf2038e1894371084626084a37cd3855e9122" translate="yes" xml:space="preserve">
          <source>Some origin server implementations might not have a clock available.
   An origin server without a clock MUST NOT assign Expires or Last-
   Modified values to a response, unless these values were associated
   with the resource by a system or user with a reliable clock. It MAY
   assign an Expires value that is known, at or before server
   configuration time, to be in the past (this allows &quot;pre-expiration&quot;
   of responses without storing separate Expires values for each
   resource).</source>
          <target state="translated">Некоторые реализации исходных серверов могут не иметь часов.Исходный сервер без часов НЕ ДОЛЖЕН присваивать ответу истечения срока действия или последние измененные значения,если только эти значения не были связаны с ресурсом системой или пользователем с надежными часами.Он МОЖЕТ присвоить значение &quot;Истечение&quot;,которое известно,в или до времени конфигурации сервера,чтобы быть в прошлом (это позволяет &quot;предварительное истечение&quot; ответов без хранения отдельных значений &quot;Истечение&quot; для каждого ресурса).</target>
        </trans-unit>
        <trans-unit id="03c3e50ec8cb12cf3acddc31b3a981323a1ddf6c" translate="yes" xml:space="preserve">
          <source>Some pages may be protected so only specific users can access it. Basic authentication may be provided by HTTP, either using the &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and similar headers, or by setting a specific session using &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt;.</source>
          <target state="translated">Некоторые страницы могут быть защищены, поэтому к ним могут получить доступ только определенные пользователи. Базовая аутентификация может быть предоставлена ​​с помощью HTTP, либо с использованием &lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; и аналогичных заголовков, либо путем установки определенного сеанса с использованием &lt;a href=&quot;cookies&quot;&gt;файлов cookie HTTP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d9fd2b2a9f9cc9b203fa68ab92a78cbe025ac65" translate="yes" xml:space="preserve">
          <source>Some pages may be protected so that only specific users can access them. Basic authentication may be provided by HTTP, either using the &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and similar headers, or by setting a specific session using &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a7d1f4b13e76bd620feb3c514de20a064d7ef93" translate="yes" xml:space="preserve">
          <source>Some proxy servers might need authority to create a tunnel. See also the &lt;a href=&quot;../headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Некоторым прокси-серверам могут потребоваться полномочия для создания туннеля. См. Также заголовок &lt;a href=&quot;../headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f0fe168232211ebb71557e7e371b951b8fb141f8" translate="yes" xml:space="preserve">
          <source>Some requests don&amp;rsquo;t trigger a &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight&lt;/a&gt;. Those are called &amp;ldquo;simple requests&amp;rdquo; in this article, though the &lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt; spec (which defines CORS) doesn&amp;rsquo;t use that term. A request that doesn&amp;rsquo;t trigger a &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight&lt;/a&gt;&amp;mdash;a so-called &amp;ldquo;simple request&amp;rdquo; &amp;mdash; is one that &lt;strong&gt;meets all the following conditions&lt;/strong&gt;:</source>
          <target state="translated">Некоторые запросы не запускают предварительную &lt;a href=&quot;#Preflighted_requests&quot;&gt;проверку CORS&lt;/a&gt; . В этой статье они называются &amp;laquo;простыми запросами&amp;raquo;, хотя в спецификации &lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt; (которая определяет CORS) этот термин не используется. Запрос, который не запускает предварительную &lt;a href=&quot;#Preflighted_requests&quot;&gt;проверку CORS&lt;/a&gt; - так называемый &amp;laquo;простой запрос&amp;raquo; - это тот, который &lt;strong&gt;удовлетворяет всем следующим условиям&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="9dcff009cb4590f1396339dc97ee7e3c2dfd40fa" translate="yes" xml:space="preserve">
          <source>Some requests don&amp;rsquo;t trigger a &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight&lt;/a&gt;. Those are called &lt;em&gt;&amp;ldquo;simple requests&amp;rdquo;&lt;/em&gt; in this article, though the &lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt; spec (which defines CORS) doesn&amp;rsquo;t use that term. A &amp;ldquo;simple request&amp;rdquo; is one that &lt;strong&gt;meets all the following conditions&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7772fe71270600ccf3a3236874e99cde15c3a7" translate="yes" xml:space="preserve">
          <source>Some requests may need more time on the server like sometimes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; requests that are scheduled for later processing. In this case, the response is a &lt;a href=&quot;status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Other) redirect that links to a page indicating that the action has been scheduled, and eventually informs about the progress, or allows to cancel it.</source>
          <target state="translated">Некоторым запросам может потребоваться больше времени на сервере, например, иногда запросам &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; , которые запланированы для последующей обработки. В этом случае ответ представляет собой перенаправление &lt;a href=&quot;status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt; (см. Прочее), которое ссылается на страницу, указывающую, что действие было запланировано, и в конечном итоге информирует о ходе выполнения или позволяет отменить его.</target>
        </trans-unit>
        <trans-unit id="e69ac0ff78ca934a19fc41226c03d69cd112b823" translate="yes" xml:space="preserve">
          <source>Some requests may need more time on the server, like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; requests that are scheduled for later processing. In this case, the response is a &lt;a href=&quot;status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Other) redirect that links to a page indicating that the action has been scheduled, and eventually informs about its progress, or allows to cancel it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932d714aa9986fefde686199be3c38ba8d61e288" translate="yes" xml:space="preserve">
          <source>Some sections of this specification are illustrated with fragments of
   a non-normative RELAX NG Compact schema [&lt;a href=&quot;#ref-RNC&quot;&gt;RNC&lt;/a&gt;].  However, the text of
   this specification provides the definition of conformance.  Complete
   schemas appear in &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;.</source>
          <target state="translated">Некоторые разделы этой спецификации проиллюстрированы фрагментами ненормативной схемы RELAX NG Compact [ &lt;a href=&quot;#ref-RNC&quot;&gt;RNC&lt;/a&gt; ]. Однако в тексте данной спецификации дается определение соответствия. Полные схемы появляются в &lt;a href=&quot;#appendix-B&quot;&gt;приложении Б&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbcfbee9d39daa00061999fcaad831841c2ed71a" translate="yes" xml:space="preserve">
          <source>Some websites use this response for requests they do not wish to handle, such as automated queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1960a9dab8a69c52ce013a2615773d1727df49" translate="yes" xml:space="preserve">
          <source>Sometimes a user agent might want or need to insist that a cache
   revalidate its cache entry with the origin server (and not just with
   the next cache along the path to the origin server), or to reload its
   cache entry from the origin server. End-to-end revalidation might be
   necessary if either the cache or the origin server has overestimated
   the expiration time of the cached response. End-to-end reload may be
   necessary if the cache entry has become corrupted for some reason.

   End-to-end revalidation may be requested either when the client does
   not have its own local cached copy, in which case we call it
   &quot;unspecified end-to-end revalidation&quot;, or when the client does have a
   local cached copy, in which case we call it &quot;specific end-to-end
   revalidation.&quot;

   The client can specify these three kinds of action using Cache-
   Control request directives:

   End-to-end reload
      The request includes a &quot;no-cache&quot; cache-control directive or, for
      compatibility with HTTP/1.0 clients, &quot;Pragma: no-cache&quot;. Field
      names MUST NOT be included with the no-cache directive in a
      request. The server MUST NOT use a cached copy when responding to
      such a request.

   Specific end-to-end revalidation
      The request includes a &quot;max-age=0&quot; cache-control directive, which
      forces each cache along the path to the origin server to
      revalidate its own entry, if any, with the next cache or server.
      The initial request includes a cache-validating conditional with
      the client's current validator.

   Unspecified end-to-end revalidation
      The request includes &quot;max-age=0&quot; cache-control directive, which
      forces each cache along the path to the origin server to
      revalidate its own entry, if any, with the next cache or server.
      The initial request does not include a cache-validating 

      conditional; the first cache along the path (if any) that holds a
      cache entry for this resource includes a cache-validating
      conditional with its current validator.

   max-age
      When an intermediate cache is forced, by means of a max-age=0
      directive, to revalidate its own cache entry, and the client has
      supplied its own validator in the request, the supplied validator
      might differ from the validator currently stored with the cache
      entry. In this case, the cache MAY use either validator in making
      its own request without affecting semantic transparency.

      However, the choice of validator might affect performance. The
      best approach is for the intermediate cache to use its own
      validator when making its request. If the server replies with 304
      (Not Modified), then the cache can return its now validated copy
      to the client with a 200 (OK) response. If the server replies with
      a new entity and cache validator, however, the intermediate cache
      can compare the returned validator with the one provided in the
      client's request, using the strong comparison function. If the
      client's validator is equal to the origin server's, then the
      intermediate cache simply returns 304 (Not Modified). Otherwise,
      it returns the new entity with a 200 (OK) response.

      If a request includes the no-cache directive, it SHOULD NOT
      include min-fresh, max-stale, or max-age.

   only-if-cached
      In some cases, such as times of extremely poor network
      connectivity, a client may want a cache to return only those
      responses that it currently has stored, and not to reload or
      revalidate with the origin server. To do this, the client may
      include the only-if-cached directive in a request. If it receives
      this directive, a cache SHOULD either respond using a cached entry
      that is consistent with the other constraints of the request, or
      respond with a 504 (Gateway Timeout) status. However, if a group
      of caches is being operated as a unified system with good internal
      connectivity, such a request MAY be forwarded within that group of
      caches.

   must-revalidate
      Because a cache MAY be configured to ignore a server's specified
      expiration time, and because a client request MAY include a max-
      stale directive (which has a similar effect), the protocol also
      includes a mechanism for the origin server to require revalidation
      of a cache entry on any subsequent use. When the must-revalidate
      directive is present in a response received by a cache, that cache
      MUST NOT use the entry after it becomes stale to respond to a 

      subsequent request without first revalidating it with the origin
      server. (I.e., the cache MUST do an end-to-end revalidation every
      time, if, based solely on the origin server's Expires or max-age
      value, the cached response is stale.)

      The must-revalidate directive is necessary to support reliable
      operation for certain protocol features. In all circumstances an
      HTTP/1.1 cache MUST obey the must-revalidate directive; in
      particular, if the cache cannot reach the origin server for any
      reason, it MUST generate a 504 (Gateway Timeout) response.

      Servers SHOULD send the must-revalidate directive if and only if
      failure to revalidate a request on the entity could result in
      incorrect operation, such as a silently unexecuted financial
      transaction. Recipients MUST NOT take any automated action that
      violates this directive, and MUST NOT automatically provide an
      unvalidated copy of the entity if revalidation fails.

      Although this is not recommended, user agents operating under
      severe connectivity constraints MAY violate this directive but, if
      so, MUST explicitly warn the user that an unvalidated response has
      been provided. The warning MUST be provided on each unvalidated
      access, and SHOULD require explicit user confirmation.

   proxy-revalidate
      The proxy-revalidate directive has the same meaning as the must-
      revalidate directive, except that it does not apply to non-shared
      user agent caches. It can be used on a response to an
      authenticated request to permit the user's cache to store and
      later return the response without needing to revalidate it (since
      it has already been authenticated once by that user), while still
      requiring proxies that service many users to revalidate each time
      (in order to make sure that each user has been authenticated).
      Note that such authenticated responses also need the public cache
      control directive in order to allow them to be cached at all.</source>
          <target state="translated">Иногда пользовательский агент может захотеть или потребовать,чтобы кэш перепроверял запись в кэше на исходном сервере (а не только на следующем кэше по пути к исходному серверу),или чтобы он перезагрузил запись в кэше с исходного сервера.Повторная проверка может быть необходима,если либо кэш,либо исходный сервер завысили время истечения срока действия ответа в кэше.Полная перезагрузка может быть необходима,если запись в кэше была повреждена по какой-либо причине.Сверхзавершенная переаттестация может быть запрошена либо когда клиент не имеет собственной локальной кэшированной копии,в этом случае мы называем ее &quot;неуказанная сквозная переаттестация&quot;,либо когда клиент имеет локальную кэшированную копию,в этом случае мы называем ее &quot;специфическая сквозная переаттестация&quot;.Клиент может указать эти три вида действий,используя директивы Cache-Control request directives:Сквозная перезагрузка Запрос включает в себя директиву контроля кэша &quot;no-cache&quot; или,для совместимости с клиентами HTTP/1.0,&quot;Pragma:no-cache&quot;.Имена полей НЕ ДОЛЖНЫ включаться в запрос с помощью директивы no-cache.Сервер НЕ ДОЛЖЕН использовать кэшированную копию при ответе на такой запрос.Конкретная сквозная ревизия Запрос включает в себя директиву управления кэшем &quot;max-age=0&quot;,которая заставляет каждый кэш по пути к исходному серверу повторять свою запись,если таковая имеется,со следующим кэшем или сервером.Начальный запрос включает условие проверки кэша с текущим валидатором клиента.Неопределённая сквозная проверка Запрос включает директиву управления кэшем &quot;max-age=0&quot;,которая заставляет каждый кэш по пути к серверу-источнику проверять свой собственный элемент,если таковой имеется,со следующим кэшем или сервером.Исходный запрос не включает условие проверки кэша;первый кэш по пути (если есть),который содержит запись в кэше для этого ресурса,включает условие проверки кэша с текущим валидатором.max-age Когда промежуточный кэш принудительно перепроверяет свою запись в кэше с помощью директивы max-age=0 и клиент предоставил в запрос свой валидатор,предоставленный валидатор может отличаться от валидатора,который хранится в кэше в данный момент.В этом случае кэш MAY использует любой валидатор в своем запросе,не влияя на семантическую прозрачность.Однако,выбор валидатора может повлиять на производительность.Лучше всего промежуточный кэш использовать свой собственный валидатор при выполнении запроса.Если сервер отвечает 304 (не изменен),то кэш может вернуть клиенту свою валидационную копию с ответом 200 (ОК).Если же сервер отвечает новой сущностью и кэширует валидатор,то промежуточный кэш может сравнить возвращенный валидатор с тем,который был указан в запросе клиента,используя функцию сильного сравнения.Если валидатор клиента равен серверу-источнику,то промежуточный кэш просто возвращает 304 (Не изменен).В противном случае он возвращает новую сущность с ответом 200 (OK).Если запрос включает директиву no-cache,он НЕ ДОЛЖЕН включать min-fresh,max-stale или max-age.only-if-cached В некоторых случаях,например,при крайне плохом сетевом подключении,клиент может захотеть,чтобы кэш возвращал только те ответы,которые он в настоящее время сохранил,а не перезагружал или перепроверял с исходным сервером.Для этого клиент может включить директиву only-if-cached в запрос.Если он получает эту директиву,то кэш ДОЛЖЕН либо ответить,используя кэшированную запись,соответствующую другим ограничениям запроса,либо ответить со статусом 504 (Gateway Timeout).Однако,если группа кэшей работает как единая система с хорошим внутренним подключением,такой запрос MAY должен быть переадресован внутри этой группы кэшей.must-revalidate Поскольку кэш MAY должен быть настроен на игнорирование указанного сервером времени истечения срока действия,и поскольку клиентский запрос MAY включает директиву max-stale (которая имеет аналогичный эффект),протокол также включает механизм,при котором сервер-источник требует повторной проверки записи в кэше при любом ее последующем использовании.Когда директива must-revalidate присутствует в ответе,полученном кэшем,этот кэш НЕ ДОЛЖЕН использовать запись после того,как она станет черствой,для ответа на последующий запрос без предварительной переоценки на исходном сервере.(Т.е.,кэш ДОЛЖЕН делать полную проверку каждый раз,если,основываясь исключительно на истечении срока годности или максимальном значении возраста,кэшированный ответ является &quot;черствым&quot;).Директива must-revalidate необходима для поддержки надежной работы определенных функций протокола.При любых обстоятельствах HTTP/1.1 кэш ДОЛЖЕН подчиняться директиве must-revalidate;в частности,если кэш не может по какой-либо причине добраться до исходного сервера,он ДОЛЖЕН сгенерировать ответ 504 (Gateway Timeout-таймаут шлюза).Серверы ДОЛЖНЫ посылать директиву must-revalidate,если и только в том случае,если отказ в повторной проверке запроса на сущность может привести к некорректной работе,например,к беззвучной невыполненной финансовой транзакции.Получатели НЕ ДОЛЖНЫ предпринимать никаких автоматических действий.</target>
        </trans-unit>
        <trans-unit id="f28c6b808e20b5e65f433eb5b11613875d49c1a2" translate="yes" xml:space="preserve">
          <source>Sometimes the requested resource can't be accessed from its canonical location, but it can be accessed from another place. In this case, a temporary redirect can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f13543920ce2519c90532c2d9391d9d564cd65" translate="yes" xml:space="preserve">
          <source>Sometimes the requested resource cannot be accessed from its canonical location, but it can be accessed from another place. In this case, a temporary redirect can be used. Search engine robots don't memorize the new, temporary link. Temporary redirections are also used when creating, updating and deleting resources to present temporary progress pages.</source>
          <target state="translated">Иногда запрашиваемый ресурс не может быть доступен из его канонического расположения,но может быть доступен из другого места.В этом случае может быть использован временный редирект.Роботы поисковых систем не запоминают новую,временную ссылку.Временные перенаправления также используются при создании,обновлении и удалении ресурсов для представления временных страниц прогресса.</target>
        </trans-unit>
        <trans-unit id="d332abe855c0a9991ccf162c5e9b1e9be151b36a" translate="yes" xml:space="preserve">
          <source>Sometimes, the server won't detect it: a redirection loop can spread over several servers which each don't have the full picture. In this case, browsers will detect it and display an error message. Firefox displays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8875e5296a70a5c55485d7837e9b58660f6869" translate="yes" xml:space="preserve">
          <source>Sometimes, the server won't detect it: a redirection loop can spread over several servers which each don't have the full picture. In this case, browsers will detect it and post an error message. Firefox will display:</source>
          <target state="translated">Иногда сервер этого не обнаруживает:цикл перенаправления может распространяться на несколько серверов,каждый из которых не имеет полной картины.В этом случае браузеры обнаружат его и выдадут сообщение об ошибке.Отобразится Firefox:</target>
        </trans-unit>
        <trans-unit id="d82ff801ae9d70ca71f25b3a35123f191863d17a" translate="yes" xml:space="preserve">
          <source>Sometimes, this code indicates that the request can not be processed until the client makes a payment. Originally it was created to enable digital cash or (micro) payment systems and would indicate that the requested content is not available until the client makes a payment. However, no standard use convention exists and different entities use it in different contexts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461f6249960b9f5e0adb518e83fe6728e5a1aa14" translate="yes" xml:space="preserve">
          <source>Source Map Revision 3 Proposal</source>
          <target state="translated">Карта источника Пересмотр 3 Предложение</target>
        </trans-unit>
        <trans-unit id="48a37d9cb6f83141d7762830d6d9b21396138f77" translate="yes" xml:space="preserve">
          <source>Source code of the resource</source>
          <target state="translated">Исходный код ресурса</target>
        </trans-unit>
        <trans-unit id="eddadabaed64a1c9704679bf2c71541b37a9a200" translate="yes" xml:space="preserve">
          <source>SourceMap</source>
          <target state="translated">SourceMap</target>
        </trans-unit>
        <trans-unit id="2eb56be3c2d93cdab0c52e677e3167dfddb30ac5" translate="yes" xml:space="preserve">
          <source>Sources</source>
          <target state="translated">Sources</target>
        </trans-unit>
        <trans-unit id="7c23b0d99698b57c5cb21fafcb8a8daf127386c6" translate="yes" xml:space="preserve">
          <source>Speaker</source>
          <target state="translated">Speaker</target>
        </trans-unit>
        <trans-unit id="65fa5e6b8d558cde85a3a07a4e444c679377961e" translate="yes" xml:space="preserve">
          <source>Special redirections</source>
          <target state="translated">Специальные перенаправления</target>
        </trans-unit>
        <trans-unit id="1432da84229d762b613e72e68e00057a594449c8" translate="yes" xml:space="preserve">
          <source>Specific &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; by the client (&lt;em&gt;server-driven negotiation&lt;/em&gt; or &lt;em&gt;proactive negotiation&lt;/em&gt;), which is the standard way of negotiating a specific kind of resource.</source>
          <target state="translated">Конкретные &lt;a href=&quot;headers&quot;&gt;HTTP-заголовки&lt;/a&gt; клиента ( &lt;em&gt;согласование на основе сервера&lt;/em&gt; или &lt;em&gt;упреждающее согласование&lt;/em&gt; ), что является стандартным способом согласования определенного типа ресурса.</target>
        </trans-unit>
        <trans-unit id="1ccf5d25dfedda0749e3abb6685b56a5fed8013a" translate="yes" xml:space="preserve">
          <source>Specification</source>
          <target state="translated">Specification</target>
        </trans-unit>
        <trans-unit id="0c709f9886c34419d95252da6707fd3dc704a220" translate="yes" xml:space="preserve">
          <source>Specifications</source>
          <target state="translated">Specifications</target>
        </trans-unit>
        <trans-unit id="30d32085a077fd1f486b08c98f4d346c5a6b17fc" translate="yes" xml:space="preserve">
          <source>Specifications and RFCs:</source>
          <target state="translated">Спецификации и КСФ:</target>
        </trans-unit>
        <trans-unit id="07b2551feb0b78f2ae3f0674493bd2ba4c495576" translate="yes" xml:space="preserve">
          <source>Specifies GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE.</source>
          <target state="translated">Определяет ПОСТАВКУ,ГОТОВКУ,ПОСТ,УДАЛЕНИЕ,СОЕДИНЕНИЕ,ВАРИАНТЫ,ТРЕЙС.</target>
        </trans-unit>
        <trans-unit id="c58c8c11265fc2163fd1c23b0043a730d6d564bd" translate="yes" xml:space="preserve">
          <source>Specifies PATCH.</source>
          <target state="translated">Определяет PATCH.</target>
        </trans-unit>
        <trans-unit id="99d3f27b2e59be204c52c5c9fc1e3fd32e5425f2" translate="yes" xml:space="preserve">
          <source>Specifies a URI that may see the timing resources. You can specify multiple origins, separated by commas.</source>
          <target state="translated">Определяет URI,который может видеть временные ресурсы.Вы можете указать несколько источников,разделенных запятыми.</target>
        </trans-unit>
        <trans-unit id="a3dc214da21e1ecdb977da6e15c1694d398e424b" translate="yes" xml:space="preserve">
          <source>Specifies an origin. Only a single origin can be specified.</source>
          <target state="translated">Определяет происхождение.Можно указать только одно происхождение.</target>
        </trans-unit>
        <trans-unit id="0e8dd4aed544a9115516fcba2b2e3d1772b43815" translate="yes" xml:space="preserve">
          <source>Specifies an origin. Only a single origin can be specified. If the server supports clients from multiple origins, it must return the origin for the specific client making the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08522ebb29d8c09aa8e3393f359476bbe00317a0" translate="yes" xml:space="preserve">
          <source>Specifies directives for caching mechanisms in both requests and responses.</source>
          <target state="translated">Определяет директивы для механизмов кэширования как в запросах,так и в ответах.</target>
        </trans-unit>
        <trans-unit id="149c7938c7e3b3f09b90de06c72ca9aaa91e52c2" translate="yes" xml:space="preserve">
          <source>Specifies if a cross-domain policy file (&lt;code&gt;crossdomain.xml&lt;/code&gt;) is allowed. The file may define a policy to grant clients, such as Adobe's Flash Player (now obsolete), Adobe Acrobat, Microsoft Silverlight (now obsolete), or Apache Flex, permission to handle data across domains that would otherwise be restricted due to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;Same-Origin Policy&lt;/a&gt;. See the &lt;a href=&quot;https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html&quot;&gt;Cross-domain Policy File Specification&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ac472e4fe7931170e92aa9f011df74fb8e68f3a" translate="yes" xml:space="preserve">
          <source>Specifies if a cross-domain policy-file (XML) is allowed. The file may define a policy to grant web clients, such as Adobe Flash Player or Adobe Acrobat (e.g. PDF), permission to handle data across domains.</source>
          <target state="translated">Указывает,разрешен ли междоменный полицейский файл (XML).Файл может определять политику предоставления веб-клиентам,таким как Adobe Flash Player или Adobe Acrobat (например,PDF),разрешения на обработку данных между доменами.</target>
        </trans-unit>
        <trans-unit id="b9cbaf8eb79c9b8c4855be6b0eca34e758b86401" translate="yes" xml:space="preserve">
          <source>Specifies one or more protocol-level WebSocket extensions to ask the server to use. Using more than one &lt;code&gt;Sec-WebSocket-Extension&lt;/code&gt; header in a request is permitted; the result is the same as if you included all of the listed extensions in one such header.</source>
          <target state="translated">Задает одно или несколько расширений WebSocket на уровне протокола, которые запрашивают сервер. Допускается использование более одного заголовка &lt;code&gt;Sec-WebSocket-Extension&lt;/code&gt; в запросе; результат будет таким же, как если бы вы включили все перечисленные расширения в один такой заголовок.</target>
        </trans-unit>
        <trans-unit id="e766075910421b2be9ca8f32bfa752ecb587b39f" translate="yes" xml:space="preserve">
          <source>Specifies origins that are allowed to see values of attributes retrieved via features of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing API&lt;/a&gt;, which would otherwise be reported as zero due to cross-origin restrictions.</source>
          <target state="translated">Указывает источники, которым разрешено видеть значения атрибутов, полученных с помощью функций &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing API&lt;/a&gt; , которые в противном случае были бы сообщены как нулевые из-за ограничений на разные источники.</target>
        </trans-unit>
        <trans-unit id="c2ecb07bbcb3e1be14696f3f86b19336ccf2cfdc" translate="yes" xml:space="preserve">
          <source>Specifies the URI to which the user agent should report Expect-CT failures.</source>
          <target state="translated">Указывает URI,по которому пользовательский агент должен сообщать о сбоях Expect-CT.</target>
        </trans-unit>
        <trans-unit id="df8493e883fbdc515ef9ca1b5b0866d3e58f3660" translate="yes" xml:space="preserve">
          <source>Specifies the WebSocket protocol version the client wishes to use, so the server can confirm whether or not that version is supported on its end.</source>
          <target state="translated">Указание версии протокола WebSocket,которую клиент желает использовать,чтобы сервер мог подтвердить,поддерживается ли эта версия на его конце.</target>
        </trans-unit>
        <trans-unit id="6b4be09a1adcb38cab1a0e2686022154d066d8ba" translate="yes" xml:space="preserve">
          <source>Specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening.</source>
          <target state="translated">Указание доменного имени сервера (для виртуального хостинга)и (опционально)номера TCP-порта,на котором прослушивается сервер.</target>
        </trans-unit>
        <trans-unit id="efd15c591f12965b47534e1779aff0b7120829dc" translate="yes" xml:space="preserve">
          <source>Specifies the form of encoding used to safely transfer the entity to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413e001d0b162dbca41b0e7d35c867d5721df5a5" translate="yes" xml:space="preserve">
          <source>Specifies the lifetime of the policy, in seconds (in a similar way to e.g. HSTS policies are time-restricted). The referenced reporting group should have a lifetime at least as long as the NEL policy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d52f387eaf11730a59df918d4e3a112a2d99212" translate="yes" xml:space="preserve">
          <source>Specifies the maximum amount of time a resource will be considered fresh. Contrary to &lt;code&gt;Expires&lt;/code&gt;, this directive is relative to the time of the request.</source>
          <target state="translated">Задает максимальное время, в течение которого ресурс будет считаться свежим. В отличие от &lt;code&gt;Expires&lt;/code&gt; , эта директива относится ко времени запроса.</target>
        </trans-unit>
        <trans-unit id="6fef4478d76a150d6928212783b2ee9858bcd272" translate="yes" xml:space="preserve">
          <source>Specifies the method or methods allowed when accessing the resource in response to a preflight request.</source>
          <target state="translated">Определяет метод или методы,разрешенные при доступе к ресурсу в ответ на предполетный запрос.</target>
        </trans-unit>
        <trans-unit id="495731834481a81b8123951704e2abcb07625db8" translate="yes" xml:space="preserve">
          <source>Specifies the methods allowed when accessing the resource in response to a preflight request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa52c5dd51b37dc7727111c50a8217213608ca08" translate="yes" xml:space="preserve">
          <source>Specifies the number of seconds after reception of the &lt;code&gt;Expect-CT&lt;/code&gt; header field during which the user agent should regard the host from whom the message was received as a known Expect-CT host.</source>
          <target state="translated">Задает количество секунд после приема поля заголовка &lt;code&gt;Expect-CT&lt;/code&gt; ,в течение которых пользовательский агент должен рассматривать хост, от которого было получено сообщение, как известный хост Expect-CT.</target>
        </trans-unit>
        <trans-unit id="7f43b9fd51101abb87a0368fc81d197d96a63735" translate="yes" xml:space="preserve">
          <source>Specifies the origin &quot;null&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea81d80712300e661852f0c6af12a440f390050" translate="yes" xml:space="preserve">
          <source>Specifies the the form of encoding used to safely transfer the entity to the user.</source>
          <target state="translated">Указывает форму кодирования,используемую для безопасной передачи сущности пользователю.</target>
        </trans-unit>
        <trans-unit id="835c2397154f468b4c8ef93ba4c3e1aa7f2607eb" translate="yes" xml:space="preserve">
          <source>Specifies the transfer encodings the user agent is willing to accept.</source>
          <target state="translated">Указание кодировок передачи,которые пользовательский агент готов принять.</target>
        </trans-unit>
        <trans-unit id="f30f059c03d4c3da1b77bd03fc6d7ad013fb12f4" translate="yes" xml:space="preserve">
          <source>Specifies those hosts to which the cookie will be sent. If not specified, defaults to the host portion of the current document location (but not including subdomains). Contrary to earlier specifications, leading dots in domain names are ignored. If a domain is specified, subdomains are always included.</source>
          <target state="translated">Определяет те хосты,на которые будет отправлен куки-файл.Если не указано,по умолчанию устанавливается хост-часть текущего местоположения документа (но не включая субдомены).В отличие от предыдущих спецификаций,ведущие точки в доменных именах игнорируются.Если домен указан,то субдомены всегда включаются.</target>
        </trans-unit>
        <trans-unit id="24167ab34816aa2157df161d6a2bd98aa1704455" translate="yes" xml:space="preserve">
          <source>Specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Указывает допустимых родителей, которые могут встраивать страницу с помощью &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa0df1c3795d4cdda9e9d0ae70ecf55400bafbc" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/WebRTC_API&quot;&gt;WebRTC&lt;/a&gt; connections.</source>
          <target state="translated">Указывает допустимые источники для соединений &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/WebRTC_API&quot;&gt;WebRTC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a90c719345e0d3bc78bace4ab1d3f64767f076c" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">Указывает допустимые источники для &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; , SharedWorker или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d098bd02b96b2bdcbdaec1bb10a529856955c4ce" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6311b937bff61b4874ab442d4d9dbb9f3cc22f" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript inline event handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd49e94946949bc3d24a4291eb9f90caffd7e887" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript.</source>
          <target state="translated">Указание допустимых источников для JavaScript.</target>
        </trans-unit>
        <trans-unit id="282bf5eae963adccbd6d47d68520fe0a5c79b871" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Указывает допустимые источники для шрифтов, загружаемых с использованием &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db33d91daba98ebe85d45f79cd3a62539127fa18" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for inline styles applied to individual DOM elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f23c7f28c98c835d7c0a52c0e41c358dd15a49" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">Указывает допустимые источники для загрузки мультимедиа с помощью элементов &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt; &lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9dc2e0e19fce72e5227e4ed05399840422564be0" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Указывает допустимые источники для загрузки вложенных контекстов просмотра с использованием таких элементов, как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae55d19529942a4f7114ca5f6d12086fa3126f81" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for stylesheets &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; elements with &lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04b49e22cf0a5230eea588841a8a2b455c0bc3e" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for stylesheets.</source>
          <target state="translated">Определяет действительные источники для таблиц стилей.</target>
        </trans-unit>
        <trans-unit id="c02deee0c3b25ce48a3b98b60fb3aad61652b709" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">Задает допустимые источники для элементов &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb673b2f31b191ea53966ff7ae48df6affc89e62" translate="yes" xml:space="preserve">
          <source>Specifies valid sources of application manifest files.</source>
          <target state="translated">Определяет действительные источники файлов манифестов приложений.</target>
        </trans-unit>
        <trans-unit id="2eb2af79b8a1a437680d977178946925ebbf2f7f" translate="yes" xml:space="preserve">
          <source>Specifies valid sources of images and favicons.</source>
          <target state="translated">Указаны действительные источники изображений и фаворитов.</target>
        </trans-unit>
        <trans-unit id="70ea0caeb914719c42a473dfe61a551bfbb951e5" translate="yes" xml:space="preserve">
          <source>Specifies valid sources to be prefetched or prerendered.</source>
          <target state="translated">Определяет допустимые источники,которые должны быть предварительно выбраны или предотправлены.</target>
        </trans-unit>
        <trans-unit id="951baad47e3b7bd99fb8056c2485c87379c7b510" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;no-cache&lt;/code&gt; or &lt;code&gt;max-age=0&lt;/code&gt; indicates that clients can cache a resource and must revalidate each time before using it. This means HTTP request occurs each time, but it can skip downloading HTTP body if the content is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e61777977f07fdafd61735735d76ae50997e152" translate="yes" xml:space="preserve">
          <source>Specifying a fallback policy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3835c694b3a6ee97cfe71fb0cd1c9d794f4e48c3" translate="yes" xml:space="preserve">
          <source>Specifying legacy document modes*</source>
          <target state="translated">Указание устаревших режимов работы с документами*</target>
        </trans-unit>
        <trans-unit id="85f30ba6e5f19f51628bda67d9500dab94232f9a" translate="yes" xml:space="preserve">
          <source>Specifying multiple links</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f65d134dfe7e03e4b9a14898c4ef7cc4877bc321" translate="yes" xml:space="preserve">
          <source>Specifying multiple values is only supported in the &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header, and not in the &lt;code&gt;referrerpolicy&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bf4478d33594d8d9be5cf924dffa2d49ead910" translate="yes" xml:space="preserve">
          <source>Specifying your policy</source>
          <target state="translated">Указание вашей политики</target>
        </trans-unit>
        <trans-unit id="f8a58e6474d46ef9548c5cf3e20d0bdc3d838946" translate="yes" xml:space="preserve">
          <source>Standard &lt;code&gt;Cache-Control&lt;/code&gt; directives that can be used by the client in an HTTP request.</source>
          <target state="translated">Стандартные директивы &lt;code&gt;Cache-Control&lt;/code&gt; , которые могут использоваться клиентом в HTTP-запросе.</target>
        </trans-unit>
        <trans-unit id="fc62e8bea8948c4f2c38c80d531e6ec6bc0f979f" translate="yes" xml:space="preserve">
          <source>Standard &lt;code&gt;Cache-Control&lt;/code&gt; directives that can be used by the server in an HTTP response.</source>
          <target state="translated">Стандартные директивы &lt;code&gt;Cache-Control&lt;/code&gt; , которые могут использоваться сервером в ответе HTTP.</target>
        </trans-unit>
        <trans-unit id="7e4f48b87246ae2a22b36e2b02bbe847fa77f9da" translate="yes" xml:space="preserve">
          <source>Standardized methods are generic; that is, they are potentially
   applicable to any resource, not just one particular media type, kind
   of resource, or application.  As such, it is preferred that new
   methods be registered in a document that isn't specific to a single
   application or data format, since orthogonal technologies deserve
   orthogonal specification.

   Since message parsing (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7230]&lt;/a&gt;) needs to be
   independent of method semantics (aside from responses to HEAD),
   definitions of new methods cannot change the parsing algorithm or
   prohibit the presence of a message body on either the request or the
   response message.  Definitions of new methods can specify that only a
   zero-length message body is allowed by requiring a Content-Length
   header field with a value of &quot;0&quot;.

   A new method definition needs to indicate whether it is safe
   (&lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;), idempotent (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;), cacheable
   (&lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;), what semantics are to be associated with the payload
   body if any is present in the request and what refinements the method
   makes to header field or status code semantics.  If the new method is
   cacheable, its definition ought to describe how, and under what
   conditions, a cache can store a response and use it to satisfy a
   subsequent request.  The new method ought to describe whether it can
   be made conditional (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;) and, if so, how a server responds
   when the condition is false.  Likewise, if the new method might have
   some use for partial response semantics ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]), it ought to
   document this, too.

      Note: Avoid defining a method name that starts with &quot;M-&quot;, since
      that prefix might be misinterpreted as having the semantics
      assigned to it by [&lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC2774&lt;/a&gt;].</source>
          <target state="translated">Стандартизированные методы являются общими; то есть они потенциально применимы к любому ресурсу, а не только к одному конкретному типу мультимедиа, виду ресурса или приложению. Таким образом, предпочтительно, чтобы новые методы были зарегистрированы в документе, который не является специфическим для одного приложения или формата данных, поскольку ортогональные технологии заслуживают ортогональной спецификации. С момента синтаксического анализа сообщения ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;раздел 3.3 [RFC7230]&lt;/a&gt;) должен быть независимым от семантики метода (помимо ответов на HEAD), определения новых методов не могут изменить алгоритм синтаксического анализа или запретить присутствие тела сообщения ни в запросе, ни в ответном сообщении. Определения новых методов могут указывать, что допускается только тело сообщения нулевой длины, требуя для поля заголовка Content-Length значение &amp;laquo;0&amp;raquo;. Новое определение метода должно указывать, является ли он безопасным ( &lt;a href=&quot;#section-4.2.1&quot;&gt;Раздел 4.2.1&lt;/a&gt; ), идемпотентным ( &lt;a href=&quot;#section-4.2.2&quot;&gt;Раздел 4.2.2&lt;/a&gt; ), кешируемым ( &lt;a href=&quot;#section-4.2.3&quot;&gt;Раздел 4.2.3).&lt;/a&gt;), какая семантика должна быть связана с телом полезной нагрузки, если таковая присутствует в запросе, и какие уточнения метод вносит в поле заголовка или семантику кода состояния. Если новый метод является кэшируемым, его определение должно описывать, как и при каких условиях кеш может хранить ответ и использовать его для удовлетворения последующего запроса. Новый метод должен описывать, можно ли сделать его условным ( &lt;a href=&quot;#section-5.2&quot;&gt;раздел 5.2&lt;/a&gt; ), и если да, то как сервер реагирует, когда условие ложно. Аналогичным образом, если новый метод может быть использован для семантики частичного ответа ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]), это тоже должно задокументировать. Примечание. Избегайте определения имени метода, которое начинается с &amp;laquo;M-&amp;raquo;, поскольку этот префикс может быть неверно истолкован как имеющий семантику, назначенную ему [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC2774&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="ec725f8ba620a293e9d02360be092dd295c3b54d" translate="yes" xml:space="preserve">
          <source>Start line</source>
          <target state="translated">линия старта</target>
        </trans-unit>
        <trans-unit id="e030402b999a37d4c6eb9f51e15b86c192ade5a6" translate="yes" xml:space="preserve">
          <source>Starting in Chrome 61, this applies to all of a frame's ancestors.</source>
          <target state="translated">Начиная с хрома 61,это относится ко всем предкам рамы.</target>
        </trans-unit>
        <trans-unit id="47374f68a6da45b7e6165e2b0f9740a82e30b4ff" translate="yes" xml:space="preserve">
          <source>Starting in Firefox 59, this applies to all of a frame's ancestors.</source>
          <target state="translated">Начиная с Firefox 59,это относится ко всем предкам кадра.</target>
        </trans-unit>
        <trans-unit id="6cbdee7a264558eb88d25ed8d267e476fca05cb7" translate="yes" xml:space="preserve">
          <source>Starting in Opera 48, this applies to all of a frame's ancestors.</source>
          <target state="translated">Начиная с Оперы 48,это относится ко всем предкам кадра.</target>
        </trans-unit>
        <trans-unit id="b6deb6ef9aab80647d8c2b91f6b9f8ab6cffc3c1" translate="yes" xml:space="preserve">
          <source>Starting in Version 6, users can opt into using a GeckoView-based Focus for Android with a hidden preference: it uses a GeckoView UA string to advertise Gecko compatibility.</source>
          <target state="translated">Начиная с версии 6,пользователи могут использовать GeckoView на основе Focus для Android со скрытыми предпочтениями:он использует строку GeckoView UA для рекламы совместимости с Gecko.</target>
        </trans-unit>
        <trans-unit id="2767241100a2bb66d29b7ccd151257fc78abe38a" translate="yes" xml:space="preserve">
          <source>Starting with Chrome 52 and Firefox 52, insecure sites (&lt;code&gt;http:&lt;/code&gt;) can't set cookies with the &quot;secure&quot; directive anymore.</source>
          <target state="translated">Начиная с Chrome 52 и Firefox 52 небезопасные сайты ( &lt;code&gt;http:&lt;/code&gt; ) больше не могут устанавливать файлы cookie с помощью директивы secure.</target>
        </trans-unit>
        <trans-unit id="2777fe7b39631e05febcca00592a28a86bb5182f" translate="yes" xml:space="preserve">
          <source>Starting with Chrome 52 and Firefox 52, insecure sites (&lt;code&gt;http:&lt;/code&gt;) can't set cookies with the &lt;code&gt;Secure&lt;/code&gt; attribute anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7d21aec22143da2cc4da25c435e7bb29874f8d" translate="yes" xml:space="preserve">
          <source>Starting with Firefox 72, the opting out of MIME sniffing is also applied to top-level documents if a &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-type&lt;/code&gt;&lt;/a&gt; is provided. This can cause HTML web pages to be downloaded instead of being rendered when they are served with a MIME type other than &lt;code&gt;text/html&lt;/code&gt;. Make sure to set both headers correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae7d5be70820ed56467bd9a63744e23b47bd711" translate="yes" xml:space="preserve">
          <source>Status</source>
          <target state="translated">Status</target>
        </trans-unit>
        <trans-unit id="f7b7abf0e2e9d417ae8391f4a4fe7d726ce87d19" translate="yes" xml:space="preserve">
          <source>Status Code Definitions (RFC 2616)</source>
          <target state="translated">Определения кода статуса (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="79f8bb09cc70b71ab1e11fda8d1499287de0d9e4" translate="yes" xml:space="preserve">
          <source>Status line</source>
          <target state="translated">Строка состояния</target>
        </trans-unit>
        <trans-unit id="8f42525bc1bf257516b4843747d743c365504980" translate="yes" xml:space="preserve">
          <source>Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   The Atom Publishing Protocol (AtomPub) is an application-level
   protocol for publishing and editing Web resources.  The protocol is
   based on HTTP transfer of Atom-formatted representations.  The Atom
   format is documented in the Atom Syndication Format. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Notational Conventions 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. XML-Related Conventions 
           &lt;a href=&quot;#section-2.1.1&quot;&gt;2.1.1&lt;/a&gt;. Referring to Information Items 
           &lt;a href=&quot;#section-2.1.2&quot;&gt;2.1.2&lt;/a&gt;. RELAX NG Schema 
           &lt;a href=&quot;#section-2.1.3&quot;&gt;2.1.3&lt;/a&gt;. Use of &quot;xml:base&quot; and &quot;xml:lang&quot; 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Terminology 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Protocol Model 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. Identity and Naming 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Documents and Resource Classification 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Control and Publishing 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Client Implementation Considerations 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Protocol Operations 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Retrieving a Service Document 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Listing Collection Members 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Creating a Resource 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Editing a Resource 
           &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt;. Retrieving a Resource 
           &lt;a href=&quot;#section-5.4.2&quot;&gt;5.4.2&lt;/a&gt;. Editing a Resource 
           &lt;a href=&quot;#section-5.4.3&quot;&gt;5.4.3&lt;/a&gt;. Deleting a Resource 
      &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;. Use of HTTP Response Codes 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Protocol Documents 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Document Types 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Document Extensibility 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Category Documents 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Element Definitions 
           &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;. The &quot;app:categories&quot; Element 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. Service Documents 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Workspaces 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. Element Definitions 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. The &quot;app:service&quot; Element 
           &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt;. The &quot;app:workspace&quot; Element 
           &lt;a href=&quot;#section-8.3.3&quot;&gt;8.3.3&lt;/a&gt;. The &quot;app:collection&quot; Element 
           &lt;a href=&quot;#section-8.3.4&quot;&gt;8.3.4&lt;/a&gt;. The &quot;app:accept&quot; Element 
           &lt;a href=&quot;#section-8.3.5&quot;&gt;8.3.5&lt;/a&gt;. Usage in Atom Feed Documents 
           &lt;a href=&quot;#section-8.3.6&quot;&gt;8.3.6&lt;/a&gt;. The &quot;app:categories&quot; Element 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Creating and Editing Resources 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. Member URIs 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. Creating Resources with POST 
           &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. Editing Resources with PUT 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. Deleting Resources with DELETE 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. Caching and Entity Tags 
           &lt;a href=&quot;#section-9.5.1&quot;&gt;9.5.1&lt;/a&gt;. Example ............................................ 

      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. Media Resources and Media Link Entries 
           &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;. Examples 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. The Slug Header 
           &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;. Slug Header Syntax 
           &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;. Example 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. Listing Collections 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. Collection Partial Lists 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. The &quot;app:edited&quot; Element 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. Atom Format Link Relation Extensions 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. The &quot;edit&quot; Link Relation 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. The &quot;edit-media&quot; Link Relation 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;. The Atom Format Type Parameter 
      &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;. The &quot;type&quot; parameter 
           &lt;a href=&quot;#section-12.1.1&quot;&gt;12.1.1&lt;/a&gt;. Conformance 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;. Atom Publishing Controls 
      &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;. The &quot;app:control&quot; Element 
           &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt;. The &quot;app:draft&quot; Element 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;. Securing the Atom Publishing Protocol 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt;. Denial of Service 
      &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt;. Replay Attacks 
      &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt;. Spoofing Attacks 
      &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt;. Linked Resources 
      &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt;. Digital Signatures and Encryption 
      &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt;. URIs and IRIs 
      &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt;. Code Injection and Cross Site Scripting 
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-16.1&quot;&gt;16.1&lt;/a&gt;. Content-Type Registration for 'application/atomcat+xml' ..39
      &lt;a href=&quot;#section-16.2&quot;&gt;16.2&lt;/a&gt;. Content-Type Registration for 'application/atomsvc+xml' ..40
      &lt;a href=&quot;#section-16.3&quot;&gt;16.3&lt;/a&gt;. Header Field Registration for 'SLUG' 
      &lt;a href=&quot;#section-16.4&quot;&gt;16.4&lt;/a&gt;. The Link Relation Registration &quot;edit&quot; 
      &lt;a href=&quot;#section-16.5&quot;&gt;16.5&lt;/a&gt;. The Link Relation Registration &quot;edit-media&quot; 
      &lt;a href=&quot;#section-16.6&quot;&gt;16.6&lt;/a&gt;. The Atom Format Media Type Parameter 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;. References 
      &lt;a href=&quot;#section-17.1&quot;&gt;17.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-17.2&quot;&gt;17.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Contributors 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. RELAX NG Compact Schema ...............................</source>
          <target state="translated">Статус этой памятки В этом документе определяется протокол отслеживания стандартов Интернета для Интернет-сообщества, а также предлагается обсуждение и предложения по улучшениям. См. Текущую редакцию &amp;laquo;Официальных стандартов протокола Интернета&amp;raquo; (STD 1), чтобы узнать о состоянии стандартизации и статусе этого протокола. Распространение этой памятки не ограничено. Аннотация Протокол публикации Atom (AtomPub) - это протокол уровня приложения для публикации и редактирования веб-ресурсов. Протокол основан на HTTP-передаче представлений в формате Atom. Формат Atom задокументирован в формате Atom Syndication Format. Содержание &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . Введение &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . Условные обозначения &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; . Соглашения, связанные с XML &lt;a href=&quot;#section-2.1.1&quot;&gt;2.1.1&lt;/a&gt; . Ссылаясь на информационные элементы &lt;a href=&quot;#section-2.1.2&quot;&gt;2.1.2&lt;/a&gt; . Схема RELAX NG &lt;a href=&quot;#section-2.1.3&quot;&gt;2.1.3&lt;/a&gt; . Использование &amp;laquo;xml: base&amp;raquo; и &amp;laquo;xml: lang&amp;raquo; &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . Терминология &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . Модель протокола &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . Идентичность и наименование &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . Документы и классификация ресурсов &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . Управление и публикация &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; . Соображения по реализации клиента &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; . Протоколные операции &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; . Получение сервисного документа &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; . Список участников Коллекции &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; . Создание ресурса &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;, Редактирование ресурса &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt; . Получение ресурса &lt;a href=&quot;#section-5.4.2&quot;&gt;5.4.2&lt;/a&gt; . Редактирование ресурса &lt;a href=&quot;#section-5.4.3&quot;&gt;5.4.3&lt;/a&gt; . Удаление ресурса &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt; . Использование кодов ответа HTTP &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . Протоколные документы &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; . Типы документов &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; . Расширяемость документа &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . Категория Документы &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; . Пример &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; . Определения элементов &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt; . Элемент &amp;laquo;приложение: категории&amp;raquo; &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . Сервисная документация &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; . Рабочие пространства &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; . Пример &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;, Определения элементов &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt; . Элемент &quot;app: service&quot; &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt; . Элемент &quot;app: workspace&quot; &lt;a href=&quot;#section-8.3.3&quot;&gt;8.3.3&lt;/a&gt; . Элемент &quot;app: collection&quot; &lt;a href=&quot;#section-8.3.4&quot;&gt;8.3.4&lt;/a&gt; . Элемент &quot;app: accept&quot; &lt;a href=&quot;#section-8.3.5&quot;&gt;8.3.5&lt;/a&gt; . Использование в документах Atom Feed &lt;a href=&quot;#section-8.3.6&quot;&gt;8.3.6&lt;/a&gt; . Элемент &amp;laquo;приложение: категории&amp;raquo; &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; . Создание и редактирование ресурсов &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; . URI участников &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; . Создание ресурсов с помощью POST &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt; . Пример &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; . Редактирование ресурсов с помощью PUT &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt; . Удаление ресурсов с помощью DELETE&lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt; . Кэширование и теги сущностей &lt;a href=&quot;#section-9.5.1&quot;&gt;9.5.1&lt;/a&gt; . Пример ........................................... &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; . Медиа-ресурсы и медиа-ссылки &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt; . Примеры &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt; . Заголовок Slug &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt; . Синтаксис заголовка &lt;a href=&quot;#section-9.7.2&quot;&gt;слага 9.7.2&lt;/a&gt; . Пример &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; . Коллекции листинга &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; . Сборник частичных списков &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; . Элемент &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; &quot;приложение: отредактировано&quot; . Расширения связи формата Atom &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt; . Связь ссылок &quot;редактировать&quot; &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt; . Связь &quot;редактировать-медиа&quot; &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt; . Параметр типа формата Atom &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt; . Параметр &amp;laquo;тип&amp;raquo; &lt;a href=&quot;#section-12.1.1&quot;&gt;12.1.1&lt;/a&gt; . Соответствие &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt; . Элементы управления публикацией Atom &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt; . Элемент &quot;app: control&quot; &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt; . Элемент &amp;laquo;app: draft&amp;raquo; &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt; . Защита протокола публикации Atom &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt; . Соображения безопасности &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt; . Отказ в обслуживании &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt; . Воспроизведение атак &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt; . Спуфинговые атаки &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt; . Связанные ресурсы &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt; . Цифровые подписи и шифрование &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt; . URI и IRI &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt; . Внедрение кода и межсайтовый скриптинг &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt; . Соображения IANA &lt;a href=&quot;#section-16.1&quot;&gt;16.1&lt;/a&gt; . Регистрация типа содержимого для 'application / atomcat + xml' ..39 &lt;a href=&quot;#section-16.2&quot;&gt;16.2&lt;/a&gt; . Регистрация типа содержимого для 'application / atomvc + xml' ..40 &lt;a href=&quot;#section-16.3&quot;&gt;16.3&lt;/a&gt; . Регистрация поля заголовка для &amp;laquo;SLUG&amp;raquo; &lt;a href=&quot;#section-16.4&quot;&gt;16.4&lt;/a&gt; . Регистрация связи ссылок &quot;править&quot; &lt;a href=&quot;#section-16.5&quot;&gt;16.5&lt;/a&gt; . Регистрация связи &quot;edit-media&quot; &lt;a href=&quot;#section-16.6&quot;&gt;16.6&lt;/a&gt; . Параметр типа носителя формата Atom &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt; . Ссылки &lt;a href=&quot;#section-17.1&quot;&gt;17.1&lt;/a&gt; . Нормативные ссылки &lt;a href=&quot;#section-17.2&quot;&gt;17.2&lt;/a&gt; . Информационные ссылки &lt;a href=&quot;#appendix-A&quot;&gt;Приложение A&lt;/a&gt;, Авторы &lt;a href=&quot;#appendix-B&quot;&gt;Приложение B&lt;/a&gt; . Компактная схема RELAX NG ...............................</target>
        </trans-unit>
        <trans-unit id="bba4ada33d7f6d8a86341c33e255f61ec01eb34d" translate="yes" xml:space="preserve">
          <source>Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The IETF Trust (2007).

Abstract

   Web Distributed Authoring and Versioning (WebDAV) consists of a set
   of methods, headers, and content-types ancillary to HTTP/1.1 for the
   management of resource properties, creation and management of
   resource collections, URL namespace manipulation, and resource
   locking (collision avoidance).

   &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; was published in February 1999, and this specification
   obsoletes &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; with minor revisions mostly due to
   interoperability experience. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Notational Conventions 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Terminology 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Data Model for Resource Properties 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. The Resource Property Model 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Properties and HTTP Headers 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Property Values 
           &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt;. Example - Property with Mixed Content 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Property Names 
      &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt;. Source Resources and Output Resources 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Collections of Web Resources 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. HTTP URL Namespace Model 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Collection Resources 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Locking 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Lock Model 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Exclusive vs. Shared Locks 
      &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;. Required Support 
      &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt;. Lock Creator and Privileges 
      &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt;. Lock Tokens 
      &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;. Lock Timeout 
      &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt;. Lock Capability Discovery 
      &lt;a href=&quot;#section-6.8&quot;&gt;6.8&lt;/a&gt;. Active Lock Discovery 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Write Lock 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Write Locks and Properties 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Avoiding Lost Updates 
      &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;. Write Locks and Unmapped URLs 
      &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt;. Write Locks and Collections 
      &lt;a href=&quot;#section-7.5&quot;&gt;7.5&lt;/a&gt;. Write Locks and the If Request Header 
           &lt;a href=&quot;#section-7.5.1&quot;&gt;7.5.1&lt;/a&gt;. Example - Write Lock and COPY 
           7.5.2. Example - Deleting a Member of a Locked
                  Collection 
      &lt;a href=&quot;#section-7.6&quot;&gt;7.6&lt;/a&gt;. Write Locks and COPY/MOVE 
      &lt;a href=&quot;#section-7.7&quot;&gt;7.7&lt;/a&gt;. Refreshing Write Locks 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. General Request and Response Handling 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Precedence in Error Handling 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Use of XML 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. URL Handling 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. Example - Correct URL Handling 
      &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;. Required Bodies in Requests 
      &lt;a href=&quot;#section-8.5&quot;&gt;8.5&lt;/a&gt;. HTTP Headers for Use in WebDAV 
      &lt;a href=&quot;#section-8.6&quot;&gt;8.6&lt;/a&gt;. ETag 
      &lt;a href=&quot;#section-8.7&quot;&gt;8.7&lt;/a&gt;. Including Error Response Bodies 
      &lt;a href=&quot;#section-8.8&quot;&gt;8.8&lt;/a&gt;. Impact of Namespace Operations on Cache Validators 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. HTTP Methods for Distributed Authoring 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. PROPFIND Method 
           &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;. PROPFIND Status Codes .............................. 

           &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;. Status Codes for Use in 'propstat' Element 
           &lt;a href=&quot;#section-9.1.3&quot;&gt;9.1.3&lt;/a&gt;. Example - Retrieving Named Properties 
           9.1.4. Example - Using 'propname' to Retrieve All
                  Property Names 
           &lt;a href=&quot;#section-9.1.5&quot;&gt;9.1.5&lt;/a&gt;. Example - Using So-called 'allprop' 
           &lt;a href=&quot;#section-9.1.6&quot;&gt;9.1.6&lt;/a&gt;. Example - Using 'allprop' with 'include' 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. PROPPATCH Method 
           &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;. Status Codes for Use in 'propstat' Element 
           &lt;a href=&quot;#section-9.2.2&quot;&gt;9.2.2&lt;/a&gt;. Example - PROPPATCH 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. MKCOL Method 
           &lt;a href=&quot;#section-9.3.1&quot;&gt;9.3.1&lt;/a&gt;. MKCOL Status Codes 
           &lt;a href=&quot;#section-9.3.2&quot;&gt;9.3.2&lt;/a&gt;. Example - MKCOL 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. GET, HEAD for Collections 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. POST for Collections 
      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. DELETE Requirements 
           &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;. DELETE for Collections 
           &lt;a href=&quot;#section-9.6.2&quot;&gt;9.6.2&lt;/a&gt;. Example - DELETE 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. PUT Requirements 
           &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;. PUT for Non-Collection Resources 
           &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;. PUT for Collections 
      &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;. COPY Method 
           &lt;a href=&quot;#section-9.8.1&quot;&gt;9.8.1&lt;/a&gt;. COPY for Non-collection Resources 
           &lt;a href=&quot;#section-9.8.2&quot;&gt;9.8.2&lt;/a&gt;. COPY for Properties 
           &lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt;. COPY for Collections 
           &lt;a href=&quot;#section-9.8.4&quot;&gt;9.8.4&lt;/a&gt;. COPY and Overwriting Destination Resources 
           &lt;a href=&quot;#section-9.8.5&quot;&gt;9.8.5&lt;/a&gt;. Status Codes 
           &lt;a href=&quot;#section-9.8.6&quot;&gt;9.8.6&lt;/a&gt;. Example - COPY with Overwrite 
           &lt;a href=&quot;#section-9.8.7&quot;&gt;9.8.7&lt;/a&gt;. Example - COPY with No Overwrite 
           &lt;a href=&quot;#section-9.8.8&quot;&gt;9.8.8&lt;/a&gt;. Example - COPY of a Collection 
      &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;. MOVE Method 
           &lt;a href=&quot;#section-9.9.1&quot;&gt;9.9.1&lt;/a&gt;. MOVE for Properties 
           &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt;. MOVE for Collections 
           &lt;a href=&quot;#section-9.9.3&quot;&gt;9.9.3&lt;/a&gt;. MOVE and the Overwrite Header 
           &lt;a href=&quot;#section-9.9.4&quot;&gt;9.9.4&lt;/a&gt;. Status Codes 
           &lt;a href=&quot;#section-9.9.5&quot;&gt;9.9.5&lt;/a&gt;. Example - MOVE of a Non-Collection 
           &lt;a href=&quot;#section-9.9.6&quot;&gt;9.9.6&lt;/a&gt;. Example - MOVE of a Collection 
      &lt;a href=&quot;#section-9.10&quot;&gt;9.10&lt;/a&gt;. LOCK Method 
           &lt;a href=&quot;#section-9.10.1&quot;&gt;9.10.1&lt;/a&gt;. Creating a Lock on an Existing Resource 
           &lt;a href=&quot;#section-9.10.2&quot;&gt;9.10.2&lt;/a&gt;. Refreshing Locks 
           &lt;a href=&quot;#section-9.10.3&quot;&gt;9.10.3&lt;/a&gt;. Depth and Locking 
           &lt;a href=&quot;#section-9.10.4&quot;&gt;9.10.4&lt;/a&gt;. Locking Unmapped URLs 
           &lt;a href=&quot;#section-9.10.5&quot;&gt;9.10.5&lt;/a&gt;. Lock Compatibility Table 
           &lt;a href=&quot;#section-9.10.6&quot;&gt;9.10.6&lt;/a&gt;. LOCK Responses 
           &lt;a href=&quot;#section-9.10.7&quot;&gt;9.10.7&lt;/a&gt;. Example - Simple Lock Request 
           &lt;a href=&quot;#section-9.10.8&quot;&gt;9.10.8&lt;/a&gt;. Example - Refreshing a Write Lock 
           &lt;a href=&quot;#section-9.10.9&quot;&gt;9.10.9&lt;/a&gt;. Example - Multi-Resource Lock Request 
      &lt;a href=&quot;#section-9.11&quot;&gt;9.11&lt;/a&gt;. UNLOCK Method 
           &lt;a href=&quot;#section-9.11.1&quot;&gt;9.11.1&lt;/a&gt;. Status Codes ...................................... 

           &lt;a href=&quot;#section-9.11.2&quot;&gt;9.11.2&lt;/a&gt;. Example - UNLOCK 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. HTTP Headers for Distributed Authoring 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. DAV Header 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. Depth Header 
      &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;. Destination Header 
      &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;. If Header 
           &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt;. Purpose 
           &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt;. Syntax 
           &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;. List Evaluation 
           &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;. Matching State Tokens and ETags 
           &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt;. If Header and Non-DAV-Aware Proxies 
           &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt;. Example - No-tag Production 
           &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt;. Example - Using &quot;Not&quot; with No-tag Production 
           10.4.8. Example - Causing a Condition to Always
                   Evaluate to True 
           &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt;. Example - Tagged List If Header in COPY 
           10.4.10. Example - Matching Lock Tokens with
                    Collection Locks 
           &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt;. Example - Matching ETags on Unmapped URLs 
      &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;. Lock-Token Header 
      &lt;a href=&quot;#section-10.6&quot;&gt;10.6&lt;/a&gt;. Overwrite Header 
      &lt;a href=&quot;#section-10.7&quot;&gt;10.7&lt;/a&gt;. Timeout Request Header 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. Status Code Extensions to HTTP/1.1 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. 207 Multi-Status 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. 422 Unprocessable Entity 
      &lt;a href=&quot;#section-11.3&quot;&gt;11.3&lt;/a&gt;. 423 Locked 
      &lt;a href=&quot;#section-11.4&quot;&gt;11.4&lt;/a&gt;. 424 Failed Dependency 
      &lt;a href=&quot;#section-11.5&quot;&gt;11.5&lt;/a&gt;. 507 Insufficient Storage 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;. Use of HTTP Status Codes 
      &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;. 412 Precondition Failed 
      &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;. 414 Request-URI Too Long 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;. Multi-Status Response 
      &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;. Response Headers 
      &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;. Handling Redirected Child Resources 
      &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt;. Internal Status Codes 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;. XML Element Definitions 
      &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt;. activelock XML Element 
      &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt;. allprop XML Element 
      &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt;. collection XML Element 
      &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt;. depth XML Element 
      &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt;. error XML Element 
      &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt;. exclusive XML Element 
      &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt;. href XML Element 
      &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;. include XML Element 
      &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;. location XML Element 
      &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;. lockentry XML Element 
      &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;. lockinfo XML Element 
      &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;. lockroot XML Element .................................... 

      &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt;. lockscope XML Element 
      &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt;. locktoken XML Element 
      &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt;. locktype XML Element 
      &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;. multistatus XML Element 
      &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;. owner XML Element 
      &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt;. prop XML Element 
      &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;. propertyupdate XML Element 
      &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;. propfind XML Element 
      &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt;. propname XML Element 
      &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt;. propstat XML Element 
      &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;. remove XML Element 
      &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;. response XML Element 
      &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;. responsedescription XML Element 
      &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;. set XML Element 
      &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt;. shared XML Element 
      &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt;. status XML Element 
      &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;. timeout XML Element 
      &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;. write XML Element 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;. DAV Properties 
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;. Precondition/Postcondition XML Elements 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;. XML Extensibility in DAV 
   &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt;. DAV Compliance Classes 
      &lt;a href=&quot;#section-18.1&quot;&gt;18.1&lt;/a&gt;. Class 1 
      &lt;a href=&quot;#section-18.2&quot;&gt;18.2&lt;/a&gt;. Class 2 
      &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;. Class 3 
   &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt;. Internationalization Considerations 
   &lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-20.1&quot;&gt;20.1&lt;/a&gt;. Authentication of Clients 
      &lt;a href=&quot;#section-20.2&quot;&gt;20.2&lt;/a&gt;. Denial of Service 
      &lt;a href=&quot;#section-20.3&quot;&gt;20.3&lt;/a&gt;. Security through Obscurity 
      &lt;a href=&quot;#section-20.4&quot;&gt;20.4&lt;/a&gt;. Privacy Issues Connected to Locks 
      &lt;a href=&quot;#section-20.5&quot;&gt;20.5&lt;/a&gt;. Privacy Issues Connected to Properties 
      &lt;a href=&quot;#section-20.6&quot;&gt;20.6&lt;/a&gt;. Implications of XML Entities 
      &lt;a href=&quot;#section-20.7&quot;&gt;20.7&lt;/a&gt;. Risks Connected with Lock Tokens 
      &lt;a href=&quot;#section-20.8&quot;&gt;20.8&lt;/a&gt;. Hosting Malicious Content 
   &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-21.1&quot;&gt;21.1&lt;/a&gt;. New URI Schemes 
      &lt;a href=&quot;#section-21.2&quot;&gt;21.2&lt;/a&gt;. XML Namespaces 
      &lt;a href=&quot;#section-21.3&quot;&gt;21.3&lt;/a&gt;. Message Header Fields 
           &lt;a href=&quot;#section-21.3.1&quot;&gt;21.3.1&lt;/a&gt;. DAV 
           &lt;a href=&quot;#section-21.3.2&quot;&gt;21.3.2&lt;/a&gt;. Depth 
           &lt;a href=&quot;#section-21.3.3&quot;&gt;21.3.3&lt;/a&gt;. Destination 
           &lt;a href=&quot;#section-21.3.4&quot;&gt;21.3.4&lt;/a&gt;. If 
           &lt;a href=&quot;#section-21.3.5&quot;&gt;21.3.5&lt;/a&gt;. Lock-Token 
           &lt;a href=&quot;#section-21.3.6&quot;&gt;21.3.6&lt;/a&gt;. Overwrite 
           &lt;a href=&quot;#section-21.3.7&quot;&gt;21.3.7&lt;/a&gt;. Timeout 
      &lt;a href=&quot;#section-21.4&quot;&gt;21.4&lt;/a&gt;. HTTP Status Codes 
   &lt;a href=&quot;#section-22&quot;&gt;22&lt;/a&gt;. Acknowledgements ............................................. 

   &lt;a href=&quot;#section-23&quot;&gt;23&lt;/a&gt;. Contributors to This Specification 
   &lt;a href=&quot;#section-24&quot;&gt;24&lt;/a&gt;. Authors of &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;&lt;a href=&quot;#section-25&quot;&gt;25&lt;/a&gt;. References 
      &lt;a href=&quot;#section-25.1&quot;&gt;25.1&lt;/a&gt;. Normative References
      &lt;a href=&quot;#section-25.2&quot;&gt;25.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;.  Notes on Processing XML Elements 
      &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt;. Notes on Empty XML Elements 
      &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt;. Notes on Illegal XML Processing 
      &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt;. Example - XML Syntax Error 
      &lt;a href=&quot;#appendix-A.4&quot;&gt;A.4&lt;/a&gt;. Example - Unexpected XML Element 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Notes on HTTP Client Compatibility 
   &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. The 'opaquelocktoken' Scheme and URIs 
   &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt;. Lock-null Resources 
      &lt;a href=&quot;#appendix-D.1&quot;&gt;D.1&lt;/a&gt;. Guidance for Clients Using LOCK to Create Resources 
   &lt;a href=&quot;#appendix-E&quot;&gt;Appendix E&lt;/a&gt;. Guidance for Clients Desiring to Authenticate 
   &lt;a href=&quot;#appendix-F&quot;&gt;Appendix F&lt;/a&gt;. Summary of Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;&lt;a href=&quot;#appendix-F.1&quot;&gt;F.1&lt;/a&gt;. Changes for Both Client and Server Implementations 
      &lt;a href=&quot;#appendix-F.2&quot;&gt;F.2&lt;/a&gt;. Changes for Server Implementations 
      &lt;a href=&quot;#appendix-F.3&quot;&gt;F.3&lt;/a&gt;. Other Changes ............................................</source>
          <target state="translated">Статус этой памятки В этом документе определяется протокол отслеживания стандартов Интернета для Интернет-сообщества, а также предлагается обсуждение и предложения по улучшениям. См. Текущую редакцию &amp;laquo;Официальных стандартов протокола Интернета&amp;raquo; (STD 1), чтобы узнать о состоянии стандартизации и статусе этого протокола. Распространение этой памятки не ограничено. Уведомление об авторских правах Авторские права (C) IETF Trust (2007 г.). Абстрактная веб-распределенная разработка и управление версиями (WebDAV) состоит из набора методов, заголовков и типов контента, вспомогательных для HTTP / 1.1 для управления свойствами ресурсов, создания и управления коллекциями ресурсов, манипулирования пространством имен URL и блокировки ресурсов (коллизия). избегание). &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;была опубликована в феврале 1999 г., и эта спецификация отменяет &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; с незначительными изменениями, в основном из-за опыта взаимодействия. Содержание &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . Введение &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . Условные обозначения &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . Терминология &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . Модель данных для свойств ресурса &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . Модель свойств ресурса &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . Свойства и заголовки HTTP &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . &lt;a href=&quot;#section-4.3.1&quot;&gt;Стоимость&lt;/a&gt; недвижимости 4.3.1 . Пример - недвижимость со смешанным содержанием &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; . Имена свойств &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt; . Исходные ресурсы и выходные ресурсы &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;, Коллекции веб-ресурсов &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; . Модель пространства имен URL-адресов HTTP &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; . Ресурсы коллекции &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . Блокировка &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; . Модель замка &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; . Эксклюзивные и общие блокировки &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; . Требуемая поддержка &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt; . Создатель блокировки и привилегии &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt; . Жетоны блокировки &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt; . Тайм-аут блокировки &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt; . Обнаружение возможности блокировки &lt;a href=&quot;#section-6.8&quot;&gt;6.8&lt;/a&gt; . Обнаружение активного замка &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . Блокировка записи &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; . Блокировки записи и свойства &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; . Как избежать утраченных обновлений &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;, Блокировки записи и несопоставленные URL-адреса &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt; . Запись замков и коллекций &lt;a href=&quot;#section-7.5&quot;&gt;7.5&lt;/a&gt; . Блокировки записи и заголовок запроса If &lt;a href=&quot;#section-7.5.1&quot;&gt;7.5.1&lt;/a&gt; . Пример - блокировка записи и копирование 7.5.2. Пример - Удаление члена закрытой коллекции &lt;a href=&quot;#section-7.6&quot;&gt;7.6&lt;/a&gt; . Блокировка записи и КОПИРОВАНИЕ / ПЕРЕМЕЩЕНИЕ &lt;a href=&quot;#section-7.7&quot;&gt;7.7&lt;/a&gt; . Обновление блокировок записи &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . Общая обработка запросов и ответов &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; . Приоритет при обработке ошибок &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; . Использование XML &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt; . Обработка URL-адресов &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt; . Пример - правильная обработка URL-адресов &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;, Обязательные элементы в запросах &lt;a href=&quot;#section-8.5&quot;&gt;8.5&lt;/a&gt; . Заголовки HTTP для использования в WebDAV &lt;a href=&quot;#section-8.6&quot;&gt;8.6&lt;/a&gt; . ETag &lt;a href=&quot;#section-8.7&quot;&gt;8.7&lt;/a&gt; . Включая тела сообщений об ошибках &lt;a href=&quot;#section-8.8&quot;&gt;8.8&lt;/a&gt; . Влияние операций с пространством имен на валидаторы кеша &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; . Методы HTTP для распределенной разработки &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; . PROPFIND Метод &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt; . Коды состояния PROPFIND ........................... &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt; . Коды состояния для использования в элементе propstat &lt;a href=&quot;#section-9.1.3&quot;&gt;9.1.3&lt;/a&gt; . Пример - получение именованных свойств 9.1.4. Пример - использование 'propname' для получения всех имен &lt;a href=&quot;#section-9.1.5&quot;&gt;свойств 9.1.5&lt;/a&gt;, Пример - использование так называемого &amp;laquo;allprop&amp;raquo; &lt;a href=&quot;#section-9.1.6&quot;&gt;9.1.6&lt;/a&gt; . Пример - использование allprop с include &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; . Метод PROPPATCH &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt; . Коды состояния для использования в элементе propstat &lt;a href=&quot;#section-9.2.2&quot;&gt;9.2.2&lt;/a&gt; . Пример - PROPPATCH &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; . MKCOL Метод &lt;a href=&quot;#section-9.3.1&quot;&gt;9.3.1&lt;/a&gt; . Коды статуса MKCOL &lt;a href=&quot;#section-9.3.2&quot;&gt;9.3.2&lt;/a&gt; . Пример - MKCOL &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt; . GET, HEAD для коллекций &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt; . POST для коллекций &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; . УДАЛИТЬ Требования &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt; . УДАЛЕНИЕ для коллекций &lt;a href=&quot;#section-9.6.2&quot;&gt;9.6.2&lt;/a&gt; . Пример - УДАЛИТЬ &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;, Требования PUT &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt; . PUT для ресурсов, не связанных с коллекцией &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt; . PUT для коллекций &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; . Метод КОПИРОВАНИЯ &lt;a href=&quot;#section-9.8.1&quot;&gt;9.8.1&lt;/a&gt; . КОПИЯ для ресурсов, не &lt;a href=&quot;#section-9.8.2&quot;&gt;связанных с&lt;/a&gt; коллекцией 9.8.2 . КОПИЯ для свойств &lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt; . КОПИЯ для коллекций &lt;a href=&quot;#section-9.8.4&quot;&gt;9.8.4&lt;/a&gt; . КОПИРОВАНИЕ и перезапись &lt;a href=&quot;#section-9.8.5&quot;&gt;целевых&lt;/a&gt; ресурсов 9.8.5 . Коды состояния &lt;a href=&quot;#section-9.8.6&quot;&gt;9.8.6&lt;/a&gt; . Пример - КОПИРОВАНИЕ с перезаписью &lt;a href=&quot;#section-9.8.7&quot;&gt;9.8.7&lt;/a&gt; . Пример - КОПИРОВАНИЕ без перезаписи &lt;a href=&quot;#section-9.8.8&quot;&gt;9.8.8&lt;/a&gt; . Пример - КОПИЯ коллекции &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;, MOVE Метод &lt;a href=&quot;#section-9.9.1&quot;&gt;9.9.1&lt;/a&gt; . MOVE для недвижимости &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt; . MOVE для коллекций &lt;a href=&quot;#section-9.9.3&quot;&gt;9.9.3&lt;/a&gt; . MOVE и перезапись заголовка &lt;a href=&quot;#section-9.9.4&quot;&gt;9.9.4&lt;/a&gt; . Коды состояния &lt;a href=&quot;#section-9.9.5&quot;&gt;9.9.5&lt;/a&gt; . Пример - &lt;a href=&quot;#section-9.9.6&quot;&gt;ПЕРЕМЕЩЕНИЕ&lt;/a&gt; не-коллекции 9.9.6 . Пример - ПЕРЕМЕЩЕНИЕ коллекции &lt;a href=&quot;#section-9.10&quot;&gt;9.10&lt;/a&gt; . Метод LOCK &lt;a href=&quot;#section-9.10.1&quot;&gt;9.10.1&lt;/a&gt; . Создание блокировки на существующем &lt;a href=&quot;#section-9.10.2&quot;&gt;ресурсе 9.10.2&lt;/a&gt; . Обновление блокировок &lt;a href=&quot;#section-9.10.3&quot;&gt;9.10.3&lt;/a&gt; . Глубина и &lt;a href=&quot;#section-9.10.4&quot;&gt;запирание 9.10.4&lt;/a&gt; . Блокировка несопоставленных URL-адресов &lt;a href=&quot;#section-9.10.5&quot;&gt;9.10.5&lt;/a&gt;, Таблица совместимости &lt;a href=&quot;#section-9.10.6&quot;&gt;замков 9.10.6&lt;/a&gt; . LOCK Ответы &lt;a href=&quot;#section-9.10.7&quot;&gt;9.10.7&lt;/a&gt; . Пример - запрос простой блокировки &lt;a href=&quot;#section-9.10.8&quot;&gt;9.10.8&lt;/a&gt; . Пример - &lt;a href=&quot;#section-9.10.9&quot;&gt;обновление&lt;/a&gt; блокировки записи 9.10.9 . Пример - запрос блокировки нескольких ресурсов &lt;a href=&quot;#section-9.11&quot;&gt;9.11&lt;/a&gt; . &lt;a href=&quot;#section-9.11.1&quot;&gt;РАЗБЛОКИРОВКА&lt;/a&gt; Метод 9.11.1 . Коды состояния ..................................... &lt;a href=&quot;#section-9.11.2&quot;&gt;9.11.2&lt;/a&gt; . Пример - РАЗБЛОКИРОВАТЬ &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; . Заголовки HTTP для распределенной разработки &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; . Заголовок DAV &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; . Заголовок глубины &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt; . Заголовок назначения &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt; . Если заголовок &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt; . Цель &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt; . Синтаксис &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; . Оценка списка &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt; . Соответствие токенов состояния и тегов ETag &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt; . Если заголовок и прокси без поддержки DAV &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt; . Пример - Производство без тегов &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt; . Пример - Использование &amp;laquo;Не&amp;raquo; с производством без тегов 10.4.8. Пример - принуждение условия всегда оценивать как истинное &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt; . Пример - Tagged List If Header in COPY 10.4.10. Пример - соответствие токенов блокировок замкам коллекций &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt; . Пример - сопоставление ETags на несопоставленных URL &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt; . Заголовок Lock-Token &lt;a href=&quot;#section-10.6&quot;&gt;10.6&lt;/a&gt; . Перезаписать заголовок &lt;a href=&quot;#section-10.7&quot;&gt;10.7&lt;/a&gt; . Заголовок запроса тайм-аута &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; . Расширения кода состояния для HTTP / 1.1 &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt; . 207 Мульти-статус &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt; . 422 Необработанная сущность &lt;a href=&quot;#section-11.3&quot;&gt;11.3&lt;/a&gt; . 423 Заблокировано &lt;a href=&quot;#section-11.4&quot;&gt;11.4&lt;/a&gt; . 424 Неудачная зависимость &lt;a href=&quot;#section-11.5&quot;&gt;11.5&lt;/a&gt; . 507 Недостаточно памяти &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt; . Использование кодов состояния HTTP &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt; . 412 Ошибка &lt;a href=&quot;#section-12.2&quot;&gt;предварительного&lt;/a&gt; условия 12.2 . 414 Request-URI Too Long &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt; . Мульти-статусный ответ &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt; . Заголовки ответа &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;, Обработка перенаправленных дочерних ресурсов &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt; . Коды внутреннего состояния &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt; . Определения элементов XML &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt; . XML-элемент activelock &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt; . XML-элемент allprop &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt; . Коллекция XML Element &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt; . XML-элемент глубины &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt; . Ошибка XML-элемента &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt; . эксклюзивный элемент XML &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt; . Элемент XML href &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt; . включить элемент XML &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt; . Элемент XML location &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt; . XML-элемент lockentry &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt; . XML-элемент lockinfo &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;, XML-элемент lockroot ....................................... &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt; . XML-элемент lockscope &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt; . XML-элемент locktoken &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt; . XML-элемент locktype &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt; . Элемент XML с несколькими состояниями &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt; . XML-элемент владельца &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt; . prop XML-элемент &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; . XML-элемент propertyupdate &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt; . Элемент XML propfind &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt; . Элемент XML &lt;a href=&quot;#section-14.22&quot;&gt;propname 14.22&lt;/a&gt; . propstat XML Элемент &lt;a href=&quot;#section-14.23&quot;&gt;14,23&lt;/a&gt; . удалить элемент XML &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; . XML-элемент ответа &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;, XML-элемент responsedescription &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; . установить элемент XML &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt; . общий элемент XML &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt; . Элемент XML status &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt; . тайм-аут XML-элемент &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt; . напишите элемент XML &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt; . DAV Свойства &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt; . XML-элементы предусловия / постусловия &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt; . Расширяемость XML в DAV &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt; . Классы соответствия DAV &lt;a href=&quot;#section-18.1&quot;&gt;18.1&lt;/a&gt; . Класс 1 &lt;a href=&quot;#section-18.2&quot;&gt;18.2&lt;/a&gt; . Класс 2 &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt; . 3 класс &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt; . Соображения по интернационализации &lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt; . Соображения безопасности &lt;a href=&quot;#section-20.1&quot;&gt;20.1&lt;/a&gt; . Аутентификация клиентов &lt;a href=&quot;#section-20.2&quot;&gt;20.2&lt;/a&gt; . Отказ в обслуживании &lt;a href=&quot;#section-20.3&quot;&gt;20.3&lt;/a&gt; . Безопасность через неизвестность &lt;a href=&quot;#section-20.4&quot;&gt;20.4&lt;/a&gt; . Проблемы конфиденциальности, связанные с замками &lt;a href=&quot;#section-20.5&quot;&gt;20.5&lt;/a&gt; . Вопросы конфиденциальности, связанные с недвижимостью &lt;a href=&quot;#section-20.6&quot;&gt;20.6&lt;/a&gt; . Значение XML-сущностей &lt;a href=&quot;#section-20.7&quot;&gt;20.7&lt;/a&gt; . Риски, связанные с токенами блокировки &lt;a href=&quot;#section-20.8&quot;&gt;20.8&lt;/a&gt; . Размещение вредоносного содержимого &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt; . Соображения IANA &lt;a href=&quot;#section-21.1&quot;&gt;21.1&lt;/a&gt; . Новые схемы URI &lt;a href=&quot;#section-21.2&quot;&gt;21.2&lt;/a&gt; . Пространства имен XML &lt;a href=&quot;#section-21.3&quot;&gt;21.3&lt;/a&gt; . Поля заголовка сообщения &lt;a href=&quot;#section-21.3.1&quot;&gt;21.3.1&lt;/a&gt; . DAV &lt;a href=&quot;#section-21.3.2&quot;&gt;21.3.2&lt;/a&gt;, Глубина &lt;a href=&quot;#section-21.3.3&quot;&gt;21.3.3&lt;/a&gt; . Назначение &lt;a href=&quot;#section-21.3.4&quot;&gt;21.3.4&lt;/a&gt; . Если &lt;a href=&quot;#section-21.3.5&quot;&gt;21.3.5&lt;/a&gt; . Lock-Token &lt;a href=&quot;#section-21.3.6&quot;&gt;21.3.6&lt;/a&gt; . Перезаписать &lt;a href=&quot;#section-21.3.7&quot;&gt;21.3.7&lt;/a&gt; . Тайм-аут &lt;a href=&quot;#section-21.4&quot;&gt;21.4&lt;/a&gt; . Коды состояния HTTP &lt;a href=&quot;#section-22&quot;&gt;22&lt;/a&gt; . Благодарности ............................................. &lt;a href=&quot;#section-23&quot;&gt;23&lt;/a&gt; . Соавторы данной спецификации &lt;a href=&quot;#section-24&quot;&gt;24&lt;/a&gt; . Авторы &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518 &lt;/a&gt;&lt;a href=&quot;#section-25&quot;&gt;25&lt;/a&gt; . Ссылки &lt;a href=&quot;#section-25.1&quot;&gt;25.1&lt;/a&gt; . Нормативные ссылки &lt;a href=&quot;#section-25.2&quot;&gt;25.2&lt;/a&gt; . Информативные ссылки &lt;a href=&quot;#appendix-A&quot;&gt;Приложение A&lt;/a&gt; . Примечания по обработке XML-элементов &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt;, Примечания к пустым элементам XML &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt; . Замечания о незаконной обработке XML &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt; . Пример - синтаксическая ошибка XML &lt;a href=&quot;#appendix-A.4&quot;&gt;A.4&lt;/a&gt; . Пример - Неожиданный XML элемент &lt;a href=&quot;#appendix-B&quot;&gt;Приложение B&lt;/a&gt; . Замечания по HTTP Client Compatibility &lt;a href=&quot;#appendix-C&quot;&gt;Приложение C&lt;/a&gt; . &amp;laquo;Opaquelocktoken&amp;raquo; Схема и идентификаторы URI &lt;a href=&quot;#appendix-D&quot;&gt;Приложение D&lt;/a&gt; . Ресурсы Lock-null &lt;a href=&quot;#appendix-D.1&quot;&gt;D.1&lt;/a&gt; . Руководство для клиентов , используя блокировку для создания ресурсов &lt;a href=&quot;#appendix-E&quot;&gt;Приложение E&lt;/a&gt; . Руководство для клиентов , желающих Authenticate &lt;a href=&quot;#appendix-F&quot;&gt;Приложения F&lt;/a&gt; . Сводка изменений по сравнению с &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518 &lt;/a&gt;&lt;a href=&quot;#appendix-F.1&quot;&gt;F.1&lt;/a&gt; . Изменения для клиентских и серверных реализаций &lt;a href=&quot;#appendix-F.2&quot;&gt;F.2&lt;/a&gt;, Изменения для серверных реализаций &lt;a href=&quot;#appendix-F.3&quot;&gt;F.3&lt;/a&gt; . Прочие изменения ............................................</target>
        </trans-unit>
        <trans-unit id="5314ebdcf29205bc56fbbcaea0c60b012d05ccf0" translate="yes" xml:space="preserve">
          <source>Status of responses including a &lt;code&gt;Location&lt;/code&gt; header: &lt;a href=&quot;../status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Статус ответов, включая заголовок &lt;code&gt;Location&lt;/code&gt; : &lt;a href=&quot;../status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/307&quot;&gt; &lt;code&gt;307&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/308&quot;&gt; &lt;code&gt;308&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d856fa610b4491baa384c8f7803b6e1e2fc35cdc" translate="yes" xml:space="preserve">
          <source>Status of this Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

Abstract

   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt;]. A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.

   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as &quot;HTTP/1.1&quot;, and is an update to &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;]. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;   Introduction 
   &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;    Purpose
   &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;   Requirements 
   &lt;a href=&quot;#section-1.3&quot;&gt;1.3&lt;/a&gt;   Terminology 
   &lt;a href=&quot;#section-1.4&quot;&gt;1.4&lt;/a&gt;   Overall Operation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;   Notational Conventions and Generic Grammar 
   &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;   Augmented BNF 
   &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;   Basic Rules 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;   Protocol Parameters 
   &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;   HTTP Version 
   &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;   Uniform Resource Identifiers 
   &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;    General Syntax 
   &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt;    http URL 
   &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt;    URI Comparison 
   &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;   Date/Time Formats 
   &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;    Full Date 
   &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt;    Delta Seconds 
   &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt;   Character Sets 
   &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1&lt;/a&gt;    Missing Charset 
   &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt;   Content Codings 
   &lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt;   Transfer Codings 
   &lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1&lt;/a&gt;    Chunked Transfer Coding 
   &lt;a href=&quot;#section-3.7&quot;&gt;3.7&lt;/a&gt;   Media Types 
   &lt;a href=&quot;#section-3.7.1&quot;&gt;3.7.1&lt;/a&gt;    Canonicalization and Text Defaults 
   &lt;a href=&quot;#section-3.7.2&quot;&gt;3.7.2&lt;/a&gt;    Multipart Types 
   &lt;a href=&quot;#section-3.8&quot;&gt;3.8&lt;/a&gt;   Product Tokens 
   &lt;a href=&quot;#section-3.9&quot;&gt;3.9&lt;/a&gt;   Quality Values 
   &lt;a href=&quot;#section-3.10&quot;&gt;3.10&lt;/a&gt;  Language Tags 
   &lt;a href=&quot;#section-3.11&quot;&gt;3.11&lt;/a&gt;  Entity Tags 
   &lt;a href=&quot;#section-3.12&quot;&gt;3.12&lt;/a&gt;  Range Units 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;   HTTP Message 
   &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;   Message Types 
   &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;   Message Headers 
   &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;   Message Body 
   &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;   Message Length 
   &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt;   General Header Fields 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;   Request 
   &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;   Request-Line 
   &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt;    Method 
   &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;    Request-URI 
   &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;   The Resource Identified by a Request 
   &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;   Request Header Fields 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;   Response 
   &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;   Status-Line 
   &lt;a href=&quot;#section-6.1.1&quot;&gt;6.1.1&lt;/a&gt;    Status Code and Reason Phrase 
   &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;   Response Header Fields ...................................... 

   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;   Entity 
   &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;   Entity Header Fields 
   &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;   Entity Body 
   &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;    Type 
   &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt;    Entity Length 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;   Connections 
   &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;   Persistent Connections 
   &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt;    Purpose 
   &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt;    Overall Operation 
   &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1.3&lt;/a&gt;    Proxy Servers 
   &lt;a href=&quot;#section-8.1.4&quot;&gt;8.1.4&lt;/a&gt;    Practical Considerations 
   &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;   Message Transmission Requirements 
   &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt;    Persistent Connections and Flow Control 
   &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt;    Monitoring Connections for Error Status Messages 
   &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3&lt;/a&gt;    Use of the 100 (Continue) Status 
   &lt;a href=&quot;#section-8.2.4&quot;&gt;8.2.4&lt;/a&gt;    Client Behavior if Server Prematurely Closes Connection ..50
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;   Method Definitions 
   &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;   Safe and Idempotent Methods 
   &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;    Safe Methods 
   &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;    Idempotent Methods 
   &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;   OPTIONS 
   &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;   GET 
   &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;   HEAD 
   &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;   POST 
   &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;   PUT 
   &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;   DELETE 
   &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;   TRACE 
   &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;   CONNECT 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;   Status Code Definitions 
   &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;  Informational 1xx 
   &lt;a href=&quot;#section-10.1.1&quot;&gt;10.1.1&lt;/a&gt;   100 Continue 
   &lt;a href=&quot;#section-10.1.2&quot;&gt;10.1.2&lt;/a&gt;   101 Switching Protocols 
   &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;  Successful 2xx 
   &lt;a href=&quot;#section-10.2.1&quot;&gt;10.2.1&lt;/a&gt;   200 OK 
   &lt;a href=&quot;#section-10.2.2&quot;&gt;10.2.2&lt;/a&gt;   201 Created 
   &lt;a href=&quot;#section-10.2.3&quot;&gt;10.2.3&lt;/a&gt;   202 Accepted 
   &lt;a href=&quot;#section-10.2.4&quot;&gt;10.2.4&lt;/a&gt;   203 Non-Authoritative Information 
   &lt;a href=&quot;#section-10.2.5&quot;&gt;10.2.5&lt;/a&gt;   204 No Content 
   &lt;a href=&quot;#section-10.2.6&quot;&gt;10.2.6&lt;/a&gt;   205 Reset Content 
   &lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;   206 Partial Content 
   &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;  Redirection 3xx 
   &lt;a href=&quot;#section-10.3.1&quot;&gt;10.3.1&lt;/a&gt;   300 Multiple Choices 
   &lt;a href=&quot;#section-10.3.2&quot;&gt;10.3.2&lt;/a&gt;   301 Moved Permanently 
   &lt;a href=&quot;#section-10.3.3&quot;&gt;10.3.3&lt;/a&gt;   302 Found 
   &lt;a href=&quot;#section-10.3.4&quot;&gt;10.3.4&lt;/a&gt;   303 See Other 
   &lt;a href=&quot;#section-10.3.5&quot;&gt;10.3.5&lt;/a&gt;   304 Not Modified 
   &lt;a href=&quot;#section-10.3.6&quot;&gt;10.3.6&lt;/a&gt;   305 Use Proxy 
   &lt;a href=&quot;#section-10.3.7&quot;&gt;10.3.7&lt;/a&gt;   306 (Unused) ............................................. 

   &lt;a href=&quot;#section-10.3.8&quot;&gt;10.3.8&lt;/a&gt;   307 Temporary Redirect 
   &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;  Client Error 4xx 
   &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt;    400 Bad Request 
   &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt;    401 Unauthorized 
   &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;    402 Payment Required 
   &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;    403 Forbidden 
   &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt;    404 Not Found 
   &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt;    405 Method Not Allowed 
   &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt;    406 Not Acceptable 
   &lt;a href=&quot;#section-10.4.8&quot;&gt;10.4.8&lt;/a&gt;    407 Proxy Authentication Required 
   &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt;    408 Request Timeout 
   &lt;a href=&quot;#section-10.4.10&quot;&gt;10.4.10&lt;/a&gt;   409 Conflict 
   &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt;   410 Gone 
   &lt;a href=&quot;#section-10.4.12&quot;&gt;10.4.12&lt;/a&gt;   411 Length Required 
   &lt;a href=&quot;#section-10.4.13&quot;&gt;10.4.13&lt;/a&gt;   412 Precondition Failed 
   &lt;a href=&quot;#section-10.4.14&quot;&gt;10.4.14&lt;/a&gt;   413 Request Entity Too Large 
   &lt;a href=&quot;#section-10.4.15&quot;&gt;10.4.15&lt;/a&gt;   414 Request-URI Too Long 
   &lt;a href=&quot;#section-10.4.16&quot;&gt;10.4.16&lt;/a&gt;   415 Unsupported Media Type 
   &lt;a href=&quot;#section-10.4.17&quot;&gt;10.4.17&lt;/a&gt;   416 Requested Range Not Satisfiable 
   &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt;   417 Expectation Failed 
   &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;  Server Error 5xx 
   &lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1&lt;/a&gt;   500 Internal Server Error 
   &lt;a href=&quot;#section-10.5.2&quot;&gt;10.5.2&lt;/a&gt;   501 Not Implemented 
   &lt;a href=&quot;#section-10.5.3&quot;&gt;10.5.3&lt;/a&gt;   502 Bad Gateway 
   &lt;a href=&quot;#section-10.5.4&quot;&gt;10.5.4&lt;/a&gt;   503 Service Unavailable 
   &lt;a href=&quot;#section-10.5.5&quot;&gt;10.5.5&lt;/a&gt;   504 Gateway Timeout 
   &lt;a href=&quot;#section-10.5.6&quot;&gt;10.5.6&lt;/a&gt;   505 HTTP Version Not Supported 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;   Access Authentication 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;   Content Negotiation 
   &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;  Server-driven Negotiation 
   &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;  Agent-driven Negotiation 
   &lt;a href=&quot;#section-12.3&quot;&gt;12.3&lt;/a&gt;  Transparent Negotiation 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;   Caching in HTTP 
   &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt;   Cache Correctness 
   &lt;a href=&quot;#section-13.1.2&quot;&gt;13.1.2&lt;/a&gt;   Warnings 
   &lt;a href=&quot;#section-13.1.3&quot;&gt;13.1.3&lt;/a&gt;   Cache-control Mechanisms 
   &lt;a href=&quot;#section-13.1.4&quot;&gt;13.1.4&lt;/a&gt;   Explicit User Agent Warnings 
   &lt;a href=&quot;#section-13.1.5&quot;&gt;13.1.5&lt;/a&gt;   Exceptions to the Rules and Warnings 
   &lt;a href=&quot;#section-13.1.6&quot;&gt;13.1.6&lt;/a&gt;   Client-controlled Behavior 
   &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;  Expiration Model 
   &lt;a href=&quot;#section-13.2.1&quot;&gt;13.2.1&lt;/a&gt;   Server-Specified Expiration 
   &lt;a href=&quot;#section-13.2.2&quot;&gt;13.2.2&lt;/a&gt;   Heuristic Expiration 
   &lt;a href=&quot;#section-13.2.3&quot;&gt;13.2.3&lt;/a&gt;   Age Calculations 
   &lt;a href=&quot;#section-13.2.4&quot;&gt;13.2.4&lt;/a&gt;   Expiration Calculations 
   &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;   Disambiguating Expiration Values 
   &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt;   Disambiguating Multiple Responses 
   &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt;  Validation Model 
   &lt;a href=&quot;#section-13.3.1&quot;&gt;13.3.1&lt;/a&gt;   Last-Modified Dates ...................................... 

   &lt;a href=&quot;#section-13.3.2&quot;&gt;13.3.2&lt;/a&gt;   Entity Tag Cache Validators 
   &lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt;   Weak and Strong Validators 
   13.3.4   Rules for When to Use Entity Tags and Last-Modified Dates.89
   &lt;a href=&quot;#section-13.3.5&quot;&gt;13.3.5&lt;/a&gt;   Non-validating Conditionals 
   &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt;  Response Cacheability 
   &lt;a href=&quot;#section-13.5&quot;&gt;13.5&lt;/a&gt;  Constructing Responses From Caches 
   &lt;a href=&quot;#section-13.5.1&quot;&gt;13.5.1&lt;/a&gt;   End-to-end and Hop-by-hop Headers 
   &lt;a href=&quot;#section-13.5.2&quot;&gt;13.5.2&lt;/a&gt;   Non-modifiable Headers 
   &lt;a href=&quot;#section-13.5.3&quot;&gt;13.5.3&lt;/a&gt;   Combining Headers 
   &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt;   Combining Byte Ranges 
   &lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;  Caching Negotiated Responses 
   &lt;a href=&quot;#section-13.7&quot;&gt;13.7&lt;/a&gt;  Shared and Non-Shared Caches 
   &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt;  Errors or Incomplete Response Cache Behavior 
   &lt;a href=&quot;#section-13.9&quot;&gt;13.9&lt;/a&gt;  Side Effects of GET and HEAD 
   &lt;a href=&quot;#section-13.10&quot;&gt;13.10&lt;/a&gt;   Invalidation After Updates or Deletions 
   &lt;a href=&quot;#section-13.11&quot;&gt;13.11&lt;/a&gt;   Write-Through Mandatory 
   &lt;a href=&quot;#section-13.12&quot;&gt;13.12&lt;/a&gt;   Cache Replacement 
   &lt;a href=&quot;#section-13.13&quot;&gt;13.13&lt;/a&gt;   History Lists 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;   Header Field Definitions 
   &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt;  Accept 
   &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt;  Accept-Charset 
   &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt;  Accept-Encoding 
   &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt;  Accept-Language 
   &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt;  Accept-Ranges 
   &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt;  Age 
   &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt;  Allow 
   &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;  Authorization 
   &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;  Cache-Control 
   &lt;a href=&quot;#section-14.9.1&quot;&gt;14.9.1&lt;/a&gt;   What is Cacheable 
   &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;   What May be Stored by Caches 
   &lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3&lt;/a&gt;   Modifications of the Basic Expiration Mechanism 
   &lt;a href=&quot;#section-14.9.4&quot;&gt;14.9.4&lt;/a&gt;   Cache Revalidation and Reload Controls 
   &lt;a href=&quot;#section-14.9.5&quot;&gt;14.9.5&lt;/a&gt;   No-Transform Directive 
   &lt;a href=&quot;#section-14.9.6&quot;&gt;14.9.6&lt;/a&gt;   Cache Control Extensions 
   &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;   Connection 
   &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;   Content-Encoding 
   &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;   Content-Language 
   &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt;   Content-Length 
   &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt;   Content-Location 
   &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt;   Content-MD5 
   &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;   Content-Range 
   &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;   Content-Type 
   &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt;   Date 
   &lt;a href=&quot;#section-14.18.1&quot;&gt;14.18.1&lt;/a&gt;   Clockless Origin Server Operation 
   &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;   ETag 
   &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;   Expect 
   &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt;   Expires 
   &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt;   From ..................................................... 

   &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;   Host 
   &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;   If-Match 
   &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;   If-Modified-Since 
   &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;   If-None-Match 
   &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt;   If-Range 
   &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt;   If-Unmodified-Since 
   &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;   Last-Modified 
   &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;   Location 
   &lt;a href=&quot;#section-14.31&quot;&gt;14.31&lt;/a&gt;   Max-Forwards 
   &lt;a href=&quot;#section-14.32&quot;&gt;14.32&lt;/a&gt;   Pragma 
   &lt;a href=&quot;#section-14.33&quot;&gt;14.33&lt;/a&gt;   Proxy-Authenticate 
   &lt;a href=&quot;#section-14.34&quot;&gt;14.34&lt;/a&gt;   Proxy-Authorization 
   &lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;   Range 
   &lt;a href=&quot;#section-14.35.1&quot;&gt;14.35.1&lt;/a&gt;    Byte Ranges 
   &lt;a href=&quot;#section-14.35.2&quot;&gt;14.35.2&lt;/a&gt;    Range Retrieval Requests 
   &lt;a href=&quot;#section-14.36&quot;&gt;14.36&lt;/a&gt;   Referer 
   &lt;a href=&quot;#section-14.37&quot;&gt;14.37&lt;/a&gt;   Retry-After 
   &lt;a href=&quot;#section-14.38&quot;&gt;14.38&lt;/a&gt;   Server 
   &lt;a href=&quot;#section-14.39&quot;&gt;14.39&lt;/a&gt;   TE 
   &lt;a href=&quot;#section-14.40&quot;&gt;14.40&lt;/a&gt;   Trailer 
   &lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;  Transfer-Encoding
   &lt;a href=&quot;#section-14.42&quot;&gt;14.42&lt;/a&gt;   Upgrade 
   &lt;a href=&quot;#section-14.43&quot;&gt;14.43&lt;/a&gt;   User-Agent 
   &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;   Vary 
   &lt;a href=&quot;#section-14.45&quot;&gt;14.45&lt;/a&gt;   Via 
   &lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt;   Warning 
   &lt;a href=&quot;#section-14.47&quot;&gt;14.47&lt;/a&gt;   WWW-Authenticate 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt; Security Considerations 
   &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt;      Personal Information
   &lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt;   Abuse of Server Log Information 
   &lt;a href=&quot;#section-15.1.2&quot;&gt;15.1.2&lt;/a&gt;   Transfer of Sensitive Information 
   &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3&lt;/a&gt;   Encoding Sensitive Information in URI's 
   &lt;a href=&quot;#section-15.1.4&quot;&gt;15.1.4&lt;/a&gt;   Privacy Issues Connected to Accept Headers 
   &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt;  Attacks Based On File and Path Names 
   &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt;  DNS Spoofing 
   &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt;  Location Headers and Spoofing 
   &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt;  Content-Disposition Issues 
   &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt;  Authentication Credentials and Idle Clients 
   &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt;  Proxies and Caching 
   &lt;a href=&quot;#section-15.7.1&quot;&gt;15.7.1&lt;/a&gt;    Denial of Service Attacks on Proxies
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;   Acknowledgments 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;   References 
   &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt;   Authors' Addresses 
   &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt;   Appendices 
   &lt;a href=&quot;#section-19.1&quot;&gt;19.1&lt;/a&gt;  Internet Media Type message/http and application/http 
   &lt;a href=&quot;#section-19.2&quot;&gt;19.2&lt;/a&gt;  Internet Media Type multipart/byteranges 
   &lt;a href=&quot;#section-19.3&quot;&gt;19.3&lt;/a&gt;  Tolerant Applications 
   &lt;a href=&quot;#section-19.4&quot;&gt;19.4&lt;/a&gt;  Differences Between HTTP Entities and &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; Entities .... 

   &lt;a href=&quot;#section-19.4.1&quot;&gt;19.4.1&lt;/a&gt;   MIME-Version 
   &lt;a href=&quot;#section-19.4.2&quot;&gt;19.4.2&lt;/a&gt;   Conversion to Canonical Form 
   &lt;a href=&quot;#section-19.4.3&quot;&gt;19.4.3&lt;/a&gt;   Conversion of Date Formats 
   &lt;a href=&quot;#section-19.4.4&quot;&gt;19.4.4&lt;/a&gt;   Introduction of Content-Encoding 
   &lt;a href=&quot;#section-19.4.5&quot;&gt;19.4.5&lt;/a&gt;   No Content-Transfer-Encoding 
   &lt;a href=&quot;#section-19.4.6&quot;&gt;19.4.6&lt;/a&gt;   Introduction of Transfer-Encoding 
   &lt;a href=&quot;#section-19.4.7&quot;&gt;19.4.7&lt;/a&gt;   MHTML and Line Length Limitations 
   &lt;a href=&quot;#section-19.5&quot;&gt;19.5&lt;/a&gt;  Additional Features 
   &lt;a href=&quot;#section-19.5.1&quot;&gt;19.5.1&lt;/a&gt;   Content-Disposition 
   &lt;a href=&quot;#section-19.6&quot;&gt;19.6&lt;/a&gt;  Compatibility with Previous Versions 
   &lt;a href=&quot;#section-19.6.1&quot;&gt;19.6.1&lt;/a&gt;   Changes from HTTP/1.0 
   &lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt;   Compatibility with HTTP/1.0 Persistent Connections 
   &lt;a href=&quot;#section-19.6.3&quot;&gt;19.6.3&lt;/a&gt;   Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;&lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt;   Index 
   &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt;   Full Copyright Statement</source>
          <target state="translated">Статус этой памятки Этот документ определяет протокол отслеживания стандартов Интернета для Интернет-сообщества и требует обсуждения и предложений по улучшениям. См. Текущую редакцию &amp;laquo;Официальных стандартов протокола Интернета&amp;raquo; (STD 1), чтобы узнать о состоянии стандартизации и статусе этого протокола. Распространение этой памятки не ограничено. Уведомление об авторских правах Авторские права (C) The Internet Society (1999). Все права защищены. Аннотация Протокол передачи гипертекста (HTTP) - это протокол прикладного уровня для распределенных, совместных гипермедийных информационных систем. Это общий протокол без сохранения состояния, который можно использовать для многих задач, помимо использования для гипертекста, таких как серверы имен и системы управления распределенными объектами, путем расширения его методов запроса,коды ошибок и заголовки [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt; ]. Особенностью HTTP является типизация и согласование представления данных, что позволяет создавать системы независимо от передаваемых данных. HTTP используется глобальной информационной инициативой World-Wide Web с 1990 года. Эта спецификация определяет протокол, называемый &amp;laquo;HTTP / 1.1&amp;raquo;, и является обновлением &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]. Содержание &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; Введение &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; Цель &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; Требования &lt;a href=&quot;#section-1.3&quot;&gt;1.3&lt;/a&gt; Терминология &lt;a href=&quot;#section-1.4&quot;&gt;1.4&lt;/a&gt; Общая работа &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; Условные обозначения и общая грамматика &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; Расширенный BNF &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; Основные правила &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; Параметры протокола &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; HTTP версии &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; Унифицированные идентификаторы ресурсов &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt; Общий синтаксис &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt; http URL &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt; Сравнение URI &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; Форматы даты и времени &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt; Полная дата &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt; Дельта-секунды &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; Наборы символов &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1&lt;/a&gt; Отсутствующая кодировка &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt; Кодирование содержимого &lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt; Кодирование передачи &lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1&lt;/a&gt; Разделенное кодирование передачи &lt;a href=&quot;#section-3.7&quot;&gt;3.7&lt;/a&gt; Типы носителей &lt;a href=&quot;#section-3.7.1&quot;&gt;3.7.1&lt;/a&gt; Канонизация и текстовые значения по умолчанию &lt;a href=&quot;#section-3.7.2&quot;&gt;3.7.2&lt;/a&gt; Составные типы &lt;a href=&quot;#section-3.8&quot;&gt;3.8&lt;/a&gt; Токены продукта &lt;a href=&quot;#section-3.9&quot;&gt;3.9&lt;/a&gt; Значения качества &lt;a href=&quot;#section-3.10&quot;&gt;3.10&lt;/a&gt; Языковые теги &lt;a href=&quot;#section-3.11&quot;&gt;3.11&lt;/a&gt; Теги сущностей &lt;a href=&quot;#section-3.12&quot;&gt;3.12&lt;/a&gt; Единицы диапазона &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; HTTP-сообщение &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; Типы сообщений &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; Заголовки сообщения &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; Тело сообщения &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; Длина сообщения &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt; Общие поля заголовка &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; Запрос &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; Строка запроса &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1 .1&lt;/a&gt; Метод &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt; Request-URI &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; Ресурс, идентифицированный запросом &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; Поля заголовка запроса &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; Ответ &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; Строка состояния &lt;a href=&quot;#section-6.1.1&quot;&gt;6.1.1&lt;/a&gt; Код состояния и фраза причины &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; Поля заголовка ответа ..................... ................. &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; Сущность &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; Поля заголовка сущности &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; Тело сущности &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt; Тип &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt; Длина сущности &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; Соединения &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; Постоянные соединения &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt; Цель &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt; Общая работа &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1 0,3&lt;/a&gt; Прокси-серверы &lt;a href=&quot;#section-8.1.4&quot;&gt;8.1.4&lt;/a&gt; Практические соображения &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; Требования к передаче сообщений &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt; Постоянные соединения и управление потоком &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt; Мониторинг соединений для сообщений о состоянии ошибок &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3&lt;/a&gt; Использование состояния 100 (продолжить) &lt;a href=&quot;#section-8.2.4&quot;&gt;8.2.4&lt;/a&gt; Поведение клиента, если сервер преждевременно закрывает соединение. .50 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; Определения методов &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; Безопасные и идемпотентные методы &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt; Безопасные методы &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt; Идемпотентные методы &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; ОПЦИИ &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; GET &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt; HEAD &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt; POST &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; PUT &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt; DELETE &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; TRACE &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt; CONNECT &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; Определения кодов состояния &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; Информационные 1xx &lt;a href=&quot;#section-10.1.1&quot;&gt;10.1.1&lt;/a&gt; 100 Продолжить &lt;a href=&quot;#section-10.1.2&quot;&gt;10.1.2&lt;/a&gt; 101 Протоколы переключения &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; Успешно 2xx &lt;a href=&quot;#section-10.2.1&quot;&gt;10.2.1&lt;/a&gt; 200 OK &lt;a href=&quot;#section-10.2.2&quot;&gt;10.2.2&lt;/a&gt; 201 Создано &lt;a href=&quot;#section-10.2.3&quot;&gt;10.2.3&lt;/a&gt; 202 Принято &lt;a href=&quot;#section-10.2.4&quot;&gt;10.2.4&lt;/a&gt; 203 &lt;a href=&quot;#section-10.2.7&quot;&gt;Неавторизованная&lt;/a&gt; информация &lt;a href=&quot;#section-10.2.5&quot;&gt;10.2.5&lt;/a&gt; 204 Нет содержимого &lt;a href=&quot;#section-10.2.6&quot;&gt;10.2.6&lt;/a&gt; 205 Сбросить содержимое 10.2.7 206 Частичное содержимое &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt; Перенаправление 3xx &lt;a href=&quot;#section-10.3.1&quot;&gt;10.3.1&lt;/a&gt; 300 Множественный выбор &lt;a href=&quot;#section-10.3.2&quot;&gt;10.3.2&lt;/a&gt; 301 Перемещено постоянно &lt;a href=&quot;#section-10.3.3&quot;&gt;10.3.3&lt;/a&gt; 302 Найдено &lt;a href=&quot;#section-10.3.4&quot;&gt;10.3.4&lt;/a&gt; 303 См. Другое &lt;a href=&quot;#section-10.3.5&quot;&gt;10.3.5&lt;/a&gt; 304 Не &lt;a href=&quot;#section-10.3.6&quot;&gt;изменено 10.3.6&lt;/a&gt; 305 Использовать прокси &lt;a href=&quot;#section-10.3.7&quot;&gt;10.3.7&lt;/a&gt; 306 (Не используется) .. ........................................... &lt;a href=&quot;#section-10.3.8&quot;&gt;10.3.8&lt;/a&gt; 307 Временное перенаправление &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt; Ошибка клиента 4xx &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt; 400 Bad Request &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt; 401 Unauthorized &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; 402 Payment Required &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt; 403 Запрещено &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt; 404 Не найдено &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt; Метод 405 &lt;a href=&quot;#section-10.4.7&quot;&gt;Недопустим 10.4.7&lt;/a&gt; 406 Неприемлем &lt;a href=&quot;#section-10.4.8&quot;&gt;10.4.8&lt;/a&gt; 407 Требуется аутентификация прокси &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt; Тайм-аут запроса 408 &lt;a href=&quot;#section-10.4.10&quot;&gt;10.4.10&lt;/a&gt; Конфликт 409 &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt; 410 Gone &lt;a href=&quot;#section-10.4.12&quot;&gt;10.4.12&lt;/a&gt; 411 Требуется длина &lt;a href=&quot;#section-10.4.13&quot;&gt;10.4.13&lt;/a&gt; 412 Precondition Failed &lt;a href=&quot;#section-10.4.14&quot;&gt;10.4.14&lt;/a&gt; 413 Request Entity Too Large &lt;a href=&quot;#section-10.4.15&quot;&gt;10.4.15&lt;/a&gt; 414 Request-URI Too Long &lt;a href=&quot;#section-10.4.16&quot;&gt;10.4.16&lt;/a&gt; 415 Unsupported Media Type &lt;a href=&quot;#section-10.4.17&quot;&gt;10.4.17&lt;/a&gt; 416 Запрошенный диапазон не выполняется &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt; Ошибка ожидания 417 &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt; Ошибка сервера 5xx &lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1&lt;/a&gt; Внутренняя ошибка сервера 500 &lt;a href=&quot;#section-10.5.2&quot;&gt;10.5.2&lt;/a&gt; 501 Не реализовано &lt;a href=&quot;#section-10.5.3&quot;&gt;10.5.3 &lt;/a&gt;&lt;a href=&quot;#section-10.5.5&quot;&gt;Неверный&lt;/a&gt; шлюз 502 &lt;a href=&quot;#section-10.5.4&quot;&gt;10.5.4&lt;/a&gt; Служба 503 недоступна 10.5.5 Тайм-аут шлюза 504 &lt;a href=&quot;#section-10.5.6&quot;&gt;10.5.6&lt;/a&gt; Версия HTTP 505 не поддерживается &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; Аутентификация доступа &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt; Согласование содержимого &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt; Согласование, управляемое сервером &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt; Согласование, управляемое агентом &lt;a href=&quot;#section-12.3&quot;&gt;12.3&lt;/a&gt; Прозрачное согласование &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt; Кэширование в HTTP &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt; Корректность кэша &lt;a href=&quot;#section-13.1.2&quot;&gt;13.1.2&lt;/a&gt; Предупреждения &lt;a href=&quot;#section-13.1.3&quot;&gt;13.1.3&lt;/a&gt; Механизмы управления &lt;a href=&quot;#section-13.1.4&quot;&gt;кешем 13.1.4&lt;/a&gt; Явные предупреждения пользовательского агента &lt;a href=&quot;#section-13.1.5&quot;&gt;13.1.5&lt;/a&gt; Исключения из правил и предупреждений &lt;a href=&quot;#section-13.1.6&quot;&gt;13.1.6&lt;/a&gt; Поведение, контролируемое клиентом &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; Модель срока действия &lt;a href=&quot;#section-13.2.1&quot;&gt;13.2.1&lt;/a&gt; Срок действия, определяемый сервером &lt;a href=&quot;#section-13.2.2&quot;&gt;13.2.2&lt;/a&gt; Эвристика Срок годности &lt;a href=&quot;#section-13.2.3&quot;&gt;13.2.3&lt;/a&gt; Расчет возраста &lt;a href=&quot;#section-13.2.4&quot;&gt;13.2.4&lt;/a&gt; Расчет срока годности &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5 Устранение неоднозначности&lt;/a&gt; значений срока годности &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6 Устранение неоднозначности&lt;/a&gt; множественных ответов &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt; Модель валидации &lt;a href=&quot;#section-13.3.1&quot;&gt;13.3.1&lt;/a&gt; Даты последнего изменения ..................................... &lt;a href=&quot;#section-13.3.2&quot;&gt;13.3.2&lt;/a&gt; Тег объекта Валидаторы кэша &lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt; Слабые и сильные валидаторы 13.3.4 Правила, когда следует использовать теги объектов и даты последнего изменения89 13.3.5 &lt;a href=&quot;#section-13.3.5&quot;&gt;Условные условия&lt;/a&gt; без проверки &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt; Кэшируемость ответов &lt;a href=&quot;#section-13.5&quot;&gt;13.5&lt;/a&gt; Создание ответов из &lt;a href=&quot;#section-13.5.1&quot;&gt;кешей 13.5.1&lt;/a&gt; Сквозная и Hop-на-HOP Заголовки &lt;a href=&quot;#section-13.5.2&quot;&gt;13.5.2&lt;/a&gt; немодифицируемых Заголовки &lt;a href=&quot;#section-13.5.3&quot;&gt;13.5.3&lt;/a&gt; Комбинирование Заголовки &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt; Совмещение Byte Ranges &lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt; Кэширование переговорных ответов &lt;a href=&quot;#section-13.7&quot;&gt;13,7&lt;/a&gt; Shared и неразделяемых кэша &lt;a href=&quot;#section-13.8&quot;&gt;13,8&lt;/a&gt; Ошибка или Неполное Поведение Cache Response &lt;a href=&quot;#section-13.9&quot;&gt;+13,9&lt;/a&gt; Побочные эффекты GET и ГОЛОВА &lt;a href=&quot;#section-13.10&quot;&gt;13,10&lt;/a&gt; утратившие После обновления или Deletions &lt;a href=&quot;#section-13.11&quot;&gt;13,11&lt;/a&gt; Write-Through Обязательного &lt;a href=&quot;#section-13.12&quot;&gt;13,12&lt;/a&gt; Cache Замена &lt;a href=&quot;#section-13.13&quot;&gt;13.13&lt;/a&gt; Списков Истории &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt; Header Поля Определение &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt; Accept &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt; Accept-Charset &lt;a href=&quot;#section-14.3&quot;&gt;14,3&lt;/a&gt; Accept- Кодирование &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt; Accept-Language &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt; Accept-Ranges &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt; Age &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt; Allow &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt; Авторизация &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt; Cache-Control &lt;a href=&quot;#section-14.9.1&quot;&gt;14.9.1&lt;/a&gt; Что является кешируемым &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt; Что может храниться в &lt;a href=&quot;#section-14.9.3&quot;&gt;кешах 14.9.3&lt;/a&gt; Модификации базового механизма истечения срока &lt;a href=&quot;#section-14.9.4&quot;&gt;14.9.4&lt;/a&gt; Повторная проверка и управление &lt;a href=&quot;#section-14.9.5&quot;&gt;перезагрузкой&lt;/a&gt; кеша 14.9.5 Директива об отсутствии преобразования &lt;a href=&quot;#section-14.9.6&quot;&gt;14.9.6&lt;/a&gt; Расширения управления кешем &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt; Соединение &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt; Content-Encoding &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt; Content-Language &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt; Content-Length &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt; Content-Location &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt; Content-MD5 &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt; Content-Range &lt;a href=&quot;#section-14.17&quot;&gt;14,17&lt;/a&gt; Content-Type &lt;a href=&quot;#section-14.18&quot;&gt;14,18&lt;/a&gt; Дата &lt;a href=&quot;#section-14.18.1&quot;&gt;14.18.1&lt;/a&gt; Clockless Origin сервера Операция &lt;a href=&quot;#section-14.19&quot;&gt;14,19&lt;/a&gt; ETag &lt;a href=&quot;#section-14.20&quot;&gt;14,20&lt;/a&gt; Ожидайте &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt; Истекает &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt; От .......................... ........................... &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; Хост &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; If-Match &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt; If-Modified-Since &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; If-None-Match &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt; If-Range &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt; If-Unmodified-Since &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt; Last-Modified &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt; Местоположение &lt;a href=&quot;#section-14.31&quot;&gt;14.31&lt;/a&gt; Max-Нападающие &lt;a href=&quot;#section-14.32&quot;&gt;14,32&lt;/a&gt; Pragma &lt;a href=&quot;#section-14.33&quot;&gt;14,33&lt;/a&gt; Proxy-Authenticate &lt;a href=&quot;#section-14.34&quot;&gt;14,34&lt;/a&gt; Proxy-Authorization &lt;a href=&quot;#section-14.35&quot;&gt;14,35&lt;/a&gt; Диапазон &lt;a href=&quot;#section-14.35.1&quot;&gt;14.35.1&lt;/a&gt; Byte Ranges &lt;a href=&quot;#section-14.35.2&quot;&gt;14.35.2&lt;/a&gt; Диапазон индексирование запросов &lt;a href=&quot;#section-14.36&quot;&gt;14,36&lt;/a&gt; Referer &lt;a href=&quot;#section-14.37&quot;&gt;14,37&lt;/a&gt; Retry-After &lt;a href=&quot;#section-14.38&quot;&gt;14,38&lt;/a&gt; Сервер &lt;a href=&quot;#section-14.39&quot;&gt;14,39&lt;/a&gt; TE &lt;a href=&quot;#section-14.40&quot;&gt;14,40&lt;/a&gt; Прицеп &lt;a href=&quot;#section-14.41&quot;&gt;14,41&lt;/a&gt; Transfer-Encoding &lt;a href=&quot;#section-14.42&quot;&gt;14,42&lt;/a&gt; Реконструкция &lt;a href=&quot;#section-14.43&quot;&gt;14,43&lt;/a&gt; User-Agent &lt;a href=&quot;#section-14.44&quot;&gt;14,44&lt;/a&gt; Варах &lt;a href=&quot;#section-14.45&quot;&gt;14.45&lt;/a&gt; через &lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt; Предупреждение &lt;a href=&quot;#section-14.47&quot;&gt;14.47&lt;/a&gt; WWW-аутентификация &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt; Соображения безопасности &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt; Личная информация &lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt; Злоупотребление информацией журнала сервера &lt;a href=&quot;#section-15.1.2&quot;&gt;15.1.2&lt;/a&gt; Передача конфиденциальной информации &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3&lt;/a&gt; Кодирование конфиденциальной информации в URI &lt;a href=&quot;#section-15.1.4&quot;&gt;15.1.4&lt;/a&gt; Проблемы конфиденциальности, связанные с принятием заголовков &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt; Атаки на основе файла и пути Имена &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt; Спуфинг DNS &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt; Заголовки местоположения и спуфинг &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt; Проблемы с размещением содержимого &lt;a href=&quot;#section-15.6&quot;&gt;15.6 Учетные данные для&lt;/a&gt; аутентификации и неактивные клиенты &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt; Прокси-серверы и кэширование &lt;a href=&quot;#section-15.7.1&quot;&gt;15.7.1&lt;/a&gt; Атаки отказа в обслуживании на прокси-серверах &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt; Подтверждения &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt; Ссылки &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt; Адреса авторов &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt; Приложения &lt;a href=&quot;#section-19.1&quot;&gt;19.1&lt;/a&gt; Тип интернет-носителя: сообщение / http и приложение / http &lt;a href=&quot;#section-19.2&quot;&gt;19.2&lt;/a&gt; Тип интернет-носителя multipart / byteranges &lt;a href=&quot;#section-19.3&quot;&gt;19.3&lt;/a&gt; Толерантные приложения &lt;a href=&quot;#section-19.4&quot;&gt;19.4&lt;/a&gt; Различия между объектами HTTP и &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; объектов .... &lt;a href=&quot;#section-19.4.1&quot;&gt;19.4.1&lt;/a&gt; MIME-версия &lt;a href=&quot;#section-19.4.2&quot;&gt;19.4.2&lt;/a&gt; Преобразование в каноническую форму &lt;a href=&quot;#section-19.4.3&quot;&gt;19.4.3&lt;/a&gt; Преобразование форматов даты &lt;a href=&quot;#section-19.4.4&quot;&gt;19.4.4&lt;/a&gt; Введение в Content-Encoding &lt;a href=&quot;#section-19.4.5&quot;&gt;19.4.5&lt;/a&gt; Отсутствие Content-Transfer-Encoding &lt;a href=&quot;#section-19.4.6&quot;&gt;19.4.6&lt;/a&gt; Введение в Transfer-Encoding &lt;a href=&quot;#section-19.4.7&quot;&gt;19.4.7&lt;/a&gt; MHTML и ограничения длины строки &lt;a href=&quot;#section-19.5&quot;&gt;19.5&lt;/a&gt; Дополнительные функции &lt;a href=&quot;#section-19.5.1&quot;&gt;19.5.1&lt;/a&gt; Content-Disposition &lt;a href=&quot;#section-19.6&quot;&gt;19.6&lt;/a&gt; Совместимость с предыдущими &lt;a href=&quot;#section-19.6.1&quot;&gt;версиями 19.6.1&lt;/a&gt; Изменения по &lt;a href=&quot;#section-19.6.2&quot;&gt;сравнению&lt;/a&gt; с HTTP / 1.0 19.6.2 Совместимость с постоянными соединениями HTTP / 1.0 &lt;a href=&quot;#section-19.6.3&quot;&gt;19.6.3&lt;/a&gt; Изменения по сравнению с &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068 &lt;/a&gt;&lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt; Указатель &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt; Полное заявление об авторских правах</target>
        </trans-unit>
        <trans-unit id="d08c83f00b0f35b12328f45a668424f28ef4c379" translate="yes" xml:space="preserve">
          <source>Storing Responses in Caches (RFC 7234)</source>
          <target state="translated">Хранение ответов в кэше (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="7ff86787ade1bf61ad2e59270f3c9e57589ff5d5" translate="yes" xml:space="preserve">
          <source>Stream priorities are changed using the PRIORITY frame.  Setting a
   dependency causes a stream to become dependent on the identified
   parent stream.

   Dependent streams move with their parent stream if the parent is
   reprioritized.  Setting a dependency with the exclusive flag for a
   reprioritized stream causes all the dependencies of the new parent
   stream to become dependent on the reprioritized stream.

   If a stream is made dependent on one of its own dependencies, the
   formerly dependent stream is first moved to be dependent on the
   reprioritized stream's previous parent.  The moved dependency retains
   its weight.

   For example, consider an original dependency tree where B and C
   depend on A, D and E depend on C, and F depends on D.  If A is made
   dependent on D, then D takes the place of A.  All other dependency
   relationships stay the same, except for F, which becomes dependent on
   A if the reprioritization is exclusive. 

       x                x                x                 x
       |               / \               |                 |
       A              D   A              D                 D
      / \            /   / \            / \                |
     B   C     ==&amp;gt;  F   B   C   ==&amp;gt;    F   A       OR      A
        / \                 |             / \             /|\
       D   E                E            B   C           B C F
       |                                     |             |
       F                                     E             E
                  (intermediate)   (non-exclusive)    (exclusive)

                Figure 5: Example of Dependency Reordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce8f34f0a23969364026999a31bec5f7b65b0ae" translate="yes" xml:space="preserve">
          <source>Streams are identified with an unsigned 31-bit integer.  Streams
   initiated by a client MUST use odd-numbered stream identifiers; those
   initiated by the server MUST use even-numbered stream identifiers.  A
   stream identifier of zero (0x0) is used for connection control
   messages; the stream identifier of zero cannot be used to establish a
   new stream.

   HTTP/1.1 requests that are upgraded to HTTP/2 (see &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;) are
   responded to with a stream identifier of one (0x1).  After the
   upgrade completes, stream 0x1 is &quot;half-closed (local)&quot; to the client.
   Therefore, stream 0x1 cannot be selected as a new stream identifier
   by a client that upgrades from HTTP/1.1.

   The identifier of a newly established stream MUST be numerically
   greater than all streams that the initiating endpoint has opened or
   reserved.  This governs streams that are opened using a HEADERS frame
   and streams that are reserved using PUSH_PROMISE.  An endpoint that
   receives an unexpected stream identifier MUST respond with a
   connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   The first use of a new stream identifier implicitly closes all
   streams in the &quot;idle&quot; state that might have been initiated by that
   peer with a lower-valued stream identifier.  For example, if a client
   sends a HEADERS frame on stream 7 without ever sending a frame on
   stream 5, then stream 5 transitions to the &quot;closed&quot; state when the
   first frame for stream 7 is sent or received.

   Stream identifiers cannot be reused.  Long-lived connections can
   result in an endpoint exhausting the available range of stream
   identifiers.  A client that is unable to establish a new stream
   identifier can establish a new connection for new streams.  A server
   that is unable to establish a new stream identifier can send a GOAWAY
   frame so that the client is forced to open a new connection for new
   streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c0b3831b3706354655bc626dc41410ec27c9ee" translate="yes" xml:space="preserve">
          <source>Strict Transport Security resolves this problem; as long as you've accessed your bank's web site once using HTTPS, and the bank's web site uses Strict Transport Security, your browser will know to automatically use only HTTPS, which prevents hackers from performing this sort of man-in-the-middle attack.</source>
          <target state="translated">Строгая транспортная безопасность решает эту проблему;до тех пор,пока вы получили доступ к веб-сайту вашего банка один раз с помощью HTTPS,и веб-сайт банка использует строгую транспортную безопасность,ваш браузер будет знать,что автоматически использовать только HTTPS,что предотвращает хакеров от выполнения такого рода man-in-the-middle атаки.</target>
        </trans-unit>
        <trans-unit id="fc587e4b5dd9c8f2dabaee348836f36fc9073981" translate="yes" xml:space="preserve">
          <source>Strict-Transport-Security</source>
          <target state="translated">Strict-Transport-Security</target>
        </trans-unit>
        <trans-unit id="b47d9bc682e1c7c17d99058428f34fc877b82f8a" translate="yes" xml:space="preserve">
          <source>Strong validation</source>
          <target state="translated">Сильное подтверждение</target>
        </trans-unit>
        <trans-unit id="bce009dcd1fa74e08bb9b002217d1633ae7d181e" translate="yes" xml:space="preserve">
          <source>Strong validation consists of guaranteeing that the resource is, byte to byte, identical to the one it is compared too. This is mandatory for some conditional headers, and the default for the others. Strong validation is very strict and may be difficult to guarantee at the server level, but it does guarantee no data loss at any time, sometimes at the expense of performance.</source>
          <target state="translated">Сильная валидация состоит в том,чтобы гарантировать,что ресурс,байт за байтом,тоже идентичен сравниваемому.Это обязательно для одних условных заголовков,а для других-по умолчанию.Сильная валидация очень строгая и может быть трудно гарантировать на уровне сервера,но она не гарантирует потери данных в любой момент времени,иногда за счет производительности.</target>
        </trans-unit>
        <trans-unit id="546f797f485e1c93debf33798738f22e2e2c71a9" translate="yes" xml:space="preserve">
          <source>Structure of a MIME type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9b0645b4584767c896ce8933cbb6a249c16aa0" translate="yes" xml:space="preserve">
          <source>Structure of a server response</source>
          <target state="translated">Структура ответа сервера</target>
        </trans-unit>
        <trans-unit id="87e09f53c79b7b9952020efdce6fce234ef5dd58" translate="yes" xml:space="preserve">
          <source>Subnet based decisions</source>
          <target state="translated">Решения на основе подсети</target>
        </trans-unit>
        <trans-unit id="d0b8ad91fc39a9beb48e35304c9f430f0a69862b" translate="yes" xml:space="preserve">
          <source>Subresource Integrity</source>
          <target state="translated">Целостность субресурсов</target>
        </trans-unit>
        <trans-unit id="983f9ac400958792e64abc2d44401492ed778563" translate="yes" xml:space="preserve">
          <source>Subresource Integrity&lt;br/&gt;&lt;small&gt;The definition of 'require-sri-for' in that specification.&lt;/small&gt;</source>
          <target state="translated">Целостность подресурсов &lt;br/&gt;&lt;small&gt;Определение &amp;laquo;require-sri-for&amp;raquo; в этой спецификации.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="522495833932f57c0df7141327df306caf0e6ac3" translate="yes" xml:space="preserve">
          <source>Subsequent lines represent an HTTP header, giving the server information about what type of data is appropriate (e.g., what language, what MIME types), or other data altering its behavior (e.g., not sending an answer if it is already cached). These HTTP headers form a block which ends with an empty line.</source>
          <target state="translated">Последующие строки представляют собой HTTP-заголовок,дающий серверу информацию о том,какой тип данных подходит (например,какой язык,какие MIME-типы),или другие данные,изменяющие его поведение (например,не посылать ответ,если он уже кэширован).Эти HTTP заголовки образуют блок,который заканчивается пустой строкой.</target>
        </trans-unit>
        <trans-unit id="8d055925604926e85c70a546b297fe94724c7c5d" translate="yes" xml:space="preserve">
          <source>Subsequent lines represent specific HTTP headers, giving the client information about the data sent (e.g. type, data size, compression algorithm used, hints about caching). Similarly to the block of HTTP headers for a client request, these HTTP headers form a block ending with an empty line.</source>
          <target state="translated">Последующие строки представляют собой специфические HTTP-заголовки,дающие клиенту информацию об отправленных данных (например,тип,размер данных,используемый алгоритм сжатия,подсказки о кэшировании).Подобно блоку HTTP-заголовков для клиентского запроса,эти HTTP-заголовки образуют блок,заканчивающийся пустой строкой.</target>
        </trans-unit>
        <trans-unit id="56befc0f91be9db5dc24b49f4e5533e7ea0072f5" translate="yes" xml:space="preserve">
          <source>Subsequent sections discuss scenarios, as well as provide a breakdown of the HTTP headers used.</source>
          <target state="translated">В последующих разделах обсуждаются сценарии,а также приводится разбивка используемых заголовков HTTP.</target>
        </trans-unit>
        <trans-unit id="ff5c588e9523269ce3c84f63e9bd3897ebe63eec" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; of the distant resource is different to each listed in this header. By default, unless the etag is prefixed with &lt;code&gt;'W/'&lt;/code&gt;, it performs a strong validation.</source>
          <target state="translated">Успешно, если &lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; удаленного ресурса отличается от каждого из перечисленных в этом заголовке. По умолчанию, если etag не имеет префикса &lt;code&gt;'W/'&lt;/code&gt; , выполняется строгая проверка.</target>
        </trans-unit>
        <trans-unit id="aeef7e868363979461d6ea2ad7bf8c6358e365a2" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; of the distant resource is equal to one listed in this header. By default, unless the etag is prefixed with &lt;code&gt;'W/'&lt;/code&gt;, it performs a strong validation.</source>
          <target state="translated">Успешно, если &lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; удаленного ресурса равен указанному в этом заголовке. По умолчанию, если etag не имеет префикса &lt;code&gt;'W/'&lt;/code&gt; , выполняется строгая проверка.</target>
        </trans-unit>
        <trans-unit id="2c3bd70cb1b0ac4e3f147078e58e04d441ea7e0e" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; date of the distant resource is more recent than the one given in this header.</source>
          <target state="translated">Успешно, если дата &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; удаленного ресурса более поздняя, ​​чем указанная в этом заголовке.</target>
        </trans-unit>
        <trans-unit id="54dce543ac7122114b0f1b25a6c18db4700a57c7" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; date of the distant resource is older or the same than the one given in this header.</source>
          <target state="translated">Успешно, если дата &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; удаленного ресурса старше или совпадает с датой, указанной в этом заголовке.</target>
        </trans-unit>
        <trans-unit id="1290a72cee06cf30f2b9582a53c05c695119f17b" translate="yes" xml:space="preserve">
          <source>Successful response has body</source>
          <target state="translated">Успешная реакция имеет тело</target>
        </trans-unit>
        <trans-unit id="d702cfd3f57a8cfe18b4f37a36bf15bc2c548094" translate="yes" xml:space="preserve">
          <source>Successful responses</source>
          <target state="translated">Успешные ответы</target>
        </trans-unit>
        <trans-unit id="47bd58ec264925cf6d2934f949144bd5b42d3e5b" translate="yes" xml:space="preserve">
          <source>Successful responses (&lt;code&gt;200&lt;/code&gt;&amp;ndash;&lt;code&gt;299&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e16e36ee4dff516de670a1cd0a9ef3f413ae5fb" translate="yes" xml:space="preserve">
          <source>Successful results of a retrieval request: a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (OK) response to a &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request containing a resource like HTML documents, images or files.</source>
          <target state="translated">Успешные результаты поискового запроса: ответ &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; (OK) на запрос &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; ,&lt;/a&gt; содержащий такой ресурс, как HTML-документы, изображения или файлы.</target>
        </trans-unit>
        <trans-unit id="7cf7d910e383411b293ea5c44eeeb1c0a4a4a122" translate="yes" xml:space="preserve">
          <source>Successful web page response:</source>
          <target state="translated">Успешный ответ веб-страницы:</target>
        </trans-unit>
        <trans-unit id="201d1d5e3d5c9d5de591a119116dd6b9386319e3" translate="yes" xml:space="preserve">
          <source>Supplants the &lt;code&gt;Origin&lt;/code&gt; header as defined in RFC6454.</source>
          <target state="translated">Подменяет заголовок &lt;code&gt;Origin&lt;/code&gt; , как определено в RFC6454.</target>
        </trans-unit>
        <trans-unit id="216a84fbd27cb3b4473b824b61cc5de56085403b" translate="yes" xml:space="preserve">
          <source>Support for the &lt;code&gt;Retry-After&lt;/code&gt; header on both clients and servers is still inconsistent. However, some crawlers and spiders, like the Googlebot, honor the &lt;code&gt;Retry-After&lt;/code&gt; header. It is useful to send it along with a &lt;a href=&quot;../status/503&quot;&gt;&lt;code&gt;503&lt;/code&gt;&lt;/a&gt; (Service Unavailable) response, so that search engines will keep indexing your site when the downtime is over.</source>
          <target state="translated">Поддержка заголовка &lt;code&gt;Retry-After&lt;/code&gt; как на клиентах, так и на серверах по-прежнему несовместима. Однако некоторые сканеры и пауки, такие как Googlebot, &lt;code&gt;Retry-After&lt;/code&gt; заголовок Retry-After . Полезно отправить его вместе с ответом &lt;a href=&quot;../status/503&quot;&gt; &lt;code&gt;503&lt;/code&gt; &lt;/a&gt; (служба недоступна), чтобы поисковые системы продолжали индексировать ваш сайт, когда время простоя закончится.</target>
        </trans-unit>
        <trans-unit id="4c6167e7995d17c7bc37724de85e632d49fe0fd7" translate="yes" xml:space="preserve">
          <source>Support of &lt;a href=&quot;../headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; allows the dissociation of the identification and the location of a given resource, allowing for a smarter &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CDN&quot;&gt;CDN&lt;/a&gt; caching mechanism.</source>
          <target state="translated">Поддержка &lt;a href=&quot;../headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; &lt;/a&gt; позволяет разделить идентификацию и местоположение данного ресурса, что позволяет использовать более умный механизм кэширования &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CDN&quot;&gt;CDN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5557d57c74c062096ddfe6fcacebab65584a47fd" translate="yes" xml:space="preserve">
          <source>Supported digest algorithms are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3230&quot;&gt;RFC 3230&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc5843&quot;&gt;RFC 5843&lt;/a&gt;, and include &lt;code&gt;SHA-256&lt;/code&gt; and &lt;code&gt;SHA-512&lt;/code&gt;. Some of the supported algorithms, including &lt;code&gt;unixsum&lt;/code&gt; and &lt;code&gt;MD5&lt;/code&gt; are subject to collisions and are thus not suitable for applications in which collision-resistance is important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf8d0d7c981d663797eeaca7523e977bed4ab51" translate="yes" xml:space="preserve">
          <source>Supporting OCSP stapling (that is, the &lt;code&gt;status_request&lt;/code&gt; TLS extension) and providing a &lt;code&gt;SignedCertificateTimestampList&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d598d97e68fd3cf7ac8ec2441b332f10d641fc" translate="yes" xml:space="preserve">
          <source>Switch to a blacklist model for restricted Accept headers in simple CORS requests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ebc7fe25f3af6b8e76fe3b492c6dd20ec4df27" translate="yes" xml:space="preserve">
          <source>Switching protocols might be used with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API&quot;&gt;WebSockets&lt;/a&gt;.</source>
          <target state="translated">Протоколы переключения могут использоваться с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API&quot;&gt;WebSockets&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00d7e2af1a23453b6e8dc5b63832fd4a645bc527" translate="yes" xml:space="preserve">
          <source>Synchronous XMLHTTPRequest</source>
          <target state="translated">Синхронный XMLHTTPRequest</target>
        </trans-unit>
        <trans-unit id="4103f0b31624fefeee3cf5f8642cc1c83ff9a978" translate="yes" xml:space="preserve">
          <source>Synchronous XMLHttpRequest</source>
          <target state="translated">Синхронный XMLHttpRequest</target>
        </trans-unit>
        <trans-unit id="be9208425b9c861fee1e1a67180b55dad01dafe7" translate="yes" xml:space="preserve">
          <source>Synchronous scripts</source>
          <target state="translated">Синхронные скрипты</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="791a9bf2077653138c6b3912f9bf31ac1b906662" translate="yes" xml:space="preserve">
          <source>Syntax of Uniform Resource Identifiers (URIs)</source>
          <target state="translated">Синтаксис унифицированных идентификаторов ресурсов (URI)</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="b10d92078103e058dd32c50f84517f2c9bcce935" translate="yes" xml:space="preserve">
          <source>TCP connection to the server timed out</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a056389515bd999bc97e7793f7c147c0b47eac3" translate="yes" xml:space="preserve">
          <source>TCP port number on which the server is listening.</source>
          <target state="translated">Номер TCP порта,на котором прослушивается сервер.</target>
        </trans-unit>
        <trans-unit id="49a198744d47717f2dedc61eda3abad936b310a2" translate="yes" xml:space="preserve">
          <source>TCP port number on which the server is listening. If no port is given, the default port for the service requested (e.g., &quot;80&quot; for an HTTP URL) is implied.</source>
          <target state="translated">Номер TCP порта,на котором прослушивается сервер.Если порт не указан,подразумевается порт по умолчанию для запрашиваемой службы (например,&quot;80&quot; для HTTP URL).</target>
        </trans-unit>
        <trans-unit id="1945ca5513cf77b8240e53495ba7a26e86acaca7" translate="yes" xml:space="preserve">
          <source>TE</source>
          <target state="translated">TE</target>
        </trans-unit>
        <trans-unit id="2dd200ebd9f2359780d12717e9c2166303c7a6d3" translate="yes" xml:space="preserve">
          <source>TE (RFC 2616)</source>
          <target state="translated">ТЭ (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="a775b64f2cd6a88a198986d46d44e0a021785125" translate="yes" xml:space="preserve">
          <source>TIFF</source>
          <target state="translated">TIFF</target>
        </trans-unit>
        <trans-unit id="b698c11e84460ed5999bfeb5cbf25b865c238f3c" translate="yes" xml:space="preserve">
          <source>TODO</source>
          <target state="translated">TODO</target>
        </trans-unit>
        <trans-unit id="ddf8a55c683ee58c6268b4264acb1d703195d588" translate="yes" xml:space="preserve">
          <source>TRACE</source>
          <target state="translated">TRACE</target>
        </trans-unit>
        <trans-unit id="0d5266ebda7b5b7ca016e3ecbf8bfe060fe9dd53" translate="yes" xml:space="preserve">
          <source>TRACE (RFC 7231)</source>
          <target state="translated">СЛЕД (ШТ.7231)</target>
        </trans-unit>
        <trans-unit id="1223c0da5965757fa8d93336605832a0144596b6" translate="yes" xml:space="preserve">
          <source>TRACE: The message body contains the request message as received by the server</source>
          <target state="translated">TRACE:тело сообщения содержит запросное сообщение,полученное сервером.</target>
        </trans-unit>
        <trans-unit id="56ab49a5c68f11cc45c651da6a3f339eff2853f8" translate="yes" xml:space="preserve">
          <source>TV</source>
          <target state="translated">TV</target>
        </trans-unit>
        <trans-unit id="fabcacd2a76a1a809975d60d7982c2a1035ab1c0" translate="yes" xml:space="preserve">
          <source>Tablet</source>
          <target state="translated">Tablet</target>
        </trans-unit>
        <trans-unit id="7193b142ed8cd6bae9bcd7f28df4d59bf30c7919" translate="yes" xml:space="preserve">
          <source>Tablet versions on WebView mirror mobile, but do not contain a &lt;code&gt;Mobile&lt;/code&gt; token.</source>
          <target state="translated">Версии для планшетов на зеркальном мобильном устройстве WebView, но не содержат токен &lt;code&gt;Mobile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e63d48cf86b47f4a2e41a4c2480abd63617e07ff" translate="yes" xml:space="preserve">
          <source>Tagged Image File Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c352e4dbdd3d9d5e6127303b4e65a452119231a" translate="yes" xml:space="preserve">
          <source>Tagged Image File Format (TIFF)</source>
          <target state="translated">Формат файла изображения с метками (TIFF)</target>
        </trans-unit>
        <trans-unit id="5c1a98fc42374c0534b21a7c408be88b0b460645" translate="yes" xml:space="preserve">
          <source>Tags and summary</source>
          <target state="translated">Теги и резюме</target>
        </trans-unit>
        <trans-unit id="03b91e28fed7956fe56ed8f65fc65fd882bbb491" translate="yes" xml:space="preserve">
          <source>Tags for the Identification of Language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a1df0d175828bc0ac87d97cb74122c8c8d4d00" translate="yes" xml:space="preserve">
          <source>Takes precedence over &lt;code&gt;max-age&lt;/code&gt; or the &lt;code&gt;Expires&lt;/code&gt; header, but it only applies to shared caches (e.g., proxies) and is ignored by a private cache.</source>
          <target state="translated">Имеет приоритет над &lt;code&gt;max-age&lt;/code&gt; или заголовком &lt;code&gt;Expires&lt;/code&gt; , но применяется только к общим кешам (например, прокси) и игнорируется частным кешем.</target>
        </trans-unit>
        <trans-unit id="c149ac475d4a9b7fd2b15c7870c52269b0872366" translate="yes" xml:space="preserve">
          <source>Tape Archive (TAR)</source>
          <target state="translated">Архив лент (TAR)</target>
        </trans-unit>
        <trans-unit id="a9bdde16c71950f9f0a80cbf4ce3915950ed2150" translate="yes" xml:space="preserve">
          <source>Targets of caching operations</source>
          <target state="translated">Цели кэширования</target>
        </trans-unit>
        <trans-unit id="d9c7795d9a943127c5b4d89543f3db9a1ffaae49" translate="yes" xml:space="preserve">
          <source>Technically a part of Device Memory API, this header represents an approximate amount of RAM client has.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2313e8c800252c9ae07b4e97927a6d9cf9ac1b33" translate="yes" xml:space="preserve">
          <source>Techniques for canonical URLs</source>
          <target state="translated">Методы для канонических URL-адресов</target>
        </trans-unit>
        <trans-unit id="04e57122701fa97f61a068ec7bd222827a269a62" translate="yes" xml:space="preserve">
          <source>Tells the browser that the page being loaded is going to want to perform a large allocation.</source>
          <target state="translated">Скажет браузеру,что загружаемая страница захочет выполнить большое выделение.</target>
        </trans-unit>
        <trans-unit id="c8c8d2a564da5b504842208aff51d3ccfc991895" translate="yes" xml:space="preserve">
          <source>Tells the client the server's prefered encoding scheme when submiting a username and password. The only allowed value is the case insensitive string &quot;UTF-8&quot;. This does not relate to the encoding of the realm string.</source>
          <target state="translated">Сообщает клиенту предпочитаемую схему кодирования сервера при отправке имени пользователя и пароля.Единственное допустимое значение-нечувствительная к регистру строка &quot;UTF-8&quot;.Это не относится к кодировке строки realm.</target>
        </trans-unit>
        <trans-unit id="3e310a9a1efd6f1548ce06a7ac2dc4748669f825" translate="yes" xml:space="preserve">
          <source>Tells the client the server's prefered encoding scheme when submitting a username and password. The only allowed value is the case insensitive string &quot;UTF-8&quot;. This does not relate to the encoding of the realm string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58df9f49057b700376e3c8d719874a09fcdc736" translate="yes" xml:space="preserve">
          <source>Tells the user-agent to reset the document which sent this request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f4edbe4b69402bc32c890fe46456f6b42c2ad1" translate="yes" xml:space="preserve">
          <source>Temporary redirections</source>
          <target state="translated">Временные переадресации</target>
        </trans-unit>
        <trans-unit id="7aefd5b2f288adc48ce6a117e81f357d1eed0b40" translate="yes" xml:space="preserve">
          <source>Temporary redirects during site maintenance or downtime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b029c546a5b81b886574d6c63becc55db5c5c32" translate="yes" xml:space="preserve">
          <source>Temporary responses to long requests</source>
          <target state="translated">Временные ответы на длительные запросы</target>
        </trans-unit>
        <trans-unit id="44729f34632c3c8c496e4f38b8037aa7c3dfb175" translate="yes" xml:space="preserve">
          <source>Temporary responses to unsafe requests</source>
          <target state="translated">Временное реагирование на небезопасные запросы</target>
        </trans-unit>
        <trans-unit id="66ad9b49478e00d9521f776ed94bddcd7f501cea" translate="yes" xml:space="preserve">
          <source>Testing your policy</source>
          <target state="translated">Проверка вашей политики</target>
        </trans-unit>
        <trans-unit id="c3328c39b0e29f78e9ff45db674248b1d245887d" translate="yes" xml:space="preserve">
          <source>Text</source>
          <target state="translated">Text</target>
        </trans-unit>
        <trans-unit id="9845ab8961b7e4a2e464fba53a5a9a896b568e17" translate="yes" xml:space="preserve">
          <source>Text, (generally ASCII or ISO 8859-&lt;em&gt;n&lt;/em&gt;)</source>
          <target state="translated">Текст (обычно ASCII или ISO 8859- &lt;em&gt;n&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="dd0fe1624d9684bcb52e0cccdb484d7e2001e225" translate="yes" xml:space="preserve">
          <source>Text-only data including any human-readable content, source code, or textual data such as comma-separated value (CSV) formatted data. Examples include &lt;code&gt;text/plain&lt;/code&gt;, &lt;code&gt;text/csv&lt;/code&gt;, and &lt;code&gt;text/html&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e7a7ed719d0daa7e0a2e3d48d3aa52fa318aae" translate="yes" xml:space="preserve">
          <source>Thanks to its extensibility &amp;ndash; creating new headers or methods is easy &amp;ndash; and even if the HTTP/1.1 protocol was refined over two revisions, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; published in June 1999 and the series of &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;-&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt; published in June 2014 in prevision of the release of HTTP/2, this protocol has been extremely stable over more than 15 years.</source>
          <target state="translated">Благодаря его расширяемости - создание новых заголовков или методов - легко - и даже если протокол HTTP / 1.1 был усовершенствован в двух версиях, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616,&lt;/a&gt; опубликованный в июне 1999 года, и серия &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt; - &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235,&lt;/a&gt; опубликованная в июне 2014 года в преддверии выпуск HTTP / 2, этот протокол был чрезвычайно стабильным более 15 лет.</target>
        </trans-unit>
        <trans-unit id="cd15a270847553d0286663fce338c3186c3904d8" translate="yes" xml:space="preserve">
          <source>Thanks to the &lt;a href=&quot;../headers/host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; header, the ability to host different domains at the same IP address now allows server collocation.</source>
          <target state="translated">Благодаря заголовку &lt;a href=&quot;../headers/host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; возможность размещать разные домены на одном IP-адресе теперь позволяет одновременное размещение серверов.</target>
        </trans-unit>
        <trans-unit id="24cf3eddb29388191b3cd3ec808e71bc6c5fd48a" translate="yes" xml:space="preserve">
          <source>Thanks to the &lt;a href=&quot;../headers/host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; header, the ability to host different domains at the same IP address now allows server colocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0b92cdd8e1ab117b52ae806f278493aef32784" translate="yes" xml:space="preserve">
          <source>That way, you still upgrade insecure requests on your secure site, but the only monitoring policy is violated and reports insecure resources to your endpoint.</source>
          <target state="translated">Таким образом,вы все еще обновляете незащищенные запросы на вашем защищенном сайте,но единственная политика мониторинга нарушается и сообщает о незащищенных ресурсах на вашу конечную точку.</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="30bedea71a5adc4d8f862982f2915b1068fb6576" translate="yes" xml:space="preserve">
          <source>The &quot;Accept&quot; header field can be used by user agents to specify
   response media types that are acceptable.  Accept header fields can
   be used to indicate that the request is specifically limited to a
   small set of desired types, as in the case of a request for an
   in-line image.

     Accept = #( media-range [ accept-params ] )

     media-range    = ( &quot;*/*&quot;
                      / ( type &quot;/&quot; &quot;*&quot; )
                      / ( type &quot;/&quot; subtype )
                      ) *( OWS &quot;;&quot; OWS parameter )
     accept-params  = weight *( accept-ext )
     accept-ext = OWS &quot;;&quot; OWS token [ &quot;=&quot; ( token / quoted-string ) ]

   The asterisk &quot;*&quot; character is used to group media types into ranges,
   with &quot;*/*&quot; indicating all media types and &quot;type/*&quot; indicating all
   subtypes of that type.  The media-range can include media type
   parameters that are applicable to that range.

   Each media-range might be followed by zero or more applicable media
   type parameters (e.g., charset), an optional &quot;q&quot; parameter for
   indicating a relative weight (&lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;), and then zero or more
   extension parameters.  The &quot;q&quot; parameter is necessary if any
   extensions (accept-ext) are present, since it acts as a separator
   between the two parameter sets.

      Note: Use of the &quot;q&quot; parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice.  Although this prevents any media type parameter named
      &quot;q&quot; from being used with a media range, such an event is believed
      to be unlikely given the lack of any &quot;q&quot; parameters in the IANA 

      media type registry and the rare usage of any media type
      parameters in Accept.  Future media types are discouraged from
      registering any parameter named &quot;q&quot;.

   The example

     Accept: audio/*; q=0.2, audio/basic

   is interpreted as &quot;I prefer audio/basic, but send me any audio type
   if it is the best available after an 80% markdown in quality&quot;.

   A request without any Accept header field implies that the user agent
   will accept any media type in response.  If the header field is
   present in a request and none of the available representations for
   the response have a media type that is listed as acceptable, the
   origin server can either honor the header field by sending a 406 (Not
   Acceptable) response or disregard the header field by treating the
   response as if it is not subject to content negotiation.

   A more elaborate example is

     Accept: text/plain; q=0.5, text/html,
             text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as &quot;text/html and text/x-c are
   the equally preferred media types, but if they do not exist, then
   send the text/x-dvi representation, and if that does not exist, send
   the text/plain representation&quot;.

   Media ranges can be overridden by more specific media ranges or
   specific media types.  If more than one media range applies to a
   given type, the most specific reference has precedence.  For example,

     Accept: text/*, text/plain, text/plain;format=flowed, */*

   have the following precedence:

   1.  text/plain;format=flowed

   2.  text/plain

   3.  text/*

   4.  */*

   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   that matches the type.  For example, 

     Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
             text/html;level=2;q=0.4, */*;q=0.5

   would cause the following values to be associated:

   +-------------------+---------------+
   | Media Type        | Quality Value |
   +-------------------+---------------+
   | text/html;level=1 | 1             |
   | text/html         | 0.7           |
   | text/plain        | 0.3           |
   | image/jpeg        | 0.5           |
   | text/html;level=2 | 0.4           |
   | text/html;level=3 | 0.7           |
   +-------------------+---------------+

   Note: A user agent might be provided with a default set of quality
   values for certain media ranges.  However, unless the user agent is a
   closed system that cannot interact with other rendering agents, this
   default set ought to be configurable by the user.</source>
          <target state="translated">Поле заголовка &amp;laquo;Принять&amp;raquo; может использоваться пользовательскими агентами для определения приемлемых типов носителей ответа. Поля заголовка Accept могут использоваться для указания того, что запрос конкретно ограничен небольшим набором желаемых типов, как в случае запроса встроенного изображения. Accept = # (media-range [accept-params]) media-range = (&quot;* / *&quot; / (type &quot;/&quot; &quot;*&quot;) / (type &quot;/&quot; подтип)) * (OWS &quot;;&quot; Параметр OWS ) accept-params = вес * (accept-ext) accept-ext = OWS &quot;;&quot; Токен OWS [&quot;=&quot; (токен / строка в кавычках)] Звездочка &quot;*&quot; используется для группировки типов мультимедиа в диапазоны, где &quot;* / *&quot; указывает все типы мультимедиа, а &quot;type / *&quot;с указанием всех подтипов этого типа. Диапазон мультимедиа может включать в себя параметры типа мультимедиа, применимые к этому диапазону. За каждым медиа-диапазоном может следовать ноль или более применимых параметров типа медиа (например, кодировка), необязательный параметр &amp;laquo;q&amp;raquo; для указания относительного веса (&lt;a href=&quot;#section-5.3.1&quot;&gt;Раздел 5.3.1&lt;/a&gt;), а затем ноль или более параметров расширения. Параметр &amp;laquo;q&amp;raquo; необходим, если присутствуют какие-либо расширения (accept-ext), поскольку он действует как разделитель между двумя наборами параметров. Примечание. Использование имени параметра &amp;laquo;q&amp;raquo; для отделения параметров типа мультимедиа от параметров расширения Accept связано с исторической практикой. Хотя это предотвращает использование любого параметра типа носителя с именем &amp;laquo;q&amp;raquo; с диапазоном носителей, такое событие считается маловероятным, учитывая отсутствие каких-либо параметров &amp;laquo;q&amp;raquo; в реестре типов носителей IANA и редкое использование любого типа носителя. параметры в Accept. В будущих типах носителей не рекомендуется регистрировать какой-либо параметр с именем &amp;laquo;q&amp;raquo;. Пример Accept: audio / *; q = 0,2, аудио / базовый интерпретируется как &quot;Я предпочитаю аудио / базовый, но присылайте мне любой тип аудио, если он лучше всего доступен после снижения качества на 80% &quot;. Запрос без поля заголовка Accept означает, что пользовательский агент примет в ответ любой тип мультимедиа. Если заголовок поле присутствует в запросе, и ни одно из доступных представлений для ответа не имеет типа носителя, который указан как приемлемый, исходный сервер может либо учитывать поле заголовка, отправив ответ 406 (неприемлемо), либо игнорировать поле заголовка, обрабатывая ответ, как если бы он не был предметом согласования содержимого. Более сложный пример: Accept: text / plain; q = 0,5, text / html, text / x-dvi; q = 0,8, text / xc Устно это будет интерпретироваться поскольку &quot;text / html и text / xc являются одинаково предпочтительными типами мультимедиа, но если они не существуют,затем отправьте представление text / x-dvi, а если оно не существует, отправьте текстовое / простое представление &quot;. Диапазоны мультимедиа могут быть переопределены более конкретными диапазонами мультимедиа или конкретными типами мультимедиа. Если к данному тип, наиболее конкретная ссылка имеет приоритет. Например, Accept: text / *, text / plain, text / plain; format = flowed, * / * имеют следующий приоритет: 1. text / plain; format = flowed 2. text / plain 3. text / * 4. * / * Фактор качества типа носителя, связанный с данным типом, определяется путем нахождения диапазона носителей с наивысшим приоритетом, который соответствует типу. Например, Accept: text / *; q = 0,3 , text / html; q = 0,7, text / html; level = 1, text / html; level = 2; q = 0,4, * / *; q = 0,5 приведет к связыванию следующих значений:+ ------------------- + --------------- + | Тип СМИ | Ценность качества | + ------------------- + --------------- + | текст / html; level = 1 | 1 | | текст / html | 0,7 | | текст / простой | 0,3 | | изображение / jpeg | 0,5 | | текст / html; level = 2 | 0,4 | | текст / html; level = 3 | 0,7 | + ------------------- + --------------- + Примечание: агенту пользователя может быть предоставлен набор по умолчанию значения качества для определенных диапазонов носителей. Однако, если пользовательский агент не является закрытой системой, которая не может взаимодействовать с другими агентами рендеринга, этот набор по умолчанию должен настраиваться пользователем.7 | | текст / простой | 0,3 | | изображение / jpeg | 0,5 | | текст / html; level = 2 | 0,4 | | текст / html; level = 3 | 0,7 | + ------------------- + --------------- + Примечание: агенту пользователя может быть предоставлен набор по умолчанию значения качества для определенных диапазонов носителей. Однако, если пользовательский агент не является закрытой системой, которая не может взаимодействовать с другими агентами рендеринга, этот набор по умолчанию должен настраиваться пользователем.7 | | текст / простой | 0,3 | | изображение / jpeg | 0,5 | | текст / html; level = 2 | 0,4 | | текст / html; level = 3 | 0,7 | + ------------------- + --------------- + Примечание: агенту пользователя может быть предоставлен набор по умолчанию значения качества для определенных диапазонов носителей. Однако, если пользовательский агент не является закрытой системой, которая не может взаимодействовать с другими агентами рендеринга, этот набор по умолчанию должен настраиваться пользователем.Если пользовательский агент не является закрытой системой, которая не может взаимодействовать с другими агентами рендеринга, этот набор по умолчанию должен настраиваться пользователем.Если пользовательский агент не является закрытой системой, которая не может взаимодействовать с другими агентами рендеринга, этот набор по умолчанию должен настраиваться пользователем.</target>
        </trans-unit>
        <trans-unit id="e190709d5dcd5319bdd81105d4e02470d1c77a57" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Charset&quot; header field can be sent by a user agent to
   indicate what charsets are acceptable in textual response content.
   This field allows user agents capable of understanding more
   comprehensive or special-purpose charsets to signal that capability
   to an origin server that is capable of representing information in
   those charsets.

     Accept-Charset = 1#( ( charset / &quot;*&quot; ) [ weight ] )

   Charset names are defined in &lt;a href=&quot;#section-3.1.1.2&quot;&gt;Section 3.1.1.2&lt;/a&gt;.  A user agent MAY
   associate a quality value with each charset to indicate the user's
   relative preference for that charset, as defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.
   An example is

     Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

   The special value &quot;*&quot;, if present in the Accept-Charset field,
   matches every charset that is not mentioned elsewhere in the
   Accept-Charset field.  If no &quot;*&quot; is present in an Accept-Charset
   field, then any charsets not explicitly mentioned in the field are
   considered &quot;not acceptable&quot; to the client.

   A request without any Accept-Charset header field implies that the
   user agent will accept any charset in response.  Most general-purpose
   user agents do not send Accept-Charset, unless specifically 

   configured to do so, because a detailed list of supported charsets
   makes it easier for a server to identify an individual by virtue of
   the user agent's request characteristics (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;).

   If an Accept-Charset header field is present in a request and none of
   the available representations for the response has a charset that is
   listed as acceptable, the origin server can either honor the header
   field, by sending a 406 (Not Acceptable) response, or disregard the
   header field by treating the resource as if it is not subject to
   content negotiation.</source>
          <target state="translated">Поле заголовка &amp;laquo;Accept-Charset&amp;raquo; может быть отправлено пользовательским агентом, чтобы указать, какие кодировки допустимы в текстовом содержимом ответа. Это поле позволяет пользовательским агентам, способным понимать более полные или специализированные кодировки, сигнализировать об этой возможности исходному серверу, который способен представлять информацию в этих кодировках. Accept-Charset = 1 # ((charset / &quot;*&quot;) [weight]) Имена наборов символов определены в &lt;a href=&quot;#section-3.1.1.2&quot;&gt;разделе 3.1.1.2&lt;/a&gt; . Пользовательский агент МОЖЕТ связать значение качества с каждой кодировкой, чтобы указать относительное предпочтение пользователя для этой кодировки, как определено в &lt;a href=&quot;#section-5.3.1&quot;&gt;Разделе 5.3.1.&lt;/a&gt;, Примером является Accept-Charset: iso-8859-5, unicode-1-1; q = 0.8 Специальное значение &amp;laquo;*&amp;raquo;, если оно присутствует в поле Accept-Charset, соответствует каждой кодировке, которая не упоминается в другом месте в Accept- Поле Charset. Если &quot;*&quot; не присутствует в поле Accept-Charset, тогда любые наборы символов, явно не упомянутые в поле, считаются &quot;неприемлемыми&quot; для клиента. Запрос без поля заголовка Accept-Charset означает, что пользовательский агент примет в ответ любую кодировку. Большинство пользовательских агентов общего назначения не отправляют Accept-Charset, если специально не настроены для этого, потому что подробный список поддерживаемых кодировок упрощает для сервера идентификацию человека на основании характеристик запроса пользовательского агента ( &lt;a href=&quot;#section-9.7&quot;&gt;раздел 9.7&lt;/a&gt;). Если поле заголовка Accept-Charset присутствует в запросе и ни одно из доступных представлений для ответа не имеет кодировки, которая указана как приемлемая, исходный сервер может либо учитывать поле заголовка, отправив ответ 406 (Not Acceptable), или игнорировать поле заголовка, рассматривая ресурс так, как будто он не является предметом согласования содержимого.</target>
        </trans-unit>
        <trans-unit id="94c1a4ee49201e6addf548dc16982d985feb45ac" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Encoding&quot; header field can be used by user agents to
   indicate what response content-codings (&lt;a href=&quot;#section-3.1.2.1&quot;&gt;Section 3.1.2.1&lt;/a&gt;) are
   acceptable in the response.  An &quot;identity&quot; token is used as a synonym
   for &quot;no encoding&quot; in order to communicate when no encoding is
   preferred.

     Accept-Encoding  = #( codings [ weight ] )
     codings          = content-coding / &quot;identity&quot; / &quot;*&quot;

   Each codings value MAY be given an associated quality value
   representing the preference for that encoding, as defined in
   &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.  The asterisk &quot;*&quot; symbol in an Accept-Encoding field
   matches any available content-coding not explicitly listed in the
   header field.

   For example,

     Accept-Encoding: compress, gzip
     Accept-Encoding:
     Accept-Encoding: *
     Accept-Encoding: compress;q=0.5, gzip;q=1.0
     Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

   A request without an Accept-Encoding header field implies that the
   user agent has no preferences regarding content-codings.  Although
   this allows the server to use any content-coding in a response, it
   does not imply that the user agent will be able to correctly process
   all encodings.

   A server tests whether a content-coding for a given representation is
   acceptable using these rules:

   1.  If no Accept-Encoding field is in the request, any content-coding
       is considered acceptable by the user agent. 

   2.  If the representation has no content-coding, then it is
       acceptable by default unless specifically excluded by the
       Accept-Encoding field stating either &quot;identity;q=0&quot; or &quot;*;q=0&quot;
       without a more specific entry for &quot;identity&quot;.

   3.  If the representation's content-coding is one of the
       content-codings listed in the Accept-Encoding field, then it is
       acceptable unless it is accompanied by a qvalue of 0.  (As
       defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;, a qvalue of 0 means &quot;not acceptable&quot;.)

   4.  If multiple content-codings are acceptable, then the acceptable
       content-coding with the highest non-zero qvalue is preferred.

   An Accept-Encoding header field with a combined field-value that is
   empty implies that the user agent does not want any content-coding in
   response.  If an Accept-Encoding header field is present in a request
   and none of the available representations for the response have a
   content-coding that is listed as acceptable, the origin server SHOULD
   send a response without any content-coding.

      Note: Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings.  This means that qvalues might
      not work and are not permitted with x-gzip or x-compress.</source>
          <target state="translated">Поле заголовка &amp;laquo;Accept-Encoding&amp;raquo; может использоваться пользовательскими агентами, чтобы указать, какие кодировки содержимого ответа ( &lt;a href=&quot;#section-3.1.2.1&quot;&gt;раздел 3.1.2.1&lt;/a&gt; ) приемлемы в ответе. Маркер &amp;laquo;идентичности&amp;raquo; используется в качестве синонима &amp;laquo;без кодирования&amp;raquo; для связи, когда кодирование не является предпочтительным. Accept-Encoding = # (codings [weight]) codings = content-coding / &quot;identity&quot; / &quot;*&quot; Каждому значению codings МОЖЕТ быть присвоено связанное значение качества, представляющее предпочтение для этого кодирования, как определено в &lt;a href=&quot;#section-5.3.1&quot;&gt;Разделе 5.3.1.&lt;/a&gt;, Символ звездочки &amp;laquo;*&amp;raquo; в поле Accept-Encoding соответствует любому доступному кодированию содержимого, не указанному явно в поле заголовка. Например, Accept-Encoding: compress, gzip Accept-Encoding: Accept-Encoding: * Accept-Encoding: compress; q = 0.5, gzip; q = 1.0 Accept-Encoding: gzip; q = 1.0, identity; q = 0,5, *; q = 0 Запрос без поля заголовка Accept-Encoding означает, что пользовательский агент не имеет предпочтений в отношении кодирования содержимого. Хотя это позволяет серверу использовать любое кодирование содержимого в ответе, это не означает, что пользовательский агент сможет правильно обрабатывать все кодировки. Сервер проверяет, приемлемо ли кодирование содержимого для данного представления, используя следующие правила: 1. Если в запросе нет поля Accept-Encoding,любое кодирование содержимого считается приемлемым для пользовательского агента. 2. Если представление не имеет кодирования содержимого, то оно приемлемо по умолчанию, если специально не исключено полем Accept-Encoding с указанием &amp;laquo;identity; q = 0&amp;raquo; или &amp;laquo;*; q = 0&amp;raquo; без более конкретной записи для &amp;laquo; идентичность&amp;raquo;. 3. Если кодирование содержимого представления является одним из кодировок содержимого, перечисленных в поле Accept-Encoding, то оно приемлемо, если оно не сопровождается значением qvalue, равным 0. (Как определено вбез более конкретной записи для &amp;laquo;идентичности&amp;raquo;. 3. Если кодирование содержимого представления является одним из кодировок содержимого, перечисленных в поле Accept-Encoding, то оно приемлемо, если оно не сопровождается значением qvalue, равным 0. (Как определено вбез более конкретной записи для &amp;laquo;идентичности&amp;raquo;. 3. Если кодирование содержимого представления является одним из кодировок содержимого, перечисленных в поле Accept-Encoding, то оно приемлемо, если оно не сопровождается значением qvalue, равным 0. (Как определено в&lt;a href=&quot;#section-5.3.1&quot;&gt;В разделе 5.3.1&lt;/a&gt; qvalue, равное 0, означает &amp;laquo;неприемлемо&amp;raquo;.) 4. Если допустимо несколько кодировок содержимого, то предпочтительным является приемлемое кодирование содержимого с наивысшим ненулевым значением q. Поле заголовка Accept-Encoding с пустым комбинированным значением поля означает, что пользовательский агент не хочет никакого кодирования содержимого в ответ. Если поле заголовка Accept-Encoding присутствует в запросе и ни одно из доступных представлений для ответа не имеет кодирования содержимого, которое указано как приемлемое, исходный сервер ДОЛЖЕН отправить ответ без какого-либо кодирования содержимого. Примечание. Большинство приложений HTTP / 1.0 не распознают и не подчиняются значениям qvalue, связанным с кодированием содержимого. Это означает, что значения qvalues ​​могут не работать и недопустимы с x-gzip или x-compress.</target>
        </trans-unit>
        <trans-unit id="e583c40d3f3281ace1211bd3a8c4c5127953cb55" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Language&quot; header field can be used by user agents to
   indicate the set of natural languages that are preferred in the
   response.  Language tags are defined in &lt;a href=&quot;#section-3.1.3.1&quot;&gt;Section 3.1.3.1&lt;/a&gt;.

     Accept-Language = 1#( language-range [ weight ] )
     language-range  =
               &amp;lt;language-range, see &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647], Section&amp;nbsp;2.1&lt;/a&gt;&amp;gt;

   Each language-range can be given an associated quality value
   representing an estimate of the user's preference for the languages
   specified by that range, as defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.  For example,

     Accept-Language: da, en-gb;q=0.8, en;q=0.7

   would mean: &quot;I prefer Danish, but will accept British English and
   other types of English&quot;.

   A request without any Accept-Language header field implies that the
   user agent will accept any language in response.  If the header field
   is present in a request and none of the available representations for
   the response have a matching language tag, the origin server can
   either disregard the header field by treating the response as if it 

   is not subject to content negotiation or honor the header field by
   sending a 406 (Not Acceptable) response.  However, the latter is not
   encouraged, as doing so can prevent users from accessing content that
   they might be able to use (with translation software, for example).

   Note that some recipients treat the order in which language tags are
   listed as an indication of descending priority, particularly for tags
   that are assigned equal quality values (no value is the same as q=1).
   However, this behavior cannot be relied upon.  For consistency and to
   maximize interoperability, many user agents assign each language tag
   a unique quality value while also listing them in order of decreasing
   quality.  Additional discussion of language priority lists can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC4647]&lt;/a&gt;.

   For matching, &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC4647]&lt;/a&gt; defines several matching
   schemes.  Implementations can offer the most appropriate matching
   scheme for their requirements.  The &quot;Basic Filtering&quot; scheme
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3.3.1&quot;&gt;[RFC4647], Section&amp;nbsp;3.3.1&lt;/a&gt;) is identical to the matching scheme that
   was previously defined for HTTP in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.4&quot;&gt;Section&amp;nbsp;14.4 of [RFC2616]&lt;/a&gt;.

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header field with the complete linguistic
   preferences of the user in every request (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;).

   Since intelligibility is highly dependent on the individual user,
   user agents need to allow user control over the linguistic preference
   (either through configuration of the user agent itself or by
   defaulting to a user controllable system setting).  A user agent that
   does not provide such control to the user MUST NOT send an
   Accept-Language header field.

      Note: User agents ought to provide guidance to users when setting
      a preference, since users are rarely familiar with the details of
      language matching as described above.  For example, users might
      assume that on selecting &quot;en-gb&quot;, they will be served any kind of
      English document if British English is not available.  A user
      agent might suggest, in such a case, to add &quot;en&quot; to the list for
      better matching behavior.</source>
          <target state="translated">Поле заголовка &amp;laquo;Accept-Language&amp;raquo; может использоваться пользовательскими агентами для указания набора естественных языков, которые предпочтительны в ответе. Языковые теги определены в &lt;a href=&quot;#section-3.1.3.1&quot;&gt;разделе 3.1.3.1&lt;/a&gt; . Accept-Language = 1 # (language-range [weight]) language-range = &amp;lt;language-range, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647], раздел 2.1&lt;/a&gt; &amp;gt; Каждому языковому диапазону может быть присвоено соответствующее значение качества, представляющее оценку предпочтений пользователя для языки, указанные в этом диапазоне, как определено в &lt;a href=&quot;#section-5.3.1&quot;&gt;Разделе 5.3.1&lt;/a&gt;, Например, Accept-Language: da, en-gb; q = 0,8, en; q = 0,7 будет означать: &amp;laquo;Я предпочитаю датский, но буду принимать британский английский и другие типы английского&amp;raquo;. Запрос без поля заголовка Accept-Language означает, что пользовательский агент примет ответ на любом языке. Если поле заголовка присутствует в запросе и ни одно из доступных представлений для ответа не имеет соответствующего языкового тега, исходный сервер может либо игнорировать поле заголовка, обрабатывая ответ, как если бы он не подлежал согласованию содержимого, либо соблюдать заголовок. поле, отправив ответ 406 (неприемлемо). Однако последнее не рекомендуется, поскольку это может помешать пользователям получить доступ к контенту, который они могут использовать (например, с помощью программного обеспечения для перевода).Обратите внимание, что некоторые получатели рассматривают порядок, в котором перечислены языковые теги, как указатель нисходящего приоритета, особенно для тегов, которым присвоены одинаковые значения качества (нет значения, аналогичного q = 1). Однако на такое поведение нельзя положиться. Для единообразия и максимальной совместимости многие пользовательские агенты присваивают каждому языковому тегу уникальное значение качества, а также перечисляют их в порядке уменьшения качества. Дополнительное обсуждение списков приоритетов языков можно найти вмногие пользовательские агенты присваивают каждому языковому тегу уникальное значение качества, а также перечисляют их в порядке убывания качества. Дополнительное обсуждение списков приоритетов языков можно найти вмногие пользовательские агенты присваивают каждому языковому тегу уникальное значение качества, а также перечисляют их в порядке убывания качества. Дополнительное обсуждение списков приоритетов языков можно найти в&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.3&quot;&gt;Раздел 2.3 [RFC4647]&lt;/a&gt; . Для сопоставления в &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3&quot;&gt;разделе 3 [RFC4647]&lt;/a&gt; определено несколько схем сопоставления. Реализации могут предложить наиболее подходящую схему соответствия их требованиям. Схема &amp;laquo;Базовая фильтрация&amp;raquo; ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3.3.1&quot;&gt;[RFC4647], раздел 3.3.1&lt;/a&gt; ) идентична схеме сопоставления, которая была ранее определена для HTTP в &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.4&quot;&gt;разделе 14.4 [RFC2616]&lt;/a&gt; . Отправка поля заголовка Accept-Language с полными лингвистическими предпочтениями пользователя в каждом запросе может противоречить ожиданиям пользователя в отношении конфиденциальности ( &lt;a href=&quot;#section-9.7&quot;&gt;раздел 9.7.&lt;/a&gt;). Поскольку разборчивость в значительной степени зависит от отдельного пользователя, пользовательские агенты должны позволять пользователю контролировать лингвистические предпочтения (либо посредством конфигурации самого пользовательского агента, либо путем установки по умолчанию системных настроек, контролируемых пользователем). Пользовательский агент, который не предоставляет такое управление пользователю, НЕ ДОЛЖЕН отправлять поле заголовка Accept-Language. Примечание. Агенты пользователя должны предоставлять пользователям указания при настройке предпочтений, поскольку пользователи редко знакомы с деталями сопоставления языков, как описано выше. Например, пользователи могут предположить, что при выборе &amp;laquo;en-gb&amp;raquo; им будет предоставлен любой документ на английском языке, если британский английский недоступен. В таком случае пользовательский агент может предложить добавить в список &amp;laquo;en&amp;raquo; для лучшего соответствия.</target>
        </trans-unit>
        <trans-unit id="660e50878abbf252e2213e4a43a8c15147d72e0c" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Ranges&quot; header field allows a server to indicate that it
   supports range requests for the target resource.

     Accept-Ranges     = acceptable-ranges
     acceptable-ranges = 1#range-unit / &quot;none&quot;

   An origin server that supports byte-range requests for a given target
   resource MAY send

     Accept-Ranges: bytes

   to indicate what range units are supported.  A client MAY generate
   range requests without having received this header field for the
   resource involved.  Range units are defined in &lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;.

   A server that does not support any kind of range request for the
   target resource MAY send

     Accept-Ranges: none

   to advise the client not to attempt a range request.</source>
          <target state="translated">Поле заголовка &amp;laquo;Accept-Ranges&amp;raquo; позволяет серверу указать, что он поддерживает запросы диапазона для целевого ресурса. Accept-Ranges = Допустимые диапазоны Допустимые диапазоны = 1 # range-unit / &quot;none&quot; Исходный сервер, который поддерживает запросы байтового диапазона для заданного целевого ресурса, МОЖЕТ отправлять Accept-Ranges: bytes, чтобы указать, какие единицы диапазона поддерживаются. Клиент МОЖЕТ генерировать запросы диапазона, не получив это поле заголовка для задействованного ресурса. Единицы измерения определены в &lt;a href=&quot;#section-2&quot;&gt;Разделе 2&lt;/a&gt; . Сервер, который не поддерживает какой-либо запрос диапазона для целевого ресурса, МОЖЕТ отправить Accept-Ranges: none, чтобы посоветовать клиенту не пытаться выполнить запрос диапазона.</target>
        </trans-unit>
        <trans-unit id="07e147c0306bf45017b2c661d092871c17cc475c" translate="yes" xml:space="preserve">
          <source>The &quot;Age&quot; header field conveys the sender's estimate of the amount of
   time since the response was generated or successfully validated at
   the origin server.  Age values are calculated as specified in
   &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;.

     Age = delta-seconds

   The Age field-value is a non-negative integer, representing time in
   seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;).

   The presence of an Age header field implies that the response was not
   generated or validated by the origin server for this request.
   However, lack of an Age header field does not imply the origin was
   contacted, since the response might have been received from an
   HTTP/1.0 cache that does not implement Age.</source>
          <target state="translated">Поле заголовка &amp;laquo;Возраст&amp;raquo; передает оценку отправителя количества времени, прошедшего с момента создания или успешной проверки ответа на исходном сервере. Значения возраста рассчитываются, как указано в &lt;a href=&quot;#section-4.2.3&quot;&gt;разделе 4.2.3&lt;/a&gt; . Возраст = дельта-секунды Значение поля Возраст - неотрицательное целое число, представляющее время в секундах (см. &lt;a href=&quot;#section-1.2.1&quot;&gt;Раздел 1.2.1&lt;/a&gt; ). Наличие поля заголовка Age подразумевает, что ответ не был сгенерирован или проверен исходным сервером для этого запроса. Однако отсутствие поля заголовка Age не означает, что с источником был установлен контакт, поскольку ответ мог быть получен из кеша HTTP / 1.0, который не реализует Age.</target>
        </trans-unit>
        <trans-unit id="1338498c252679bf6adfadb0f7074e7b148e3793" translate="yes" xml:space="preserve">
          <source>The &quot;Allow&quot; header field lists the set of methods advertised as
   supported by the target resource.  The purpose of this field is
   strictly to inform the recipient of valid request methods associated
   with the resource.

     Allow = #method

   Example of use:

     Allow: GET, HEAD, PUT

   The actual set of allowed methods is defined by the origin server at
   the time of each request.  An origin server MUST generate an Allow
   field in a 405 (Method Not Allowed) response and MAY do so in any
   other response.  An empty Allow field value indicates that the
   resource allows no methods, which might occur in a 405 response if
   the resource has been temporarily disabled by configuration.

   A proxy MUST NOT modify the Allow header field -- it does not need to
   understand all of the indicated methods in order to handle them
   according to the generic message handling rules.</source>
          <target state="translated">В поле заголовка &quot;Разрешить&quot; перечислен набор методов,рекламируемых как поддерживаемые целевым ресурсом.Назначение данного поля-строгое информирование получателя о допустимых методах запроса,связанных с ресурсом.Allow=#метод Пример использования:Разрешить:GET,HEAD,PUT Реальный набор разрешенных методов определяется сервером отправителя в момент каждого запроса.Сервер отправителя ДОЛЖЕН генерировать поле Allow в ответе 405 (Метод не разрешен)и MAY делать это в любом другом ответе.Пустое значение поля Allow указывает на то,что ресурс не разрешает никаких методов,что может произойти в ответе 405,если ресурс был временно отключен конфигурацией.Прокси-сервер НЕ ДОЛЖЕН изменять поле Allow заголовка --ему не нужно понимать все указанные методы для того,чтобы обрабатывать их в соответствии с общими правилами обработки сообщений.</target>
        </trans-unit>
        <trans-unit id="833bc28aae892154d2187dc74fadd75ecc7a7e54" translate="yes" xml:space="preserve">
          <source>The &quot;Authorization&quot; header field allows a user agent to authenticate
   itself with an origin server -- usually, but not necessarily, after
   receiving a 401 (Unauthorized) response.  Its value consists of
   credentials containing the authentication information of the user
   agent for the realm of the resource being requested.

     Authorization = credentials

   If a request is authenticated and a realm specified, the same
   credentials are presumed to be valid for all other requests within
   this realm (assuming that the authentication scheme itself does not
   require otherwise, such as credentials that vary according to a
   challenge value or using synchronized clocks).

   A proxy forwarding a request MUST NOT modify any Authorization fields
   in that request.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7234]&lt;/a&gt; for details of and
   requirements pertaining to handling of the Authorization field by
   HTTP caches.</source>
          <target state="translated">Поле заголовка &amp;laquo;Авторизация&amp;raquo; позволяет пользовательскому агенту аутентифицироваться на исходном сервере - обычно, но не обязательно, после получения ответа 401 (неавторизованный). Его значение состоит из учетных данных, содержащих информацию аутентификации пользовательского агента для области запрашиваемого ресурса. Авторизация = учетные данные Если запрос аутентифицирован и указана область, предполагается, что одни и те же учетные данные действительны для всех других запросов в этой области (при условии, что сама схема аутентификации не требует иного, например учетные данные, которые меняются в зависимости от значения запроса. или используя синхронизированные часы). Прокси-сервер, пересылающий запрос, НЕ ДОЛЖЕН изменять какие-либо поля авторизации в этом запросе. См. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3.2&quot;&gt;Раздел 3.2 [RFC7234]&lt;/a&gt; для получения подробной информации и требований, относящихся к обработке поля авторизации кешами HTTP.</target>
        </trans-unit>
        <trans-unit id="7168d04cbf63301e6705540ed2ab42ae32147600" translate="yes" xml:space="preserve">
          <source>The &quot;Basic&quot; HTTP authentication scheme is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617&lt;/a&gt;, which transmits credentials as user ID/password pairs, encoded using base64.</source>
          <target state="translated">&amp;laquo;Базовая&amp;raquo; схема HTTP-аутентификации определена в &lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617&lt;/a&gt; , который передает учетные данные в виде пар идентификатора пользователя и пароля, закодированных с использованием base64.</target>
        </trans-unit>
        <trans-unit id="e6a4b6da05626e019facf6e5f03b1b90399b48bf" translate="yes" xml:space="preserve">
          <source>The &quot;Cache-Control&quot; header field is used to specify directives for
   caches along the request/response chain.  Such cache directives are
   unidirectional in that the presence of a directive in a request does
   not imply that the same directive is to be given in the response.

   A cache MUST obey the requirements of the Cache-Control directives
   defined in this section.  See &lt;a href=&quot;#section-5.2.3&quot;&gt;Section 5.2.3&lt;/a&gt; for information about how
   Cache-Control directives defined elsewhere are handled.

      Note: Some HTTP/1.0 caches might not implement Cache-Control.

   A proxy, whether or not it implements a cache, MUST pass cache
   directives through in forwarded messages, regardless of their
   significance to that application, since the directives might be
   applicable to all recipients along the request/response chain.  It is
   not possible to target a directive to a specific cache.

   Cache directives are identified by a token, to be compared
   case-insensitively, and have an optional argument, that can use both
   token and quoted-string syntax.  For the directives defined below
   that define arguments, recipients ought to accept both forms, even if
   one is documented to be preferred.  For any directive not defined by
   this specification, a recipient MUST accept both forms. 

     Cache-Control   = 1#cache-directive

     cache-directive = token [ &quot;=&quot; ( token / quoted-string ) ]

   For the cache directives defined below, no argument is defined (nor
   allowed) unless stated otherwise.</source>
          <target state="translated">Поле заголовка &amp;laquo;Cache-Control&amp;raquo; используется для указания директив для кешей в цепочке запроса / ответа. Такие директивы кэша являются однонаправленными в том смысле, что наличие директивы в запросе не означает, что та же самая директива должна быть указана в ответе. Кэш ДОЛЖЕН подчиняться требованиям директив Cache-Control, определенных в этом разделе. См. &lt;a href=&quot;#section-5.2.3&quot;&gt;Раздел 5.2.3.&lt;/a&gt;для получения информации о том, как обрабатываются директивы Cache-Control, определенные в другом месте. Примечание. Некоторые кэши HTTP / 1.0 могут не реализовывать Cache-Control. Прокси-сервер, независимо от того, реализует он кэш или нет, ДОЛЖЕН передавать директивы кеша в пересылаемых сообщениях, независимо от их значения для этого приложения, поскольку директивы могут быть применимы ко всем получателям в цепочке запроса / ответа. Невозможно нацелить директиву на конкретный кеш. Директивы кэша идентифицируются токеном, сравниваются без учета регистра и имеют необязательный аргумент, который может использовать синтаксис как токена, так и строки в кавычках. Для определенных ниже директив, которые определяют аргументы, получатели должны принять обе формы, даже если одна из них задокументирована как предпочтительная. Для любой директивы, не определенной в этой спецификации,получатель ДОЛЖЕН принять обе формы. Cache-Control = 1 # директива кеширования cache-directive = token [&quot;=&quot; (токен / строка в кавычках)] Для директив кеша, определенных ниже, аргумент не определен (и не разрешен), если не указано иное.</target>
        </trans-unit>
        <trans-unit id="ead8e33ac22c36beaaccc520e5c8f0383500fa6b" translate="yes" xml:space="preserve">
          <source>The &quot;Connection&quot; header field allows the sender to indicate desired
   control options for the current connection.  In order to avoid
   confusing downstream recipients, a proxy or gateway MUST remove or
   replace any received connection options before forwarding the
   message.

   When a header field aside from Connection is used to supply control
   information for or about the current connection, the sender MUST list
   the corresponding field-name within the Connection header field.  A
   proxy or gateway MUST parse a received Connection header field before
   a message is forwarded and, for each connection-option in this field,
   remove any header field(s) from the message with the same name as the
   connection-option, and then remove the Connection header field itself
   (or replace it with the intermediary's own connection options for the
   forwarded message).

   Hence, the Connection header field provides a declarative way of
   distinguishing header fields that are only intended for the immediate
   recipient (&quot;hop-by-hop&quot;) from those fields that are intended for all
   recipients on the chain (&quot;end-to-end&quot;), enabling the message to be
   self-descriptive and allowing future connection-specific extensions
   to be deployed without fear that they will be blindly forwarded by
   older intermediaries.

   The Connection header field's value has the following grammar:

     Connection        = 1#connection-option
     connection-option = token

   Connection options are case-insensitive.

   A sender MUST NOT send a connection option corresponding to a header
   field that is intended for all recipients of the payload.  For
   example, Cache-Control is never appropriate as a connection option
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;). 

   The connection options do not always correspond to a header field
   present in the message, since a connection-specific header field
   might not be needed if there are no parameters associated with a
   connection option.  In contrast, a connection-specific header field
   that is received without a corresponding connection option usually
   indicates that the field has been improperly forwarded by an
   intermediary and ought to be ignored by the recipient.

   When defining new connection options, specification authors ought to
   survey existing header field names and ensure that the new connection
   option does not share the same name as an already deployed header
   field.  Defining a new connection option essentially reserves that
   potential field-name for carrying additional information related to
   the connection option, since it would be unwise for senders to use
   that field-name for anything else.

   The &quot;close&quot; connection option is defined for a sender to signal that
   this connection will be closed after completion of the response.  For
   example,

     Connection: close

   in either the request or the response header fields indicates that
   the sender is going to close the connection after the current
   request/response is complete (&lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;).

   A client that does not support persistent connections MUST send the
   &quot;close&quot; connection option in every request message.

   A server that does not support persistent connections MUST send the
   &quot;close&quot; connection option in every response message that does not
   have a 1xx (Informational) status code.</source>
          <target state="translated">Поле заголовка &amp;laquo;Соединение&amp;raquo; позволяет отправителю указать желаемые параметры управления для текущего соединения. Во избежание путаницы в нисходящих получателях прокси-сервер или шлюз ДОЛЖНЫ удалить или заменить все полученные параметры соединения перед пересылкой сообщения. Когда поле заголовка помимо Connection используется для предоставления управляющей информации для текущего соединения или о нем, отправитель ДОЛЖЕН указать соответствующее имя поля в поле заголовка Connection. Прокси-сервер или шлюз ДОЛЖНЫ проанализировать полученное поле заголовка соединения перед пересылкой сообщения и для каждого параметра подключения в этом поле удалить все поля заголовка из сообщения с тем же именем, что и параметр подключения, а затем удалить само поле заголовка соединения (или замените его на посредника)собственные параметры подключения для пересылаемого сообщения). Следовательно, поле заголовка соединения обеспечивает декларативный способ отличить поля заголовка, которые предназначены только для непосредственного получателя (&amp;laquo;шаг за шагом&amp;raquo;), от тех полей, которые предназначены для всех получателей в цепочке (&amp;laquo;сквозной &quot;), позволяя сообщению быть информативным и позволяя развертывать будущие расширения для конкретных соединений, не опасаясь, что они будут вслепую перенаправлены старыми посредниками. Значение поля заголовка подключения имеет следующую грамматику: Connection = 1 # connection-option connection-option = token Параметры подключения не чувствительны к регистру. Отправитель НЕ ДОЛЖЕН отправлять параметр подключения, соответствующий полю заголовка, который предназначен для всех получателей полезной нагрузки.Например, Cache-Control никогда не подходит в качестве варианта подключения (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Раздел 5.2 [RFC7234]&lt;/a&gt;). Параметры подключения не всегда соответствуют полю заголовка, присутствующему в сообщении, поскольку поле заголовка для конкретного подключения может не понадобиться, если с параметром подключения не связаны никакие параметры. Напротив, зависящее от соединения поле заголовка, полученное без соответствующей опции соединения, обычно указывает на то, что поле было неправильно переадресовано посредником и должно быть проигнорировано получателем. При определении новых параметров подключения авторы спецификации должны изучить существующие имена полей заголовка и убедиться, что имя нового варианта подключения не совпадает с именем уже развернутого поля заголовка. Определение новой опции подключения по существу резервирует это потенциальное имя поля для переноса дополнительной информации, связанной с опцией подключения,так как для отправителей было бы неразумно использовать это имя поля для чего-либо еще. Опция &amp;laquo;закрыть&amp;raquo; соединение определена для отправителя, чтобы сообщить, что это соединение будет закрыто после завершения ответа. Например, Connection: close в полях заголовка запроса или ответа указывает, что отправитель собирается закрыть соединение после завершения текущего запроса / ответа (close в полях заголовка запроса или ответа указывает, что отправитель собирается закрыть соединение после завершения текущего запроса / ответа (close в полях заголовка запроса или ответа указывает, что отправитель собирается закрыть соединение после завершения текущего запроса / ответа (&lt;a href=&quot;#section-6.6&quot;&gt;Раздел 6.6&lt;/a&gt; ). Клиент, который не поддерживает постоянные соединения, ДОЛЖЕН посылать опцию &amp;laquo;закрыть&amp;raquo; соединение в каждом сообщении запроса. Сервер, который не поддерживает постоянные соединения, ДОЛЖЕН посылать опцию &amp;laquo;закрыть&amp;raquo; соединение в каждом ответном сообщении, не имеющем кода состояния 1xx (информационный).</target>
        </trans-unit>
        <trans-unit id="f005d7daab665deae0b91cf8d9396978496c7fec" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Encoding&quot; header field indicates what content codings
   have been applied to the representation, beyond those inherent in the
   media type, and thus what decoding mechanisms have to be applied in
   order to obtain data in the media type referenced by the Content-Type
   header field.  Content-Encoding is primarily used to allow a
   representation's data to be compressed without losing the identity of
   its underlying media type.

     Content-Encoding = 1#content-coding

   An example of its use is

     Content-Encoding: gzip

   If one or more encodings have been applied to a representation, the
   sender that applied the encodings MUST generate a Content-Encoding
   header field that lists the content codings in the order in which
   they were applied.  Additional information about the encoding
   parameters can be provided by other header fields not defined by this
   specification.

   Unlike Transfer-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;Section&amp;nbsp;3.3.1 of [RFC7230]&lt;/a&gt;), the codings
   listed in Content-Encoding are a characteristic of the
   representation; the representation is defined in terms of the coded
   form, and all other metadata about the representation is about the
   coded form unless otherwise noted in the metadata definition.
   Typically, the representation is only decoded just prior to rendering
   or analogous usage.

   If the media type includes an inherent encoding, such as a data
   format that is always compressed, then that encoding would not be
   restated in Content-Encoding even if it happens to be the same
   algorithm as one of the content codings.  Such a content coding would
   only be listed if, for some bizarre reason, it is applied a second
   time to form the representation.  Likewise, an origin server might
   choose to publish the same data as multiple representations that
   differ only in whether the coding is defined as part of Content-Type 

   or Content-Encoding, since some user agents will behave differently
   in their handling of each response (e.g., open a &quot;Save as ...&quot; dialog
   instead of automatic decompression and rendering of content).

   An origin server MAY respond with a status code of 415 (Unsupported
   Media Type) if a representation in the request message has a content
   coding that is not acceptable.</source>
          <target state="translated">Поле заголовка &amp;laquo;Content-Encoding&amp;raquo; указывает, какие кодировки контента были применены к представлению, помимо тех, которые присущи типу мультимедиа, и, таким образом, какие механизмы декодирования должны быть применены для получения данных в типе мультимедиа, на который ссылается Content- Введите поле заголовка. Content-Encoding в основном используется для сжатия данных представления без потери идентичности базового типа мультимедиа. Content-Encoding = 1 # content-coding Примером его использования является Content-Encoding: gzip. Если к представлению были применены одна или несколько кодировок, отправитель, применивший кодировки, ДОЛЖЕН создать поле заголовка Content-Encoding, в котором перечислено содержимое. кодировки в том порядке, в котором они были применены.Дополнительная информация о параметрах кодирования может быть предоставлена ​​другими полями заголовка, не определенными в данной спецификации. В отличие от Transfer-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;Раздел 3.3.1 [RFC7230]&lt;/a&gt;), кодировки, перечисленные в Content-Encoding, являются характеристикой представления; представление определяется в терминах закодированной формы, а все другие метаданные о представлении относятся к закодированной форме, если иное не указано в определении метаданных. Обычно представление декодируется только непосредственно перед визуализацией или аналогичным использованием. Если тип мультимедиа включает внутреннюю кодировку, такую ​​как формат данных, который всегда сжимается, то эта кодировка не будет повторно преобразована в Content-Encoding, даже если это будет тот же алгоритм, что и одна из кодировок содержимого. Такое кодирование содержимого будет указано только в том случае, если по какой-то причудливой причине оно будет применено второй раз для формирования представления. Точно так же,исходный сервер может выбрать публикацию одних и тех же данных в виде нескольких представлений, которые отличаются только тем, определено ли кодирование как часть Content-Type или Content-Encoding, поскольку некоторые пользовательские агенты будут вести себя по-разному при обработке каждого ответа (например, открывать диалоговое окно &amp;laquo;Сохранить как ...&amp;raquo; вместо автоматической распаковки и рендеринга содержимого). Сервер-источник МОЖЕТ ответить кодом состояния 415 (неподдерживаемый тип мультимедиа), если представление в сообщении запроса имеет кодирование содержимого, которое неприемлемо.Сервер-источник МОЖЕТ ответить кодом состояния 415 (неподдерживаемый тип мультимедиа), если представление в сообщении запроса имеет кодирование содержимого, которое неприемлемо.Сервер-источник МОЖЕТ ответить кодом состояния 415 (неподдерживаемый тип мультимедиа), если представление в сообщении запроса имеет кодирование содержимого, которое неприемлемо.</target>
        </trans-unit>
        <trans-unit id="164d16f9f8916d272734f22f4029358169a82681" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Language&quot; header field describes the natural language(s)
   of the intended audience for the representation.  Note that this
   might not be equivalent to all the languages used within the
   representation.

     Content-Language = 1#language-tag 

   Language tags are defined in &lt;a href=&quot;#section-3.1.3.1&quot;&gt;Section 3.1.3.1&lt;/a&gt;.  The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   representations according to the users' own preferred language.
   Thus, if the content is intended only for a Danish-literate audience,
   the appropriate field is

     Content-Language: da

   If no Content-Language is specified, the default is that the content
   is intended for all language audiences.  This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.

   Multiple languages MAY be listed for content that is intended for
   multiple audiences.  For example, a rendition of the &quot;Treaty of
   Waitangi&quot;, presented simultaneously in the original Maori and English
   versions, would call for

     Content-Language: mi, en

   However, just because multiple languages are present within a
   representation does not mean that it is intended for multiple
   linguistic audiences.  An example would be a beginner's language
   primer, such as &quot;A First Lesson in Latin&quot;, which is clearly intended
   to be used by an English-literate audience.  In this case, the
   Content-Language would properly only include &quot;en&quot;.

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.</source>
          <target state="translated">Поле заголовка Content-Language описывает естественный язык (языки) целевой аудитории для представления. Обратите внимание, что это может быть не эквивалентно всем языкам, используемым в представлении. Content-Language = 1 # language-tag Языковые теги определены в &lt;a href=&quot;#section-3.1.3.1&quot;&gt;разделе 3.1.3.1.&lt;/a&gt;, Основная цель Content-Language - позволить пользователю идентифицировать и различать представления в соответствии с его собственным предпочтительным языком. Таким образом, если контент предназначен только для аудитории, владеющей датским языком, соответствующее поле - Content-Language: da. Если Content-Language не указан, по умолчанию контент предназначен для всех языковых аудиторий. Это может означать, что отправитель не считает его специфичным для какого-либо естественного языка или что отправитель не знает, для какого языка он предназначен. Для контента, предназначенного для разных аудиторий, МОГУТ быть указаны несколько языков. Например, исполнение &amp;laquo;Договора Вайтанги&amp;raquo;, представленное одновременно в оригинальной маори и английской версиях, будет требовать Content-Language: mi,Common crawl ru Однако тот факт, что в представлении присутствует несколько языков, не означает, что оно предназначено для нескольких языковых аудиторий. Примером может служить учебник по языку для начинающих, такой как &amp;laquo;Первый урок латыни&amp;raquo;, который явно предназначен для англоязычной аудитории. В этом случае Content-Language правильно будет включать только &amp;laquo;en&amp;raquo;. Content-Language МОЖЕТ применяться к любому типу мультимедиа - это не ограничивается текстовыми документами.В этом случае Content-Language правильно будет включать только &amp;laquo;en&amp;raquo;. Content-Language МОЖЕТ применяться к любому типу мультимедиа - это не ограничивается текстовыми документами.В этом случае Content-Language правильно будет включать только &amp;laquo;en&amp;raquo;. Content-Language МОЖЕТ применяться к любому типу мультимедиа - это не ограничивается текстовыми документами.</target>
        </trans-unit>
        <trans-unit id="befc0a5526257450f3dfb30b2d0dfe3ea24c1e2b" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Location&quot; header field references a URI that can be used
   as an identifier for a specific resource corresponding to the
   representation in this message's payload.  In other words, if one
   were to perform a GET request on this URI at the time of this
   message's generation, then a 200 (OK) response would contain the same
   representation that is enclosed as payload in this message.

     Content-Location = absolute-URI / partial-URI

   The Content-Location value is not a replacement for the effective
   Request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7230]&lt;/a&gt;).  It is representation
   metadata.  It has the same syntax and semantics as the header field
   of the same name defined for MIME body parts in &lt;a href=&quot;https://tools.ietf.org/html/rfc2557#section-4&quot;&gt;Section&amp;nbsp;4 of
   [RFC2557]&lt;/a&gt;.  However, its appearance in an HTTP message has some
   special implications for HTTP recipients. 

   If Content-Location is included in a 2xx (Successful) response
   message and its value refers (after conversion to absolute form) to a
   URI that is the same as the effective request URI, then the recipient
   MAY consider the payload to be a current representation of that
   resource at the time indicated by the message origination date.  For
   a GET (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;) or HEAD (&lt;a href=&quot;#section-4.3.2&quot;&gt;Section 4.3.2&lt;/a&gt;) request, this is the
   same as the default semantics when no Content-Location is provided by
   the server.  For a state-changing request like PUT (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;) or
   POST (&lt;a href=&quot;#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt;), it implies that the server's response contains
   the new representation of that resource, thereby distinguishing it
   from representations that might only report about the action (e.g.,
   &quot;It worked!&quot;).  This allows authoring applications to update their
   local copies without the need for a subsequent GET request.

   If Content-Location is included in a 2xx (Successful) response
   message and its field-value refers to a URI that differs from the
   effective request URI, then the origin server claims that the URI is
   an identifier for a different resource corresponding to the enclosed
   representation.  Such a claim can only be trusted if both identifiers
   share the same resource owner, which cannot be programmatically
   determined via HTTP.

   o  For a response to a GET or HEAD request, this is an indication
      that the effective request URI refers to a resource that is
      subject to content negotiation and the Content-Location
      field-value is a more specific identifier for the selected
      representation.

   o  For a 201 (Created) response to a state-changing method, a
      Content-Location field-value that is identical to the Location
      field-value indicates that this payload is a current
      representation of the newly created resource.

   o  Otherwise, such a Content-Location indicates that this payload is
      a representation reporting on the requested action's status and
      that the same report is available (for future access with GET) at
      the given URI.  For example, a purchase transaction made via a
      POST request might include a receipt document as the payload of
      the 200 (OK) response; the Content-Location field-value provides
      an identifier for retrieving a copy of that same receipt in the
      future.

   A user agent that sends Content-Location in a request message is
   stating that its value refers to where the user agent originally
   obtained the content of the enclosed representation (prior to any
   modifications made by that user agent).  In other words, the user
   agent is providing a back link to the source of the original
   representation. 

   An origin server that receives a Content-Location field in a request
   message MUST treat the information as transitory request context
   rather than as metadata to be saved verbatim as part of the
   representation.  An origin server MAY use that context to guide in
   processing the request or to save it for other uses, such as within
   source links or versioning metadata.  However, an origin server MUST
   NOT use such context information to alter the request semantics.

   For example, if a client makes a PUT request on a negotiated resource
   and the origin server accepts that PUT (without redirection), then
   the new state of that resource is expected to be consistent with the
   one representation supplied in that PUT; the Content-Location cannot
   be used as a form of reverse content selection identifier to update
   only one of the negotiated representations.  If the user agent had
   wanted the latter semantics, it would have applied the PUT directly
   to the Content-Location URI.</source>
          <target state="translated">Поле заголовка &amp;laquo;Content-Location&amp;raquo; ссылается на URI, который может использоваться в качестве идентификатора для конкретного ресурса, соответствующего представлению в полезной нагрузке этого сообщения. Другими словами, если бы кто-то должен был выполнить запрос GET для этого URI во время генерации этого сообщения, то ответ 200 (OK) будет содержать то же представление, что и полезная нагрузка в этом сообщении. Content-Location = absolute-URI / partial-URI Значение Content-Location не является заменой действующего URI запроса ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;раздел 5.5 [RFC7230]&lt;/a&gt; ). Это метаданные представления. Он имеет тот же синтаксис и семантику, что и одноименное поле заголовка, определенное для частей тела MIME в &lt;a href=&quot;https://tools.ietf.org/html/rfc2557#section-4&quot;&gt;Разделе 4 [RFC2557].&lt;/a&gt;, Однако его появление в сообщении HTTP имеет некоторые особые последствия для получателей HTTP. Если Content-Location включен в ответное сообщение 2xx (Успешно) и его значение относится (после преобразования в абсолютную форму) к URI, который совпадает с действующим URI запроса, то получатель МОЖЕТ рассматривать полезные данные как текущее представление этого ресурса во время, указанное датой создания сообщения. Для запроса GET ( &lt;a href=&quot;#section-4.3.1&quot;&gt;раздел 4.3.1&lt;/a&gt; ) или HEAD ( &lt;a href=&quot;#section-4.3.2&quot;&gt;раздел 4.3.2&lt;/a&gt; ) это то же самое, что и семантика по умолчанию, когда сервер не предоставляет Content-Location. Для запроса на изменение состояния, такого как PUT ( &lt;a href=&quot;#section-4.3.4&quot;&gt;Раздел 4.3.4&lt;/a&gt; ) или POST ( &lt;a href=&quot;#section-4.3.3&quot;&gt;Раздел 4.3.3)&lt;/a&gt;), это означает, что ответ сервера содержит новое представление этого ресурса, тем самым отличая его от представлений, которые могут сообщать только о действии (например, &amp;laquo;Это сработало!&amp;raquo;). Это позволяет приложениям-разработчикам обновлять свои локальные копии без необходимости в последующем запросе GET. Если Content-Location включен в ответное сообщение 2xx (Successful) и его значение поля относится к URI, который отличается от действующего URI запроса, то исходный сервер утверждает, что URI является идентификатором для другого ресурса, соответствующего вложенному представление. Такому утверждению можно доверять только в том случае, если оба идентификатора совместно используют одного и того же владельца ресурса, что не может быть определено программно через HTTP. o Для ответа на запрос GET или HEAD,это указание на то, что эффективный URI запроса относится к ресурсу, который является предметом согласования содержимого, а значение поля Content-Location является более конкретным идентификатором для выбранного представления. o Для ответа 201 (Created) на метод изменения состояния значение поля Content-Location, которое идентично значению поля Location, указывает, что эта полезная нагрузка является текущим представлением вновь созданного ресурса. o В противном случае такое Content-Location указывает, что эта полезная нагрузка является представлением, сообщающим о состоянии запрошенного действия, и что тот же отчет доступен (для будущего доступа с помощью GET) по данному URI. Например,транзакция покупки, совершенная через запрос POST, может включать в себя квитанцию ​​в качестве полезной нагрузки ответа 200 (OK); значение поля Content-Location предоставляет идентификатор для получения копии той же квитанции в будущем. Пользовательский агент, который отправляет Content-Location в сообщении с запросом, заявляет, что его значение относится к тому, где пользовательский агент первоначально получил контент вложенного представления (до любых изменений, сделанных этим пользовательским агентом). Другими словами, пользовательский агент предоставляет обратную ссылку на источник исходного представления. Исходный сервер, который получает поле Content-Location в сообщении запроса, ДОЛЖЕН обрабатывать информацию как временный контекст запроса, а не как метаданные, которые должны быть сохранены дословно как часть представления.Исходный сервер МОЖЕТ использовать этот контекст для руководства при обработке запроса или для его сохранения для других целей, например, для ссылок на источники или метаданных управления версиями. Однако исходный сервер НЕ ДОЛЖЕН использовать такую ​​контекстную информацию для изменения семантики запроса. Например, если клиент делает запрос PUT для согласованного ресурса, а исходный сервер принимает этот PUT (без перенаправления), то ожидается, что новое состояние этого ресурса будет согласовано с одним представлением, предоставленным в этом PUT; Content-Location не может использоваться как форма обратного идентификатора выбора контента для обновления только одного из согласованных представлений. Если бы пользовательскому агенту требовалась последняя семантика, он применил бы PUT непосредственно к URI Content-Location.</target>
        </trans-unit>
        <trans-unit id="e94ff61628ee1556f9cb7b6e53cdb420e3640f8b" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Range&quot; header field is sent in a single part 206
   (Partial Content) response to indicate the partial range of the
   selected representation enclosed as the message payload, sent in each
   part of a multipart 206 response to indicate the range enclosed
   within each body part, and sent in 416 (Range Not Satisfiable)
   responses to provide information about the selected representation.

     Content-Range       = byte-content-range
                         / other-content-range

     byte-content-range  = bytes-unit SP
                           ( byte-range-resp / unsatisfied-range )

     byte-range-resp     = byte-range &quot;/&quot; ( complete-length / &quot;*&quot; )
     byte-range          = first-byte-pos &quot;-&quot; last-byte-pos
     unsatisfied-range   = &quot;*/&quot; complete-length

     complete-length     = 1*DIGIT

     other-content-range = other-range-unit SP other-range-resp
     other-range-resp    = *CHAR 

   If a 206 (Partial Content) response contains a Content-Range header
   field with a range unit (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;) that the recipient does not
   understand, the recipient MUST NOT attempt to recombine it with a
   stored representation.  A proxy that receives such a message SHOULD
   forward it downstream.

   For byte ranges, a sender SHOULD indicate the complete length of the
   representation from which the range has been extracted, unless the
   complete length is unknown or difficult to determine.  An asterisk
   character (&quot;*&quot;) in place of the complete-length indicates that the
   representation length was unknown when the header field was
   generated.

   The following example illustrates when the complete length of the
   selected representation is known by the sender to be 1234 bytes:

     Content-Range: bytes 42-1233/1234

   and this second example illustrates when the complete length is
   unknown:

     Content-Range: bytes 42-1233/*

   A Content-Range field value is invalid if it contains a
   byte-range-resp that has a last-byte-pos value less than its
   first-byte-pos value, or a complete-length value less than or equal
   to its last-byte-pos value.  The recipient of an invalid
   Content-Range MUST NOT attempt to recombine the received content with
   a stored representation.

   A server generating a 416 (Range Not Satisfiable) response to a
   byte-range request SHOULD send a Content-Range header field with an
   unsatisfied-range value, as in the following example:

     Content-Range: bytes */1234

   The complete-length in a 416 response indicates the current length of
   the selected representation.

   The Content-Range header field has no meaning for status codes that
   do not explicitly describe its semantic.  For this specification,
   only the 206 (Partial Content) and 416 (Range Not Satisfiable) status
   codes describe a meaning for Content-Range. 

   The following are examples of Content-Range values in which the
   selected representation contains a total of 1234 bytes:

   o  The first 500 bytes:

        Content-Range: bytes 0-499/1234

   o  The second 500 bytes:

        Content-Range: bytes 500-999/1234

   o  All except for the first 500 bytes:

        Content-Range: bytes 500-1233/1234

   o  The last 500 bytes:

        Content-Range: bytes 734-1233/1234</source>
          <target state="translated">Поле заголовка Content-Range отправляется в ответе с одной частью 206 (частичное содержимое), чтобы указать частичный диапазон выбранного представления, заключенного в качестве полезной нагрузки сообщения, отправляемого в каждой части многочастного ответа 206, чтобы указать диапазон, заключенный в каждой части тела и отправили 416 (диапазон не удовлетворяет) ответов, чтобы предоставить информацию о выбранном представлении. Content-Range = byte-content-range / other-content-range byte-content-range = byte-unit SP (byte-range-resp / unsatisfied-range) byte-range-resp = byte-range &quot;/&quot; (полный -length / &quot;*&quot;) byte-range = first-byte-pos &quot;-&quot; last-byte-pos unsatisfied-range = &quot;* /&quot;full-length complete-length = 1 * DIGIT other-content-range = other-range-unit SP other-range-resp other-range-resp = * CHAR Если ответ 206 (частичное содержимое) содержит поле заголовка Content-Range с дальномером (&lt;a href=&quot;#section-2&quot;&gt;Раздел 2&lt;/a&gt;), которого получатель не понимает, получатель НЕ ДОЛЖЕН пытаться рекомбинировать его с сохраненным представлением. Прокси-сервер, который получает такое сообщение, ДОЛЖЕН пересылать его в нисходящем направлении. Для байтовых диапазонов отправителю СЛЕДУЕТ указать полную длину представления, из которого был извлечен диапазон, если полная длина неизвестна или ее трудно определить. Символ звездочки (&amp;laquo;*&amp;raquo;) вместо полной длины указывает, что длина представления была неизвестна на момент создания поля заголовка. В следующем примере показано, когда полная длина выбранного представления, как известно отправителю, составляет 1234 байта: Content-Range: байты 42-1233 / 1234, а этот второй пример показывает, когда полная длина неизвестна: Content-Range:bytes 42-1233 / * Значение поля Content-Range недействительно, если оно содержит byte-range-resp, у которого значение last-byte-pos меньше, чем его значение first-byte-pos, или значение полной длины меньше, чем или равно его значению last-byte-pos. Получатель недопустимого Content-Range НЕ ДОЛЖЕН пытаться рекомбинировать полученный контент с сохраненным представлением. Серверу, генерирующему ответ 416 (Range Not Satisfiable) на запрос диапазона байтов, СЛЕДУЕТ отправить поле заголовка Content-Range со значением неудовлетворенного диапазона, как в следующем примере: Content-Range: bytes * / 1234 The full-length в ответе 416 указывает текущую длину выбранного представления. Поле заголовка Content-Range не имеет значения для кодов состояния, которые явно не описывают его семантику. Для этой спецификациитолько коды состояния 206 (частичное содержимое) и 416 (диапазон не удовлетворяется) описывают значение Content-Range. Ниже приведены примеры значений Content-Range, в которых выбранное представление содержит всего 1234 байта: o Первые 500 байтов: Content-Range: байты 0-499 / 1234 o Вторые 500 байтов: Content-Range: байты 500- 999/1234 o Все, кроме первых 500 байтов: Content-Range: байты 500-1233 / 1234 o Последние 500 байтов: Content-Range: байты 734-1233 / 1234байты 0-499 / 1234 o Вторые 500 байтов: Content-Range: байты 500-999 / 1234 o Все, кроме первых 500 байтов: Content-Range: байты 500-1233 / 1234 o Последние 500 байтов: Content-Range : байты 734-1233 / 1234байты 0-499 / 1234 o Вторые 500 байтов: Content-Range: байты 500-999 / 1234 o Все, кроме первых 500 байтов: Content-Range: байты 500-1233 / 1234 o Последние 500 байтов: Content-Range : байты 734-1233 / 1234</target>
        </trans-unit>
        <trans-unit id="3c402cbbcb9ecb9297de91cbbec783939a3ff8f6" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Type&quot; header field indicates the media type of the
   associated representation: either the representation enclosed in the
   message payload or the selected representation, as determined by the
   message semantics.  The indicated media type defines both the data
   format and how that data is intended to be processed by a recipient,
   within the scope of the received message semantics, after any content
   codings indicated by Content-Encoding are decoded.

     Content-Type = media-type 

   Media types are defined in &lt;a href=&quot;#section-3.1.1.1&quot;&gt;Section 3.1.1.1&lt;/a&gt;.  An example of the field
   is

     Content-Type: text/html; charset=ISO-8859-4

   A sender that generates a message containing a payload body SHOULD
   generate a Content-Type header field in that message unless the
   intended media type of the enclosed representation is unknown to the
   sender.  If a Content-Type header field is not present, the recipient
   MAY either assume a media type of &quot;application/octet-stream&quot;
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-4.5.1&quot;&gt;[RFC2046], Section&amp;nbsp;4.5.1&lt;/a&gt;) or examine the data to determine its type.

   In practice, resource owners do not always properly configure their
   origin server to provide the correct Content-Type for a given
   representation, with the result that some clients will examine a
   payload's content and override the specified type.  Clients that do
   so risk drawing incorrect conclusions, which might expose additional
   security risks (e.g., &quot;privilege escalation&quot;).  Furthermore, it is
   impossible to determine the sender's intent by examining the data
   format: many data formats match multiple media types that differ only
   in processing semantics.  Implementers are encouraged to provide a
   means of disabling such &quot;content sniffing&quot; when it is used.</source>
          <target state="translated">Поле заголовка Content-Type указывает тип носителя связанного представления: либо представление, заключенное в полезной нагрузке сообщения, либо выбранное представление, как определено семантикой сообщения. Указанный тип мультимедиа определяет как формат данных, так и то, как эти данные предназначены для обработки получателем в рамках семантики полученного сообщения после декодирования любых кодировок содержимого, указанных с помощью Content-Encoding. Content-Type = media-type Типы мультимедиа определены в &lt;a href=&quot;#section-3.1.1.1&quot;&gt;разделе 3.1.1.1.&lt;/a&gt;, Пример поля - Content-Type: text / html; charset = ISO-8859-4 Отправителю, который генерирует сообщение, содержащее тело полезной нагрузки, СЛЕДУЕТ сгенерировать поле заголовка Content-Type в этом сообщении, если только предполагаемый тип мультимедиа вложенного представления неизвестен отправителю. Если поле заголовка Content-Type отсутствует, получатель МОЖЕТ либо принять тип носителя &amp;laquo;application / octet-stream&amp;raquo; ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-4.5.1&quot;&gt;[RFC2046], раздел 4.5.1).&lt;/a&gt;) или изучите данные, чтобы определить их тип. На практике владельцы ресурсов не всегда правильно настраивают свой исходный сервер для предоставления правильного Content-Type для данного представления, в результате чего некоторые клиенты будут проверять содержимое полезной нагрузки и переопределять указанный тип. Клиенты, которые поступают таким образом, рискуют сделать неверные выводы, что может привести к дополнительным рискам безопасности (например, &amp;laquo;повышение привилегий&amp;raquo;). Кроме того, невозможно определить намерение отправителя, исследуя формат данных: многие форматы данных соответствуют нескольким типам носителей, которые отличаются только семантикой обработки. Разработчикам рекомендуется предоставлять средства для отключения такого &amp;laquo;сниффинга контента&amp;raquo;, когда оно используется.</target>
        </trans-unit>
        <trans-unit id="c0724161072ae90382f70ffbb3410a3dba3f3bf1" translate="yes" xml:space="preserve">
          <source>The &quot;Date&quot; header field represents the date and time at which the
   message was originated, having the same semantics as the Origination
   Date Field (orig-date) defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.1&quot;&gt;Section&amp;nbsp;3.6.1 of [RFC5322]&lt;/a&gt;.  The
   field value is an HTTP-date, as defined in &lt;a href=&quot;#section-7.1.1.1&quot;&gt;Section 7.1.1.1&lt;/a&gt;.

     Date = HTTP-date

   An example is

     Date: Tue, 15 Nov 1994 08:12:31 GMT

   When a Date header field is generated, the sender SHOULD generate its
   field value as the best available approximation of the date and time
   of message generation.  In theory, the date ought to represent the
   moment just before the payload is generated.  In practice, the date
   can be generated at any time during message origination.

   An origin server MUST NOT send a Date header field if it does not
   have a clock capable of providing a reasonable approximation of the
   current instance in Coordinated Universal Time.  An origin server MAY
   send a Date header field if the response is in the 1xx
   (Informational) or 5xx (Server Error) class of status codes.  An
   origin server MUST send a Date header field in all other cases. 

   A recipient with a clock that receives a response message without a
   Date header field MUST record the time it was received and append a
   corresponding Date header field to the message's header section if it
   is cached or forwarded downstream.

   A user agent MAY send a Date header field in a request, though
   generally will not do so unless it is believed to convey useful
   information to the server.  For example, custom applications of HTTP
   might convey a Date if the server is expected to adjust its
   interpretation of the user's request based on differences between the
   user agent and server clocks.</source>
          <target state="translated">Поле заголовка &amp;laquo;Дата&amp;raquo; представляет дату и время, когда было &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.1&quot;&gt;отправлено&lt;/a&gt; сообщение, и имеет ту же семантику, что и поле &amp;laquo;Дата создания&amp;raquo; (orig-date), определенное в разделе 3.6.1 [RFC5322] . Значением поля является дата HTTP, как определено в &lt;a href=&quot;#section-7.1.1.1&quot;&gt;Разделе 7.1.1.1.&lt;/a&gt;, Date = HTTP-date Пример: Date: Tue, 15 Nov 1994, 08:12:31 GMT. Когда создается поле заголовка Date, отправителю СЛЕДУЕТ сгенерировать значение своего поля как наилучшее доступное приближение даты и времени создания сообщения. Теоретически дата должна представлять момент непосредственно перед созданием полезной нагрузки. На практике дату можно создать в любой момент во время создания сообщения. Исходный сервер НЕ ДОЛЖЕН отправлять поле заголовка Date, если у него нет часов, способных обеспечить разумную аппроксимацию текущего экземпляра во всемирном координированном времени. Исходный сервер МОЖЕТ отправить поле заголовка Date, если ответ относится к классу кодов состояния 1xx (информационный) или 5xx (ошибка сервера). Во всех остальных случаях исходный сервер ДОЛЖЕН отправить поле заголовка Date.Получатель с часами, который получает ответное сообщение без поля заголовка Date, ДОЛЖЕН записать время его получения и добавить соответствующее поле заголовка Date к разделу заголовка сообщения, если оно кэшируется или пересылается в нисходящем направлении. Пользовательский агент МОЖЕТ отправить поле заголовка Date в запросе, хотя обычно не будет этого делать, если не предполагается, что он передает полезную информацию на сервер. Например, пользовательские приложения HTTP могут передавать дату, если ожидается, что сервер настроит свою интерпретацию запроса пользователя на основе различий между часами пользовательского агента и сервера.s раздел заголовка, если он кэшируется или перенаправляется вниз по течению. Пользовательский агент МОЖЕТ отправить поле заголовка Date в запросе, хотя обычно не будет этого делать, если не предполагается, что он передает полезную информацию на сервер. Например, пользовательские приложения HTTP могут передавать дату, если ожидается, что сервер настроит свою интерпретацию запроса пользователя на основе различий между часами пользовательского агента и сервера.s раздел заголовка, если он кэшируется или перенаправляется вниз по течению. Пользовательский агент МОЖЕТ отправить поле заголовка Date в запросе, хотя обычно не будет этого делать, если не предполагается, что он передает полезную информацию на сервер. Например, пользовательские приложения HTTP могут передавать дату, если ожидается, что сервер настроит свою интерпретацию запроса пользователя на основе различий между часами пользовательского агента и сервера.</target>
        </trans-unit>
        <trans-unit id="d5a2d6bec4db1f50bd741730e8b916c0b881dd31" translate="yes" xml:space="preserve">
          <source>The &quot;ETag&quot; header field in a response provides the current entity-tag
   for the selected representation, as determined at the conclusion of
   handling the request.  An entity-tag is an opaque validator for
   differentiating between multiple representations of the same
   resource, regardless of whether those multiple representations are
   due to resource state changes over time, content negotiation
   resulting in multiple representations being valid at the same time,
   or both.  An entity-tag consists of an opaque quoted string, possibly
   prefixed by a weakness indicator.

     ETag       = entity-tag

     entity-tag = [ weak ] opaque-tag
     weak       = %x57.2F ; &quot;W/&quot;, case-sensitive
     opaque-tag = DQUOTE *etagc DQUOTE
     etagc      = %x21 / %x23-7E / obs-text
                ; VCHAR except double quotes, plus obs-text

      Note: Previously, opaque-tag was defined to be a quoted-string
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616], Section&amp;nbsp;3.11&lt;/a&gt;); thus, some recipients might perform
      backslash unescaping.  Servers therefore ought to avoid backslash
      characters in entity tags.

   An entity-tag can be more reliable for validation than a modification
   date in situations where it is inconvenient to store modification
   dates, where the one-second resolution of HTTP date values is not
   sufficient, or where modification dates are not consistently
   maintained.

   Examples:

     ETag: &quot;xyzzy&quot;
     ETag: W/&quot;xyzzy&quot;
     ETag: &quot;&quot; 

   An entity-tag can be either a weak or strong validator, with strong
   being the default.  If an origin server provides an entity-tag for a
   representation and the generation of that entity-tag does not satisfy
   all of the characteristics of a strong validator (&lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;), then
   the origin server MUST mark the entity-tag as weak by prefixing its
   opaque value with &quot;W/&quot; (case-sensitive).</source>
          <target state="translated">Поле заголовка &amp;laquo;ETag&amp;raquo; в ответе предоставляет текущий тег объекта для выбранного представления, как определено в конце обработки запроса. Объект-тег - это непрозрачный валидатор для различения нескольких представлений одного и того же ресурса, независимо от того, вызваны ли эти несколько представлений изменениями состояния ресурса с течением времени, согласованием содержимого, приводящим к одновременному действию нескольких представлений, или и тем, и другим. Объект-тег состоит из непрозрачной строки в кавычках, возможно, с префиксом индикатора слабости. ETag = entity-tag entity-tag = [weak] opaque-tag weak =% x57.2F; &quot;W /&quot;, чувствительный к регистру opaque-tag = DQUOTE * etagc DQUOTE etagc =% x21 /% x23-7E / obs-text; VCHAR кроме двойных кавычек,плюс obs-text Примечание. Ранее непрозрачный тег определялся как строка в кавычках (&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616], раздел 3.11&lt;/a&gt; ); таким образом, некоторые получатели могут выполнять обратную косую черту без экранирования. Поэтому серверам следует избегать символов обратной косой черты в тегах сущностей. Тег entity-tag может быть более надежным для проверки, чем дата модификации, в ситуациях, когда неудобно хранить даты модификации, где односекундное разрешение значений даты HTTP недостаточно или когда даты модификации не поддерживаются постоянно. Примеры: ETag: &quot;xyzzy&quot; ETag: W / &quot;xyzzy&quot; ETag: &quot;&quot; Тег объекта может быть либо слабым, либо сильным валидатором, по умолчанию - сильным.Если исходный сервер предоставляет объектный тег для представления и генерация этого объектного тега не удовлетворяет всем характеристикам сильного валидатора ( &lt;a href=&quot;#section-2.1&quot;&gt;раздел 2.1&lt;/a&gt;), то исходный сервер ДОЛЖЕН пометить тег объекта как слабый, добавив к его непрозрачному значению префикс &quot;W /&quot; (с учетом регистра).</target>
        </trans-unit>
        <trans-unit id="6cbf7e19bfd8298755a091ae5f476f70610c660d" translate="yes" xml:space="preserve">
          <source>The &quot;Expect&quot; header field in a request indicates a certain set of
   behaviors (expectations) that need to be supported by the server in
   order to properly handle this request.  The only such expectation
   defined by this specification is 100-continue.

     Expect  = &quot;100-continue&quot;

   The Expect field-value is case-insensitive.

   A server that receives an Expect field-value other than 100-continue
   MAY respond with a 417 (Expectation Failed) status code to indicate
   that the unexpected expectation cannot be met.

   A 100-continue expectation informs recipients that the client is
   about to send a (presumably large) message body in this request and
   wishes to receive a 100 (Continue) interim response if the
   request-line and header fields are not sufficient to cause an
   immediate success, redirect, or error response.  This allows the
   client to wait for an indication that it is worthwhile to send the
   message body before actually doing so, which can improve efficiency
   when the message body is huge or when the client anticipates that an
   error is likely (e.g., when sending a state-changing method, for the
   first time, without previously verified authentication credentials).

   For example, a request that begins with

     PUT /somewhere/fun HTTP/1.1
     Host: origin.example.com
     Content-Type: video/h264
     Content-Length: 1234567890987
     Expect: 100-continue


   allows the origin server to immediately respond with an error
   message, such as 401 (Unauthorized) or 405 (Method Not Allowed),
   before the client starts filling the pipes with an unnecessary data
   transfer.

   Requirements for clients:

   o  A client MUST NOT generate a 100-continue expectation in a request
      that does not include a message body.

   o  A client that will wait for a 100 (Continue) response before
      sending the request message body MUST send an Expect header field
      containing a 100-continue expectation. 

   o  A client that sends a 100-continue expectation is not required to
      wait for any specific length of time; such a client MAY proceed to
      send the message body even if it has not yet received a response.
      Furthermore, since 100 (Continue) responses cannot be sent through
      an HTTP/1.0 intermediary, such a client SHOULD NOT wait for an
      indefinite period before sending the message body.

   o  A client that receives a 417 (Expectation Failed) status code in
      response to a request containing a 100-continue expectation SHOULD
      repeat that request without a 100-continue expectation, since the
      417 response merely indicates that the response chain does not
      support expectations (e.g., it passes through an HTTP/1.0 server).

   Requirements for servers:

   o  A server that receives a 100-continue expectation in an HTTP/1.0
      request MUST ignore that expectation.

   o  A server MAY omit sending a 100 (Continue) response if it has
      already received some or all of the message body for the
      corresponding request, or if the framing indicates that there is
      no message body.

   o  A server that sends a 100 (Continue) response MUST ultimately send
      a final status code, once the message body is received and
      processed, unless the connection is closed prematurely.

   o  A server that responds with a final status code before reading the
      entire message body SHOULD indicate in that response whether it
      intends to close the connection or continue reading and discarding
      the request message (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.6&quot;&gt;Section&amp;nbsp;6.6 of [RFC7230]&lt;/a&gt;).

   An origin server MUST, upon receiving an HTTP/1.1 (or later)
   request-line and a complete header section that contains a
   100-continue expectation and indicates a request message body will
   follow, either send an immediate response with a final status code,
   if that status can be determined by examining just the request-line
   and header fields, or send an immediate 100 (Continue) response to
   encourage the client to send the request's message body.  The origin
   server MUST NOT wait for the message body before sending the 100
   (Continue) response.

   A proxy MUST, upon receiving an HTTP/1.1 (or later) request-line and
   a complete header section that contains a 100-continue expectation
   and indicates a request message body will follow, either send an
   immediate response with a final status code, if that status can be
   determined by examining just the request-line and header fields, or
   begin forwarding the request toward the origin server by sending a 

   corresponding request-line and header section to the next inbound
   server.  If the proxy believes (from configuration or past
   interaction) that the next inbound server only supports HTTP/1.0, the
   proxy MAY generate an immediate 100 (Continue) response to encourage
   the client to begin sending the message body.

      Note: The Expect header field was added after the original
      publication of HTTP/1.1 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;] as both the means to request an
      interim 100 (Continue) response and the general mechanism for
      indicating must-understand extensions.  However, the extension
      mechanism has not been used by clients and the must-understand
      requirements have not been implemented by many servers, rendering
      the extension mechanism useless.  This specification has removed
      the extension mechanism in order to simplify the definition and
      processing of 100-continue.</source>
          <target state="translated">Поле заголовка &amp;laquo;Expect&amp;raquo; в запросе указывает на определенный набор поведения (ожиданий), который должен поддерживаться сервером для правильной обработки этого запроса. Единственное такое ожидание, определенное этой спецификацией, - 100-continue. Expect = &quot;100-continue&quot; Значение поля Expect не чувствительно к регистру. Сервер, который получает значение поля Expect, отличное от 100-continue, МОЖЕТ ответить кодом состояния 417 (Expectation Failed), чтобы указать, что неожиданное ожидание не может быть выполнено. Ожидание 100-continue информирует получателей о том, что клиент собирается отправить (предположительно большой) тело сообщения в этом запросе и желает получить промежуточный ответ 100 (Continue), если поля строки запроса и заголовка недостаточно, чтобы вызвать немедленное успех, перенаправление,или ответ об ошибке. Это позволяет клиенту дождаться индикации того, что стоит отправить тело сообщения, прежде чем это делать, что может повысить эффективность, когда тело сообщения огромно или когда клиент ожидает вероятной ошибки (например, при отправке состояния -смена метода, впервые без ранее проверенных учетных данных). Например, запрос, который начинается с PUT /where / fun HTTP / 1.1 Host: origin.example.com Content-Type: video / h264 Content-Length: 1234567890987 Expect: 100-continue, позволяет исходному серверу немедленно ответить с ошибкой. сообщение, такое как 401 (Unauthorized) или 405 (Method Not Allowed), прежде чем клиент начнет заполнять каналы ненужной передачей данных. Требования к клиентам:o Клиент НЕ ДОЛЖЕН генерировать ожидание 100-продолжения в запросе, который не включает тело сообщения. o Клиент, который будет ждать ответа 100 (Продолжить) перед отправкой тела сообщения запроса, ДОЛЖЕН отправить поле заголовка Expect, содержащее ожидание 100-продолжения. o Клиент, который отправляет ожидание продолжения 100, не обязан ждать в течение определенного периода времени; такой клиент МОЖЕТ продолжить отправку тела сообщения, даже если он еще не получил ответа. Кроме того, поскольку 100 ответов (Продолжить) не могут быть отправлены через посредник HTTP / 1.0, такому клиенту НЕ СЛЕДУЕТ ждать неопределенное время перед отправкой тела сообщения.o Клиент, который получает код состояния 417 (ожидание не выполнено) в ответ на запрос, содержащий ожидание 100-продолжения, ДОЛЖЕН повторить этот запрос без ожидания 100-продолжения, поскольку ответ 417 просто указывает, что цепочка ответов не поддерживает ожидания ( например, он проходит через сервер HTTP / 1.0). Требования к серверам: o Сервер, который получает ожидание 100-продолжения в запросе HTTP / 1.0, ДОЛЖЕН игнорировать это ожидание. o Сервер МОЖЕТ пропустить отправку ответа 100 (Продолжить), если он уже получил часть или все тело сообщения для соответствующего запроса, или если кадрирование указывает на отсутствие тела сообщения. o Сервер, который отправляет ответ 100 (Продолжить), ДОЛЖЕН в конечном итоге отправить окончательный код состояния,после получения и обработки тела сообщения, если соединение не разорвано преждевременно. o Сервер, который отвечает окончательным кодом состояния перед чтением всего тела сообщения, ДОЛЖЕН указать в этом ответе, намеревается ли он закрыть соединение или продолжить чтение и отбрасывание сообщения запроса (см.&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.6&quot;&gt;Раздел 6.6 [RFC7230]&lt;/a&gt;). Исходный сервер ДОЛЖЕН после получения строки запроса HTTP / 1.1 (или новее) и полного раздела заголовка, который содержит ожидание продолжения 100 и указывает, что тело сообщения запроса будет следовать, либо отправить немедленный ответ с окончательным кодом состояния, если этот статус можно определить, проверив только поля строки запроса и заголовка, или отправить немедленный ответ 100 (Продолжить), чтобы побудить клиента отправить тело сообщения запроса. Исходный сервер НЕ ДОЛЖЕН ждать тела сообщения перед отправкой ответа 100 (Продолжить). Прокси-сервер ДОЛЖЕН после получения строки запроса HTTP / 1.1 (или более поздней версии) и полного раздела заголовка, который содержит ожидание продолжения 100 и указывает, что тело сообщения запроса будет следовать, либо отправить немедленный ответ с окончательным кодом состояния,если этот статус можно определить, изучив только поля строки запроса и заголовка, или начать пересылку запроса исходному серверу, отправив соответствующую строку запроса и раздел заголовка на следующий входящий сервер. Если прокси считает (из конфигурации или прошлого взаимодействия), что следующий входящий сервер поддерживает только HTTP / 1.0, прокси МОЖЕТ немедленно сгенерировать ответ 100 (Продолжить), чтобы побудить клиента начать отправку тела сообщения. Примечание. Поле заголовка Expect было добавлено после первоначальной публикации HTTP / 1.1 [Если прокси считает (из конфигурации или прошлого взаимодействия), что следующий входящий сервер поддерживает только HTTP / 1.0, прокси МОЖЕТ немедленно сгенерировать ответ 100 (Продолжить), чтобы побудить клиента начать отправку тела сообщения. Примечание. Поле заголовка Expect было добавлено после первоначальной публикации HTTP / 1.1 [Если прокси полагает (из конфигурации или прошлого взаимодействия), что следующий входящий сервер поддерживает только HTTP / 1.0, прокси МОЖЕТ немедленно сгенерировать ответ 100 (Продолжить), чтобы побудить клиента начать отправку тела сообщения. Примечание. Поле заголовка Expect было добавлено после первоначальной публикации HTTP / 1.1 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt; ] как средство для запроса промежуточного ответа 100 (продолжить) и как общий механизм для указания расширений, которые необходимо понимать. Однако механизм расширения не использовался клиентами, а обязательные требования не были реализованы на многих серверах, что делает механизм расширения бесполезным. В этой спецификации был удален механизм расширения, чтобы упростить определение и обработку 100-continue.</target>
        </trans-unit>
        <trans-unit id="73ec74b4c3de0b0e8320b9c1e9209dc1703d5df1" translate="yes" xml:space="preserve">
          <source>The &quot;Expires&quot; header field gives the date/time after which the
   response is considered stale.  See &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; for further discussion
   of the freshness model.

   The presence of an Expires field does not imply that the original
   resource will change or cease to exist at, before, or after that
   time.

   The Expires value is an HTTP-date timestamp, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;7.1.1.1 of [RFC7231]&lt;/a&gt;.

     Expires = HTTP-date

   For example

     Expires: Thu, 01 Dec 1994 16:00:00 GMT

   A cache recipient MUST interpret invalid date formats, especially the
   value &quot;0&quot;, as representing a time in the past (i.e., &quot;already
   expired&quot;).

   If a response includes a Cache-Control field with the max-age
   directive (&lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt;), a recipient MUST ignore the Expires
   field.  Likewise, if a response includes the s-maxage directive
   (&lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;), a shared cache recipient MUST ignore the Expires
   field.  In both these cases, the value in Expires is only intended
   for recipients that have not yet implemented the Cache-Control field.

   An origin server without a clock MUST NOT generate an Expires field
   unless its value represents a fixed time in the past (always expired)
   or its value has been associated with the resource by a system or
   user with a reliable clock.

   Historically, HTTP required the Expires field-value to be no more
   than a year in the future.  While longer freshness lifetimes are no
   longer prohibited, extremely large values have been demonstrated to
   cause problems (e.g., clock overflows due to use of 32-bit integers
   for time values), and many caches will evict a response far sooner
   than that.</source>
          <target state="translated">В поле заголовка &amp;laquo;Истекает&amp;raquo; указывается дата / время, после которых ответ считается устаревшим. См. &lt;a href=&quot;#section-4.2&quot;&gt;Раздел 4.2&lt;/a&gt; для дальнейшего обсуждения модели свежести. Наличие поля Expires не означает, что исходный ресурс изменится или прекратит свое существование в, до или после этого времени. Значение Expires представляет собой метку времени HTTP-даты, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;разделе &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;7.1.1.1 [RFC7231]&lt;/a&gt; . Expires = HTTP-date Например, Expires: Thu, 01 Dec 1994 16:00:00 GMT Получатель кеша ДОЛЖЕН интерпретировать недопустимые форматы даты, особенно значение &amp;laquo;0&amp;raquo;, как представление времени в прошлом (т. Е. &amp;laquo;Уже истекло&amp;raquo; ). Если ответ включает поле Cache-Control с директивой max-age ( &lt;a href=&quot;#section-5.2.2.8&quot;&gt;Раздел 5.2.2.8&lt;/a&gt;), получатель ДОЛЖЕН игнорировать поле Expires. Аналогично, если ответ включает директиву s-maxage ( &lt;a href=&quot;#section-5.2.2.9&quot;&gt;Раздел 5.2.2.9&lt;/a&gt;), получатель общего кэша ДОЛЖЕН игнорировать поле Expires. В обоих случаях значение Expires предназначено только для получателей, которые еще не реализовали поле Cache-Control. Исходный сервер без часов НЕ ДОЛЖЕН создавать поле Expires, если его значение не представляет фиксированное время в прошлом (всегда истекло) или его значение не было связано с ресурсом системой или пользователем с надежными часами. Исторически сложилось так, что HTTP требовал, чтобы значение поля Expires не превышало года в будущем. Хотя более длительное время жизни свежести больше не запрещено, было продемонстрировано, что чрезвычайно большие значения вызывают проблемы (например, переполнение часов из-за использования 32-битных целых чисел для значений времени), и многие кеши вытеснят ответ гораздо раньше.</target>
        </trans-unit>
        <trans-unit id="435ee716a99e236d6e9d74d1e773dafee502988a" translate="yes" xml:space="preserve">
          <source>The &quot;From&quot; header field contains an Internet email address for a
   human user who controls the requesting user agent.  The address ought
   to be machine-usable, as defined by &quot;mailbox&quot; in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;Section&amp;nbsp;3.4 of
   [RFC5322]&lt;/a&gt;:

     From    = mailbox

     mailbox = &amp;lt;mailbox, see &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;

   An example is:

     From: webmaster@example.org

   The From header field is rarely sent by non-robotic user agents.  A
   user agent SHOULD NOT send a From header field without explicit
   configuration by the user, since that might conflict with the user's
   privacy interests or their site's security policy. 

   A robotic user agent SHOULD send a valid From header field so that
   the person responsible for running the robot can be contacted if
   problems occur on servers, such as if the robot is sending excessive,
   unwanted, or invalid requests.

   A server SHOULD NOT use the From header field for access control or
   authentication, since most recipients will assume that the field
   value is public information.</source>
          <target state="translated">Поле заголовка &amp;laquo;От&amp;raquo; содержит адрес электронной почты в Интернете для человека, который управляет запрашивающим агентом пользователя. Адрес должен быть машинным, как определено &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;термином&lt;/a&gt; &amp;laquo;почтовый ящик&amp;raquo; в разделе 3.4 [RFC5322] : From = mailbox mailbox = &amp;lt;mailbox, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322], раздел 3.4.&lt;/a&gt;&amp;gt; Пример: From: webmaster@example.org Поле заголовка From редко отправляется не роботизированными пользовательскими агентами. Пользовательскому агенту НЕ СЛЕДУЕТ отправлять поле заголовка From без явной конфигурации со стороны пользователя, поскольку это может противоречить интересам конфиденциальности пользователя или политике безопасности его сайта. Роботизированный пользовательский агент ДОЛЖЕН отправлять допустимое поле заголовка From, чтобы можно было связаться с лицом, ответственным за запуск робота, в случае возникновения проблем на серверах, например, если робот отправляет чрезмерные, нежелательные или недопустимые запросы. Серверу НЕ СЛЕДУЕТ использовать поле заголовка From для управления доступом или аутентификации, поскольку большинство получателей будут предполагать, что значение поля является общедоступной информацией.</target>
        </trans-unit>
        <trans-unit id="145f68a05a65e51d6c2dc78deb7c678abdc3112c" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Content Coding Registry&quot; defines the namespace for content
   coding names (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7230]&lt;/a&gt;).  The content coding registry
   is maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;laquo;Реестр кодирования содержимого HTTP&amp;raquo; определяет пространство имен для имен кодирования содержимого ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;раздел 4.2 [RFC7230]&lt;/a&gt; ). Реестр кодирования контента поддерживается по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;.</target>
        </trans-unit>
        <trans-unit id="1a7b21f0cdc6fe3b27a7e8f318212ccc9bbfe4e2" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Content Coding Registry&quot; defines the namespace for content
   coding names (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7230]&lt;/a&gt;).  The content coding registry
   is maintained at &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096c718821f30fce49e8b7b18bb3a8ea8e6712d1" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Content Coding Registry&quot; has been updated with the
   registrations below:

   +----------+----------------------------------------+---------------+
   | Name     | Description                            | Reference     |
   +----------+----------------------------------------+---------------+
   | identity | Reserved (synonym for &quot;no encoding&quot; in | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt; |
   |          | Accept-Encoding)                       |               |
   +----------+----------------------------------------+---------------+</source>
          <target state="translated">В &amp;laquo;Реестр кодирования содержимого HTTP&amp;raquo; добавлены следующие регистрации: + ---------- + ----------------------- ----------------- + --------------- + | Имя | Описание | Справка | + ---------- + -------------------------------------- - + --------------- + | личность | Зарезервировано (синоним &quot;без кодирования&quot; в | &lt;a href=&quot;#section-5.3.4&quot;&gt;Раздел 5.3.4&lt;/a&gt; | | | Accept-Encoding) | | + ---------- + -------------------------------------- - + --------------- +</target>
        </trans-unit>
        <trans-unit id="a5c1ee951a5c8eed58e62c23efb0f5396f9627c4" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Range Unit Registry&quot; defines the namespace for the range
   unit names and refers to their corresponding specifications.  The
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;laquo;Реестр единиц диапазона HTTP&amp;raquo; определяет пространство имен для имен единиц диапазона и ссылается на их соответствующие спецификации. Реестр был создан и теперь поддерживается по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;.</target>
        </trans-unit>
        <trans-unit id="75f1995c2e9e10c3b1c547ec7aef2ed12aaf759a" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Range Unit Registry&quot; defines the namespace for the range
   unit names and refers to their corresponding specifications.  The
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05bfcc8f57df61bc6ed194b315d3b4b0050023f" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Transfer Coding Registry&quot; defines the namespace for
   transfer coding names.  It is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;laquo;Реестр кодирования передачи HTTP&amp;raquo; определяет пространство имен для имен кодирования передачи. Он поддерживается по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;.</target>
        </trans-unit>
        <trans-unit id="edbeb56a986b02337b75fd6710823d9b5e86a66f" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Transfer Coding Registry&quot; defines the namespace for
   transfer coding names.  It is maintained at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b8c24090cb7e4cccc52c9a6ee16a7c95a28e07" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Transfer Coding Registry&quot; has been updated with the
   registrations below:

   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | chunked    | Transfer in a series of chunks       | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;   |
   | compress   | UNIX &quot;compress&quot; data format [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;]  | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | deflate    | &quot;deflate&quot; compressed data            | &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt; |
   |            | ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;]) inside the &quot;zlib&quot; data   |               |
   |            | format ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;])                   |               |
   | gzip       | GZIP file format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;]           | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   | x-compress | Deprecated (alias for compress)      | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | x-gzip     | Deprecated (alias for gzip)          | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   +------------+--------------------------------------+---------------+</source>
          <target state="translated">В &amp;laquo;Реестр кодирования передачи HTTP&amp;raquo; добавлены следующие регистрации: + ------------ + --------------------- ----------------- + --------------- + | Имя | Описание | Справка | + ------------ + ------------------------------------ - + --------------- + | разбитый | Передача серией кусков | &lt;a href=&quot;#section-4.1&quot;&gt;Раздел 4.1&lt;/a&gt; | | сжать | UNIX &quot;сжимает&quot; формат данных [ &lt;a href=&quot;#ref-Welch&quot;&gt;Велч&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.1&quot;&gt;Раздел 4.2.1&lt;/a&gt; | | сдуть | &quot;сдуть&quot; сжатые данные | &lt;a href=&quot;#section-4.2.2&quot;&gt;Раздел 4.2.2&lt;/a&gt; | | | ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]) внутри данных &quot;zlib&quot; | | | | формат ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;]) | | | gzip | Формат файла GZIP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.3&quot;&gt;Раздел 4.2.3&lt;/a&gt; | | x-compress | Устарело (псевдоним для сжатия) | &lt;a href=&quot;#section-4.2.1&quot;&gt;Раздел 4.2.1&lt;/a&gt; | | x-gzip | Устарело (псевдоним для gzip) | &lt;a href=&quot;#section-4.2.3&quot;&gt;Раздел 4.2.3&lt;/a&gt; | + ------------ + ------------------------------------ - + --------------- +</target>
        </trans-unit>
        <trans-unit id="49c73e0ff74e54cb4f5a88bc231df89416d0af4b" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP&quot; entry in the upgrade token registry has been updated with
   the registration below:

   +-------+----------------------+----------------------+-------------+
   | Value | Description          | Expected Version     | Reference   |
   |       |                      | Tokens               |             |
   +-------+----------------------+----------------------+-------------+
   | HTTP  | Hypertext Transfer   | any DIGIT.DIGIT      | &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt; |
   |       | Protocol             | (e.g, &quot;2.0&quot;)         |             |
   +-------+----------------------+----------------------+-------------+

   The responsible party is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">Запись &amp;laquo;HTTP&amp;raquo; в реестре токенов обновления была обновлена ​​с регистрацией ниже: + ------- + ---------------------- + ---------------------- + ------------- + | Значение | Описание | Ожидаемая версия | Справка | | | | Жетоны | | + ------- + ---------------------- + ------------------ ---- + ------------- + | HTTP | Передача гипертекста | любая DIGIT.DIGIT | &lt;a href=&quot;#section-2.6&quot;&gt;Раздел 2.6&lt;/a&gt; | | | Протокол | (например, &amp;laquo;2,0&amp;raquo;) | | + ------- + ---------------------- + ------------------ ---- + ------------- + Ответственная сторона: &amp;laquo;IETF (iesg@ietf.org) - Инженерная группа Интернета&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="706b09d6ff20df56763add1c7636ec30c154eae9" translate="yes" xml:space="preserve">
          <source>The &quot;Host&quot; header field in a request provides the host and port
   information from the target URI, enabling the origin server to
   distinguish among resources while servicing requests for multiple
   host names on a single IP address.

     Host = uri-host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;

   A client MUST send a Host header field in all HTTP/1.1 request
   messages.  If the target URI includes an authority component, then a
   client MUST send a field-value for Host that is identical to that
   authority component, excluding any userinfo subcomponent and its &quot;@&quot;
   delimiter (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;).  If the authority component is missing or
   undefined for the target URI, then a client MUST send a Host header
   field with an empty field-value.

   Since the Host field-value is critical information for handling a
   request, a user agent SHOULD generate Host as the first header field
   following the request-line.

   For example, a GET request to the origin server for
   &amp;lt;http://www.example.org/pub/WWW/&amp;gt; would begin with:

     GET /pub/WWW/ HTTP/1.1
     Host: www.example.org

   A client MUST send a Host header field in an HTTP/1.1 request even if
   the request-target is in the absolute-form, since this allows the
   Host information to be forwarded through ancient HTTP/1.0 proxies
   that might not have implemented Host.

   When a proxy receives a request with an absolute-form of
   request-target, the proxy MUST ignore the received Host header field
   (if any) and instead replace it with the host information of the
   request-target.  A proxy that forwards such a request MUST generate a
   new Host field-value based on the received request-target rather than
   forward the received Host field-value.

   Since the Host header field acts as an application-level routing
   mechanism, it is a frequent target for malware seeking to poison a
   shared cache or redirect a request to an unintended server.  An
   interception proxy is particularly vulnerable if it relies on the
   Host field-value for redirecting requests to internal servers, or for
   use as a cache key in a shared cache, without first verifying that
   the intercepted connection is targeting a valid IP address for that
   host. 

   A server MUST respond with a 400 (Bad Request) status code to any
   HTTP/1.1 request message that lacks a Host header field and to any
   request message that contains more than one Host header field or a
   Host header field with an invalid field-value.</source>
          <target state="translated">Поле заголовка &amp;laquo;Host&amp;raquo; в запросе предоставляет информацию об узле и порте из целевого URI, позволяя исходному серверу различать ресурсы при обслуживании запросов для нескольких имен узлов на одном IP-адресе. Хост = uri-host [&quot;:&quot; порт]; &lt;a href=&quot;#section-2.7.1&quot;&gt;Раздел 2.7.1&lt;/a&gt; . Клиент ДОЛЖЕН отправлять поле заголовка Host во всех сообщениях запроса HTTP / 1.1. Если целевой URI включает компонент полномочий, то клиент ДОЛЖЕН отправить значение поля для Host, которое идентично этому компоненту полномочий, за исключением подкомпонента userinfo и его разделителя &amp;laquo;@&amp;raquo; ( &lt;a href=&quot;#section-2.7.1&quot;&gt;раздел 2.7.1.&lt;/a&gt;). Если компонент полномочий отсутствует или не определен для целевого URI, то клиент ДОЛЖЕН отправить поле заголовка Host с пустым значением поля. Поскольку значение поля Host является важной информацией для обработки запроса, пользовательский агент ДОЛЖЕН сгенерировать Host в качестве первого поля заголовка, следующего за строкой запроса. Например, запрос GET к исходному серверу для &amp;lt;http://www.example.org/pub/WWW/&amp;gt; будет начинаться с: GET / pub / WWW / HTTP / 1.1 Host: www.example.org Клиент ДОЛЖЕН отправлять поле заголовка Host в запросе HTTP / 1.1, даже если цель запроса находится в абсолютной форме, поскольку это позволяет пересылать информацию Host через старые прокси HTTP / 1.0, которые, возможно, не реализовали Host. Когда прокси-сервер получает запрос с абсолютной формой цели запроса,прокси ДОЛЖЕН игнорировать полученное поле заголовка Host (если есть) и вместо этого заменить его информацией о хосте цели запроса. Прокси-сервер, который пересылает такой запрос, ДОЛЖЕН сгенерировать новое значение поля Host на основе полученной цели запроса, а не пересылать полученное значение поля Host. Поскольку поле заголовка Host действует как механизм маршрутизации на уровне приложения, оно часто становится целью вредоносных программ, стремящихся отравить общий кеш или перенаправить запрос на непредусмотренный сервер. Прокси-сервер перехвата особенно уязвим, если он полагается на значение поля Host для перенаправления запросов на внутренние серверы или для использования в качестве ключа кеша в общем кэше без предварительной проверки того, что перехваченное соединение нацелено на действительный IP-адрес этого хоста. ,Сервер ДОЛЖЕН отвечать кодом состояния 400 (неверный запрос) на любое сообщение запроса HTTP / 1.1, в котором отсутствует поле заголовка узла, и на любое сообщение запроса, которое содержит более одного поля заголовка узла или поле заголовка узла с недопустимым значением поля. ,</target>
        </trans-unit>
        <trans-unit id="bf76981296c1a614d1d61fab43ab95f1d60e0e35" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Authentication Scheme
   Registry&quot; defines the namespace for the authentication schemes in
   challenges and credentials.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-authschemes&quot;&gt;http://www.iana.org/assignments/http-authschemes&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;laquo;Реестр схемы аутентификации протокола передачи гипертекста (HTTP)&amp;raquo; определяет пространство имен для схем аутентификации в запросах и учетных данных. Он был создан и сейчас поддерживается по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-authschemes&quot;&gt;http://www.iana.org/assignments/http-authschemes&lt;/a&gt; &amp;gt;.</target>
        </trans-unit>
        <trans-unit id="002b5bb59e4ccc5e549506e4e0d88baf5e0fc60c" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Authentication Scheme
   Registry&quot; defines the namespace for the authentication schemes in
   challenges and credentials.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-authschemes&quot;&gt;http://www.iana.org/assignments/http-authschemes&lt;/a&gt;&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88cc8d3cf97af683587a5f4c1d90c4302b8b701f" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Cache Directive Registry&quot;
   defines the namespace for the cache directives.  It has been created
   and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-cache-directives&quot;&gt;http://www.iana.org/assignments/http-cache-directives&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;laquo;Реестр директив кэширования протокола передачи гипертекста (HTTP)&amp;raquo; определяет пространство имен для директив кеширования. Он был создан и сейчас поддерживается по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-cache-directives&quot;&gt;http://www.iana.org/assignments/http-cache-directives&lt;/a&gt; &amp;gt;.</target>
        </trans-unit>
        <trans-unit id="bc8c370c2974e750cf997b37c57dc05857094eb4" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Cache Directive Registry&quot;
   defines the namespace for the cache directives.  It has been created
   and is now maintained at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-cache-directives&quot;&gt;http://www.iana.org/assignments/http-cache-directives&lt;/a&gt;&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b60962bbc448e0c8070e4bc5da2bd79c07e165d8" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot; defines the
   namespace for the request method token (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;).  The method
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-methods&quot;&gt;http://www.iana.org/assignments/http-methods&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;laquo;Реестр метода протокола передачи гипертекста (HTTP)&amp;raquo; определяет пространство имен для токена метода запроса ( &lt;a href=&quot;#section-4&quot;&gt;раздел 4&lt;/a&gt; ). Реестр методов был создан и теперь поддерживается по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-methods&quot;&gt;http://www.iana.org/assignments/http-methods&lt;/a&gt; &amp;gt;.</target>
        </trans-unit>
        <trans-unit id="9cd3990fda532be7bd6bbc9bf3f5b65d7f9043a9" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot; defines the
   namespace for the request method token (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;).  The method
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-methods&quot;&gt;http://www.iana.org/assignments/http-methods&lt;/a&gt;&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c8fd27b56ab4d4e5338d1c107879dea630f834" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot; has been
   populated with the registrations below:

   +---------+------+------------+---------------+
   | Method  | Safe | Idempotent | Reference     |
   +---------+------+------------+---------------+
   | CONNECT | no   | no         | &lt;a href=&quot;#section-4.3.6&quot;&gt;Section 4.3.6&lt;/a&gt; |
   | DELETE  | no   | yes        | &lt;a href=&quot;#section-4.3.5&quot;&gt;Section 4.3.5&lt;/a&gt; |
   | GET     | yes  | yes        | &lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt; |
   | HEAD    | yes  | yes        | &lt;a href=&quot;#section-4.3.2&quot;&gt;Section 4.3.2&lt;/a&gt; |
   | OPTIONS | yes  | yes        | &lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt; |
   | POST    | no   | no         | &lt;a href=&quot;#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt; |
   | PUT     | no   | yes        | &lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt; |
   | TRACE   | yes  | yes        | &lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt; |
   +---------+------+------------+---------------+</source>
          <target state="translated">&amp;laquo;Реестр методов протокола передачи гипертекста (HTTP)&amp;raquo; заполнен следующими регистрационными данными: + --------- + ------ + ------------ + --------------- + | Метод | Сейф | Идемпотент | Справка | + --------- + ------ + ------------ + --------------- + | ПОДКЛЮЧИТЬ | нет | нет | &lt;a href=&quot;#section-4.3.6&quot;&gt;Раздел 4.3.6&lt;/a&gt; | | УДАЛИТЬ | нет | да | &lt;a href=&quot;#section-4.3.5&quot;&gt;Раздел 4.3.5&lt;/a&gt; | | ПОЛУЧИТЬ | да | да | &lt;a href=&quot;#section-4.3.1&quot;&gt;Раздел 4.3.1&lt;/a&gt; | | ГОЛОВА | да | да | &lt;a href=&quot;#section-4.3.2&quot;&gt;Раздел 4.3.2&lt;/a&gt; | | ОПЦИИ | да | да | &lt;a href=&quot;#section-4.3.7&quot;&gt;Раздел 4.3.7&lt;/a&gt; | | ПОЧТА | нет | нет | &lt;a href=&quot;#section-4.3.3&quot;&gt;Раздел 4.3.3&lt;/a&gt; | | PUT | нет | да | &lt;a href=&quot;#section-4.3.4&quot;&gt;Раздел 4.3.4&lt;/a&gt; | | TRACE | да | да |&lt;a href=&quot;#section-4.3.8&quot;&gt;Раздел 4.3.8&lt;/a&gt; | + --------- + ------ + ------------ + --------------- +</target>
        </trans-unit>
        <trans-unit id="af47de3832189b79659dd3c031cb9fcb9be1aa14" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; defines
   the namespace for the response status-code token (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).  The
   status code registry is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt;.

   This section replaces the registration procedure for HTTP Status
   Codes previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC2817]&lt;/a&gt;.</source>
          <target state="translated">&amp;laquo;Реестр кода состояния протокола передачи гипертекста (HTTP)&amp;raquo; определяет пространство имен для токена кода состояния ответа ( &lt;a href=&quot;#section-6&quot;&gt;раздел 6&lt;/a&gt; ). Реестр кодов состояния поддерживается по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;. Этот раздел заменяет процедуру регистрации кодов состояния HTTP, ранее определенную в &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;разделе 7.1 [RFC2817]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a45ba9e45b71e336091c29201d1b51a6f2a6fcc9" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; defines
   the namespace for the response status-code token (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).  The
   status code registry is maintained at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt;.

   This section replaces the registration procedure for HTTP Status
   Codes previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC2817]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4249a89b69736470c36f6442d2bdc76c91dde18" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated to include the registrations below:

   +-------+-----------------------+-------------+
   | Value | Description           | Reference   |
   +-------+-----------------------+-------------+
   | 206   | Partial Content       | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 416   | Range Not Satisfiable | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; |
   +-------+-----------------------+-------------+</source>
          <target state="translated">&amp;laquo;Реестр кодов состояния протокола передачи гипертекста (HTTP)&amp;raquo;, расположенный по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;, был обновлен и теперь включает следующие регистрации: + ------- + ----------------------- + ------------- + | Значение | Описание | Справка | + ------- + ----------------------- + ------------- + | 206 | Частичное содержание | &lt;a href=&quot;#section-4.1&quot;&gt;Раздел 4.1&lt;/a&gt; | | 416 | Неудовлетворительный диапазон | &lt;a href=&quot;#section-4.4&quot;&gt;Раздел 4.4&lt;/a&gt; | + ------- + ----------------------- + ------------- +</target>
        </trans-unit>
        <trans-unit id="42357d7df40e3a7ed38e6ec9bc128df372e92eb1" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+---------------------+-------------+
   | Value | Description         | Reference   |
   +-------+---------------------+-------------+
   | 304   | Not Modified        | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 412   | Precondition Failed | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   +-------+---------------------+-------------+</source>
          <target state="translated">&amp;laquo;Реестр кодов состояния протокола передачи гипертекста (HTTP)&amp;raquo;, расположенный по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;, был обновлен с учетом следующих регистраций: + ------- + --------------------- + ------------- + | Значение | Описание | Справка | + ------- + --------------------- + ------------- + | 304 | Не изменено | &lt;a href=&quot;#section-4.1&quot;&gt;Раздел 4.1&lt;/a&gt; | | 412 | Предварительное условие не выполнено | &lt;a href=&quot;#section-4.2&quot;&gt;Раздел 4.2&lt;/a&gt; | + ------- + --------------------- + ------------- +</target>
        </trans-unit>
        <trans-unit id="6373f51fbfb2756123d6ebe8d028d312dde91148" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+-------------------------------+-------------+
   | Value | Description                   | Reference   |
   +-------+-------------------------------+-------------+
   | 401   | Unauthorized                  | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   | 407   | Proxy Authentication Required | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   +-------+-------------------------------+-------------+</source>
          <target state="translated">&amp;laquo;Реестр кодов состояния протокола передачи гипертекста (HTTP)&amp;raquo;, расположенный по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;, был обновлен с учетом следующих регистраций: + ------- + ------------------------------- + ------------- + | Значение | Описание | Справка | + ------- + ------------------------------- + --------- ---- + | 401 | Несанкционированный | &lt;a href=&quot;#section-3.1&quot;&gt;Раздел 3.1&lt;/a&gt; | | 407 | Требуется проверка подлинности прокси | &lt;a href=&quot;#section-3.2&quot;&gt;Раздел 3.2&lt;/a&gt; | + ------- + ------------------------------- + --------- ---- +</target>
        </trans-unit>
        <trans-unit id="0d233463e7c00bea493b97cf8c9268be036e2061" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated to include the registrations below:

   +-------+-----------------------+-------------+
   | Value | Description           | Reference   |
   +-------+-----------------------+-------------+
   | 206   | Partial Content       | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 416   | Range Not Satisfiable | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; |
   +-------+-----------------------+-------------+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f1f814c2cf44d9372988a246bfd9ac2b6e5b07" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+---------------------+-------------+
   | Value | Description         | Reference   |
   +-------+---------------------+-------------+
   | 304   | Not Modified        | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 412   | Precondition Failed | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   +-------+---------------------+-------------+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11128a3063d582f33a0c37f1b802fe903c747b9" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+-------------------------------+-------------+
   | Value | Description                   | Reference   |
   +-------+-------------------------------+-------------+
   | 401   | Unauthorized                  | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   | 407   | Proxy Authentication Required | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   +-------+-------------------------------+-------------+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cad05fd1eebfb52b696d9b41f75945bfa2216cd" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Upgrade Token Registry&quot;
   defines the namespace for protocol-name tokens used to identify
   protocols in the Upgrade header field.  The registry is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-upgrade-tokens&quot;&gt;http://www.iana.org/assignments/http-upgrade-tokens&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;laquo;Реестр токенов обновления протокола передачи гипертекста (HTTP)&amp;raquo; определяет пространство имен для токенов имени протокола, используемых для идентификации протоколов в поле заголовка обновления. Реестр ведется по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-upgrade-tokens&quot;&gt;http://www.iana.org/assignments/http-upgrade-tokens&lt;/a&gt; &amp;gt;.</target>
        </trans-unit>
        <trans-unit id="19825e8c6c98e1d92761bcca24b5b2209be12407" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Upgrade Token Registry&quot;
   defines the namespace for protocol-name tokens used to identify
   protocols in the Upgrade header field.  The registry is maintained at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-upgrade-tokens&quot;&gt;http://www.iana.org/assignments/http-upgrade-tokens&lt;/a&gt;&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dff627671b970f06b09a819242fd5432d30d4c1d" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Warn Codes&quot; registry defines
   the namespace for warn codes.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes&quot;&gt;http://www.iana.org/assignments/http-warn-codes&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">Реестр &amp;laquo;Коды предупреждений протокола передачи гипертекста (HTTP)&amp;raquo; определяет пространство имен для кодов предупреждений. Он был создан и сейчас поддерживается по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes&quot;&gt;http://www.iana.org/assignments/http-warn-codes&lt;/a&gt; &amp;gt;.</target>
        </trans-unit>
        <trans-unit id="a01f619197e218b37486439c5f8bed7947d36e60" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Warn Codes&quot; registry defines
   the namespace for warn codes.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-warn-codes&quot;&gt;http://www.iana.org/assignments/http-warn-codes&lt;/a&gt;&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce30eef6a7cd5d843d61361a8fb74fe7770cdcce" translate="yes" xml:space="preserve">
          <source>The &quot;If-Match&quot; header field makes the request method conditional on
   the recipient origin server either having at least one current
   representation of the target resource, when the field-value is &quot;*&quot;,
   or having a current representation of the target resource that has an
   entity-tag matching a member of the list of entity-tags provided in
   the field-value.

   An origin server MUST use the strong comparison function when
   comparing entity-tags for If-Match (&lt;a href=&quot;#section-2.3.2&quot;&gt;Section 2.3.2&lt;/a&gt;), since the client
   intends this precondition to prevent the method from being applied if
   there have been any changes to the representation data.

     If-Match = &quot;*&quot; / 1#entity-tag

   Examples:

     If-Match: &quot;xyzzy&quot;
     If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
     If-Match: *

   If-Match is most often used with state-changing methods (e.g., POST,
   PUT, DELETE) to prevent accidental overwrites when multiple user
   agents might be acting in parallel on the same resource (i.e., to 

   prevent the &quot;lost update&quot; problem).  It can also be used with safe
   methods to abort a request if the selected representation does not
   match one already stored (or partially stored) from a prior request.

   An origin server that receives an If-Match header field MUST evaluate
   the condition prior to performing the method (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  If the
   field-value is &quot;*&quot;, the condition is false if the origin server does
   not have a current representation for the target resource.  If the
   field-value is a list of entity-tags, the condition is false if none
   of the listed tags match the entity-tag of the selected
   representation.

   An origin server MUST NOT perform the requested method if a received
   If-Match condition evaluates to false; instead, the origin server
   MUST respond with either a) the 412 (Precondition Failed) status code
   or b) one of the 2xx (Successful) status codes if the origin server
   has verified that a state change is being requested and the final
   state is already reflected in the current state of the target
   resource (i.e., the change requested by the user agent has already
   succeeded, but the user agent might not be aware of it, perhaps
   because the prior response was lost or a compatible change was made
   by some other user agent).  In the latter case, the origin server
   MUST NOT send a validator header field in the response unless it can
   verify that the request is a duplicate of an immediately prior change
   made by the same user agent.

   The If-Match header field can be ignored by caches and intermediaries
   because it is not applicable to a stored response.</source>
          <target state="translated">Поле заголовка &amp;laquo;If-Match&amp;raquo; ставит метод запроса в зависимость от исходного сервера получателя, имеющего хотя бы одно текущее представление целевого ресурса, когда значение поля равно &amp;laquo;*&amp;raquo;, или имеющего текущее представление целевого ресурса, который имеет тег объекта, соответствующий члену списка тегов объекта, предоставленного в значении поля. Исходный сервер ДОЛЖЕН использовать функцию строгого сравнения при сравнении тегов объектов для If-Match ( &lt;a href=&quot;#section-2.3.2&quot;&gt;раздел 2.3.2.&lt;/a&gt;), поскольку клиент намеревается сделать это предварительное условие, чтобы предотвратить применение метода, если были какие-либо изменения в данных представления. If-Match = &quot;*&quot; / 1 # Примеры тегов объекта: If-Match: &quot;xyzzy&quot; If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot; If-Match: * If-Match чаще всего используется с методы изменения состояния (например, POST, PUT, DELETE) для предотвращения случайной перезаписи, когда несколько пользовательских агентов могут работать параллельно с одним и тем же ресурсом (то есть, чтобы предотвратить проблему &amp;laquo;потерянного обновления&amp;raquo;). Его также можно использовать с безопасными методами для прерывания запроса, если выбранное представление не совпадает с уже сохраненным (или частично сохраненным) из предыдущего запроса.Исходный сервер, который получает поле заголовка If-Match, ДОЛЖЕН оценить условие до выполнения метода (&lt;a href=&quot;#section-5&quot;&gt;Раздел 5&lt;/a&gt;). Если значение поля равно &amp;laquo;*&amp;raquo;, условие ложно, если исходный сервер не имеет текущего представления для целевого ресурса. Если значение поля является списком тегов сущностей, условие ложно, если ни один из перечисленных тегов не соответствует тегу объекта выбранного представления. Исходный сервер НЕ ДОЛЖЕН выполнять запрошенный метод, если полученное условие If-Match оценивается как ложное; вместо этого исходный сервер ДОЛЖЕН ответить либо a) кодом состояния 412 (Precondition Failed), либо b) одним из кодов состояния 2xx (Successful), если исходный сервер подтвердил, что запрашивается изменение состояния, и конечное состояние уже отражается в текущем состоянии целевого ресурса (т. е. изменение, запрошенное пользовательским агентом, уже выполнено успешно,но пользовательский агент может не знать об этом, возможно, потому, что предыдущий ответ был потерян или совместимое изменение было внесено каким-либо другим пользовательским агентом). В последнем случае исходный сервер НЕ ДОЛЖЕН отправлять поле заголовка валидатора в ответ, если он не может подтвердить, что запрос является дубликатом непосредственно предшествующего изменения, сделанного тем же пользовательским агентом. Поле заголовка If-Match может игнорироваться кешами и посредниками, поскольку оно не применимо к сохраненному ответу.Поле заголовка If-Match может игнорироваться кешами и посредниками, поскольку оно не применимо к сохраненному ответу.Поле заголовка If-Match может игнорироваться кешами и посредниками, поскольку оно не применимо к сохраненному ответу.</target>
        </trans-unit>
        <trans-unit id="6a8bdb230b0368d774ef7c392fdbc661a6f47bdb" translate="yes" xml:space="preserve">
          <source>The &quot;If-Modified-Since&quot; header field makes a GET or HEAD request
   method conditional on the selected representation's modification date
   being more recent than the date provided in the field-value.
   Transfer of the selected representation's data is avoided if that
   data has not changed.

     If-Modified-Since = HTTP-date

   An example of the field is:

     If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A recipient MUST ignore If-Modified-Since if the request contains an
   If-None-Match header field; the condition in If-None-Match is
   considered to be a more accurate replacement for the condition in
   If-Modified-Since, and the two are only combined for the sake of
   interoperating with older intermediaries that might not implement
   If-None-Match.

   A recipient MUST ignore the If-Modified-Since header field if the
   received field-value is not a valid HTTP-date, or if the request
   method is neither GET nor HEAD.

   A recipient MUST interpret an If-Modified-Since field-value's
   timestamp in terms of the origin server's clock.

   If-Modified-Since is typically used for two distinct purposes: 1) to
   allow efficient updates of a cached representation that does not have
   an entity-tag and 2) to limit the scope of a web traversal to
   resources that have recently changed.

   When used for cache updates, a cache will typically use the value of
   the cached message's Last-Modified field to generate the field value
   of If-Modified-Since.  This behavior is most interoperable for cases
   where clocks are poorly synchronized or when the server has chosen to
   only honor exact timestamp matches (due to a problem with
   Last-Modified dates that appear to go &quot;back in time&quot; when the origin
   server's clock is corrected or a representation is restored from an
   archived backup).  However, caches occasionally generate the field
   value based on other data, such as the Date header field of the
   cached message or the local clock time that the message was received,
   particularly when the cached message does not contain a Last-Modified
   field. 

   When used for limiting the scope of retrieval to a recent time
   window, a user agent will generate an If-Modified-Since field value
   based on either its own local clock or a Date header field received
   from the server in a prior response.  Origin servers that choose an
   exact timestamp match based on the selected representation's
   Last-Modified field will not be able to help the user agent limit its
   data transfers to only those changed during the specified window.

   An origin server that receives an If-Modified-Since header field
   SHOULD evaluate the condition prior to performing the method
   (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  The origin server SHOULD NOT perform the requested
   method if the selected representation's last modification date is
   earlier than or equal to the date provided in the field-value;
   instead, the origin server SHOULD generate a 304 (Not Modified)
   response, including only those metadata that are useful for
   identifying or updating a previously cached response.

   Requirements on cache handling of a received If-Modified-Since header
   field are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">Поле заголовка &amp;laquo;If-Modified-Since&amp;raquo; делает метод запроса GET или HEAD условным, если дата изменения выбранного представления более поздняя, ​​чем дата, указанная в значении поля. Перенос данных выбранного представления предотвращается, если эти данные не изменились. If-Modified-Since = HTTP-date Пример поля: If-Modified-Since: Сб, 29 октября 1994 г., 19:43:31 GMT Получатель ДОЛЖЕН игнорировать If-Modified-Since, если запрос содержит If-None -Поле заголовка совпадения; условие в If-None-Match считается более точной заменой условия в If-Modified-Since, и они объединяются только для взаимодействия со старыми посредниками, которые могут не реализовывать If-None-Match.Получатель ДОЛЖЕН игнорировать поле заголовка If-Modified-Since, если полученное значение поля не является допустимой датой HTTP или если метод запроса не является ни GET, ни HEAD. Получатель ДОЛЖЕН интерпретировать метку времени значения поля If-Modified-Since в терминах часов исходного сервера. If-Modified-Since обычно используется для двух разных целей: 1) для обеспечения эффективных обновлений кэшированного представления, не имеющего тега объекта, и 2) для ограничения объема веб-обхода ресурсами, которые недавно изменились. При использовании для обновлений кеша, кеш обычно использует значение поля Last-Modified кэшированного сообщения для генерации значения поля If-Modified-Since.Это поведение наиболее совместимо в случаях, когда часы плохо синхронизированы или когда сервер решил соблюдать только точные совпадения меток времени (из-за проблемы с датами Last-Modified, которые кажутся возвращающимися &quot;назад во времени&quot;, когда часы исходного сервера исправлены. или представление восстанавливается из архивной резервной копии). Однако кеши иногда генерируют значение поля на основе других данных, таких как поле заголовка Date кэшированного сообщения или локальные часы, когда сообщение было получено, особенно когда кэшированное сообщение не содержит поля Last-Modified. Когда используется для ограничения области поиска недавним временным окном,пользовательский агент сгенерирует значение поля If-Modified-Since либо на основе своих локальных часов, либо на основе поля заголовка Date, полученного от сервера в предыдущем ответе. Серверы происхождения, которые выбирают точное совпадение меток времени на основе поля Last-Modified выбранного представления, не смогут помочь пользовательскому агенту ограничить передачу данных только теми, которые были изменены в течение указанного окна. Исходному серверу, который получает поле заголовка If-Modified-Since, СЛЕДУЕТ оценить условие до выполнения метода (Исходному серверу, который получает поле заголовка If-Modified-Since, СЛЕДУЕТ оценить условие до выполнения метода (Исходному серверу, который получает поле заголовка If-Modified-Since, СЛЕДУЕТ оценить условие до выполнения метода (&lt;a href=&quot;#section-5&quot;&gt;Раздел 5&lt;/a&gt; ). Исходному серверу НЕ СЛЕДУЕТ выполнять запрошенный метод, если дата последнего изменения выбранного представления раньше или равна дате, указанной в значении поля; вместо этого исходный сервер ДОЛЖЕН генерировать ответ 304 (Not Modified), включая только те метаданные, которые полезны для идентификации или обновления ранее кэшированного ответа. Требования к обработке кэша полученного поля заголовка If-Modified-Since определены в &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;разделе 4.3.2 [RFC7234]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a0c758120c2ca9721b5496606fe6d4cf8c40d68" translate="yes" xml:space="preserve">
          <source>The &quot;If-None-Match&quot; header field makes the request method conditional
   on a recipient cache or origin server either not having any current
   representation of the target resource, when the field-value is &quot;*&quot;,
   or having a selected representation with an entity-tag that does not
   match any of those listed in the field-value.

   A recipient MUST use the weak comparison function when comparing
   entity-tags for If-None-Match (&lt;a href=&quot;#section-2.3.2&quot;&gt;Section 2.3.2&lt;/a&gt;), since weak entity-tags
   can be used for cache validation even if there have been changes to
   the representation data.

     If-None-Match = &quot;*&quot; / 1#entity-tag 

   Examples:

     If-None-Match: &quot;xyzzy&quot;
     If-None-Match: W/&quot;xyzzy&quot;
     If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
     If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
     If-None-Match: *

   If-None-Match is primarily used in conditional GET requests to enable
   efficient updates of cached information with a minimum amount of
   transaction overhead.  When a client desires to update one or more
   stored responses that have entity-tags, the client SHOULD generate an
   If-None-Match header field containing a list of those entity-tags
   when making a GET request; this allows recipient servers to send a
   304 (Not Modified) response to indicate when one of those stored
   responses matches the selected representation.

   If-None-Match can also be used with a value of &quot;*&quot; to prevent an
   unsafe request method (e.g., PUT) from inadvertently modifying an
   existing representation of the target resource when the client
   believes that the resource does not have a current representation
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7231]&lt;/a&gt;).  This is a variation on the &quot;lost
   update&quot; problem that might arise if more than one client attempts to
   create an initial representation for the target resource.

   An origin server that receives an If-None-Match header field MUST
   evaluate the condition prior to performing the method (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).
   If the field-value is &quot;*&quot;, the condition is false if the origin
   server has a current representation for the target resource.  If the
   field-value is a list of entity-tags, the condition is false if one
   of the listed tags match the entity-tag of the selected
   representation.

   An origin server MUST NOT perform the requested method if the
   condition evaluates to false; instead, the origin server MUST respond
   with either a) the 304 (Not Modified) status code if the request
   method is GET or HEAD or b) the 412 (Precondition Failed) status code
   for all other request methods.

   Requirements on cache handling of a received If-None-Match header
   field are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">Поле заголовка &amp;laquo;If-None-Match&amp;raquo; ставит метод запроса в зависимость от кэша получателя или исходного сервера, который либо не имеет текущего представления целевого ресурса, когда значение поля равно &amp;laquo;*&amp;raquo;, либо имеет выбранное представление с тег объекта, который не соответствует ни одному из перечисленных в значении поля. Получатель ДОЛЖЕН использовать функцию слабого сравнения при сравнении тегов объекта для If-None-Match ( &lt;a href=&quot;#section-2.3.2&quot;&gt;раздел 2.3.2.&lt;/a&gt;), поскольку слабые теги сущностей могут использоваться для проверки кеша, даже если в данные представления были внесены изменения. If-None-Match = &quot;*&quot; / 1 # Примеры тегов объекта: If-None-Match: &quot;xyzzy&quot; If-None-Match: W / &quot;xyzzy&quot; If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot; , &quot;c3piozzzz&quot; If-None-Match: W / &quot;xyzzy&quot;, W / &quot;r2d2xxxx&quot;, W / &quot;c3piozzzz&quot; If-None-Match: * If-None-Match в основном используется в условных запросах GET для включения эффективных обновлений кэшированной информации с минимальным объемом транзакционных накладных расходов. Когда клиент желает обновить один или несколько сохраненных ответов, которые имеют теги объекта, ему СЛЕДУЕТ сгенерировать поле заголовка If-None-Match, содержащее список этих тегов объекта, при выполнении запроса GET;это позволяет серверам-получателям отправлять ответ 304 (Not Modified), чтобы указать, когда один из этих сохраненных ответов соответствует выбранному представлению. If-None-Match также может использоваться со значением &quot;*&quot;, чтобы предотвратить непреднамеренное изменение небезопасным методом запроса (например, PUT) существующего представления целевого ресурса, когда клиент считает, что ресурс не имеет текущего представления. (PUT) от непреднамеренного изменения существующего представления целевого ресурса, когда клиент считает, что ресурс не имеет текущего представления (PUT) от непреднамеренного изменения существующего представления целевого ресурса, когда клиент считает, что ресурс не имеет текущего представления (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;Раздел 4.2.1 [RFC7231]&lt;/a&gt; ). Это вариант проблемы &amp;laquo;потерянного обновления&amp;raquo;, которая может возникнуть, если несколько клиентов попытаются создать начальное представление для целевого ресурса. Исходный сервер, который получает поле заголовка If-None-Match, ДОЛЖЕН оценить условие перед выполнением метода ( &lt;a href=&quot;#section-5&quot;&gt;Раздел 5&lt;/a&gt;). Если значение поля &amp;laquo;*&amp;raquo;, условие ложно, если исходный сервер имеет текущее представление для целевого ресурса. Если значение поля представляет собой список тегов сущностей, условие ложно, если один из перечисленных тегов соответствует тегу объекта выбранного представления. Исходный сервер НЕ ДОЛЖЕН выполнять запрошенный метод, если условие оценивается как ложное; вместо этого исходный сервер ДОЛЖЕН ответить либо а) кодом состояния 304 (не изменен), если метод запроса - GET или HEAD, или б) кодом состояния 412 (отказ предварительного условия) для всех других методов запроса. Требования к обработке кэша полученного поля заголовка If-None-Match определены в &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;разделе 4.3.2 [RFC7234]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9010727bf44de6e918d999396395dcc003b1b98" translate="yes" xml:space="preserve">
          <source>The &quot;If-Range&quot; header field provides a special conditional request
   mechanism that is similar to the If-Match and If-Unmodified-Since
   header fields but that instructs the recipient to ignore the Range
   header field if the validator doesn't match, resulting in transfer of
   the new selected representation instead of a 412 (Precondition
   Failed) response.  If-Range is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt;.</source>
          <target state="translated">Поле заголовка &amp;laquo;If-Range&amp;raquo; предоставляет специальный механизм условного запроса, который похож на поля заголовка If-Match и If-Unmodified-Since, но инструктирует получателя игнорировать поле заголовка Range, если валидатор не соответствует, в результате при передаче нового выбранного представления вместо ответа 412 (Precondition Failed). If-Range определен в &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;разделе 3.2 [RFC7233]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8425f95c9971ed97dd968bffd651d8482f2d923d" translate="yes" xml:space="preserve">
          <source>The &quot;If-Unmodified-Since&quot; header field makes the request method
   conditional on the selected representation's last modification date
   being earlier than or equal to the date provided in the field-value.
   This field accomplishes the same purpose as If-Match for cases where
   the user agent does not have an entity-tag for the representation.

     If-Unmodified-Since = HTTP-date

   An example of the field is:

     If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A recipient MUST ignore If-Unmodified-Since if the request contains
   an If-Match header field; the condition in If-Match is considered to
   be a more accurate replacement for the condition in
   If-Unmodified-Since, and the two are only combined for the sake of
   interoperating with older intermediaries that might not implement
   If-Match.

   A recipient MUST ignore the If-Unmodified-Since header field if the
   received field-value is not a valid HTTP-date.

   A recipient MUST interpret an If-Unmodified-Since field-value's
   timestamp in terms of the origin server's clock. 

   If-Unmodified-Since is most often used with state-changing methods
   (e.g., POST, PUT, DELETE) to prevent accidental overwrites when
   multiple user agents might be acting in parallel on a resource that
   does not supply entity-tags with its representations (i.e., to
   prevent the &quot;lost update&quot; problem).  It can also be used with safe
   methods to abort a request if the selected representation does not
   match one already stored (or partially stored) from a prior request.

   An origin server that receives an If-Unmodified-Since header field
   MUST evaluate the condition prior to performing the method
   (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  The origin server MUST NOT perform the requested method
   if the selected representation's last modification date is more
   recent than the date provided in the field-value; instead the origin
   server MUST respond with either a) the 412 (Precondition Failed)
   status code or b) one of the 2xx (Successful) status codes if the
   origin server has verified that a state change is being requested and
   the final state is already reflected in the current state of the
   target resource (i.e., the change requested by the user agent has
   already succeeded, but the user agent might not be aware of that
   because the prior response message was lost or a compatible change
   was made by some other user agent).  In the latter case, the origin
   server MUST NOT send a validator header field in the response unless
   it can verify that the request is a duplicate of an immediately prior
   change made by the same user agent.

   The If-Unmodified-Since header field can be ignored by caches and
   intermediaries because it is not applicable to a stored response.</source>
          <target state="translated">Поле заголовка &amp;laquo;If-Unmodified-Since&amp;raquo; делает метод запроса условным, если дата последнего изменения выбранного представления раньше или равна дате, указанной в значении поля. Это поле выполняет ту же цель, что и If-Match, для случаев, когда пользовательский агент не имеет тега объекта для представления. If-Unmodified-Since = HTTP-date Пример поля: If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT Получатель ДОЛЖЕН игнорировать If-Unmodified-Since, если запрос содержит If-Match поле заголовка; условие в If-Match считается более точной заменой условия в If-Unmodified-Since, и оба они объединены только для взаимодействия со старыми посредниками, которые могут не реализовывать If-Match.Получатель ДОЛЖЕН игнорировать поле заголовка If-Unmodified-Since, если полученное значение поля не является допустимой датой HTTP. Получатель ДОЛЖЕН интерпретировать метку времени значения поля If-Unmodified-Since в терминах часов исходного сервера. If-Unmodified-Since наиболее часто используется с методами изменения состояния (например, POST, PUT, DELETE) для предотвращения случайной перезаписи, когда несколько пользовательских агентов могут действовать параллельно с ресурсом, который не предоставляет теги объекта с его представлениями ( то есть, чтобы предотвратить проблему &quot;потерянного обновления&quot;). Его также можно использовать с безопасными методами для прерывания запроса, если выбранное представление не совпадает с уже сохраненным (или частично сохраненным) из предыдущего запроса.Исходный сервер, который получает поле заголовка If-Unmodified-Since, ДОЛЖЕН оценить условие до выполнения метода (&lt;a href=&quot;#section-5&quot;&gt;Раздел 5&lt;/a&gt;). Исходный сервер НЕ ДОЛЖЕН выполнять запрошенный метод, если дата последнего изменения выбранного представления более поздняя, ​​чем дата, указанная в значении поля; вместо этого исходный сервер ДОЛЖЕН ответить либо a) кодом состояния 412 (Precondition Failed), либо b) одним из кодов состояния 2xx (Successful), если исходный сервер подтвердил, что запрашивается изменение состояния, и конечное состояние уже отражено в текущем состоянии целевого ресурса (т. е. изменение, запрошенное пользовательским агентом, уже выполнено успешно, но пользовательский агент может не знать об этом, потому что предыдущее ответное сообщение было потеряно или совместимое изменение было внесено каким-либо другим пользовательским агентом ). В последнем случае,исходный сервер НЕ ДОЛЖЕН отправлять поле заголовка валидатора в ответ, если он не может подтвердить, что запрос является копией непосредственно предшествующего изменения, сделанного тем же пользовательским агентом. Поле заголовка If-Unmodified-Since может игнорироваться кешами и посредниками, поскольку оно не применимо к сохраненному ответу.</target>
        </trans-unit>
        <trans-unit id="3bcbe36b4b07ea53d8dfd522bedc5b18d8069ffd" translate="yes" xml:space="preserve">
          <source>The &quot;Last-Modified&quot; header field in a response provides a timestamp
   indicating the date and time at which the origin server believes the
   selected representation was last modified, as determined at the
   conclusion of handling the request.

     Last-Modified = HTTP-date

   An example of its use is

     Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT</source>
          <target state="translated">Поле заголовка &quot;Last-Modified&quot; в ответе предоставляет временную метку,указывающую дату и время,когда сервер отправителя считает,что выбранное представление было в последний раз изменено,как это было определено при завершении обработки запроса.Last-Modified=HTTP-date Примером его использования является Last-Modified:Тю,15 ноября 1994 12:45:26 по Гринвичу.</target>
        </trans-unit>
        <trans-unit id="a6eb1d27a3336049ef780463edbd186c94593ceb" translate="yes" xml:space="preserve">
          <source>The &quot;Location&quot; header field is used in some responses to refer to a
   specific resource in relation to the response.  The type of
   relationship is defined by the combination of request method and
   status code semantics.

     Location = URI-reference

   The field value consists of a single URI-reference.  When it has the
   form of a relative reference (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], Section&amp;nbsp;4.2&lt;/a&gt;), the final
   value is computed by resolving it against the effective request URI
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;[RFC3986], Section&amp;nbsp;5&lt;/a&gt;).

   For 201 (Created) responses, the Location value refers to the primary
   resource created by the request.  For 3xx (Redirection) responses,
   the Location value refers to the preferred target resource for
   automatically redirecting the request.

   If the Location value provided in a 3xx (Redirection) response does
   not have a fragment component, a user agent MUST process the
   redirection as if the value inherits the fragment component of the
   URI reference used to generate the request target (i.e., the
   redirection inherits the original reference's fragment, if any).

   For example, a GET request generated for the URI reference
   &quot;http://www.example.org/~tim&quot; might result in a 303 (See Other)
   response containing the header field:

     Location: /People.html#tim

   which suggests that the user agent redirect to
   &quot;http://www.example.org/People.html#tim&quot; 

   Likewise, a GET request generated for the URI reference
   &quot;http://www.example.org/index.html#larry&quot; might result in a 301
   (Moved Permanently) response containing the header field:

     Location: http://www.example.net/index.html

   which suggests that the user agent redirect to
   &quot;http://www.example.net/index.html#larry&quot;, preserving the original
   fragment identifier.

   There are circumstances in which a fragment identifier in a Location
   value would not be appropriate.  For example, the Location header
   field in a 201 (Created) response is supposed to provide a URI that
   is specific to the created resource.

      Note: Some recipients attempt to recover from Location fields that
      are not valid URI references.  This specification does not mandate
      or define such processing, but does allow it for the sake of
      robustness.

      Note: The Content-Location header field (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;) differs
      from Location in that the Content-Location refers to the most
      specific resource corresponding to the enclosed representation.
      It is therefore possible for a response to contain both the
      Location and Content-Location header fields.</source>
          <target state="translated">Поле заголовка &amp;laquo;Местоположение&amp;raquo; используется в некоторых ответах для ссылки на конкретный ресурс по отношению к ответу. Тип связи определяется комбинацией метода запроса и семантики кода состояния. Местоположение = URI-ссылка Значение поля состоит из единственной URI-ссылки. Когда он имеет форму относительной ссылки ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], раздел 4.2&lt;/a&gt; ), окончательное значение вычисляется путем сопоставления его с эффективным URI запроса ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;[RFC3986], раздел 5&lt;/a&gt;). Для ответов 201 (Создано) значение Location относится к основному ресурсу, созданному запросом. Для ответов 3xx (перенаправление) значение Location относится к предпочтительному целевому ресурсу для автоматического перенаправления запроса. Если значение Location, указанное в ответе 3xx (перенаправление), не имеет компонента фрагмента, пользовательский агент ДОЛЖЕН обработать перенаправление, как если бы значение наследует компонент фрагмента ссылки URI, используемой для генерации цели запроса (т. Е. Перенаправление наследует фрагмент исходной ссылки, если есть). Например, запрос GET, созданный для ссылки URI &amp;laquo;http://www.example.org/~tim&amp;raquo;, может привести к ответу 303 (см. Другое), содержащему поле заголовка: Location: / People.html # tim, который предполагает, что пользовательский агент перенаправляет на &quot;http://www.example.org/People.html#tim&quot;. Аналогично, запрос GET, созданный для ссылки URI &quot;http://www.example.org/index .html # larry &quot;может привести к ответу 301 (перемещено навсегда), содержащему поле заголовка: Location: http://www.example.net/index.html, который предполагает, что пользовательский агент перенаправляет на&quot; http: // www. example.net/index.html#larry &quot;с сохранением исходного идентификатора фрагмента. Бывают обстоятельства, при которых идентификатор фрагмента в значении Location не подходит. Например, поле заголовка Location в ответе 201 (Created) должно предоставлять URI, специфичный для созданного ресурса. Примечание:Некоторые получатели пытаются восстановить из полей Location, которые не являются допустимыми ссылками URI. Эта спецификация не требует и не определяет такую ​​обработку, но разрешает ее в целях надежности. Примечание. Поле заголовка Content-Location (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Раздел 3.1.4.2&lt;/a&gt; ) отличается от Location тем, что Content-Location относится к наиболее конкретному ресурсу, соответствующему вложенному представлению. Следовательно, ответ может содержать как поля заголовка Location, так и поля Content-Location.</target>
        </trans-unit>
        <trans-unit id="74bdc0b34c81dec67352f90c99efe73d9563e534" translate="yes" xml:space="preserve">
          <source>The &quot;Max-Forwards&quot; header field provides a mechanism with the TRACE
   (&lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt;) and OPTIONS (&lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt;) request methods to limit
   the number of times that the request is forwarded by proxies.  This
   can be useful when the client is attempting to trace a request that
   appears to be failing or looping mid-chain.

     Max-Forwards = 1*DIGIT

   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message can be forwarded.

   Each intermediary that receives a TRACE or OPTIONS request containing
   a Max-Forwards header field MUST check and update its value prior to
   forwarding the request.  If the received value is zero (0), the
   intermediary MUST NOT forward the request; instead, the intermediary
   MUST respond as the final recipient.  If the received Max-Forwards
   value is greater than zero, the intermediary MUST generate an updated
   Max-Forwards field in the forwarded message with a field-value that
   is the lesser of a) the received value decremented by one (1) or b)
   the recipient's maximum supported value for Max-Forwards.

   A recipient MAY ignore a Max-Forwards header field received with any
   other request methods.</source>
          <target state="translated">Поле заголовка &quot;Max-Forwards&quot; обеспечивает механизм с TRACE ( &lt;a href=&quot;#section-4.3.8&quot;&gt;раздел 4.3.8&lt;/a&gt; ) и OPTIONS ( &lt;a href=&quot;#section-4.3.7&quot;&gt;раздел 4.3.7).&lt;/a&gt;) методы запроса, чтобы ограничить количество раз, когда запрос пересылается прокси. Это может быть полезно, когда клиент пытается отследить запрос, который, по-видимому, не работает или зацикливается в середине цепочки. Max-Forwards = 1 * DIGIT Значение Max-Forwards представляет собой десятичное целое число, указывающее оставшееся количество раз, когда это сообщение запроса может быть переадресовано. Каждый посредник, который получает запрос TRACE или OPTIONS, содержащий поле заголовка Max-Forwards, ДОЛЖЕН проверить и обновить его значение перед пересылкой запроса. Если полученное значение равно нулю (0), посредник НЕ ДОЛЖЕН пересылать запрос; вместо этого посредник ДОЛЖЕН отвечать как конечный получатель. Если полученное значение Max-Forwards больше нуля,посредник ДОЛЖЕН сгенерировать обновленное поле Max-Forwards в пересылаемом сообщении со значением поля, которое является меньшим из a) полученного значения, уменьшенного на единицу (1) или b) максимального поддерживаемого значения получателя для Max-Forwards. Получатель МОЖЕТ игнорировать поле заголовка Max-Forwards, полученное с помощью любых других методов запроса.</target>
        </trans-unit>
        <trans-unit id="62a3d127d32e2961eab7613512f025a99727d041" translate="yes" xml:space="preserve">
          <source>The &quot;Message Headers&quot; registry has been updated with the following
   permanent registrations:

   +-------------------+----------+----------+-----------------+
   | Header Field Name | Protocol | Status   | Reference       |
   +-------------------+----------+----------+-----------------+
   | Accept            | http     | standard | &lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt;   |
   | Accept-Charset    | http     | standard | &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;   |
   | Accept-Encoding   | http     | standard | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt;   |
   | Accept-Language   | http     | standard | &lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt;   |
   | Allow             | http     | standard | &lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;   |
   | Content-Encoding  | http     | standard | &lt;a href=&quot;#section-3.1.2.2&quot;&gt;Section 3.1.2.2&lt;/a&gt; |
   | Content-Language  | http     | standard | &lt;a href=&quot;#section-3.1.3.2&quot;&gt;Section 3.1.3.2&lt;/a&gt; |
   | Content-Location  | http     | standard | &lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt; |
   | Content-Type      | http     | standard | &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt; |
   | Date              | http     | standard | &lt;a href=&quot;#section-7.1.1.2&quot;&gt;Section 7.1.1.2&lt;/a&gt; |
   | Expect            | http     | standard | &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;   |
   | From              | http     | standard | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt;   |
   | Location          | http     | standard | &lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;   |
   | Max-Forwards      | http     | standard | &lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;   |
   | MIME-Version      | http     | standard | &lt;a href=&quot;#appendix-A.1&quot;&gt;Appendix A.1&lt;/a&gt;    |
   | Referer           | http     | standard | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt;   |
   | Retry-After       | http     | standard | &lt;a href=&quot;#section-7.1.3&quot;&gt;Section 7.1.3&lt;/a&gt;   |
   | Server            | http     | standard | &lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;   |
   | User-Agent        | http     | standard | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;   |
   | Vary              | http     | standard | &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;   |
   +-------------------+----------+----------+-----------------+

   The change controller for the above registrations is: &quot;IETF
   (iesg@ietf.org) - Internet Engineering Task Force&quot;.</source>
          <target state="translated">В реестр &amp;laquo;Заголовки сообщений&amp;raquo; добавлены следующие постоянные регистрации: + ------------------- + ---------- + --- ------- + ----------------- + | Имя поля заголовка | Протокол | Статус | Справка | + ------------------- + ---------- + ---------- + ------- ---------- + | Принять | http | стандарт | &lt;a href=&quot;#section-5.3.2&quot;&gt;Раздел 5.3.2&lt;/a&gt; | | Accept-Charset | http | стандарт | &lt;a href=&quot;#section-5.3.3&quot;&gt;Раздел 5.3.3&lt;/a&gt; | | Принять-кодирование | http | стандарт | &lt;a href=&quot;#section-5.3.4&quot;&gt;Раздел 5.3.4&lt;/a&gt; | | Accept-Language | http | стандарт | &lt;a href=&quot;#section-5.3.5&quot;&gt;Раздел 5.3.5&lt;/a&gt; | | Разрешить | http | стандарт | &lt;a href=&quot;#section-7.4.1&quot;&gt;Раздел 7.4.1&lt;/a&gt; | | Content-Encoding | http | стандарт | &lt;a href=&quot;#section-3.1.2.2&quot;&gt;Раздел 3.1.2.2&lt;/a&gt;| | Content-Language | http | стандарт | &lt;a href=&quot;#section-3.1.3.2&quot;&gt;Раздел 3.1.3.2&lt;/a&gt; | | Content-Location | http | стандарт | &lt;a href=&quot;#section-3.1.4.2&quot;&gt;Раздел 3.1.4.2&lt;/a&gt; | | Content-Type | http | стандарт | &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Раздел 3.1.1.5&lt;/a&gt; | | Дата | http | стандарт | &lt;a href=&quot;#section-7.1.1.2&quot;&gt;Раздел 7.1.1.2&lt;/a&gt; | | Ожидайте | http | стандарт | &lt;a href=&quot;#section-5.1.1&quot;&gt;Раздел 5.1.1&lt;/a&gt; | | От | http | стандарт | &lt;a href=&quot;#section-5.5.1&quot;&gt;Раздел 5.5.1&lt;/a&gt; | | Расположение | http | стандарт | &lt;a href=&quot;#section-7.1.2&quot;&gt;Раздел 7.1.2&lt;/a&gt; | | Макс-Форвардс | http | стандарт | &lt;a href=&quot;#section-5.1.2&quot;&gt;Раздел 5.1.2&lt;/a&gt; | | MIME-версия | http | стандарт | &lt;a href=&quot;#appendix-A.1&quot;&gt;Приложение A.1&lt;/a&gt; | | Referer | http | стандарт | &lt;a href=&quot;#section-5.5.2&quot;&gt;Раздел 5.5.2&lt;/a&gt; | | Retry-After | http | стандарт | &lt;a href=&quot;#section-7.1.3&quot;&gt;Раздел 7.1.3&lt;/a&gt; | | Сервер | http | стандарт | &lt;a href=&quot;#section-7.4.2&quot;&gt;Раздел 7.4.2&lt;/a&gt; | | User-Agent | http | стандарт | &lt;a href=&quot;#section-5.5.3&quot;&gt;Раздел 5.5.3&lt;/a&gt; | | Вары | http | стандарт | &lt;a href=&quot;#section-7.1.4&quot;&gt;Раздел 7.1.4&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ---------- + Контроллер изменений для вышеуказанных регистраций: &amp;laquo;IETF (iesg@ietf.org) - Инженерная группа Интернета&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="17017ddede4b2983af658e0ef12536aeaa0acb5a" translate="yes" xml:space="preserve">
          <source>The &quot;Pragma&quot; header field allows backwards compatibility with
   HTTP/1.0 caches, so that clients can specify a &quot;no-cache&quot; request
   that they will understand (as Cache-Control was not defined until
   HTTP/1.1).  When the Cache-Control header field is also present and
   understood in a request, Pragma is ignored.

   In HTTP/1.0, Pragma was defined as an extensible field for
   implementation-specified directives for recipients.  This
   specification deprecates such extensions to improve interoperability.

     Pragma           = 1#pragma-directive
     pragma-directive = &quot;no-cache&quot; / extension-pragma
     extension-pragma = token [ &quot;=&quot; ( token / quoted-string ) ]

   When the Cache-Control header field is not present in a request,
   caches MUST consider the no-cache request pragma-directive as having
   the same effect as if &quot;Cache-Control: no-cache&quot; were present (see
   &lt;a href=&quot;#section-5.2.1&quot;&gt;Section 5.2.1&lt;/a&gt;).

   When sending a no-cache request, a client ought to include both the
   pragma and cache-control directives, unless Cache-Control: no-cache
   is purposefully omitted to target other Cache-Control response
   directives at HTTP/1.1 caches.  For example:

     GET / HTTP/1.1
     Host: www.example.com
     Cache-Control: max-age=30
     Pragma: no-cache

   will constrain HTTP/1.1 caches to serve a response no older than 30
   seconds, while precluding implementations that do not understand
   Cache-Control from serving a cached response.

      Note: Because the meaning of &quot;Pragma: no-cache&quot; in responses is
      not specified, it does not provide a reliable replacement for
      &quot;Cache-Control: no-cache&quot; in them.</source>
          <target state="translated">Поле заголовка &amp;laquo;Pragma&amp;raquo; обеспечивает обратную совместимость с кешами HTTP / 1.0, так что клиенты могут указать запрос &amp;laquo;без кеширования&amp;raquo;, который они будут понимать (поскольку Cache-Control не был определен до HTTP / 1.1). Если поле заголовка Cache-Control также присутствует и понимается в запросе, Pragma игнорируется. В HTTP / 1.0 Pragma была определена как расширяемое поле для директив, определяемых реализацией, для получателей. В данной спецификации такие расширения не рекомендуются для улучшения взаимодействия. Pragma = 1 # директива-директива pragma-directive = &quot;no-cache&quot; / extension-pragma extension-pragma = token [&quot;=&quot; (token / quoted-string)] Когда поле заголовка Cache-Control не присутствует в запросе ,кеши ДОЛЖНЫ рассматривать директиву pragma-директивы no-cache request как имеющую такой же эффект, как если бы &quot;Cache-Control: no-cache&quot; присутствовал (см. &lt;a href=&quot;#section-5.2.1&quot;&gt;Раздел 5.2.1&lt;/a&gt; ). При отправке запроса без кеширования клиент должен включать директивы pragma и cache-control, если только Cache-Control: no-cache специально не пропущен для нацеливания других директив ответа Cache-Control в кешах HTTP / 1.1. Например: GET / HTTP / 1.1 Host: www.example.com Cache-Control: max-age = 30 Pragma: no-cache будет ограничивать кеши HTTP / 1.1, чтобы они обслуживали ответ не старше 30 секунд, исключая реализации, которые не понимают, что Cache-Control обслуживает кешированный ответ. Примечание. Поскольку значение &amp;laquo;Pragma: no-cache&amp;raquo; в ответах не указывается, оно не обеспечивает надежную замену &amp;laquo;Cache-Control: no-cache&amp;raquo; в них.</target>
        </trans-unit>
        <trans-unit id="056fcf2a31c44d11769adceb052cd538bdba3b52" translate="yes" xml:space="preserve">
          <source>The &quot;Proxy-Authenticate&quot; header field consists of at least one
   challenge that indicates the authentication scheme(s) and parameters
   applicable to the proxy for this effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5
   of [RFC7230]&lt;/a&gt;).  A proxy MUST send at least one Proxy-Authenticate
   header field in each 407 (Proxy Authentication Required) response
   that it generates.

     Proxy-Authenticate = 1#challenge

   Unlike WWW-Authenticate, the Proxy-Authenticate header field applies
   only to the next outbound client on the response chain.  This is
   because only the client that chose a given proxy is likely to have
   the credentials necessary for authentication.  However, when multiple
   proxies are used within the same administrative domain, such as
   office and regional caching proxies within a large corporate network,
   it is common for credentials to be generated by the user agent and
   passed through the hierarchy until consumed.  Hence, in such a
   configuration, it will appear as if Proxy-Authenticate is being
   forwarded because each proxy will send the same challenge set.

   Note that the parsing considerations for WWW-Authenticate apply to
   this header field as well; see &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; for details.</source>
          <target state="translated">Поле заголовка &amp;laquo;Proxy-Authenticate&amp;raquo; состоит как минимум из одного запроса, который указывает схему (схемы) аутентификации и параметры, применимые к прокси для этого действующего URI запроса ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;раздел 5.5 [RFC7230]&lt;/a&gt;). Прокси-сервер ДОЛЖЕН отправлять по крайней мере одно поле заголовка Proxy-Authenticate в каждом генерируемом им ответе 407 (Proxy Authentication Required). Proxy-Authenticate = 1 # проблема В отличие от WWW-Authenticate, поле заголовка Proxy-Authenticate применяется только к следующему исходящему клиенту в цепочке ответов. Это потому, что только клиент, выбравший данный прокси, скорее всего, будет иметь учетные данные, необходимые для аутентификации. Однако, когда несколько прокси-серверов используются в одном административном домене, например офисные и региональные прокси-серверы кэширования в большой корпоративной сети, учетные данные обычно генерируются пользовательским агентом и передаются по иерархии до тех пор, пока не будут использованы. Следовательно, в такой конфигурацииэто будет выглядеть так, как будто Proxy-Authenticate пересылается, потому что каждый прокси будет отправлять один и тот же набор вызовов. Обратите внимание, что соображения по синтаксическому анализу для WWW-Authenticate также применимы к этому полю заголовка; видеть&lt;a href=&quot;#section-4.1&quot;&gt;&lt;/a&gt;Подробности см. В разделе 4.1 .</target>
        </trans-unit>
        <trans-unit id="4e55a01408a5bfa971888b6023693ae2d37ad3ee" translate="yes" xml:space="preserve">
          <source>The &quot;Proxy-Authorization&quot; header field allows the client to identify
   itself (or its user) to a proxy that requires authentication.  Its
   value consists of credentials containing the authentication
   information of the client for the proxy and/or realm of the resource
   being requested.

     Proxy-Authorization = credentials

   Unlike Authorization, the Proxy-Authorization header field applies
   only to the next inbound proxy that demanded authentication using the
   Proxy-Authenticate field.  When multiple proxies are used in a chain,
   the Proxy-Authorization header field is consumed by the first inbound
   proxy that was expecting to receive credentials.  A proxy MAY relay
   the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.</source>
          <target state="translated">Поле заголовка &quot;Proxy-Authorization&quot; позволяет клиенту идентифицировать себя (или своего пользователя)на прокси,который требует аутентификации.Его значение состоит из учетных данных,содержащих информацию об аутентификации клиента по прокси и/или области запрашиваемого ресурса.Proxy-Authorization=credentials Unlike Authorization,поле заголовка Proxy-Authorization применяется только к следующему входящему прокси,который требует аутентификации с помощью поля Proxy-Authenticate.Когда в цепочке используется несколько прокси,поле заголовка Proxy-Authorization используется первым входящим прокси,который ожидал получить учетные данные.Прокси MAY передает учетные данные из клиентского запроса следующему прокси,если это механизм,с помощью которого прокси совместно аутентифицируют данный запрос.</target>
        </trans-unit>
        <trans-unit id="b718f4bbb4edbfe4ac380e46d4526fcfa5c21c8b" translate="yes" xml:space="preserve">
          <source>The &quot;Range&quot; header field on a GET request modifies the method
   semantics to request transfer of only one or more subranges of the
   selected representation data, rather than the entire selected
   representation data.

     Range = byte-ranges-specifier / other-ranges-specifier
     other-ranges-specifier = other-range-unit &quot;=&quot; other-range-set
     other-range-set = 1*VCHAR

   A server MAY ignore the Range header field.  However, origin servers
   and intermediate caches ought to support byte ranges when possible,
   since Range supports efficient recovery from partially failed
   transfers and partial retrieval of large representations.  A server
   MUST ignore a Range header field received with a request method other
   than GET.

   An origin server MUST ignore a Range header field that contains a
   range unit it does not understand.  A proxy MAY discard a Range
   header field that contains a range unit it does not understand.

   A server that supports range requests MAY ignore or reject a Range
   header field that consists of more than two overlapping ranges, or a
   set of many small ranges that are not listed in ascending order,
   since both are indications of either a broken client or a deliberate
   denial-of-service attack (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).  A client SHOULD NOT request
   multiple ranges that are inherently less efficient to process and
   transfer than a single range that encompasses the same data.

   A client that is requesting multiple ranges SHOULD list those ranges
   in ascending order (the order in which they would typically be
   received in a complete representation) unless there is a specific
   need to request a later part earlier.  For example, a user agent
   processing a large representation with an internal catalog of parts
   might need to request later parts first, particularly if the
   representation consists of pages stored in reverse order and the user
   agent wishes to transfer one page at a time.

   The Range header field is evaluated after evaluating the precondition
   header fields defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;], and only if the result in absence
   of the Range header field would be a 200 (OK) response.  In other
   words, Range is ignored when a conditional GET would result in a 304
   (Not Modified) response. 

   The If-Range header field (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;) can be used as a precondition
   to applying the Range header field.

   If all of the preconditions are true, the server supports the Range
   header field for the target resource, and the specified range(s) are
   valid and satisfiable (as defined in &lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;), the server SHOULD
   send a 206 (Partial Content) response with a payload containing one
   or more partial representations that correspond to the satisfiable
   ranges requested, as defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

   If all of the preconditions are true, the server supports the Range
   header field for the target resource, and the specified range(s) are
   invalid or unsatisfiable, the server SHOULD send a 416 (Range Not
   Satisfiable) response.</source>
          <target state="translated">Поле заголовка &amp;laquo;Диапазон&amp;raquo; в запросе GET изменяет семантику метода, запрашивая передачу только одного или нескольких поддиапазонов выбранных данных представления, а не всех выбранных данных представления. Диапазон = спецификатор-диапазонов-байтов / спецификатор-других-диапазонов спецификатор-других-диапазонов = другой-диапазон-единиц &quot;=&quot; другой-набор-диапазонов другой-диапазон-набор = 1 * VCHAR Сервер МОЖЕТ игнорировать поле заголовка диапазона. Однако исходные серверы и промежуточные кэши должны поддерживать байтовые диапазоны, когда это возможно, поскольку Range поддерживает эффективное восстановление после частично неудачных передач и частичное извлечение больших представлений. Сервер ДОЛЖЕН игнорировать поле заголовка Range, полученное с помощью метода запроса, отличного от GET.Исходный сервер ДОЛЖЕН игнорировать поле заголовка диапазона, которое содержит непонятную ему единицу диапазона. Прокси-сервер МОЖЕТ отбросить поле заголовка диапазона, которое содержит непонятную ему единицу диапазона. Сервер, поддерживающий запросы диапазона, МОЖЕТ игнорировать или отклонять поле заголовка диапазона, которое состоит из более чем двух перекрывающихся диапазонов, или набор из множества небольших диапазонов, которые не перечислены в порядке возрастания, поскольку оба являются признаком неисправного клиента или преднамеренного атака отказа в обслуживании (поскольку оба являются признаком неисправного клиента или преднамеренной атаки отказа в обслуживании (поскольку оба являются признаком неисправного клиента или преднамеренной атаки отказа в обслуживании (&lt;a href=&quot;#section-6.1&quot;&gt;Раздел 6.1&lt;/a&gt; ). Клиенту НЕ СЛЕДУЕТ запрашивать несколько диапазонов, которые по своей природе менее эффективны для обработки и передачи, чем один диапазон, содержащий одни и те же данные. Клиенту, который запрашивает несколько диапазонов, СЛЕДУЕТ перечислить эти диапазоны в порядке возрастания (порядок, в котором они обычно будут получены в полном представлении), если нет особой необходимости запросить более позднюю часть раньше. Например, пользовательскому агенту, обрабатывающему большое представление с внутренним каталогом частей, может потребоваться сначала запросить более поздние части, особенно если представление состоит из страниц, хранящихся в обратном порядке, и пользовательский агент желает передавать по одной странице за раз. Поле заголовка диапазона оценивается после оценки полей заголовка предварительного условия, определенных в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;], и только если результатом отсутствия поля заголовка Range будет ответ 200 (OK). Другими словами, Range игнорируется, если условный GET приведет к ответу 304 (Not Modified). Поле заголовка If-Range ( &lt;a href=&quot;#section-3.2&quot;&gt;раздел 3.2&lt;/a&gt; ) можно использовать в качестве предварительного условия для применения поля заголовка Range. Если все предварительные условия верны, сервер поддерживает поле заголовка Range для целевого ресурса, а указанные диапазоны действительны и допустимы (как определено в &lt;a href=&quot;#section-2.1&quot;&gt;разделе 2.1&lt;/a&gt; ), серверу СЛЕДУЕТ отправить ответ 206 (частичное содержимое). с полезной нагрузкой, содержащей одно или несколько частичных представлений, которые соответствуют удовлетворительным запрошенным диапазонам, как определено в &lt;a href=&quot;#section-4&quot;&gt;разделе 4&lt;/a&gt;, Если все предварительные условия верны, сервер поддерживает поле заголовка Range для целевого ресурса, а указанные диапазоны недействительны или неудовлетворительны, серверу СЛЕДУЕТ отправить ответ 416 (Range Not Satisfiable).</target>
        </trans-unit>
        <trans-unit id="1a6f10ce133a2f9215112587238b74cbf177295e" translate="yes" xml:space="preserve">
          <source>The &quot;Referer&quot; [sic] header field allows the user agent to specify a
   URI reference for the resource from which the target URI was obtained
   (i.e., the &quot;referrer&quot;, though the field name is misspelled).  A user
   agent MUST NOT include the fragment and userinfo components of the
   URI reference [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;], if any, when generating the Referer field
   value.

     Referer = absolute-URI / partial-URI

   The Referer header field allows servers to generate back-links to
   other resources for simple analytics, logging, optimized caching,
   etc.  It also allows obsolete or mistyped links to be found for
   maintenance.  Some servers use the Referer header field as a means of
   denying links from other sites (so-called &quot;deep linking&quot;) or
   restricting cross-site request forgery (CSRF), but not all requests
   contain it.

   Example:

     Referer: http://www.example.org/hypertext/Overview.html

   If the target URI was obtained from a source that does not have its
   own URI (e.g., input from the user keyboard, or an entry within the
   user's bookmarks/favorites), the user agent MUST either exclude the
   Referer field or send it with a value of &quot;about:blank&quot;.

   The Referer field has the potential to reveal information about the
   request context or browsing history of the user, which is a privacy
   concern if the referring resource's identifier reveals personal
   information (such as an account name) or a resource that is supposed
   to be confidential (such as behind a firewall or internal to a
   secured service).  Most general-purpose user agents do not send the
   Referer header field when the referring resource is a local &quot;file&quot; or
   &quot;data&quot; URI.  A user agent MUST NOT send a Referer header field in an
   unsecured HTTP request if the referring page was received with a
   secure protocol.  See &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt; for additional security
   considerations. 

   Some intermediaries have been known to indiscriminately remove
   Referer header fields from outgoing requests.  This has the
   unfortunate side effect of interfering with protection against CSRF
   attacks, which can be far more harmful to their users.
   Intermediaries and user agent extensions that wish to limit
   information disclosure in Referer ought to restrict their changes to
   specific edits, such as replacing internal domain names with
   pseudonyms or truncating the query and/or path components.  An
   intermediary SHOULD NOT modify or delete the Referer header field
   when the field value shares the same scheme and host as the request
   target.</source>
          <target state="translated">Поле заголовка &amp;laquo;Referer&amp;raquo; [sic] позволяет пользовательскому агенту указать ссылку URI для ресурса, из которого был получен целевой URI (т. Е. &amp;laquo;Реферер&amp;raquo;, хотя имя поля написано с ошибкой). Пользовательский агент НЕ ДОЛЖЕН включать компоненты фрагмента и информации о пользователе в ссылку URI [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;], если есть, при генерации значения поля Referer. Referer = absolute-URI / partial-URI Поле заголовка Referer позволяет серверам генерировать обратные ссылки на другие ресурсы для простой аналитики, ведения журнала, оптимизированного кэширования и т. Д. Это также позволяет находить устаревшие или ошибочные ссылки для обслуживания. Некоторые серверы используют поле заголовка Referer как средство отклонения ссылок с других сайтов (так называемые &amp;laquo;глубокие ссылки&amp;raquo;) или ограничения подделки межсайтовых запросов (CSRF), но не все запросы содержат его. Пример: Referer: http://www.example.org/hypertext/Overview.html Если целевой URI был получен из источника, не имеющего собственного URI (например, ввод с клавиатуры пользователя или запись в пользовательском закладки / избранное),агент пользователя ДОЛЖЕН либо исключить поле Referer, либо отправить его со значением about: blank. Поле Referer может раскрыть информацию о контексте запроса или истории просмотров пользователя, что является проблемой конфиденциальности, если идентификатор ссылающегося ресурса раскрывает личную информацию (например, имя учетной записи) или ресурс, который предполагается конфиденциальным ( например, за брандмауэром или внутри защищенной службы). Большинство пользовательских агентов общего назначения не отправляют поле заголовка Referer, если ссылающийся ресурс является локальным URI &amp;laquo;файла&amp;raquo; или &amp;laquo;данных&amp;raquo;. Пользовательский агент НЕ ДОЛЖЕН отправлять поле заголовка Referer в незащищенном HTTP-запросе, если ссылающаяся страница была получена с помощью безопасного протокола. ВидетьПоле Referer может раскрыть информацию о контексте запроса или истории просмотров пользователя, что является проблемой конфиденциальности, если идентификатор ссылающегося ресурса раскрывает личную информацию (например, имя учетной записи) или ресурс, который предполагается конфиденциальным ( например, за брандмауэром или внутри защищенной службы). Большинство пользовательских агентов общего назначения не отправляют поле заголовка Referer, если ссылающийся ресурс является локальным URI &amp;laquo;файла&amp;raquo; или &amp;laquo;данных&amp;raquo;. Пользовательский агент НЕ ДОЛЖЕН отправлять поле заголовка Referer в незащищенном HTTP-запросе, если ссылающаяся страница была получена с помощью безопасного протокола. ВидетьПоле Referer может раскрыть информацию о контексте запроса или истории просмотров пользователя, что является проблемой конфиденциальности, если идентификатор ссылающегося ресурса раскрывает личную информацию (например, имя учетной записи) или ресурс, который предполагается конфиденциальным ( например, за брандмауэром или внутри защищенной службы). Большинство пользовательских агентов общего назначения не отправляют поле заголовка Referer, если ссылающийся ресурс является локальным URI &amp;laquo;файла&amp;raquo; или &amp;laquo;данных&amp;raquo;. Пользовательский агент НЕ ДОЛЖЕН отправлять поле заголовка Referer в незащищенном HTTP-запросе, если ссылающаяся страница была получена с помощью безопасного протокола. Видетьs идентификатор раскрывает личную информацию (например, имя учетной записи) или ресурс, который должен быть конфиденциальным (например, за брандмауэром или внутри защищенной службы). Большинство пользовательских агентов общего назначения не отправляют поле заголовка Referer, если ссылающийся ресурс является локальным URI &amp;laquo;файла&amp;raquo; или &amp;laquo;данных&amp;raquo;. Пользовательский агент НЕ ДОЛЖЕН отправлять поле заголовка Referer в незащищенном HTTP-запросе, если ссылающаяся страница была получена с помощью безопасного протокола. Видетьs идентификатор раскрывает личную информацию (например, имя учетной записи) или ресурс, который должен быть конфиденциальным (например, за брандмауэром или внутри защищенной службы). Большинство пользовательских агентов общего назначения не отправляют поле заголовка Referer, если ссылающийся ресурс является локальным URI &amp;laquo;файла&amp;raquo; или &amp;laquo;данных&amp;raquo;. Пользовательский агент НЕ ДОЛЖЕН отправлять поле заголовка Referer в незащищенном HTTP-запросе, если ссылающаяся страница была получена с помощью безопасного протокола. ВидетьПользовательский агент НЕ ДОЛЖЕН отправлять поле заголовка Referer в незащищенном HTTP-запросе, если ссылающаяся страница была получена с помощью безопасного протокола. ВидетьПользовательский агент НЕ ДОЛЖЕН отправлять поле заголовка Referer в незащищенном HTTP-запросе, если ссылающаяся страница была получена с помощью безопасного протокола. Видеть&lt;a href=&quot;#section-9.4&quot;&gt;Раздел 9.4&lt;/a&gt; для дополнительных соображений безопасности. Известно, что некоторые посредники без разбора удаляют поля заголовка Referer из исходящих запросов. У этого есть неприятный побочный эффект, заключающийся в нарушении защиты от CSRF-атак, которые могут быть гораздо более вредными для их пользователей. Посредники и расширения пользовательских агентов, которые хотят ограничить раскрытие информации в Referer, должны ограничить свои изменения конкретными изменениями, такими как замена внутренних доменных имен псевдонимами или усечение компонентов запроса и / или пути. Посреднику НЕ СЛЕДУЕТ изменять или удалять поле заголовка Referer, если значение поля использует ту же схему и хост, что и цель запроса.</target>
        </trans-unit>
        <trans-unit id="d19493afa0fd7d7d38b18500fe6b7e410894e8e6" translate="yes" xml:space="preserve">
          <source>The &quot;Server&quot; header field contains information about the software
   used by the origin server to handle the request, which is often used
   by clients to help identify the scope of reported interoperability
   problems, to work around or tailor requests to avoid particular
   server limitations, and for analytics regarding server or operating
   system use.  An origin server MAY generate a Server field in its
   responses.

     Server = product *( RWS ( product / comment ) )

   The Server field-value consists of one or more product identifiers,
   each followed by zero or more comments (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;),
   which together identify the origin server software and its
   significant subproducts.  By convention, the product identifiers are
   listed in decreasing order of their significance for identifying the
   origin server software.  Each product identifier consists of a name
   and optional version, as defined in &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;.

   Example:

     Server: CERN/3.0 libwww/2.17

   An origin server SHOULD NOT generate a Server field containing
   needlessly fine-grained detail and SHOULD limit the addition of
   subproducts by third parties.  Overly long and detailed Server field
   values increase response latency and potentially reveal internal
   implementation details that might make it (slightly) easier for
   attackers to find and exploit known security holes.</source>
          <target state="translated">Поле заголовка &amp;laquo;Сервер&amp;raquo; содержит информацию о программном обеспечении, используемом исходным сервером для обработки запроса, которая часто используется клиентами для определения объема сообщаемых проблем совместимости, обхода или адаптации запросов во избежание определенных ограничений сервера, а также для аналитики использования сервера или операционной системы. Исходный сервер МОЖЕТ генерировать поле Server в своих ответах. Server = product * (RWS (product / comment)) Значение поля Server состоит из одного или нескольких идентификаторов продукта, за каждым из которых следует ноль или несколько комментариев ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;раздел 3.2 [RFC7230]&lt;/a&gt;), которые вместе идентифицируют программное обеспечение исходного сервера и его важные субпродукты. По соглашению идентификаторы продуктов перечислены в порядке убывания их значимости для идентификации программного обеспечения исходного сервера. Каждый идентификатор продукта состоит из названия и необязательной версии, как определено в &lt;a href=&quot;#section-5.5.3&quot;&gt;Разделе 5.5.3&lt;/a&gt; . Пример: Сервер: CERN / 3.0 libwww / 2.17 Исходному серверу НЕ СЛЕДУЕТ создавать поле Сервер, содержащее ненужные мелкие детали, и СЛЕДУЕТ ограничивать добавление субпродуктов третьими сторонами. Слишком длинные и подробные значения полей Server увеличивают задержку ответа и потенциально раскрывают детали внутренней реализации, которые могут (немного) облегчить злоумышленникам поиск и использование известных дыр в безопасности.</target>
        </trans-unit>
        <trans-unit id="bf7a34c8bf8ec710d19c3accad390aa1affece68" translate="yes" xml:space="preserve">
          <source>The &quot;TE&quot; header field in a request indicates what transfer codings,
   besides chunked, the client is willing to accept in response, and
   whether or not the client is willing to accept trailer fields in a
   chunked transfer coding.

   The TE field-value consists of a comma-separated list of transfer
   coding names, each allowing for optional parameters (as described in
   &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), and/or the keyword &quot;trailers&quot;.  A client MUST NOT send
   the chunked transfer coding name in TE; chunked is always acceptable
   for HTTP/1.1 recipients.

     TE        = #t-codings
     t-codings = &quot;trailers&quot; / ( transfer-coding [ t-ranking ] )
     t-ranking = OWS &quot;;&quot; OWS &quot;q=&quot; rank
     rank      = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
                / ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )

   Three examples of TE use are below.

     TE: deflate
     TE:
     TE: trailers, deflate;q=0.5

   The presence of the keyword &quot;trailers&quot; indicates that the client is
   willing to accept trailer fields in a chunked transfer coding, as
   defined in &lt;a href=&quot;#section-4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt;, on behalf of itself and any downstream
   clients.  For requests from an intermediary, this implies that
   either: (a) all downstream clients are willing to accept trailer
   fields in the forwarded response; or, (b) the intermediary will
   attempt to buffer the response on behalf of downstream recipients.
   Note that HTTP/1.1 does not define any means to limit the size of a
   chunked response such that an intermediary can be assured of
   buffering the entire response.

   When multiple transfer codings are acceptable, the client MAY rank
   the codings by preference using a case-insensitive &quot;q&quot; parameter
   (similar to the qvalues used in content negotiation fields, Section 

   5.3.1 of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]).  The rank value is a real number in the range 0
   through 1, where 0.001 is the least preferred and 1 is the most
   preferred; a value of 0 means &quot;not acceptable&quot;.

   If the TE field-value is empty or if no TE field is present, the only
   acceptable transfer coding is chunked.  A message with no transfer
   coding is always acceptable.

   Since the TE header field only applies to the immediate connection, a
   sender of TE MUST also send a &quot;TE&quot; connection option within the
   Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) in order to prevent the TE
   field from being forwarded by intermediaries that do not support its
   semantics.</source>
          <target state="translated">Поле заголовка &amp;laquo;TE&amp;raquo; в запросе указывает, какие кодировки передачи, помимо фрагментированных, клиент готов принять в ответ, и готов ли клиент принимать поля концевых звеньев в кодировании фрагментированной передачи. Значение поля TE состоит из разделенного запятыми списка имен кодирования передачи, каждое из которых допускает необязательные параметры (как описано в &lt;a href=&quot;#section-4&quot;&gt;Разделе 4.&lt;/a&gt;) и / или ключевое слово &quot;трейлеры&quot;. Клиент НЕ ДОЛЖЕН отправлять кодовое имя фрагментированной передачи в TE; chunked всегда приемлем для получателей HTTP / 1.1. TE = # t-codings t-codings = &quot;трейлеры&quot; / (кодирование передачи [t-рейтинг]) t-rank = OWS &quot;;&quot; OWS &quot;q =&quot; rank rank = (&quot;0&quot; [&quot;.&quot; 0 * 3DIGIT]) / (&quot;1&quot; [&quot;.&quot; 0 * 3 (&quot;0&quot;)]) Ниже приведены три примера использования TE. TE: deflate TE: TE: trailers, deflate; q = 0.5 Наличие ключевого слова &quot;trailers&quot; указывает на то, что клиент готов принять поля трейлеров в кодировке передачи по частям, как определено в &lt;a href=&quot;#section-4.1.2&quot;&gt;Разделе 4.1.2.&lt;/a&gt;, от своего имени и от имени всех нижестоящих клиентов. Для запросов от посредника это означает, что либо: (a) все нижестоящие клиенты готовы принять поля концевых звеньев в перенаправленном ответе; или (b) посредник попытается буферизовать ответ от имени нижестоящих получателей. Обратите внимание, что HTTP / 1.1 не определяет никаких средств для ограничения размера фрагментированного ответа, чтобы посредник мог быть уверен в буферизации всего ответа. Когда допустимо несколько кодировок передачи, клиент МОЖЕТ ранжировать кодировки по предпочтению, используя нечувствительный к регистру параметр &amp;laquo;q&amp;raquo; (аналогично значениям q, используемым в полях согласования содержимого, раздел 5.3.1 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231]&lt;/a&gt;]). Значение ранга представляет собой действительное число в диапазоне от 0 до 1, где 0,001 является наименее предпочтительным, а 1 - наиболее предпочтительным; значение 0 означает &amp;laquo;неприемлемо&amp;raquo;. Если значение поля TE пустое или поле TE отсутствует, единственное допустимое кодирование передачи разбивается на блоки. Сообщение без кодировки передачи всегда приемлемо. Поскольку поле заголовка TE применяется только к непосредственному соединению, отправитель TE ДОЛЖЕН также отправить параметр соединения &amp;laquo;TE&amp;raquo; в поле заголовка соединения ( &lt;a href=&quot;#section-6.1&quot;&gt;раздел 6.1&lt;/a&gt; ), чтобы предотвратить пересылку поля TE посредниками, которые не поддерживают его семантика.</target>
        </trans-unit>
        <trans-unit id="642dca3b33f00cb08595b70f704b7b8a5ca96a77" translate="yes" xml:space="preserve">
          <source>The &quot;Upgrade&quot; header field is intended to provide a simple mechanism
   for transitioning from HTTP/1.1 to some other protocol on the same
   connection.  A client MAY send a list of protocols in the Upgrade
   header field of a request to invite the server to switch to one or
   more of those protocols, in order of descending preference, before
   sending the final response.  A server MAY ignore a received Upgrade
   header field if it wishes to continue using the current protocol on
   that connection.  Upgrade cannot be used to insist on a protocol
   change.

     Upgrade          = 1#protocol

     protocol         = protocol-name [&quot;/&quot; protocol-version]
     protocol-name    = token
     protocol-version = token

   A server that sends a 101 (Switching Protocols) response MUST send an
   Upgrade header field to indicate the new protocol(s) to which the
   connection is being switched; if multiple protocol layers are being
   switched, the sender MUST list the protocols in layer-ascending
   order.  A server MUST NOT switch to a protocol that was not indicated
   by the client in the corresponding request's Upgrade header field.  A 

   server MAY choose to ignore the order of preference indicated by the
   client and select the new protocol(s) based on other factors, such as
   the nature of the request or the current load on the server.

   A server that sends a 426 (Upgrade Required) response MUST send an
   Upgrade header field to indicate the acceptable protocols, in order
   of descending preference.

   A server MAY send an Upgrade header field in any other response to
   advertise that it implements support for upgrading to the listed
   protocols, in order of descending preference, when appropriate for a
   future request.

   The following is a hypothetical example sent by a client:

     GET /hello.txt HTTP/1.1
     Host: www.example.com
     Connection: upgrade
     Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11


   The capabilities and nature of the application-level communication
   after the protocol change is entirely dependent upon the new
   protocol(s) chosen.  However, immediately after sending the 101
   (Switching Protocols) response, the server is expected to continue
   responding to the original request as if it had received its
   equivalent within the new protocol (i.e., the server still has an
   outstanding request to satisfy after the protocol has been changed,
   and is expected to do so without requiring the request to be
   repeated).

   For example, if the Upgrade header field is received in a GET request
   and the server decides to switch protocols, it first responds with a
   101 (Switching Protocols) message in HTTP/1.1 and then immediately
   follows that with the new protocol's equivalent of a response to a
   GET on the target resource.  This allows a connection to be upgraded
   to protocols with the same semantics as HTTP without the latency cost
   of an additional round trip.  A server MUST NOT switch protocols
   unless the received message semantics can be honored by the new
   protocol; an OPTIONS request can be honored by any protocol. 

   The following is an example response to the above hypothetical
   request:

     HTTP/1.1 101 Switching Protocols
     Connection: upgrade
     Upgrade: HTTP/2.0

     [... data stream switches to HTTP/2.0 with an appropriate response
     (as defined by new protocol) to the &quot;GET /hello.txt&quot; request ...]

   When Upgrade is sent, the sender MUST also send a Connection header
   field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) that contains an &quot;upgrade&quot; connection option, in
   order to prevent Upgrade from being accidentally forwarded by
   intermediaries that might not implement the listed protocols.  A
   server MUST ignore an Upgrade header field that is received in an
   HTTP/1.0 request.

   A client cannot begin using an upgraded protocol on the connection
   until it has completely sent the request message (i.e., the client
   can't change the protocol it is sending in the middle of a message).
   If a server receives both an Upgrade and an Expect header field with
   the &quot;100-continue&quot; expectation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.1.1&quot;&gt;Section&amp;nbsp;5.1.1 of [RFC7231]&lt;/a&gt;), the
   server MUST send a 100 (Continue) response before sending a 101
   (Switching Protocols) response.

   The Upgrade header field only applies to switching protocols on top
   of the existing connection; it cannot be used to switch the
   underlying connection (transport) protocol, nor to switch the
   existing communication to a different connection.  For those
   purposes, it is more appropriate to use a 3xx (Redirection) response
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.4&quot;&gt;Section&amp;nbsp;6.4 of [RFC7231]&lt;/a&gt;).

   This specification only defines the protocol name &quot;HTTP&quot; for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt; and future updates to this
   specification.  Additional tokens ought to be registered with IANA
   using the registration procedure defined in &lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt;.</source>
          <target state="translated">Поле заголовка &amp;laquo;Upgrade&amp;raquo; предназначено для обеспечения простого механизма перехода с HTTP / 1.1 на другой протокол в том же соединении. Клиент МОЖЕТ отправить список протоколов в поле заголовка Upgrade запроса, чтобы предложить серверу переключиться на один или несколько из этих протоколов в порядке убывания предпочтений перед отправкой окончательного ответа. Сервер МОЖЕТ игнорировать полученное поле заголовка Upgrade, если он желает продолжить использование текущего протокола в этом соединении. Обновление нельзя использовать для настаивания на изменении протокола. Обновление = 1 # протокол протокол = имя-протокола [&quot;/&quot;версия-протокола] имя-протокола = токен версия-протокол = токен Сервер, который отправляет ответ 101 (протоколы коммутации), ДОЛЖЕН отправить поле заголовка обновления, чтобы указать новый протокол (-ы), на который переключается соединение; если переключаются несколько уровней протокола, отправитель ДОЛЖЕН перечислить протоколы в порядке возрастания уровня. Сервер НЕ ДОЛЖЕН переключаться на протокол, который не был указан клиентом в соответствующем поле заголовка запроса Upgrade. Сервер МОЖЕТ игнорировать порядок предпочтений, указанный клиентом, и выбирать новый протокол (ы) на основе других факторов, таких как характер запроса или текущая нагрузка на сервер. Сервер, который отправляет ответ 426 (требуется обновление), ДОЛЖЕН отправить поле заголовка обновления, чтобы указать допустимые протоколы,в порядке убывания предпочтений. Сервер МОЖЕТ отправить поле заголовка Upgrade в любом другом ответе, чтобы объявить, что он реализует поддержку обновления до перечисленных протоколов, в порядке убывания предпочтений, когда это необходимо для будущего запроса. Ниже приводится гипотетический пример, отправленный клиентом: GET /hello.txt HTTP / 1.1 Host: www.example.com Подключение: обновление Обновление: HTTP / 2.0, SHTTP / 1.3, IRC / 6.9, RTA / x11 Возможности и характер Связь на уровне приложений после изменения протокола полностью зависит от выбранного нового протокола (ов). Однако сразу после отправки ответа 101 (протоколы переключения) ожидается, что сервер продолжит отвечать на исходный запрос, как если бы он получил его эквивалент в новом протоколе (т. Е.сервер все еще имеет невыполненный запрос для удовлетворения после изменения протокола, и ожидается, что он сделает это, не требуя повторения запроса). Например, если поле заголовка Upgrade получено в запросе GET, и сервер решает переключить протоколы, он сначала отвечает сообщением 101 (Switching Protocols) в HTTP / 1.1, а затем сразу же следует за ним с эквивалентом ответа для нового протокола. в GET на целевом ресурсе. Это позволяет модернизировать соединение до протоколов с той же семантикой, что и HTTP, без дополнительных затрат на задержку в обоих направлениях. Сервер НЕ ДОЛЖЕН переключать протоколы, если семантика полученного сообщения не может быть учтена новым протоколом; запрос OPTIONS может выполняться любым протоколом.Ниже приведен пример ответа на вышеупомянутый гипотетический запрос: HTTP / 1.1 101 Подключение протоколов переключения: обновление Обновление: HTTP / 2.0 [... поток данных переключается на HTTP / 2.0 с соответствующим ответом (как определено новым протоколом) на Запрос &quot;GET /hello.txt&quot; ...] При отправке обновления отправитель ДОЛЖЕН также отправить поле заголовка соединения (&lt;a href=&quot;#section-6.1&quot;&gt;Раздел 6.1&lt;/a&gt; ), который содержит опцию подключения &amp;laquo;обновление&amp;raquo;, чтобы предотвратить случайную переадресацию обновления посредниками, которые могут не реализовать перечисленные протоколы. Сервер ДОЛЖЕН игнорировать поле заголовка обновления, полученное в запросе HTTP / 1.0. Клиент не может начать использовать обновленный протокол в соединении, пока он полностью не отправит сообщение запроса (т. Е. Клиент не может изменить протокол, который он отправляет в середине сообщения). Если сервер получает поля заголовка Upgrade и Expect с ожиданием &amp;laquo;100-continue&amp;raquo; ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.1.1&quot;&gt;раздел 5.1.1 [RFC7231])&lt;/a&gt;), сервер ДОЛЖЕН отправить ответ 100 (Продолжить) перед отправкой ответа 101 (Протоколы переключения). Поле заголовка Upgrade применяется только к протоколам переключения поверх существующего соединения; его нельзя использовать для переключения базового (транспортного) протокола соединения или переключения существующего соединения на другое соединение. Для этих целей более целесообразно использовать ответ 3xx (перенаправление) ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.4&quot;&gt;раздел 6.4 [RFC7231]&lt;/a&gt; ). Эта спецификация определяет только имя протокола &amp;laquo;HTTP&amp;raquo; для использования семейством протоколов передачи гипертекста, как определено правилами версии HTTP &lt;a href=&quot;#section-2.6&quot;&gt;раздела 2.6&lt;/a&gt; и будущими обновлениями этой спецификации. Дополнительные токены должны быть зарегистрированы в IANA с использованием процедуры регистрации, определенной в&lt;a href=&quot;#section-8.6&quot;&gt;Раздел 8.6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cca24e17d2817ed4fdcf6d3f466ac894c19b3c68" translate="yes" xml:space="preserve">
          <source>The &quot;User-Agent&quot; header field contains information about the user
   agent originating the request, which is often used by servers to help
   identify the scope of reported interoperability problems, to work
   around or tailor responses to avoid particular user agent
   limitations, and for analytics regarding browser or operating system
   use.  A user agent SHOULD send a User-Agent field in each request
   unless specifically configured not to do so.

     User-Agent = product *( RWS ( product / comment ) )

   The User-Agent field-value consists of one or more product
   identifiers, each followed by zero or more comments (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of
   [RFC7230]&lt;/a&gt;), which together identify the user agent software and its
   significant subproducts.  By convention, the product identifiers are
   listed in decreasing order of their significance for identifying the
   user agent software.  Each product identifier consists of a name and
   optional version.

     product         = token [&quot;/&quot; product-version]
     product-version = token

   A sender SHOULD limit generated product identifiers to what is
   necessary to identify the product; a sender MUST NOT generate
   advertising or other nonessential information within the product
   identifier.  A sender SHOULD NOT generate information in
   product-version that is not a version identifier (i.e., successive
   versions of the same product name ought to differ only in the
   product-version portion of the product identifier).

   Example:

     User-Agent: CERN-LineMode/2.15 libwww/2.17b3 

   A user agent SHOULD NOT generate a User-Agent field containing
   needlessly fine-grained detail and SHOULD limit the addition of
   subproducts by third parties.  Overly long and detailed User-Agent
   field values increase request latency and the risk of a user being
   identified against their wishes (&quot;fingerprinting&quot;).

   Likewise, implementations are encouraged not to use the product
   tokens of other implementations in order to declare compatibility
   with them, as this circumvents the purpose of the field.  If a user
   agent masquerades as a different user agent, recipients can assume
   that the user intentionally desires to see responses tailored for
   that identified user agent, even if they might not work as well for
   the actual user agent being used.</source>
          <target state="translated">Поле заголовка &amp;laquo;User-Agent&amp;raquo; содержит информацию о пользовательском агенте, отправляющем запрос, которая часто используется серверами, чтобы помочь определить объем обнаруженных проблем совместимости, обойти или адаптировать ответы, чтобы избежать определенных ограничений пользовательского агента, а также для аналитики. относительно использования браузера или операционной системы. Пользовательский агент ДОЛЖЕН отправлять поле User-Agent в каждом запросе, если специально не настроено для этого. User-Agent = product * (RWS (product / comment)) Значение поля User-Agent состоит из одного или нескольких идентификаторов продукта, за каждым из которых следует ноль или несколько комментариев ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;раздел 3.2 [RFC7230]&lt;/a&gt;), которые вместе идентифицируют программное обеспечение пользовательского агента и его важные субпродукты. По соглашению идентификаторы продуктов перечислены в порядке убывания их значимости для идентификации программного обеспечения пользовательского агента. Каждый идентификатор продукта состоит из названия и необязательной версии. product = token [&quot;/&quot; product-version] product-version = token Отправителю СЛЕДУЕТ ограничить сгенерированные идентификаторы продукта тем, что необходимо для идентификации продукта; отправитель НЕ ДОЛЖЕН генерировать рекламу или другую несущественную информацию в идентификаторе продукта. Отправителю НЕ СЛЕДУЕТ генерировать информацию в product-version, которая не является идентификатором версии (т. Е. Последовательные версии одного и того же продукта должны отличаться только частью product-version идентификатора продукта). Пример:User-Agent: CERN-LineMode / 2.15 libwww / 2.17b3 Пользовательскому агенту НЕ СЛЕДУЕТ генерировать поле User-Agent, содержащее ненужные мелкие детали, и СЛЕДУЕТ ограничивать добавление субпродуктов третьими сторонами. Слишком длинные и подробные значения полей User-Agent увеличивают задержку запроса и риск того, что пользователь будет идентифицирован против его желания (&amp;laquo;снятие отпечатков пальцев&amp;raquo;). Аналогичным образом, реализациям рекомендуется не использовать токены продуктов других реализаций, чтобы декларировать совместимость с ними, поскольку это обходит цель поля. Если пользовательский агент маскируется под другого пользовательского агента, получатели могут предположить, что пользователь намеренно желает видеть ответы, адаптированные для этого идентифицированного пользовательского агента, даже если они могут не работать так же хорошо для реального используемого пользовательского агента.CERN-LineMode / 2.15 libwww / 2.17b3 Пользовательский агент НЕ ДОЛЖЕН генерировать поле User-Agent, содержащее ненужные мелкие детали, и ДОЛЖЕН ограничивать добавление субпродуктов третьими сторонами. Слишком длинные и подробные значения полей User-Agent увеличивают задержку запроса и риск того, что пользователь будет идентифицирован против его желания (&amp;laquo;снятие отпечатков пальцев&amp;raquo;). Аналогичным образом, реализациям рекомендуется не использовать токены продуктов других реализаций, чтобы заявить о совместимости с ними, поскольку это обходит цель поля. Если пользовательский агент маскируется под другого пользовательского агента, получатели могут предположить, что пользователь намеренно желает видеть ответы, адаптированные для этого идентифицированного пользовательского агента, даже если они могут не работать так же хорошо для реального используемого пользовательского агента.CERN-LineMode / 2.15 libwww / 2.17b3 Пользовательский агент НЕ ДОЛЖЕН генерировать поле User-Agent, содержащее ненужные мелкие детали, и ДОЛЖЕН ограничивать добавление субпродуктов третьими сторонами. Слишком длинные и подробные значения полей User-Agent увеличивают задержку запроса и риск того, что пользователь будет идентифицирован против его желания (&amp;laquo;снятие отпечатков пальцев&amp;raquo;). Аналогичным образом, реализациям рекомендуется не использовать токены продуктов других реализаций, чтобы декларировать совместимость с ними, поскольку это обходит цель поля. Если пользовательский агент маскируется под другого пользовательского агента, получатели могут предположить, что пользователь намеренно желает видеть ответы, адаптированные для этого идентифицированного пользовательского агента, даже если они могут не работать так же хорошо для реального используемого пользовательского агента.17b3 Пользовательскому агенту НЕ СЛЕДУЕТ создавать поле User-Agent, содержащее ненужные мелкие детали, и СЛЕДУЕТ ограничивать добавление субпродуктов третьими сторонами. Слишком длинные и подробные значения полей User-Agent увеличивают задержку запроса и риск того, что пользователь будет идентифицирован против его желания (&amp;laquo;снятие отпечатков пальцев&amp;raquo;). Аналогичным образом, реализациям рекомендуется не использовать токены продуктов других реализаций, чтобы заявить о совместимости с ними, поскольку это обходит цель поля. Если пользовательский агент маскируется под другого пользовательского агента, получатели могут предположить, что пользователь намеренно желает видеть ответы, адаптированные для этого идентифицированного пользовательского агента, даже если они могут не работать так же хорошо для реального используемого пользовательского агента.17b3 Пользовательскому агенту НЕ СЛЕДУЕТ создавать поле User-Agent, содержащее ненужные мелкие детали, и СЛЕДУЕТ ограничивать добавление субпродуктов третьими сторонами. Слишком длинные и подробные значения полей User-Agent увеличивают задержку запроса и риск того, что пользователь будет идентифицирован против его желания (&amp;laquo;снятие отпечатков пальцев&amp;raquo;). Аналогичным образом, реализациям рекомендуется не использовать токены продуктов других реализаций, чтобы заявить о совместимости с ними, поскольку это обходит цель поля. Если пользовательский агент маскируется под другого пользовательского агента, получатели могут предположить, что пользователь намеренно желает видеть ответы, адаптированные для этого идентифицированного пользовательского агента, даже если они могут не работать так же хорошо для реального используемого пользовательского агента.</target>
        </trans-unit>
        <trans-unit id="6bcae230b73127da4f18a6ca33ad2072b01f296a" translate="yes" xml:space="preserve">
          <source>The &quot;Vary&quot; header field in a response describes what parts of a
   request message, aside from the method, Host header field, and
   request target, might influence the origin server's process for
   selecting and representing this response.  The value consists of
   either a single asterisk (&quot;*&quot;) or a list of header field names
   (case-insensitive).

     Vary = &quot;*&quot; / 1#field-name

   A Vary field value of &quot;*&quot; signals that anything about the request
   might play a role in selecting the response representation, possibly
   including elements outside the message syntax (e.g., the client's
   network address).  A recipient will not be able to determine whether
   this response is appropriate for a later request without forwarding
   the request to the origin server.  A proxy MUST NOT generate a Vary
   field with a &quot;*&quot; value.

   A Vary field value consisting of a comma-separated list of names
   indicates that the named request header fields, known as the
   selecting header fields, might have a role in selecting the
   representation.  The potential selecting header fields are not
   limited to those defined by this specification.

   For example, a response that contains

     Vary: accept-encoding, accept-language

   indicates that the origin server might have used the request's
   Accept-Encoding and Accept-Language fields (or lack thereof) as
   determining factors while choosing the content for this response.

   An origin server might send Vary with a list of fields for two
   purposes:

   1.  To inform cache recipients that they MUST NOT use this response
       to satisfy a later request unless the later request has the same
       values for the listed fields as the original request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.1&quot;&gt;Section&amp;nbsp;4.1
       of [RFC7234]&lt;/a&gt;).  In other words, Vary expands the cache key
       required to match a new request to the stored cache entry. 

   2.  To inform user agent recipients that this response is subject to
       content negotiation (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) and that a different
       representation might be sent in a subsequent request if
       additional parameters are provided in the listed header fields
       (proactive negotiation).

   An origin server SHOULD send a Vary header field when its algorithm
   for selecting a representation varies based on aspects of the request
   message other than the method and request target, unless the variance
   cannot be crossed or the origin server has been deliberately
   configured to prevent cache transparency.  For example, there is no
   need to send the Authorization field name in Vary because reuse
   across users is constrained by the field definition (&lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of
   [RFC7235]&lt;/a&gt;).  Likewise, an origin server might use Cache-Control
   directives (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;) to supplant Vary if it
   considers the variance less significant than the performance cost of
   Vary's impact on caching.</source>
          <target state="translated">Поле заголовка &amp;laquo;Vary&amp;raquo; в ответе описывает, какие части сообщения запроса, помимо метода, поля заголовка хоста и цели запроса, могут влиять на процесс исходного сервера для выбора и представления этого ответа. Значение состоит либо из одной звездочки (&amp;laquo;*&amp;raquo;), либо из списка имен полей заголовка (без учета регистра). Vary = &quot;*&quot; / 1 # field-name Значение поля Vary &quot;*&quot; сигнализирует о том, что что-либо в запросе может играть роль в выборе представления ответа, возможно, включая элементы вне синтаксиса сообщения (например, сетевой адрес клиента) , Получатель не сможет определить, подходит ли этот ответ для более позднего запроса, не перенаправив запрос на исходный сервер.Прокси-сервер НЕ ДОЛЖЕН создавать поле Vary со значением &amp;laquo;*&amp;raquo;. Значение поля Vary, состоящее из списка имен, разделенных запятыми, указывает, что именованные поля заголовка запроса, известные как поля заголовка выбора, могут иметь значение при выборе представления. Возможные поля заголовка выбора не ограничиваются теми, которые определены в этой спецификации. Например, ответ, содержащий Vary: accept-encoding, accept-language, указывает, что исходный сервер мог использовать поля запроса Accept-Encoding и Accept-Language (или их отсутствие) в качестве определяющих факторов при выборе содержимого для этого ответа. Исходный сервер может отправлять Vary со списком полей для двух целей: 1.Чтобы проинформировать получателей кеша, что они НЕ ДОЛЖНЫ использовать этот ответ для удовлетворения более позднего запроса, если только более поздний запрос не имеет тех же значений для перечисленных полей, что и исходный запрос (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.1&quot;&gt;Раздел 4.1 [RFC7234]&lt;/a&gt; ). Другими словами, Vary расширяет ключ кеша, необходимый для сопоставления нового запроса с сохраненной записью кеша. 2. Чтобы проинформировать получателей пользовательского агента, что этот ответ подлежит согласованию содержимого ( &lt;a href=&quot;#section-5.3&quot;&gt;Раздел 5.3.&lt;/a&gt;) и что другое представление может быть отправлено в последующем запросе, если в перечисленных полях заголовка указаны дополнительные параметры (упреждающее согласование). Исходный сервер ДОЛЖЕН отправить поле заголовка Vary, когда его алгоритм выбора представления зависит от аспектов сообщения запроса, отличных от метода и цели запроса, за исключением случаев, когда отклонение не может быть пересечено или исходный сервер был специально настроен для предотвращения прозрачности кеша. , Например, нет необходимости отправлять имя поля авторизации в Vary, потому что повторное использование пользователями ограничено определением поля ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;раздел 4.2 [RFC7235]&lt;/a&gt; ). Аналогично, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;исходный&lt;/a&gt; сервер может использовать директивы Cache-Control ( раздел 5.2 [RFC7234]), чтобы заменить Vary, если он считает, что отклонение менее значимо, чем затраты на производительность из-за влияния Vary на кеширование.</target>
        </trans-unit>
        <trans-unit id="316863bc1d70a96f56b104e2287a2491c7e69bb0" translate="yes" xml:space="preserve">
          <source>The &quot;Via&quot; header field indicates the presence of intermediate
   protocols and recipients between the user agent and the server (on
   requests) or between the origin server and the client (on responses),
   similar to the &quot;Received&quot; header field in email (&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.7&quot;&gt;Section&amp;nbsp;3.6.7 of
   [RFC5322]&lt;/a&gt;).  Via can be used for tracking message forwards, avoiding
   request loops, and identifying the protocol capabilities of senders
   along the request/response chain.

     Via = 1#( received-protocol RWS received-by [ RWS comment ] )

     received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
                         ; see &lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;
     received-by       = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
     pseudonym         = token

   Multiple Via field values represent each proxy or gateway that has
   forwarded the message.  Each intermediary appends its own information
   about how the message was received, such that the end result is
   ordered according to the sequence of forwarding recipients. 

   A proxy MUST send an appropriate Via header field, as described
   below, in each message that it forwards.  An HTTP-to-HTTP gateway
   MUST send an appropriate Via header field in each inbound request
   message and MAY send a Via header field in forwarded response
   messages.

   For each intermediary, the received-protocol indicates the protocol
   and protocol version used by the upstream sender of the message.
   Hence, the Via field value records the advertised protocol
   capabilities of the request/response chain such that they remain
   visible to downstream recipients; this can be useful for determining
   what backwards-incompatible features might be safe to use in
   response, or within a later request, as described in &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt;.
   For brevity, the protocol-name is omitted when the received protocol
   is HTTP.

   The received-by portion of the field value is normally the host and
   optional port number of a recipient server or client that
   subsequently forwarded the message.  However, if the real host is
   considered to be sensitive information, a sender MAY replace it with
   a pseudonym.  If a port is not provided, a recipient MAY interpret
   that as meaning it was received on the default TCP port, if any, for
   the received-protocol.

   A sender MAY generate comments in the Via header field to identify
   the software of each recipient, analogous to the User-Agent and
   Server header fields.  However, all comments in the Via field are
   optional, and a recipient MAY remove them prior to forwarding the
   message.

   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named &quot;fred&quot;, which uses HTTP/1.1 to
   forward the request to a public proxy at p.example.net, which
   completes the request by forwarding it to the origin server at
   www.example.com.  The request received by www.example.com would then
   have the following Via header field:

     Via: 1.0 fred, 1.1 p.example.net

   An intermediary used as a portal through a network firewall SHOULD
   NOT forward the names and ports of hosts within the firewall region
   unless it is explicitly enabled to do so.  If not enabled, such an
   intermediary SHOULD replace each received-by host of any host behind
   the firewall by an appropriate pseudonym for that host. 

   An intermediary MAY combine an ordered subsequence of Via header
   field entries into a single such entry if the entries have identical
   received-protocol values.  For example,

     Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

   could be collapsed to

     Via: 1.0 ricky, 1.1 mertz, 1.0 lucy

   A sender SHOULD NOT combine multiple entries unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms.  A sender MUST NOT combine entries that have
   different received-protocol values.</source>
          <target state="translated">Поле заголовка &amp;laquo;Via&amp;raquo; указывает на наличие промежуточных протоколов и получателей между пользовательским агентом и сервером (по запросам) или между исходным сервером и клиентом (по ответам), аналогично полю заголовка &amp;laquo;Получено&amp;raquo; в электронной почте ( &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.7&quot;&gt;раздел 3.6.7 из [RFC5322]&lt;/a&gt; ). Via может использоваться для отслеживания пересылки сообщений, предотвращения зацикливания запросов и определения возможностей протокола отправителей в цепочке запросов / ответов. Via = 1 # (полученный-протокол RWS получен [комментарий RWS]) полученный-протокол = [имя-протокола &quot;/&quot;] версия-протокола; см. &lt;a href=&quot;#section-6.7&quot;&gt;раздел 6.7&lt;/a&gt; полученный-кем = (uri-host [&quot;:&quot; порт]) / псевдоним псевдоним = токен. Несколько значений поля Via представляют каждый прокси или шлюз, который переадресовал сообщение. Каждый посредник добавляет свою собственную информацию о том, как было получено сообщение, так что конечный результат упорядочивается в соответствии с последовательностью пересылаемых получателей. Прокси-сервер ДОЛЖЕН отправлять соответствующее поле заголовка Via, как описано ниже, в каждом пересылаемом сообщении. Шлюз HTTP-HTTP ДОЛЖЕН отправлять соответствующее поле заголовка Via в каждом входящем сообщении запроса и МОЖЕТ отправлять поле заголовка Via в пересылаемых ответных сообщениях. Для каждого посредника полученный протокол указывает протокол и версию протокола, используемую восходящим отправителем сообщения. Следовательно,значение поля Via записывает анонсированные возможности протокола цепочки запросов / ответов, чтобы они оставались видимыми для получателей в нисходящем направлении; это может быть полезно для определения того, какие обратно несовместимые функции могут быть безопасными для использования в ответе или в более позднем запросе, как описано в&lt;a href=&quot;#section-2.6&quot;&gt;Раздел 2.6&lt;/a&gt;, Для краткости имя протокола опускается, если полученным протоколом является HTTP. Полученная часть значения поля обычно представляет собой хост и необязательный номер порта сервера-получателя или клиента, который впоследствии переадресовал сообщение. Однако, если реальный хост считается конфиденциальной информацией, отправитель МОЖЕТ заменить ее псевдонимом. Если порт не указан, получатель МОЖЕТ интерпретировать это как означающее, что он был получен на TCP-порт по умолчанию, если таковой имеется, для принятого протокола. Отправитель МОЖЕТ создавать комментарии в поле заголовка Via, чтобы идентифицировать программное обеспечение каждого получателя, аналогично полям заголовка User-Agent и Server. Однако все комментарии в поле Via являются необязательными, и получатель МОЖЕТ удалить их перед пересылкой сообщения. Например,сообщение запроса может быть отправлено от пользовательского агента HTTP / 1.0 на внутренний прокси-сервер с кодовым именем &amp;laquo;fred&amp;raquo;, который использует HTTP / 1.1 для пересылки запроса на общедоступный прокси-сервер на p.example.net, который завершает запрос путем пересылки его на исходный сервер www.example.com. Запрос, полученный www.example.com, будет иметь следующее поле заголовка Via: Via: 1.0 fred, 1.1 p.example.net Посреднику, используемому в качестве портала через сетевой брандмауэр, НЕ СЛЕДУЕТ пересылать имена и порты хостов в пределах область межсетевого экрана, если это явно не разрешено. Если этот параметр не включен, такой посредник ДОЛЖЕН заменить каждый полученный хост любого хоста за брандмауэром соответствующим псевдонимом для этого хоста.Посредник МОЖЕТ объединить упорядоченную подпоследовательность записей поля заголовка Via в одну такую ​​запись, если записи имеют идентичные значения протокола приема. Например, Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy может быть свернут до Via: 1.0 ricky, 1.1 mertz, 1.0 lucy Отправителю НЕ СЛЕДУЕТ объединять несколько записей, если они все не находятся под одним и тем же организационным контролем и хосты не имеют уже заменены псевдонимами. Отправитель НЕ ДОЛЖЕН объединять записи с разными значениями протокола приема.0 lucy Отправителю НЕ СЛЕДУЕТ объединять несколько записей, если все они не находятся под одним и тем же организационным контролем и хосты уже заменены псевдонимами. Отправитель НЕ ДОЛЖЕН объединять записи с разными значениями протокола приема.0 lucy Отправителю НЕ СЛЕДУЕТ объединять несколько записей, если все они не находятся под одним и тем же организационным контролем и хосты уже заменены псевдонимами. Отправитель НЕ ДОЛЖЕН объединять записи с разными значениями протокола приема.</target>
        </trans-unit>
        <trans-unit id="9867a861577bfb6c81de727cf7f2304bd8cb13b4" translate="yes" xml:space="preserve">
          <source>The &quot;WWW-Authenticate&quot; header field indicates the authentication
   scheme(s) and parameters applicable to the target resource.

     WWW-Authenticate = 1#challenge

   A server generating a 401 (Unauthorized) response MUST send a
   WWW-Authenticate header field containing at least one challenge.  A
   server MAY generate a WWW-Authenticate header field in other response
   messages to indicate that supplying credentials (or different
   credentials) might affect the response.

   A proxy forwarding a response MUST NOT modify any WWW-Authenticate
   fields in that response.

   User agents are advised to take special care in parsing the field
   value, as it might contain more than one challenge, and each
   challenge can contain a comma-separated list of authentication
   parameters.  Furthermore, the header field itself can occur multiple
   times.

   For instance:

     WWW-Authenticate: Newauth realm=&quot;apps&quot;, type=1,
                       title=&quot;Login to \&quot;apps\&quot;&quot;, Basic realm=&quot;simple&quot;

   This header field contains two challenges; one for the &quot;Newauth&quot;
   scheme with a realm value of &quot;apps&quot;, and two additional parameters
   &quot;type&quot; and &quot;title&quot;, and another one for the &quot;Basic&quot; scheme with a
   realm value of &quot;simple&quot;.

      Note: The challenge grammar production uses the list syntax as
      well.  Therefore, a sequence of comma, whitespace, and comma can
      be considered either as applying to the preceding challenge, or to
      be an empty entry in the list of challenges.  In practice, this
      ambiguity does not affect the semantics of the header field value
      and thus is harmless.</source>
          <target state="translated">Поле заголовка &quot;WWW-Аутентификация&quot; указывает на схему(и)аутентификации и параметры,применимые к целевому ресурсу.WWW-аутентификация=1#вызов Сервер,генерирующий ответ 401 (Неавторизованный)ДОЛЖЕН посылать поле заголовка &quot;WWW-аутентификация&quot;,содержащее,по крайней мере,один вызов.Сервер MAY генерирует поле заголовка WWW-аутентификации в других ответных сообщениях,чтобы показать,что предоставление учетных данных (или различных учетных данных)может повлиять на ответ.Прокси-сервер,пересылающий ответ,НЕ ДОЛЖЕН изменять какие-либо поля WWW-Аутентификации в этом ответе.Пользовательским агентам рекомендуется проявлять особую осторожность при разборе значения поля,так как оно может содержать более одного вызова,и каждый вызов может содержать разделенный запятыми список параметров аутентификации.Более того,само поле заголовка может встречаться несколько раз.Например:WWW-аутентификация:Newauth realm=&quot;apps&quot;,type=1,title=&quot;Login to \&quot;apps\&quot;&quot;,Basic realm=&quot;simple&quot; Это поле заголовка содержит два вызова;один для схемы &quot;Newauth&quot; со значением области &quot;apps&quot;,и два дополнительных параметра &quot;type&quot; и &quot;title&quot;,и другой для схемы &quot;Basic&quot; со значением области &quot;simple&quot;.Примечание:При изготовлении грамматики задач также используется синтаксис списка.Поэтому последовательность из запятой,пробела и запятой может рассматриваться либо как относящаяся к предыдущему запросу,либо как пустая запись в списке вызовов.На практике эта неоднозначность не влияет на семантику значения поля заголовка и,следовательно,является безобидной.</target>
        </trans-unit>
        <trans-unit id="010ba1a9ad73a34753b90adf3c72f63de66025ee" translate="yes" xml:space="preserve">
          <source>The &quot;Warning&quot; header field is used to carry additional information
   about the status or transformation of a message that might not be
   reflected in the status code.  This information is typically used to
   warn about possible incorrectness introduced by caching operations or
   transformations applied to the payload of the message. 

   Warnings can be used for other purposes, both cache-related and
   otherwise.  The use of a warning, rather than an error status code,
   distinguishes these responses from true failures.

   Warning header fields can in general be applied to any message,
   however some warn-codes are specific to caches and can only be
   applied to response messages.

     Warning       = 1#warning-value

     warning-value = warn-code SP warn-agent SP warn-text
                                           [ SP warn-date ]

     warn-code  = 3DIGIT
     warn-agent = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
                     ; the name or pseudonym of the server adding
                     ; the Warning header field, for use in debugging
                     ; a single &quot;-&quot; is recommended when agent unknown
     warn-text  = quoted-string
     warn-date  = DQUOTE HTTP-date DQUOTE

   Multiple warnings can be generated in a response (either by the
   origin server or by a cache), including multiple warnings with the
   same warn-code number that only differ in warn-text.

   A user agent that receives one or more Warning header fields SHOULD
   inform the user of as many of them as possible, in the order that
   they appear in the response.  Senders that generate multiple Warning
   header fields are encouraged to order them with this user agent
   behavior in mind.  A sender that generates new Warning header fields
   MUST append them after any existing Warning header fields.

   Warnings are assigned three digit warn-codes.  The first digit
   indicates whether the Warning is required to be deleted from a stored
   response after validation:

   o  1xx warn-codes describe the freshness or validation status of the
      response, and so they MUST be deleted by a cache after validation.
      They can only be generated by a cache when validating a cached
      entry, and MUST NOT be generated in any other situation.

   o  2xx warn-codes describe some aspect of the representation that is
      not rectified by a validation (for example, a lossy compression of
      the representation) and they MUST NOT be deleted by a cache after
      validation, unless a full response is sent, in which case they
      MUST be. 

   If a sender generates one or more 1xx warn-codes in a message to be
   sent to a recipient known to implement only HTTP/1.0, the sender MUST
   include in each corresponding warning-value a warn-date that matches
   the Date header field in the message.  For example:

     HTTP/1.1 200 OK
     Date: Sat, 25 Aug 2012 23:34:45 GMT
     Warning: 112 - &quot;network down&quot; &quot;Sat, 25 Aug 2012 23:34:45 GMT&quot;


   Warnings have accompanying warn-text that describes the error, e.g.,
   for logging.  It is advisory only, and its content does not affect
   interpretation of the warn-code.

   If a recipient that uses, evaluates, or displays Warning header
   fields receives a warn-date that is different from the Date value in
   the same message, the recipient MUST exclude the warning-value
   containing that warn-date before storing, forwarding, or using the
   message.  This allows recipients to exclude warning-values that were
   improperly retained after a cache validation.  If all of the
   warning-values are excluded, the recipient MUST exclude the Warning
   header field as well.

   The following warn-codes are defined by this specification, each with
   a recommended warn-text in English, and a description of its meaning.
   The procedure for defining additional warn codes is described in
   &lt;a href=&quot;#section-7.2.1&quot;&gt;Section 7.2.1&lt;/a&gt;.</source>
          <target state="translated">Поле заголовка &amp;laquo;Предупреждение&amp;raquo; используется для переноса дополнительной информации о состоянии или преобразовании сообщения, которая может не отражаться в коде состояния. Эта информация обычно используется для предупреждения о возможной некорректности, вызванной операциями кэширования или преобразованиями, применяемыми к полезной нагрузке сообщения. Предупреждения могут использоваться для других целей, как связанных с кешем, так и других. Использование предупреждения, а не кода состояния ошибки, отличает эти ответы от истинных сбоев. Поля заголовка предупреждения обычно могут применяться к любому сообщению, однако некоторые коды предупреждений относятся к кэшам и могут применяться только к ответным сообщениям.Предупреждение = 1 # значение-предупреждения значение-предупреждения = код-предупреждения SP-агент-предупреждения SP-текст-предупреждения [Дата-предупреждения-SP] код-предупреждения = 3DIGIT-агент-предупреждения = (uri-host [&quot;:&quot; порт]) / псевдоним ; имя или псевдоним добавляемого сервера; поле заголовка &amp;laquo;Предупреждение&amp;raquo; для использования при отладке; один знак &amp;laquo;-&amp;raquo; рекомендуется, когда агент unknown warn-text = quoted-string warn-date = DQUOTE HTTP-date DQUOTE В ответе (либо исходным сервером, либо кешем) может быть сгенерировано несколько предупреждений, включая несколько предупреждений с один и тот же номер кода предупреждения, который отличается только текстом предупреждения. Агент пользователя, который получает одно или несколько полей заголовка предупреждения, ДОЛЖЕН информировать пользователя о как можно большем количестве из них,в том порядке, в котором они появляются в ответе. Отправителям, которые генерируют несколько полей заголовка Warning, рекомендуется упорядочивать их с учетом этого поведения пользовательского агента. Отправитель, который генерирует новые поля заголовка предупреждения, ДОЛЖЕН добавить их после любых существующих полей заголовка предупреждения. Предупреждениям присваиваются трехзначные коды предупреждений. Первая цифра указывает, требуется ли удалить предупреждение из сохраненного ответа после проверки: o 1xx коды предупреждений описывают актуальность или статус проверки ответа, и поэтому они ДОЛЖНЫ быть удалены из кэша после проверки. Они могут быть сгенерированы кешем только при проверке кэшированной записи и НЕ ДОЛЖНЫ создаваться ни в какой другой ситуации.o Коды предупреждений 2xx описывают некоторые аспекты представления, которые не исправляются проверкой (например, сжатие представления с потерями), и они НЕ ДОЛЖНЫ быть удалены из кеша после проверки, если не отправлен полный ответ, в котором случае они ДОЛЖНЫ быть. Если отправитель генерирует один или несколько кодов предупреждения 1xx в сообщении для отправки получателю, о котором известно, что он реализует только HTTP / 1.0, отправитель ДОЛЖЕН включить в каждое соответствующее значение предупреждения дату предупреждения, которая соответствует полю заголовка Date в сообщение. Например: HTTP / 1.1 200 OK Дата: Сб, 25 августа 2012 г. 23:34:45 GMT Предупреждение: 112 - &amp;laquo;сеть не работает&amp;raquo; &amp;laquo;Сб, 25 августа 2012 г. 23:34:45 GMT&amp;raquo; Предупреждения сопровождаются текстом предупреждения, описывающим ошибка, например, для регистрации. Только рекомендательный,и его содержание не влияет на интерпретацию кода предупреждения. Если получатель, который использует, оценивает или отображает поля заголовка предупреждения, получает дату предупреждения, которая отличается от значения даты в том же сообщении, получатель ДОЛЖЕН исключить значение предупреждения, содержащее эту дату предупреждения перед сохранением, пересылкой или использованием сообщение. Это позволяет получателям исключать значения предупреждений, которые были неправильно сохранены после проверки кеша. Если все значения предупреждений исключены, получатель ДОЛЖЕН также исключить поле заголовка предупреждения. В данной спецификации определены следующие коды предупреждений, каждый из которых имеет рекомендуемый текст предупреждения на английском языке и описание его значения. Процедура определения дополнительных кодов предупреждений описана вЕсли получатель, который использует, оценивает или отображает поля заголовка предупреждения, получает дату предупреждения, которая отличается от значения даты в том же сообщении, получатель ДОЛЖЕН исключить значение предупреждения, содержащее эту дату предупреждения перед сохранением, пересылкой или использованием сообщение. Это позволяет получателям исключать значения предупреждений, которые были неправильно сохранены после проверки кеша. Если все значения предупреждений исключены, получатель ДОЛЖЕН также исключить поле заголовка предупреждения. В данной спецификации определены следующие коды предупреждений, каждый из которых имеет рекомендуемый текст предупреждения на английском языке и описание его значения. Процедура определения дополнительных кодов предупреждений описана вЕсли получатель, который использует, оценивает или отображает поля заголовка предупреждения, получает дату предупреждения, которая отличается от значения даты в том же сообщении, получатель ДОЛЖЕН исключить значение предупреждения, содержащее эту дату предупреждения перед сохранением, пересылкой или использованием сообщение. Это позволяет получателям исключать значения предупреждений, которые были неправильно сохранены после проверки кеша. Если все значения предупреждений исключены, получатель ДОЛЖЕН также исключить поле заголовка предупреждения. В данной спецификации определены следующие коды предупреждений, каждый из которых имеет рекомендуемый текст предупреждения на английском языке и описание его значения. Процедура определения дополнительных кодов предупреждений описана вили отображает поля заголовка предупреждения получает дату предупреждения, которая отличается от значения даты в том же сообщении, получатель ДОЛЖЕН исключить значение предупреждения, содержащее эту дату предупреждения, перед сохранением, пересылкой или использованием сообщения. Это позволяет получателям исключать значения предупреждений, которые были неправильно сохранены после проверки кеша. Если все значения предупреждений исключены, получатель ДОЛЖЕН также исключить поле заголовка предупреждения. В данной спецификации определены следующие коды предупреждений, каждый из которых имеет рекомендуемый текст предупреждения на английском языке и описание его значения. Процедура определения дополнительных кодов предупреждений описана вили отображает поля заголовка предупреждения получает дату предупреждения, которая отличается от значения даты в том же сообщении, получатель ДОЛЖЕН исключить значение предупреждения, содержащее эту дату предупреждения, перед сохранением, пересылкой или использованием сообщения. Это позволяет получателям исключать значения предупреждений, которые были неправильно сохранены после проверки кеша. Если все значения предупреждений исключены, получатель ДОЛЖЕН также исключить поле заголовка предупреждения. В данной спецификации определены следующие коды предупреждений, каждый из которых имеет рекомендуемый текст предупреждения на английском языке и описание его значения. Процедура определения дополнительных кодов предупреждений описана вЭто позволяет получателям исключать значения предупреждений, которые были неправильно сохранены после проверки кеша. Если все значения предупреждений исключены, получатель ДОЛЖЕН также исключить поле заголовка предупреждения. В данной спецификации определены следующие коды предупреждений, каждый из которых имеет рекомендуемый текст предупреждения на английском языке и описание его значения. Процедура определения дополнительных кодов предупреждений описана вЭто позволяет получателям исключать значения предупреждений, которые были неправильно сохранены после проверки кеша. Если все значения предупреждений исключены, получатель ДОЛЖЕН также исключить поле заголовка предупреждения. В данной спецификации определены следующие коды предупреждений, каждый из которых имеет рекомендуемый текст предупреждения на английском языке и описание его значения. Процедура определения дополнительных кодов предупреждений описана в &lt;a href=&quot;#section-7.2.1&quot;&gt;Раздел 7.2.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="995d6efd3e0c66344c9a13f1a4baae749a8853bd" translate="yes" xml:space="preserve">
          <source>The &quot;app:categories&quot; element provides a list of the categories that
   can be applied to the members of a Collection.  See &lt;a href=&quot;#section-7.2.1&quot;&gt;Section 7.2.1&lt;/a&gt; for
   the detailed definition of app:categories.

   The server MAY reject attempts to create or store members whose
   categories are not present in its categories list.  A Collection that
   indicates the category set is open SHOULD NOT reject otherwise
   acceptable members whose categories are not in its categories list.
   The absence of an app:categories element means that the category
   handling of the Collection is unspecified.  A &quot;fixed&quot; category list
   that contains zero categories indicates the Collection does not
   accept category data.</source>
          <target state="translated">Элемент &amp;laquo;приложение: категории&amp;raquo; предоставляет список категорий, которые могут применяться к членам Коллекции. См. &lt;a href=&quot;#section-7.2.1&quot;&gt;Раздел 7.2.1&lt;/a&gt; для подробного определения приложения: категории. Сервер МОЖЕТ отклонить попытки создать или сохранить участников, категории которых отсутствуют в его списке категорий. Коллекции, которая указывает, что набор категорий открыт, НЕ СЛЕДУЕТ отклонять в противном случае приемлемые члены, категории которых не входят в ее список категорий. Отсутствие элемента app: Categories означает, что обработка категорий в Коллекции не указана. &amp;laquo;Фиксированный&amp;raquo; список категорий, содержащий нулевые категории, означает, что Коллекция не принимает данные категории.</target>
        </trans-unit>
        <trans-unit id="2862e4bbac71e75234686e57a0b3abd15c18ac9a" translate="yes" xml:space="preserve">
          <source>The &quot;app:collection&quot; element describes a Collection.  The app:
   collection element MUST contain one atom:title element.

   The app:collection element MAY contain any number of app:accept
   elements, indicating the types of representations accepted by the
   Collection.  The order of such elements is not significant.

   The app:collection element MAY contain any number of app:categories
   elements.

   appCollection =
      element app:collection {
         appCommonAttributes,
         attribute href { atomURI  },
         ( atomTitle
           &amp;amp; appAccept*
           &amp;amp; appCategories*
           &amp;amp; extensionSansTitleElement* )
      }</source>
          <target state="translated">Элемент &amp;laquo;app: collection&amp;raquo; описывает коллекцию. Элемент app: collection ДОЛЖЕН содержать один элемент atom: title. Элемент app: collection МОЖЕТ содержать любое количество элементов app: accept, указывающих типы представлений, принимаемых Collection. Порядок таких элементов не имеет значения. Элемент app: collection МОЖЕТ содержать любое количество элементов app: category. appCollection = element app: collection {appCommonAttributes, attribute href {atomURI}, (atomTitle &amp;amp; appAccept * &amp;amp; appCategories * &amp;amp; extensionSansTitleElement *)}</target>
        </trans-unit>
        <trans-unit id="4f92b1bc26a73cb4af47cd72166377ea0b007dfa" translate="yes" xml:space="preserve">
          <source>The &quot;app:edited&quot; element is a Date construct (as defined by
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;]), whose content indicates the last time an Entry was
   edited.  If the entry has not been edited yet, the content indicates
   the time it was created.  Atom Entry elements in Collection Documents
   SHOULD contain one app:edited element, and MUST NOT contain more than
   one.

   appEdited = element app:edited ( atomDateConstruct )

   The server SHOULD change the value of this element every time an
   Entry Resource or an associated Media Resource has been edited.</source>
          <target state="translated">Элемент &amp;laquo;app: edited&amp;raquo; - это конструкция Date (как определено в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]), содержимое которой указывает, когда в последний раз редактировалась запись. Если запись еще не редактировалась, в содержимом указывается время ее создания. Элементы Atom Entry в документах коллекции ДОЛЖНЫ содержать один элемент app: edited и НЕ ДОЛЖНЫ содержать более одного. appEdited = element app: edited (atomDateConstruct) Серверу СЛЕДУЕТ изменять значение этого элемента каждый раз, когда редактируется входной ресурс или связанный медиаресурс.</target>
        </trans-unit>
        <trans-unit id="68f4c11acf63f6cde7cb7434dea073f5a30ec84b" translate="yes" xml:space="preserve">
          <source>The &quot;atom:title&quot; element is defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] and gives a human-
   readable title for the Collection.</source>
          <target state="translated">Элемент &quot;atom: title&quot; определен в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] и дает читабельный заголовок для Коллекции.</target>
        </trans-unit>
        <trans-unit id="409b2e89b2d86b6bfc0d29cd3e58e574f2822ac5" translate="yes" xml:space="preserve">
          <source>The &quot;compress&quot; coding is an adaptive Lempel-Ziv-Welch (LZW) coding
   [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;] that is commonly produced by the UNIX file compression
   program &quot;compress&quot;.  A recipient SHOULD consider &quot;x-compress&quot; to be
   equivalent to &quot;compress&quot;.</source>
          <target state="translated">Кодирование &quot;compress&quot; - это адаптивное кодирование Лемпеля-Зива-Велча (LZW) [ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ], которое обычно создается программой сжатия файлов UNIX &quot;compress&quot;. Получатель ДОЛЖЕН рассматривать &amp;laquo;x-compress&amp;raquo; как эквивалент &amp;laquo;compress&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="5450639421b7ec9a5bfb9b3a5351d2c59960ee2f" translate="yes" xml:space="preserve">
          <source>The &quot;data&quot; URL scheme</source>
          <target state="translated">Схема URL-адреса &quot;данных&quot;</target>
        </trans-unit>
        <trans-unit id="7fec5b6deed76c5c2f6df9fc9a93ea6b5f359e93" translate="yes" xml:space="preserve">
          <source>The &quot;deflate&quot; coding is a &quot;zlib&quot; data format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;] containing a
   &quot;deflate&quot; compressed data stream [&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;] that uses a combination of
   the Lempel-Ziv (LZ77) compression algorithm and Huffman coding.

      Note: Some non-conformant implementations send the &quot;deflate&quot;
      compressed data without the zlib wrapper.</source>
          <target state="translated">Кодирование &amp;laquo;deflate&amp;raquo; - это формат данных &amp;laquo;zlib&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt; ], содержащий поток сжатых данных &amp;laquo;deflate&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ], в котором используется комбинация алгоритма сжатия Lempel-Ziv (LZ77) и кодирования Хаффмана. Примечание. Некоторые несовместимые реализации отправляют сжатые данные &amp;laquo;deflate&amp;raquo; без оболочки zlib.</target>
        </trans-unit>
        <trans-unit id="18f6fc86dc33b8be8746e1979432c3044e14ee93" translate="yes" xml:space="preserve">
          <source>The &quot;gzip&quot; coding is an LZ77 coding with a 32-bit Cyclic Redundancy
   Check (CRC) that is commonly produced by the gzip file compression
   program [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;].  A recipient SHOULD consider &quot;x-gzip&quot; to be
   equivalent to &quot;gzip&quot;.</source>
          <target state="translated">Кодирование &amp;laquo;gzip&amp;raquo; - это кодирование LZ77 с 32-битным циклическим контролем избыточности (CRC), которое обычно создается программой сжатия файлов gzip [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ]. Получатель ДОЛЖЕН рассматривать &amp;laquo;x-gzip&amp;raquo; как эквивалент &amp;laquo;gzip&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3da79a4d757a4b703e27456e900e76eca528f808" translate="yes" xml:space="preserve">
          <source>The &quot;http&quot; URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening for
   TCP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc0793&quot;&gt;RFC0793&lt;/a&gt;]) connections on a given port.

     http-URI = &quot;http:&quot; &quot;//&quot; authority path-abempty [ &quot;?&quot; query ]
                [ &quot;#&quot; fragment ]

   The origin server for an &quot;http&quot; URI is identified by the authority
   component, which includes a host identifier and optional TCP port
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.2&lt;/a&gt;).  The hierarchical path component and
   optional query component serve as an identifier for a potential
   target resource within that origin server's name space.  The optional
   fragment component allows for indirect identification of a secondary
   resource, independent of the URI scheme, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;Section&amp;nbsp;3.5 of
   [RFC3986]&lt;/a&gt;.

   A sender MUST NOT generate an &quot;http&quot; URI with an empty host
   identifier.  A recipient that processes such a URI reference MUST
   reject it as invalid.

   If the host identifier is provided as an IP address, the origin
   server is the listener (if any) on the indicated TCP port at that IP
   address.  If host is a registered name, the registered name is an
   indirect identifier for use with a name resolution service, such as
   DNS, to find an address for that origin server.  If the port
   subcomponent is empty or not given, TCP port 80 (the reserved port
   for WWW services) is the default.

   Note that the presence of a URI with a given authority component does
   not imply that there is always an HTTP server listening for
   connections on that host and port.  Anyone can mint a URI.  What the
   authority component determines is who has the right to respond
   authoritatively to requests that target the identified resource.  The
   delegated nature of registered names and IP addresses creates a
   federated namespace, based on control over the indicated host and
   port, whether or not an HTTP server is present.  See &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt; for
   security considerations related to establishing authority.

   When an &quot;http&quot; URI is used within a context that calls for access to
   the indicated resource, a client MAY attempt access by resolving the
   host to an IP address, establishing a TCP connection to that address
   on the indicated port, and sending an HTTP request message
   (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) containing the URI's identifying data (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;) to the
   server.  If the server responds to that request with a non-interim 

   HTTP response message, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7231]&lt;/a&gt;, then
   that response is considered an authoritative answer to the client's
   request.

   Although HTTP is independent of the transport protocol, the &quot;http&quot;
   scheme is specific to TCP-based services because the name delegation
   process depends on TCP for establishing authority.  An HTTP service
   based on some other underlying connection protocol would presumably
   be identified using a different URI scheme, just as the &quot;https&quot;
   scheme (below) is used for resources that require an end-to-end
   secured connection.  Other protocols might also be used to provide
   access to &quot;http&quot; identified resources -- it is only the authoritative
   interface that is specific to TCP.

   The URI generic syntax for authority also includes a deprecated
   userinfo subcomponent (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.1&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.1&lt;/a&gt;) for including user
   authentication information in the URI.  Some implementations make use
   of the userinfo component for internal configuration of
   authentication information, such as within command invocation
   options, configuration files, or bookmark lists, even though such
   usage might expose a user identifier or password.  A sender MUST NOT
   generate the userinfo subcomponent (and its &quot;@&quot; delimiter) when an
   &quot;http&quot; URI reference is generated within a message as a request
   target or header field value.  Before making use of an &quot;http&quot; URI
   reference received from an untrusted source, a recipient SHOULD parse
   for userinfo and treat its presence as an error; it is likely being
   used to obscure the authority for the sake of phishing attacks.</source>
          <target state="translated">Схема URI &amp;laquo;http&amp;raquo; настоящим определена с целью извлечения идентификаторов в соответствии с их ассоциацией с иерархическим пространством имен, управляемым потенциальным &lt;a href=&quot;https://tools.ietf.org/html/rfc0793&quot;&gt;исходным&lt;/a&gt; сервером HTTP, который прослушивает соединения TCP ([ RFC0793 ]) на заданном порту. http-URI = &quot;http:&quot; &quot;//&quot; путь к авторизации-abempty [&quot;?&quot; query] [фрагмент &amp;laquo;#&amp;raquo;] Исходный сервер для URI &amp;laquo;http&amp;raquo; идентифицируется компонентом полномочий, который включает идентификатор хоста и необязательный порт TCP ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], раздел 3.2.2&lt;/a&gt;). Компонент иерархического пути и необязательный компонент запроса служат идентификатором потенциального целевого ресурса в пространстве имен исходного сервера. Необязательный компонент фрагмента позволяет косвенно идентифицировать вторичный ресурс, независимо от схемы URI, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;разделе 3.5 [RFC3986]&lt;/a&gt;, Отправитель НЕ ДОЛЖЕН генерировать URI &quot;http&quot; с пустым идентификатором хоста. Получатель, обрабатывающий такую ​​ссылку URI, ДОЛЖЕН отклонить ее как недопустимую. Если идентификатор хоста предоставляется как IP-адрес, исходный сервер является слушателем (если есть) на указанном TCP-порту на этом IP-адресе. Если host является зарегистрированным именем, зарегистрированное имя является косвенным идентификатором для использования со службой разрешения имен, такой как DNS, для поиска адреса этого исходного сервера. Если подкомпонент порта пуст или не задан, по умолчанию используется TCP-порт 80 (зарезервированный порт для служб WWW). Обратите внимание, что наличие URI с заданным компонентом полномочий не означает, что всегда существует HTTP-сервер, прослушивающий соединения на этом хосте и порту. Кто угодно может создать URI.Компонент полномочий определяет, кто имеет право авторитетно отвечать на запросы, нацеленные на указанный ресурс. Делегированный характер зарегистрированных имен и IP-адресов создает объединенное пространство имен, основанное на контроле над указанным хостом и портом, независимо от того, присутствует ли HTTP-сервер. Видеть&lt;a href=&quot;#section-9.1&quot;&gt;Раздел 9.1&lt;/a&gt; для соображений безопасности, связанных с установлением полномочий. Когда URI &quot;http&quot; используется в контексте, который требует доступа к указанному ресурсу, клиент МОЖЕТ попытаться получить доступ, преобразовав хост в IP-адрес, установив TCP-соединение с этим адресом на указанный порт и отправив HTTP сообщение запроса ( &lt;a href=&quot;#section-3&quot;&gt;раздел 3&lt;/a&gt; ), содержащее идентификационные данные URI ( &lt;a href=&quot;#section-5&quot;&gt;раздел 5&lt;/a&gt; ) для сервера. Если сервер отвечает на этот запрос сообщением HTTP-ответа, не являющимся промежуточным, как описано в &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;разделе 6 [RFC7231]&lt;/a&gt;, то этот ответ считается авторитетным ответом на запрос клиента. Хотя HTTP не зависит от транспортного протокола, схема &amp;laquo;http&amp;raquo; специфична для служб на основе TCP, поскольку процесс делегирования имени зависит от TCP для установления полномочий. Служба HTTP, основанная на каком-либо другом базовом протоколе соединения, предположительно будет идентифицирована с использованием другой схемы URI, точно так же, как схема &amp;laquo;https&amp;raquo; (ниже) используется для ресурсов, которым требуется сквозное защищенное соединение. Другие протоколы также могут использоваться для обеспечения доступа к ресурсам, идентифицированным &quot;http&quot; - для TCP характерен только авторитетный интерфейс. Общий синтаксис URI для полномочий также включает устаревший подкомпонент userinfo ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.1&quot;&gt;[RFC3986], раздел 3.2.1&lt;/a&gt;) для включения информации об аутентификации пользователя в URI. Некоторые реализации используют компонент userinfo для внутренней конфигурации информации аутентификации, например, в параметрах вызова команд, файлах конфигурации или списках закладок, даже если такое использование может раскрыть идентификатор пользователя или пароль. Отправитель НЕ ДОЛЖЕН генерировать подкомпонент userinfo (и его разделитель &amp;laquo;@&amp;raquo;), когда в сообщении создается ссылка на URI &amp;laquo;http&amp;raquo; в качестве значения поля заголовка или цели запроса. Прежде чем использовать ссылку URI &amp;laquo;http&amp;raquo;, полученную из ненадежного источника, получатель ДОЛЖЕН проанализировать информацию о пользователе и рассматривать ее присутствие как ошибку; скорее всего, он используется для сокрытия авторитета в целях фишинговых атак.</target>
        </trans-unit>
        <trans-unit id="e8a58311de89d4c408e7b65f13ca2deebb29dec3" translate="yes" xml:space="preserve">
          <source>The &quot;http&quot; scheme is used to locate network resources via the HTTP
   protocol. This section defines the scheme-specific syntax and
   semantics for http URLs.

   http_URL = &quot;http:&quot; &quot;//&quot; host [ &quot;:&quot; port ] [ abs_path [ &quot;?&quot; query ]]

   If the port is empty or not given, port 80 is assumed. The semantics
   are that the identified resource is located at the server listening
   for TCP connections on that port of that host, and the Request-URI
   for the resource is abs_path (&lt;a href=&quot;#section-5.1.2&quot;&gt;section 5.1.2&lt;/a&gt;). The use of IP addresses
   in URLs SHOULD be avoided whenever possible (see &lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC 1900&lt;/a&gt; [&lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt;]). If
   the abs_path is not present in the URL, it MUST be given as &quot;/&quot; when
   used as a Request-URI for a resource (&lt;a href=&quot;#section-5.1.2&quot;&gt;section 5.1.2&lt;/a&gt;). If a proxy
   receives a host name which is not a fully qualified domain name, it
   MAY add its domain to the host name it received. If a proxy receives
   a fully qualified domain name, the proxy MUST NOT change the host
   name.</source>
          <target state="translated">Схема &amp;laquo;http&amp;raquo; используется для поиска сетевых ресурсов по протоколу HTTP. В этом разделе определяется синтаксис и семантика конкретных схем для URL-адресов http. http_URL = &quot;http:&quot; &quot;//&quot; хост [&quot;:&quot; порт] [abs_path [&quot;?&quot; запрос]] Если порт пуст или не указан, предполагается порт 80. Семантика такова, что идентифицированный ресурс расположен на сервере, который прослушивает TCP-соединения на этом порту этого хоста, а Request-URI для ресурса - это abs_path ( &lt;a href=&quot;#section-5.1.2&quot;&gt;раздел 5.1.2&lt;/a&gt; ). По возможности СЛЕДУЕТ избегать использования IP-адресов в URL-адресах (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC 1900&lt;/a&gt; [ &lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt; ]). Если abs_path не присутствует в URL-адресе, он ДОЛЖЕН быть указан как &amp;laquo;/&amp;raquo; при использовании в качестве Request-URI для ресурса ( &lt;a href=&quot;#section-5.1.2&quot;&gt;раздел 5.1.2&lt;/a&gt;). Если прокси-сервер получает имя хоста, которое не является полностью определенным доменным именем, он МОЖЕТ добавить свой домен к полученному имени хоста. Если прокси-сервер получает полное доменное имя, он НЕ ДОЛЖЕН изменять имя хоста.</target>
        </trans-unit>
        <trans-unit id="73555a35c2933a1c75aa810e673714fa36744ea0" translate="yes" xml:space="preserve">
          <source>The &quot;https&quot; URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening to a
   given TCP port for TLS-secured connections ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]).

   All of the requirements listed above for the &quot;http&quot; scheme are also
   requirements for the &quot;https&quot; scheme, except that TCP port 443 is the
   default if the port subcomponent is empty or not given, and the user
   agent MUST ensure that its connection to the origin server is secured
   through the use of strong encryption, end-to-end, prior to sending
   the first HTTP request.

     https-URI = &quot;https:&quot; &quot;//&quot; authority path-abempty [ &quot;?&quot; query ]
                 [ &quot;#&quot; fragment ]

   Note that the &quot;https&quot; URI scheme depends on both TLS and TCP for
   establishing authority.  Resources made available via the &quot;https&quot;
   scheme have no shared identity with the &quot;http&quot; scheme even if their 

   resource identifiers indicate the same authority (the same host
   listening to the same TCP port).  They are distinct namespaces and
   are considered to be distinct origin servers.  However, an extension
   to HTTP that is defined to apply to entire host domains, such as the
   Cookie protocol [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;], can allow information set by one service
   to impact communication with other services within a matching group
   of host domains.

   The process for authoritative access to an &quot;https&quot; identified
   resource is defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;].</source>
          <target state="translated">Схема URI &amp;laquo;https&amp;raquo; настоящим определяется с целью извлечения идентификаторов в соответствии с их ассоциацией с иерархическим пространством имен, управляемым потенциальным исходным сервером HTTP, который прослушивает данный порт TCP для подключений, защищенных TLS ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]). Все требования, перечисленные выше для схемы &amp;laquo;http&amp;raquo;, также являются требованиями для схемы &amp;laquo;https&amp;raquo;, за исключением того, что TCP-порт 443 используется по умолчанию, если подкомпонент порта пуст или не задан, и пользовательский агент ДОЛЖЕН гарантировать, что его подключение к исходный сервер защищен с помощью надежного сквозного шифрования перед отправкой первого HTTP-запроса. https-URI = &quot;https:&quot; &quot;//&quot; путь доступа-abempty [&quot;?&quot; query] [фрагмент &amp;laquo;#&amp;raquo;] Обратите внимание, что схема URI &amp;laquo;https&amp;raquo; зависит от TLS и TCP для установления полномочий. Ресурсы, доступные по схеме https, не имеют общего идентификатора с http.схема, даже если их идентификаторы ресурсов указывают одинаковые полномочия (один и тот же хост слушает один и тот же TCP-порт). Это разные пространства имен и считаются отдельными серверами-источниками. Однако расширение HTTP, которое определено для применения ко всем доменам хоста, например протокол Cookie [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ], может позволить информации, установленной одной службой, влиять на связь с другими службами в соответствующей группе доменов хоста. Процесс &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;авторизованного&lt;/a&gt; доступа к ресурсу с определенным протоколом https определен в [ RFC2818 ].</target>
        </trans-unit>
        <trans-unit id="381425c701e0e7786e14ce1ebe204baefd4cf1f3" translate="yes" xml:space="preserve">
          <source>The &quot;must-revalidate&quot; response directive indicates that once it has
   become stale, a cache MUST NOT use the response to satisfy subsequent
   requests without successful validation on the origin server.

   The must-revalidate directive is necessary to support reliable
   operation for certain protocol features.  In all circumstances a
   cache MUST obey the must-revalidate directive; in particular, if a
   cache cannot reach the origin server for any reason, it MUST generate
   a 504 (Gateway Timeout) response.

   The must-revalidate directive ought to be used by servers if and only
   if failure to validate a request on the representation could result
   in incorrect operation, such as a silently unexecuted financial
   transaction.</source>
          <target state="translated">Директива ответа &quot;must-revalidate&quot; указывает,что после того,как кэш устарел,кэш НЕ ДОЛЖЕН использовать ответ для удовлетворения последующих запросов без успешной проверки на оригинальном сервере.Директива must-revalidate необходима для поддержки надежной работы некоторых функций протокола.Во всех случаях кэш ДОЛЖЕН подчиняться директиве must-revalidate;в частности,если кэш не может по какой-либо причине добраться до сервера-источника,он ДОЛЖЕН сгенерировать ответ 504 (Gateway Timeout).Директива must-revalidate должна использоваться серверами,если и только в том случае,если невыполнение запроса на представлении может привести к некорректной работе,например,к молчаливому неисполнению финансовой транзакции.</target>
        </trans-unit>
        <trans-unit id="c4b6b9fcb971dd4f353272a2f91db7cf9a5b6db0" translate="yes" xml:space="preserve">
          <source>The &quot;no-cache&quot; request directive indicates that a cache MUST NOT use
   a stored response to satisfy the request without successful
   validation on the origin server.</source>
          <target state="translated">Директива запроса &quot;no-cache&quot; указывает,что кэш НЕ ДОЛЖЕН использовать сохраненный ответ для удовлетворения запроса без успешной проверки на исходном сервере.</target>
        </trans-unit>
        <trans-unit id="6e8f6289e5ab1b4d0a53bcb9e1b83dc08f1a97ef" translate="yes" xml:space="preserve">
          <source>The &quot;no-store&quot; request directive indicates that a cache MUST NOT
   store any part of either this request or any response to it.  This
   directive applies to both private and shared caches.  &quot;MUST NOT
   store&quot; in this context means that the cache MUST NOT intentionally
   store the information in non-volatile storage, and MUST make a
   best-effort attempt to remove the information from volatile storage
   as promptly as possible after forwarding it.

   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy.  In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might
   be vulnerable to eavesdropping.

   Note that if a request containing this directive is satisfied from a
   cache, the no-store request directive does not apply to the already
   stored response.</source>
          <target state="translated">Директива запроса &quot;no-store&quot; указывает,что кэш НЕ ДОЛЖЕН хранить какую-либо часть этого запроса или ответа на него.Эта директива относится как к приватному,так и к общему кэшу.В этом контексте &quot;НЕ хранить&quot; означает,что кэш НЕ ДОЛЖЕН умышленно хранить информацию в энергонезависимом хранилище,и ДОЛЖЕН делать наилучшую попытку удалить информацию из энергонезависимого хранилища как можно быстрее после ее пересылки.Данная директива НЕ является надежным или достаточным механизмом обеспечения конфиденциальности.В частности,вредоносный или скомпрометированный кэш может не распознать эту директиву или не подчиниться ей,а сети связи могут быть уязвимы для подслушивания.Обратите внимание,что если запрос,содержащий эту директиву,удовлетворяется из кэша,то директива no-store request не применяется к уже сохраненному ответу.</target>
        </trans-unit>
        <trans-unit id="94cb482b3050dacf986c6ae2b51caac0dbd9698e" translate="yes" xml:space="preserve">
          <source>The &quot;no-store&quot; response directive indicates that a cache MUST NOT
   store any part of either the immediate request or response.  This
   directive applies to both private and shared caches.  &quot;MUST NOT
   store&quot; in this context means that the cache MUST NOT intentionally
   store the information in non-volatile storage, and MUST make a
   best-effort attempt to remove the information from volatile storage
   as promptly as possible after forwarding it.

   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy.  In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might
   be vulnerable to eavesdropping.</source>
          <target state="translated">Директива ответа &quot;no-store&quot; указывает,что кэш НЕ ДОЛЖЕН хранить какую-либо часть немедленного запроса или ответа.Эта директива относится как к приватному,так и к общему кэшу.В этом контексте &quot;НЕ хранить&quot; означает,что кэш НЕ ДОЛЖЕН умышленно хранить информацию в энергонезависимом хранилище,и ДОЛЖЕН делать наилучшую попытку удалить информацию из энергонезависимого хранилища как можно быстрее после ее пересылки.Данная директива НЕ является надежным или достаточным механизмом обеспечения конфиденциальности.В частности,вредоносный или скомпрометированный кэш может не распознать эту директиву или не подчиниться ей,а сети связи могут быть уязвимы для подслушивания.</target>
        </trans-unit>
        <trans-unit id="246740c14df98a9984cb7c90b794ca4cbab5f083" translate="yes" xml:space="preserve">
          <source>The &quot;no-transform&quot; request directive indicates that an intermediary
   (whether or not it implements a cache) MUST NOT transform the
   payload, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">Директива запроса &amp;laquo;no-transform&amp;raquo; указывает, что посредник (независимо от того, реализует он кэш или нет) НЕ ДОЛЖЕН преобразовывать полезную нагрузку, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;разделе 5.7.2 [RFC7230]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26ea1a7d280ad4fbc448761f675e1d88af0183a2" translate="yes" xml:space="preserve">
          <source>The &quot;no-transform&quot; response directive indicates that an intermediary
   (regardless of whether it implements a cache) MUST NOT transform the
   payload, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">Директива ответа &amp;laquo;no-transform&amp;raquo; указывает, что посредник (независимо от того, реализует ли он кэш) НЕ ДОЛЖЕН преобразовывать полезную нагрузку, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;разделе 5.7.2 [RFC7230]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32d0e455b09d675a4810b93c728652a215d3ce1a" translate="yes" xml:space="preserve">
          <source>The &quot;only-if-cached&quot; request directive indicates that the client only
   wishes to obtain a stored response.  If it receives this directive, a
   cache SHOULD either respond using a stored response that is
   consistent with the other constraints of the request, or respond with 

   a 504 (Gateway Timeout) status code.  If a group of caches is being
   operated as a unified system with good internal connectivity, a
   member cache MAY forward such a request within that group of caches.</source>
          <target state="translated">Директива запроса &quot;only-if-cached&quot; указывает,что клиент хочет получить только сохраненный ответ.Если он получает эту директиву,то кэш ДОЛЖЕН либо ответить,используя сохраненный ответ,который согласуется с другими ограничениями запроса,либо ответить с кодом состояния 504 (Gateway Timeout).Если группа кэшей работает как единая система с хорошим внутренним подключением,член кэша МАЙЯ пересылает такой запрос внутри этой группы кэшей.</target>
        </trans-unit>
        <trans-unit id="b71570fd0465b4f17b5b1cc37961cb5f46e70128" translate="yes" xml:space="preserve">
          <source>The &quot;proxy-revalidate&quot; response directive has the same meaning as the
   must-revalidate response directive, except that it does not apply to
   private caches.</source>
          <target state="translated">Директива ответа &quot;proxy-revalidate&quot; имеет то же значение,что и директива ответа &quot;must-revalidate&quot;,за исключением того,что она не применяется к приватным кэшам.</target>
        </trans-unit>
        <trans-unit id="f75c67cbc215fa2c33b29aa7195f38b3d21101a2" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; directive indicates that the response may be cached by any cache. This can be useful if pages with HTTP authentication, or response status codes that aren't normally cacheable, should now be cached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6876985726810eb54534e7e11d768f44365be0" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; directive indicates that the response may be cached by any cache. This can be useful, if pages with HTTP authentication or response status codes that aren't normally cacheable, should now be cached.</source>
          <target state="translated">Директива &quot;public&quot; указывает,что ответ может быть кэширован любым кэшем.Это может быть полезно,если страницы с HTTP-аутентификацией или коды статуса ответа,которые обычно не кэшируются,теперь должны быть кэшированы.</target>
        </trans-unit>
        <trans-unit id="4971052d2513145d16ddbb98b369e6dbbfe2ae90" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; response directive indicates that any cache MAY store
   the response, even if the response would normally be non-cacheable or
   cacheable only within a private cache.  (See &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; for
   additional details related to the use of public in response to a
   request containing Authorization, and &lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt; for details of how
   public affects responses that would normally not be stored, due to
   their status codes not being defined as cacheable by default; see
   &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;.)</source>
          <target state="translated">Директива ответа &amp;laquo;public&amp;raquo; указывает, что любой кэш МОЖЕТ хранить ответ, даже если ответ обычно не кэшируется или кэшируется только в частном кэше. (См. Дополнительные сведения об использовании public в ответ на запрос, содержащий авторизацию, в &lt;a href=&quot;#section-3.2&quot;&gt;разделе 3.2&lt;/a&gt; , а в &lt;a href=&quot;#section-3&quot;&gt;разделе 3 -&lt;/a&gt; о том, как public влияет на ответы, которые обычно не сохраняются, поскольку их коды состояния не определены как кэшируемые по умолчанию. ; см. &lt;a href=&quot;#section-4.2.2&quot;&gt;раздел 4.2.2&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="3a53d63d810ef97bac3b0a2d1828ead948bae860" translate="yes" xml:space="preserve">
          <source>The &quot;realm&quot; authentication parameter is reserved for use by
   authentication schemes that wish to indicate a scope of protection.

   A protection space is defined by the canonical root URI (the scheme
   and authority components of the effective request URI; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;5.5 of [RFC7230]&lt;/a&gt;) of the server being accessed, in combination with
   the realm value if present.  These realms allow the protected
   resources on a server to be partitioned into a set of protection 

   spaces, each with its own authentication scheme and/or authorization
   database.  The realm value is a string, generally assigned by the
   origin server, that can have additional semantics specific to the
   authentication scheme.  Note that a response can have multiple
   challenges with the same auth-scheme but with different realms.

   The protection space determines the domain over which credentials can
   be automatically applied.  If a prior request has been authorized,
   the user agent MAY reuse the same credentials for all other requests
   within that protection space for a period of time determined by the
   authentication scheme, parameters, and/or user preferences (such as a
   configurable inactivity timeout).  Unless specifically allowed by the
   authentication scheme, a single protection space cannot extend
   outside the scope of its server.

   For historical reasons, a sender MUST only generate the quoted-string
   syntax.  Recipients might have to support both token and
   quoted-string syntax for maximum interoperability with existing
   clients that have been accepting both notations for a long time.</source>
          <target state="translated">Параметр аутентификации &quot;область&quot; зарезервирован для использования схемами аутентификации, которые хотят указать объем защиты. Пространство защиты определяется каноническим корневым URI (схема и компоненты полномочий действующего URI запроса; см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Раздел &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;5.5 [RFC7230]&lt;/a&gt;) сервера, к которому осуществляется доступ, в сочетании со значением области, если оно есть. Эти области позволяют разделить защищенные ресурсы на сервере на набор пространств защиты, каждое со своей собственной схемой аутентификации и / или базой данных авторизации. Значение области - это строка, обычно назначаемая исходным сервером, которая может иметь дополнительную семантику, специфичную для схемы аутентификации. Обратите внимание, что в ответе может быть несколько запросов с одной и той же схемой аутентификации, но с разными областями. Пространство защиты определяет домен, в котором учетные данные могут применяться автоматически. Если предыдущий запрос был авторизован, пользовательский агент МОЖЕТ повторно использовать те же учетные данные для всех других запросов в пределах этого защитного пространства в течение периода времени, определенного схемой аутентификации, параметрами,и / или пользовательские предпочтения (например, настраиваемый тайм-аут бездействия). Если это специально не разрешено схемой аутентификации, единое пространство защиты не может выходить за пределы своего сервера. По историческим причинам отправитель ДОЛЖЕН генерировать только синтаксис строки в кавычках. Получателям, возможно, придется поддерживать синтаксис как токена, так и строки в кавычках для максимальной совместимости с существующими клиентами, которые долгое время принимали обе нотации.Получателям, возможно, придется поддерживать синтаксис как токена, так и строки в кавычках для максимальной совместимости с существующими клиентами, которые долгое время принимали обе нотации.Получателям, возможно, придется поддерживать синтаксис как токена, так и строки в кавычках для максимальной совместимости с существующими клиентами, которые долгое время принимали обе нотации.</target>
        </trans-unit>
        <trans-unit id="151e607c7a4575c8ca7477aa6824b0c9baed0674" translate="yes" xml:space="preserve">
          <source>The 'Basic' HTTP Authentication Scheme</source>
          <target state="translated">Схема 'Основной' HTTP аутентификации</target>
        </trans-unit>
        <trans-unit id="31b797417bbccba76fa104cff98e9ec776af2bfd" translate="yes" xml:space="preserve">
          <source>The 'opaquelocktoken' URI scheme was defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] (and
   registered by IANA) in order to create syntactically correct and
   easy-to-generate URIs out of UUIDs, intended to be used as lock
   tokens and to be unique across all resources for all time.

   An opaquelocktoken URI is constructed by concatenating the
   'opaquelocktoken' scheme with a UUID, along with an optional
   extension.  Servers can create new UUIDs for each new lock token.  If
   a server wishes to reuse UUIDs, the server MUST add an extension, and
   the algorithm generating the extension MUST guarantee that the same
   extension will never be used twice with the associated UUID.

     OpaqueLockToken-URI = &quot;opaquelocktoken:&quot; UUID [Extension]
       ; UUID is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC4122]&lt;/a&gt;.  Note that LWS
       ; is not allowed between elements of
       ; this production.

     Extension = path
       ; path is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC3986]&lt;/a&gt;</source>
          <target state="translated">Схема URI 'opaquelocktoken' была определена в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ] (и зарегистрирована IANA) для создания синтаксически правильных и легко генерируемых URI из UUID, предназначенных для использования в качестве токенов блокировки и уникальных для всех ресурсов для все время. URI непрозрачного токена создается путем объединения схемы &amp;laquo;непрозрачный токен&amp;raquo; с UUID вместе с дополнительным расширением. Серверы могут создавать новые UUID для каждого нового токена блокировки. Если сервер желает повторно использовать UUID, сервер ДОЛЖЕН добавить расширение, и алгоритм, генерирующий расширение, ДОЛЖЕН гарантировать, что одно и то же расширение никогда не будет использоваться дважды с соответствующим UUID. OpaqueLockToken-URI = &quot;opaquelocktoken:&quot; UUID [Расширение]; UUID определен в &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-3&quot;&gt;разделе 3 [RFC4122]&lt;/a&gt;, Обратите внимание, что LWS; не допускается между элементами; это производство. Расширение = путь; путь определен в &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;разделе 3.3 [RFC3986]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="40135f19d49dbe171471ff8585f7f6ce0a630cbe" translate="yes" xml:space="preserve">
          <source>The 100 (Continue) status code indicates that the initial part of a
   request has been received and has not yet been rejected by the
   server.  The server intends to send a final response after the
   request has been fully received and acted upon.

   When the request contains an Expect header field that includes a
   100-continue expectation, the 100 response indicates that the server
   wishes to receive the request payload body, as described in
   &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;.  The client ought to continue sending the request and
   discard the 100 response.

   If the request did not contain an Expect header field containing the
   100-continue expectation, the client can simply discard this interim
   response.</source>
          <target state="translated">Код состояния 100 (Продолжить) указывает, что начальная часть запроса получена и еще не была отклонена сервером. Сервер намеревается отправить окончательный ответ после того, как запрос будет полностью получен и обработан. Когда запрос содержит поле заголовка Expect, которое включает ожидание продолжения 100, ответ 100 указывает, что сервер желает получить тело полезной нагрузки запроса, как описано в &lt;a href=&quot;#section-5.1.1&quot;&gt;Разделе 5.1.1&lt;/a&gt; . Клиент должен продолжить отправку запроса и отклонить ответ 100. Если в запросе не было поля заголовка Expect, содержащего ожидание продолжения 100, клиент может просто отклонить этот промежуточный ответ.</target>
        </trans-unit>
        <trans-unit id="0d01ba31f4c44842de2b726b8f94536c5aca0981" translate="yes" xml:space="preserve">
          <source>The 101 (Switching Protocols) status code indicates that the server
   understands and is willing to comply with the client's request, via
   the Upgrade header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Section&amp;nbsp;6.7 of [RFC7230]&lt;/a&gt;), for a change in
   the application protocol being used on this connection.  The server 

   MUST generate an Upgrade header field in the response that indicates
   which protocol(s) will be switched to immediately after the empty
   line that terminates the 101 response.

   It is assumed that the server will only agree to switch protocols
   when it is advantageous to do so.  For example, switching to a newer
   version of HTTP might be advantageous over older versions, and
   switching to a real-time, synchronous protocol might be advantageous
   when delivering resources that use such features.</source>
          <target state="translated">Код состояния 101 (протоколы переключения) указывает, что сервер понимает и готов выполнить запрос клиента через поле заголовка Upgrade ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;раздел 6.7 [RFC7230]&lt;/a&gt; ) об изменении протокола приложения, используемого в этом соединении. Сервер ДОЛЖЕН сгенерировать поле заголовка обновления в ответе, которое указывает, на какой протокол (ы) будет переключено сразу после пустой строки, завершающей ответ 101. Предполагается, что сервер согласится переключить протоколы только тогда, когда это будет выгодно. Например, переключение на более новую версию HTTP может быть более выгодным по сравнению со старыми версиями, а переключение на синхронный протокол реального времени может быть выгодным при доставке ресурсов, использующих такие функции.</target>
        </trans-unit>
        <trans-unit id="c844ae29efcb21429730db5f3e66a84ced4ddb52" translate="yes" xml:space="preserve">
          <source>The 101 status code</source>
          <target state="translated">101 код статуса</target>
        </trans-unit>
        <trans-unit id="3ed3da1546f287aac58cc367f269cb9295233354" translate="yes" xml:space="preserve">
          <source>The 1xx (Informational) class of status code indicates an interim
   response for communicating connection status or request progress
   prior to completing the requested action and sending a final
   response. 1xx responses are terminated by the first empty line after
   the status-line (the empty line signaling the end of the header
   section).  Since HTTP/1.0 did not define any 1xx status codes, a
   server MUST NOT send a 1xx response to an HTTP/1.0 client.

   A client MUST be able to parse one or more 1xx responses received
   prior to a final response, even if the client does not expect one.  A
   user agent MAY ignore unexpected 1xx responses.

   A proxy MUST forward 1xx responses unless the proxy itself requested
   the generation of the 1xx response.  For example, if a proxy adds an
   &quot;Expect: 100-continue&quot; field when it forwards a request, then it need
   not forward the corresponding 100 (Continue) response(s).</source>
          <target state="translated">Класс состояния 1xx (Информационный)обозначает промежуточный ответ для передачи состояния соединения или хода выполнения запроса до завершения запрошенного действия и отправки финального ответа.Ответы 1xx завершаются первой пустой строкой после строки состояния (пустая строка сигнализирует об окончании заголовочной части).Поскольку HTTP/1.0 не определил никаких кодов статуса 1xx,сервер НЕ ДОЛЖЕН посылать 1xx-ответ клиенту HTTP/1.0.Клиент ДОЛЖЕН уметь разобрать один или несколько 1xx ответов,полученных до получения окончательного ответа,даже если клиент не ожидает его.Пользовательский агент МОЖЕТ игнорировать неожиданные 1xx-ответы.Прокси ДОЛЖЕН пересылать 1xx ответы,если только сам прокси не запросил генерацию 1xx ответа.Например,если при переадресации запроса прокси добавляет поле &quot;Ожидать:100-continue&quot;,то ему не нужно переадресовывать соответствующие 100 (Продолжить)ответов.</target>
        </trans-unit>
        <trans-unit id="73c66d189cbfbc42b2d25d8e68502411eaf75067" translate="yes" xml:space="preserve">
          <source>The 200 (OK) status code indicates that the request has succeeded.
   The payload sent in a 200 response depends on the request method.
   For the methods defined by this specification, the intended meaning
   of the payload can be summarized as:

   GET  a representation of the target resource;

   HEAD  the same representation as GET, but without the representation
      data;

   POST  a representation of the status of, or results obtained from,
      the action;

   PUT, DELETE  a representation of the status of the action;

   OPTIONS  a representation of the communications options;

   TRACE  a representation of the request message as received by the end
      server.

   Aside from responses to CONNECT, a 200 response always has a payload,
   though an origin server MAY generate a payload body of zero length.
   If no payload is desired, an origin server ought to send 204 (No
   Content) instead.  For CONNECT, no payload is allowed because the
   successful result is a tunnel, which begins immediately after the 200
   response header section.

   A 200 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Код состояния 200 (ОК) указывает, что запрос выполнен успешно. Полезная нагрузка, отправляемая в ответе 200, зависит от метода запроса. Для методов, определенных в этой спецификации, предполагаемое значение полезной нагрузки можно резюмировать следующим образом: GET - представление целевого ресурса; HEAD то же представление, что и GET, но без данных представления; POST представление статуса или результатов, полученных в результате действия; PUT, DELETE - представление статуса действия; OPTIONS - представление вариантов связи; TRACE - представление сообщения запроса, полученного конечным сервером. Помимо ответов на CONNECT, ответ 200 всегда имеет полезную нагрузку, хотя исходный сервер МОЖЕТ сгенерировать тело полезной нагрузки нулевой длины. Если полезная нагрузка не требуется,исходный сервер должен вместо этого отправить 204 (без содержимого). Для CONNECT полезная нагрузка не разрешена, потому что успешным результатом является туннель, который начинается сразу после раздела заголовка 200 ответа. По умолчанию ответ 200 кэшируется; то есть, если иное не указано в определении метода или явных элементах управления кешем (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Раздел 4.2.2 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fb652482ea97cc2ed5c9e3a8e7d46c55940f8e9f" translate="yes" xml:space="preserve">
          <source>The 201 (Created) status code indicates that the request has been
   fulfilled and has resulted in one or more new resources being
   created.  The primary resource created by the request is identified
   by either a Location header field in the response or, if no Location
   field is received, by the effective request URI.

   The 201 response payload typically describes and links to the
   resource(s) created.  See &lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt; for a discussion of the meaning
   and purpose of validator header fields, such as ETag and
   Last-Modified, in a 201 response.</source>
          <target state="translated">Код состояния 201 (Создан) указывает, что запрос был выполнен и привел к созданию одного или нескольких новых ресурсов. Первичный ресурс, созданный запросом, идентифицируется либо полем заголовка Location в ответе, либо, если поле Location не получено, действующим URI запроса. Полезные данные ответа 201 обычно описывают созданные ресурсы и ссылаются на них. См. &lt;a href=&quot;#section-7.2&quot;&gt;Раздел 7.2&lt;/a&gt; для обсуждения значения и назначения полей заголовка валидатора, таких как ETag и Last-Modified, в ответе 201.</target>
        </trans-unit>
        <trans-unit id="abf13ad15a9e2fc228718670b40afce5ab72fe28" translate="yes" xml:space="preserve">
          <source>The 202 (Accepted) status code indicates that the request has been
   accepted for processing, but the processing has not been completed.
   The request might or might not eventually be acted upon, as it might
   be disallowed when processing actually takes place.  There is no
   facility in HTTP for re-sending a status code from an asynchronous
   operation.

   The 202 response is intentionally noncommittal.  Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed.  The representation sent with this
   response ought to describe the request's current status and point to
   (or embed) a status monitor that can provide the user with an
   estimate of when the request will be fulfilled.</source>
          <target state="translated">Код состояния 202 (Принято)указывает,что запрос был принят на обработку,но обработка не была завершена.В конце концов,запрос может быть обработан,а может и не быть,так как он может быть запрещен,когда обработка действительно происходит.В HTTP нет возможности повторно отправить код статуса из асинхронной операции.Ответ 202 намеренно не является обязательным.Его цель-позволить серверу принять запрос на какой-то другой процесс (возможно,пакетно-ориентированный процесс,который запускается только один раз в день),не требуя,чтобы соединение агента пользователя с сервером продолжалось до тех пор,пока процесс не будет завершен.Представление,посылаемое с таким ответом,должно описывать текущий статус запроса и указывать на (или внедрять)монитор статуса,который может предоставить пользователю оценку того,когда запрос будет выполнен.</target>
        </trans-unit>
        <trans-unit id="9a4650176c01777123e8dd8f9e1788cc242ba3f7" translate="yes" xml:space="preserve">
          <source>The 203 (Non-Authoritative Information) status code indicates that
   the request was successful but the enclosed payload has been modified
   from that of the origin server's 200 (OK) response by a transforming
   proxy (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;).  This status code allows the
   proxy to notify recipients when a transformation has been applied,
   since that knowledge might impact later decisions regarding the
   content.  For example, future cache validation requests for the
   content might only be applicable along the same request path (through
   the same proxies).

   The 203 response is similar to the Warning code of 214 Transformation
   Applied (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7234]&lt;/a&gt;), which has the advantage of being
   applicable to responses with any status code. 

   A 203 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Код состояния 203 (неавторизованная информация) указывает, что запрос был успешным, но вложенные полезные данные были изменены &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;по сравнению с ответом исходного&lt;/a&gt; сервера 200 (OK) преобразующим прокси-сервером ( раздел 5.7.2 [RFC7230] ). Этот код состояния позволяет прокси-серверу уведомлять получателей о применении преобразования, поскольку это знание может повлиять на последующие решения относительно содержимого. Например, будущие запросы проверки кэша для контента могут быть применимы только по тому же пути запроса (через одни и те же прокси). Ответ 203 аналогичен коду предупреждения при применении преобразования 214 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;раздел 5.5 [RFC7234]&lt;/a&gt;), который может применяться к ответам с любым кодом состояния. По умолчанию ответ 203 кэшируется; то есть, если иное не указано в определении метода или явных элементах управления кешем (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;раздел 4.2.2 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a03bafae0f2da4aa1963199aa2ef89f97a8ce60c" translate="yes" xml:space="preserve">
          <source>The 204 (No Content) status code indicates that the server has
   successfully fulfilled the request and that there is no additional
   content to send in the response payload body.  Metadata in the
   response header fields refer to the target resource and its selected
   representation after the requested action was applied.

   For example, if a 204 status code is received in response to a PUT
   request and the response contains an ETag header field, then the PUT
   was successful and the ETag field-value contains the entity-tag for
   the new representation of that target resource.

   The 204 response allows a server to indicate that the action has been
   successfully applied to the target resource, while implying that the
   user agent does not need to traverse away from its current &quot;document
   view&quot; (if any).  The server assumes that the user agent will provide
   some indication of the success to its user, in accord with its own
   interface, and apply any new or updated metadata in the response to
   its active representation.

   For example, a 204 status code is commonly used with document editing
   interfaces corresponding to a &quot;save&quot; action, such that the document
   being saved remains available to the user for editing.  It is also
   frequently used with interfaces that expect automated data transfers
   to be prevalent, such as within distributed version control systems.

   A 204 response is terminated by the first empty line after the header
   fields because it cannot contain a message body.

   A 204 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Код состояния 204 (нет содержимого) указывает, что сервер успешно выполнил запрос и что в теле полезной нагрузки ответа нет дополнительного содержимого для отправки. Метаданные в полях заголовка ответа относятся к целевому ресурсу и его выбранному представлению после применения запрошенного действия. Например, если код состояния 204 получен в ответ на запрос PUT, и ответ содержит поле заголовка ETag, значит, PUT был успешным, а значение поля ETag содержит тег объекта для нового представления этого целевого ресурса. Ответ 204 позволяет серверу указать, что действие было успешно применено к целевому ресурсу, при этом подразумевая, что агенту пользователя не нужно уходить от своего текущего &amp;laquo;представления документа&amp;raquo; (если есть).Сервер предполагает, что пользовательский агент предоставит некоторую индикацию успеха своему пользователю в соответствии со своим собственным интерфейсом и применит любые новые или обновленные метаданные в ответ на свое активное представление. Например, код состояния 204 обычно используется с интерфейсами редактирования документов, соответствующими действию &amp;laquo;сохранить&amp;raquo;, так что сохраняемый документ остается доступным для редактирования пользователем. Он также часто используется с интерфейсами, которые ожидают преобладания автоматической передачи данных, например, в распределенных системах контроля версий. Ответ 204 заканчивается первой пустой строкой после полей заголовка, потому что он не может содержать тело сообщения. По умолчанию ответ 204 кэшируется; т.е.если иное не указано в определении метода или явных элементах управления кешем (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Раздел 4.2.2 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="956b428452b332069240075e35ec925980806e62" translate="yes" xml:space="preserve">
          <source>The 205 (Reset Content) status code indicates that the server has
   fulfilled the request and desires that the user agent reset the
   &quot;document view&quot;, which caused the request to be sent, to its original
   state as received from the origin server.

   This response is intended to support a common data entry use case
   where the user receives content that supports data entry (a form,
   notepad, canvas, etc.), enters or manipulates data in that space, 

   causes the entered data to be submitted in a request, and then the
   data entry mechanism is reset for the next entry so that the user can
   easily initiate another input action.

   Since the 205 status code implies that no additional content will be
   provided, a server MUST NOT generate a payload in a 205 response.  In
   other words, a server MUST do one of the following for a 205
   response: a) indicate a zero-length body for the response by
   including a Content-Length header field with a value of 0; b)
   indicate a zero-length payload for the response by including a
   Transfer-Encoding header field with a value of chunked and a message
   body consisting of a single chunk of zero-length; or, c) close the
   connection immediately after sending the blank line terminating the
   header section.</source>
          <target state="translated">Код состояния 205 (Reset Content)указывает на то,что сервер выполнил запрос,и желает,чтобы агент пользователя сбросил &quot;вид документа&quot;,из-за которого запрос был отправлен,до его первоначального состояния,полученного от сервера-отправителя.Этот ответ предназначен для поддержки общего случая использования ввода данных,когда пользователь получает контент,который поддерживает ввод данных (форма,блокнот,холст и т.д.),вводит или манипулирует данными в этом пространстве,вызывает представление введенных данных в запросе,а затем механизм ввода данных сбрасывается для следующего ввода,чтобы пользователь мог легко инициировать еще одно действие по вводу данных.Поскольку код состояния 205 подразумевает,что никакого дополнительного содержания не будет предоставлено,сервер НЕ ДОЛЖЕН генерировать полезную нагрузку в ответе 205.Другими словами,сервер ДОЛЖЕН выполнять одно из следующих действий для ответа 205:a)указать тело ответа с нулевой длиной,включив в него поле заголовка Content-Length со значением 0;b)указать поле заголовка с нулевой длиной для ответа,включив в него поле заголовка Transfer-Encoding со значением кусочка и тело сообщения,состоящее из одного кусочка с нулевой длиной;или,c)закрыть соединение сразу же после отправки пустой строки,завершающей раздел заголовка.</target>
        </trans-unit>
        <trans-unit id="07f77f37a20dc983a618d2c0027e2bd10388099a" translate="yes" xml:space="preserve">
          <source>The 206 (Partial Content) status code indicates that the server is
   successfully fulfilling a range request for the target resource by
   transferring one or more parts of the selected representation that
   correspond to the satisfiable ranges found in the request's Range
   header field (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;).

   If a single part is being transferred, the server generating the 206
   response MUST generate a Content-Range header field, describing what
   range of the selected representation is enclosed, and a payload
   consisting of the range.  For example:

     HTTP/1.1 206 Partial Content
     Date: Wed, 15 Nov 1995 06:25:24 GMT
     Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
     Content-Range: bytes 21010-47021/47022
     Content-Length: 26012
     Content-Type: image/gif

     ... 26012 bytes of partial image data 

   If multiple parts are being transferred, the server generating the
   206 response MUST generate a &quot;multipart/byteranges&quot; payload, as
   defined in &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;, and a Content-Type header field containing the
   multipart/byteranges media type and its required boundary parameter.
   To avoid confusion with single-part responses, a server MUST NOT
   generate a Content-Range header field in the HTTP header section of a
   multiple part response (this field will be sent in each part
   instead). 

   Within the header area of each body part in the multipart payload,
   the server MUST generate a Content-Range header field corresponding
   to the range being enclosed in that body part.  If the selected
   representation would have had a Content-Type header field in a 200
   (OK) response, the server SHOULD generate that same Content-Type
   field in the header area of each body part.  For example:

     HTTP/1.1 206 Partial Content
     Date: Wed, 15 Nov 1995 06:25:24 GMT
     Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
     Content-Length: 1741
     Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

     --THIS_STRING_SEPARATES
     Content-Type: application/pdf
     Content-Range: bytes 500-999/8000

     ...the first range
     --THIS_STRING_SEPARATES
     Content-Type: application/pdf
     Content-Range: bytes 7000-7999/8000

     ...the second range
     --THIS_STRING_SEPARATES--

   When multiple ranges are requested, a server MAY coalesce any of the
   ranges that overlap, or that are separated by a gap that is smaller
   than the overhead of sending multiple parts, regardless of the order
   in which the corresponding byte-range-spec appeared in the received
   Range header field.  Since the typical overhead between parts of a
   multipart/byteranges payload is around 80 bytes, depending on the
   selected representation's media type and the chosen boundary
   parameter length, it can be less efficient to transfer many small
   disjoint parts than it is to transfer the entire selected
   representation.

   A server MUST NOT generate a multipart response to a request for a
   single range, since a client that does not request multiple parts
   might not support multipart responses.  However, a server MAY
   generate a multipart/byteranges payload with only a single body part
   if multiple ranges were requested and only one range was found to be
   satisfiable or only one range remained after coalescing.  A client
   that cannot process a multipart/byteranges response MUST NOT generate
   a request that asks for multiple ranges.

   When a multipart response payload is generated, the server SHOULD
   send the parts in the same order that the corresponding
   byte-range-spec appeared in the received Range header field, 

   excluding those ranges that were deemed unsatisfiable or that were
   coalesced into other ranges.  A client that receives a multipart
   response MUST inspect the Content-Range header field present in each
   body part in order to determine which range is contained in that body
   part; a client cannot rely on receiving the same ranges that it
   requested, nor the same order that it requested.

   When a 206 response is generated, the server MUST generate the
   following header fields, in addition to those required above, if the
   field would have been sent in a 200 (OK) response to the same
   request: Date, Cache-Control, ETag, Expires, Content-Location, and
   Vary.

   If a 206 is generated in response to a request with an If-Range
   header field, the sender SHOULD NOT generate other representation
   header fields beyond those required above, because the client is
   understood to already have a prior response containing those header
   fields.  Otherwise, the sender MUST generate all of the
   representation header fields that would have been sent in a 200 (OK)
   response to the same request.

   A 206 response is cacheable by default; i.e., unless otherwise
   indicated by explicit cache controls (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of
   [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Код состояния 206 (частичное содержимое) указывает, что сервер успешно выполняет запрос диапазона для целевого ресурса, передавая одну или несколько частей выбранного представления, которые соответствуют допустимым диапазонам, найденным в поле заголовка диапазона запроса ( &lt;a href=&quot;#section-3.1&quot;&gt;раздел 3.1.&lt;/a&gt;). Если передается одна часть, сервер, генерирующий ответ 206, ДОЛЖЕН сгенерировать поле заголовка Content-Range, описывающее, какой диапазон выбранного представления заключен, и полезную нагрузку, состоящую из этого диапазона. Например: HTTP / 1.1 206 Частичное содержимое Дата: среда, 15 ноября 1995 г., 06:25:24 GMT Последнее изменение: среда, 15 ноября 1995 г., 04:58:08 GMT Диапазон содержимого: байты 21010-47021 / 47022 Длина содержимого : 26012 Content-Type: image / gif ... 26012 байт данных частичного изображения Если передается несколько частей, сервер, генерирующий ответ 206, ДОЛЖЕН генерировать полезную нагрузку multipart / byteranges, как определено в &lt;a href=&quot;#appendix-A&quot;&gt;Приложении A&lt;/a&gt;и поле заголовка Content-Type, содержащее тип мультимедиа multipart / byteranges и его обязательный параметр границы. Во избежание путаницы с ответами, состоящими из одной части, сервер НЕ ДОЛЖЕН создавать поле заголовка Content-Range в разделе заголовка HTTP ответа из нескольких частей (вместо этого это поле будет отправлено в каждой части). В области заголовка каждой части тела в составной полезной нагрузке сервер ДОЛЖЕН генерировать поле заголовка Content-Range, соответствующее диапазону, заключенному в этой части тела. Если выбранное представление имело бы поле заголовка Content-Type в ответе 200 (OK), серверу СЛЕДУЕТ сгенерировать это же поле Content-Type в области заголовка каждой части тела. Например: HTTP / 1.1 206 Частичное содержимое Дата: среда, 15 ноября 1995 г., 06:25:24 GMT Последнее изменение: среда,15 ноя 1995, 04:58:08 GMT Длина содержимого: 1741 Тип содержимого: multipart / byteranges; border = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES Content-Type: application / pdf Content-Range: байты 500-999 / 8000 ... первый диапазон --THIS_STRING_SEPARATES Content-Type: application / pdf Content-Range: байты 7000-7999 / 8000. ..второй диапазон --THIS_STRING_SEPARATES - Когда запрашивается несколько диапазонов, сервер МОЖЕТ объединить любой из диапазонов, которые перекрываются или разделены промежутком, меньшим, чем накладные расходы на отправку нескольких частей, независимо от порядка в который соответствующий byte-range-spec появился в полученном поле заголовка Range. Поскольку типичные накладные расходы между частями полезной нагрузки multipart / byteranges составляют около 80 байт,В зависимости от типа носителя выбранного представления и длины выбранного граничного параметра передача большого количества небольших непересекающихся частей может быть менее эффективной, чем передача всего выбранного представления. Сервер НЕ ДОЛЖЕН генерировать составной ответ на запрос для одного диапазона, поскольку клиент, который не запрашивает несколько частей, может не поддерживать составные ответы. Однако сервер МОЖЕТ сгенерировать полезную нагрузку multipart / byteranges только с одной частью тела, если было запрошено несколько диапазонов, и только один диапазон оказался приемлемым или только один диапазон остался после объединения. Клиент, который не может обработать ответ multipart / byteranges, НЕ ДОЛЖЕН генерировать запрос, запрашивающий несколько диапазонов. Когда создается многочастный ответ,серверу СЛЕДУЕТ отправлять части в том же порядке, в котором соответствующая спецификация диапазона байтов появилась в полученном поле заголовка диапазона, за исключением тех диапазонов, которые были признаны неудовлетворительными или которые были объединены в другие диапазоны. Клиент, который получает ответ из нескольких частей, ДОЛЖЕН проверить поле заголовка Content-Range, присутствующее в каждой части тела, чтобы определить, какой диапазон содержится в этой части тела; клиент не может полагаться на получение тех же диапазонов, которые он запросил, или того же порядка, который он запросил. Когда генерируется ответ 206, сервер ДОЛЖЕН сгенерировать следующие поля заголовка в дополнение к тем, которые требуются выше, если это поле было бы отправлено в ответе 200 (OK) на тот же запрос: Date, Cache-Control, ETag, Срок действия, Content-Location и Vary.Если 206 генерируется в ответ на запрос с полем заголовка If-Range, отправителю НЕ СЛЕДУЕТ генерировать другие поля заголовка представления, помимо требуемых выше, поскольку предполагается, что у клиента уже есть предыдущий ответ, содержащий эти поля заголовка. В противном случае отправитель ДОЛЖЕН сгенерировать все поля заголовка представления, которые были бы отправлены в ответе 200 (OK) на тот же запрос. По умолчанию ответ 206 кэшируется; то есть, если иное не указано явными элементами управления кешем (см.отправитель ДОЛЖЕН сгенерировать все поля заголовка представления, которые были бы отправлены в ответе 200 (OK) на тот же запрос. По умолчанию ответ 206 кэшируется; то есть, если иное не указано явными элементами управления кешем (см.отправитель ДОЛЖЕН сгенерировать все поля заголовка представления, которые были бы отправлены в ответе 200 (OK) на тот же запрос. По умолчанию ответ 206 кэшируется; то есть, если иное не указано явными элементами управления кешем (см.&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Раздел 4.2.2 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a96c2c15082f71e24cf514861b9f6649cccdc6d7" translate="yes" xml:space="preserve">
          <source>The 207 (Multi-Status) status code provides status for multiple
   independent operations (see &lt;a href=&quot;#section-13&quot;&gt;Section 13&lt;/a&gt; for more information).</source>
          <target state="translated">Код состояния 207 (Multi-Status) предоставляет статус для нескольких независимых операций ( дополнительную информацию см. В &lt;a href=&quot;#section-13&quot;&gt;разделе 13&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="21abf74518ada2943ea07b28d70fb2e06dfc8c14" translate="yes" xml:space="preserve">
          <source>The 2xx (Successful) class of status code indicates that the client's
   request was successfully received, understood, and accepted.</source>
          <target state="translated">Класс статуса 2xx (Successful)указывает на то,что запрос клиента был успешно принят,понят и принят.</target>
        </trans-unit>
        <trans-unit id="8091edce5c825502d2461f4be1e98fbbf163fbf9" translate="yes" xml:space="preserve">
          <source>The 300 (Multiple Choices) status code indicates that the target
   resource has more than one representation, each with its own more
   specific identifier, and information about the alternatives is being
   provided so that the user (or user agent) can select a preferred
   representation by redirecting its request to one or more of those
   identifiers.  In other words, the server desires that the user agent
   engage in reactive negotiation to select the most appropriate
   representation(s) for its needs (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;).

   If the server has a preferred choice, the server SHOULD generate a
   Location header field containing a preferred choice's URI reference.
   The user agent MAY use the Location field value for automatic
   redirection.

   For request methods other than HEAD, the server SHOULD generate a
   payload in the 300 response containing a list of representation
   metadata and URI reference(s) from which the user or user agent can
   choose the one most preferred.  The user agent MAY make a selection
   from that list automatically if it understands the provided media
   type.  A specific format for automatic selection is not defined by
   this specification because HTTP tries to remain orthogonal to the
   definition of its payloads.  In practice, the representation is
   provided in some easily parsed format believed to be acceptable to
   the user agent, as determined by shared design or content
   negotiation, or in some commonly accepted hypertext format. 

   A 300 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).

      Note: The original proposal for the 300 status code defined the
      URI header field as providing a list of alternative
      representations, such that it would be usable for 200, 300, and
      406 responses and be transferred in responses to the HEAD method.
      However, lack of deployment and disagreement over syntax led to
      both URI and Alternates (a subsequent proposal) being dropped from
      this specification.  It is possible to communicate the list using
      a set of Link header fields [&lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC5988&lt;/a&gt;], each with a relationship of
      &quot;alternate&quot;, though deployment is a chicken-and-egg problem.</source>
          <target state="translated">Код состояния 300 (множественный выбор) указывает, что целевой ресурс имеет более одного представления, каждое со своим собственным более конкретным идентификатором, и предоставляется информация об альтернативах, чтобы пользователь (или пользовательский агент) мог выбрать предпочтительное представление с помощью перенаправляет свой запрос одному или нескольким из этих идентификаторов. Другими словами, сервер желает, чтобы пользовательский агент участвовал в реактивном согласовании, чтобы выбрать наиболее подходящие представления для своих нужд ( &lt;a href=&quot;#section-3.4&quot;&gt;раздел 3.4.&lt;/a&gt;). Если у сервера есть предпочтительный выбор, серверу СЛЕДУЕТ сгенерировать поле заголовка Location, содержащее ссылку URI предпочтительного выбора. Пользовательский агент МОЖЕТ использовать значение поля Location для автоматического перенаправления. Для методов запроса, отличных от HEAD, серверу СЛЕДУЕТ генерировать полезную нагрузку в ответе 300, содержащую список метаданных представления и ссылку (ссылки) URI, из которых пользователь или пользовательский агент могут выбрать наиболее предпочтительный. Пользовательский агент МОЖЕТ сделать выбор из этого списка автоматически, если он понимает предоставленный тип носителя. Конкретный формат для автоматического выбора в этой спецификации не определен, потому что HTTP пытается оставаться ортогональным определению своих полезных данных. На практике,представление предоставляется в некотором легко анализируемом формате, который считается приемлемым для пользовательского агента, как определено совместно используемым дизайном или согласованием содержимого, или в каком-либо общепринятом гипертекстовом формате. По умолчанию ответ 300 кэшируется; то есть, если иное не указано в определении метода или явных элементах управления кешем (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Раздел 4.2.2 [RFC7234]&lt;/a&gt; ). Примечание. Первоначальное предложение для кода состояния 300 определяло поле заголовка URI как предоставляющее список альтернативных представлений, так что его можно было бы использовать для ответов 200, 300 и 406 и передавать в ответах методу HEAD. Однако отсутствие развертывания и разногласия по поводу синтаксиса привели к тому, что как URI, так и альтернативные варианты (последующее предложение) были исключены из этой спецификации. Список можно передать с помощью набора полей заголовка Link [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC5988&lt;/a&gt; ], каждое из которых имеет отношение &amp;laquo;альтернативное&amp;raquo;, хотя развертывание - это проблема курицы и яйца.</target>
        </trans-unit>
        <trans-unit id="e89e16d2ad3f5f0023fdef413da39c2201b7eab8" translate="yes" xml:space="preserve">
          <source>The 301 (Moved Permanently) status code indicates that the target
   resource has been assigned a new permanent URI and any future
   references to this resource ought to use one of the enclosed URIs.
   Clients with link-editing capabilities ought to automatically re-link
   references to the effective request URI to one or more of the new
   references sent by the server, where possible.

   The server SHOULD generate a Location header field in the response
   containing a preferred URI reference for the new permanent URI.  The
   user agent MAY use the Location field value for automatic
   redirection.  The server's response payload usually contains a short
   hypertext note with a hyperlink to the new URI(s).

      Note: For historical reasons, a user agent MAY change the request
      method from POST to GET for the subsequent request.  If this
      behavior is undesired, the 307 (Temporary Redirect) status code
      can be used instead.

   A 301 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Код состояния 301 (перемещен навсегда) указывает, что целевому ресурсу был назначен новый постоянный URI, и любые будущие ссылки на этот ресурс должны использовать один из вложенных URI. Клиенты с возможностями редактирования ссылок должны автоматически повторно связывать ссылки с действующим URI запроса на одну или несколько новых ссылок, отправленных сервером, где это возможно. Серверу СЛЕДУЕТ генерировать поле заголовка Location в ответе, содержащее ссылку на предпочтительный URI для нового постоянного URI. Пользовательский агент МОЖЕТ использовать значение поля Location для автоматического перенаправления. Полезные данные ответа сервера обычно содержат короткую гипертекстовую заметку с гиперссылкой на новый URI. Примечание. По историческим причинам пользовательский агент МОЖЕТ изменить метод запроса с POST на GET для последующего запроса.Если такое поведение нежелательно, вместо него можно использовать код состояния 307 (временное перенаправление). По умолчанию ответ 301 кэшируется; то есть, если иное не указано в определении метода или явных элементах управления кешем (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Раздел 4.2.2 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ef3872d9a97e7902a4418ab95fd36038bea8203" translate="yes" xml:space="preserve">
          <source>The 302 (Found) status code indicates that the target resource
   resides temporarily under a different URI.  Since the redirection
   might be altered on occasion, the client ought to continue to use the
   effective request URI for future requests. 

   The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.  The user agent MAY
   use the Location field value for automatic redirection.  The server's
   response payload usually contains a short hypertext note with a
   hyperlink to the different URI(s).

      Note: For historical reasons, a user agent MAY change the request
      method from POST to GET for the subsequent request.  If this
      behavior is undesired, the 307 (Temporary Redirect) status code
      can be used instead.</source>
          <target state="translated">Код статуса 302 (Найден)указывает на то,что целевой ресурс временно находится под другим URI.Так как перенаправление может быть изменено в некоторых случаях,клиент должен продолжать использовать эффективный URI запроса для будущих запросов.Сервер SHOULD генерирует поле заголовка Location в ответе,содержащее ссылку на URI для другого URI.Пользовательский агент MAY MAY использует значение поля Location для автоматического перенаправления.Полезная нагрузка ответа сервера обычно содержит короткую гипертекстовую заметку с гиперссылкой на различные URI.Примечание:По историческим причинам пользовательский агент MAY изменяет метод запроса с POST на GET для последующего запроса.Если такое поведение нежелательно,вместо него можно использовать код статуса 307 (Temporary Redirect).</target>
        </trans-unit>
        <trans-unit id="f98486b9c7317cc8a6b18febd1348ba3209011c0" translate="yes" xml:space="preserve">
          <source>The 303 (See Other) status code indicates that the server is
   redirecting the user agent to a different resource, as indicated by a
   URI in the Location header field, which is intended to provide an
   indirect response to the original request.  A user agent can perform
   a retrieval request targeting that URI (a GET or HEAD request if
   using HTTP), which might also be redirected, and present the eventual
   result as an answer to the original request.  Note that the new URI
   in the Location header field is not considered equivalent to the
   effective request URI.

   This status code is applicable to any HTTP method.  It is primarily
   used to allow the output of a POST action to redirect the user agent
   to a selected resource, since doing so provides the information
   corresponding to the POST response in a form that can be separately
   identified, bookmarked, and cached, independent of the original
   request.

   A 303 response to a GET request indicates that the origin server does
   not have a representation of the target resource that can be
   transferred by the server over HTTP.  However, the Location field
   value refers to a resource that is descriptive of the target
   resource, such that making a retrieval request on that other resource
   might result in a representation that is useful to recipients without
   implying that it represents the original target resource.  Note that
   answers to the questions of what can be represented, what
   representations are adequate, and what might be a useful description
   are outside the scope of HTTP.

   Except for responses to a HEAD request, the representation of a 303
   response ought to contain a short hypertext note with a hyperlink to
   the same URI reference provided in the Location header field.</source>
          <target state="translated">Код статуса 303 (см.Другое)указывает на то,что сервер перенаправляет пользовательского агента на другой ресурс,как указывает URI в поле заголовка Location,который предназначен для предоставления косвенного ответа на исходный запрос.Пользовательский агент может выполнить запрос на получение,нацеленный на этот URI (GET или HEAD запрос,если используется HTTP),который также может быть перенаправлен,и представить конечный результат в виде ответа на исходный запрос.Обратите внимание,что новый URI в поле заголовка Location не считается эквивалентным действующему URI запроса.Этот код статуса применим к любому методу HTTP.В первую очередь он используется для того,чтобы разрешить вывод POST действия для перенаправления пользовательского агента на выбранный ресурс,так как при этом предоставляется информация,соответствующая POST ответу в форме,которая может быть отдельно идентифицирована,занесена в закладки и кэширована,независимо от оригинального запроса.Ответ 303 на GET запрос указывает на то,что исходный сервер не имеет представления о целевом ресурсе,который может быть передан сервером по HTTP.Тем не менее,значение поля Location относится к ресурсу,который является описанием целевого ресурса,таким образом,чтобы сделать запрос на получение на этот другой ресурс может привести к представлению,которое является полезным для получателей,не подразумевая,что он представляет собой исходный целевой ресурс.Обратите внимание,что ответы на вопросы о том,что может быть представлено,какие представления адекватны,и что может быть полезным описанием,находятся за пределами HTTP.За исключением ответов на запрос HEAD,представление ответа 303 должно содержать короткую гипертекстовую заметку с гиперссылкой на ту же самую ссылку на URI,которая содержится в поле заголовка Location.</target>
        </trans-unit>
        <trans-unit id="1310056b9a11237a35ab8cb0a6c54f0611f4bdbf" translate="yes" xml:space="preserve">
          <source>The 304 (Not Modified) status code indicates that a conditional GET
   or HEAD request has been received and would have resulted in a 200
   (OK) response if it were not for the fact that the condition
   evaluated to false.  In other words, there is no need for the server
   to transfer a representation of the target resource because the
   request indicates that the client, which made the request 

   conditional, already has a valid representation; the server is
   therefore redirecting the client to make use of that stored
   representation as if it were the payload of a 200 (OK) response.

   The server generating a 304 response MUST generate any of the
   following header fields that would have been sent in a 200 (OK)
   response to the same request: Cache-Control, Content-Location, Date,
   ETag, Expires, and Vary.

   Since the goal of a 304 response is to minimize information transfer
   when the recipient already has one or more cached representations, a
   sender SHOULD NOT generate representation metadata other than the
   above listed fields unless said metadata exists for the purpose of
   guiding cache updates (e.g., Last-Modified might be useful if the
   response does not have an ETag field).

   Requirements on a cache that receives a 304 response are defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.4&quot;&gt;Section&amp;nbsp;4.3.4 of [RFC7234]&lt;/a&gt;.  If the conditional request originated
   with an outbound client, such as a user agent with its own cache
   sending a conditional GET to a shared proxy, then the proxy SHOULD
   forward the 304 response to that client.

   A 304 response cannot contain a message-body; it is always terminated
   by the first empty line after the header fields.</source>
          <target state="translated">Код состояния 304 (Not Modified) указывает, что условный запрос GET или HEAD был получен и привел бы к ответу 200 (OK), если бы не тот факт, что условие было оценено как ложное. Другими словами, серверу нет необходимости передавать представление целевого ресурса, потому что запрос указывает, что клиент, который сделал запрос условным, уже имеет действительное представление; поэтому сервер перенаправляет клиента на использование этого сохраненного представления, как если бы это была полезная нагрузка ответа 200 (OK). Сервер, генерирующий ответ 304, ДОЛЖЕН сгенерировать любое из следующих полей заголовка, которые были бы отправлены в ответе 200 (OK) на тот же запрос: Cache-Control, Content-Location, Date, ETag, Expires и Vary.Поскольку цель ответа 304 состоит в том, чтобы минимизировать передачу информации, когда получатель уже имеет одно или несколько кэшированных представлений, отправителю НЕ СЛЕДУЕТ генерировать метаданные представления, отличные от перечисленных выше полей, если указанные метаданные не существуют для целей управления обновлениями кеша (например, Last-Modified может быть полезен, если в ответе нет поля ETag). Требования к кэшу, который получает ответ 304, определены вТребования к кэшу, который получает ответ 304, определены вТребования к кэшу, который получает ответ 304, определены в &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.4&quot;&gt;Раздел 4.3.4 [RFC7234]&lt;/a&gt; . Если условный запрос исходит от исходящего клиента, такого как пользовательский агент со своим собственным кешем, отправляющий условный GET на общий прокси-сервер, то прокси-сервер ДОЛЖЕН переслать ответ 304 этому клиенту. Ответ 304 не может содержать тело сообщения; он всегда заканчивается первой пустой строкой после полей заголовка.</target>
        </trans-unit>
        <trans-unit id="d962e03df1dabcc2ec176a4937563211d6cfd2cc" translate="yes" xml:space="preserve">
          <source>The 305 (Use Proxy) status code was defined in a previous version of
   this specification and is now deprecated (Appendix B).</source>
          <target state="translated">Код статуса 305 (Использовать прокси)был определен в предыдущей версии этой спецификации и теперь устарел (Приложение B).</target>
        </trans-unit>
        <trans-unit id="bbf9b7a6555633242c214ea7db29148fae94dc7d" translate="yes" xml:space="preserve">
          <source>The 306 status code was defined in a previous version of this
   specification, is no longer used, and the code is reserved.</source>
          <target state="translated">Код статуса 306 был определен в предыдущей версии данной спецификации,больше не используется,и код зарезервирован.</target>
        </trans-unit>
        <trans-unit id="4404c364ec3064905980ead43e5d3f9ef55ccb2e" translate="yes" xml:space="preserve">
          <source>The 306 status code was used in a previous version of the
   specification, is no longer used, and the code is reserved.</source>
          <target state="translated">Код статуса 306 использовался в предыдущей версии спецификации,больше не используется,и код зарезервирован.</target>
        </trans-unit>
        <trans-unit id="efa8bf4f32294cae0ef47f6deb993b93eec7981d" translate="yes" xml:space="preserve">
          <source>The 307 (Temporary Redirect) status code indicates that the target
   resource resides temporarily under a different URI and the user agent
   MUST NOT change the request method if it performs an automatic
   redirection to that URI.  Since the redirection can change over time,
   the client ought to continue using the original effective request URI
   for future requests.

   The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.  The user agent MAY
   use the Location field value for automatic redirection.  The server's
   response payload usually contains a short hypertext note with a
   hyperlink to the different URI(s).

      Note: This status code is similar to 302 (Found), except that it
      does not allow changing the request method from POST to GET.  This
      specification defines no equivalent counterpart for 301 (Moved
      Permanently) ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;RFC7238&lt;/a&gt;], however, defines the status code 308
      (Permanent Redirect) for this purpose).</source>
          <target state="translated">Код состояния 307 (временное перенаправление) указывает, что целевой ресурс временно находится под другим URI, и пользовательский агент НЕ ДОЛЖЕН изменять метод запроса, если он выполняет автоматическое перенаправление на этот URI. Поскольку перенаправление может со временем измениться, клиент должен продолжать использовать исходный действующий URI запроса для будущих запросов. Серверу СЛЕДУЕТ генерировать поле заголовка Location в ответе, содержащем ссылку URI для другого URI. Пользовательский агент МОЖЕТ использовать значение поля Location для автоматического перенаправления. Полезные данные ответа сервера обычно содержат короткую гипертекстовую заметку с гиперссылкой на разные URI. Примечание. Этот код состояния аналогичен 302 (Найдено), за исключением того, что он не позволяет изменить метод запроса с POST на GET.Эта спецификация не определяет эквивалентного аналога для 301 (перемещено навсегда) ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;RFC7238&lt;/a&gt; ], однако, для этой цели определяет код состояния 308 (постоянное перенаправление)).</target>
        </trans-unit>
        <trans-unit id="0b552dedeef68a9fc1c9bedf80fe2f970232311c" translate="yes" xml:space="preserve">
          <source>The 3xx (Redirection) class of status code indicates that further
   action needs to be taken by the user agent in order to fulfill the
   request.  If a Location header field (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;) is provided, the
   user agent MAY automatically redirect its request to the URI
   referenced by the Location field value, even if the specific status
   code is not understood.  Automatic redirection needs to done with
   care for methods not known to be safe, as defined in &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;,
   since the user might not wish to redirect an unsafe request.

   There are several types of redirects:

   1.  Redirects that indicate the resource might be available at a
       different URI, as provided by the Location field, as in the
       status codes 301 (Moved Permanently), 302 (Found), and 307
       (Temporary Redirect).

   2.  Redirection that offers a choice of matching resources, each
       capable of representing the original request target, as in the
       300 (Multiple Choices) status code.

   3.  Redirection to a different resource, identified by the Location
       field, that can represent an indirect response to the request, as
       in the 303 (See Other) status code.

   4.  Redirection to a previously cached result, as in the 304 (Not
       Modified) status code.

      Note: In HTTP/1.0, the status codes 301 (Moved Permanently) and
      302 (Found) were defined for the first type of redirect
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc1945#section-9.3&quot;&gt;[RFC1945], Section&amp;nbsp;9.3&lt;/a&gt;).  Early user agents split on whether the
      method applied to the redirect target would be the same as the 

      original request or would be rewritten as GET.  Although HTTP
      originally defined the former semantics for 301 and 302 (to match
      its original implementation at CERN), and defined 303 (See Other)
      to match the latter semantics, prevailing practice gradually
      converged on the latter semantics for 301 and 302 as well.  The
      first revision of HTTP/1.1 added 307 (Temporary Redirect) to
      indicate the former semantics without being impacted by divergent
      practice.  Over 10 years later, most user agents still do method
      rewriting for 301 and 302; therefore, this specification makes
      that behavior conformant when the original request is POST.

   A client SHOULD detect and intervene in cyclical redirections (i.e.,
   &quot;infinite&quot; redirection loops).

      Note: An earlier version of this specification recommended a
      maximum of five redirections (&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-10.3&quot;&gt;[RFC2068], Section&amp;nbsp;10.3&lt;/a&gt;).  Content
      developers need to be aware that some clients might implement such
      a fixed limitation.</source>
          <target state="translated">Класс кода состояния 3xx (перенаправление) указывает, что пользовательский агент должен предпринять дальнейшие действия для выполнения запроса. Если предоставляется поле заголовка Location ( &lt;a href=&quot;#section-7.1.2&quot;&gt;раздел 7.1.2&lt;/a&gt; ), пользовательский агент МОЖЕТ автоматически перенаправить свой запрос на URI, на который ссылается значение поля Location, даже если конкретный код состояния не понят. Автоматическое перенаправление должно выполняться с осторожностью для методов, небезопасных, как определено в &lt;a href=&quot;#section-4.2.1&quot;&gt;Разделе 4.2.1.&lt;/a&gt;, поскольку пользователь может не захотеть перенаправлять небезопасный запрос. Существует несколько типов перенаправления: 1. Перенаправления, которые указывают на то, что ресурс может быть доступен по другому URI, как указано в поле &amp;laquo;Местоположение&amp;raquo;, например, в кодах состояния 301 (перемещено постоянно), 302 (найдено) и 307 (временное перенаправление). ). 2. Перенаправление, которое предлагает выбор совпадающих ресурсов, каждый из которых может представлять исходную цель запроса, как в коде состояния 300 (множественный выбор). 3. Перенаправление на другой ресурс, идентифицированный полем Location, который может представлять косвенный ответ на запрос, как в коде состояния 303 (See Other). 4. Перенаправление к ранее кэшированному результату, как в коде состояния 304 (Не изменено). Примечание. В HTTP / 1.0коды состояния 301 (перемещено постоянно) и 302 (найдено) были определены для первого типа перенаправления (&lt;a href=&quot;https://tools.ietf.org/html/rfc1945#section-9.3&quot;&gt;[RFC1945], раздел 9.3&lt;/a&gt;). Ранние пользовательские агенты разделяются по тому, будет ли метод, примененный к цели перенаправления, таким же, как исходный запрос, или будет переписан как GET. Хотя HTTP изначально определил первую семантику для 301 и 302 (чтобы соответствовать ее исходной реализации в CERN) и определил 303 (см. Другое), чтобы соответствовать последней семантике, преобладающая практика постепенно сошлась на последней семантике также и для 301 и 302. Первая версия HTTP / 1.1 добавила 307 (временное перенаправление), чтобы указать прежнюю семантику, не подвергаясь влиянию различных практик. Спустя более 10 лет большинство пользовательских агентов по-прежнему переписывают методы для 301 и 302; следовательно, эта спецификация делает это поведение совместимым, когда исходный запрос - POST.Клиенту СЛЕДУЕТ обнаруживать циклические перенаправления (т. Е. &amp;laquo;Бесконечные&amp;raquo; циклы перенаправления) и вмешиваться в них. Примечание: более ранняя версия этой спецификации рекомендовала максимум пять перенаправлений (&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-10.3&quot;&gt;[RFC2068], раздел 10.3&lt;/a&gt; ). Разработчики контента должны знать, что некоторые клиенты могут применять такое фиксированное ограничение.</target>
        </trans-unit>
        <trans-unit id="334ca39a91da7c29dc27f4fe5d1fa671a87b47b0" translate="yes" xml:space="preserve">
          <source>The 400 (Bad Request) status code indicates that the server cannot or
   will not process the request due to something that is perceived to be
   a client error (e.g., malformed request syntax, invalid request
   message framing, or deceptive request routing).</source>
          <target state="translated">Код состояния 400 (Плохой запрос)указывает на то,что сервер не может или не будет обрабатывать запрос из-за чего-то,что воспринимается как ошибка клиента (например,неправильный синтаксис запроса,неправильная формулировка запроса или обманчивая маршрутизация запроса).</target>
        </trans-unit>
        <trans-unit id="29689450f4d2cb77a3efa906a5294a262a4c2452" translate="yes" xml:space="preserve">
          <source>The 401 (Unauthorized) status code indicates that the request has not
   been applied because it lacks valid authentication credentials for
   the target resource.  The server generating a 401 response MUST send
   a WWW-Authenticate header field (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) containing at least one
   challenge applicable to the target resource.

   If the request included authentication credentials, then the 401
   response indicates that authorization has been refused for those
   credentials.  The user agent MAY repeat the request with a new or
   replaced Authorization header field (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;).  If the 401
   response contains the same challenge as the prior response, and the
   user agent has already attempted authentication at least once, then
   the user agent SHOULD present the enclosed representation to the
   user, since it usually contains relevant diagnostic information.</source>
          <target state="translated">Код состояния 401 (Неавторизован) указывает, что запрос не был применен, поскольку ему не хватает действительных учетных данных для аутентификации для целевого ресурса. Сервер, генерирующий ответ 401, ДОЛЖЕН отправить поле заголовка WWW-Authenticate ( &lt;a href=&quot;#section-4.1&quot;&gt;раздел 4.1&lt;/a&gt; ), содержащее по крайней мере один запрос, применимый к целевому ресурсу. Если запрос включал учетные данные аутентификации, то ответ 401 указывает, что для этих учетных данных в авторизации было отказано. Пользовательский агент МОЖЕТ повторить запрос с новым или замененным полем заголовка авторизации ( &lt;a href=&quot;#section-4.2&quot;&gt;раздел 4.2&lt;/a&gt;). Если ответ 401 содержит тот же вызов, что и предыдущий ответ, и пользовательский агент уже пытался аутентифицироваться хотя бы один раз, то пользовательский агент ДОЛЖЕН предоставить пользователю заключенное представление, поскольку оно обычно содержит релевантную диагностическую информацию.</target>
        </trans-unit>
        <trans-unit id="8a32cd96fa39bd8cea46e432f2bd383665a1ab08" translate="yes" xml:space="preserve">
          <source>The 402 (Payment Required) status code is reserved for future use.</source>
          <target state="translated">Код статуса 402 (Payment Required)зарезервирован для использования в будущем.</target>
        </trans-unit>
        <trans-unit id="79339f2e8ca3d487560bd812a6eea754f58b8f81" translate="yes" xml:space="preserve">
          <source>The 403 (Forbidden) status code indicates that the server understood
   the request but refuses to authorize it.  A server that wishes to
   make public why the request has been forbidden can describe that
   reason in the response payload (if any).

   If authentication credentials were provided in the request, the
   server considers them insufficient to grant access.  The client
   SHOULD NOT automatically repeat the request with the same
   credentials.  The client MAY repeat the request with new or different
   credentials.  However, a request might be forbidden for reasons
   unrelated to the credentials.

   An origin server that wishes to &quot;hide&quot; the current existence of a
   forbidden target resource MAY instead respond with a status code of
   404 (Not Found).</source>
          <target state="translated">Код статуса 403 (Запрещенный)указывает на то,что сервер понял запрос,но отказался его авторизовать.Сервер,желающий обнародовать причину,по которой запрос был запрещен,может описать эту причину в ответе полезной нагрузкой (если таковая имеется).Если в запросе были указаны идентификационные данные,то сервер считает их недостаточными для предоставления доступа.Клиент НЕ ДОЛЖЕН автоматически повторить запрос с теми же самыми учетными данными.Клиент МОЖЕТ повторить запрос с новыми или другими учетными данными.Однако,запрос может быть запрещен по причинам,не связанным с учетными данными.Сервер-источник,желающий &quot;скрыть&quot; текущее существование запрещенного целевого ресурса MAY,вместо этого отвечает кодом статуса 404 (Not Found).</target>
        </trans-unit>
        <trans-unit id="e3def26038d6d95647ba8eb940680d2af264c867" translate="yes" xml:space="preserve">
          <source>The 404 (Not Found) status code indicates that the origin server did
   not find a current representation for the target resource or is not
   willing to disclose that one exists.  A 404 status code does not
   indicate whether this lack of representation is temporary or
   permanent; the 410 (Gone) status code is preferred over 404 if the
   origin server knows, presumably through some configurable means, that
   the condition is likely to be permanent.

   A 404 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Код состояния 404 (не найден) указывает на то, что исходный сервер не нашел текущего представления для целевого ресурса или не желает раскрывать его существование. Код состояния 404 не указывает, является ли это отсутствие представления временным или постоянным; код состояния 410 (Gone) предпочтительнее 404, если исходный сервер знает, предположительно с помощью некоторых настраиваемых средств, что состояние, вероятно, будет постоянным. По умолчанию ответ 404 кэшируется; то есть, если иное не указано в определении метода или явных элементах управления кешем (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;раздел 4.2.2 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="139fdce0aa53e1ec81629bd1c9fe084f1e273d10" translate="yes" xml:space="preserve">
          <source>The 405 (Method Not Allowed) status code indicates that the method
   received in the request-line is known by the origin server but not
   supported by the target resource.  The origin server MUST generate an
   Allow header field in a 405 response containing a list of the target
   resource's currently supported methods.

   A 405 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Код состояния 405 (метод запрещен) указывает, что метод, полученный в строке запроса, известен исходному серверу, но не поддерживается целевым ресурсом. Исходный сервер ДОЛЖЕН генерировать поле заголовка Allow в ответе 405, содержащем список поддерживаемых в настоящее время методов целевого ресурса. По умолчанию ответ 405 кэшируется; то есть, если иное не указано в определении метода или явных элементах управления кешем (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;раздел 4.2.2 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ee79d34ebbf5f698fa72e9938ee69213ae4643fa" translate="yes" xml:space="preserve">
          <source>The 406 (Not Acceptable) status code indicates that the target
   resource does not have a current representation that would be
   acceptable to the user agent, according to the proactive negotiation
   header fields received in the request (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;), and the server
   is unwilling to supply a default representation.

   The server SHOULD generate a payload containing a list of available
   representation characteristics and corresponding resource identifiers
   from which the user or user agent can choose the one most
   appropriate.  A user agent MAY automatically select the most
   appropriate choice from that list.  However, this specification does
   not define any standard for such automatic selection, as described in
   &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;.</source>
          <target state="translated">Код состояния 406 (Неприемлемо) указывает, что целевой ресурс не имеет текущего представления, которое было бы приемлемо для пользовательского агента, согласно полям заголовка упреждающего согласования, полученным в запросе ( &lt;a href=&quot;#section-5.3&quot;&gt;раздел 5.3&lt;/a&gt; ), и сервер не желает предоставить представление по умолчанию. Серверу СЛЕДУЕТ генерировать полезную нагрузку, содержащую список доступных характеристик представления и соответствующие идентификаторы ресурсов, из которых пользователь или пользовательский агент может выбрать наиболее подходящий. Пользовательский агент МОЖЕТ автоматически выбрать наиболее подходящий вариант из этого списка. Однако эта спецификация не определяет никаких стандартов для такого автоматического выбора, как описано в &lt;a href=&quot;#section-6.4.1&quot;&gt;разделе 6.4.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec483ec7612cbc4a7219b208c6205da13b1a5be1" translate="yes" xml:space="preserve">
          <source>The 407 (Proxy Authentication Required) status code is similar to 401
   (Unauthorized), but it indicates that the client needs to
   authenticate itself in order to use a proxy.  The proxy MUST send a
   Proxy-Authenticate header field (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) containing a challenge
   applicable to that proxy for the target resource.  The client MAY
   repeat the request with a new or replaced Proxy-Authorization header
   field (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;).</source>
          <target state="translated">Код состояния 407 (требуется проверка подлинности прокси) аналогичен 401 (не авторизован), но указывает, что клиенту необходимо пройти проверку подлинности, чтобы использовать прокси. Прокси-сервер ДОЛЖЕН отправить поле заголовка Proxy-Authenticate ( &lt;a href=&quot;#section-4.3&quot;&gt;раздел 4.3&lt;/a&gt; ), содержащее запрос, применимый к этому прокси для целевого ресурса. Клиент МОЖЕТ повторить запрос с новым или замененным полем заголовка Proxy-Authorization ( &lt;a href=&quot;#section-4.4&quot;&gt;раздел 4.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d63a1397f5112fdbc72a63c104b8b9b743795432" translate="yes" xml:space="preserve">
          <source>The 408 (Request Timeout) status code indicates that the server did
   not receive a complete request message within the time that it was
   prepared to wait.  A server SHOULD send the &quot;close&quot; connection option
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC7230]&lt;/a&gt;) in the response, since 408 implies that
   the server has decided to close the connection rather than continue
   waiting.  If the client has an outstanding request in transit, the
   client MAY repeat that request on a new connection.</source>
          <target state="translated">Код состояния 408 (тайм-аут запроса) указывает, что сервер не получил полное сообщение запроса в течение времени, которое он был подготовлен к ожиданию. Серверу СЛЕДУЕТ отправлять в ответ вариант &amp;laquo;закрыть&amp;raquo; соединение ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;раздел 6.1 [RFC7230]&lt;/a&gt; ), поскольку 408 подразумевает, что сервер решил закрыть соединение, а не продолжать ожидание. Если у клиента есть ожидающий запрос в пути, клиент МОЖЕТ повторить этот запрос при новом соединении.</target>
        </trans-unit>
        <trans-unit id="710b792af9157df3657d23cffcb2324a8f3a8d23" translate="yes" xml:space="preserve">
          <source>The 409 (Conflict) status code indicates that the request could not
   be completed due to a conflict with the current state of the target
   resource.  This code is used in situations where the user might be
   able to resolve the conflict and resubmit the request.  The server
   SHOULD generate a payload that includes enough information for a user
   to recognize the source of the conflict.

   Conflicts are most likely to occur in response to a PUT request.  For
   example, if versioning were being used and the representation being
   PUT included changes to a resource that conflict with those made by
   an earlier (third-party) request, the origin server might use a 409
   response to indicate that it can't complete the request.  In this
   case, the response representation would likely contain information
   useful for merging the differences based on the revision history.</source>
          <target state="translated">Код статуса 409 (Конфликт)указывает на то,что запрос не может быть завершен из-за конфликта с текущим состоянием целевого ресурса.Этот код используется в ситуациях,когда пользователь может разрешить конфликт и повторно отправить запрос.Сервер SHOULD генерирует полезную нагрузку,включающую в себя достаточно информации для того,чтобы пользователь мог распознать источник конфликта.Конфликты чаще всего возникают в ответ на запрос PUT.Например,если используется версионирование и представление,которым является PUT,включает в себя изменения ресурса,которые конфликтуют с изменениями,сделанными более ранним (сторонним)запросом,сервер-источник может использовать ответ 409,чтобы указать,что он не может завершить запрос.В этом случае ответное представление,скорее всего,будет содержать информацию,полезную для объединения различий на основе истории ревизий.</target>
        </trans-unit>
        <trans-unit id="ed70c66832007f42d2ffeafd2453c5472e4f6db0" translate="yes" xml:space="preserve">
          <source>The 410 (Gone) status code indicates that access to the target
   resource is no longer available at the origin server and that this
   condition is likely to be permanent.  If the origin server does not 

   know, or has no facility to determine, whether or not the condition
   is permanent, the status code 404 (Not Found) ought to be used
   instead.

   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed.  Such an event is common
   for limited-time, promotional services and for resources belonging to
   individuals no longer associated with the origin server's site.  It
   is not necessary to mark all permanently unavailable resources as
   &quot;gone&quot; or to keep the mark for any length of time -- that is left to
   the discretion of the server owner.

   A 410 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Код состояния 410 (Gone) указывает, что доступ к целевому ресурсу больше не доступен на исходном сервере и что это состояние, вероятно, будет постоянным. Если исходный сервер не знает или не имеет возможности определить, является ли условие постоянным, вместо этого следует использовать код состояния 404 (Не найдено). Ответ 410 в первую очередь предназначен для поддержки задачи обслуживания сети путем уведомления получателя о том, что ресурс намеренно недоступен и что владельцы серверов желают, чтобы удаленные ссылки на этот ресурс были удалены. Такое событие характерно для ограниченных по времени рекламных услуг и ресурсов, принадлежащих лицам, больше не связанным с сайтом исходного сервера. Нет необходимости отмечать все постоянно недоступные ресурсы как &quot;ушел &quot;или оставить метку в течение любого периода времени - это остается на усмотрение владельца сервера. Ответ 410 кэшируется по умолчанию, т. е. если иное не указано в определении метода или явных элементах управления кешем (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Раздел 4.2.2 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1d57fe4e2e7ca23134c38c0ed0018ac65cd3855c" translate="yes" xml:space="preserve">
          <source>The 411 (Length Required) status code indicates that the server
   refuses to accept the request without a defined Content-Length
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;Section&amp;nbsp;3.3.2 of [RFC7230]&lt;/a&gt;).  The client MAY repeat the request if
   it adds a valid Content-Length header field containing the length of
   the message body in the request message.</source>
          <target state="translated">Код состояния 411 (требуется длина) указывает, что сервер отказывается принять запрос без определенной длины содержимого ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;раздел 3.3.2 [RFC7230]&lt;/a&gt; ). Клиент МОЖЕТ повторить запрос, если он добавляет допустимое поле заголовка Content-Length, содержащее длину тела сообщения в сообщении запроса.</target>
        </trans-unit>
        <trans-unit id="a2b0a5d0ce695f774d281e52c15ee444fd3362b0" translate="yes" xml:space="preserve">
          <source>The 412 (Precondition Failed) status code indicates that one or more
   conditions given in the request header fields evaluated to false when
   tested on the server.  This response code allows the client to place
   preconditions on the current resource state (its current
   representations and metadata) and, thus, prevent the request method
   from being applied if the target resource is in an unexpected state.</source>
          <target state="translated">Код состояния 412 (Precondition Failed)указывает,что одно или несколько условий,указанных в полях заголовка запроса,оцениваются как ложные при тестировании на сервере.Этот код ответа позволяет клиенту поставить предусловия на текущее состояние ресурса (его текущие представления и метаданные)и,таким образом,предотвратить применение метода запроса,если целевой ресурс находится в неожиданном состоянии.</target>
        </trans-unit>
        <trans-unit id="d068c8261010d8ad8c83770690d1c48285eb7c3d" translate="yes" xml:space="preserve">
          <source>The 413 (Payload Too Large) status code indicates that the server is
   refusing to process a request because the request payload is larger
   than the server is willing or able to process.  The server MAY close
   the connection to prevent the client from continuing the request.

   If the condition is temporary, the server SHOULD generate a
   Retry-After header field to indicate that it is temporary and after
   what time the client MAY try again.</source>
          <target state="translated">Код статуса 413 (полезная нагрузка слишком велика)указывает на то,что сервер отказывается обрабатывать запрос,потому что полезная нагрузка запроса больше,чем сервер хочет или может обработать.Сервер MAY закрывает соединение,чтобы не позволить клиенту продолжить обработку запроса.Если условие является временным,сервер ДОЛЖЕН сгенерировать поле заголовка Retry-After,чтобы указать,что оно является временным и после какого времени клиент MAY повторяет попытку.</target>
        </trans-unit>
        <trans-unit id="2eeffaec19aae81212514c4d922d7dc543cfcc59" translate="yes" xml:space="preserve">
          <source>The 414 (URI Too Long) status code indicates that the server is
   refusing to service the request because the request-target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;5.3 of [RFC7230]&lt;/a&gt;) is longer than the server is willing to interpret.
   This rare condition is only likely to occur when a client has
   improperly converted a POST request to a GET request with long query
   information, when the client has descended into a &quot;black hole&quot; of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself) or when the server is under attack by a client attempting to
   exploit potential security holes. 

   A 414 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Код состояния 414 (URI Too Long) указывает на то, что сервер отказывается обслуживать запрос, потому что целевой объект запроса ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;раздел &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;5.3 [RFC7230]&lt;/a&gt; ) длиннее, чем сервер готов интерпретировать. Это редкое состояние может возникнуть только тогда, когда клиент неправильно преобразовал запрос POST в запрос GET с длинной информацией запроса, когда клиент спустился в &amp;laquo;черную дыру&amp;raquo; перенаправления (например, префикс перенаправленного URI, указывающий на суффикс самого себя) или когда сервер подвергается атаке со стороны клиента, пытающегося использовать потенциальные дыры в безопасности. По умолчанию ответ 414 кэшируется; то есть, если иное не указано в определении метода или явных элементах управления кешем (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;раздел 4.2.2 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="60bd497af3a67e2912392260b738e67280886922" translate="yes" xml:space="preserve">
          <source>The 415 (Unsupported Media Type) status code indicates that the
   origin server is refusing to service the request because the payload
   is in a format not supported by this method on the target resource.
   The format problem might be due to the request's indicated
   Content-Type or Content-Encoding, or as a result of inspecting the
   data directly.</source>
          <target state="translated">Код статуса 415 (Unsupported Media Type)указывает,что исходный сервер отказывается обслуживать запрос,так как полезная нагрузка на целевом ресурсе находится в формате,не поддерживаемом этим методом.Проблема формата может быть вызвана указанным в запросе Content-Type или Content-Encoding,или в результате непосредственной проверки данных.</target>
        </trans-unit>
        <trans-unit id="e7168717c59ebb6678e8095c4f89436d6063047e" translate="yes" xml:space="preserve">
          <source>The 416 (Range Not Satisfiable) status code indicates that none of
   the ranges in the request's Range header field (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;) overlap
   the current extent of the selected resource or that the set of ranges
   requested has been rejected due to invalid ranges or an excessive
   request of small or overlapping ranges.

   For byte ranges, failing to overlap the current extent means that the
   first-byte-pos of all of the byte-range-spec values were greater than
   the current length of the selected representation.  When this status
   code is generated in response to a byte-range request, the sender
   SHOULD generate a Content-Range header field specifying the current
   length of the selected representation (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;).

   For example:

     HTTP/1.1 416 Range Not Satisfiable
     Date: Fri, 20 Jan 2012 15:41:54 GMT
     Content-Range: bytes */47022

      Note: Because servers are free to ignore Range, many
      implementations will simply respond with the entire selected
      representation in a 200 (OK) response.  That is partly because
      most clients are prepared to receive a 200 (OK) to complete the
      task (albeit less efficiently) and partly because clients might
      not stop making an invalid partial request until they have
      received a complete representation.  Thus, clients cannot depend
      on receiving a 416 (Range Not Satisfiable) response even when it
      is most appropriate.</source>
          <target state="translated">Код состояния 416 (диапазон не удовлетворяется) указывает, что ни один из диапазонов в поле заголовка диапазона запроса ( &lt;a href=&quot;#section-3.1&quot;&gt;раздел 3.1&lt;/a&gt; ) не перекрывает текущий экстент выбранного ресурса или что запрошенный набор диапазонов был отклонен из-за недопустимых диапазонов или чрезмерного запрос малых или перекрывающихся диапазонов. Для диапазонов байтов отсутствие перекрытия текущего экстента означает, что первая позиция байта всех значений спецификации диапазона байтов была больше, чем текущая длина выбранного представления. Когда этот код состояния генерируется в ответ на запрос диапазона байтов, отправителю СЛЕДУЕТ сгенерировать поле заголовка Content-Range, указывающее текущую длину выбранного представления ( &lt;a href=&quot;#section-4.2&quot;&gt;раздел 4.2&lt;/a&gt;). Например: HTTP / 1.1 416 Range Not Satisfiable Date: Fri, 20 Jan 2012 15:41:54 GMT Content-Range: bytes * / 47022 Примечание: поскольку серверы могут игнорировать Range, многие реализации просто ответят всем выбранным представление в ответе 200 (ОК). Отчасти это связано с тем, что большинство клиентов готовы получить 200 (OK) для выполнения задачи (хотя и менее эффективно), а отчасти потому, что клиенты могут не прекратить делать недействительный частичный запрос, пока они не получат полное представление. Таким образом, клиенты не могут зависеть от получения ответа 416 (диапазон не удовлетворен), даже если он наиболее уместен.</target>
        </trans-unit>
        <trans-unit id="74e2689c2b2651176712bcca9c3464c338299fa4" translate="yes" xml:space="preserve">
          <source>The 417 (Expectation Failed) status code indicates that the
   expectation given in the request's Expect header field
   (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;) could not be met by at least one of the inbound
   servers.</source>
          <target state="translated">Код состояния 417 (Expectation Failed) указывает, что ожидание, указанное в поле заголовка Expect запроса ( &lt;a href=&quot;#section-5.1.1&quot;&gt;раздел 5.1.1&lt;/a&gt; ), не может быть выполнено по крайней мере одним из входящих серверов.</target>
        </trans-unit>
        <trans-unit id="3e7e0d5b09bdf010782a5ab49b88e3ef27b80255" translate="yes" xml:space="preserve">
          <source>The 421 (Misdirected Request) status code indicates that the request
   was directed at a server that is not able to produce a response.
   This can be sent by a server that is not configured to produce
   responses for the combination of scheme and authority that are
   included in the request URI. 

   Clients receiving a 421 (Misdirected Request) response from a server
   MAY retry the request -- whether the request method is idempotent or
   not -- over a different connection.  This is possible if a connection
   is reused (&lt;a href=&quot;#section-9.1.1&quot;&gt;Section 9.1.1&lt;/a&gt;) or if an alternative service is selected
   [&lt;a href=&quot;#ref-ALT-SVC&quot;&gt;ALT-SVC&lt;/a&gt;].

   This status code MUST NOT be generated by proxies.

   A 421 response is cacheable by default, i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240b1b41518b4e60c5fb369224ec2a4d545cd292" translate="yes" xml:space="preserve">
          <source>The 422 (Unprocessable Entity) status code means the server
   understands the content type of the request entity (hence a
   415(Unsupported Media Type) status code is inappropriate), and the
   syntax of the request entity is correct (thus a 400 (Bad Request)
   status code is inappropriate) but was unable to process the contained
   instructions.  For example, this error condition may occur if an XML
   request body contains well-formed (i.e., syntactically correct), but
   semantically erroneous, XML instructions.</source>
          <target state="translated">Код статуса 422 (Unprocessable Entity-Необрабатываемая сущность)означает,что сервер понимает тип содержимого сущности запроса (поэтому код статуса 415 (Unsupported Media Type-Неподдерживаемый тип носителя)неуместен),и синтаксис сущности запроса корректен (таким образом,код статуса 400 (Bad Request-Плохой запрос)неуместен),но не смог обработать содержащиеся в нем инструкции.Например,такое состояние ошибки может возникнуть,если XML-тело запроса содержит хорошо сформированные (т.е.синтаксически корректные),но семантически ошибочные XML-инструкции.</target>
        </trans-unit>
        <trans-unit id="ab7728b25333c3ed3e9c44c0ad08c1c5736966a3" translate="yes" xml:space="preserve">
          <source>The 423 (Locked) status code means the source or destination resource
   of a method is locked.  This response SHOULD contain an appropriate
   precondition or postcondition code, such as 'lock-token-submitted' or
   'no-conflicting-lock'.</source>
          <target state="translated">Код статуса 423 (Заблокирован)означает,что ресурс-источник или ресурс-получатель метода заблокирован.Этот ответ SHOULD содержит соответствующее предусловие или код постусловия,например,'lock-token-submitted' или 'no-conflicting-lock'.</target>
        </trans-unit>
        <trans-unit id="7bea7308e120efd626a2dea25e346d82459c7846" translate="yes" xml:space="preserve">
          <source>The 424 (Failed Dependency) status code means that the method could
   not be performed on the resource because the requested action
   depended on another action and that action failed.  For example, if a
   command in a PROPPATCH method fails, then, at minimum, the rest of
   the commands will also fail with 424 (Failed Dependency).</source>
          <target state="translated">Код статуса 424 (Failed Dependency)означает,что метод не мог быть выполнен в отношении ресурса,потому что запрашиваемое действие зависело от другого действия,и это действие было неудачным.Например,если команда в методе PROPPATCH не работает,то,как минимум,остальные команды также не работают с 424 (Failed Dependency-Неудачная зависимость).</target>
        </trans-unit>
        <trans-unit id="bbb046d45cb07e647735e9643ff8b2d8aa6d1cf5" translate="yes" xml:space="preserve">
          <source>The 426 (Upgrade Required) status code indicates that the server
   refuses to perform the request using the current protocol but might
   be willing to do so after the client upgrades to a different
   protocol.  The server MUST send an Upgrade header field in a 426
   response to indicate the required protocol(s) (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Section&amp;nbsp;6.7 of
   [RFC7230]&lt;/a&gt;).

   Example:

     HTTP/1.1 426 Upgrade Required
     Upgrade: HTTP/3.0
     Connection: Upgrade
     Content-Length: 53
     Content-Type: text/plain

     This service requires use of the HTTP/3.0 protocol.</source>
          <target state="translated">Код состояния 426 (требуется обновление) указывает на то, что сервер отказывается выполнять запрос с использованием текущего протокола, но может быть готов сделать это после того, как клиент перейдет на другой протокол. Сервер ДОЛЖЕН отправить поле заголовка Upgrade в ответе 426, чтобы указать требуемый протокол (ы) ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;раздел 6.7 [RFC7230]&lt;/a&gt; ). Пример: HTTP / 1.1 426 Требуется обновление Обновление: HTTP / 3.0 Соединение: Обновление Content-Length: 53 Content-Type: text / plain Эта служба требует использования протокола HTTP / 3.0.</target>
        </trans-unit>
        <trans-unit id="ff18add20b8f554c457e49bc2e7ce8d714901464" translate="yes" xml:space="preserve">
          <source>The 4xx (Client Error) class of status code indicates that the client
   seems to have erred.  Except when responding to a HEAD request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition.  These status codes are applicable to any request method.
   User agents SHOULD display any included representation to the user.</source>
          <target state="translated">Код статуса класса 4xx (Client Error)указывает на то,что клиент,похоже,ошибся.За исключением ответа на запрос HEAD,сервер ДОЛЖЕН отправить представление,содержащее объяснение ситуации с ошибкой,и является ли это временным или постоянным состоянием.Эти коды статуса применимы к любому методу запроса.Пользовательские агенты SHOULD отображают любое включенное представление пользователю.</target>
        </trans-unit>
        <trans-unit id="0c2a74d9f06b0a77075195702a5230a67673de95" translate="yes" xml:space="preserve">
          <source>The 4xx class of status code is intended for cases in which the
   client seems to have erred. Except when responding to a HEAD request,
   the server SHOULD include an entity containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition. These status codes are applicable to any request method.
   User agents SHOULD display any included entity to the user.

   If the client is sending data, a server implementation using TCP
   SHOULD be careful to ensure that the client acknowledges receipt of
   the packet(s) containing the response, before the server closes the
   input connection. If the client continues sending data to the server
   after the close, the server's TCP stack will send a reset packet to
   the client, which may erase the client's unacknowledged input buffers
   before they can be read and interpreted by the HTTP application.</source>
          <target state="translated">Статусный код класса 4xx предназначен для случаев,в которых клиент,похоже,ошибся.За исключением ответа на запрос HEAD,сервер SHOULD включает в себя сущность,содержащую объяснение ситуации ошибки,и является ли она временным или постоянным состоянием.Эти коды статуса применимы к любому методу запроса.Пользовательские агенты SHOULD отображают любую включенную сущность пользователю.Если клиент посылает данные,то при реализации сервера с использованием TCP SHOULD необходимо убедиться,что клиент подтверждает получение пакета(ов),содержащего(их)ответ,до того,как сервер закроет входное соединение.Если клиент продолжает посылать данные на сервер после закрытия,серверный TCP-стек посылает клиенту пакет сброса,который может стереть непризнанные входные буферы клиента до того,как они будут прочитаны и интерпретированы HTTP-приложением.</target>
        </trans-unit>
        <trans-unit id="e4172cee002fab51d59cbb6c27d459c5303764c9" translate="yes" xml:space="preserve">
          <source>The 500 (Internal Server Error) status code indicates that the server
   encountered an unexpected condition that prevented it from fulfilling
   the request.</source>
          <target state="translated">Код состояния 500 (Ошибка внутреннего сервера)указывает на то,что сервер столкнулся с неожиданным состоянием,которое не позволило ему выполнить запрос.</target>
        </trans-unit>
        <trans-unit id="5e788aee762bb64f07dea7e2e3b12cc4a6d5e7c2" translate="yes" xml:space="preserve">
          <source>The 501 (Not Implemented) status code indicates that the server does
   not support the functionality required to fulfill the request.  This
   is the appropriate response when the server does not recognize the
   request method and is not capable of supporting it for any resource.

   A 501 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Код состояния 501 (не реализовано) указывает, что сервер не поддерживает функции, необходимые для выполнения запроса. Это подходящий ответ, когда сервер не распознает метод запроса и не может поддерживать его для какого-либо ресурса. По умолчанию ответ 501 кэшируется; то есть, если иное не указано в определении метода или явных элементах управления кешем (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;раздел 4.2.2 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="537a3dde972341b94cbb072093d8857e86b4614a" translate="yes" xml:space="preserve">
          <source>The 502 (Bad Gateway) status code indicates that the server, while
   acting as a gateway or proxy, received an invalid response from an
   inbound server it accessed while attempting to fulfill the request.</source>
          <target state="translated">Код состояния 502 (Плохой шлюз)указывает,что сервер,действуя в качестве шлюза или прокси-сервера,получил неверный ответ от входящего сервера,к которому он обращался при попытке выполнить запрос.</target>
        </trans-unit>
        <trans-unit id="6bbdd751ae4429ec4369780a1676c0e2b99f0f2f" translate="yes" xml:space="preserve">
          <source>The 503 (Service Unavailable) status code indicates that the server
   is currently unable to handle the request due to a temporary overload
   or scheduled maintenance, which will likely be alleviated after some
   delay.  The server MAY send a Retry-After header field
   (&lt;a href=&quot;#section-7.1.3&quot;&gt;Section 7.1.3&lt;/a&gt;) to suggest an appropriate amount of time for the
   client to wait before retrying the request.

      Note: The existence of the 503 status code does not imply that a
      server has to use it when becoming overloaded.  Some servers might
      simply refuse the connection.</source>
          <target state="translated">Код состояния 503 (служба недоступна) указывает на то, что сервер в настоящее время не может обработать запрос из-за временной перегрузки или планового обслуживания, которые, вероятно, будут устранены после некоторой задержки. Сервер МОЖЕТ отправить поле заголовка Retry-After ( &lt;a href=&quot;#section-7.1.3&quot;&gt;раздел 7.1.3&lt;/a&gt; ), чтобы предложить клиенту соответствующее время ожидания перед повторной попыткой запроса. Примечание. Наличие кода состояния 503 не означает, что сервер должен использовать его при перегрузке. Некоторые серверы могут просто отказать в соединении.</target>
        </trans-unit>
        <trans-unit id="cb5a6e6224a6befed044cf459ac3ad6b9a312b3f" translate="yes" xml:space="preserve">
          <source>The 504 (Gateway Timeout) status code indicates that the server,
   while acting as a gateway or proxy, did not receive a timely response
   from an upstream server it needed to access in order to complete the
   request.</source>
          <target state="translated">Код состояния 504 (Gateway Timeout)указывает на то,что сервер,действуя в качестве шлюза или прокси-сервера,не получил своевременного ответа от сервера,к которому он должен был получить доступ для завершения запроса.</target>
        </trans-unit>
        <trans-unit id="73dde1c42105fdf2e1da6b5ec6f32547fa21c1f6" translate="yes" xml:space="preserve">
          <source>The 505 (HTTP Version Not Supported) status code indicates that the
   server does not support, or refuses to support, the major version of
   HTTP that was used in the request message.  The server is indicating
   that it is unable or unwilling to complete the request using the same
   major version as the client, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.6&quot;&gt;Section&amp;nbsp;2.6 of
   [RFC7230]&lt;/a&gt;, other than with this error message.  The server SHOULD
   generate a representation for the 505 response that describes why
   that version is not supported and what other protocols are supported
   by that server.</source>
          <target state="translated">Код состояния 505 (версия HTTP не поддерживается) указывает, что сервер не поддерживает или отказывается поддерживать основную версию HTTP, которая использовалась в сообщении запроса. Сервер указывает, что он не может или не хочет выполнить запрос, используя ту же основную версию, что и клиент, как описано в &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.6&quot;&gt;разделе 2.6 [RFC7230]&lt;/a&gt; , за исключением этого сообщения об ошибке. Серверу СЛЕДУЕТ генерировать представление для ответа 505, которое описывает, почему эта версия не поддерживается, и какие другие протоколы поддерживаются этим сервером.</target>
        </trans-unit>
        <trans-unit id="6cfe58d6c6aa1b9a0d0a3a747564d201b045f349" translate="yes" xml:space="preserve">
          <source>The 507 (Insufficient Storage) status code means the method could not
   be performed on the resource because the server is unable to store
   the representation needed to successfully complete the request.  This
   condition is considered to be temporary.  If the request that
   received this status code was the result of a user action, the
   request MUST NOT be repeated until it is requested by a separate user
   action.</source>
          <target state="translated">Код статуса 507 (Недостаточное хранение)означает,что метод не может быть выполнен на ресурсе,так как сервер не может хранить представление,необходимое для успешного завершения запроса.Это условие считается временным.Если запрос,получивший такой код статуса,является результатом действия пользователя,то запрос НЕ ДОЛЖЕН повторяться до тех пор,пока не будет запрошен отдельным действием пользователя.</target>
        </trans-unit>
        <trans-unit id="0e2021f09cffdfd7e8e3c2b6e4af6afc876e3ba4" translate="yes" xml:space="preserve">
          <source>The 511 status code indicates that the client needs to authenticate to gain network access.</source>
          <target state="translated">Код состояния 511 указывает,что для получения доступа к сети клиенту необходимо пройти аутентификацию.</target>
        </trans-unit>
        <trans-unit id="6f13f00eed6e2731f85266d4d2b5d1b194f1dc69" translate="yes" xml:space="preserve">
          <source>The 5xx (Server Error) class of status code indicates that the server
   is aware that it has erred or is incapable of performing the
   requested method.  Except when responding to a HEAD request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent 

   condition.  A user agent SHOULD display any included representation
   to the user.  These response codes are applicable to any request
   method.</source>
          <target state="translated">Класс 5xx (Server Error)кода статуса указывает на то,что сервер знает,что он ошибся или не способен выполнить запрошенный метод.За исключением ответа на запрос HEAD,сервер ДОЛЖЕН посылать представление,содержащее объяснение ситуации ошибки,и является ли это временным или постоянным состоянием.Пользовательский агент SHOULD выводит на экран любое включенное представление.Эти коды ответа применимы к любому методу запроса.</target>
        </trans-unit>
        <trans-unit id="eff8921ecde9859824b0aa4a316363853f77725f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../index&quot;&gt;HTTP&lt;/a&gt;&lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8981236cb35a3546e80d22d9775227a98e95ef1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME type&lt;/a&gt; of the resource or the data.</source>
          <target state="translated">Тип &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME&lt;/a&gt; ресурса или данных.</target>
        </trans-unit>
        <trans-unit id="476cfd9f7f7d09d394f8e2d140063c4110e761fd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header tells the server that when the actual request is sent, it will have the &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11aa0c02b1fe58d03a5cb415bbf783776721cd3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; header sent in the preflight request tells the server that when the actual request is sent, it will have a &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee0f2cff0fd1a73153d67243f177de87af10640" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; HTTP header.</source>
          <target state="translated">&lt;a href=&quot;../headers/feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; HTTP заголовка.</target>
        </trans-unit>
        <trans-unit id="1495070845bb0ae9175f95e2e4b9163ee31037e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; URL is too long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3221539e7878d032dbdd4035adad83f822b0aa1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header will be omitted entirely. No referrer information is sent along with requests.</source>
          <target state="translated">&lt;a href=&quot;../referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; заголовок будет полностью опущен. Информация о реферере не отправляется вместе с запросами.</target>
        </trans-unit>
        <trans-unit id="e873c7c4f23e96331a7b10f6fab0e72d0c3815f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header needs to be set to &quot;keep-alive&quot; for this header to have any meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823cc49a67542bdec9a4ef4d6b1e415d7aeb3b04" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header needs to be set to &quot;keep-alive&quot; for this header to have any meaning. Also, &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt; are ignored in HTTP/2; connection management is handled by other mechanisms there.</source>
          <target state="translated">В &lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; потребности заголовок должен быть установлен в &amp;laquo;Keep-Alive&amp;raquo; для этого заголовка , чтобы иметь какое - либо значение. Также в HTTP / 2 игнорируются &lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt; ; там управление подключением осуществляется другими механизмами.</target>
        </trans-unit>
        <trans-unit id="28e20ae8f53246c900d9de361122fb549b4a54cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header with type &lt;code&gt;upgrade&lt;/code&gt; must &lt;em&gt;always&lt;/em&gt; be sent with the &lt;code&gt;Upgrade&lt;/code&gt; header (as shown above).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3168c5253229cb7eddd39a17b55204a0719f1ccb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; defining the boundary of the multipart body.</source>
          <target state="translated">&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; определение границы многочастного тела.</target>
        </trans-unit>
        <trans-unit id="c285a5fb007b2a2d826d7bbfcdc526294f9f38d5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt; header is defined by the browser, or any other user-agent, and can vary according to the context, like fetching an HTML page or an image, a video, or a script: It is different when fetching a document entered in the address bar or an element linked via an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; element. Browsers are free to use the value of the header that they think is the most adequate; an exhaustive list of &lt;a href=&quot;content_negotiation/list_of_default_accept_values&quot;&gt;default values for common browsers&lt;/a&gt; is available.</source>
          <target state="translated">&lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; заголовок определяется браузером или любого другим агентом пользователя, и может варьироваться в зависимости от контекста, как извлечение страницы HTML или изображения, видео или сценария: Он отличается при выборке документ вступил в адресная строка или элемент, связанный с помощью элемента &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; . Браузеры могут свободно использовать значение заголовка, которое они считают наиболее подходящим; доступен исчерпывающий список &lt;a href=&quot;content_negotiation/list_of_default_accept_values&quot;&gt;значений по умолчанию для распространенных браузеров&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb614dd01dd7b5c3319f1fa867383facbd91a1a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt; header lists the MIME types of media resources that the agent is willing to process. It is comma-separated lists of MIME types, each combined with a quality factor, a parameter indicating the relative degree of preference between the different MIME types.</source>
          <target state="translated">В заголовке &lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; перечислены MIME-типы медиаресурсов, которые агент готов обрабатывать. Это списки типов MIME, разделенных запятыми, каждый из которых объединен с коэффициентом качества, параметром, указывающим относительную степень предпочтения между различными типами MIME.</target>
        </trans-unit>
        <trans-unit id="47c1d1550663e7b9840b652f6ba1f6059d00bdc3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-ch-lifetime&quot;&gt;&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt;&lt;/a&gt; header is used with the &lt;code&gt;Device-Memory&lt;/code&gt; value of the &lt;code&gt;Accept-CH&lt;/code&gt; header and indicates the amount of time the device should opt-in to sharing the amount of device memory with the server. The value is given in miliseconds and it's use is optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ac9e88d286f1a089252d01c7518ad33d10efe4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt; header indicates to the server what kinds of character encodings are understood by the user-agent. Traditionally, it was set to a different value for each locale for the browser, like &lt;code&gt;ISO-8859-1,utf-8;q=0.7,*;q=0.7&lt;/code&gt; for a Western European locale.</source>
          <target state="translated">&lt;a href=&quot;headers/accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt; заголовок указывает серверу , какие кодировки символов понятны агента пользователя. Традиционно для каждого языкового стандарта браузера было установлено другое значение, например &lt;code&gt;ISO-8859-1,utf-8;q=0.7,*;q=0.7&lt;/code&gt; для западноевропейского языкового стандарта.</target>
        </trans-unit>
        <trans-unit id="cac90f4ab93dcb579a645e89e4735bc55952622d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; header defines the acceptable content-encoding (supported compressions). The value is a q-factor list (e.g.: &lt;code&gt;br, gzip;q=0.8&lt;/code&gt;) that indicates the priority of the encoding values. The default value &lt;code&gt;identity&lt;/code&gt; is at the lowest priority (unless otherwise declared).</source>
          <target state="translated">&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; заголовок определяет приемлемый контент-кодирование (поддерживаются сжатия). Значение представляет собой список q-факторов (например: &lt;code&gt;br, gzip;q=0.8&lt;/code&gt; ), который указывает приоритет значений кодирования. Значение по умолчанию &lt;code&gt;identity&lt;/code&gt; является самым низким приоритетом (если иное не заявлено).</target>
        </trans-unit>
        <trans-unit id="1da487f47873fc85841849fa6ec975c0f7e1eb16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt; header is used to indicate the language preference of the user. It is a list of values with quality factors (like: &lt;code&gt;&quot;de, en;q=0.7&lt;/code&gt;&quot;). A default value is often set according the language of the graphical interface of the user agent, but most browsers allow to set different language preferences.</source>
          <target state="translated">&lt;a href=&quot;headers/accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; заголовок используется для обозначения языка предпочтения пользователя. Это список значений с коэффициентами качества (например: &lt;code&gt;&quot;de, en;q=0.7&lt;/code&gt; &amp;raquo;). Значение по умолчанию часто устанавливается в соответствии с языком графического интерфейса пользовательского агента, но большинство браузеров позволяют устанавливать различные языковые предпочтения.</target>
        </trans-unit>
        <trans-unit id="5e7674c7262d6464316098c5b65d3d21f6faacd3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt; header Indicates whether or not the response to the request can be exposed when the &lt;code&gt;credentials&lt;/code&gt; flag is true. When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. Note that simple &lt;code&gt;GET&lt;/code&gt; requests are not preflighted, and so if a request is made for a resource with credentials, if this header is not returned with the resource, the response is ignored by the browser and not returned to web content.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; заголовка Указывает , является ли ответ на запрос может быть открыта , когда &lt;code&gt;credentials&lt;/code&gt; флаг верно. При использовании как часть ответа на предварительный запрос, это указывает, может ли фактический запрос быть выполнен с использованием учетных данных. Обратите внимание, что простые запросы &lt;code&gt;GET&lt;/code&gt; не выполняются заранее, и поэтому, если запрос сделан для ресурса с учетными данными, если этот заголовок не возвращается с ресурсом, ответ игнорируется браузером и не возвращается веб-контенту.</target>
        </trans-unit>
        <trans-unit id="fb5022c494946ba6c712c71a1fbc929d4a279c00" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; header is used in response to a &lt;a href=&quot;#Preflighted_requests&quot;&gt;preflight request&lt;/a&gt; to indicate which HTTP headers can be used when making the actual request.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt; заголовок используется в ответ на &lt;a href=&quot;#Preflighted_requests&quot;&gt;предполетной просьбу&lt;/a&gt; указать , какие HTTP заголовки могут быть использованы при выполнении фактического запроса.</target>
        </trans-unit>
        <trans-unit id="47e57affccad38127a20bce8c3436539e88c6c38" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header specifies the method or methods allowed when accessing the resource. This is used in response to a preflight request. The conditions under which a request is preflighted are discussed above.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; заголовок определяет метод или методы , разрешенные при обращении к ресурсу. Это используется в ответ на предполетный запрос. Условия, при которых выполняется предварительная проверка запроса, описаны выше.</target>
        </trans-unit>
        <trans-unit id="4527c593b9686c403ce7ee6942811c00a0260ae5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-expose-headers&quot;&gt;&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;&lt;/a&gt; header lets a server whitelist headers that Javascript (such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getResponseHeader&quot;&gt;&lt;code&gt;getResponseHeader()&lt;/code&gt;&lt;/a&gt;) in browsers are allowed to access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7542b9c473bf75e6b574a96c6ca9ae6b946296" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-expose-headers&quot;&gt;&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;&lt;/a&gt; header lets a server whitelist headers that browsers are allowed to access. For example:</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-expose-headers&quot;&gt; &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; &lt;/a&gt; заголовок позволяет серверу белый список заголовков , которые браузеры разрешен доступ. Например:</target>
        </trans-unit>
        <trans-unit id="0c96e27b026e07ddc3f2931ff6f47daf2922b214" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-max-age&quot;&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;&lt;/a&gt; header indicates how long the results of a preflight request can be cached. For an example of a preflight request, see the above examples.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-max-age&quot;&gt; &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; &lt;/a&gt; заголовок указывает на то, как долго можно кэшировать результаты предполетного запроса. Пример запроса предварительной проверки см. В примерах выше.</target>
        </trans-unit>
        <trans-unit id="b00b4f03e257f3dbfb1f8d0d5cf818265cd59e8a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header is used when issuing a preflight request to let the server know what HTTP headers will be used when the actual request is made.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; заголовок используется при выдаче предполетной запрос , чтобы позволить ноу - сервера , что HTTP заголовки будут использоваться , когда фактический запрос был сделан.</target>
        </trans-unit>
        <trans-unit id="691c99e3378023d77080d83aad7e1e58d0aa3326" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; header notifies the server as part of a preflight request that when the actual request is sent, it will be sent with a &lt;code&gt;POST&lt;/code&gt; request method. The &lt;a href=&quot;headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header notifies the server that when the actual request is sent, it will be sent with a &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; custom headers. The server now has an opportunity to determine whether it wishes to accept a request under these circumstances.</source>
          <target state="translated">В &lt;a href=&quot;headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt; оповещает заголовок сервер в качестве части предполетной просьбы о том , когда фактический запрос отправляется, он будет отправлен с &lt;code&gt;POST&lt;/code&gt; методом запроса. В &lt;a href=&quot;headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; оповещает заголовок сервера , на котором , когда фактический запрос отправляется, он будет отправлен с &lt;code&gt;X-PINGOTHER&lt;/code&gt; и &lt;code&gt;Content-Type&lt;/code&gt; пользовательских заголовков. Теперь у сервера есть возможность определить, желает ли он принять запрос в этих обстоятельствах.</target>
        </trans-unit>
        <trans-unit id="00e93481fc61267674621b1c977f194bc75b6c9a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; is used when issuing a preflight request to let the server know what HTTP method will be used when the actual request is made.</source>
          <target state="translated">Метод &lt;a href=&quot;headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt; используется при выдаче предполетного запроса, чтобы сервер знал, какой HTTP-метод будет использован при выполнении фактического запроса.</target>
        </trans-unit>
        <trans-unit id="7fbe0c67984080abcf5fba23225ff8d88603f4f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request headers contain the credentials to authenticate a user agent with a (proxy) server. Here, the &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is needed again followed by the credentials, which can be encoded or encrypted depending on which authentication scheme is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32735ad57de0b36b9cb875eb26ae77710d7487d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request headers contain the credentials to authenticate a user agent with a (proxy) server. Here, the type is needed again followed by the credentials, which can be encoded or encrypted depending on which authentication scheme is used.</source>
          <target state="translated">В &lt;a href=&quot;headers/authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; заголовки запроса содержат учетные данные для аутентификации агента пользователя с сервером (прокси). Здесь снова требуется тип, за которым следуют учетные данные, которые могут быть закодированы или зашифрованы в зависимости от того, какая схема аутентификации используется.</target>
        </trans-unit>
        <trans-unit id="53e54b41889fb412304c339ba63b0b1d28f93d5d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; HTTP/1.1 general-header field is used to specify directives for caching mechanisms in both requests and responses. Use this header to define your caching policies with the variety of directives it provides.</source>
          <target state="translated">Поле общего заголовка &lt;a href=&quot;headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; HTTP / 1.1 используется для указания директив для механизмов кэширования как в запросах, так и в ответах. Используйте этот заголовок, чтобы определить свою политику кэширования с помощью множества предоставляемых им директив.</target>
        </trans-unit>
        <trans-unit id="7095083b873f36d44191b5aa9a6bd5c7f44c8102" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header now indicates the size of the requested range (and not the full size of the image). The &lt;a href=&quot;headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; response header indicates where in the full resource this partial message belongs.</source>
          <target state="translated">&lt;a href=&quot;headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; заголовка теперь указывает размер запрашиваемого диапазона (и не полный размер изображения). &lt;a href=&quot;headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; заголовка ответа указывает на то, где в полном ресурсе принадлежит это частичное сообщение.</target>
        </trans-unit>
        <trans-unit id="373e10b1138008b081311180730e472ee8b5d4d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; response header fields allows web site administrators to control resources the user agent is allowed to load for a given page. With a few exceptions, policies mostly involve specifying server origins and script endpoints.</source>
          <target state="translated">В &lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; поля заголовка ответа позволяет администраторам веб - сайта для управления ресурсами агент пользователю разрешено нагрузки для данной страницы. За некоторыми исключениями, политики в основном включают указание источников сервера и конечных точек сценария.</target>
        </trans-unit>
        <trans-unit id="b9fe6d801fee6375976ebc4e32f720967639b006" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; response header is an &lt;em&gt;opaque-to-the-useragent&lt;/em&gt; value that can be used as a strong validator. That means that a HTTP user-agent, such as the browser, does not know what this string represents and can't predict what its value would be. If the &lt;code&gt;ETag&lt;/code&gt; header was part of the response for a resource, the client can issue an &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; in the header of future requests &amp;ndash; in order to validate the cached resource.</source>
          <target state="translated">&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; заголовок ответа является &lt;em&gt;непрозрачным-к-UserAgent&lt;/em&gt; значение , которое может быть использовано в качестве сильного валидатора. Это означает, что пользовательский агент HTTP, такой как браузер, не знает, что представляет собой эта строка, и не может предсказать, каким будет ее значение. Если заголовок &lt;code&gt;ETag&lt;/code&gt; был частью ответа для ресурса, клиент может выдать &lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; в заголовке будущих запросов - для проверки кэшированного ресурса.</target>
        </trans-unit>
        <trans-unit id="cc825b2410b4df4739e11c71f412ef7ef377ba8f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; HTTP header.</source>
          <target state="translated">&lt;a href=&quot;headers/feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; HTTP заголовка.</target>
        </trans-unit>
        <trans-unit id="02c9a22613e0a52af16dfd3143868970cb39f043" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt; HTTP request header makes a range request conditional: if the condition is fulfilled, the range request will be issued and the server sends back a &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status. This header can be used either with a &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; validator, or with an &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but not with both.</source>
          <target state="translated">&lt;a href=&quot;headers/if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt; заголовок запроса HTTP делает запрос диапазона условно: если условие выполняется, то запрос на диапазон будет выдан и сервер отправляет обратно &lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; ответа с соответствующим органом. Если условие не выполняется, возвращается полный ресурс со статусом &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; . Этот заголовок может использоваться либо с валидатором &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; , либо с &lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; , но не с обоими.</target>
        </trans-unit>
        <trans-unit id="590a84433585d18f20730243da1b6a8953716c09" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; response header can be used as a weak validator. It is considered weak because it only has 1-second resolution. If the &lt;code&gt;Last-Modified&lt;/code&gt; header is present in a response, then the client can issue an &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; request header to validate the cached document.</source>
          <target state="translated">&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; заголовок ответа может быть использован в качестве слабого валидатора. Он считается слабым, потому что имеет разрешение всего 1 секунду. Если в ответе присутствует заголовок &lt;code&gt;Last-Modified&lt;/code&gt; , то клиент может выдать заголовок запроса &lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; для проверки кэшированного документа.</target>
        </trans-unit>
        <trans-unit id="9a00311ebb7587989dbe59dcf3d642597bd57cd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header indicates the origin of the cross-site access request or preflight request.</source>
          <target state="translated">&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; заголовка указывает происхождение запроса доступа межсайтовому или предполетной запрос.</target>
        </trans-unit>
        <trans-unit id="00410abbfb65785de4501043b5495b885e06221c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header also allows you to get multiple ranges at once in a multipart document. The ranges are separated by a comma.</source>
          <target state="translated">&lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; заголовка также позволяет получить несколько диапазонов сразу в нескольких частей документа. Диапазоны разделяются запятой.</target>
        </trans-unit>
        <trans-unit id="86f95f2219b451868ec50ea455d93d73adebbf1e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; HTTP response header sends cookies from the server to the user agent. A simple cookie is set like this:</source>
          <target state="translated">&lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; заголовка ответа HTTP , посылает куки с сервера агента пользователя. Простой файл cookie устанавливается следующим образом:</target>
        </trans-unit>
        <trans-unit id="af75cb2c0da0fe81a5535d484eb290c4bd4d639e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header allows chunked encoding, which is useful when larger amounts of data are sent to the client and the total size of the response is not known until the request has been fully processed. The server sends data to the client straight away without buffering the response or determining the exact length, which leads to improved latency. Range requests and chunking are compatible and can be used with or without each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7f353f47a7491fd7a18b5bc1a1b46d2745b86d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header allows chunked encoding, which useful when larger amounts of data are sent to the client and the total size of the response is not known until the request has been fully processed. The server sends data to the client straight away without buffering the response or determining the exact length, which leads to improved latency. Range requests and chunking are compatible and can be used with or without each other.</source>
          <target state="translated">&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; заголовок позволяет блочное кодирование, которое полезно , когда большие объемы данных , отправляемый клиенту и общего размеру ответа не известно , пока запрос был полностью обработан. Сервер сразу отправляет данные клиенту, не буферизуя ответ и не определяя точную длину, что приводит к уменьшению задержки. Запросы диапазона и разбиение на части совместимы и могут использоваться друг с другом или без него.</target>
        </trans-unit>
        <trans-unit id="427718e5d2f07133480270391026fe30a80122e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; header identifies the browser sending the request. This string may contain a space-separated list of &lt;em&gt;product tokens&lt;/em&gt; and &lt;em&gt;comments&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; заголовок идентифицирует браузер отправляет запрос. Эта строка может содержать разделенный пробелами список &lt;em&gt;токенов продукта&lt;/em&gt; и &lt;em&gt;комментариев&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1e0b7713d148829012c4c472ea954c0d5574cc79" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</source>
          <target state="translated">&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; HTTP - заголовок ответа определяет , как соответствовать запросу в будущем заголовков , чтобы решить , можно ли использовать в кэше ответ , а не запрашивать свежую один из исходного сервера.</target>
        </trans-unit>
        <trans-unit id="b1d4a413436104711d19f9e2f2ce3b22dd6fa9fb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used, or if a fresh one must be requested from the origin server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8e8fc45b5f4468eb6609ffd5ad8cb0e64e2e51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response headers define the authentication method that should be used to gain access to a resource. They must specify which authentication scheme is used, so that the client that wishes to authorize knows how to provide the credentials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f41cb2e8943b80c1ccc9757d2185689ead0a50" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response headers define the authentication method that should be used to gain access to a resource. They need to specify which authentication scheme is used, so that the client that wishes to authorize knows how to provide the credentials. The syntax for these headers is the following:</source>
          <target state="translated">В &lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; заголовков ответа определяют метод проверки подлинности , который должен использоваться для получения доступа к ресурсу. Им необходимо указать, какая схема аутентификации используется, чтобы клиент, желающий авторизоваться, знал, как предоставить учетные данные. Синтаксис этих заголовков следующий:</target>
        </trans-unit>
        <trans-unit id="841a5f97046d98851a68c9d87ead02d585e0efda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; request header field as received by the proxy.</source>
          <target state="translated">Поле заголовка запроса &lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; полученное прокси.</target>
        </trans-unit>
        <trans-unit id="90ae0d5ac939ab22b89ef22ef6cf0f70a90df9a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt; module can also be used to create redirects. It is more flexible, but a bit more complex to use.</source>
          <target state="translated">Модуль &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt; также можно использовать для создания перенаправлений. Он более гибкий, но немного сложнее в использовании.</target>
        </trans-unit>
        <trans-unit id="575f2f642c54dbd7133186d28418d1c27eaa5d6f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes/http-warn-codes.xhtml&quot;&gt;HTTP Warn Codes registry at iana.org&lt;/a&gt; defines the namespace for warn codes.</source>
          <target state="translated">&lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes/http-warn-codes.xhtml&quot;&gt;HTTP Предупреждать коды реестра в iana.org&lt;/a&gt; определяет пространство имен для предупредят коды.</target>
        </trans-unit>
        <trans-unit id="8df2d67e805aa2c79e4d6afb765f67e048353741" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://blogs.msdn.microsoft.com/ie/2008/09/02/ie8-security-part-vi-beta-2-update/&quot;&gt;original definition&lt;/a&gt; of X-Content-Type-Options by Microsoft.</source>
          <target state="translated">&lt;a href=&quot;https://blogs.msdn.microsoft.com/ie/2008/09/02/ie8-security-part-vi-beta-2-update/&quot;&gt;Первоначальное определение&lt;/a&gt; рентгеновских Content-Type-Options Майкрософт.</target>
        </trans-unit>
        <trans-unit id="b6bb44a38f57a4a24a21a54355c1172f452d3808" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ALPN&quot;&gt;ALPN&lt;/a&gt; protocol identifier. Examples include h2 for HTTP/2 and h3-25 for draft 25 of the HTTP/3 protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="303a7ca8e087b00d9976db8accc4e29108a04169" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request requires preflight, preflighting could not be performed. There are a couple of reasons why preflighting might fail:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; запрос требует предполетной, предпечатной проверки не может быть выполнена. Есть несколько причин, по которым предварительная проверка может не работать:</target>
        </trans-unit>
        <trans-unit id="0ac1bdf745446afae63eab40c6dbfdebac045663" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request requires that the server permit the use of credentials, but the server's &lt;a href=&quot;../../headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt; header's value isn't set to &lt;code&gt;true&lt;/code&gt; to enable their use.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; запрос требует, чтобы сервер разрешает использование учетных данных, но сервера &lt;a href=&quot;../../headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; , значение заголовка не установлен , чтобы &lt;code&gt;true&lt;/code&gt; для обеспечения возможности их использования.</target>
        </trans-unit>
        <trans-unit id="a3fef220d846f02c9cfee24670814beeba7e7355" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request was attempted with the credentials flag set, but the server is configured using the wildcard (&lt;code&gt;&quot;*&quot;&lt;/code&gt;) as the value of &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;, which doesn't allow the use of credentials.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; запрос был предпринят с набором учетных данных флага, но сервер настроен с помощью подстановки ( &lt;code&gt;&quot;*&quot;&lt;/code&gt; ) в качестве значения &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; , которая не позволяет использовать учетные данные.</target>
        </trans-unit>
        <trans-unit id="94840953c7f31c8c81ed2848ad9300fdfc9d44eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request was responded to by the server with an HTTP redirect to a URL on a different origin than the original request, which is not permitted during CORS requests.</source>
          <target state="translated">На запрос &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; сервер ответил перенаправлением HTTP на URL-адрес из источника, отличного от исходного запроса, что не разрешено во время запросов CORS.</target>
        </trans-unit>
        <trans-unit id="46ef7b51d18c11a16b9ea7877d2ee5b389add21e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; request which makes use of CORS failed because the HTTP connection failed at either the network or protocol level. The error is not directly related to CORS, but is a fundamental network error of some kind.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; запрос , который использует CO не удался , так как соединение HTTP потерпело неудачу в любой сети или на уровне протокола. Ошибка не связана напрямую с CORS, но является какой-то фундаментальной сетевой ошибкой.</target>
        </trans-unit>
        <trans-unit id="77ebeb340729beee4023ffdb21e08feae0d716a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; to apply to that option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca3dd995c40f4f12da6eea0a0fb62e8d5df0822" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_header&quot;&gt;simple headers&lt;/a&gt;, &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; (but only with a MIME type of its parsed value (ignoring parameters) of either &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain&lt;/code&gt;), are always available and don't need to be listed by this header.</source>
          <target state="translated">Эти &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_header&quot;&gt;простые заголовки&lt;/a&gt; , &lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; (но только с типом MIME , его разобранного значения ( без учета параметров) либо &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; , &lt;code&gt;multipart/form-data&lt;/code&gt; , или &lt;code&gt;text/plain&lt;/code&gt; ) всегда доступны и не должны указываться в этом заголовке.</target>
        </trans-unit>
        <trans-unit id="7c8c624b902acbdfb33352d81eeb9f16044ff38e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; was unable to add the required &lt;a href=&quot;../../headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; request. All CORS requests must have an &lt;code&gt;Origin&lt;/code&gt; header.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;Агент пользователя&lt;/a&gt; не удалось добавить нужный &lt;a href=&quot;../../headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; заголовок в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; - запросе. Все запросы CORS должны иметь заголовок &lt;code&gt;Origin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="541849bca8dfcb4810abe650d5548422c6848655" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FormData&quot;&gt;&lt;code&gt;FormData&lt;/code&gt;&lt;/a&gt; interface used to manipulate form data for use in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FormData&quot;&gt; &lt;code&gt;FormData&lt;/code&gt; ,&lt;/a&gt; используемый для управления данными формы для использования в API &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7537c29a754763b348491b7f0dbd96e605a4a484" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Reporting_API&quot;&gt;reporting API&lt;/a&gt; group to send network error reports to (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315a779e6acad1d531dd53b54135b697e3e3e7ed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket&quot;&gt;&lt;code&gt;WebSocket()&lt;/code&gt;&lt;/a&gt; constructor does all the work of creating an initial HTTP/1.1 connection then handling the handshaking and upgrade process for you.</source>
          <target state="translated">Конструктор &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket&quot;&gt; &lt;code&gt;WebSocket()&lt;/code&gt; &lt;/a&gt; выполняет всю работу по созданию начального соединения HTTP / 1.1, а затем обрабатывает за вас процесс установления связи и обновления.</target>
        </trans-unit>
        <trans-unit id="d45717eba61ad3d5a426950cb644c8f2dd47e3a7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt; has been replced with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebXR_API&quot;&gt;WebXR Device API&lt;/a&gt; and is currently being removed from the web platform. Use the feature identifier &lt;a href=&quot;xr-spatial-tracking&quot;&gt;&lt;code&gt;xr-spatial-tracking&lt;/code&gt;&lt;/a&gt; for WebXR Device API instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d572fbbc7fb5223d172c4f660df4f67fd67a10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;&lt;code&gt;allow&lt;/code&gt;&lt;/a&gt; attribute on iframes.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt; &lt;code&gt;allow&lt;/code&gt; &lt;/a&gt; атрибут фреймов.</target>
        </trans-unit>
        <trans-unit id="41b2d8d87680fc3732f8e6149116b853f67342a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;Позволяют&lt;/a&gt; атрибут &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="81c151e97bb2fc9016b004646d1163e360980269" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH-Lifetime&quot;&gt;&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt;&lt;/a&gt; header is used with the &lt;code&gt;Device-Memory&lt;/code&gt; value of the &lt;code&gt;Accept-CH&lt;/code&gt; header and indicates the amount of time the device should opt-in to sharing the amount of device memory with the server. The value is given in miliseconds and it's use is optional.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH-Lifetime&quot;&gt; &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; &lt;/a&gt; заголовок используется с &lt;code&gt;Device-Memory&lt;/code&gt; значения &lt;code&gt;Accept-CH&lt;/code&gt; заголовка и указывает количество времени , устройство должно отказаться в обмен на объем памяти устройства с сервером. Значение указывается в миллисекундах, и его использование не является обязательным.</target>
        </trans-unit>
        <trans-unit id="feae0b21dc6047c955761cda1dd45a586e339677" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header field is used by clients to invite the server to switch to one of the listed protocols, in descending preference order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102f0a3635d954f2ea429dc9612327a656cc4b1f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Audio_codecs&quot;&gt;audio codec&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Video_codecs&quot;&gt;video codec&lt;/a&gt; guides list the various codecs that web browsers often support, providing compatibility details along with technical information such as how many audio channels they support, what sort of compression is used, and what bit rates and so forth they're useful at. The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/WebRTC_codecs&quot;&gt;codecs used by WebRTC&lt;/a&gt; guide expands upon this by specifically covering the codecs supported by the major web browsers, so you can choose the codecs that best cover the range of browsers you wish to support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbd12c73f76eeadd9f5a8a7c267e1d8bb10451c5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP protocol&lt;/a&gt; provides a special mechanism allowing an already established connection to upgrade to a new, incompatible, protocol. This guide covers how this works and offers examples of scenarios in which it's used.</source>
          <target state="translated">Протокол &lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP&lt;/a&gt; предоставляет специальный механизм, позволяющий уже установленному соединению перейти на новый, несовместимый протокол. В этом руководстве рассказывается, как это работает, и предлагаются примеры сценариев, в которых это используется.</target>
        </trans-unit>
        <trans-unit id="56487f351a83f4ece995635d28e031bb9e971d36" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header&quot;&gt;Cross-Origin-Resource-Policy&lt;/a&gt; header prevents other domains from loading the resources.</source>
          <target state="translated">В &lt;a href=&quot;https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header&quot;&gt;Cross-Origin-Ресурс-политика&lt;/a&gt; заголовок предотвращает другие домены от загрузки ресурсов.</target>
        </trans-unit>
        <trans-unit id="30ff7cff75928c0f981ddbe781c5a37e5b8ec7ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt; module has &lt;code&gt;Redirect&lt;/code&gt; and &lt;code&gt;RedirectMatch&lt;/code&gt; directives that set up a &lt;a href=&quot;status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; response (by default):</source>
          <target state="translated">В модуле &lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt; есть директивы &lt;code&gt;Redirect&lt;/code&gt; и &lt;code&gt;RedirectMatch&lt;/code&gt; , которые устанавливают ответ &lt;a href=&quot;status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt; (по умолчанию):</target>
        </trans-unit>
        <trans-unit id="dfdf1721b0f5a67b62cb197634da7d5057e2041b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://observatory.mozilla.org/&quot;&gt;Mozilla Observatory&lt;/a&gt; tool testing the configuration (including this header) of Web sites for safety and security</source>
          <target state="translated">Инструмент &lt;a href=&quot;https://observatory.mozilla.org/&quot;&gt;Mozilla Observatory&lt;/a&gt; , проверяющий конфигурацию (включая этот заголовок) веб-сайтов на безопасность и защищенность.</target>
        </trans-unit>
        <trans-unit id="b0c2f791ad88a8a7e38ea528eb0f0ccd9df436bb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://tools.ietf.org/html/rfc4648#section-5&quot;&gt;base64url&lt;/a&gt; format is not the same as standard Base64 encoding. This is almost but not quite the same as standard Base64. The only difference: in order to ensure that the resulting string is safe for use in both URLs and filenames, the 62nd and 63rd characters in its alphabet are changed from &lt;code&gt;&quot;+&quot;&lt;/code&gt; and &lt;code&gt;&quot;/&quot;&lt;/code&gt; to &lt;code&gt;&quot;-&quot;&lt;/code&gt; (minus) and &lt;code&gt;&quot;_&quot;&lt;/code&gt; (underscore), respectively.</source>
          <target state="translated">Формат &lt;a href=&quot;https://tools.ietf.org/html/rfc4648#section-5&quot;&gt;base64url&lt;/a&gt; не совпадает со стандартной кодировкой Base64. Это почти, но не совсем то же самое, что и стандартный Base64. Единственное отличие: чтобы гарантировать, что результирующая строка безопасна для использования как в URL-адресах, так и в именах файлов, 62-й и 63-й символы в ее алфавите изменены с &lt;code&gt;&quot;+&quot;&lt;/code&gt; и &lt;code&gt;&quot;/&quot;&lt;/code&gt; на &lt;code&gt;&quot;-&quot;&lt;/code&gt; (минус) и &lt;code&gt;&quot;_&quot;&lt;/code&gt; (подчеркивание) соответственно.</target>
        </trans-unit>
        <trans-unit id="e864176c816370410ca7b511fa51ea0441aec0c3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.iana.org/&quot;&gt;Internet Assigned Numbers Authority (IANA)&lt;/a&gt; is responsible for all official MIME types, and you can find the most up-to-date and complete list at their &lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;Media Types&lt;/a&gt; page.</source>
          <target state="translated">За все официальные типы MIME отвечает &lt;a href=&quot;https://www.iana.org/&quot;&gt;Internet Assigned Numbers Authority (IANA)&lt;/a&gt; , и вы можете найти самый последний и полный список на их странице &lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;Media Types&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e5161e796ede3d041d86dc6f2b70145c4f74bc4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.iana.org/assignments/http-warn-codes/http-warn-codes.xhtml&quot;&gt;HTTP Warn Codes registry at iana.org&lt;/a&gt; defines the namespace for warn codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ea81494b8105f6717337ab7d95f01a45c084f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;index&quot;&gt;HTTP/1.1 protocol&lt;/a&gt; provides a special mechanism that can be used to upgrade an already established connection to a different protocol, using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab5fee31c8ccbebe1e49d2cda4be11eb9064dcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method requests a data representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">Метод &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; запрашивает представление данных указанного ресурса. Запросы с использованием &lt;code&gt;GET&lt;/code&gt; должны только получать данные.</target>
        </trans-unit>
        <trans-unit id="85676b7109bc7c3348572fe11d463aa4452c7f6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; method sends data to a server so it may change its state. This is the method often used for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Forms&lt;/a&gt;.</source>
          <target state="translated">Метод &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; отправляет данные на сервер, чтобы он мог изменить свое состояние. Этот метод часто используется для &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML-форм&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="759d2232e34b1fccdd6a4688d236906067716e48" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header will be omitted entirely. No referrer information is sent along with requests.</source>
          <target state="translated">&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; заголовок будет полностью опущен. Информация о реферере не отправляется вместе с запросами.</target>
        </trans-unit>
        <trans-unit id="bb80c4be8693337fa70be2fe31fd2c4154708a28" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/101&quot;&gt;&lt;code&gt;101&lt;/code&gt;&lt;/a&gt; status code is sent as a response to a request including the &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; header to signal that the recipient of the request is willing to upgrade to one of the desired protocols. If the &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; status code is returned, the header must also include the &lt;code&gt;Connection&lt;/code&gt; and &lt;code&gt;Upgrade&lt;/code&gt; headers to describe the chosen protocol. See the examples in &lt;a href=&quot;#Common_uses_for_this_mechanism&quot;&gt;Common uses for this mechanism&lt;/a&gt; to learn more about how this works.</source>
          <target state="translated">Код состояния &lt;a href=&quot;status/101&quot;&gt; &lt;code&gt;101&lt;/code&gt; &lt;/a&gt; отправляется в качестве ответа на запрос, включающий заголовок &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; чтобы сигнализировать, что получатель запроса желает перейти на один из требуемых протоколов. Если возвращается код состояния &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; , заголовок также должен включать заголовки &lt;code&gt;Connection&lt;/code&gt; и &lt;code&gt;Upgrade&lt;/code&gt; для описания выбранного протокола. См. Примеры в разделе &amp;laquo; &lt;a href=&quot;#Common_uses_for_this_mechanism&quot;&gt;Общие способы использования этого механизма&amp;raquo;,&lt;/a&gt; чтобы узнать больше о том, как это работает.</target>
        </trans-unit>
        <trans-unit id="ba7765f4a93430d93893449738d810f79adab493" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/300&quot;&gt;&lt;code&gt;300&lt;/code&gt;&lt;/a&gt; (Multiple Choices) or &lt;a href=&quot;status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) &lt;a href=&quot;status&quot;&gt;HTTP response codes&lt;/a&gt; by the server (&lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;), that are used as fallback mechanisms.</source>
          <target state="translated">В &lt;a href=&quot;status/300&quot;&gt; &lt;code&gt;300&lt;/code&gt; &lt;/a&gt; (Множественном выборе) или &lt;a href=&quot;status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt; (не приемлемы) &lt;a href=&quot;status&quot;&gt;HTTP - кода ответа&lt;/a&gt; от сервера ( &lt;em&gt;агентом обсуждение&lt;/em&gt; или &lt;em&gt;реактивных переговоры&lt;/em&gt; ), которые используются в качестве механизмов резервных.</target>
        </trans-unit>
        <trans-unit id="7a2ea4621d5db4a0643b172c60b9729d03740461" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/300&quot;&gt;&lt;code&gt;300&lt;/code&gt;&lt;/a&gt; (Multiple Choices) or &lt;a href=&quot;status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable), &lt;a href=&quot;status/415&quot;&gt;&lt;code&gt;415&lt;/code&gt;&lt;/a&gt; (Unsupported Media Type) &lt;a href=&quot;status&quot;&gt;HTTP response codes&lt;/a&gt; by the server (&lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;), that are used as fallback mechanisms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc1524f620c113ef489962d737efb33b27f2eac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; request header needs to be set to &quot;trailers&quot; to allow trailer fields.</source>
          <target state="translated">&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; заголовок запроса должен быть установлен на &amp;laquo;прицепы&amp;raquo; , чтобы поля трейлера.</target>
        </trans-unit>
        <trans-unit id="106d3051b32652488ca1792a9b8e10220f0e7a85" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive is evaluated before &lt;code&gt;block-all-mixed-content&lt;/code&gt; and If the former is set, the latter is effectively a no-op. It is recommended to set one directive or the other &amp;ndash; not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">&lt;a href=&quot;upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt; директива вычисляется перед &lt;code&gt;block-all-mixed-content&lt;/code&gt; и если бывший установлен, последний не является эффективно не оп. Рекомендуется установить одну директиву или другую, но не обе, если только вы не хотите принудительно использовать HTTPS в старых браузерах, которые не заставляют его после перенаправления на HTTP.</target>
        </trans-unit>
        <trans-unit id="5a51eef50de25b01cedd4928f3f99c9fae3d5200" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive is evaluated before &lt;code&gt;block-all-mixed-content&lt;/code&gt;. If the former is set, the latter does nothing, so set one directive or the other &amp;ndash; not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f16849e96b723097d3105369f7d2ec73a2c9b25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header ensures that the content is cached properly (for instance ensuring that the user is not served a lower-quality image from the cache when &lt;code&gt;Save-Data&lt;/code&gt; header is no longer present [&lt;em&gt;e.g.&lt;/em&gt; after having switched from cellular to Wi-Fi]).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5a0a42af328d6549a6884a0d4203b5b8180652" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'src'&lt;/code&gt; origin is used in the iframe &lt;code&gt;allow&lt;/code&gt; attribute only, and is the &lt;em&gt;default&lt;/em&gt;&lt;code&gt;allowlist&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e69a4edf06fe574fa80e88285f8fb7d88da970" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'strict-dynamic'&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. For example, a policy such as &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; would allow loading of a root script with &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; and propagate that trust to any script loaded by &lt;code&gt;loader.js&lt;/code&gt;, but disallow loading scripts from &lt;code&gt;https://whitelisted.com/&lt;/code&gt; unless accompanied by a nonce or loaded from a trusted script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b021b3c1d64f7dedfd2f1fd076264572ee155ed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'strict-dynamic&lt;/code&gt;' source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. For example, a policy such as &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; would allow loading of a root script with &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; and propagate that trust to any script loaded by &lt;code&gt;loader.js&lt;/code&gt;, but disallow loading scripts from &lt;code&gt;https://whitelisted.com/&lt;/code&gt; unless accompanied by a nonce or loaded from a trusted script.</source>
          <target state="translated">В &lt;code&gt;'strict-dynamic&lt;/code&gt; выражении источника указует&amp;raquo; , что доверие явно приведенный в сценарии , присутствующий в разметке, сопровождая его с одноразовым номером или хэшем, должны распространяться на все сценарии , загруженных этим корневого сценарий. В то же время любые выражения из белого списка или источника, такие как &lt;code&gt;'self'&lt;/code&gt; или &lt;code&gt;'unsafe-inline'&lt;/code&gt; будут игнорироваться. Например, такая политика, как &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; , разрешит загрузку корневого скрипта с &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; и распространите это доверие на любой скрипт, загруженный &lt;code&gt;loader.js&lt;/code&gt; , но запретите загрузку скриптов с &lt;code&gt;https://whitelisted.com/&lt;/code&gt; если не сопровождается одноразовым номером или не загружается из доверенного сценария.</target>
        </trans-unit>
        <trans-unit id="6382e529a182503f39a7f7388e99ab1653c33241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'unsafe-eval'&lt;/code&gt; source expression controls several script execution methods that create code from strings. If &lt;code&gt;'unsafe-eval'&lt;/code&gt; isn't specified with the &lt;code&gt;script-src&lt;/code&gt; directive, the following methods are blocked and won't have any effect:</source>
          <target state="translated">В &lt;code&gt;'unsafe-eval'&lt;/code&gt; выражение источника управление несколько методов выполнения сценария , которые создают код из строк. Если &lt;code&gt;'unsafe-eval'&lt;/code&gt; не указан в директиве &lt;code&gt;script-src&lt;/code&gt; , следующие методы блокируются и не будут иметь никакого эффекта:</target>
        </trans-unit>
        <trans-unit id="7a974fff323538cd623f076264d18fe2300bde8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'unsafe-eval'&lt;/code&gt; source expression controls several style methods that create style declarations from strings. If &lt;code&gt;'unsafe-eval'&lt;/code&gt; isn't specified with the &lt;code&gt;style-src&lt;/code&gt; directive, the following methods are blocked and won't have any effect:</source>
          <target state="translated">В &lt;code&gt;'unsafe-eval'&lt;/code&gt; выражение источника управление несколько методов стилей , которые создают стиль объявление из строк. Если &lt;code&gt;'unsafe-eval'&lt;/code&gt; не указан в директиве &lt;code&gt;style-src&lt;/code&gt; , следующие методы блокируются и не будут иметь никакого эффекта:</target>
        </trans-unit>
        <trans-unit id="c3028d259a6399103c9ce4edc7dfac31909edc67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file references a &lt;code&gt;.htpasswd&lt;/code&gt; file in which each line consists of a username and a password separated by a colon (&lt;code&gt;:&lt;/code&gt;). You cannot see the actual passwords as they are &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;hashed&lt;/a&gt; (using MD5-based hashing, in this case). Note that you can name your &lt;code&gt;.htpasswd&lt;/code&gt; file differently if you like, but keep in mind this file shouldn't be accessible to anyone. (Apache is usually configured to prevent access to &lt;code&gt;.ht*&lt;/code&gt; files).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d8d01c839e9d424312b47d646a614086c80cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file references a &lt;code&gt;.htpasswd&lt;/code&gt; file in which each line contains of a username and a password separated by a colon (&quot;:&quot;). You can not see the actual passwords as they are &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;encrypted&lt;/a&gt; (md5 in this case). Note that you can name your &lt;code&gt;.htpasswd&lt;/code&gt; file differently if you like, but keep in mind this file shouldn't be accessible to anyone. (Apache is usually configured to prevent access to &lt;code&gt;.ht*&lt;/code&gt; files).</source>
          <target state="translated">В &lt;code&gt;.htaccess&lt;/code&gt; ссылки стандартного файла &lt;code&gt;.htpasswd&lt;/code&gt; файл , в котором каждая строка содержит имени пользователя и пароль , разделенное двоеточие ( &amp;laquo;:&amp;raquo;). Вы не можете увидеть настоящие пароли, поскольку они &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;зашифрованы&lt;/a&gt; (в данном случае md5). Обратите внимание, что вы можете назвать свой файл &lt;code&gt;.htpasswd&lt;/code&gt; по- другому, если хотите, но помните, что этот файл не должен быть доступен никому. (Обычно Apache настроен на предотвращение доступа к &lt;code&gt;.ht*&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="01ea6c155e3bff628716e111f394e3a0636ae28e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file typically looks like this:</source>
          <target state="translated">&lt;code&gt;.htaccess&lt;/code&gt; файл , как правило , выглядит следующим образом :</target>
        </trans-unit>
        <trans-unit id="4140f45978733db50c0722e19703d0dd8732110c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;203&lt;/code&gt; response is similar to the value &lt;code&gt;&lt;a href=&quot;../headers/warning#Warning_codes&quot;&gt;214&lt;/a&gt;&lt;/code&gt;, meaning &lt;code&gt;Transformation Applied&lt;/code&gt;, of the &lt;a href=&quot;../headers/warning&quot;&gt;&lt;code&gt;Warning&lt;/code&gt;&lt;/a&gt; header code, which has the additional advantage of being applicable to responses with any status code.</source>
          <target state="translated">&lt;code&gt;203&lt;/code&gt; ответ аналогично значения &lt;code&gt;&lt;a href=&quot;../headers/warning#Warning_codes&quot;&gt;214&lt;/a&gt;&lt;/code&gt; , а это означает &lt;code&gt;Transformation Applied&lt;/code&gt; , в &lt;a href=&quot;../headers/warning&quot;&gt; &lt;code&gt;Warning&lt;/code&gt; &lt;/a&gt; коде заголовка, который имеет дополнительное преимущество в том , применим к ответам с любым кодом состояния.</target>
        </trans-unit>
        <trans-unit id="fd1e39721a458a8f43a8fa40e465369253ea6854" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;416&lt;/code&gt; response message contains a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; indicating an unsatisfied range (that is a &lt;code&gt;'*'&lt;/code&gt;) followed by a &lt;code&gt;'/'&lt;/code&gt; and the current length of the resource. E.g. &lt;code&gt;Content-Range: */12777&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;416&lt;/code&gt; ответное сообщение содержит &lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; , указывающий на неудовлетворенный диапазон (то есть &lt;code&gt;'*'&lt;/code&gt; ) , а затем &lt;code&gt;'/'&lt;/code&gt; и текущую длину ресурса. Например, &lt;code&gt;Content-Range: */12777&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc6eca35190b0a85bc179efcd6440ff5e420f987" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;416&lt;/code&gt; response message contains a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; indicating an unsatisfied range (that is a &lt;code&gt;'*'&lt;/code&gt;) followed by a &lt;code&gt;'/'&lt;/code&gt; and the current length of the resource. E.g. &lt;code&gt;Content-Range: bytes */12777&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000250a8c920d71a596d42e3ba222cb0c276eb98" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt;&lt;/code&gt; module can also create redirects. It is more flexible, but a bit more complex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d74ebb54bf35188baf88fab6ddfb03450100af2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-allow&quot;&gt;allow&lt;/a&gt;&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678867190bea86d25ddd4c42f7e5d5945a9962ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; attribute should start with a number indicating how many seconds the browser should wait before redirecting to the given URL. Always set it to &lt;code&gt;0&lt;/code&gt; for accessibility compliance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37ff63edc4a58e58577f391879495cdf22ee684" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; attribute starts with a number indicating how many seconds the browser should wait before redirecting to the given URL. Always set it to &lt;code&gt;0&lt;/code&gt;, for better accessibility.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; начинается атрибут с числом , показывающим , сколько секунд браузер должен ждать перед перенаправлением к данному URL. Всегда устанавливайте значение &lt;code&gt;0&lt;/code&gt; для лучшей доступности.</target>
        </trans-unit>
        <trans-unit id="df94992d56f1ec3780068eef1f291a2bd6528445" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developers.google.com/search/reference/robots_meta_tag#xrobotstag&quot;&gt;X-Robots-Tag&lt;/a&gt;&lt;/code&gt; HTTP header is used to indicate how a web page is to be indexed within public search engine results. The header is effectively equivalent to &lt;code&gt;&amp;lt;meta name=&quot;robots&quot; content=&quot;...&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9f882bdef0f2fbd9c820397fd3355193604e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/jj542450(v=vs.85)?#the-noopen-directive&quot;&gt;X-Download-Options&lt;/a&gt;&lt;/code&gt; HTTP header indicates that the browser (Internet Explorer) should not display the option to &quot;Open&quot; a file that has been downloaded from an application, to prevent phishing attacks as the file otherwise would gain access to execute in the context of the application. (Note: related &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/18488178/&quot;&gt;MS Edge bug&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8570429a0850dacdf55e905b24382087aa950397" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; module has &lt;code&gt;Redirect&lt;/code&gt; and &lt;code&gt;RedirectMatch&lt;/code&gt; directives that set up &lt;a href=&quot;status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; redirects by default:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ceb6b99bc589e7f4ef4cc475222c90b7cc3bbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt;&lt;/code&gt; module can also create redirects. It is more flexible, but a bit more complex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a33077bdfc87f84fa941dba1652820231ca50a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf90377c54cfb58cf2ddd3a014cf93971e6153b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/link&quot;&gt;&amp;lt;link&amp;gt;&lt;/a&gt;&lt;/code&gt; element.</source>
          <target state="translated">Поле заголовка объекта &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; предоставляет средства для сериализации одной или нескольких ссылок в заголовках HTTP. Семантически эквивалентен элементу HTML &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/link&quot;&gt;&amp;lt;link&amp;gt;&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a78799203cafc041527d32fff46051e530f3f10a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.1&quot;&gt;Signature&lt;/a&gt;&lt;/code&gt; header field conveys a list of signatures for an exchange, each one accompanied by information about how to determine the authority of and refresh that signature.</source>
          <target state="translated">Поле заголовка &amp;laquo; &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.1&quot;&gt;Signature&lt;/a&gt;&lt;/code&gt; содержит список подписей для обмена, каждая из которых сопровождается информацией о том, как определить полномочия и обновить эту подпись.</target>
        </trans-unit>
        <trans-unit id="ac287448eebb179af2b5fea39da63acb2f0e34a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.5.1.2&quot;&gt;Signed-Headers&lt;/a&gt;&lt;/code&gt; header field identifies an ordered list of response header fields to include in a signature.</source>
          <target state="translated">Поле &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.5.1.2&quot;&gt;Signed-Headers&lt;/a&gt;&lt;/code&gt; определяет упорядоченный список полей заголовка ответа для включения в подпись.</target>
        </trans-unit>
        <trans-unit id="f3c5f0394e6c797409337c3ba59ac4660eea6b49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Accept-CH-Lifetime&lt;/strong&gt;&lt;/code&gt; header is set by the server to specify the persistence of &lt;a href=&quot;accept-ch&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; header value that specifies for which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; headers client should include in subsequent requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc84160c5460da89ca680071c3cd21f91aa02e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Accept-CH&lt;/strong&gt;&lt;/code&gt; header is set by the server to specify which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; headers a client should include in subsequent requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d982342366479f245d9e1687b6642ae3d345e689" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Accept-Ranges&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to advertise its support of partial requests. The value of this field indicates the unit that can be used to define a range.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Accept-Ranges&lt;/strong&gt;&lt;/code&gt; ответ HTTP заголовок представляет собой маркер , используемый сервер для рекламы своей поддержки частичных запросов. Значение этого поля указывает единицу измерения, которую можно использовать для определения диапазона.</target>
        </trans-unit>
        <trans-unit id="d3c88e931c279d244b193828eb2439579c4ee0ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;&lt;/code&gt; response header indicates whether the response can be shared with requesting code from the given &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;&lt;/code&gt; заголовка ответа указывает , является ли ответ может использоваться совместно с просьбой код из данного &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;происхождения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7e76f11cda78abd0588ec375967af559825d413" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Age&lt;/strong&gt;&lt;/code&gt; header contains the time in seconds the object has been in a proxy cache.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Age&lt;/strong&gt;&lt;/code&gt; заголовок содержит время в секундах объект был в прокси - кэше.</target>
        </trans-unit>
        <trans-unit id="f9681dd052c79b13127ae3929a731da18e4b72d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; header lists the set of methods support by a resource.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; Header Перечисляет набор методов поддержки ресурсом.</target>
        </trans-unit>
        <trans-unit id="c95653d764bb42232e9cbd3888e86cd3686754bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; header lists the set of methods supported by a resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc0cc776eb12ee2c880638b893d5b55050e39bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Digest&lt;/strong&gt;&lt;/code&gt; response HTTP header provides a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/digest&quot;&gt;digest&lt;/a&gt; of the requested resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e78b75471626ac2160cc198bfd26d8ad9f80eb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is set by an intermediary to indicate that the request has been conveyed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS early data&lt;/a&gt;, and also indicates that the intermediary understands the &lt;a href=&quot;../status/425&quot;&gt;&lt;code&gt;425 (Too Early)&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61bb0d627ec7b7f17d0bc47d697b57d00a1bc5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is set by an intermediate to indicates that the request has been conveyed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS early data&lt;/a&gt;, and additionally indicates that an intermediary understands the &lt;a href=&quot;../status/425&quot;&gt;&lt;code&gt;425 (Too Early)&lt;/code&gt;&lt;/a&gt; status code. The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is not set by the originator of the request (i.e., a browser).</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; заголовка устанавливается в качестве промежуточного указывает , что запрос был передано в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS ранние данные&lt;/a&gt; , и дополнительно указывает на то, что посредник понимает &lt;a href=&quot;../status/425&quot;&gt; &lt;code&gt;425 (Too Early)&lt;/code&gt; &lt;/a&gt; код состояния. &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; заголовок не установлен отправителем запроса (то есть, браузер).</target>
        </trans-unit>
        <trans-unit id="e737d89463e54c8720f8ad63e418a0bfb0f07f1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;/code&gt; header contains the date/time after which the response is considered stale.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;/code&gt; заголовок содержит дату / время , после которого ответ считается устаревшим.</target>
        </trans-unit>
        <trans-unit id="5be71a78718c793e01b9247dbf20bee8de751846" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;From&lt;/strong&gt;&lt;/code&gt; request header contains an Internet email address for a human user who controls the requesting user agent.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;From&lt;/strong&gt;&lt;/code&gt; заголовка запроса содержит адрес электронной почты в Интернете для пользователя - человека , который контролирует запрашивающему агент пользователя.</target>
        </trans-unit>
        <trans-unit id="73a9129a968278840bcb3ecb81312e01ea1c7ad9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; request header specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; заголовок запроса определяет доменное имя сервера (для виртуального хостинга), и (необязательно) ТСР номер порта , на котором сервер прослушивает.</target>
        </trans-unit>
        <trans-unit id="1d90ed71aec05b79116744d2cf8473e3277dfbc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; request header specifies the host and port number of the server to which the request is being sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36122c8169aa84d5fb618cc5e704f67fadc13a5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; general header allows the sender to hint about how the connection and may be used to set a timeout and a maximum amount of requests.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; общий заголовок позволяет отправителю подсказку о том , как соединение и может быть использован для установки тайм - аут и максимальное количество запросов.</target>
        </trans-unit>
        <trans-unit id="c0b74d9f17da8401496a5b8c7cf402bea1cb5769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; general header allows the sender to hint about how the connection may be used to set a timeout and a maximum amount of requests.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; общий заголовок позволяет отправителю подсказку о том , как соединение может быть использовано для установки тайм - аут и максимальное количество запросов.</target>
        </trans-unit>
        <trans-unit id="2fbf23d9b9327582f4f49a7ec76472bba6a6a4fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Pragma&lt;/strong&gt;&lt;/code&gt; HTTP/1.0 general header is an implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the &lt;code&gt;Cache-Control&lt;/code&gt; HTTP/1.1 header is not yet present.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Pragma&lt;/strong&gt;&lt;/code&gt; HTTP / 1.0 общий заголовок является реализацией конкретного заголовка , который может иметь различные эффекты вдоль цепи запроса-ответа. Он используется для обратной совместимости с кешами HTTP / 1.0, где заголовок &lt;code&gt;Cache-Control&lt;/code&gt; HTTP / 1.1 еще не присутствует.</target>
        </trans-unit>
        <trans-unit id="df9c97c4ad9d61f0d260427224fcdc949c7f1596" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; request header contains the address of the page making the request. When following a link, this would be the url of the page containing the link. When making AJAX requests to another domain, this would be your page's url. The &lt;code&gt;Referer&lt;/code&gt; header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3c55e276ce88c71d0f16074fd5ecc0e9f413f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; request header contains the address of the previous web page from which a link to the currently requested page was followed. The &lt;code&gt;Referer&lt;/code&gt; header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; заголовок запроса содержит адрес предыдущей веб - страницу , с которой последовала ссылка на текущий запрошенную страницу. &lt;code&gt;Referer&lt;/code&gt; заголовок позволяет серверам определить , где люди посещают их и могут использовать эти данные для аналитики, регистрации или оптимизированного кэширования, например.</target>
        </trans-unit>
        <trans-unit id="f35781aa0d1de163111fee93c0d8d38911b682ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; header contains information about the software used by the origin server to handle the request.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; заголовок содержит информацию о программном обеспечении , используемом сервером происхождения , чтобы обработать запрос.</target>
        </trans-unit>
        <trans-unit id="d1b3c683e4cd677dc3be26bd03213dd34909bab4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; header describes the software used by the origin server that handled the request &amp;mdash; that is, the server that generated the response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72ba03805654f750e5994c434c6ce48268c191f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;TE&lt;/strong&gt;&lt;/code&gt; request header specifies the transfer encodings the user agent is willing to accept. (you could informally call it &lt;em&gt;&lt;code&gt;Accept-Transfer-Encoding&lt;/code&gt;&lt;/em&gt;, which would be more intuitive).</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;TE&lt;/strong&gt;&lt;/code&gt; заголовок запроса определяет кодировки передачи пользовательского агент готов принять. (вы могли бы неофициально назвать это &lt;em&gt; &lt;code&gt;Accept-Transfer-Encoding&lt;/code&gt; &lt;/em&gt; , что было бы более интуитивно понятно).</target>
        </trans-unit>
        <trans-unit id="5652b37e21feb912010feecdf8d75ae0995d40af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Timing-Allow-Origin&lt;/strong&gt;&lt;/code&gt; response header specifies origins that are allowed to see values of attributes retrieved via features of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing API&lt;/a&gt;, which would otherwise be reported as zero due to cross-origin restrictions.</source>
          <target state="translated">В &lt;code&gt;&lt;strong&gt;Timing-Allow-Origin&lt;/strong&gt;&lt;/code&gt; заголовка ответа Определяет происхождение, которым разрешено видеть значение атрибутов , получаемых с помощью особенностей &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Timing API ресурсов&lt;/a&gt; , которые иначе было бы отчётным нуль из - за ограничения поперечного происхождения.</target>
        </trans-unit>
        <trans-unit id="459b5cbc88f2c6244c84b2b7cf57687d4fed7e90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Variant Also Negotiates&lt;/strong&gt;&lt;/code&gt; status code indicates an internal server configuration error in which the chosen variant is itself configured to engage in content negotiation, so is not a proper negotiation endpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06db3329ed9ad8dfc09e37ef09b6402d3732e8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Via&lt;/strong&gt;&lt;/code&gt; general header is added by proxies, both forward and reverse proxies, and can appear in the request headers and the response headers. It is used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of senders along the request/response chain.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Via&lt;/strong&gt;&lt;/code&gt; общий заголовок добавляется прокси - сервера, как вперед , так и обратные прокси - сервера, и может появляться в заголовках запроса и заголовках ответа. Он используется для отслеживания пересылки сообщений, предотвращения зацикливания запросов и определения возможностей протокола отправителей в цепочке запросов / ответов.</target>
        </trans-unit>
        <trans-unit id="519d7e47665e940480525b25780c7db7b6681325" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Want-Digest&lt;/strong&gt;&lt;/code&gt; HTTP header is primarily used in a HTTP request, to ask the responder to provide a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/digest&quot;&gt;digest&lt;/a&gt; of the requested resource using the &lt;code&gt;&lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt;&lt;/code&gt; response header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a25ab474d784c5f16b25d0aa6fcd7fc6ce7fc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to indicate that the &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt; advertised in the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; headers should not be changed and be followed. This allows to opt-out of &lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME type sniffing&lt;/a&gt;, or, in other words, it is a way to say that the webmasters knew what they were doing.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; Ответные HTTP заголовок представляет собой маркер , используемый сервером , чтобы указать , что &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;типы MIME&lt;/a&gt; рекламируется в &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; заголовки не должны быть изменены и следовать. Это позволяет отказаться от &lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;сниффинга типа MIME&lt;/a&gt; , или, другими словами, это способ сказать, что веб-мастера знали, что они делают.</target>
        </trans-unit>
        <trans-unit id="cd7aecd4c1fd5dec57a2c138b3e5a8c117d9036d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to indicate that the &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt; advertised in the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; headers should not be changed and be followed. This is a way to opt out of &lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME type sniffing&lt;/a&gt;, or, in other words, to say that the MIME types are deliberately configured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bceacb1272f77c276df2ceb5f3eec10ddfee111d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string indicates if Firefox is running on a phone-sized or tablet device. When Firefox runs on a device that has the phone form factor, there is a &lt;code&gt;Mobile;&lt;/code&gt; token in the &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string. When Firefox runs on a tablet device, there is a &lt;code&gt;Tablet;&lt;/code&gt; token in the &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string instead. For example:</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; часть строки UA указует , если Firefox работает на телефонный размере или планшетное устройство. Когда Firefox работает на устройстве, имеющем форм-фактор телефона, есть &lt;code&gt;Mobile;&lt;/code&gt; токен в &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; части строки UA. Когда Firefox работает на планшете, есть &lt;code&gt;Tablet;&lt;/code&gt; вместо этого токен в &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; части строки UA. Например:</target>
        </trans-unit>
        <trans-unit id="82e98053eac989383e680a4cf5cc9358923e6dcb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; заголовка</target>
        </trans-unit>
        <trans-unit id="6df4384dcc248042b53e1dc48377a116aa3f10ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-CH&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-CH&lt;/code&gt; заголовок</target>
        </trans-unit>
        <trans-unit id="c43f0f2a86e0d2275393478d7fdb73db5ffbaada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-Charset&lt;/code&gt; заголовок</target>
        </trans-unit>
        <trans-unit id="2cb1ca877d3eb1b0f248f74c9ec40232997e5dc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; request HTTP header advertises which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/character_encoding&quot;&gt;character encodings&lt;/a&gt; the client understands. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server selects one of the encodings, uses it, and informs the client of its choice within the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header, usually in a &lt;code&gt;charset=&lt;/code&gt; parameter. Browsers usually don't send this header, as the default value for each resource is usually correct and transmitting it would allow &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Privacy/Tracking_Protection&quot;&gt;fingerprinting&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1a79dc44f6324b9656f0e9b91f70c6b6ee9b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; request HTTP header advertises which character set the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice within the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header. Browsers usually don't set this header as the default value for each content type is usually correct and transmitting it would allow easier fingerprinting.</source>
          <target state="translated">&lt;code&gt;Accept-Charset&lt;/code&gt; запросить HTTP заголовок рекламирует какой набор символов клиент способен понять. Использование &lt;a href=&quot;../content_negotiation&quot;&gt;согласования содержимого&lt;/a&gt; , сервер выбирает один из этих предложений, использует его и информирует клиента о своем выборе в рамках &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; заголовка ответа. Браузеры обычно не устанавливают этот заголовок, поскольку значение по умолчанию для каждого типа контента обычно правильное, и его передача упростит снятие отпечатков пальцев.</target>
        </trans-unit>
        <trans-unit id="32e4c478c87a3a2796f89e9931f3a93966bdfdbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Encoding&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-Encoding&lt;/code&gt; заголовок</target>
        </trans-unit>
        <trans-unit id="91185be688fa9da1a182310f6df358fd174c46f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Encoding&lt;/code&gt; request HTTP header advertises which content encoding, usually a compression algorithm, the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt; response header.</source>
          <target state="translated">&lt;code&gt;Accept-Encoding&lt;/code&gt; запрос HTTP заголовок рекламирует, содержание которых кодирование, как правило , алгоритм сжатия, клиент может понять. Используя &lt;a href=&quot;../content_negotiation&quot;&gt;согласование содержимого&lt;/a&gt; , сервер выбирает одно из предложений, использует его и сообщает клиенту о своем выборе с помощью заголовка ответа &lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ae7d36d36006ff093b2a55d71bd74d51e77b3ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Language&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-Language&lt;/code&gt; заголовок</target>
        </trans-unit>
        <trans-unit id="c4a25b290f315f1cab7813fec6b003a441c0d600" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Language&lt;/code&gt; request HTTP header advertises which languages the client is able to understand, and which locale variant is preferred. (By languages, we mean natural languages, such as English, and not programming languages.) Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt; response header. Browsers set adequate values for this header according to their user interface language and even if a user can change it, this happens rarely (and is frowned upon as it leads to fingerprinting).</source>
          <target state="translated">&lt;code&gt;Accept-Language&lt;/code&gt; запросить HTTP заголовок рекламирует какие языки клиент способен понять, и какие локали вариант является предпочтительным. (Под языками мы имеем в виду естественные языки, такие как английский, а не языки программирования.) Используя &lt;a href=&quot;../content_negotiation&quot;&gt;согласование содержимого&lt;/a&gt; , сервер затем выбирает одно из предложений, использует его и сообщает клиенту о своем выборе с помощью заголовка ответа &lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt; . Браузеры устанавливают адекватные значения для этого заголовка в соответствии с языком своего пользовательского интерфейса, и даже если пользователь может его изменить, это случается редко (и не одобряется, поскольку приводит к снятию отпечатков пальцев).</target>
        </trans-unit>
        <trans-unit id="f1d16f67263a6c86cf3fcdfef1e4b190e49a0296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Patch&lt;/code&gt; response HTTP header advertises which media-type the server is able to understand in a PATCH request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6003efca5251790ce42906144c5dccf2f87ad99b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Post&lt;/code&gt; response HTTP header advertises which &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;media types&lt;/a&gt; are accepted by the server for HTTP post requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1004b9f5d3731dda0f9cb684f40a19f9053e7da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept&lt;/code&gt; заголовок</target>
        </trans-unit>
        <trans-unit id="826c8958d78002b0f5bee62cfd9d7b4401ff27e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept&lt;/code&gt; request HTTP header advertises which content types, expressed as &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;, the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header. Browsers set adequate values for this header depending on the context where the request is done: when fetching a CSS stylesheet a different value is set for the request than when fetching an image, video or a script.</source>
          <target state="translated">&lt;code&gt;Accept&lt;/code&gt; запрос HTTP заголовок рекламирует какие типы контента, выраженные в виде &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;типов MIME&lt;/a&gt; , клиент может понять. Используя &lt;a href=&quot;../content_negotiation&quot;&gt;согласование содержимого&lt;/a&gt; , сервер затем выбирает одно из предложений, использует его и сообщает клиенту о своем выборе с помощью заголовка ответа &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; . Браузеры устанавливают адекватные значения для этого заголовка в зависимости от контекста, в котором выполняется запрос: при получении таблицы стилей CSS для запроса устанавливается другое значение, чем при получении изображения, видео или сценария.</target>
        </trans-unit>
        <trans-unit id="44e072ab59ddfb74fd5772684f9e86075ecb4b7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header works in conjunction with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;&lt;code&gt;XMLHttpRequest.withCredentials&lt;/code&gt;&lt;/a&gt; property or with the &lt;code&gt;credentials&lt;/code&gt; option in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/Request&quot;&gt;&lt;code&gt;Request()&lt;/code&gt;&lt;/a&gt; constructor of the Fetch API. For a CORS request with credentials, in order for browsers to expose the response to frontend JavaScript code, both the server (using the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header) and the client (by setting the credentials mode for the XHR, Fetch, or Ajax request) must indicate that they&amp;rsquo;re opting in to including credentials.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; заголовок работает в сочетании с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt; &lt;code&gt;XMLHttpRequest.withCredentials&lt;/code&gt; &lt;/a&gt; собственности или с &lt;code&gt;credentials&lt;/code&gt; опции в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/Request&quot;&gt; &lt;code&gt;Request()&lt;/code&gt; &lt;/a&gt; конструктор Fetch API. Для запроса CORS с учетными данными, чтобы браузеры могли предоставлять ответ на внешний код JavaScript, как сервер (с использованием заголовка &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; ), так и клиент (путем установки режима учетных данных для XHR, Fetch, или запрос Ajax) должен указывать, что они хотят включить учетные данные.</target>
        </trans-unit>
        <trans-unit id="b7dcdecf1d26a57b7f2c288b092d6918cb0c9128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header indicates whether or not the response to the request can be exposed to the page. It can be exposed when the &lt;code&gt;true&lt;/code&gt; value is returned.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; заголовка ответа указывает , является ли ответ на запрос может подвергаться странице. Его можно раскрыть, когда будет возвращено &lt;code&gt;true&lt;/code&gt; значение.</target>
        </trans-unit>
        <trans-unit id="3c6671b887bc83cf312809fdd2c8e99c4197d40f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header tells browsers whether to expose the response to frontend JavaScript code when the request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &quot;&lt;code&gt;include&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; заголовка ответа указывает браузеры ли открывающие ответ на FRONTEND код JavaScript , когда режим учетных данных по просьбе ( в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt; ) является &amp;laquo; &lt;code&gt;include&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f12c8be59963d49889bc73472fd35b514c851a07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header tells browsers whether to expose the response to frontend JavaScript code when the request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;include&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72353e1b96e08b162b2efe8857a396c5cd57de4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;; it lets the client know which &lt;a href=&quot;../../headers&quot;&gt;HTTP headers&lt;/a&gt; are permitted in CORS requests. If the client &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; finds among the comma-delineated values provided by the header any header name it does not recognize, this error occurs.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; заголовок отправляется сервером в ответ на &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;предполетной просьбу&lt;/a&gt; ; он позволяет клиенту узнать, какие &lt;a href=&quot;../../headers&quot;&gt;HTTP-заголовки&lt;/a&gt; разрешены в запросах CORS. Если клиентский &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;пользовательский агент&lt;/a&gt; находит среди значений, разделенных запятыми, предоставленных заголовком, какое-либо имя заголовка, которое он не распознает, возникает эта ошибка.</target>
        </trans-unit>
        <trans-unit id="0864906322164b5b88f217b19f6a18996814ca0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server to let the client know which headers it supports for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests. The value of &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; should be a comma-delineated list of header names, such as &quot;&lt;code&gt;X-Custom-Information&lt;/code&gt;&quot; or any of the standard but non-basic header names (which are always allowed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd672b7157d867818df2e4b6551047d6d6feb57a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server to let the client know which headers it supports for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests. The value of &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; should be a comma-delineated list of header names, such as &lt;code&gt;&quot;X-Custom-Information&quot;&lt;/code&gt; or any of the standard but non-basic header names (which are always allowed).</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; заголовок отправляется на сервер , чтобы позволить клиенту знать , какие заголовки он поддерживает для &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; запросов. Значение &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; должно быть разделенным запятыми списком имен заголовков, например &lt;code&gt;&quot;X-Custom-Information&quot;&lt;/code&gt; или любыми стандартными, но не базовыми именами заголовков (которые всегда разрешены).</target>
        </trans-unit>
        <trans-unit id="7ff32aaa41aa73f3f46503d5b741dbb0efe92ed8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; response header is used in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; which includes the &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; to indicate which HTTP headers can be used during the actual request.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; заголовок ответа используется в ответ на &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;предполетный запрос&lt;/a&gt; , который включает в себя &lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; , чтобы указать , какие HTTP заголовки может быть использована во время фактического запроса.</target>
        </trans-unit>
        <trans-unit id="e0316b88b462433d980db8987aaedc7affa9a74d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; header is sent by the server to let the client know what &lt;a href=&quot;../../methods&quot;&gt;HTTP request methods&lt;/a&gt; it supports for CORS requests. The header's value is a comma-delineated string of HTTP method names, such as &lt;a href=&quot;../../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;. If any of the specified values are not recognized by the client &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;, this error occurs.</source>
          <target state="translated">В &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; заголовка отправляемый сервер , чтобы позволить клиенту , что то , что &lt;a href=&quot;../../methods&quot;&gt;HTTP методов запроса&lt;/a&gt; он поддерживает для CORS запросов. Значение заголовка - это разделенная запятыми строка имен HTTP-методов, например &lt;a href=&quot;../../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; . Если какое-либо из указанных значений не распознается клиентским &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;пользовательским агентом&lt;/a&gt; , возникает эта ошибка.</target>
        </trans-unit>
        <trans-unit id="77116c8fb41e193fc817da845099a6fb246839d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; response header specifies the method or methods allowed when accessing the resource in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;.</source>
          <target state="translated">В &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; заголовок ответа определяет метод или методы позволили при обращении к ресурсу в ответ на &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;предполетную просьбу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="067f39d99ac015284dffa6b70703714ad54ce876" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; response header indicates which headers can be exposed as part of the response by listing their names.</source>
          <target state="translated">&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; заголовка ответа указывает на то, какие заголовки могут быть представлены как часть ответа, перечислив их имена.</target>
        </trans-unit>
        <trans-unit id="0d0b9369d0f212ed412c895390853280713fe380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; response header indicates how long the results of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; (that is the information contained in the &lt;a href=&quot;access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; headers) can be cached.</source>
          <target state="translated">&lt;code&gt;Access-Control-Max-Age&lt;/code&gt; заголовка ответа указывает на то, как долго результаты &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;предполетного запроса&lt;/a&gt; (то есть информация , содержащаяся в &lt;a href=&quot;access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt; заголовки) можно кэшировать.</target>
        </trans-unit>
        <trans-unit id="d911724c3b9a4293a98fa691e196743b5241679f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; request header is used by browsers when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;, to let the server know which &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; the client might send when the actual request is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafa896f612431fbab583cf168f3881c2f6b27aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; request header is used when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; to let the server know which &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; will be used when the actual request is made.</source>
          <target state="translated">&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; заголовок запроса используется при выдаче &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;предполетного запроса&lt;/a&gt; , чтобы позволить ноу - серверу , который &lt;a href=&quot;../headers&quot;&gt;HTTP заголовков&lt;/a&gt; будет использоваться , когда фактический запрос был сделан.</target>
        </trans-unit>
        <trans-unit id="da80f865ca3264cb02c6582db1c71f9050cac42c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; request header is used by browsers when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;, to let the server know which &lt;a href=&quot;../methods&quot;&gt;HTTP method&lt;/a&gt; will be used when the actual request is made. This header is necessary as the preflight request is always an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; and doesn't use the same method as the actual request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c04d281d947283fc5e13f4243911531dd1e81ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; request header is used when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; to let the server know which &lt;a href=&quot;../methods&quot;&gt;HTTP method&lt;/a&gt; will be used when the actual request is made. This header is necessary as the preflight request is always an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; and doesn't use the same method as the actual request.</source>
          <target state="translated">&lt;code&gt;Access-Control-Request-Method&lt;/code&gt; заголовок запроса используется при выдаче &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;предполетного запроса&lt;/a&gt; , чтобы позволить ноу - серверу , который &lt;a href=&quot;../methods&quot;&gt;HTTP метода&lt;/a&gt; будет использоваться , когда фактический запрос был сделан. Этот заголовок необходим, поскольку предварительный запрос всегда является &lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; и не использует тот же метод, что и фактический запрос.</target>
        </trans-unit>
        <trans-unit id="c0cd5616b768c68f7ab87609f718d08faf8821ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Age&lt;/code&gt; header is usually close to zero. If it is &lt;code&gt;Age: 0&lt;/code&gt;, it was probably just fetched from the origin server; otherwise It is usually calculated as a difference between the proxy's current date and the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; general header included in the HTTP response.</source>
          <target state="translated">&lt;code&gt;Age&lt;/code&gt; заголовок, как правило , близок к нулю. Если это &lt;code&gt;Age: 0&lt;/code&gt; , вероятно, он был только что получен с исходного сервера; в противном случае он обычно рассчитывается как разница между текущей датой прокси и общим заголовком &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; ,&lt;/a&gt; включенным в ответ HTTP.</target>
        </trans-unit>
        <trans-unit id="86a92479e304493df13e1947522f656380ef064d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alt-Svc&lt;/code&gt; HTTP response header is used to advertise alternative services through which the same resource can be reached. An alternative service is defined by a protocol/host/port combination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58db6b4226911c9c041223607c76d210c4b75632" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alt-Svc&lt;/code&gt; header is used to list alternate ways to reach this website.</source>
          <target state="translated">&lt;code&gt;Alt-Svc&lt;/code&gt; заголовок используется в список альтернативных способов достижения этого веб - сайта.</target>
        </trans-unit>
        <trans-unit id="f8bcd29c16619b65da2808b96987a30c145398a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; method establishes a tunnel to the server identified by the target resource.</source>
          <target state="translated">Метод &lt;code&gt;CONNECT&lt;/code&gt; устанавливает туннель к серверу, идентифицированному целевым ресурсом.</target>
        </trans-unit>
        <trans-unit id="d62340e78d8072dcadbb02101963582d73906639" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; method starts two-way communications with the requested resource. It can be used to open a tunnel.</source>
          <target state="translated">Метод &lt;code&gt;CONNECT&lt;/code&gt; запускает двустороннюю связь с запрошенным ресурсом. Его можно использовать для открытия туннеля.</target>
        </trans-unit>
        <trans-unit id="d8e201387bc9b6658a40f0cd1fa9bd028389520f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; starts two-way communications with the requested resource. It can be used to open a tunnel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6df08e573a851328603ffe071d7221d02feef0bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; HTTP header holds &lt;em&gt;directives&lt;/em&gt; (instructions) for &lt;a href=&quot;../caching&quot;&gt;caching&lt;/a&gt; in both requests and responses. A given directive in a request does not mean the same directive should be in the response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb3aeaa30daf04257b5de4b9c07c7b9084e9851" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; general-header field is used to specify directives for caching mechanisms in both requests and responses. Caching directives are unidirectional, meaning that a given directive in a request is not implying that the same directive is to be given in the response.</source>
          <target state="translated">Поле общего заголовка &lt;code&gt;Cache-Control&lt;/code&gt; используется для указания директив для механизмов кэширования как в запросах, так и в ответах. Директивы кэширования являются однонаправленными, что означает, что данная директива в запросе не подразумевает, что такая же директива должна быть указана в ответе.</target>
        </trans-unit>
        <trans-unit id="06a62b505dd9b8d1a88549c8be79a0204c13ff7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c781f98a9ab9c12f19392e18737aa478f857a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-control&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Cache-control&lt;/code&gt; заголовка</target>
        </trans-unit>
        <trans-unit id="c446d7df905a8656f6c8ae1eb3467db307c496ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clear-Site-Data&lt;/code&gt; header accepts one or more directives. If all types of data should be cleared, the wildcard directive (&lt;code&gt;&quot;*&quot;&lt;/code&gt;) can be used.</source>
          <target state="translated">&lt;code&gt;Clear-Site-Data&lt;/code&gt; заголовка принимает один или несколько директив. Если все типы данных должны быть очищены, можно использовать подстановочную директиву ( &lt;code&gt;&quot;*&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aaa643bf0a85cb5496af99271031c5e3d158467e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clear-Site-Data&lt;/code&gt; header clears browsing data (cookies, storage, cache) associated with the requesting website. It allows web developers to have more control over the data stored locally by a browser for their origins.</source>
          <target state="translated">&lt;code&gt;Clear-Site-Data&lt;/code&gt; заголовок очищает просматривающие данные (кук, хранение, кэш) , связанные с запрашивающим сайтом. Это позволяет веб-разработчикам иметь больший контроль над данными, хранящимися локально браузером для их источников.</target>
        </trans-unit>
        <trans-unit id="f577eabd139f31271f00d10bbba8aad8ea919cc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Connection&lt;/code&gt; general header controls whether or not the network connection stays open after the current transaction finishes. If the value sent is &lt;code&gt;keep-alive&lt;/code&gt;, the connection is persistent and not closed, allowing for subsequent requests to the same server to be done.</source>
          <target state="translated">В &lt;code&gt;Connection&lt;/code&gt; элементы управления общего заголовка или не открывать распорки подключения к сети после завершения текущей отделки транзакций. Если отправленное значение является &lt;code&gt;keep-alive&lt;/code&gt; , соединение является постоянным и не закрывается, что позволяет выполнять последующие запросы к тому же серверу.</target>
        </trans-unit>
        <trans-unit id="d537fcd6c95a2057cfd4527c292424b94b1ea111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Connection&lt;/code&gt; header is set to &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; to indicate that an upgrade is requested.</source>
          <target state="translated">&lt;code&gt;Connection&lt;/code&gt; заголовка устанавливается в &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; , чтобы указать , что обновление запрашивается.</target>
        </trans-unit>
        <trans-unit id="2861dc12e30d4470a55eeb695e751b55e5e6a33a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Disposition&lt;/code&gt; header is defined in the larger context of MIME messages for e-mail, but only a subset of the possible parameters apply to HTTP forms and &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests. Only the value &lt;code&gt;form-data&lt;/code&gt;, as well as the optional directive &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;, can be used in the HTTP context.</source>
          <target state="translated">&lt;code&gt;Content-Disposition&lt;/code&gt; заголовок определяется в более широком контексте сообщений MIME для электронной почты, но только часть из возможных параметров применяется к HTTP формы и &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; запросы. В контексте HTTP можно использовать только значение &lt;code&gt;form-data&lt;/code&gt; , а также необязательное &lt;code&gt;name&lt;/code&gt; директивы и &lt;code&gt;filename&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="488c45ed82b63009ef20ba093e068984681301a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Encoding&lt;/code&gt; entity header is used to compress the media-type. When present, its value indicates which encodings were applied to the entity-body. It lets the client know how to decode in order to obtain the media-type referenced by the &lt;code&gt;Content-Type&lt;/code&gt; header.</source>
          <target state="translated">&lt;code&gt;Content-Encoding&lt;/code&gt; заголовок объекта используется для сжатия типа носителя. Когда он присутствует, его значение указывает, какие кодировки были применены к телу объекта. Он позволяет клиенту знать, как выполнить декодирование, чтобы получить тип мультимедиа, на который ссылается заголовок &lt;code&gt;Content-Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43905a4350aba1098e2a710d64c8e9ee9088db8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt; header is used to specify the &lt;strong&gt; intended audience of the page&lt;/strong&gt;, and can indicate that this is more than one language.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; заголовок используется для определения &lt;strong&gt;целевой аудитории страницы&lt;/strong&gt; , и может указать , что это более чем на одном языке.</target>
        </trans-unit>
        <trans-unit id="76fdb5d41ede9d4b6ff14e156b9fc840583f22aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;entity header&lt;/a&gt; is used to &lt;strong&gt;describe the language(s) intended for the audience&lt;/strong&gt;, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7cdf9f8259b0b027b83c7eabaf300c7bb40cfcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;entity header&lt;/a&gt; is used to describe the language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;заголовок объекта&lt;/a&gt; используются для описания языка (ов) , предназначенными для зрителей, так что она позволяет пользователю различать в соответствии с собственным предпочитаемым языком пользователей.</target>
        </trans-unit>
        <trans-unit id="9ceb94b4b8102114799b44b32b66d5292b6f1285" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Length&lt;/code&gt; entity header indicates the size of the entity-body, in bytes, sent to the recipient.</source>
          <target state="translated">&lt;code&gt;Content-Length&lt;/code&gt; заголовок объект указывает размер тела объекта, в байтах, отправляется получателю.</target>
        </trans-unit>
        <trans-unit id="5d90bdb5582a8fea93b884b09c9eb8e68632eacc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Location&lt;/code&gt; header indicates an alternate location for the returned data. The principal use is to indicate the URL of a resource transmitted as the result of &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Content-Location&lt;/code&gt; заголовка указывает альтернативное расположение для возвращаемых данных. Основное использование - указать URL-адрес ресурса, переданного в результате &lt;a href=&quot;../content_negotiation&quot;&gt;согласования содержимого&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23071b7ae3831b0ab8df674533efac8686372e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Range&lt;/code&gt; response HTTP header indicates where in a full body message a partial message belongs.</source>
          <target state="translated">&lt;code&gt;Content-Range&lt;/code&gt; ответ HTTP заголовок указывает , где в полном сообщении тела принадлежит частичное сообщение.</target>
        </trans-unit>
        <trans-unit id="7a62e0c2806ef55661c99afdb86b1f8e171c816e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;strong&gt;&lt;dfn&gt;&lt;code&gt;Report-To&lt;/code&gt;&lt;/dfn&gt;&lt;/strong&gt; HTTP response header field instructs the user agent to store reporting endpoints for an origin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda7fd480680111156c0cfd188e09b05c5966f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Type&lt;/code&gt; entity header is used to indicate the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;media type&lt;/a&gt; of the resource.</source>
          <target state="translated">&lt;code&gt;Content-Type&lt;/code&gt; заголовок объекта используется для указания &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;типа носителя&lt;/a&gt; ресурса.</target>
        </trans-unit>
        <trans-unit id="426d10d47e9cd0040a6dc32d3445f661ae1dd5ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; HTTP request header contains stored &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; previously sent by the server with the &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">&lt;code&gt;Cookie&lt;/code&gt; заголовка запроса HTTP содержит хранится &lt;a href=&quot;../cookies&quot;&gt;HTTP куки&lt;/a&gt; , ранее отправленные сервером с &lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; заголовка.</target>
        </trans-unit>
        <trans-unit id="55cd10bb3eab56fcb3aaa9ed9e419b3b3cdd6947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; header is optional and may be omitted if, for example, the browser's privacy settings block cookies.</source>
          <target state="translated">&lt;code&gt;Cookie&lt;/code&gt; заголовка не является обязательным и может быть опущено , если, например, настройки конфиденциальности браузера блокирует куки.</target>
        </trans-unit>
        <trans-unit id="906194f2cbb1fc47870cf91c47d3fd010f4ebd31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; deletes the specified resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82dc9f4d351ce501d0f5c9cfab64763375d85ec2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; method deletes the specified resource.</source>
          <target state="translated">Метод &lt;code&gt;DELETE&lt;/code&gt; удаляет указанный ресурс.</target>
        </trans-unit>
        <trans-unit id="52d55ecc480b283f141b3b6f98cde8cb0145d572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DNT&lt;/code&gt; (&lt;strong&gt;D&lt;/strong&gt;o &lt;strong&gt;N&lt;/strong&gt;ot &lt;strong&gt;T&lt;/strong&gt;rack) request header indicates the user's tracking preference. It lets users indicate whether they would prefer privacy rather than personalized content.</source>
          <target state="translated">&lt;code&gt;DNT&lt;/code&gt; ( &lt;strong&gt;Д&lt;/strong&gt; о &lt;strong&gt;N&lt;/strong&gt; OT &lt;strong&gt;T&lt;/strong&gt; стойки) заголовка запроса указывает на то предпочтение отслеживания пользователя. Это позволяет пользователям указать, предпочитают ли они конфиденциальность, а не персонализированный контент.</target>
        </trans-unit>
        <trans-unit id="1cd717754d93b6be80da07e08c9fb1185b7e6942" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DPR&lt;/code&gt; header is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; headers which represents the client device pixel ratio (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DPR&quot;&gt;DPR&lt;/a&gt;), which is the the number of physical device pixels corresponding to every CSS pixel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ac6b7e2c0b37cbc89c1ece6a483f1521bccee2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Date&lt;/code&gt; general HTTP header contains the date and time at which the message was originated.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; заголовок HTTP вообще содержит дату и время , в которое было инициировано сообщение.</target>
        </trans-unit>
        <trans-unit id="2eebea2d9e6a6d288555a242f73a9f9b00abe276" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Device-Memory&lt;/code&gt; header is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Device_Memory_API&quot;&gt;Device Memory API&lt;/a&gt; header that works like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; header which represents the approximate amount of RAM client device has.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca5c6f26004ba8e513493500c35759b7d8670d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; attributes define the &lt;em&gt;scope&lt;/em&gt; of the cookie: what URLs the cookies should be sent to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b1269bf21dd422aa77c2c9c23ee0803a5f37a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; directives define the &lt;em&gt;scope&lt;/em&gt; of the cookie: what URLs the cookies should be sent to.</source>
          <target state="translated">В &lt;code&gt;Domain&lt;/code&gt; и &lt;code&gt;Path&lt;/code&gt; директивы определяют &lt;em&gt;объем&lt;/em&gt; куки: что URL - куки должны быть отправлены.</target>
        </trans-unit>
        <trans-unit id="bae089f0efeafa75b1ab5dc8946d17d6e70ec21e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; attribute specifies which hosts are allowed to receive the cookie. If unspecified, it defaults to the same &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt; that set the cookie, &lt;em&gt;excluding subdomains&lt;/em&gt;. If &lt;code&gt;Domain&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; specified, then subdomains are always included. Therefore, specifying &lt;code&gt;Domain&lt;/code&gt; is less restrictive than omitting it. However, it can be helpful when subdomains need to share information about a user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9c5ea9e0e528b35e54f97738194b2df17917c31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ETag&lt;/code&gt; HTTP response header is an identifier for a specific version of a resource. It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other (&quot;mid-air collisions&quot;).</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; заголовок HTTP - ответа является идентификатором для конкретной версии ресурса. Это позволяет кешам быть более эффективными и экономить полосу пропускания, поскольку веб-серверу не нужно отправлять полный ответ, если содержимое не изменилось. С другой стороны, если содержимое изменилось, etags полезны для предотвращения перезаписи одновременных обновлений ресурса друг друга (&amp;laquo;воздушные столкновения&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="08646657870bfe9fc25378ffe7f57b55887a674a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ETag&lt;/code&gt; HTTP response header is an identifier for a specific version of a resource. It lets caches be more efficient and save bandwidth, as a web server does not need to resend a full response if the content has not changed. Additionally, etags help prevent simultaneous updates of a resource from overwriting each other (&lt;a href=&quot;#Caching_of_unchanged_resources&quot;&gt;&quot;mid-air collisions&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b330412716d107192b6533fb30bf1581cd40ed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Early-Data&lt;/code&gt; header is &lt;strong&gt;not&lt;/strong&gt; set by the originator of the request (i.e., a browser).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26733480324535c0741d6a6528e1941641f5ce19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; заголовок позволяет сайты , чтобы выбрать в отчетности и / или приведении в исполнение требований сертификата прозрачности, которая предотвращает использование misissued сертификатов для этого сайта из незамеченным.</target>
        </trans-unit>
        <trans-unit id="d45aa61794fa19b9937294984a26564b7a2b70b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed. When a site enables the &lt;code&gt;Expect-CT&lt;/code&gt; header, they are requesting that the browser check that any certificate for that site appears in public CT logs.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; заголовок позволяет сайты , чтобы выбрать в отчетности и / или приведении в исполнение требований сертификата прозрачности, которая предотвращает использование misissued сертификатов для этого сайта из незамеченным. Когда сайт включает заголовок &lt;code&gt;Expect-CT&lt;/code&gt; , он запрашивает у браузера проверку наличия любого сертификата для этого сайта в общедоступных журналах CT.</target>
        </trans-unit>
        <trans-unit id="5a38756d00a5a11b921674c4de083e3755d47807" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header lets sites opt in to reporting and/or enforcement of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; requirements, to prevent the use of misissued certificates for that site from going unnoticed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5d41eb6b835eb5ad3b6e94b607f55e721d9fdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; will likely become obsolete in June 2021. Since May 2018 new certificates are expected to support SCTs by default. Certificates before March 2018 were allowed to have a lifetime of 39 months, those will all be expired in June 2021.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f567c805d3b14ec3ccf5444b3918351ca629ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect&lt;/code&gt; HTTP request header indicates expectations that need to be fulfilled by the server in order to properly handle the request.</source>
          <target state="translated">&lt;code&gt;Expect&lt;/code&gt; заголовок запроса HTTP указывает на то, что ожидания должны быть выполнены на сервере, чтобы правильно обработать запрос.</target>
        </trans-unit>
        <trans-unit id="ea971246a330c3fd5b0ad3d128ebdbac36f3fb88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Feature-Policy&lt;/code&gt; header has now been renamed to &lt;code&gt;Permissions-Policy&lt;/code&gt; in the spec, and this article will eventually be updated to reflect that change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9092e5df3d3c5b1e6e4085ebcd0973332a4819a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Forwarded&lt;/code&gt; header contains information from the &lt;a href=&quot;../proxy_servers_and_tunneling&quot;&gt;reverse proxy servers&lt;/a&gt; that is altered or lost when a proxy is involved in the path of the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43b4a38f617b0e601765fc7fa48f903467c8a77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Forwarded&lt;/code&gt; header contains information from the client-facing side of proxy servers that is altered or lost when a proxy is involved in the path of the request.</source>
          <target state="translated">&lt;code&gt;Forwarded&lt;/code&gt; заголовок содержит информацию от клиента обращенной стороны прокси - серверов , которые были изменены или потеряны , когда прокси участвуют в пути запроса.</target>
        </trans-unit>
        <trans-unit id="e7acf99131e3b502a504dfc606eb81c2fa8a3438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; method requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">Метод &lt;code&gt;GET&lt;/code&gt; запрашивает представление указанного ресурса. Запросы с использованием &lt;code&gt;GET&lt;/code&gt; должны только получать данные.</target>
        </trans-unit>
        <trans-unit id="f4a622f1f455f51e4324f29b7983e11b4aa63399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">&lt;code&gt;GET&lt;/code&gt; запрашивает представление указанного ресурса. Запросы с использованием &lt;code&gt;GET&lt;/code&gt; должны только получать данные.</target>
        </trans-unit>
        <trans-unit id="fe2a61ce5f6f874b6cccf46f639263ba9a7751c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; method asks for a response identical to that of a &lt;code&gt;GET&lt;/code&gt; request, but without the response body.</source>
          <target state="translated">Метод &lt;code&gt;HEAD&lt;/code&gt; запрашивает ответ, идентичный &lt;code&gt;GET&lt;/code&gt; запроса GET , но без тела ответа.</target>
        </trans-unit>
        <trans-unit id="8ab0b6ae10182c291f380700fbca30952dcca777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; requests the &lt;a href=&quot;../headers&quot;&gt;headers&lt;/a&gt; that would be returned if the &lt;code&gt;HEAD&lt;/code&gt; request's URL was instead requested with the HTTP &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method. For example, if a URL might produce a large download, a &lt;code&gt;HEAD&lt;/code&gt; request could read its &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header to check the filesize without actually downloading the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcdb3000e143a76a0cbe83303746d3c1a0deba82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; requests the headers that are returned if the specified resource would be requested with an HTTP &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method. Such a request can be done before deciding to download a large resource to save bandwidth, for example.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; запрашивает заголовки, которые возвращаются , если указанный ресурс будет предложен с помощью HTTP &lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; метода. Такой запрос может быть выполнен до принятия решения о загрузке большого ресурса, например, для экономии полосы пропускания.</target>
        </trans-unit>
        <trans-unit id="25050b6d25bf48e5e860b9e13a504c685ed5f20b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HttpOnly&lt;/code&gt; cookie attribute can help to mitigate this attack by preventing access to cookie value through JavaScript.</source>
          <target state="translated">&lt;code&gt;HttpOnly&lt;/code&gt; атрибут печенья может помочь смягчить эту атаку путем предотвращения доступа к значению печенья через JavaScript.</target>
        </trans-unit>
        <trans-unit id="4db136fae95161e355b0319d6e24b7eb8dde4690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource only if it matches one of the listed &lt;code&gt;ETags&lt;/code&gt;. For &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; and other non-safe methods, it will only upload the resource in this case.</source>
          <target state="translated">&lt;code&gt;If-Match&lt;/code&gt; заголовок запроса HTTP делает запрос условна. Для методов &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; сервер отправит обратно запрошенный ресурс, только если он соответствует одному из перечисленных &lt;code&gt;ETags&lt;/code&gt; . Для &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; и других небезопасных методов он будет загружать ресурс только в этом случае.</target>
        </trans-unit>
        <trans-unit id="89b34bc5ae9734af9081d0e5ea57512f4460ba59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Modified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it has been last modified after the given date. If the request has not been modified since, the response will be a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt; without any body; the &lt;a href=&quot;last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; response header of a previous request will contain the date of last modification. Unlike &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-Modified-Since&lt;/code&gt; can only be used with a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;If-Modified-Since&lt;/code&gt; запрос HTTP заголовка делает запрос условно: сервер будет отправлять обратно запрошенный ресурс, с &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; статусом, только если оно было отредактировано после указанной даты. Если запрос не был изменен с тех пор, ответом будет &lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; без тела; &lt;a href=&quot;last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; заголовок ответа предыдущего запроса будет содержать дату последнего изменения. В отличие от &lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;If-Modified-Since&lt;/code&gt; может использоваться только с &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5986b8f11ba0994d8a72e97fe21f90cc137ceae5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-None-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it doesn't have an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; matching the given ones. For other methods, the request will be processed only if the eventually existing resource's &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; doesn't match any of the values listed.</source>
          <target state="translated">&lt;code&gt;If-None-Match&lt;/code&gt; заголовок запроса HTTP делает запрос условна. Для методов &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; сервер отправит обратно запрошенный ресурс со статусом &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; , только если у него нет &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; ,&lt;/a&gt; соответствующего данным. Для других методов запрос будет обработан только в том случае, если &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; существующего в конечном итоге ресурса не соответствует ни одному из перечисленных значений.</target>
        </trans-unit>
        <trans-unit id="2724d0a408c5f3bcd5c0014c571f5f10868e51ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Range&lt;/code&gt; HTTP request header makes a range request conditional: if the condition is fulfilled, the range request will be issued and the server sends back a &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status.</source>
          <target state="translated">&lt;code&gt;If-Range&lt;/code&gt; заголовок запроса HTTP делает запрос диапазона условно: если условие выполняется, то запрос на диапазон будет выдан и сервер отправляет обратно &lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; ответа с соответствующим органом. Если условие не выполняется, возвращается полный ресурс со статусом &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22163b61a8a59a375d09bff2ee1f49eb81aa2552" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the request has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">&lt;code&gt;If-Unmodified-Since&lt;/code&gt; запрос HTTP заголовок делает запрос условный: сервер будет отправлять обратно запрошенный ресурс, или принять его в случае &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; или другого не- &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;безопасного&lt;/a&gt; метода, если только он не был изменен после того, как последним заданным Дата. Если запрос был изменен после указанной даты, ответом будет ошибка &lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; (Ошибка предварительного условия).</target>
        </trans-unit>
        <trans-unit id="33d2652dcdd336882d1ff7dcd4aab424143119d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the resource has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">&lt;code&gt;If-Unmodified-Since&lt;/code&gt; запрос HTTP заголовок делает запрос условный: сервер будет отправлять обратно запрошенный ресурс, или принять его в случае &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; или другого не- &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;безопасного&lt;/a&gt; метода, если только он не был изменен после того, как последним заданным Дата. Если ресурс был изменен после указанной даты, ответом будет ошибка &lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; (ошибка предварительного условия).</target>
        </trans-unit>
        <trans-unit id="c6e9dbc2bd4ee3beeb7dae2fbab0d0ed4f0f0c7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Large-Allocation&lt;/code&gt; header throws warnings or error messages when used incorrectly. You'll encounter them in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;web console&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; заголовок бросает предупреждения или сообщения об ошибках при неправильном использовании. Вы встретите их в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;веб-консоли&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f7bbba0c2fe1da5cfd40ee4dbb5a457286f63d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Last-Modified&lt;/code&gt; response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. Less accurate than an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header, it is a fallback mechanism. Conditional requests containing &lt;a href=&quot;if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; headers make use of this field.</source>
          <target state="translated">&lt;code&gt;Last-Modified&lt;/code&gt; ответ HTTP заголовок содержит дату и время, когда сервер происхождения полагает ресурс последнего изменения. Он используется в качестве валидатора, чтобы определить, является ли полученный или сохраненный ресурс одинаковым. Менее точный, чем заголовок &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; , это резервный механизм. В условных запросах, содержащих &lt;a href=&quot;if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; ,&lt;/a&gt; используется это поле.</target>
        </trans-unit>
        <trans-unit id="408faa70ae199f0916e25f0545a45cf1159c3a15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Location&lt;/code&gt; response header indicates the URL to redirect a page to. It only provides a meaning when served with a &lt;code&gt;3xx&lt;/code&gt; (redirection) or &lt;code&gt;201&lt;/code&gt; (created) status response.</source>
          <target state="translated">&lt;code&gt;Location&lt;/code&gt; заголовка ответа указывает URL для перенаправления на страницу. Он имеет смысл только при предоставлении ответа статуса &lt;code&gt;3xx&lt;/code&gt; (перенаправление) или &lt;code&gt;201&lt;/code&gt; (создано).</target>
        </trans-unit>
        <trans-unit id="7d4bbe1245321cac039158aa76ac84b747faeeee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; is used to describe the communication options for the target resource. The client can specify a URL for the OPTIONS method, or an asterisk (*) to refer to the entire server.</source>
          <target state="translated">В &lt;code&gt;OPTIONS&lt;/code&gt; используется для описания параметров связи для целевого ресурса. Клиент может указать URL-адрес для метода OPTIONS или звездочку (*) для ссылки на весь сервер.</target>
        </trans-unit>
        <trans-unit id="87018d773f4ad1701e531629a9f995260745c1b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; method is used to describe the communication options for the target resource.</source>
          <target state="translated">Метод &lt;code&gt;OPTIONS&lt;/code&gt; используется для описания параметров связи для целевого ресурса.</target>
        </trans-unit>
        <trans-unit id="a6e38b6b645f385912507ae1ea58453222ae125b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; requests permitted communication options for a given URL or server. A client can specify a URL with this method, or an asterisk (&lt;code&gt;*&lt;/code&gt;) to refer to the entire server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a07a0f8f183e5dac76997068b2e3c2b7238732b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Origin&lt;/code&gt; request header indicates where a fetch originates from. It doesn't include any path information, but only the server name. It is sent with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests, as well as with &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests. It is similar to the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, but, unlike this header, it doesn't disclose the whole path.</source>
          <target state="translated">&lt;code&gt;Origin&lt;/code&gt; заголовок запроса указывает , где выборка происходит из. Он не включает никакой информации о пути, а только имя сервера. Он отправляется с запросами &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; , а также с запросами &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; . Он похож на заголовок &lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; , но, в отличие от этого заголовка, он не раскрывает весь путь.</target>
        </trans-unit>
        <trans-unit id="fbfda01971457a54151941075f2b100b82e48523" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PATCH&lt;/code&gt; applies partial modifications to a resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9159e5596093f157b377894f822a924c1cb222b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PATCH&lt;/code&gt; method is used to apply partial modifications to a resource.</source>
          <target state="translated">Метод &lt;code&gt;PATCH&lt;/code&gt; используется для частичного изменения ресурса.</target>
        </trans-unit>
        <trans-unit id="1f5331c568d957daee441f1fc46cb653dfa3c711" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; method is used to submit an entity to the specified resource, often causing a change in state or side effects on the server.</source>
          <target state="translated">Метод &lt;code&gt;POST&lt;/code&gt; используется для отправки объекта указанному ресурсу, часто вызывая изменение состояния или побочные эффекты на сервере.</target>
        </trans-unit>
        <trans-unit id="3be3fad872235976dca00e40191bbd8a2412e11e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; sends data to the server. The type of the body of the request is indicated by the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; отправляет данные на сервер. Тип тела запроса указывается заголовком &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa5fa4af532ebd69d21f151a379cfa743406c0e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUT&lt;/code&gt; creates a new resource or replaces a representation of the target resource with the request payload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05eb025eb7c8b4be7ac86b298f646c06fa3ba3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUT&lt;/code&gt; method replaces all current representations of the target resource with the request payload.</source>
          <target state="translated">Метод &lt;code&gt;PUT&lt;/code&gt; заменяет все текущие представления целевого ресурса полезными данными запроса.</target>
        </trans-unit>
        <trans-unit id="6881c728a58c81e16c491c3900a0cb662b6f7797" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Path&lt;/code&gt; attribute indicates a URL path that must exist in the requested URL in order to send the &lt;code&gt;Cookie&lt;/code&gt; header. The &lt;code&gt;%x2F&lt;/code&gt; (&quot;/&quot;) character is considered a directory separator, and subdirectories match as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c89f21cbe09b59b1b9abe85e9acdd8ee45935d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pragma&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Pragma&lt;/code&gt; заголовок</target>
        </trans-unit>
        <trans-unit id="d99324cd748dcc4ddf7bf1ab613ab29af0de9abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Proxy-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Proxy-Authenticate&lt;/code&gt; заголовка отправляется вместе с &lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38b88eeb5a1167fff3d87ac75a5f9789ffbc4ed1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt; HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one &lt;code&gt;Range&lt;/code&gt; header at once, and the server may send back these ranges in a multipart document. If the server sends back ranges, it uses the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Partial Content&lt;/code&gt; for the response. If the ranges are invalid, the server returns the &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Range Not Satisfiable&lt;/code&gt; error. The server can also ignore the &lt;code&gt;Range&lt;/code&gt; header and return the whole document with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b15d048b735cd58d12cb36f1c04b433a92d0de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt; HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one &lt;code&gt;Range&lt;/code&gt; header at once, and the server may send back these ranges in a multipart document. If the server sends back ranges, it uses the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; for the response. If the ranges are invalid, the server returns the &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Range Not Satisfiable&lt;/code&gt; error. The server can also ignore the &lt;code&gt;Range&lt;/code&gt; header and return the whole document with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; заголовка запроса HTTP указывает часть документа , который сервер должен вернуть. С одним заголовком &lt;code&gt;Range&lt;/code&gt; можно запросить сразу несколько частей , и сервер может отправить обратно эти диапазоны в документе, состоящем из нескольких частей . Если сервер отправляет обратно диапазоны, он использует &lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; для ответа. Если диапазоны недействительны, сервер возвращает ошибку &lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Range Not Satisfiable&lt;/code&gt; . Сервер также может игнорировать заголовок &lt;code&gt;Range&lt;/code&gt; и возвращать весь документ с кодом состояния &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d730336d5f314e4ffb348e65cc342c819634ceb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header governs which referrer information, sent in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, should be included with requests made.</source>
          <target state="translated">&lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP заголовок определяет , какие сведения, посланные в ссылающейся &lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; заголовке, должен быть включен запросами , сделанных.</target>
        </trans-unit>
        <trans-unit id="76239ca8ee1c72f207bd371031df7511a9737ea4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Referrer-Policy&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP_header&quot;&gt;HTTP header&lt;/a&gt; controls how much &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Referer_header:_privacy_and_security_concerns&quot;&gt;referrer information&lt;/a&gt; (sent via the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header) should be included with requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="471a084b48fd4c8723f09a90baa8df53c1cd93e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Retry-After&lt;/code&gt; response HTTP header indicates how long the user agent should wait before making a follow-up request. There are three main cases this header is used:</source>
          <target state="translated">&lt;code&gt;Retry-After&lt;/code&gt; ответа HTTP заголовка указывает на то, как долго агент пользователя должен подождать , прежде чем сделать последующий запрос. Есть три основных случая использования этого заголовка:</target>
        </trans-unit>
        <trans-unit id="cd701418d7c6bf62926c6ad09e3776653cf803d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SameSite&lt;/code&gt; attribute accepts three values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12bf22b5dbc2a8c45c1d6d8c1615396a45809438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SameSite&lt;/code&gt; attribute lets servers require that a cookie shouldn't be sent with cross-origin requests (where &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Site&quot;&gt;Site&lt;/a&gt; is defined by the registrable domain), which provides some protection against cross-site request forgery attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRF&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c183288b7bfb9b7d64e4bb9f606b605293a750ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SameSite&lt;/code&gt; attribute of the &lt;a href=&quot;../set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; HTTP response header allows you to declare if your cookie should be restricted to a first-party or same-site context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff9a7daddb986f8f3e9947219b02e125a02e07a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Save-Data&lt;/code&gt; header field is a boolean which, in requests, indicates the client's preference for reduced data usage. This could be for reasons such as high transfer costs, slow connection speeds, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c50e0dbd49e9be339d0014ff98de27f5af6b7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-Dest&lt;/code&gt; fetch metadata header indicates the request's destination, that is how the fetched data will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31f9900ebfdde4aa1830afd97db024c6b3f830be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-Mode&lt;/code&gt; fetch metadata header indicates the request's mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25babdcd9266b9b2ebf26be60ebc0d7bfea878a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-Site&lt;/code&gt; fetch metadata header indicates the relationship between a request initiator's origin and the origin of the resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea3db281f732bb94a4a366b08b7f44ee831dbefd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-User&lt;/code&gt; fetch metadata header indicates whether or not a navigation request was triggered by a user activation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6374aa4b75562bedbe4aa399825eadf45d2253c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header specifies one or more WebSocket protocols that you wish to use, in order of preference. The first one that is supported by the server will be selected and returned by the server in a &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header included in the response. You can use this more than once in the header, as well; the result is the same as if you used a comma-delineated list of subprotocol identifiers in a single header.</source>
          <target state="translated">В &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; заголовка указывает один или более WebSocket протоколы , которые вы хотите использовать, в порядке предпочтения. Первый, который поддерживается сервером, будет выбран и возвращен сервером в заголовке &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; , включенном в ответ. Вы также можете использовать это более одного раза в заголовке; результат будет таким же, как если бы вы использовали разделенный запятыми список идентификаторов подпротоколов в одном заголовке.</target>
        </trans-unit>
        <trans-unit id="bcaa9b003cfb51a580c36805f7e5708f883883c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header communicates one or more metrics and descriptions for a given request-response cycle. It is used to surface any backend server timing metrics (e.g. database read/write, CPU time, file system access, etc.) in the developer tools in the user's browser or in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt;&lt;code&gt;PerformanceServerTiming&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; заголовка передает один или несколько метрик и описания для данного цикла запрос-ответ. Он используется для отображения любых метрик синхронизации внутреннего сервера (например, чтение / запись базы данных, время ЦП, доступ к файловой системе и т. Д.) В инструментах разработчика в браузере пользователя или в интерфейсе &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt; &lt;code&gt;PerformanceServerTiming&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58ba7a6637e80a2b7ed529a9998dc728401d3c92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header may expose potentially sensitive application and infrastructure information. Consider to control which metrics are returned when and to whom on the server side. For example, you could only show metrics to authenticated users and nothing to the public.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; заголовка может выставить потенциально важную информацию приложений и инфраструктуры. Подумайте о том, чтобы контролировать, какие метрики, когда и кому возвращаются на стороне сервера. Например, вы можете показывать показатели только аутентифицированным пользователям и ничего не показывать публике.</target>
        </trans-unit>
        <trans-unit id="55f111f3d740121c0376e9d447632d82acbbd389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP response header is used to send a cookie from the server to the user agent, so the user agent can send it back to the server later. To send multiple cookies, multiple &lt;code&gt;Set-Cookie&lt;/code&gt; headers should be sent in the same response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e616d6c13d2c598274b6aa0d7cf7d1cc7921936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP response header is used to send cookies from the server to the user agent.</source>
          <target state="translated">&lt;code&gt;Set-Cookie&lt;/code&gt; заголовка ответа HTTP используется для отправки печенье с сервера агента пользователя.</target>
        </trans-unit>
        <trans-unit id="d633495cdc7990d58394c50c8d640450b06b2d19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; and &lt;code&gt;Cookie&lt;/code&gt; headers</source>
          <target state="translated">В &lt;code&gt;Set-Cookie&lt;/code&gt; и &lt;code&gt;Cookie&lt;/code&gt; заголовки</target>
        </trans-unit>
        <trans-unit id="4ee3227d824b48a69ef6dfb672317e9a7fe813f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SourceMap&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header links generated code to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;source map&lt;/a&gt;, enabling the browser to reconstruct the original source and present the reconstructed original in the debugger.</source>
          <target state="translated">В &lt;code&gt;SourceMap&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; заголовок ответ ссылка сгенерированный код на &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;карту источника&lt;/a&gt; , что позволяет браузер реконструировать оригинал и представить восстановленный оригинал в отладчике.</target>
        </trans-unit>
        <trans-unit id="cc48476ae000e635700cbc6cc0b3e1b52a2ba404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Strict-Transport-Security&lt;/code&gt; response header (often abbreviated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) lets a web site tell browsers that it should only be accessed using HTTPS, instead of using HTTP.</source>
          <target state="translated">&lt;code&gt;Strict-Transport-Security&lt;/code&gt; заголовок ответа (часто сокращенно &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt; ) позволяет веб - сайт , сообщить браузеру , что он должен быть доступен только через HTTPS, вместо того , чтобы использовать HTTP.</target>
        </trans-unit>
        <trans-unit id="a54300d397ddd96a89ed7e4299d868f45d6d3b45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; method performs a message loop-back test along the path to the target resource.</source>
          <target state="translated">Метод &lt;code&gt;TRACE&lt;/code&gt; выполняет проверку обратной связи сообщения на пути к целевому ресурсу.</target>
        </trans-unit>
        <trans-unit id="f4e482563cca8b6b536cb03f419ca214a60b04b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; performs a message loop-back test along the path to the target resource, providing a useful debugging mechanism.</source>
          <target state="translated">&lt;code&gt;TRACE&lt;/code&gt; выполняет тест петли обратно сообщения по пути к целевому ресурсу, обеспечивая полезный механизм отладки.</target>
        </trans-unit>
        <trans-unit id="24a6cebd134cf5267f57018cea1581d2a79160d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tk&lt;/code&gt; response header indicates the tracking status that applied to the corresponding request.</source>
          <target state="translated">&lt;code&gt;Tk&lt;/code&gt; заголовка ответа указывает на состояние отслеживания , которая применяется к соответствующему запросу.</target>
        </trans-unit>
        <trans-unit id="661d8abe462ff964e30520abb6a9490ee2f57e77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Transfer-Encoding&lt;/code&gt; header specifies the form of encoding used to safely transfer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;entity&lt;/a&gt; to the user.</source>
          <target state="translated">&lt;code&gt;Transfer-Encoding&lt;/code&gt; заголовок определяет форму кодирования используется для безопасного переноса &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;лица&lt;/a&gt; пользователя.</target>
        </trans-unit>
        <trans-unit id="e80b8cf0899b9de1fbc8c3b7fc1f7628157f4015" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Transfer-Encoding&lt;/code&gt; header specifies the form of encoding used to safely transfer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Payload_body&quot;&gt;payload body&lt;/a&gt; to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4d1816f1bb2e8b52d94106ccb83a944a14eca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Upgrade&lt;/code&gt; header field may be used by clients to invite a server to switch to one (or more) of the listed protocols, in descending preference order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fd812100e724a16068b0d9d88fea979cbef78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Upgrade&lt;/code&gt; header specifies one or more comma-separated protocol names, in order of preference.</source>
          <target state="translated">В &lt;code&gt;Upgrade&lt;/code&gt; Header указывает один или несколько имен протоколов , разделенных запятыми, в порядке предпочтения.</target>
        </trans-unit>
        <trans-unit id="ba632e686f1f5e8841818ed95374f3d49208c686" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;User-Agent&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;User-Agent&lt;/code&gt; заголовка</target>
        </trans-unit>
        <trans-unit id="d7a5f551ef4f873a95fa7564b99b777f320ff383" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server. It is used by the server to indicate which headers it used when selecting a representation of a resource in a &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; algorithm.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; HTTP - заголовок ответа определяет , как соответствовать запросу в будущем заголовков , чтобы решить , можно ли использовать в кэше ответ , а не запрашивать свежую один из исходного сервера. Он используется сервером, чтобы указать, какие заголовки он использовал при выборе представления ресурса в алгоритме &lt;a href=&quot;../content_negotiation&quot;&gt;согласования содержимого&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b41f5b9f20c1124889bea2cf3b58e60fc1e6c962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header can also be useful for serving different content to desktop and mobile users, or to allow search engines to discover the mobile version of a page (and perhaps also tell them that no &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;Cloaking&lt;/a&gt; is intended). This is usually achieved with the &lt;code&gt;Vary: User-Agent&lt;/code&gt; header, and works because the &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; header value is different for mobile and desktop clients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="194b4e9dbe38f2da963d88dc0f228c708df4f3f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header should be set on a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; response exactly like it would have been set on an equivalent &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; response.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; заголовок должен быть установлен на &lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; ответа так же , как это было бы набор на эквивалентном &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; ответа.</target>
        </trans-unit>
        <trans-unit id="320c93529dc0245d276d67069f44ba338d5af1d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header was added in the version 1.1 of HTTP and is necessary in order to allow caches to work appropriately. A cache, in order to work with server-driven content negotiation, needs to know which criteria was used by the server to select the transmitted content. That way, the cache can replay the algorithm and will be able to serve acceptable content directly, without more request to the server. Obviously, the wildcard '&lt;code&gt;*&lt;/code&gt;' prevents caching from occurring, as the cache cannot know what element is behind it.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; заголовок был добавлен в версии 1.1 HTTP , и необходимо для того , чтобы позволить кэши , чтобы работать должным образом. Кэш, чтобы работать с согласованием контента, управляемым сервером, должен знать, какие критерии использовались сервером для выбора переданного контента. Таким образом, кеш может воспроизвести алгоритм и сможет обслуживать приемлемый контент напрямую, без дополнительных запросов к серверу. Очевидно, что подстановочный знак &amp;laquo; &lt;code&gt;*&lt;/code&gt; &amp;raquo; предотвращает кеширование, поскольку кеш не может знать, какой элемент скрывается за ним.</target>
        </trans-unit>
        <trans-unit id="76641ba7095f2c68f90780c9306f63f6bf04e9de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header was added in the version 1.1 of HTTP and is necessary in order to allow caches to work appropriately. A cache, in order to work with server-driven content negotiation, needs to know which criteria was used by the server to select the transmitted content. That way, the cache can replay the algorithm and will be able to serve acceptable content directly, without more request to the server. Obviously, the wildcard '&lt;code&gt;*&lt;/code&gt;' prevents caching from occurring, as the cache cannot know what element is behind it. For more information &lt;a href=&quot;caching#Varying_responses&quot;&gt;HTTP caching &amp;gt; Varying responses&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4bde9aa68e310507cb43566d5d20223a7c4d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; response header</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; заголовок ответа</target>
        </trans-unit>
        <trans-unit id="405a63b6723f58e2ec7f579da6d22e1185e2ba24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WWW-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; response.</source>
          <target state="translated">&lt;code&gt;WWW-Authenticate&lt;/code&gt; заголовок отправляются вместе с &lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; ответом.</target>
        </trans-unit>
        <trans-unit id="4c2052dca6314ec4744d6670a2fcfde4364c3176" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Warning&lt;/code&gt; general HTTP header contains information about possible problems with the status of the message. More than one &lt;code&gt;Warning&lt;/code&gt; header may appear in a response.</source>
          <target state="translated">Общий HTTP-заголовок &amp;laquo; &lt;code&gt;Warning&lt;/code&gt; содержит информацию о возможных проблемах со статусом сообщения. В ответе может отображаться более одного заголовка &amp;laquo; &lt;code&gt;Warning&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efe0fdb5e1f6f144e9e814a9d19ed38077ab4d3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Width&lt;/code&gt; request header field is a number that indicates the desired resource width in physical pixels (i.e. intrinsic size of an image). The provided pixel value is a number rounded to the smallest following integer (i.e. ceiling value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e5b0e1f18626b41321a488aa80a25f985f1deb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; HTTP response header controls DNS prefetching, a feature by which browsers proactively perform domain name resolution on both links that the user may choose to follow as well as URLs for items referenced by the document, including images, CSS, JavaScript, and so forth.</source>
          <target state="translated">В &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; контролирует заголовок ответа HTTP DNS упреждающая выборка, функция , с помощью которого браузеры активно выполнять разрешение доменных имен на обеих ссылок , которые пользователь может выбрать , чтобы следовать, а также URL - адреса для элементов , упоминаемых в документе, в том числе изображений, CSS , JavaScript и так далее.</target>
        </trans-unit>
        <trans-unit id="ff3dc3f28097222bbf317e1c8c99177c20310367" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-For&lt;/code&gt; (XFF) header is a de-facto standard header for identifying the originating IP address of a client connecting to a web server through an HTTP proxy or a load balancer. When traffic is intercepted between clients and servers, server access logs contain the IP address of the proxy or load balancer only. To see the original IP address of the client, the &lt;code&gt;X-Forwarded-For&lt;/code&gt; request header is used.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-For&lt;/code&gt; (XFF) заголовка является де-факто стандартный заголовок для идентификации IP - адрес , исходящих от клиента , подключенного к веб - серверу через HTTP прокси - сервер или балансировки нагрузки. Когда трафик перехватывается между клиентами и серверами, журналы доступа к серверу содержат только IP-адрес прокси или балансировщика нагрузки. Чтобы увидеть исходный IP-адрес клиента, используется заголовок запроса &lt;code&gt;X-Forwarded-For&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="482fcec20c0b4ec16aa7ff0f4a40cd4a8e96efd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Host&lt;/code&gt; (XFH) header is a de-facto standard header for identifying the original host requested by the client in the &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; HTTP request header.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-Host&lt;/code&gt; заголовка (XFH) является стандартом де-факто заголовок для идентификации оригинального хоста , запрошенный клиентом в &lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; - заголовка запроса HTTP.</target>
        </trans-unit>
        <trans-unit id="ac80a173a5330f7e0e915503af16d57814a7f24e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; (XFP) header is a de-facto standard header for identifying the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer. Your server access logs contain the protocol used between the server and the load balancer, but not the protocol used between the client and the load balancer. To determine the protocol used between the client and the load balancer, the &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; request header can be used.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-Proto&lt;/code&gt; заголовок (XFP) является стандартом де-факто заголовок для идентификации протокола (HTTP или HTTPS) , что клиент , используемый для подключения к прокси - сервер или балансировки нагрузки. Журналы доступа к серверу содержат протокол, используемый между сервером и балансировщиком нагрузки, но не протокол, используемый между клиентом и балансировщиком нагрузки. Чтобы определить протокол, используемый между клиентом и балансировщиком нагрузки, можно использовать заголовок запроса &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7641932b013d9ddf2ffa745ed9e59704ae3a5eaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; . Sites can use this to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;clickjacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; - заголовок ответа может быть использован , чтобы указать , должен ли браузер разрешено отобразить страницу в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; . Сайты могут использовать это, чтобы избежать атак с использованием &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;кликджекинга&lt;/a&gt; , гарантируя, что их контент не встроен в другие сайты.</target>
        </trans-unit>
        <trans-unit id="f8fc0e13a5bd95f55b983508d376db1ef57d9475" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; . Sites can use this to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;clickjacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c716845b63ad60de10c5d0721c333cc0a7789d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;. Sites can use this to avoid &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Click-jacking&quot;&gt;click-jacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691c4a3bae3f1a7c0be3c3aed1c8e618e4fcd9e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delta-seconds&lt;/code&gt; parameter indicates the number of seconds the results can be cached.</source>
          <target state="translated">Параметр &lt;code&gt;delta-seconds&lt;/code&gt; указывает количество секунд, в течение которых результаты могут быть кэшированы.</target>
        </trans-unit>
        <trans-unit id="b2e68877049d392fb0d9efdba7e61a35e4736a2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame-ancestors&lt;/code&gt; directive&amp;rsquo;s syntax is similar to a source list of other directives (e.g. &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;), but doesn't allow &lt;code&gt;'unsafe-eval'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; for example. It will also not fall back to a &lt;code&gt;default-src&lt;/code&gt; setting. Only the sources listed below are allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8325de55392dc75d103db2ad034803012b8edc93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame-ancestors&lt;/code&gt; directive&amp;rsquo;s syntax is similar to a source list of other directives (e.g. &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;, but doesn't allow &lt;code&gt;'unsafe-eval'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; for example. It will also not fall back to a &lt;code&gt;default-src&lt;/code&gt; setting. Only the sources listed below are allowed:</source>
          <target state="translated">В &lt;code&gt;frame-ancestors&lt;/code&gt; синтаксис директивы похож на список источников других директив (например , по &lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; , но не позволяет &lt;code&gt;'unsafe-eval'&lt;/code&gt; или &lt;code&gt;'unsafe-inline'&lt;/code&gt; , например. Он также не падать обратно в &lt;code&gt;default-src&lt;/code&gt; . Разрешены только источники, перечисленные ниже:</target>
        </trans-unit>
        <trans-unit id="e84f1d948281d5568220728b9d276abf0bdd4199" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;https://foo.example&lt;/code&gt; origin is permitted to request the &lt;code&gt;bar.example/resources/post-here/&lt;/code&gt; URL via the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d731b7e80edba53bed02fe84939621f3420c12d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; makes it case-insensitive, and &lt;code&gt;mobi&lt;/code&gt; matches all mobile browsers.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; делаю его не чувствителен к регистру, и &lt;code&gt;mobi&lt;/code&gt; соответствует всем мобильным браузерам.</target>
        </trans-unit>
        <trans-unit id="6ff2a01caeced20b51683f18c74fcf809d0a629a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;infile&lt;/code&gt; parameter is the name of the file you wish to encode into base64 format, and &lt;code&gt;remotename&lt;/code&gt; is the remote name for the file, which isn't actually used in &lt;code&gt;data&lt;/code&gt; URLs.</source>
          <target state="translated">&lt;code&gt;infile&lt;/code&gt; параметр является именем файла , который вы хотите закодировать в формат base64 и &lt;code&gt;remotename&lt;/code&gt; это имя удаленного файл, который фактически не используется в &lt;code&gt;data&lt;/code&gt; URL.</target>
        </trans-unit>
        <trans-unit id="604f09cfd89d091aa486d6636b750613f4f96b4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mediatype&lt;/code&gt; is a &lt;a href=&quot;mime_types&quot;&gt;MIME type&lt;/a&gt; string, such as &lt;code&gt;'image/jpeg'&lt;/code&gt; for a JPEG image file. If omitted, defaults to &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e539bd2196b041a5032c2ef5a8994c7b7bde4dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mediatype&lt;/code&gt; is a MIME type string, such as &lt;code&gt;'image/jpeg'&lt;/code&gt; for a JPEG image file. If omitted, defaults to &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mediatype&lt;/code&gt; строкового типа MIME, такие как &lt;code&gt;'image/jpeg'&lt;/code&gt; для файла изображения JPEG. Если не указано, по умолчанию используется &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da52d7b321f788536d3829326d49c595d809fbf1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/byteranges&lt;/code&gt; MIME type is used to send partial responses to the browser.</source>
          <target state="translated">&lt;code&gt;multipart/byteranges&lt;/code&gt; типа MIME используются для отправки частичных ответов на браузер.</target>
        </trans-unit>
        <trans-unit id="13ff0ccca95ad2dd6f5550002a8ef74789370c1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/form-data&lt;/code&gt; type can be used when sending the values of a completed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Form&lt;/a&gt; from browser to server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4a04b22f0b8d9d9056086ed2761a4ce7474e18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/form-data&lt;/code&gt;type can be used when sending the values of a completed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Form&lt;/a&gt; from browser to server.</source>
          <target state="translated">Тип &lt;code&gt;multipart/form-data&lt;/code&gt; можно использовать при отправке значений заполненной &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML-формы&lt;/a&gt; из браузера на сервер.</target>
        </trans-unit>
        <trans-unit id="5ed16b201bb930d269ec462a17331c9fe9b5c948" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no-store&lt;/code&gt; directive will prevent a new resource being cached, but it will not prevent the cache from responding with a non-stale resource that was cached as the result of an earlier request. Setting &lt;code&gt;max-age=0&lt;/code&gt; as well forces the cache to revalidate (clears the cache).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d35dc77974d9a90114bab977a8eb5559894a4d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;payment&lt;/code&gt; feature's default allowlist value is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa620fbdcb9cf9072c11203ebc2680fadd85c4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict-dynamic&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any allow-list or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; are ignored. See &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; for an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82adb286ff040efc04b5588e84c42dc13b4b83e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict-dynamic&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. See &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; for an example.</source>
          <target state="translated">В &lt;code&gt;strict-dynamic&lt;/code&gt; выражении источника указует , что траст явно приведенный в сценарии , присутствующий в разметке, сопровождая его с одноразовым номером или хэшем, должны распространяться на все сценарии , загруженных этим корневого сценарий. В то же время любые выражения из белого списка или источника, такие как &lt;code&gt;'self'&lt;/code&gt; или &lt;code&gt;'unsafe-inline'&lt;/code&gt; будут игнорироваться. См. Пример &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3dc0a625918a10bc3cf47e685dbed66f751c4502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive is evaluated before &lt;a href=&quot;block-all-mixed-content&quot;&gt;&lt;code&gt;block-all-mixed-content&lt;/code&gt;&lt;/a&gt; and if it is set, the latter is effectively a no-op. It is recommended to set either directive, but not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">&lt;code&gt;upgrade-insecure-requests&lt;/code&gt; директива вычисляется перед &lt;a href=&quot;block-all-mixed-content&quot;&gt; &lt;code&gt;block-all-mixed-content&lt;/code&gt; &lt;/a&gt; , и если он установлен, то последний не является эффективно не оп. Рекомендуется установить любую директиву, но не обе, если только вы не хотите принудительно использовать HTTPS в старых браузерах, которые не заставляют его после перенаправления на HTTP.</target>
        </trans-unit>
        <trans-unit id="67a6354b055d21e0ec5e6eda7647d60f1e916b1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive will not ensure that users visiting your site via links on third-party sites will be upgraded to HTTPS for the top-level navigation and thus does not replace the &lt;a href=&quot;../strict-transport-security&quot;&gt;&lt;code&gt;Strict-Transport-Security&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) header, which should still be set with an appropriate &lt;code&gt;max-age&lt;/code&gt; to ensure that users are not subject to SSL stripping attacks.</source>
          <target state="translated">&lt;code&gt;upgrade-insecure-requests&lt;/code&gt; директива не будет гарантировать , что пользователи посещают сайт с помощью ссылок на сторонних сайтах будут обновлены до HTTPS для навигации верхнего уровня и , таким образом , не заменяет &lt;a href=&quot;../strict-transport-security&quot;&gt; &lt;code&gt;Strict-Transport-Security&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt; ) заголовок, который все равно должен быть установлен соответствующий &lt;code&gt;max-age&lt;/code&gt; чтобы гарантировать, что пользователи не будут подвержены атакам с удалением SSL.</target>
        </trans-unit>
        <trans-unit id="6a8d44d29e56bc0c55ce499b78519e2f545a58b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;HTTP version&lt;/em&gt;, which defines the structure of the remaining message, acting as an indicator of the expected version to use for the response.</source>
          <target state="translated">Версия &lt;em&gt;HTTP&lt;/em&gt; , которая определяет структуру оставшегося сообщения, действуя как индикатор ожидаемой версии, которая будет использоваться для ответа.</target>
        </trans-unit>
        <trans-unit id="534c7de6c70ce30d5cc7ac84f7a1d413ddee5f41" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;asterisk form&lt;/em&gt;, a simple asterisk (&lt;code&gt;'*'&lt;/code&gt;) is used with &lt;code&gt;OPTIONS&lt;/code&gt;, representing the server as a whole.</source>
          <target state="translated">Форма &lt;em&gt;звездочки&lt;/em&gt; , простая звездочка ( &lt;code&gt;'*'&lt;/code&gt; ) используется с &lt;code&gt;OPTIONS&lt;/code&gt; , представляя сервер в целом.</target>
        </trans-unit>
        <trans-unit id="e9fb04fb929e15b710da1fe284b86de9e6922e23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;protocol version&lt;/em&gt;, usually &lt;code&gt;HTTP/1.1&lt;/code&gt;.</source>
          <target state="translated">Версия &lt;em&gt;протокола&lt;/em&gt; , обычно &lt;code&gt;HTTP/1.1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57141383ea92e8d11fc4aae1bb6ea799c9f809f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request target&lt;/em&gt;, usually a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;, or the absolute path of the protocol, port, and domain are usually characterized by the request context. The format of this request target varies between different HTTP methods. It can be</source>
          <target state="translated">Цель &lt;em&gt;запроса&lt;/em&gt; , обычно &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL-адрес&lt;/a&gt; или абсолютный путь протокола, порта и домена, обычно характеризуются контекстом запроса. Формат этой цели запроса зависит от разных методов HTTP. Может быть</target>
        </trans-unit>
        <trans-unit id="f9cc4edb4b5b40b8f3c061c79a6b4c632e4c730a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user-agent&lt;/em&gt; is any tool that acts on the behalf of the user. This role is primarily performed by the Web browser; a few exceptions being programs used by engineers, and Web developers to debug their applications.</source>
          <target state="translated">&lt;em&gt;Агент пользователя&lt;/em&gt; является любым инструментом , который действует от имени пользователя. Эту роль в основном выполняет веб-браузер; за некоторыми исключениями являются программы, используемые инженерами и веб-разработчиками для отладки своих приложений.</target>
        </trans-unit>
        <trans-unit id="094e3c74b2c1d28d2f1a69f2c5868e7adb3602cc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user-agent&lt;/em&gt; is any tool that acts on the behalf of the user. This role is primarily performed by the Web browser; other possibilities are programs used by engineers and Web developers to debug their applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ff728fce867d59850505a9f213412ce8cd201b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;var&gt;type&lt;/var&gt;&lt;/strong&gt; represents the general category into which the data type falls, such as &lt;code&gt;video&lt;/code&gt; or &lt;code&gt;text&lt;/code&gt;. The &lt;strong&gt;&lt;var&gt;subtype&lt;/var&gt;&lt;/strong&gt; identifies the exact kind of data of the specified type the MIME type represents. For example, for the MIME type &lt;code&gt;text&lt;/code&gt;, the subtype might be &lt;code&gt;plain&lt;/code&gt; (plain text), &lt;code&gt;html&lt;/code&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt; source code), or &lt;code&gt;calendar&lt;/code&gt; (for iCalendar/&lt;code&gt;.ics&lt;/code&gt;) files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b83df44d3d37a4c410b129685134339244574f5" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Alt-Svc&lt;/strong&gt; header is used to list alternate ways to reach this website.</source>
          <target state="translated">&lt;strong&gt;Alt-Svc&lt;/strong&gt; заголовок используется в список альтернативных способов достижения этого веб - сайта.</target>
        </trans-unit>
        <trans-unit id="8c3c79f7301c1c8d0fa9e587ad3fa734394dfbe4" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP DELETE request method&lt;/strong&gt; deletes the specified resource.</source>
          <target state="translated">Метод &lt;strong&gt;запроса HTTP DELETE&lt;/strong&gt; удаляет указанный ресурс.</target>
        </trans-unit>
        <trans-unit id="8f98d07b9e286fdee4af0bfd151e3fef8b4e1fdf" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PATCH request method&lt;/strong&gt; applies partial modifications to a resource.</source>
          <target state="translated">Метод &lt;strong&gt;запроса HTTP PATCH&lt;/strong&gt; применяет частичные изменения к ресурсу.</target>
        </trans-unit>
        <trans-unit id="2f72c255d4cd8cf0faaa3dfd5ef732d3c26ae02b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PUT request method&lt;/strong&gt; creates a new resource or replaces a representation of the target resource with the request payload.</source>
          <target state="translated">Метод &lt;strong&gt;запроса HTTP PUT&lt;/strong&gt; создает новый ресурс или заменяет представление целевого ресурса полезными данными запроса.</target>
        </trans-unit>
        <trans-unit id="617a279a7f85aa11b7e9119c0549c65940ed8bdb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Sec-WebSocket-Accept&lt;/strong&gt; header is used in the websocket opening handshake. It would appear in the response headers. That is, this is header is sent from server to client to inform that server is willing to initiate a websocket connection.</source>
          <target state="translated">&lt;strong&gt;Втор-WebSocket-Accept&lt;/strong&gt; заголовок используется в открытии WebSocket квитирования. Он появится в заголовках ответов. То есть этот заголовок отправляется от сервера к клиенту, чтобы сообщить, что сервер готов инициировать соединение через веб-сокет.</target>
        </trans-unit>
        <trans-unit id="fec1b2ea30a4b23ec6ed613fb4a58917ff6f2e5d" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Trailer&lt;/strong&gt; response header allows the sender to include additional fields at the end of chunked messages in order to supply metadata that might be dynamically generated while the message body is sent, such as a message integrity check, digital signature, or post-processing status.</source>
          <target state="translated">&lt;strong&gt;Трейлер&lt;/strong&gt; заголовок ответа позволяет отправителю включать в себя дополнительные поля в конце фрагментированных сообщений для того , чтобы метаданные питания , которые могут быть динамически генерируемым в то время как тело сообщения посылаются, например, проверка целостности сообщения, цифровая подпись, или статус поста-обработки.</target>
        </trans-unit>
        <trans-unit id="72b737b3f7ebb245858f1a5344bbb6bcfd1d296b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;User-Agent&lt;/strong&gt; request header contains a characteristic string that allows the network protocol peers to identify the application type, operating system, software vendor or software version of the requesting software user agent.</source>
          <target state="translated">&lt;strong&gt;User-Agent&lt;/strong&gt; заголовок запроса содержит характерную строку , которая позволяет сверстникам сетевого протокола , чтобы идентифицировать тип приложения, операционную систему, программное обеспечение от поставщика или версии программного обеспечения запрашивающего пользователя программного агента.</target>
        </trans-unit>
        <trans-unit id="2288013069b97e56ffbc4768d5888642c23e6913" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;User-Agent&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/request_header&quot;&gt;request header&lt;/a&gt; is a characteristic string that lets servers and network peers identify the application, operating system, vendor, and/or version of the requesting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808b80dac820b6a1614956c81b08b2381235cc1b" translate="yes" xml:space="preserve">
          <source>The Accept header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7fb45a1dfda8bd680e10b36530ac6598af98b2" translate="yes" xml:space="preserve">
          <source>The Accept request-header field can be used to specify certain media
   types which are acceptable for the response. Accept headers can be
   used to indicate that the request is specifically limited to a small
   set of desired types, as in the case of a request for an in-line
   image.

       Accept         = &quot;Accept&quot; &quot;:&quot;
                        #( media-range [ accept-params ] )

       media-range    = ( &quot;*/*&quot;
                        | ( type &quot;/&quot; &quot;*&quot; )
                        | ( type &quot;/&quot; subtype )
                        ) *( &quot;;&quot; parameter )
       accept-params  = &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue *( accept-extension )
       accept-extension = &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]

   The asterisk &quot;*&quot; character is used to group media types into ranges,
   with &quot;*/*&quot; indicating all media types and &quot;type/*&quot; indicating all
   subtypes of that type. The media-range MAY include media type
   parameters that are applicable to that range.

   Each media-range MAY be followed by one or more accept-params,
   beginning with the &quot;q&quot; parameter for indicating a relative quality
   factor. The first &quot;q&quot; parameter (if any) separates the media-range
   parameter(s) from the accept-params. Quality factors allow the user
   or user agent to indicate the relative degree of preference for that
   media-range, using the qvalue scale from 0 to 1 (&lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;). The
   default value is q=1.

      Note: Use of the &quot;q&quot; parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice. Although this prevents any media type parameter named
      &quot;q&quot; from being used with a media range, such an event is believed
      to be unlikely given the lack of any &quot;q&quot; parameters in the IANA
      media type registry and the rare usage of any media type
      parameters in Accept. Future media types are discouraged from
      registering any parameter named &quot;q&quot;. 

   The example

       Accept: audio/*; q=0.2, audio/basic

   SHOULD be interpreted as &quot;I prefer audio/basic, but send me any audio
   type if it is the best available after an 80% mark-down in quality.&quot;

   If no Accept header field is present, then it is assumed that the
   client accepts all media types. If an Accept header field is present,
   and if the server cannot send a response which is acceptable
   according to the combined Accept field value, then the server SHOULD
   send a 406 (not acceptable) response.

   A more elaborate example is

       Accept: text/plain; q=0.5, text/html,
               text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as &quot;text/html and text/x-c are
   the preferred media types, but if they do not exist, then send the
   text/x-dvi entity, and if that does not exist, send the text/plain
   entity.&quot;

   Media ranges can be overridden by more specific media ranges or
   specific media types. If more than one media range applies to a given
   type, the most specific reference has precedence. For example,

       Accept: text/*, text/html, text/html;level=1, */*

   have the following precedence:

       1) text/html;level=1
       2) text/html
       3) text/*
       4) */*

   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   which matches that type. For example,

       Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
               text/html;level=2;q=0.4, */*;q=0.5

   would cause the following values to be associated:

       text/html;level=1         = 1
       text/html                 = 0.7
       text/plain                = 0.3 

       image/jpeg                = 0.5
       text/html;level=2         = 0.4
       text/html;level=3         = 0.7

      Note: A user agent might be provided with a default set of quality
      values for certain media ranges. However, unless the user agent is
      a closed system which cannot interact with other rendering agents,
      this default set ought to be configurable by the user.</source>
          <target state="translated">Поле заголовка запроса Accept может использоваться для указания определенных типов мультимедиа, приемлемых для ответа. Заголовки принятия могут использоваться, чтобы указать, что запрос конкретно ограничен небольшим набором желаемых типов, как в случае запроса встроенного изображения. Accept = &quot;Accept&quot; &quot;:&quot; # (media-range [accept-params]) media-range = (&quot;* / *&quot; | (type &quot;/&quot; &quot;*&quot;) | (type &quot;/&quot; подтип)) * ( &quot;;&quot; параметр) accept-params = &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue * (accept-extension) accept-extension = &quot;;&quot; токен [&quot;=&quot; (токен | строка в кавычках)] Звездочка &quot;*&quot;Символ используется для группировки типов мультимедиа в диапазоны, где &amp;laquo;* / *&amp;raquo; указывает все типы мультимедиа, а &amp;laquo;type / *&amp;raquo; указывает все подтипы этого типа. Медиа-диапазон МОЖЕТ включать в себя параметры типа носителя, применимые к этому диапазону. За каждым медиа-диапазоном МОЖЕТ следовать один или несколько accept-params, начиная с параметра &amp;laquo;q&amp;raquo; для указания относительного коэффициента качества. Первый параметр &amp;laquo;q&amp;raquo; (если есть) отделяет параметр (ы) медиа-диапазона от принимаемых параметров. Коэффициенты качества позволяют пользователю или пользовательскому агенту указать относительную степень предпочтения для этого диапазона мультимедиа, используя шкалу qvalue от 0 до 1 (Медиа-диапазон МОЖЕТ включать в себя параметры типа носителя, применимые к этому диапазону. За каждым медиа-диапазоном МОЖЕТ следовать один или несколько accept-params, начиная с параметра &amp;laquo;q&amp;raquo; для указания относительного коэффициента качества. Первый параметр &amp;laquo;q&amp;raquo; (если есть) отделяет параметр (ы) медиа-диапазона от принимаемых параметров. Коэффициенты качества позволяют пользователю или пользовательскому агенту указать относительную степень предпочтения для этого диапазона мультимедиа, используя шкалу qvalue от 0 до 1 (Медиа-диапазон МОЖЕТ включать в себя параметры типа носителя, применимые к этому диапазону. За каждым медиа-диапазоном МОЖЕТ следовать один или несколько accept-params, начиная с параметра &amp;laquo;q&amp;raquo; для указания относительного коэффициента качества. Первый параметр &amp;laquo;q&amp;raquo; (если есть) отделяет параметр (ы) медиа-диапазона от принимаемых параметров. Коэффициенты качества позволяют пользователю или пользовательскому агенту указать относительную степень предпочтения для этого диапазона мультимедиа, используя шкалу qvalue от 0 до 1 (Коэффициенты качества позволяют пользователю или пользовательскому агенту указать относительную степень предпочтения для этого диапазона мультимедиа, используя шкалу qvalue от 0 до 1 (Коэффициенты качества позволяют пользователю или пользовательскому агенту указать относительную степень предпочтения для этого диапазона мультимедиа, используя шкалу qvalue от 0 до 1 (&lt;a href=&quot;#section-3.9&quot;&gt;Раздел 3.9&lt;/a&gt;). Значение по умолчанию - q = 1. Примечание. Использование имени параметра &amp;laquo;q&amp;raquo; для отделения параметров типа мультимедиа от параметров расширения Accept связано с исторической практикой. Хотя это предотвращает использование любого параметра типа носителя с именем &amp;laquo;q&amp;raquo; с диапазоном носителей, такое событие считается маловероятным, учитывая отсутствие каких-либо параметров &amp;laquo;q&amp;raquo; в реестре типов носителей IANA и редкое использование любого типа носителя. параметры в Accept. В будущих типах носителей не рекомендуется регистрировать какой-либо параметр с именем &amp;laquo;q&amp;raquo;. Пример Accept: audio / *; q = 0,2, audio / basic СЛЕДУЕТ интерпретировать как &amp;laquo;Я предпочитаю audio / basic, но присылайте мне любой тип звука, если он является лучшим из доступных после снижения качества на 80%&amp;raquo;. Если поле заголовка Accept отсутствует,тогда предполагается, что клиент принимает все типы носителей. Если присутствует поле заголовка Accept, и если сервер не может отправить ответ, который является приемлемым в соответствии с объединенным значением поля Accept, то серверу СЛЕДУЕТ отправить ответ 406 (неприемлемо). Более сложный пример - Accept: text / plain; q = 0,5, текст / HTML, текст / x-dvi; q = 0.8, text / xc На словах это будет интерпретироваться как &amp;laquo;text / html и text / xc являются предпочтительными типами мультимедиа, но если они не существуют, отправьте объект text / x-dvi, и если это не так. существуют, отправьте текст / простой объект &quot;. Диапазоны носителей могут быть переопределены более конкретными диапазонами носителей или конкретными типами носителей. Если к данному типу применяется более одного диапазона носителей, приоритет имеет наиболее конкретная ссылка. Например, Принять:text / *, text / html, text / html; level = 1, * / * имеют следующий приоритет: 1) text / html; level = 1 2) text / html 3) text / * 4) * / * Медиа Фактор качества, связанный с данным типом, определяется путем нахождения диапазона носителей с наивысшим приоритетом, который соответствует этому типу. Например, Accept: text / *; q = 0,3, text / html; q = 0,7, text / html; level = 1, text / html; level = 2; q = 0,4, * / *; q = 0,5 вызовет следующие значения должны быть связаны: text / html; level = 1 = 1 text / html = 0.7 text / plain = 0.3 image / jpeg = 0.5 text / html; level = 2 = 0.4 text / html; level = 3 = 0.7 Примечание. : Агенту пользователя может быть предоставлен набор значений качества по умолчанию для определенных диапазонов мультимедиа.Однако, если пользовательский агент не является закрытой системой, которая не может взаимодействовать с другими агентами рендеринга, этот набор по умолчанию должен быть настроен пользователем.</target>
        </trans-unit>
        <trans-unit id="e7b4f26fbb0e2bce3365129a80d0fb7728e75c9b" translate="yes" xml:space="preserve">
          <source>The Accept-CH header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d63aae7229caefbd97fe24c548f9020512978ccc" translate="yes" xml:space="preserve">
          <source>The Accept-CH-Lifetime header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4769fb0951abad4aa7016b3134653949993c77de" translate="yes" xml:space="preserve">
          <source>The Accept-Charset header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234dfa2f1729dd01886001e7daa88ee0bafe27f6" translate="yes" xml:space="preserve">
          <source>The Accept-Charset request-header field can be used to indicate what
   character sets are acceptable for the response. This field allows
   clients capable of understanding more comprehensive or special-
   purpose character sets to signal that capability to a server which is
   capable of representing documents in those character sets.

      Accept-Charset = &quot;Accept-Charset&quot; &quot;:&quot;
              1#( ( charset | &quot;*&quot; )[ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )


   Character set values are described in &lt;a href=&quot;#section-3.4&quot;&gt;section 3.4&lt;/a&gt;. Each charset MAY
   be given an associated quality value which represents the user's
   preference for that charset. The default value is q=1. An example is

      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

   The special value &quot;*&quot;, if present in the Accept-Charset field,
   matches every character set (including ISO-8859-1) which is not
   mentioned elsewhere in the Accept-Charset field. If no &quot;*&quot; is present
   in an Accept-Charset field, then all character sets not explicitly
   mentioned get a quality value of 0, except for ISO-8859-1, which gets
   a quality value of 1 if not explicitly mentioned.

   If no Accept-Charset header is present, the default is that any
   character set is acceptable. If an Accept-Charset header is present,
   and if the server cannot send a response which is acceptable
   according to the Accept-Charset header, then the server SHOULD send
   an error response with the 406 (not acceptable) status code, though
   the sending of an unacceptable response is also allowed.</source>
          <target state="translated">Поле заголовка запроса Accept-Charset может использоваться, чтобы указать, какие наборы символов приемлемы для ответа. Это поле позволяет клиентам, способным понимать более полные или специальные наборы символов, сигнализировать об этой возможности серверу, который способен представлять документы в этих наборах символов. Accept-Charset = &quot;Accept-Charset&quot; &quot;:&quot; 1 # ((charset | &quot;*&quot;) [&quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue]) Значения набора символов описаны в &lt;a href=&quot;#section-3.4&quot;&gt;разделе 3.4.&lt;/a&gt;, Каждой кодировке МОЖЕТ быть присвоено соответствующее значение качества, которое представляет предпочтения пользователя для этой кодировки. Значение по умолчанию - q = 1. Пример: Accept-Charset: iso-8859-5, unicode-1-1; q = 0.8 Специальное значение &amp;laquo;*&amp;raquo;, если оно присутствует в поле Accept-Charset, соответствует каждому набору символов (включая ISO-8859-1) который не упоминается в другом месте в поле Accept-Charset. Если &quot;*&quot; не присутствует в поле Accept-Charset, тогда все наборы символов, не упомянутые явно, получают значение качества 0, за исключением ISO-8859-1, который получает значение качества 1, если не указано явно. Если заголовок Accept-Charset отсутствует, по умолчанию допустим любой набор символов. Если присутствует заголовок Accept-Charset,и если сервер не может отправить ответ, который является приемлемым в соответствии с заголовком Accept-Charset, то сервер ДОЛЖЕН отправить ответ об ошибке с кодом состояния 406 (неприемлемо), хотя отправка неприемлемого ответа также разрешена.</target>
        </trans-unit>
        <trans-unit id="4cd92c762aa78d137a23b8b73482ba75b9995048" translate="yes" xml:space="preserve">
          <source>The Accept-Encoding header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e57729d1ed38c6ddc068a85cca9d470a3c1d181" translate="yes" xml:space="preserve">
          <source>The Accept-Encoding request-header field is similar to Accept, but
   restricts the content-codings (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;) that are acceptable in
   the response.

       Accept-Encoding  = &quot;Accept-Encoding&quot; &quot;:&quot; 

                          1#( codings [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       codings          = ( content-coding | &quot;*&quot; )

   Examples of its use are:

       Accept-Encoding: compress, gzip
       Accept-Encoding:
       Accept-Encoding: *
       Accept-Encoding: compress;q=0.5, gzip;q=1.0
       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

   A server tests whether a content-coding is acceptable, according to
   an Accept-Encoding field, using these rules:

      1. If the content-coding is one of the content-codings listed in
         the Accept-Encoding field, then it is acceptable, unless it is
         accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;)

      2. The special &quot;*&quot; symbol in an Accept-Encoding field matches any
         available content-coding not explicitly listed in the header
         field.

      3. If multiple content-codings are acceptable, then the acceptable
         content-coding with the highest non-zero qvalue is preferred.

      4. The &quot;identity&quot; content-coding is always acceptable, unless
         specifically refused because the Accept-Encoding field includes
         &quot;identity;q=0&quot;, or because the field includes &quot;*;q=0&quot; and does
         not explicitly include the &quot;identity&quot; content-coding. If the
         Accept-Encoding field-value is empty, then only the &quot;identity&quot;
         encoding is acceptable.

   If an Accept-Encoding field is present in a request, and if the
   server cannot send a response which is acceptable according to the
   Accept-Encoding header, then the server SHOULD send an error response
   with the 406 (Not Acceptable) status code.

   If no Accept-Encoding field is present in a request, the server MAY
   assume that the client will accept any content coding. In this case,
   if &quot;identity&quot; is one of the available content-codings, then the
   server SHOULD use the &quot;identity&quot; content-coding, unless it has
   additional information that a different content-coding is meaningful
   to the client.

      Note: If the request does not include an Accept-Encoding field,
      and if the &quot;identity&quot; content-coding is unavailable, then
      content-codings commonly understood by HTTP/1.0 clients (i.e., 

      &quot;gzip&quot; and &quot;compress&quot;) are preferred; some older clients
      improperly display messages sent with other content-codings.  The
      server might also make this decision based on information about
      the particular user-agent or client.

      Note: Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings. This means that qvalues will not
      work and are not permitted with x-gzip or x-compress.</source>
          <target state="translated">Поле заголовка запроса Accept-Encoding похоже на Accept, но ограничивает кодирование содержимого ( &lt;a href=&quot;#section-3.5&quot;&gt;раздел 3.5&lt;/a&gt;), которые приемлемы в ответе. Accept-Encoding = &quot;Accept-Encoding&quot; &quot;:&quot; 1 # (codings [&quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue]) codings = (content-coding | &quot;*&quot;) Примеры его использования: Accept-Encoding: сжатие, gzip Accept-Encoding: Accept-Encoding: * Accept-Encoding: compress; q = 0,5, gzip; q = 1.0 Accept-Encoding: gzip; q = 1.0, identity; q = 0,5, *; q = 0 Сервер проверяет, приемлемо ли кодирование содержимого, в соответствии с полем Accept-Encoding, используя следующие правила: 1. Если кодирование содержимого является одним из кодировок содержимого, перечисленных в Accept-Encoding. -Encoding, тогда это приемлемо, если оно не сопровождается qvalue, равным 0. (Как определено в &lt;a href=&quot;#section-3.9&quot;&gt;разделе 3.9.&lt;/a&gt;, qvalue 0 означает &amp;laquo;неприемлемо&amp;raquo;.) 2. Специальный символ &amp;laquo;*&amp;raquo; в поле Accept-Encoding соответствует любому доступному кодированию содержимого, не указанному явно в поле заголовка. 3. Если допустимо несколько кодировок содержимого, то предпочтительным является приемлемое кодирование содержимого с наивысшим ненулевым значением q. 4. &amp;laquo;Идентификационное&amp;raquo; кодирование содержимого всегда приемлемо, если специально не отказано, потому что поле Accept-Encoding включает &amp;laquo;identity; q = 0&amp;raquo;, или потому что поле включает &amp;laquo;*; q = 0&amp;raquo; и не включает явно &amp;raquo; идентичность &quot;контент-кодирование. Если значение поля Accept-Encoding пусто, то приемлемой является только &quot;идентификационная&quot; кодировка.Если в запросе присутствует поле Accept-Encoding, и если сервер не может отправить ответ, который является приемлемым в соответствии с заголовком Accept-Encoding, то сервер ДОЛЖЕН отправить ответ об ошибке с кодом состояния 406 (Not Acceptable). Если в запросе нет поля Accept-Encoding, сервер МОЖЕТ предположить, что клиент примет любое кодирование содержимого. В этом случае, если &amp;laquo;идентичность&amp;raquo; является одним из доступных кодировок контента, то серверу СЛЕДУЕТ использовать &amp;laquo;идентичность&amp;raquo; кодирования контента, если только у него нет дополнительной информации о том, что другое кодирование контента имеет значение для клиента. Примечание. Если запрос не включает поле Accept-Encoding, и если &quot;идентификационное&quot; кодирование содержимого недоступно, то кодирование содержимого обычно понимается клиентами HTTP / 1.0 (т. Е.gzip и compress) предпочтительны; некоторые старые клиенты неправильно отображают сообщения, отправленные с другим кодированием содержимого. Сервер также может принять это решение на основе информации о конкретном пользовательском агенте или клиенте. Примечание. Большинство приложений HTTP / 1.0 не распознают и не подчиняются значениям qvalue, связанным с кодированием содержимого. Это означает, что qvalues ​​не будут работать и не разрешены с x-gzip или x-compress.Это означает, что qvalues ​​не будут работать и не разрешены с x-gzip или x-compress.Это означает, что qvalues ​​не будут работать и не разрешены с x-gzip или x-compress.</target>
        </trans-unit>
        <trans-unit id="007df01155d25e755642903868beaa64cb7fcbdf" translate="yes" xml:space="preserve">
          <source>The Accept-Language header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba115d77d254ca318ebb9337409d39d8d2c75fa" translate="yes" xml:space="preserve">
          <source>The Accept-Language request-header field is similar to Accept, but
   restricts the set of natural languages that are preferred as a
   response to the request. Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;.

       Accept-Language = &quot;Accept-Language&quot; &quot;:&quot;
                         1#( language-range [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       language-range  = ( ( 1*8ALPHA *( &quot;-&quot; 1*8ALPHA ) ) | &quot;*&quot; )

   Each language-range MAY be given an associated quality value which
   represents an estimate of the user's preference for the languages
   specified by that range. The quality value defaults to &quot;q=1&quot;. For
   example,

       Accept-Language: da, en-gb;q=0.8, en;q=0.7

   would mean: &quot;I prefer Danish, but will accept British English and
   other types of English.&quot; A language-range matches a language-tag if
   it exactly equals the tag, or if it exactly equals a prefix of the
   tag such that the first tag character following the prefix is &quot;-&quot;.
   The special range &quot;*&quot;, if present in the Accept-Language field,
   matches every tag not matched by any other range present in the
   Accept-Language field.

      Note: This use of a prefix matching rule does not imply that
      language tags are assigned to languages in such a way that it is
      always true that if a user understands a language with a certain
      tag, then this user will also understand all languages with tags
      for which this tag is a prefix. The prefix rule simply allows the
      use of prefix tags if this is the case.

   The language quality factor assigned to a language-tag by the
   Accept-Language field is the quality value of the longest language-
   range in the field that matches the language-tag. If no language-
   range in the field matches the tag, the language quality factor
   assigned is 0. If no Accept-Language header is present in the
   request, the server 

   SHOULD assume that all languages are equally acceptable. If an
   Accept-Language header is present, then all languages which are
   assigned a quality factor greater than 0 are acceptable.

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header with the complete linguistic preferences of
   the user in every request. For a discussion of this issue, see
   &lt;a href=&quot;#section-15.1.4&quot;&gt;section 15.1.4&lt;/a&gt;.

   As intelligibility is highly dependent on the individual user, it is
   recommended that client applications make the choice of linguistic
   preference available to the user. If the choice is not made
   available, then the Accept-Language header field MUST NOT be given in
   the request.

      Note: When making the choice of linguistic preference available to
      the user, we remind implementors of  the fact that users are not
      familiar with the details of language matching as described above,
      and should provide appropriate guidance. As an example, users
      might assume that on selecting &quot;en-gb&quot;, they will be served any
      kind of English document if British English is not available. A
      user agent might suggest in such a case to add &quot;en&quot; to get the
      best matching behavior.</source>
          <target state="translated">Поле заголовка запроса Accept-Language аналогично Accept, но ограничивает набор естественных языков, которые предпочтительны в качестве ответа на запрос. Языковые теги определены в &lt;a href=&quot;#section-3.10&quot;&gt;разделе 3.10.&lt;/a&gt;, Accept-Language = &quot;Accept-Language&quot; &quot;:&quot; 1 # (language-range [&quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue]) language-range = ((1 * 8ALPHA * (&quot;-&quot; 1 * 8ALPHA)) | &quot;*&quot;) Каждому языковому диапазону МОЖЕТ быть присвоено соответствующее значение качества, которое представляет собой оценку предпочтений пользователя в отношении языков, указанных в этом диапазоне. Значение качества по умолчанию &amp;laquo;q = 1&amp;raquo;. Например, Accept-Language: da, en-gb; q = 0,8, en; q = 0,7 будет означать: &amp;laquo;Я предпочитаю датский, но буду принимать британский английский и другие типы английского&amp;raquo;. Языковой диапазон соответствует языковому тегу, если он в точности совпадает с тегом или если он в точности соответствует префиксу тега, так что первый символ тега, следующий за префиксом, равен &amp;laquo;-&amp;raquo;.Специальный диапазон &amp;laquo;*&amp;raquo;, если он присутствует в поле Accept-Language, соответствует каждому тегу, не совпадающему ни с каким другим диапазоном, представленным в поле Accept-Language. Примечание: это использование правила сопоставления префиксов не означает, что языковые теги назначаются языкам таким образом, что всегда верно, что если пользователь понимает язык с определенным тегом, то этот пользователь также будет понимать все языки с тегами. для которых этот тег является префиксом. Правило префикса просто позволяет использовать префиксные теги, если это так. Фактор качества языка, присвоенный языковому тегу полем Accept-Language, является значением качества самого длинного языкового диапазона в поле, которое соответствует языковому тегу. Если ни один языковой диапазон в поле не соответствует тегу, присвоенный коэффициент качества языка равен 0.Если в запросе отсутствует заголовок Accept-Language, серверу СЛЕДУЕТ предполагать, что все языки одинаково приемлемы. Если присутствует заголовок Accept-Language, то приемлемы все языки, которым назначен коэффициент качества больше 0. Отправка заголовка Accept-Language с полными языковыми предпочтениями пользователя в каждом запросе может противоречить ожиданиям пользователя о конфиденциальности. Для обсуждения этого вопроса см.Отправка заголовка Accept-Language с полными языковыми предпочтениями пользователя в каждом запросе может противоречить ожиданиям пользователя о конфиденциальности. Для обсуждения этого вопроса см.Отправка заголовка Accept-Language с полными языковыми предпочтениями пользователя в каждом запросе может противоречить ожиданиям пользователя о конфиденциальности. Для обсуждения этого вопроса см. &lt;a href=&quot;#section-15.1.4&quot;&gt;раздел 15.1.4&lt;/a&gt;, Поскольку разборчивость во многом зависит от отдельного пользователя, рекомендуется, чтобы клиентские приложения предоставляли пользователю возможность выбора языковых предпочтений. Если выбор недоступен, то поле заголовка Accept-Language НЕ ДОЛЖНО указываться в запросе. Примечание. Делая выбор языковых предпочтений доступным для пользователя, мы напоминаем разработчикам о том, что пользователи не знакомы с деталями сопоставления языков, как описано выше, и должны предоставить соответствующие инструкции. Например, пользователи могут предположить, что при выборе &amp;laquo;en-gb&amp;raquo; им будет предоставлен любой документ на английском языке, если британский английский недоступен. В этом случае пользовательский агент может предложить добавить &amp;laquo;en&amp;raquo;, чтобы добиться наилучшего соответствия.</target>
        </trans-unit>
        <trans-unit id="dceeccc14ca79697274f5080fd10fd4f709e2583" translate="yes" xml:space="preserve">
          <source>The Accept-Ranges response-header field allows the server to
      indicate its acceptance of range requests for a resource:

          Accept-Ranges     = &quot;Accept-Ranges&quot; &quot;:&quot; acceptable-ranges
          acceptable-ranges = 1#range-unit | &quot;none&quot;

      Origin servers that accept byte-range requests MAY send

          Accept-Ranges: bytes

      but are not required to do so. Clients MAY generate byte-range
      requests without having received this header for the resource
      involved. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

      Servers that do not accept any kind of range request for a
      resource MAY send

          Accept-Ranges: none

      to advise the client not to attempt a range request.</source>
          <target state="translated">Поле заголовка ответа Accept-Ranges позволяет серверу указывать, что он принимает запросы диапазона для ресурса: Accept-Ranges = &quot;Accept-Ranges&quot; &quot;:&quot; Допустимые диапазоны диапазонов = 1 # единица измерения диапазона | &quot;none&quot; Серверы происхождения, которые принимают запросы диапазона байтов, МОГУТ отправлять Accept-Ranges: bytes, но не обязаны это делать. Клиенты МОГУТ генерировать запросы байтового диапазона, не получив этот заголовок для задействованного ресурса. Единицы измерения определены в &lt;a href=&quot;#section-3.12&quot;&gt;разделе 3.12&lt;/a&gt; . Серверы, которые не принимают какие-либо запросы диапазона для ресурса, МОГУТ отправлять Accept-Ranges: none, чтобы посоветовать клиенту не пытаться выполнить запрос диапазона.</target>
        </trans-unit>
        <trans-unit id="20fe0a78765b42653f8af73cd9564f1524ef0e69" translate="yes" xml:space="preserve">
          <source>The Age header field is used to convey an estimated age of the
   response message when obtained from a cache.  The Age field value is
   the cache's estimate of the number of seconds since the response was
   generated or validated by the origin server.  In essence, the Age 

   value is the sum of the time that the response has been resident in
   each of the caches along the path from the origin server, plus the
   amount of time it has been in transit along network paths.

   The following data is used for the age calculation:

   age_value

      The term &quot;age_value&quot; denotes the value of the Age header field
      (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;), in a form appropriate for arithmetic operation; or
      0, if not available.

   date_value

      The term &quot;date_value&quot; denotes the value of the Date header field,
      in a form appropriate for arithmetic operations.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;7.1.1.2 of [RFC7231]&lt;/a&gt; for the definition of the Date header field,
      and for requirements regarding responses without it.

   now

      The term &quot;now&quot; means &quot;the current value of the clock at the host
      performing the calculation&quot;.  A host ought to use NTP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;])
      or some similar protocol to synchronize its clocks to Coordinated
      Universal Time.

   request_time

      The current value of the clock at the host at the time the request
      resulting in the stored response was made.

   response_time

      The current value of the clock at the host at the time the
      response was received.

   A response's age can be calculated in two entirely independent ways:

   1.  the &quot;apparent_age&quot;: response_time minus date_value, if the local
       clock is reasonably well synchronized to the origin server's
       clock.  If the result is negative, the result is replaced by
       zero.

   2.  the &quot;corrected_age_value&quot;, if all of the caches along the
       response path implement HTTP/1.1.  A cache MUST interpret this
       value relative to the time the request was initiated, not the
       time that the response was received. 

     apparent_age = max(0, response_time - date_value);

     response_delay = response_time - request_time;
     corrected_age_value = age_value + response_delay;

   These are combined as

     corrected_initial_age = max(apparent_age, corrected_age_value);

   unless the cache is confident in the value of the Age header field
   (e.g., because there are no HTTP/1.0 hops in the Via header field),
   in which case the corrected_age_value MAY be used as the
   corrected_initial_age.

   The current_age of a stored response can then be calculated by adding
   the amount of time (in seconds) since the stored response was last
   validated by the origin server to the corrected_initial_age.

     resident_time = now - response_time;
     current_age = corrected_initial_age + resident_time;</source>
          <target state="translated">Поле заголовка Age используется для передачи предполагаемого возраста ответного сообщения при получении из кеша. Значение поля Age - это оценка кэша количества секунд с момента создания или проверки ответа исходным сервером. По сути, значение Age - это сумма времени, в течение которого ответ находился в каждом из кешей на пути от исходного сервера, плюс время, в течение которого он находился в пути по сетевым путям. Для вычисления возраста используются следующие данные: age_value Термин age_value обозначает значение поля заголовка Age ( &lt;a href=&quot;#section-5.1&quot;&gt;Раздел 5.1&lt;/a&gt;) в форме, подходящей для арифметических операций; или 0, если недоступен. date_value Термин &amp;laquo;date_value&amp;raquo; обозначает значение поля заголовка Date в форме, подходящей для арифметических операций. См. &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Раздел &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;7.1.1.2 [RFC7231]&lt;/a&gt; для определения поля заголовка Date и требований к ответам без него. now Термин &amp;laquo;сейчас&amp;raquo; означает &amp;laquo;текущее значение часов на хосте, выполняющем расчет&amp;raquo;. Хост должен использовать NTP ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;]) или подобный протокол для синхронизации часов по всемирному координированному времени. request_time Текущее значение часов на хосте в момент выполнения запроса, в результате которого был получен сохраненный ответ. response_time Текущее значение часов на хосте на момент получения ответа. Возраст ответа может быть вычислен двумя совершенно независимыми способами: 1. &amp;laquo;видимый_ возраст&amp;raquo;: время ответа минус значение_даты, если локальные часы достаточно хорошо синхронизированы с часами исходного сервера. Если результат отрицательный, результат заменяется нулем. 2. &amp;laquo;corrected_age_value&amp;raquo;, если все кеши на пути ответа реализуют HTTP / 1.1.Кэш ДОЛЖЕН интерпретировать это значение относительно времени, когда запрос был инициирован, а не времени, когда был получен ответ. кажущийся возраст = макс (0, время_ответа - значение_даты); response_delay = response_time - время_запроса; corrected_age_value = age_value + response_delay; Они объединяются как corrected_initial_age = max (visible_age, corrected_age_value); если только кэш не уверен в значении поля заголовка Age (например, потому что в поле заголовка Via нет переходов HTTP / 1.0), и в этом случае значение corrected_age_value МОЖЕТ использоваться как corrected_initial_age. Current_age сохраненного ответа затем может быть вычислено путем добавления количества времени (в секундах) с момента последней проверки сохраненного ответа исходным сервером к corrected_initial_age.resident_time = now - response_time; current_age = исправленный_initial_age + resident_time;</target>
        </trans-unit>
        <trans-unit id="fdef55523947f477881a984ce9c7d78915e916d7" translate="yes" xml:space="preserve">
          <source>The Age response-header field conveys the sender's estimate of the
      amount of time since the response (or its revalidation) was
      generated at the origin server. A cached response is &quot;fresh&quot; if
      its age does not exceed its freshness lifetime. Age values are
      calculated as specified in &lt;a href=&quot;#section-13.2.3&quot;&gt;section 13.2.3&lt;/a&gt;.

           Age = &quot;Age&quot; &quot;:&quot; age-value
           age-value = delta-seconds

      Age values are non-negative decimal integers, representing time in
      seconds.

      If a cache receives a value larger than the largest positive
      integer it can represent, or if any of its age calculations
      overflows, it MUST transmit an Age header with a value of
      2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST
      include an Age header field in every response generated from its
      own cache. Caches SHOULD use an arithmetic type of at least 31
      bits of range.</source>
          <target state="translated">Поле заголовка ответа Age передает оценку отправителя количества времени, прошедшего с момента создания ответа (или его повторной проверки) на исходном сервере. Кешированный ответ считается &amp;laquo;свежим&amp;raquo;, если его возраст не превышает срок его действия. Значения возраста рассчитываются, как указано в &lt;a href=&quot;#section-13.2.3&quot;&gt;разделе 13.2.3.&lt;/a&gt;, Age = &quot;Age&quot; &quot;:&quot; age-value age-value = delta-seconds Значения возраста являются неотрицательными десятичными целыми числами, представляющими время в секундах. Если кэш получает значение, превышающее наибольшее положительное целое число, которое он может представить, или если какие-либо из его вычислений возраста переполняются, он ДОЛЖЕН передать заголовок Age со значением 2147483648 (2 ^ 31). Сервер HTTP / 1.1, который включает кеш, ДОЛЖЕН включать поле заголовка Age в каждый ответ, сгенерированный из его собственного кеша. Кэш ДОЛЖЕН использовать арифметический тип с диапазоном не менее 31 бита.</target>
        </trans-unit>
        <trans-unit id="d37b3ed1a7bd53de7b0c73a5ae6518e139d2ed9d" translate="yes" xml:space="preserve">
          <source>The Allow entity-header field lists the set of methods supported
      by the resource identified by the Request-URI. The purpose of this
      field is strictly to inform the recipient of valid methods
      associated with the resource. An Allow header field MUST be
      present in a 405 (Method Not Allowed) response.

          Allow   = &quot;Allow&quot; &quot;:&quot; #Method

      Example of use:

          Allow: GET, HEAD, PUT

      This field cannot prevent a client from trying other methods.
      However, the indications given by the Allow header field value
      SHOULD be followed. The actual set of allowed methods is defined
      by the origin server at the time of each request.

      The Allow header field MAY be provided with a PUT request to
      recommend the methods to be supported by the new or modified
      resource. The server is not required to support these methods and
      SHOULD include an Allow header in the response giving the actual
      supported methods. 

      A proxy MUST NOT modify the Allow header field even if it does not
      understand all the methods specified, since the user agent might
      have other means of communicating with the origin server.</source>
          <target state="translated">В поле Allow entity-header (Разрешить)перечислен набор методов,поддерживаемых ресурсом,определенным в Request-URI.Целью данного поля является строгое информирование получателя о допустимых методах,связанных с ресурсом.Поле Allow header (Разрешить заголовок)ДОЛЖНО присутствовать в ответе 405 (Метод не разрешен).Разрешить=&quot;Разрешить&quot; &quot;:&quot; #Пример использования метода:Разрешить:GET,HEAD,PUT Это поле не может запретить клиенту пробовать другие методы.Однако,необходимо следовать указаниям,данным в поле Allow header value SHOULD.Реальный набор разрешенных методов определяется сервером-источником в момент каждого запроса.Поле Allow header MAY (Разрешить заголовок)МАЙЯ получает PUT-запрос,чтобы рекомендовать методы,которые будут поддерживаться новым или измененным ресурсом.Сервер не обязан поддерживать эти методы и ДОЛЖЕН включать Allow header (Разрешительный заголовок)в ответ,дающий реально поддерживаемые методы.Прокси-сервер НЕ ДОЛЖЕН изменять поле Allow header (Разрешить заголовок),даже если он не понимает все указанные методы,так как пользовательский агент может иметь другие средства связи с исходным сервером.</target>
        </trans-unit>
        <trans-unit id="13a4fef575d5af4e237a81912fe641b20dff803a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol imposes few restrictions on the actions of servers.
   Unless a constraint is specified here, servers can be expected to
   vary in behavior, in particular around the manipulation of Atom
   Entries sent by clients.  For example, although this specification
   only defines the expected behavior of Collections with respect to GET
   and POST, this does not imply that PUT, DELETE, PROPPATCH, and others
   are forbidden on Collection Resources -- only that this specification
   does not define what the server's response would be to those methods.
   Similarly, while some HTTP status codes are mentioned explicitly,
   clients ought to be prepared to handle any status code from a server.
   Servers can choose to accept, reject, delay, moderate, censor,
   reformat, translate, relocate, or re-categorize the content submitted
   to them.  Only some of these choices are immediately relayed back to
   the client in responses to client requests; other choices may only
   become apparent later, in the feed or published entries.  The same
   series of requests to two different publishing sites can result in a
   different series of HTTP responses, different resulting feeds, or
   different entry contents.

   As a result, client software has to be written flexibly to accept
   what the server decides are the results of its submissions.  Any
   server response or server content modification not explicitly
   forbidden by this specification or HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] is therefore
   allowed.</source>
          <target state="translated">Протокол Atom налагает несколько ограничений на действия серверов. Если здесь не указано ограничение, можно ожидать, что серверы будут различаться по поведению, в частности, в отношении манипуляций с записями Atom, отправляемыми клиентами. Например, хотя эта спецификация определяет только ожидаемое поведение коллекций в отношении GET и POST, это не означает, что PUT, DELETE, PROPPATCH и другие запрещены для ресурсов коллекции - только эта спецификация не определяет, что сервер ответ будет на эти методы. Точно так же, хотя некоторые коды состояния HTTP упоминаются явно, клиенты должны быть готовы обрабатывать любой код состояния с сервера. Серверы могут выбрать принятие, отклонение, задержку, модерацию, цензуру, переформатирование, перевод, перемещение,или измените категорию представленного им контента. Только некоторые из этих вариантов немедленно передаются обратно клиенту в ответах на запросы клиента; другие варианты могут стать очевидными только позже, в ленте или опубликованных записях. Одна и та же серия запросов к двум разным сайтам публикации может привести к разным сериям HTTP-ответов, разным результирующим каналам или разному содержимому записей. В результате клиентское программное обеспечение должно быть гибко написано, чтобы принимать то, что сервер решает как результат его представлений. Любой ответ сервера или изменение содержимого сервера, не запрещенные явно данной спецификацией или HTTP [в ленте или опубликованных записях. Одна и та же серия запросов к двум разным сайтам публикации может привести к разным сериям HTTP-ответов, разным результирующим каналам или разному содержимому записей. В результате клиентское программное обеспечение должно быть гибко написано, чтобы принимать то, что сервер решает как результат его представлений. Любой ответ сервера или изменение содержимого сервера, не запрещенные явно данной спецификацией или HTTP [в ленте или опубликованных записях. Одна и та же серия запросов к двум разным сайтам публикации может привести к разным сериям HTTP-ответов, разным результирующим каналам или разному содержимому записей. В результате клиентское программное обеспечение должно быть гибко написано, чтобы принимать то, что сервер решает как результат его представлений. Любой ответ сервера или изменение содержимого сервера, не запрещенные явно данной спецификацией или HTTP [Любой ответ сервера или изменение содержимого сервера, не запрещенные явно данной спецификацией или HTTP [Любой ответ сервера или изменение содержимого сервера, не запрещенные явно данной спецификацией или HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] поэтому допускается.</target>
        </trans-unit>
        <trans-unit id="3007c47f9b138e0499c5f1a7d9a65013178447c8" translate="yes" xml:space="preserve">
          <source>The Atom Protocol specifies operations for publishing and editing
   Resources using HTTP.  It uses Atom-formatted representations to
   describe the state and metadata of those Resources.  It defines how
   Collections of Resources can be organized, and it specifies formats
   to support their discovery, grouping and categorization.</source>
          <target state="translated">Протокол Atom определяет операции по публикации и редактированию Ресурсов с использованием HTTP.Он использует Атом-форматированные представления для описания состояния и метаданных этих Ресурсов.Он определяет,как могут быть организованы Коллекции Ресурсов,и определяет форматы для поддержки их обнаружения,группировки и категоризации.</target>
        </trans-unit>
        <trans-unit id="3a69850b360c5d4d12134d47ffb0f4087be9cb1a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol uses the response status codes defined in HTTP to
   indicate the success or failure of an operation.  Consult the HTTP
   specification [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] for detailed definitions of each status code.

   Implementers are asked to note that according to the HTTP
   specification, HTTP 4xx and 5xx response entities SHOULD include a
   human-readable explanation of the error.</source>
          <target state="translated">Протокол Atom использует коды состояния ответа, определенные в HTTP, чтобы указать успех или неудачу операции. См. Подробные определения каждого кода состояния в спецификации HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]. Разработчиков просят отметить, что в соответствии со спецификацией HTTP, объекты ответа HTTP 4xx и 5xx ДОЛЖНЫ включать понятное для человека объяснение ошибки.</target>
        </trans-unit>
        <trans-unit id="169d7cc9960872ff8dd439fd04a8242bd3b29ed5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol</source>
          <target state="translated">Протокол публикации атомов</target>
        </trans-unit>
        <trans-unit id="aa8edeb1773be5498439f67a0412dde5980a08ac" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is an application-level protocol for
   publishing and editing Web Resources using HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and XML 1.0
   [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].  The protocol supports the creation of Web Resources and
   provides facilities for:

   o  Collections: Sets of Resources, which can be retrieved in whole or
      in part.

   o  Services: Discovery and description of Collections.

   o  Editing: Creating, editing, and deleting Resources.

   The Atom Publishing Protocol is different from many contemporary
   protocols in that the server is given wide latitude in processing
   requests from clients.  See &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; for more details.</source>
          <target state="translated">Протокол публикации Atom - это протокол уровня приложения для публикации и редактирования веб-ресурсов с использованием HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] и XML 1.0 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ]. Протокол поддерживает создание веб-ресурсов и предоставляет возможности для: o Коллекций: наборов ресурсов, которые могут быть получены полностью или частично. o Услуги: открытие и описание коллекций. o Редактирование: создание, редактирование и удаление ресурсов. Протокол публикации Atom отличается от многих современных протоколов тем, что серверу предоставляется широкая свобода действий при обработке запросов от клиентов. См. &lt;a href=&quot;#section-4.4&quot;&gt;Раздел 4.4&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="091cad87f70ba141ab92f1e05e1c2c4c7b6a0753" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP and thus subject to the
   security considerations found in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;Section&amp;nbsp;15 of [RFC2616]&lt;/a&gt;.

   The threats listed in this section apply to many protocols that run
   under HTTP.  The Atompub Working Group decided that the protection
   afforded by running authenticated HTTP under TLS (as described in
   &lt;a href=&quot;#section-14&quot;&gt;Section 14&lt;/a&gt;) was sufficient to mitigate many of the problems presented
   by the attacks listed in this section.</source>
          <target state="translated">Протокол публикации Atom основан на HTTP и, следовательно, подчиняется соображениям безопасности, изложенным в &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;разделе 15 [RFC2616]&lt;/a&gt; . Угрозы, перечисленные в этом разделе, относятся ко многим протоколам, работающим по протоколу HTTP. Рабочая группа Atompub решила, что защиты, обеспечиваемой запуском аутентифицированного HTTP под TLS (как описано в &lt;a href=&quot;#section-14&quot;&gt;разделе 14&lt;/a&gt; ), достаточно для смягчения многих проблем, связанных с атаками, перечисленными в этом разделе.</target>
        </trans-unit>
        <trans-unit id="5d125ad81e218339dcf924271a55cccc89e9d5f5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP.  Authentication
   requirements for HTTP are covered in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;Section&amp;nbsp;11 of [RFC2616]&lt;/a&gt;.

   The use of authentication mechanisms to prevent POSTing or editing by
   unknown or unauthorized clients is RECOMMENDED but not required.
   When authentication is not used, clients and servers are vulnerable
   to trivial spoofing, denial-of-service, and defacement attacks.
   However, in some contexts, this is an acceptable risk.

   The type of authentication deployed is a local decision made by the
   server operator.  Clients are likely to face authentication schemes
   that vary across server deployments.  At a minimum, client and server
   implementations MUST be capable of being configured to use HTTP Basic
   Authentication [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] in conjunction with a connection made with
   TLS 1.0 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt;] or a subsequent standards-track version of TLS
   (such as [&lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt;]), supporting the conventions for using HTTP over
   TLS described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]. 

   The choice of authentication mechanism will impact interoperability.
   The minimum level of security referenced above (Basic Authentication
   with TLS) is considered good practice for Internet applications at
   the time of publication of this specification and sufficient for
   establishing a baseline for interoperability.  Implementers are
   encouraged to investigate and use alternative mechanisms regarded as
   equivalently good or better at the time of deployment.  It is
   RECOMMENDED that clients be implemented in such a way that new
   authentication schemes can be deployed.

   Because this protocol uses HTTP response status codes as the primary
   means of reporting the result of a request, servers are advised to
   respond to unauthorized or unauthenticated requests using an
   appropriate 4xx HTTP response code (e.g., 401 &quot;Unauthorized&quot; or 403
   &quot;Forbidden&quot;) in accordance with [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;].</source>
          <target state="translated">Протокол публикации Atom основан на HTTP. Требования аутентификации для HTTP описаны в &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;разделе 11 [RFC2616]&lt;/a&gt; . РЕКОМЕНДУЕТСЯ, но не обязательно использовать механизмы аутентификации для предотвращения отправки или редактирования неизвестными или неавторизованными клиентами. Когда аутентификация не используется, клиенты и серверы уязвимы для банального спуфинга, отказа в обслуживании и атак искажения. Однако в некоторых случаях это приемлемый риск. Тип развернутой аутентификации - это локальное решение, принимаемое оператором сервера. Клиенты могут столкнуться со схемами аутентификации, которые различаются в зависимости от развертывания сервера. Как минимум, реализации клиента и сервера ДОЛЖНЫ быть настроены на использование базовой аутентификации HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] в сочетании с подключением, выполненным с помощью TLS 1.0 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt; ] или последующей версии TLS, соответствующей стандартам (например, [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt; ]), поддерживая соглашения об использовании HTTP поверх TLS, описанные в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]. Выбор механизма аутентификации повлияет на взаимодействие. Упомянутый выше минимальный уровень безопасности (базовая аутентификация с TLS) считается хорошей практикой для Интернет-приложений на момент публикации данной спецификации и достаточен для установления базового уровня взаимодействия. Разработчикам рекомендуется изучить и использовать альтернативные механизмы, которые на момент развертывания считаются равноценными или лучшими. РЕКОМЕНДУЕТСЯ, чтобы клиенты были реализованы таким образом, чтобы можно было развертывать новые схемы аутентификации. Поскольку этот протокол использует коды состояния ответа HTTP в качестве основного средства сообщения о результате запроса, серверам рекомендуется отвечать на неавторизованные или неаутентифицированные запросы, используя соответствующий код ответа HTTP 4xx (например,401 &amp;laquo;Несанкционированный&amp;raquo; или 403 &amp;laquo;Запрещенный&amp;raquo;) в соответствии с [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="b27e5a48d6a66251fa9d4883723e1c6d86c30969" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol uses HTTP methods to author Member
   Resources as follows:

   o  GET is used to retrieve a representation of a known Resource.

   o  POST is used to create a new, dynamically named, Resource.  When
      the client submits non-Atom-Entry representations to a Collection
      for creation, two Resources are always created -- a Media Entry
      for the requested Resource, and a Media Link Entry for metadata
      about the Resource that will appear in the Collection.

   o  PUT is used to edit a known Resource.  It is not used for Resource
      creation.

   o  DELETE is used to remove a known Resource.

   The Atom Protocol only covers the creating, editing, and deleting of
   Entry and Media Resources.  Other Resources could be created, edited,
   and deleted as the result of manipulating a Collection, but the
   number of those Resources, their media types, and effects of Atom
   Protocol operations on them are outside the scope of this
   specification. 

   Since all aspects of client-server interaction are defined in terms
   of HTTP, [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] should be consulted for any areas not covered in
   this specification.</source>
          <target state="translated">Протокол публикации Atom использует методы HTTP для создания ресурсов участников следующим образом: o GET используется для получения представления известного ресурса. o POST используется для создания нового ресурса с динамическим именем. Когда клиент отправляет представления, не относящиеся к записи Atom, в коллекцию для создания, всегда создаются два ресурса - запись мультимедиа для запрошенного ресурса и запись связи мультимедиа для метаданных о ресурсе, который будет отображаться в коллекции. o PUT используется для редактирования известного ресурса. Он не используется для создания Ресурса. o DELETE используется для удаления известного ресурса. Протокол Atom охватывает только создание, редактирование и удаление входных и медиаресурсов. Другие ресурсы можно было создавать, редактировать и удалять в результате манипулирования Коллекцией,но количество этих ресурсов, их типы носителей и влияние операций на них протокола Atom выходят за рамки данной спецификации. Поскольку все аспекты взаимодействия клиент-сервер определены в терминах HTTP, [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] следует обращаться к любым областям, не охваченным в этой спецификации.</target>
        </trans-unit>
        <trans-unit id="42d277116045b96cf12bbfe45ba81c76ae3ef5f2" translate="yes" xml:space="preserve">
          <source>The Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] defines the &quot;application/
   atom+xml&quot; media type to identify both Atom Feed and Atom Entry
   Documents.  Implementation experience has demonstrated that Atom Feed
   and Entry Documents can have different processing models and that
   there are situations where they need to be differentiated.  This
   specification defines a &quot;type&quot; parameter used to differentiate the
   two types of Atom documents.</source>
          <target state="translated">Формат синдикации Atom [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] определяет тип носителя &amp;laquo;application / atom + xml&amp;raquo; для идентификации как Atom Feed, так и документов Atom Entry. Опыт внедрения показал, что Atom Feed и Entry Documents могут иметь разные модели обработки и что есть ситуации, в которых их необходимо различать. Эта спецификация определяет параметр &amp;laquo;тип&amp;raquo;, используемый для различения двух типов документов Atom.</target>
        </trans-unit>
        <trans-unit id="d54dec6d4ad6caa6017041a8dbe37766ea30ecca" translate="yes" xml:space="preserve">
          <source>The CONNECT method can be used to create disproportionate load on an
   proxy, since stream creation is relatively inexpensive when compared
   to the creation and maintenance of a TCP connection.  A proxy might
   also maintain some resources for a TCP connection beyond the closing
   of the stream that carries the CONNECT request, since the outgoing
   TCP connection remains in the TIME_WAIT state.  Therefore, a proxy
   cannot rely on SETTINGS_MAX_CONCURRENT_STREAMS alone to limit the
   resources consumed by CONNECT requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a14656993634aa0a74177de15aa55441d492abb" translate="yes" xml:space="preserve">
          <source>The CONNECT method requests that the recipient establish a tunnel to
   the destination origin server identified by the request-target and,
   if successful, thereafter restrict its behavior to blind forwarding
   of packets, in both directions, until the tunnel is closed.  Tunnels
   are commonly used to create an end-to-end virtual connection, through
   one or more proxies, which can then be secured using TLS (Transport
   Layer Security, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]).

   CONNECT is intended only for use in requests to a proxy.  An origin
   server that receives a CONNECT request for itself MAY respond with a
   2xx (Successful) status code to indicate that a connection is
   established.  However, most origin servers do not implement CONNECT.

   A client sending a CONNECT request MUST send the authority form of
   request-target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;); i.e., the request-target
   consists of only the host name and port number of the tunnel
   destination, separated by a colon.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80

   The recipient proxy can establish a tunnel either by directly
   connecting to the request-target or, if configured to use another
   proxy, by forwarding the CONNECT request to the next inbound proxy.
   Any 2xx (Successful) response indicates that the sender (and all 

   inbound proxies) will switch to tunnel mode immediately after the
   blank line that concludes the successful response's header section;
   data received after that blank line is from the server identified by
   the request-target.  Any response other than a successful response
   indicates that the tunnel has not yet been formed and that the
   connection remains governed by HTTP.

   A tunnel is closed when a tunnel intermediary detects that either
   side has closed its connection: the intermediary MUST attempt to send
   any outstanding data that came from the closed side to the other
   side, close both connections, and then discard any remaining data
   left undelivered.

   Proxy authentication might be used to establish the authority to
   create a tunnel.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80
     Proxy-Authorization: basic aGVsbG86d29ybGQ=

   There are significant risks in establishing a tunnel to arbitrary
   servers, particularly when the destination is a well-known or
   reserved TCP port that is not intended for Web traffic.  For example,
   a CONNECT to a request-target of &quot;example.com:25&quot; would suggest that
   the proxy connect to the reserved port for SMTP traffic; if allowed,
   that could trick the proxy into relaying spam email.  Proxies that
   support CONNECT SHOULD restrict its use to a limited set of known
   ports or a configurable whitelist of safe request targets.

   A server MUST NOT send any Transfer-Encoding or Content-Length header
   fields in a 2xx (Successful) response to CONNECT.  A client MUST
   ignore any Content-Length or Transfer-Encoding header fields received
   in a successful response to CONNECT.

   A payload within a CONNECT request message has no defined semantics;
   sending a payload body on a CONNECT request might cause some existing
   implementations to reject the request.

   Responses to the CONNECT method are not cacheable.</source>
          <target state="translated">Метод CONNECT требует, чтобы получатель установил туннель к исходному серверу назначения, идентифицированному целевым объектом запроса, и, в случае успеха, после этого ограничил свое поведение слепой пересылкой пакетов в обоих направлениях, пока туннель не будет закрыт. Туннели обычно используются для создания сквозного виртуального соединения через один или несколько прокси-серверов, которые затем могут быть защищены с помощью TLS (Transport Layer Security, [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246]&lt;/a&gt;]). CONNECT предназначен только для использования в запросах к прокси. Исходный сервер, который получает запрос CONNECT для себя, МОЖЕТ ответить кодом состояния 2xx (Успешно), чтобы указать, что соединение установлено. Однако большинство исходных серверов не поддерживают CONNECT. Клиент, отправляющий запрос CONNECT, ДОЛЖЕН отправить форму полномочий request-target ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;раздел 5.3 [RFC7230]).&lt;/a&gt;); то есть цель запроса состоит только из имени хоста и номера порта назначения туннеля, разделенных двоеточием. Например, CONNECT server.example.com:80 HTTP / 1.1 Host: server.example.com:80 Прокси-сервер получателя может установить туннель либо путем прямого подключения к цели запроса, либо, если настроен на использование другого прокси, путем пересылки запрос CONNECT к следующему входящему прокси. Любой ответ 2xx (успешный) означает, что отправитель (и все входящие прокси) переключатся в туннельный режим сразу после пустой строки, завершающей раздел заголовка успешного ответа; данные, полученные после этой пустой строки, поступают с сервера, идентифицированного целью запроса.Любой ответ, кроме успешного, указывает на то, что туннель еще не сформирован и что соединение остается управляемым HTTP. Туннель закрывается, когда туннельный посредник обнаруживает, что одна из сторон закрыла свое соединение: посредник ДОЛЖЕН попытаться отправить любые незавершенные данные, которые пришли с закрытой стороны на другую сторону, закрыть оба соединения и затем отбросить все оставшиеся данные, оставшиеся недоставленными. Прокси-аутентификация может использоваться для установления полномочий для создания туннеля. Например, CONNECT server.example.com:80 HTTP / 1.1 Host: server.example.com:80 Proxy-Authorization: basic aGVsbG86d29ybGQ = Установление туннеля к произвольным серверам сопряжено со значительными рисками,особенно, когда местом назначения является хорошо известный или зарезервированный TCP-порт, который не предназначен для веб-трафика. Например, CONNECT к цели запроса &amp;laquo;example.com:25&amp;raquo; предполагает, что прокси-сервер подключается к зарезервированному порту для трафика SMTP; если разрешено, это может обманом заставить прокси-сервер пересылать спам. Прокси-серверы, поддерживающие CONNECT, ДОЛЖНЫ ограничить его использование ограниченным набором известных портов или настраиваемым белым списком безопасных целей запроса. Сервер НЕ ДОЛЖЕН отправлять какие-либо поля заголовка Transfer-Encoding или Content-Length в ответе 2xx (Успешно) на CONNECT. Клиент ДОЛЖЕН игнорировать любые поля заголовка Content-Length или Transfer-Encoding, полученные в успешном ответе на CONNECT. Полезная нагрузка в сообщении запроса CONNECT не имеет определенной семантики;отправка тела полезной нагрузки по запросу CONNECT может привести к тому, что некоторые существующие реализации отклонят запрос. Ответы на метод CONNECT не кэшируются.</target>
        </trans-unit>
        <trans-unit id="44e2ab9943f4c0dd2becd2a23e49a2cb8c91d927" translate="yes" xml:space="preserve">
          <source>The CONTINUATION frame (type=0x9) is used to continue a sequence of
   header block fragments (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).  Any number of CONTINUATION
   frames can be sent, as long as the preceding frame is on the same
   stream and is a HEADERS, PUSH_PROMISE, or CONTINUATION frame without
   the END_HEADERS flag set.

    +---------------------------------------------------------------+
    |                   Header Block Fragment (*)                 
    +---------------------------------------------------------------+

                   Figure 15: CONTINUATION Frame Payload

   The CONTINUATION frame payload contains a header block fragment
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;). 

   The CONTINUATION frame defines the following flag:

   END_HEADERS (0x4):  When set, bit 2 indicates that this frame ends a
      header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).

      If the END_HEADERS bit is not set, this frame MUST be followed by
      another CONTINUATION frame.  A receiver MUST treat the receipt of
      any other type of frame or a frame on a different stream as a
      connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   The CONTINUATION frame changes the connection state as defined in
   &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;.

   CONTINUATION frames MUST be associated with a stream.  If a
   CONTINUATION frame is received whose stream identifier field is 0x0,
   the recipient MUST respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of
   type PROTOCOL_ERROR.

   A CONTINUATION frame MUST be preceded by a HEADERS, PUSH_PROMISE or
   CONTINUATION frame without the END_HEADERS flag set.  A recipient
   that observes violation of this rule MUST respond with a connection
   error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc173ef45538302331fa209f0189866cab3850f" translate="yes" xml:space="preserve">
          <source>The COPY method creates a duplicate of the source resource identified
   by the Request-URI, in the destination resource identified by the URI
   in the Destination header.  The Destination header MUST be present.
   The exact behavior of the COPY method depends on the type of the
   source resource.

   All WebDAV-compliant resources MUST support the COPY method.
   However, support for the COPY method does not guarantee the ability
   to copy a resource.  For example, separate programs may control
   resources on the same server.  As a result, it may not be possible to
   copy a resource to a location that appears to be on the same server.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">Метод COPY создает копию исходного ресурса, идентифицированного Request-URI, в целевом ресурсе, идентифицированном URI в заголовке Destination. ДОЛЖЕН присутствовать заголовок назначения. Точное поведение метода COPY зависит от типа исходного ресурса. Все ресурсы, совместимые с WebDAV, ДОЛЖНЫ поддерживать метод COPY. Однако поддержка метода COPY не гарантирует возможность копирования ресурса. Например, отдельные программы могут управлять ресурсами на одном сервере. В результате может оказаться невозможным скопировать ресурс в место, которое находится на том же сервере. Этот метод идемпотентен, но небезопасен (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Раздел 9.1 [RFC2616]&lt;/a&gt; ). Ответы на этот метод НЕ ДОЛЖНЫ кэшироваться.</target>
        </trans-unit>
        <trans-unit id="14111f3c8a7b4d6556d104b92402303159cbab91" translate="yes" xml:space="preserve">
          <source>The COPY method on a collection without a Depth header MUST act as if
   a Depth header with value &quot;infinity&quot; was included.  A client may
   submit a Depth header on a COPY on a collection with a value of &quot;0&quot;
   or &quot;infinity&quot;.  Servers MUST support the &quot;0&quot; and &quot;infinity&quot; Depth
   header behaviors on WebDAV-compliant resources.

   An infinite-depth COPY instructs that the collection resource
   identified by the Request-URI is to be copied to the location
   identified by the URI in the Destination header, and all its internal
   member resources are to be copied to a location relative to it,
   recursively through all levels of the collection hierarchy.  Note
   that an infinite-depth COPY of /A/ into /A/B/ could lead to infinite
   recursion if not handled correctly.

   A COPY of &quot;Depth: 0&quot; only instructs that the collection and its
   properties, but not resources identified by its internal member URLs,
   are to be copied.

   Any headers included with a COPY MUST be applied in processing every
   resource to be copied with the exception of the Destination header.

   The Destination header only specifies the destination URI for the
   Request-URI.  When applied to members of the collection identified by
   the Request-URI, the value of Destination is to be modified to
   reflect the current location in the hierarchy.  So, if the Request-
   URI is /a/ with Host header value http://example.com/ and the 

   Destination is http://example.com/b/, then when
   http://example.com/a/c/d is processed, it must use a Destination of
   http://example.com/b/c/d.

   When the COPY method has completed processing, it MUST have created a
   consistent URL namespace at the destination (see &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; for the
   definition of namespace consistency).  However, if an error occurs
   while copying an internal collection, the server MUST NOT copy any
   resources identified by members of this collection (i.e., the server
   must skip this subtree), as this would create an inconsistent
   namespace.  After detecting an error, the COPY operation SHOULD try
   to finish as much of the original copy operation as possible (i.e.,
   the server should still attempt to copy other subtrees and their
   members that are not descendants of an error-causing collection).

   So, for example, if an infinite-depth copy operation is performed on
   collection /a/, which contains collections /a/b/ and /a/c/, and an
   error occurs copying /a/b/, an attempt should still be made to copy
   /a/c/.  Similarly, after encountering an error copying a non-
   collection resource as part of an infinite-depth copy, the server
   SHOULD try to finish as much of the original copy operation as
   possible.

   If an error in executing the COPY method occurs with a resource other
   than the resource identified in the Request-URI, then the response
   MUST be a 207 (Multi-Status), and the URL of the resource causing the
   failure MUST appear with the specific error.

   The 424 (Failed Dependency) status code SHOULD NOT be returned in the
   207 (Multi-Status) response from a COPY method.  These responses can
   be safely omitted because the client will know that the progeny of a
   resource could not be copied when the client receives an error for
   the parent.  Additionally, 201 (Created)/204 (No Content) status
   codes SHOULD NOT be returned as values in 207 (Multi-Status)
   responses from COPY methods.  They, too, can be safely omitted
   because they are the default success codes.</source>
          <target state="translated">Метод COPY для коллекции без заголовка Depth ДОЛЖЕН действовать так, как если бы был включен заголовок Depth со значением &amp;laquo;бесконечность&amp;raquo;. Клиент может отправить заголовок глубины в КОПИИ коллекции со значением &amp;laquo;0&amp;raquo; или &amp;laquo;бесконечность&amp;raquo;. Серверы ДОЛЖНЫ поддерживать поведение заголовка глубины &amp;laquo;0&amp;raquo; и &amp;laquo;бесконечность&amp;raquo; на ресурсах, совместимых с WebDAV. Бесконечная копия COPY указывает, что ресурс коллекции, идентифицированный Request-URI, должен быть скопирован в местоположение, указанное URI в заголовке Destination, и все его внутренние ресурсы-члены должны быть скопированы в местоположение относительно него, рекурсивно на всех уровнях иерархии коллекций. Обратите внимание, что КОПИРОВАНИЕ / A / в / A / B / бесконечной глубины может привести к бесконечной рекурсии, если не обработано правильно. КОПИЯ &amp;laquo;Глубины:0 &quot;указывает только на то, что необходимо скопировать коллекцию и ее свойства, но не ресурсы, идентифицированные ее внутренними URL-адресами. Любые заголовки, включенные в COPY, ДОЛЖНЫ применяться при обработке каждого копируемого ресурса, за исключением заголовка Destination. Заголовок Destination указывает только URI пункта назначения для Request-URI. При применении к членам коллекции, идентифицированным Request-URI, значение Destination должно быть изменено, чтобы отражать текущее местоположение в иерархии. Итак, если Request - URI - это / a / со значением заголовка хоста http://example.com/, а назначение - http://example.com/b/, тогда при обработке http://example.com/a/c/d , он должен использовать назначение http://example.com/b/c/d. Когда метод COPY завершит обработку,он ДОЛЖЕН создать согласованное пространство имен URL в месте назначения (см.&lt;a href=&quot;#section-5.1&quot;&gt;Раздел 5.1&lt;/a&gt;для определения согласованности пространства имен). Однако, если при копировании внутренней коллекции возникает ошибка, сервер НЕ ДОЛЖЕН копировать какие-либо ресурсы, идентифицированные членами этой коллекции (т. Е. Сервер должен пропускать это поддерево), поскольку это создаст несогласованное пространство имен. После обнаружения ошибки операции КОПИРОВАТЬ СЛЕДУЕТ попытаться завершить как можно большую часть исходной операции копирования (т. Е. Сервер все равно должен пытаться скопировать другие поддеревья и их элементы, которые не являются потомками вызывающей ошибку коллекции). Так, например, если операция копирования с бесконечной глубиной выполняется для коллекции / a /, которая содержит коллекции / a / b / и / a / c /, и возникает ошибка копирования / a / b /, попытка все равно должна быть Сделать копию / a / c /. Так же,после обнаружения ошибки при копировании ресурса, не являющегося коллекцией, как части копии с бесконечной глубиной, серверу СЛЕДУЕТ попытаться завершить как можно большую часть исходной операции копирования. Если ошибка при выполнении метода COPY происходит с ресурсом, отличным от ресурса, указанного в Request-URI, то ответ ДОЛЖЕН быть 207 (Multi-Status), а URL-адрес ресурса, вызвавшего сбой, ДОЛЖЕН появиться с конкретным ошибка. Код состояния 424 (неудачная зависимость) НЕ ДОЛЖЕН возвращаться в ответе 207 (мульти-статус) от метода COPY. Эти ответы можно безопасно опустить, потому что клиент будет знать, что потомок ресурса не может быть скопирован, когда клиент получит ошибку для родителя. Дополнительно,Коды состояния 201 (Создано) / 204 (Нет содержимого) НЕ ДОЛЖНЫ возвращаться как значения в ответах 207 (Мульти-статус) от методов КОПИРОВАНИЯ. Их тоже можно безопасно опустить, потому что они являются кодами успеха по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4ccb4eecacf9e00ad51b2aefeb841f59a202bd7d" translate="yes" xml:space="preserve">
          <source>The CORS mechanism supports secure cross-origin requests and data transfers between browsers and servers. Modern browsers use CORS in APIs such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; to mitigate the risks of cross-origin HTTP requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbbf23077eb5623c9faba43d84ac7826f9fbf870" translate="yes" xml:space="preserve">
          <source>The CORS mechanism supports secure cross-origin requests and data transfers between browsers and web servers. Modern browsers use CORS in an API container such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; to help mitigate the risks of cross-origin HTTP requests.</source>
          <target state="translated">Механизм CORS поддерживает безопасные запросы из разных источников и передачу данных между браузерами и веб-серверами. Современные браузеры используют CORS в контейнере API, таком как &lt;code&gt;XMLHttpRequest&lt;/code&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch,&lt;/a&gt; чтобы снизить риски HTTP-запросов между разными источниками.</target>
        </trans-unit>
        <trans-unit id="96ee35d668c5e43e29f1dd8cb8ffc05ffe8f756d" translate="yes" xml:space="preserve">
          <source>The CORS protocol originally required that behavior but &lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;was subsequently changed to no longer require it&lt;/a&gt;. However, not all browsers have implemented the change, and so still exhibit the behavior that was originally required.</source>
          <target state="translated">Протокол CORS изначально требовал такого поведения, но &lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;впоследствии был изменен, чтобы он больше не требовался&lt;/a&gt; . Однако не все браузеры реализовали это изменение и поэтому по-прежнему демонстрируют поведение, которое требовалось изначально.</target>
        </trans-unit>
        <trans-unit id="90251c7853324d5188765c4d4396bb48f7d83e13" translate="yes" xml:space="preserve">
          <source>The CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive should be used with this header, otherwise this header will be an expensive no-op machine.</source>
          <target state="translated">С этим заголовком следует использовать директиву CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; , иначе этот заголовок будет дорогостоящим бесполезным компьютером.</target>
        </trans-unit>
        <trans-unit id="bb80a0a4cc2668fea5fc69f81138adf60314c6bd" translate="yes" xml:space="preserve">
          <source>The CSP mechanism allows multiple policies being specified for a resource, including via the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header, the &lt;a href=&quot;content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1440f01ca2c2191b9c319acb6ec56e362606ce" translate="yes" xml:space="preserve">
          <source>The Cache-Control general-header field is used to specify directives
   that MUST be obeyed by all caching mechanisms along the
   request/response chain. The directives specify behavior intended to
   prevent caches from adversely interfering with the request or
   response. These directives typically override the default caching
   algorithms. Cache directives are unidirectional in that the presence
   of a directive in a request does not imply that the same directive is
   to be given in the response.

      Note that HTTP/1.0 caches might not implement Cache-Control and
      might only implement Pragma: no-cache (see &lt;a href=&quot;#section-14.32&quot;&gt;section 14.32&lt;/a&gt;).

   Cache directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a cache-
   directive for a specific cache.

    Cache-Control   = &quot;Cache-Control&quot; &quot;:&quot; 1#cache-directive

    cache-directive = cache-request-directive
         | cache-response-directive

    cache-request-directive =
           &quot;no-cache&quot;                          ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                          ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds         ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;, 14.9.4
         | &quot;max-stale&quot; [ &quot;=&quot; delta-seconds ]   ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;min-fresh&quot; &quot;=&quot; delta-seconds       ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;no-transform&quot;                      ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;only-if-cached&quot;                    ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | cache-extension                     ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

     cache-response-directive =
           &quot;public&quot;                               ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;private&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ] ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-cache&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ]; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                             ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;no-transform&quot;                         ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;must-revalidate&quot;                      ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;proxy-revalidate&quot;                     ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds            ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;s-maxage&quot; &quot;=&quot; delta-seconds           ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | cache-extension                        ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

    cache-extension = token [ &quot;=&quot; ( token | quoted-string ) ] 

   When a directive appears without any 1#field-name parameter, the
   directive applies to the entire request or response. When such a
   directive appears with a 1#field-name parameter, it applies only to
   the named field or fields, and not to the rest of the request or
   response. This mechanism supports extensibility; implementations of
   future versions of the HTTP protocol might apply these directives to
   header fields not defined in HTTP/1.1.

   The cache-control directives can be broken down into these general
   categories:

      - Restrictions on what are cacheable; these may only be imposed by
        the origin server.

      - Restrictions on what may be stored by a cache; these may be
        imposed by either the origin server or the user agent.

      - Modifications of the basic expiration mechanism; these may be
        imposed by either the origin server or the user agent.

      - Controls over cache revalidation and reload; these may only be
        imposed by a user agent.

      - Control over transformation of entities.

      - Extensions to the caching system.</source>
          <target state="translated">Поле общего заголовка Cache-Control используется для определения директив, которые ДОЛЖНЫ выполняться всеми механизмами кэширования в цепочке запросов / ответов. Директивы определяют поведение, предназначенное для предотвращения неблагоприятного воздействия кэшей на запрос или ответ. Эти директивы обычно переопределяют алгоритмы кэширования по умолчанию. Директивы кэша являются однонаправленными в том смысле, что наличие директивы в запросе не означает, что та же самая директива должна быть указана в ответе. Обратите внимание, что кеши HTTP / 1.0 могут не реализовывать Cache-Control и могут реализовывать только Pragma: no-cache (см. &lt;a href=&quot;#section-14.32&quot;&gt;Раздел 14.32&lt;/a&gt;). Директивы кэша ДОЛЖНЫ передаваться прокси-сервером или приложением-шлюзом, независимо от их значимости для этого приложения, поскольку директивы могут применяться ко всем получателям в цепочке запросов / ответов. Невозможно указать директиву cache- для конкретного кеша. Cache-Control = &quot;Cache-Control&quot; &quot;:&quot; 1 # кеш-директива cache-directive = кеш-запрос-директива | кеш-ответ-директива кеш-запрос-директива = &quot;без кеша&quot;; &lt;a href=&quot;#section-14.9.1&quot;&gt;Раздел 14.9.1&lt;/a&gt; | &quot;нет магазина&quot;; &lt;a href=&quot;#section-14.9.2&quot;&gt;Раздел 14.9.2&lt;/a&gt; | &quot;max-age&quot; &quot;=&quot; дельта-секунды; &lt;a href=&quot;#section-14.9.3&quot;&gt;Раздел 14.9.3&lt;/a&gt; , 14.9.4 | &amp;laquo;Макс-затхлый&amp;raquo;[&quot;=&quot; дельта-секунды]; &lt;a href=&quot;#section-14.9.3&quot;&gt;Раздел 14.9.3&lt;/a&gt; | &quot;min-fresh&quot; &quot;=&quot; дельта-секунды; &lt;a href=&quot;#section-14.9.3&quot;&gt;Раздел 14.9.3&lt;/a&gt; | &quot;без преобразования&quot;; &lt;a href=&quot;#section-14.9.5&quot;&gt;Раздел 14.9.5&lt;/a&gt; | &quot;только при кэшировании&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;Раздел 14.9.4&lt;/a&gt; | кеш-расширение; &lt;a href=&quot;#section-14.9.6&quot;&gt;Раздел 14.9.6&lt;/a&gt; cache-response-directive = &quot;public&quot;; &lt;a href=&quot;#section-14.9.1&quot;&gt;Раздел 14.9.1&lt;/a&gt; | &quot;private&quot; [&quot;=&quot; &amp;lt;&quot;&amp;gt; 1 # имя-поля &amp;lt;&quot;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;Раздел 14.9.1&lt;/a&gt; | &quot;no-cache&quot; [&quot;=&quot; &amp;lt;&quot;&amp;gt; 1 # имя-поля &amp;lt;&quot;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;Раздел 14.9.1&lt;/a&gt; | &quot;нет магазина&quot;;&lt;a href=&quot;#section-14.9.2&quot;&gt;Раздел 14.9.2&lt;/a&gt; | &quot;без преобразования&quot;; &lt;a href=&quot;#section-14.9.5&quot;&gt;Раздел 14.9.5&lt;/a&gt; | &quot;необходимо перепроверить&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;Раздел 14.9.4&lt;/a&gt; | &quot;proxy-revalidate&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;Раздел 14.9.4&lt;/a&gt; | &quot;max-age&quot; &quot;=&quot; дельта-секунды; &lt;a href=&quot;#section-14.9.3&quot;&gt;Раздел 14.9.3&lt;/a&gt; | &quot;s-maxage&quot; &quot;=&quot; дельта-секунды; &lt;a href=&quot;#section-14.9.3&quot;&gt;Раздел 14.9.3&lt;/a&gt; | кеш-расширение; &lt;a href=&quot;#section-14.9.6&quot;&gt;Раздел 14.9.6&lt;/a&gt; cache-extension = token [&quot;=&quot; (токен | строка в кавычках)] Когда директива появляется без какого-либо 1 # параметра field-name, директива применяется ко всему запросу или ответу. Когда такая директива появляется с параметром 1 # field-name, она применяется только к названному полю или полям, а не к остальной части запроса или ответа. Этот механизм поддерживает расширяемость; реализации будущих версий протокола HTTP могут применять эти директивы к полям заголовка, не определенным в HTTP / 1.1. Директивы управления кешем можно разбить на следующие общие категории: - Ограничения на то, что кэшируется; они могут быть наложены только исходным сервером. - Ограничения на то, что может храниться в кэше; они могут быть наложены либо исходным сервером, либо пользовательским агентом.- Модификации основного механизма истечения срока действия; они могут быть наложены либо исходным сервером, либо пользовательским агентом. - Контроль повторной валидации и перезагрузки кеша; они могут быть наложены только пользовательским агентом. - Контроль трансформации юридических лиц. - Расширения к системе кеширования.</target>
        </trans-unit>
        <trans-unit id="9324bfa18c0087b8561a3281ae4b9944c65be9ca" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional assigned value.
   Informational extensions (those which do not require a change in
   cache behavior) MAY be added without changing the semantics of other
   directives. Behavioral extensions are designed to work by acting as
   modifiers to the existing base of cache directives. Both the new
   directive and the standard directive are supplied, such that
   applications which do not understand the new directive will default
   to the behavior specified by the standard directive, and those that
   understand the new directive will recognize it as modifying the
   requirements associated with the standard directive. In this way,
   extensions to the cache-control directives can be made without
   requiring changes to the base protocol.

   This extension mechanism depends on an HTTP cache obeying all of the
   cache-control directives defined for its native HTTP-version, obeying
   certain extensions, and ignoring all directives that it does not
   understand.

   For example, consider a hypothetical new response directive called
   community which acts as a modifier to the private directive. We
   define this new directive to mean that, in addition to any non-shared
   cache, any cache which is shared only by members of the community
   named within its value may cache the response. An origin server
   wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

       Cache-Control: private, community=&quot;UCI&quot;

   A cache seeing this header field will act correctly even if the cache
   does not understand the community cache-extension, since it will also
   see and understand the private directive and thus default to the safe
   behavior. 

   Unrecognized cache-directives MUST be ignored; it is assumed that any
   cache-directive likely to be unrecognized by an HTTP/1.1 cache will
   be combined with standard directives (or the response's default
   cacheability) such that the cache behavior will remain minimally
   correct even if the cache does not understand the extension(s).</source>
          <target state="translated">Поле заголовка Cache-Control может быть расширено с помощью одного или нескольких маркеров расширения кэша,каждый из которых имеет опционально назначенное значение.Информационные расширения (те,которые не требуют изменения поведения кэша)MAY могут быть добавлены без изменения семантики других директив.Поведенческие расширения предназначены для работы в качестве модификаторов к существующей базе кэш-директив.И новая директива,и стандартная директива поставляются таким образом,что приложения,которые не понимают новую директиву,будут по умолчанию соответствовать поведению,указанному стандартной директивой,а те,кто понимают новую директиву,будут распознавать ее как модифицирующую требования,связанные со стандартной директивой.Таким образом,расширения к директивам управления кэшем могут быть сделаны без необходимости внесения изменений в базовый протокол.Этот механизм расширений зависит от того,что HTTP-кэш подчиняется всем директивам управления кэшем,определенным для его родной HTTP-версии,подчиняется определенным расширениям и игнорирует все директивы,которые ему непонятны.Например,рассмотрим гипотетическую новую директиву ответа,называемую community,которая действует как модификатор к директиве private.Мы определяем эту новую директиву как означающую,что в дополнение к любому неиспользуемому кэшу,любой кэш,который является общим только для членов сообщества,названного в пределах его значения,может кэшировать ответ.Исходный сервер,желающий разрешить сообществу UCI использовать приватный ответ в своем общем кэше(ах),может сделать это,включив Cache-Control:private,community=&quot;UCI&quot; Кэш,видящий это поле заголовка,будет действовать корректно,даже если кэш не понимает расширение кэша сообщества,так как он также увидит и поймет директиву private и,таким образом,по умолчанию будет безопасным поведением.Непопознанные директивы по кэшированию ДОЛЖНЫ быть проигнорированы,предполагается,что любые директивы по кэшированию,которые могут быть нераспознаны кэшем HTTP/1.1,будут объединены со стандартными директивами (или кэшируемостью ответа по умолчанию)таким образом,что поведение кэша останется минимально корректным даже в том случае,если кэш не понимает расширения(-ий).</target>
        </trans-unit>
        <trans-unit id="f33f8e03ed1edc160f54d39609d6b7e8bfc2a2f7" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional value.  A cache
   MUST ignore unrecognized cache directives.

   Informational extensions (those that do not require a change in cache
   behavior) can be added without changing the semantics of other
   directives.

   Behavioral extensions are designed to work by acting as modifiers to
   the existing base of cache directives.  Both the new directive and
   the old directive are supplied, such that applications that do not
   understand the new directive will default to the behavior specified
   by the old directive, and those that understand the new directive
   will recognize it as modifying the requirements associated with the
   old directive.  In this way, extensions to the existing cache-control
   directives can be made without breaking deployed caches.

   For example, consider a hypothetical new response directive called
   &quot;community&quot; that acts as a modifier to the private directive: in
   addition to private caches, any cache that is shared only by members
   of the named community is allowed to cache the response.  An origin
   server wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

     Cache-Control: private, community=&quot;UCI&quot;

   A cache that recognizes such a community cache-extension could
   broaden its behavior in accordance with that extension.  A cache that
   does not recognize the community cache-extension would ignore it and
   adhere to the private directive.</source>
          <target state="translated">Поле заголовка Cache-Control может быть расширено с помощью одного или нескольких маркеров расширения кэша,каждый из которых имеет дополнительное значение.Кэш ДОЛЖЕН игнорировать нераспознанные директивы кэша.Информационные расширения (те,которые не требуют изменения поведения кэша)могут быть добавлены без изменения семантики других директив.Поведенческие расширения предназначены для работы в качестве модификаторов к существующей базе директив кэша.И новая,и старая директива поставляются таким образом,что приложения,которые не понимают новую директиву,будут по умолчанию соответствовать поведению,указанному старой директивой,а те,кто понимает новую директиву,будут распознавать ее как модифицирующую требования,связанные со старой директивой.Таким образом,расширения к существующим директивам управления кэшем могут быть сделаны без разрыва развернутого кэша.Например,рассмотрим гипотетическую новую директиву ответа,называемую &quot;community&quot;,которая действует как модификатор к директиве private:в дополнение к приватным кэшам любой кэш,совместно используемый только членами именованного сообщества,может кэшировать ответ.Исходный сервер,желающий разрешить сообществу UCI использовать приватный ответ в своем общем кэше(ах),может сделать это,включив Cache-Control:private,community=&quot;UCI&quot; Кэш,который распознает такое расширение кэша сообщества,может расширить свое поведение в соответствии с этим расширением.Кэш,который не распознает расширение community cache-extension,будет игнорировать его и придерживаться директивы private.</target>
        </trans-unit>
        <trans-unit id="b85b1bbcc9141ccc627797dbf9d5406273b17461" translate="yes" xml:space="preserve">
          <source>The California Consumer Privacy Act</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50007c31e7e40ed5eaa0ff3024c3f4a7f1a8be9" translate="yes" xml:space="preserve">
          <source>The Chrome (or Chromium/Blink-based engines) user agent string is similar to Firefox&amp;rsquo;s. For compatibility, it adds strings like &lt;code&gt;KHTML, like Gecko&lt;/code&gt; and &lt;code&gt;Safari&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4526b0c406ce54b0f40282cbe0ea0db53127d37" translate="yes" xml:space="preserve">
          <source>The Chrome (or Chromium/blink-based engines) user agent string is similar to the Firefox format. For compatibility, it adds strings like &quot;KHTML, like Gecko&quot; and &quot;Safari&quot;.</source>
          <target state="translated">Строка пользовательского агента Chrome (или Chromium/blink-based engines)похожа на формат Firefox.Для совместимости он добавляет строки типа &quot;KHTML,как Gecko&quot; и &quot;Safari&quot;.</target>
        </trans-unit>
        <trans-unit id="4e445db7bcb2d5d8898885e114adb8cb0619ec53" translate="yes" xml:space="preserve">
          <source>The Connection general-header field allows the sender to specify
   options that are desired for that particular connection and MUST NOT
   be communicated by proxies over further connections.

   The Connection header has the following grammar:

       Connection = &quot;Connection&quot; &quot;:&quot; 1#(connection-token)
       connection-token  = token

   HTTP/1.1 proxies MUST parse the Connection header field before a
   message is forwarded and, for each connection-token in this field,
   remove any header field(s) from the message with the same name as the
   connection-token. Connection options are signaled by the presence of
   a connection-token in the Connection header field, not by any
   corresponding additional header field(s), since the additional header
   field may not be sent if there are no parameters associated with that
   connection option.

   Message headers listed in the Connection header MUST NOT include
   end-to-end headers, such as Cache-Control.

   HTTP/1.1 defines the &quot;close&quot; connection option for the sender to
   signal that the connection will be closed after completion of the
   response. For example,

       Connection: close

   in either the request or the response header fields indicates that
   the connection SHOULD NOT be considered `persistent' (&lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;)
   after the current request/response is complete.

   HTTP/1.1 applications that do not support persistent connections MUST
   include the &quot;close&quot; connection option in every message.

   A system receiving an HTTP/1.0 (or lower-version) message that
   includes a Connection header MUST, for each connection-token in this
   field, remove and ignore any header field(s) from the message with
   the same name as the connection-token. This protects against mistaken
   forwarding of such header fields by pre-HTTP/1.1 proxies. See &lt;a href=&quot;#section-19.6.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt;.</source>
          <target state="translated">Поле общего заголовка соединения позволяет отправителю указывать параметры, которые требуются для этого конкретного соединения, и НЕ ДОЛЖНЫ передаваться прокси-серверами через другие соединения. Заголовок Connection имеет следующую грамматику: Connection = &quot;Connection&quot; &quot;:&quot; 1 # (токен соединения) токен соединения = токен HTTP / 1.1 прокси ДОЛЖНЫ анализировать поле заголовка соединения перед пересылкой сообщения и для каждого токена соединения в этом поле удалите все поля заголовка из сообщения с тем же именем, что и токен соединения. Варианты подключения сигнализируются наличием токена подключения в поле заголовка подключения, а не соответствующими дополнительными полями заголовка,поскольку дополнительное поле заголовка не может быть отправлено, если с этим вариантом подключения не связаны параметры. Заголовки сообщений, перечисленные в заголовке соединения, НЕ ДОЛЖНЫ включать сквозные заголовки, такие как Cache-Control. HTTP / 1.1 определяет опцию &amp;laquo;закрытия&amp;raquo; соединения для отправителя, чтобы сообщить, что соединение будет закрыто после завершения ответа. Например, Connection: close в полях заголовка запроса или ответа указывает, что соединение НЕ СЛЕДУЕТ рассматривать как постоянное (опция соединения для отправителя, чтобы сообщить, что соединение будет закрыто после завершения ответа. Например, Connection: close в полях заголовка запроса или ответа указывает, что соединение НЕ ДОЛЖНО считаться постоянным (опция соединения для отправителя, чтобы сообщить, что соединение будет закрыто после завершения ответа. Например, Connection: close в полях заголовка запроса или ответа указывает, что соединение НЕ ДОЛЖНО считаться постоянным (&lt;a href=&quot;#section-8.1&quot;&gt;раздел 8.1&lt;/a&gt; ) после завершения текущего запроса / ответа. Приложения HTTP / 1.1, которые не поддерживают постоянные соединения, ДОЛЖНЫ включать опцию &amp;laquo;закрыть&amp;raquo; соединение в каждое сообщение. Система, получающая сообщение HTTP / 1.0 (или более ранней версии), которое включает заголовок соединения, ДОЛЖНА для каждого токена соединения в этом поле удалять и игнорировать любые поля заголовка из сообщения с тем же именем, что и соединение. маркер. Это защищает от ошибочной пересылки таких полей заголовка прокси до HTTP / 1.1. См. &lt;a href=&quot;#section-19.6.2&quot;&gt;Раздел &lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="400f4aed66b4ae488aed6a9f1d0ba0a1d48e0bf5" translate="yes" xml:space="preserve">
          <source>The Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) provides a &quot;close&quot;
   connection option that a sender SHOULD send when it wishes to close
   the connection after the current request/response pair.

   A client that sends a &quot;close&quot; connection option MUST NOT send further
   requests on that connection (after the one containing &quot;close&quot;) and
   MUST close the connection after reading the final response message
   corresponding to this request.

   A server that receives a &quot;close&quot; connection option MUST initiate a
   close of the connection (see below) after it sends the final response
   to the request that contained &quot;close&quot;.  The server SHOULD send a
   &quot;close&quot; connection option in its final response on that connection.
   The server MUST NOT process any further requests received on that
   connection.

   A server that sends a &quot;close&quot; connection option MUST initiate a close
   of the connection (see below) after it sends the response containing
   &quot;close&quot;.  The server MUST NOT process any further requests received
   on that connection.

   A client that receives a &quot;close&quot; connection option MUST cease sending
   requests on that connection and close the connection after reading
   the response message containing the &quot;close&quot;; if additional pipelined
   requests had been sent on the connection, the client SHOULD NOT
   assume that they will be processed by the server. 

   If a server performs an immediate close of a TCP connection, there is
   a significant risk that the client will not be able to read the last
   HTTP response.  If the server receives additional data from the
   client on a fully closed connection, such as another request that was
   sent by the client before receiving the server's response, the
   server's TCP stack will send a reset packet to the client;
   unfortunately, the reset packet might erase the client's
   unacknowledged input buffers before they can be read and interpreted
   by the client's HTTP parser.

   To avoid the TCP reset problem, servers typically close a connection
   in stages.  First, the server performs a half-close by closing only
   the write side of the read/write connection.  The server then
   continues to read from the connection until it receives a
   corresponding close by the client, or until the server is reasonably
   certain that its own TCP stack has received the client's
   acknowledgement of the packet(s) containing the server's last
   response.  Finally, the server fully closes the connection.

   It is unknown whether the reset problem is exclusive to TCP or might
   also be found in other transport connection protocols.</source>
          <target state="translated">Поле заголовка соединения ( &lt;a href=&quot;#section-6.1&quot;&gt;раздел 6.1&lt;/a&gt;) предоставляет опцию &amp;laquo;закрыть&amp;raquo; соединение, которую ДОЛЖЕН отправить отправитель, когда он хочет закрыть соединение после текущей пары запрос / ответ. Клиент, который отправляет опцию &amp;laquo;закрыть&amp;raquo; соединение, НЕ ДОЛЖЕН отправлять дальнейшие запросы по этому соединению (после того, который содержит &amp;laquo;закрыть&amp;raquo;) и ДОЛЖЕН закрыть соединение после прочтения окончательного ответного сообщения, соответствующего этому запросу. Сервер, который получает опцию &amp;laquo;закрыть&amp;raquo; соединение, ДОЛЖЕН инициировать закрытие соединения (см. Ниже) после того, как он отправит окончательный ответ на запрос, содержащий &amp;laquo;закрыть&amp;raquo;. Серверу СЛЕДУЕТ отправить параметр &amp;laquo;закрыть&amp;raquo; соединение в своем окончательном ответе на это соединение. Сервер НЕ ДОЛЖЕН обрабатывать дальнейшие запросы, полученные по этому соединению. Сервер, который отправляет &quot;Параметр соединения close &quot;ДОЛЖЕН инициировать закрытие соединения (см. ниже) после того, как он отправит ответ, содержащий&quot; закрыть &quot;. Сервер НЕ ДОЛЖЕН обрабатывать любые дальнейшие запросы, полученные по этому соединению. Клиент, который получает параметр соединения&quot; закрыть &quot;, ДОЛЖЕН прекратить отправка запросов по этому соединению и закрытие соединения после прочтения ответного сообщения, содержащего &quot;закрыть&quot;; если в соединении были отправлены дополнительные конвейерные запросы, клиент НЕ ДОЛЖЕН предполагать, что они будут обработаны сервером. Если сервер выполняет немедленное закрытие TCP-соединения, существует значительный риск того, что клиент не сможет прочитать последний HTTP-ответ. Если сервер получает дополнительные данные от клиента при полностью закрытом соединении,например, другой запрос, который был отправлен клиентом до получения ответа сервера, стек TCP сервера отправит клиенту пакет сброса; К сожалению, пакет сброса может стереть неподтвержденные входные буферы клиента до того, как они будут прочитаны и интерпретированы клиентским анализатором HTTP. Чтобы избежать проблемы сброса TCP, серверы обычно закрывают соединение поэтапно. Сначала сервер выполняет полузакрытие, закрывая только сторону записи соединения чтения / записи. Затем сервер продолжает чтение из соединения до тех пор, пока он не получит соответствующее закрытие от клиента или пока сервер не будет достаточно уверен, что его собственный TCP-стек получил подтверждение клиента о пакете (-ах), содержащем последний ответ сервера. В заключение,сервер полностью закрывает соединение. Неизвестно, является ли проблема сброса исключительной для TCP или также может быть обнаружена в других протоколах транспортного соединения.</target>
        </trans-unit>
        <trans-unit id="e4269110c11e8492bcb4464320596b28df93a15f" translate="yes" xml:space="preserve">
          <source>The Content-Disposition response-header field has been proposed as a
   means for the origin server to suggest a default filename if the user
   requests that the content is saved to a file. This usage is derived
   from the definition of Content-Disposition in &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; [&lt;a href=&quot;#ref-35&quot;&gt;35&lt;/a&gt;].

        content-disposition = &quot;Content-Disposition&quot; &quot;:&quot;
                              disposition-type *( &quot;;&quot; disposition-parm )
        disposition-type = &quot;attachment&quot; | disp-extension-token
        disposition-parm = filename-parm | disp-extension-parm
        filename-parm = &quot;filename&quot; &quot;=&quot; quoted-string
        disp-extension-token = token
        disp-extension-parm = token &quot;=&quot; ( token | quoted-string )

   An example is

        Content-Disposition: attachment; filename=&quot;fname.ext&quot;

   The receiving user agent SHOULD NOT respect any directory path
   information present in the filename-parm parameter, which is the only
   parameter believed to apply to HTTP implementations at this time. The
   filename SHOULD be treated as a terminal component only.

   If this header is used in a response with the application/octet-
   stream content-type, the implied suggestion is that the user agent
   should not display the response, but directly enter a `save response
   as...' dialog.

   See &lt;a href=&quot;#section-15.5&quot;&gt;section 15.5&lt;/a&gt; for Content-Disposition security issues.</source>
          <target state="translated">Поле заголовка ответа Content-Disposition было предложено в качестве средства для исходного сервера, чтобы предложить имя файла по умолчанию, если пользователь запрашивает сохранение содержимого в файл. Это использование происходит из определения Content-Disposition в &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; [ &lt;a href=&quot;#ref-35&quot;&gt;35&lt;/a&gt;]. content-disposition = &quot;Content-Disposition&quot; &quot;:&quot; disposition-type * (&quot;;&quot; disposition-parm) disposition-type = &quot;attachment&quot; | disp-extension-token disposition-parm = filename-parm | disp-extension-parm filename-parm = &quot;filename&quot; &quot;=&quot; строка в кавычках disp-extension-token = token disp-extension-parm = token &quot;=&quot; (токен | строка в кавычках) Пример: Content-Disposition: attachment ; filename = &quot;fname.ext&quot; Принимающий пользовательский агент НЕ ДОЛЖЕН учитывать любую информацию о пути к каталогу, представленную в параметре filename-parm, который является единственным параметром, который, как считается, применим к реализациям HTTP в настоящее время. Имя файла СЛЕДУЕТ рассматривать только как терминальный компонент.Если этот заголовок используется в ответе с типом содержимого application / octet-stream, подразумевается, что пользовательский агент не должен отображать ответ, а непосредственно вводить диалоговое окно &amp;laquo;сохранить ответ как ...&amp;raquo;. Видеть&lt;a href=&quot;#section-15.5&quot;&gt;раздел 15.5&lt;/a&gt; по вопросам безопасности Content-Disposition.</target>
        </trans-unit>
        <trans-unit id="22177303e5c541de4c1a2fb13e69fc833be5a044" translate="yes" xml:space="preserve">
          <source>The Content-Encoding entity-header field is used as a modifier to the
   media-type. When present, its value indicates what additional content
   codings have been applied to the entity-body, and thus what decoding
   mechanisms must be applied in order to obtain the media-type
   referenced by the Content-Type header field. Content-Encoding is
   primarily used to allow a document to be compressed without losing
   the identity of its underlying media type.

       Content-Encoding  = &quot;Content-Encoding&quot; &quot;:&quot; 1#content-coding

   Content codings are defined in &lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;. An example of its use is

       Content-Encoding: gzip

   The content-coding is a characteristic of the entity identified by
   the Request-URI. Typically, the entity-body is stored with this
   encoding and is only decoded before rendering or analogous usage.
   However, a non-transparent proxy MAY modify the content-coding if the
   new coding is known to be acceptable to the recipient, unless the
   &quot;no-transform&quot; cache-control directive is present in the message.

   If the content-coding of an entity is not &quot;identity&quot;, then the
   response MUST include a Content-Encoding entity-header (&lt;a href=&quot;#section-14.11&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;) that lists the non-identity content-coding(s) used.

   If the content-coding of an entity in a request message is not
   acceptable to the origin server, the server SHOULD respond with a
   status code of 415 (Unsupported Media Type).

   If multiple encodings have been applied to an entity, the content
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.</source>
          <target state="translated">Поле заголовка объекта Content-Encoding используется в качестве модификатора медиа-типа. Когда он присутствует, его значение указывает, какие дополнительные кодировки контента были применены к телу объекта, и, следовательно, какие механизмы декодирования должны быть применены для получения медиа-типа, на который ссылается поле заголовка Content-Type. Content-Encoding в основном используется для сжатия документа без потери идентичности его базового типа носителя. Content-Encoding = &quot;Content-Encoding&quot; &quot;:&quot; 1 # content-coding Кодирование содержимого определено в &lt;a href=&quot;#section-3.5&quot;&gt;разделе 3.5.&lt;/a&gt;, Примером его использования является Content-Encoding: gzip. Content-coding - это характеристика объекта, идентифицированного Request-URI. Обычно тело объекта сохраняется с этой кодировкой и декодируется только перед визуализацией или аналогичным использованием. Однако непрозрачный прокси МОЖЕТ изменить кодирование содержимого, если известно, что новое кодирование приемлемо для получателя, если только в сообщении не присутствует директива управления кешем &amp;laquo;без преобразования&amp;raquo;. Если кодирование содержимого объекта не является &amp;laquo;идентичностью&amp;raquo;, то ответ ДОЛЖЕН включать заголовок объекта Content-Encoding ( &lt;a href=&quot;#section-14.11&quot;&gt;раздел &lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;), в котором перечислены используемые неидентификационные коды содержимого. Если кодирование содержимого объекта в сообщении запроса неприемлемо для исходного сервера, серверу СЛЕДУЕТ ответить кодом состояния 415 (неподдерживаемый тип носителя). Если к объекту было применено несколько кодировок, кодирование контента ДОЛЖНО быть перечислено в том порядке, в котором они были применены. Дополнительная информация о параметрах кодирования МОЖЕТ быть предоставлена ​​другими полями заголовка объекта, не определенными в данной спецификации.</target>
        </trans-unit>
        <trans-unit id="78e0f66604a34d6350aaee50ec1aed948b641dff" translate="yes" xml:space="preserve">
          <source>The Content-Language entity-header field describes the natural
   language(s) of the intended audience for the enclosed entity. Note
   that this might not be equivalent to all the languages used within
   the entity-body.

       Content-Language  = &quot;Content-Language&quot; &quot;:&quot; 1#language-tag 

   Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;. The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   entities according to the user's own preferred language. Thus, if the
   body content is intended only for a Danish-literate audience, the
   appropriate field is

       Content-Language: da

   If no Content-Language is specified, the default is that the content
   is intended for all language audiences. This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.

   Multiple languages MAY be listed for content that is intended for
   multiple audiences. For example, a rendition of the &quot;Treaty of
   Waitangi,&quot; presented simultaneously in the original Maori and English
   versions, would call for

       Content-Language: mi, en

   However, just because multiple languages are present within an entity
   does not mean that it is intended for multiple linguistic audiences.
   An example would be a beginner's language primer, such as &quot;A First
   Lesson in Latin,&quot; which is clearly intended to be used by an
   English-literate audience. In this case, the Content-Language would
   properly only include &quot;en&quot;.

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.</source>
          <target state="translated">Поле заголовка объекта Content-Language описывает естественный язык (языки) целевой аудитории для вложенного объекта. Обратите внимание, что это может быть не эквивалентно всем языкам, используемым в теле объекта. Content-Language = &quot;Content-Language&quot; &quot;:&quot; 1 # language-tag Языковые теги определены в &lt;a href=&quot;#section-3.10&quot;&gt;разделе 3.10.&lt;/a&gt;, Основная цель Content-Language - позволить пользователю идентифицировать и различать объекты в соответствии с его собственным предпочтительным языком. Таким образом, если основной контент предназначен только для аудитории, владеющей датским языком, соответствующее поле - Content-Language: da Если Content-Language не указан, по умолчанию контент предназначен для всех языковых аудиторий. Это может означать, что отправитель не считает его специфичным для какого-либо естественного языка или что отправитель не знает, для какого языка он предназначен. Для контента, предназначенного для разных аудиторий, МОГУТ быть указаны несколько языков. Например, исполнение &amp;laquo;Договора Вайтанги&amp;raquo;, представленное одновременно в оригинальной маори и английской версиях, будет требовать Content-Language: mi,Common crawl ru Однако наличие нескольких языков в объекте не означает, что он предназначен для нескольких языковых аудиторий. Примером может служить учебник по языку для начинающих, такой как &amp;laquo;Первый урок латыни&amp;raquo;, который явно предназначен для англоязычной аудитории. В этом случае Content-Language правильно будет включать только &amp;laquo;en&amp;raquo;. Content-Language МОЖЕТ применяться к любому типу мультимедиа - это не ограничивается текстовыми документами.Content-Language правильно будет включать только &quot;en&quot;. Content-Language МОЖЕТ применяться к любому типу мультимедиа - это не ограничивается текстовыми документами.Content-Language правильно будет включать только &quot;en&quot;. Content-Language МОЖЕТ применяться к любому типу мультимедиа - это не ограничивается текстовыми документами.</target>
        </trans-unit>
        <trans-unit id="a1abd3b0ff945fb9c54be7f36c23b898d0262eca" translate="yes" xml:space="preserve">
          <source>The Content-Length entity-header field indicates the size of the
   entity-body, in decimal number of OCTETs, sent to the recipient or,
   in the case of the HEAD method, the size of the entity-body that
   would have been sent had the request been a GET.

       Content-Length    = &quot;Content-Length&quot; &quot;:&quot; 1*DIGIT

   An example is

       Content-Length: 3495

   Applications SHOULD use this field to indicate the transfer-length of
   the message-body, unless this is prohibited by the rules in &lt;a href=&quot;#section-4.4&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. 

   Any Content-Length greater than or equal to zero is a valid value.
   &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; describes how to determine the length of a message-body
   if a Content-Length is not given.

   Note that the meaning of this field is significantly different from
   the corresponding definition in MIME, where it is an optional field
   used within the &quot;message/external-body&quot; content-type. In HTTP, it
   SHOULD be sent whenever the message's length can be determined prior
   to being transferred, unless this is prohibited by the rules in
   &lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;.</source>
          <target state="translated">Поле заголовка объекта Content-Length указывает размер тела объекта в десятичном числе OCTET, отправленных получателю, или, в случае метода HEAD, размер тела объекта, которое было бы отправлено, если бы запрос был GET. Content-Length = &quot;Content-Length&quot; &quot;:&quot; 1 * DIGIT. Примером Content-Length: 3495 СЛЕДУЕТ использовать это поле для указания длины передачи тела сообщения, если это не запрещено правилами в &lt;a href=&quot;#section-4.4&quot;&gt;разделе &lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;4.4.&lt;/a&gt; , Любое значение Content-Length, большее или равное нулю, является допустимым значением. &lt;a href=&quot;#section-4.4&quot;&gt;Раздел 4.4&lt;/a&gt;описывает, как определить длину тела сообщения, если Content-Length не задана. Обратите внимание, что значение этого поля значительно отличается от соответствующего определения в MIME, где это необязательное поле, используемое в типе содержимого &amp;laquo;message / external-body&amp;raquo;. В HTTP его СЛЕДУЕТ отправлять всякий раз, когда длина сообщения может быть определена до передачи, если это не запрещено правилами в &lt;a href=&quot;#section-4.4&quot;&gt;разделе 4.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5000316ac8e17d070fa4e93bb14ed2071d4d60f" translate="yes" xml:space="preserve">
          <source>The Content-Location entity-header field MAY be used to supply the
   resource location for the entity enclosed in the message when that
   entity is accessible from a location separate from the requested
   resource's URI. A server SHOULD provide a Content-Location for the
   variant corresponding to the response entity; especially in the case
   where a resource has multiple entities associated with it, and those
   entities actually have separate locations by which they might be
   individually accessed, the server SHOULD provide a Content-Location
   for the particular variant which is returned.

       Content-Location = &quot;Content-Location&quot; &quot;:&quot;
                         ( absoluteURI | relativeURI )

   The value of Content-Location also defines the base URI for the
   entity.

   The Content-Location value is not a replacement for the original
   requested URI; it is only a statement of the location of the resource
   corresponding to this particular entity at the time of the request.
   Future requests MAY specify the Content-Location URI as the request-
   URI if the desire is to identify the source of that particular
   entity.

   A cache cannot assume that an entity with a Content-Location
   different from the URI used to retrieve it can be used to respond to
   later requests on that Content-Location URI. However, the Content-
   Location can be used to differentiate between multiple entities
   retrieved from a single requested resource, as described in &lt;a href=&quot;#section-13.6&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;.

   If the Content-Location is a relative URI, the relative URI is
   interpreted relative to the Request-URI.

   The meaning of the Content-Location header in PUT or POST requests is
   undefined; servers are free to ignore it in those cases.</source>
          <target state="translated">Поле заголовка объекта Content-Location МОЖЕТ использоваться для предоставления местоположения ресурса для объекта, заключенного в сообщении, когда этот объект доступен из местоположения, отдельного от URI запрошенного ресурса. Серверу СЛЕДУЕТ предоставлять Content-Location для варианта, соответствующего объекту ответа; особенно в случае, когда с ресурсом связано несколько объектов, и эти объекты фактически имеют отдельные местоположения, по которым к ним можно получить индивидуальный доступ, серверу СЛЕДУЕТ предоставить Content-Location для конкретного варианта, который возвращается. Content-Location = &quot;Content-Location&quot; &quot;:&quot; (absoluteURI | relativeURI) Значение Content-Location также определяет базовый URI для объекта.Значение Content-Location не заменяет исходный запрошенный URI; это всего лишь указание на местонахождение ресурса, соответствующего данной конкретной сущности во время запроса. В будущих запросах МОЖЕТ указывать URI Content-Location в качестве URI запроса, если желательно идентифицировать источник этого конкретного объекта. Кэш не может предполагать, что объект с Content-Location, отличным от URI, используемого для его извлечения, может использоваться для ответа на последующие запросы по этому Content-Location URI. Однако Content-Location можно использовать для различения нескольких сущностей, полученных из одного запрошенного ресурса, как описано вэто всего лишь указание на местонахождение ресурса, соответствующего данной конкретной сущности во время запроса. В будущих запросах МОЖЕТ указывать URI Content-Location в качестве URI запроса, если желательно идентифицировать источник этого конкретного объекта. Кэш не может предполагать, что объект с Content-Location, отличным от URI, используемого для его извлечения, может использоваться для ответа на последующие запросы по этому Content-Location URI. Однако Content-Location можно использовать для различения нескольких сущностей, полученных из одного запрошенного ресурса, как описано вэто всего лишь указание на местонахождение ресурса, соответствующего данной конкретной сущности во время запроса. В будущих запросах МОЖЕТ указывать URI Content-Location в качестве URI запроса, если желательно идентифицировать источник этого конкретного объекта. Кэш не может предполагать, что объект с Content-Location, отличным от URI, используемого для его извлечения, может использоваться для ответа на последующие запросы по этому Content-Location URI. Однако Content-Location можно использовать для различения нескольких сущностей, полученных из одного запрошенного ресурса, как описано вКэш не может предполагать, что объект с Content-Location, отличным от URI, используемого для его извлечения, может использоваться для ответа на последующие запросы по этому Content-Location URI. Однако Content-Location можно использовать для различения нескольких сущностей, полученных из одного запрошенного ресурса, как описано вКэш не может предполагать, что объект с Content-Location, отличным от URI, используемого для его извлечения, может использоваться для ответа на последующие запросы по этому Content-Location URI. Однако Content-Location можно использовать для различения нескольких сущностей, полученных из одного запрошенного ресурса, как описано в&lt;a href=&quot;#section-13.6&quot;&gt;раздел &lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt; . Если Content-Location является относительным URI, относительный URI интерпретируется относительно Request-URI. Значение заголовка Content-Location в запросах PUT или POST не определено; серверы могут игнорировать это в таких случаях.</target>
        </trans-unit>
        <trans-unit id="6782e7664ef97f5aa5c3c489b023d738a78d068c" translate="yes" xml:space="preserve">
          <source>The Content-MD5 entity-header field, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [&lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt;], is
   an MD5 digest of the entity-body for the purpose of providing an
   end-to-end message integrity check (MIC) of the entity-body. (Note: a
   MIC is good for detecting accidental modification of the entity-body
   in transit, but is not proof against malicious attacks.)

        Content-MD5   = &quot;Content-MD5&quot; &quot;:&quot; md5-digest
        md5-digest   = &amp;lt;base64 of 128 bit MD5 digest as per &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;&amp;gt;

   The Content-MD5 header field MAY be generated by an origin server or
   client to function as an integrity check of the entity-body. Only
   origin servers or clients MAY generate the Content-MD5 header field;
   proxies and gateways MUST NOT generate it, as this would defeat its
   value as an end-to-end integrity check. Any recipient of the entity-
   body, including gateways and proxies, MAY check that the digest value
   in this header field matches that of the entity-body as received.

   The MD5 digest is computed based on the content of the entity-body,
   including any content-coding that has been applied, but not including
   any transfer-encoding applied to the message-body. If the message is
   received with a transfer-encoding, that encoding MUST be removed
   prior to checking the Content-MD5 value against the received entity.

   This has the result that the digest is computed on the octets of the
   entity-body exactly as, and in the order that, they would be sent if
   no transfer-encoding were being applied.

   HTTP extends &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; to permit the digest to be computed for MIME
   composite media-types (e.g., multipart/* and message/rfc822), but
   this does not change how the digest is computed as defined in the
   preceding paragraph.

   There are several consequences of this. The entity-body for composite
   types MAY contain many body-parts, each with its own MIME and HTTP
   headers (including Content-MD5, Content-Transfer-Encoding, and
   Content-Encoding headers). If a body-part has a Content-Transfer-
   Encoding or Content-Encoding header, it is assumed that the content
   of the body-part has had the encoding applied, and the body-part is
   included in the Content-MD5 digest as is -- i.e., after the
   application. The Transfer-Encoding header field is not allowed within
   body-parts.

   Conversion of all line breaks to CRLF MUST NOT be done before
   computing or checking the digest: the line break convention used in
   the text actually transmitted MUST be left unaltered when computing
   the digest. 

      Note: while the definition of Content-MD5 is exactly the same for
      HTTP as in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; for MIME entity-bodies, there are several ways
      in which the application of Content-MD5 to HTTP entity-bodies
      differs from its application to MIME entity-bodies. One is that
      HTTP, unlike MIME, does not use Content-Transfer-Encoding, and
      does use Transfer-Encoding and Content-Encoding. Another is that
      HTTP more frequently uses binary content types than MIME, so it is
      worth noting that, in such cases, the byte order used to compute
      the digest is the transmission byte order defined for the type.
      Lastly, HTTP allows transmission of text types with any of several
      line break conventions and not just the canonical form using CRLF.</source>
          <target state="translated">Поле заголовка объекта Content-MD5, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [ &lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt; ], является дайджестом MD5 тела объекта с целью обеспечения сквозной проверки целостности сообщения (MIC) тела объекта. (Примечание: MIC хорош для обнаружения случайной модификации тела объекта при передаче, но не защищает от злонамеренных атак.) Content-MD5 = &quot;Content-MD5&quot; &quot;:&quot; md5-digest md5-digest = &amp;lt;base64 of 128-битный дайджест MD5 согласно &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;&amp;gt; Поле заголовка Content-MD5 МОЖЕТ быть сгенерировано исходным сервером или клиентом для работы в качестве проверки целостности тела объекта. Только исходные серверы или клиенты МОГУТ генерировать поле заголовка Content-MD5; прокси-серверы и шлюзы НЕ ДОЛЖНЫ генерировать его, поскольку это нарушит его значение как сквозную проверку целостности. Любой получатель тела объекта, включая шлюзы и прокси, МОЖЕТ проверить, что значение дайджеста в этом поле заголовка совпадает с полученным телом объекта. Дайджест MD5 вычисляется на основе содержимого тела объекта, включая любое примененное кодирование содержимого, но не включая кодирование передачи, примененное к телу сообщения. Если сообщение получено с кодировкой передачи, это кодирование ДОЛЖНО быть удалено до проверки значения Content-MD5 на полученный объект.Это приводит к тому, что дайджест вычисляется по октетам тела объекта точно так же и в том порядке, в котором они будут отправлены, если бы не применялось кодирование передачи. HTTP расширяет&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;чтобы позволить вычислять дайджест для составных медиа-типов MIME (например, multipart / * и message / rfc822), но это не меняет способ вычисления дайджеста, как определено в предыдущем абзаце. У этого есть несколько последствий. Тело объекта для составных типов МОЖЕТ содержать множество частей тела, каждая со своими собственными заголовками MIME и HTTP (включая заголовки Content-MD5, Content-Transfer-Encoding и Content-Encoding). Если у части тела есть заголовок Content-Transfer-Encoding или Content-Encoding, предполагается, что к содержимому части тела была применена кодировка, и эта часть тела включена в дайджест Content-MD5 как есть - т.е. после заявки. Поле заголовка Transfer-Encoding не допускается внутри частей тела.Преобразование всех разрывов строк в CRLF НЕ ДОЛЖНО выполняться перед вычислением или проверкой дайджеста: соглашение о переносе строк, используемое в фактически переданном тексте, ДОЛЖНО быть оставлено неизменным при вычислении дайджеста. Примечание: хотя определение Content-MD5 для HTTP точно такое же, как в&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; для тел-сущностей MIME, существует несколько способов, которыми применение Content-MD5 к телам сущностей HTTP отличается от его применения к телам сущностей MIME. Во-первых, HTTP, в отличие от MIME, не использует Content-Transfer-Encoding, а использует Transfer-Encoding и Content-Encoding. Другой заключается в том, что HTTP чаще использует двоичные типы содержимого, чем MIME, поэтому стоит отметить, что в таких случаях порядок байтов, используемый для вычисления дайджеста, является порядком байтов передачи, определенным для типа. Наконец, HTTP позволяет передавать текстовые типы с любым из нескольких соглашений о переносе строки, а не только в канонической форме с использованием CRLF.</target>
        </trans-unit>
        <trans-unit id="ff07970e216340fa2fb8373a79c1c42c82bcf1ba" translate="yes" xml:space="preserve">
          <source>The Content-Range entity-header is sent with a partial entity-body to
   specify where in the full entity-body the partial body should be
   applied. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

       Content-Range = &quot;Content-Range&quot; &quot;:&quot; content-range-spec

       content-range-spec      = byte-content-range-spec
       byte-content-range-spec = bytes-unit SP
                                 byte-range-resp-spec &quot;/&quot;
                                 ( instance-length | &quot;*&quot; )

       byte-range-resp-spec = (first-byte-pos &quot;-&quot; last-byte-pos)
                                      | &quot;*&quot;
       instance-length           = 1*DIGIT

   The header SHOULD indicate the total length of the full entity-body,
   unless this length is unknown or difficult to determine. The asterisk
   &quot;*&quot; character means that the instance-length is unknown at the time
   when the response was generated.

   Unlike byte-ranges-specifier values (see &lt;a href=&quot;#section-14.35.1&quot;&gt;section 14.35.1&lt;/a&gt;), a byte-
   range-resp-spec MUST only specify one range, and MUST contain
   absolute byte positions for both the first and last byte of the
   range.

   A byte-content-range-spec with a byte-range-resp-spec whose last-
   byte-pos value is less than its first-byte-pos value, or whose
   instance-length value is less than or equal to its last-byte-pos
   value, is invalid. The recipient of an invalid byte-content-range-
   spec MUST ignore it and any content transferred along with it.

   A server sending a response with status code 416 (Requested range not
   satisfiable) SHOULD include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;. The instance-length specifies the current length of 

   the selected resource. A response with status code 206 (Partial
   Content) MUST NOT include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;.

   Examples of byte-content-range-spec values, assuming that the entity
   contains a total of 1234 bytes:

      . The first 500 bytes:
       bytes 0-499/1234

      . The second 500 bytes:
       bytes 500-999/1234

      . All except for the first 500 bytes:
       bytes 500-1233/1234

      . The last 500 bytes:
       bytes 734-1233/1234

   When an HTTP message includes the content of a single range (for
   example, a response to a request for a single range, or to a request
   for a set of ranges that overlap without any holes), this content is
   transmitted with a Content-Range header, and a Content-Length header
   showing the number of bytes actually transferred. For example,

       HTTP/1.1 206 Partial content
       Date: Wed, 15 Nov 1995 06:25:24 GMT
       Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
       Content-Range: bytes 21010-47021/47022
       Content-Length: 26012
       Content-Type: image/gif

   When an HTTP message includes the content of multiple ranges (for
   example, a response to a request for multiple non-overlapping
   ranges), these are transmitted as a multipart message. The multipart
   media type used for this purpose is &quot;multipart/byteranges&quot; as defined
   in appendix 19.2. See appendix 19.6.3 for a compatibility issue.

   A response to a request for a single range MUST NOT be sent using the
   multipart/byteranges media type.  A response to a request for
   multiple ranges, whose result is a single range, MAY be sent as a
   multipart/byteranges media type with one part. A client that cannot
   decode a multipart/byteranges message MUST NOT ask for multiple
   byte-ranges in a single request.

   When a client requests multiple byte-ranges in one request, the
   server SHOULD return them in the order that they appeared in the
   request. 

   If the server ignores a byte-range-spec because it is syntactically
   invalid, the server SHOULD treat the request as if the invalid Range
   header field did not exist. (Normally, this means return a 200
   response containing the full entity).

   If the server receives a request (other than one including an If-
   Range request-header field) with an unsatisfiable Range request-
   header field (that is, all of whose byte-range-spec values have a
   first-byte-pos value greater than the current length of the selected
   resource), it SHOULD return a response code of 416 (Requested range
   not satisfiable) (&lt;a href=&quot;#section-10.4.17&quot;&gt;section 10.4.17&lt;/a&gt;).

      Note: clients cannot depend on servers to send a 416 (Requested
      range not satisfiable) response instead of a 200 (OK) response for
      an unsatisfiable Range request-header, since not all servers
      implement this request-header.</source>
          <target state="translated">Заголовок объекта Content-Range отправляется с частичным телом объекта, чтобы указать, где в полном теле объекта следует применить частичное тело. Единицы измерения определены в &lt;a href=&quot;#section-3.12&quot;&gt;разделе 3.12.&lt;/a&gt;, Content-Range = &quot;Content-Range&quot; &quot;:&quot; content-range-spec content-range-spec = byte-content-range-spec byte-content-range-spec = bytes-unit SP byte-range-resp-spec &quot; / &quot;(длина экземпляра |&quot; * &quot;) byte-range-resp-spec = (first-byte-pos&quot; - &quot;last-byte-pos) | &amp;laquo;*&amp;raquo; instance-length = 1 * DIGIT. Заголовок ДОЛЖЕН указывать общую длину всего тела объекта, если только эта длина неизвестна или ее трудно определить. Символ звездочки &amp;laquo;*&amp;raquo; означает, что длина экземпляра неизвестна на момент генерации ответа. В отличие от значений спецификатора диапазонов байтов (см. &lt;a href=&quot;#section-14.35.1&quot;&gt;Раздел 14.35.1&lt;/a&gt;), byte-range-resp-spec ДОЛЖЕН указывать только один диапазон и ДОЛЖЕН содержать абсолютные позиции байтов как для первого, так и для последнего байта диапазона. Byte-content-range-spec с byte-range-resp-spec, значение last-byte-pos меньше, чем его значение first-byte-pos, или чье значение длины экземпляра меньше или равно его last- значение byte-pos недействительно. Получатель недопустимой спецификации byte-content-range- ДОЛЖЕН игнорировать ее и любой контент, передаваемый вместе с ней. Серверу, отправляющему ответ с кодом состояния 416 (запрошенный диапазон не удовлетворяется), СЛЕДУЕТ включать поле Content-Range со спецификацией байтового диапазона или &quot;*&quot;. Длина экземпляра указывает текущую длину выбранного ресурса.Ответ с кодом состояния 206 (частичное содержимое) НЕ ДОЛЖЕН включать поле Content-Range с байтовым диапазоном или спецификацией &quot;*&quot;. Примеры значений byte-content-range-spec при условии, что объект содержит всего 1234 байта:. Первые 500 байт: байты 0-499 / 1234. Вторые 500 байт: байты 500-999 / 1234. Все, кроме первых 500 байтов: байты 500&amp;ndash;1233 / 1234. Последние 500 байтов: байты 734-1233 / 1234 Когда сообщение HTTP включает в себя содержимое одного диапазона (например, ответ на запрос для одного диапазона или на запрос набора диапазонов, которые перекрываются без каких-либо дыр) ), это содержимое передается с заголовком Content-Range и заголовком Content-Length, показывающим количество фактически переданных байтов. Например, HTTP / 1.1206 Частичное содержимое Дата: среда, 15 ноября 1995 г., 06:25:24 GMT Последнее изменение: среда, 15 ноября 1995 г., 04:58:08 GMT Content-Range: байты 21010-47021 / 47022 Content-Length: 26012 Content-Type : image / gif Когда HTTP-сообщение включает в себя содержимое нескольких диапазонов (например, ответ на запрос нескольких неперекрывающихся диапазонов), они передаются как составное сообщение. Тип мультимедиа multipart, используемый для этой цели, - multipart / byteranges, как определено в приложении 19.2. См. Приложение 19.6.3 по вопросу совместимости. Ответ на запрос для одного диапазона НЕ ДОЛЖЕН отправляться с использованием типа носителя multipart / byteranges. Ответ на запрос для нескольких диапазонов, результатом которого является один диапазон, МОЖЕТ быть отправлен как тип мультимедиа multipart / byteranges с одной частью.Клиент, который не может декодировать сообщение multipart / byteranges, НЕ ДОЛЖЕН запрашивать несколько диапазонов байтов в одном запросе. Когда клиент запрашивает несколько диапазонов байтов в одном запросе, серверу СЛЕДУЕТ возвращать их в том порядке, в котором они указаны в запросе. Если сервер игнорирует спецификацию байтового диапазона, потому что она синтаксически недопустима, сервер ДОЛЖЕН обрабатывать запрос так, как если бы недопустимое поле заголовка диапазона не существовало. (Обычно это означает возврат 200 ответа, содержащего полную сущность). Если сервер получает запрос (кроме того, который включает поле заголовка запроса If-Range) с неудовлетворительным полем заголовка запроса Range (то есть, все значения которого byte-range-spec имеют значение first-byte-pos больше чем текущая длина выбранного ресурса),он ДОЛЖЕН возвращать код ответа 416 (Запрошенный диапазон неудовлетворителен) (&lt;a href=&quot;#section-10.4.17&quot;&gt;раздел 10.4.17&lt;/a&gt; ). Примечание: клиенты не могут зависеть от серверов для отправки ответа 416 (Запрошенный диапазон не удовлетворяется) вместо ответа 200 (ОК) для неудовлетворительного заголовка запроса Range, поскольку не все серверы реализуют этот заголовок запроса.</target>
        </trans-unit>
        <trans-unit id="e283ef83ad0c98c2f0776bde603c318284d66f81" translate="yes" xml:space="preserve">
          <source>The Content-Type entity-header field indicates the media type of the
   entity-body sent to the recipient or, in the case of the HEAD method,
   the media type that would have been sent had the request been a GET.

       Content-Type   = &quot;Content-Type&quot; &quot;:&quot; media-type

   Media types are defined in &lt;a href=&quot;#section-3.7&quot;&gt;section 3.7&lt;/a&gt;. An example of the field is

       Content-Type: text/html; charset=ISO-8859-4

   Further discussion of methods for identifying the media type of an
   entity is provided in &lt;a href=&quot;#section-7.2.1&quot;&gt;section 7.2.1&lt;/a&gt;.</source>
          <target state="translated">Поле заголовка объекта Content-Type указывает тип носителя тела объекта, отправленного получателю, или, в случае метода HEAD, тип носителя, который был бы отправлен, если бы запрос был GET. Content-Type = &quot;Content-Type&quot; &quot;:&quot; media-type Типы мультимедиа определены в &lt;a href=&quot;#section-3.7&quot;&gt;разделе 3.7&lt;/a&gt; . Пример поля - Content-Type: text / html; charset = ISO-8859-4. Дальнейшее обсуждение методов идентификации типа носителя объекта приведено в &lt;a href=&quot;#section-7.2.1&quot;&gt;разделе 7.2.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d09adc4e47017807bd60018491b4e8efd7bba713" translate="yes" xml:space="preserve">
          <source>The Cookie header field [&lt;a href=&quot;#ref-COOKIE&quot;&gt;COOKIE&lt;/a&gt;] uses a semi-colon (&quot;;&quot;) to delimit
   cookie-pairs (or &quot;crumbs&quot;).  This header field doesn't follow the
   list construction rules in HTTP (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.2&lt;/a&gt;), which
   prevents cookie-pairs from being separated into different name-value
   pairs.  This can significantly reduce compression efficiency as
   individual cookie-pairs are updated.

   To allow for better compression efficiency, the Cookie header field
   MAY be split into separate header fields, each with one or more
   cookie-pairs.  If there are multiple Cookie header fields after
   decompression, these MUST be concatenated into a single octet string
   using the two-octet delimiter of 0x3B, 0x20 (the ASCII string &quot;; &quot;)
   before being passed into a non-HTTP/2 context, such as an HTTP/1.1
   connection, or a generic HTTP server application.

   Therefore, the following two lists of Cookie header fields are
   semantically equivalent.

     cookie: a=b; c=d; e=f

     cookie: a=b
     cookie: c=d
     cookie: e=f</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037f56850e2d9507141cb0bfad334028f9b60f2f" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing standard works by adding new &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; that allow servers to describe the set of origins that are permitted to read that information using a web browser. Additionally, for HTTP request methods that can cause side-effects on server's data (in particular, for HTTP methods other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or for &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; usage with certain &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &quot;preflight&quot; the request, soliciting supported methods from the server with an HTTP &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &quot;approval&quot; from the server, sending the actual request with the actual HTTP request method. Servers can also notify clients whether &quot;credentials&quot; (including &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and HTTP Authentication data) should be sent with requests.</source>
          <target state="translated">Стандарт совместного использования ресурсов между источниками работает путем добавления новых &lt;a href=&quot;headers&quot;&gt;заголовков HTTP,&lt;/a&gt; которые позволяют серверам описывать набор источников, которым разрешено читать эту информацию с помощью веб-браузера. Кроме того, для методов HTTP-запроса, которые могут вызывать побочные эффекты для данных сервера (в частности, для HTTP-методов, отличных от &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , или для использования &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; с определенными &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;типами MIME&lt;/a&gt; ), спецификация требует, чтобы браузеры выполняли предварительную проверку запроса, запрашивая поддерживаемые методы. с сервера с помощью метода запроса HTTP &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; , а затем, после &amp;laquo;утверждения&amp;raquo; с сервера, отправка фактического запроса с фактическим методом запроса HTTP. Серверы также могут уведомлять клиентов о наличии &amp;laquo;учетных данных&amp;raquo;(включая &lt;a href=&quot;cookies&quot;&gt;файлы cookie&lt;/a&gt;и данные HTTP-аутентификации) должны отправляться с запросами.</target>
        </trans-unit>
        <trans-unit id="a3df3b7b4551cce965a08ca5b788db7477ac35eb" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing standard works by adding new &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; that let servers describe which origins are permitted to read that information from a web browser. Additionally, for HTTP request methods that can cause side-effects on server data (in particular, HTTP methods other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; with certain &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &quot;preflight&quot; the request, soliciting supported methods from the server with the HTTP &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &quot;approval&quot; from the server, sending the actual request. Servers can also inform clients whether &quot;credentials&quot; (such as &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and &lt;a href=&quot;authentication&quot;&gt;HTTP Authentication&lt;/a&gt;) should be sent with requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858dfd56015c8a42c014f2e88a9adef69bbf8f6d" translate="yes" xml:space="preserve">
          <source>The DELETE method on a collection MUST act as if a &quot;Depth: infinity&quot;
   header was used on it.  A client MUST NOT submit a Depth header with
   a DELETE on a collection with any value but infinity.

   DELETE instructs that the collection specified in the Request-URI and
   all resources identified by its internal member URLs are to be
   deleted.

   If any resource identified by a member URL cannot be deleted, then
   all of the member's ancestors MUST NOT be deleted, so as to maintain
   URL namespace consistency.

   Any headers included with DELETE MUST be applied in processing every
   resource to be deleted.

   When the DELETE method has completed processing, it MUST result in a
   consistent URL namespace.

   If an error occurs deleting a member resource (a resource other than
   the resource identified in the Request-URI), then the response can be
   a 207 (Multi-Status).  Multi-Status is used here to indicate which
   internal resources could NOT be deleted, including an error code,
   which should help the client understand which resources caused the
   failure.  For example, the Multi-Status body could include a response
   with status 423 (Locked) if an internal resource was locked.

   The server MAY return a 4xx status response, rather than a 207, if
   the request failed completely.

   424 (Failed Dependency) status codes SHOULD NOT be in the 207 (Multi-
   Status) response for DELETE.  They can be safely left out because the
   client will know that the ancestors of a resource could not be
   deleted when the client receives an error for the ancestor's progeny.
   Additionally, 204 (No Content) errors SHOULD NOT be returned in the
   207 (Multi-Status).  The reason for this prohibition is that 204 (No
   Content) is the default success code.</source>
          <target state="translated">Метод DELETE на коллекции ДОЛЖЕН действовать так,как будто на ней был использован заголовок &quot;Глубина:бесконечность&quot;.Клиент НЕ ДОЛЖЕН подавать заголовок Depth с DELETE на коллекции с любым значением,но бесконечностью.DELETE инструктирует,что коллекция,указанная в Request-URI,и все ресурсы,идентифицированные по URL ее внутренних членов,должны быть удалены.Если какой-либо ресурс,идентифицируемый по URL-адресу пользователя,не может быть удален,то все предки пользователя НЕ ДОЛЖНЫ быть удалены,чтобы сохранить согласованность пространства имен URL-адресов.Любые заголовки,включенные в DELETE ДОЛЖНЫ применяться при обработке каждого удаляемого ресурса.Когда метод DELETE завершает обработку,он ДОЛЖЕН приводить к согласованному пространству имён URL.Если возникает ошибка удаления члена ресурса (ресурса,отличного от ресурса,указанного в Request-URI),то ответом может быть 207 (Multi-Status).Здесь Multi-Status используется для указания,какие внутренние ресурсы НЕ могут быть удалены,включая код ошибки,который должен помочь клиенту понять,какие ресурсы вызвали сбой.Например,тело Multi-Status может содержать ответ со статусом 423 (Locked),если внутренний ресурс заблокирован.Сервер MAY возвращает ответ со статусом 4xx,а не 207,если запрос был полностью отклонен.Коды статуса 424 (Failed Dependency)НЕ ДОЛЖНЫ быть в ответе 207 (Multi-Status)для УДАЛЕНИЯ.Они могут быть безопасно пропущены,потому что клиент будет знать,что предки ресурса не могли быть удалены,когда клиент получит ошибку для потомка предка.Кроме того,204 ошибки (No Content)НЕ ДОЛЖНЫ возвращаться в 207 (Multi-Status).Причина такого запрета заключается в том,что 204 (No Content)является кодом успеха по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e71c2610a983fa8562e2bcbd279e311806bf6084" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server delete the resource
   identified by the Request-URI. This method MAY be overridden by human
   intervention (or other means) on the origin server. The client cannot
   be guaranteed that the operation has been carried out, even if the
   status code returned from the origin server indicates that the action
   has been completed successfully. However, the server SHOULD NOT
   indicate success unless, at the time the response is given, it
   intends to delete the resource or move it to an inaccessible
   location.

   A successful response SHOULD be 200 (OK) if the response includes an
   entity describing the status, 202 (Accepted) if the action has not
   yet been enacted, or 204 (No Content) if the action has been enacted
   but the response does not include an entity.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.</source>
          <target state="translated">Метод DELETE требует,чтобы исходный сервер удалил ресурс,идентифицируемый Request-URI.Этот метод МОЖЕТ быть переопределен человеческим вмешательством (или другими способами)на исходном сервере.Клиент не может быть уверен в том,что операция была выполнена,даже если код статуса,возвращенный с исходного сервера,указывает на то,что операция была выполнена успешно.Однако,сервер НЕ ДОЛЖЕН указывать на успешное выполнение операции,если только в момент получения ответа он не намеревается удалить ресурс или переместить его в недоступное место.Успешный ответ ДОЛЖЕН быть 200 (OK),если ответ включает сущность,описывающую статус,202 (Принято),если действие еще не было предпринято,или 204 (Без содержания),если действие было предпринято,но ответ не включает сущность.Если запрос проходит через кэш и Request-URI идентифицирует одну или более сущностей,занесенных в кэш в данный момент,то эти записи ДОЛЖНЫ быть обработаны как черствые.Ответы на этот метод не кэшируются.</target>
        </trans-unit>
        <trans-unit id="c974be9fc532fcdd84db91fdeb0ba6b9b0cfa15b" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server remove the
   association between the target resource and its current
   functionality.  In effect, this method is similar to the rm command
   in UNIX: it expresses a deletion operation on the URI mapping of the
   origin server rather than an expectation that the previously
   associated information be deleted.

   If the target resource has one or more current representations, they
   might or might not be destroyed by the origin server, and the
   associated storage might or might not be reclaimed, depending
   entirely on the nature of the resource and its implementation by the
   origin server (which are beyond the scope of this specification).
   Likewise, other implementation aspects of a resource might need to be
   deactivated or archived as a result of a DELETE, such as database or
   gateway connections.  In general, it is assumed that the origin
   server will only allow DELETE on resources for which it has a
   prescribed mechanism for accomplishing the deletion.

   Relatively few resources allow the DELETE method -- its primary use
   is for remote authoring environments, where the user has some
   direction regarding its effect.  For example, a resource that was
   previously created using a PUT request, or identified via the
   Location header field after a 201 (Created) response to a POST
   request, might allow a corresponding DELETE request to undo those
   actions.  Similarly, custom user agent implementations that implement 

   an authoring function, such as revision control clients using HTTP
   for remote operations, might use DELETE based on an assumption that
   the server's URI space has been crafted to correspond to a version
   repository.

   If a DELETE method is successfully applied, the origin server SHOULD
   send a 202 (Accepted) status code if the action will likely succeed
   but has not yet been enacted, a 204 (No Content) status code if the
   action has been enacted and no further information is to be supplied,
   or a 200 (OK) status code if the action has been enacted and the
   response message includes a representation describing the status.

   A payload within a DELETE request message has no defined semantics;
   sending a payload body on a DELETE request might cause some existing
   implementations to reject the request.

   Responses to the DELETE method are not cacheable.  If a DELETE
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Метод DELETE запрашивает у исходного сервера удаление связи между целевым ресурсом и его текущими функциями. По сути, этот метод похож на команду rm в UNIX: он выражает операцию удаления в сопоставлении URI исходного сервера, а не ожидание удаления ранее связанной информации. Если целевой ресурс имеет одно или несколько текущих представлений, они могут быть или не быть уничтожены исходным сервером, а связанное хранилище может быть или не может быть восстановлено, полностью в зависимости от природы ресурса и его реализации исходным сервером ( которые выходят за рамки данной спецификации). Аналогичным образом, другие аспекты реализации ресурса могут потребоваться деактивировать или заархивировать в результате DELETE,например, соединения с базой данных или шлюзами. В общем, предполагается, что исходный сервер разрешит УДАЛЕНИЕ только для ресурсов, для которых у него есть предписанный механизм для выполнения удаления. Относительно небольшое количество ресурсов позволяет использовать метод DELETE - его основное использование - для сред удаленной разработки, где у пользователя есть определенные указания относительно его эффекта. Например, ресурс, который был ранее создан с помощью запроса PUT или идентифицирован с помощью поля заголовка Location после ответа 201 (Created) на запрос POST, может позволить соответствующему запросу DELETE отменить эти действия. Точно так же реализации настраиваемых пользовательских агентов, которые реализуют функцию создания, например клиенты управления версиями, использующие HTTP для удаленных операций, могут использовать DELETE на основе предположения, что сервер '■ Пространство URI создано для соответствия репозиторию версий. Если метод DELETE успешно применен, исходный сервер ДОЛЖЕН отправить код состояния 202 (Принято), если действие, скорее всего, будет успешным, но еще не выполнено, код состояния 204 (Нет содержимого), если действие было выполнено, и больше не будет должна быть предоставлена ​​информация или код состояния 200 (ОК), если действие было выполнено и ответное сообщение включает представление, описывающее состояние. Полезная нагрузка в сообщении запроса DELETE не имеет определенной семантики; отправка тела полезной нагрузки в запросе DELETE может привести к тому, что некоторые существующие реализации отклонят запрос. Ответы на метод DELETE не кэшируются. Если запрос DELETE проходит через кеш, в котором есть один или несколько сохраненных ответов для действующего URI запроса,эти сохраненные ответы будут признаны недействительными (см.&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Раздел 4.4 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dd290a0d44bd1aedc43b87181e19c3e8fd871af9" translate="yes" xml:space="preserve">
          <source>The Date general-header field represents the date and time at which
   the message was originated, having the same semantics as orig-date in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;. The field value is an HTTP-date, as described in &lt;a href=&quot;#section-3.3.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;; it MUST be sent in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]-date format.

       Date  = &quot;Date&quot; &quot;:&quot; HTTP-date

   An example is

       Date: Tue, 15 Nov 1994 08:12:31 GMT

   Origin servers MUST include a Date header field in all responses,
   except in these cases: 

      1. If the response status code is 100 (Continue) or 101 (Switching
         Protocols), the response MAY include a Date header field, at
         the server's option.

      2. If the response status code conveys a server error, e.g. 500
         (Internal Server Error) or 503 (Service Unavailable), and it is
         inconvenient or impossible to generate a valid Date.

      3. If the server does not have a clock that can provide a
         reasonable approximation of the current time, its responses
         MUST NOT include a Date header field. In this case, the rules
         in &lt;a href=&quot;#section-14.18.1&quot;&gt;section 14.18.1&lt;/a&gt; MUST be followed.

   A received message that does not have a Date header field MUST be
   assigned one by the recipient if the message will be cached by that
   recipient or gatewayed via a protocol which requires a Date. An HTTP
   implementation without a clock MUST NOT cache responses without
   revalidating them on every use. An HTTP cache, especially a shared
   cache, SHOULD use a mechanism, such as NTP [&lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;], to synchronize its
   clock with a reliable external standard.

   Clients SHOULD only send a Date header field in messages that include
   an entity-body, as in the case of the PUT and POST requests, and even
   then it is optional. A client without a clock MUST NOT send a Date
   header field in a request.

   The HTTP-date sent in a Date header SHOULD NOT represent a date and
   time subsequent to the generation of the message. It SHOULD represent
   the best available approximation of the date and time of message
   generation, unless the implementation has no means of generating a
   reasonably accurate date and time. In theory, the date ought to
   represent the moment just before the entity is generated. In
   practice, the date can be generated at any time during the message
   origination without affecting its semantic value.</source>
          <target state="translated">Поле общего заголовка Date представляет дату и время, когда было отправлено сообщение, и имеет ту же семантику, что и исходная дата в &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; . Значение поля - это HTTP-дата, как описано в &lt;a href=&quot;#section-3.3.1&quot;&gt;разделе &lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt; ; он ДОЛЖЕН быть отправлен в &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]-Формат даты. Date = &quot;Date&quot; &quot;:&quot; HTTP-date Пример: Date: Tue, 15 Nov 1994 08:12:31 GMT Серверы происхождения ДОЛЖНЫ включать поле заголовка Date во все ответы, за исключением следующих случаев: 1. Если статус ответа код - 100 (продолжить) или 101 (протоколы переключения), ответ МОЖЕТ включать поле заголовка даты по выбору сервера. 2. Если код состояния ответа передает ошибку сервера, например 500 (внутренняя ошибка сервера) или 503 (служба недоступна), и создать действительную дату неудобно или невозможно. 3. Если на сервере нет часов, которые могут обеспечить разумное приближение текущего времени, его ответы НЕ ДОЛЖНЫ включать поле заголовка Date. В таком случае,правила в &lt;a href=&quot;#section-14.18.1&quot;&gt;разделе 14.18.1&lt;/a&gt;НЕОБХОДИМО соблюдать. Полученное сообщение, которое не имеет поля заголовка Date, ДОЛЖНО быть назначено получателем, если сообщение будет кэшировано этим получателем или шлюзом через протокол, который требует Date. Реализация HTTP без часов НЕ ДОЛЖНА кэшировать ответы без их повторной проверки при каждом использовании. Кэш HTTP, особенно общий кеш, ДОЛЖЕН использовать такой механизм, как NTP [ &lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;], чтобы синхронизировать часы с надежным внешним стандартом. Клиенты ДОЛЖНЫ отправлять поле заголовка Date только в сообщениях, которые включают тело объекта, как в случае запросов PUT и POST, и даже в этом случае это необязательно. Клиент без часов НЕ ДОЛЖЕН отправлять поле заголовка Date в запросе. HTTP-дата, отправленная в заголовке Date, НЕ ДОЛЖНА представлять дату и время после генерации сообщения. Он ДОЛЖЕН представлять наилучшее возможное приближение даты и времени генерации сообщения, если только реализация не имеет средств для генерации достаточно точной даты и времени. Теоретически дата должна представлять момент непосредственно перед созданием объекта. На практике дата может быть сгенерирована в любой момент во время создания сообщения, не влияя на ее семантическое значение.</target>
        </trans-unit>
        <trans-unit id="6903ec22652fb8e7c29947078193d2ba673e0d45" translate="yes" xml:space="preserve">
          <source>The Depth header may be used with the LOCK method.  Values other than
   0 or infinity MUST NOT be used with the Depth header on a LOCK
   method.  All resources that support the LOCK method MUST support the
   Depth header.

   A Depth header of value 0 means to just lock the resource specified
   by the Request-URI.

   If the Depth header is set to infinity, then the resource specified
   in the Request-URI along with all its members, all the way down the
   hierarchy, are to be locked.  A successful result MUST return a
   single lock token.  Similarly, if an UNLOCK is successfully executed
   on this token, all associated resources are unlocked.  Hence, partial
   success is not an option for LOCK or UNLOCK.  Either the entire
   hierarchy is locked or no resources are locked.

   If the lock cannot be granted to all resources, the server MUST
   return a Multi-Status response with a 'response' element for at least
   one resource that prevented the lock from being granted, along with a
   suitable status code for that failure (e.g., 403 (Forbidden) or 423
   (Locked)).  Additionally, if the resource causing the failure was not
   the resource requested, then the server SHOULD include a 'response'
   element for the Request-URI as well, with a 'status' element
   containing 424 Failed Dependency.

   If no Depth header is submitted on a LOCK request, then the request
   MUST act as if a &quot;Depth:infinity&quot; had been submitted.</source>
          <target state="translated">Заголовок Глубина может быть использован с методом БЛОКИРОВКИ.Значения,отличные от 0 или бесконечности,НЕ ДОЛЖНЫ использоваться с заголовком Depth в методе LOCK.Все ресурсы,поддерживающие метод БЛОКИРОВКИ,ДОЛЖНЫ поддерживать заголовок Depth.Заголовок Depth,имеющий значение 0,означает просто заблокировать ресурс,указанный в Request-URI.Если заголовок Depth установлен на бесконечность,то ресурс,указанный в Request-URI вместе со всеми его членами,вплоть до иерархии,должен быть заблокирован.Успешный результат ДОЛЖЕН возвращать один маркер блокировки.Аналогично,в случае успешного выполнения UNLOCK на этой маркере,все связанные с ней ресурсы будут разблокированы.Следовательно,частичный успех не является вариантом для БЛОКИРОВКИ или UNLOCK.Либо блокируется вся иерархия,либо не блокируются никакие ресурсы.Если блокировка не может быть предоставлена всем ресурсам,сервер ДОЛЖЕН вернуть Multi-Status ответ с элементом 'response' по крайней мере для одного ресурса,который не смог предоставить блокировку,вместе с подходящим кодом статуса для этого отказа (например,403 (Запрещенный)или 423 (Заблокированный)).Дополнительно,если ресурс,вызвавший сбой,не был запрошенным ресурсом,то сервер ДОЛЖЕН включить элемент 'response' для Request-URI,с элементом 'status',содержащим 424 Failed Dependency (Неудачная зависимость).Если на запрос БЛОКИРОВКИ не отправлен заголовок Depth,то запрос ДОЛЖЕН действовать так,как если бы был отправлен элемент &quot;Depth:бесконечность&quot;.</target>
        </trans-unit>
        <trans-unit id="35342d84dcd43dba8096f5d5b39874e99cb4604b" translate="yes" xml:space="preserve">
          <source>The Destination request header specifies the URI that identifies a
   destination resource for methods such as COPY and MOVE, which take
   two URIs as parameters.

      Destination = &quot;Destination&quot; &quot;:&quot; Simple-ref


   If the Destination value is an absolute-URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;Section&amp;nbsp;4.3 of
   [RFC3986]&lt;/a&gt;), it may name a different server (or different port or
   scheme).  If the source server cannot attempt a copy to the remote
   server, it MUST fail the request.  Note that copying and moving
   resources to remote servers is not fully defined in this
   specification (e.g., specific error conditions). 

   If the Destination value is too long or otherwise unacceptable, the
   server SHOULD return 400 (Bad Request), ideally with helpful
   information in an error body.</source>
          <target state="translated">Заголовок запроса Destination определяет URI, который идентифицирует ресурс назначения для таких методов, как COPY и MOVE, которые принимают два URI в качестве параметров. Destination = &quot;Destination&quot; &quot;:&quot; Simple-ref. Если значение Destination является абсолютным URI ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;раздел 4.3 [RFC3986]&lt;/a&gt; ), оно может называть другой сервер (или другой порт или схему). Если исходный сервер не может попытаться скопировать на удаленный сервер, он ДОЛЖЕН не выполнить запрос. Обратите внимание, что копирование и перемещение ресурсов на удаленные серверы не полностью определены в этой спецификации (например, конкретные условия ошибки). Если значение Destination слишком длинное или неприемлемо по иным причинам, сервер ДОЛЖЕН вернуть 400 (неверный запрос), в идеале с полезной информацией в теле ошибки.</target>
        </trans-unit>
        <trans-unit id="5ec562967c3ab4eb672c7b7fd0765b0c9a09d6b8" translate="yes" xml:space="preserve">
          <source>The ETag response-header field provides the current value of the
   entity tag for the requested variant. The headers used with entity
   tags are described in sections &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;. The entity tag
   MAY be used for comparison with other entities from the same resource
   (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;).

      ETag = &quot;ETag&quot; &quot;:&quot; entity-tag

   Examples:

      ETag: &quot;xyzzy&quot;
      ETag: W/&quot;xyzzy&quot;
      ETag: &quot;&quot;</source>
          <target state="translated">Поле заголовка ответа ETag содержит текущее значение тега объекта для запрошенного варианта. Заголовки, используемые с тегами объектов, описаны в разделах &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; , &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; и &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt; . Тег объекта МОЖЕТ использоваться для сравнения с другими объектами из того же ресурса (см. &lt;a href=&quot;#section-13.3.3&quot;&gt;Раздел 13.3.3&lt;/a&gt; ). ETag = &quot;ETag&quot; &quot;:&quot; entity-tag Примеры: ETag: &quot;xyzzy&quot; ETag: W / &quot;xyzzy&quot; ETag: &quot;&quot;</target>
        </trans-unit>
        <trans-unit id="4712a2d0dd6a27be4029656072d6f063c6808073" translate="yes" xml:space="preserve">
          <source>The ETag response-header field value, an entity tag, provides for an
   &quot;opaque&quot; cache validator. This might allow more reliable validation
   in situations where it is inconvenient to store modification dates,
   where the one-second resolution of HTTP date values is not
   sufficient, or where the origin server wishes to avoid certain
   paradoxes that might arise from the use of modification dates.

   Entity Tags are described in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The headers used with
   entity tags are described in sections &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;, &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;.</source>
          <target state="translated">Значение поля заголовка ответа ETag, тег объекта, обеспечивает &amp;laquo;непрозрачный&amp;raquo; валидатор кеша. Это может обеспечить более надежную проверку в ситуациях, когда неудобно хранить даты модификации, когда односекундное разрешение значений даты HTTP недостаточно или когда исходный сервер желает избежать определенных парадоксов, которые могут возникнуть из-за использования дат изменения. , Теги сущностей описаны в &lt;a href=&quot;#section-3.11&quot;&gt;разделе 3.11&lt;/a&gt; . Заголовки, используемые с тегами &lt;a href=&quot;#section-14.19&quot;&gt;объектов&lt;/a&gt; , описаны в разделах 14.19 , &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; , &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; и &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e574d1947b2d7656ccf38b993e2056ebdd1b0a0" translate="yes" xml:space="preserve">
          <source>The Expect request-header field is used to indicate that particular
   server behaviors are required by the client.

      Expect       =  &quot;Expect&quot; &quot;:&quot; 1#expectation

      expectation  =  &quot;100-continue&quot; | expectation-extension
      expectation-extension =  token [ &quot;=&quot; ( token | quoted-string )
                               *expect-params ]
      expect-params =  &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]


   A server that does not understand or is unable to comply with any of
   the expectation values in the Expect field of a request MUST respond
   with appropriate error status. The server MUST respond with a 417
   (Expectation Failed) status if any of the expectations cannot be met
   or, if there are other problems with the request, some other 4xx
   status.

   This header field is defined with extensible syntax to allow for
   future extensions. If a server receives a request containing an
   Expect field that includes an expectation-extension that it does not
   support, it MUST respond with a 417 (Expectation Failed) status.

   Comparison of expectation values is case-insensitive for unquoted
   tokens (including the 100-continue token), and is case-sensitive for
   quoted-string expectation-extensions. 

   The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST
   return a 417 (Expectation Failed) status if it receives a request
   with an expectation that it cannot meet. However, the Expect
   request-header itself is end-to-end; it MUST be forwarded if the
   request is forwarded.

   Many older HTTP/1.0 and HTTP/1.1 applications do not understand the
   Expect header.

   See &lt;a href=&quot;#section-8.2.3&quot;&gt;section 8.2.3&lt;/a&gt; for the use of the 100 (continue) status.</source>
          <target state="translated">Поле заголовка запроса Expect используется для указания того, что конкретное поведение сервера требуется клиенту. Expect = &quot;Expect&quot; &quot;:&quot; 1 # ожидание expectation = &quot;100-continue&quot; | расширение-ожидание расширение-ожидание = токен [&quot;=&quot; (токен | строка-кавычки) * параметры-ожидания] ожидаемые параметры = &quot;;&quot; token [&quot;=&quot; (токен | строка в кавычках)] Сервер, который не понимает или не может выполнить какое-либо из ожидаемых значений в поле Expect запроса, ДОЛЖЕН ответить соответствующим статусом ошибки. Сервер ДОЛЖЕН ответить статусом 417 (Ожидание не выполнено), если какое-либо из ожиданий не может быть выполнено, или, если есть другие проблемы с запросом, каким-либо другим статусом 4xx.Это поле заголовка определено с расширяемым синтаксисом, что позволяет использовать его в будущем. Если сервер получает запрос, содержащий поле Expect, которое включает расширение ожидания, которое он не поддерживает, он ДОЛЖЕН ответить статусом 417 (Expectation Failed). При сравнении ожидаемых значений регистр не учитывается для токенов без кавычек (включая токен с продолжением 100) и учитывается регистр для расширений ожидания в кавычках. Механизм ожидания является поэтапным: то есть прокси-сервер HTTP / 1.1 ДОЛЖЕН возвращать статус 417 (ожидание не выполнено), если он получает запрос с ожиданием, которое он не может удовлетворить. Однако сам заголовок запроса Expect является сквозным; он ДОЛЖЕН быть переадресован, если запрос пересылается. Многие старые приложения HTTP / 1.0 и HTTP / 1.1 не понимают заголовок Expect. ВидетьВидетьВидетьВидетьВидетьВидетьВидетьЕсли сервер получает запрос, содержащий поле Expect, которое включает расширение ожидания, которое он не поддерживает, он ДОЛЖЕН ответить статусом 417 (Expectation Failed). При сравнении ожидаемых значений регистр не учитывается для токенов без кавычек (включая токен с продолжением 100) и учитывается регистр для расширений ожидания в кавычках. Механизм ожидания является поэтапным: то есть прокси-сервер HTTP / 1.1 ДОЛЖЕН возвращать статус 417 (ожидание не выполнено), если он получает запрос с ожиданием, которое он не может удовлетворить. Однако сам заголовок запроса Expect является сквозным; он ДОЛЖЕН быть переадресован, если запрос пересылается. Многие старые приложения HTTP / 1.0 и HTTP / 1.1 не понимают заголовок Expect. ВидетьЕсли сервер получает запрос, содержащий поле Expect, которое включает расширение ожидания, которое он не поддерживает, он ДОЛЖЕН ответить статусом 417 (Expectation Failed). При сравнении ожидаемых значений регистр не учитывается для токенов без кавычек (включая токен с продолжением 100) и учитывается регистр для расширений ожидания в кавычках. Механизм ожидания является поэтапным: то есть прокси-сервер HTTP / 1.1 ДОЛЖЕН возвращать статус 417 (ожидание не выполнено), если он получает запрос с ожиданием, которое он не может удовлетворить. Однако сам заголовок запроса Expect является сквозным; он ДОЛЖЕН быть переадресован, если запрос пересылается. Многие старые приложения HTTP / 1.0 и HTTP / 1.1 не понимают заголовок Expect. ВидетьВидетьВидетьПри сравнении ожидаемых значений регистр не учитывается для токенов без кавычек (включая токен с продолжением 100) и учитывается регистр для расширений ожидания в кавычках. Механизм ожидания является поэтапным: то есть прокси-сервер HTTP / 1.1 ДОЛЖЕН возвращать статус 417 (ожидание не выполнено), если он получает запрос с ожиданием, которое он не может удовлетворить. Однако сам заголовок запроса Expect является сквозным; он ДОЛЖЕН быть переадресован, если запрос пересылается. Многие старые приложения HTTP / 1.0 и HTTP / 1.1 не понимают заголовок Expect. ВидетьПри сравнении ожидаемых значений регистр не учитывается для токенов без кавычек (включая токен с продолжением 100) и учитывается регистр для расширений ожидания в кавычках. Механизм ожидания является поэтапным: то есть прокси-сервер HTTP / 1.1 ДОЛЖЕН возвращать статус 417 (ожидание не выполнено), если он получает запрос с ожиданием, которое он не может удовлетворить. Однако сам заголовок запроса Expect является сквозным; он ДОЛЖЕН быть переадресован, если запрос пересылается. Многие старые приложения HTTP / 1.0 и HTTP / 1.1 не понимают заголовок Expect. ВидетьПрокси-сервер 1 ДОЛЖЕН возвращать статус 417 (ожидание не выполнено), если он получает запрос с ожиданием, которое он не может удовлетворить. Однако сам заголовок запроса Expect является сквозным; он ДОЛЖЕН быть переадресован, если запрос пересылается. Многие старые приложения HTTP / 1.0 и HTTP / 1.1 не понимают заголовок Expect. ВидетьПрокси-сервер 1 ДОЛЖЕН возвращать статус 417 (ожидание не выполнено), если он получает запрос с ожиданием, которое он не может удовлетворить. Однако сам заголовок запроса Expect является сквозным; он ДОЛЖЕН быть переадресован, если запрос пересылается. Многие старые приложения HTTP / 1.0 и HTTP / 1.1 не понимают заголовок Expect. Видеть&lt;a href=&quot;#section-8.2.3&quot;&gt;раздел 8.2.3&lt;/a&gt; для использования статуса 100 (продолжить).</target>
        </trans-unit>
        <trans-unit id="99ea10caeb88c8a848354c782365979235f3abbc" translate="yes" xml:space="preserve">
          <source>The Expires entity-header field gives the date/time after which the
   response is considered stale. A stale cache entry may not normally be
   returned by a cache (either a proxy cache or a user agent cache)
   unless it is first validated with the origin server (or with an
   intermediate cache that has a fresh copy of the entity). See &lt;a href=&quot;#section-13.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; for further discussion of the expiration model.

   The presence of an Expires field does not imply that the original
   resource will change or cease to exist at, before, or after that
   time.

   The format is an absolute date and time as defined by HTTP-date in
   &lt;a href=&quot;#section-3.3.1&quot;&gt;section 3.3.1&lt;/a&gt;; it MUST be in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; date format:

      Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date

   An example of its use is

      Expires: Thu, 01 Dec 1994 16:00:00 GMT

      Note: if a response includes a Cache-Control field with the max-
      age directive (see &lt;a href=&quot;#section-14.9.3&quot;&gt;section 14.9.3&lt;/a&gt;), that directive overrides the
      Expires field.

   HTTP/1.1 clients and caches MUST treat other invalid date formats,
   especially including the value &quot;0&quot;, as in the past (i.e., &quot;already
   expired&quot;).

   To mark a response as &quot;already expired,&quot; an origin server sends an
   Expires date that is equal to the Date header value. (See the rules
   for expiration calculations in &lt;a href=&quot;#section-13.2.4&quot;&gt;section 13.2.4&lt;/a&gt;.) 

   To mark a response as &quot;never expires,&quot; an origin server sends an
   Expires date approximately one year from the time the response is
   sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one
   year in the future.

   The presence of an Expires header field with a date value of some
   time in the future on a response that otherwise would by default be
   non-cacheable indicates that the response is cacheable, unless
   indicated otherwise by a Cache-Control header field (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).</source>
          <target state="translated">В поле заголовка объекта Expires указывается дата / время, после которых ответ считается устаревшим. Устаревшая запись кэша обычно не может быть возвращена кешем (либо кешем прокси, либо кешем пользовательского агента), если она сначала не проверена на исходном сервере (или с промежуточным кешем, в котором есть свежая копия объекта). См. &lt;a href=&quot;#section-13.2&quot;&gt;Раздел &lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; для дальнейшего обсуждения модели истечения срока. Наличие поля Expires не означает, что исходный ресурс изменится или прекратит свое существование в, до или после этого времени. Формат - это абсолютная дата и время, как определено HTTP-date в &lt;a href=&quot;#section-3.3.1&quot;&gt;разделе 3.3.1&lt;/a&gt; ; это ДОЛЖНО быть в &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt;формат даты: Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date Пример его использования: Expires: Thu, 01 Dec 1994 16:00:00 GMT Примечание: если ответ включает поле Cache-Control с директивой max age (см. &lt;a href=&quot;#section-14.9.3&quot;&gt;раздел 14.9.3&lt;/a&gt; ), эта директива имеет приоритет над полем Expires. Клиенты и кеши HTTP / 1.1 ДОЛЖНЫ обрабатывать другие недопустимые форматы даты, особенно включая значение &amp;laquo;0&amp;raquo;, как в прошлом (т. Е. &amp;laquo;Срок действия уже истек&amp;raquo;). Чтобы пометить ответ как &amp;laquo;уже просроченный&amp;raquo;, исходный сервер отправляет дату Expires, которая равна значению заголовка Date. (См. Правила расчета срока действия в &lt;a href=&quot;#section-13.2.4&quot;&gt;разделе 13.2.4.&lt;/a&gt;.) Чтобы пометить ответ как &amp;laquo;никогда не истекающий&amp;raquo;, исходный сервер отправляет дату истечения примерно через год с момента отправки ответа. Серверы HTTP / 1.1 НЕ ДОЛЖНЫ отправлять даты истечения срока действия более чем на один год в будущем. Присутствие поля заголовка Expires со значением даты на некоторое время в будущем в ответе, который в противном случае по умолчанию не был бы кэшируемым, указывает на то, что ответ кэшируется, если иное не указано в поле заголовка Cache-Control ( &lt;a href=&quot;#section-14.9&quot;&gt;раздел 14.9&lt;/a&gt; ) ,</target>
        </trans-unit>
        <trans-unit id="074a25a70f6f59d4456b693beabbab06efa52e09" translate="yes" xml:space="preserve">
          <source>The Feature Policy directive to apply the &lt;code&gt;allowlist&lt;/code&gt; to. See &lt;a href=&quot;#Directives&quot;&gt;Directives&lt;/a&gt; below for a list of the permitted directive names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802828c9e44a9d19272a3ae660a11b2bb9d689e1" translate="yes" xml:space="preserve">
          <source>The Feature-Policy HTTP header</source>
          <target state="translated">Функция-политика HTTP заголовок</target>
        </trans-unit>
        <trans-unit id="8b610252bef915d12d88c567e1882bdb3b137742" translate="yes" xml:space="preserve">
          <source>The From request-header field, if given, SHOULD contain an Internet
   e-mail address for the human user who controls the requesting user
   agent. The address SHOULD be machine-usable, as defined by &quot;mailbox&quot;
   in &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as updated by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]:

       From   = &quot;From&quot; &quot;:&quot; mailbox

   An example is:

       From: webmaster@w3.org

   This header field MAY be used for logging purposes and as a means for
   identifying the source of invalid or unwanted requests. It SHOULD NOT
   be used as an insecure form of access protection. The interpretation
   of this field is that the request is being performed on behalf of the
   person given, who accepts responsibility for the method performed. In
   particular, robot agents SHOULD include this header so that the
   person responsible for running the robot can be contacted if problems
   occur on the receiving end.

   The Internet e-mail address in this field MAY be separate from the
   Internet host which issued the request. For example, when a request
   is passed through a proxy the original issuer's address SHOULD be
   used.

   The client SHOULD NOT send the From header field without the user's
   approval, as it might conflict with the user's privacy interests or
   their site's security policy. It is strongly recommended that the
   user be able to disable, enable, and modify the value of this field
   at any time prior to a request.</source>
          <target state="translated">Поле заголовка запроса From, если оно задано, ДОЛЖНО содержать адрес электронной почты в Интернете для человека-пользователя, который управляет запрашивающим пользовательским агентом. Адрес ДОЛЖЕН быть машинным, как определено &quot;почтовым ящиком&quot; в &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ] и обновлено &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]: From = &quot;From&quot; &quot;:&quot; почтовый ящик Пример: From: webmaster@w3.org Это поле заголовка МОЖЕТ использоваться для ведения журнала и как средство для определения источника недействительных или нежелательных запросов. Его НЕ СЛЕДУЕТ использовать в качестве небезопасной формы защиты доступа. Интерпретация этого поля заключается в том, что запрос выполняется от имени данного лица, которое принимает на себя ответственность за выполненный метод. В частности, агенты роботов ДОЛЖНЫ включать этот заголовок, чтобы можно было связаться с лицом, ответственным за запуск робота, в случае возникновения проблем на принимающей стороне. Адрес электронной почты в Интернете в этом поле МОЖЕТ быть отдельным от узла Интернета, отправившего запрос. Например, когда запрос передается через прокси, исходный эмитент 'СЛЕДУЕТ использовать адрес s. Клиенту НЕ СЛЕДУЕТ отправлять поле заголовка From без одобрения пользователя, так как это может противоречить интересам конфиденциальности пользователя или политике безопасности его сайта. Настоятельно рекомендуется, чтобы пользователь мог отключать, включать и изменять значение этого поля в любое время до запроса.</target>
        </trans-unit>
        <trans-unit id="8a3df35a0d664c78b3c3b6d7181ee8d7a2e5448f" translate="yes" xml:space="preserve">
          <source>The GET method means retrieve whatever information (in the form of an
   entity) is identified by the Request-URI. If the Request-URI refers
   to a data-producing process, it is the produced data which shall be
   returned as the entity in the response and not the source text of the
   process, unless that text happens to be the output of the process.

   The semantics of the GET method change to a &quot;conditional GET&quot; if the
   request message includes an If-Modified-Since, If-Unmodified-Since,
   If-Match, If-None-Match, or If-Range header field. A conditional GET
   method requests that the entity be transferred only under the
   circumstances described by the conditional header field(s). The
   conditional GET method is intended to reduce unnecessary network
   usage by allowing cached entities to be refreshed without requiring
   multiple requests or transferring data already held by the client.

   The semantics of the GET method change to a &quot;partial GET&quot; if the
   request message includes a Range header field. A partial GET requests
   that only part of the entity be transferred, as described in &lt;a href=&quot;#section-14.35&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;. The partial GET method is intended to reduce unnecessary
   network usage by allowing partially-retrieved entities to be
   completed without transferring data already held by the client.

   The response to a GET request is cacheable if and only if it meets
   the requirements for HTTP caching described in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations when used for forms.</source>
          <target state="translated">Метод GET означает получение любой информации (в форме объекта), идентифицированной Request-URI. Если Request-URI относится к процессу создания данных, то в качестве объекта в ответе должны быть возвращены произведенные данные, а не исходный текст процесса, если только этот текст не является выходом процесса. Семантика метода GET изменяется на &amp;laquo;условный GET&amp;raquo;, если сообщение запроса включает поле заголовка If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match или If-Range. Условный метод GET требует, чтобы объект был передан только при обстоятельствах, описанных полями условного заголовка.Условный метод GET предназначен для уменьшения ненужного использования сети, позволяя обновлять кэшированные объекты, не требуя множественных запросов или передачи данных, уже хранящихся у клиента. Семантика метода GET изменяется на &amp;laquo;частичный GET&amp;raquo;, если сообщение запроса включает поле заголовка Range. Частичный GET-запрос передает только часть объекта, как описано в&lt;a href=&quot;#section-14.35&quot;&gt;Раздел &lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt; . Метод частичного GET предназначен для уменьшения ненужного использования сети, позволяя завершать частично извлеченные объекты без передачи данных, уже хранящихся у клиента. Ответ на запрос GET кэшируется тогда и только тогда, когда он соответствует требованиям к HTTP-кешированию, описанным в &lt;a href=&quot;#section-13&quot;&gt;разделе 13&lt;/a&gt; . См. &lt;a href=&quot;#section-15.1.3&quot;&gt;Раздел 15.1.3&lt;/a&gt; для ознакомления с соображениями безопасности при использовании форм.</target>
        </trans-unit>
        <trans-unit id="7fe6f3c8c21eb606abd80993ecfb90185941dd2b" translate="yes" xml:space="preserve">
          <source>The GET method requests transfer of a current selected representation
   for the target resource.  GET is the primary mechanism of information
   retrieval and the focus of almost all performance optimizations.
   Hence, when people speak of retrieving some identifiable information
   via HTTP, they are generally referring to making a GET request.

   It is tempting to think of resource identifiers as remote file system
   pathnames and of representations as being a copy of the contents of
   such files.  In fact, that is how many resources are implemented (see
   &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt; for related security considerations).  However, there are
   no such limitations in practice.  The HTTP interface for a resource
   is just as likely to be implemented as a tree of content objects, a
   programmatic view on various database records, or a gateway to other
   information systems.  Even when the URI mapping mechanism is tied to
   a file system, an origin server might be configured to execute the
   files with the request as input and send the output as the
   representation rather than transfer the files directly.  Regardless,
   only the origin server needs to know how each of its resource 

   identifiers corresponds to an implementation and how each
   implementation manages to select and send a current representation of
   the target resource in a response to GET.

   A client can alter the semantics of GET to be a &quot;range request&quot;,
   requesting transfer of only some part(s) of the selected
   representation, by sending a Range header field in the request
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]).

   A payload within a GET request message has no defined semantics;
   sending a payload body on a GET request might cause some existing
   implementations to reject the request.

   The response to a GET request is cacheable; a cache MAY use it to
   satisfy subsequent GET and HEAD requests unless otherwise indicated
   by the Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Метод GET запрашивает передачу текущего выбранного представления для целевого ресурса. GET - это основной механизм поиска информации, на котором сосредоточены практически все методы оптимизации производительности. Следовательно, когда люди говорят о получении некоторой идентифицируемой информации через HTTP, они обычно имеют в виду выполнение запроса GET. Заманчиво думать об идентификаторах ресурсов как о путях к удаленной файловой системе, а о представлениях - как об копиях содержимого таких файлов. Фактически, именно столько ресурсов реализовано (см. &lt;a href=&quot;#section-9.1&quot;&gt;Раздел 9.1&lt;/a&gt;по связанным соображениям безопасности). Однако на практике таких ограничений нет. Интерфейс HTTP для ресурса с такой же вероятностью будет реализован как дерево объектов контента, программное представление для различных записей базы данных или шлюз к другим информационным системам. Даже когда механизм сопоставления URI привязан к файловой системе, исходный сервер может быть настроен на выполнение файлов с запросом в качестве входных данных и отправку выходных данных в качестве представления, а не передачу файлов напрямую. Тем не менее, только исходный сервер должен знать, как каждый из его идентификаторов ресурса соответствует реализации и как каждая реализация управляет выбором и отправкой текущего представления целевого ресурса в ответ на GET. Клиент может изменить семантику GET на &quot;запрос диапазона &quot;, запрашивая передачу только части (частей) выбранного представления, отправив поле заголовка диапазона в запросе ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]). Полезные данные в сообщении запроса GET не имеют определенной семантики; отправка тела полезной нагрузки в запросе GET может привести к тому, что некоторые существующие реализации отклонят запрос. Ответ на запрос GET кэшируется; кэш МОЖЕТ использовать его для удовлетворения последующих запросов GET и HEAD, если иное не указано в поле заголовка Cache-Control ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;раздел 5.2 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7d2462324b684ba6bb0e708d0480d884f24bd586" translate="yes" xml:space="preserve">
          <source>The GOAWAY frame (type=0x7) is used to initiate shutdown of a
   connection or to signal serious error conditions.  GOAWAY allows an
   endpoint to gracefully stop accepting new streams while still
   finishing processing of previously established streams.  This enables
   administrative actions, like server maintenance.

   There is an inherent race condition between an endpoint starting new
   streams and the remote sending a GOAWAY frame.  To deal with this
   case, the GOAWAY contains the stream identifier of the last peer-
   initiated stream that was or might be processed on the sending
   endpoint in this connection.  For instance, if the server sends a
   GOAWAY frame, the identified stream is the highest-numbered stream
   initiated by the client.

   Once sent, the sender will ignore frames sent on streams initiated by
   the receiver if the stream has an identifier higher than the included
   last stream identifier.  Receivers of a GOAWAY frame MUST NOT open
   additional streams on the connection, although a new connection can
   be established for new streams.

   If the receiver of the GOAWAY has sent data on streams with a higher
   stream identifier than what is indicated in the GOAWAY frame, those
   streams are not or will not be processed.  The receiver of the GOAWAY
   frame can treat the streams as though they had never been created at
   all, thereby allowing those streams to be retried later on a new
   connection.

   Endpoints SHOULD always send a GOAWAY frame before closing a
   connection so that the remote peer can know whether a stream has been
   partially processed or not.  For example, if an HTTP client sends a
   POST at the same time that a server closes a connection, the client
   cannot know if the server started to process that POST request if the
   server does not send a GOAWAY frame to indicate what streams it might
   have acted on.

   An endpoint might choose to close a connection without sending a
   GOAWAY for misbehaving peers. 

   A GOAWAY frame might not immediately precede closing of the
   connection; a receiver of a GOAWAY that has no more use for the
   connection SHOULD still send a GOAWAY frame before terminating the
   connection.

    +-+-------------------------------------------------------------+
    |R|                  Last-Stream-ID (31)                        |
    +-+-------------------------------------------------------------+
    |                      Error Code (32)                          |
    +---------------------------------------------------------------+
    |                  Additional Debug Data (*)                    |
    +---------------------------------------------------------------+

                     Figure 13: GOAWAY Payload Format

   The GOAWAY frame does not define any flags.

   The GOAWAY frame applies to the connection, not a specific stream.
   An endpoint MUST treat a GOAWAY frame with a stream identifier other
   than 0x0 as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   The last stream identifier in the GOAWAY frame contains the highest-
   numbered stream identifier for which the sender of the GOAWAY frame
   might have taken some action on or might yet take action on.  All
   streams up to and including the identified stream might have been
   processed in some way.  The last stream identifier can be set to 0 if
   no streams were processed.

      Note: In this context, &quot;processed&quot; means that some data from the
      stream was passed to some higher layer of software that might have
      taken some action as a result.

   If a connection terminates without a GOAWAY frame, the last stream
   identifier is effectively the highest possible stream identifier.

   On streams with lower- or equal-numbered identifiers that were not
   closed completely prior to the connection being closed, reattempting
   requests, transactions, or any protocol activity is not possible,
   with the exception of idempotent actions like HTTP GET, PUT, or
   DELETE.  Any protocol activity that uses higher-numbered streams can
   be safely retried using a new connection.

   Activity on streams numbered lower or equal to the last stream
   identifier might still complete successfully.  The sender of a GOAWAY
   frame might gracefully shut down a connection by sending a GOAWAY
   frame, maintaining the connection in an &quot;open&quot; state until all in-
   progress streams complete. 

   An endpoint MAY send multiple GOAWAY frames if circumstances change.
   For instance, an endpoint that sends GOAWAY with NO_ERROR during
   graceful shutdown could subsequently encounter a condition that
   requires immediate termination of the connection.  The last stream
   identifier from the last GOAWAY frame received indicates which
   streams could have been acted upon.  Endpoints MUST NOT increase the
   value they send in the last stream identifier, since the peers might
   already have retried unprocessed requests on another connection.

   A client that is unable to retry requests loses all requests that are
   in flight when the server closes the connection.  This is especially
   true for intermediaries that might not be serving clients using
   HTTP/2.  A server that is attempting to gracefully shut down a
   connection SHOULD send an initial GOAWAY frame with the last stream
   identifier set to 2^31-1 and a NO_ERROR code.  This signals to the
   client that a shutdown is imminent and that initiating further
   requests is prohibited.  After allowing time for any in-flight stream
   creation (at least one round-trip time), the server can send another
   GOAWAY frame with an updated last stream identifier.  This ensures
   that a connection can be cleanly shut down without losing requests.

   After sending a GOAWAY frame, the sender can discard frames for
   streams initiated by the receiver with identifiers higher than the
   identified last stream.  However, any frames that alter connection
   state cannot be completely ignored.  For instance, HEADERS,
   PUSH_PROMISE, and CONTINUATION frames MUST be minimally processed to
   ensure the state maintained for header compression is consistent (see
   &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;); similarly, DATA frames MUST be counted toward the
   connection flow-control window.  Failure to process these frames can
   cause flow control or header compression state to become
   unsynchronized.

   The GOAWAY frame also contains a 32-bit error code (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) that
   contains the reason for closing the connection.

   Endpoints MAY append opaque data to the payload of any GOAWAY frame.
   Additional debug data is intended for diagnostic purposes only and
   carries no semantic value.  Debug information could contain security-
   or privacy-sensitive data.  Logged or otherwise persistently stored
   debug data MUST have adequate safeguards to prevent unauthorized
   access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5094fc44298eab7b1db803d184d5d22fe3243b4b" translate="yes" xml:space="preserve">
          <source>The General Data Privacy Regulation (GDPR) in the European Union</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df79dab20c7e00cfdc0198d8b7108bafe0b904f" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   return a message-body in the response. The metainformation contained
   in the HTTP headers in response to a HEAD request SHOULD be identical
   to the information sent in response to a GET request. This method can
   be used for obtaining metainformation about the entity implied by the
   request without transferring the entity-body itself. This method is
   often used for testing hypertext links for validity, accessibility,
   and recent modification.

   The response to a HEAD request MAY be cacheable in the sense that the
   information contained in the response MAY be used to update a
   previously cached entity from that resource. If the new field values
   indicate that the cached entity differs from the current entity (as
   would be indicated by a change in Content-Length, Content-MD5, ETag
   or Last-Modified), then the cache MUST treat the cache entry as
   stale.</source>
          <target state="translated">Метод HEAD идентичен GET за исключением того,что сервер НЕ ДОЛЖЕН возвращать тело сообщения в ответе.Метаинформация,содержащаяся в заголовках HTTP в ответ на запрос HEAD ДОЛЖНА быть идентична информации,отправленной в ответ на запрос GET.Этот метод может быть использован для получения метаинформации о сущности,подразумеваемой запросом,без передачи самого сущности-тела.Данный метод часто используется для проверки гипертекстовых ссылок на достоверность,доступность и недавние изменения.Ответ на HEAD запрос МОЖЕТ быть кэшируемым в том смысле,что информация,содержащаяся в ответе МОЖЕТ быть использована для обновления ранее кэшированной сущности с этого ресурса.Если новые значения полей указывают на то,что кэшируемая сущность отличается от текущей (о чем свидетельствует изменение Content-Length,Content-MD5,ETag или Last-Modified),то кэш ДОЛЖЕН относиться к кэшируемой сущности как к черствой.</target>
        </trans-unit>
        <trans-unit id="af87f0a9948cd0c865e17fe40c999f5f6559a626" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   send a message body in the response (i.e., the response terminates at
   the end of the header section).  The server SHOULD send the same
   header fields in response to a HEAD request as it would have sent if
   the request had been a GET, except that the payload header fields
   (&lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;) MAY be omitted.  This method can be used for obtaining
   metadata about the selected representation without transferring the
   representation data and is often used for testing hypertext links for
   validity, accessibility, and recent modification.

   A payload within a HEAD request message has no defined semantics;
   sending a payload body on a HEAD request might cause some existing
   implementations to reject the request.

   The response to a HEAD request is cacheable; a cache MAY use it to
   satisfy subsequent HEAD requests unless otherwise indicated by the
   Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).  A HEAD
   response might also have an effect on previously cached responses to
   GET; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;Section&amp;nbsp;4.3.5 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">Метод HEAD идентичен GET, за исключением того, что сервер НЕ ДОЛЖЕН отправлять тело сообщения в ответ (т. Е. Ответ заканчивается в конце раздела заголовка). Серверу СЛЕДУЕТ отправлять в ответ на запрос HEAD те же поля заголовка, которые он отправил бы, если бы запрос был GET, за исключением того, что поля заголовка полезной нагрузки ( &lt;a href=&quot;#section-3.3&quot;&gt;раздел 3.3&lt;/a&gt;) МОЖЕТ быть опущено. Этот метод можно использовать для получения метаданных о выбранном представлении без передачи данных представления и часто используется для проверки гипертекстовых ссылок на достоверность, доступность и недавнюю модификацию. Полезная нагрузка в сообщении запроса HEAD не имеет определенной семантики; отправка тела полезной нагрузки в запросе HEAD может привести к тому, что некоторые существующие реализации отклонят запрос. Ответ на запрос HEAD кэшируется; кэш МОЖЕТ использовать его для удовлетворения последующих запросов HEAD, если иное не указано в поле заголовка Cache-Control ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;раздел 5.2 [RFC7234]&lt;/a&gt; ). Ответ HEAD также может влиять на ранее кэшированные ответы на GET; см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;раздел 4.3.5 [RFC7234]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b66172e68b0534fed4eb909af19fada53af1789" translate="yes" xml:space="preserve">
          <source>The HEADERS frame (type=0x1) is used to open a stream (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;),
   and additionally carries a header block fragment.  HEADERS frames can
   be sent on a stream in the &quot;idle&quot;, &quot;reserved (local)&quot;, &quot;open&quot;, or
   &quot;half-closed (remote)&quot; state. 

    +---------------+
    |Pad Length? (8)|
    +-+-------------+-----------------------------------------------+
    |E|                 Stream Dependency? (31)                     |
    +-+-------------+-----------------------------------------------+
    |  Weight? (8)  |
    +-+-------------+-----------------------------------------------+
    |                   Header Block Fragment (*)                 
    +---------------------------------------------------------------+
    |                           Padding (*)                       
    +---------------------------------------------------------------+

                      Figure 7: HEADERS Frame Payload

   The HEADERS frame payload has the following fields:

   Pad Length:  An 8-bit field containing the length of the frame
      padding in units of octets.  This field is only present if the
      PADDED flag is set.

   E: A single-bit flag indicating that the stream dependency is
      exclusive (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  This field is only present if the
      PRIORITY flag is set.

   Stream Dependency:  A 31-bit stream identifier for the stream that
      this stream depends on (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  This field is only
      present if the PRIORITY flag is set.

   Weight:  An unsigned 8-bit integer representing a priority weight for
      the stream (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  Add one to the value to obtain a
      weight between 1 and 256.  This field is only present if the
      PRIORITY flag is set.

   Header Block Fragment:  A header block fragment (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).

   Padding:  Padding octets.

   The HEADERS frame defines the following flags:

   END_STREAM (0x1):  When set, bit 0 indicates that the header block
      (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) is the last that the endpoint will send for the
      identified stream.

      A HEADERS frame carries the END_STREAM flag that signals the end
      of a stream.  However, a HEADERS frame with the END_STREAM flag
      set can be followed by CONTINUATION frames on the same stream.
      Logically, the CONTINUATION frames are part of the HEADERS frame. 

   END_HEADERS (0x4):  When set, bit 2 indicates that this frame
      contains an entire header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) and is not followed
      by any CONTINUATION frames.

      A HEADERS frame without the END_HEADERS flag set MUST be followed
      by a CONTINUATION frame for the same stream.  A receiver MUST
      treat the receipt of any other type of frame or a frame on a
      different stream as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
      PROTOCOL_ERROR.

   PADDED (0x8):  When set, bit 3 indicates that the Pad Length field
      and any padding that it describes are present.

   PRIORITY (0x20):  When set, bit 5 indicates that the Exclusive Flag
      (E), Stream Dependency, and Weight fields are present; see
      &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;.

   The payload of a HEADERS frame contains a header block fragment
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).  A header block that does not fit within a HEADERS
   frame is continued in a CONTINUATION frame (&lt;a href=&quot;#section-6.10&quot;&gt;Section 6.10&lt;/a&gt;).

   HEADERS frames MUST be associated with a stream.  If a HEADERS frame
   is received whose stream identifier field is 0x0, the recipient MUST
   respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   The HEADERS frame changes the connection state as described in
   &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;.

   The HEADERS frame can include padding.  Padding fields and flags are
   identical to those defined for DATA frames (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).  Padding
   that exceeds the size remaining for the header block fragment MUST be
   treated as a PROTOCOL_ERROR.

   Prioritization information in a HEADERS frame is logically equivalent
   to a separate PRIORITY frame, but inclusion in HEADERS avoids the
   potential for churn in stream prioritization when new streams are
   created.  Prioritization fields in HEADERS frames subsequent to the
   first on a stream reprioritize the stream (&lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa0cc40bb9e4667e351329947478703648e5a09" translate="yes" xml:space="preserve">
          <source>The HTML of &lt;code&gt;signup.html&lt;/code&gt; looks like this:</source>
          <target state="translated">HTML- &lt;code&gt;signup.html&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="7de3d21abd96bd4beb67ffb6ec818595df38d03d" translate="yes" xml:space="preserve">
          <source>The HTTP 1.1 (only) &lt;code&gt;Upgrade&lt;/code&gt; header can be used to upgrade an already established client/server connection to a different protocol (over the same transport protocol). For example, it can be used by a client to upgrade a connection from HTTP 1.1 to HTTP 2.0, or an HTTP or HTTPS connection into a WebSocket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e4ed100d87a6355dfbd6e285bdb4feb98fdc0d9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets over HTTP when the page uses HTTPS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ee255be05b605cffc50bf531b8bbc6cd52f1c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; предотвращает загрузку любых ресурсов с использованием HTTP, когда страница загружается с использованием HTTPS.</target>
        </trans-unit>
        <trans-unit id="9387c952373df9470c27016caf452ee055a0a173" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect-src&lt;/strong&gt;&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4307301fcd6bb5ccdab9143ff3528885084251b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ограничивает URL-адреса, которые могут быть загружены с помощью интерфейсов сценариев. Ограниченные API:</target>
        </trans-unit>
        <trans-unit id="182931c21e0e507ac442ba7fad6c85f7022aa1b1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) по &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; служит резервным вариантом для других &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;директив&lt;/a&gt; CSP fetch . Для каждой из следующих директив, которые отсутствуют, пользовательский агент будет искать директиву &lt;code&gt;default-src&lt;/code&gt; и будет использовать для нее это значение:</target>
        </trans-unit>
        <trans-unit id="df6b0aa2488b0f60a06ea64f5f84252e16a5ba40" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для шрифтов, загружаемых с использованием &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b26fdbf4c8f95b8df3d8b6830742e1c693873add" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-action&lt;/code&gt; ограничивает URL-адреса, которые могут использоваться в качестве цели для отправки формы из заданного контекста.</target>
        </trans-unit>
        <trans-unit id="e3702b120d46e550d906d2d9a8d47f7b89a394a2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; указывает допустимые родительские элементы, которые могут встраивать страницу с помощью &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7a99a281dc2a7e2980a9a7cde577543fea1d6f5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; указывает допустимые источники для загрузки вложенных контекстов просмотра с использованием таких элементов, как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f35361ac952ed5107a00ab5b6446fbed51185da5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e405945a5f6f3e5caa215c10fb1ba16c926f41" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для загрузки мультимедиа с помощью элементов &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5cc0adb408b4a8f77493eae319c581cf4526353" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;navigate&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-to&lt;/code&gt; directive restricts the URLs to which a document can initiate navigations by any means including &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;/a&gt; (if &lt;a href=&quot;form-action&quot;&gt;&lt;code&gt;form-action&lt;/code&gt;&lt;/a&gt; is not specified), &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt;&lt;code&gt;window.location&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open&lt;/code&gt;&lt;/a&gt;, etc. This is an enforcement on what navigations this document initiates &lt;strong&gt;not&lt;/strong&gt; on what this document is allowed to navigate to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d107e0a38faf65b9362f0868294c5f1f868d7aa" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; ограничивает набор &lt;strong&gt;подключаемых модулей,&lt;/strong&gt; которые могут быть встроены в документ, путем ограничения типов ресурсов, которые могут быть загружены.</target>
        </trans-unit>
        <trans-unit id="f6e050006d74c56b081d711041cc2a29932e1bfd" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;prefetch-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid resources that may be prefetched or prerendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad6e328ff3b4fb09016b0d4cd3b23b2ef304500" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;../referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">Директива &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP), используемая для указания информации в заголовке &lt;a href=&quot;../referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; (с одним &lt;code&gt;r&lt;/code&gt; , поскольку это была опечатка в исходной спецификации) для ссылок за пределами страницы. Этот API устарел и удален из браузеров.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="871ccac3ab2ff9b3690d358a4ea40b08884840e9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;require-trusted-types-for&lt;/strong&gt;&lt;/code&gt;  directive instructs user agents to control the data passed to DOM XSS sink functions, like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML&quot;&gt;Element.innerHTML&lt;/a&gt; setter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8670f822879a6c1f70bb6696d4385c9e028089" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; директива позволяет песочницу для запрошенного ресурса аналогичен &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; атрибута. Он применяет ограничения к действиям страницы, включая предотвращение всплывающих окон, предотвращение выполнения плагинов и скриптов, а также принудительное применение политики одного происхождения.</target>
        </trans-unit>
        <trans-unit id="a54e3f9dc9e10d181fcc5b9d14de91d2158ed49a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src-attr&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript inline event handlers. This includes only inline script event handlers like &lt;code&gt;onclick&lt;/code&gt;, but not URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d32345b8cf84239a5bf4892731d98708512218" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; указывает допустимые источники для JavaScript. Сюда входят не только URL-адреса, загружаемые непосредственно в элементы &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; , но и такие вещи, как встроенные обработчики событий сценария ( &lt;code&gt;onclick&lt;/code&gt; ) и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;таблицы стилей XSLT,&lt;/a&gt; которые могут запускать выполнение сценария.</target>
        </trans-unit>
        <trans-unit id="ae949c0f5a7694445f0b27c386a8832b1c5e94b2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src-attr&lt;/code&gt; directive specifies valid sources for inline styles applied to individual DOM elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e52836f01982774b986b243c0c4f29e000b612f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src-elem&lt;/code&gt; directive specifies valid sources for stylesheets &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; elements with &lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a780dcd99b14cfc49a43bc74102f1ed0b2e3e6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для таблиц стилей.</target>
        </trans-unit>
        <trans-unit id="7b3e13bcd5d8d9f7bcf64acc3459db7ca20c7578" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;trusted-types&lt;/strong&gt;&lt;/code&gt;  directive instructs user agents to restrict the creation of Trusted Types policies - functions that build non-spoofable, typed values intended to be passed to DOM XSS sinks in place of strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591de896ab33256052ca0797fb955116eff15e90" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; предписывает пользовательским агентам обрабатывать все небезопасные URL-адреса сайта (обслуживаемые через HTTP), как если бы они были заменены безопасными URL-адресами (обслуживаемыми через HTTPS). Эта директива предназначена для веб-сайтов с большим количеством небезопасных устаревших URL-адресов, которые необходимо переписать.</target>
        </trans-unit>
        <trans-unit id="32ff6a8bc2363d0ff4f3086755b7248183c5b34b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; указывает допустимые источники для &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; , SharedWorker или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3acbb37620b5c60ffd911d6cef85fd1eada27d24" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5b4e1965627b7bb6308888f53e91d8ff996658" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;default-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent looks for the &lt;code&gt;default-src&lt;/code&gt; directive and uses this value for it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9204eef966021c11aedbb0e9fb96b1228c1de8f2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;script-src-elem&lt;/code&gt; directive specifies valid sources for JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but not inline script event handlers like &lt;code&gt;onclick&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa9970523d0f2da18a413ddfa67a54c01337b6d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;style-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275423427a5662144b985c69ef01612f4d51c0a4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;strong&gt;manifest-src&lt;/strong&gt;&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8c324b7db31bcba8cef085e4b98f52d8cd17a3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает, какой &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;манифест&lt;/a&gt; можно применить к ресурсу.</target>
        </trans-unit>
        <trans-unit id="8d10806c81e23539dc0cc263131762383ee75c31" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b239689551cd0c9430aba9321c015f59f5b7ee6a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники изображений и значков.</target>
        </trans-unit>
        <trans-unit id="f43d22faa65da48c48f2987c23a1ac5f2d7480b1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db12171daec1cecdac720828f51ca0a57d2ce24" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для элементов &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a75713e06f850d30f3c1d3897dfbb65c817d0a9c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; указывает клиенту требовать использования &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; для скриптов или стилей на странице.</target>
        </trans-unit>
        <trans-unit id="a32f782eaaf1368e46240e1ae4c440922d0f70d0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; ограничивает URL-адреса, которые могут использоваться в элементе &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; документа&lt;/a&gt; . Если это значение отсутствует, то разрешен любой URI. Если эта директива отсутствует, пользовательский агент будет использовать значение в элементе &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0361bbd3e19dd4db920260e46f1803df2efaa1a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;accelerometer&lt;/code&gt; directive controls whether the current document is allowed to gather information about the acceleration of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Accelerometer&quot;&gt;&lt;code&gt;Accelerometer&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c66228b38d0470e96db98a40225a18c2d3231a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;ambient-light-sensor&lt;/code&gt; directive controls whether the current document is allowed to gather information about the amount of light in the environment around the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AmbientLightSensor&quot;&gt;&lt;code&gt;AmbientLightSensor&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="358c131c1d5a8c89c254e16cfb1b9e90fee71186" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio#attr-autoplay&quot;&gt;autoplay&lt;/a&gt;&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c9ca551ef322fcef92f79b3a236ae1ba63f558" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;. The &lt;code&gt;autoplay&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">Директива &lt;code&gt;autoplay&lt;/code&gt; заголовка &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; HTTP определяет, разрешено ли текущему документу автоматически воспроизводить мультимедиа, запрошенную через интерфейс &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt; . Когда эта политика включена и пользовательских жестов не было, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; возвращаемое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt; будет отклонено с &lt;code&gt;DOMException&lt;/code&gt; . &lt;code&gt;autoplay&lt;/code&gt; атрибут &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; элементы будут игнорироваться.</target>
        </trans-unit>
        <trans-unit id="9bd2e515d62f7d6ede21b6f102d6e75bcfdc2806" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;battery&lt;/code&gt; directive controls whether the current document is allowed to gather information about the battery of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/BatteryManager&quot;&gt;&lt;code&gt;BatteryManager&lt;/code&gt;&lt;/a&gt; interface obtained via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getBattery&quot;&gt;&lt;code&gt;Navigator.getBattery()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7087babf47c5844e7ac3510edec835b831437673" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NotAllowedError&quot;&gt;&lt;code&gt;NotAllowedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ab43068a1ce03c2c700695396807b764653f4c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;camera&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать устройства ввода видео. Когда эта политика включена, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; возвращаемое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; будет отклонено с &lt;code&gt;NotAllowedError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a38d3aba5839b81049ae1c111db31f4dd2359f9e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;display-capture&lt;/code&gt; directive controls whether or not the document is permitted to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen_Capture_API&quot;&gt;Screen Capture API&lt;/a&gt;, i.e.,&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia&quot;&gt;&lt;code&gt;getDisplayMedia()&lt;/code&gt;&lt;/a&gt; to capture the screen's contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0509b709eb9c12fa1d36b479d880843a32939bb2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;document-domain&lt;/code&gt; directive controls whether the current document is allowed to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, attempting to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt; will fail and cause a &lt;code&gt;SecurityError&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; to be be thrown.</source>
          <target state="translated">Директива &lt;code&gt;document-domain&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу устанавливать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt; . Когда эта политика включена, попытка установить &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt; завершится ошибкой и вызовет &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; &lt;code&gt;SecurityError&lt;/code&gt; DOMException .</target>
        </trans-unit>
        <trans-unit id="db2a12cedfc96871f58d6b87b88cf7641d46244e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c66dd6d4d4a75699b185decdfad8e45e19e0002d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;encrypted-media&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). Когда эта политика включена, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; возвращаемое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt; будет отклонено с &lt;code&gt;DOMException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e8d5d79df5028bcf829983040e4f5d620f67f63" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива &lt;code&gt;fullscreen&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt; . Когда эта политика включена, возвращенное &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; отклоняется с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb70b85868a9918e7c850de1c73663ec03ac5340" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;geolocation&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать интерфейс &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt; . Когда эта политика включена, вызовы &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; &lt;/a&gt; будут вызывать обратные вызовы этих функций с кодом &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt; &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1aa24dbbd3715af81f21828a56fabf5ec110953" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;gyroscope&lt;/code&gt; directive controls whether the current document is allowed to gather information about the orientation of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Gyroscope&quot;&gt;&lt;code&gt;Gyroscope&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ff5966dce2b9c7b7600a4d4c06b6e4b170f277" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;layout-animations&lt;/code&gt; directive controls whether the current document is allowed to show layout animations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79581f7e39deb619df4e34954f818f674b43f16f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;legacy-image-formats&lt;/code&gt; directive controls whether the current document is allowed to display images in legacy formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb5ebff50a1c299f3cfff78c80e0f15d5569925" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;magnetometer&lt;/code&gt; directive controls whether the current document is allowed to gather information about the orientation of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Magnetometer&quot;&gt;&lt;code&gt;Magnetometer&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88583ce1eab6212205a0ce4ec5269a6f045f6b3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;microphone&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать устройства ввода звука. Когда эта политика включена, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; возвращаемое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; будет отклонено с &lt;code&gt;NotAllowedError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f61a9280d76cca41de0c10b1bb571562297d206c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;midi&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt;&lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;midi&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt; . Когда эта политика включена, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; возвращаемое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt; &lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt; &lt;/a&gt; будет отклонено с &lt;code&gt;DOMException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7143f5b43341ab71af365409875146a8699bd3ea" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;oversized-images&lt;/code&gt; directive controls whether the current document is allowed to download and display large images.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad49b71ef86ec5410e8de76cba85903aa7fec02d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;payment&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;API запроса платежа&lt;/a&gt; . Если эта политика включена, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt; конструктор бросит &lt;code&gt;SecurityError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bf49ec28a205e1ed0b001dfbdb9aa642280ff0c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;picture-in-picture&lt;/code&gt; directive controls whether the current document is allowed to play a video in a Picture-in-Picture mode via the corresponding API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ebcad6e4fbff3f317a76c00d82e77cbe034d342" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;publickey-credentials-get&lt;/code&gt; directive controls whether the current document is allowed to access &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API&quot;&gt;Web Authentcation API&lt;/a&gt; to create new public-key credentials, i.e, via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get&quot;&gt;&lt;code&gt;navigator.credentials.get({publicKey: ..., ...})&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5bf4e9f3fed1765343fd59a9718f4cd6d7d27d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;screen-wake-lock&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API&quot;&gt;Screen Wake Lock API&lt;/a&gt; to indicate that device should not dim or turn off the screen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d480f24830d984d0930580ca8ddada9de45700d1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;sync-xhr&lt;/code&gt; directive controls whether the current document is allowed to make synchronous &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a58ad5a409b3b1c3a41e1e839795597dc6204dc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;unoptimized-images&lt;/code&gt; directive controls whether the current document is allowed to download and display unoptimized images.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80682ef1147e80bdbff00f43c45c04f77992134" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;unsized-media&lt;/code&gt; directive controls whether the current document is allowed to change the size of media elements after the initial layout is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad639cf0153cfd80980b0affb3cc2e1e990de76" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vibrate&lt;/code&gt;  directive controls whether the current document is allowed to trigger device vibrations via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/vibrate&quot;&gt;&lt;code&gt;Navigator.vibrate()&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API&quot;&gt;Vibration API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="596ebd10a4b879fc3f494e6c070eefbc8b1b78da" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf81d231c67dd1b00b85de64c8fcc4e2241cad31" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;vr&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;API WebVR&lt;/a&gt; . Когда эта политика включена, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; возвращаемое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt; будет отклонено с &lt;code&gt;DOMException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15c0f9c5a8e9e08ad03923f24381554ed8b9ab1c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;wake-lock&lt;/code&gt; directive controls whether the current document is allowed to use Wake Lock API to indicate that device should not enter power-saving mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269d13c10993281fbc573c770f836b44bc5f308a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;web-share&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share&quot;&gt;&lt;code&gt;Navigator.share()&lt;/code&gt;&lt;/a&gt; method of the Web Share API to share text, links, images, and other content to arbitrary destinations of the user's choice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62dced3e4a986bc5373d1a7961ad28c776d2c977" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;xr-spatial-tracking&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API&quot;&gt;WebXR Device API&lt;/a&gt;. This policy controls whether &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XR/requestSession&quot;&gt;&lt;code&gt;navigator.xr.requestSession()&lt;/code&gt;&lt;/a&gt; can return &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XRSession&quot;&gt;&lt;code&gt;XRSession&lt;/code&gt;&lt;/a&gt; that requires spatial tracking and whether user agent can indicate support for sessions supporting spatial tracking via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XR/isSessionSupported&quot;&gt;&lt;code&gt;navigator.xr.isSessionSupported()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/devicechange&quot;&gt;devicechange&lt;/a&gt;&lt;/code&gt; event on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/xr&quot;&gt;&lt;code&gt;navigator.xr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4136ce714258747e9ae7bb826711d2f7370051e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header field's &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is disabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="085032760c08ad9b9fdf7e3304ad0c84d9aeabf7" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header usb directive controls whether the current document is allowed to use the WebUSB API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90bd59abf141ac2acd0d6eb93603dfbb20ca13bb" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; предотвращает загрузку любых ресурсов с использованием HTTP, когда страница загружается с использованием HTTPS.</target>
        </trans-unit>
        <trans-unit id="2c130ba07e36557d606dab5e0daeea1174e0f829" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ограничивает URL-адреса, которые могут быть загружены с помощью интерфейсов сценариев. Ограниченные API:</target>
        </trans-unit>
        <trans-unit id="f9e44e9310d4af0da6d15e0f9e8b89d123612c88" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) по &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; служит резервным вариантом для других &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;директив&lt;/a&gt; CSP fetch . Для каждой из следующих директив, которые отсутствуют, пользовательский агент будет искать директиву &lt;code&gt;default-src&lt;/code&gt; и будет использовать для нее это значение:</target>
        </trans-unit>
        <trans-unit id="872a0ce0f866c4f403e5c4fdabdba2ac75e64283" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для шрифтов, загружаемых с использованием &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89db1b08f92d8384d90536ecc2f476ece38912e3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-action&lt;/code&gt; ограничивает URL-адреса, которые могут использоваться в качестве цели для отправки формы из заданного контекста.</target>
        </trans-unit>
        <trans-unit id="53e746d6be4fd9b5eb3832de56d4365f491df6d6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; указывает допустимые родительские элементы, которые могут встраивать страницу с помощью &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60434b7f567fe8e897910e8b6a67bd2318a07eda" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; указывает допустимые источники для загрузки вложенных контекстов просмотра с использованием таких элементов, как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af2c302ddc10d3d222e0a67e09b8d5d05e052366" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для загрузки мультимедиа с помощью элементов &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d40cffb60b43134b32f0810a5ed2a290fe665f6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; ограничивает набор &lt;strong&gt;подключаемых модулей,&lt;/strong&gt; которые могут быть встроены в документ, путем ограничения типов ресурсов, которые могут быть загружены.</target>
        </trans-unit>
        <trans-unit id="bdd0798eaf4df1ffabbf8a0c8d7aa4c0dbd9e69b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">Директива &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP), используемая для указания информации в заголовке &lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; (с одним &lt;code&gt;r&lt;/code&gt; , поскольку это была опечатка в исходной спецификации) для ссылок за пределами страницы. Этот API устарел и удален из браузеров.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="befd663ba9deb24fd4ec2918a5d6109d2636a2d4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; директива позволяет песочницу для запрошенного ресурса аналогичен &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; атрибута. Он применяет ограничения к действиям страницы, включая предотвращение всплывающих окон, предотвращение выполнения плагинов и скриптов, а также принудительное применение политики одного происхождения.</target>
        </trans-unit>
        <trans-unit id="5b8d334a3bce170c8993d25e4d184932264ac72f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; указывает допустимые источники для JavaScript. Сюда входят не только URL-адреса, загружаемые непосредственно в элементы &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; , но и такие вещи, как встроенные обработчики событий сценария ( &lt;code&gt;onclick&lt;/code&gt; ) и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;таблицы стилей XSLT,&lt;/a&gt; которые могут запускать выполнение сценария.</target>
        </trans-unit>
        <trans-unit id="8cef37884cea47d641cdd47c4c37fa6b8ac6254c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for sources for stylesheets.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для источников для таблиц стилей.</target>
        </trans-unit>
        <trans-unit id="27cf15a50bbcd9352999ad2ec374352073190e0d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7e1c437a2a4b57d25b681153a76fdfe0cd58a0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; предписывает пользовательским агентам обрабатывать все небезопасные URL-адреса сайта (обслуживаемые через HTTP), как если бы они были заменены безопасными URL-адресами (обслуживаемыми через HTTPS). Эта директива предназначена для веб-сайтов с большим количеством небезопасных устаревших URL-адресов, которые необходимо переписать.</target>
        </trans-unit>
        <trans-unit id="c6470e7d04b8abe1f65b75c4d51906723a206d5d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; указывает допустимые источники для &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; , SharedWorker или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65fa53659e196a5f364ee4db69fef14fde746c4b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает, какой &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;манифест&lt;/a&gt; можно применить к ресурсу.</target>
        </trans-unit>
        <trans-unit id="e5534bb581250f2eb94ed31caf65205d9ee368e1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники изображений и значков.</target>
        </trans-unit>
        <trans-unit id="dc76ac8291a24a25cb87200add3759c6483c6ea1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для элементов &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d78f21670ba26d46502f42156fd74dce6127ca2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; указывает клиенту требовать использования &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; для скриптов или стилей на странице.</target>
        </trans-unit>
        <trans-unit id="c04dd8d66fd1dfd03e0cb89fd2b86f5466e7e9c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; ограничивает URL-адреса, которые могут использоваться в элементе &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; документа&lt;/a&gt; . Если это значение отсутствует, то разрешен любой URI. Если эта директива отсутствует, пользовательский агент будет использовать значение в элементе &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="434bd95977151980be645e25d889ee96d08c9496" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;. The &lt;code&gt;autoplay&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f42da0f7bda5731910d6ec6cb2dc9b13ff87de9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b38e64dd4aafe5fbe1b9af5c13faa83b6a43ced" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;document-domain&lt;/code&gt; directive controls whether the current document is allowed to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, attempting to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt; will fail and cause a &lt;code&gt;SecurityError&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; to be be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52529e863205e105281cb3b1e67c42491db93580" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c026bd77cc15606268a474526426c47ed406dd3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива &lt;code&gt;fullscreen&lt;/code&gt; заголовка HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt; . Когда эта политика включена, возвращенное &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; отклоняется с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="279945c05ed4e9f8612677a6cb5333c055c3347c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;geolocation&lt;/code&gt; заголовка HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать интерфейс &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt; . Когда эта политика включена, вызовы &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; &lt;/a&gt; вызовут обратные вызовы этих функций с кодом &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt; &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b86b8ff6f832650a49ab241aa391e1a80cf0e208" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;microphone&lt;/code&gt; заголовка HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать устройства ввода звука. Если эта политика включена, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; возвращаемое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; будет отклонено с &lt;code&gt;NotAllowedError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ee0bf2b06d49cf8e3886496858e4c50b79dbf27" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;midi&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt;&lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e1c9da52aa492cca410e5baad4c4d7dda1aa4f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9aec9b3d7ed8d0d68045c2927ccdfecf55159b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a01790dc40b1842141c794cdff77d6c8665d41c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method only allows complete replacement of a document. Unlike &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt; is not idempotent, meaning successive identical patch requests &lt;em&gt;may &lt;/em&gt;have different effects. However, it is possible to issue &lt;code&gt;PATCH&lt;/code&gt; requests in such a way as to be idempotent.</source>
          <target state="translated">Метод HTTP &lt;a href=&quot;put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; позволяет только полную замену документа. В отличие от &lt;code&gt;PUT&lt;/code&gt; , &lt;code&gt;PATCH&lt;/code&gt; не идемпотентен, что означает, что последовательные одинаковые запросы исправлений &lt;em&gt;могут&lt;/em&gt; иметь разные эффекты. Однако можно &lt;code&gt;PATCH&lt;/code&gt; запросы PATCH таким образом, чтобы они были идемпотентными.</target>
        </trans-unit>
        <trans-unit id="7f334e7627368fd785cf9c286367893a77c43e45" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;100 Continue&lt;/code&gt; informational status response code indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.</source>
          <target state="translated">Код ответа информационного статуса HTTP &lt;code&gt;100 Continue&lt;/code&gt; указывает, что пока все в порядке, и что клиент должен продолжить выполнение запроса или проигнорировать его, если он уже завершен.</target>
        </trans-unit>
        <trans-unit id="7fbaadcda1376e28783b5f635687be50467a1933" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;103 Early Hints&lt;/code&gt; information response status code is primarily intended to be used with the &lt;a href=&quot;../headers/link&quot;&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/a&gt; header to allow the user agent to start preloading resources while the server is still preparing a response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278c46bdc85af7c390f125d693bcbfb316c79076" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;200 OK&lt;/code&gt; success status response code indicates that the request has succeeded. A 200 response is cacheable by default.</source>
          <target state="translated">Код ответа об успешном состоянии HTTP &lt;code&gt;200 OK&lt;/code&gt; указывает, что запрос выполнен успешно. По умолчанию ответ 200 кэшируется.</target>
        </trans-unit>
        <trans-unit id="c0eb27679053d5143a43ddd8d3a3431a539fa9ad" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;201 Created&lt;/code&gt; success status response code indicates that the request has succeeded and has led to the creation of a resource. The new resource is effectively created before this response is sent back and the new resource is returned in the body of the message, its location being either the URL of the request, or the content of the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Код ответа HTTP &lt;code&gt;201 Created&lt;/code&gt; Success status указывает, что запрос выполнен успешно и привел к созданию ресурса. Новый ресурс фактически создается до того, как этот ответ будет отправлен обратно, и новый ресурс будет возвращен в теле сообщения, его местонахождением является либо URL-адрес запроса, либо содержимое заголовка &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f20649a3f0fe7c56e61071fa1174a4b08047b9bd" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; response status indicates that the request was successful but the enclosed payload has been modified by a transforming &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxy&lt;/a&gt; from that of the origin server's &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d3953aeb6b99914993168434167c7b602ed71d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; response status indicates that the request was successful but the enclosed payload has been modified from that of the origin server's &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response by a transforming &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxy&lt;/a&gt;.</source>
          <target state="translated">Статус ответа HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; указывает, что запрос был успешным, но вложенные полезные данные были изменены по сравнению с ответом исходного сервера &lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;OK&lt;/code&gt; ) преобразующим &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;прокси&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8b0b238f5e41f13b1e7f817deb60c88d7d3bc20" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;204 No Content&lt;/code&gt; success status response code indicates that the request has succeeded, but that the client doesn't need to go away from its current page. A 204 response is cacheable by default. An &lt;a href=&quot;../headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header is included in such a response.</source>
          <target state="translated">Код ответа HTTP &lt;code&gt;204 No Content&lt;/code&gt; Success status указывает, что запрос выполнен успешно, но клиенту не нужно уходить со своей текущей страницы. По умолчанию ответ 204 кэшируется. &lt;a href=&quot;../headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; заголовок включен в таком ответ.</target>
        </trans-unit>
        <trans-unit id="80288ab170aee829f4cf209605eb49eadc086eef" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;205 Reset Content&lt;/code&gt; response status tells the client to reset the document view, so for example to clear the content of a form, reset a canvas state, or to refresh the UI.</source>
          <target state="translated">Статус ответа &amp;laquo; &lt;code&gt;205 Reset Content&lt;/code&gt; HTTP 205&amp;raquo; сообщает клиенту, что необходимо сбросить представление документа, например очистить содержимое формы, сбросить состояние холста или обновить пользовательский интерфейс.</target>
        </trans-unit>
        <trans-unit id="0c81546d9f0eee981bd016b4cb4e7eaa4833eb13" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; success status response code indicates that the request has succeeded and has the body contains the requested ranges of data, as described in the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header of the request.</source>
          <target state="translated">Код ответа об успешном завершении HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; указывает на то, что запрос выполнен успешно, и его тело содержит запрошенные диапазоны данных, как описано в заголовке &lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; запроса.</target>
        </trans-unit>
        <trans-unit id="3b3b5e099cd9381b1fd70b5113573795b1907f7d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.</source>
          <target state="translated">Код ответа о состоянии ошибки HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; клиент&amp;raquo; указывает на то, что запрос не был применен из-за отсутствия действительных учетных данных аутентификации для целевого ресурса.</target>
        </trans-unit>
        <trans-unit id="29e296a48560f66dbcc3ec52c233f4fdb267b76e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;402 Payment Required&lt;/code&gt; is a nonstandard client error status response code that is reserved for future use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979b22f333764accadf3c7a12f9ce50117ebb170" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; client error status response code indicates that the server understood the request but refuses to authorize it.</source>
          <target state="translated">Код ответа HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; client error status показывает, что сервер понял запрос, но отказывается его авторизовать.</target>
        </trans-unit>
        <trans-unit id="17d3fa05f1dcd2e00101e33637b74e845046dbb5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt; that is between the browser and the server that can access the requested resource.</source>
          <target state="translated">Код ответа состояния ошибки клиента HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; указывает, что запрос не был применен из-за отсутствия действительных учетных данных для &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;прокси-сервера,&lt;/a&gt; который находится между браузером и сервером, который может получить доступ к запрошенному ресурсу.</target>
        </trans-unit>
        <trans-unit id="bbb5886db0baaa39aa591bfbfac7d405f377c2ab" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; client error response code indicates that the expectation given in the request's &lt;a href=&quot;../headers/expect&quot;&gt;&lt;code&gt;Expect&lt;/code&gt;&lt;/a&gt; header could not be met.</source>
          <target state="translated">Код ответа об ошибке клиента HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; указывает, что ожидание, указанное в заголовке &lt;a href=&quot;../headers/expect&quot;&gt; &lt;code&gt;Expect&lt;/code&gt; &lt;/a&gt; запроса, не может быть выполнено.</target>
        </trans-unit>
        <trans-unit id="0fd8eba95386e5a941324f20f703ccd45af95a3a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error response code indicates that the server refuses to brew coffee because it is a teapot. This error is a reference of Hyper Text Coffee Pot Control Protocol which was an April Fools' joke in 1998.</source>
          <target state="translated">Код ответа HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; указывает на то, что сервер отказывается варить кофе, потому что это чайник. Эта ошибка является отсылкой к протоколу Hyper Text Coffee Pot Control Protocol, который в 1998 году был первоапрельской шуткой.</target>
        </trans-unit>
        <trans-unit id="654a84748c864e6e1a07b612586a854316f7aeb8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error response code indicates that the server refuses to brew coffee because it is, permanently, a teapot. A combined coffee/tea pot that is temporarily out of coffee should instead return 503. This error is a reference to Hyper Text Coffee Pot Control Protocol defined in April Fools' jokes in 1998 and 2014.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c11a396d84c2b4361354f28621db5450bb7872a5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; response code indicates the protocol the server is switching to as requested by a client which sent the message including the &lt;a href=&quot;../headers/upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73eb36719efddb2bf307089114ca5c1ff83bc1f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; response code indicates the protocol the server is switching to as requested by a client which sent the message including the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">Код ответа HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; указывает на протокол, на который сервер переключается по запросу клиента, который отправил сообщение, включая заголовок запроса &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7eb48272f72778b0b684676d2f608817e02eb9f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the request has more than one possible responses. The user-agent or the user should choose one of them. As there is no standardized way of choosing one of the responses, this response code is very rarely used.</source>
          <target state="translated">Код ответа состояния перенаправления HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; указывает, что запрос имеет более одного возможных ответов. Пользовательский агент или пользователь должны выбрать один из них. Поскольку не существует стандартизированного способа выбора одного из ответов, этот код ответа используется очень редко.</target>
        </trans-unit>
        <trans-unit id="de334adf5ffab7d89b3c6e50513373cd0cee8cfc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; client redirection response code indicates that there is no need to retransmit the requested resources. It is an implicit redirection to a cached resource. This happens when the request method is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, like a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request, or when the request is conditional and uses a &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Код ответа перенаправления клиента HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; указывает, что нет необходимости повторно передавать запрошенные ресурсы. Это неявное перенаправление на кэшированный ресурс. Это происходит, когда метод запроса &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;безопасен&lt;/a&gt; , например &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; , или когда запрос является условным и использует заголовок &lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="709d37d1b0cf9c49b3de2408fbf6ef4e0002c27a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server can't find the requested resource. Links that lead to a 404 page are often called broken or dead links and can be subject to &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;link rot&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="341bb159a2216d99ce107781a967531062a1c137" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server can't find the requested resource. Links which lead to a 404 page are often called broken or dead links, and can be subject to &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;link rot&lt;/a&gt;.</source>
          <target state="translated">Код ответа клиента об ошибке HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; указывает, что сервер не может найти запрошенный ресурс. Ссылки, которые ведут на страницу 404, часто называют неработающими или мертвыми ссылками, и они могут быть подвержены &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;гниению ссылок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="963eb81b613d14e6431a53b19e1087de4815c917" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; response status code indicates a request conflict with current state of the server.</source>
          <target state="translated">Код состояния ответа HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; указывает на конфликт запроса с текущим состоянием сервера.</target>
        </trans-unit>
        <trans-unit id="4a775e572f006026758ef524b8a9cc133b9ccc99" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; response status code indicates a request conflict with current state of the target resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e620c227a6a0b266557df35d3c5635f4241af7c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request entity is larger than limits defined by server; the server might close the connection or return a &lt;a href=&quot;../headers/retry-after&quot;&gt;&lt;code&gt;Retry-After&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">Код состояния ответа HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; указывает на то, что объект запроса превышает пределы, определенные сервером; сервер может закрыть соединение или вернуть поле заголовка &lt;a href=&quot;../headers/retry-after&quot;&gt; &lt;code&gt;Retry-After&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84e2079297e778196c8c9ae50616e31cf6eb1ce4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; response status code indicates that the URI requested by the client is longer than the server is willing to interpret.</source>
          <target state="translated">Код состояния ответа HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; указывает, что URI, запрошенный клиентом, длиннее, чем сервер готов интерпретировать.</target>
        </trans-unit>
        <trans-unit id="fd260910ed4759c1378089671fbb6c0fbbb60660" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request because the payload format is in an unsupported format.</source>
          <target state="translated">Код ответа клиента об ошибке &amp;laquo; &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; HTTP &lt;strong&gt;415&lt;/strong&gt; указывает на то, что сервер отказывается принять запрос, поскольку формат полезной нагрузки находится в неподдерживаемом формате.</target>
        </trans-unit>
        <trans-unit id="fa970ac1d28b371bc4205e842d1c6d26ad5a73c4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.</source>
          <target state="translated">Код ответа клиента об ошибке HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; указывает на то, что сервер отказывается выполнять запрос с использованием текущего протокола, но может быть готов сделать это после того, как клиент перейдет на другой протокол.</target>
        </trans-unit>
        <trans-unit id="75aa3c74acfab1e106209fd4dd08b06e3054f27c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server requires the request to be &lt;a href=&quot;../conditional_requests&quot;&gt;conditional&lt;/a&gt;.</source>
          <target state="translated">Код состояния ответа HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; указывает, что сервер требует, чтобы запрос был &lt;a href=&quot;../conditional_requests&quot;&gt;условным&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="caa3bb3b92f0cfe33012b47986779e7f954a74b6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; response status code indicates the user has sent too many requests in a given amount of time (&quot;rate limiting&quot;).</source>
          <target state="translated">Код состояния ответа HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; указывает, что пользователь отправил слишком много запросов за заданный промежуток времени (&amp;laquo;ограничение скорости&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="04093cec2709dfaadbfa7527dc5c2ce1cd0b0646" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to process the request because its header fields are too large. The request may be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">Код состояния ответа HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; указывает на то, что сервер не желает обрабатывать запрос, поскольку его поля заголовка слишком велики. Запрос может быть отправлен повторно после уменьшения размера полей заголовка запроса.</target>
        </trans-unit>
        <trans-unit id="aa944fee90f822e5d898a487cb81942f7a56be65" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server refuses to process the request because the request&amp;rsquo;s &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; are too long. The request &lt;em&gt;may&lt;/em&gt; be resubmitted after reducing the size of the request headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ddb3645327183c13becf845f54f56cdc4fdb5b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the client needs to authenticate to gain network access.</source>
          <target state="translated">Код состояния ответа HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; указывает, что клиенту необходимо пройти аутентификацию, чтобы получить доступ к сети.</target>
        </trans-unit>
        <trans-unit id="61ba4c1907f9a2e1f56de138ea9bcbb425c864e8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; response header sends reports of pinning violation to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header but, unlike &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; still allows browsers to connect to the server if the pinning is violated.</source>
          <target state="translated">Заголовок ответа HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; отправляет отчеты о нарушении закрепления в &lt;code&gt;report-uri&lt;/code&gt; указанный в заголовке, но, в отличие от &lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; ,по-&lt;/a&gt; прежнему позволяет браузерам подключаться к серверу, если закрепление нарушено.</target>
        </trans-unit>
        <trans-unit id="1d86ddf68a31dc8a760b8d60344a39004ec85b2f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; response header was used to send reports of pinning violation to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header but, unlike &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; still allows browsers to connect to the server if the pinning is violated. The header is silently ignored in modern browsers as support for HPKP has been removed. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; and the &lt;a href=&quot;expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f1aca0b8602a1b4269702669b5705705488252e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; response header associates a specific cryptographic public &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;key&lt;/a&gt; with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates. If one or several keys are pinned and none of them are used by the server, the browser will not accept the response as legitimate, and will not display it.</source>
          <target state="translated">Заголовок ответа HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; связывает конкретный криптографический открытый &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;ключ&lt;/a&gt; с определенным веб-сервером, чтобы снизить риск атак &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; с поддельными сертификатами. Если один или несколько ключей закреплены и ни один из них не используется сервером, браузер не примет ответ как законный и не отобразит его.</target>
        </trans-unit>
        <trans-unit id="5426b643c79f95f69aab37cfedbccbbaa4236ca6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; response header used to associate a specific cryptographic public &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;key&lt;/a&gt; with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates, however, it has been removed from modern browsers and is no longer supported. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; and &lt;a href=&quot;expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc17523ceced42a997fa4ec405b48542dc6da961" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent with a server, usually after the server has responded with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; status and the &lt;a href=&quot;www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Заголовок запроса HTTP- &lt;code&gt;Authorization&lt;/code&gt; содержит учетные данные для аутентификации пользовательского агента с сервером, обычно после того, как сервер ответил статусом &lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; и заголовком &lt;a href=&quot;www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91c7c3a40bace5e7298eaff1c25e12df9e924d3d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent with a server, usually, but not necessarily, after the server has responded with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; status and the &lt;a href=&quot;www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eefae1a810c845c3fa68fd46660a1ab4ceaacda0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; response header allows web developers to experiment with policies by monitoring (but not enforcing) their effects. These violation reports consist of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; documents sent via an HTTP &lt;code&gt;POST&lt;/code&gt; request to the specified URI.</source>
          <target state="translated">Заголовок ответа HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; позволяет веб-разработчикам экспериментировать с политиками, отслеживая (но не применяя) их эффекты. Эти отчеты о нарушениях состоят из документов &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON,&lt;/a&gt; отправленных через HTTP- запрос &lt;code&gt;POST&lt;/code&gt; на указанный URI.</target>
        </trans-unit>
        <trans-unit id="1cedc9503c55c7df39812e0c200c391cb9852c4a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; response header allows web site administrators to control resources the user agent is allowed to load for a given page. With a few exceptions, policies mostly involve specifying server origins and script endpoints. This helps guard against cross-site scripting attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">Заголовок ответа HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; позволяет администраторам веб-сайтов контролировать ресурсы, которые пользовательский агент может загружать для данной страницы. За некоторыми исключениями, политики в основном включают указание источников сервера и конечных точек сценария. Это помогает защититься от атак с использованием межсайтовых сценариев ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e9a358c2e37bd97387c345bc97d49f2b9964bebc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Cross-Origin-Embedder-Policy&lt;/code&gt; (COEP) response header prevents a document from loading any cross-origin resources that don't explicitly grant the document permission (using &lt;a href=&quot;../cross-origin_resource_policy_(corp)&quot;&gt;CORP&lt;/a&gt; or &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd12a715eb3e020beaec19eacef98180f3c03eb5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Cross-Origin-Opener-Policy&lt;/code&gt; (COOP) response header allows you to ensure a top-level document does not share a browsing context group with cross-origin documents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="532f81dfa15429527706f99b56516bbbb7103920" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Cross-Origin-Resource-Policy&lt;/code&gt; response header conveys a desire that the browser blocks no-cors cross-origin/cross-site requests to the given resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1606c56903114379a30109e67a8a9703c7538a88" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; header provides a mechanism to allow and deny the use of browser features in its own frame, and in content within any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; elements in the document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f93db0c2b1cae96ab8007915ebdc3aee6ae9b29" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; header provides a mechanism to allow and deny the use of browser features in its own frame, and in iframes that it embeds.</source>
          <target state="translated">Заголовок HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; предоставляет механизм, позволяющий разрешать и запрещать использование функций браузера в собственном фрейме и во встроенных фреймах.</target>
        </trans-unit>
        <trans-unit id="ffce3b68f1b8be8fa0ab126f01ab7dcd1167232b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Link&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15bba15c0e7df46ed2a8a40b2e760da5664fad96" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;NEL&lt;/code&gt; response header is used to configure network request logging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee6fbdaf32a73c5d2da4ea87e0ad9941527d763" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource behind a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt;. It authenticates the request to the proxy server, allowing it to transmit the request further.</source>
          <target state="translated">Заголовок ответа HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; определяет метод аутентификации, который следует использовать для получения доступа к ресурсу за &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;прокси-сервером&lt;/a&gt; . Он аутентифицирует запрос на прокси-сервере, позволяя ему передавать запрос дальше.</target>
        </trans-unit>
        <trans-unit id="d342efd1df2902182c9b47d04c0940ea25837a75" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent to a proxy server, usually after the server has responded with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt; status and the &lt;a href=&quot;proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Заголовок запроса HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; содержит учетные данные для аутентификации пользовательского агента на прокси-сервере, как правило, после того, как сервер ответил статусом &lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; и заголовком &lt;a href=&quot;proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06706a733035595c3ca09ed579f53668680fa83e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; request header sends a signal to the server expressing the client&amp;rsquo;s preference for an encrypted and authenticated response, and that it can successfully handle the &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;CSP&lt;/a&gt; directive.</source>
          <target state="translated">Заголовок запроса HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; отправляет сигнал на сервер, выражающий предпочтение клиента в отношении зашифрованного и аутентифицированного ответа и о том, что он может успешно обрабатывать директиву &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;CSP &lt;/a&gt;&lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f27fddd57d61b2e03f1c5514e09709028f9f0a9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource.</source>
          <target state="translated">Заголовок ответа HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; определяет метод аутентификации, который следует использовать для получения доступа к ресурсу.</target>
        </trans-unit>
        <trans-unit id="aeb81534f8cc6e53ddfa06e7cb5d6c8eaf9dba55" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; response header is a feature of Internet Explorer, Chrome and Safari that stops pages from loading when they detect reflected cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;) attacks. Although these protections are largely unnecessary in modern browsers when sites implement a strong &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; that disables the use of inline JavaScript (&lt;code&gt;'unsafe-inline'&lt;/code&gt;), they can still provide protections for users of older web browsers that don't yet support &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSP&lt;/a&gt;.</source>
          <target state="translated">Заголовок ответа HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; - это функция Internet Explorer, Chrome и Safari, которая останавливает загрузку страниц при обнаружении атак с использованием отраженных межсайтовых сценариев ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; ). Хотя в современных браузерах эти средства защиты в значительной степени не нужны, когда сайты реализуют строгую &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; которая отключает использование встроенного JavaScript ( &lt;code&gt;'unsafe-inline'&lt;/code&gt; ), они все же могут обеспечивать защиту для пользователей старых веб-браузеров, которые еще не поддержка &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a09546225cff6400570e0443b16e0c6e86472fe" translate="yes" xml:space="preserve">
          <source>The HTTP Strict Transport Security header informs the browser that it should never load a site using HTTP and should automatically convert all attempts to access the site using HTTP to HTTPS requests instead.</source>
          <target state="translated">Заголовок HTTP Strict Transport Security информирует браузер о том,что он никогда не должен загружать сайт с помощью HTTP и должен автоматически преобразовывать все попытки доступа к сайту с помощью HTTP в HTTPS запросы вместо этого.</target>
        </trans-unit>
        <trans-unit id="be8b00e9c8d5d272b2e1f90c102d59e067b32a0b" translate="yes" xml:space="preserve">
          <source>The HTTP URL namespace is a hierarchical namespace where the
   hierarchy is delimited with the &quot;/&quot; character.

   An HTTP URL namespace is said to be consistent if it meets the
   following conditions: for every URL in the HTTP hierarchy there
   exists a collection that contains that URL as an internal member URL.
   The root, or top-level collection of the namespace under
   consideration, is exempt from the previous rule.  The top-level
   collection of the namespace under consideration is not necessarily
   the collection identified by the absolute path '/' -- it may be
   identified by one or more path segments (e.g., /servlets/webdav/...)

   Neither HTTP/1.1 nor WebDAV requires that the entire HTTP URL
   namespace be consistent -- a WebDAV-compatible resource may not have
   a parent collection.  However, certain WebDAV methods are prohibited
   from producing results that cause namespace inconsistencies.

   As is implicit in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;], any resource, including
   collection resources, MAY be identified by more than one URI.  For
   example, a resource could be identified by multiple HTTP URLs.</source>
          <target state="translated">Пространство имен HTTP URL - это иерархическое пространство имен, в котором иерархия ограничена знаком &amp;laquo;/&amp;raquo;. Пространство имен URL-адресов HTTP считается согласованным, если оно соответствует следующим условиям: для каждого URL-адреса в иерархии HTTP существует коллекция, содержащая этот URL-адрес в качестве URL-адреса внутреннего члена. Корневая или верхняя коллекция рассматриваемого пространства имен освобождается от предыдущего правила. Коллекция верхнего уровня рассматриваемого пространства имен не обязательно является коллекцией, идентифицируемой абсолютным путем '/' - она ​​может быть идентифицирована одним или несколькими сегментами пути (например, / servlets / webdav / ...) Ни HTTP / 1.1, ни WebDAV не требует, чтобы все пространство имен URL-адресов HTTP было согласованным - ресурс, совместимый с WebDAV, может не иметь родительской коллекции. Тем не мение,Некоторым методам WebDAV запрещено давать результаты, вызывающие несогласованность пространств имен. Как подразумевается в [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] и [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ], любой ресурс, включая ресурсы сбора, МОЖЕТ быть идентифицирован более чем одним URI. Например, ресурс может быть идентифицирован несколькими URL-адресами HTTP.</target>
        </trans-unit>
        <trans-unit id="4fce77c17c83cf3b9166ab68262d46c09171eb1b" translate="yes" xml:space="preserve">
          <source>The HTTP authentication framework does not define a single mechanism
   for maintaining the confidentiality of credentials; instead, each
   authentication scheme defines how the credentials are encoded prior
   to transmission.  While this provides flexibility for the development
   of future authentication schemes, it is inadequate for the protection
   of existing schemes that provide no confidentiality on their own, or
   that do not sufficiently protect against replay attacks.
   Furthermore, if the server expects credentials that are specific to
   each individual user, the exchange of those credentials will have the
   effect of identifying that user even if the content within
   credentials remains confidential.

   HTTP depends on the security properties of the underlying transport-
   or session-level connection to provide confidential transmission of
   header fields.  In other words, if a server limits access to
   authenticated users using this framework, the server needs to ensure
   that the connection is properly secured in accordance with the nature
   of the authentication scheme used.  For example, services that depend
   on individual user authentication often require a connection to be
   secured with TLS (&quot;Transport Layer Security&quot;, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]) prior to
   exchanging any credentials.</source>
          <target state="translated">Структура HTTP-аутентификации не определяет единого механизма для поддержания конфиденциальности учетных данных; вместо этого каждая схема аутентификации определяет, как учетные данные кодируются перед передачей. Хотя это обеспечивает гибкость для разработки будущих схем аутентификации, этого недостаточно для защиты существующих схем, которые сами по себе не обеспечивают конфиденциальности или которые не обеспечивают достаточной защиты от атак повторного воспроизведения. Кроме того, если сервер ожидает учетные данные, специфичные для каждого отдельного пользователя, обмен этими учетными данными приведет к идентификации этого пользователя, даже если содержимое в учетных данных остается конфиденциальным.HTTP зависит от свойств безопасности базового соединения на уровне транспорта или сеанса, чтобы обеспечить конфиденциальную передачу полей заголовка. Другими словами, если сервер ограничивает доступ для аутентифицированных пользователей, использующих эту структуру, сервер должен гарантировать, что соединение должным образом защищено в соответствии с характером используемой схемы аутентификации. Например, службы, зависящие от аутентификации отдельного пользователя, часто требуют, чтобы соединение было защищено с помощью TLS (&amp;laquo;Безопасность транспортного уровня&amp;raquo;, [службы, зависящие от аутентификации отдельного пользователя, часто требуют, чтобы соединение было защищено с помощью TLS (&amp;laquo;Безопасность транспортного уровня&amp;raquo;, [службы, которые зависят от аутентификации отдельного пользователя, часто требуют, чтобы соединение было защищено с помощью TLS (&amp;laquo;Transport Layer Security&amp;raquo;, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt; ]) перед обменом учетными данными.</target>
        </trans-unit>
        <trans-unit id="d8d09b5015d287016b84da909b78b11d8d4463c3" translate="yes" xml:space="preserve">
          <source>The HTTP conditional request header fields [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;] allow a client
   to place a precondition on the state of the target resource, so that
   the action corresponding to the method semantics will not be applied
   if the precondition evaluates to false.  Each precondition defined by 

   this specification consists of a comparison between a set of
   validators obtained from prior representations of the target resource
   to the current state of validators for the selected representation
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;).  Hence, these preconditions evaluate whether the state
   of the target resource has changed since a given state known by the
   client.  The effect of such an evaluation depends on the method
   semantics and choice of conditional, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;Section&amp;nbsp;5 of
   [RFC7232]&lt;/a&gt;.

   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | If-Match            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC7232]&lt;/a&gt; |
   | If-None-Match       | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7232]&lt;/a&gt; |
   | If-Modified-Since   | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7232]&lt;/a&gt; |
   | If-Unmodified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;Section&amp;nbsp;3.4 of [RFC7232]&lt;/a&gt; |
   | If-Range            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt; |
   +---------------------+--------------------------+</source>
          <target state="translated">Поля заголовка условного запроса HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ] позволяют клиенту помещать предварительное условие в состояние целевого ресурса, так что действие, соответствующее семантике метода, не будет применяться, если предварительное условие оценивается как ложное. Каждое предварительное условие, определенное этой спецификацией, состоит из сравнения между набором валидаторов, полученных из предыдущих представлений целевого ресурса, с текущим состоянием валидаторов для выбранного представления ( &lt;a href=&quot;#section-7.2&quot;&gt;раздел 7.2&lt;/a&gt; ). Следовательно, эти предварительные условия оценивают, изменилось ли состояние целевого ресурса с данного состояния, известного клиенту. Эффект такой оценки зависит от семантики метода и выбора условия, как определено в&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;Раздел 5 [RFC7232]&lt;/a&gt; . + --------------------- + -------------------------- + | Имя поля заголовка | Определено в ... | + --------------------- + -------------------------- + | If-Match | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;Раздел 3.1 [RFC7232]&lt;/a&gt; | | Если-None-Match | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Раздел 3.2 [RFC7232]&lt;/a&gt; | | If-Modified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Раздел 3.3 [RFC7232]&lt;/a&gt; | | If-Unmodified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;Раздел 3.4 [RFC7232]&lt;/a&gt; | | Если-диапазон | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Раздел 3.2 [RFC7233]&lt;/a&gt; | + --------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="db5702e7098e5089b43ae75747b9b4a1f88a17e6" translate="yes" xml:space="preserve">
          <source>The HTTP method being used by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request is not included in the list of methods specified by the response's &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header. This header specifies a comma-delineated list of the HTTP methods which may be used when using CORS to access the URL specified in the request; if the request is using any other method, this error occurs.</source>
          <target state="translated">Метод HTTP, используемый запросом &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS,&lt;/a&gt; не включен в список методов, указанный в заголовке ответа &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; . Этот заголовок определяет разделенный запятыми список методов HTTP, которые могут использоваться при использовании CORS для доступа к URL-адресу, указанному в запросе; если запрос использует какой-либо другой метод, возникает эта ошибка.</target>
        </trans-unit>
        <trans-unit id="9a5f8b591cdf4b19c28a4fbbf2ef71bf29cedf58" translate="yes" xml:space="preserve">
          <source>The HTTP protocol is a request/response protocol. A client sends a
   request to the server in the form of a request method, URI, and
   protocol version, followed by a MIME-like message containing request
   modifiers, client information, and possible body content over a
   connection with a server. The server responds with a status line,
   including the message's protocol version and a success or error code,
   followed by a MIME-like message containing server information, entity
   metainformation, and possible entity-body content. The relationship
   between HTTP and MIME is described in appendix 19.4.

   Most HTTP communication is initiated by a user agent and consists of
   a request to be applied to a resource on some origin server. In the
   simplest case, this may be accomplished via a single connection (v)
   between the user agent (UA) and the origin server (O).

          request chain ------------------------&amp;gt;
       UA -------------------v------------------- O
          &amp;lt;----------------------- response chain

   A more complicated situation occurs when one or more intermediaries
   are present in the request/response chain. There are three common
   forms of intermediary: proxy, gateway, and tunnel. A proxy is a
   forwarding agent, receiving requests for a URI in its absolute form,
   rewriting all or part of the message, and forwarding the reformatted
   request toward the server identified by the URI. A gateway is a
   receiving agent, acting as a layer above some other server(s) and, if
   necessary, translating the requests to the underlying server's
   protocol. A tunnel acts as a relay point between two connections
   without changing the messages; tunnels are used when the
   communication needs to pass through an intermediary (such as a
   firewall) even when the intermediary cannot understand the contents
   of the messages.

          request chain --------------------------------------&amp;gt;
       UA -----v----- A -----v----- B -----v----- C -----v----- O
          &amp;lt;------------------------------------- response chain

   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server. A request or response message that
   travels the whole chain will pass through four separate connections.
   This distinction is important because some HTTP communication options 

   may apply only to the connection with the nearest, non-tunnel
   neighbor, only to the end-points of the chain, or to all connections
   along the chain. Although the diagram is linear, each participant may
   be engaged in multiple, simultaneous communications. For example, B
   may be receiving requests from many clients other than A, and/or
   forwarding requests to servers other than C, at the same time that it
   is handling A's request.

   Any party to the communication which is not acting as a tunnel may
   employ an internal cache for handling requests. The effect of a cache
   is that the request/response chain is shortened if one of the
   participants along the chain has a cached response applicable to that
   request. The following illustrates the resulting chain if B has a
   cached copy of an earlier response from O (via C) for a request which
   has not been cached by UA or A.

          request chain ----------&amp;gt;
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          &amp;lt;--------- response chain

   Not all responses are usefully cacheable, and some requests may
   contain modifiers which place special requirements on cache behavior.
   HTTP requirements for cache behavior and cacheable responses are
   defined in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   In fact, there are a wide variety of architectures and configurations
   of caches and proxies currently being experimented with or deployed
   across the World Wide Web. These systems include national hierarchies
   of proxy caches to save transoceanic bandwidth, systems that
   broadcast or multicast cache entries, organizations that distribute
   subsets of cached data via CD-ROM, and so on. HTTP systems are used
   in corporate intranets over high-bandwidth links, and for access via
   PDAs with low-power radio links and intermittent connectivity. The
   goal of HTTP/1.1 is to support the wide diversity of configurations
   already deployed while introducing protocol constructs that meet the
   needs of those who build web applications that require high
   reliability and, failing that, at least reliable indications of
   failure.

   HTTP communication usually takes place over TCP/IP connections. The
   default port is TCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;], but other ports can be used. This does
   not preclude HTTP from being implemented on top of any other protocol
   on the Internet, or on other networks. HTTP only presumes a reliable
   transport; any protocol that provides such guarantees can be used;
   the mapping of the HTTP/1.1 request and response structures onto the
   transport data units of the protocol in question is outside the scope
   of this specification. 

   In HTTP/1.0, most implementations used a new connection for each
   request/response exchange. In HTTP/1.1, a connection may be used for
   one or more request/response exchanges, although connections may be
   closed for a variety of reasons (see &lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;).</source>
          <target state="translated">Протокол HTTP - это протокол запроса / ответа. Клиент отправляет запрос на сервер в форме метода запроса, URI и версии протокола, за которым следует MIME-подобное сообщение, содержащее модификаторы запроса, информацию о клиенте и возможное содержимое тела через соединение с сервером. Сервер отвечает строкой состояния, включая версию протокола сообщения и код успеха или ошибки, за которым следует MIME-подобное сообщение, содержащее информацию о сервере, метаинформацию объекта и возможное содержимое тела объекта. Связь между HTTP и MIME описана в приложении 19.4. Большинство HTTP-коммуникаций инициируется пользовательским агентом и состоит из запроса, который должен быть применен к ресурсу на каком-либо исходном сервере. В простейшем случаеэто может быть выполнено через одно соединение (v) между пользовательским агентом (UA) и исходным сервером (O). цепочка запросов ------------------------&amp;gt; UA ------------------- v-- ----------------- O &amp;lt;----------------------- цепочка ответов Более сложная ситуация возникает, когда один или несколько посредников присутствуют в цепочке запросов / ответов. Существует три распространенных формы посредника: прокси, шлюз и туннель. Прокси-сервер - это агент пересылки, принимающий запросы на URI в его абсолютной форме, перезаписывающий все или часть сообщения и пересылающий переформатированный запрос на сервер, идентифицированный URI. Шлюз - это агент-получатель, который действует как уровень над некоторыми другими серверами и, при необходимости, транслирует запросы в протокол нижележащего сервера.Туннель действует как точка ретрансляции между двумя соединениями без изменения сообщений; Туннели используются, когда связь должна проходить через посредника (например, брандмауэр), даже если посредник не может понять содержимое сообщений. цепочка запросов --------------------------------------&amp;gt; UA ----- v-- --- A ----- v ----- B ----- v ----- C ----- v ----- O &amp;lt;--------- ---------------------------- Цепочка ответов На рисунке выше показаны три посредника (A, B и C) между пользовательским агентом и источником. сервер. Сообщение запроса или ответа, которое проходит по всей цепочке, проходит через четыре отдельных соединения. Это различие важно, потому что некоторые параметры связи HTTP могут применяться только к соединению с ближайшим соседом, не являющимся туннелем,только к конечным точкам цепочки или ко всем соединениям в цепочке. Хотя диаграмма является линейной, каждый участник может участвовать в нескольких одновременных коммуникациях. Например, B может получать запросы от многих клиентов, отличных от A, и / или пересылать запросы на серверы, отличные от C, в то же время, когда он обрабатывает запрос A. Любая сторона связи, которая не действует как туннель, может использовать внутренний кэш для обработки запросов. Эффект кеширования заключается в том, что цепочка запросов / ответов укорачивается, если один из участников цепочки имеет кэшированный ответ, применимый к этому запросу. Ниже показана результирующая цепочка, если у B есть кэшированная копия более раннего ответа от O (через C) на запрос, который не был кэширован UA или A.цепочка запросов ----------&amp;gt; UA ----- v ----- A ----- v ----- B - - - - - - C - - - - - - O &amp;lt;--------- цепочка ответов Не все ответы можно кэшировать, и некоторые запросы могут содержать модификаторы, которые предъявляют особые требования к поведению кеша. Требования HTTP для поведения кеша и кешируемых ответов определены в&lt;a href=&quot;#section-13&quot;&gt;Раздел 13&lt;/a&gt;, Фактически, существует большое количество разнообразных архитектур и конфигураций кэшей и прокси-серверов, с которыми в настоящее время проводятся эксперименты или развертываются во всемирной паутине. Эти системы включают национальные иерархии прокси-кэшей для сохранения трансокеанской полосы пропускания, системы, которые транслируют или многоадресные записи кэша, организации, которые распространяют подмножества кэшированных данных через CD-ROM, и так далее. Системы HTTP используются в корпоративных интрасетях по каналам с высокой пропускной способностью, а также для доступа через КПК с маломощными радиоканалами и с прерывистой связью. Целью HTTP / 1.1 является поддержка широкого разнообразия уже развернутых конфигураций, при этом вводятся конструкции протоколов, отвечающие потребностям тех, кто создает веб-приложения, требующие высокой надежности и, в противном случае, по крайней мере надежных индикаторов сбоя.Связь HTTP обычно происходит через соединения TCP / IP. Порт по умолчанию - TCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ], но можно использовать и другие порты. Это не препятствует реализации HTTP поверх любого другого протокола в Интернете или других сетях. HTTP предполагает только надежный транспорт; может использоваться любой протокол, который предоставляет такие гарантии; отображение структур запроса и ответа HTTP / 1.1 на транспортные блоки данных рассматриваемого протокола выходит за рамки данной спецификации. В HTTP / 1.0 большинство реализаций использовали новое соединение для каждого обмена запросом / ответом. В HTTP / 1.1 соединение может использоваться для одного или нескольких обменов запросом / ответом, хотя соединения могут быть закрыты по разным причинам (см. &lt;a href=&quot;#section-8.1&quot;&gt;Раздел 8.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="711fba1dbcca7b38687dec5dcf6d2cbe1d22690a" translate="yes" xml:space="preserve">
          <source>The HTTP protocol specifies a request method called &lt;a href=&quot;methods/connect&quot;&gt;&lt;code&gt;CONNECT&lt;/code&gt;&lt;/a&gt;. It starts two-way communications with the requested resource and can be used to open a tunnel. This is how a client behind an HTTP proxy can access websites using SSL (i.e. HTTPS, port 443). Note, however, that not all proxy servers support the &lt;code&gt;CONNECT&lt;/code&gt; method or limit it to port 443 only.</source>
          <target state="translated">Протокол HTTP определяет метод запроса, называемый &lt;a href=&quot;methods/connect&quot;&gt; &lt;code&gt;CONNECT&lt;/code&gt; &lt;/a&gt; . Он запускает двустороннюю связь с запрошенным ресурсом и может использоваться для открытия туннеля. Вот как клиент, находящийся за HTTP-прокси, может получить доступ к веб-сайтам с помощью SSL (например, HTTPS, порт 443). Обратите внимание, однако, что не все прокси-серверы поддерживают метод &lt;code&gt;CONNECT&lt;/code&gt; или ограничивают его только портом 443.</target>
        </trans-unit>
        <trans-unit id="a45670933a882d376a78839281d063695249e118" translate="yes" xml:space="preserve">
          <source>The HTTP protocol used in those early phases was very simple, later dubbed HTTP/0.9, and sometimes as the one-line protocol.</source>
          <target state="translated">Протокол HTTP,используемый на этих ранних этапах,был очень простым,позже получившим название HTTP/0.9,а иногда и однострочным протоколом.</target>
        </trans-unit>
        <trans-unit id="8b8c615279d732a85c03cf31a496dadc0ee7a1e0" translate="yes" xml:space="preserve">
          <source>The HTTP request headers</source>
          <target state="translated">Заголовки HTTP-запросов</target>
        </trans-unit>
        <trans-unit id="dc91001bcd5977c42287ce1ec14f986765b8a528" translate="yes" xml:space="preserve">
          <source>The HTTP response headers</source>
          <target state="translated">Заголовки ответа HTTP</target>
        </trans-unit>
        <trans-unit id="eb8587eac722cc07a0cd8556b058eb4e29c05d63" translate="yes" xml:space="preserve">
          <source>The HTTP status code of the resource on which the global object was instantiated.</source>
          <target state="translated">HTTP код статуса ресурса,на котором был инстанцирован глобальный объект.</target>
        </trans-unit>
        <trans-unit id="7642977e6ce54243574090f3f5103dcd8214c71f" translate="yes" xml:space="preserve">
          <source>The HTTP version used in the request is not supported by the server.</source>
          <target state="translated">Версия HTTP,используемая в запросе,не поддерживается сервером.</target>
        </trans-unit>
        <trans-unit id="0cf1515c8e62f4e6628b5f0c81397855080991ba" translate="yes" xml:space="preserve">
          <source>The HTTP/1.1 standard defines list of the standard headers that start server-driven negotiation (&lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;). Though strictly speaking &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; is not in this list, it is sometimes also used to send a specific representation of the requested resource, though this is not considered as a good practice. The server uses the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header to indicate which headers it actually used for content negotiation (or more precisely the associated response headers), so that &lt;a href=&quot;caching&quot;&gt;caches&lt;/a&gt; can work optimally.</source>
          <target state="translated">Стандарт HTTP / 1.1 определяет список стандартных заголовков, которые запускают согласование на сервере ( &lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; ). Хотя, строго говоря, &lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; отсутствует в этом списке, иногда он также используется для отправки определенного представления запрошенного ресурса, хотя это не считается хорошей практикой. Сервер использует заголовок &lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; ,&lt;/a&gt; чтобы указать, какие заголовки он фактически использовал для согласования содержимого (или, точнее, связанные заголовки ответов), чтобы &lt;a href=&quot;caching&quot;&gt;кеши&lt;/a&gt; могли работать оптимально.</target>
        </trans-unit>
        <trans-unit id="ed9884f0209355d73677c39f7ea1c603c1d343ae" translate="yes" xml:space="preserve">
          <source>The HTTP/2 binary framing mechanism has been designed to not require any alteration of the APIs or config files applied: it is broadly transparent to the user.</source>
          <target state="translated">Механизм бинарного фрейминга HTTP/2 был разработан таким образом,чтобы не требовать изменения применяемых API или конфигурационных файлов:он широко прозрачен для пользователя.</target>
        </trans-unit>
        <trans-unit id="eab0e3a9f6070e36846c5fd400fcb4bef4e35044" translate="yes" xml:space="preserve">
          <source>The HTTP/2 header field encoding allows the expression of names that
   are not valid field names in the Internet Message Syntax used by
   HTTP/1.1.  Requests or responses containing invalid header field
   names MUST be treated as malformed (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).  An
   intermediary therefore cannot translate an HTTP/2 request or response
   containing an invalid field name into an HTTP/1.1 message.

   Similarly, HTTP/2 allows header field values that are not valid.
   While most of the values that can be encoded will not alter header
   field parsing, carriage return (CR, ASCII 0xd), line feed (LF, ASCII
   0xa), and the zero character (NUL, ASCII 0x0) might be exploited by
   an attacker if they are translated verbatim.  Any request or response
   that contains a character not permitted in a header field value MUST
   be treated as malformed (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).  Valid characters are
   defined by the &quot;field-content&quot; ABNF rule in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2a35fa99cfd317dd5558de4b34fa07535768f1" translate="yes" xml:space="preserve">
          <source>The HTTP/2 protocol has several prime differences from the HTTP/1.1 version:</source>
          <target state="translated">Протокол HTTP/2 имеет несколько основных отличий от версии HTTP/1.1:</target>
        </trans-unit>
        <trans-unit id="5ab1960130a01b920907a6e30a6c6e0c01c3afed" translate="yes" xml:space="preserve">
          <source>The HTTP/2 specification is split into four parts:

   o  Starting HTTP/2 (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) covers how an HTTP/2 connection is
      initiated.

   o  The frame (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) and stream (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;) layers describe the
      way HTTP/2 frames are structured and formed into multiplexed
      streams.

   o  Frame (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;) and error (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) definitions include
      details of the frame and error types used in HTTP/2.

   o  HTTP mappings (&lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;) and additional requirements (&lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;)
      describe how HTTP semantics are expressed using frames and
      streams.

   While some of the frame and stream layer concepts are isolated from
   HTTP, this specification does not define a completely generic frame
   layer.  The frame and stream layers are tailored to the needs of the
   HTTP protocol and server push.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fbf8dd0978f7db7e2a91bcbd770cc0ec6b4bcd" translate="yes" xml:space="preserve">
          <source>The Host request-header field specifies the Internet host and port
   number of the resource being requested, as obtained from the original
   URI given by the user or referring resource (generally an HTTP URL, 

   as described in &lt;a href=&quot;#section-3.2.2&quot;&gt;section 3.2.2&lt;/a&gt;). The Host field value MUST represent
   the naming authority of the origin server or gateway given by the
   original URL. This allows the origin server or gateway to
   differentiate between internally-ambiguous URLs, such as the root &quot;/&quot;
   URL of a server for multiple host names on a single IP address.

       Host = &quot;Host&quot; &quot;:&quot; host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-3.2.2&quot;&gt;Section 3.2.2&lt;/a&gt;

   A &quot;host&quot; without any trailing port information implies the default
   port for the service requested (e.g., &quot;80&quot; for an HTTP URL). For
   example, a request on the origin server for
   &amp;lt;&lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;&amp;gt; would properly include:

       GET /pub/WWW/ HTTP/1.1
       Host: www.w3.org

   A client MUST include a Host header field in all HTTP/1.1 request
   messages . If the requested URI does not include an Internet host
   name for the service being requested, then the Host header field MUST
   be given with an empty value. An HTTP/1.1 proxy MUST ensure that any
   request message it forwards does contain an appropriate Host header
   field that identifies the service being requested by the proxy. All
   Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request)
   status code to any HTTP/1.1 request message which lacks a Host header
   field.

   See sections &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; and &lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt; for other requirements relating to
   Host.</source>
          <target state="translated">Поле заголовка запроса Host указывает Интернет-хост и номер порта запрашиваемого ресурса, полученный из исходного URI, предоставленного пользователем или ссылающимся ресурсом (обычно это URL HTTP, как описано в &lt;a href=&quot;#section-3.2.2&quot;&gt;разделе 3.2.2&lt;/a&gt; ). Значение поля Host ДОЛЖНО представлять полномочия по присвоению имен исходного сервера или шлюза, указанные в исходном URL. Это позволяет исходному серверу или шлюзу различать внутренне неоднозначные URL-адреса, такие как корневой URL-адрес &amp;laquo;/&amp;raquo; сервера для нескольких имен хостов на одном IP-адресе. Хост = &quot;Хост&quot; &quot;:&quot; хост [&quot;:&quot; порт]; &lt;a href=&quot;#section-3.2.2&quot;&gt;Раздел 3.2.2&lt;/a&gt; &amp;laquo;Хост&amp;raquo; без какой-либо информации о конечном порте подразумевает порт по умолчанию для запрошенной службы (например, &amp;laquo;80&amp;raquo; для URL-адреса HTTP). Например, запрос на исходном сервере для &amp;lt; &lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;&amp;gt; будет правильно включать: GET / pub / WWW / HTTP / 1.1 Host: www.w3.org Клиент ДОЛЖЕН включать поле заголовка Host во все сообщения запроса HTTP / 1.1. Если запрошенный URI не включает имя Интернет-хоста для запрашиваемой услуги, тогда в поле заголовка Host ДОЛЖНО быть указано пустое значение. Прокси-сервер HTTP / 1.1 ДОЛЖЕН гарантировать, что любое пересылаемое им сообщение запроса содержит соответствующее поле заголовка Host, которое идентифицирует услугу, запрашиваемую прокси-сервером. Все Интернет-серверы HTTP / 1.1 ДОЛЖНЫ отвечать кодом состояния 400 (неверный запрос) на любое сообщение запроса HTTP / 1.1, в котором отсутствует поле заголовка узла. См. Разделы &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; и &lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt; для других требований, относящихся к Хосту.</target>
        </trans-unit>
        <trans-unit id="c397d086f53828c604451e8255fdaa21db19ac88" translate="yes" xml:space="preserve">
          <source>The Host request-header field specifies the Internet host and port
   number of the resource being requested, as obtained from the original
   URI given by the user or referring resource (generally an HTTP URL, 

   as described in &lt;a href=&quot;#section-3.2.2&quot;&gt;section 3.2.2&lt;/a&gt;). The Host field value MUST represent
   the naming authority of the origin server or gateway given by the
   original URL. This allows the origin server or gateway to
   differentiate between internally-ambiguous URLs, such as the root &quot;/&quot;
   URL of a server for multiple host names on a single IP address.

       Host = &quot;Host&quot; &quot;:&quot; host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-3.2.2&quot;&gt;Section 3.2.2&lt;/a&gt;

   A &quot;host&quot; without any trailing port information implies the default
   port for the service requested (e.g., &quot;80&quot; for an HTTP URL). For
   example, a request on the origin server for
   &amp;lt;&lt;a href=&quot;https://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;&amp;gt; would properly include:

       GET /pub/WWW/ HTTP/1.1
       Host: www.w3.org

   A client MUST include a Host header field in all HTTP/1.1 request
   messages . If the requested URI does not include an Internet host
   name for the service being requested, then the Host header field MUST
   be given with an empty value. An HTTP/1.1 proxy MUST ensure that any
   request message it forwards does contain an appropriate Host header
   field that identifies the service being requested by the proxy. All
   Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request)
   status code to any HTTP/1.1 request message which lacks a Host header
   field.

   See sections &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; and &lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt; for other requirements relating to
   Host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1aa4a92939a94846182a9752d0647f06200784" translate="yes" xml:space="preserve">
          <source>The Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA)</source>
          <target state="translated">Протокол управления гипертекстовым кофейником для чайных аппаратов (HTCPCP-TEA).</target>
        </trans-unit>
        <trans-unit id="2fbdae656d9bef10ff135384ea52e37645e6d50f" translate="yes" xml:space="preserve">
          <source>The Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA): Response Codes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1867896c3b2397819388475788a0bf4abcbf5ed6" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request has been accepted for processing, but the processing has not been completed; in fact, processing may not have started yet. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa10aaa19ccd9183c515b022dab356e9181ff7f" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request has been received but not yet acted upon. It is non-committal, meaning that there is no way for the HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">Код состояния ответа &quot; &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; ответ&quot; протокола передачи гипертекста (HTTP) &lt;strong&gt;202&lt;/strong&gt; указывает, что запрос был получен, но еще не обработан. Это не является обязательным, что означает, что HTTP не может позже отправить асинхронный ответ, указывающий на результат обработки запроса. Он предназначен для случаев, когда другой процесс или сервер обрабатывает запрос, или для пакетной обработки.</target>
        </trans-unit>
        <trans-unit id="8da2e56e0326733411c384ee9df3d066f1be28c3" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; redirect status response code указывает, что запрошенный ресурс был окончательно перемещен на URL-адрес, указанный в заголовках &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; . Браузер перенаправляет на эту страницу, и поисковые системы обновляют свои ссылки на ресурс (в &amp;laquo;SEO-слове&amp;raquo; говорится, что &amp;laquo;сок ссылки&amp;raquo; отправляется на новый URL).</target>
        </trans-unit>
        <trans-unit id="bca235dd87a759f1a9dd3bfa9203b6546d063663" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been temporarily moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header. A browser redirects to this page but search engines don't update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is not sent to the new URL).</source>
          <target state="translated">Код ответа состояния переадресации &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; по протоколу передачи гипертекста (HTTP) указывает, что запрошенный ресурс был временно перемещен по URL-адресу, указанному в заголовке &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; . Браузер перенаправляет на эту страницу, но поисковые системы не обновляют свои ссылки на ресурс (в &amp;laquo;SEO-терминологии&amp;raquo; говорится, что &amp;laquo;сок ссылки&amp;raquo; не отправляется на новый URL).</target>
        </trans-unit>
        <trans-unit id="a0dc42b9614cba52b23ba38ea15b1e9d7488ecb2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the redirects don't link to the newly uploaded resources but to another page, like a confirmation page or an upload progress page. This response code is usually sent back as a result of &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;. The method used to display this redirected page is always &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; код ответа состояния перенаправления указывает, что перенаправления ссылаются не на вновь загруженные ресурсы, а на другую страницу, например страницу подтверждения или страницу выполнения загрузки. Этот код ответа обычно отправляется обратно в результате &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; . Для отображения этой перенаправленной страницы всегда используется метод &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d5990b78312268a2a1237e68fb338dd4e8d416f" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the redirects don't link to the newly uploaded resources, but to another page (such as a confirmation page or an upload progress page). This response code is usually sent back as a result of &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;. The method used to display this redirected page is always &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3108347112af1e3d29e6704655c39459a5034ad0" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">Код ответа статуса перенаправления &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; протокола передачи гипертекста (HTTP) &lt;strong&gt;308&lt;/strong&gt; указывает, что запрошенный ресурс был окончательно перемещен по URL-адресу, указанному в заголовках &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; . Браузер перенаправляет на эту страницу, и поисковые системы обновляют свои ссылки на ресурс (в &amp;laquo;SEO-слове&amp;raquo; говорится, что &amp;laquo;сок ссылки&amp;raquo; отправляется на новый URL).</target>
        </trans-unit>
        <trans-unit id="cbd8493e7cce398f69ed55cb6bb5f24186092644" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2055230dbe836c1aaf7bd92cbe0fa85f1440c7fc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server could not understand the request due to invalid syntax.</source>
          <target state="translated">Код состояния ответа &amp;laquo; &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; протокола передачи гипертекста (HTTP) &lt;strong&gt;400&lt;/strong&gt; указывает на то, что сервер не может понять запрос из-за недопустимого синтаксиса.</target>
        </trans-unit>
        <trans-unit id="15ac14cd04fa900b118bba5f014d31ab3bbfe121" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request method is known by the server but is not supported by the target resource.</source>
          <target state="translated">Код состояния ответа &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; протокола передачи гипертекста (HTTP) указывает, что метод запроса известен серверу, но не поддерживается целевым ресурсом.</target>
        </trans-unit>
        <trans-unit id="60871008192002b75675780fc635a2b570a2bf8c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server cannot produce a response matching the list of acceptable values defined in the request's proactive &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; headers, and that the server is unwilling to supply a default representation.</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; client error code response code указывает, что сервер не может создать ответ, соответствующий списку допустимых значений, определенному в заголовках упреждающего &lt;a href=&quot;../content_negotiation&quot;&gt;согласования содержимого&lt;/a&gt; запроса , и что сервер не желает предоставлять представление по умолчанию.</target>
        </trans-unit>
        <trans-unit id="6d70feb7e34e129ebc5526b0c592e1fdbf1c816e" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; response status code means that the server would like to shut down this unused connection. It is sent on an idle connection by some servers, &lt;em&gt;even without any previous request by the client&lt;/em&gt;.</source>
          <target state="translated">Код состояния ответа &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; протокола передачи гипертекста (HTTP) означает, что сервер хотел бы закрыть это неиспользуемое соединение. Некоторые серверы отправляют его при неактивном соединении, &lt;em&gt;даже без предварительного запроса клиента&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a66fb4f3fae8e6c063276dcb5237ee845eeca4ed" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent.</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; клиентского кода ответа на ошибку указывает, что доступ к целевому ресурсу больше не доступен на исходном сервере и что это состояние, вероятно, будет постоянным.</target>
        </trans-unit>
        <trans-unit id="4b9a35e682079b0a683f989a76db71ce57aae81d" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request without a defined &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Код ответа клиента на ошибку &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; протокола передачи гипертекста (HTTP) указывает, что сервер отказывается принять запрос без определенного заголовка &lt;a href=&quot;../headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="731510b854954129731e069eb6b3d2e9019b2fdc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource has been denied. This happens with conditional requests on methods other than &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; when the condition defined by the &lt;a href=&quot;../headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; headers is not fulfilled. In that case, the request, usually an upload or a modification of a resource, cannot be made and this error response is sent back.</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; client error response code указывает, что доступ к целевому ресурсу был запрещен. Это происходит с условными запросами к методам, отличным от &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; ,&lt;/a&gt; когда условие, определенное заголовками &lt;a href=&quot;../headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; ,&lt;/a&gt; не выполняется. В этом случае запрос, обычно загрузка или изменение ресурса, не может быть выполнен, и этот ответ об ошибке отправляется обратно.</target>
        </trans-unit>
        <trans-unit id="95dad23f3e8d87cfe4b0b1791422ccff7fdb0ec9" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; error response code indicates that a server cannot serve the requested ranges. The most likely reason is that the document doesn't contain such ranges, or that the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header value, though syntactically correct, doesn't make sense.</source>
          <target state="translated">Код ответа об ошибке протокола передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; указывает, что сервер не может обслуживать запрошенные диапазоны. Наиболее вероятная причина заключается в том, что документ не содержит таких диапазонов или что значение заголовка &lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; , хотя и синтаксически правильное, не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="99f1059b5dc6332a65c7949a31d1b45cbce33ed7" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server understands the content type of the request entity, and the syntax of the request entity is correct, but it was unable to process the contained instructions.</source>
          <target state="translated">Код состояния ответа &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; протокола передачи гипертекста (HTTP) указывает, что сервер понимает тип контента сущности запроса и синтаксис сущности запроса правильный, но он не смог обработать содержащиеся инструкции.</target>
        </trans-unit>
        <trans-unit id="630618c062b0adb0b4e53d21c6ec93a1ffc8709b" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to risk processing a request that might be replayed, which creates the potential for a replay attack.</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; код состояния ответа указывает, что сервер не желает рисковать обработкой запроса, который может быть воспроизведен, что создает возможность для атаки повторного воспроизведения.</target>
        </trans-unit>
        <trans-unit id="2ba79c25bd016d25902460c531a9af1832ad5084" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the user requested a resource that is not available due to legal reasons, such as a web page for which a legal action has been issued.</source>
          <target state="translated">Код ответа об ошибке клиента протокола передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; указывает на то, что пользователь запросил ресурс, который недоступен по юридическим причинам, например веб-страницу, в отношении которой был возбужден судебный иск.</target>
        </trans-unit>
        <trans-unit id="b137e360e4b5274b152a6bc5424bdda215ece645" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.</source>
          <target state="translated">Код ответа сервера на &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; сервера HyperText Transfer Protocol (HTTP) &lt;strong&gt;500&lt;/strong&gt; указывает на то, что сервер обнаружил непредвиденное условие, которое не позволило ему выполнить запрос.</target>
        </trans-unit>
        <trans-unit id="9c744578cdc0d9bb57ba2e4e4ab0fa07c99379e2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Код ответа сервера с ошибкой &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; протоколу передачи гипертекста (HTTP) указывает, что метод запроса не поддерживается сервером и не может быть обработан. Единственные методы, которые серверы должны поддерживать (и, следовательно, не должны возвращать этот код), - это &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1db14053efdc5b849d20c165c505ccbdce0af60c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; server error response code means that &lt;strong&gt;the server does not support the functionality required to fulfill the request&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56e521d7943d1bf8ac9d8be1e1d2c5a9c11ad29" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, received an invalid response from the upstream server.</source>
          <target state="translated">Код ответа на ошибку сервера &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; по протоколу передачи гипертекста (HTTP) указывает, что сервер, выступая в качестве шлюза или прокси-сервера, получил недопустимый ответ от вышестоящего сервера.</target>
        </trans-unit>
        <trans-unit id="d97095b9bce2f7dabb2319cf5e31ce5cd055c7fe" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server is not ready to handle the request.</source>
          <target state="translated">Код ответа сервера протокола передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; указывает на то, что сервер не готов обработать запрос.</target>
        </trans-unit>
        <trans-unit id="ed70120131ebb0a274691c4d30386f6dc8fc669c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, cannot get a response in time.</source>
          <target state="translated">Код ответа на ошибку сервера протокола передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; указывает на то, что сервер, действуя как шлюз или прокси, не может получить ответ вовремя.</target>
        </trans-unit>
        <trans-unit id="a75a514de375190ba5cb2f8574ec6665fc8a648c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, did not get a response in time from the upstream server that it needed in order to complete the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5206e7fbe439a4fe0558730cbd561b9d56ad71ad" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; response status code indicates that the HTTP version used in the request is not supported by the server.</source>
          <target state="translated">Код состояния ответа протокола передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; указывает, что версия HTTP, используемая в запросе, не поддерживается сервером.</target>
        </trans-unit>
        <trans-unit id="49ce1d6f6a8be4676edf766aee4540297f25f76a" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;506 Variant Also Negotiates&lt;/strong&gt;&lt;/code&gt; response status code may be given in the context of Transparent Content Negotiation (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC 2295&lt;/a&gt;). This protocol enables a client to retrieve the best variant of a given resource, where the server supports multiple variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="820e5cef7a998998b0849eeb24e0fff1b6649bae" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;507 Insufficient Storage&lt;/strong&gt;&lt;/code&gt; response status code may be given in the context of the Web Distributed Authoring and Versioning (WebDAV) protocol (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC 4918&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d88c87ab8a315a60aa9543690290ffbfbdb653" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;508 Loop Detected&lt;/strong&gt;&lt;/code&gt; response status code may be given in the context of the Web Distributed Authoring and Versioning (WebDAV) protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81aa286d5750f499d27f8f17321bc45f7f2ca1f1" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;510 Not Extended&lt;/strong&gt;&lt;/code&gt; response status code is sent in the context of the HTTP Extension Framework, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC 2774&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3eb482b38eeaa5e40d4ddbab8b13b92a13f7fd" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level request/response protocol that uses extensible semantics and
   self-descriptive message payloads for flexible interaction with
   network-based hypertext information systems.  This document is the
   first in a series of documents that collectively form the HTTP/1.1
   specification:

   1.  &quot;Message Syntax and Routing&quot; (this document)

   2.  &quot;Semantics and Content&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]

   3.  &quot;Conditional Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]

   4.  &quot;Range Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]

   5.  &quot;Caching&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]

   6.  &quot;Authentication&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;]

   This HTTP/1.1 specification obsoletes &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; (on HTTP
   versioning).  This specification also updates the use of CONNECT to
   establish a tunnel, previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;, and defines the
   &quot;https&quot; URI scheme that was described informally in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;.

   HTTP is a generic interface protocol for information systems.  It is
   designed to hide the details of how a service is implemented by
   presenting a uniform interface to clients that is independent of the
   types of resources provided.  Likewise, servers do not need to be
   aware of each client's purpose: an HTTP request can be considered in
   isolation rather than being associated with a specific type of client
   or a predetermined sequence of application steps.  The result is a
   protocol that can be used effectively in many different contexts and
   for which implementations can evolve independently over time.

   HTTP is also designed for use as an intermediation protocol for
   translating communication to and from non-HTTP information systems.
   HTTP proxies and gateways can provide access to alternative
   information services by translating their diverse protocols into a
   hypertext format that can be viewed and manipulated by clients in the
   same way as HTTP services.

   One consequence of this flexibility is that the protocol cannot be
   defined in terms of what occurs behind the interface.  Instead, we
   are limited to defining the syntax of communication, the intent of
   received communication, and the expected behavior of recipients.  If
   the communication is considered in isolation, then successful actions 

   ought to be reflected in corresponding changes to the observable
   interface provided by servers.  However, since multiple clients might
   act in parallel and perhaps at cross-purposes, we cannot require that
   such changes be observable beyond the scope of a single response.

   This document describes the architectural elements that are used or
   referred to in HTTP, defines the &quot;http&quot; and &quot;https&quot; URI schemes,
   describes overall network operation and connection management, and
   defines HTTP message framing and forwarding requirements.  Our goal
   is to define all of the mechanisms necessary for HTTP message
   handling that are independent of message semantics, thereby defining
   the complete set of requirements for message parsers and message-
   forwarding intermediaries.</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) - это протокол запроса / ответа уровня приложения без сохранения состояния, который использует расширяемую семантику и полезные данные самоописательных сообщений для гибкого взаимодействия с сетевыми гипертекстовыми информационными системами. Этот документ является первым в серии документов, которые вместе составляют спецификацию HTTP / 1.1: 1. &amp;laquo;Синтаксис сообщений и маршрутизация&amp;raquo; (этот документ) 2. &amp;laquo;Семантика и контент&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 3. &amp;laquo;Условные запросы&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ] 4. &amp;laquo;Запросы диапазона&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ] 5. &amp;laquo;Кэширование&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ] 6. &amp;laquo;Аутентификация&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ] Это HTTP / 1.1 спецификация устарела &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; и &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;(при управлении версиями HTTP). Эта спецификация также обновляет использование CONNECT для установления туннеля, ранее определенное в &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt; , и определяет схему URI &amp;laquo;https&amp;raquo;, которая неформально описана в &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818.&lt;/a&gt;, HTTP - это общий протокол интерфейса для информационных систем. Он разработан, чтобы скрыть детали того, как реализована служба, путем предоставления клиентам единого интерфейса, который не зависит от типов предоставляемых ресурсов. Точно так же серверам не нужно знать цель каждого клиента: HTTP-запрос можно рассматривать изолированно, а не связывать его с конкретным типом клиента или заранее определенной последовательностью шагов приложения. Результатом является протокол, который можно эффективно использовать во многих различных контекстах, и реализации которого могут развиваться независимо с течением времени. HTTP также разработан для использования в качестве протокола-посредника для передачи сообщений в информационные системы, отличные от HTTP, и обратно.Прокси-серверы и шлюзы HTTP могут предоставлять доступ к альтернативным информационным службам, переводя их различные протоколы в гипертекстовый формат, который клиенты могут просматривать и управлять ими так же, как и службы HTTP. Одним из следствий этой гибкости является то, что протокол не может быть определен в терминах того, что происходит за интерфейсом. Вместо этого мы ограничены определением синтаксиса общения, цели полученного сообщения и ожидаемого поведения получателей. Если связь рассматривается изолированно, то успешные действия должны отражаться в соответствующих изменениях наблюдаемого интерфейса, предоставляемого серверами. Однако, поскольку несколько клиентов могут действовать параллельно и, возможно, в разных целях,мы не можем требовать, чтобы такие изменения наблюдались вне рамок единственного ответа. Этот документ описывает архитектурные элементы, которые используются или упоминаются в HTTP, определяет схемы URI &amp;laquo;http&amp;raquo; и &amp;laquo;https&amp;raquo;, описывает общую работу сети и управление соединением, а также определяет требования к кадрированию и пересылке сообщений HTTP. Наша цель - определить все механизмы, необходимые для обработки сообщений HTTP, которые не зависят от семантики сообщения, тем самым определяя полный набор требований к анализаторам сообщений и посредникам для пересылки сообщений.описывает общую работу сети и управление соединениями, а также определяет требования к кадрированию и пересылке HTTP-сообщений. Наша цель - определить все механизмы, необходимые для обработки сообщений HTTP, которые не зависят от семантики сообщения, тем самым определяя полный набор требований к анализаторам сообщений и посредникам для пересылки сообщений.описывает общую работу сети и управление соединениями, а также определяет требования к кадрированию и пересылке HTTP-сообщений. Наша цель - определить все механизмы, необходимые для обработки сообщений HTTP, которые не зависят от семантики сообщения, тем самым определяя полный набор требований к анализаторам сообщений и посредникам, пересылающим сообщения.</target>
        </trans-unit>
        <trans-unit id="265e7d56ba5f2b7320f23766ef7d78d6049d252e" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is a wildly successful
   protocol.  However, the way HTTP/1.1 uses the underlying transport
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6&quot;&gt;[RFC7230], Section&amp;nbsp;6&lt;/a&gt;) has several characteristics that have a
   negative overall effect on application performance today.

   In particular, HTTP/1.0 allowed only one request to be outstanding at
   a time on a given TCP connection.  HTTP/1.1 added request pipelining,
   but this only partially addressed request concurrency and still
   suffers from head-of-line blocking.  Therefore, HTTP/1.0 and HTTP/1.1
   clients that need to make many requests use multiple connections to a
   server in order to achieve concurrency and thereby reduce latency.

   Furthermore, HTTP header fields are often repetitive and verbose,
   causing unnecessary network traffic as well as causing the initial
   TCP [&lt;a href=&quot;#ref-TCP&quot;&gt;TCP&lt;/a&gt;] congestion window to quickly fill.  This can result in
   excessive latency when multiple requests are made on a new TCP
   connection.

   HTTP/2 addresses these issues by defining an optimized mapping of
   HTTP's semantics to an underlying connection.  Specifically, it
   allows interleaving of request and response messages on the same
   connection and uses an efficient coding for HTTP header fields.  It
   also allows prioritization of requests, letting more important
   requests complete more quickly, further improving performance. 

   The resulting protocol is more friendly to the network because fewer
   TCP connections can be used in comparison to HTTP/1.x.  This means
   less competition with other flows and longer-lived connections, which
   in turn lead to better utilization of available network capacity.

   Finally, HTTP/2 also enables more efficient processing of messages
   through use of binary message framing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfba6f949d10bf9871b3c465a4b0c721c894d894" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. HTTP has been in use by the World-Wide Web global
   information initiative since 1990. The first version of HTTP,
   referred to as HTTP/0.9, was a simple protocol for raw data transfer
   across the Internet. HTTP/1.0, as defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; [&lt;a href=&quot;#ref-6&quot;&gt;6&lt;/a&gt;], improved
   the protocol by allowing messages to be in the format of MIME-like
   messages, containing metainformation about the data transferred and
   modifiers on the request/response semantics. However, HTTP/1.0 does
   not sufficiently take into consideration the effects of hierarchical
   proxies, caching, the need for persistent connections, or virtual
   hosts. In addition, the proliferation of incompletely-implemented
   applications calling themselves &quot;HTTP/1.0&quot; has necessitated a
   protocol version change in order for two communicating applications
   to determine each other's true capabilities.

   This specification defines the protocol referred to as &quot;HTTP/1.1&quot;.
   This protocol includes more stringent requirements than HTTP/1.0 in
   order to ensure reliable implementation of its features.

   Practical information systems require more functionality than simple
   retrieval, including search, front-end update, and annotation. HTTP
   allows an open-ended set of methods and headers that indicate the
   purpose of a request [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt;]. It builds on the discipline of reference
   provided by the Uniform Resource Identifier (URI) [&lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt;], as a location
   (URL) [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] or name (URN) [&lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt;], for indicating the resource to which a 

   method is to be applied. Messages are passed in a format similar to
   that used by Internet mail [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as defined by the Multipurpose
   Internet Mail Extensions (MIME) [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;].

   HTTP is also used as a generic protocol for communication between
   user agents and proxies/gateways to other Internet systems, including
   those supported by the SMTP [&lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt;], NNTP [&lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt;], FTP [&lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt;], Gopher [&lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt;],
   and WAIS [&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt;] protocols. In this way, HTTP allows basic hypermedia
   access to resources available from diverse applications.</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) - это протокол прикладного уровня для распределенных, совместных гипермедийных информационных систем. HTTP используется глобальной информационной инициативой World-Wide Web с 1990 года. Первая версия HTTP, называемая HTTP / 0.9, была простым протоколом для передачи необработанных данных через Интернет. HTTP / 1.0, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; [ &lt;a href=&quot;#ref-6&quot;&gt;6&lt;/a&gt;], улучшил протокол, позволив сообщениям быть в формате MIME-подобных сообщений, содержащих метаинформацию о передаваемых данных и модификаторы семантики запроса / ответа. Однако HTTP / 1.0 недостаточно учитывает влияние иерархических прокси, кэширования, необходимости постоянных подключений или виртуальных хостов. Кроме того, распространение не полностью реализованных приложений, называющих себя &amp;laquo;HTTP / 1.0&amp;raquo;, потребовало изменения версии протокола, чтобы два взаимодействующих приложения могли определять истинные возможности друг друга. Эта спецификация определяет протокол, называемый &amp;laquo;HTTP / 1.1&amp;raquo;. Этот протокол включает более строгие требования, чем HTTP / 1.0, для обеспечения надежной реализации его функций.Практические информационные системы требуют большей функциональности, чем простой поиск, включая поиск, обновление интерфейса и аннотации. HTTP позволяет использовать открытый набор методов и заголовков, которые указывают цель запроса [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt; ]. Он основан на дисциплине ссылки, обеспечиваемой унифицированным идентификатором ресурса (URI) [ &lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt; ] в виде местоположения (URL) [ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ] или имени (URN) [ &lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt; ], для указания ресурса, к которому должен применяться метод. , Сообщения передаются в формате, аналогичном формату, используемому почтой Интернета [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ], как определено в многоцелевых расширениях электронной почты Интернета (MIME) [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]. HTTP также используется как общий протокол для связи между пользовательскими агентами и прокси / шлюзами с другими системами Интернета, включая те, которые поддерживаются SMTP [ &lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt; ], NNTP [ &lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt; ], FTP [ &lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt; ], Gopher [ &lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt; ] и WAIS [&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt; ] протоколы. Таким образом, HTTP обеспечивает базовый доступ гипермедиа к ресурсам, доступным из различных приложений.</target>
        </trans-unit>
        <trans-unit id="1a129c42494254f3f39028a252991104523d52ce" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol Status Code 308 (Permanent Redirect)</source>
          <target state="translated">Статус протокола гипертекстовой передачи Код 308 (постоянная переадресация)</target>
        </trans-unit>
        <trans-unit id="7c3eef52124b6a04770da43e5780935c839f5a5d" translate="yes" xml:space="preserve">
          <source>The IP address is invalid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eeb9098fe0eb68f08e0d43612ff763509c93784" translate="yes" xml:space="preserve">
          <source>The IP address is unreachable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f67a1bb61a74c01a68383ec9ae389f39adb9d3d" translate="yes" xml:space="preserve">
          <source>The If header has two distinct purposes:

   o  The first purpose is to make a request conditional by supplying a
      series of state lists with conditions that match tokens and ETags
      to a specific resource.  If this header is evaluated and all state
      lists fail, then the request MUST fail with a 412 (Precondition
      Failed) status.  On the other hand, the request can succeed only
      if one of the described state lists succeeds.  The success
      criteria for state lists and matching functions are defined in
      Sections &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; and &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;.

   o  Additionally, the mere fact that a state token appears in an If
      header means that it has been &quot;submitted&quot; with the request.  In
      general, this is used to indicate that the client has knowledge of
      that state token.  The semantics for submitting a state token
      depend on its type (for lock tokens, please refer to &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).

   Note that these two purposes need to be treated distinctly: a state
   token counts as being submitted independently of whether the server
   actually has evaluated the state list it appears in, and also
   independently of whether or not the condition it expressed was found
   to be true.</source>
          <target state="translated">Заголовок If имеет две различные цели: o Первая цель - сделать запрос условным, предоставив серию списков состояний с условиями, которые соответствуют токенам и тегам ETag для определенного ресурса. Если этот заголовок оценивается и все списки состояний терпят неудачу, то запрос ДОЛЖЕН завершиться неудачей со статусом 412 (Precondition Failed). С другой стороны, запрос может быть успешным только в случае успешного выполнения одного из описанных списков состояний. Критерии успеха для списков состояний и функций сопоставления определены в разделах &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; и &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4.&lt;/a&gt;, o Кроме того, тот факт, что маркер состояния появляется в заголовке If, означает, что он был &amp;laquo;отправлен&amp;raquo; вместе с запросом. Обычно это используется, чтобы указать, что клиент знает этот токен состояния. Семантика отправки токена состояния зависит от его типа (токены блокировки см. В &lt;a href=&quot;#section-6&quot;&gt;разделе 6&lt;/a&gt; ). Обратите внимание, что эти две цели необходимо рассматривать отдельно: маркер состояния считается отправленным независимо от того, действительно ли сервер оценил список состояний, в котором он отображается, а также независимо от того, было ли обнаружено, что условие, которое он выражает, истинным.</target>
        </trans-unit>
        <trans-unit id="ef772a237bb19f58e37ac6262a206108449c06a7" translate="yes" xml:space="preserve">
          <source>The If request header is intended to have similar functionality to
   the If-Match header defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;Section&amp;nbsp;14.24 of [RFC2616]&lt;/a&gt;.  However,
   the If header handles any state token as well as ETags.  A typical
   example of a state token is a lock token, and lock tokens are the
   only state tokens defined in this specification.</source>
          <target state="translated">Заголовок запроса If должен иметь функциональность, аналогичную заголовку If-Match, определенному в &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;разделе 14.24 [RFC2616]&lt;/a&gt; . Однако заголовок If обрабатывает любой токен состояния, а также теги ETag. Типичным примером токена состояния является токен блокировки, и токены блокировки являются единственными токенами состояния, определенными в этой спецификации.</target>
        </trans-unit>
        <trans-unit id="f13702c8c2a26258beb9827d9b24d567b0373ca0" translate="yes" xml:space="preserve">
          <source>The If-Match request-header field is used with a method to make it
   conditional. A client that has one or more entities previously
   obtained from the resource can verify that one of those entities is
   current by including a list of their associated entity tags in the
   If-Match header field. Entity tags are defined in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The
   purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead. It is also
   used, on updating requests, to prevent inadvertent modification of
   the wrong version of a resource. As a special case, the value &quot;*&quot;
   matches any current entity of the resource.

       If-Match = &quot;If-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-Match header) on that resource, or if &quot;*&quot; is given 

   and any current entity exists for that resource, then the server MAY
   perform the requested method as if the If-Match header field did not
   exist.

   A server MUST use the strong comparison function (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;)
   to compare the entity tags in If-Match.

   If none of the entity tags match, or if &quot;*&quot; is given and no current
   entity exists, the server MUST NOT perform the requested method, and
   MUST return a 412 (Precondition Failed) response. This behavior is
   most useful when the client wants to prevent an updating method, such
   as PUT, from modifying a resource that has changed since the client
   last retrieved it.

   If the request would, without the If-Match header field, result in
   anything other than a 2xx or 412 status, then the If-Match header
   MUST be ignored.

   The meaning of &quot;If-Match: *&quot; is that the method SHOULD be performed
   if the representation selected by the origin server (or by a cache,
   possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;) exists, and
   MUST NOT be performed if the representation does not exist.

   A request intended to update a resource (e.g., a PUT) MAY include an
   If-Match header field to signal that the request method MUST NOT be
   applied if the entity corresponding to the If-Match value (a single
   entity tag) is no longer a representation of that resource. This
   allows the user to indicate that they do not wish the request to be
   successful if the resource has been changed without their knowledge.
   Examples:

       If-Match: &quot;xyzzy&quot;
       If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-Match: *

   The result of a request having both an If-Match header field and
   either an If-None-Match or an If-Modified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">Поле заголовка запроса If-Match используется с методом, чтобы сделать его условным. Клиент, у которого есть одна или несколько сущностей, ранее полученных из ресурса, может проверить, что одна из этих сущностей является текущей, включив список связанных с ними тегов сущностей в поле заголовка If-Match. Теги сущностей определены в &lt;a href=&quot;#section-3.11&quot;&gt;разделе 3.11.&lt;/a&gt;, Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Он также используется при обновлении запросов, чтобы предотвратить непреднамеренное изменение неправильной версии ресурса. В качестве особого случая значение &amp;laquo;*&amp;raquo; соответствует любой текущей сущности ресурса. If-Match = &quot;If-Match&quot; &quot;:&quot; (&quot;*&quot; | 1 # entity-tag) Если какой-либо из тегов объекта соответствует тегу объекта объекта, который был бы возвращен в ответе на аналогичный запрос GET ( без заголовка If-Match) на этом ресурсе, или если задан &quot;*&quot; и для этого ресурса существует какой-либо текущий объект, то сервер МОЖЕТ выполнить запрошенный метод, как если бы поле заголовка If-Match не существовало.Сервер ДОЛЖЕН использовать функцию &lt;a href=&quot;#section-13.3.3&quot;&gt;строгого сравнения (см. Раздел 13.3.3.&lt;/a&gt;) для сравнения тегов сущностей в If-Match. Если ни один из тегов объекта не совпадает, или если дан &quot;*&quot; и текущий объект не существует, сервер НЕ ДОЛЖЕН выполнять запрошенный метод и ДОЛЖЕН возвращать ответ 412 (Precondition Failed). Это поведение наиболее полезно, когда клиент хочет запретить методу обновления, например PUT, изменять ресурс, который изменился с момента его последнего получения клиентом. Если запрос без поля заголовка If-Match приведет к чему-либо, кроме статуса 2xx или 412, то заголовок If-Match ДОЛЖЕН игнорироваться. Значение &amp;laquo;If-Match: *&amp;raquo; состоит в том, что метод ДОЛЖЕН выполняться, если представление, выбранное исходным сервером (или кешем, возможно с использованием механизма Vary, см. &lt;a href=&quot;#section-14.44&quot;&gt;Раздел 14.44).&lt;/a&gt;) существует и НЕ ДОЛЖЕН выполняться, если представление не существует. Запрос, предназначенный для обновления ресурса (например, PUT), МОЖЕТ включать поле заголовка If-Match, чтобы сигнализировать, что метод запроса НЕ ДОЛЖЕН применяться, если объект, соответствующий значению If-Match (одиночный тег объекта), больше не представление этого ресурса. Это позволяет пользователю указать, что он не хочет, чтобы запрос был успешным, если ресурс был изменен без его ведома. Примеры: If-Match: &quot;xyzzy&quot; If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot; If-Match: * Результат запроса, имеющего как поле заголовка If-Match, так и либо If-None-Match или поля заголовка If-Modified-Since не определены этой спецификацией.</target>
        </trans-unit>
        <trans-unit id="9436a493b897cd39a84206566701a405b2d51016" translate="yes" xml:space="preserve">
          <source>The If-Modified-Since request-header field is used with a method to
   make it conditional: if the requested variant has not been modified
   since the time specified in this field, an entity will not be
   returned from the server; instead, a 304 (not modified) response will
   be returned without any message-body.

       If-Modified-Since = &quot;If-Modified-Since&quot; &quot;:&quot; HTTP-date 

   An example of the field is:

       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A GET method with an If-Modified-Since header and no Range header
   requests that the identified entity be transferred only if it has
   been modified since the date given by the If-Modified-Since header.
   The algorithm for determining this includes the following cases:

      a) If the request would normally result in anything other than a
         200 (OK) status, or if the passed If-Modified-Since date is
         invalid, the response is exactly the same as for a normal GET.
         A date which is later than the server's current time is
         invalid.

      b) If the variant has been modified since the If-Modified-Since
         date, the response is exactly the same as for a normal GET.

      c) If the variant has not been modified since a valid If-
         Modified-Since date, the server SHOULD return a 304 (Not
         Modified) response.

   The purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead.

      Note: The Range request-header field modifies the meaning of If-
      Modified-Since; see &lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt; for full details.

      Note: If-Modified-Since times are interpreted by the server, whose
      clock might not be synchronized with the client.

      Note: When handling an If-Modified-Since header field, some
      servers will use an exact date comparison function, rather than a
      less-than function, for deciding whether to send a 304 (Not
      Modified) response. To get best results when sending an If-
      Modified-Since header field for cache validation, clients are
      advised to use the exact date string received in a previous Last-
      Modified header field whenever possible.

      Note: If a client uses an arbitrary date in the If-Modified-Since
      header instead of a date taken from the Last-Modified header for
      the same request, the client should be aware of the fact that this
      date is interpreted in the server's understanding of time. The
      client should consider unsynchronized clocks and rounding problems
      due to the different encodings of time between the client and
      server. This includes the possibility of race conditions if the
      document has changed between the time it was first requested and
      the If-Modified-Since date of a subsequent request, and the 

      possibility of clock-skew-related problems if the If-Modified-
      Since date is derived from the client's clock without correction
      to the server's clock. Corrections for different time bases
      between client and server are at best approximate due to network
      latency.

   The result of a request having both an If-Modified-Since header field
   and either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">Поле заголовка запроса If-Modified-Since используется с методом, делающим его условным: если запрошенный вариант не был изменен с момента времени, указанного в этом поле, объект не будет возвращен с сервера; вместо этого будет возвращен ответ 304 (не измененный) без тела сообщения. If-Modified-Since = &quot;If-Modified-Since&quot; &quot;:&quot; HTTP-date Пример поля: If-Modified-Since: Сб, 29 октября 1994 г., 19:43:31 GMT Метод GET с If- Заголовок Modified-Since и заголовок no Range запрашивают передачу идентифицированного объекта, только если он был изменен с даты, указанной в заголовке If-Modified-Since. Алгоритм определения этого включает следующие случаи:a) Если запрос обычно приводит к чему-либо, кроме состояния 200 (OK), или если переданная дата If-Modified-Since недействительна, ответ будет таким же, как и для обычного GET. Дата, более поздняя, ​​чем текущее время сервера, недействительна. б) Если вариант был изменен после даты If-Modified-Since, ответ будет таким же, как и для обычного GET. c) Если вариант не был изменен после действительной даты If-Modified-Since, серверу СЛЕДУЕТ вернуть ответ 304 (Not Modified). Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Примечание. Поле заголовка запроса Range изменяет значение If-Modified-Since; видетьили если переданная дата If-Modified-Since недействительна, ответ будет таким же, как и для обычного GET. Дата, более поздняя, ​​чем текущее время сервера, недействительна. б) Если вариант был изменен после даты If-Modified-Since, ответ будет таким же, как и для обычного GET. c) Если вариант не был изменен после действительной даты If-Modified-Since, серверу СЛЕДУЕТ вернуть ответ 304 (Not Modified). Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Примечание. Поле заголовка запроса Range изменяет значение If-Modified-Since; видетьили если переданная дата If-Modified-Since недействительна, ответ будет таким же, как и для обычного GET. Дата, более поздняя, ​​чем текущее время сервера, недействительна. б) Если вариант был изменен после даты If-Modified-Since, ответ будет таким же, как и для обычного GET. c) Если вариант не был изменен после действительной даты If-Modified-Since, серверу СЛЕДУЕТ вернуть ответ 304 (Not Modified). Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальными затратами на транзакции. Примечание. Поле заголовка запроса Range изменяет значение If-Modified-Since; видетьДата, более поздняя, ​​чем текущее время сервера, недействительна. б) Если вариант был изменен после даты If-Modified-Since, ответ будет таким же, как и для обычного GET. c) Если вариант не был изменен с момента действительной даты If-Modified-Since, сервер ДОЛЖЕН вернуть ответ 304 (Not Modified). Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Примечание. Поле заголовка запроса Range изменяет значение If-Modified-Since; видетьДата, более поздняя, ​​чем текущее время сервера, недействительна. б) Если вариант был изменен после даты If-Modified-Since, ответ будет таким же, как и для обычного GET. c) Если вариант не был изменен после действительной даты If-Modified-Since, серверу СЛЕДУЕТ вернуть ответ 304 (Not Modified). Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Примечание. Поле заголовка запроса Range изменяет значение If-Modified-Since; видетьc) Если вариант не был изменен после действительной даты If-Modified-Since, серверу СЛЕДУЕТ вернуть ответ 304 (Not Modified). Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Примечание. Поле заголовка запроса Range изменяет значение If-Modified-Since; видетьc) Если вариант не был изменен после действительной даты If-Modified-Since, серверу СЛЕДУЕТ вернуть ответ 304 (Not Modified). Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Примечание. Поле заголовка запроса Range изменяет значение If-Modified-Since; видеть&lt;a href=&quot;#section-14.35&quot;&gt;Раздел 14.35&lt;/a&gt;для получения полной информации. Примечание. Время If-Modified-Since интерпретируется сервером, часы которого могут не синхронизироваться с клиентом. Примечание. При обработке поля заголовка If-Modified-Since некоторые серверы будут использовать функцию сравнения точных дат, а не функцию &amp;laquo;меньше чем&amp;raquo;, чтобы решить, отправлять ли ответ 304 (Not Modified). Чтобы получить наилучшие результаты при отправке поля заголовка If-Modified-Since для проверки кэша, клиентам рекомендуется по возможности использовать строку с точной датой, полученную в предыдущем поле заголовка Last-Modified. Примечание. Если клиент использует произвольную дату в заголовке If-Modified-Since вместо даты, взятой из заголовка Last-Modified для того же запроса,клиент должен знать, что эта дата интерпретируется в понимании времени сервером. Клиент должен учитывать несинхронизированные часы и проблемы с округлением из-за различий в кодировании времени между клиентом и сервером. Это включает в себя возможность состояний гонки, если документ был изменен между временем, когда он был впервые запрошен, и датой If-Modified-Since последующего запроса, а также возможность проблем, связанных со сдвигом часов, если дата If-Modified-Since выводится из часов клиента без поправки на часы сервера. Корректировки для разных временных баз между клиентом и сервером в лучшем случае приблизительны из-за задержки в сети.Результат запроса, имеющего как поле заголовка If-Modified-Since, так и поля заголовка If-Match или If-Unmodified-Since, не определен данной спецификацией.</target>
        </trans-unit>
        <trans-unit id="39e92741a96fab5452a65a932345457528d34e55" translate="yes" xml:space="preserve">
          <source>The If-None-Match request-header field is used with a method to make
   it conditional. A client that has one or more entities previously
   obtained from the resource can verify that none of those entities is
   current by including a list of their associated entity tags in the
   If-None-Match header field. The purpose of this feature is to allow
   efficient updates of cached information with a minimum amount of
   transaction overhead. It is also used to prevent a method (e.g. PUT)
   from inadvertently modifying an existing resource when the client
   believes that the resource does not exist.

   As a special case, the value &quot;*&quot; matches any current entity of the
   resource.

       If-None-Match = &quot;If-None-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-None-Match header) on that resource, or if &quot;*&quot; is
   given and any current entity exists for that resource, then the
   server MUST NOT perform the requested method, unless required to do
   so because the resource's modification date fails to match that
   supplied in an If-Modified-Since header field in the request.
   Instead, if the request method was GET or HEAD, the server SHOULD
   respond with a 304 (Not Modified) response, including the cache-
   related header fields (particularly ETag) of one of the entities that
   matched. For all other request methods, the server MUST respond with
   a status of 412 (Precondition Failed).

   See &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt; for rules on how to determine if two entities tags
   match. The weak comparison function can only be used with GET or HEAD
   requests. 

   If none of the entity tags match, then the server MAY perform the
   requested method as if the If-None-Match header field did not exist,
   but MUST also ignore any If-Modified-Since header field(s) in the
   request. That is, if no entity tags match, then the server MUST NOT
   return a 304 (Not Modified) response.

   If the request would, without the If-None-Match header field, result
   in anything other than a 2xx or 304 status, then the If-None-Match
   header MUST be ignored. (See &lt;a href=&quot;#section-13.3.4&quot;&gt;section 13.3.4&lt;/a&gt; for a discussion of
   server behavior when both If-Modified-Since and If-None-Match appear
   in the same request.)

   The meaning of &quot;If-None-Match: *&quot; is that the method MUST NOT be
   performed if the representation selected by the origin server (or by
   a cache, possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;)
   exists, and SHOULD be performed if the representation does not exist.
   This feature is intended to be useful in preventing races between PUT
   operations.

   Examples:

       If-None-Match: &quot;xyzzy&quot;
       If-None-Match: W/&quot;xyzzy&quot;
       If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
       If-None-Match: *

   The result of a request having both an If-None-Match header field and
   either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">Поле заголовка запроса If-None-Match используется с методом, чтобы сделать его условным. Клиент, у которого есть одна или несколько сущностей, ранее полученных из ресурса, может проверить, что ни одна из этих сущностей не является текущей, включив список связанных с ними тегов сущностей в поле заголовка If-None-Match. Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Он также используется для предотвращения непреднамеренного изменения существующего ресурса методом (например, PUT), когда клиент считает, что этот ресурс не существует. В качестве особого случая значение &amp;laquo;*&amp;raquo; соответствует любой текущей сущности ресурса. If-None-Match = &quot;If-None-Match&quot; &quot;:&quot; (&quot;*&quot;| 1 # entity-tag) Если какой-либо из тегов объекта соответствует тегу объекта объекта, который был бы возвращен в ответ на аналогичный запрос GET (без заголовка If-None-Match) для этого ресурса, или если &quot;* &quot;задан, и для этого ресурса существует какой-либо текущий объект, то сервер НЕ ДОЛЖЕН выполнять запрошенный метод, если это не требуется, потому что дата модификации ресурса не соответствует дате, указанной в поле заголовка If-Modified-Since в запросе. Вместо этого, если метод запроса был GET или HEAD, серверу СЛЕДУЕТ ответить ответом 304 (Not Modified), включая поля заголовка, связанные с кешем (в частности, ETag) одного из сопоставленных объектов. Для всех других методов запроса сервер ДОЛЖЕН ответить статусом 412 (предварительное условие не выполнено). ВидетьВидетьВидетьВидетьВидетьтогда сервер НЕ ДОЛЖЕН выполнять запрошенный метод, если это не требуется, потому что дата модификации ресурса не соответствует дате, указанной в поле заголовка If-Modified-Since в запросе. Вместо этого, если метод запроса был GET или HEAD, серверу СЛЕДУЕТ ответить ответом 304 (Not Modified), включая поля заголовка, связанные с кешем (в частности, ETag) одного из сопоставленных объектов. Для всех других методов запроса сервер ДОЛЖЕН ответить статусом 412 (предварительное условие не выполнено). Видетьтогда сервер НЕ ДОЛЖЕН выполнять запрошенный метод, если это не требуется, потому что дата модификации ресурса не соответствует дате, указанной в поле заголовка If-Modified-Since в запросе. Вместо этого, если метод запроса был GET или HEAD, серверу СЛЕДУЕТ ответить ответом 304 (Not Modified), включая поля заголовка, связанные с кешем (в частности, ETag) одного из сопоставленных объектов. Для всех других методов запроса сервер ДОЛЖЕН ответить статусом 412 (предварительное условие не выполнено). Видетьсерверу СЛЕДУЕТ ответить ответом 304 (Not Modified), включая связанные с кешем поля заголовка (в частности, ETag) одного из сопоставленных объектов. Для всех других методов запроса сервер ДОЛЖЕН ответить статусом 412 (предварительное условие не выполнено). Видетьсерверу СЛЕДУЕТ ответить ответом 304 (Not Modified), включая связанные с кешем поля заголовка (в частности, ETag) одного из сопоставленных объектов. Для всех других методов запроса сервер ДОЛЖЕН ответить статусом 412 (предварительное условие не выполнено). Видеть&lt;a href=&quot;#section-13.3.3&quot;&gt;раздел 13.3.3&lt;/a&gt; о правилах определения совпадения двух тегов сущностей. Функция слабого сравнения может использоваться только с запросами GET или HEAD. Если ни один из тегов объекта не совпадает, тогда сервер МОЖЕТ выполнить запрошенный метод, как если бы поле заголовка If-None-Match не существовало, но ДОЛЖЕН также игнорировать любые поля заголовка If-Modified-Since в запросе. То есть, если ни один тег объекта не совпадает, сервер НЕ ДОЛЖЕН возвращать ответ 304 (Not Modified). Если запрос без поля заголовка If-None-Match приведет к чему-либо, кроме статуса 2xx или 304, тогда заголовок If-None-Match ДОЛЖЕН игнорироваться. (См. &lt;a href=&quot;#section-13.3.4&quot;&gt;Раздел 13.3.4.&lt;/a&gt;для обсуждения поведения сервера, когда и If-Modified-Since, и If-None-Match появляются в одном запросе.) Значение &amp;laquo;If-None-Match: *&amp;raquo; состоит в том, что метод НЕ ДОЛЖЕН выполняться, если выбрано представление исходным сервером (или кешем, возможно, с использованием механизма Vary, см. &lt;a href=&quot;#section-14.44&quot;&gt;раздел 14.44).&lt;/a&gt;) существует, и ДОЛЖЕН выполняться, если представление не существует. Эта функция предназначена для предотвращения скачков между операциями PUT. Примеры: If-None-Match: &quot;xyzzy&quot; If-None-Match: W / &quot;xyzzy&quot; If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot; If-None-Match: W / &quot;xyzzy&quot; , W / &quot;r2d2xxxx&quot;, W / &quot;c3piozzzz&quot; If-None-Match: * Результат запроса, имеющего как поле заголовка If-None-Match, так и поля заголовка If-Match или If-Unmodified-Since, является не определено данной спецификацией.</target>
        </trans-unit>
        <trans-unit id="a77607d9e035711baba5b97bc67fee22711422dd" translate="yes" xml:space="preserve">
          <source>The If-Unmodified-Since request-header field is used with a method to
   make it conditional. If the requested resource has not been modified
   since the time specified in this field, the server SHOULD perform the
   requested operation as if the If-Unmodified-Since header were not
   present.

   If the requested variant has been modified since the specified time,
   the server MUST NOT perform the requested operation, and MUST return
   a 412 (Precondition Failed).

      If-Unmodified-Since = &quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-date

   An example of the field is:

       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   If the request normally (i.e., without the If-Unmodified-Since
   header) would result in anything other than a 2xx or 412 status, the
   If-Unmodified-Since header SHOULD be ignored.

   If the specified date is invalid, the header is ignored.

   The result of a request having both an If-Unmodified-Since header
   field and either an If-None-Match or an If-Modified-Since header
   fields is undefined by this specification.</source>
          <target state="translated">Поле If-Unmodified-Since request-header используется с методом для того,чтобы сделать его условным.Если с момента,указанного в данном поле,запрашиваемый ресурс не был изменён,то сервер ДОЛЖЕН выполнить запрошенную операцию так,как если бы заголовок If-Unmodified-Since отсутствовал.Если запрашиваемый вариант был изменен с указанного времени,то сервер ДОЛЖЕН НЕ выполнять запрашиваемую операцию,а возвращать 412 (Precondition Failed).If-Unmodified-Since=&quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-дата Пример поля:If-Unmodified-Since:Sat,29 Oct 1994 19:43:31 GMT Если запрос в обычном режиме (т.е.без заголовка If-Unmodified-Since)приведет к чему-либо,кроме статуса 2xx или 412,заголовок If-Unmodified-Since ДОЛЖЕН быть проигнорирован.Если указанная дата недействительна,заголовок игнорируется.Результат запроса,имеющего как поле заголовка If-Unmodified-Since,так и поле заголовка If-None-Match или If-Modified-Since,не определяется данной спецификацией.</target>
        </trans-unit>
        <trans-unit id="fdfb0dc451f3880ef0d4f67dac2ee95582caadcf" translate="yes" xml:space="preserve">
          <source>The JavaScript function returns a single string</source>
          <target state="translated">Функция JavaScript возвращает единственную строку</target>
        </trans-unit>
        <trans-unit id="703e778a54d67833e0037322f76c267a64284bbc" translate="yes" xml:space="preserve">
          <source>The JavaScript function should always be saved to a file by itself and not be embedded in HTML.</source>
          <target state="translated">Функция JavaScript всегда должна быть сохранена в файле сама по себе и не должна быть встроена в HTML.</target>
        </trans-unit>
        <trans-unit id="b34c71697b1823e77b9a782ccdbeeb5fdf757c55" translate="yes" xml:space="preserve">
          <source>The JavaScript function should always be saved to a file by itself but not be embedded in a HTML file or any other file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3233de7c368a8e5f19a8ef2604664291230823" translate="yes" xml:space="preserve">
          <source>The JavaScript snippets included in these sections (and running instances of the server-code that correctly handles these cross-site requests) can be found &quot;in action&quot; at &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http://arunranga.com/examples/access-control/&lt;/a&gt;, and will work in browsers that support cross-site &lt;code&gt;XMLHttpRequest&lt;/code&gt;.</source>
          <target state="translated">Фрагменты JavaScript, включенные в эти разделы (и запущенные экземпляры серверного кода, который правильно обрабатывает эти межсайтовые запросы), можно найти &amp;laquo;в действии&amp;raquo; по адресу &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http://arunranga.com/examples/access-control/&lt;/a&gt; , и они будут работать в браузерах, поддерживающих межсайтовый &lt;code&gt;XMLHttpRequest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="925661df194abc683169e90bef883c4c078be359" translate="yes" xml:space="preserve">
          <source>The Keep-Alive Header (Experimental specification)</source>
          <target state="translated">Заголовок &quot;Keep-Alive&quot; (Экспериментальная спецификация)</target>
        </trans-unit>
        <trans-unit id="db2749cedc967fd4ef7ed7614b130c614deab08c" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field indicates the date and time at
   which the origin server believes the variant was last modified.

       Last-Modified  = &quot;Last-Modified&quot; &quot;:&quot; HTTP-date 

   An example of its use is

       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT

   The exact meaning of this header field depends on the implementation
   of the origin server and the nature of the original resource. For
   files, it may be just the file system last-modified time. For
   entities with dynamically included parts, it may be the most recent
   of the set of last-modify times for its component parts. For database
   gateways, it may be the last-update time stamp of the record. For
   virtual objects, it may be the last time the internal state changed.

   An origin server MUST NOT send a Last-Modified date which is later
   than the server's time of message origination. In such cases, where
   the resource's last modification would indicate some time in the
   future, the server MUST replace that date with the message
   origination date.

   An origin server SHOULD obtain the Last-Modified value of the entity
   as close as possible to the time that it generates the Date value of
   its response. This allows a recipient to make an accurate assessment
   of the entity's modification time, especially if the entity changes
   near the time that the response is generated.

   HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.</source>
          <target state="translated">В поле Last-Modified entity-header (Заголовок структуры)указывается дата и время,когда сервер происхождения считает,что вариант был в последний раз изменен.Last-Modified=&quot;Last-Modified&quot; &quot;:&quot; HTTP-date Примером его использования является Last-Modified:Tue,15 Nov 1994 12:45:26 GMT Точное значение этого поля заголовка зависит от реализации сервера-источника и природы исходного ресурса.Для файлов это может быть только время последней модификации файловой системы.Для сущностей с динамически включаемыми частями,оно может быть самым последним из множества последних модифицированных времен для их составных частей.Для шлюзов баз данных это может быть последняя метка времени записи.Для виртуальных объектов это может быть последний раз,когда внутреннее состояние изменилось.Сервер происхождения НЕ ДОЛЖЕН посылать последнюю измененную дату,которая является более поздней,чем время отправки сообщения сервером.В таких случаях,когда последняя модификация ресурса будет указывать на некоторое время в будущем,сервер ДОЛЖЕН заменить эту дату на дату возникновения сообщения.Сервер происхождения ДОЛЖЕН получить значение Last-Modified сущности как можно ближе к тому времени,когда он генерирует значение Date своего ответа.Это позволяет получателю точно оценить время модификации сущности,особенно если сущность изменяется близко ко времени генерации ответа.HTTP/1.1 серверы ДОЛЖНЫ посылать последнюю модификацию,когда это возможно.</target>
        </trans-unit>
        <trans-unit id="528a83f631c94edde30298fe82ad4b470dc52fd6" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field value is often used as a cache
   validator. In simple terms, a cache entry is considered to be valid
   if the entity has not been modified since the Last-Modified value.</source>
          <target state="translated">Значение поля &quot;Last-Modified entity-header&quot; часто используется в качестве валидатора кэша.Проще говоря,запись в кэше считается действительной,если сущность не была изменена после значения Last-Modified.</target>
        </trans-unit>
        <trans-unit id="017625ae11b1cf3babbe1d1e9f72538a1d0bcdba" translate="yes" xml:space="preserve">
          <source>The Location response-header field is used to redirect the recipient
   to a location other than the Request-URI for completion of the
   request or identification of a new resource. For 201 (Created)
   responses, the Location is that of the new resource which was created
   by the request. For 3xx responses, the location SHOULD indicate the
   server's preferred URI for automatic redirection to the resource. The
   field value consists of a single absolute URI.

       Location       = &quot;Location&quot; &quot;:&quot; absoluteURI

   An example is:

       Location: &lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http://www.w3.org/pub/WWW/People.html&lt;/a&gt;

      Note: The Content-Location header field (&lt;a href=&quot;#section-14.14&quot;&gt;section 14.14&lt;/a&gt;) differs
      from Location in that the Content-Location identifies the original
      location of the entity enclosed in the request. It is therefore
      possible for a response to contain header fields for both Location
      and Content-Location. Also see &lt;a href=&quot;#section-13.10&quot;&gt;section 13.10&lt;/a&gt; for cache
      requirements of some methods.</source>
          <target state="translated">Поле заголовка ответа Location используется для перенаправления получателя в местоположение, отличное от Request-URI, для завершения запроса или идентификации нового ресурса. Для 201 (Созданного) ответа Location - это местоположение нового ресурса, который был создан запросом. Для ответов 3xx расположение ДОЛЖНО указывать предпочтительный URI сервера для автоматического перенаправления на ресурс. Значение поля состоит из одного абсолютного URI. Location = &quot;Location&quot; &quot;:&quot; absoluteURI Пример: Location: &lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http://www.w3.org/pub/WWW/People.html&lt;/a&gt; Примечание. Поле заголовка Content-Location ( &lt;a href=&quot;#section-14.14&quot;&gt;раздел 14.14&lt;/a&gt;) отличается от Location тем, что Content-Location идентифицирует исходное местоположение объекта, включенного в запрос. Следовательно, ответ может содержать поля заголовка как для Location, так и для Content-Location. Также см. &lt;a href=&quot;#section-13.10&quot;&gt;Раздел 13.10&lt;/a&gt; о требованиях к кешированию некоторых методов.</target>
        </trans-unit>
        <trans-unit id="5ec50ccb1766d60abdfd671b868367af7c968122" translate="yes" xml:space="preserve">
          <source>The Location response-header field is used to redirect the recipient
   to a location other than the Request-URI for completion of the
   request or identification of a new resource. For 201 (Created)
   responses, the Location is that of the new resource which was created
   by the request. For 3xx responses, the location SHOULD indicate the
   server's preferred URI for automatic redirection to the resource. The
   field value consists of a single absolute URI.

       Location       = &quot;Location&quot; &quot;:&quot; absoluteURI

   An example is:

       Location: &lt;a href=&quot;https://www.w3.org/pub/WWW/People.html&quot;&gt;http://www.w3.org/pub/WWW/People.html&lt;/a&gt;

      Note: The Content-Location header field (&lt;a href=&quot;#section-14.14&quot;&gt;section 14.14&lt;/a&gt;) differs
      from Location in that the Content-Location identifies the original
      location of the entity enclosed in the request. It is therefore
      possible for a response to contain header fields for both Location
      and Content-Location. Also see &lt;a href=&quot;#section-13.10&quot;&gt;section 13.10&lt;/a&gt; for cache
      requirements of some methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc7ceee0f881c0002d5d80140938c1e7f80c8e7" translate="yes" xml:space="preserve">
          <source>The MIME type of audiovisual files mostly indicate the container formats. The most common ones on the Web are:</source>
          <target state="translated">MIME-тип аудиовизуальных файлов в основном указывает на форматы контейнеров.Наиболее распространенные из них в Сети:</target>
        </trans-unit>
        <trans-unit id="7e997fc9b96d9d0ec4b11746c0834f2c40378a91" translate="yes" xml:space="preserve">
          <source>The MOVE operation on a non-collection resource is the logical
   equivalent of a copy (COPY), followed by consistency maintenance
   processing, followed by a delete of the source, where all three
   actions are performed in a single operation.  The consistency
   maintenance step allows the server to perform updates caused by the
   move, such as updating all URLs, other than the Request-URI that
   identifies the source resource, to point to the new destination
   resource. 

   The Destination header MUST be present on all MOVE methods and MUST
   follow all COPY requirements for the COPY part of the MOVE method.
   All WebDAV-compliant resources MUST support the MOVE method.

   Support for the MOVE method does not guarantee the ability to move a
   resource to a particular destination.  For example, separate programs
   may actually control different sets of resources on the same server.
   Therefore, it may not be possible to move a resource within a
   namespace that appears to belong to the same server.

   If a resource exists at the destination, the destination resource
   will be deleted as a side-effect of the MOVE operation, subject to
   the restrictions of the Overwrite header.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">Операция MOVE для ресурса, не являющегося сборником, является логическим эквивалентом копирования (COPY), за которым следует обработка поддержания согласованности, за которой следует удаление источника, где все три действия выполняются за одну операцию. Этап поддержания согласованности позволяет серверу выполнять обновления, вызванные перемещением, такие как обновление всех URL-адресов, кроме Request-URI, который идентифицирует исходный ресурс, для указания на новый целевой ресурс. Заголовок Destination ДОЛЖЕН присутствовать во всех методах MOVE и ДОЛЖЕН соответствовать всем требованиям COPY для части COPY метода MOVE. Все ресурсы, совместимые с WebDAV, ДОЛЖНЫ поддерживать метод MOVE. Поддержка метода MOVE не гарантирует возможность перемещения ресурса в конкретное место назначения. Например,отдельные программы могут фактически управлять разными наборами ресурсов на одном сервере. Следовательно, может оказаться невозможным переместить ресурс в пространстве имен, которое кажется принадлежащим тому же серверу. Если ресурс существует в месте назначения, ресурс назначения будет удален как побочный эффект операции MOVE с учетом ограничений заголовка Overwrite. Этот метод идемпотентен, но небезопасен (см.&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Раздел 9.1 [RFC2616]&lt;/a&gt; ). Ответы на этот метод НЕ ДОЛЖНЫ кэшироваться.</target>
        </trans-unit>
        <trans-unit id="cb1023831cad3159839df21a4251dd372a13a0bc" translate="yes" xml:space="preserve">
          <source>The Max-Forwards request-header field provides a mechanism with the
   TRACE (&lt;a href=&quot;#section-9.8&quot;&gt;section 9.8&lt;/a&gt;) and OPTIONS (&lt;a href=&quot;#section-9.2&quot;&gt;section 9.2&lt;/a&gt;) methods to limit the
   number of proxies or gateways that can forward the request to the
   next inbound server. This can be useful when the client is attempting
   to trace a request chain which appears to be failing or looping in
   mid-chain.

       Max-Forwards   = &quot;Max-Forwards&quot; &quot;:&quot; 1*DIGIT

   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message may be forwarded.

   Each proxy or gateway recipient of a TRACE or OPTIONS request
   containing a Max-Forwards header field MUST check and update its
   value prior to forwarding the request. If the received value is zero
   (0), the recipient MUST NOT forward the request; instead, it MUST
   respond as the final recipient. If the received Max-Forwards value is
   greater than zero, then the forwarded message MUST contain an updated
   Max-Forwards field with a value decremented by one (1).

   The Max-Forwards header field MAY be ignored for all other methods
   defined by this specification and for any extension methods for which
   it is not explicitly referred to as part of that method definition.</source>
          <target state="translated">Поле заголовка запроса Max-Forwards обеспечивает механизм с TRACE ( &lt;a href=&quot;#section-9.8&quot;&gt;раздел 9.8&lt;/a&gt; ) и OPTIONS ( &lt;a href=&quot;#section-9.2&quot;&gt;раздел 9.2).&lt;/a&gt;), чтобы ограничить количество прокси или шлюзов, которые могут перенаправить запрос на следующий входящий сервер. Это может быть полезно, когда клиент пытается отследить цепочку запросов, которая, похоже, дает сбой или зацикливается в середине цепочки. Max-Forwards = &quot;Max-Forwards&quot; &quot;:&quot; 1 * DIGIT Значение Max-Forwards представляет собой десятичное целое число, указывающее оставшееся количество раз, когда это сообщение запроса может быть переадресовано. Каждый прокси-сервер или шлюз-получатель запроса TRACE или OPTIONS, содержащего поле заголовка Max-Forwards, ДОЛЖЕН проверить и обновить его значение до пересылки запроса. Если полученное значение равно нулю (0), получатель НЕ ДОЛЖЕН пересылать запрос; вместо этого он ДОЛЖЕН отвечать как конечный получатель. Если полученное значение Max-Forwards больше нуля,тогда переадресованное сообщение ДОЛЖНО содержать обновленное поле Max-Forwards со значением, уменьшенным на единицу (1). Поле заголовка Max-Forwards МОЖЕТ игнорироваться для всех других методов, определенных в этой спецификации, и для любых методов расширения, для которых оно явно не упоминается как часть этого определения метода.</target>
        </trans-unit>
        <trans-unit id="b9679bb7ec73b85f439581526aa5e2f804e20f5f" translate="yes" xml:space="preserve">
          <source>The Member URI allows clients to retrieve, edit, and delete a Member
   Resource using HTTP's GET, PUT, and DELETE methods.  Entry Resources
   are represented as Atom Entry documents.

   Member URIs appear in two places.  They are returned in a Location
   header after successful Resource creation using POST, as described in
   &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt; below.  They can also appear in a Collection Feed's
   Entries, as atom:link elements with a link relation of &quot;edit&quot;.

   A Member Entry SHOULD contain such an atom:link element with a link
   relation of &quot;edit&quot;, which indicates the Member URI.</source>
          <target state="translated">URI участника позволяет клиентам получать, редактировать и удалять ресурс участника с помощью методов HTTP GET, PUT и DELETE. Входные ресурсы представлены как входные документы Atom. URI участников появляются в двух местах. Они возвращаются в заголовке Location после успешного создания ресурса с помощью POST, как описано в &lt;a href=&quot;#section-9.2&quot;&gt;Разделе 9.2&lt;/a&gt; ниже. Они также могут появляться в записях фида подборки как элементы atom: link с отношением ссылки &amp;laquo;редактировать&amp;raquo;. Запись участника ДОЛЖНА содержать такой элемент atom: link с отношением ссылки &amp;laquo;редактировать&amp;raquo;, которое указывает URI участника.</target>
        </trans-unit>
        <trans-unit id="8bc27eaceea013a32bec84be620f4a677881aac7" translate="yes" xml:space="preserve">
          <source>The Method  token indicates the method to be performed on the
   resource identified by the Request-URI. The method is case-sensitive.

       Method         = &quot;OPTIONS&quot;                ; &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;
                      | &quot;GET&quot;                    ; &lt;a href=&quot;#section-9.3&quot;&gt;Section 9.3&lt;/a&gt;
                      | &quot;HEAD&quot;                   ; &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt;
                      | &quot;POST&quot;                   ; &lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;
                      | &quot;PUT&quot;                    ; &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;
                      | &quot;DELETE&quot;                 ; &lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;
                      | &quot;TRACE&quot;                  ; &lt;a href=&quot;#section-9.8&quot;&gt;Section 9.8&lt;/a&gt;
                      | &quot;CONNECT&quot;                ; &lt;a href=&quot;#section-9.9&quot;&gt;Section 9.9&lt;/a&gt;
                      | extension-method
       extension-method = token

   The list of methods allowed by a resource can be specified in an
   Allow header field (&lt;a href=&quot;#section-14.7&quot;&gt;section 14.7&lt;/a&gt;). The return code of the response
   always notifies the client whether a method is currently allowed on a
   resource, since the set of allowed methods can change dynamically. An
   origin server SHOULD return the status code 405 (Method Not Allowed)
   if the method is known by the origin server but not allowed for the
   requested resource, and 501 (Not Implemented) if the method is
   unrecognized or not implemented by the origin server. The methods GET
   and HEAD MUST be supported by all general-purpose servers. All other
   methods are OPTIONAL; however, if the above methods are implemented,
   they MUST be implemented with the same semantics as those specified
   in &lt;a href=&quot;#section-9&quot;&gt;section 9&lt;/a&gt;.</source>
          <target state="translated">Маркер метода указывает метод, который будет выполняться для ресурса, указанного в Request-URI. В методе учитывается регистр. Метод = &quot;ОПЦИИ&quot;; &lt;a href=&quot;#section-9.2&quot;&gt;Раздел 9.2&lt;/a&gt; | &quot;ПОЛУЧИТЬ&quot; ; &lt;a href=&quot;#section-9.3&quot;&gt;Раздел 9.3&lt;/a&gt; | &quot;ГЛАВА&quot; ; &lt;a href=&quot;#section-9.4&quot;&gt;Раздел 9.4&lt;/a&gt; | &quot;ПОЧТА&quot; ; &lt;a href=&quot;#section-9.5&quot;&gt;Раздел 9.5&lt;/a&gt; | &quot;СТАВИТЬ&quot; ; &lt;a href=&quot;#section-9.6&quot;&gt;Раздел 9.6&lt;/a&gt; | &quot;УДАЛИТЬ&quot; ; &lt;a href=&quot;#section-9.7&quot;&gt;Раздел 9.7&lt;/a&gt; | &amp;laquo;СЛЕД&amp;raquo;; &lt;a href=&quot;#section-9.8&quot;&gt;Раздел 9.8&lt;/a&gt; | &quot;CONNECT&quot;; &lt;a href=&quot;#section-9.9&quot;&gt;Раздел 9.9&lt;/a&gt; | extension-method extension-method = token Список методов, разрешенных ресурсом, может быть указан в поле заголовка Allow ( &lt;a href=&quot;#section-14.7&quot;&gt;раздел 14.7&lt;/a&gt;). Код возврата ответа всегда уведомляет клиента о том, разрешен ли метод в данный момент для ресурса, поскольку набор разрешенных методов может изменяться динамически. Исходный сервер ДОЛЖЕН возвращать код состояния 405 (метод не разрешен), если метод известен исходному серверу, но не разрешен для запрошенного ресурса, и 501 (не реализован), если метод нераспознан или не реализован исходным сервером. Методы GET и HEAD ДОЛЖНЫ поддерживаться всеми серверами общего назначения. Все остальные методы НЕОБЯЗАТЕЛЬНЫ; однако, если вышеупомянутые методы реализованы, они ДОЛЖНЫ быть реализованы с той же семантикой, что и те, которые указаны в &lt;a href=&quot;#section-9&quot;&gt;разделе 9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b472ea77a890edf2b85c6971105718fc4fd6fc42" translate="yes" xml:space="preserve">
          <source>The OPTIONS method represents a request for information about the
   communication options available on the request/response chain
   identified by the Request-URI. This method allows the client to
   determine the options and/or requirements associated with a resource,
   or the capabilities of a server, without implying a resource action
   or initiating a resource retrieval.

   Responses to this method are not cacheable.

   If the OPTIONS request includes an entity-body (as indicated by the
   presence of Content-Length or Transfer-Encoding), then the media type
   MUST be indicated by a Content-Type field. Although this
   specification does not define any use for such a body, future
   extensions to HTTP might use the OPTIONS body to make more detailed
   queries on the server. A server that does not support such an
   extension MAY discard the request body.

   If the Request-URI is an asterisk (&quot;*&quot;), the OPTIONS request is
   intended to apply to the server in general rather than to a specific
   resource. Since a server's communication options typically depend on
   the resource, the &quot;*&quot; request is only useful as a &quot;ping&quot; or &quot;no-op&quot;
   type of method; it does nothing beyond allowing the client to test
   the capabilities of the server. For example, this can be used to test
   a proxy for HTTP/1.1 compliance (or lack thereof).

   If the Request-URI is not an asterisk, the OPTIONS request applies
   only to the options that are available when communicating with that
   resource.

   A 200 response SHOULD include any header fields that indicate
   optional features implemented by the server and applicable to that
   resource (e.g., Allow), possibly including extensions not defined by
   this specification. The response body, if any, SHOULD also include
   information about the communication options. The format for such a 

   body is not defined by this specification, but might be defined by
   future extensions to HTTP. Content negotiation MAY be used to select
   the appropriate response format. If no response body is included, the
   response MUST include a Content-Length field with a field-value of
   &quot;0&quot;.

   The Max-Forwards request-header field MAY be used to target a
   specific proxy in the request chain. When a proxy receives an OPTIONS
   request on an absoluteURI for which request forwarding is permitted,
   the proxy MUST check for a Max-Forwards field. If the Max-Forwards
   field-value is zero (&quot;0&quot;), the proxy MUST NOT forward the message;
   instead, the proxy SHOULD respond with its own communication options.
   If the Max-Forwards field-value is an integer greater than zero, the
   proxy MUST decrement the field-value when it forwards the request. If
   no Max-Forwards field is present in the request, then the forwarded
   request MUST NOT include a Max-Forwards field.</source>
          <target state="translated">Метод OPTIONS (ВАРИАНТ)представляет собой запрос информации о вариантах коммуникации,доступных в цепочке запрос/реакция,обозначенной в Request-URI (Запросы-URI).Этот метод позволяет клиенту определить опции и/или требования,связанные с ресурсом или возможностями сервера,не подразумевая действий с ресурсом и не инициируя его извлечение.Ответы на этот метод не являются кэшируемыми.Если запрос OPTIONS включает в себя сущность-тело (на что указывает наличие Content-Length или Transfer-Encoding),то тип носителя ДОЛЖЕН быть обозначен полем Content-Type.Хотя эта спецификация не определяет использование такого тела,будущие расширения HTTP могут использовать тело OPTIONS для более детальных запросов на сервере.Сервер,не поддерживающий такое расширение,МОЖЕТ отбросить тело запроса.Если Request-URI помечен звездочкой (&quot;*&quot;),то запрос OPTIONS предназначен для применения к серверу в целом,а не к конкретному ресурсу.Так как варианты взаимодействия сервера обычно зависят от ресурса,то запрос &quot;*&quot; полезен только как метод &quot;ping&quot; или &quot;no-op&quot;;он ничего не делает,кроме как позволяет клиенту проверить возможности сервера.Например,это может быть использовано для проверки прокси на соответствие HTTP/1.1 (или его отсутствие).Если запрос Request-URI не помечен звездочкой,то запрос OPTIONS применяется только к тем опциям,которые доступны при общении с этим ресурсом.Поле 200 ответа SHOULD включает в себя любые поля заголовка,которые указывают на необязательные опции,реализованные сервером и применимые к этому ресурсу (например,Allow),возможно,включая расширения,не определенные данной спецификацией.Тело ответа,если таковое имеется,SHOULD также включает информацию о вариантах обмена данными.Формат такого тела не определен данной спецификацией,но может быть определен будущими расширениями HTTP.Согласование содержания МОЖЕТ быть использовано для выбора соответствующего формата ответа.Если тело ответа не включено,то ответ ДОЛЖЕН содержать поле Content-Length со значением поля &quot;0&quot;.Поле Max-Forwards-заголовок запроса MAY должно использоваться для назначения конкретного прокси-сервера в цепочке запросов.Когда прокси-сервер получает запрос OPTIONS на абсолютном уровне,для которого разрешена переадресация запроса,он ДОЛЖЕН проверять поле Max-Forwards.Если значение поля Max-Forwards равно нулю (&quot;0&quot;),прокси-сервер НЕ ДОЛЖЕН пересылать сообщение;вместо этого прокси-сервер ДОЛЖЕН отвечать собственными опциями связи.Если значение поля Max-Forwards больше нуля,то при пересылке запроса прокси-сервер ДОЛЖЕН уменьшать значение поля.Если в запросе отсутствует поле Max-Forwards,то пересылаемый запрос НЕ ДОЛЖЕН включать поле Max-Forwards.</target>
        </trans-unit>
        <trans-unit id="49820b72a266a24d241c6570cc10be88c4ce50ca" translate="yes" xml:space="preserve">
          <source>The OPTIONS method requests information about the communication
   options available for the target resource, at either the origin
   server or an intervening intermediary.  This method allows a client
   to determine the options and/or requirements associated with a
   resource, or the capabilities of a server, without implying a
   resource action. 

   An OPTIONS request with an asterisk (&quot;*&quot;) as the request-target
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;) applies to the server in general rather
   than to a specific resource.  Since a server's communication options
   typically depend on the resource, the &quot;*&quot; request is only useful as a
   &quot;ping&quot; or &quot;no-op&quot; type of method; it does nothing beyond allowing the
   client to test the capabilities of the server.  For example, this can
   be used to test a proxy for HTTP/1.1 conformance (or lack thereof).

   If the request-target is not an asterisk, the OPTIONS request applies
   to the options that are available when communicating with the target
   resource.

   A server generating a successful response to OPTIONS SHOULD send any
   header fields that might indicate optional features implemented by
   the server and applicable to the target resource (e.g., Allow),
   including potential extensions not defined by this specification.
   The response payload, if any, might also describe the communication
   options in a machine or human-readable representation.  A standard
   format for such a representation is not defined by this
   specification, but might be defined by future extensions to HTTP.  A
   server MUST generate a Content-Length field with a value of &quot;0&quot; if no
   payload body is to be sent in the response.

   A client MAY send a Max-Forwards header field in an OPTIONS request
   to target a specific recipient in the request chain (see
   &lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;).  A proxy MUST NOT generate a Max-Forwards header
   field while forwarding a request unless that request was received
   with a Max-Forwards field.

   A client that generates an OPTIONS request containing a payload body
   MUST send a valid Content-Type header field describing the
   representation media type.  Although this specification does not
   define any use for such a payload, future extensions to HTTP might
   use the OPTIONS body to make more detailed queries about the target
   resource.

   Responses to the OPTIONS method are not cacheable.</source>
          <target state="translated">Метод OPTIONS запрашивает информацию о вариантах связи, доступных для целевого ресурса, либо на исходном сервере, либо на промежуточном посреднике. Этот метод позволяет клиенту определять параметры и / или требования, связанные с ресурсом, или возможности сервера, не подразумевая действие ресурса. Запрос OPTIONS со звездочкой (&amp;laquo;*&amp;raquo;) в качестве цели запроса ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;раздел 5.3 [RFC7230]&lt;/a&gt;) применяется к серверу в целом, а не к конкретному ресурсу. Поскольку параметры связи сервера обычно зависят от ресурса, запрос &amp;laquo;*&amp;raquo; полезен только как метод типа &amp;laquo;ping&amp;raquo; или &amp;laquo;no-op&amp;raquo;; он не делает ничего, кроме того, что позволяет клиенту проверить возможности сервера. Например, это можно использовать для проверки прокси-сервера на соответствие HTTP / 1.1 (или его отсутствие). Если цель запроса не является звездочкой, запрос OPTIONS применяется к параметрам, которые доступны при взаимодействии с целевым ресурсом. Сервер, генерирующий успешный ответ на OPTIONS, ДОЛЖЕН отправить любые поля заголовка, которые могут указывать на дополнительные функции, реализованные сервером и применимые к целевому ресурсу (например, Allow),включая потенциальные расширения, не определенные в данной спецификации. Полезная нагрузка ответа, если таковая имеется, может также описывать варианты связи в машинном или удобочитаемом представлении. Стандартный формат для такого представления не определен в этой спецификации, но может быть определен в будущих расширениях HTTP. Сервер ДОЛЖЕН сгенерировать поле Content-Length со значением &amp;laquo;0&amp;raquo;, если в ответе не требуется отправлять тело полезной нагрузки. Клиент МОЖЕТ отправить поле заголовка Max-Forwards в запросе OPTIONS для нацеливания на конкретного получателя в цепочке запросов (см.но может быть определен в будущих расширениях HTTP. Сервер ДОЛЖЕН сгенерировать поле Content-Length со значением &amp;laquo;0&amp;raquo;, если в ответе не требуется отправлять тело полезной нагрузки. Клиент МОЖЕТ отправить поле заголовка Max-Forwards в запросе OPTIONS для нацеливания на конкретного получателя в цепочке запросов (см.но может быть определен в будущих расширениях HTTP. Сервер ДОЛЖЕН сгенерировать поле Content-Length со значением &amp;laquo;0&amp;raquo;, если в ответе не требуется отправлять тело полезной нагрузки. Клиент МОЖЕТ отправить поле заголовка Max-Forwards в запросе OPTIONS для нацеливания на конкретного получателя в цепочке запросов (см. &lt;a href=&quot;#section-5.1.2&quot;&gt;Раздел 5.1.2&lt;/a&gt; ). Прокси-сервер НЕ ДОЛЖЕН генерировать поле заголовка Max-Forwards при пересылке запроса, если этот запрос не был получен с полем Max-Forwards. Клиент, который генерирует запрос OPTIONS, содержащий тело полезной нагрузки, ДОЛЖЕН отправить допустимое поле заголовка Content-Type, описывающее тип носителя представления. Хотя эта спецификация не определяет какое-либо использование такой полезной нагрузки, будущие расширения HTTP могут использовать тело OPTIONS для выполнения более подробных запросов о целевом ресурсе. Ответы на метод OPTIONS не кэшируются.</target>
        </trans-unit>
        <trans-unit id="335a905cdd5cc098f1e6a149fd20a764baed11c1" translate="yes" xml:space="preserve">
          <source>The Opera browser is also based on the Blink engine, which is why it almost looks the same, but adds &lt;code&gt;&quot;OPR/&amp;lt;version&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0b5a78c1f599442b880ea6a8403854d20e3ef6" translate="yes" xml:space="preserve">
          <source>The Opera browser is also based on the blink engine, which is why it almost looks the same, but adds &quot;OPR/&amp;lt;version&amp;gt;&quot;.</source>
          <target state="translated">Браузер Opera также основан на движке мигания, поэтому выглядит почти так же, но добавляет &amp;laquo;OPR / &amp;lt;version&amp;gt;&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="1a9fb731478c28f4fa3740727c3862c0e8280261" translate="yes" xml:space="preserve">
          <source>The Operating System is given in most User Agent strings (although not web-focused platforms like Firefox OS), but the format varies a lot. It is a fixed string between two semi-colons, in the comment part of the User Agent. These strings are specific for each browser. They indicate the OS, but also often its version and information on the relying hardware (32 or 64 bits, or Intel/PPC for Mac).</source>
          <target state="translated">Операционная система представлена в большинстве строк User Agent (хотя и не ориентирована на веб-платформы,такие как Firefox OS),но формат сильно варьируется.Это фиксированная строка между двумя полуколоннами,в комментаторской части Пользовательского агента.Эти строки специфичны для каждого браузера.Они указывают не только на операционную систему,но и часто ее версию и информацию о полагающемся оборудовании (32 или 64 бита,или Intel/PPC для Mac).</target>
        </trans-unit>
        <trans-unit id="b865b396cc503b061720f4db16c1a8fdc2531248" translate="yes" xml:space="preserve">
          <source>The PAC file is named &lt;code&gt;proxy.pac&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9837bd9139ad48f4cd2dd0906bd1f2401fbe7f" translate="yes" xml:space="preserve">
          <source>The PAC file is named proxy.pac</source>
          <target state="translated">Файл PAC называется proxy.pac.</target>
        </trans-unit>
        <trans-unit id="ad2834ac0702672d145d7ca3894c53d5a21fd051" translate="yes" xml:space="preserve">
          <source>The PHP snippets (and the JavaScript invocations to the server) in subsequent sections are taken from &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;the working code samples posted here.&lt;/a&gt; These will work in browsers that implement cross-site &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Фрагменты PHP (и вызовы JavaScript на сервере) в последующих разделах взяты из &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;размещенных здесь примеров рабочего кода.&lt;/a&gt; Они будут работать в браузерах, реализующих межсайтовый &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="68bd99f90bb560cf24ee3bfb0650ff1043f9b961" translate="yes" xml:space="preserve">
          <source>The PING frame (type=0x6) is a mechanism for measuring a minimal
   round-trip time from the sender, as well as determining whether an
   idle connection is still functional.  PING frames can be sent from
   any endpoint.

    +---------------------------------------------------------------+
    |                                                               |
    |                      Opaque Data (64)                         |
    |                                                               |
    +---------------------------------------------------------------+

                      Figure 12: PING Payload Format

   In addition to the frame header, PING frames MUST contain 8 octets of
   opaque data in the payload.  A sender can include any value it
   chooses and use those octets in any fashion.

   Receivers of a PING frame that does not include an ACK flag MUST send
   a PING frame with the ACK flag set in response, with an identical
   payload.  PING responses SHOULD be given higher priority than any
   other frame.

   The PING frame defines the following flags:

   ACK (0x1):  When set, bit 0 indicates that this PING frame is a PING
      response.  An endpoint MUST set this flag in PING responses.  An
      endpoint MUST NOT respond to PING frames containing this flag. 

   PING frames are not associated with any individual stream.  If a PING
   frame is received with a stream identifier field value other than
   0x0, the recipient MUST respond with a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   Receipt of a PING frame with a length field value other than 8 MUST
   be treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   FRAME_SIZE_ERROR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84539c58092eb061728beac8d3510599c78d9e2" translate="yes" xml:space="preserve">
          <source>The POST method is used to request that the origin server accept the
   entity enclosed in the request as a new subordinate of the resource
   identified by the Request-URI in the Request-Line. POST is designed
   to allow a uniform method to cover the following functions:

      - Annotation of existing resources;

      - Posting a message to a bulletin board, newsgroup, mailing list,
        or similar group of articles;

      - Providing a block of data, such as the result of submitting a
        form, to a data-handling process;

      - Extending a database through an append operation.

   The actual function performed by the POST method is determined by the
   server and is usually dependent on the Request-URI. The posted entity
   is subordinate to that URI in the same way that a file is subordinate
   to a directory containing it, a news article is subordinate to a
   newsgroup to which it is posted, or a record is subordinate to a
   database.

   The action performed by the POST method might not result in a
   resource that can be identified by a URI. In this case, either 200
   (OK) or 204 (No Content) is the appropriate response status,
   depending on whether or not the response includes an entity that
   describes the result. 

   If a resource has been created on the origin server, the response
   SHOULD be 201 (Created) and contain an entity which describes the
   status of the request and refers to the new resource, and a Location
   header (see &lt;a href=&quot;#section-14.30&quot;&gt;section 14.30&lt;/a&gt;).

   Responses to this method are not cacheable, unless the response
   includes appropriate Cache-Control or Expires header fields. However,
   the 303 (See Other) response can be used to direct the user agent to
   retrieve a cacheable resource.

   POST requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">Метод POST используется для запроса, чтобы исходный сервер принял объект, заключенный в запросе, как новый подчиненный ресурс, идентифицированный Request-URI в строке запроса. POST разработан, чтобы позволить единообразному методу охватить следующие функции: - Аннотации существующих ресурсов; - размещение сообщения на доске объявлений, в группе новостей, в списке рассылки или в аналогичной группе статей; - Предоставление блока данных, такого как результат отправки формы, процессу обработки данных; - Расширение базы данных с помощью операции добавления. Фактическая функция, выполняемая методом POST, определяется сервером и обычно зависит от Request-URI. Опубликованный объект подчиняется этому URI так же, как файл подчиняется каталогу, содержащему его,новостная статья подчиняется группе новостей, в которой она размещена, или запись подчиняется базе данных. Действие, выполняемое методом POST, может не привести к созданию ресурса, который можно идентифицировать по URI. В этом случае подходящим статусом ответа является либо 200 (ОК), либо 204 (Нет содержимого), в зависимости от того, включает ли ответ сущность, описывающую результат. Если ресурс был создан на исходном сервере, ответ ДОЛЖЕН быть 201 (Создан) и содержать объект, который описывает статус запроса и ссылается на новый ресурс, и заголовок Location (см.В этом случае подходящим статусом ответа является либо 200 (ОК), либо 204 (Нет содержимого), в зависимости от того, включает ли ответ сущность, описывающую результат. Если ресурс был создан на исходном сервере, ответ ДОЛЖЕН быть 201 (Создан) и содержать объект, который описывает статус запроса и ссылается на новый ресурс, и заголовок Location (см.В этом случае подходящим статусом ответа является либо 200 (ОК), либо 204 (Нет содержимого), в зависимости от того, включает ли ответ сущность, описывающую результат. Если ресурс был создан на исходном сервере, ответ ДОЛЖЕН быть 201 (Создан) и содержать объект, который описывает статус запроса и ссылается на новый ресурс, и заголовок Location (см.&lt;a href=&quot;#section-14.30&quot;&gt;раздел 14.30&lt;/a&gt; ). Ответы на этот метод не кэшируются, если ответ не включает соответствующие поля заголовка Cache-Control или Expires. Однако ответ 303 (см. Прочее) может использоваться для указания пользовательскому агенту получить кэшируемый ресурс. Запросы POST ДОЛЖНЫ соответствовать требованиям к передаче сообщений, изложенным в &lt;a href=&quot;#section-8.2&quot;&gt;разделе 8.2&lt;/a&gt; . См. &lt;a href=&quot;#section-15.1.3&quot;&gt;Раздел 15.1.3&lt;/a&gt; по соображениям безопасности.</target>
        </trans-unit>
        <trans-unit id="a7c4a0540415d773e2957d84d1e4f16f405d585a" translate="yes" xml:space="preserve">
          <source>The POST method requests that the target resource process the
   representation enclosed in the request according to the resource's
   own specific semantics.  For example, POST is used for the following
   functions (among others):

   o  Providing a block of data, such as the fields entered into an HTML
      form, to a data-handling process; 

   o  Posting a message to a bulletin board, newsgroup, mailing list,
      blog, or similar group of articles;

   o  Creating a new resource that has yet to be identified by the
      origin server; and

   o  Appending data to a resource's existing representation(s).

   An origin server indicates response semantics by choosing an
   appropriate status code depending on the result of processing the
   POST request; almost all of the status codes defined by this
   specification might be received in a response to POST (the exceptions
   being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not
   Satisfiable)).

   If one or more resources has been created on the origin server as a
   result of successfully processing a POST request, the origin server
   SHOULD send a 201 (Created) response containing a Location header
   field that provides an identifier for the primary resource created
   (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;) and a representation that describes the status of the
   request while referring to the new resource(s).

   Responses to POST requests are only cacheable when they include
   explicit freshness information (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7234]&lt;/a&gt;).
   However, POST caching is not widely implemented.  For cases where an
   origin server wishes the client to be able to cache the result of a
   POST in a way that can be reused by a later GET, the origin server
   MAY send a 200 (OK) response containing the result and a
   Content-Location header field that has the same value as the POST's
   effective request URI (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;).

   If the result of processing a POST would be equivalent to a
   representation of an existing resource, an origin server MAY redirect
   the user agent to that resource by sending a 303 (See Other) response
   with the existing resource's identifier in the Location field.  This
   has the benefits of providing the user agent a resource identifier
   and transferring the representation via a method more amenable to
   shared caching, though at the cost of an extra request if the user
   agent does not already have the representation cached.</source>
          <target state="translated">Метод POST требует, чтобы целевой ресурс обработал представление, заключенное в запросе, в соответствии с собственной конкретной семантикой ресурса. Например, POST используется для следующих функций (среди прочего): o Предоставление блока данных, такого как поля, введенные в форму HTML, процессу обработки данных; o Размещение сообщения на доске объявлений, в группе новостей, в списке рассылки, в блоге или в аналогичной группе статей; o Создание нового ресурса, который еще не идентифицирован исходным сервером; и o Добавление данных к существующим представлениям ресурса. Исходный сервер указывает семантику ответа, выбирая соответствующий код состояния в зависимости от результата обработки запроса POST;почти все коды состояния, определенные этой спецификацией, могут быть получены в ответе на POST (за исключением 206 (частичное содержимое), 304 (не изменено) и 416 (диапазон не удовлетворяется)). Если один или несколько ресурсов были созданы на исходном сервере в результате успешной обработки запроса POST, исходный сервер ДОЛЖЕН отправить ответ 201 (Created), содержащий поле заголовка Location, которое предоставляет идентификатор для созданного основного ресурса (исходному серверу СЛЕДУЕТ отправить ответ 201 (Created), содержащий поле заголовка Location, которое предоставляет идентификатор для созданного первичного ресурса (исходному серверу СЛЕДУЕТ отправить ответ 201 (Created), содержащий поле заголовка Location, которое предоставляет идентификатор для созданного первичного ресурса (&lt;a href=&quot;#section-7.1.2&quot;&gt;Раздел 7.1.2&lt;/a&gt; ) и представление, которое описывает статус запроса при ссылке на новый ресурс (ресурсы). Ответы на запросы POST кэшируются только в том случае, если они включают явную информацию о свежести (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;Раздел 4.2.1 [RFC7234]&lt;/a&gt; ). Однако кэширование POST широко не применяется. В случаях, когда исходный сервер желает, чтобы клиент имел возможность кэшировать результат POST таким образом, чтобы его можно было повторно использовать более поздним GET, исходный сервер МОЖЕТ отправить ответ 200 (OK), содержащий результат и Content-Location. поле заголовка, которое имеет то же значение, что и действующий URI запроса POST ( &lt;a href=&quot;#section-3.1.4.2&quot;&gt;раздел 3.1.4.2&lt;/a&gt;). Если результат обработки POST будет эквивалентен представлению существующего ресурса, исходный сервер МОЖЕТ перенаправить пользовательский агент на этот ресурс, отправив ответ 303 (см. Другое) с идентификатором существующего ресурса в поле Location. Это дает преимущества предоставления пользовательскому агенту идентификатора ресурса и передачи представления с помощью метода, более подходящего для совместного кэширования, хотя и за счет дополнительного запроса, если пользовательский агент еще не кэшировал представление.</target>
        </trans-unit>
        <trans-unit id="009ae6509d491675faf3db2c6925c60d8bb4838c" translate="yes" xml:space="preserve">
          <source>The PRIORITY frame (type=0x2) specifies the sender-advised priority
   of a stream (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  It can be sent in any stream state,
   including idle or closed streams. 

    +-+-------------------------------------------------------------+
    |E|                  Stream Dependency (31)                     |
    +-+-------------+-----------------------------------------------+
    |   Weight (8)  |
    +-+-------------+

                     Figure 8: PRIORITY Frame Payload

   The payload of a PRIORITY frame contains the following fields:

   E: A single-bit flag indicating that the stream dependency is
      exclusive (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).

   Stream Dependency:  A 31-bit stream identifier for the stream that
      this stream depends on (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).

   Weight:  An unsigned 8-bit integer representing a priority weight for
      the stream (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  Add one to the value to obtain a
      weight between 1 and 256.

   The PRIORITY frame does not define any flags.

   The PRIORITY frame always identifies a stream.  If a PRIORITY frame
   is received with a stream identifier of 0x0, the recipient MUST
   respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   The PRIORITY frame can be sent on a stream in any state, though it
   cannot be sent between consecutive frames that comprise a single
   header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).  Note that this frame could arrive after
   processing or frame sending has completed, which would cause it to
   have no effect on the identified stream.  For a stream that is in the
   &quot;half-closed (remote)&quot; or &quot;closed&quot; state, this frame can only affect
   processing of the identified stream and its dependent streams; it
   does not affect frame transmission on that stream.

   The PRIORITY frame can be sent for a stream in the &quot;idle&quot; or &quot;closed&quot;
   state.  This allows for the reprioritization of a group of dependent
   streams by altering the priority of an unused or closed parent
   stream.

   A PRIORITY frame with a length other than 5 octets MUST be treated as
   a stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of type FRAME_SIZE_ERROR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="babc13478772ae526be737f6ddcf858ed85d894b" translate="yes" xml:space="preserve">
          <source>The PROPFIND method retrieves properties defined on the resource
   identified by the Request-URI, if the resource does not have any
   internal members, or on the resource identified by the Request-URI
   and potentially its member resources, if the resource is a collection
   that has internal member URLs.  All DAV-compliant resources MUST
   support the PROPFIND method and the propfind XML element
   (&lt;a href=&quot;#section-14.20&quot;&gt;Section 14.20&lt;/a&gt;) along with all XML elements defined for use with that
   element.

   A client MUST submit a Depth header with a value of &quot;0&quot;, &quot;1&quot;, or
   &quot;infinity&quot; with a PROPFIND request.  Servers MUST support &quot;0&quot; and &quot;1&quot;
   depth requests on WebDAV-compliant resources and SHOULD support
   &quot;infinity&quot; requests.  In practice, support for infinite-depth
   requests MAY be disabled, due to the performance and security
   concerns associated with this behavior.  Servers SHOULD treat a
   request without a Depth header as if a &quot;Depth: infinity&quot; header was
   included. 

   A client may submit a 'propfind' XML element in the body of the
   request method describing what information is being requested.  It is
   possible to:

   o  Request particular property values, by naming the properties
      desired within the 'prop' element (the ordering of properties in
      here MAY be ignored by the server),

   o  Request property values for those properties defined in this
      specification (at a minimum) plus dead properties, by using the
      'allprop' element (the 'include' element can be used with
      'allprop' to instruct the server to also include additional live
      properties that may not have been returned otherwise),

   o  Request a list of names of all the properties defined on the
      resource, by using the 'propname' element.

   A client may choose not to submit a request body.  An empty PROPFIND
   request body MUST be treated as if it were an 'allprop' request.

   Note that 'allprop' does not return values for all live properties.
   WebDAV servers increasingly have expensively-calculated or lengthy
   properties (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]) and do not return all
   properties already.  Instead, WebDAV clients can use propname
   requests to discover what live properties exist, and request named
   properties when retrieving values.  For a live property defined
   elsewhere, that definition can specify whether or not that live
   property would be returned in 'allprop' requests.

   All servers MUST support returning a response of content type text/
   xml or application/xml that contains a multistatus XML element that
   describes the results of the attempts to retrieve the various
   properties.

   If there is an error retrieving a property, then a proper error
   result MUST be included in the response.  A request to retrieve the
   value of a property that does not exist is an error and MUST be noted
   with a 'response' XML element that contains a 404 (Not Found) status
   value.

   Consequently, the 'multistatus' XML element for a collection resource
   MUST include a 'response' XML element for each member URL of the
   collection, to whatever depth was requested.  It SHOULD NOT include
   any 'response' elements for resources that are not WebDAV-compliant.
   Each 'response' element MUST contain an 'href' element that contains
   the URL of the resource on which the properties in the prop XML
   element are defined.  Results for a PROPFIND on a collection resource
   are returned as a flat list whose order of entries is not 

   significant.  Note that a resource may have only one value for a
   property of a given name, so the property may only show up once in
   PROPFIND responses.

   Properties may be subject to access control.  In the case of
   'allprop' and 'propname' requests, if a principal does not have the
   right to know whether a particular property exists, then the property
   MAY be silently excluded from the response.

   Some PROPFIND results MAY be cached, with care, as there is no cache
   validation mechanism for most properties.  This method is both safe
   and idempotent (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of [RFC2616]&lt;/a&gt;).</source>
          <target state="translated">Метод PROPFIND извлекает свойства, определенные в ресурсе, идентифицированном Request-URI, если ресурс не имеет внутренних членов, или в ресурсе, идентифицированном Request-URI и, возможно, его ресурсах-членах, если ресурс является коллекцией, имеющей внутренние URL-адреса участников. Все DAV-совместимые ресурсы ДОЛЖНЫ поддерживать метод PROPFIND и XML-элемент propfind ( &lt;a href=&quot;#section-14.20&quot;&gt;раздел 14.20.&lt;/a&gt;) вместе со всеми элементами XML, определенными для использования с этим элементом. Клиент ДОЛЖЕН отправить заголовок глубины со значением &amp;laquo;0&amp;raquo;, &amp;laquo;1&amp;raquo; или &amp;laquo;бесконечность&amp;raquo; с запросом PROPFIND. Серверы ДОЛЖНЫ поддерживать запросы глубины &amp;laquo;0&amp;raquo; и &amp;laquo;1&amp;raquo; для ресурсов, совместимых с WebDAV, и ДОЛЖНЫ поддерживать запросы &amp;laquo;бесконечности&amp;raquo;. На практике поддержка запросов бесконечной глубины МОЖЕТ быть отключена из-за проблем производительности и безопасности, связанных с этим поведением. Серверы ДОЛЖНЫ обрабатывать запрос без заголовка Depth, как если бы был включен заголовок &amp;laquo;Depth: infinity&amp;raquo;. Клиент может отправить XML-элемент propfind в теле метода запроса, описывающий, какая информация запрашивается. Можно: o Запросить определенные значения свойств,путем наименования желаемых свойств в элементе 'prop' (порядок свойств здесь МОЖЕТ игнорироваться сервером), o Запросить значения свойств для тех свойств, которые определены в этой спецификации (как минимум), плюс мертвые свойства, используя ' allprop '(элемент' include 'может использоваться с' allprop ', чтобы указать серверу также включать дополнительные живые свойства, которые в противном случае могли бы не быть возвращены), o Запросите список имен всех свойств, определенных для ресурса, с помощью элемента 'propname'. Клиент может отказаться от отправки тела запроса. Пустое тело запроса PROPFIND ДОЛЖНО обрабатываться, как если бы это был запрос allprop. Обратите внимание, что allprop не возвращает значения для всех действующих свойств.Серверы WebDAV все чаще имеют дорогостоящие или длительные свойства (см. [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ] и [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]) и уже не возвращать все свойства. Вместо этого клиенты WebDAV могут использовать запросы propname, чтобы обнаружить, какие существующие свойства существуют, и запрашивать именованные свойства при извлечении значений. Для живого свойства, определенного в другом месте, это определение может указывать, будет ли это живое свойство возвращаться в запросах allprop. Все серверы ДОЛЖНЫ поддерживать возврат ответа типа содержимого text / xml или application / xml, который содержит элемент XML с несколькими состояниями, который описывает результаты попыток получить различные свойства. Если при получении свойства произошла ошибка, то в ответ ДОЛЖЕН быть включен правильный результат ошибки. Запрос на получение значения несуществующего свойства является ошибкой и ДОЛЖЕН быть отмечен как &amp;laquo;ответ&amp;raquo;.Элемент XML, содержащий значение статуса 404 (не найдено). Следовательно, элемент XML &amp;laquo;мультистатус&amp;raquo; для ресурса коллекции ДОЛЖЕН включать элемент XML &amp;laquo;ответ&amp;raquo; для каждого URL-адреса члена коллекции, независимо от запрошенной глубины. Он НЕ ДОЛЖЕН включать никаких элементов ответа для ресурсов, не совместимых с WebDAV. Каждый элемент response ДОЛЖЕН содержать элемент href, который содержит URL ресурса, для которого определены свойства в элементе prop XML. Результаты для PROPFIND на ресурсе коллекции возвращаются в виде плоского списка, порядок записей которого не имеет значения. Обратите внимание, что ресурс может иметь только одно значение для свойства с заданным именем, поэтому свойство может отображаться только один раз в ответах PROPFIND.Свойства могут подлежать контролю доступа. В случае запросов allprop и propname, если принципал не имеет права знать, существует ли конкретное свойство, то свойство МОЖЕТ быть молча исключено из ответа. Некоторые результаты PROPFIND МОГУТ быть кэшированы с осторожностью, так как для большинства свойств нет механизма проверки кеша. Этот метод безопасен и идемпотентен (см.&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Раздел 9.1 [RFC2616]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="63b7604adf362cf9b58baac42bf0c778df2e71b7" translate="yes" xml:space="preserve">
          <source>The PROPPATCH method processes instructions specified in the request
   body to set and/or remove properties defined on the resource
   identified by the Request-URI.

   All DAV-compliant resources MUST support the PROPPATCH method and
   MUST process instructions that are specified using the
   propertyupdate, set, and remove XML elements.  Execution of the
   directives in this method is, of course, subject to access control
   constraints.  DAV-compliant resources SHOULD support the setting of
   arbitrary dead properties.

   The request message body of a PROPPATCH method MUST contain the
   propertyupdate XML element.

   Servers MUST process PROPPATCH instructions in document order (an
   exception to the normal rule that ordering is irrelevant).
   Instructions MUST either all be executed or none executed.  Thus, if
   any error occurs during processing, all executed instructions MUST be
   undone and a proper error result returned.  Instruction processing
   details can be found in the definition of the set and remove
   instructions in Sections &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; and &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;.

   If a server attempts to make any of the property changes in a
   PROPPATCH request (i.e., the request is not rejected for high-level
   errors before processing the body), the response MUST be a Multi-
   Status response as described in &lt;a href=&quot;#section-9.2.1&quot;&gt;Section 9.2.1&lt;/a&gt;.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">Метод PROPPATCH обрабатывает инструкции, указанные в теле запроса, для установки и / или удаления свойств, определенных для ресурса, идентифицированного Request-URI. Все DAV-совместимые ресурсы ДОЛЖНЫ поддерживать метод PROPPATCH и ДОЛЖНЫ обрабатывать инструкции, указанные с помощью элементов XML propertyupdate, set и remove. Выполнение директив в этом методе, конечно, зависит от ограничений управления доступом. Ресурсы, совместимые с DAV, ДОЛЖНЫ поддерживать установку произвольных мертвых свойств. Тело сообщения запроса метода PROPPATCH ДОЛЖНО содержать XML-элемент propertyupdate. Серверы ДОЛЖНЫ обрабатывать инструкции PROPPATCH в порядке документа (исключение из обычного правила, что порядок не имеет значения). Инструкции ДОЛЖНЫ выполняться либо все, либо ни одна из них. Таким образом,если во время обработки возникает какая-либо ошибка, все выполненные инструкции ДОЛЖНЫ быть отменены и возвращен правильный результат ошибки. Подробности обработки инструкций можно найти в определении инструкций установки и удаления в разделах&lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; и &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; . Если сервер пытается внести какие-либо изменения свойств в запросе PROPPATCH (т. Е. Запрос не отклоняется из-за ошибок высокого уровня до обработки тела), ответ ДОЛЖЕН быть ответом с несколькими состояниями, как описано в &lt;a href=&quot;#section-9.2.1&quot;&gt;разделе 9.2.1.&lt;/a&gt; , Этот метод идемпотентен, но небезопасен (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Раздел 9.1 [RFC2616]&lt;/a&gt; ). Ответы на этот метод НЕ ДОЛЖНЫ кэшироваться.</target>
        </trans-unit>
        <trans-unit id="601421813323ca4f0788af9d830329726cc8945b" translate="yes" xml:space="preserve">
          <source>The PUSH_PROMISE frame (type=0x5) is used to notify the peer endpoint
   in advance of streams the sender intends to initiate.  The
   PUSH_PROMISE frame includes the unsigned 31-bit identifier of the
   stream the endpoint plans to create along with a set of headers that
   provide additional context for the stream.  &lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt; contains a
   thorough description of the use of PUSH_PROMISE frames.

    +---------------+
    |Pad Length? (8)|
    +-+-------------+-----------------------------------------------+
    |R|                  Promised Stream ID (31)                    |
    +-+-----------------------------+-------------------------------+
    |                   Header Block Fragment (*)                 
    +---------------------------------------------------------------+
    |                           Padding (*)                       
    +---------------------------------------------------------------+

                  Figure 11: PUSH_PROMISE Payload Format

   The PUSH_PROMISE frame payload has the following fields:

   Pad Length:  An 8-bit field containing the length of the frame
      padding in units of octets.  This field is only present if the
      PADDED flag is set.

   R: A single reserved bit.

   Promised Stream ID:  An unsigned 31-bit integer that identifies the
      stream that is reserved by the PUSH_PROMISE.  The promised stream
      identifier MUST be a valid choice for the next stream sent by the
      sender (see &quot;new stream identifier&quot; in &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;).

   Header Block Fragment:  A header block fragment (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;)
      containing request header fields.

   Padding:  Padding octets. 

   The PUSH_PROMISE frame defines the following flags:

   END_HEADERS (0x4):  When set, bit 2 indicates that this frame
      contains an entire header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) and is not followed
      by any CONTINUATION frames.

      A PUSH_PROMISE frame without the END_HEADERS flag set MUST be
      followed by a CONTINUATION frame for the same stream.  A receiver
      MUST treat the receipt of any other type of frame or a frame on a
      different stream as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
      PROTOCOL_ERROR.

   PADDED (0x8):  When set, bit 3 indicates that the Pad Length field
      and any padding that it describes are present.

   PUSH_PROMISE frames MUST only be sent on a peer-initiated stream that
   is in either the &quot;open&quot; or &quot;half-closed (remote)&quot; state.  The stream
   identifier of a PUSH_PROMISE frame indicates the stream it is
   associated with.  If the stream identifier field specifies the value
   0x0, a recipient MUST respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;)
   of type PROTOCOL_ERROR.

   Promised streams are not required to be used in the order they are
   promised.  The PUSH_PROMISE only reserves stream identifiers for
   later use.

   PUSH_PROMISE MUST NOT be sent if the SETTINGS_ENABLE_PUSH setting of
   the peer endpoint is set to 0.  An endpoint that has set this setting
   and has received acknowledgement MUST treat the receipt of a
   PUSH_PROMISE frame as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   Recipients of PUSH_PROMISE frames can choose to reject promised
   streams by returning a RST_STREAM referencing the promised stream
   identifier back to the sender of the PUSH_PROMISE.

   A PUSH_PROMISE frame modifies the connection state in two ways.
   First, the inclusion of a header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) potentially
   modifies the state maintained for header compression.  Second,
   PUSH_PROMISE also reserves a stream for later use, causing the
   promised stream to enter the &quot;reserved&quot; state.  A sender MUST NOT
   send a PUSH_PROMISE on a stream unless that stream is either &quot;open&quot;
   or &quot;half-closed (remote)&quot;; the sender MUST ensure that the promised
   stream is a valid choice for a new stream identifier (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;)
   (that is, the promised stream MUST be in the &quot;idle&quot; state). 

   Since PUSH_PROMISE reserves a stream, ignoring a PUSH_PROMISE frame
   causes the stream state to become indeterminate.  A receiver MUST
   treat the receipt of a PUSH_PROMISE on a stream that is neither
   &quot;open&quot; nor &quot;half-closed (local)&quot; as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.  However, an endpoint that
   has sent RST_STREAM on the associated stream MUST handle PUSH_PROMISE
   frames that might have been created before the RST_STREAM frame is
   received and processed.

   A receiver MUST treat the receipt of a PUSH_PROMISE that promises an
   illegal stream identifier (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;) as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.  Note that an illegal stream
   identifier is an identifier for a stream that is not currently in the
   &quot;idle&quot; state.

   The PUSH_PROMISE frame can include padding.  Padding fields and flags
   are identical to those defined for DATA frames (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1975f22fa255d880d63431b9c6a1e839eaebbdbb" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the enclosed entity be stored under the
   supplied Request-URI. If the Request-URI refers to an already
   existing resource, the enclosed entity SHOULD be considered as a
   modified version of the one residing on the origin server. If the
   Request-URI does not point to an existing resource, and that URI is
   capable of being defined as a new resource by the requesting user
   agent, the origin server can create the resource with that URI. If a
   new resource is created, the origin server MUST inform the user agent
   via the 201 (Created) response. If an existing resource is modified,
   either the 200 (OK) or 204 (No Content) response codes SHOULD be sent
   to indicate successful completion of the request. If the resource
   could not be created or modified with the Request-URI, an appropriate
   error response SHOULD be given that reflects the nature of the
   problem. The recipient of the entity MUST NOT ignore any Content-*
   (e.g. Content-Range) headers that it does not understand or implement
   and MUST return a 501 (Not Implemented) response in such cases.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.

   The fundamental difference between the POST and PUT requests is
   reflected in the different meaning of the Request-URI. The URI in a
   POST request identifies the resource that will handle the enclosed
   entity. That resource might be a data-accepting process, a gateway to
   some other protocol, or a separate entity that accepts annotations.
   In contrast, the URI in a PUT request identifies the entity enclosed
   with the request -- the user agent knows what URI is intended and the
   server MUST NOT attempt to apply the request to some other resource.
   If the server desires that the request be applied to a different URI, 

   it MUST send a 301 (Moved Permanently) response; the user agent MAY
   then make its own decision regarding whether or not to redirect the
   request.

   A single resource MAY be identified by many different URIs. For
   example, an article might have a URI for identifying &quot;the current
   version&quot; which is separate from the URI identifying each particular
   version. In this case, a PUT request on a general URI might result in
   several other URIs being defined by the origin server.

   HTTP/1.1 does not define how a PUT method affects the state of an
   origin server.

   PUT requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   Unless otherwise specified for a particular entity-header, the
   entity-headers in the PUT request SHOULD be applied to the resource
   created or modified by the PUT.</source>
          <target state="translated">Метод PUT запрашивает, чтобы закрытый объект был сохранен под предоставленным Request-URI. Если Request-URI относится к уже существующему ресурсу, вложенный объект СЛЕДУЕТ рассматривать как модифицированную версию того, что находится на исходном сервере. Если Request-URI не указывает на существующий ресурс и этот URI может быть определен как новый ресурс запрашивающим пользовательским агентом, исходный сервер может создать ресурс с этим URI. Если создается новый ресурс, исходный сервер ДОЛЖЕН проинформировать пользовательский агент через ответ 201 (Created). Если существующий ресурс изменен, ДОЛЖНЫ быть отправлены коды ответа 200 (ОК) или 204 (Нет содержимого), чтобы указать на успешное завершение запроса. Если ресурс не может быть создан или изменен с помощью Request-URI,ДОЛЖЕН быть предоставлен соответствующий ответ об ошибке, который отражает характер проблемы. Получатель объекта НЕ ДОЛЖЕН игнорировать какие-либо заголовки Content- * (например, Content-Range), которые он не понимает или не реализует, и ДОЛЖЕН возвращать ответ 501 (не реализовано) в таких случаях. Если запрос проходит через кеш и Request-URI идентифицирует один или несколько кэшированных в данный момент объектов, эти записи СЛЕДУЕТ рассматривать как устаревшие. Ответы на этот метод не кэшируются. Принципиальная разница между запросами POST и PUT отражается в различном значении Request-URI. URI в запросе POST определяет ресурс, который будет обрабатывать вложенный объект. Этот ресурс может быть процессом приема данных, шлюзом к другому протоколу или отдельным объектом, который принимает аннотации.Напротив, URI в запросе PUT идентифицирует объект, заключенный с запросом - пользовательский агент знает, какой URI предназначен, и сервер НЕ ДОЛЖЕН пытаться применить запрос к какому-либо другому ресурсу. Если сервер желает, чтобы запрос был применен к другому URI, он ДОЛЖЕН отправить ответ 301 (перемещен навсегда); затем пользовательский агент МОЖЕТ принять собственное решение относительно перенаправления запроса. Один ресурс МОЖЕТ идентифицироваться множеством разных URI. Например, статья может иметь URI для идентификации &amp;laquo;текущей версии&amp;raquo;, который отличается от URI, идентифицирующего каждую конкретную версию. В этом случае запрос PUT для общего URI может привести к тому, что сервер-источник определит несколько других URI. HTTP / 1.1 не определяет, как метод PUT влияет на состояние исходного сервера. Запросы PUT ДОЛЖНЫ подчиняться требованиям передачи сообщений, изложенным в&lt;a href=&quot;#section-8.2&quot;&gt;раздел 8.2&lt;/a&gt; . Если иное не указано для конкретного заголовка объекта, заголовки объекта в запросе PUT ДОЛЖНЫ применяться к ресурсу, созданному или измененному PUT.</target>
        </trans-unit>
        <trans-unit id="7beb3539a595c62f6de09ee642f7b3a560d38b59" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the state of the target resource be
   created or replaced with the state defined by the representation
   enclosed in the request message payload.  A successful PUT of a given
   representation would suggest that a subsequent GET on that same
   target resource will result in an equivalent representation being
   sent in a 200 (OK) response.  However, there is no guarantee that 

   such a state change will be observable, since the target resource
   might be acted upon by other user agents in parallel, or might be
   subject to dynamic processing by the origin server, before any
   subsequent GET is received.  A successful response only implies that
   the user agent's intent was achieved at the time of its processing by
   the origin server.

   If the target resource does not have a current representation and the
   PUT successfully creates one, then the origin server MUST inform the
   user agent by sending a 201 (Created) response.  If the target
   resource does have a current representation and that representation
   is successfully modified in accordance with the state of the enclosed
   representation, then the origin server MUST send either a 200 (OK) or
   a 204 (No Content) response to indicate successful completion of the
   request.

   An origin server SHOULD ignore unrecognized header fields received in
   a PUT request (i.e., do not save them as part of the resource state).

   An origin server SHOULD verify that the PUT representation is
   consistent with any constraints the server has for the target
   resource that cannot or will not be changed by the PUT.  This is
   particularly important when the origin server uses internal
   configuration information related to the URI in order to set the
   values for representation metadata on GET responses.  When a PUT
   representation is inconsistent with the target resource, the origin
   server SHOULD either make them consistent, by transforming the
   representation or changing the resource configuration, or respond
   with an appropriate error message containing sufficient information
   to explain why the representation is unsuitable.  The 409 (Conflict)
   or 415 (Unsupported Media Type) status codes are suggested, with the
   latter being specific to constraints on Content-Type values.

   For example, if the target resource is configured to always have a
   Content-Type of &quot;text/html&quot; and the representation being PUT has a
   Content-Type of &quot;image/jpeg&quot;, the origin server ought to do one of:

   a.  reconfigure the target resource to reflect the new media type;

   b.  transform the PUT representation to a format consistent with that
       of the resource before saving it as the new resource state; or,

   c.  reject the request with a 415 (Unsupported Media Type) response
       indicating that the target resource is limited to &quot;text/html&quot;,
       perhaps including a link to a different resource that would be a
       suitable target for the new representation. 

   HTTP does not define exactly how a PUT method affects the state of an
   origin server beyond what can be expressed by the intent of the user
   agent request and the semantics of the origin server response.  It
   does not define what a resource might be, in any sense of that word,
   beyond the interface provided via HTTP.  It does not define how
   resource state is &quot;stored&quot;, nor how such storage might change as a
   result of a change in resource state, nor how the origin server
   translates resource state into representations.  Generally speaking,
   all implementation details behind the resource interface are
   intentionally hidden by the server.

   An origin server MUST NOT send a validator header field
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;), such as an ETag or Last-Modified field, in a
   successful response to PUT unless the request's representation data
   was saved without any transformation applied to the body (i.e., the
   resource's new representation data is identical to the representation
   data received in the PUT request) and the validator field value
   reflects the new representation.  This requirement allows a user
   agent to know when the representation body it has in memory remains
   current as a result of the PUT, thus not in need of being retrieved
   again from the origin server, and that the new validator(s) received
   in the response can be used for future conditional requests in order
   to prevent accidental overwrites (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

   The fundamental difference between the POST and PUT methods is
   highlighted by the different intent for the enclosed representation.
   The target resource in a POST request is intended to handle the
   enclosed representation according to the resource's own semantics,
   whereas the enclosed representation in a PUT request is defined as
   replacing the state of the target resource.  Hence, the intent of PUT
   is idempotent and visible to intermediaries, even though the exact
   effect is only known by the origin server.

   Proper interpretation of a PUT request presumes that the user agent
   knows which target resource is desired.  A service that selects a
   proper URI on behalf of the client, after receiving a state-changing
   request, SHOULD be implemented using the POST method rather than PUT.
   If the origin server will not make the requested PUT state change to
   the target resource and instead wishes to have it applied to a
   different resource, such as when the resource has been moved to a
   different URI, then the origin server MUST send an appropriate 3xx
   (Redirection) response; the user agent MAY then make its own decision
   regarding whether or not to redirect the request.

   A PUT request applied to the target resource can have side effects on
   other resources.  For example, an article might have a URI for
   identifying &quot;the current version&quot; (a resource) that is separate from
   the URIs identifying each particular version (different resources 

   that at one point shared the same state as the current version
   resource).  A successful PUT request on &quot;the current version&quot; URI
   might therefore create a new version resource in addition to changing
   the state of the target resource, and might also cause links to be
   added between the related resources.

   An origin server that allows PUT on a given target resource MUST send
   a 400 (Bad Request) response to a PUT request that contains a
   Content-Range header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7233]&lt;/a&gt;), since the
   payload is likely to be partial content that has been mistakenly PUT
   as a full representation.  Partial content updates are possible by
   targeting a separately identified resource with state that overlaps a
   portion of the larger resource, or by using a different method that
   has been specifically defined for partial updates (for example, the
   PATCH method defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt;]).

   Responses to the PUT method are not cacheable.  If a successful PUT
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Метод PUT требует, чтобы состояние целевого ресурса было создано или заменено состоянием, определенным представлением, заключенным в полезные данные сообщения запроса. Успешный PUT данного представления предполагает, что последующий GET для того же целевого ресурса приведет к отправке эквивалентного представления в ответе 200 (OK). Однако нет никакой гарантии, что такое изменение состояния будет наблюдаемым, поскольку целевой ресурс может обрабатываться другими пользовательскими агентами параллельно или может подвергаться динамической обработке исходным сервером до получения любого последующего GET. Успешный ответ только означает, что намерение пользовательского агента было достигнуто во время его обработки исходным сервером.Если целевой ресурс не имеет текущего представления и PUT успешно его создает, то исходный сервер ДОЛЖЕН проинформировать пользовательский агент, отправив ответ 201 (Создано). Если целевой ресурс действительно имеет текущее представление и это представление успешно модифицируется в соответствии с состоянием вложенного представления, то исходный сервер ДОЛЖЕН отправить ответ 200 (ОК) или 204 (Нет содержимого), чтобы указать на успешное завершение запрос. Сервер-источник ДОЛЖЕН игнорировать нераспознанные поля заголовка, полученные в запросе PUT (т. Е. Не сохранять их как часть состояния ресурса). Исходный сервер ДОЛЖЕН проверять, что представление PUT согласуется с любыми ограничениями, которые сервер имеет для целевого ресурса, которые не могут или не будут изменены PUT.Это особенно важно, когда исходный сервер использует внутреннюю информацию о конфигурации, связанную с URI, для установки значений для метаданных представления в ответах GET. Когда представление PUT несовместимо с целевым ресурсом, исходный сервер ДОЛЖЕН либо сделать их согласованными, преобразовав представление или изменив конфигурацию ресурса, либо ответить соответствующим сообщением об ошибке, содержащим достаточно информации, чтобы объяснить, почему представление непригодно. Предлагаются коды состояния 409 (конфликт) или 415 (неподдерживаемый тип носителя), причем последний относится к ограничениям на значения Content-Type. Например, если целевой ресурс настроен так, чтобы всегда иметь Content-Type &amp;laquo;text / html&amp;raquo;и представление PUT имеет Content-Type &quot;image / jpeg&quot;, исходный сервер должен выполнить одно из следующих действий: a. перенастроить целевой ресурс для отражения нового типа носителя; б. преобразовать представление PUT в формат, совместимый с форматом ресурса, перед сохранением его в качестве нового состояния ресурса; или, c. отклонить запрос с ответом 415 (неподдерживаемый тип мультимедиа), указывающим, что целевой ресурс ограничен &amp;laquo;текстом / html&amp;raquo;, возможно, включая ссылку на другой ресурс, который будет подходящей целью для нового представления. HTTP не определяет точно, как метод PUT влияет на состояние исходного сервера, помимо того, что может быть выражено намерением запроса пользовательского агента и семантикой ответа исходного сервера.Он не определяет, каким может быть ресурс в любом смысле этого слова, помимо интерфейса, предоставляемого через HTTP. Он не определяет, как &amp;laquo;сохраняется&amp;raquo; состояние ресурса, ни то, как такое хранилище может измениться в результате изменения состояния ресурса, ни то, как исходный сервер переводит состояние ресурса в представления. Вообще говоря, все детали реализации интерфейса ресурса намеренно скрыты сервером. Исходный сервер НЕ ДОЛЖЕН отправлять поле заголовка валидатора (все детали реализации за интерфейсом ресурса намеренно скрыты сервером. Исходный сервер НЕ ДОЛЖЕН отправлять поле заголовка валидатора (все детали реализации за интерфейсом ресурса намеренно скрыты сервером. Исходный сервер НЕ ДОЛЖЕН отправлять поле заголовка валидатора (&lt;a href=&quot;#section-7.2&quot;&gt;Раздел 7.2&lt;/a&gt; ), например, поле ETag или Last-Modified, в успешном ответе на PUT, если данные представления запроса не были сохранены без какого-либо преобразования, примененного к телу (т. Е. Новые данные представления ресурса идентичны данным представления, полученным в запрос PUT), а значение поля валидатора отражает новое представление. Это требование позволяет пользовательскому агенту знать, когда тело представления, которое он имеет в памяти, остается текущим в результате PUT, таким образом, не нуждается в повторном получении с исходного сервера, и что новый валидатор (-ы), полученный в ответе может использоваться для будущих условных запросов, чтобы предотвратить случайную перезапись ( &lt;a href=&quot;#section-5.2&quot;&gt;Раздел 5.2&lt;/a&gt;). Принципиальное различие между методами POST и PUT подчеркивается разным предназначением вложенного представления. Целевой ресурс в запросе POST предназначен для обработки вложенного представления в соответствии с собственной семантикой ресурса, тогда как вложенное представление в запросе PUT определяется как заменяющее состояние целевого ресурса. Следовательно, цель PUT идемпотентна и видна посредникам, даже если точный эффект известен только исходному серверу. Правильная интерпретация запроса PUT предполагает, что пользовательский агент знает, какой целевой ресурс требуется. Сервис, который выбирает правильный URI от имени клиента после получения запроса на изменение состояния, ДОЛЖЕН быть реализован с использованием метода POST, а не PUT.Если исходный сервер не будет выполнять запрошенное изменение состояния PUT для целевого ресурса и вместо этого хочет, чтобы оно было применено к другому ресурсу, например, когда ресурс был перемещен на другой URI, тогда исходный сервер ДОЛЖЕН отправить соответствующий 3xx (Перенаправление) ответ; затем пользовательский агент МОЖЕТ принять собственное решение относительно перенаправления запроса. Запрос PUT, примененный к целевому ресурсу, может иметь побочные эффекты для других ресурсов. Например, статья может иметь URI для идентификации &amp;laquo;текущей версии&amp;raquo; (ресурса), который отличается от URI, идентифицирующих каждую конкретную версию (разные ресурсы, которые в какой-то момент имели то же состояние, что и ресурс текущей версии). Успешный запрос PUT для &amp;laquo;текущей версии&amp;raquo;Таким образом, URI может создавать ресурс новой версии в дополнение к изменению состояния целевого ресурса, а также может вызывать добавление ссылок между связанными ресурсами. Сервер-источник, который разрешает PUT для данного целевого ресурса, ДОЛЖЕН отправить ответ 400 (Bad Request) на запрос PUT, который содержит поле заголовка Content-Range (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;Раздел 4.2 [RFC7233]&lt;/a&gt; ), поскольку полезная нагрузка, скорее всего, является частичным содержанием, которое было ошибочно PUT как полное представление. Частичные обновления контента возможны путем нацеливания на отдельно идентифицированный ресурс с состоянием, которое перекрывает часть большего ресурса, или с использованием другого метода, который был специально определен для частичных обновлений (например, метод PATCH, определенный в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt; ]). Ответы на метод PUT не кэшируются. Если успешный запрос PUT проходит через кеш, в котором есть один или несколько сохраненных ответов для действующего URI запроса, эти сохраненные ответы будут признаны недействительными (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Раздел 4.4 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6e42dfbab6315a9d1786cb94b26bfc16b764a831" translate="yes" xml:space="preserve">
          <source>The Pragma general-header field is used to include implementation-
   specific directives that might apply to any recipient along the
   request/response chain. All pragma directives specify optional
   behavior from the viewpoint of the protocol; however, some systems
   MAY require that behavior be consistent with the directives.

       Pragma            = &quot;Pragma&quot; &quot;:&quot; 1#pragma-directive
       pragma-directive  = &quot;no-cache&quot; | extension-pragma
       extension-pragma  = token [ &quot;=&quot; ( token | quoted-string ) ]

   When the no-cache directive is present in a request message, an
   application SHOULD forward the request toward the origin server even
   if it has a cached copy of what is being requested. This pragma
   directive has the same semantics as the no-cache cache-directive (see
   &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;) and is defined here for backward compatibility with
   HTTP/1.0. Clients SHOULD include both header fields when a no-cache
   request is sent to a server not known to be HTTP/1.1 compliant. 

   Pragma directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a pragma for a
   specific recipient; however, any pragma directive not relevant to a
   recipient SHOULD be ignored by that recipient.

   HTTP/1.1 caches SHOULD treat &quot;Pragma: no-cache&quot; as if the client had
   sent &quot;Cache-Control: no-cache&quot;. No new Pragma directives will be
   defined in HTTP.

      Note: because the meaning of &quot;Pragma: no-cache as a response
      header field is not actually specified, it does not provide a
      reliable replacement for &quot;Cache-Control: no-cache&quot; in a response</source>
          <target state="translated">Поле общего заголовка Pragma используется для включения директив, зависящих от реализации, которые могут применяться к любому получателю в цепочке запроса / ответа. Все директивы pragma определяют необязательное поведение с точки зрения протокола; однако некоторые системы МОГУТ требовать, чтобы поведение соответствовало директивам. Pragma = &quot;Pragma&quot; &quot;:&quot; 1 # директива-директива pragma-directive = &quot;no-cache&quot; | extension-pragma extension-pragma = token [&quot;=&quot; (token | quoted-string)] Когда директива no-cache присутствует в сообщении запроса, приложение ДОЛЖНО пересылать запрос исходному серверу, даже если у него есть кешированная копия того, что запрашивается. Эта директива pragma имеет ту же семантику, что и директива кеширования no-cache (см. &lt;a href=&quot;#section-14.9&quot;&gt;Раздел 14.9.&lt;/a&gt;) и определен здесь для обратной совместимости с HTTP / 1.0. Клиенты ДОЛЖНЫ включать оба поля заголовка, когда запрос без кеширования отправляется на сервер, который, как известно, не совместим с HTTP / 1.1. Директивы Pragma ДОЛЖНЫ проходить через прокси-сервер или приложение-шлюз, независимо от их значения для этого приложения, поскольку директивы могут применяться ко всем получателям в цепочке запросов / ответов. Невозможно указать прагму для конкретного получателя; однако любая директива pragma, не относящаяся к получателю, ДОЛЖНА игнорироваться этим получателем. Кеши HTTP / 1.1 ДОЛЖНЫ обрабатывать &amp;laquo;Pragma: no-cache&amp;raquo;, как если бы клиент отправил &amp;laquo;Cache-Control: no-cache&amp;raquo;. Никакие новые директивы Pragma не будут определены в HTTP. Примечание: поскольку значение &amp;laquo;Прагма:no-cache в качестве поля заголовка ответа на самом деле не указано, он не обеспечивает надежную замену &quot;Cache-Control: no-cache&quot; в ответе</target>
        </trans-unit>
        <trans-unit id="871bcdf53c1b79539586617d7fc176e073aa2706" translate="yes" xml:space="preserve">
          <source>The Proxy-Authenticate response-header field MUST be included as part
   of a 407 (Proxy Authentication Required) response. The field value
   consists of a challenge that indicates the authentication scheme and
   parameters applicable to the proxy for this Request-URI.

       Proxy-Authenticate  = &quot;Proxy-Authenticate&quot; &quot;:&quot; 1#challenge

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. Unlike
   WWW-Authenticate, the Proxy-Authenticate header field applies only to
   the current connection and SHOULD NOT be passed on to downstream
   clients. However, an intermediate proxy might need to obtain its own
   credentials by requesting them from the downstream client, which in
   some circumstances will appear as if the proxy is forwarding the
   Proxy-Authenticate header field.</source>
          <target state="translated">Поле заголовка ответа Proxy-Authenticate ДОЛЖНО быть включено как часть ответа 407 (Proxy Authentication Required). Значение поля состоит из запроса, который указывает схему аутентификации и параметры, применимые к прокси для этого Request-URI. Proxy-Authenticate = &quot;Proxy-Authenticate&quot; &quot;:&quot; 1 # проблема Процесс аутентификации HTTP-доступа описан в &quot;HTTP-аутентификации: базовая и дайджест-аутентификация доступа&quot; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. В отличие от WWW-Authenticate, поле заголовка Proxy-Authenticate применяется только к текущему соединению и НЕ ДОЛЖНО передаваться нижестоящим клиентам. Однако промежуточному прокси-серверу может потребоваться получить свои собственные учетные данные, запросив их у нижестоящего клиента, что в некоторых случаях будет выглядеть так, как если бы прокси пересылал поле заголовка Proxy-Authenticate.</target>
        </trans-unit>
        <trans-unit id="ad6052a85e2e7f8497d8ed5920ca77e487770b52" translate="yes" xml:space="preserve">
          <source>The Proxy-Authorization request-header field allows the client to
   identify itself (or its user) to a proxy which requires
   authentication. The Proxy-Authorization field value consists of
   credentials containing the authentication information of the user
   agent for the proxy and/or realm of the resource being requested.

       Proxy-Authorization     = &quot;Proxy-Authorization&quot; &quot;:&quot; credentials

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;] . Unlike
   Authorization, the Proxy-Authorization header field applies only to
   the next outbound proxy that demanded authentication using the Proxy-
   Authenticate field. When multiple proxies are used in a chain, the 

   Proxy-Authorization header field is consumed by the first outbound
   proxy that was expecting to receive credentials. A proxy MAY relay
   the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.</source>
          <target state="translated">Поле заголовка запроса Proxy-Authorization позволяет клиенту идентифицировать себя (или своего пользователя) для прокси, который требует аутентификации. Значение поля Proxy-Authorization состоит из учетных данных, содержащих информацию аутентификации пользовательского агента для прокси и / или области запрашиваемого ресурса. Proxy-Authorization = &quot;Proxy-Authorization&quot; &quot;:&quot; учетные данные Процесс аутентификации HTTP-доступа описан в &quot;HTTP-аутентификации: базовая и дайджест-аутентификация доступа&quot; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. В отличие от авторизации, поле заголовка Proxy-Authorization применяется только к следующему исходящему прокси-серверу, который потребовал аутентификации с использованием поля Proxy-Authenticate. Когда в цепочке используются несколько прокси, поле заголовка Proxy-Authorization используется первым исходящим прокси, который ожидал получить учетные данные. Прокси-сервер МОЖЕТ передавать учетные данные из клиентского запроса следующему прокси-серверу, если это механизм, с помощью которого прокси-серверы совместно аутентифицируют данный запрос.</target>
        </trans-unit>
        <trans-unit id="3fb25443f99d4a6f4c3661e5265360468e08d470" translate="yes" xml:space="preserve">
          <source>The RST_STREAM frame (type=0x3) allows for immediate termination of a
   stream.  RST_STREAM is sent to request cancellation of a stream or to
   indicate that an error condition has occurred.

    +---------------------------------------------------------------+
    |                        Error Code (32)                        |
    +---------------------------------------------------------------+

                    Figure 9: RST_STREAM Frame Payload

   The RST_STREAM frame contains a single unsigned, 32-bit integer
   identifying the error code (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).  The error code indicates why
   the stream is being terminated.

   The RST_STREAM frame does not define any flags.

   The RST_STREAM frame fully terminates the referenced stream and
   causes it to enter the &quot;closed&quot; state.  After receiving a RST_STREAM
   on a stream, the receiver MUST NOT send additional frames for that
   stream, with the exception of PRIORITY.  However, after sending the
   RST_STREAM, the sending endpoint MUST be prepared to receive and
   process additional frames sent on the stream that might have been
   sent by the peer prior to the arrival of the RST_STREAM.

   RST_STREAM frames MUST be associated with a stream.  If a RST_STREAM
   frame is received with a stream identifier of 0x0, the recipient MUST
   treat this as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   RST_STREAM frames MUST NOT be sent for a stream in the &quot;idle&quot; state.
   If a RST_STREAM frame identifying an idle stream is received, the
   recipient MUST treat this as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of
   type PROTOCOL_ERROR.

   A RST_STREAM frame with a length other than 4 octets MUST be treated
   as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type FRAME_SIZE_ERROR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e20c61425846c0564c678e617e3a0e40ac8e14" translate="yes" xml:space="preserve">
          <source>The Referer[sic] request-header field allows the client to specify,
   for the server's benefit, the address (URI) of the resource from
   which the Request-URI was obtained (the &quot;referrer&quot;, although the
   header field is misspelled.) The Referer request-header allows a
   server to generate lists of back-links to resources for interest,
   logging, optimized caching, etc. It also allows obsolete or mistyped
   links to be traced for maintenance. The Referer field MUST NOT be
   sent if the Request-URI was obtained from a source that does not have
   its own URI, such as input from the user keyboard.

       Referer        = &quot;Referer&quot; &quot;:&quot; ( absoluteURI | relativeURI )

   Example:

       Referer: &lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http://www.w3.org/hypertext/DataSources/Overview.html&lt;/a&gt; 

   If the field value is a relative URI, it SHOULD be interpreted
   relative to the Request-URI. The URI MUST NOT include a fragment. See
   &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">Поле заголовка запроса Referer [sic] позволяет клиенту указать, для удобства сервера, адрес (URI) ресурса, из которого был получен Request-URI (&quot;реферер&quot;, хотя в поле заголовка написано с ошибкой). Заголовок запроса Referer позволяет серверу создавать списки обратных ссылок на ресурсы для интереса, ведения журнала, оптимизированного кэширования и т. Д. Он также позволяет отслеживать устаревшие или ошибочно введенные ссылки для обслуживания. Поле Referer НЕ ДОЛЖНО отправляться, если Request-URI был получен из источника, не имеющего своего собственного URI, такого как ввод с пользовательской клавиатуры. Referer = &quot;Referer&quot; &quot;:&quot; (absoluteURI | relativeURI) Пример: Referer: &lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http://www.w3.org/hypertext/DataSources/Overview.html&lt;/a&gt; Если значение поля является относительным URI, его СЛЕДУЕТ интерпретировать относительно Request-URI. URI НЕ ДОЛЖЕН включать фрагмент. См. &lt;a href=&quot;#section-15.1.3&quot;&gt;Раздел 15.1.3&lt;/a&gt; по соображениям безопасности.</target>
        </trans-unit>
        <trans-unit id="c0091308c0468b84ee0f64008295744c23a2f601" translate="yes" xml:space="preserve">
          <source>The Referer[sic] request-header field allows the client to specify,
   for the server's benefit, the address (URI) of the resource from
   which the Request-URI was obtained (the &quot;referrer&quot;, although the
   header field is misspelled.) The Referer request-header allows a
   server to generate lists of back-links to resources for interest,
   logging, optimized caching, etc. It also allows obsolete or mistyped
   links to be traced for maintenance. The Referer field MUST NOT be
   sent if the Request-URI was obtained from a source that does not have
   its own URI, such as input from the user keyboard.

       Referer        = &quot;Referer&quot; &quot;:&quot; ( absoluteURI | relativeURI )

   Example:

       Referer: &lt;a href=&quot;https://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http://www.w3.org/hypertext/DataSources/Overview.html&lt;/a&gt; 

   If the field value is a relative URI, it SHOULD be interpreted
   relative to the Request-URI. The URI MUST NOT include a fragment. See
   &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada285615064adfa5d8e8460b22e8d2e1a9f7a60" translate="yes" xml:space="preserve">
          <source>The Request-Line begins with a method token, followed by the
   Request-URI and the protocol version, and ending with CRLF. The
   elements are separated by SP characters. No CR or LF is allowed
   except in the final CRLF sequence.

        Request-Line   = Method SP Request-URI SP HTTP-Version CRLF</source>
          <target state="translated">Линия запросов начинается с маркера метода,за которым следует Request-URI и версия протокола,и заканчивается CRLF.Элементы разделены символами SP.Ни CR,ни LF не допускаются,кроме как в окончательной последовательности CRLF.Request-Line=метод SP Request-URI SP HTTP-Version CRLF.</target>
        </trans-unit>
        <trans-unit id="8314c65661bfa76aafcdfccc2a0cabd4c8b07f40" translate="yes" xml:space="preserve">
          <source>The Request-URI is a Uniform Resource Identifier (&lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;) and
   identifies the resource upon which to apply the request.

       Request-URI    = &quot;*&quot; | absoluteURI | abs_path | authority

   The four options for Request-URI are dependent on the nature of the
   request. The asterisk &quot;*&quot; means that the request does not apply to a
   particular resource, but to the server itself, and is only allowed
   when the method used does not necessarily apply to a resource. One
   example would be

       OPTIONS * HTTP/1.1

   The absoluteURI form is REQUIRED when the request is being made to a
   proxy. The proxy is requested to forward the request or service it
   from a valid cache, and return the response. Note that the proxy MAY
   forward the request on to another proxy or directly to the server 

   specified by the absoluteURI. In order to avoid request loops, a
   proxy MUST be able to recognize all of its server names, including
   any aliases, local variations, and the numeric IP address. An example
   Request-Line would be:

       GET &lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP/1.1

   To allow for transition to absoluteURIs in all requests in future
   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI
   form in requests, even though HTTP/1.1 clients will only generate
   them in requests to proxies.

   The authority form is only used by the CONNECT method (&lt;a href=&quot;#section-9.9&quot;&gt;section 9.9&lt;/a&gt;).

   The most common form of Request-URI is that used to identify a
   resource on an origin server or gateway. In this case the absolute
   path of the URI MUST be transmitted (see &lt;a href=&quot;#section-3.2.1&quot;&gt;section 3.2.1&lt;/a&gt;, abs_path) as
   the Request-URI, and the network location of the URI (authority) MUST
   be transmitted in a Host header field. For example, a client wishing
   to retrieve the resource above directly from the origin server would
   create a TCP connection to port 80 of the host &quot;www.w3.org&quot; and send
   the lines:

       GET /pub/WWW/TheProject.html HTTP/1.1
       Host: www.w3.org

   followed by the remainder of the Request. Note that the absolute path
   cannot be empty; if none is present in the original URI, it MUST be
   given as &quot;/&quot; (the server root).

   The Request-URI is transmitted in the format specified in &lt;a href=&quot;#section-3.2.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;. If the Request-URI is encoded using the &quot;% HEX HEX&quot; encoding
   [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;], the origin server MUST decode the Request-URI in order to
   properly interpret the request. Servers SHOULD respond to invalid
   Request-URIs with an appropriate status code.

   A transparent proxy MUST NOT rewrite the &quot;abs_path&quot; part of the
   received Request-URI when forwarding it to the next inbound server,
   except as noted above to replace a null abs_path with &quot;/&quot;.

      Note: The &quot;no rewrite&quot; rule prevents the proxy from changing the
      meaning of the request when the origin server is improperly using
      a non-reserved URI character for a reserved purpose.  Implementors
      should be aware that some pre-HTTP/1.1 proxies have been known to
      rewrite the Request-URI.</source>
          <target state="translated">Request-URI - это универсальный идентификатор ресурса ( &lt;a href=&quot;#section-3.2&quot;&gt;раздел 3.2.&lt;/a&gt;) и определяет ресурс, к которому следует применить запрос. Request-URI = &quot;*&quot; | absoluteURI | abs_path | Authority Четыре варианта Request-URI зависят от характера запроса. Звездочка &amp;laquo;*&amp;raquo; означает, что запрос не применяется к определенному ресурсу, а к самому серверу, и разрешен только в том случае, если используемый метод не обязательно применим к ресурсу. Одним из примеров может быть OPTIONS * HTTP / 1.1. Форма absoluteURI НЕОБХОДИМА, когда запрос делается к прокси. Прокси-сервер запрашивается для пересылки запроса или обслуживания его из допустимого кеша и возврата ответа. Обратите внимание, что прокси МОЖЕТ перенаправить запрос на другой прокси или непосредственно на сервер, указанный в absoluteURI. Чтобы избежать зацикливания запросов,прокси-сервер ДОЛЖЕН быть в состоянии распознавать все свои имена серверов, включая любые псевдонимы, локальные варианты и числовой IP-адрес. Пример строки запроса: GET&lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP / 1.1 Чтобы разрешить переход на absoluteURI во всех запросах в будущих версиях HTTP, все серверы HTTP / 1.1 ДОЛЖНЫ принимать форму absoluteURI в запросах, даже если Клиенты HTTP / 1.1 будут генерировать их только в запросах к прокси. Форма полномочий используется только методом CONNECT ( &lt;a href=&quot;#section-9.9&quot;&gt;раздел 9.9&lt;/a&gt; ). Наиболее распространенная форма Request-URI - это та, которая используется для идентификации ресурса на исходном сервере или шлюзе. В этом случае ДОЛЖЕН быть передан абсолютный путь URI (см. &lt;a href=&quot;#section-3.2.1&quot;&gt;Раздел 3.2.1.&lt;/a&gt;, abs_path) как Request-URI, а сетевое местоположение URI (полномочия) ДОЛЖНО передаваться в поле заголовка Host. Например, клиент, желающий получить указанный выше ресурс непосредственно с исходного сервера, должен создать TCP-соединение с портом 80 хоста &amp;laquo;www.w3.org&amp;raquo; и отправить строки: GET /pub/WWW/TheProject.html HTTP / 1.1 Хост: www.w3.org, за которым следует оставшаяся часть запроса. Обратите внимание, что абсолютный путь не может быть пустым; если в исходном URI ничего нет, он ДОЛЖЕН быть указан как &amp;laquo;/&amp;raquo; (корень сервера). Request-URI передается в формате, указанном в &lt;a href=&quot;#section-3.2.1&quot;&gt;разделе &lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt; . Если Request-URI закодирован с использованием кодировки &quot;% HEX HEX&quot; [ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;], исходный сервер ДОЛЖЕН декодировать Request-URI, чтобы правильно интерпретировать запрос. Серверы ДОЛЖНЫ отвечать на недопустимые Request-URI с соответствующим кодом состояния. Прозрачный прокси-сервер НЕ ДОЛЖЕН переписывать часть &amp;laquo;abs_path&amp;raquo; полученного Request-URI при пересылке его на следующий входящий сервер, за исключением случаев, указанных выше, для замены нулевого abs_path на &amp;laquo;/&amp;raquo;. Примечание. Правило &amp;laquo;без перезаписи&amp;raquo; не позволяет прокси-серверу изменять значение запроса, когда исходный сервер неправильно использует незарезервированный символ URI для зарезервированной цели. Разработчики должны знать, что некоторые прокси до HTTP / 1.1, как известно, переписывают Request-URI.</target>
        </trans-unit>
        <trans-unit id="1b7981c08ac4de37a8ea2b93d3e5c2168d3aee17" translate="yes" xml:space="preserve">
          <source>The Request-URI is a Uniform Resource Identifier (&lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;) and
   identifies the resource upon which to apply the request.

       Request-URI    = &quot;*&quot; | absoluteURI | abs_path | authority

   The four options for Request-URI are dependent on the nature of the
   request. The asterisk &quot;*&quot; means that the request does not apply to a
   particular resource, but to the server itself, and is only allowed
   when the method used does not necessarily apply to a resource. One
   example would be

       OPTIONS * HTTP/1.1

   The absoluteURI form is REQUIRED when the request is being made to a
   proxy. The proxy is requested to forward the request or service it
   from a valid cache, and return the response. Note that the proxy MAY
   forward the request on to another proxy or directly to the server 

   specified by the absoluteURI. In order to avoid request loops, a
   proxy MUST be able to recognize all of its server names, including
   any aliases, local variations, and the numeric IP address. An example
   Request-Line would be:

       GET &lt;a href=&quot;https://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP/1.1

   To allow for transition to absoluteURIs in all requests in future
   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI
   form in requests, even though HTTP/1.1 clients will only generate
   them in requests to proxies.

   The authority form is only used by the CONNECT method (&lt;a href=&quot;#section-9.9&quot;&gt;section 9.9&lt;/a&gt;).

   The most common form of Request-URI is that used to identify a
   resource on an origin server or gateway. In this case the absolute
   path of the URI MUST be transmitted (see &lt;a href=&quot;#section-3.2.1&quot;&gt;section 3.2.1&lt;/a&gt;, abs_path) as
   the Request-URI, and the network location of the URI (authority) MUST
   be transmitted in a Host header field. For example, a client wishing
   to retrieve the resource above directly from the origin server would
   create a TCP connection to port 80 of the host &quot;www.w3.org&quot; and send
   the lines:

       GET /pub/WWW/TheProject.html HTTP/1.1
       Host: www.w3.org

   followed by the remainder of the Request. Note that the absolute path
   cannot be empty; if none is present in the original URI, it MUST be
   given as &quot;/&quot; (the server root).

   The Request-URI is transmitted in the format specified in &lt;a href=&quot;#section-3.2.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;. If the Request-URI is encoded using the &quot;% HEX HEX&quot; encoding
   [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;], the origin server MUST decode the Request-URI in order to
   properly interpret the request. Servers SHOULD respond to invalid
   Request-URIs with an appropriate status code.

   A transparent proxy MUST NOT rewrite the &quot;abs_path&quot; part of the
   received Request-URI when forwarding it to the next inbound server,
   except as noted above to replace a null abs_path with &quot;/&quot;.

      Note: The &quot;no rewrite&quot; rule prevents the proxy from changing the
      meaning of the request when the origin server is improperly using
      a non-reserved URI character for a reserved purpose.  Implementors
      should be aware that some pre-HTTP/1.1 proxies have been known to
      rewrite the Request-URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27df10f6e52fad72f86af47082d4aed616c53e54" translate="yes" xml:space="preserve">
          <source>The Retry-After response-header field can be used with a 503 (Service
   Unavailable) response to indicate how long the service is expected to
   be unavailable to the requesting client. This field MAY also be used
   with any 3xx (Redirection) response to indicate the minimum time the
   user-agent is asked wait before issuing the redirected request. The
   value of this field can be either an HTTP-date or an integer number
   of seconds (in decimal) after the time of the response.

       Retry-After  = &quot;Retry-After&quot; &quot;:&quot; ( HTTP-date | delta-seconds )

   Two examples of its use are

       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
       Retry-After: 120

   In the latter example, the delay is 2 minutes.</source>
          <target state="translated">Поле заголовка ответа Retry-After может быть использовано с ответом 503 (Service Unavailable)для указания того,как долго сервис,как ожидается,будет недоступен запрашивающему клиенту.Это поле MAY также может использоваться с любым 3xx (перенаправленным)ответом для указания минимального времени,в течение которого пользователь-агент должен подождать,прежде чем отправить перенаправленный запрос.Значение этого поля может быть либо HTTP-датой,либо целым числом секунд (в десятичных числах)после времени ответа.Повтор-после=&quot;Повтор-после&quot; &quot;:&quot;(HTTP-дата | дельта-секунды)Два примера его использования-повтор-после:Fri,31 Dec.1999 23:59:59 GMT Retry-After:120 В последнем примере задержка составляет 2 минуты.</target>
        </trans-unit>
        <trans-unit id="818c17cd76fd87b90da17d6a18fd82be94517b9c" translate="yes" xml:space="preserve">
          <source>The SETTINGS frame (type=0x4) conveys configuration parameters that
   affect how endpoints communicate, such as preferences and constraints
   on peer behavior.  The SETTINGS frame is also used to acknowledge the
   receipt of those parameters.  Individually, a SETTINGS parameter can
   also be referred to as a &quot;setting&quot;. 

   SETTINGS parameters are not negotiated; they describe characteristics
   of the sending peer, which are used by the receiving peer.  Different
   values for the same parameter can be advertised by each peer.  For
   example, a client might set a high initial flow-control window,
   whereas a server might set a lower value to conserve resources.

   A SETTINGS frame MUST be sent by both endpoints at the start of a
   connection and MAY be sent at any other time by either endpoint over
   the lifetime of the connection.  Implementations MUST support all of
   the parameters defined by this specification.

   Each parameter in a SETTINGS frame replaces any existing value for
   that parameter.  Parameters are processed in the order in which they
   appear, and a receiver of a SETTINGS frame does not need to maintain
   any state other than the current value of its parameters.  Therefore,
   the value of a SETTINGS parameter is the last value that is seen by a
   receiver.

   SETTINGS parameters are acknowledged by the receiving peer.  To
   enable this, the SETTINGS frame defines the following flag:

   ACK (0x1):  When set, bit 0 indicates that this frame acknowledges
      receipt and application of the peer's SETTINGS frame.  When this
      bit is set, the payload of the SETTINGS frame MUST be empty.
      Receipt of a SETTINGS frame with the ACK flag set and a length
      field value other than 0 MUST be treated as a connection error
      (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type FRAME_SIZE_ERROR.  For more information,
      see &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt; (&quot;Settings Synchronization&quot;).

   SETTINGS frames always apply to a connection, never a single stream.
   The stream identifier for a SETTINGS frame MUST be zero (0x0).  If an
   endpoint receives a SETTINGS frame whose stream identifier field is
   anything other than 0x0, the endpoint MUST respond with a connection
   error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   The SETTINGS frame affects connection state.  A badly formed or
   incomplete SETTINGS frame MUST be treated as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   A SETTINGS frame with a length other than a multiple of 6 octets MUST
   be treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   FRAME_SIZE_ERROR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f8174334dfb42409bd14d344357a61e0522761d" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-Dest HTTP Request Header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="089fba56f3ba935817b0ee0ba0d50c6c7250a452" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-Mode HTTP Request Header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0922dedc70e7039f73de5afb1791c6af1cadc728" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-Site HTTP Request Header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9ebb888b481c6982054f06f45605ddc268b5db" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-User HTTP Request Header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f351e70802256078de6c82adb6c9f8135e4ad1a4" translate="yes" xml:space="preserve">
          <source>The Server response-header field contains information about the
   software used by the origin server to handle the request. The field
   can contain multiple product tokens (&lt;a href=&quot;#section-3.8&quot;&gt;section 3.8&lt;/a&gt;) and comments
   identifying the server and any significant subproducts. The product
   tokens are listed in order of their significance for identifying the
   application.

       Server         = &quot;Server&quot; &quot;:&quot; 1*( product | comment )

   Example:

       Server: CERN/3.0 libwww/2.17

   If the response is being forwarded through a proxy, the proxy
   application MUST NOT modify the Server response-header. Instead, it
   SHOULD include a Via field (as described in &lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;).

      Note: Revealing the specific software version of the server might
      allow the server machine to become more vulnerable to attacks
      against software that is known to contain security holes. Server
      implementors are encouraged to make this field a configurable
      option.</source>
          <target state="translated">Поле заголовка ответа сервера содержит информацию о программном обеспечении, используемом исходным сервером для обработки запроса. Поле может содержать несколько токенов продукта ( &lt;a href=&quot;#section-3.8&quot;&gt;раздел 3.8&lt;/a&gt; ) и комментарии, идентифицирующие сервер и любые важные субпродукты. Жетоны продуктов перечислены в порядке их значимости для идентификации приложения. Server = &quot;Server&quot; &quot;:&quot; 1 * (product | comment) Пример: Сервер: CERN / 3.0 libwww / 2.17 Если ответ пересылается через прокси, прокси-приложение НЕ ДОЛЖНО изменять заголовок ответа сервера. Вместо этого он ДОЛЖЕН включать поле Via (как описано в &lt;a href=&quot;#section-14.45&quot;&gt;разделе 14.45.&lt;/a&gt;). Примечание. Выявление конкретной версии программного обеспечения сервера может сделать серверный компьютер более уязвимым для атак на программное обеспечение, которое, как известно, содержит бреши в безопасности. Разработчикам серверов рекомендуется сделать это поле настраиваемой опцией.</target>
        </trans-unit>
        <trans-unit id="87ed514ae2ccfa3b72514fa6a84c466f301be7c1" translate="yes" xml:space="preserve">
          <source>The Status-Code element is a 3-digit integer result code of the
   attempt to understand and satisfy the request. These codes are fully
   defined in &lt;a href=&quot;#section-10&quot;&gt;section 10&lt;/a&gt;. The Reason-Phrase is intended to give a short
   textual description of the Status-Code. The Status-Code is intended
   for use by automata and the Reason-Phrase is intended for the human
   user. The client is not required to examine or display the Reason-
   Phrase. 

   The first digit of the Status-Code defines the class of response. The
   last two digits do not have any categorization role. There are 5
   values for the first digit:

      - 1xx: Informational - Request received, continuing process

      - 2xx: Success - The action was successfully received,
        understood, and accepted

      - 3xx: Redirection - Further action must be taken in order to
        complete the request

      - 4xx: Client Error - The request contains bad syntax or cannot
        be fulfilled

      - 5xx: Server Error - The server failed to fulfill an apparently
        valid request

   The individual values of the numeric status codes defined for
   HTTP/1.1, and an example set of corresponding Reason-Phrase's, are
   presented below. The reason phrases listed here are only
   recommendations -- they MAY be replaced by local equivalents without
   affecting the protocol.

      Status-Code    =
            &quot;100&quot;  ; &lt;a href=&quot;#section-10.1.1&quot;&gt;Section 10.1.1&lt;/a&gt;: Continue
          | &quot;101&quot;  ; &lt;a href=&quot;#section-10.1.2&quot;&gt;Section 10.1.2&lt;/a&gt;: Switching Protocols
          | &quot;200&quot;  ; &lt;a href=&quot;#section-10.2.1&quot;&gt;Section 10.2.1&lt;/a&gt;: OK
          | &quot;201&quot;  ; &lt;a href=&quot;#section-10.2.2&quot;&gt;Section 10.2.2&lt;/a&gt;: Created
          | &quot;202&quot;  ; &lt;a href=&quot;#section-10.2.3&quot;&gt;Section 10.2.3&lt;/a&gt;: Accepted
          | &quot;203&quot;  ; &lt;a href=&quot;#section-10.2.4&quot;&gt;Section 10.2.4&lt;/a&gt;: Non-Authoritative Information
          | &quot;204&quot;  ; &lt;a href=&quot;#section-10.2.5&quot;&gt;Section 10.2.5&lt;/a&gt;: No Content
          | &quot;205&quot;  ; &lt;a href=&quot;#section-10.2.6&quot;&gt;Section 10.2.6&lt;/a&gt;: Reset Content
          | &quot;206&quot;  ; &lt;a href=&quot;#section-10.2.7&quot;&gt;Section 10.2.7&lt;/a&gt;: Partial Content
          | &quot;300&quot;  ; &lt;a href=&quot;#section-10.3.1&quot;&gt;Section 10.3.1&lt;/a&gt;: Multiple Choices
          | &quot;301&quot;  ; &lt;a href=&quot;#section-10.3.2&quot;&gt;Section 10.3.2&lt;/a&gt;: Moved Permanently
          | &quot;302&quot;  ; &lt;a href=&quot;#section-10.3.3&quot;&gt;Section 10.3.3&lt;/a&gt;: Found
          | &quot;303&quot;  ; &lt;a href=&quot;#section-10.3.4&quot;&gt;Section 10.3.4&lt;/a&gt;: See Other
          | &quot;304&quot;  ; &lt;a href=&quot;#section-10.3.5&quot;&gt;Section 10.3.5&lt;/a&gt;: Not Modified
          | &quot;305&quot;  ; &lt;a href=&quot;#section-10.3.6&quot;&gt;Section 10.3.6&lt;/a&gt;: Use Proxy
          | &quot;307&quot;  ; &lt;a href=&quot;#section-10.3.8&quot;&gt;Section 10.3.8&lt;/a&gt;: Temporary Redirect
          | &quot;400&quot;  ; &lt;a href=&quot;#section-10.4.1&quot;&gt;Section 10.4.1&lt;/a&gt;: Bad Request
          | &quot;401&quot;  ; &lt;a href=&quot;#section-10.4.2&quot;&gt;Section 10.4.2&lt;/a&gt;: Unauthorized
          | &quot;402&quot;  ; &lt;a href=&quot;#section-10.4.3&quot;&gt;Section 10.4.3&lt;/a&gt;: Payment Required
          | &quot;403&quot;  ; &lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;: Forbidden
          | &quot;404&quot;  ; &lt;a href=&quot;#section-10.4.5&quot;&gt;Section 10.4.5&lt;/a&gt;: Not Found
          | &quot;405&quot;  ; &lt;a href=&quot;#section-10.4.6&quot;&gt;Section 10.4.6&lt;/a&gt;: Method Not Allowed
          | &quot;406&quot;  ; &lt;a href=&quot;#section-10.4.7&quot;&gt;Section 10.4.7&lt;/a&gt;: Not Acceptable 

          | &quot;407&quot;  ; &lt;a href=&quot;#section-10.4.8&quot;&gt;Section 10.4.8&lt;/a&gt;: Proxy Authentication Required
          | &quot;408&quot;  ; &lt;a href=&quot;#section-10.4.9&quot;&gt;Section 10.4.9&lt;/a&gt;: Request Time-out
          | &quot;409&quot;  ; &lt;a href=&quot;#section-10.4.10&quot;&gt;Section 10.4.10&lt;/a&gt;: Conflict
          | &quot;410&quot;  ; &lt;a href=&quot;#section-10.4.11&quot;&gt;Section 10.4.11&lt;/a&gt;: Gone
          | &quot;411&quot;  ; &lt;a href=&quot;#section-10.4.12&quot;&gt;Section 10.4.12&lt;/a&gt;: Length Required
          | &quot;412&quot;  ; &lt;a href=&quot;#section-10.4.13&quot;&gt;Section 10.4.13&lt;/a&gt;: Precondition Failed
          | &quot;413&quot;  ; &lt;a href=&quot;#section-10.4.14&quot;&gt;Section 10.4.14&lt;/a&gt;: Request Entity Too Large
          | &quot;414&quot;  ; &lt;a href=&quot;#section-10.4.15&quot;&gt;Section 10.4.15&lt;/a&gt;: Request-URI Too Large
          | &quot;415&quot;  ; &lt;a href=&quot;#section-10.4.16&quot;&gt;Section 10.4.16&lt;/a&gt;: Unsupported Media Type
          | &quot;416&quot;  ; &lt;a href=&quot;#section-10.4.17&quot;&gt;Section 10.4.17&lt;/a&gt;: Requested range not satisfiable
          | &quot;417&quot;  ; &lt;a href=&quot;#section-10.4.18&quot;&gt;Section 10.4.18&lt;/a&gt;: Expectation Failed
          | &quot;500&quot;  ; &lt;a href=&quot;#section-10.5.1&quot;&gt;Section 10.5.1&lt;/a&gt;: Internal Server Error
          | &quot;501&quot;  ; &lt;a href=&quot;#section-10.5.2&quot;&gt;Section 10.5.2&lt;/a&gt;: Not Implemented
          | &quot;502&quot;  ; &lt;a href=&quot;#section-10.5.3&quot;&gt;Section 10.5.3&lt;/a&gt;: Bad Gateway
          | &quot;503&quot;  ; &lt;a href=&quot;#section-10.5.4&quot;&gt;Section 10.5.4&lt;/a&gt;: Service Unavailable
          | &quot;504&quot;  ; &lt;a href=&quot;#section-10.5.5&quot;&gt;Section 10.5.5&lt;/a&gt;: Gateway Time-out
          | &quot;505&quot;  ; &lt;a href=&quot;#section-10.5.6&quot;&gt;Section 10.5.6&lt;/a&gt;: HTTP Version not supported
          | extension-code

      extension-code = 3DIGIT
      Reason-Phrase  = *&amp;lt;TEXT, excluding CR, LF&amp;gt;

   HTTP status codes are extensible. HTTP applications are not required
   to understand the meaning of all registered status codes, though such
   understanding is obviously desirable. However, applications MUST
   understand the class of any status code, as indicated by the first
   digit, and treat any unrecognized response as being equivalent to the
   x00 status code of that class, with the exception that an
   unrecognized response MUST NOT be cached. For example, if an
   unrecognized status code of 431 is received by the client, it can
   safely assume that there was something wrong with its request and
   treat the response as if it had received a 400 status code. In such
   cases, user agents SHOULD present to the user the entity returned
   with the response, since that entity is likely to include human-
   readable information which will explain the unusual status.</source>
          <target state="translated">Элемент Status-Code представляет собой трехзначный целочисленный код результата попытки понять и удовлетворить запрос. Эти коды полностью определены в &lt;a href=&quot;#section-10&quot;&gt;разделе 10.&lt;/a&gt;, Фраза-причина предназначена для краткого текстового описания кода состояния. Код состояния предназначен для использования автоматами, а фраза-причина предназначена для пользователя-человека. От клиента не требуется изучать или отображать фразу-причину. Первая цифра кода состояния определяет класс ответа. Последние две цифры не имеют роли категоризации. Первая цифра имеет 5 значений: - 1xx: информационное - запрос получен, процесс продолжается - 2xx: успех - действие было успешно получено, понято и принято - 3xx: перенаправление - для выполнения запроса необходимо предпринять дальнейшие действия - 4xx: ошибка клиента - запрос содержит неверный синтаксис или не может быть выполнен - ​​5xx:Ошибка сервера - серверу не удалось выполнить явно действительный запрос. Ниже представлены отдельные значения числовых кодов состояния, определенных для HTTP / 1.1, и примерный набор соответствующих фраз-причин. Фразы причин, перечисленные здесь, являются всего лишь рекомендациями - они МОГУТ быть заменены местными эквивалентами, не влияя на протокол. Код состояния = &quot;100&quot;;&lt;a href=&quot;#section-10.1.1&quot;&gt;Раздел 10.1.1&lt;/a&gt; : Продолжить | &amp;laquo;101&amp;raquo;; &lt;a href=&quot;#section-10.1.2&quot;&gt;Раздел 10.1.2&lt;/a&gt; : Переключение протоколов | &amp;laquo;200&amp;raquo;; &lt;a href=&quot;#section-10.2.1&quot;&gt;Раздел 10.2.1&lt;/a&gt; : ОК | &amp;laquo;201&amp;raquo;; &lt;a href=&quot;#section-10.2.2&quot;&gt;Раздел 10.2.2&lt;/a&gt; : Создано | &amp;laquo;202&amp;raquo;; &lt;a href=&quot;#section-10.2.3&quot;&gt;Раздел 10.2.3&lt;/a&gt; : Принято | &amp;laquo;203&amp;raquo;; &lt;a href=&quot;#section-10.2.4&quot;&gt;Раздел 10.2.4&lt;/a&gt; : Неавторитетная информация | &amp;laquo;204&amp;raquo;; &lt;a href=&quot;#section-10.2.5&quot;&gt;Раздел 10.2.5&lt;/a&gt; : Нет содержимого | &amp;laquo;205&amp;raquo;; &lt;a href=&quot;#section-10.2.6&quot;&gt;Раздел 10.2.6&lt;/a&gt; : Сброс содержимого | &amp;laquo;206&amp;raquo;; &lt;a href=&quot;#section-10.2.7&quot;&gt;Раздел 10.2.7&lt;/a&gt; : Частичное содержимое | &amp;laquo;300&amp;raquo;; &lt;a href=&quot;#section-10.3.1&quot;&gt;Раздел 10.3.1&lt;/a&gt; : Несколько вариантов | &amp;laquo;301&amp;raquo;; &lt;a href=&quot;#section-10.3.2&quot;&gt;Раздел 10.3.&lt;/a&gt;2 : перемещен навсегда | &amp;laquo;302&amp;raquo;;&lt;a href=&quot;#section-10.3.3&quot;&gt;Раздел 10.3.3&lt;/a&gt; : Найдено | &amp;laquo;303&amp;raquo;; &lt;a href=&quot;#section-10.3.4&quot;&gt;Раздел 10.3.4&lt;/a&gt; : См. Другое | &amp;laquo;304&amp;raquo;; &lt;a href=&quot;#section-10.3.5&quot;&gt;Раздел 10.3.5&lt;/a&gt; : Не изменено | &amp;laquo;305&amp;raquo;; &lt;a href=&quot;#section-10.3.6&quot;&gt;Раздел 10.3.6&lt;/a&gt; : Использование прокси | &amp;laquo;307&amp;raquo;; &lt;a href=&quot;#section-10.3.8&quot;&gt;Раздел 10.3.8&lt;/a&gt; : Временное перенаправление | &amp;laquo;400&amp;raquo;; &lt;a href=&quot;#section-10.4.1&quot;&gt;Раздел 10.4.1&lt;/a&gt; : Неверный запрос | &amp;laquo;401&amp;raquo;; &lt;a href=&quot;#section-10.4.2&quot;&gt;Раздел 10.4.2&lt;/a&gt; : Несанкционированный | &amp;laquo;402&amp;raquo;; &lt;a href=&quot;#section-10.4.3&quot;&gt;Раздел 10.4.3&lt;/a&gt; : Требуется оплата | &amp;laquo;403&amp;raquo;; &lt;a href=&quot;#section-10.4.4&quot;&gt;Раздел 10.4.4&lt;/a&gt; : Запрещено | &amp;laquo;404&amp;raquo;; &lt;a href=&quot;#section-10.4.5&quot;&gt;Раздел 10.4.5&lt;/a&gt; : Не найдено | &amp;laquo;405&amp;raquo;; &lt;a href=&quot;#section-10.4.6&quot;&gt;Раздел 10.4.6&lt;/a&gt; :Метод не разрешен | &amp;laquo;406&amp;raquo;; &lt;a href=&quot;#section-10.4.7&quot;&gt;Раздел 10.4.7&lt;/a&gt;: Неприемлемо | &amp;laquo;407&amp;raquo;; &lt;a href=&quot;#section-10.4.8&quot;&gt;Раздел 10.4.8&lt;/a&gt; : Требуется аутентификация прокси | &amp;laquo;408&amp;raquo;; &lt;a href=&quot;#section-10.4.9&quot;&gt;Раздел 10.4.9&lt;/a&gt; : Тайм-аут запроса | &amp;laquo;409&amp;raquo;; &lt;a href=&quot;#section-10.4.10&quot;&gt;Раздел 10.4.10&lt;/a&gt; : Конфликт | &amp;laquo;410&amp;raquo;; &lt;a href=&quot;#section-10.4.11&quot;&gt;Раздел 10.4.11&lt;/a&gt; : Ушло | &amp;laquo;411&amp;raquo;; &lt;a href=&quot;#section-10.4.12&quot;&gt;Раздел 10.4.12&lt;/a&gt; : Требуемая длина | &amp;laquo;412&amp;raquo;; &lt;a href=&quot;#section-10.4.13&quot;&gt;Раздел 10.4.13&lt;/a&gt; : Ошибка предварительного условия | &amp;laquo;413&amp;raquo;; &lt;a href=&quot;#section-10.4.14&quot;&gt;Раздел 10.4.14&lt;/a&gt; : Слишком большой объект запроса | &amp;laquo;414&amp;raquo;; &lt;a href=&quot;#section-10.4.15&quot;&gt;Раздел 10.4.15&lt;/a&gt; : Слишком большой URI запроса | &amp;laquo;415&amp;raquo;; &lt;a href=&quot;#section-10.4.16&quot;&gt;Раздел 10.4.16&lt;/a&gt; : Неподдерживаемый тип носителя | &amp;laquo;416&amp;raquo;;&lt;a href=&quot;#section-10.4.17&quot;&gt;Раздел 10.4.17&lt;/a&gt;: Запрошенный диапазон не подходит | &amp;laquo;417&amp;raquo;; &lt;a href=&quot;#section-10.4.18&quot;&gt;Раздел 10.4.18&lt;/a&gt; : Ожидание не выполнено | &amp;laquo;500&amp;raquo;; &lt;a href=&quot;#section-10.5.1&quot;&gt;Раздел 10.5.1&lt;/a&gt; : Внутренняя ошибка сервера | &amp;laquo;501&amp;raquo;; &lt;a href=&quot;#section-10.5.2&quot;&gt;Раздел 10.5.2&lt;/a&gt; : Не реализовано | &amp;laquo;502&amp;raquo;; &lt;a href=&quot;#section-10.5.3&quot;&gt;Раздел 10.5.3&lt;/a&gt; : Плохой шлюз | &amp;laquo;503&amp;raquo;; &lt;a href=&quot;#section-10.5.4&quot;&gt;Раздел 10.5.4&lt;/a&gt; : Служба недоступна | &amp;laquo;504&amp;raquo;; &lt;a href=&quot;#section-10.5.5&quot;&gt;Раздел 10.5.5&lt;/a&gt; : Тайм-аут шлюза | &amp;laquo;505&amp;raquo;; &lt;a href=&quot;#section-10.5.6&quot;&gt;Раздел 10.5.6&lt;/a&gt;: Версия HTTP не поддерживается | extension-code extension-code = 3DIGIT Reason-Phrase = * &amp;lt;ТЕКСТ, исключая CR, LF&amp;gt; Коды состояния HTTP являются расширяемыми. Приложения HTTP не обязаны понимать значение всех зарегистрированных кодов состояния, хотя такое понимание, очевидно, желательно. Однако приложения ДОЛЖНЫ понимать класс любого кода состояния, обозначенного первой цифрой, и обрабатывать любой нераспознанный ответ как эквивалентный коду состояния x00 этого класса, за исключением того, что нераспознанный ответ НЕ ДОЛЖЕН кэшироваться. Например, если клиент получает нераспознанный код состояния 431, он может с уверенностью предположить, что с его запросом что-то не так, и рассматривать ответ, как если бы он получил код состояния 400. В таких случаях,пользовательские агенты ДОЛЖНЫ представлять пользователю объект, возвращенный с ответом, поскольку этот объект, вероятно, будет включать в себя читаемую человеком информацию, которая объяснит необычный статус.</target>
        </trans-unit>
        <trans-unit id="b8418e17a41aec97d3c590fcc65fedf33be9a1c2" translate="yes" xml:space="preserve">
          <source>The TCP connection failed due to reasons not covered by previous errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63d3da83f08f3589783fd322c14eb384668776f" translate="yes" xml:space="preserve">
          <source>The TCP connection was aborted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece1a07cee60e2c0d379acd1235868c7480c2fcb" translate="yes" xml:space="preserve">
          <source>The TCP connection was closed by the server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="796733a0ab45ac90906d6f198849475b13814e44" translate="yes" xml:space="preserve">
          <source>The TCP connection was refused by the server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cef75a8f9ea523ffedd880063709751f6702f3" translate="yes" xml:space="preserve">
          <source>The TCP connection was reset</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a033c5a9ee721261b9ef910b0f68478ac7363993" translate="yes" xml:space="preserve">
          <source>The TCP handshake itself is time-consuming, but a TCP connection adapts to its load, becoming more efficient with more sustained (or warm) connections. Short-lived connections do not make use of this efficiency feature of TCP, and performance degrades from optimum by persisting to transmit over a new, cold connection.</source>
          <target state="translated">Само по себе TCP рукопожатие отнимает много времени,но TCP-соединение адаптируется к его нагрузке,становясь более эффективным с более устойчивыми (или теплыми)соединениями.Короткоживущие соединения не используют эту функцию эффективности TCP,и производительность снижается до оптимального уровня,продолжая передаваться по новому,холодному соединению.</target>
        </trans-unit>
        <trans-unit id="a9a108e88ad08677b3a7b101ee6720f85b6d8f49" translate="yes" xml:space="preserve">
          <source>The TE request-header field indicates what extension transfer-codings
   it is willing to accept in the response and whether or not it is
   willing to accept trailer fields in a chunked transfer-coding. Its
   value may consist of the keyword &quot;trailers&quot; and/or a comma-separated
   list of extension transfer-coding names with optional accept
   parameters (as described in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;).

       TE        = &quot;TE&quot; &quot;:&quot; #( t-codings )
       t-codings = &quot;trailers&quot; | ( transfer-extension [ accept-params ] )

   The presence of the keyword &quot;trailers&quot; indicates that the client is
   willing to accept trailer fields in a chunked transfer-coding, as
   defined in &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt;. This keyword is reserved for use with
   transfer-coding values even though it does not itself represent a
   transfer-coding.

   Examples of its use are:

       TE: deflate
       TE:
       TE: trailers, deflate;q=0.5

   The TE header field only applies to the immediate connection.
   Therefore, the keyword MUST be supplied within a Connection header
   field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) whenever TE is present in an HTTP/1.1 message.

   A server tests whether a transfer-coding is acceptable, according to
   a TE field, using these rules:

      1. The &quot;chunked&quot; transfer-coding is always acceptable. If the
         keyword &quot;trailers&quot; is listed, the client indicates that it is
         willing to accept trailer fields in the chunked response on
         behalf of itself and any downstream clients. The implication is
         that, if given, the client is stating that either all
         downstream clients are willing to accept trailer fields in the
         forwarded response, or that it will attempt to buffer the
         response on behalf of downstream recipients.

         Note: HTTP/1.1 does not define any means to limit the size of a
         chunked response such that a client can be assured of buffering
         the entire response.

      2. If the transfer-coding being tested is one of the transfer-
         codings listed in the TE field, then it is acceptable unless it
         is accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;) 

      3. If multiple transfer-codings are acceptable, then the
         acceptable transfer-coding with the highest non-zero qvalue is
         preferred.  The &quot;chunked&quot; transfer-coding always has a qvalue
         of 1.

   If the TE field-value is empty or if no TE field is present, the only
   transfer-coding  is &quot;chunked&quot;. A message with no transfer-coding is
   always acceptable.</source>
          <target state="translated">Поле заголовка запроса TE указывает, какие расширения кодирования передачи он готов принять в ответ, и готов ли он принимать поля концевых звеньев в кодировании передачи по частям. Его значение может состоять из ключевого слова &quot;трейлеры&quot; и / или разделенного запятыми списка расширенных имен кодирования передачи с необязательными параметрами принятия (как описано в &lt;a href=&quot;#section-3.6&quot;&gt;разделе 3.6&lt;/a&gt; ). TE = &quot;TE&quot; &quot;:&quot; # (t-codings) t-codings = &quot;trailers&quot; | (расширение-передачи [accept-params]) Наличие ключевого слова &quot;трейлеры&quot; указывает на то, что клиент готов принять поля трейлера в кодировке передачи по частям, как определено в &lt;a href=&quot;#section-3.6.1&quot;&gt;разделе 3.6.1.&lt;/a&gt;, Это ключевое слово зарезервировано для использования со значениями кодирования передачи, даже если оно само не представляет собой кодирование передачи. Примеры его использования: TE: deflate TE: TE: trailers, deflate; q = 0.5 Поле заголовка TE применяется только к непосредственному соединению. Следовательно, ключевое слово ДОЛЖНО быть предоставлено в поле заголовка соединения ( &lt;a href=&quot;#section-14.10&quot;&gt;раздел 14.10.&lt;/a&gt;) всякий раз, когда TE присутствует в сообщении HTTP / 1.1. Сервер проверяет, допустимо ли кодирование передачи, в соответствии с полем TE, используя следующие правила: 1. &amp;laquo;Разделенное&amp;raquo; кодирование передачи всегда приемлемо. Если указано ключевое слово &amp;laquo;трейлеры&amp;raquo;, клиент указывает, что он готов принять поля трейлеров в фрагментированном ответе от своего имени и от имени всех нижестоящих клиентов. Подразумевается, что, если он задан, клиент заявляет, что либо все нижестоящие клиенты готовы принять поля трейлера в перенаправленном ответе, либо он попытается буферизовать ответ от имени нижестоящих получателей. Примечание: HTTP / 1.1 не определяет никаких средств для ограничения размера фрагментированного ответа, чтобы клиент мог быть уверен в буферизации всего ответа. 2. Если тестируемое кодирование передачи является одним из кодировок передачи, перечисленных в поле TE, то оно приемлемо, если оно не сопровождается значением q, равным 0. (Как определено в&lt;a href=&quot;#section-3.9&quot;&gt;в разделе 3.9&lt;/a&gt; qvalue 0 означает &amp;laquo;неприемлемо&amp;raquo;.) 3. Если допускается несколько кодировок передачи, то предпочтительным является приемлемое кодирование передачи с наивысшим ненулевым значением q. &amp;laquo;Разделенное&amp;raquo; кодирование передачи всегда имеет qvalue, равное 1. Если значение поля TE пусто или если поле TE отсутствует, единственное кодирование передачи - &amp;laquo;фрагментированное&amp;raquo;. Сообщение без кодирования передачи всегда приемлемо.</target>
        </trans-unit>
        <trans-unit id="028b36d5d9b3506526bee546184ec9c68b1e3650" translate="yes" xml:space="preserve">
          <source>The TRACE method is used to invoke a remote, application-layer loop-
   back of the request message. The final recipient of the request
   SHOULD reflect the message received back to the client as the
   entity-body of a 200 (OK) response. The final recipient is either the 

   origin server or the first proxy or gateway to receive a Max-Forwards
   value of zero (0) in the request (see &lt;a href=&quot;#section-14.31&quot;&gt;section 14.31&lt;/a&gt;). A TRACE request
   MUST NOT include an entity.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information. The value of the Via header field (&lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;) is of
   particular interest, since it acts as a trace of the request chain.
   Use of the Max-Forwards header field allows the client to limit the
   length of the request chain, which is useful for testing a chain of
   proxies forwarding messages in an infinite loop.

   If the request is valid, the response SHOULD contain the entire
   request message in the entity-body, with a Content-Type of
   &quot;message/http&quot;. Responses to this method MUST NOT be cached.</source>
          <target state="translated">Метод TRACE используется для вызова удаленной петли на уровне приложения для сообщения запроса. Конечному получателю запроса СЛЕДУЕТ отражать полученное сообщение обратно клиенту как тело объекта ответа 200 (ОК). Конечным получателем является либо исходный сервер, либо первый прокси или шлюз, получивший в запросе нулевое (0) значение Max-Forwards (см. &lt;a href=&quot;#section-14.31&quot;&gt;Раздел 14.31&lt;/a&gt; ). Запрос TRACE НЕ ДОЛЖЕН включать сущность. TRACE позволяет клиенту видеть, что получено на другом конце цепочки запросов, и использовать эти данные для тестирования или диагностической информации. Значение поля заголовка Via ( &lt;a href=&quot;#section-14.45&quot;&gt;раздел 14.45&lt;/a&gt;) is of particular interest, since it acts as a trace of the request chain. Use of the Max-Forwards header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop. If the request is valid, the response SHOULD contain the entire request message in the entity-body, with a Content-Type of &quot;message/http&quot;. Responses to this method MUST NOT be cached.</target>
        </trans-unit>
        <trans-unit id="6e96e28d353c4ec4abe9e9bc4e5f7f7754ad5448" translate="yes" xml:space="preserve">
          <source>The TRACE method requests a remote, application-level loop-back of
   the request message.  The final recipient of the request SHOULD
   reflect the message received, excluding some fields described below,
   back to the client as the message body of a 200 (OK) response with a
   Content-Type of &quot;message/http&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;Section&amp;nbsp;8.3.1 of [RFC7230]&lt;/a&gt;).  The
   final recipient is either the origin server or the first server to
   receive a Max-Forwards value of zero (0) in the request
   (&lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;). 

   A client MUST NOT generate header fields in a TRACE request
   containing sensitive data that might be disclosed by the response.
   For example, it would be foolish for a user agent to send stored user
   credentials [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;] or cookies [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] in a TRACE request.  The
   final recipient of the request SHOULD exclude any request header
   fields that are likely to contain sensitive data when that recipient
   generates the response body.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information.  The value of the Via header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;Section&amp;nbsp;5.7.1 of
   [RFC7230]&lt;/a&gt;) is of particular interest, since it acts as a trace of the
   request chain.  Use of the Max-Forwards header field allows the
   client to limit the length of the request chain, which is useful for
   testing a chain of proxies forwarding messages in an infinite loop.

   A client MUST NOT send a message body in a TRACE request.

   Responses to the TRACE method are not cacheable.</source>
          <target state="translated">Метод TRACE запрашивает удаленную обратную связь на уровне приложения для сообщения запроса. Конечному получателю запроса СЛЕДУЕТ отразить полученное сообщение, за исключением некоторых полей, описанных ниже, обратно клиенту в виде тела сообщения ответа 200 (OK) с Content-Type &amp;laquo;message / http&amp;raquo; ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;раздел 8.3.1 of [RFC7230]&lt;/a&gt; ). Конечным получателем является либо исходный сервер, либо первый сервер, получивший в запросе значение Max-Forwards, равное нулю (0) ( &lt;a href=&quot;#section-5.1.2&quot;&gt;раздел 5.1.2&lt;/a&gt; ). Клиент НЕ ДОЛЖЕН создавать поля заголовка в запросе TRACE, содержащие конфиденциальные данные, которые могут быть раскрыты ответом. Например, было бы глупо для пользовательского агента отправлять сохраненные учетные данные пользователя [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ] или файлы cookie [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] в запросе TRACE. Конечному получателю запроса СЛЕДУЕТ исключить любые поля заголовка запроса, которые могут содержать конфиденциальные данные, когда этот получатель создает тело ответа. TRACE позволяет клиенту видеть, что получено на другом конце цепочки запросов, и использовать эти данные для тестирования или диагностической информации. Значение поля заголовка Via ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;раздел 5.7.1 [RFC7230]&lt;/a&gt; ) представляет особый интерес, поскольку оно действует как трассировка цепочки запросов. Использование поля заголовка Max-Forwards позволяет клиенту ограничивать длину цепочки запросов, что полезно для тестирования цепочки прокси-серверов, пересылающих сообщения в бесконечном цикле. Клиент НЕ ДОЛЖЕН отправлять тело сообщения в запросе TRACE. Ответы на метод TRACE не кэшируются.</target>
        </trans-unit>
        <trans-unit id="03897f64a14a74fe7d2358b82a3a5d08dc5e4c2f" translate="yes" xml:space="preserve">
          <source>The Trailer general field value indicates that the given set of
   header fields is present in the trailer of a message encoded with
   chunked transfer-coding.

       Trailer  = &quot;Trailer&quot; &quot;:&quot; 1#field-name

   An HTTP/1.1 message SHOULD include a Trailer header field in a
   message using chunked transfer-coding with a non-empty trailer. Doing
   so allows the recipient to know which header fields to expect in the
   trailer.

   If no Trailer header field is present, the trailer SHOULD NOT include
   any header fields. See &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt; for restrictions on the use of
   trailer fields in a &quot;chunked&quot; transfer-coding.

   Message header fields listed in the Trailer header field MUST NOT
   include the following header fields:

      . Transfer-Encoding

      . Content-Length

      . Trailer</source>
          <target state="translated">Значение общего поля трейлера указывает, что данный набор полей заголовка присутствует в трейлере сообщения, закодированного с помощью кодирования передачи по частям. Trailer = &quot;Trailer&quot; &quot;:&quot; 1 # field-name Сообщение HTTP / 1.1 ДОЛЖНО включать поле заголовка Trailer в сообщение с использованием фрагментированного кодирования передачи с непустым трейлером. Это позволяет получателю узнать, какие поля заголовка ожидать в трейлере. Если поле заголовка трейлера отсутствует, трейлер НЕ ДОЛЖЕН включать какие-либо поля заголовка. См. &lt;a href=&quot;#section-3.6.1&quot;&gt;Раздел 3.6.1&lt;/a&gt; для получения информации об ограничениях на использование полей трейлера в &amp;laquo;фрагментированном&amp;raquo; кодировании передачи. Поля заголовка сообщения, перечисленные в поле заголовка трейлера, НЕ ДОЛЖНЫ включать следующие поля заголовка:. Передача-кодирование. Content-Length.трейлер</target>
        </trans-unit>
        <trans-unit id="5a0c272967d0d482ca0381c6f18703875d017457" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding general-header field indicates what (if any)
   type of transformation has been applied to the message body in order
   to safely transfer it between the sender and the recipient. This
   differs from the content-coding in that the transfer-coding is a
   property of the message, not of the entity.

     Transfer-Encoding       = &quot;Transfer-Encoding&quot; &quot;:&quot; 1#transfer-coding

   Transfer-codings are defined in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;. An example is:

     Transfer-Encoding: chunked 

   If multiple encodings have been applied to an entity, the transfer-
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.

   Many older HTTP/1.0 applications do not understand the Transfer-
   Encoding header.</source>
          <target state="translated">Поле общего заголовка Transfer-Encoding указывает, какой (если есть) тип преобразования был применен к телу сообщения, чтобы безопасно передать его между отправителем и получателем. Это отличается от кодирования содержимого тем, что кодирование передачи является свойством сообщения, а не объекта. Transfer-Encoding = &quot;Transfer-Encoding&quot; &quot;:&quot; 1 # transfer-coding Кодирование передачи определено в &lt;a href=&quot;#section-3.6&quot;&gt;разделе 3.6.&lt;/a&gt;, Пример: Transfer-Encoding: chunked. Если к объекту было применено несколько кодировок, они ДОЛЖНЫ быть перечислены в том порядке, в котором они были применены. Дополнительная информация о параметрах кодирования МОЖЕТ быть предоставлена ​​другими полями заголовка объекта, не определенными в данной спецификации. Многие старые приложения HTTP / 1.0 не понимают заголовок Transfer-Encoding.</target>
        </trans-unit>
        <trans-unit id="2b9c17fcff0e77e15eb4e1a1d785371389cb348c" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding header field lists the transfer coding names
   corresponding to the sequence of transfer codings that have been (or
   will be) applied to the payload body in order to form the message
   body.  Transfer codings are defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

     Transfer-Encoding = 1#transfer-coding

   Transfer-Encoding is analogous to the Content-Transfer-Encoding field
   of MIME, which was designed to enable safe transport of binary data
   over a 7-bit transport service (&lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045], Section&amp;nbsp;6&lt;/a&gt;).  However, safe
   transport has a different focus for an 8bit-clean transfer protocol.
   In HTTP's case, Transfer-Encoding is primarily intended to accurately
   delimit a dynamically generated payload and to distinguish payload
   encodings that are only applied for transport efficiency or security
   from those that are characteristics of the selected resource. 

   A recipient MUST be able to parse the chunked transfer coding
   (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) because it plays a crucial role in framing messages
   when the payload body size is not known in advance.  A sender MUST
   NOT apply chunked more than once to a message body (i.e., chunking an
   already chunked message is not allowed).  If any transfer coding
   other than chunked is applied to a request payload body, the sender
   MUST apply chunked as the final transfer coding to ensure that the
   message is properly framed.  If any transfer coding other than
   chunked is applied to a response payload body, the sender MUST either
   apply chunked as the final transfer coding or terminate the message
   by closing the connection.

   For example,

     Transfer-Encoding: gzip, chunked

   indicates that the payload body has been compressed using the gzip
   coding and then chunked using the chunked coding while forming the
   message body.

   Unlike Content-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;Section&amp;nbsp;3.1.2.1 of [RFC7231]&lt;/a&gt;),
   Transfer-Encoding is a property of the message, not of the
   representation, and any recipient along the request/response chain
   MAY decode the received transfer coding(s) or apply additional
   transfer coding(s) to the message body, assuming that corresponding
   changes are made to the Transfer-Encoding field-value.  Additional
   information about the encoding parameters can be provided by other
   header fields not defined by this specification.

   Transfer-Encoding MAY be sent in a response to a HEAD request or in a
   304 (Not Modified) response (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7232]&lt;/a&gt;) to a GET
   request, neither of which includes a message body, to indicate that
   the origin server would have applied a transfer coding to the message
   body if the request had been an unconditional GET.  This indication
   is not required, however, because any recipient on the response chain
   (including the origin server) can remove transfer codings when they
   are not needed.

   A server MUST NOT send a Transfer-Encoding header field in any
   response with a status code of 1xx (Informational) or 204 (No
   Content).  A server MUST NOT send a Transfer-Encoding header field in
   any 2xx (Successful) response to a CONNECT request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;).

   Transfer-Encoding was added in HTTP/1.1.  It is generally assumed
   that implementations advertising only HTTP/1.0 support will not
   understand how to process a transfer-encoded payload.  A client MUST
   NOT send a request containing Transfer-Encoding unless it knows the 

   server will handle HTTP/1.1 (or later) requests; such knowledge might
   be in the form of specific user configuration or by remembering the
   version of a prior received response.  A server MUST NOT send a
   response containing Transfer-Encoding unless the corresponding
   request indicates HTTP/1.1 (or later).

   A server that receives a request message with a transfer coding it
   does not understand SHOULD respond with 501 (Not Implemented).</source>
          <target state="translated">В поле заголовка Transfer-Encoding перечислены имена кодов передачи, соответствующие последовательности кодировок передачи, которые были (или будут) применены к телу полезной нагрузки для формирования тела сообщения. Кодирование передачи определено в &lt;a href=&quot;#section-4&quot;&gt;Разделе 4&lt;/a&gt; . Transfer-Encoding = 1 # transfer-coding Transfer-Encoding аналогичен полю Content-Transfer-Encoding MIME, которое было разработано для обеспечения безопасной транспортировки двоичных данных через 7-битную транспортную службу ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045], раздел 6&lt;/a&gt;). Однако безопасный транспорт имеет другую направленность для протокола передачи с 8-битной чистой передачей. В случае HTTP Transfer-Encoding в первую очередь предназначена для точного разграничения динамически генерируемой полезной нагрузки и различения кодировок полезной нагрузки, которые применяются только для эффективности или безопасности транспорта, от тех, которые являются характеристиками выбранного ресурса. Получатель ДОЛЖЕН иметь возможность анализировать кодировку фрагментированной передачи ( &lt;a href=&quot;#section-4.1&quot;&gt;раздел 4.1.&lt;/a&gt;), потому что он играет решающую роль в формировании сообщений, когда размер тела полезной нагрузки неизвестен заранее. Отправитель НЕ ДОЛЖЕН применять фрагменты более одного раза к телу сообщения (т. Е. Фрагменты уже разбитого сообщения не разрешены). Если к телу полезной нагрузки запроса применяется какое-либо кодирование передачи, отличное от фрагментированного, отправитель ДОЛЖЕН применять фрагментированное кодирование в качестве окончательного кодирования передачи, чтобы гарантировать, что сообщение правильно сформировано. Если к телу полезной нагрузки ответа применяется какое-либо кодирование передачи, отличное от фрагментированного, отправитель ДОЛЖЕН либо применить фрагментированное кодирование в качестве окончательного кодирования передачи, либо завершить сообщение, закрыв соединение. Например, Transfer-Encoding: gzip, chunked указывает, что тело полезной нагрузки было сжато с использованием кодирования gzip, а затем разделено на фрагменты с использованием кодирования по фрагментам при формировании тела сообщения.В отличие от Content-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;Раздел 3.1.2.1 [RFC7231]&lt;/a&gt; ), Transfer-Encoding - это свойство сообщения, а не его представления, и любой получатель в цепочке запроса / ответа МОЖЕТ декодировать полученный код (ы) передачи или применять дополнительное кодирование (s) передачи ) в тело сообщения, предполагая, что соответствующие изменения внесены в значение поля Transfer-Encoding. Дополнительная информация о параметрах кодирования может быть предоставлена ​​другими полями заголовка, не определенными в данной спецификации. Transfer-Encoding МОЖЕТ быть отправлено в ответ на запрос HEAD или в ответе 304 (не изменено) ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;раздел 4.1 [RFC7232]&lt;/a&gt;) к запросу GET, ни один из которых не включает тело сообщения, чтобы указать, что исходный сервер применил бы кодирование передачи к телу сообщения, если бы запрос был безусловным GET. Однако это указание не требуется, поскольку любой получатель в цепочке ответов (включая исходный сервер) может удалить кодировки передачи, когда они не нужны. Сервер НЕ ДОЛЖЕН отправлять поле заголовка Transfer-Encoding в любом ответе с кодом состояния 1xx (информационный) или 204 (без содержимого). Сервер НЕ ДОЛЖЕН отправлять поле заголовка Transfer-Encoding в любом ответе 2xx (Успешно) на запрос CONNECT ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;раздел 4.3.6 [RFC7231])&lt;/a&gt;). Кодирование передачи было добавлено в HTTP / 1.1. Обычно предполагается, что реализации, рекламирующие только поддержку HTTP / 1.0, не поймут, как обрабатывать данные, закодированные при передаче. Клиент НЕ ДОЛЖЕН отправлять запрос, содержащий Transfer-Encoding, если он не знает, что сервер будет обрабатывать запросы HTTP / 1.1 (или более поздней версии); такие знания могут быть в форме конкретной пользовательской конфигурации или путем запоминания версии ранее полученного ответа. Сервер НЕ ДОЛЖЕН отправлять ответ, содержащий Transfer-Encoding, если в соответствующем запросе не указано HTTP / 1.1 (или более поздняя версия). Серверу, который получает сообщение запроса с непонятной ему кодировкой передачи, СЛЕДУЕТ ответить 501 (не реализовано).</target>
        </trans-unit>
        <trans-unit id="1c8b20b0d07b7680a3c0f95ac8ec3b25b3de332b" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.2</source>
          <target state="translated">Протокол безопасности транспортного уровня (TLS)Версия 1.2</target>
        </trans-unit>
        <trans-unit id="12fd383ebe402c54f473646772c58d3e6163c837" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.3</source>
          <target state="translated">Протокол безопасности транспортного уровня (TLS)версия 1.3</target>
        </trans-unit>
        <trans-unit id="8a56da9b77b531c4fafce5d057fc066caa86cf4f" translate="yes" xml:space="preserve">
          <source>The UA string of Firefox itself is broken down into four components:</source>
          <target state="translated">Строка UA самого Firefox разбита на четыре компонента:</target>
        </trans-unit>
        <trans-unit id="f72374d140af175240e14a12a7f961729a13b2d2" translate="yes" xml:space="preserve">
          <source>The UNLOCK method removes the lock identified by the lock token in
   the Lock-Token request header.  The Request-URI MUST identify a
   resource within the scope of the lock.

   Note that use of the Lock-Token header to provide the lock token is
   not consistent with other state-changing methods, which all require
   an If header with the lock token.  Thus, the If header is not needed
   to provide the lock token.  Naturally, when the If header is present,
   it has its normal meaning as a conditional header.

   For a successful response to this method, the server MUST delete the
   lock entirely.

   If all resources that have been locked under the submitted lock token
   cannot be unlocked, then the UNLOCK request MUST fail.

   A successful response to an UNLOCK method does not mean that the
   resource is necessarily unlocked.  It means that the specific lock
   corresponding to the specified token no longer exists.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the UNLOCK method.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">Метод UNLOCK снимает блокировку, идентифицированную токеном блокировки в заголовке запроса Lock-Token. Request-URI ДОЛЖЕН идентифицировать ресурс в рамках блокировки. Обратите внимание, что использование заголовка Lock-Token для предоставления токена блокировки несовместимо с другими методами изменения состояния, которые все требуют заголовка If с токеном блокировки. Таким образом, заголовок If не нужен для предоставления токена блокировки. Естественно, когда присутствует заголовок If, он имеет свое обычное значение как условный заголовок. Для успешного ответа на этот метод сервер ДОЛЖЕН полностью удалить блокировку. Если все ресурсы, которые были заблокированы поданным токеном блокировки, не могут быть разблокированы, то запрос UNLOCK ДОЛЖЕН завершиться неудачей. Успешный ответ на метод UNLOCK не означает, что ресурс обязательно разблокирован.Это означает, что конкретной блокировки, соответствующей указанному токену, больше не существует. Любой DAV-совместимый ресурс, поддерживающий метод LOCK, ДОЛЖЕН поддерживать метод UNLOCK. Этот метод идемпотентен, но небезопасен (см.&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Раздел 9.1 [RFC2616]&lt;/a&gt; ). Ответы на этот метод НЕ ДОЛЖНЫ кэшироваться.</target>
        </trans-unit>
        <trans-unit id="b0025b4b69a4ce00bf003d08c44025493d147db8" translate="yes" xml:space="preserve">
          <source>The URI (absolute or relative) must be enclosed between &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc195e95f3f78e1ec1e89ef97a6a85b571c15d4" translate="yes" xml:space="preserve">
          <source>The URI of the document in which the violation occurred.</source>
          <target state="translated">URI документа,в котором произошло нарушение.</target>
        </trans-unit>
        <trans-unit id="a00094afe4ee340f38859ca45715a9f8d4fda91e" translate="yes" xml:space="preserve">
          <source>The URI of the resource that was blocked from loading by the Content Security Policy. If the blocked URI is from a different origin than the &lt;code&gt;document-uri&lt;/code&gt;, then the blocked URI is truncated to contain just the scheme, host, and port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb66755626c081ee38ccbccf8e082e6464687a3" translate="yes" xml:space="preserve">
          <source>The URI of the resource that was blocked from loading by the Content Security Policy. If the blocked URI is from a different origin than the document-uri, then the blocked URI is truncated to contain just the scheme, host, and port.</source>
          <target state="translated">URI ресурса,который был заблокирован для загрузки политикой безопасности контента.Если заблокированный URI имеет иное происхождение,чем document-uri,то заблокированный URI усекается,чтобы содержать только схему,хост и порт.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
