<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="a7213ccaea2b1f5a17c04d5d00a491991e7405ff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;cookie-name&amp;gt;&lt;/code&gt; can be any US-ASCII characters, except control characters, spaces, or tabs. It also must not contain a separator character like the following: &lt;code&gt;( ) &amp;lt; &amp;gt; @ , ; : \ &quot; / [ ] ? = { }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b2a81bf240653adf4ae5646645097e3700e614" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;cookie-value&amp;gt;&lt;/code&gt; can optionally be set in double quotes and any US-ASCII characters excluding CTLs, whitespace, double quotes, comma, semicolon, and backslash are allowed. &lt;strong&gt;Encoding&lt;/strong&gt;: Many implementations perform URL encoding on cookie values, however it is not required per the RFC specification. It does help satisfying the requirements about which characters are allowed for &amp;lt;cookie-value&amp;gt; though.</source>
          <target state="translated">&lt;code&gt;&amp;lt;cookie-value&amp;gt;&lt;/code&gt; необязательно может быть установлен в двойные кавычки и любые US-ASCII символов , исключая ЦТЛ, пробелы, двойные кавычки, запятая, точка с запятой и обратной косой черты допускается. &lt;strong&gt;Кодирование&lt;/strong&gt; : многие реализации выполняют кодирование URL-адресов для значений файлов cookie, однако это не требуется согласно спецификации RFC. Однако это помогает удовлетворить требования о том, какие символы разрешены для &amp;lt;cookie-value&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="e3f20af8a4d172bba05887f769d27d85c6a8c07e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;cookie-value&amp;gt;&lt;/code&gt; can optionally be wrapped in double quotes and include any US-ASCII characters excluding control characters, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Whitespace&quot;&gt;Whitespace&lt;/a&gt;, double quotes, comma, semicolon, and backslash. &lt;strong&gt;Encoding&lt;/strong&gt;: Many implementations perform URL encoding on cookie values, however it is not required per the RFC specification. It does help satisfying the requirements about which characters are allowed for &amp;lt;cookie-value&amp;gt; though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f819db31cf5179b914aa0bbc4b051d20a15499c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ruellan-http-accept-push-policy-00#section-3.2&quot;&gt;Push-Policy&lt;/a&gt;&lt;/code&gt; defines the server behaviour regarding push when processing a request.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ruellan-http-accept-push-policy-00#section-3.2&quot;&gt;Push-Policy&lt;/a&gt;&lt;/code&gt; определяет поведение сервера относительно толчок при обработке запроса.</target>
        </trans-unit>
        <trans-unit id="907291403f83bafff1a5018284ddb5cda5ef87c1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Host&lt;/code&gt; header field must be sent in all HTTP/1.1 request messages. A &lt;a href=&quot;../status/400&quot;&gt;&lt;code&gt;400&lt;/code&gt;&lt;/a&gt; (Bad Request) status code may be sent to any HTTP/1.1 request message that lacks a &lt;code&gt;Host&lt;/code&gt; header field or that contains more than one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd38adbfb297f98e4845f58ef168d327990960e8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Host&lt;/code&gt; header field must be sent in all HTTP/1.1 request messages. A &lt;a href=&quot;../status/400&quot;&gt;&lt;code&gt;400&lt;/code&gt;&lt;/a&gt; (Bad Request) status code will be sent to any HTTP/1.1 request message that lacks a &lt;code&gt;Host&lt;/code&gt; header field or contains more than one.</source>
          <target state="translated">&lt;code&gt;Host&lt;/code&gt; поле заголовка должно быть отправлено во всех сообщениях HTTP / 1.1 запроса. &lt;a href=&quot;../status/400&quot;&gt; &lt;code&gt;400&lt;/code&gt; &lt;/a&gt; (Bad Request) код состояния будет отправлено на любое сообщение / 1.1 запроса HTTP , который испытывает недостаток в &lt;code&gt;Host&lt;/code&gt; - поле заголовка или содержит больше , чем один.</target>
        </trans-unit>
        <trans-unit id="8d493f4b34b837ecbf516ab3be315bb7e5800bd7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Large-Allocation&lt;/code&gt; header was ignored due to the document not being loaded out of process.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; заголовок был проигнорирован из - документа не загруженный из процесса.</target>
        </trans-unit>
        <trans-unit id="b52f033ccd0a61255fd618ddae3d133b3a87b36a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Large-Allocation&lt;/code&gt; header was ignored due to the load being triggered by a non-GET request.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; заголовок был проигнорирован из - за нагрузки , которые инициированы по запросу не-GET.</target>
        </trans-unit>
        <trans-unit id="8b66ecc22d4701e215c7c43a0496c165504db343" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Large-Allocation&lt;/code&gt; header was ignored due to the presence of windows which have a reference to this browsing context through the frame hierarchy or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/opener&quot;&gt;&lt;code&gt;window.opener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; заголовок был проигнорирован из - за наличие окон , которые имеют ссылки на этот контекст просмотра через иерархию фреймов или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/opener&quot;&gt; &lt;code&gt;window.opener&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73a9512193aaddbed5822d47b67cd6e8914618f0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;PATCH&lt;/code&gt; is not necessarily idempotent, although it can be. Contrast this with &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;; which is always idempotent. The word &quot;idempotent&quot; means that any number of repeated, identical requests will leave the resource in the same state. For example if an auto-incrementing counter field is an integral part of the resource, then a &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; will naturally overwrite it (since it overwrites everything), but not necessarily so for &lt;code&gt;PATCH&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8022f4e83935a93ef3b8b1c2d930ed06dced354" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;PATCH&lt;/code&gt; request is considered a set of instructions on how to modify a resource. Contrast this with &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;; which is a complete representation of a resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148adc34b3c03dd4552c4ce02841588fbe7d2b17" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;POST&lt;/code&gt; request is typically sent via an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML form&lt;/a&gt; and results in a change on the server. In this case, the content type is selected by putting the adequate string in the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#attr-enctype&quot;&gt;enctype&lt;/a&gt;&lt;/code&gt; attribute of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;/a&gt; element or the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-formenctype&quot;&gt;formenctype&lt;/a&gt;&lt;/code&gt; attribute of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button&quot;&gt;&lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;&lt;/a&gt; elements:</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; - запрос обычно посылаются через &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;форму HTML&lt;/a&gt; и приводит к изменению на сервере. В этом случае тип содержимого выбирается путем помещения соответствующей строки в атрибут &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#attr-enctype&quot;&gt;enctype&lt;/a&gt;&lt;/code&gt; элемента &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;/a&gt; или атрибут &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-formenctype&quot;&gt;formenctype&lt;/a&gt;&lt;/code&gt; элементов &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt; &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button&quot;&gt; &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a9a09061e55ef0722388221ef70fbf98831901fc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Referer&lt;/code&gt; header is not sent by browsers if:</source>
          <target state="translated">&lt;code&gt;Referer&lt;/code&gt; заголовок не отправляется при помощи браузера , если:</target>
        </trans-unit>
        <trans-unit id="b7de4dc33844cb3c83cd7c6ece8fd1f67d772660" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Tk&lt;/code&gt; header for a resource that claims not to be tracking would look like:</source>
          <target state="translated">&lt;code&gt;Tk&lt;/code&gt; заголовок для ресурса , который утверждает , что не будет отслеживания будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="3a39de192b8c94e0bdb22f2bcb149d7e553934cb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;data&lt;/code&gt; URL provides a file within a file, which can potentially be very wide relative to the width of the enclosing document. As a URL, the &lt;code&gt;data&lt;/code&gt; should be formatable with whitespace (linefeed, tab, or spaces), but there are practical issues that arise &lt;a href=&quot;http://bugzilla.mozilla.org/show_bug.cgi?id=73026#c12&quot;&gt;when using base64 encoding&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; URL - адрес содержит файл в файл, который потенциально может быть очень широким по сравнению с шириной вмещающего документа. В качестве URL-адреса &lt;code&gt;data&lt;/code&gt; должны быть отформатированы с использованием пробелов (перевод строки, табуляция или пробелы), но &lt;a href=&quot;http://bugzilla.mozilla.org/show_bug.cgi?id=73026#c12&quot;&gt;при использовании кодировки base64&lt;/a&gt; возникают практические проблемы .</target>
        </trans-unit>
        <trans-unit id="0f62e0b29365c072d5d290c0cb67e2e50ff07068" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;multipart/form-data&lt;/code&gt; body requires a &lt;code&gt;Content-Disposition&lt;/code&gt; header to provide information for each subpart of the form (e.g. for every form field and any files that are part of field data). The first directive is always &lt;code&gt;form-data&lt;/code&gt;, and the header &lt;em&gt;must&lt;/em&gt; also include a &lt;code&gt;name&lt;/code&gt; parameter to identify the relevant field. Additional directives are case-insensitive and have arguments that use quoted-string syntax after the &lt;code&gt;'='&lt;/code&gt; sign. Multiple parameters are separated by a semi-colon (&lt;code&gt;';'&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ef0cbe7ad55aa4468b6292a11f980a072c57e1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;name&lt;/code&gt; with a value of &lt;code&gt;'_charset_'&lt;/code&gt; indicates that the part is not an HTML field, but the default charset to use for parts without explicit charset information.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; со значением &lt;code&gt;'_charset_'&lt;/code&gt; указывает на то, что часть не является полем HTML, но кодировка по умолчанию использовать для частей без явного информации кодировок.</target>
        </trans-unit>
        <trans-unit id="77ca7e4cfdb62ea74f42d6c168a3d1427f68fc26" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;product token&lt;/em&gt; is a name followed by a '&lt;code&gt;/&lt;/code&gt;' and a version number, like &lt;code&gt;Firefox/4.0.1&lt;/code&gt;. There may be as many of them as the user-agent wants. A &lt;em&gt;comment&lt;/em&gt; is a free string delimited by parentheses. Obviously parentheses cannot be used in that string. The inner format of a comment is not defined by the standard, though several browser put several tokens in it, separated by '&lt;code&gt;;&lt;/code&gt;'.</source>
          <target state="translated">&lt;em&gt;Маркер продукта&lt;/em&gt; это имя следует &amp;laquo; &lt;code&gt;/&lt;/code&gt; &amp;raquo; и номер версии, как &lt;code&gt;Firefox/4.0.1&lt;/code&gt; . Их может быть столько, сколько хочет пользовательский агент. &lt;em&gt;Комментарий&lt;/em&gt; является свободной строкой с разделителями в скобках. Очевидно, что в этой строке нельзя использовать круглые скобки. Внутренний формат комментария не определен стандартом, хотя некоторые браузеры помещают в него несколько токенов, разделенных символом ' &lt;code&gt;;&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7807903fa1b0b7939213e9e4f5b3217c04d49395" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;start-line&lt;/em&gt; describing the requests to be implemented, or its status of whether successful or a failure. This start-line is always a single line.</source>
          <target state="translated">&lt;em&gt;Начало строки&lt;/em&gt; описания запросов должны быть реализованы, или его статус является ли успешной или сбоя. Эта начальная линия всегда представляет собой одну строку.</target>
        </trans-unit>
        <trans-unit id="93859c81ff65c5134b0dd141e4cbca2ab3420924" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;status code&lt;/em&gt;, indicating success or failure of the request. Common status codes are &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;status/404&quot;&gt;&lt;code&gt;404&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;Код состояния&lt;/em&gt; , указывающий успех или неудачу запроса. Общие коды состояния: &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;status/404&quot;&gt; &lt;code&gt;404&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; .&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76c2a47356f2a849271ea7cc25822c2941eeef27" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;status text&lt;/em&gt;. A brief, purely informational, textual description of the status code to help a human understand the HTTP message.</source>
          <target state="translated">&lt;em&gt;Текст статуса&lt;/em&gt; . Краткое, чисто информационное, текстовое описание кода состояния, помогающее человеку понять HTTP-сообщение.</target>
        </trans-unit>
        <trans-unit id="0559ada531b9179dd1b1f6a65154a22a437ad6c4" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;Multipurpose Internet Mail Extensions (MIME) type&lt;/strong&gt; is a standard that indicates the nature and format of a document, file, or assortment of bytes. It is defined and standardized in &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;IETF RFC 6838&lt;/a&gt;.</source>
          <target state="translated">Тип &lt;strong&gt;многоцелевых расширений электронной почты (MIME)&lt;/strong&gt; - это стандарт, который указывает характер и формат документа, файла или набора байтов. Он определен и стандартизирован в &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;IETF RFC 6838&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06fe2028c6d41d5f963c85bb23a2f9582052e0be" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;Proxy Auto-Configuration (PAC)&lt;/strong&gt; file is a JavaScript function that determines whether web browser requests (HTTP, HTTPS, and FTP) go directly to the destination or are forwarded to a web proxy server. The JavaScript function contained in the PAC file defines the function:</source>
          <target state="translated">&lt;strong&gt;Proxy Auto-Configuration (PAC)&lt;/strong&gt; файл является функцией JavaScript , который определяет , является ли запросы веб - браузера (HTTP, HTTPS и FTP) перейти непосредственно к месту назначения или направляются к веб - прокси - сервер. Функция JavaScript, содержащаяся в файле PAC, определяет функцию:</target>
        </trans-unit>
        <trans-unit id="921d1ae1d227879cc9b76f47ae6c47c89749c0e7" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;media type&lt;/strong&gt; (also known as a &lt;strong&gt;Multipurpose Internet Mail Extensions or MIME type&lt;/strong&gt;) is a standard that indicates the nature and format of a document, file, or assortment of bytes. It is defined and standardized in IETF's &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32908568fcbbdd8ea0e3d262e49fd8c59b6cf1c5" translate="yes" xml:space="preserve">
          <source>A COPY method invocation MUST NOT duplicate any write locks active on
   the source.  However, as previously noted, if the COPY copies the
   resource into a collection that is locked with a depth-infinity lock,
   then the resource will be added to the lock.

   A successful MOVE request on a write locked resource MUST NOT move
   the write lock with the resource.  However, if there is an existing
   lock at the destination, the server MUST add the moved resource to
   the destination lock scope.  For example, if the MOVE makes the
   resource a child of a collection that has a depth-infinity lock, then
   the resource will be added to that collection's lock.  Additionally,
   if a resource with a depth-infinity lock is moved to a destination
   that is within the scope of the same lock (e.g., within the URL
   namespace tree covered by the lock), the moved resource will again be
   added to the lock.  In both these examples, as specified in
   &lt;a href=&quot;#section-7.5&quot;&gt;Section 7.5&lt;/a&gt;, an If header must be submitted containing a lock token
   for both the source and destination.</source>
          <target state="translated">Вызов метода COPY НЕ ДОЛЖЕН дублировать какие-либо блокировки записи, действующие в источнике. Однако, как отмечалось ранее, если COPY копирует ресурс в коллекцию, которая заблокирована блокировкой бесконечности глубины, то ресурс будет добавлен к блокировке. Успешный запрос MOVE для ресурса с блокировкой записи НЕ ДОЛЖЕН перемещать блокировку записи вместе с ресурсом. Однако, если в месте назначения существует блокировка, сервер ДОЛЖЕН добавить перемещенный ресурс в область блокировки назначения. Например, если MOVE делает ресурс дочерним по отношению к коллекции, которая имеет блокировку бесконечности глубины, то ресурс будет добавлен к блокировке этой коллекции. Кроме того, если ресурс с блокировкой бесконечности глубины перемещается в место назначения, которое находится в области действия той же блокировки (например,в дереве пространства имен URL, охваченном блокировкой), перемещенный ресурс снова будет добавлен к блокировке. В обоих этих примерах, как указано в &lt;a href=&quot;#section-7.5&quot;&gt;В разделе 7.5&lt;/a&gt; необходимо отправить заголовок If, содержащий токен блокировки как для источника, так и для пункта назначения.</target>
        </trans-unit>
        <trans-unit id="54ccf84b84ef6409cbbed9c34674f05d1e7198a6" translate="yes" xml:space="preserve">
          <source>A Condition that consists of a single entity-tag or state-token
   evaluates to true if the resource matches the described state (where
   the individual matching functions are defined below in
   &lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;).  Prefixing it with &quot;Not&quot; reverses the result of the
   evaluation (thus, the &quot;Not&quot; applies only to the subsequent entity-tag
   or state-token).

   Each List production describes a series of conditions.  The whole
   list evaluates to true if and only if each condition evaluates to
   true (that is, the list represents a logical conjunction of
   Conditions).

   Each No-tag-list and Tagged-list production may contain one or more
   Lists.  They evaluate to true if and only if any of the contained
   lists evaluates to true (that is, if there's more than one List, that
   List sequence represents a logical disjunction of the Lists). 

   Finally, the whole If header evaluates to true if and only if at
   least one of the No-tag-list or Tagged-list productions evaluates to
   true.  If the header evaluates to false, the server MUST reject the
   request with a 412 (Precondition Failed) status.  Otherwise,
   execution of the request can proceed as if the header wasn't present.</source>
          <target state="translated">Условие, состоящее из одного тега объекта или токена состояния, оценивается как истинное, если ресурс соответствует описанному состоянию (где отдельные функции сопоставления определены ниже в &lt;a href=&quot;#section-10.4.4&quot;&gt;Разделе 10.4.4.&lt;/a&gt;). Приставка &amp;laquo;Not&amp;raquo; к нему отменяет результат оценки (таким образом, &amp;laquo;Not&amp;raquo; применяется только к последующему тегу объекта или токену состояния). Каждая продукция Списка описывает ряд условий. Весь список оценивается как истинный тогда и только тогда, когда каждое условие оценивается как истинное (то есть список представляет собой логическое соединение условий). Каждый список без тегов и список с тегами может содержать один или несколько списков. Они оцениваются как истинные тогда и только тогда, когда какой-либо из содержащихся списков оценивается как истинный (то есть, если существует более одного списка, эта последовательность списков представляет собой логическое разделение списков). Наконец, весь заголовок If оценивается как истинный тогда и только тогда, когда по крайней мере одно из производств No-tag-list или Tagged-list оценивается как истинное. Если значение заголовка ложно,сервер ДОЛЖЕН отклонить запрос со статусом 412 (Precondition Failed). В противном случае выполнение запроса может продолжаться, как если бы заголовок отсутствовал.</target>
        </trans-unit>
        <trans-unit id="8ca49fbd841006f7b8c4f68cfeb745b6f799b83d" translate="yes" xml:space="preserve">
          <source>A DAV-compliant resource can advertise several classes of compliance.
   A client can discover the compliance classes of a resource by
   executing OPTIONS on the resource and examining the &quot;DAV&quot; header
   which is returned.  Note particularly that resources, rather than
   servers, are spoken of as being compliant.  That is because
   theoretically some resources on a server could support different
   feature sets.  For example, a server could have a sub-repository
   where an advanced feature like versioning was supported, even if that
   feature was not supported on all sub-repositories.

   Since this document describes extensions to the HTTP/1.1 protocol,
   minimally all DAV-compliant resources, clients, and proxies MUST be
   compliant with [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   A resource that is class 2 or class 3 compliant must also be class 1
   compliant.</source>
          <target state="translated">Ресурс, совместимый с DAV, может рекламировать несколько классов соответствия. Клиент может обнаружить классы соответствия ресурса, выполнив OPTIONS для ресурса и проверив возвращаемый заголовок &amp;laquo;DAV&amp;raquo;. Обратите особое внимание на то, что ресурсы, а не серверы, считаются совместимыми. Это потому, что теоретически некоторые ресурсы на сервере могут поддерживать разные наборы функций. Например, на сервере может быть суб-репозиторий, в котором поддерживается расширенная функция, такая как управление версиями, даже если эта функция не поддерживается во всех суб-репозиториях. Поскольку в этом документе описаны расширения протокола HTTP / 1.1, как минимум все DAV-совместимые ресурсы, клиенты и прокси ДОЛЖНЫ соответствовать [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]. Ресурс, соответствующий классу 2 или 3, также должен соответствовать классу 1.</target>
        </trans-unit>
        <trans-unit id="f86021a073cb3d0361968791f30494aec6a11bf5" translate="yes" xml:space="preserve">
          <source>A LOCK request to an existing resource will create a lock on the
   resource identified by the Request-URI, provided the resource is not
   already locked with a conflicting lock.  The resource identified in
   the Request-URI becomes the root of the lock.  LOCK method requests
   to create a new lock MUST have an XML request body.  The server MUST
   preserve the information provided by the client in the 'owner'
   element in the LOCK request.  The LOCK request MAY have a Timeout
   header.

   When a new lock is created, the LOCK response:

   o  MUST contain a body with the value of the DAV:lockdiscovery
      property in a prop XML element.  This MUST contain the full
      information about the lock just granted, while information about
      other (shared) locks is OPTIONAL.

   o  MUST include the Lock-Token response header with the token
      associated with the new lock.</source>
          <target state="translated">Запрос на БЛОКИРОВКУ к существующему ресурсу создаст блокировку на ресурсе,идентифицируемом Request-URI,при условии,что ресурс еще не заблокирован конфликтующим замком.Ресурс,идентифицируемый в Request-URI,становится корнем замка.Запросы метода блокировки для создания нового замка ДОЛЖНЫ иметь XML тело запроса.Сервер ДОЛЖЕН сохранять информацию,предоставленную клиентом в элементе 'владелец' в запросе LOCK.Запрос на БЛОКИРОВКУ ДОЛЖЕН иметь заголовок Timeout.Когда новый замок создается,ответ БЛОКИРОВКА:o ДОЛЖЕН содержать тело со значением свойства DAV:lock-discovery в элементе prop XML.Это ДОЛЖНО содержать полную информацию о блокировке только что предоставлено,в то время как информация о других (общих)замков является ФАКУЛЬТАТИВНЫМ.o ДОЛЖЕН включать Lock-Token ответ заголовок с токеном,связанные с новой блокировки.</target>
        </trans-unit>
        <trans-unit id="b5ec04e796ad556a9a01172c14afcf29870510e8" translate="yes" xml:space="preserve">
          <source>A Last-Modified time, when used as a validator in a request, is
   implicitly weak unless it is possible to deduce that it is strong,
   using the following rules:

   o  The validator is being compared by an origin server to the actual
      current validator for the representation and,

   o  That origin server reliably knows that the associated
      representation did not change twice during the second covered by
      the presented validator.

   or

   o  The validator is about to be used by a client in an
      If-Modified-Since, If-Unmodified-Since, or If-Range header field,
      because the client has a cache entry for the associated
      representation, and

   o  That cache entry includes a Date value, which gives the time when
      the origin server sent the original response, and

   o  The presented Last-Modified time is at least 60 seconds before the
      Date value.

   or

   o  The validator is being compared by an intermediate cache to the
      validator stored in its cache entry for the representation, and

   o  That cache entry includes a Date value, which gives the time when
      the origin server sent the original response, and

   o  The presented Last-Modified time is at least 60 seconds before the
      Date value. 

   This method relies on the fact that if two different responses were
   sent by the origin server during the same second, but both had the
   same Last-Modified time, then at least one of those responses would
   have a Date value equal to its Last-Modified time.  The arbitrary
   60-second limit guards against the possibility that the Date and
   Last-Modified values are generated from different clocks or at
   somewhat different times during the preparation of the response.  An
   implementation MAY use a value larger than 60 seconds, if it is
   believed that 60 seconds is too short.</source>
          <target state="translated">Последнее изменённое время,когда оно используется в качестве валидатора в запросе,является неявно слабым,если только нет возможности вывести,что оно сильное,используя следующие правила:o Валидатор сравнивается сервером-источником с действительным текущим валидатором для данного представления и,o Этот сервер-источник надёжно знает,что связанное с ним представление не изменялось дважды в течение второго периода,охватываемого представленным валидатором.или o Валидатор собирается использовать клиент в поле заголовка If-Modified-Since,If-Unmodified-Since или If-Range,так как клиент имеет запись в кэше для ассоциированного представления,и o Эта запись в кэше включает значение Date (Дата),дающее время,когда сервер отправил оригинальный ответ,и o Представленное время Last-Modified (Последнее измененное)как минимум 60 секунд до значения Date (Дата).или o Валидатор сравнивается промежуточным кэшем с валидатором,хранящимся в его кэш-памяти для представления,и o Эта запись в кэше включает значение Date (Дата),которое указывает время,когда сервер отправил оригинальный ответ,и o Представленное Последнее измененное время как минимум за 60 секунд до значения Date (Дата).Этот метод основан на том факте,что если бы два разных ответа были отправлены сервером происхождения в течение одной и той же секунды,но оба имели одно и то же время Last-Modified time,то,по крайней мере,один из этих ответов имел бы значение Date,равное его Last-Modified time.Произвольный 60-секундный лимит предохраняет от возможности того,что значения Date и Last-Modified генерируются разными часами или в несколько разное время во время подготовки ответа.Реализация MAY использует значение больше 60 секунд,если считается,что 60 секунд слишком мало.</target>
        </trans-unit>
        <trans-unit id="3b3ff774d817ff6a5f8200f28c0299ad729f7f1f" translate="yes" xml:space="preserve">
          <source>A MIME type consists of a &lt;strong&gt;type&lt;/strong&gt; and a &lt;strong&gt;subtype&lt;/strong&gt; &amp;mdash; two strings separated by &lt;code&gt;/&lt;/code&gt;. No whitespace is allowed. The &lt;em&gt;type&lt;/em&gt; represents the category and can be a &lt;em&gt;discrete&lt;/em&gt; or a &lt;em&gt;multipart&lt;/em&gt; type. The &lt;em&gt;subtype&lt;/em&gt; is specific to each type.</source>
          <target state="translated">Тип MIME состоит из &lt;strong&gt;типа&lt;/strong&gt; и &lt;strong&gt;подтипа&lt;/strong&gt; - двух строк, разделенных &lt;code&gt;/&lt;/code&gt; . Пробелы не допускаются. &lt;em&gt;Тип&lt;/em&gt; представляет собой категорию и может быть &lt;em&gt;дискретным&lt;/em&gt; или &lt;em&gt;многочастным&lt;/em&gt; типом. &lt;em&gt;Подтипа&lt;/em&gt; является специфическим для каждого типа.</target>
        </trans-unit>
        <trans-unit id="df3b4fd9f2c9a070d38b528649b2abf469edffda" translate="yes" xml:space="preserve">
          <source>A MIME type, but without any subtype. &lt;code&gt;image/*&lt;/code&gt; will match &lt;code&gt;image/png&lt;/code&gt;, &lt;code&gt;image/svg&lt;/code&gt;, &lt;code&gt;image/gif&lt;/code&gt; and any other image types.</source>
          <target state="translated">Тип MIME, но без подтипа. &lt;code&gt;image/*&lt;/code&gt; будет соответствовать &lt;code&gt;image/png&lt;/code&gt; , &lt;code&gt;image/svg&lt;/code&gt; , &lt;code&gt;image/gif&lt;/code&gt; и любым другим типам изображений.</target>
        </trans-unit>
        <trans-unit id="5ad212a1da928bdf764389014591f982a86a3c0f" translate="yes" xml:space="preserve">
          <source>A MOVE with &quot;Depth: infinity&quot; instructs that the collection
   identified by the Request-URI be moved to the address specified in
   the Destination header, and all resources identified by its internal
   member URLs are to be moved to locations relative to it, recursively
   through all levels of the collection hierarchy.

   The MOVE method on a collection MUST act as if a &quot;Depth: infinity&quot;
   header was used on it.  A client MUST NOT submit a Depth header on a
   MOVE on a collection with any value but &quot;infinity&quot;. 

   Any headers included with MOVE MUST be applied in processing every
   resource to be moved with the exception of the Destination header.
   The behavior of the Destination header is the same as given for COPY
   on collections.

   When the MOVE method has completed processing, it MUST have created a
   consistent URL namespace at both the source and destination (see
   &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; for the definition of namespace consistency).  However,
   if an error occurs while moving an internal collection, the server
   MUST NOT move any resources identified by members of the failed
   collection (i.e., the server must skip the error-causing subtree), as
   this would create an inconsistent namespace.  In this case, after
   detecting the error, the move operation SHOULD try to finish as much
   of the original move as possible (i.e., the server should still
   attempt to move other subtrees and the resources identified by their
   members that are not descendants of an error-causing collection).
   So, for example, if an infinite-depth move is performed on collection
   /a/, which contains collections /a/b/ and /a/c/, and an error occurs
   moving /a/b/, an attempt should still be made to try moving /a/c/.
   Similarly, after encountering an error moving a non-collection
   resource as part of an infinite-depth move, the server SHOULD try to
   finish as much of the original move operation as possible.

   If an error occurs with a resource other than the resource identified
   in the Request-URI, then the response MUST be a 207 (Multi-Status),
   and the errored resource's URL MUST appear with the specific error.

   The 424 (Failed Dependency) status code SHOULD NOT be returned in the
   207 (Multi-Status) response from a MOVE method.  These errors can be
   safely omitted because the client will know that the progeny of a
   resource could not be moved when the client receives an error for the
   parent.  Additionally, 201 (Created)/204 (No Content) responses
   SHOULD NOT be returned as values in 207 (Multi-Status) responses from
   a MOVE.  These responses can be safely omitted because they are the
   default success codes.</source>
          <target state="translated">MOVE с &quot;Depth: infinity&quot; указывает, что коллекция, идентифицированная Request-URI, должна быть перемещена по адресу, указанному в заголовке Destination, и все ресурсы, идентифицированные ее внутренними URL-адресами, должны быть перемещены в местоположения относительно нее, рекурсивно через все уровни иерархии коллекций. Метод MOVE для коллекции ДОЛЖЕН действовать так, как если бы для него использовался заголовок &amp;laquo;Depth: infinity&amp;raquo;. Клиент НЕ ДОЛЖЕН отправлять заголовок Depth при MOVE в коллекции с любым значением, кроме &quot;бесконечности&quot;. Любые заголовки, включенные в MOVE, ДОЛЖНЫ применяться при обработке каждого перемещаемого ресурса, за исключением заголовка Destination. Поведение заголовка Destination такое же, как и для COPY в коллекциях. Когда метод MOVE завершит обработку,он ДОЛЖЕН создать согласованное пространство имен URL как в источнике, так и в месте назначения (см. &lt;a href=&quot;#section-5.1&quot;&gt;Раздел 5.1&lt;/a&gt;для определения согласованности пространства имен). Однако, если при перемещении внутренней коллекции возникает ошибка, сервер НЕ ДОЛЖЕН перемещать какие-либо ресурсы, идентифицированные членами неудачной коллекции (т. Е. Сервер должен пропустить поддерево, вызывающее ошибку), поскольку это создаст несогласованное пространство имен. В этом случае, после обнаружения ошибки, операции перемещения СЛЕДУЕТ попытаться завершить как можно большую часть исходного перемещения (т. Е. Сервер все равно должен пытаться переместить другие поддеревья и ресурсы, идентифицированные их членами, которые не являются потомками ошибки. - причинный сборник). Так, например, если перемещение на бесконечную глубину выполняется для коллекции / a /, которая содержит коллекции / a / b / и / a / c /, и возникает ошибка при перемещении / a / b /, попытка все равно должна быть заставил попробовать переместить / a / c /. Так же,после обнаружения ошибки при перемещении ресурса, не являющегося коллекцией, как части перемещения на бесконечную глубину, серверу СЛЕДУЕТ попытаться завершить как можно большую часть исходной операции перемещения. Если ошибка возникает с ресурсом, отличным от ресурса, указанного в Request-URI, тогда ответ ДОЛЖЕН быть 207 (Multi-Status), а URL-адрес ошибочного ресурса ДОЛЖЕН появиться с конкретной ошибкой. Код состояния 424 (Failed Dependency) НЕ ДОЛЖЕН возвращаться в ответе 207 (Multi-Status) от метода MOVE. Эти ошибки можно безопасно опустить, потому что клиент будет знать, что потомок ресурса не может быть перемещен, когда клиент получит ошибку для родительского элемента. Кроме того, ответы 201 (Создано) / 204 (Нет содержимого) НЕ ДОЛЖНЫ возвращаться как значения в ответах 207 (Мульти-статус) от MOVE.Эти ответы можно безопасно опустить, потому что они являются кодами успеха по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e669f83c371fcfc2d6309646e47cad96a8d6939b" translate="yes" xml:space="preserve">
          <source>A Multi-Status response conveys information about multiple resources
   in situations where multiple status codes might be appropriate.  The
   default Multi-Status response body is a text/xml or application/xml
   HTTP entity with a 'multistatus' root element.  Further elements
   contain 200, 300, 400, and 500 series status codes generated during
   the method invocation. 100 series status codes SHOULD NOT be recorded
   in a 'response' XML element.

   Although '207' is used as the overall response status code, the
   recipient needs to consult the contents of the multistatus response
   body for further information about the success or failure of the
   method execution.  The response MAY be used in success, partial
   success and also in failure situations.

   The 'multistatus' root element holds zero or more 'response' elements
   in any order, each with information about an individual resource.
   Each 'response' element MUST have an 'href' element to identify the
   resource.

   A Multi-Status response uses one out of two distinct formats for
   representing the status:

   1.  A 'status' element as child of the 'response' element indicates
       the status of the message execution for the identified resource
       as a whole (for instance, see &lt;a href=&quot;#section-9.6.2&quot;&gt;Section 9.6.2&lt;/a&gt;).  Some method
       definitions provide information about specific status codes
       clients should be prepared to see in a response.  However,
       clients MUST be able to handle other status codes, using the
       generic rules defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;Section&amp;nbsp;10 of [RFC2616]&lt;/a&gt;.

   2.  For PROPFIND and PROPPATCH, the format has been extended using
       the 'propstat' element instead of 'status', providing information
       about individual properties of a resource.  This format is
       specific to PROPFIND and PROPPATCH, and is described in detail in
       Sections &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; and &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;.</source>
          <target state="translated">Ответ с несколькими состояниями передает информацию о нескольких ресурсах в ситуациях, когда может потребоваться несколько кодов состояния. Тело ответа Multi-Status по умолчанию - это HTTP-объект text / xml или application / xml с корневым элементом multistatus. Дополнительные элементы содержат коды состояния серий 200, 300, 400 и 500, сгенерированные во время вызова метода. Коды состояния серии 100 НЕ ДОЛЖНЫ записываться в XML-элементе &amp;laquo;ответ&amp;raquo;. Хотя &amp;laquo;207&amp;raquo; используется в качестве общего кода состояния ответа, получателю необходимо проконсультироваться с содержимым тела мультистатусного ответа для получения дополнительной информации об успехе или неудаче выполнения метода. Ответ МОЖЕТ быть использован в случае успеха, частичного успеха, а также в ситуациях неудачи. Мультистатускорневой элемент содержит ноль или более элементов &amp;laquo;ответа&amp;raquo; в любом порядке, каждый с информацией об отдельном ресурсе. Каждый элемент ответа ДОЛЖЕН иметь элемент href для идентификации ресурса. В ответе с несколькими состояниями используется один из двух различных форматов для представления статуса: 1. Элемент status как дочерний элемент элемента response указывает статус выполнения сообщения для идентифицированного ресурса в целом (например, видетьв качестве дочернего элемента элемента response указывает статус выполнения сообщения для идентифицированного ресурса в целом (например, см.в качестве дочернего элемента элемента response указывает статус выполнения сообщения для идентифицированного ресурса в целом (например, см.&lt;a href=&quot;#section-9.6.2&quot;&gt;Раздел 9.6.2&lt;/a&gt; ). Некоторые определения методов предоставляют информацию о конкретных кодах состояния, которые клиенты должны быть готовы увидеть в ответе. Однако клиенты ДОЛЖНЫ иметь возможность обрабатывать другие коды состояния, используя общие правила, определенные в &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;разделе 10 [RFC2616]&lt;/a&gt; . 2. Для PROPFIND и PROPPATCH формат был расширен с использованием элемента &amp;laquo;propstat&amp;raquo; вместо &amp;laquo;status&amp;raquo;, предоставляющего информацию об отдельных свойствах ресурса. Этот формат специфичен для PROPFIND и PROPPATCH и подробно описан в разделах &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; и &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da18d217768d6c1e8762bf2a3c6c1f21f00b13c4" translate="yes" xml:space="preserve">
          <source>A Multi-Status response conveys information about multiple resources in situations where multiple status codes might be appropriate.</source>
          <target state="translated">Реакция &quot;Мульти-статус&quot; передает информацию о множестве ресурсов в ситуациях,когда может быть уместно использовать несколько кодов статуса.</target>
        </trans-unit>
        <trans-unit id="47c63e0905725bb2dacb2b7404ab31605abb7f60" translate="yes" xml:space="preserve">
          <source>A PUT performed on an existing resource replaces the GET response
   entity of the resource.  Properties defined on the resource may be
   recomputed during PUT processing but are not otherwise affected.  For
   example, if a server recognizes the content type of the request body,
   it may be able to automatically extract information that could be
   profitably exposed as properties.

   A PUT that would result in the creation of a resource without an
   appropriately scoped parent collection MUST fail with a 409
   (Conflict).

   A PUT request allows a client to indicate what media type an entity
   body has, and whether it should change if overwritten.  Thus, a
   client SHOULD provide a Content-Type for a new resource if any is
   known.  If the client does not provide a Content-Type for a new
   resource, the server MAY create a resource with no Content-Type
   assigned, or it MAY attempt to assign a Content-Type. 

   Note that although a recipient ought generally to treat metadata
   supplied with an HTTP request as authoritative, in practice there's
   no guarantee that a server will accept client-supplied metadata
   (e.g., any request header beginning with &quot;Content-&quot;).  Many servers
   do not allow configuring the Content-Type on a per-resource basis in
   the first place.  Thus, clients can't always rely on the ability to
   directly influence the content type by including a Content-Type
   request header.</source>
          <target state="translated">PUT,выполненный на существующем ресурсе,заменяет объект GET-ответа ресурса.Свойства,определенные на ресурсе,могут быть пересчитаны во время обработки PUT,но не затрагиваются.Например,если сервер распознает тип содержимого тела запроса,он может быть в состоянии автоматически извлечь информацию,которая может быть выгодно выставлена в качестве свойств.PUT,который может привести к созданию ресурса без соответствующей родительской коллекции,ДОЛЖЕН обвалиться с 409 (Конфликт).Запрос PUT позволяет клиенту указать,какой тип носителя имеет тело сущности,и должен ли он измениться,если будет перезаписан.Таким образом,клиент ДОЛЖЕН предоставить Content-Type для нового ресурса,если он известен.Если клиент не предоставляет Content-Type для нового ресурса,то сервер MAY создает ресурс без присвоения Content-Type,или он MAY пытается присвоить Content-Type.Обратите внимание,что хотя получатель,как правило,должен относиться к метаданным,поставляемым с HTTP-запросом,как к полномочиям,на практике нет никакой гарантии,что сервер будет принимать метаданные,поставляемые клиентом (например,любой заголовок запроса,начинающийся с &quot;Content-&quot;).Многие серверы не позволяют настроить Content-Type для каждого отдельного ресурса в первую очередь.Таким образом,клиенты не всегда могут рассчитывать на возможность прямого влияния на тип контента путем включения заголовка Content-Type запроса.</target>
        </trans-unit>
        <trans-unit id="3416af5b6f6d84eb8e002dbdbec4d7e1feccd161" translate="yes" xml:space="preserve">
          <source>A Resource whose IRI is listed in a Collection is called a Member
   Resource.  The protocol defines two kinds of Member Resources --
   Entry Resources and Media Resources.  Entry Resources are represented
   as Atom Entry Documents [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].  Media Resources can have
   representations in any media type.  A Media Resource is described
   within a Collection using an Entry called a Media Link Entry.  This
   diagram shows the classification of Resources within the Atom
   Protocol:

                Member Resources
                       |
                -----------------
               |                 |
         Entry Resources     Media Resources
               |
         Media Link Entry

   The Atom Protocol defines Collection Resources for managing and
   organizing both kinds of Member Resource.  A Collection is
   represented by an Atom Feed Document.  A Collection Feed's Entries
   contain the IRIs of, and metadata about, the Collection's Member
   Resources.  A Collection Feed can contain any number of Entries,
   which might represent all the Members of the Collection, or an
   ordered subset of them (see &lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;).  In the diagram of a
   Collection below, there are two Entries.  The first contains the IRI
   of an Entry Resource.  The second contains the IRIs of both a Media
   Resource and a Media Link Entry, which contains the metadata for that
   Media Resource:

     Collection
        |
        o- Entry
        |    |
        |    o- Member Entry IRI (Entry Resource)
        |
        o- Entry
             |
             o- Member Entry IRI (Media Link Entry)
             |
             o- Media IRI        (Media Resource)

   The Atom Protocol does not make a distinction between Feeds used for
   Collections and other Atom Feeds.  The only mechanism that this
   specification supplies for indicating that a Feed is a Collection
   Feed is the presence of the Feed's IRI in a Service Document. 

   Service Documents represent server-defined groups of Collections, and
   are used to initialize the process of creating and editing Resources.
   These groups of Collections are called Workspaces.  Workspaces have
   names, but no IRIs, and no specified processing model.  The Service
   Document can indicate which media types, and which categories, a
   Collection will accept.  In the diagram below, there are two
   Workspaces each describing the IRIs, acceptable media types, and
   categories for a Collection:

     Service
        o- Workspace
        |    |
        |    o- Collection
        |         |
        |         o- IRI, categories, media types
        |
        o- Workspace
             |
             o- Collection
                  |
                  o- IRI, categories, media types</source>
          <target state="translated">Ресурс, IRI которого указан в коллекции, называется ресурсом-членом. Протокол определяет два вида членских ресурсов - входные ресурсы и медиаресурсы. Ресурсы ввода представлены как документы &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;ввода&lt;/a&gt; Atom [ RFC4287]. Медиа-ресурсы могут иметь представления в любом медиа-типе. Медиа-ресурс описывается в Коллекции с помощью записи, называемой медиа-ссылкой. На этой диаграмме показана классификация ресурсов в протоколе Atom: Ресурсы участников | ----------------- | | Ресурсы для входа Медиа-ресурсы | Запись медиа-ссылки Протокол Atom определяет ресурсы сбора для управления и организации обоих видов ресурсов-членов. Коллекция представлена ​​документом Atom Feed. Записи фида подборки содержат IRI и метаданные о ресурсах-членах коллекции. Фид подборки может содержать любое количество записей,которые могут представлять всех участников коллекции или их упорядоченное подмножество (см.&lt;a href=&quot;#section-10.1&quot;&gt;Раздел 10.1&lt;/a&gt;). На схеме коллекции ниже есть две записи. Первый содержит IRI ресурса входа. Второй содержит IRI медиаресурса и записи медиа-ссылки, которая содержит метаданные для этого медиаресурса: Коллекция | o- Вход | | | o- Вход для членов IRI (Ресурс для входа) | o- Вход | o- Вход для участников IRI (вход по медиа-ссылке) | o- Media IRI (медиаресурс) Протокол Atom не делает различия между фидами, используемыми для коллекций, и другими фидами Atom. Единственный механизм, который эта спецификация предоставляет для указания того, что фид является фидом коллекции, - это наличие IRI фида в служебном документе.Сервисные документы представляют собой определенные сервером группы Коллекций и используются для инициализации процесса создания и редактирования Ресурсов. Эти группы коллекций называются рабочими областями. У рабочих пространств есть имена, но нет IRI и нет определенной модели обработки. В служебном документе можно указать, какие типы мультимедиа и какие категории принимает Коллекция. На диаграмме ниже представлены две рабочие области, каждая из которых описывает IRI, допустимые типы мультимедиа и категории для коллекции: Service o- Workspace | | | o- Коллекция | | | o- IRI, категории, типы медиа | o- Рабочая область | o- Коллекция | o- IRI, категории, типы медиаи используются для инициализации процесса создания и редактирования ресурсов. Эти группы коллекций называются рабочими областями. У рабочих пространств есть имена, но нет IRI и нет определенной модели обработки. В служебном документе можно указать, какие типы мультимедиа и какие категории принимает Коллекция. На диаграмме ниже представлены две рабочие области, каждая из которых описывает IRI, допустимые типы мультимедиа и категории для коллекции: Service o- Workspace | | | o- Коллекция | | | o- IRI, категории, типы медиа | o- Рабочая область | o- Коллекция | o- IRI, категории, типы медиаи используются для инициализации процесса создания и редактирования ресурсов. Эти группы коллекций называются рабочими областями. У рабочих пространств есть имена, но нет IRI и нет определенной модели обработки. В служебном документе можно указать, какие типы мультимедиа и какие категории принимает Коллекция. На диаграмме ниже представлены две рабочие области, каждая из которых описывает IRI, допустимые типы мультимедиа и категории для коллекции: Service o- Workspace | | | o- Коллекция | | | o- IRI, категории, типы медиа | o- Рабочая область | o- Коллекция | o- IRI, категории, типы медиаУ рабочих пространств есть имена, но нет IRI и нет определенной модели обработки. В служебном документе можно указать, какие типы мультимедиа и какие категории принимает Коллекция. На диаграмме ниже представлены две рабочие области, каждая из которых описывает IRI, допустимые типы мультимедиа и категории для коллекции: Service o- Workspace | | | o- Коллекция | | | o- IRI, категории, типы медиа | o- Рабочая область | o- Коллекция | o- IRI, категории, типы медиаУ рабочих пространств есть имена, но нет IRI и нет определенной модели обработки. В служебном документе можно указать, какие типы мультимедиа и какие категории принимает Коллекция. На диаграмме ниже представлены две рабочие области, каждая из которых описывает IRI, допустимые типы мультимедиа и категории для коллекции: Service o- Workspace | | | o- Коллекция | | | o- IRI, категории, типы медиа | o- Рабочая область | o- Коллекция | o- IRI, категории, типы медиадопустимые типы мультимедиа и категории для коллекции: Service o- Workspace | | | o- Коллекция | | | o- IRI, категории, типы медиа | o- Рабочая область | o- Коллекция | o- IRI, категории, типы медиадопустимые типы мультимедиа и категории для коллекции: Service o- Workspace | | | o- Коллекция | | | o- IRI, категории, типы медиа | o- Рабочая область | o- Коллекция | o- IRI, категории, типы медиа</target>
        </trans-unit>
        <trans-unit id="35b9ab54a0a93ba0ced7c4af3c76df8322f7ce52" translate="yes" xml:space="preserve">
          <source>A Service Document groups Collections into Workspaces.  Operations on
   Workspaces, such as creation or deletion, are not defined by this
   specification.  This specification assigns no meaning to Workspaces;
   that is, a Workspace does not imply any specific processing
   assumptions.

   There is no requirement that a server support multiple Workspaces.
   In addition, a Collection MAY appear in more than one Workspace.</source>
          <target state="translated">Сервисный документ группирует коллекции в рабочие области.Операции на рабочих пространствах,такие как создание или удаление,не определяются данной спецификацией.Эта спецификация не придает значения рабочим пространствам;т.е.рабочее пространство не подразумевает никаких специфических предположений по обработке.Нет никаких требований к тому,чтобы сервер поддерживал несколько рабочих пространств.Кроме того,коллекция MAY появляется более чем в одной рабочей области.</target>
        </trans-unit>
        <trans-unit id="ab9f1fd23a2ea88a066574ed1c1549d86b5413c4" translate="yes" xml:space="preserve">
          <source>A TLS extension of type &lt;code&gt;signed_certificate_timestamp&lt;/code&gt; sent during the handshake</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c9ff77a6964659200d811cbcc28e7831aa3441" translate="yes" xml:space="preserve">
          <source>A URI where to POST the report to.</source>
          <target state="translated">УРИ,куда ПОСТАВИТЬ отчет.</target>
        </trans-unit>
        <trans-unit id="7d9a4a4099f798612139543cae66aebb996fc259" translate="yes" xml:space="preserve">
          <source>A URL is composed of different parts, some mandatory and others are optional. A more complex example might look like this:</source>
          <target state="translated">URL-адрес состоит из различных частей,некоторые обязательны,а другие необязательны.Более сложный пример может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="17235672157ab3c954238f5bafa108a22cb04819" translate="yes" xml:space="preserve">
          <source>A Uniform Resource Name (URN) is a URI that identifies a resource by name in a particular namespace.</source>
          <target state="translated">Унифицированное имя ресурса (URN)-это URI,который идентифицирует ресурс по имени в определенном пространстве имен.</target>
        </trans-unit>
        <trans-unit id="f48650afe5c259c1528667a4e36bcfbef464815b" translate="yes" xml:space="preserve">
          <source>A Web page is a hypertext document. This means some parts of displayed text are links which can be activated (usually by a click of the mouse) to fetch a new Web page, allowing the user to direct their user-agent and navigate through the Web. The browser translates these directions in HTTP requests, and further interprets the HTTP responses to present the user with a clear response.</source>
          <target state="translated">Веб-страница-это гипертекстовый документ.Это означает,что некоторые части отображаемого текста являются ссылками,которые могут быть активированы (обычно щелчком мыши)для получения новой Web-страницы,позволяя пользователю направлять своего пользователя-агента и перемещаться по Web.Браузер переводит эти направления в HTTP-запросах,а затем интерпретирует ответы HTTP,чтобы представить пользователю четкий ответ.</target>
        </trans-unit>
        <trans-unit id="4801f2494f1bfe7a2312cfcf44cb6aeb3133107d" translate="yes" xml:space="preserve">
          <source>A WebDAV client implemented to this specification might find servers
   that create lock-null resources (implemented before this
   specification using [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;]) as well as servers that create locked
   empty resources.  The response to the LOCK request will not indicate
   what kind of resource was created.  There are a few techniques that
   help the client deal with either type.

      If the client wishes to avoid accidentally creating either lock-
      null or empty locked resources, an &quot;If-Match: *&quot; header can be
      included with LOCK requests to prevent the server from creating a
      new resource.

      If a LOCK request creates a resource and the client subsequently
      wants to overwrite that resource using a COPY or MOVE request, the
      client should include an &quot;Overwrite: T&quot; header.

      If a LOCK request creates a resource and the client then decides
      to get rid of that resource, a DELETE request is supposed to fail
      on a lock-null resource and UNLOCK should be used instead.  But
      with a locked empty resource, UNLOCK doesn't make the resource
      disappear.  Therefore, the client might have to try both requests
      and ignore an error in one of the two requests.</source>
          <target state="translated">Клиент WebDAV, реализованный в этой спецификации, может найти серверы, которые создают ресурсы с нулевой блокировкой (реализовано до этой спецификации с использованием [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;]), а также серверы, которые создают заблокированные пустые ресурсы. Ответ на запрос LOCK не будет указывать, какой ресурс был создан. Есть несколько методов, которые помогут клиенту справиться с любым типом. Если клиент желает избежать случайного создания либо lock-null, либо пустых заблокированных ресурсов, заголовок &amp;laquo;If-Match: *&amp;raquo; может быть включен в запросы LOCK, чтобы предотвратить создание сервером нового ресурса. Если запрос LOCK создает ресурс, и клиент впоследствии хочет перезаписать этот ресурс с помощью запроса COPY или MOVE, клиент должен включить заголовок &amp;laquo;Overwrite: T&amp;raquo;. Если запрос LOCK создает ресурс, а затем клиент решает избавиться от этого ресурса,предполагается, что запрос DELETE завершится ошибкой для ресурса с нулевой блокировкой, и вместо этого следует использовать UNLOCK. Но с заблокированным пустым ресурсом UNLOCK не приводит к исчезновению ресурса. Следовательно, клиенту, возможно, придется попробовать оба запроса и проигнорировать ошибку в одном из двух запросов.</target>
        </trans-unit>
        <trans-unit id="b9c050a4669d26963f30fbcabf737a5a269d8088" translate="yes" xml:space="preserve">
          <source>A WebDAV-compliant resource is not required to support locking in any
   form.  If the resource does support locking, it may choose to support
   any combination of exclusive and shared locks for any access types.

   The reason for this flexibility is that locking policy strikes to the
   very heart of the resource management and versioning systems employed
   by various storage repositories.  These repositories require control
   over what sort of locking will be made available.  For example, some
   repositories only support shared write locks, while others only
   provide support for exclusive write locks, while yet others use no
   locking at all.  As each system is sufficiently different to merit
   exclusion of certain locking features, this specification leaves
   locking as the sole axis of negotiation within WebDAV.</source>
          <target state="translated">Ресурс,совместимый с WebDAV,не требуется для поддержки блокировки в любой форме.Если ресурс все же поддерживает блокировку,он может выбрать любую комбинацию эксклюзивных и разделяемых блокировок для любых типов доступа.Причина такой гибкости заключается в том,что политика блокировки поражает самое сердце систем управления ресурсами и версиями,используемых в различных репозиториях хранилищ.Эти репозитории требуют контроля над тем,какой тип блокировки будет доступен.Например,некоторые репозитории поддерживают только разделяемые блокировки записи,в то время как другие предоставляют поддержку только эксклюзивных блокировок записи,в то время как другие вообще не используют блокировки.Так как каждая система достаточно отличается от других,чтобы исключить некоторые возможности блокировки,эта спецификация оставляет блокировку в качестве единственной оси переговоров в WebDAV.</target>
        </trans-unit>
        <trans-unit id="38254fe710f16f85c9fd4ff8f8d9fcf247affba8" translate="yes" xml:space="preserve">
          <source>A blank line indicating all meta-information for the request has been sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dffa4d2573a0c29a3cf6a916b1ae983e76a72cd2" translate="yes" xml:space="preserve">
          <source>A blank line indicating all meta-information for the request have been sent.</source>
          <target state="translated">Пустая строка с указанием всей мета-информации для запроса была отправлена.</target>
        </trans-unit>
        <trans-unit id="98ed6d976f0709e14a223063750e838af2371092" translate="yes" xml:space="preserve">
          <source>A boolean that indicates the user agent's preference for reduced data usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f5fbf27da59695f3ff9b3365893efeb5c2ea49" translate="yes" xml:space="preserve">
          <source>A brief description of the changes between the early versions of HTTP, to the modern HTTP/2 and beyond.</source>
          <target state="translated">Краткое описание изменений между ранними версиями HTTP,к современному HTTP/2 и далее.</target>
        </trans-unit>
        <trans-unit id="39fb3ea12550138a780b56267e0eeca6a0faf155" translate="yes" xml:space="preserve">
          <source>A brief description of the changes between the early versions of HTTP, to the modern HTTP/2, the emergent HTTP/3 and beyond.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd6e33516e3b56de33ea030077bb00ea0ddc4642" translate="yes" xml:space="preserve">
          <source>A brief introduction of the notion of resources, identifiers, and locations on the Web.</source>
          <target state="translated">Краткое введение в понятие ресурсов,идентификаторов и местоположений в Сети.</target>
        </trans-unit>
        <trans-unit id="2eb51aaae5e24e4201d71c51102766328e241d9e" translate="yes" xml:space="preserve">
          <source>A brief introduction to the concept of resources, identifiers, and locations on the web.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b11a72f1dd5ff054b32769e00fdf5e574c1d4a" translate="yes" xml:space="preserve">
          <source>A cache MUST NOT store a response to any request, unless:

   o  The request method is understood by the cache and defined as being
      cacheable, and

   o  the response status code is understood by the cache, and

   o  the &quot;no-store&quot; cache directive (see &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;) does not appear
      in request or response header fields, and

   o  the &quot;private&quot; response directive (see &lt;a href=&quot;#section-5.2.2.6&quot;&gt;Section 5.2.2.6&lt;/a&gt;) does not
      appear in the response, if the cache is shared, and

   o  the Authorization header field (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7235]&lt;/a&gt;) does
      not appear in the request, if the cache is shared, unless the
      response explicitly allows it (see &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;), and

   o  the response either:

      *  contains an Expires header field (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;), or

      *  contains a max-age response directive (see &lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt;), or

      *  contains a s-maxage response directive (see &lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;)
         and the cache is shared, or

      *  contains a Cache Control Extension (see &lt;a href=&quot;#section-5.2.3&quot;&gt;Section 5.2.3&lt;/a&gt;) that
         allows it to be cached, or

      *  has a status code that is defined as cacheable by default (see
         &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;), or 

      *  contains a public response directive (see &lt;a href=&quot;#section-5.2.2.5&quot;&gt;Section 5.2.2.5&lt;/a&gt;).

   Note that any of the requirements listed above can be overridden by a
   cache-control extension; see &lt;a href=&quot;#section-5.2.3&quot;&gt;Section 5.2.3&lt;/a&gt;.

   In this context, a cache has &quot;understood&quot; a request method or a
   response status code if it recognizes it and implements all specified
   caching-related behavior.

   Note that, in normal operation, some caches will not store a response
   that has neither a cache validator nor an explicit expiration time,
   as such responses are not usually useful to store.  However, caches
   are not prohibited from storing such responses.</source>
          <target state="translated">Кэш НЕ ДОЛЖЕН хранить ответ на любой запрос, кроме случаев, когда: o метод запроса понимается кешем и определяется как кэшируемый; o код состояния ответа понимается кешем; o директива кэша &quot;no-store&quot; (см. &lt;a href=&quot;#section-5.2&quot;&gt;Раздел 5.2&lt;/a&gt; ) не отображается в полях заголовка запроса или ответа, а также o директива ответа &amp;laquo;private&amp;raquo; (см. &lt;a href=&quot;#section-5.2.2.6&quot;&gt;Раздел 5.2.2.6&lt;/a&gt; ) не появляется в ответе, если кэш является общим, и o поле заголовка авторизации ( см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;раздел 4.2 [RFC7235]&lt;/a&gt; ) не отображается в запросе, если кеш является общим, если только ответ явно не разрешает это (см. &lt;a href=&quot;#section-3.2&quot;&gt;раздел 3.2&lt;/a&gt; ), и o ответ либо:* содержит поле заголовка Expires (см.&lt;a href=&quot;#section-5.3&quot;&gt;Раздел 5.3&lt;/a&gt; ), или * содержит директиву ответа max-age (см. &lt;a href=&quot;#section-5.2.2.8&quot;&gt;Раздел 5.2.2.8&lt;/a&gt; ), или * содержит директиву ответа s-maxage (см. &lt;a href=&quot;#section-5.2.2.9&quot;&gt;Раздел 5.2.2.9&lt;/a&gt; ), и кеш является общим, или * содержит расширение управления кешем (см. &lt;a href=&quot;#section-5.2.3&quot;&gt;Раздел 5.2.3&lt;/a&gt; ), который позволяет его кэшировать, или * имеет код состояния, который по умолчанию определен как кэшируемый (см. &lt;a href=&quot;#section-4.2.2&quot;&gt;Раздел 4.2.2&lt;/a&gt; ), или * содержит директиву публичного ответа (см. &lt;a href=&quot;#section-5.2.2.5&quot;&gt;Раздел 5.2.2.5&lt;/a&gt; ). Обратите внимание, что любое из перечисленных выше требований может быть отменено расширением управления кешем; см. &lt;a href=&quot;#section-5.2.3&quot;&gt;раздел 5.2.3&lt;/a&gt;, В этом контексте кэш &amp;laquo;понял&amp;raquo; метод запроса или код состояния ответа, если он распознал его и реализует все указанное поведение, связанное с кэшированием. Обратите внимание, что при нормальной работе некоторые кеши не будут хранить ответ, который не имеет ни валидатора кеша, ни явного срока действия, поскольку такие ответы обычно нецелесообразно хранить. Однако кэшам не запрещено хранить такие ответы.</target>
        </trans-unit>
        <trans-unit id="afcd457e5449ea96b9730d7945fa792f97c22645" translate="yes" xml:space="preserve">
          <source>A cache SHOULD generate this if it heuristically chose a freshness
   lifetime greater than 24 hours and the response's age is greater than
   24 hours.</source>
          <target state="translated">Кэш ДОЛЖЕН генерировать это,если он эвристически выбрал срок жизни свежести больше 24 часов,а возраст ответа больше 24 часов.</target>
        </trans-unit>
        <trans-unit id="f6168c09c8c7fd95195aaf7adbff37d6acd9b77a" translate="yes" xml:space="preserve">
          <source>A cache SHOULD generate this if it is intentionally disconnected from
   the rest of the network for a period of time.</source>
          <target state="translated">Кэш SHOULD генерирует его,если он намеренно отключен от остальной сети на некоторое время.</target>
        </trans-unit>
        <trans-unit id="5d58c7fee0ffec3747d196ae22d87f92a88b3159" translate="yes" xml:space="preserve">
          <source>A cache SHOULD generate this when sending a stale response because an
   attempt to validate the response failed, due to an inability to reach
   the server.</source>
          <target state="translated">Кэш-память SHOULD генерирует это при отправке несвежего ответа,так как попытка проверки ответа не удалась из-за невозможности дозвониться до сервера.</target>
        </trans-unit>
        <trans-unit id="9dedbe9ca421577a1ae13ea9af987a4dc03874f1" translate="yes" xml:space="preserve">
          <source>A cache SHOULD generate this whenever the sent response is stale.</source>
          <target state="translated">Кэш-память ДОЛЖНА сгенерировать его всякий раз,когда отправленный ответ затвердевает.</target>
        </trans-unit>
        <trans-unit id="3d66f1b37c3af5067fb436a94514119f41081f5c" translate="yes" xml:space="preserve">
          <source>A cache can calculate the freshness lifetime (denoted as
   freshness_lifetime) of a response by using the first match of the
   following:

   o  If the cache is shared and the s-maxage response directive
      (&lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;) is present, use its value, or

   o  If the max-age response directive (&lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt;) is present,
      use its value, or

   o  If the Expires response header field (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) is present, use
      its value minus the value of the Date response header field, or

   o  Otherwise, no explicit expiration time is present in the response.
      A heuristic freshness lifetime might be applicable; see
      &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;.

   Note that this calculation is not vulnerable to clock skew, since all
   of the information comes from the origin server. 

   When there is more than one value present for a given directive
   (e.g., two Expires header fields, multiple Cache-Control: max-age
   directives), the directive's value is considered invalid.  Caches are
   encouraged to consider responses that have invalid freshness
   information to be stale.</source>
          <target state="translated">Кэш может вычислить время жизни свежести (обозначается как freshness_lifetime) ответа, используя первое совпадение из следующего: o Если кеш является общим и присутствует директива ответа s-maxage ( &lt;a href=&quot;#section-5.2.2.9&quot;&gt;раздел 5.2.2.9&lt;/a&gt; ), используйте ее значение, или o Если присутствует директива ответа max-age ( &lt;a href=&quot;#section-5.2.2.8&quot;&gt;раздел 5.2.2.8&lt;/a&gt; ), используйте его значение, или o если присутствует поле заголовка ответа Expires ( &lt;a href=&quot;#section-5.3&quot;&gt;раздел 5.3&lt;/a&gt; ), используйте его значение минус значение поля заголовка ответа Date, или o В противном случае в ответе не указано явное время истечения срока действия. Может быть применимо эвристическое время жизни свежести; см. &lt;a href=&quot;#section-4.2.2&quot;&gt;раздел 4.2.2&lt;/a&gt;, Обратите внимание, что этот расчет не подвержен перекосу часов, поскольку вся информация поступает с исходного сервера. Если для данной директивы присутствует более одного значения (например, два поля заголовка Expires, несколько директив Cache-Control: max-age), значение директивы считается недопустимым. Кэшам рекомендуется рассматривать ответы с недопустимой информацией о актуальности как устаревшие.</target>
        </trans-unit>
        <trans-unit id="ffb1f6da1ee8afd1a7b46e415ab53e9563e80045" translate="yes" xml:space="preserve">
          <source>A cache entry might also consist of multiple stored responses differentiated by a secondary key, if the request is target of content negotiation. For more details see the information about the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header &lt;a href=&quot;#Varying_responses&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Запись кэша может также состоять из нескольких сохраненных ответов, различаемых вторичным ключом, если запрос является целью согласования содержимого. Подробнее см. Информацию о заголовке &lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#Varying_responses&quot;&gt; ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5972d7cea05a00533e908dec31b26470e29e3357" translate="yes" xml:space="preserve">
          <source>A cache that receives an incomplete response (for example, with fewer
   bytes of data than specified in a Content-Length header) MAY store
   the response. However, the cache MUST treat this as a partial
   response. Partial responses MAY be combined as described in &lt;a href=&quot;#section-13.5.4&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt;; the result might be a full response or might still be
   partial. A cache MUST NOT return a partial response to a client
   without explicitly marking it as such, using the 206 (Partial
   Content) status code. A cache MUST NOT return a partial response
   using a status code of 200 (OK).

   If a cache receives a 5xx response while attempting to revalidate an
   entry, it MAY either forward this response to the requesting client,
   or act as if the server failed to respond. In the latter case, it MAY
   return a previously received response unless the cached entry
   includes the &quot;must-revalidate&quot; cache-control directive (see &lt;a href=&quot;#section-14.9&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;).</source>
          <target state="translated">Кэш, который получает неполный ответ (например, с меньшим количеством байтов данных, чем указано в заголовке Content-Length), МОЖЕТ сохранить ответ. Однако кэш ДОЛЖЕН рассматривать это как частичный ответ. Частичные ответы МОГУТ быть объединены, как описано в &lt;a href=&quot;#section-13.5.4&quot;&gt;разделе &lt;/a&gt;&lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4.&lt;/a&gt;; результат может быть полным или частичным. Кэш НЕ ДОЛЖЕН возвращать частичный ответ клиенту без явной пометки его как такового с использованием кода состояния 206 (частичное содержимое). Кэш НЕ ДОЛЖЕН возвращать частичный ответ с кодом состояния 200 (ОК). Если кэш получает ответ 5xx при попытке повторно подтвердить запись, он МОЖЕТ либо переслать этот ответ запрашивающему клиенту, либо действовать так, как если бы сервер не ответил. В последнем случае он МОЖЕТ вернуть ранее полученный ответ, если только кэшированная запись не содержит директиву управления кешем &quot;must-revalidate&quot; (см. &lt;a href=&quot;#section-14.9&quot;&gt;Раздел &lt;/a&gt;&lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a72a187927140b084c50b2a86bb3cae9c1129d9d" translate="yes" xml:space="preserve">
          <source>A cache will send the request to the origin server for validation before releasing a cached copy.</source>
          <target state="translated">Кэш отправит запрос на исходный сервер для проверки перед выпуском кэшированной копии.</target>
        </trans-unit>
        <trans-unit id="92c597b13172b0ae1b9fec4cca7c94c8d5002a48" translate="yes" xml:space="preserve">
          <source>A character encoding name, like &lt;code&gt;utf-8&lt;/code&gt; or &lt;code&gt;iso-8859-15.&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef7762a0337a8349674180425bb13270b132201a" translate="yes" xml:space="preserve">
          <source>A character set like &lt;code&gt;utf-8&lt;/code&gt; or &lt;code&gt;iso-8859-15.&lt;/code&gt;</source>
          <target state="translated">Набор символов, например &lt;code&gt;utf-8&lt;/code&gt; или &lt;code&gt;iso-8859-15.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a46fba5aafbe140d23668fd13707246dc167e60e" translate="yes" xml:space="preserve">
          <source>A class 1 compliant resource MUST meet all &quot;MUST&quot; requirements in all
   sections of this document.

   Class 1 compliant resources MUST return, at minimum, the value &quot;1&quot; in
   the DAV header on all responses to the OPTIONS method.</source>
          <target state="translated">Ресурс,соответствующий классу 1 ДОЛЖЕН отвечать всем требованиям &quot;ДОЛЖЕН&quot; во всех разделах данного документа.Ресурсы,соответствующие классу 1 ДОЛЖНЫ возвращать,как минимум,значение &quot;1&quot; в заголовке DAV для всех ответов на метод OPTIONS.</target>
        </trans-unit>
        <trans-unit id="f09ae974e30d6d65603cbcb265f3f767e63d4b38" translate="yes" xml:space="preserve">
          <source>A class 2 compliant resource MUST meet all class 1 requirements and
   support the LOCK method, the DAV:supportedlock property, the DAV:
   lockdiscovery property, the Time-Out response header and the Lock-
   Token request header.  A class 2 compliant resource SHOULD also
   support the Timeout request header and the 'owner' XML element.

   Class 2 compliant resources MUST return, at minimum, the values &quot;1&quot;
   and &quot;2&quot; in the DAV header on all responses to the OPTIONS method.</source>
          <target state="translated">Ресурс,соответствующий классу 2 ДОЛЖЕН отвечать всем требованиям класса 1 и поддерживать метод LOCK,свойство DAV:supportedlock,свойство DAV:lock-discovery,заголовок ответа Time-Out и заголовок запроса Lock-Token.Ресурс,соответствующий классу 2 ДОЛЖЕН также поддерживать заголовок запроса Timeout и XML элемент 'owner'.Ресурсы класса 2 ДОЛЖНЫ возвращать,как минимум,значения &quot;1&quot; и &quot;2&quot; в заголовке DAV на все ответы на метод OPTIONS.</target>
        </trans-unit>
        <trans-unit id="c8a24609de1da03e233355a5b214ad825afc020e" translate="yes" xml:space="preserve">
          <source>A client MUST NOT submit the same write lock request twice.  Note
   that a client is always aware it is resubmitting the same lock
   request because it must include the lock token in the If header in
   order to make the request for a resource that is already locked.

   However, a client may submit a LOCK request with an If header but
   without a body.  A server receiving a LOCK request with no body MUST
   NOT create a new lock -- this form of the LOCK request is only to be
   used to &quot;refresh&quot; an existing lock (meaning, at minimum, that any
   timers associated with the lock MUST be reset).

   Clients may submit Timeout headers of arbitrary value with their lock
   refresh requests.  Servers, as always, may ignore Timeout headers
   submitted by the client, and a server MAY refresh a lock with a
   timeout period that is different than the previous timeout period
   used for the lock, provided it advertises the new value in the LOCK
   refresh response.

   If an error is received in response to a refresh LOCK request, the
   client MUST NOT assume that the lock was refreshed.</source>
          <target state="translated">Клиент НЕ ДОЛЖЕН подавать один и тот же запрос на блокировку записи дважды.Обратите внимание,что клиент всегда знает,что он повторно отправляет один и тот же запрос блокировки,потому что он должен включить маркер блокировки в заголовок If,чтобы сделать запрос на ресурс,который уже заблокирован.Однако,клиент может подать запрос на блокировку с заголовком If,но без тела.Сервер,получающий запрос на БЛОКИРОВКУ без тела,НЕ ДОЛЖЕН создавать новую блокировку-эта форма запроса на БЛОКИРОВКУ должна использоваться только для &quot;обновления&quot; существующей блокировки (что означает,как минимум,что любые таймеры,связанные с блокировкой,ДОЛЖНЫ быть сброшены).Клиенты могут подавать заголовки таймаута произвольного значения со своими запросами на обновление блокировки.Серверы,как всегда,могут игнорировать заголовки таймаута,поданные клиентом,и сервер ДОЛЖЕН обновлять блокировку с периодом таймаута,отличным от предыдущего периода таймаута,используемого для блокировки,при условии,что он рекламирует новое значение в ответе LOCK refresh.Если в ответ на запрос на обновление БЛОКИРОВКИ получена ошибка,клиент НЕ ДОЛЖЕН считать,что замок был обновлен.</target>
        </trans-unit>
        <trans-unit id="7d982f3df26faad33edb44e7ec5819638eb4f0b9" translate="yes" xml:space="preserve">
          <source>A client can POST Media Resources as well as Entry Resources to a
   Collection.  If a server accepts such a request, then it MUST create
   two new Resources -- one that corresponds to the entity sent in the
   request, called the Media Resource, and an associated Member Entry,
   called the Media Link Entry.  Media Link Entries are represented as
   Atom Entries, and appear in the Collection.

   The Media Link Entry contains the metadata and IRI of the (perhaps
   non-textual) Media Resource.  The Media Link Entry thus makes the
   metadata about the Media Resource separately available for retrieval
   and alteration.

   The server can signal the media types it will accept using the app:
   accept element in the Service Document, as specified in &lt;a href=&quot;#section-8.3.4&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-8.3.4&quot;&gt;8.3.4&lt;/a&gt;.

   Successful responses to creation requests MUST include the URI of the
   Media Link Entry in the Location header.  The Media Link Entry SHOULD
   contain an atom:link element with a link relation of &quot;edit-media&quot;
   that contains the Media Resource IRI.  The Media Link Entry MUST have
   an atom:content element with a &quot;src&quot; attribute.  The value of the
   &quot;src&quot; attribute is an IRI for the newly created Media Resource.  It
   is OPTIONAL that the IRI of the &quot;src&quot; attribute on the atom:content
   element be the same as the Media Resource IRI.  For example, the
   &quot;src&quot; attribute value might instead be a link into a static cache or
   content distribution network and not the Media Resource IRI.

   Implementers are asked to note that [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] specifies that Atom
   Entries MUST contain an atom:summary element.  Thus, upon successful
   creation of a Media Link Entry, a server MAY choose to populate the
   atom:summary element (as well as any other mandatory elements such as
   atom:id, atom:author, and atom:title) with content derived from the
   POSTed entity or from any other source.  A server might not allow a
   client to modify the server-selected values for these elements.

   For Resource creation, this specification only defines cases where
   the POST body has an Atom Entry entity declared as an Atom media type
   (&quot;application/atom+xml&quot;), or a non-Atom entity declared as a non-Atom
   media type.  When a client is POSTing an Atom Entry to a Collection,
   it may use a media type of either &quot;application/atom+xml&quot; or
   &quot;application/atom +xml;type=entry&quot;.  This specification does not
   specify any request semantics or server behavior in the case where
   the POSTed media type is &quot;application/atom+xml&quot; but the body is
   something other than an Atom Entry.  In particular, what happens on
   POSTing an Atom Feed Document to a Collection using the &quot;application/
   atom+xml&quot; media type is undefined. 

   The Atom Protocol does not specify a means to create multiple
   representations of the same Resource (for example, a PNG and a JPG of
   the same image) either on creation or editing.</source>
          <target state="translated">Клиент может отправлять медиаресурсы POST, а также входные ресурсы в коллекцию. Если сервер принимает такой запрос, он ДОЛЖЕН создать два новых ресурса - один, который соответствует объекту, отправленному в запросе, называемый медиаресурсом, и связанный элемент записи, называемый входом медиа-ссылки. Записи медиа-ссылок представлены как записи Atom и отображаются в коллекции. Запись Media Link содержит метаданные и IRI (возможно, нетекстового) медиаресурса. Таким образом, запись Media Link делает метаданные о медиаресурсе отдельно доступными для поиска и изменения. Сервер может сигнализировать о типах мультимедиа, которые он примет, с помощью элемента app: accept в служебном документе, как указано в &lt;a href=&quot;#section-8.3.4&quot;&gt;Разделе &lt;/a&gt;&lt;a href=&quot;#section-8.3.4&quot;&gt;8.3.4.&lt;/a&gt;, Успешные ответы на запросы создания ДОЛЖНЫ включать URI записи Media Link в заголовке Location. Запись Media Link ДОЛЖНА содержать элемент atom: link с отношением ссылки &quot;edit-media&quot;, который содержит IRI медиаресурса. Запись Media Link ДОЛЖНА иметь элемент atom: content с атрибутом src. Значение атрибута &amp;laquo;src&amp;raquo; - это IRI для вновь созданного медиаресурса. НЕОБЯЗАТЕЛЬНО, чтобы IRI атрибута &quot;src&quot; в элементе atom: content был таким же, как IRI медиаресурса. Например, значение атрибута &amp;laquo;src&amp;raquo; может вместо этого быть ссылкой на статический кэш или сеть распространения контента, а не на IRI медиаресурса. Разработчикам предлагается принять к сведению, что [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] указывает, что записи Atom ДОЛЖНЫ содержать элемент atom: summary. Таким образом, после успешного создания записи медиа-ссылки сервер МОЖЕТ выбрать заполнение элемента atom: summary (а также любых других обязательных элементов, таких как atom: id, atom: author и atom: title) содержимым, полученным из POSTed объект или из любого другого источника. Сервер может не разрешать клиенту изменять выбранные сервером значения для этих элементов. Для создания ресурса эта спецификация определяет только случаи, когда в теле POST есть объект Atom Entry, объявленный как тип мультимедиа Atom (&quot;application / atom + xml&quot;), или объект, не являющийся объектом Atom, объявленный как тип мультимедиа, отличный от Atom. Когда клиент отправляет запись Atom в коллекцию, он может использовать тип мультимедиа либо &amp;laquo;application / atom + xml&amp;raquo;, либо &amp;laquo;application / atom + xml&amp;raquo;;type = entry &quot;. Эта спецификация не определяет какую-либо семантику запроса или поведение сервера в случае, когда типом мультимедиа POSTed является&quot; application / atom + xml &quot;, но тело представляет собой нечто иное, чем запись Atom. В частности, что происходит при POSTing документ Atom Feed в коллекцию с использованием типа носителя &quot;application / atom + xml&quot; не определен. Протокол Atom не определяет средства для создания нескольких представлений одного и того же ресурса (например, PNG и JPG одного и того же изображения ) либо при создании, либо при редактировании.что происходит при размещении документа Atom Feed в Коллекцию с использованием типа носителя &amp;laquo;application / atom + xml&amp;raquo;, не определено. Протокол Atom не определяет средства для создания нескольких представлений одного и того же ресурса (например, PNG и JPG одного и того же изображения) ни при создании, ни при редактировании.что происходит при размещении документа Atom Feed в Коллекцию с использованием типа носителя &amp;laquo;application / atom + xml&amp;raquo;, не определено. Протокол Atom не определяет средства для создания нескольких представлений одного и того же ресурса (например, PNG и JPG одного и того же изображения) ни при создании, ни при редактировании.</target>
        </trans-unit>
        <trans-unit id="7e5c63dbdb2f7786ab98990dffa15132b1ea80a1" translate="yes" xml:space="preserve">
          <source>A client can assign a priority for a new stream by including
   prioritization information in the HEADERS frame (&lt;a href=&quot;#section-6.2&quot;&gt;Section 6.2&lt;/a&gt;) that
   opens the stream.  At any other time, the PRIORITY frame
   (&lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;) can be used to change the priority of a stream.

   The purpose of prioritization is to allow an endpoint to express how
   it would prefer its peer to allocate resources when managing
   concurrent streams.  Most importantly, priority can be used to select
   streams for transmitting frames when there is limited capacity for
   sending.

   Streams can be prioritized by marking them as dependent on the
   completion of other streams (&lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;).  Each dependency is
   assigned a relative weight, a number that is used to determine the
   relative proportion of available resources that are assigned to
   streams dependent on the same stream. 

   Explicitly setting the priority for a stream is input to a
   prioritization process.  It does not guarantee any particular
   processing or transmission order for the stream relative to any other
   stream.  An endpoint cannot force a peer to process concurrent
   streams in a particular order using priority.  Expressing priority is
   therefore only a suggestion.

   Prioritization information can be omitted from messages.  Defaults
   are used prior to any explicit values being provided (&lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b701e8884cdcbec201923a5462b4446bf15619" translate="yes" xml:space="preserve">
          <source>A client can express the desired push policy for a request by sending an &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ruellan-http-accept-push-policy-00#section-3.1&quot;&gt;Accept-Push-Policy&lt;/a&gt;&lt;/code&gt; header field in the request.</source>
          <target state="translated">Клиент может выразить желаемую политику push-уведомлений для запроса, отправив в запросе поле заголовка &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ruellan-http-accept-push-policy-00#section-3.1&quot;&gt;Accept-Push-Policy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="158968deede144dac0a0fb8c225610ac022fddfc" translate="yes" xml:space="preserve">
          <source>A client can learn that a particular server supports HTTP/2 by other
   means.  For example, [&lt;a href=&quot;#ref-ALT-SVC&quot;&gt;ALT-SVC&lt;/a&gt;] describes a mechanism for advertising
   this capability.

   A client MUST send the connection preface (&lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt;) and then MAY
   immediately send HTTP/2 frames to such a server; servers can identify
   these connections by the presence of the connection preface.  This 

   only affects the establishment of HTTP/2 connections over cleartext
   TCP; implementations that support HTTP/2 over TLS MUST use protocol
   negotiation in TLS [&lt;a href=&quot;#ref-TLS-ALPN&quot;&gt;TLS-ALPN&lt;/a&gt;].

   Likewise, the server MUST send a connection preface (&lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt;).

   Without additional information, prior support for HTTP/2 is not a
   strong signal that a given server will support HTTP/2 for future
   connections.  For example, it is possible for server configurations
   to change, for configurations to differ between instances in
   clustered servers, or for network conditions to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf460d7009baa0cf38dad3c06caeb746522b55c" translate="yes" xml:space="preserve">
          <source>A client can send the &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.7&quot;&gt;Accept-Signature&lt;/a&gt;&lt;/code&gt; header field to indicate intention to take advantage of any available signatures and to indicate what kinds of signatures it supports.</source>
          <target state="translated">Клиент может отправить поле заголовка &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.7&quot;&gt;Accept-Signature&lt;/a&gt;&lt;/code&gt; , чтобы указать намерение использовать любые доступные подписи и указать, какие типы подписей он поддерживает.</target>
        </trans-unit>
        <trans-unit id="80a4adc81ca6f443765ed44b189dadef0d1bac96" translate="yes" xml:space="preserve">
          <source>A client ought to limit the number of simultaneous open connections
   that it maintains to a given server.

   Previous revisions of HTTP gave a specific number of connections as a
   ceiling, but this was found to be impractical for many applications.
   As a result, this specification does not mandate a particular maximum
   number of connections but, instead, encourages clients to be
   conservative when opening multiple connections.

   Multiple connections are typically used to avoid the &quot;head-of-line
   blocking&quot; problem, wherein a request that takes significant
   server-side processing and/or has a large payload blocks subsequent
   requests on the same connection.  However, each connection consumes
   server resources.  Furthermore, using multiple connections can cause
   undesirable side effects in congested networks.

   Note that a server might reject traffic that it deems abusive or
   characteristic of a denial-of-service attack, such as an excessive
   number of open connections from a single client.</source>
          <target state="translated">Клиент должен ограничить количество одновременно открытых соединений,которые он поддерживает с данным сервером.Предыдущие версии HTTP давали определенное количество соединений в качестве потолка,но это было признано непрактичным для многих приложений.В результате,эта спецификация не предписывает определенное максимальное количество соединений,а вместо этого поощряет клиентов быть консервативными при открытии нескольких соединений.Многочисленные соединения,как правило,используются для избежания проблемы &quot;блокировки головной линии&quot;,когда запрос,требующий значительной обработки на стороне сервера и/или имеющий большую полезную нагрузку,блокирует последующие запросы по тому же самому соединению.Однако каждое соединение потребляет ресурсы сервера.Более того,использование нескольких соединений может вызвать нежелательные побочные эффекты в перегруженных сетях.Обратите внимание,что сервер может отклонить трафик,который он считает оскорбительным или характерным для атак типа &quot;отказ в обслуживании&quot;,например,чрезмерное количество открытых соединений с одного клиента.</target>
        </trans-unit>
        <trans-unit id="8c4361d2d7548ea6bc70d98eca9d420ed02557e9" translate="yes" xml:space="preserve">
          <source>A client requests signals to the server that it supports the upgrade mechanisms of &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Клиент запрашивает сигналы серверу о том, что он поддерживает механизмы &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt; для обновления-небезопасных-запросов :</target>
        </trans-unit>
        <trans-unit id="d5dc81872963bb2874b6966923a2cab55617f3ce" translate="yes" xml:space="preserve">
          <source>A client sends a request with a Expect header and waits for the server to respond before sending the message body.</source>
          <target state="translated">Клиент посылает запрос с заголовком Expect и ждет ответа сервера,прежде чем отправить тело сообщения.</target>
        </trans-unit>
        <trans-unit id="3c772b2037eba42a257f31dd19bdf0b51277103f" translate="yes" xml:space="preserve">
          <source>A client sends an HTTP request on a new stream, using a previously
   unused stream identifier (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;).  A server sends an HTTP
   response on the same stream as the request.

   An HTTP message (request or response) consists of:

   1.  for a response only, zero or more HEADERS frames (each followed
       by zero or more CONTINUATION frames) containing the message
       headers of informational (1xx) HTTP responses (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230],
       Section&amp;nbsp;3.2&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.2&quot;&gt;[RFC7231], Section&amp;nbsp;6.2&lt;/a&gt;),

   2.  one HEADERS frame (followed by zero or more CONTINUATION frames)
       containing the message headers (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;),

   3.  zero or more DATA frames containing the payload body (see
       &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.3&lt;/a&gt;), and

   4.  optionally, one HEADERS frame, followed by zero or more
       CONTINUATION frames containing the trailer-part, if present (see
       &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1.2&quot;&gt;[RFC7230], Section&amp;nbsp;4.1.2&lt;/a&gt;).

   The last frame in the sequence bears an END_STREAM flag, noting that
   a HEADERS frame bearing the END_STREAM flag can be followed by
   CONTINUATION frames that carry any remaining portions of the header
   block.

   Other frames (from any stream) MUST NOT occur between the HEADERS
   frame and any CONTINUATION frames that might follow.

   HTTP/2 uses DATA frames to carry message payloads.  The &quot;chunked&quot;
   transfer encoding defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7230]&lt;/a&gt; MUST NOT be
   used in HTTP/2.

   Trailing header fields are carried in a header block that also
   terminates the stream.  Such a header block is a sequence starting
   with a HEADERS frame, followed by zero or more CONTINUATION frames,
   where the HEADERS frame bears an END_STREAM flag.  Header blocks
   after the first that do not terminate the stream are not part of an
   HTTP request or response. 

   A HEADERS frame (and associated CONTINUATION frames) can only appear
   at the start or end of a stream.  An endpoint that receives a HEADERS
   frame without the END_STREAM flag set after receiving a final (non-
   informational) status code MUST treat the corresponding request or
   response as malformed (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).

   An HTTP request/response exchange fully consumes a single stream.  A
   request starts with the HEADERS frame that puts the stream into an
   &quot;open&quot; state.  The request ends with a frame bearing END_STREAM,
   which causes the stream to become &quot;half-closed (local)&quot; for the
   client and &quot;half-closed (remote)&quot; for the server.  A response starts
   with a HEADERS frame and ends with a frame bearing END_STREAM, which
   places the stream in the &quot;closed&quot; state.

   An HTTP response is complete after the server sends -- or the client
   receives -- a frame with the END_STREAM flag set (including any
   CONTINUATION frames needed to complete a header block).  A server can
   send a complete response prior to the client sending an entire
   request if the response does not depend on any portion of the request
   that has not been sent and received.  When this is true, a server MAY
   request that the client abort transmission of a request without error
   by sending a RST_STREAM with an error code of NO_ERROR after sending
   a complete response (i.e., a frame with the END_STREAM flag).
   Clients MUST NOT discard responses as a result of receiving such a
   RST_STREAM, though clients can always discard responses at their
   discretion for other reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637640a6ac566c746cfe3512f687ebb242d9b708" translate="yes" xml:space="preserve">
          <source>A client sends request header fields to provide more information
   about the request context, make the request conditional based on the
   target resource state, suggest preferred formats for the response,
   supply authentication credentials, or modify the expected request
   processing.  These fields act as request modifiers, similar to the
   parameters on a programming language method invocation.</source>
          <target state="translated">Клиент посылает поля заголовка запроса,чтобы предоставить больше информации о контексте запроса,сделать запрос условным,основываясь на состоянии целевого ресурса,предложить предпочтительные форматы ответа,предоставить аутентификационные данные или изменить обработку ожидаемого запроса.Эти поля выступают в качестве модификаторов запроса,подобно параметрам вызова метода на языке программирования.</target>
        </trans-unit>
        <trans-unit id="e0dfb61cf763ec1db31697625b14173ab1816338" translate="yes" xml:space="preserve">
          <source>A client that makes a request for an &quot;http&quot; URI without prior
   knowledge about support for HTTP/2 on the next hop uses the HTTP
   Upgrade mechanism (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Section&amp;nbsp;6.7 of [RFC7230]&lt;/a&gt;).  The client does so by
   making an HTTP/1.1 request that includes an Upgrade header field with
   the &quot;h2c&quot; token.  Such an HTTP/1.1 request MUST include exactly one
   HTTP2-Settings (&lt;a href=&quot;#section-3.2.1&quot;&gt;Section 3.2.1&lt;/a&gt;) header field.

   For example:

     GET / HTTP/1.1
     Host: server.example.com
     Connection: Upgrade, HTTP2-Settings
     Upgrade: h2c
     HTTP2-Settings: &amp;lt;base64url encoding of HTTP/2 SETTINGS payload&amp;gt;

   Requests that contain a payload body MUST be sent in their entirety
   before the client can send HTTP/2 frames.  This means that a large
   request can block the use of the connection until it is completely
   sent.

   If concurrency of an initial request with subsequent requests is
   important, an OPTIONS request can be used to perform the upgrade to
   HTTP/2, at the cost of an additional round trip. 

   A server that does not support HTTP/2 can respond to the request as
   though the Upgrade header field were absent:

     HTTP/1.1 200 OK
     Content-Length: 243
     Content-Type: text/html

     

   A server MUST ignore an &quot;h2&quot; token in an Upgrade header field.
   Presence of a token with &quot;h2&quot; implies HTTP/2 over TLS, which is
   instead negotiated as described in &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;.

   A server that supports HTTP/2 accepts the upgrade with a 101
   (Switching Protocols) response.  After the empty line that terminates
   the 101 response, the server can begin sending HTTP/2 frames.  These
   frames MUST include a response to the request that initiated the
   upgrade.

   For example:

     HTTP/1.1 101 Switching Protocols
     Connection: Upgrade
     Upgrade: h2c

     [ HTTP/2 connection 

   The first HTTP/2 frame sent by the server MUST be a server connection
   preface (&lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt;) consisting of a SETTINGS frame (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;).
   Upon receiving the 101 response, the client MUST send a connection
   preface (&lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt;), which includes a SETTINGS frame.

   The HTTP/1.1 request that is sent prior to upgrade is assigned a
   stream identifier of 1 (see &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;) with default priority
   values (&lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt;).  Stream 1 is implicitly &quot;half-closed&quot; from
   the client toward the server (see &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;), since the request is
   completed as an HTTP/1.1 request.  After commencing the HTTP/2
   connection, stream 1 is used for the response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e7d76a2766c403c7c4fb05311e3908c0f23363" translate="yes" xml:space="preserve">
          <source>A client that makes a request to an &quot;https&quot; URI uses TLS [&lt;a href=&quot;#ref-TLS12&quot;&gt;TLS12&lt;/a&gt;] with
   the application-layer protocol negotiation (ALPN) extension
   [&lt;a href=&quot;#ref-TLS-ALPN&quot;&gt;TLS-ALPN&lt;/a&gt;].

   HTTP/2 over TLS uses the &quot;h2&quot; protocol identifier.  The &quot;h2c&quot;
   protocol identifier MUST NOT be sent by a client or selected by a
   server; the &quot;h2c&quot; protocol identifier describes a protocol that does
   not use TLS.

   Once TLS negotiation is complete, both the client and the server MUST
   send a connection preface (&lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed66d390cb72517711831274a3a7d112673c59ff" translate="yes" xml:space="preserve">
          <source>A client that supports persistent connections MAY &quot;pipeline&quot; its
   requests (i.e., send multiple requests without waiting for each
   response).  A server MAY process a sequence of pipelined requests in
   parallel if they all have safe methods (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7231]&lt;/a&gt;),
   but it MUST send the corresponding responses in the same order that
   the requests were received.

   A client that pipelines requests SHOULD retry unanswered requests if
   the connection closes before it receives all of the corresponding
   responses.  When retrying pipelined requests after a failed
   connection (a connection not explicitly closed by the server in its
   last complete response), a client MUST NOT pipeline immediately after
   connection establishment, since the first remaining request in the
   prior pipeline might have caused an error response that can be lost
   again if multiple requests are sent on a prematurely closed
   connection (see the TCP reset problem described in &lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;).

   Idempotent methods (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7231]&lt;/a&gt;) are significant to
   pipelining because they can be automatically retried after a
   connection failure.  A user agent SHOULD NOT pipeline requests after
   a non-idempotent method, until the final response status code for
   that method has been received, unless the user agent has a means to
   detect and recover from partial failure conditions involving the
   pipelined sequence. 

   An intermediary that receives pipelined requests MAY pipeline those
   requests when forwarding them inbound, since it can rely on the
   outbound user agent(s) to determine what requests can be safely
   pipelined.  If the inbound connection fails before receiving a
   response, the pipelining intermediary MAY attempt to retry a sequence
   of requests that have yet to receive a response if the requests all
   have idempotent methods; otherwise, the pipelining intermediary
   SHOULD forward any received responses and then close the
   corresponding outbound connection(s) so that the outbound user
   agent(s) can recover accordingly.</source>
          <target state="translated">Клиент, поддерживающий постоянные соединения, МОЖЕТ &amp;laquo;конвейерно&amp;raquo; свои запросы (т. Е. Отправлять несколько запросов, не дожидаясь каждого ответа). Сервер МОЖЕТ обрабатывать последовательность конвейерных запросов параллельно, если все они имеют безопасные методы ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;раздел 4.2.1 [RFC7231]&lt;/a&gt;), но он ДОЛЖЕН отправлять соответствующие ответы в том же порядке, в котором были получены запросы. Клиенту, который передает запросы по конвейеру, СЛЕДУЕТ повторять неотвеченные запросы, если соединение закрывается до того, как он получит все соответствующие ответы. При повторной попытке конвейерных запросов после неудачного соединения (соединение, явно не закрытое сервером в его последнем полном ответе), клиент НЕ ДОЛЖЕН выполнять конвейерную обработку сразу после установления соединения, так как первый оставшийся запрос в предыдущем конвейере мог вызвать ответ с ошибкой, который могут быть потеряны снова, если несколько запросов будут отправлены по преждевременно закрытому соединению (см. проблему сброса TCP, описанную в &lt;a href=&quot;#section-6.6&quot;&gt;разделе 6.6&lt;/a&gt; ). Идемпотентные методы ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.2&quot;&gt;раздел 4.2.2 [RFC7231]&lt;/a&gt;) важны для конвейерной обработки, поскольку их можно автоматически повторить после сбоя соединения. Пользовательскому агенту НЕ СЛЕДУЕТ конвейерные запросы после неидемпотентного метода до тех пор, пока не будет получен окончательный код состояния ответа для этого метода, если только пользовательский агент не имеет средств для обнаружения и восстановления после условий частичного отказа, включающих конвейерную последовательность. Посредник, который получает конвейерные запросы, МОЖЕТ конвейеризовать эти запросы при их входящей передаче, поскольку он может полагаться на исходящих пользовательских агентов, чтобы определить, какие запросы можно безопасно конвейеризовать. Если входящее соединение не удается до получения ответа, конвейерный посредник МОЖЕТ попытаться повторить последовательность запросов, которые еще не получили ответ, если все запросы имеют идемпотентные методы; в противном случае,конвейерному посреднику СЛЕДУЕТ пересылать любые полученные ответы, а затем закрывать соответствующее исходящее соединение (я), чтобы исходящий пользовательский агент (ы) мог соответственно восстановиться.</target>
        </trans-unit>
        <trans-unit id="09e95576fba358e044ab16ce38c0a6a7604b1900" translate="yes" xml:space="preserve">
          <source>A client that supports persistent connections MAY &quot;pipeline&quot; its
   requests (i.e., send multiple requests without waiting for each
   response). A server MUST send its responses to those requests in the
   same order that the requests were received.

   Clients which assume persistent connections and pipeline immediately
   after connection establishment SHOULD be prepared to retry their
   connection if the first pipelined attempt fails. If a client does
   such a retry, it MUST NOT pipeline before it knows the connection is
   persistent. Clients MUST also be prepared to resend their requests if
   the server closes the connection before sending all of the
   corresponding responses.

   Clients SHOULD NOT pipeline requests using non-idempotent methods or
   non-idempotent sequences of methods (see &lt;a href=&quot;#section-9.1.2&quot;&gt;section 9.1.2&lt;/a&gt;). Otherwise, a
   premature termination of the transport connection could lead to
   indeterminate results. A client wishing to send a non-idempotent
   request SHOULD wait to send that request until it has received the
   response status for the previous request.</source>
          <target state="translated">Клиент, поддерживающий постоянные соединения, МОЖЕТ &amp;laquo;конвейерно&amp;raquo; свои запросы (т. Е. Отправлять несколько запросов, не дожидаясь каждого ответа). Сервер ДОЛЖЕН отправлять свои ответы на эти запросы в том же порядке, в котором они были получены. Клиенты, которые предполагают постоянные соединения и конвейер сразу после установления соединения, ДОЛЖНЫ быть готовы к повторной попытке подключения, если первая конвейерная попытка не удалась. Если клиент выполняет такую ​​повторную попытку, он НЕ ДОЛЖЕН выполнять конвейерную обработку, прежде чем он узнает, что соединение является постоянным. Клиенты ДОЛЖНЫ быть готовы к повторной отправке своих запросов, если сервер закрывает соединение перед отправкой всех соответствующих ответов. Клиентам НЕ СЛЕДУЕТ конвейерные запросы с использованием неидемпотентных методов или неидемпотентных последовательностей методов (см. &lt;a href=&quot;#section-9.1.2&quot;&gt;Раздел 9.1.2.&lt;/a&gt;). В противном случае преждевременное завершение транспортного соединения может привести к неопределенным результатам. Клиенту, желающему отправить неидемпотентный запрос, СЛЕДУЕТ дождаться отправки этого запроса, пока он не получит статус ответа для предыдущего запроса.</target>
        </trans-unit>
        <trans-unit id="63e7a43a912d31f1510e39f67b9021a4a00a0103" translate="yes" xml:space="preserve">
          <source>A client that wants to authenticate itself with the server can then do so by including an &lt;a href=&quot;headers/authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; request header with the credentials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4673d2cf5f078d0e80766af3fc18ef334aaf9ad" translate="yes" xml:space="preserve">
          <source>A client to display (and accidentally edit) these documents, the first Web browser called &lt;em&gt;WorldWideWeb&lt;/em&gt;.</source>
          <target state="translated">Клиент для отображения (и случайного редактирования) этих документов, первый веб-браузер под названием &lt;em&gt;WorldWideWeb&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bc8b63d811e299dc8d332f7a04036fbab8d18d90" translate="yes" xml:space="preserve">
          <source>A client's request signals to the server that it supports the upgrade mechanisms of &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf22c128590a11ccd015eab613d6d6178d3986e" translate="yes" xml:space="preserve">
          <source>A collection of tips to help operational teams with creating secure web applications.</source>
          <target state="translated">Сборник подсказок,которые помогут оперативным группам в создании безопасных веб-приложений.</target>
        </trans-unit>
        <trans-unit id="545d7ecd63391cf84687a091c329dea2e48ff465" translate="yes" xml:space="preserve">
          <source>A comma-delimited list of &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; that are included in the request.</source>
          <target state="translated">Разделенный запятыми список &lt;a href=&quot;../headers&quot;&gt;заголовков HTTP&lt;/a&gt; , включенных в запрос.</target>
        </trans-unit>
        <trans-unit id="4a7070eb1fb6568ed5750e765e691507dcbb9e26" translate="yes" xml:space="preserve">
          <source>A comma-delineated list of the WebSocket protocol versions supported by the server.</source>
          <target state="translated">Список поддерживаемых сервером версий протокола WebSocket с запятыми.</target>
        </trans-unit>
        <trans-unit id="dd0dcb0efcb7d9566b65a09f6272f43ad4054b47" translate="yes" xml:space="preserve">
          <source>A comma-separated list of extensions to request (or agree to support). These should be selected from the &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#extension-name&quot;&gt;IANA WebSocket Extension Name Registry&lt;/a&gt;. Extensions which take parameters do so by using semicolon delineation.</source>
          <target state="translated">Список разделенных запятыми расширений, которые нужно запросить (или согласиться на поддержку). Их следует выбрать из &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#extension-name&quot;&gt;реестра имен расширений IANA WebSocket&lt;/a&gt; . Расширения, которые принимают параметры, делают это, используя точку с запятой.</target>
        </trans-unit>
        <trans-unit id="6d9b0d38fc7576edfbc87bdb5049a93e906cc613" translate="yes" xml:space="preserve">
          <source>A comma-separated list of header names to take into account when deciding whether or not a cached response can be used.</source>
          <target state="translated">Разделенный запятыми список имен заголовков для учета при принятии решения о возможности использования кэшированного ответа.</target>
        </trans-unit>
        <trans-unit id="3351f8daef225cdddd1d659a4e4c2bff164ed208" translate="yes" xml:space="preserve">
          <source>A comma-separated list of parameters, each consisting of an identifier and a value separated by the equal sign (&lt;code&gt;'='&lt;/code&gt;). The following identifiers are possible:</source>
          <target state="translated">Список параметров, разделенных запятыми, каждый из которых состоит из идентификатора и значения, разделенных знаком равенства ( &lt;code&gt;'='&lt;/code&gt; ). Возможны следующие идентификаторы:</target>
        </trans-unit>
        <trans-unit id="e64dd752a990983ce318fbd34f3017c824c11259" translate="yes" xml:space="preserve">
          <source>A comma-separated list of subprotocol names, in the order of preference. The subprotocols may be selected from the &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#subprotocol-name&quot;&gt;IANA WebSocket Subprotocol Name Registry&lt;/a&gt; or may be a custom name jointly understood by the client and the server.</source>
          <target state="translated">Список имен подпротоколов, разделенных запятыми, в порядке предпочтения. Подпротоколы могут быть выбраны из &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#subprotocol-name&quot;&gt;реестра имен подпротоколов IANA WebSocket&lt;/a&gt; или могут быть настраиваемым именем, совместно понятным клиенту и серверу.</target>
        </trans-unit>
        <trans-unit id="954560756b7f774ff0dbcf3f403c65bfec685270" translate="yes" xml:space="preserve">
          <source>A common case is when a site resides at &lt;code&gt;www.example.com&lt;/code&gt;, but accessing it from &lt;code&gt;example.com&lt;/code&gt; should also work. Redirections for &lt;code&gt;example.com&lt;/code&gt; to &lt;code&gt;www.example.com&lt;/code&gt; are thus set up. You might also redirect from common synonyms or frequent typos of your domains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765a1ca65f0ae709d5083d956638fa8d4f371723" translate="yes" xml:space="preserve">
          <source>A common operation in Web applications is to &lt;em&gt;update&lt;/em&gt; a remote document. This is very common in any file system or source control applications, but any application that allows to store remote resources needs such a mechanism. Common Web sites, like wikis and other CMS, have such a need.</source>
          <target state="translated">Распространенной операцией в веб-приложениях является &lt;em&gt;обновление&lt;/em&gt; удаленного документа. Это очень распространено в любой файловой системе или приложениях управления версиями, но любое приложение, которое позволяет хранить удаленные ресурсы, нуждается в таком механизме. Обычные веб-сайты, такие как вики и другие CMS, имеют такую ​​потребность.</target>
        </trans-unit>
        <trans-unit id="56fb8e2fb85d7e564f3d29ea311fff6ca481b845" translate="yes" xml:space="preserve">
          <source>A complete URL, known as the &lt;em&gt;absolute form&lt;/em&gt;, is mostly used with &lt;code&gt;GET&lt;/code&gt; when connected to a proxy.</source>
          <target state="translated">Полный URL-адрес, известный как &lt;em&gt;абсолютная форма&lt;/em&gt; , в основном используется с &lt;code&gt;GET&lt;/code&gt; при подключении к прокси.</target>
        </trans-unit>
        <trans-unit id="fe1809df44023e8e001ce74fe56c8e7ccf0d8591" translate="yes" xml:space="preserve">
          <source>A compression format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;Lempel-Ziv coding&lt;/a&gt; (LZ77), with a 32-bit CRC.</source>
          <target state="translated">Формат сжатия с использованием &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;кодирования Лемпеля-Зива&lt;/a&gt; (LZ77) с 32-битным CRC.</target>
        </trans-unit>
        <trans-unit id="f3c6e3712615587b61d1ea467fde1e10f59e37c9" translate="yes" xml:space="preserve">
          <source>A compression format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Lempel-Ziv-Welch&lt;/a&gt; (LZW) algorithm.</source>
          <target state="translated">Формат сжатия с использованием алгоритма &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Лемпеля-Зива-Велча&lt;/a&gt; (LZW).</target>
        </trans-unit>
        <trans-unit id="fc4d9ed7204457ec6cc9721d89f040474b7a652b" translate="yes" xml:space="preserve">
          <source>A compression format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure, with the &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt; compression algorithm.</source>
          <target state="translated">Формат сжатия с использованием структуры &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; с алгоритмом сжатия &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05595aa3b6a0abccc227abaf6c71dbce8636585f" translate="yes" xml:space="preserve">
          <source>A compression format using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Brotli&quot;&gt;Brotli&lt;/a&gt; algorithm.</source>
          <target state="translated">Формат сжатия с использованием алгоритма &lt;a href=&quot;https://en.wikipedia.org/wiki/Brotli&quot;&gt;Бротли&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5f5c5610894d726a658909063c81dee8cf8da26" translate="yes" xml:space="preserve">
          <source>A compression format using the &lt;a href=&quot;https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;Lempel-Ziv coding&lt;/a&gt; (LZ77), with a 32-bit CRC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ee4dcdbc16553632cbd81d6f559303fab97423" translate="yes" xml:space="preserve">
          <source>A compression format using the &lt;a href=&quot;https://en.wikipedia.org/wiki/LZW&quot;&gt;Lempel-Ziv-Welch&lt;/a&gt; (LZW) algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df54e7cc1e88fc5811ec6386faef052c65d5bf5" translate="yes" xml:space="preserve">
          <source>A compression format using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure, with the &lt;a href=&quot;https://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt; compression algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7bb2d2d512282eb3e9b2963af2987738e151227" translate="yes" xml:space="preserve">
          <source>A connection can be reused, saving the time to reopen it numerous times to display the resources embedded into the single original document retrieved.</source>
          <target state="translated">Соединение может быть использовано повторно,что позволяет сэкономить время на многократное повторное открытие для отображения ресурсов,встроенных в единственный полученный оригинальный документ.</target>
        </trans-unit>
        <trans-unit id="509931ff360314f1dcb21ee1409195696c609d6d" translate="yes" xml:space="preserve">
          <source>A connection error is any error that prevents further processing of
   the frame layer or corrupts any connection state.

   An endpoint that encounters a connection error SHOULD first send a
   GOAWAY frame (&lt;a href=&quot;#section-6.8&quot;&gt;Section 6.8&lt;/a&gt;) with the stream identifier of the last
   stream that it successfully received from its peer.  The GOAWAY frame
   includes an error code that indicates why the connection is
   terminating.  After sending the GOAWAY frame for an error condition,
   the endpoint MUST close the TCP connection.

   It is possible that the GOAWAY will not be reliably received by the
   receiving endpoint (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.6&quot;&gt;[RFC7230], Section&amp;nbsp;6.6&lt;/a&gt; describes how an immediate
   connection close can result in data loss).  In the event of a
   connection error, GOAWAY only provides a best-effort attempt to
   communicate with the peer about why the connection is being
   terminated.

   An endpoint can end a connection at any time.  In particular, an
   endpoint MAY choose to treat a stream error as a connection error.
   Endpoints SHOULD send a GOAWAY frame when ending a connection,
   providing that circumstances permit it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a3a1fcd6e5f64af49a78c0978fa2905e70fbdc" translate="yes" xml:space="preserve">
          <source>A connection is controlled at the transport layer, and therefore fundamentally out of scope for HTTP. Though HTTP doesn't require the underlying transport protocol to be connection-based; only requiring it to be &lt;em&gt;reliable&lt;/em&gt;, or not lose messages (so at minimum presenting an error). Among the two most common transport protocols on the Internet, TCP is reliable and UDP isn't. HTTP subsequently relies on the TCP standard, which is connection-based, even though a connection is not always required.</source>
          <target state="translated">Соединение контролируется на транспортном уровне и поэтому принципиально выходит за рамки HTTP. Хотя HTTP не требует, чтобы базовый транспортный протокол был основан на соединении; только требуя, чтобы он был &lt;em&gt;надежным&lt;/em&gt; , или не терял сообщения (как минимум, представляя ошибку). Среди двух наиболее распространенных транспортных протоколов в Интернете TCP является надежным, а UDP - нет. Впоследствии HTTP полагается на стандарт TCP, основанный на соединении, хотя соединение не всегда требуется.</target>
        </trans-unit>
        <trans-unit id="449f1efb42383b982f63e22f55d172b3f3d362a4" translate="yes" xml:space="preserve">
          <source>A connection is controlled at the transport layer, and therefore fundamentally out of scope for HTTP. Though HTTP doesn't require the underlying transport protocol to be connection-based; only requiring it to be &lt;em&gt;reliable&lt;/em&gt;, or not lose messages (so at minimum presenting an error). Among the two most common transport protocols on the Internet, TCP is reliable and UDP isn't. HTTP therefore relies on the TCP standard, which is connection-based.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da45e542a4ecf477e31105fbfb530cf280b696ac" translate="yes" xml:space="preserve">
          <source>A cookie begins with a name-value pair:</source>
          <target state="translated">Печенье начинается с пары &quot;имя-значение&quot;:</target>
        </trans-unit>
        <trans-unit id="c987d7297ad42a4f63e657b6a26ef82f6c58c39b" translate="yes" xml:space="preserve">
          <source>A cookie belonging to a domain that does not include the origin server &lt;a href=&quot;https://tools.ietf.org/html/rfc6265#section-4.1.2.3&quot;&gt;should be rejected by the user agent&lt;/a&gt;. The following cookie will be rejected if it was set by a server hosted on originalcompany.com.</source>
          <target state="translated">Файл cookie, принадлежащий домену, который не включает исходный сервер, &lt;a href=&quot;https://tools.ietf.org/html/rfc6265#section-4.1.2.3&quot;&gt;должен быть отклонен пользовательским агентом&lt;/a&gt; . Следующий файл cookie будет отклонен, если он был установлен сервером, размещенным на originalcompany.com.</target>
        </trans-unit>
        <trans-unit id="0f35e435392b2381557a355cb4470d731e02478a" translate="yes" xml:space="preserve">
          <source>A cookie for a domain that does not include the server that set it &lt;a href=&quot;https://tools.ietf.org/html/rfc6265#section-4.1.2.3&quot;&gt;should be rejected by the user agent&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37ce32a93b2cb9f5253c4016337dd3a5af1c3e5" translate="yes" xml:space="preserve">
          <source>A cookie for a sub domain of the serving domain will be rejected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf8f0198fd6d1e23aedf60fb515a3869ace7ce34" translate="yes" xml:space="preserve">
          <source>A cookie is associated with a domain. If this domain is the same as the domain of the page you are on, the cookie is called a &lt;em&gt;first-party cookie&lt;/em&gt;. If the domain is different, it is a &lt;em&gt;third-party cookie&lt;/em&gt;. While the server hosting a web page sets first-party cookies, the page may contain images or other components stored on servers in other domains (for example, ad banners), which may set third-party cookies. These are mainly used for advertising and tracking across the web. See for example the &lt;a href=&quot;https://policies.google.com/technologies/types&quot;&gt;types of cookies used by Google&lt;/a&gt;. A third party server can build up a profile of a user's browsing history and habits based on cookies sent to it by the same browser when accessing multiple sites. Firefox, by default, blocks third-party cookies that are known to contain trackers. Third-party cookies (or just tracking cookies) may also be blocked by other browser settings or extensions. Cookie blocking can cause some third-party components (such as social media widgets) to not function as intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d37c8e928ad783b182cebcac2bda3dbbdb9937" translate="yes" xml:space="preserve">
          <source>A cookie with the &lt;code&gt;HttpOnly&lt;/code&gt; attribute is inaccessible to the JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; API; it is sent only to the server. For example, cookies that persist server-side sessions don't need to be available to JavaScript, and should have the &lt;code&gt;HttpOnly&lt;/code&gt; attribute. This precaution helps mitigate cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Cross-site_scripting_(XSS)&quot;&gt;XSS&lt;/a&gt;) attacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a5315337fe2caafeb7456394c12b7df8509b49" translate="yes" xml:space="preserve">
          <source>A cookie with the &lt;code&gt;Secure&lt;/code&gt; attribute is sent to the server only with an encrypted request over the HTTPS protocol, never with unsecured HTTP (except on localhost), and therefore can't easily be accessed by a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MitM&quot;&gt;man-in-the-middle&lt;/a&gt; attacker. Insecure sites (with &lt;code&gt;http:&lt;/code&gt; in the URL) can't set cookies with the &lt;code&gt;Secure&lt;/code&gt; attribute. However, do not assume that &lt;code&gt;Secure&lt;/code&gt; prevents all access to sensitive information in cookies; for example, it can be read and modified by someone with access to the client's hard disk (or JavaScript if the &lt;code&gt;HttpOnly&lt;/code&gt; attribute is not set).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2001d70e25e20b433ea2e7fdbd02e6058831b1c9" translate="yes" xml:space="preserve">
          <source>A correct cache MUST respond to a request with the most up-to-date
   response held by the cache that is appropriate to the request (see
   sections &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;, &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt;, and &lt;a href=&quot;#section-13.12&quot;&gt;13.12&lt;/a&gt;) which meets one of the following
   conditions:

      1. It has been checked for equivalence with what the origin server
         would have returned by revalidating the response with the
         origin server (&lt;a href=&quot;#section-13.3&quot;&gt;section 13.3&lt;/a&gt;); 

      2. It is &quot;fresh enough&quot; (see &lt;a href=&quot;#section-13.2&quot;&gt;section 13.2&lt;/a&gt;). In the default case,
         this means it meets the least restrictive freshness requirement
         of the client, origin server, and cache (see &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;); if
         the origin server so specifies, it is the freshness requirement
         of the origin server alone.

         If a stored response is not &quot;fresh enough&quot; by the most
         restrictive freshness requirement of both the client and the
         origin server, in carefully considered circumstances the cache
         MAY still return the response with the appropriate Warning
         header (see &lt;a href=&quot;#section-13.1.5&quot;&gt;section 13.1.5&lt;/a&gt; and 14.46), unless such a response
         is prohibited (e.g., by a &quot;no-store&quot; cache-directive, or by a
         &quot;no-cache&quot; cache-request-directive; see &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).

      3. It is an appropriate 304 (Not Modified), 305 (Proxy Redirect),
         or error (4xx or 5xx) response message.

   If the cache can not communicate with the origin server, then a
   correct cache SHOULD respond as above if the response can be
   correctly served from the cache; if not it MUST return an error or
   warning indicating that there was a communication failure.

   If a cache receives a response (either an entire response, or a 304
   (Not Modified) response) that it would normally forward to the
   requesting client, and the received response is no longer fresh, the
   cache SHOULD forward it to the requesting client without adding a new
   Warning (but without removing any existing Warning headers). A cache
   SHOULD NOT attempt to revalidate a response simply because that
   response became stale in transit; this might lead to an infinite
   loop. A user agent that receives a stale response without a Warning
   MAY display a warning indication to the user.</source>
          <target state="translated">Правильный кэш ДОЛЖЕН отвечать на запрос самым последним ответом , &lt;a href=&quot;#section-13.2.6&quot;&gt;хранящимся&lt;/a&gt; в кэше, который соответствует запросу (см. Разделы &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt; , 13.2.6 и &lt;a href=&quot;#section-13.12&quot;&gt;13.12&lt;/a&gt; ), который удовлетворяет одному из следующих условий: 1 Он был проверен на эквивалентность тому, что сервер-источник возвратил бы путем повторной проверки ответа с сервером-источником ( &lt;a href=&quot;#section-13.3&quot;&gt;раздел 13.3&lt;/a&gt; ); 2. Он &amp;laquo;достаточно свежий&amp;raquo; (см. &lt;a href=&quot;#section-13.2&quot;&gt;Раздел 13.2&lt;/a&gt; ). В случае по умолчанию это означает, что он соответствует наименее строгим требованиям к свежести клиента, исходного сервера и кеша (см. &lt;a href=&quot;#section-14.9&quot;&gt;Раздел 14.9.&lt;/a&gt;); если исходный сервер так указывает, это требование свежести только исходного сервера. Если сохраненный ответ не является &amp;laquo;достаточно свежим&amp;raquo; из-за наиболее строгих требований к свежести как клиента, так и исходного сервера, при тщательно продуманных обстоятельствах кеш МОЖЕТ вернуть ответ с соответствующим заголовком предупреждения (см. &lt;a href=&quot;#section-13.1.5&quot;&gt;Разделы 13.1.5&lt;/a&gt; и 14.46 ) , если такой ответ не запрещен (например, директивой кеширования &amp;laquo;no-store&amp;raquo; или директивой запроса кеша &amp;laquo;no-cache&amp;raquo;; см. &lt;a href=&quot;#section-14.9&quot;&gt;раздел 14.9&lt;/a&gt;). 3. Это соответствующее сообщение ответа 304 (Не изменено), 305 (Перенаправление прокси) или ошибки (4xx или 5xx). Если кэш не может взаимодействовать с исходным сервером, то правильный кеш ДОЛЖЕН отвечать, как указано выше, если ответ может быть правильно доставлен из кеша; в противном случае он ДОЛЖЕН вернуть ошибку или предупреждение, указывающее на сбой связи. Если кэш получает ответ (либо весь ответ, либо ответ 304 (не изменено)), который обычно пересылается запрашивающему клиенту, и полученный ответ больше не является свежим, кеш ДОЛЖЕН переслать его запрашивающему клиенту без добавление нового предупреждения (но без удаления существующих заголовков предупреждений). Кэшу НЕ СЛЕДУЕТ пытаться повторно подтвердить ответ просто потому, что этот ответ устарел при передаче;это может привести к бесконечному циклу. Пользовательский агент, который получает устаревший ответ без предупреждения, МОЖЕТ отображать предупреждение для пользователя.</target>
        </trans-unit>
        <trans-unit id="89577e07030bd40f6712d10194b453cf2d440e98" translate="yes" xml:space="preserve">
          <source>A cross-site request has previously been performed that already did a preflight, and doing the preflight again is not permitted. Make sure your code only preflights once per connection.</source>
          <target state="translated">Ранее был выполнен межсайтовый запрос,который уже выполнял предполетный полет,и повторное выполнение предполетного полета не разрешается.Убедитесь,что Ваш код выполняется только один раз за одно соединение.</target>
        </trans-unit>
        <trans-unit id="a811a3a9985b454708fdc8eb33814dd46cc41295" translate="yes" xml:space="preserve">
          <source>A custom header</source>
          <target state="translated">Пользовательский заголовок</target>
        </trans-unit>
        <trans-unit id="5a2fa58bd2284006bceccd7cb755ebd723f2c6f7" translate="yes" xml:space="preserve">
          <source>A custom header (such as &lt;code&gt;X-PINGARUNER&lt;/code&gt;) is sent with the request.</source>
          <target state="translated">Пользовательский заголовок (например, &lt;code&gt;X-PINGARUNER&lt;/code&gt; ) отправляется вместе с запросом.</target>
        </trans-unit>
        <trans-unit id="503ad6dab740192f7df55700acaa852749538c30" translate="yes" xml:space="preserve">
          <source>A date after which to retry. See the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; header for more details on the HTTP date format.</source>
          <target state="translated">Дата, после которой можно повторить попытку. См. Заголовок &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; для получения дополнительных сведений о формате даты HTTP.</target>
        </trans-unit>
        <trans-unit id="b40039ddee641d60641b6ebc43748e9635b227eb" translate="yes" xml:space="preserve">
          <source>A deployment of HTTP/2 over TLS 1.2 SHOULD NOT use any of the cipher
   suites that are listed in the cipher suite black list (Appendix A).

   Endpoints MAY choose to generate a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;)
   of type INADEQUATE_SECURITY if one of the cipher suites from the
   black list is negotiated.  A deployment that chooses to use a black-
   listed cipher suite risks triggering a connection error unless the
   set of potential peers is known to accept that cipher suite.

   Implementations MUST NOT generate this error in reaction to the
   negotiation of a cipher suite that is not on the black list.
   Consequently, when clients offer a cipher suite that is not on the
   black list, they have to be prepared to use that cipher suite with
   HTTP/2.

   The black list includes the cipher suite that TLS 1.2 makes
   mandatory, which means that TLS 1.2 deployments could have non-
   intersecting sets of permitted cipher suites.  To avoid this problem
   causing TLS handshake failures, deployments of HTTP/2 that use TLS
   1.2 MUST support TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 [&lt;a href=&quot;#ref-TLS-ECDHE&quot;&gt;TLS-ECDHE&lt;/a&gt;]
   with the P-256 elliptic curve [&lt;a href=&quot;#ref-FIPS186&quot;&gt;FIPS186&lt;/a&gt;]. 

   Note that clients might advertise support of cipher suites that are
   on the black list in order to allow for connection to servers that do
   not support HTTP/2.  This allows servers to select HTTP/1.1 with a
   cipher suite that is on the HTTP/2 black list.  However, this can
   result in HTTP/2 being negotiated with a black-listed cipher suite if
   the application protocol and cipher suite are independently selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cf3c99c4d72849ee4efd8ac6882b05e9d3a1a1" translate="yes" xml:space="preserve">
          <source>A description of the protected area, the realm. If no realm is specified, clients often display a formatted host name instead.</source>
          <target state="translated">Описание охраняемой территории,царства.Если область не указана,клиенты часто отображают вместо нее отформатированное имя хоста.</target>
        </trans-unit>
        <trans-unit id="5e9d729c23cc7169e172ea196579970b84e7e284" translate="yes" xml:space="preserve">
          <source>A description of the protected area. If no realm is specified, clients often display a formatted hostname instead.</source>
          <target state="translated">Описание охраняемой территории.Если область не указана,клиенты часто отображают вместо нее отформатированное имя хоста.</target>
        </trans-unit>
        <trans-unit id="b5a8720daf81911489f27aaafe4bd0ccd798eb06" translate="yes" xml:space="preserve">
          <source>A discussion of Cross-Origin Resource Sharing from a server perspective (including PHP code snippets) can be found in the &lt;a href=&quot;server-side_access_control&quot;&gt;Server-Side Access Control (CORS)&lt;/a&gt; article.</source>
          <target state="translated">Обсуждение совместного использования ресурсов между источниками с точки зрения сервера (включая фрагменты кода PHP) можно найти в статье &lt;a href=&quot;server-side_access_control&quot;&gt;Server-Side Access Control (CORS)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4908a8b2c4833ed56d01c1531e18571e4bbedba2" translate="yes" xml:space="preserve">
          <source>A document can only load resources from the same origin, or resources explicitly marked as loadable from another origin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3fc6fb939e0085074cefc8e6d65d3381d91750" translate="yes" xml:space="preserve">
          <source>A few examples:</source>
          <target state="translated">Несколько примеров:</target>
        </trans-unit>
        <trans-unit id="b27d2c2e1b4290f0ba6c37cc3712ff739648e303" translate="yes" xml:space="preserve">
          <source>A form using the &lt;code&gt;multipart/form-data&lt;/code&gt; content type:</source>
          <target state="translated">Форма, использующая тип содержимого &lt;code&gt;multipart/form-data&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="614f75732c39c44f099d446998fd31224f828fd2" translate="yes" xml:space="preserve">
          <source>A format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;Lempel-Ziv coding&lt;/a&gt; (LZ77), with a 32-bit CRC is accepted as a transfer coding name.</source>
          <target state="translated">Формат, использующий &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;кодирование Лемпеля-Зива&lt;/a&gt; (LZ77) с 32-битным CRC, принимается в качестве названия кодирования передачи.</target>
        </trans-unit>
        <trans-unit id="22748d9ab36c5f67b399f36a38ad2543edae63ac" translate="yes" xml:space="preserve">
          <source>A format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;Lempel-Ziv coding&lt;/a&gt; (LZ77), with a 32-bit CRC. This is originally the format of the UNIX &lt;em&gt;gzip&lt;/em&gt; program. The HTTP/1.1 standard also recommends that the servers supporting this content-encoding should recognize &lt;code&gt;x-gzip&lt;/code&gt; as an alias, for compatibility purposes.</source>
          <target state="translated">Формат, использующий &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;кодирование Лемпеля-Зива&lt;/a&gt; (LZ77) с 32-битным CRC. Изначально это формат программы &lt;em&gt;gzip для&lt;/em&gt; UNIX . Стандарт HTTP / 1.1 также рекомендует, чтобы серверы, поддерживающие это кодирование содержимого, распознавали &lt;code&gt;x-gzip&lt;/code&gt; как псевдоним для целей совместимости.</target>
        </trans-unit>
        <trans-unit id="ef17edcb9fdca11383c92d9963d7bf24f22d1a7d" translate="yes" xml:space="preserve">
          <source>A format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;Lempel-Ziv coding&lt;/a&gt; (LZ77), with a 32-bit CRC. This is the original format of the UNIX &lt;em&gt;gzip&lt;/em&gt; program. The HTTP/1.1 standard also recommends that the servers supporting this content-encoding should recognize &lt;code&gt;x-gzip&lt;/code&gt; as an alias, for compatibility purposes.</source>
          <target state="translated">Формат, использующий &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;кодирование Лемпеля-Зива&lt;/a&gt; (LZ77) с 32-битным CRC. Это исходный формат программы &lt;em&gt;gzip для&lt;/em&gt; UNIX . Стандарт HTTP / 1.1 также рекомендует, чтобы серверы, поддерживающие это кодирование содержимого, распознавали &lt;code&gt;x-gzip&lt;/code&gt; как псевдоним для целей совместимости.</target>
        </trans-unit>
        <trans-unit id="44f47b4033a24779dd1d3b91694a7e0c751de3c5" translate="yes" xml:space="preserve">
          <source>A format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Lempel-Ziv-Welch&lt;/a&gt; (LZW) algorithm is accepted as a transfer coding name.</source>
          <target state="translated">Формат, использующий алгоритм &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Лемпеля-Зива-Велча&lt;/a&gt; (LZW), принимается в качестве названия кодирования передачи.</target>
        </trans-unit>
        <trans-unit id="ff6501d8ed3cac8df2af44cead1b7ab4b7e10774" translate="yes" xml:space="preserve">
          <source>A format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Lempel-Ziv-Welch&lt;/a&gt; (LZW) algorithm. The value name was taken from the UNIX &lt;em&gt;compress&lt;/em&gt; program, which implemented this algorithm.</source>
          <target state="translated">Формат, использующий алгоритм &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Лемпеля-Зива-Велча&lt;/a&gt; (LZW). Имя значения было взято из программы &lt;em&gt;сжатия&lt;/em&gt; UNIX , в которой реализован этот алгоритм.</target>
        </trans-unit>
        <trans-unit id="474b27ae1efc1cf4c0259d41c022937667b49d1f" translate="yes" xml:space="preserve">
          <source>A format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Lempel-Ziv-Welch&lt;/a&gt; (LZW) algorithm. The value name was taken from the UNIX &lt;em&gt;compress&lt;/em&gt; program, which implemented this algorithm. Like the compress program, which has disappeared from most UNIX distributions, this content-encoding is not used by many browsers today, partly because of a patent issue (it expired in 2003).</source>
          <target state="translated">Формат, использующий алгоритм &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Лемпеля-Зива-Велча&lt;/a&gt; (LZW). Имя значения было взято из программы &lt;em&gt;сжатия&lt;/em&gt; UNIX , в которой реализован этот алгоритм. Подобно программе сжатия, которая исчезла из большинства дистрибутивов UNIX, эта кодировка содержимого не используется сегодня многими браузерами, отчасти из-за проблемы с патентом (срок ее действия истек в 2003 году).</target>
        </trans-unit>
        <trans-unit id="61675e08319d9261f19703357a0adf44d98c5d90" translate="yes" xml:space="preserve">
          <source>A format using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Brotli&quot;&gt;Brotli&lt;/a&gt; algorithm.</source>
          <target state="translated">Формат, использующий алгоритм &lt;a href=&quot;https://en.wikipedia.org/wiki/Brotli&quot;&gt;Бротли&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3ddbd90fc923592bb2b8a99325a9ed24ae5ba5a" translate="yes" xml:space="preserve">
          <source>A forward proxy, or gateway, or just &quot;proxy&quot; provides proxy services to a client or a group of clients. There are likely hundreds of thousands of open forward proxies on the Internet. They store and forward Internet services (like the DNS, or web pages) to reduce and control the bandwidth used by the group.</source>
          <target state="translated">Прямой прокси,или шлюз,или просто &quot;прокси&quot; предоставляет прокси услуги клиенту или группе клиентов.Скорее всего,в сети Интернет есть сотни тысяч открытых форвардных прокси.Они хранят и переадресовывают интернет-сервисы (например,DNS или веб-страницы),чтобы уменьшить и контролировать пропускную способность,используемую группой.</target>
        </trans-unit>
        <trans-unit id="910536150ef5b9e104120b70b03cb221a8cac548" translate="yes" xml:space="preserve">
          <source>A fresh response is one whose age has not yet exceeded its freshness
   lifetime.  Conversely, a stale response is one where it has.

   A response's freshness lifetime is the length of time between its
   generation by the origin server and its expiration time.  An explicit
   expiration time is the time at which the origin server intends that a
   stored response can no longer be used by a cache without further
   validation, whereas a heuristic expiration time is assigned by a
   cache when no explicit expiration time is available.

   A response's age is the time that has passed since it was generated
   by, or successfully validated with, the origin server.

   When a response is &quot;fresh&quot; in the cache, it can be used to satisfy
   subsequent requests without contacting the origin server, thereby
   improving efficiency.

   The primary mechanism for determining freshness is for an origin
   server to provide an explicit expiration time in the future, using
   either the Expires header field (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) or the max-age response
   directive (&lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt;).  Generally, origin servers will assign
   future explicit expiration times to responses in the belief that the
   representation is not likely to change in a semantically significant
   way before the expiration time is reached.

   If an origin server wishes to force a cache to validate every
   request, it can assign an explicit expiration time in the past to
   indicate that the response is already stale.  Compliant caches will
   normally validate a stale cached response before reusing it for
   subsequent requests (see &lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;).

   Since origin servers do not always provide explicit expiration times,
   caches are also allowed to use a heuristic to determine an expiration
   time under certain circumstances (see &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;).

   The calculation to determine if a response is fresh is:

      response_is_fresh = (freshness_lifetime &amp;gt; current_age)

   freshness_lifetime is defined in &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;; current_age is
   defined in &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;.

   Clients can send the max-age or min-fresh cache directives in a
   request to constrain or relax freshness calculations for the
   corresponding response (&lt;a href=&quot;#section-5.2.1&quot;&gt;Section 5.2.1&lt;/a&gt;). 

   When calculating freshness, to avoid common problems in date parsing:

   o  Although all date formats are specified to be case-sensitive, a
      cache recipient SHOULD match day, week, and time-zone names
      case-insensitively.

   o  If a cache recipient's internal implementation of time has less
      resolution than the value of an HTTP-date, the recipient MUST
      internally represent a parsed Expires date as the nearest time
      equal to or earlier than the received value.

   o  A cache recipient MUST NOT allow local time zones to influence the
      calculation or comparison of an age or expiration time.

   o  A cache recipient SHOULD consider a date with a zone abbreviation
      other than GMT or UTC to be invalid for calculating expiration.

   Note that freshness applies only to cache operation; it cannot be
   used to force a user agent to refresh its display or reload a
   resource.  See &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt; for an explanation of the difference between
   caches and history mechanisms.</source>
          <target state="translated">Свежий ответ - это тот, чей возраст еще не превысил срок его жизни. И наоборот, устаревший ответ - это тот, где он есть. Время жизни ответа - это промежуток времени между его генерацией исходным сервером и сроком его действия. Явное время истечения срока - это время, когда исходный сервер предполагает, что сохраненный ответ больше не может использоваться кешем без дальнейшей проверки, тогда как эвристическое время истечения срока назначается кешем, когда явное время истечения недоступно. Возраст ответа - это время, прошедшее с момента его создания или успешной проверки исходным сервером. Когда ответ &amp;laquo;свежий&amp;raquo; в кэше, его можно использовать для удовлетворения последующих запросов без связи с исходным сервером, тем самым повышая эффективность.Первичный механизм определения актуальности заключается в том, что исходный сервер предоставляет явное время истечения срока действия в будущем, используя либо поле заголовка Expires (&lt;a href=&quot;#section-5.3&quot;&gt;Раздел 5.3&lt;/a&gt; ) или директиву ответа о максимальном возрасте ( &lt;a href=&quot;#section-5.2.2.8&quot;&gt;раздел 5.2.2.8&lt;/a&gt; ). Как правило, исходные серверы назначают будущее явное время истечения для ответов, полагая, что представление вряд ли изменится семантически значимым образом до того, как истечет время истечения. Если исходный сервер желает заставить кеш проверять каждый запрос, он может назначить явное время истечения срока в прошлом, чтобы указать, что ответ уже устарел. Совместимые кеши обычно проверяют устаревший кэшированный ответ перед его повторным использованием для последующих запросов (см. &lt;a href=&quot;#section-4.2.4&quot;&gt;Раздел 4.2.4.&lt;/a&gt;). Поскольку исходные серверы не всегда предоставляют явное время истечения срока действия, кэшам также разрешено использовать эвристику для определения срока истечения при определенных обстоятельствах (см. &lt;a href=&quot;#section-4.2.2&quot;&gt;Раздел 4.2.2&lt;/a&gt; ). Вычисление для определения, является ли ответ свежим: response_is_fresh = (freshness_lifetime&amp;gt; current_age) freshness_lifetime определено в &lt;a href=&quot;#section-4.2.1&quot;&gt;Разделе 4.2.1&lt;/a&gt; ; current_age определен в &lt;a href=&quot;#section-4.2.3&quot;&gt;разделе 4.2.3&lt;/a&gt; . Клиенты могут отправлять директивы кэша max-age или min-fresh в запросе, чтобы ограничить или ослабить вычисления актуальности для соответствующего ответа ( &lt;a href=&quot;#section-5.2.1&quot;&gt;раздел 5.2.1).&lt;/a&gt;). При вычислении актуальности, чтобы избежать распространенных проблем при синтаксическом анализе даты: o Хотя все форматы даты указаны с учетом регистра, получатель кеша ДОЛЖЕН сопоставлять имена дней, недель и часовых поясов без учета регистра. o Если внутренняя реализация времени получателя кэша имеет меньшее разрешение, чем значение HTTP-date, получатель ДОЛЖЕН внутренне представлять проанализированную дату истечения срока как ближайшее время, равное полученному значению или предшествующее ему. o Получатель кэша НЕ ДОЛЖЕН позволять местным часовым поясам влиять на расчет или сравнение возраста или срока действия. o Получатель кеша ДОЛЖЕН считать дату с аббревиатурой зоны, отличной от GMT или UTC, недопустимой для расчета срока действия. Обратите внимание, что актуальность применяется только к операции с кешем;его нельзя использовать, чтобы заставить пользовательский агент обновить свое отображение или перезагрузить ресурс. Видеть&lt;a href=&quot;#section-6&quot;&gt;Раздел 6&lt;/a&gt; для объяснения разницы между кешами и механизмами истории.</target>
        </trans-unit>
        <trans-unit id="ec3a4e1f8c0ddeb70da974b4f25090860679d57c" translate="yes" xml:space="preserve">
          <source>A full language tag. In addition to the language itself, it may contain additional information after a &lt;code&gt;'-'&lt;/code&gt;. The most common extra information is the country variant (like &lt;code&gt;'en-US'&lt;/code&gt;) or the type of alphabet to use (like &lt;code&gt;'sr-Lat'&lt;/code&gt;). Other variants like the type of orthography (&lt;code&gt;'de-DE-1996'&lt;/code&gt;) are usually not used in the context of this header.</source>
          <target state="translated">Полный языковой тег. Помимо самого языка, он может содержать дополнительную информацию после &lt;code&gt;'-'&lt;/code&gt; . Наиболее распространенной дополнительной информацией является вариант страны (например &lt;code&gt;'en-US'&lt;/code&gt; ) или тип используемого алфавита (например &lt;code&gt;'sr-Lat'&lt;/code&gt; ). Другие варианты, такие как тип орфографии ( &lt;code&gt;'de-DE-1996'&lt;/code&gt; ), обычно не используются в контексте этого заголовка.</target>
        </trans-unit>
        <trans-unit id="9f898e90d14bf75f1a87a64bdb376f6dbabf567d" translate="yes" xml:space="preserve">
          <source>A general warning field containing information about possible problems.</source>
          <target state="translated">Общее поле предупреждения,содержащее информацию о возможных проблемах.</target>
        </trans-unit>
        <trans-unit id="0a3e8915e8c75e5f7d73ca07d7035d1049a05c98" translate="yes" xml:space="preserve">
          <source>A language expressed as a 2 or 3-character string.</source>
          <target state="translated">Язык,выраженный в виде 2-х или 3-х символьной строки.</target>
        </trans-unit>
        <trans-unit id="746b4aed00138f5979b1e170746db262eb836c96" translate="yes" xml:space="preserve">
          <source>A language tag (which is sometimes referred to as a &quot;locale identifier&quot;). This consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by &lt;code&gt;'-'&lt;/code&gt;. The most common extra information is the country or region variant (like &lt;code&gt;'en-US'&lt;/code&gt; or &lt;code&gt;'fr-CA'&lt;/code&gt;) or the type of alphabet to use (like &lt;code&gt;'sr-Latn'&lt;/code&gt;). Other variants like the type of orthography (&lt;code&gt;'de-DE-1996'&lt;/code&gt;) are usually not used in the context of this header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492fb7060c509851f8ee1f0684fc115667c9e3f7" translate="yes" xml:space="preserve">
          <source>A language tag identifies a natural language spoken, written, or
   otherwise conveyed by human beings for communication of information
   to other human beings. Computer languages are explicitly excluded.
   HTTP uses language tags within the Accept-Language and Content-
   Language fields.

   The syntax and registry of HTTP language tags is the same as that
   defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;RFC 1766&lt;/a&gt; [&lt;a href=&quot;#ref-1&quot;&gt;1&lt;/a&gt;]. In summary, a language tag is composed of 1
   or more parts: A primary language tag and a possibly empty series of
   subtags:

        language-tag  = primary-tag *( &quot;-&quot; subtag )
        primary-tag   = 1*8ALPHA
        subtag        = 1*8ALPHA

   White space is not allowed within the tag and all tags are case-
   insensitive. The name space of language tags is administered by the
   IANA. Example tags include:

       en, en-US, en-cockney, i-cherokee, x-pig-latin 

   where any two-letter primary-tag is an ISO-639 language abbreviation
   and any two-letter initial subtag is an ISO-3166 country code. (The
   last three tags above are not registered tags; all but the last are
   examples of tags which could be registered in future.)</source>
          <target state="translated">Языковой тег идентифицирует естественный язык, на котором говорят, пишутся или иным образом передаются людьми для передачи информации другим людям. Компьютерные языки явно исключены. HTTP использует языковые теги в полях Accept-Language и Content-Language. Синтаксис и реестр языковых тегов HTTP такие же, как и в &lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;RFC 1766&lt;/a&gt; [ &lt;a href=&quot;#ref-1&quot;&gt;1&lt;/a&gt;]. Таким образом, языковой тег состоит из 1 или более частей: основного языкового тега и, возможно, пустой серии вложенных тегов: language-tag = primary-tag * (&quot;-&quot; вложенный тег) primary-tag = 1 * 8 ALPHA subtag = 1 * 8ALPHA Пробелы в теге не допускаются, и все теги нечувствительны к регистру. Пространство имен языковых тегов администрируется IANA. Примеры тегов: en, en-US, en-cockney, i-cherokee, x-pig-latin, где любой двухбуквенный первичный тег - это аббревиатура языка ISO-639, а любой двухбуквенный начальный подтег - это ISO-3166. код страны. (Последние три тега выше не являются зарегистрированными тегами; все, кроме последнего, являются примерами тегов, которые могут быть зарегистрированы в будущем.)</target>
        </trans-unit>
        <trans-unit id="94092a3bb36b69c98b3f284dcd812139e3cd4535" translate="yes" xml:space="preserve">
          <source>A language tag, as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5646&quot;&gt;RFC5646&lt;/a&gt;], identifies a natural
   language spoken, written, or otherwise conveyed by human beings for
   communication of information to other human beings.  Computer
   languages are explicitly excluded.

   HTTP uses language tags within the Accept-Language and
   Content-Language header fields.  Accept-Language uses the broader
   language-range production defined in &lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt;, whereas
   Content-Language uses the language-tag production defined below.

     language-tag = &amp;lt;Language-Tag, see &lt;a href=&quot;https://tools.ietf.org/html/rfc5646#section-2.1&quot;&gt;[RFC5646], Section&amp;nbsp;2.1&lt;/a&gt;&amp;gt;

   A language tag is a sequence of one or more case-insensitive subtags,
   each separated by a hyphen character (&quot;-&quot;, %x2D).  In most cases, a
   language tag consists of a primary language subtag that identifies a
   broad family of related languages (e.g., &quot;en&quot; = English), which is
   optionally followed by a series of subtags that refine or narrow that
   language's range (e.g., &quot;en-CA&quot; = the variety of English as
   communicated in Canada).  Whitespace is not allowed within a language
   tag.  Example tags include:

     fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN

   See [&lt;a href=&quot;https://tools.ietf.org/html/rfc5646&quot;&gt;RFC5646&lt;/a&gt;] for further information.</source>
          <target state="translated">Языковой тег, как определено в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5646&quot;&gt;RFC5646&lt;/a&gt; ], идентифицирует естественный язык, на котором говорят, пишутся или иным образом передаются людьми для передачи информации другим людям. Компьютерные языки явно исключены. HTTP использует языковые теги в полях заголовка Accept-Language и Content-Language. Accept-Language использует продукцию более широкого диапазона языков, определенную в &lt;a href=&quot;#section-5.3.5&quot;&gt;Разделе 5.3.5&lt;/a&gt; , тогда как Content-Language использует продукцию языковых тегов, определенную ниже. language-tag = &amp;lt;Language-Tag, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc5646#section-2.1&quot;&gt;[RFC5646], раздел 2.1.&lt;/a&gt;&amp;gt; Языковой тег - это последовательность из одного или нескольких вложенных тегов без учета регистра, каждый из которых разделен знаком дефиса (&quot;-&quot;,% x2D). В большинстве случаев языковой тег состоит из вложенного тега основного языка, который идентифицирует широкую группу родственных языков (например, &quot;en&quot; = английский), за которым необязательно следует ряд вложенных тегов, которые уточняют или сужают диапазон этого языка (например, &quot;en-CA&quot; = разновидность английского языка, используемая в Канаде). В языковом теге нельзя использовать пробелы. Примеры тегов: fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN См. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5646&quot;&gt;RFC5646&lt;/a&gt; ] для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="e661c244f36d3503b3fccce131704ef80b3983c9" translate="yes" xml:space="preserve">
          <source>A large header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) can cause an implementation to
   commit a large amount of state.  Header fields that are critical for
   routing can appear toward the end of a header block, which prevents
   streaming of header fields to their ultimate destination.  This
   ordering and other reasons, such as ensuring cache correctness, mean 

   that an endpoint might need to buffer the entire header block.  Since
   there is no hard limit to the size of a header block, some endpoints
   could be forced to commit a large amount of available memory for
   header fields.

   An endpoint can use the SETTINGS_MAX_HEADER_LIST_SIZE to advise peers
   of limits that might apply on the size of header blocks.  This
   setting is only advisory, so endpoints MAY choose to send header
   blocks that exceed this limit and risk having the request or response
   being treated as malformed.  This setting is specific to a
   connection, so any request or response could encounter a hop with a
   lower, unknown limit.  An intermediary can attempt to avoid this
   problem by passing on values presented by different peers, but they
   are not obligated to do so.

   A server that receives a larger header block than it is willing to
   handle can send an HTTP 431 (Request Header Fields Too Large) status
   code [&lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC6585&lt;/a&gt;].  A client can discard responses that it cannot
   process.  The header block MUST be processed to ensure a consistent
   connection state, unless the connection is closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f7a702b8c7697ca25eba936c967f0eb503afb30" translate="yes" xml:space="preserve">
          <source>A list of exposed headers consisting of zero or more &lt;a href=&quot;../headers&quot;&gt;header names&lt;/a&gt; other than the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header&quot;&gt;CORS-safelisted request headers&lt;/a&gt; that the resource might use and can be exposed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401eed78acd05f98cd45899dd71bdbf7ded19951" translate="yes" xml:space="preserve">
          <source>A list of exposed headers consisting of zero or more &lt;a href=&quot;../headers&quot;&gt;header names&lt;/a&gt; other than the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Simple_response_header&quot;&gt;simple response headers&lt;/a&gt; that the resource might use and can be exposed.</source>
          <target state="translated">Список открытых заголовков, состоящий из нуля или более &lt;a href=&quot;../headers&quot;&gt;имен заголовков,&lt;/a&gt; кроме &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Simple_response_header&quot;&gt;простых заголовков ответов,&lt;/a&gt; которые ресурс может использовать и которые могут быть представлены.</target>
        </trans-unit>
        <trans-unit id="a086a61548ed72dd4794fb8ac5f997765cb5cd7d" translate="yes" xml:space="preserve">
          <source>A list of name-value pairs in the form of &lt;code&gt;&amp;lt;cookie-name&amp;gt;=&amp;lt;cookie-value&amp;gt;&lt;/code&gt;. Pairs in the list are separated by a semicolon and a space (&lt;code&gt;'; '&lt;/code&gt;).</source>
          <target state="translated">Список пар имя-значение в виде &lt;code&gt;&amp;lt;cookie-name&amp;gt;=&amp;lt;cookie-value&amp;gt;&lt;/code&gt; . Пары в списке разделяются точкой с запятой и пробелом ( &lt;code&gt;'; '&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="201228fcd5cdd61ee1713b535c51e93b617c9561" translate="yes" xml:space="preserve">
          <source>A lock MAY have a limited lifetime.  The lifetime is suggested by the
   client when creating or refreshing the lock, but the server
   ultimately chooses the timeout value.  Timeout is measured in seconds
   remaining until lock expiration.

   The timeout counter MUST be restarted if a refresh lock request is
   successful (see &lt;a href=&quot;#section-9.10.2&quot;&gt;Section 9.10.2&lt;/a&gt;).  The timeout counter SHOULD NOT be
   restarted at any other time.

   If the timeout expires, then the lock SHOULD be removed.  In this
   case the server SHOULD act as if an UNLOCK method was executed by the 

   server on the resource using the lock token of the timed-out lock,
   performed with its override authority.

   Servers are advised to pay close attention to the values submitted by
   clients, as they will be indicative of the type of activity the
   client intends to perform.  For example, an applet running in a
   browser may need to lock a resource, but because of the instability
   of the environment within which the applet is running, the applet may
   be turned off without warning.  As a result, the applet is likely to
   ask for a relatively small timeout value so that if the applet dies,
   the lock can be quickly harvested.  However, a document management
   system is likely to ask for an extremely long timeout because its
   user may be planning on going offline.

   A client MUST NOT assume that just because the timeout has expired,
   the lock has immediately been removed.

   Likewise, a client MUST NOT assume that just because the timeout has
   not expired, the lock still exists.  Clients MUST assume that locks
   can arbitrarily disappear at any time, regardless of the value given
   in the Timeout header.  The Timeout header only indicates the
   behavior of the server if extraordinary circumstances do not occur.
   For example, a sufficiently privileged user may remove a lock at any
   time, or the system may crash in such a way that it loses the record
   of the lock's existence.</source>
          <target state="translated">Замок МОЖЕТ иметь ограниченный срок службы. Время жизни предлагается клиентом при создании или обновлении блокировки, но в конечном итоге сервер выбирает значение тайм-аута. Тайм-аут измеряется в секундах, оставшихся до истечения срока действия блокировки. Счетчик тайм-аута ДОЛЖЕН быть перезапущен, если запрос на обновление блокировки был успешным (см. &lt;a href=&quot;#section-9.10.2&quot;&gt;Раздел 9.10.2).&lt;/a&gt;). Счетчик тайм-аута НЕ ДОЛЖЕН перезапускаться в любое другое время. Если время ожидания истекает, блокировку СЛЕДУЕТ снять. В этом случае серверу СЛЕДУЕТ действовать так, как если бы метод UNLOCK был выполнен сервером на ресурсе с использованием маркера блокировки блокировки с тайм-аутом, выполненной с его полномочиями отмены. Серверам рекомендуется обращать пристальное внимание на значения, представленные клиентами, поскольку они будут указывать на тип активности, которую клиент намеревается выполнять. Например, апплет, работающий в браузере, может нуждаться в блокировке ресурса, но из-за нестабильности среды, в которой работает апплет, апплет может быть отключен без предупреждения. В результате апплет, вероятно, запросит относительно небольшое значение тайм-аута, так что, если апплет умирает, блокировка может быть быстро снята.Однако система управления документами может запросить очень долгий тайм-аут, потому что ее пользователь может планировать отключение. Клиент НЕ ДОЛЖЕН предполагать, что блокировка была немедленно снята только по истечении времени ожидания. Аналогичным образом, клиент НЕ ДОЛЖЕН предполагать, что блокировка все еще существует только потому, что время ожидания не истекло. Клиенты ДОЛЖНЫ предполагать, что блокировки могут произвольно исчезнуть в любое время, независимо от значения, указанного в заголовке Timeout. Заголовок Timeout указывает на поведение сервера только в том случае, если не возникают чрезвычайные обстоятельства. Например, достаточно привилегированный пользователь может снять блокировку в любое время, или система может дать сбой, что приведет к потере записи о существовании блокировки.система управления документами может запросить очень долгий таймаут, потому что ее пользователь может планировать отключение. Клиент НЕ ДОЛЖЕН предполагать, что только по истечении тайм-аута блокировка была немедленно снята. Аналогичным образом, клиент НЕ ДОЛЖЕН предполагать, что блокировка все еще существует только потому, что время ожидания не истекло. Клиенты ДОЛЖНЫ предполагать, что блокировки могут произвольно исчезнуть в любое время, независимо от значения, указанного в заголовке Timeout. Заголовок Timeout указывает на поведение сервера только в том случае, если не возникают чрезвычайные обстоятельства. Например, достаточно привилегированный пользователь может снять блокировку в любое время, или система может дать сбой, что приведет к потере записи о существовании блокировки.система управления документами может запросить очень долгий таймаут, потому что ее пользователь может планировать отключение. Клиент НЕ ДОЛЖЕН предполагать, что только по истечении тайм-аута блокировка была немедленно снята. Аналогичным образом, клиент НЕ ДОЛЖЕН предполагать, что блокировка все еще существует только потому, что время ожидания не истекло. Клиенты ДОЛЖНЫ предполагать, что блокировки могут произвольно исчезнуть в любое время, независимо от значения, указанного в заголовке Timeout. Заголовок Timeout указывает на поведение сервера только в том случае, если не возникают чрезвычайные обстоятельства. Например, достаточно привилегированный пользователь может снять блокировку в любое время, или система может дать сбой, что приведет к потере записи о существовании блокировки.Клиент НЕ ДОЛЖЕН предполагать, что только по истечении тайм-аута блокировка была немедленно снята. Аналогичным образом, клиент НЕ ДОЛЖЕН предполагать, что блокировка все еще существует только потому, что время ожидания не истекло. Клиенты ДОЛЖНЫ предполагать, что блокировки могут произвольно исчезнуть в любое время, независимо от значения, указанного в заголовке Timeout. Заголовок Timeout указывает на поведение сервера только в том случае, если не возникают чрезвычайные обстоятельства. Например, достаточно привилегированный пользователь может снять блокировку в любое время, или система может дать сбой, что приведет к потере записи о существовании блокировки.Клиент НЕ ДОЛЖЕН предполагать, что только по истечении тайм-аута блокировка была немедленно снята. Аналогичным образом, клиент НЕ ДОЛЖЕН предполагать, что блокировка все еще существует только потому, что время ожидания не истекло. Клиенты ДОЛЖНЫ предполагать, что блокировки могут произвольно исчезнуть в любое время, независимо от значения, указанного в заголовке Timeout. Заголовок Timeout указывает на поведение сервера только в том случае, если не возникают чрезвычайные обстоятельства. Например, достаточно привилегированный пользователь может снять блокировку в любое время, или система может дать сбой, что приведет к потере записи о существовании блокировки.Клиенты ДОЛЖНЫ предполагать, что блокировки могут произвольно исчезнуть в любое время, независимо от значения, указанного в заголовке Timeout. Заголовок Timeout указывает на поведение сервера только в том случае, если не возникают чрезвычайные обстоятельства. Например, достаточно привилегированный пользователь может снять блокировку в любое время, или система может дать сбой, что приведет к потере записи о существовании блокировки.Клиенты ДОЛЖНЫ предполагать, что блокировки могут произвольно исчезнуть в любое время, независимо от значения, указанного в заголовке Timeout. Заголовок Timeout указывает на поведение сервера только в том случае, если не возникают чрезвычайные обстоятельства. Например, достаточно привилегированный пользователь может снять блокировку в любое время, или система может дать сбой, что приведет к потере записи о существовании блокировки.</target>
        </trans-unit>
        <trans-unit id="a65767371978fb7907be1bc9f3cea569719dbaa4" translate="yes" xml:space="preserve">
          <source>A lock is refreshed by sending a LOCK request to the URL of a
   resource within the scope of the lock.  This request MUST NOT have a
   body and it MUST specify which lock to refresh by using the 'If'
   header with a single lock token (only one lock may be refreshed at a
   time).  The request MAY contain a Timeout header, which a server MAY
   accept to change the duration remaining on the lock to the new value.
   A server MUST ignore the Depth header on a LOCK refresh.

   If the resource has other (shared) locks, those locks are unaffected
   by a lock refresh.  Additionally, those locks do not prevent the
   named lock from being refreshed.

   The Lock-Token header is not returned in the response for a
   successful refresh LOCK request, but the LOCK response body MUST
   contain the new value for the DAV:lockdiscovery property.</source>
          <target state="translated">Блокировка обновляется путем отправки запроса на БЛОКИРОВКУ на URL ресурса,находящегося в пределах блокировки.Этот запрос НЕ ДОЛЖЕН иметь тело,и он ДОЛЖЕН указывать,какой замок обновлять,используя заголовок 'If' с одним маркером блокировки (только один замок может обновляться одновременно).Запрос MAY содержит заголовок Timeout,который сервер MAY принимает для изменения длительности оставшейся в блокировке длительности на новое значение.Сервер ДОЛЖЕН игнорировать заголовок Depth при обновлении LOCK.Если у ресурса есть другие (общие)блокировки,то эти блокировки не зависят от обновления блокировки.Кроме того,эти замки не препятствуют обновлению именованного замка.Заголовок Lock-Token не возвращается в ответе на успешный запрос обновления LOCK,но тело ответа LOCK ДОЛЖНО содержать новое значение для свойства DAV:lockdiscovery.</target>
        </trans-unit>
        <trans-unit id="2d1c6621f1a90b5ee7c672cc60c74be33fafb4aa" translate="yes" xml:space="preserve">
          <source>A lock token is a type of state token that identifies a particular
   lock.  Each lock has exactly one unique lock token generated by the
   server.  Clients MUST NOT attempt to interpret lock tokens in any
   way.

   Lock token URIs MUST be unique across all resources for all time.
   This uniqueness constraint allows lock tokens to be submitted across
   resources and servers without fear of confusion.  Since lock tokens
   are unique, a client MAY submit a lock token in an If header on a
   resource other than the one that returned it.

   When a LOCK operation creates a new lock, the new lock token is
   returned in the Lock-Token response header defined in &lt;a href=&quot;#section-10.5&quot;&gt;Section 10.5&lt;/a&gt;,
   and also in the body of the response.

   Servers MAY make lock tokens publicly readable (e.g., in the DAV:
   lockdiscovery property).  One use case for making lock tokens
   readable is so that a long-lived lock can be removed by the resource
   owner (the client that obtained the lock might have crashed or
   disconnected before cleaning up the lock).  Except for the case of
   using UNLOCK under user guidance, a client SHOULD NOT use a lock
   token created by another client instance.

   This specification encourages servers to create Universally Unique
   Identifiers (UUIDs) for lock tokens, and to use the URI form defined
   by &quot;A Universally Unique Identifier (UUID) URN Namespace&quot;
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt;]).  However, servers are free to use any URI (e.g., from
   another scheme) so long as it meets the uniqueness requirements.  For
   example, a valid lock token might be constructed using the
   &quot;opaquelocktoken&quot; scheme defined in &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;.

   Example: &quot;urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6&quot;</source>
          <target state="translated">Токен блокировки - это тип токена состояния, который идентифицирует конкретную блокировку. Каждая блокировка имеет ровно один уникальный токен блокировки, созданный сервером. Клиенты НЕ ДОЛЖНЫ каким-либо образом пытаться интерпретировать токены блокировки. URI токена блокировки ДОЛЖНЫ быть уникальными для всех ресурсов во все времена. Это ограничение уникальности позволяет отправлять токены блокировки между ресурсами и серверами, не опасаясь путаницы. Поскольку токены блокировки уникальны, клиент МОЖЕТ отправить токен блокировки в заголовке If на ресурсе, отличном от того, который его вернул. Когда операция LOCK создает новую блокировку, новый токен блокировки возвращается в заголовке ответа Lock-Token, определенном в &lt;a href=&quot;#section-10.5&quot;&gt;Разделе 10.5.&lt;/a&gt;, а также в теле ответа. Серверы МОГУТ сделать токены блокировки общедоступными (например, в свойстве DAV: lockdiscovery). Один из вариантов использования токенов блокировки для чтения состоит в том, что долгоживущая блокировка может быть удалена владельцем ресурса (клиент, получивший блокировку, мог дать сбой или отключиться до очистки блокировки). За исключением случая использования UNLOCK под руководством пользователя, клиент НЕ ДОЛЖЕН использовать токен блокировки, созданный другим экземпляром клиента. Эта спецификация поощряет серверы создавать универсальные уникальные идентификаторы (UUID) для токенов блокировки и использовать форму URI, определенную &amp;laquo;пространством имен URN универсального уникального идентификатора (UUID)&amp;raquo; ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt;]). Однако серверы могут использовать любой URI (например, из другой схемы), если он соответствует требованиям уникальности. Например, действительный маркер блокировки может быть построен с использованием &amp;laquo;opaquelocktoken&amp;raquo; схемы , определенной в &lt;a href=&quot;#appendix-C&quot;&gt;приложении C&lt;/a&gt; . Пример: &quot;urn: uuid: f81d4fae-7dec-11d0-a765-00a0c91e6bf6&quot;</target>
        </trans-unit>
        <trans-unit id="38e28447330e8077fc8cab54715d0f561c86ebbf" translate="yes" xml:space="preserve">
          <source>A machine-usable email address.</source>
          <target state="translated">Машинный адрес электронной почты.</target>
        </trans-unit>
        <trans-unit id="638122c7d8d04d744e55be1901fffac264110971" translate="yes" xml:space="preserve">
          <source>A malformed request or response is one that is an otherwise valid
   sequence of HTTP/2 frames but is invalid due to the presence of
   extraneous frames, prohibited header fields, the absence of mandatory
   header fields, or the inclusion of uppercase header field names.

   A request or response that includes a payload body can include a
   content-length header field.  A request or response is also malformed
   if the value of a content-length header field does not equal the sum
   of the DATA frame payload lengths that form the body.  A response
   that is defined to have no payload, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;[RFC7230],
   Section&amp;nbsp;3.3.2&lt;/a&gt;, can have a non-zero content-length header field, even
   though no content is included in DATA frames.

   Intermediaries that process HTTP requests or responses (i.e., any
   intermediary not acting as a tunnel) MUST NOT forward a malformed
   request or response.  Malformed requests or responses that are
   detected MUST be treated as a stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   For malformed requests, a server MAY send an HTTP response prior to
   closing or resetting the stream.  Clients MUST NOT accept a malformed
   response.  Note that these requirements are intended to protect
   against several types of common attacks against HTTP; they are
   deliberately strict because being permissive can expose
   implementations to these vulnerabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe425fac28cb48d5475051bae0bfe4902aafb25c" translate="yes" xml:space="preserve">
          <source>A message that encapsulates other messages. This can be used, for instance, to represent an email that includes a forwarded message as part of its data, or to allow sending very large messages in chunks as if it were multiple messages. Examples include &lt;code&gt;message/rfc822&lt;/code&gt; (for forwarded or replied-to message quoting) and &lt;code&gt;message/partial&lt;/code&gt; to allow breaking a large message into smaller ones automatically to be reassembled by the recipient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e534d830d6d1a4baaca41c124f70dc5dd2676c60" translate="yes" xml:space="preserve">
          <source>A method other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is used, or if &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is used with a &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;&lt;strong&gt;other than&lt;/strong&gt; one of &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain&lt;/code&gt;. For instance, if the &lt;code&gt;Content-Type&lt;/code&gt; of the &lt;code&gt;POST&lt;/code&gt; body is &lt;code&gt;application/xml&lt;/code&gt;, a request is preflighted.</source>
          <target state="translated">Используется метод, отличный от &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; , или если &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; используется с &lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; ,&lt;/a&gt;&lt;strong&gt; отличным&lt;/strong&gt; от &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; , &lt;code&gt;multipart/form-data&lt;/code&gt; или &lt;code&gt;text/plain&lt;/code&gt; . Например, если &lt;code&gt;Content-Type&lt;/code&gt; в &lt;code&gt;POST&lt;/code&gt; тела &lt;code&gt;application/xml&lt;/code&gt; , запрос preflighted.</target>
        </trans-unit>
        <trans-unit id="aed855bd7233b72a834c1273c05aff7651b0d47d" translate="yes" xml:space="preserve">
          <source>A more radical approach to cookies are zombie cookies or &quot;Evercookies&quot; which are recreated after their deletion and are intentionally hard to delete forever. They are using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API&quot;&gt;Web storage API&lt;/a&gt;, Flash Local Shared Objects and other techniques to recreate themselves whenever the cookie's absence is detected.</source>
          <target state="translated">Более радикальный подход к файлам cookie - это файлы cookie зомби или &amp;laquo;Evercookies&amp;raquo;, которые воссоздаются после их удаления и которые намеренно трудно удалить навсегда. Они используют &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API&quot;&gt;API веб-хранилища&lt;/a&gt; , Flash Local Shared Objects и другие методы для воссоздания себя всякий раз, когда обнаруживается отсутствие cookie.</target>
        </trans-unit>
        <trans-unit id="b6cbf91c7a233e2d92640564b32c98fc24c39369" translate="yes" xml:space="preserve">
          <source>A non-negative decimal integer indicating the seconds to delay after the response is received.</source>
          <target state="translated">Отрицательное десятичное число,указывающее на секунды задержки после получения ответа.</target>
        </trans-unit>
        <trans-unit id="6619a7d6c651e30a9c93d75a3aae971cdd6730a9" translate="yes" xml:space="preserve">
          <source>A non-negative integer, representing time in seconds the object has been in a proxy cache.</source>
          <target state="translated">Отрицательное целое число,представляющее время в секундах,в течение которого объект находился в кэше прокси-сервера.</target>
        </trans-unit>
        <trans-unit id="de5cdae960d879dbf9f2c82fb00f32d958dffa0f" translate="yes" xml:space="preserve">
          <source>A number of security issues (e.g. phishing) have been associated with data URLs, and navigating to them in the browser's top level. To mitigate such issues, top-level navigation to &lt;code&gt;data://&lt;/code&gt; URIs has been blocked in Firefox 59+ (release version, Nightly/Beta from 58), and we hope to see other browsers follow suit soon. &lt;a href=&quot;https://blog.mozilla.org/security/2017/11/27/blocking-top-level-navigations-data-urls-firefox-58/&quot;&gt;See Blocking Top-Level Navigations to data URLs for Firefox 58&lt;/a&gt; for more details.</source>
          <target state="translated">Ряд проблем безопасности (например, фишинг) был связан с URL-адресами данных и переходом к ним на верхнем уровне браузера. Чтобы смягчить такие проблемы, в Firefox 59+ (версия выпуска, Nightly / Beta с 58) была заблокирована навигация верхнего уровня к URI &lt;code&gt;data://&lt;/code&gt; , и мы надеемся, что скоро этому примеру последуют другие браузеры. &lt;a href=&quot;https://blog.mozilla.org/security/2017/11/27/blocking-top-level-navigations-data-urls-firefox-58/&quot;&gt;См. Раздел &amp;laquo;Блокировка навигации верхнего уровня по URL-адресам данных в Firefox 58&amp;raquo;&lt;/a&gt; для получения дополнительных сведений.</target>
        </trans-unit>
        <trans-unit id="141411a44840cd22ecb3eb10490b2fda0a7babf0" translate="yes" xml:space="preserve">
          <source>A number of security issues (e.g. phishing) have been associated with data URLs, and navigating to them in the browser's top level. To mitigate such issues, top-level navigation to &lt;code&gt;data://&lt;/code&gt; URLs has been blocked in Firefox 59+ (release version, Nightly/Beta from 58), and we hope to see other browsers follow suit soon. &lt;a href=&quot;https://blog.mozilla.org/security/2017/11/27/blocking-top-level-navigations-data-urls-firefox-58/&quot;&gt;See Blocking Top-Level Navigations to data URLs for Firefox 58&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11607966c4ade482e455f279b7d34f6602b327af" translate="yes" xml:space="preserve">
          <source>A number that indicates the client&amp;rsquo;s current Device Pixel Ratio (DPR), which is the ratio of physical pixels over CSS pixels (Section 5.2 of &lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html#CSSVAL&quot;&gt;&lt;cite&gt;[CSSVAL]&lt;/cite&gt;&lt;/a&gt;) of the layout viewport (Section 9.1.1 of &lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html#CSS2&quot;&gt;&lt;cite&gt;[CSS2]&lt;/cite&gt;&lt;/a&gt;) on the device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c02c1193cef8895bfcfd76fab36022e947d7a1b5" translate="yes" xml:space="preserve">
          <source>A number that indicates the layout viewport width in CSS pixels. The provided pixel value is a number rounded to the smallest following integer (i.e. ceiling value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b684cac1ea80ff01d85f8cdf2dbba122eead923" translate="yes" xml:space="preserve">
          <source>A number that indicates the ratio between physical pixels over CSS pixels of the selected image response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d140d340f4e2b728e728d3e54954e96ec6667988" translate="yes" xml:space="preserve">
          <source>A numerical value indicating whether the client wants to opt in to reduced data usage mode. &lt;code&gt;on&lt;/code&gt; indicates yes, while &lt;code&gt;off&lt;/code&gt; (the default) indicates no.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f80a5754b00a7b58692d532b283436fe5b8ce5" translate="yes" xml:space="preserve">
          <source>A path that must exist in the requested URL, or the browser won't send the &lt;code&gt;Cookie&lt;/code&gt; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650f390919a1e248d300f040459a60f3f5810f31" translate="yes" xml:space="preserve">
          <source>A peer can limit the number of concurrently active streams using the
   SETTINGS_MAX_CONCURRENT_STREAMS parameter (see &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;) within
   a SETTINGS frame.  The maximum concurrent streams setting is specific
   to each endpoint and applies only to the peer that receives the
   setting.  That is, clients specify the maximum number of concurrent
   streams the server can initiate, and servers specify the maximum
   number of concurrent streams the client can initiate.

   Streams that are in the &quot;open&quot; state or in either of the &quot;half-
   closed&quot; states count toward the maximum number of streams that an
   endpoint is permitted to open.  Streams in any of these three states
   count toward the limit advertised in the
   SETTINGS_MAX_CONCURRENT_STREAMS setting.  Streams in either of the
   &quot;reserved&quot; states do not count toward the stream limit.

   Endpoints MUST NOT exceed the limit set by their peer.  An endpoint
   that receives a HEADERS frame that causes its advertised concurrent
   stream limit to be exceeded MUST treat this as a stream error
   (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of type PROTOCOL_ERROR or REFUSED_STREAM.  The choice
   of error code determines whether the endpoint wishes to enable
   automatic retry (see &lt;a href=&quot;#section-8.1.4&quot;&gt;Section 8.1.4&lt;/a&gt;) for details).

   An endpoint that wishes to reduce the value of
   SETTINGS_MAX_CONCURRENT_STREAMS to a value that is below the current
   number of open streams can either close streams that exceed the new
   value or allow streams to complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4c8ac9e916c2f51a9f789cc3213dedde33771f" translate="yes" xml:space="preserve">
          <source>A persistent connection is one which remains open for a period of time, and can be reused for several requests, saving the need for a new TCP handshake, and utilizing TCP's performance enhancing capabilities. This connection will not stay open forever: idle connections are closed after some time (a server may use the &lt;a href=&quot;headers/keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt; header to specify a minimum time the connection should be kept open).</source>
          <target state="translated">Постоянное соединение - это соединение, которое остается открытым в течение определенного периода времени и может повторно использоваться для нескольких запросов, избавляя от необходимости в новом квитировании TCP и используя возможности TCP по повышению производительности. Это соединение не будет оставаться открытым навсегда: незанятые соединения закрываются через некоторое время (сервер может использовать заголовок &lt;a href=&quot;headers/keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; ,&lt;/a&gt; чтобы указать минимальное время, в течение которого соединение должно оставаться открытым).</target>
        </trans-unit>
        <trans-unit id="7f5964b3fdbddffba630fc173f336fc4d53d9c2d" translate="yes" xml:space="preserve">
          <source>A policy is described using a series of policy directives, each of which describes the policy for a certain resource type or policy area. Your policy should include a &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; policy directive, which is a fallback for other resource types when they don't have policies of their own (for a complete list, see the description of the &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive). A policy needs to include a &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/content-security-policy/script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive to prevent inline scripts from running, as well as blocking the use of &lt;code&gt;eval()&lt;/code&gt;. A policy needs to include a &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/content-security-policy/style-src&quot;&gt;&lt;code&gt;style-src&lt;/code&gt;&lt;/a&gt; directive to restrict inline styles from being applied from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element or a &lt;code&gt;style&lt;/code&gt; attribute.</source>
          <target state="translated">Политика описывается с помощью серии директив политики, каждая из которых описывает политику для определенного типа ресурса или области политики. Ваша политика должна включать директиву политики &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; , которая является резервным вариантом для других типов ресурсов, когда у них нет собственных политик (полный список см. В описании директивы &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; ). Политика должна включать директиву &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;headers/content-security-policy/script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt; для предотвращения запуска встроенных скриптов, а также для блокировки использования &lt;code&gt;eval()&lt;/code&gt; . Политика должна включать директиву &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;headers/content-security-policy/style-src&quot;&gt; &lt;code&gt;style-src&lt;/code&gt; ,&lt;/a&gt; чтобы ограничить применение встроенных стилей из элемента &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;style&lt;/code&gt; атрибут стиля .</target>
        </trans-unit>
        <trans-unit id="49ce15f1c7d8b0b9060e29949f31f97e8c869e2f" translate="yes" xml:space="preserve">
          <source>A policy is described using a series of policy directives, each of which describes the policy for a certain resource type or policy area. Your policy should include a &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; policy directive, which is a fallback for other resource types when they don't have policies of their own (for a complete list, see the description of the &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive). A policy needs to include a &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/content-security-policy/script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive to prevent inline scripts from running, as well as blocking the use of &lt;code&gt;eval()&lt;/code&gt;. A policy needs to include a &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/content-security-policy/style-src&quot;&gt;&lt;code&gt;style-src&lt;/code&gt;&lt;/a&gt; directive to restrict inline styles from being applied from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element or a &lt;code&gt;style&lt;/code&gt; attribute. There are specific directives for a wide variety of types of items, so that each type can have its own policy, including fonts, frames, images, audio and video media, scripts, and workers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3f38c5e6f98017e27ccd823e11fb4f53638759" translate="yes" xml:space="preserve">
          <source>A policy is described using a set of individual policy directives. A policy directive is a combination of a defined feature name, and an allowlist of origins that can use the feature.</source>
          <target state="translated">Политика описывается с помощью набора индивидуальных директив.Директива политики-это комбинация имени определенной функции и списка разрешенных источников,которые могут использовать эту функцию.</target>
        </trans-unit>
        <trans-unit id="96c2d8ce988407a2f35daa2b84e52da67848d1ab" translate="yes" xml:space="preserve">
          <source>A policy is described using a set of individual policy directives. A policy directive is a combination of a defined feature name, and an allowlist of origins that can use the feature. Features within a policy are separated by semicolons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f98b79f6a6f4ba906bbb9100d3b420de5ceeef" translate="yes" xml:space="preserve">
          <source>A potential security hole recently been fixed by browsers is authentication of cross-site images. From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/59&quot;&gt;Firefox 59&lt;/a&gt; onwards, image resources loaded from different origins to the current document are no longer able to trigger HTTP authentication dialogs (&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1423146&quot;&gt;bug 1423146&lt;/a&gt;), preventing user credentials being stolen if attackers were able to embed an arbitrary image into a third-party page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc1e2a64ac8cc70397584ab85d7a956880edca58" translate="yes" xml:space="preserve">
          <source>A potential security hole that has recently been fixed by browsers is authentication of cross-site images. From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/59&quot;&gt;Firefox 59&lt;/a&gt; onwards, image resources loaded from different origins to the current document are no longer able to trigger HTTP authentication dialogs (&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1423146&quot;&gt;bug 1423146&lt;/a&gt;), preventing user credentials being stolen if attackers were able to embed an arbitrary image into a third-party page.</source>
          <target state="translated">Потенциальная дыра в безопасности, которая недавно была исправлена ​​браузерами, - это аутентификация межсайтовых изображений. Начиная с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/59&quot;&gt;Firefox 59 и&lt;/a&gt; далее ресурсы изображений, загруженные из разных источников в текущий документ, больше не могут запускать диалоги HTTP-аутентификации ( &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1423146&quot;&gt;ошибка 1423146&lt;/a&gt; ), предотвращая кражу учетных данных пользователя, если злоумышленники смогли встроить произвольное изображение на стороннюю страницу.</target>
        </trans-unit>
        <trans-unit id="6365c5dff77a5f8170fa70a3b4adb72b11fd2b61" translate="yes" xml:space="preserve">
          <source>A primary goal of CSP is to mitigate and report XSS attacks. XSS attacks exploit the browser's trust of the content received from the server. Malicious scripts are executed by the victim's browser because the browser trusts the source of the content, even when it's not coming from where it seems to be coming from.</source>
          <target state="translated">Основной целью CSP является смягчение последствий атак XSS и информирование о них.XSS-атаки используют доверие браузера к контенту,получаемому с сервера.Вредоносные скрипты выполняются браузером жертвы,потому что браузер доверяет источнику контента,даже если он не исходит оттуда,откуда кажется,что он исходит.</target>
        </trans-unit>
        <trans-unit id="439d68646c04f15f6a1847145b2f1608413870b0" translate="yes" xml:space="preserve">
          <source>A private cache is dedicated to a single user. You might have seen &quot;caching&quot; in your browser's settings already. A browser cache holds all documents downloaded via &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; by the user. This cache is used to make visited documents available for back/forward navigation, saving, viewing-as-source, etc. without requiring an additional trip to the server. It likewise improves offline browsing of cached content.</source>
          <target state="translated">Частный кеш предназначен для одного пользователя. Возможно, вы уже видели &amp;laquo;кеширование&amp;raquo; в настройках вашего браузера. Кэш браузера содержит все документы, загруженные пользователем по &lt;a href=&quot;index&quot;&gt;протоколу HTTP&lt;/a&gt; . Этот кеш используется, чтобы сделать посещенные документы доступными для навигации назад / вперед, сохранения, просмотра в качестве источника и т. Д. Без необходимости дополнительной поездки на сервер. Это также улучшает автономный просмотр кэшированного содержимого.</target>
        </trans-unit>
        <trans-unit id="f82d2b7fb1e238df861eebe638d87bc4cf317285" translate="yes" xml:space="preserve">
          <source>A process for decoding the chunked transfer coding can be represented
   in pseudo-code as:

     length := 0
     read chunk-size, chunk-ext (if any), and CRLF
     while (chunk-size &amp;gt; 0) {
        read chunk-data and CRLF
        append chunk-data to decoded-body
        length := length + chunk-size
        read chunk-size, chunk-ext (if any), and CRLF
     }
     read trailer field
     while (trailer field is not empty) {
        if (trailer field is allowed to be sent in a trailer) {
            append trailer field to existing header fields
        }
        read trailer-field
     }
     Content-Length := length
     Remove &quot;chunked&quot; from Transfer-Encoding
     Remove Trailer from existing header fields</source>
          <target state="translated">Процесс декодирования кодирования фрагментированной передачи может быть представлен в псевдокоде как: length: = 0 read chunk-size, chunk-ext (если есть) и CRLF while (chunk-size&amp;gt; 0) {read chunk-data и CRLF добавляет данные фрагмента к длине декодированного тела: = длина + размер фрагмента чтения размер фрагмента, расширенный фрагмент (если есть) и CRLF} считывают поле трейлера, пока (поле трейлера не пусто) {if (поле трейлера равно разрешена для отправки в трейлере) {добавить поле трейлера к существующим полям заголовка} прочитать поле трейлера} Content-Length: = length Удалить фрагменты из Transfer-Encoding Удалить трейлер из существующих полей заголовка</target>
        </trans-unit>
        <trans-unit id="3433ae2d101b2c7bcd4c2dc4e1a13455c8f60c5d" translate="yes" xml:space="preserve">
          <source>A product identifier</source>
          <target state="translated">Идентификатор продукта</target>
        </trans-unit>
        <trans-unit id="9958c4830d3fc544adf2dd5f899a801d1f14198e" translate="yes" xml:space="preserve">
          <source>A product identifier &amp;mdash; its name or development codename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0885b17418737dcc207d3d7f9c2773976ecc3fe7" translate="yes" xml:space="preserve">
          <source>A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.</source>
          <target state="translated">Проект,призванный помочь разработчикам,системным администраторам и специалистам по безопасности безопасно и надежно настроить свои сайты.</target>
        </trans-unit>
        <trans-unit id="812c8d56ede89e043cd0d76837494a71cd36e6fd" translate="yes" xml:space="preserve">
          <source>A property name is a universally unique identifier that is associated
   with a schema that provides information about the syntax and
   semantics of the property.

   Because a property's name is universally unique, clients can depend
   upon consistent behavior for a particular property across multiple
   resources, on the same and across different servers, so long as that
   property is &quot;live&quot; on the resources in question, and the
   implementation of the live property is faithful to its definition.

   The XML namespace mechanism, which is based on URIs ([&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]), is
   used to name properties because it prevents namespace collisions and
   provides for varying degrees of administrative control.

   The property namespace is flat; that is, no hierarchy of properties
   is explicitly recognized.  Thus, if a property A and a property A/B
   exist on a resource, there is no recognition of any relationship
   between the two properties.  It is expected that a separate
   specification will eventually be produced that will address issues
   relating to hierarchical properties.

   Finally, it is not possible to define the same property twice on a
   single resource, as this would cause a collision in the resource's
   property namespace.</source>
          <target state="translated">Имя свойства - это универсальный уникальный идентификатор, связанный со схемой, которая предоставляет информацию о синтаксисе и семантике свойства. Поскольку имя свойства универсально уникально, клиенты могут зависеть от согласованного поведения конкретного свойства на нескольких ресурсах, на одном и том же и на разных серверах, пока это свойство &quot;живо&quot; на рассматриваемых ресурсах, и реализация live property соответствует своему определению. Механизм пространства имен XML, основанный на URI ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]) используется для именования свойств, поскольку он предотвращает конфликты пространств имен и обеспечивает различные степени административного контроля. Пространство имен свойств плоское; то есть никакая иерархия свойств не распознается явно. Таким образом, если свойство A и свойство A / B существуют в ресурсе, не распознается какая-либо связь между этими двумя свойствами. Ожидается, что в конечном итоге будет создана отдельная спецификация, в которой будут рассмотрены вопросы, касающиеся иерархических свойств. Наконец, невозможно определить одно и то же свойство дважды для одного ресурса, так как это может вызвать конфликт в пространстве имен свойств ресурса.</target>
        </trans-unit>
        <trans-unit id="6673520452754c10b992e04503b918fc10714c5c" translate="yes" xml:space="preserve">
          <source>A receiver that wishes to use a smaller flow-control window than the
   current size can send a new SETTINGS frame.  However, the receiver
   MUST be prepared to receive data that exceeds this window size, since
   the sender might send data that exceeds the lower limit prior to
   processing the SETTINGS frame.

   After sending a SETTINGS frame that reduces the initial flow-control
   window size, a receiver MAY continue to process streams that exceed
   flow-control limits.  Allowing streams to continue does not allow the
   receiver to immediately reduce the space it reserves for flow-control
   windows.  Progress on these streams can also stall, since
   WINDOW_UPDATE frames are needed to allow the sender to resume
   sending.  The receiver MAY instead send a RST_STREAM with an error
   code of FLOW_CONTROL_ERROR for the affected streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cacdba23a65a183495b790ee68fdf2145281249c" translate="yes" xml:space="preserve">
          <source>A recurring question among website owners is whether to choose non-www or www URLs. This page provides some advice on what's best.</source>
          <target state="translated">Среди владельцев сайтов постоянно возникает вопрос,следует ли выбирать не-www или www URL.На этой странице приведены некоторые советы о том,что лучше.</target>
        </trans-unit>
        <trans-unit id="7dfa1a7fc8e90c654961e3cd92ce898d60b0c079" translate="yes" xml:space="preserve">
          <source>A referrer will be sent for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-site origins&lt;/a&gt;, but cross-origin requests will contain no referrer information.</source>
          <target state="translated">Реферер будет отправлен для источников из &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;одного и того же сайта&lt;/a&gt; , но запросы на другие источники не будут содержать информации о реферере.</target>
        </trans-unit>
        <trans-unit id="9b6c9e53e2af534c3dcf745698dae9e91a4a2d0a" translate="yes" xml:space="preserve">
          <source>A referrer will be sent for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-site origins&lt;/a&gt;, but cross-origin requests will send no referrer information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae243fc787eed5f661f7ca1eba239db78ab53cd" translate="yes" xml:space="preserve">
          <source>A registration MUST include the following fields:

   o  Cache Directive Name 

   o  Pointer to specification text

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">Регистрация ДОЛЖНА включать следующие поля: o Имя директивы кэширования o Указатель на текст спецификации. Значения, добавляемые в это пространство имен, требуют &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;проверки&lt;/a&gt; IETF (см. [RFC5226], раздел 4.1 ).</target>
        </trans-unit>
        <trans-unit id="d53f7f5a3cccd3a8eb1b60f9e389fc08f9663236" translate="yes" xml:space="preserve">
          <source>A registration MUST include the following fields:

   o  Status Code (3 digits)

   o  Short Description

   o  Pointer to specification text

   Values to be added to the HTTP status code namespace require IETF
   Review (see &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">Регистрация ДОЛЖНА включать следующие поля: o Код состояния (3 цифры) o Краткое описание o Указатель на текст спецификации. Значения, добавляемые в пространство имен кода состояния HTTP, требуют &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;проверки&lt;/a&gt; IETF (см. [RFC5226], раздел 4.1 ).</target>
        </trans-unit>
        <trans-unit id="30a86ff2e17ce76a1f3b579485c7312a875e5283" translate="yes" xml:space="preserve">
          <source>A registration MUST include the following fields:

   o  Warn Code (3 digits)

   o  Short Description

   o  Pointer to specification text

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">Регистрация ДОЛЖНА включать следующие поля: o Код предупреждения (3 цифры) o Краткое описание o Указатель на текст спецификации Значения, добавляемые в это пространство имен, требуют &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;проверки&lt;/a&gt; IETF (см. [RFC5226], раздел 4.1 ).</target>
        </trans-unit>
        <trans-unit id="49d235161b5c7adbe95acaa5e39a723e244ff106" translate="yes" xml:space="preserve">
          <source>A related topic is the concept of HTTP connection upgrades, wherein an HTTP/1.1 connection is upgraded to a different protocol, such as TLS/1.0, WebSocket, or even HTTP/2 in cleartext. This &lt;a href=&quot;protocol_upgrade_mechanism&quot;&gt;protocol upgrade mechanism&lt;/a&gt; is documented in more detail elsewhere.</source>
          <target state="translated">Связанная тема - это концепция обновления HTTP-соединения, при которой соединение HTTP / 1.1 обновляется до другого протокола, такого как TLS / 1.0, WebSocket или даже HTTP / 2 в открытом виде. Этот &lt;a href=&quot;protocol_upgrade_mechanism&quot;&gt;механизм обновления протокола&lt;/a&gt; более подробно описан в другом месте.</target>
        </trans-unit>
        <trans-unit id="07d792622b2930c487cb661d9dfa70764d9bdce6" translate="yes" xml:space="preserve">
          <source>A relative (to the request URL) or absolute URL pointing to a source map file.</source>
          <target state="translated">Относительный (к URL запроса)или абсолютный URL,указывающий на файл исходной карты.</target>
        </trans-unit>
        <trans-unit id="04b17c6c33bdd43b6f562d0d41e6eb0e2aa2ab77" translate="yes" xml:space="preserve">
          <source>A relative (to the request URL) or absolute URL.</source>
          <target state="translated">Относительный (к URL запроса)или абсолютный URL.</target>
        </trans-unit>
        <trans-unit id="b2268a2e42421e9d441dc85b7260cf9456fb7200" translate="yes" xml:space="preserve">
          <source>A representation can be partitioned into subranges according to
   various structural units, depending on the structure inherent in the
   representation's media type.  This &quot;range unit&quot; is used in the
   Accept-Ranges (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;) response header field to advertise
   support for range requests, the Range (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;) request header
   field to delineate the parts of a representation that are requested,
   and the Content-Range (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;) payload header field to describe
   which part of a representation is being transferred.

     range-unit       = bytes-unit / other-range-unit</source>
          <target state="translated">Представление может быть разделено на поддиапазоны согласно различным структурным единицам, в зависимости от структуры, присущей типу носителя представления. Эта &amp;laquo;единица диапазона&amp;raquo; используется в поле заголовка ответа Accept-Ranges ( &lt;a href=&quot;#section-2.3&quot;&gt;раздел 2.3&lt;/a&gt; ) для рекламы поддержки запросов диапазона, в поле заголовка запроса Range ( &lt;a href=&quot;#section-3.1&quot;&gt;раздел 3.1&lt;/a&gt; ) для выделения запрошенных частей представления и в поле Content- Поле заголовка полезной нагрузки диапазона ( &lt;a href=&quot;#section-4.2&quot;&gt;раздел 4.2&lt;/a&gt; ) для описания того, какая часть представления передается. Единица диапазона = единица байтов / другая единица диапазона</target>
        </trans-unit>
        <trans-unit id="d71b4bd9a10e17cd95bbfd491a4aa1f6dbc4d2f2" translate="yes" xml:space="preserve">
          <source>A request message from a client to a server includes, within the
   first line of that message, the method to be applied to the resource,
   the identifier of the resource, and the protocol version in use.

        Request       = Request-Line              ; &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;
                        *(( general-header        ; &lt;a href=&quot;#section-4.5&quot;&gt;Section 4.5&lt;/a&gt;
                         | request-header         ; &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;
                         | entity-header ) CRLF)  ; &lt;a href=&quot;#section-7.1&quot;&gt;Section 7.1&lt;/a&gt;
                        CRLF
                        [ message-body ]          ; &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;</source>
          <target state="translated">Сообщение запроса от клиента к серверу включает в первой строке этого сообщения метод, который будет применен к ресурсу, идентификатор ресурса и версию используемого протокола. Запрос = строка запроса; &lt;a href=&quot;#section-5.1&quot;&gt;Раздел 5.1&lt;/a&gt; * ((общий заголовок; &lt;a href=&quot;#section-4.5&quot;&gt;Раздел 4.5&lt;/a&gt; | заголовок запроса; &lt;a href=&quot;#section-5.3&quot;&gt;Раздел 5.3&lt;/a&gt; | заголовок объекта) CRLF); &lt;a href=&quot;#section-7.1&quot;&gt;Раздел 7.1&lt;/a&gt; CRLF [тело сообщения]; &lt;a href=&quot;#section-4.3&quot;&gt;Раздел 4.3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d9fa92bb2a5449449d61328cb82bf9e89b926d4" translate="yes" xml:space="preserve">
          <source>A request method is considered &quot;idempotent&quot; if the intended effect on
   the server of multiple identical requests with that method is the
   same as the effect for a single such request.  Of the request methods
   defined by this specification, PUT, DELETE, and safe request methods
   are idempotent. 

   Like the definition of safe, the idempotent property only applies to
   what has been requested by the user; a server is free to log each
   request separately, retain a revision control history, or implement
   other non-idempotent side effects for each idempotent request.

   Idempotent methods are distinguished because the request can be
   repeated automatically if a communication failure occurs before the
   client is able to read the server's response.  For example, if a
   client sends a PUT request and the underlying connection is closed
   before any response is received, then the client can establish a new
   connection and retry the idempotent request.  It knows that repeating
   the request will have the same intended effect, even if the original
   request succeeded, though the response might differ.</source>
          <target state="translated">Способ запроса считается &quot;idempotent&quot;,если предполагаемое воздействие на сервер нескольких идентичных запросов с этим методом такое же,как и на один такой запрос.Из методов запроса,определенных данной спецификацией,PUT,DELETE и безопасные методы запроса являются &quot;idempotent&quot;.Как и определение сейфа,свойство idempotent применяется только к тому,что было запрошено пользователем;сервер может регистрировать каждый запрос отдельно,сохранять историю контроля ревизий или реализовывать другие неидемпотентные побочные эффекты для каждого запроса idempotent.Методы idempotent отличаются тем,что запрос может быть повторен автоматически,если сбой связи произошел до того,как клиент смог прочитать ответ сервера.Например,если клиент посылает PUT запрос,и основное соединение закрывается до получения ответа,то клиент может установить новое соединение и повторить запрос idempotent.Он знает,что повторение запроса будет иметь тот же эффект,даже если исходный запрос удался,хотя ответ может отличаться.</target>
        </trans-unit>
        <trans-unit id="546384726031738c999ae47dc3029524e1da7c86" translate="yes" xml:space="preserve">
          <source>A request that needs to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; was attempted, but CORS is disabled in the user's browser. When this happens, the user needs to turn CORS back on in their browser.</source>
          <target state="translated">Была предпринята попытка запроса, который должен использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; , но CORS отключен в браузере пользователя. Когда это происходит, пользователю необходимо снова включить CORS в своем браузере.</target>
        </trans-unit>
        <trans-unit id="58731bd968021ea09d9af4e515aa9201da338c9d" translate="yes" xml:space="preserve">
          <source>A request that upgrades from HTTP/1.1 to HTTP/2 MUST include exactly
   one &quot;HTTP2-Settings&quot; header field.  The HTTP2-Settings header field
   is a connection-specific header field that includes parameters that
   govern the HTTP/2 connection, provided in anticipation of the server
   accepting the request to upgrade.

     HTTP2-Settings    = token68 

   A server MUST NOT upgrade the connection to HTTP/2 if this header
   field is not present or if more than one is present.  A server MUST
   NOT send this header field.

   The content of the HTTP2-Settings header field is the payload of a
   SETTINGS frame (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;), encoded as a base64url string (that is,
   the URL- and filename-safe Base64 encoding described in &lt;a href=&quot;https://tools.ietf.org/html/rfc4648#section-5&quot;&gt;Section&amp;nbsp;5 of
   [RFC4648]&lt;/a&gt;, with any trailing '=' characters omitted).  The ABNF
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] production for &quot;token68&quot; is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of
   [RFC7235]&lt;/a&gt;.

   Since the upgrade is only intended to apply to the immediate
   connection, a client sending the HTTP2-Settings header field MUST
   also send &quot;HTTP2-Settings&quot; as a connection option in the Connection
   header field to prevent it from being forwarded (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of
   [RFC7230]&lt;/a&gt;).

   A server decodes and interprets these values as it would any other
   SETTINGS frame.  Explicit acknowledgement of these settings
   (&lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt;) is not necessary, since a 101 response serves as
   implicit acknowledgement.  Providing these values in the upgrade
   request gives a client an opportunity to provide parameters prior to
   receiving any frames from the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4fecdc1b419060578658673f7841f56391ef3c" translate="yes" xml:space="preserve">
          <source>A request-line begins with a method token, followed by a single space
   (SP), the request-target, another single space (SP), the protocol
   version, and ends with CRLF.

     request-line   = method SP request-target SP HTTP-version CRLF

   The method token indicates the request method to be performed on the
   target resource.  The request method is case-sensitive.

     method         = token

   The request methods defined by this specification can be found in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7231]&lt;/a&gt;, along with information regarding the HTTP
   method registry and considerations for defining new methods.

   The request-target identifies the target resource upon which to apply
   the request, as defined in &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;.

   Recipients typically parse the request-line into its component parts
   by splitting on whitespace (see &lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt;), since no whitespace is
   allowed in the three components.  Unfortunately, some user agents
   fail to properly encode or exclude whitespace found in hypertext
   references, resulting in those disallowed characters being sent in a
   request-target.

   Recipients of an invalid request-line SHOULD respond with either a
   400 (Bad Request) error or a 301 (Moved Permanently) redirect with
   the request-target properly encoded.  A recipient SHOULD NOT attempt
   to autocorrect and then process the request without a redirect, since
   the invalid request-line might be deliberately crafted to bypass
   security filters along the request chain.

   HTTP does not place a predefined limit on the length of a
   request-line, as described in &lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;.  A server that receives a
   method longer than any that it implements SHOULD respond with a 501
   (Not Implemented) status code.  A server that receives a 

   request-target longer than any URI it wishes to parse MUST respond
   with a 414 (URI Too Long) status code (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.12&quot;&gt;Section&amp;nbsp;6.5.12 of
   [RFC7231]&lt;/a&gt;).

   Various ad hoc limitations on request-line length are found in
   practice.  It is RECOMMENDED that all HTTP senders and recipients
   support, at a minimum, request-line lengths of 8000 octets.</source>
          <target state="translated">Строка запроса начинается с токена метода, за которым следует одиночный пробел (SP), цель запроса, еще один одиночный пробел (SP), версия протокола и заканчивается CRLF. строка-запроса = метод SP целевой-запрос SP HTTP-версия CRLF Маркер метода указывает метод запроса, который должен быть выполнен на целевом ресурсе. В методе запроса учитывается регистр. method = token Методы запроса, определенные этой спецификацией, можно найти в &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4&quot;&gt;разделе 4 [RFC7231]&lt;/a&gt; вместе с информацией о реестре методов HTTP и соображениями по определению новых методов. Цель запроса идентифицирует целевой ресурс, к которому следует применить запрос, как определено в &lt;a href=&quot;#section-5.3&quot;&gt;разделе 5.3.&lt;/a&gt;, Получатели обычно разбирают строку запроса на составные части, разделяя их на пробелы (см. &lt;a href=&quot;#section-3.5&quot;&gt;Раздел 3.5.&lt;/a&gt;), поскольку в трех компонентах не допускается использование пробелов. К сожалению, некоторые пользовательские агенты не могут правильно кодировать или исключать пробелы, обнаруженные в гипертекстовых ссылках, в результате чего эти запрещенные символы отправляются в цель запроса. Получатели недопустимой строки запроса ДОЛЖНЫ ответить либо ошибкой 400 (неверный запрос), либо перенаправлением 301 (перемещено навсегда) с правильно закодированной целью запроса. Получателю НЕ СЛЕДУЕТ пытаться выполнить автокоррекцию, а затем обработать запрос без перенаправления, так как недопустимая строка запроса может быть специально создана для обхода фильтров безопасности в цепочке запросов. HTTP не устанавливает предопределенных ограничений на длину строки запроса, как описано в &lt;a href=&quot;#section-2.5&quot;&gt;Разделе 2.5.&lt;/a&gt;, Серверу, который получает метод длиннее, чем любой, который он реализует, СЛЕДУЕТ ответить кодом состояния 501 (не реализовано). Сервер, который принимает цель запроса дольше любого URI, который он хочет проанализировать, ДОЛЖЕН ответить кодом состояния 414 (URI Too Long) (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.12&quot;&gt;Раздел 6.5.12 [RFC7231]&lt;/a&gt; ). На практике встречаются различные специальные ограничения на длину строки запроса. РЕКОМЕНДУЕТСЯ, чтобы все отправители и получатели HTTP поддерживали как минимум длину строки запроса 8000 октетов.</target>
        </trans-unit>
        <trans-unit id="7980e0e9f0bf2020cb5e958089632996a1336213" translate="yes" xml:space="preserve">
          <source>A resource can explicitly advertise its support for the revisions to
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] made in this document.  Class 1 MUST be supported as well.
   Class 2 MAY be supported.  Advertising class 3 support in addition to
   class 1 and 2 means that the server supports all the requirements in
   this specification.  Advertising class 3 and class 1 support, but not
   class 2, means that the server supports all the requirements in this
   specification except possibly those that involve locking support. 

   Example:

            DAV: 1, 3</source>
          <target state="translated">Ресурс может явно &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;заявить о&lt;/a&gt; своей поддержке изменений в [ RFC2518 ], внесенных в этот документ. Также ДОЛЖЕН поддерживаться класс 1. МОЖЕТ поддерживаться класс 2. Поддержка рекламы класса 3 в дополнение к классам 1 и 2 означает, что сервер поддерживает все требования данной спецификации. Реклама поддержки классов 3 и 1, но не класса 2, означает, что сервер поддерживает все требования данной спецификации, за исключением, возможно, тех, которые включают поддержку блокировок. Пример: DAV: 1, 3</target>
        </trans-unit>
        <trans-unit id="8f0b02bd6becb7e138339ca8cbce88e5c8dc9860" translate="yes" xml:space="preserve">
          <source>A response containing a &lt;code&gt;Keep-Alive&lt;/code&gt; header:</source>
          <target state="translated">Ответ, содержащий заголовок &lt;code&gt;Keep-Alive&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e3589c5d5733be22e8a4c793501192c7aeaaf910" translate="yes" xml:space="preserve">
          <source>A response containing one single range:</source>
          <target state="translated">Ответ,содержащий один единственный диапазон:</target>
        </trans-unit>
        <trans-unit id="d288a5da8b4ec025b38438ed09fb0060c6a676e8" translate="yes" xml:space="preserve">
          <source>A response containing several ranges:</source>
          <target state="translated">Ответ,содержащий несколько диапазонов:</target>
        </trans-unit>
        <trans-unit id="a0ee67e224ae11e90845c87f77f2fe7ec059fb94" translate="yes" xml:space="preserve">
          <source>A response message is considered complete when all of the octets
   indicated by the message framing ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]) are received prior to
   the connection being closed.  If the request method is GET, the
   response status code is 200 (OK), and the entire response header
   section has been received, a cache MAY store an incomplete response
   message body if the cache entry is recorded as incomplete.  Likewise,
   a 206 (Partial Content) response MAY be stored as if it were an
   incomplete 200 (OK) cache entry.  However, a cache MUST NOT store
   incomplete or partial-content responses if it does not support the
   Range and Content-Range header fields or if it does not understand
   the range units used in those fields.

   A cache MAY complete a stored incomplete response by making a
   subsequent range request ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]) and combining the successful
   response with the stored entry, as defined in &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;.  A cache
   MUST NOT use an incomplete response to answer requests unless the
   response has been made complete or the request is partial and
   specifies a range that is wholly within the incomplete response.  A
   cache MUST NOT send a partial response to a client without explicitly
   marking it as such using the 206 (Partial Content) status code.</source>
          <target state="translated">Ответное сообщение считается завершенным, если все октеты, указанные в &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;кадре&lt;/a&gt; сообщения ([ RFC7230]) принимаются до закрытия соединения. Если метод запроса - GET, код состояния ответа - 200 (OK), и весь раздел заголовка ответа был получен, кэш МОЖЕТ сохранить тело сообщения неполного ответа, если запись кэша записана как неполная. Точно так же ответ 206 (частичное содержимое) МОЖЕТ быть сохранен, как если бы он был неполной записью кэша 200 (ОК). Однако кэш НЕ ДОЛЖЕН хранить ответы с неполным или частичным содержимым, если он не поддерживает поля заголовка Range и Content-Range или если он не понимает единицы диапазона, используемые в этих полях. Кэш МОЖЕТ завершить сохраненный неполный ответ, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;выполнив&lt;/a&gt; последующий запрос диапазона ([ RFC7233 ]) и комбинируя успешный ответ с сохраненной записью, как определено в&lt;a href=&quot;#section-3.3&quot;&gt;Раздел 3.3&lt;/a&gt; . Кэш НЕ ДОЛЖЕН использовать неполный ответ для ответа на запросы, если ответ не был сделан полным или запрос не является частичным и не указывает диапазон, который полностью находится в пределах неполного ответа. Кэш НЕ ДОЛЖЕН отправлять частичный ответ клиенту без явной пометки его как такового с помощью кода состояния 206 (частичное содержимое).</target>
        </trans-unit>
        <trans-unit id="999a0c8fd82d7b5d2242dddbeb3edd70fcd18975" translate="yes" xml:space="preserve">
          <source>A response might transfer only a partial representation if the
   connection closed prematurely or if the request used one or more
   Range specifiers ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]).  After several such transfers, a cache
   might have received several ranges of the same representation.  A
   cache MAY combine these ranges into a single stored response, and
   reuse that response to satisfy later requests, if they all share the
   same strong validator and the cache complies with the client
   requirements in &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.3&quot;&gt;Section&amp;nbsp;4.3 of [RFC7233]&lt;/a&gt;.

   When combining the new response with one or more stored responses, a
   cache MUST:

   o  delete any Warning header fields in the stored response with
      warn-code 1xx (see &lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;);

   o  retain any Warning header fields in the stored response with
      warn-code 2xx; and,

   o  use other header fields provided in the new response, aside from
      Content-Range, to replace all instances of the corresponding
      header fields in the stored response.</source>
          <target state="translated">Ответ может передавать только частичное представление, если соединение закрылось преждевременно или если в запросе использовался один или несколько спецификаторов диапазона ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]). После нескольких таких передач кэш мог получить несколько диапазонов одного и того же представления. Кэш МОЖЕТ объединить эти диапазоны в один сохраненный ответ и повторно использовать этот ответ для удовлетворения последующих запросов, если все они используют один и тот же надежный валидатор и кеш соответствует требованиям клиента в &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.3&quot;&gt;разделе 4.3 [RFC7233]&lt;/a&gt; . При объединении нового ответа с одним или несколькими сохраненными ответами кэш ДОЛЖЕН: o удалить любые поля заголовка предупреждения в сохраненном ответе с кодом предупреждения 1xx (см. &lt;a href=&quot;#section-5.5&quot;&gt;Раздел 5.5.&lt;/a&gt;); o сохранить любые поля заголовка предупреждения в сохраненном ответе с кодом предупреждения 2xx; и o использовать другие поля заголовка, представленные в новом ответе, помимо Content-Range, для замены всех экземпляров соответствующих полей заголовка в сохраненном ответе.</target>
        </trans-unit>
        <trans-unit id="c70c6ad8d852190de6c159770119532624c086ed" translate="yes" xml:space="preserve">
          <source>A response might transfer only a subrange of a representation if the
   connection closed prematurely or if the request used one or more
   Range specifications.  After several such transfers, a client might
   have received several ranges of the same representation.  These
   ranges can only be safely combined if they all have in common the
   same strong validator (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC7232]&lt;/a&gt;).

   A client that has received multiple partial responses to GET requests
   on a target resource MAY combine those responses into a larger
   continuous range if they share the same strong validator.

   If the most recent response is an incomplete 200 (OK) response, then
   the header fields of that response are used for any combined response
   and replace those of the matching stored responses.

   If the most recent response is a 206 (Partial Content) response and
   at least one of the matching stored responses is a 200 (OK), then the
   combined response header fields consist of the most recent 200
   response's header fields.  If all of the matching stored responses
   are 206 responses, then the stored response with the most recent
   header fields is used as the source of header fields for the combined
   response, except that the client MUST use other header fields
   provided in the new response, aside from Content-Range, to replace
   all instances of the corresponding header fields in the stored
   response. 

   The combined response message body consists of the union of partial
   content ranges in the new response and each of the selected
   responses.  If the union consists of the entire range of the
   representation, then the client MUST process the combined response as
   if it were a complete 200 (OK) response, including a Content-Length
   header field that reflects the complete length.  Otherwise, the
   client MUST process the set of continuous ranges as one of the
   following: an incomplete 200 (OK) response if the combined response
   is a prefix of the representation, a single 206 (Partial Content)
   response containing a multipart/byteranges body, or multiple 206
   (Partial Content) responses, each with one continuous range that is
   indicated by a Content-Range header field.</source>
          <target state="translated">Ответ может передавать только поддиапазон представления, если соединение преждевременно закрыто или если запрос использовал одну или несколько спецификаций диапазона. После нескольких таких передач клиент мог получить несколько диапазонов одного и того же представления. Эти диапазоны можно безопасно комбинировать только в том случае, если все они имеют общий мощный валидатор ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.1&quot;&gt;раздел 2.1 [RFC7232]).&lt;/a&gt;). Клиент, получивший несколько частичных ответов на запросы GET на целевом ресурсе, МОЖЕТ объединить эти ответы в более широкий непрерывный диапазон, если они используют один и тот же надежный валидатор. Если самый последний ответ является неполным ответом 200 (ОК), то поля заголовка этого ответа используются для любого комбинированного ответа и заменяют поля совпадающих сохраненных ответов. Если самым последним ответом является ответ 206 (частичное содержимое) и по крайней мере один из совпадающих сохраненных ответов - 200 (ОК), то поля заголовка комбинированного ответа состоят из 200 полей заголовка последнего ответа. Если все совпадающие сохраненные ответы представляют собой 206 ответов, то сохраненный ответ с самыми последними полями заголовка используется в качестве источника полей заголовка для комбинированного ответа,за исключением того, что клиент ДОЛЖЕН использовать другие поля заголовка, представленные в новом ответе, помимо Content-Range, для замены всех экземпляров соответствующих полей заголовка в сохраненном ответе. Тело комбинированного ответного сообщения состоит из объединения частичных диапазонов содержимого в новом ответе и каждом из выбранных ответов. Если объединение состоит из всего диапазона представления, то клиент ДОЛЖЕН обработать объединенный ответ, как если бы он был полным ответом 200 (OK), включая поле заголовка Content-Length, которое отражает полную длину. В противном случае клиент ДОЛЖЕН обработать набор непрерывных диапазонов как одно из следующего: неполный ответ 200 (OK), если комбинированный ответ является префиксом представления,один ответ 206 (частичное содержимое), содержащий тело multipart / byteranges, или несколько ответов 206 (частичное содержимое), каждый с одним непрерывным диапазоном, который указывается полем заголовка Content-Range.</target>
        </trans-unit>
        <trans-unit id="13df76672f8936d6bfa4c75fdd9352b5d89d02a9" translate="yes" xml:space="preserve">
          <source>A response might transfer only a subrange of the bytes of an entity-
   body, either because the request included one or more Range
   specifications, or because a connection was broken prematurely. After
   several such transfers, a cache might have received several ranges of
   the same entity-body.

   If a cache has a stored non-empty set of subranges for an entity, and
   an incoming response transfers another subrange, the cache MAY
   combine the new subrange with the existing set if both the following
   conditions are met:

      - Both the incoming response and the cache entry have a cache
        validator.

      - The two cache validators match using the strong comparison
        function (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;).

   If either requirement is not met, the cache MUST use only the most
   recent partial response (based on the Date values transmitted with
   every response, and using the incoming response if these values are
   equal or missing), and MUST discard the other partial information.</source>
          <target state="translated">Ответ может передавать только поддиапазон байтов тела объекта либо потому, что запрос включал одну или несколько спецификаций диапазона, либо потому, что соединение было преждевременно разорвано. После нескольких таких передач кэш мог получить несколько диапазонов одного и того же тела объекта. Если в кэше хранится непустой набор поддиапазонов для объекта, а входящий ответ передает другой поддиапазон, кеш МОЖЕТ объединить новый поддиапазон с существующим набором, если выполняются оба следующих условия: - И входящий ответ, и запись в кеше имеет валидатор кеша. - Два валидатора кеша совпадают с использованием функции &lt;a href=&quot;#section-13.3.3&quot;&gt;строгого&lt;/a&gt; сравнения (см. Раздел 13.3.3.). Если какое-либо из требований не выполняется, кэш ДОЛЖЕН использовать только самый последний частичный ответ (на основе значений даты, передаваемых с каждым ответом, и с использованием входящего ответа, если эти значения равны или отсутствуют), и ДОЛЖЕН отбрасывать другую частичную информацию.</target>
        </trans-unit>
        <trans-unit id="fd3c0d3780d4efb8123ce73b8830668addce6c7f" translate="yes" xml:space="preserve">
          <source>A response provided by a cache is stale (the expiration time set for it has passed).</source>
          <target state="translated">Ответ,предоставляемый кэшем,является просроченным (время истечения срока действия,установленное для него,прошло).</target>
        </trans-unit>
        <trans-unit id="ce0f87926e811ddf23f0d196ca75fb63d5c3ead6" translate="yes" xml:space="preserve">
          <source>A response that tells the browser to allow code from any origin to access a resource will include the following:</source>
          <target state="translated">Ответ,который говорит браузеру разрешить код любого происхождения для доступа к ресурсу,будет включать следующее:</target>
        </trans-unit>
        <trans-unit id="16c3c1296edc54a60a8b59b30b92efe26a36cd5c" translate="yes" xml:space="preserve">
          <source>A response that tells the browser to allow requesting code from the origin &lt;code&gt;https://developer.mozilla.org&lt;/code&gt; to access a resource will include the following:</source>
          <target state="translated">Ответ, который сообщает браузеру разрешить запрос кода из источника &lt;code&gt;https://developer.mozilla.org&lt;/code&gt; для доступа к ресурсу, будет включать следующее:</target>
        </trans-unit>
        <trans-unit id="a2251e4ef7d0bf0a06db2d6ac25abf911ead38c0" translate="yes" xml:space="preserve">
          <source>A response to a &lt;code&gt;HEAD&lt;/code&gt; method &lt;em&gt;should not&lt;/em&gt; have a body. If it has one anyway, that body &lt;strong&gt;must be&lt;/strong&gt; ignored: any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;entity headers&lt;/a&gt; that might describe the erroneous body are instead assumed to describe the response which a similar &lt;code&gt;GET&lt;/code&gt; request would have received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a9acb9401a41dff46ebd4d7c24d2a3d9111ef3" translate="yes" xml:space="preserve">
          <source>A response to a &lt;code&gt;HEAD&lt;/code&gt; method should not have a body. If so, it must be ignored. Even so, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;entity headers&lt;/a&gt; describing the content of the body, like &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; may be included in the response. They don't relate to the body of the &lt;code&gt;HEAD&lt;/code&gt; response, which should be empty, but to the body of similar request using the &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method would have returned as a response.</source>
          <target state="translated">Ответ на метод &lt;code&gt;HEAD&lt;/code&gt; не должен иметь тела. Если да, то это нужно игнорировать. Даже в этом случае &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;заголовки сущностей,&lt;/a&gt; описывающие содержимое тела, например &lt;a href=&quot;../headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; ,&lt;/a&gt; могут быть включены в ответ. Они не относятся к телу ответа &lt;code&gt;HEAD&lt;/code&gt; , которое должно быть пустым, но к телу аналогичного запроса, использующего метод &lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , возвращалось бы как ответ.</target>
        </trans-unit>
        <trans-unit id="e2a4eab8fbc63e64d63cfaa4c539160dcfdafd03" translate="yes" xml:space="preserve">
          <source>A response to the HEAD method is identical to what an equivalent
   request made with a GET would have been, except it lacks a body.
   This property of HEAD responses can be used to invalidate or update a
   cached GET response if the more efficient conditional GET request
   mechanism is not available (due to no validators being present in the
   stored response) or if transmission of the representation body is not
   desired even if it has changed.

   When a cache makes an inbound HEAD request for a given request target
   and receives a 200 (OK) response, the cache SHOULD update or
   invalidate each of its stored GET responses that could have been
   selected for that request (see &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;).

   For each of the stored responses that could have been selected, if
   the stored response and HEAD response have matching values for any
   received validator fields (ETag and Last-Modified) and, if the HEAD
   response has a Content-Length header field, the value of
   Content-Length matches that of the stored response, the cache SHOULD
   update the stored response as described below; otherwise, the cache
   SHOULD consider the stored response to be stale. 

   If a cache updates a stored response with the metadata provided in a
   HEAD response, the cache MUST:

   o  delete any Warning header fields in the stored response with
      warn-code 1xx (see &lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;);

   o  retain any Warning header fields in the stored response with
      warn-code 2xx; and,

   o  use other header fields provided in the HEAD response to replace
      all instances of the corresponding header fields in the stored
      response and append new header fields to the stored response's
      header section unless otherwise restricted by the Cache-Control
      header field.</source>
          <target state="translated">Ответ на метод HEAD идентичен тому, каким был бы эквивалентный запрос, сделанный с помощью GET, за исключением того, что у него нет тела. Это свойство ответов HEAD можно использовать для аннулирования или обновления кэшированного ответа GET, если более эффективный механизм условного запроса GET недоступен (из-за отсутствия валидаторов в сохраненном ответе) или если передача тела представления нежелательна даже если он изменился. Когда кэш выполняет входящий запрос HEAD для данной цели запроса и получает ответ 200 (OK), кеш ДОЛЖЕН обновить или сделать недействительным каждый из сохраненных ответов GET, которые могли быть выбраны для этого запроса (см. &lt;a href=&quot;#section-4.1&quot;&gt;Раздел 4.1.&lt;/a&gt;). Для каждого из сохраненных ответов, которые могли быть выбраны, если сохраненный ответ и ответ HEAD имеют совпадающие значения для любых полученных полей валидатора (ETag и Last-Modified) и, если ответ HEAD имеет поле заголовка Content-Length, значение если Content-Length соответствует сохраненному ответу, кэш ДОЛЖЕН обновить сохраненный ответ, как описано ниже; в противном случае кэш ДОЛЖЕН считать сохраненный ответ устаревшим. Если кэш обновляет сохраненный ответ метаданными, предоставленными в ответе HEAD, кеш ДОЛЖЕН: o удалить любые поля заголовка предупреждения в сохраненном ответе с кодом предупреждения 1xx (см. &lt;a href=&quot;#section-5.5&quot;&gt;Раздел 5.5.&lt;/a&gt;); o сохранить любые поля заголовка предупреждения в сохраненном ответе с кодом предупреждения 2xx; и, o использовать другие поля заголовка, предоставленные в ответе HEAD, чтобы заменить все экземпляры соответствующих полей заголовка в сохраненном ответе и добавить новые поля заголовка в раздел заголовка сохраненного ответа, если иное не ограничено полем заголовка Cache-Control.</target>
        </trans-unit>
        <trans-unit id="669f6d87675fe454e2d369ba30faa8e2cfffabb9" translate="yes" xml:space="preserve">
          <source>A response triggering the &quot;Save As&quot; dialog:</source>
          <target state="translated">Реакция,вызывающая диалоговое окно &quot;Сохранить как&quot;:</target>
        </trans-unit>
        <trans-unit id="b9e19c47b651e8243cff78fe0138bde2241237d7" translate="yes" xml:space="preserve">
          <source>A returned resource may have one &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header, with the following syntax:</source>
          <target state="translated">Возвращенный ресурс может иметь один заголовок &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; со следующим синтаксисом:</target>
        </trans-unit>
        <trans-unit id="95815d7a3c95d6951515bf50a9472dbd82e8e267" translate="yes" xml:space="preserve">
          <source>A schema such as 'http:' or 'https:'. &lt;strong&gt;The colon is required, single quotes shouldn't be used&lt;/strong&gt;. You can also specify data schemas (not recommended).</source>
          <target state="translated">Схема, например http: или https:. &lt;strong&gt;Двоеточие является обязательным, одинарные кавычки использовать нельзя&lt;/strong&gt; . Вы также можете указать схемы данных (не рекомендуется).</target>
        </trans-unit>
        <trans-unit id="cbe7c636e6af2d87ce371a4de3a942151e1fda04" translate="yes" xml:space="preserve">
          <source>A schema such as 'http:' or 'https:'. The colon is required. You can also specify data schemas (not recommended).</source>
          <target state="translated">Схема типа 'http:' или 'https:'.Требуется двоеточие.Вы также можете указать схемы данных (не рекомендуется).</target>
        </trans-unit>
        <trans-unit id="d95228bc872e424d1fe8017595ec38304956be44" translate="yes" xml:space="preserve">
          <source>A scheme such as &lt;code&gt;http:&lt;/code&gt; or &lt;code&gt;https:&lt;/code&gt;. The colon is required and scheme should not be quoted. You can also specify data schemes (not recommended).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3df65d87ed800b56d06e1302b4935c2d9d8a276" translate="yes" xml:space="preserve">
          <source>A scheme such as &lt;code&gt;http:&lt;/code&gt; or &lt;code&gt;https:&lt;/code&gt;. The colon is required. Unlike other values below, single quotes shouldn't be used. You can also specify data schemes (not recommended).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40cd5842c9a4632e241e41e95dbacd3ae50ac805" translate="yes" xml:space="preserve">
          <source>A secure cookie is only sent to the server with an encrypted request over the HTTPS protocol. Even with &lt;code&gt;Secure&lt;/code&gt;, sensitive information should &lt;em&gt;never&lt;/em&gt; be stored in cookies, as they are inherently insecure and this flag can't offer real protection. Starting with Chrome 52 and Firefox 52, insecure sites (&lt;code&gt;http:&lt;/code&gt;) can't set cookies with the &lt;code&gt;Secure&lt;/code&gt; directive.</source>
          <target state="translated">Безопасный файл cookie отправляется на сервер только с зашифрованным запросом по протоколу HTTPS. Даже с &lt;code&gt;Secure&lt;/code&gt; конфиденциальная информация &lt;em&gt;никогда не&lt;/em&gt; должна храниться в файлах cookie, поскольку они по своей сути небезопасны, и этот флаг не может обеспечить реальную защиту. Начиная с Chrome 52 и Firefox 52 небезопасные сайты ( &lt;code&gt;http:&lt;/code&gt; ) не могут устанавливать файлы cookie с помощью директивы &lt;code&gt;Secure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7af3cd8d402a8e9beb152653018d719dd4ad9d78" translate="yes" xml:space="preserve">
          <source>A secure cookie will only be sent to the server when a request is made using SSL and the HTTPS protocol. However, confidential or sensitive information should never be stored or transmitted in HTTP Cookies as the entire mechanism is inherently insecure and this doesn't mean that any information is encrypted, for example.</source>
          <target state="translated">Безопасный куки-файл будет отправлен на сервер только в том случае,если запрос сделан с использованием SSL и протокола HTTPS.Тем не менее,конфиденциальная или чувствительная информация никогда не должна храниться или передаваться в HTTP Cookies,так как весь механизм по своей природе небезопасен,и это не означает,что любая информация,например,зашифрована.</target>
        </trans-unit>
        <trans-unit id="1953290f4d197b8408a6748e64b125663c28443d" translate="yes" xml:space="preserve">
          <source>A server SHOULD return a response with this status code if a request
   included a Range request-header field (&lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt;), and none of
   the range-specifier values in this field overlap the current extent
   of the selected resource, and the request did not include an If-Range
   request-header field. (For byte-ranges, this means that the first-
   byte-pos of all of the byte-range-spec values were greater than the
   current length of the selected resource.)

   When this status code is returned for a byte-range request, the
   response SHOULD include a Content-Range entity-header field
   specifying the current length of the selected resource (see &lt;a href=&quot;#section-14.16&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;). This response MUST NOT use the multipart/byteranges content-
   type.</source>
          <target state="translated">Серверу СЛЕДУЕТ возвращать ответ с этим кодом состояния, если запрос включал поле заголовка запроса диапазона ( &lt;a href=&quot;#section-14.35&quot;&gt;раздел 14.35&lt;/a&gt; ), и ни одно из значений спецификатора диапазона в этом поле не перекрывает текущий экстент выбранного ресурса, и запрос не включить поле заголовка запроса If-Range. (Для диапазонов байтов это означает, что первая позиция байта всех значений спецификации диапазона байтов была больше, чем текущая длина выбранного ресурса.) Когда этот код состояния возвращается для запроса диапазона байтов, ответ СЛЕДУЕТ включать в себя поле заголовка объекта Content-Range, указывающее текущую длину выбранного ресурса (см. &lt;a href=&quot;#section-14.16&quot;&gt;раздел &lt;/a&gt;&lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt; ). Этот ответ НЕ ДОЛЖЕН использовать тип содержимого multipart / byteranges.</target>
        </trans-unit>
        <trans-unit id="e0f49674d51f115dc57ea58b6c6057d6e1f1f18a" translate="yes" xml:space="preserve">
          <source>A server is in the position to save personal data about a user's
   requests over time, which might identify their reading patterns or
   subjects of interest.  In particular, log information gathered at an
   intermediary often contains a history of user agent interaction,
   across a multitude of sites, that can be traced to individual users.

   HTTP log information is confidential in nature; its handling is often
   constrained by laws and regulations.  Log information needs to be
   securely stored and appropriate guidelines followed for its analysis.
   Anonymization of personal information within individual entries
   helps, but it is generally not sufficient to prevent real log traces
   from being re-identified based on correlation with other access
   characteristics.  As such, access traces that are keyed to a specific
   client are unsafe to publish even if the key is pseudonymous. 

   To minimize the risk of theft or accidental publication, log
   information ought to be purged of personally identifiable
   information, including user identifiers, IP addresses, and
   user-provided query parameters, as soon as that information is no
   longer necessary to support operational needs for security, auditing,
   or fraud control.</source>
          <target state="translated">Сервер имеет возможность сохранять со временем персональные данные о запросах пользователя,которые могут идентифицировать характер их прочтения или интересующие его темы.В частности,журнальная информация,собранная у посредника,часто содержит историю взаимодействия пользователя с агентом на множестве сайтов,которая может быть прослежена до отдельных пользователей.Журнальная информация HTTP является конфиденциальной по своей природе;ее обработка часто ограничивается законами и нормативными актами.Журнальная информация должна храниться в безопасном месте,и для ее анализа должны соблюдаться соответствующие правила.Анонимизация личной информации в отдельных записях помогает,но,как правило,этого недостаточно для того,чтобы предотвратить повторную идентификацию реальных следов журнала на основе соотношения с другими характеристиками доступа.Как таковые,следы доступа,к которым подключен конкретный клиент,небезопасно публиковать,даже если ключ является псевдонимом.Чтобы свести к минимуму риск кражи или случайной публикации,информация в логах должна быть очищена от личной информации,включая идентификаторы пользователей,IP-адреса и параметры запроса,предоставляемые пользователем,как только эта информация перестанет быть необходимой для удовлетворения оперативных потребностей в безопасности,аудите или контроле над мошенничеством.</target>
        </trans-unit>
        <trans-unit id="09bccdb2c6a511f29817abf1fc56652b7723e836" translate="yes" xml:space="preserve">
          <source>A server is in the position to save personal data about a user's
   requests which might identify their reading patterns or subjects of
   interest. This information is clearly confidential in nature and its
   handling can be constrained by law in certain countries. People using
   the HTTP protocol to provide data are responsible for ensuring that
   such material is not distributed without the permission of any
   individuals that are identifiable by the published results.</source>
          <target state="translated">Сервер имеет возможность сохранять персональные данные о запросах пользователя,которые могут идентифицировать характер их чтения или интересующих субъектов.Эта информация,безусловно,является конфиденциальной по своей природе,и ее обработка может быть ограничена законом в некоторых странах.Люди,использующие протокол HTTP для предоставления данных,несут ответственность за то,чтобы такие материалы не распространялись без разрешения любых лиц,которые могут быть идентифицированы по опубликованным результатам.</target>
        </trans-unit>
        <trans-unit id="ec687f3c8448a18d04b2f853d94efde481053651" translate="yes" xml:space="preserve">
          <source>A server is not necessarily a single machine, but several server software instances can be hosted on the same machine. With HTTP/1.1 and the &lt;a href=&quot;headers/host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; header, they may even share the same IP address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d019112f6091b0eed2debdbb713a8f052cf5222e" translate="yes" xml:space="preserve">
          <source>A server is not necessarily a single machine, but several servers can be hosted on the same machine. With HTTP/1.1 and the &lt;a href=&quot;headers/host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; header, they may even share the same IP address.</source>
          <target state="translated">Сервер не обязательно является одной машиной, но на одной машине могут размещаться несколько серверов. С HTTP / 1.1 и заголовком &lt;a href=&quot;headers/host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; они могут даже использовать один и тот же IP-адрес.</target>
        </trans-unit>
        <trans-unit id="b79873bcb71a9cedddcc30f39182301545811028" translate="yes" xml:space="preserve">
          <source>A server isn't necessarily a physical machine: several servers can reside on the same physical machine. Or, one server can be handled by several machines, cooperating to produce the answer or balancing the load of the requests between them. The key point is that semantically &lt;em&gt;one domain name represents one single server&lt;/em&gt;.</source>
          <target state="translated">Сервер не обязательно является физической машиной: несколько серверов могут находиться на одной физической машине. Или один сервер может обслуживаться несколькими машинами, которые взаимодействуют друг с другом для получения ответа или балансировки нагрузки запросов между ними. Ключевым моментом является то, что семантически &lt;em&gt;одно доменное имя представляет один единственный сервер&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f0b526e8ef3de96dc3fb291521c6f4a105213fa5" translate="yes" xml:space="preserve">
          <source>A server may also send the header as part of a &lt;a href=&quot;../status/426&quot;&gt;&lt;code&gt;426&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Upgrade Required&lt;/code&gt; response, to indicate that the server won't perform the request using the current protocol, but might do so if the protocol is changed. The client can then request a protocol change using the process above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfac30184b9556e9ef555e2af061b31b9e243352" translate="yes" xml:space="preserve">
          <source>A server receives a request for &lt;code&gt;http://www.example.org/whaddup&lt;/code&gt; (when the canonical domain is example.org)</source>
          <target state="translated">Сервер получает запрос на &lt;code&gt;http://www.example.org/whaddup&lt;/code&gt; (когда каноническим доменом является example.org)</target>
        </trans-unit>
        <trans-unit id="6385a8f83518f5bb31e0c309e5837964daeac0d1" translate="yes" xml:space="preserve">
          <source>A server receiving a PATCH request with an unsupported media type could reply with &lt;a href=&quot;../status/415&quot;&gt;&lt;code&gt;415&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unsupported Media Type&lt;/code&gt; and an Accept-Patch header referencing one or more supported media types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ffc5be989c3040f832f85d28f183c24d1ebfbb" translate="yes" xml:space="preserve">
          <source>A server should send the &quot;close&quot; &lt;a href=&quot;../headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header field in the response, since &lt;code&gt;408&lt;/code&gt; implies that the server has decided to close the connection rather than continue waiting.</source>
          <target state="translated">Сервер должен отправить в ответе поле заголовка &amp;laquo;закрыть&amp;raquo; &lt;a href=&quot;../headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; , поскольку &lt;code&gt;408&lt;/code&gt; подразумевает, что сервер решил закрыть соединение, а не продолжать ожидание.</target>
        </trans-unit>
        <trans-unit id="23fcc0e82756bfddc3111906b38afc8f67f763c0" translate="yes" xml:space="preserve">
          <source>A server supporting partial downloads broadcasts this by sending the &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt; header. Once this happens, the client can resume a download by sending a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Ranges&quot;&gt;&lt;code&gt;Ranges&lt;/code&gt;&lt;/a&gt; header with the missing ranges:</source>
          <target state="translated">Сервер, поддерживающий частичную загрузку, передает это, отправляя заголовок &lt;a href=&quot;headers/accept-ranges&quot;&gt; &lt;code&gt;Accept-Ranges&lt;/code&gt; &lt;/a&gt; . Как только это произойдет, клиент может возобновить загрузку, отправив заголовок &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Ranges&quot;&gt; &lt;code&gt;Ranges&lt;/code&gt; &lt;/a&gt; с отсутствующими диапазонами:</target>
        </trans-unit>
        <trans-unit id="6f9b03e6063cc4b5ce8870c57b5b3f1fefcf329b" translate="yes" xml:space="preserve">
          <source>A server that receives an incomplete request message, usually due to
   a canceled request or a triggered timeout exception, MAY send an
   error response prior to closing the connection.

   A client that receives an incomplete response message, which can
   occur when a connection is closed prematurely or when decoding a
   supposedly chunked transfer coding fails, MUST record the message as
   incomplete.  Cache requirements for incomplete responses are defined
   in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC7234]&lt;/a&gt;.

   If a response terminates in the middle of the header section (before
   the empty line is received) and the status code might rely on header
   fields to convey the full meaning of the response, then the client
   cannot assume that meaning has been conveyed; the client might need
   to repeat the request in order to determine what action to take next.

   A message body that uses the chunked transfer coding is incomplete if
   the zero-sized chunk that terminates the encoding has not been
   received.  A message that uses a valid Content-Length is incomplete
   if the size of the message body received (in octets) is less than the
   value given by Content-Length.  A response that has neither chunked
   transfer coding nor Content-Length is terminated by closure of the
   connection and, thus, is considered complete regardless of the number
   of message body octets received, provided that the header section was
   received intact.</source>
          <target state="translated">Сервер, который получает сообщение с неполным запросом, обычно из-за отмененного запроса или инициированного исключения тайм-аута, МОЖЕТ отправить ответ об ошибке до закрытия соединения. Клиент, который получает сообщение с неполным ответом, что может произойти при преждевременном закрытии соединения или при сбое декодирования предположительно фрагментированного кодирования передачи, ДОЛЖЕН записать сообщение как неполное. Требования к &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3&quot;&gt;кешу&lt;/a&gt; для неполных ответов определены в разделе 3 [RFC7234]., Если ответ заканчивается в середине раздела заголовка (до получения пустой строки) и код состояния может полагаться на поля заголовка, чтобы передать полное значение ответа, то клиент не может предполагать, что значение было передано; клиенту может потребоваться повторить запрос, чтобы определить, какое действие предпринять дальше. Тело сообщения, в котором используется кодирование передачи по фрагментам, является неполным, если фрагмент нулевого размера, который завершает кодирование, не был получен. Сообщение, в котором используется допустимая длина содержимого, является неполным, если размер полученного тела сообщения (в октетах) меньше значения, заданного параметром Content-Length. Ответ, который не имеет ни кодирования передачи по частям, ни Content-Length, завершается закрытием соединения и, таким образом,считается завершенным независимо от количества полученных октетов тела сообщения, при условии, что раздел заголовка был получен без изменений.</target>
        </trans-unit>
        <trans-unit id="a058fcef10ecb10e40930fc393c822b8da706b5f" translate="yes" xml:space="preserve">
          <source>A server to give access to the document, an early version of &lt;em&gt;httpd&lt;/em&gt;.</source>
          <target state="translated">Сервер для предоставления доступа к документу, ранняя версия &lt;em&gt;httpd&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5428d9f2d224f7b0136e57c085942bc52a277388" translate="yes" xml:space="preserve">
          <source>A sha256, sha384 or sha512 hash of scripts or styles. The use of this source consists of two portions separated by a dash: the encryption algorithm used to create the hash and the base64-encoded hash of the script or style. When generating the hash, don't include the &amp;lt;script&amp;gt; or &amp;lt;style&amp;gt; tags and note that capitalization and whitespace matter, including leading or trailing whitespace. See &lt;a href=&quot;script-src#Unsafe_inline_script&quot;&gt;unsafe inline script&lt;/a&gt; for an example. In CSP 2.0 this applied only to inline scripts. CSP 3.0 allows it in the case of &lt;code&gt;script-src&lt;/code&gt; for external scripts.</source>
          <target state="translated">Sha256, sha384 или sha512 хеш скриптов или стилей. Использование этого источника состоит из двух частей, разделенных тире: алгоритм шифрования, используемый для создания хэша, и хеш-код сценария или стиля в кодировке base64. При создании хэша не включайте теги &amp;lt;script&amp;gt; или &amp;lt;style&amp;gt; и обратите внимание, что использование заглавных букв и пробелов имеет значение, включая начальные и конечные пробелы. См. Пример &lt;a href=&quot;script-src#Unsafe_inline_script&quot;&gt;небезопасного встроенного скрипта&lt;/a&gt; . В CSP 2.0 это относилось только к встроенным скриптам. CSP 3.0 позволяет это в случае &lt;code&gt;script-src&lt;/code&gt; для внешних скриптов.</target>
        </trans-unit>
        <trans-unit id="b0be84bce742baeb2d49ccf396ba5e30b04dc8c9" translate="yes" xml:space="preserve">
          <source>A sha256, sha384 or sha512 hash of scripts or styles. The use of this source consists of two portions separated by a dash: the encryption algorithm used to create the hash and the base64-encoded hash of the script or style. When generating the hash, don't include the &amp;lt;script&amp;gt; or &amp;lt;style&amp;gt; tags and note that capitalization and whitespace matter, including leading or trailing whitespace. See &lt;a href=&quot;script-src#Unsafe_inline_script&quot;&gt;unsafe inline script&lt;/a&gt; for an example. In CSP 2.0, this applied only to inline scripts. CSP 3.0 allows it in the case of &lt;code&gt;script-src&lt;/code&gt; for external scripts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="effe3f436253f2fb4b93f88cfbc11ed917fb2ccb" translate="yes" xml:space="preserve">
          <source>A shared cache MUST NOT use a cached response to a request with an
   Authorization header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7235]&lt;/a&gt;) to satisfy any
   subsequent request unless a cache directive that allows such
   responses to be stored is present in the response.

   In this specification, the following Cache-Control response
   directives (&lt;a href=&quot;#section-5.2.2&quot;&gt;Section 5.2.2&lt;/a&gt;) have such an effect: must-revalidate,
   public, and s-maxage. 

   Note that cached responses that contain the &quot;must-revalidate&quot; and/or
   &quot;s-maxage&quot; response directives are not allowed to be served stale
   (&lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;) by shared caches.  In particular, a response with
   either &quot;max-age=0, must-revalidate&quot; or &quot;s-maxage=0&quot; cannot be used to
   satisfy a subsequent request without revalidating it on the origin
   server.</source>
          <target state="translated">Общий кеш НЕ ДОЛЖЕН использовать кэшированный ответ на запрос с полем заголовка авторизации ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;раздел 4.2 [RFC7235]&lt;/a&gt; ) для удовлетворения любого последующего запроса, если в ответе не присутствует директива кеша, которая позволяет сохранять такие ответы. В этой спецификации следующие директивы ответа Cache-Control ( &lt;a href=&quot;#section-5.2.2&quot;&gt;раздел 5.2.2&lt;/a&gt; ) имеют такой эффект: must-revalidate, public и s-maxage. Обратите внимание, что кэшированные ответы, содержащие директивы ответа &amp;laquo;must-revalidate&amp;raquo; и / или &amp;laquo;s-maxage&amp;raquo;, не могут быть обработаны устаревшими ( &lt;a href=&quot;#section-4.2.4&quot;&gt;раздел 4.2.4.&lt;/a&gt;) с помощью общих кешей. В частности, ответ с &quot;max-age = 0, must-revalidate&quot; или &quot;s-maxage = 0&quot; не может использоваться для удовлетворения последующего запроса без повторной проверки его на исходном сервере.</target>
        </trans-unit>
        <trans-unit id="6723cf8edd03849b4cdc5d908be434852f344b77" translate="yes" xml:space="preserve">
          <source>A shared cache is a cache that stores responses to be reused by more than one user. For example, an ISP or your company might have set up a web proxy as part of its local network infrastructure to serve many users so that popular resources are reused a number of times, reducing network traffic and latency.</source>
          <target state="translated">Общий кэш-это кэш,в котором хранятся ответы для повторного использования несколькими пользователями.Например,провайдер интернет-услуг или ваша компания могла бы настроить веб-прокси как часть своей локальной сетевой инфраструктуры для обслуживания многих пользователей,чтобы популярные ресурсы использовались повторно несколько раз,снижая сетевой трафик и задержки.</target>
        </trans-unit>
        <trans-unit id="c2b2979df34c75249acdcbaead32af4206e98c1f" translate="yes" xml:space="preserve">
          <source>A significant difference between HTTP/1.1 and earlier versions of
   HTTP is that persistent connections are the default behavior of any
   HTTP connection. That is, unless otherwise indicated, the client
   SHOULD assume that the server will maintain a persistent connection,
   even after error responses from the server.

   Persistent connections provide a mechanism by which a client and a
   server can signal the close of a TCP connection. This signaling takes
   place using the Connection header field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;). Once a close
   has been signaled, the client MUST NOT send any more requests on that
   connection.</source>
          <target state="translated">Существенная разница между HTTP / 1.1 и более ранними версиями HTTP заключается в том, что постоянные соединения являются поведением по умолчанию для любого HTTP-соединения. То есть, если не указано иное, клиенту СЛЕДУЕТ предполагать, что сервер будет поддерживать постоянное соединение даже после ответов сервера об ошибках. Постоянные соединения предоставляют механизм, с помощью которого клиент и сервер могут сигнализировать о закрытии TCP-соединения. Эта сигнализация осуществляется с использованием поля заголовка соединения ( &lt;a href=&quot;#section-14.10&quot;&gt;раздел 14.10&lt;/a&gt; ). После сигнала о закрытии клиент НЕ ДОЛЖЕН отправлять больше запросов по этому соединению.</target>
        </trans-unit>
        <trans-unit id="fc833fea6c576628123c7be8083a40beb8ce29b5" translate="yes" xml:space="preserve">
          <source>A simple form using the default &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; content type:</source>
          <target state="translated">Простая форма с использованием типа содержимого &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; по умолчанию :</target>
        </trans-unit>
        <trans-unit id="c7b39b34d060373154765396af385c3d062ca369" translate="yes" xml:space="preserve">
          <source>A simple protocol to exchange these documents, the &lt;em&gt;HypertText Transfer Protocol &lt;/em&gt;(HTTP).</source>
          <target state="translated">Простой протокол для обмена этими документами, &lt;em&gt;HypertText Transfer Protocol&lt;/em&gt; (HTTP).</target>
        </trans-unit>
        <trans-unit id="fe6b8df10d2d0221c0d8b10a29444ba2522da8aa" translate="yes" xml:space="preserve">
          <source>A single, precise &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME type&lt;/a&gt;, like &lt;code&gt;text/html&lt;/code&gt;.</source>
          <target state="translated">Единственный точный &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;тип MIME&lt;/a&gt; , например &lt;code&gt;text/html&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4deb257d47824330583bad2d749145dc206117e9" translate="yes" xml:space="preserve">
          <source>A specific document is called a &lt;em&gt;resource&lt;/em&gt;. When a client wants to obtain a resource, the client requests it using its URL. The server uses this URL to choose one of the variants it provides &amp;ndash; each variant being called a &lt;em&gt;representation&lt;/em&gt; &amp;ndash; and returns a specific representation to the client. The overall resource, as well as each of the representations, have a specific URL. How a specific representation is chosen when the resource is called is determined by &lt;em&gt;content negotiation&lt;/em&gt; and there are several ways of negotiating between the client and the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b779f5a10d17e9e595f84888aae03e305b6d164d" translate="yes" xml:space="preserve">
          <source>A specific document is called a &lt;em&gt;resource&lt;/em&gt;. When a client wants to obtain it, it requests it using its URL. The server uses this URL to choose one of the variants it provides &amp;ndash; each variant being called a &lt;em&gt;representation&lt;/em&gt; &amp;ndash; and returns this specific representation to the client. The overall resource, as well as each of the representations, have a specific URL. How a specific representation is chosen when the resource is called is determined by &lt;em&gt;content negotiation&lt;/em&gt; and there are several ways of negotiating between the client and the server.</source>
          <target state="translated">Конкретный документ называется &lt;em&gt;ресурсом&lt;/em&gt; . Когда клиент хочет его получить, он запрашивает его, используя свой URL-адрес. Сервер использует этот URL-адрес для выбора одного из предоставляемых им вариантов - каждый вариант называется &lt;em&gt;представлением&lt;/em&gt; - и возвращает это конкретное представление клиенту. Общий ресурс, а также каждое из представлений имеют определенный URL. Выбор конкретного представления при вызове ресурса определяется &lt;em&gt;согласованием содержимого,&lt;/em&gt; и существует несколько способов согласования между клиентом и сервером.</target>
        </trans-unit>
        <trans-unit id="ceace1a8903945561dd351633e2b54bd5662380b" translate="yes" xml:space="preserve">
          <source>A specific incompatibility exists in some versions of the Safari web browser, whereby if a Content Security Policy header is set, but not a Same Origin header, the browser will block self-hosted content and off-site content, and incorrectly report that this is due to a the Content Security Policy not allowing the content.</source>
          <target state="translated">В некоторых версиях веб-браузера Safari существует определённая несовместимость,в результате чего,если установлен заголовок Политики Безопасности Содержимого,но не заголовок Тот же Происхождение,браузер заблокирует самохостинговое содержимое и содержимое вне сайта,и неверно сообщит о том,что это из-за того,что Политика Безопасности Содержимого не разрешает содержимое.</target>
        </trans-unit>
        <trans-unit id="c9d5d6a9b1ff08cc641c31611f35b864c75165ef" translate="yes" xml:space="preserve">
          <source>A specific kind of URI that directly embeds the resource it represents. Data URIs are very convenient, but have some caveats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a8fdf6c2788b6b9978669c875fa2c7ee77f30d" translate="yes" xml:space="preserve">
          <source>A specific kind of URIs that directly embeds the resource it represents. Data URIs are very convenient, but have some caveats.</source>
          <target state="translated">Определенный вид URI,который непосредственно встраивает представляемый ресурс.URI данных очень удобны,но имеют некоторые предостережения.</target>
        </trans-unit>
        <trans-unit id="6717e7d4b911da2b4b4a18d74011b1145e1b78df" translate="yes" xml:space="preserve">
          <source>A specific kind of URIs, data URIs, embed the resource itself inside the identifier.</source>
          <target state="translated">Определенный вид URI,URI данных,встраивает сам ресурс в идентификатор.</target>
        </trans-unit>
        <trans-unit id="fa9c947ce55668387be7bc6267a41295eae128cc" translate="yes" xml:space="preserve">
          <source>A specification such as this thrives on piercing critical review and
   withers from apathetic neglect.  The authors gratefully acknowledge
   the contributions of the following people, whose insights were so
   valuable at every stage of our work.

   Contributors to &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;

   Terry Allen, Harald Alvestrand, Jim Amsden, Becky Anderson, Alan
   Babich, Sanford Barr, Dylan Barrell, Bernard Chester, Tim Berners-
   Lee, Dan Connolly, Jim Cunningham, Ron Daniel, Jr., Jim Davis, Keith
   Dawson, Mark Day, Brian Deen, Martin Duerst, David Durand, Lee
   Farrell, Chuck Fay, Wesley Felter, Roy Fielding, Mark Fisher, Alan
   Freier, George Florentine, Jim Gettys, Phill Hallam-Baker, Dennis
   Hamilton, Steve Henning, Mead Himelstein, Alex Hopmann, Andre van der
   Hoek, Ben Laurie, Paul Leach, Ora Lassila, Karen MacArthur, Steven
   Martin, Larry Masinter, Michael Mealling, Keith Moore, Thomas Narten,
   Henrik Nielsen, Kenji Ota, Bob Parker, Glenn Peterson, Jon Radoff,
   Saveen Reddy, Henry Sanders, Christopher Seiwald, Judith Slein, Mike
   Spreitzer, Einar Stefferud, Greg Stein, Ralph Swick, Kenji Takahashi,
   Richard N. Taylor, Robert Thau, John Turner, Sankar Virdhagriswaran,
   Fabio Vitali, Gregory Woodhouse, and Lauren Wood.

   Two from this list deserve special mention.  The contributions by
   Larry Masinter have been invaluable; he both helped the formation of
   the working group and patiently coached the authors along the way.
   In so many ways he has set high standards that we have toiled to
   meet.  The contributions of Judith Slein were also invaluable; by
   clarifying the requirements and in patiently reviewing version after
   version, she both improved this specification and expanded our minds
   on document management.

   We would also like to thank John Turner for developing the XML DTD.

   The authors of &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; were Yaron Goland, Jim Whitehead, A. Faizi,
   Steve Carter, and D. Jensen.  Although their names had to be removed
   due to IETF author count restrictions, they can take credit for the
   majority of the design of WebDAV.

   Additional Acknowledgements for This Specification

   Significant contributors of text for this specification are listed as
   contributors in the section below.  We must also gratefully
   acknowledge Geoff Clemm, Joel Soderberg, and Dan Brotsky for hashing
   out specific text on the list or in meetings.  Joe Hildebrand and
   Cullen Jennings helped close many issues.  Barry Lind described an
   additional security consideration and Cullen Jennings provided text 

   for that consideration.  Jason Crawford tracked issue status for this
   document for a period of years, followed by Elias Sinderson.</source>
          <target state="translated">Подобная спецификация процветает благодаря проницательному критическому обзору и увядает от апатичного пренебрежения. Авторы с благодарностью признают вклад следующих людей, чьи идеи были так ценны на каждом этапе нашей работы. Авторы &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; Терри Аллен, Харальд Альвестранд, Джим Амсден, Бекки Андерсон, Алан Бабич, Сэнфорд Барр, Дилан Баррелл, Бернард Честер, Тим Бернерс-Ли, Дэн Коннолли, Джим Каннингем, Рон Дэниел младший, Джим Дэвис, Кейт Доусон, Марк Дэй, Брайан Дин, Мартин Дуэрст, Дэвид Дюран, Ли Фаррелл, Чак Фэй, Уэсли Фелтер, Рой Филдинг, Марк Фишер, Алан Фрейер, Джордж Флорентин, Джим Геттис, Фил Халлам-Бейкер, Деннис Гамильтон, Стив Хеннинг, Мид Химельштейн, Алекс Хопманн, Андре ван дер Хук, Бен Лори, Пол Лич, Ора Лассила, Карен МакАртур, Стивен Мартин, Ларри Масинтер, Майкл Миллинг, Кейт Мур, Томас Нартен, Хенрик Нильсен, Кенджи Ота, Боб Паркер, Гленн Петерсон, Джон Радофф, Савен Редди, Генри Сандерс, Кристофер Зайвальд, Джудит Слейн, Майк Спрейцер, Эйнар Штефферуд, Грег Штайн, Ральф Свик, Кенджи Такахаши,Ричард Н. Тейлор, Роберт Тау, Джон Тернер, Санкар Вирдхагрисваран, Фабио Витали, Грегори Вудхаус и Лорен Вуд. Два из этого списка заслуживают особого упоминания. Вклад Ларри Мастера неоценим; он не только помогал формированию рабочей группы, но и терпеливо тренировал авторов. Во многих отношениях он установил высокие стандарты, которым мы очень старались соответствовать. Неоценим был также вклад Джудит Слейн; Уточняя требования и терпеливо просматривая версию за версией, она улучшила эту спецификацию и расширила наши представления об управлении документами. Мы также хотели бы поблагодарить Джона Тернера за разработку XML DTD. АвторыДва из этого списка заслуживают особого упоминания. Вклад Ларри Мастера неоценим; он не только помогал формированию рабочей группы, но и терпеливо тренировал авторов. Во многих отношениях он установил высокие стандарты, которым мы очень старались соответствовать. Неоценим был также вклад Джудит Слейн; Уточняя требования и терпеливо просматривая версию за версией, она улучшила эту спецификацию и расширила наши представления об управлении документами. Мы также хотели бы поблагодарить Джона Тернера за разработку XML DTD. АвторыДва из этого списка заслуживают особого упоминания. Вклад Ларри Мастера неоценим; он не только помогал формированию рабочей группы, но и терпеливо тренировал авторов. Во многих отношениях он установил высокие стандарты, которым мы очень старались соответствовать. Неоценим был также вклад Джудит Слейн; Уточняя требования и терпеливо просматривая версию за версией, она улучшила эту спецификацию и расширила наши представления об управлении документами. Мы также хотели бы поблагодарить Джона Тернера за разработку XML DTD. АвторыВо многих отношениях он установил высокие стандарты, которым мы очень старались соответствовать. Неоценим был также вклад Джудит Слейн; Уточняя требования и терпеливо просматривая версию за версией, она улучшила эту спецификацию и расширила наши представления об управлении документами. Мы также хотели бы поблагодарить Джона Тернера за разработку XML DTD. АвторыВо многих отношениях он установил высокие стандарты, которым мы очень старались соответствовать. Неоценим был также вклад Джудит Слейн; Уточняя требования и терпеливо просматривая версию за версией, она улучшила эту спецификацию и расширила наши представления об управлении документами. Мы также хотели бы поблагодарить Джона Тернера за разработку XML DTD. Авторы&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;были Ярон Голанд, Джим Уайтхед, А. Файзи, Стив Картер и Д. Дженсен. Хотя их имена пришлось удалить из-за ограничений IETF по количеству авторов, они могут взять на себя ответственность за большую часть дизайна WebDAV. Дополнительные благодарности за эту спецификацию Существенные авторы текста данной спецификации перечислены как участники в разделе ниже. Мы также должны поблагодарить Джеффа Клемма, Джоэла Содерберга и Дэна Броцки за то, что они разработали конкретный текст в списке или на встречах. Джо Хильдебранд и Каллен Дженнингс помогли решить многие проблемы. Барри Линд описал дополнительное соображение безопасности, а Каллен Дженнингс предоставил текст для этого соображения. Джейсон Кроуфорд отслеживал статус проблемы для этого документа в течение нескольких лет, а за ним следовал Элиас Синдерсон.</target>
        </trans-unit>
        <trans-unit id="243ac7b5d0c4b7135957ced81f079042072b4147" translate="yes" xml:space="preserve">
          <source>A standardized version of this header is the HTTP &lt;a href=&quot;forwarded&quot;&gt;&lt;code&gt;Forwarded&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Стандартизированной версией этого заголовка является заголовок HTTP &lt;a href=&quot;forwarded&quot;&gt; &lt;code&gt;Forwarded&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5732080026806544aacb362bb381344fc069b68" translate="yes" xml:space="preserve">
          <source>A status code line is also sent at the beginning of the response, allowing the browser itself to understand the success or failure of the request and to adapt its behavior in consequence (like in updating or using its local cache in a specific way)</source>
          <target state="translated">В начале ответа также посылается строка кода состояния,позволяющая браузеру самому понять успех или неудачу запроса и адаптировать его поведение в последствии (например,при обновлении или использовании локального кэша определенным образом).</target>
        </trans-unit>
        <trans-unit id="c8e08ba45f9595801714cdefafd3faea76d549c5" translate="yes" xml:space="preserve">
          <source>A status message, a non-authoritative short description of the status code.</source>
          <target state="translated">Сообщение о статусе,неавторитетное краткое описание кода статуса.</target>
        </trans-unit>
        <trans-unit id="8af24e7123d43765daa487b6cb3e5b3c4417b1a2" translate="yes" xml:space="preserve">
          <source>A stream error is an error related to a specific stream that does not
   affect processing of other streams.

   An endpoint that detects a stream error sends a RST_STREAM frame
   (&lt;a href=&quot;#section-6.4&quot;&gt;Section 6.4&lt;/a&gt;) that contains the stream identifier of the stream where
   the error occurred.  The RST_STREAM frame includes an error code that
   indicates the type of error.

   A RST_STREAM is the last frame that an endpoint can send on a stream.
   The peer that sends the RST_STREAM frame MUST be prepared to receive
   any frames that were sent or enqueued for sending by the remote peer.
   These frames can be ignored, except where they modify connection
   state (such as the state maintained for header compression
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) or flow control).

   Normally, an endpoint SHOULD NOT send more than one RST_STREAM frame
   for any stream.  However, an endpoint MAY send additional RST_STREAM
   frames if it receives frames on a closed stream after more than a
   round-trip time.  This behavior is permitted to deal with misbehaving
   implementations. 

   To avoid looping, an endpoint MUST NOT send a RST_STREAM in response
   to a RST_STREAM frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e013235aa2f4b291e00e311c2ac1352025ad323f" translate="yes" xml:space="preserve">
          <source>A string for identifying HTTP/2 is entered into the &quot;Application-
   Layer Protocol Negotiation (ALPN) Protocol IDs&quot; registry established
   in [&lt;a href=&quot;#ref-TLS-ALPN&quot;&gt;TLS-ALPN&lt;/a&gt;].

   This document establishes a registry for frame types, settings, and
   error codes.  These new registries appear in the new &quot;Hypertext
   Transfer Protocol version 2 (HTTP/2) Parameters&quot; section.

   This document registers the HTTP2-Settings header field for use in
   HTTP; it also registers the 421 (Misdirected Request) status code.

   This document registers the &quot;PRI&quot; method for use in HTTP to avoid
   collisions with the connection preface (&lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a08604bc21c1691f9b1f625192cc47697f42035b" translate="yes" xml:space="preserve">
          <source>A successful LOCK method MUST result in the creation of an empty
   resource that is locked (and that is not a collection) when a
   resource did not previously exist at that URL.  Later on, the lock
   may go away but the empty resource remains.  Empty resources MUST
   then appear in PROPFIND responses including that URL in the response
   scope.  A server MUST respond successfully to a GET request to an
   empty resource, either by using a 204 No Content response, or by
   using 200 OK with a Content-Length header indicating zero length</source>
          <target state="translated">Успешный метод БЛОКИРОВКИ ДОЛЖЕН привести к созданию пустого ресурса,который заблокирован (и это не коллекция),когда ресурс ранее не существовал по этому URL.Позже блокировка может исчезнуть,но пустой ресурс останется.Пустые ресурсы ДОЛЖНЫ затем появляться в ответах PROPFIND,включая этот URL в области видимости ответа.Сервер ДОЛЖЕН успешно ответить на GET-запрос пустого ресурса,либо используя ответ No Content 204,либо используя 200 OK с заголовком Content-Length,указывающим нулевую длину.</target>
        </trans-unit>
        <trans-unit id="761ebc49a4e6c7f0646a5103ac3b55e7ffb14172" translate="yes" xml:space="preserve">
          <source>A successful response is indicated by any &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.3&quot;&gt;2xx&lt;/a&gt; status code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34367556fdd895f927c5302a93e55ce713fb9f94" translate="yes" xml:space="preserve">
          <source>A successful response is indicated with a &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt; response code, because the response in the example does not carry a message body. (which a response with the 200 code would have). Note that other success codes could be used as well.</source>
          <target state="translated">Успешный ответ обозначается кодом ответа &lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt; , потому что ответ в примере не содержит тела сообщения. (который будет иметь ответ с кодом 200). Обратите внимание, что можно использовать и другие коды успеха.</target>
        </trans-unit>
        <trans-unit id="e103fc95ad4823358a2845eae9f826cfeffda4c5" translate="yes" xml:space="preserve">
          <source>A textual format to represent hypertext documents, the &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HyperText Markup Language&lt;/a&gt;&lt;/em&gt; (HTML).</source>
          <target state="translated">Текстовый формат для представления гипертекстовых документов, &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;язык разметки гипертекста&lt;/a&gt;&lt;/em&gt; (HTML).</target>
        </trans-unit>
        <trans-unit id="4ce1aa0486be881fd62b04d40f7f043b63b1c037" translate="yes" xml:space="preserve">
          <source>A three-digit warning number. The first digit indicates whether the &lt;code&gt;Warning&lt;/code&gt; is required to be deleted from a stored response after validation.</source>
          <target state="translated">Трехзначный номер предупреждения. Первая цифра указывает, требуется ли удаление &lt;code&gt;Warning&lt;/code&gt; из сохраненного ответа после проверки.</target>
        </trans-unit>
        <trans-unit id="7b7d752bda74832f7282cbd7c03d86206cc0cd43" translate="yes" xml:space="preserve">
          <source>A trailer allows the sender to include additional fields at the end
   of a chunked message in order to supply metadata that might be
   dynamically generated while the message body is sent, such as a
   message integrity check, digital signature, or post-processing
   status.  The trailer fields are identical to header fields, except
   they are sent in a chunked trailer instead of the message's header
   section.

     trailer-part   = *( header-field CRLF )

   A sender MUST NOT generate a trailer that contains a field necessary
   for message framing (e.g., Transfer-Encoding and Content-Length),
   routing (e.g., Host), request modifiers (e.g., controls and
   conditionals in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5&quot;&gt;Section&amp;nbsp;5 of [RFC7231]&lt;/a&gt;), authentication (e.g., see
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;]), response control data (e.g., see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1&quot;&gt;7.1 of [RFC7231]&lt;/a&gt;), or determining how to process the payload (e.g.,
   Content-Encoding, Content-Type, Content-Range, and Trailer).

   When a chunked message containing a non-empty trailer is received,
   the recipient MAY process the fields (aside from those forbidden
   above) as if they were appended to the message's header section.  A
   recipient MUST ignore (or consider as an error) any fields that are
   forbidden to be sent in a trailer, since processing them as if they
   were present in the header section might bypass external security
   filters.

   Unless the request includes a TE header field indicating &quot;trailers&quot;
   is acceptable, as described in &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;, a server SHOULD NOT
   generate trailer fields that it believes are necessary for the user
   agent to receive.  Without a TE containing &quot;trailers&quot;, the server
   ought to assume that the trailer fields might be silently discarded
   along the path to the user agent.  This requirement allows
   intermediaries to forward a de-chunked message to an HTTP/1.0
   recipient without buffering the entire response.</source>
          <target state="translated">Трейлер позволяет отправителю включать дополнительные поля в конце фрагментированного сообщения для предоставления метаданных, которые могут динамически генерироваться при отправке тела сообщения, например проверка целостности сообщения, цифровая подпись или статус постобработки. Поля трейлера идентичны полям заголовка, за исключением того, что они отправляются в фрагментированном трейлере, а не в разделе заголовка сообщения. трейлер-часть = * (поле заголовка CRLF) Отправитель НЕ ДОЛЖЕН создавать трейлер, который содержит поле, необходимое для кадрирования сообщения (например, Transfer-Encoding и Content-Length), маршрутизации (например, Host), модификаторов запроса (например, элементы управления и условия в &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5&quot;&gt;разделе 5 [RFC7231]&lt;/a&gt; ), аутентификация (например, см. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ] и [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;]), данные управления ответом (например, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1&quot;&gt;раздел &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1&quot;&gt;7.1 [RFC7231]&lt;/a&gt; ) или определение способа обработки полезной нагрузки (например, Content-Encoding, Content-Type, Content-Range и Trailer). Когда получено фрагментированное сообщение, содержащее непустой трейлер, получатель МОЖЕТ обработать поля (кроме запрещенных выше), как если бы они были добавлены в раздел заголовка сообщения. Получатель ДОЛЖЕН игнорировать (или рассматривать как ошибку) любые поля, которые запрещено отправлять в трейлере, поскольку их обработка, как если бы они присутствовали в разделе заголовка, может обойти внешние фильтры безопасности. Если запрос не включает поле заголовка TE, указывающее, что &quot;трейлеры&quot; приемлемы, как описано в &lt;a href=&quot;#section-4.3&quot;&gt;разделе 4.3.&lt;/a&gt;, серверу НЕ СЛЕДУЕТ создавать поля трейлера, которые, по его мнению, необходимы пользовательскому агенту. Без TE, содержащего &amp;laquo;трейлеры&amp;raquo;, сервер должен предполагать, что поля трейлера могут быть незаметно отброшены на пути к пользовательскому агенту. Это требование позволяет посредникам пересылать расшифрованное сообщение получателю HTTP / 1.0 без буферизации всего ответа.</target>
        </trans-unit>
        <trans-unit id="b66dee6b11e93736d953af429c12c61621b0b237" translate="yes" xml:space="preserve">
          <source>A typical HTTP session</source>
          <target state="translated">Типичная сессия HTTP</target>
        </trans-unit>
        <trans-unit id="96ee2f8f3bbbe21e292a7b8dac9501fca154c6f0" translate="yes" xml:space="preserve">
          <source>A typical flow of requests, all through one single connection is now looking like this:</source>
          <target state="translated">Типичный поток запросов,проходящий через одно единственное соединение,теперь выглядит так:</target>
        </trans-unit>
        <trans-unit id="4ccbdc0f9453daa1ff4757f0c1283a456c445232" translate="yes" xml:space="preserve">
          <source>A typical status line looks like: &lt;code&gt;HTTP/1.1 404 Not Found.&lt;/code&gt;</source>
          <target state="translated">Типичная строка состояния выглядит так: &lt;code&gt;HTTP/1.1 404 Not Found.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5301a544830b2f5e4f1a802c0392489c4929900" translate="yes" xml:space="preserve">
          <source>A typical status line looks like: &lt;code&gt;HTTP/1.1 404 Not Found&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7772ff9ebd19b33547ec2a86b5652c058907a9ee" translate="yes" xml:space="preserve">
          <source>A unique string identifying the version of the resource. Conditional requests using &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; use this value to change the behavior of the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae78cbf97ee4cff3a5f3f02f099427e133082c03" translate="yes" xml:space="preserve">
          <source>A user agent has to demonstrate knowledge of a lock when requesting
   an operation on a locked resource.  Otherwise, the following scenario
   might occur.  In the scenario, program A, run by User A, takes out a
   write lock on a resource.  Program B, also run by User A, has no
   knowledge of the lock taken out by program A, yet performs a PUT to
   the locked resource.  In this scenario, the PUT succeeds because
   locks are associated with a principal, not a program, and thus
   program B, because it is acting with principal A's credential, is
   allowed to perform the PUT.  However, had program B known about the
   lock, it would not have overwritten the resource, preferring instead
   to present a dialog box describing the conflict to the user.  Due to
   this scenario, a mechanism is needed to prevent different programs
   from accidentally ignoring locks taken out by other programs with the
   same authorization.

   In order to prevent these collisions, a lock token MUST be submitted
   by an authorized principal for all locked resources that a method may
   change or the method MUST fail.  A lock token is submitted when it
   appears in an If header.  For example, if a resource is to be moved
   and both the source and destination are locked, then two lock tokens
   must be submitted in the If header, one for the source and the other
   for the destination.</source>
          <target state="translated">Пользовательский агент должен продемонстрировать знание блокировки при запросе операции на заблокированном ресурсе.В противном случае может произойти следующий сценарий.В этом сценарии программа А,выполняемая пользователем А,снимает блокировку записи с ресурса.Программа B,также выполняемая пользователем A,не знает о блокировке,снятой программой A,но выполняет PUT к заблокированному ресурсу.В этом сценарии PUT удается,потому что блокировки связаны с директором,а не с программой,и,следовательно,программе B,потому что она действует с учетной записью директора А,разрешается выполнять PUT.Однако,если бы программа B знала о блокировке,она бы не перезаписала ресурс,предпочитая вместо этого представить пользователю диалоговое окно,описывающее конфликт.Из-за этого сценария необходим механизм,предотвращающий случайное игнорирование различными программами блокировок,снятых другими программами с той же самой авторизацией.Для предотвращения таких столкновений маркер блокировки ДОЛЖЕН быть представлен авторизованным директором для всех заблокированных ресурсов,которые могут измениться или метод ДОЛЖЕН выйти из строя.Токен блокировки передается,когда он появляется в заголовке If.Например,если ресурс должен быть перемещен и заблокированы как источник,так и место назначения,то в заголовке If должны быть представлены два маркера блокировки,один для источника,а другой для места назначения.</target>
        </trans-unit>
        <trans-unit id="1665264fcfc3dbf5c0a1ff63ea9c76cb5daa217f" translate="yes" xml:space="preserve">
          <source>A user agent that wishes to authenticate itself with a server--
      usually, but not necessarily, after receiving a 401 response--does
      so by including an Authorization request-header field with the
      request.  The Authorization field value consists of credentials
      containing the authentication information of the user agent for
      the realm of the resource being requested.

          Authorization  = &quot;Authorization&quot; &quot;:&quot; credentials

      HTTP access authentication is described in &quot;HTTP Authentication:
      Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. If a request is
      authenticated and a realm specified, the same credentials SHOULD
      be valid for all other requests within this realm (assuming that
      the authentication scheme itself does not require otherwise, such
      as credentials that vary according to a challenge value or using
      synchronized clocks).

      When a shared cache (see &lt;a href=&quot;#section-13.7&quot;&gt;section 13.7&lt;/a&gt;) receives a request
      containing an Authorization field, it MUST NOT return the
      corresponding response as a reply to any other request, unless one
      of the following specific exceptions holds:

      1. If the response includes the &quot;s-maxage&quot; cache-control
         directive, the cache MAY use that response in replying to a
         subsequent request. But (if the specified maximum age has
         passed) a proxy cache MUST first revalidate it with the origin
         server, using the request-headers from the new request to allow
         the origin server to authenticate the new request. (This is the
         defined behavior for s-maxage.) If the response includes &quot;s-
         maxage=0&quot;, the proxy MUST always revalidate it before re-using
         it.

      2. If the response includes the &quot;must-revalidate&quot; cache-control
         directive, the cache MAY use that response in replying to a
         subsequent request. But if the response is stale, all caches
         MUST first revalidate it with the origin server, using the
         request-headers from the new request to allow the origin server
         to authenticate the new request.

      3. If the response includes the &quot;public&quot; cache-control directive,
         it MAY be returned in reply to any subsequent request.</source>
          <target state="translated">Пользовательский агент, который желает аутентифицироваться на сервере - обычно, но не обязательно, после получения ответа 401 - делает это, включая в запрос поле заголовка запроса авторизации. Значение поля авторизации состоит из учетных данных, содержащих информацию аутентификации пользовательского агента для области запрашиваемого ресурса. Authorization = &quot;Authorization&quot; &quot;:&quot; учетные данные Аутентификация доступа по протоколу HTTP описана в разделе &amp;laquo;Аутентификация HTTP: базовая и дайджест-аутентификация доступа&amp;raquo; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. Если запрос аутентифицирован и указана область, одни и те же учетные данные ДОЛЖНЫ быть действительными для всех других запросов в этой области (при условии, что сама схема аутентификации не требует иного, например учетные данные, которые меняются в зависимости от значения запроса или с использованием синхронизированных часов) , Когда общий кеш (см. &lt;a href=&quot;#section-13.7&quot;&gt;Раздел 13.7&lt;/a&gt;) получает запрос, содержащий поле авторизации, он НЕ ДОЛЖЕН возвращать соответствующий ответ в качестве ответа на любой другой запрос, если только не выполняется одно из следующих особых исключений: 1. Если ответ включает директиву управления кешем &quot;s-maxage&quot;, кэш МОЖЕТ использовать этот ответ при ответе на последующий запрос. Но (если указанный максимальный возраст прошел) прокси-кеш ДОЛЖЕН сначала повторно подтвердить его на исходном сервере, используя заголовки запроса из нового запроса, чтобы позволить исходному серверу аутентифицировать новый запрос. (Это определенное поведение для s-maxage.) Если ответ включает &amp;laquo;s-maxage = 0&amp;raquo;, прокси-сервер ДОЛЖЕН всегда проверять его заново перед повторным использованием. 2. Если ответ включает &quot;must-revalidate &amp;raquo;, кэш МОЖЕТ использовать этот ответ при ответе на последующий запрос. Но если ответ устарел, все кеши ДОЛЖНЫ сначала подтвердить его на исходном сервере, используя заголовки запроса из нового запроса для разрешить исходному серверу аутентифицировать новый запрос. 3. Если ответ включает в себя &amp;laquo;публичную&amp;raquo; директиву управления кешем, он МОЖЕТ быть возвращен в ответ на любой последующий запрос.Если ответ включает &amp;laquo;публичную&amp;raquo; директиву управления кешем, он МОЖЕТ быть возвращен в ответ на любой последующий запрос.Если ответ включает &amp;laquo;публичную&amp;raquo; директиву управления кешем, он МОЖЕТ быть возвращен в ответ на любой последующий запрос.</target>
        </trans-unit>
        <trans-unit id="3eb38217a0a68009475024a823a8a9c28117955a" translate="yes" xml:space="preserve">
          <source>A valid &lt;a href=&quot;../../basics_of_http/mime_types/complete_list_of_mime_types&quot;&gt;MIME type&lt;/a&gt;.</source>
          <target state="translated">Допустимый &lt;a href=&quot;../../basics_of_http/mime_types/complete_list_of_mime_types&quot;&gt;тип MIME&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8fbdf43407e27f9040d31e47e9ef380e7e61d10a" translate="yes" xml:space="preserve">
          <source>A valid policy name consists only of alphanumeric characters, or one of &quot;&lt;code&gt;-#=_/@.%&lt;/code&gt;&quot;. A star (&lt;code&gt;*&lt;/code&gt;) as a policy name instructs the user agent to allow any unique policy name ('&lt;code&gt;allow-duplicates&lt;/code&gt;' may relax that further).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38f471ad34bbb66b972153ec1a0f3abc561da01" translate="yes" xml:space="preserve">
          <source>A value of &lt;code&gt;On&lt;/code&gt; indicates explicit user opt-in into a reduced data usage mode on the client, and when communicated to origins allows them to deliver alternative content to reduce the data downloaded such as smaller image and video resources, different markup and styling, disabled polling and automatic updates, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e6db7c902ddf3358740b6f48b9c66a1329f13a" translate="yes" xml:space="preserve">
          <source>A value of &lt;strong&gt;-1&lt;/strong&gt; will disable caching, requiring a preflight OPTIONS check for all calls.</source>
          <target state="translated">Значение &lt;strong&gt;-1&lt;/strong&gt; отключает кеширование, требуя предварительной проверки OPTIONS для всех вызовов.</target>
        </trans-unit>
        <trans-unit id="5889b8a74eb0576ba107584be5617ae14bc061f0" translate="yes" xml:space="preserve">
          <source>A version number of the product.</source>
          <target state="translated">Номер версии продукта.</target>
        </trans-unit>
        <trans-unit id="e076002695264f7b92b71f90d2a5b52b89009a69" translate="yes" xml:space="preserve">
          <source>A very comprehensive article on browser internals and request flow through HTTP protocol. A MUST-READ for any web developer.</source>
          <target state="translated">Очень подробная статья о внутреннем устройстве браузера и потоке запросов по протоколу HTTP.ДОЛЖНА ЧИТАТЬСЯ для любого веб-разработчика.</target>
        </trans-unit>
        <trans-unit id="1fa040618dd780f3a0aef82d86f3446592dbd355" translate="yes" xml:space="preserve">
          <source>A video file, possibly with audio, in the OGG container format. Theora is the usual video codec used within it; Vorbis is the usual audio codec.</source>
          <target state="translated">Видеофайл,возможно,со звуком,в формате OGG-контейнера.Theora-обычный видеокодек,используемый в нем;Vorbis-обычный аудиокодек.</target>
        </trans-unit>
        <trans-unit id="4c86cb2facddc78dcf860daaf77f4a3854799edb" translate="yes" xml:space="preserve">
          <source>A video file, possibly with audio, in the Ogg container format. Theora is the usual video codec used within it; Vorbis is the usual audio codec, although Opus is becoming more common.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa979d0019d43f2c9b25ac426f79d9a5706a185" translate="yes" xml:space="preserve">
          <source>A video file, possibly with audio, in the WebM container format. VP8 and VP9 are the most common video codecs; Vorbis and Opus the most common audio codecs.</source>
          <target state="translated">Видеофайл,возможно со звуком,в формате WebM-контейнера.VP8 и VP9-наиболее распространенные видеокодеки;Vorbis и Opus-наиболее распространенные аудиокодеки.</target>
        </trans-unit>
        <trans-unit id="19beb4d587d6a250a74c565550aaab0fc61d9928" translate="yes" xml:space="preserve">
          <source>A vulnerable application on a sub-domain can set a cookie with the &lt;code&gt;Domain&lt;/code&gt; attribute, which gives access to that cookie on all other subdomains. This mechanism can be abused in a &lt;em&gt;session fixation&lt;/em&gt; attack. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Session_fixation&quot;&gt;session fixation&lt;/a&gt; for primary mitigation methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a189a3656c45672cb9f6d2aac0bf5a253e8d427" translate="yes" xml:space="preserve">
          <source>A web site administrator for an online banking site wants to ensure that all its content is loaded using SSL, in order to prevent attackers from eavesdropping on requests.</source>
          <target state="translated">Администратор сайта для сайта интернет-банка хочет гарантировать,что все его содержимое загружается с помощью SSL,чтобы злоумышленники не могли прослушивать запросы.</target>
        </trans-unit>
        <trans-unit id="b4a4bd38a2a84044ff7aca2e9392bd40ae65380b" translate="yes" xml:space="preserve">
          <source>A web site administrator for an online banking site wants to ensure that all its content is loaded using TLS, in order to prevent attackers from eavesdropping on requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a6cf5a14fccb26323ff827be190ed35fcc6e26" translate="yes" xml:space="preserve">
          <source>A web site administrator of a web mail site wants to allow HTML in email, as well as images loaded from anywhere, but not JavaScript or other potentially dangerous content.</source>
          <target state="translated">Администратор сайта хочет разрешить HTML в электронной почте,а также изображения,загружаемые откуда угодно,но не JavaScript или другое потенциально опасное содержимое.</target>
        </trans-unit>
        <trans-unit id="7426821d25f9d1be7cdc0dee42a0c8e03a96be3c" translate="yes" xml:space="preserve">
          <source>A web site administrator wants all content to come from the site's own origin (this excludes subdomains.)</source>
          <target state="translated">Администратор сайта хочет,чтобы все содержимое сайта исходило из его собственного происхождения (это исключает субдомены).</target>
        </trans-unit>
        <trans-unit id="094a073a77d4ea29e21e0f0aa48a85ef6fc064f6" translate="yes" xml:space="preserve">
          <source>A web site administrator wants to allow content from a trusted domain and all its subdomains (it doesn't have to be the same domain that the CSP is set on.)</source>
          <target state="translated">Администратор сайта хочет разрешить контент из доверенного домена и всех его субдоменов (это не обязательно должен быть тот же домен,на котором установлен CSP).</target>
        </trans-unit>
        <trans-unit id="c81c7277d68cf8c04b37b98fb5f5a7cea290054e" translate="yes" xml:space="preserve">
          <source>A web site administrator wants to allow users of a web application to include images from any origin in their own content, but to restrict audio or video media to trusted providers, and all scripts only to a specific server that hosts trusted code.</source>
          <target state="translated">Администратор сайта хочет разрешить пользователям веб-приложений включать изображения любого происхождения в их собственное содержимое,но ограничивать аудио или видео носители только доверенными провайдерами,а все скрипты только конкретным сервером,на котором размещен доверенный код.</target>
        </trans-unit>
        <trans-unit id="9498f184ab4111b05c76c6fbfcfb1b645e8241e1" translate="yes" xml:space="preserve">
          <source>A whitelist for specific inline scripts using a cryptographic nonce (number used once). The server must generate a unique nonce value each time it transmits a policy. It is critical to provide an unguessable nonce, as bypassing a resource&amp;rsquo;s policy is otherwise trivial. See &lt;a href=&quot;script-src#Unsafe_inline_script&quot;&gt;unsafe inline script&lt;/a&gt; for an example. Specifying nonce makes a modern browser ignore &lt;code&gt;'unsafe-inline'&lt;/code&gt; which could still be set for older browsers without nonce support.</source>
          <target state="translated">Белый список для определенных встроенных скриптов с использованием криптографического одноразового номера (номер используется один раз). Сервер должен генерировать уникальное значение одноразового номера каждый раз при передаче политики. Очень важно предоставить неугадываемый одноразовый номер, поскольку в противном случае обход политики ресурса тривиален. См. Пример &lt;a href=&quot;script-src#Unsafe_inline_script&quot;&gt;небезопасного встроенного скрипта&lt;/a&gt; . Указание временного значения делает современный браузер игнорировать &lt;code&gt;'unsafe-inline'&lt;/code&gt; , который все еще может быть установлен для старых браузеров без поддержки Нонс.</target>
        </trans-unit>
        <trans-unit id="607dbcd9743fda8a80dc6941bb1406560915ac51" translate="yes" xml:space="preserve">
          <source>A.1.  Changes from HTTP/1.0</source>
          <target state="translated">A.1.Изменения по сравнению с HTTP/1.0</target>
        </trans-unit>
        <trans-unit id="71e7c2181bcefe9076dade6180831af529a35160" translate="yes" xml:space="preserve">
          <source>A.1.  MIME-Version</source>
          <target state="translated">A.1 MIME-версия</target>
        </trans-unit>
        <trans-unit id="934d78a07914cb136497f33678b675d378c9c1c3" translate="yes" xml:space="preserve">
          <source>A.1.  Notes on Empty XML Elements</source>
          <target state="translated">A.1.Примечания к пустым элементам XML</target>
        </trans-unit>
        <trans-unit id="0a1cd245606e42807b94c9f374a34eccc7961ec0" translate="yes" xml:space="preserve">
          <source>A.1.1.  Multihomed Web Servers</source>
          <target state="translated">A.1.1.Многодоменные веб-серверы</target>
        </trans-unit>
        <trans-unit id="31ff08eb30576725916a16c707537cd82a7aa072" translate="yes" xml:space="preserve">
          <source>A.1.2.  Keep-Alive Connections</source>
          <target state="translated">A.1.2.Подключения Keep-Alive</target>
        </trans-unit>
        <trans-unit id="4be274cc414e041aa285536fd1d9abea04688061" translate="yes" xml:space="preserve">
          <source>A.1.3.  Introduction of Transfer-Encoding</source>
          <target state="translated">A.1.3.Введение трансфертного кодирования</target>
        </trans-unit>
        <trans-unit id="b625deb328c263df8d663f465330058cd2f6a3db" translate="yes" xml:space="preserve">
          <source>A.2.  Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;</source>
          <target state="translated">А.2. Отличия от &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c37ee894c4d97db6e012967c60c8ae1646c47d2" translate="yes" xml:space="preserve">
          <source>A.2.  Conversion to Canonical Form</source>
          <target state="translated">A.2.Преобразование в каноническую форму</target>
        </trans-unit>
        <trans-unit id="13a5586a515762626176f0ba79e73a11ee5d37bc" translate="yes" xml:space="preserve">
          <source>A.2.  Notes on Illegal XML Processing</source>
          <target state="translated">A.2.Примечания по незаконной обработке XML</target>
        </trans-unit>
        <trans-unit id="5c000b068248fb6a64403618c2b71c2ec3faa5ef" translate="yes" xml:space="preserve">
          <source>A.3.  Conversion of Date Formats</source>
          <target state="translated">A.3.Преобразование форматов даты</target>
        </trans-unit>
        <trans-unit id="ddb60af0705f2ed7e764e5c836e357c9a4588554" translate="yes" xml:space="preserve">
          <source>A.3.  Example - XML Syntax Error</source>
          <target state="translated">A.3.Пример-XML ошибка синтаксиса</target>
        </trans-unit>
        <trans-unit id="c26036cb9e7529396282952036d022db566e885e" translate="yes" xml:space="preserve">
          <source>A.4.  Conversion of Content-Encoding</source>
          <target state="translated">A.4.Преобразование Content-Encoding</target>
        </trans-unit>
        <trans-unit id="6ea2c416d6e0ef6e9a66400fec7ff2af31243cc5" translate="yes" xml:space="preserve">
          <source>A.4.  Example - Unexpected XML Element</source>
          <target state="translated">A.4.Пример-Неожиданный элемент XML</target>
        </trans-unit>
        <trans-unit id="a266ccc4168540071853c8f0598387442256e895" translate="yes" xml:space="preserve">
          <source>A.5.  Conversion of Content-Transfer-Encoding</source>
          <target state="translated">A.5.Преобразование конверсии Контент-Трансфер-Энкодирование</target>
        </trans-unit>
        <trans-unit id="206ee8943d80ea391322bf6e9311cef2b5532423" translate="yes" xml:space="preserve">
          <source>A.6.  MHTML and Line Length Limitations</source>
          <target state="translated">A.6.Ограничения по длине линии и MHTML</target>
        </trans-unit>
        <trans-unit id="b463080c85b05823aaddc6fc68a219f5680ee32b" translate="yes" xml:space="preserve">
          <source>AAC audio</source>
          <target state="translated">звук AAC</target>
        </trans-unit>
        <trans-unit id="3ed3e9ef5eed89882da580130970d5049696337c" translate="yes" xml:space="preserve">
          <source>ABNF List Extension: #rule (RFC 7230)</source>
          <target state="translated">Расширение списка ABNF:#rule (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="ebcd0787537de59613870f2b356e9e9a51dc2254" translate="yes" xml:space="preserve">
          <source>ACCEPT POST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1588a2512f762c137bb4684cdcc818aa63d0393" translate="yes" xml:space="preserve">
          <source>ALLOW-FROM</source>
          <target state="translated">ALLOW-FROM</target>
        </trans-unit>
        <trans-unit id="5766cf5be7954090e3b573bc2ac357eb125cb979" translate="yes" xml:space="preserve">
          <source>APIs based on HTTP</source>
          <target state="translated">API на базе HTTP</target>
        </trans-unit>
        <trans-unit id="8ccf350ab0d3a2a51ea1d5c6a29807a0e4f960cf" translate="yes" xml:space="preserve">
          <source>APNG</source>
          <target state="translated">APNG</target>
        </trans-unit>
        <trans-unit id="491f27fea75b26dbfefa2ee1bed63b09db887b09" translate="yes" xml:space="preserve">
          <source>AVI: Audio Video Interleave</source>
          <target state="translated">AVI:Аудио-видео интерлейв</target>
        </trans-unit>
        <trans-unit id="cd437865cbac7655f8b86519aea764f378093804" translate="yes" xml:space="preserve">
          <source>Abbreviation</source>
          <target state="translated">Abbreviation</target>
        </trans-unit>
        <trans-unit id="24750e2e16dfc2b89dc7f623971f1a084bde0d9a" translate="yes" xml:space="preserve">
          <source>Abstract

   The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level protocol for distributed, collaborative, hypermedia information
   systems.  This document defines the HTTP Authentication framework.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Section&amp;nbsp;2 of RFC 5741&lt;/a&gt;.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7235&quot;&gt;http://www.rfc-editor.org/info/rfc7235&lt;/a&gt;.

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this 

   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
      &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;. Conformance and Error Handling 
      &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;. Syntax Notation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Access Authentication Framework 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. Challenge and Response 
      &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;. Protection Space (Realm) 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Status Code Definitions 
      &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;. 401 Unauthorized 
      &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;. 407 Proxy Authentication Required 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Header Field Definitions 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. WWW-Authenticate 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Authorization 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Proxy-Authenticate 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Proxy-Authorization 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Authentication Scheme Registry 
           &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;. Considerations for New Authentication Schemes 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Status Code Registration 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Header Field Registration 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Confidentiality of Credentials 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Authentication Credentials and Idle Clients 
      &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;. Protection Spaces 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Acknowledgments 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. References 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Changes from RFCs 2616 and 2617 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Imported ABNF 
   &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. Collected ABNF 
   Index .............................................................</source>
          <target state="translated">Аннотация Протокол передачи гипертекста (HTTP) - это протокол уровня приложений без сохранения состояния для распределенных совместных гипермедийных информационных систем. Этот документ определяет структуру HTTP-аутентификации. Статус этой памятки. Это документ, посвященный стандартам Интернета. Этот документ является продуктом Инженерной группы Интернета (IETF). Он представляет собой консенсус сообщества IETF. Он прошел общественное рассмотрение и был одобрен для публикации Руководящей группой Интернет-разработок (IESG). Дополнительная информация о стандартах Интернета доступна в &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;разделе 2 RFC 5741&lt;/a&gt; . Информацию о текущем статусе этого документа, любых ошибках и способах обратной связи по нему можно получить по адресу &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7235&quot;&gt;http://www.rfc-editor.org/info/rfc7235.&lt;/a&gt;, Уведомление об авторских правах Авторские права (c) 2014 IETF Trust и лица, указанные в качестве авторов документа. Все права защищены. Этот документ регулируется &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; и Правовыми положениями IETF Trust, касающимися документов IETF ( &lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) действует на дату публикации этого документа. Пожалуйста, внимательно ознакомьтесь с этими документами, поскольку они описывают ваши права и ограничения в отношении этого документа. Компоненты кода, извлеченные из этого документа, должны включать упрощенный текст лицензии BSD, как описано в разделе 4.e Правовых положений Trust, и предоставляются без гарантии, как описано в упрощенной лицензии BSD. Этот документ может содержать материалы из Документов IETF или Вкладов IETF, опубликованных или сделанных общедоступными до 10 ноября 2008 г. Лицо (лица), контролирующее авторские права на некоторые из этих материалов, возможно, не предоставило IETF Trust право разрешать модификации таких материалов. вне процесса стандартизации IETF.Без получения соответствующей лицензии от лица (лиц), контролирующего авторские права на такие материалы, этот документ не может быть изменен за пределами Процесса стандартизации IETF, и его производные работы не могут быть созданы вне Процесса стандартизации IETF, за исключением форматирования его для публикация в виде RFC или перевод на другие языки, кроме английского. Оглавление &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . Введение &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; . Соответствие и обработка ошибок &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; . Обозначение синтаксиса &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . Структура аутентификации доступа &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; . Вызов и ответ &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; . Защитное пространство (область) &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . Определения кодов состояния &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; . 401 Несанкционированный &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; . 407 Требуется проверка подлинности прокси &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . Определения полей заголовка &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . WWW-аутентификация &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . Авторизация &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . Прокси-аутентификация &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; . Прокси-авторизация &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;, Соображения IANA &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; . Реестр схемы аутентификации &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt; . Процедура &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt; . Соображения по поводу новых схем аутентификации &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; . Регистрация кода состояния &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; . Регистрация поля заголовка &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . Соображения безопасности &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; . Конфиденциальность учетных данных &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; . Учетные данные для аутентификации и неактивные клиенты &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; . Защитные пространства &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . Благодарности &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . Ссылки &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; . Нормативные ссылки &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; . Информативные ссылки &lt;a href=&quot;#appendix-A&quot;&gt;Приложение А&lt;/a&gt; . Изменения от РЛК 2616 и 2617 &lt;a href=&quot;#appendix-B&quot;&gt;Приложение B&lt;/a&gt; . Imported ABNF &lt;a href=&quot;#appendix-C&quot;&gt;Приложение C&lt;/a&gt; . Собранный индекс ABNF ............................................... ..............</target>
        </trans-unit>
        <trans-unit id="b5cf0df594932a60c94f36c291eebcfe03889d61" translate="yes" xml:space="preserve">
          <source>Abstract

   The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level protocol for distributed, collaborative, hypertext information
   systems.  This document defines HTTP caches and the associated header
   fields that control cache behavior or indicate cacheable response
   messages.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Section&amp;nbsp;2 of RFC 5741&lt;/a&gt;.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7234&quot;&gt;http://www.rfc-editor.org/info/rfc7234&lt;/a&gt;. 

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
      &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;. Conformance and Error Handling 
      &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;. Syntax Notation 
           &lt;a href=&quot;#section-1.2.1&quot;&gt;1.2.1&lt;/a&gt;. Delta Seconds 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Overview of Cache Operation 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Storing Responses in Caches 
      &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;. Storing Incomplete Responses 
      &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;. Storing Responses to Authenticated Requests 
      &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;. Combining Partial Content 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Constructing Responses from Caches 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. Calculating Secondary Keys with Vary 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Freshness 
           &lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1&lt;/a&gt;. Calculating Freshness Lifetime 
           &lt;a href=&quot;#section-4.2.2&quot;&gt;4.2.2&lt;/a&gt;. Calculating Heuristic Freshness 
           &lt;a href=&quot;#section-4.2.3&quot;&gt;4.2.3&lt;/a&gt;. Calculating Age 
           &lt;a href=&quot;#section-4.2.4&quot;&gt;4.2.4&lt;/a&gt;. Serving Stale Responses 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Validation 
           &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt;. Sending a Validation Request 
           &lt;a href=&quot;#section-4.3.2&quot;&gt;4.3.2&lt;/a&gt;. Handling a Received Validation Request ............. 

           &lt;a href=&quot;#section-4.3.3&quot;&gt;4.3.3&lt;/a&gt;. Handling a Validation Response 
           &lt;a href=&quot;#section-4.3.4&quot;&gt;4.3.4&lt;/a&gt;. Freshening Stored Responses upon Validation 
           &lt;a href=&quot;#section-4.3.5&quot;&gt;4.3.5&lt;/a&gt;. Freshening Responses via HEAD 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Invalidation 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Header Field Definitions 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Age 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Cache-Control 
           &lt;a href=&quot;#section-5.2.1&quot;&gt;5.2.1&lt;/a&gt;. Request Cache-Control Directives 
           &lt;a href=&quot;#section-5.2.2&quot;&gt;5.2.2&lt;/a&gt;. Response Cache-Control Directives 
           &lt;a href=&quot;#section-5.2.3&quot;&gt;5.2.3&lt;/a&gt;. Cache Control Extensions 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Expires 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Pragma 
      &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;. Warning 
           &lt;a href=&quot;#section-5.5.1&quot;&gt;5.5.1&lt;/a&gt;. Warning: 110 - &quot;Response is Stale&quot; 
           &lt;a href=&quot;#section-5.5.2&quot;&gt;5.5.2&lt;/a&gt;. Warning: 111 - &quot;Revalidation Failed&quot; 
           &lt;a href=&quot;#section-5.5.3&quot;&gt;5.5.3&lt;/a&gt;. Warning: 112 - &quot;Disconnected Operation&quot; 
           &lt;a href=&quot;#section-5.5.4&quot;&gt;5.5.4&lt;/a&gt;. Warning: 113 - &quot;Heuristic Expiration&quot; 
           &lt;a href=&quot;#section-5.5.5&quot;&gt;5.5.5&lt;/a&gt;. Warning: 199 - &quot;Miscellaneous Warning&quot; 
           &lt;a href=&quot;#section-5.5.6&quot;&gt;5.5.6&lt;/a&gt;. Warning: 214 - &quot;Transformation Applied&quot; 
           &lt;a href=&quot;#section-5.5.7&quot;&gt;5.5.7&lt;/a&gt;. Warning: 299 - &quot;Miscellaneous Persistent Warning&quot; ..32
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. History Lists 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Cache Directive Registry 
           &lt;a href=&quot;#section-7.1.1&quot;&gt;7.1.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-7.1.2&quot;&gt;7.1.2&lt;/a&gt;. Considerations for New Cache Control Directives 
           &lt;a href=&quot;#section-7.1.3&quot;&gt;7.1.3&lt;/a&gt;. Registrations 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Warn Code Registry 
           &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt;. Registrations 
      &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;. Header Field Registration 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. Security Considerations 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Acknowledgments 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. References 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;&lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Imported ABNF 
   &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. Collected ABNF 
   Index .............................................................</source>
          <target state="translated">Аннотация Протокол передачи гипертекста (HTTP) - это протокол уровня приложений без сохранения состояния для распределенных, совместных гипертекстовых информационных систем. Этот документ определяет кеши HTTP и связанные поля заголовка, которые управляют поведением кеша или указывают кэшируемые ответные сообщения. Статус этой памятки. Это документ, посвященный стандартам Интернета. Этот документ является продуктом Инженерной группы Интернета (IETF). Он представляет собой консенсус сообщества IETF. Он прошел общественное рассмотрение и был одобрен для публикации Руководящей группой Интернет-разработок (IESG). Дополнительная информация о стандартах Интернета доступна в &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;разделе 2 RFC 5741.&lt;/a&gt;, Информацию о текущем статусе этого документа, обнаруженных ошибках и способах обратной связи можно получить по адресу &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7234&quot;&gt;http://www.rfc-editor.org/info/rfc7234&lt;/a&gt; . Уведомление об авторских правах Авторские права (c) 2014 IETF Trust и лица, указанные в качестве авторов документа. Все права защищены. Этот документ регулируется &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; и Правовыми положениями IETF Trust, касающимися документов IETF ( &lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) действует на дату публикации этого документа. Пожалуйста, внимательно ознакомьтесь с этими документами, поскольку они описывают ваши права и ограничения в отношении этого документа. Компоненты кода, извлеченные из этого документа, должны включать упрощенный текст лицензии BSD, как описано в разделе 4.e Правовых положений Trust, и предоставляются без гарантии, как описано в упрощенной лицензии BSD. Этот документ может содержать материалы из Документов IETF или Вкладов IETF, опубликованных или сделанных общедоступными до 10 ноября 2008 г. Лицо (лица), контролирующее авторские права на некоторые из этих материалов, возможно, не предоставило IETF Trust право разрешать модификации таких материалов. вне процесса стандартизации IETF.Без получения соответствующей лицензии от лица (лиц), контролирующего авторские права на такие материалы, этот документ не может быть изменен за пределами Процесса стандартизации IETF, и его производные работы не могут быть созданы вне Процесса стандартизации IETF, за исключением форматирования его для публикация в виде RFC или перевод на другие языки, кроме английского. Оглавление &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . Введение &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; . Соответствие и обработка ошибок &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; . Обозначение синтаксиса &lt;a href=&quot;#section-1.2.1&quot;&gt;1.2.1&lt;/a&gt; . Дельта-секунды &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . Обзор работы с кешем &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . Хранение ответов в кешах &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; . Сохранение неполных ответов &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; . Хранение ответов на аутентифицированные запросы &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; . Объединение частичного содержимого &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . Построение ответов из кешей &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . Расчет вторичных ключей с помощью Vary &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . Свежесть &lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1&lt;/a&gt; . Расчет срока свежести &lt;a href=&quot;#section-4.2.2&quot;&gt;4.2.2&lt;/a&gt;, Расчет эвристической свежести &lt;a href=&quot;#section-4.2.3&quot;&gt;4.2.3&lt;/a&gt; . Расчет возраста &lt;a href=&quot;#section-4.2.4&quot;&gt;4.2.4&lt;/a&gt; . Обслуживание устаревших ответов &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . Проверка &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt; . Отправка запроса на валидацию &lt;a href=&quot;#section-4.3.2&quot;&gt;4.3.2&lt;/a&gt; . Обработка полученного запроса на валидацию ............. &lt;a href=&quot;#section-4.3.3&quot;&gt;4.3.3&lt;/a&gt; . Обработка проверочного ответа &lt;a href=&quot;#section-4.3.4&quot;&gt;4.3.4&lt;/a&gt; . Обновление сохраненных ответов при валидации &lt;a href=&quot;#section-4.3.5&quot;&gt;4.3.5&lt;/a&gt; . Обновление ответов через HEAD &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; . Признание недействительным &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; . Определения полей заголовка &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; . Возраст &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; . Cache-Control &lt;a href=&quot;#section-5.2.1&quot;&gt;5.2.1&lt;/a&gt; . Запросить директивы управления кешем &lt;a href=&quot;#section-5.2.2&quot;&gt;5.2.2&lt;/a&gt; . Директивы управления кэшем ответов &lt;a href=&quot;#section-5.2.3&quot;&gt;5.2.3&lt;/a&gt; . Расширения управления кешем &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; . Срок действия истекает &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt; . Pragma &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt; . Предупреждение &lt;a href=&quot;#section-5.5.1&quot;&gt;5.5.1&lt;/a&gt; . Предупреждение: 110 - &amp;laquo;Ответ устарел&amp;raquo; &lt;a href=&quot;#section-5.5.2&quot;&gt;5.5.2&lt;/a&gt; . Предупреждение: 111 - &amp;laquo;Повторная проверка не удалась&amp;raquo; &lt;a href=&quot;#section-5.5.3&quot;&gt;5.5.3&lt;/a&gt; . Предупреждение: 112 - &amp;laquo;Работа в отключенном состоянии&amp;raquo; &lt;a href=&quot;#section-5.5.4&quot;&gt;5.5.4&lt;/a&gt; . Предупреждение: 113 - &amp;laquo;Эвристическое истечение&amp;raquo; &lt;a href=&quot;#section-5.5.5&quot;&gt;5.5.5&lt;/a&gt; . Предупреждение: 199 - &amp;laquo;Прочие предупреждения&amp;raquo; &lt;a href=&quot;#section-5.5.6&quot;&gt;5.5.6&lt;/a&gt;, Предупреждение: 214 - &amp;laquo;Преобразование применено&amp;raquo; &lt;a href=&quot;#section-5.5.7&quot;&gt;5.5.7&lt;/a&gt; . Предупреждение: 299 - &amp;laquo;Разное постоянное предупреждение&amp;raquo; ..32 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . Списки истории &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . Соображения IANA &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; . Реестр директивы кеширования &lt;a href=&quot;#section-7.1.1&quot;&gt;7.1.1&lt;/a&gt; . Порядок &lt;a href=&quot;#section-7.1.2&quot;&gt;действий 7.1.2&lt;/a&gt; . Соображения относительно новых директив управления &lt;a href=&quot;#section-7.1.3&quot;&gt;кешем 7.1.3&lt;/a&gt; . Регистрации &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; . Реестр кода предупреждений &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt; . Порядок &lt;a href=&quot;#section-7.2.2&quot;&gt;действий 7.2.2&lt;/a&gt; . Регистрации &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt; . Регистрация поля заголовка &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . Соображения безопасности &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;, Благодарности &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; . Ссылки &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; . Нормативные ссылки &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; . Информативные ссылки &lt;a href=&quot;#appendix-A&quot;&gt;Приложение A&lt;/a&gt; . Изменения по сравнению с &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616 &lt;/a&gt;&lt;a href=&quot;#appendix-B&quot;&gt;Приложение B&lt;/a&gt; . Imported ABNF &lt;a href=&quot;#appendix-C&quot;&gt;Приложение C&lt;/a&gt; . Собранный индекс ABNF ............................................... ..............</target>
        </trans-unit>
        <trans-unit id="ccfa8b0f43222ebcd97d708793fc8cc336ca94f7" translate="yes" xml:space="preserve">
          <source>Abstract

   The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level protocol for distributed, collaborative, hypertext information
   systems.  This document defines HTTP/1.1 conditional requests,
   including metadata header fields for indicating state changes,
   request header fields for making preconditions on such state, and
   rules for constructing the responses to a conditional request when
   one or more preconditions evaluate to false.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Section&amp;nbsp;2 of RFC 5741&lt;/a&gt;.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7232&quot;&gt;http://www.rfc-editor.org/info/rfc7232&lt;/a&gt;. 

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
      &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;. Conformance and Error Handling 
      &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;. Syntax Notation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Validators 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. Weak versus Strong 
      &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;. Last-Modified 
           &lt;a href=&quot;#section-2.2.1&quot;&gt;2.2.1&lt;/a&gt;. Generation 
           &lt;a href=&quot;#section-2.2.2&quot;&gt;2.2.2&lt;/a&gt;. Comparison 
      &lt;a href=&quot;#section-2.3&quot;&gt;2.3&lt;/a&gt;. ETag 
           &lt;a href=&quot;#section-2.3.1&quot;&gt;2.3.1&lt;/a&gt;. Generation 
           &lt;a href=&quot;#section-2.3.2&quot;&gt;2.3.2&lt;/a&gt;. Comparison 
           2.3.3. Example: Entity-Tags Varying on
                  Content-Negotiated Resources 
      &lt;a href=&quot;#section-2.4&quot;&gt;2.4&lt;/a&gt;. When to Use Entity-Tags and Last-Modified Dates 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Precondition Header Fields 
      &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;. If-Match 
      &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;. If-None-Match 
      &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;. If-Modified-Since 
      &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt;. If-Unmodified-Since 
      &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt;. If-Range 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Status Code Definitions 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. 304 Not Modified 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. 412 Precondition Failed 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Evaluation 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Precedence 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Status Code Registration 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Header Field Registration 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. Security Considerations 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Acknowledgments 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. References 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;&lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Imported ABNF 
   &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. Collected ABNF 
   Index .............................................................</source>
          <target state="translated">Аннотация Протокол передачи гипертекста (HTTP) - это протокол уровня приложений без сохранения состояния для распределенных, совместных гипертекстовых информационных систем. Этот документ определяет условные запросы HTTP / 1.1, включая поля заголовка метаданных для индикации изменений состояния, поля заголовка запроса для создания предварительных условий для такого состояния и правила для построения ответов на условный запрос, когда одно или несколько предварительных условий оцениваются как ложные. Статус этой памятки. Это документ, посвященный стандартам Интернета. Этот документ является продуктом Инженерной группы Интернета (IETF). Он представляет собой консенсус сообщества IETF. Он прошел общественное рассмотрение и был одобрен для публикации Руководящей группой Интернет-разработок (IESG).Дополнительная информация о стандартах Интернета доступна в&lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Раздел 2 RFC 5741&lt;/a&gt; . Информацию о текущем статусе этого документа, любых ошибках и способах обратной связи можно получить по адресу &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7232&quot;&gt;http://www.rfc-editor.org/info/rfc7232&lt;/a&gt; . Уведомление об авторских правах Авторские права (c) 2014 IETF Trust и лица, указанные в качестве авторов документа. Все права защищены. Этот документ регулируется &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; и Правовыми положениями IETF Trust, касающимися документов IETF ( &lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) действует на дату публикации этого документа. Пожалуйста, внимательно ознакомьтесь с этими документами, поскольку они описывают ваши права и ограничения в отношении этого документа. Компоненты кода, извлеченные из этого документа, должны включать упрощенный текст лицензии BSD, как описано в разделе 4.e Правовых положений Trust, и предоставляются без гарантии, как описано в упрощенной лицензии BSD. Этот документ может содержать материалы из Документов IETF или Вкладов IETF, опубликованных или сделанных общедоступными до 10 ноября 2008 г. Лицо (лица), контролирующее авторские права на некоторые из этих материалов, возможно, не предоставило IETF Trust право разрешать модификации таких материалов. вне процесса стандартизации IETF.Без получения соответствующей лицензии от лица (лиц), контролирующего авторские права на такие материалы, этот документ не может быть изменен за пределами Процесса стандартизации IETF, и его производные работы не могут быть созданы вне Процесса стандартизации IETF, за исключением форматирования его для публикация в виде RFC или перевод на другие языки, кроме английского. Оглавление &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . Введение &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; . Соответствие и обработка ошибок &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; . Обозначение синтаксиса &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . Валидаторы &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; . Слабый против сильного &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; . Последнее изменение &lt;a href=&quot;#section-2.2.1&quot;&gt;2.2.1&lt;/a&gt; . Поколение &lt;a href=&quot;#section-2.2.2&quot;&gt;2.2.2&lt;/a&gt; . Сравнение &lt;a href=&quot;#section-2.3&quot;&gt;2.3&lt;/a&gt; . ETag &lt;a href=&quot;#section-2.3.1&quot;&gt;2.3.1&lt;/a&gt; . Поколение &lt;a href=&quot;#section-2.3.2&quot;&gt;2.3.2&lt;/a&gt; . Сравнение 2.3.3. Пример: Entity-Tags различаются для ресурсов с согласованным содержанием &lt;a href=&quot;#section-2.4&quot;&gt;2.4&lt;/a&gt; . Когда использовать Entity-Tags и даты последнего изменения &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . Поля заголовка предварительного условия &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;, Если совпадение &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; . Если-нет-соответствует &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; . Если-Изменено-Начиная с &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; . Если-без изменений-с &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt; . Если-диапазон &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . Определения кодов состояния &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . 304 Без изменений &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . 412 Ошибка предварительного условия &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; . Оценка &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . Приоритет &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . Соображения IANA &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; . Регистрация кода состояния &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; . Регистрация поля заголовка &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . Соображения безопасности &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; . Благодарности &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; . Ссылки &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;, Нормативные ссылки &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; . Информативные ссылки &lt;a href=&quot;#appendix-A&quot;&gt;Приложение A&lt;/a&gt; . Изменения по сравнению с &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616 &lt;/a&gt;&lt;a href=&quot;#appendix-B&quot;&gt;Приложение B&lt;/a&gt; . Imported ABNF &lt;a href=&quot;#appendix-C&quot;&gt;Приложение C&lt;/a&gt; . Собранный индекс ABNF ............................................... ..............</target>
        </trans-unit>
        <trans-unit id="4ab940ed5bb0ef7e467d0859d7a9acd1d3a04f4b" translate="yes" xml:space="preserve">
          <source>Abstract

   The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level protocol for distributed, collaborative, hypertext information
   systems.  This document defines range requests and the rules for
   constructing and combining responses to those requests.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Section&amp;nbsp;2 of RFC 5741&lt;/a&gt;.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7233&quot;&gt;http://www.rfc-editor.org/info/rfc7233&lt;/a&gt;. 

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
      &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;. Conformance and Error Handling 
      &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;. Syntax Notation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Range Units 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. Byte Ranges 
      &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;. Other Range Units 
      &lt;a href=&quot;#section-2.3&quot;&gt;2.3&lt;/a&gt;. Accept-Ranges 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Range Requests 
      &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;. Range 
      &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;. If-Range 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Responses to a Range Request 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. 206 Partial Content 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Content-Range 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Combining Ranges 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. 416 Range Not Satisfiable 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Range Unit Registry 
           &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;. Registrations 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Status Code Registration 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Header Field Registration 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Internet Media Type Registration 
           &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt;. Internet Media Type multipart/byteranges 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Denial-of-Service Attacks Using Range 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Acknowledgments 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. References 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Internet Media Type multipart/byteranges 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;&lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. Imported ABNF 
   &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt;. Collected ABNF 
   Index .............................................................</source>
          <target state="translated">Аннотация Протокол передачи гипертекста (HTTP) - это протокол уровня приложений без сохранения состояния для распределенных, совместных гипертекстовых информационных систем. Этот документ определяет запросы диапазона и правила построения и комбинирования ответов на эти запросы. Статус этой памятки. Это документ, посвященный стандартам Интернета. Этот документ является продуктом Инженерной группы Интернета (IETF). Он представляет собой консенсус сообщества IETF. Он прошел общественное рассмотрение и был одобрен для публикации Руководящей группой Интернет-разработок (IESG). Дополнительная информация о стандартах Интернета доступна в &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;разделе 2 RFC 5741.&lt;/a&gt;, Информацию о текущем статусе этого документа, выявленных ошибках и способах обратной связи можно получить по адресу &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7233&quot;&gt;http://www.rfc-editor.org/info/rfc7233&lt;/a&gt; . Уведомление об авторских правах Авторские права (c) 2014 IETF Trust и лица, указанные в качестве авторов документа. Все права защищены. Этот документ регулируется &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; и Правовыми положениями IETF Trust, касающимися документов IETF ( &lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) действует на дату публикации этого документа. Пожалуйста, внимательно ознакомьтесь с этими документами, поскольку они описывают ваши права и ограничения в отношении этого документа. Компоненты кода, извлеченные из этого документа, должны включать упрощенный текст лицензии BSD, как описано в разделе 4.e Правовых положений Trust, и предоставляются без гарантии, как описано в упрощенной лицензии BSD. Этот документ может содержать материалы из Документов IETF или Вкладов IETF, опубликованных или сделанных общедоступными до 10 ноября 2008 г. Лицо (лица), контролирующее авторские права на некоторые из этих материалов, возможно, не предоставило IETF Trust право разрешать модификации таких материалов. вне процесса стандартизации IETF.Без получения соответствующей лицензии от лица (лиц), контролирующего авторские права на такие материалы, этот документ не может быть изменен за пределами Процесса стандартизации IETF, и его производные работы не могут быть созданы вне Процесса стандартизации IETF, за исключением форматирования его для публикация в виде RFC или перевод на другие языки, кроме английского. Оглавление &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . Введение &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; . Соответствие и обработка ошибок &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; . Обозначение синтаксиса &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . Единицы измерения &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; . Байтовые диапазоны &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; . Другие единицы измерения &lt;a href=&quot;#section-2.3&quot;&gt;2.3&lt;/a&gt; . Допустимые диапазоны &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . Запросы диапазона &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; . Диапазон &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; . Если-диапазон &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . Ответы на запрос диапазона &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . 206 Частичное содержимое &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . Content-Range &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . Комбинирование диапазонов &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; . 416 Диапазон не соответствует требованиям &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; . Соображения IANA &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; . Реестр единиц дальности &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt; . Процедура &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt; . Регистрации &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; . Регистрация кода состояния &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; . Регистрация поля заголовка &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt; . Регистрация типа Интернет-СМИ &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt; . Тип Интернет-носителя multipart / byteranges &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . Соображения безопасности &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; . Атаки отказа в обслуживании с использованием диапазона &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . Благодарности &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . Ссылки &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; . Нормативные ссылки &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; . Информационные ссылки &lt;a href=&quot;#appendix-A&quot;&gt;Приложение A&lt;/a&gt;, Internet Media Type многочастному / byteranges &lt;a href=&quot;#appendix-B&quot;&gt;Приложение B&lt;/a&gt; . Изменения по сравнению с &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616 &lt;/a&gt;&lt;a href=&quot;#appendix-C&quot;&gt;Приложение C&lt;/a&gt; . Imported ABNF &lt;a href=&quot;#appendix-D&quot;&gt;Приложение D&lt;/a&gt; . Собранный индекс ABNF ............................................... ..............</target>
        </trans-unit>
        <trans-unit id="175c5b30db7132745dd409dfe5b4fe160db2ec2b" translate="yes" xml:space="preserve">
          <source>Abstract

   The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level protocol for distributed, collaborative, hypertext information
   systems.  This document defines the semantics of HTTP/1.1 messages,
   as expressed by request methods, request header fields, response
   status codes, and response header fields, along with the payload of
   messages (metadata and body content) and mechanisms for content
   negotiation.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Section&amp;nbsp;2 of RFC 5741&lt;/a&gt;.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7231&quot;&gt;http://www.rfc-editor.org/info/rfc7231&lt;/a&gt;. 

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
      &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;. Conformance and Error Handling 
      &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;. Syntax Notation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Resources 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Representations 
      &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;. Representation Metadata 
           &lt;a href=&quot;#section-3.1.1&quot;&gt;3.1.1&lt;/a&gt;. Processing Representation Data 
           &lt;a href=&quot;#section-3.1.2&quot;&gt;3.1.2&lt;/a&gt;. Encoding for Compression or Integrity 
           &lt;a href=&quot;#section-3.1.3&quot;&gt;3.1.3&lt;/a&gt;. Audience Language 
           &lt;a href=&quot;#section-3.1.4&quot;&gt;3.1.4&lt;/a&gt;. Identification 
      &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;. Representation Data 
      &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;. Payload Semantics 
      &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt;. Content Negotiation 
           &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1&lt;/a&gt;. Proactive Negotiation 
           &lt;a href=&quot;#section-3.4.2&quot;&gt;3.4.2&lt;/a&gt;. Reactive Negotiation 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Request Methods 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. Overview 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Common Method Properties 
           &lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1&lt;/a&gt;. Safe Methods 
           &lt;a href=&quot;#section-4.2.2&quot;&gt;4.2.2&lt;/a&gt;. Idempotent Methods 
           &lt;a href=&quot;#section-4.2.3&quot;&gt;4.2.3&lt;/a&gt;. Cacheable Methods 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Method Definitions 
           &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt;. GET 
           &lt;a href=&quot;#section-4.3.2&quot;&gt;4.3.2&lt;/a&gt;. HEAD 
           &lt;a href=&quot;#section-4.3.3&quot;&gt;4.3.3&lt;/a&gt;. POST 
           &lt;a href=&quot;#section-4.3.4&quot;&gt;4.3.4&lt;/a&gt;. PUT 
           &lt;a href=&quot;#section-4.3.5&quot;&gt;4.3.5&lt;/a&gt;. DELETE 
           &lt;a href=&quot;#section-4.3.6&quot;&gt;4.3.6&lt;/a&gt;. CONNECT 
           &lt;a href=&quot;#section-4.3.7&quot;&gt;4.3.7&lt;/a&gt;. OPTIONS 
           &lt;a href=&quot;#section-4.3.8&quot;&gt;4.3.8&lt;/a&gt;. TRACE 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Request Header Fields 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Controls 
           &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt;. Expect 
           &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;. Max-Forwards 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Conditionals 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Content Negotiation 
           &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1&lt;/a&gt;. Quality Values 
           &lt;a href=&quot;#section-5.3.2&quot;&gt;5.3.2&lt;/a&gt;. Accept 
           &lt;a href=&quot;#section-5.3.3&quot;&gt;5.3.3&lt;/a&gt;. Accept-Charset 
           &lt;a href=&quot;#section-5.3.4&quot;&gt;5.3.4&lt;/a&gt;. Accept-Encoding 
           &lt;a href=&quot;#section-5.3.5&quot;&gt;5.3.5&lt;/a&gt;. Accept-Language 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Authentication Credentials 
      &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;. Request Context 
           &lt;a href=&quot;#section-5.5.1&quot;&gt;5.5.1&lt;/a&gt;. From 
           &lt;a href=&quot;#section-5.5.2&quot;&gt;5.5.2&lt;/a&gt;. Referer 
           &lt;a href=&quot;#section-5.5.3&quot;&gt;5.5.3&lt;/a&gt;. User-Agent ......................................... 

   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Response Status Codes 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Overview of Status Codes 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Informational 1xx 
           &lt;a href=&quot;#section-6.2.1&quot;&gt;6.2.1&lt;/a&gt;. 100 Continue 
           &lt;a href=&quot;#section-6.2.2&quot;&gt;6.2.2&lt;/a&gt;. 101 Switching Protocols 
      &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;. Successful 2xx 
           &lt;a href=&quot;#section-6.3.1&quot;&gt;6.3.1&lt;/a&gt;. 200 OK 
           &lt;a href=&quot;#section-6.3.2&quot;&gt;6.3.2&lt;/a&gt;. 201 Created 
           &lt;a href=&quot;#section-6.3.3&quot;&gt;6.3.3&lt;/a&gt;. 202 Accepted 
           &lt;a href=&quot;#section-6.3.4&quot;&gt;6.3.4&lt;/a&gt;. 203 Non-Authoritative Information 
           &lt;a href=&quot;#section-6.3.5&quot;&gt;6.3.5&lt;/a&gt;. 204 No Content 
           &lt;a href=&quot;#section-6.3.6&quot;&gt;6.3.6&lt;/a&gt;. 205 Reset Content 
      &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt;. Redirection 3xx 
           &lt;a href=&quot;#section-6.4.1&quot;&gt;6.4.1&lt;/a&gt;. 300 Multiple Choices 
           &lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt;. 301 Moved Permanently 
           &lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt;. 302 Found 
           &lt;a href=&quot;#section-6.4.4&quot;&gt;6.4.4&lt;/a&gt;. 303 See Other 
           &lt;a href=&quot;#section-6.4.5&quot;&gt;6.4.5&lt;/a&gt;. 305 Use Proxy 
           &lt;a href=&quot;#section-6.4.6&quot;&gt;6.4.6&lt;/a&gt;. 306 (Unused) 
           &lt;a href=&quot;#section-6.4.7&quot;&gt;6.4.7&lt;/a&gt;. 307 Temporary Redirect 
      &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt;. Client Error 4xx 
           &lt;a href=&quot;#section-6.5.1&quot;&gt;6.5.1&lt;/a&gt;. 400 Bad Request 
           &lt;a href=&quot;#section-6.5.2&quot;&gt;6.5.2&lt;/a&gt;. 402 Payment Required 
           &lt;a href=&quot;#section-6.5.3&quot;&gt;6.5.3&lt;/a&gt;. 403 Forbidden 
           &lt;a href=&quot;#section-6.5.4&quot;&gt;6.5.4&lt;/a&gt;. 404 Not Found 
           &lt;a href=&quot;#section-6.5.5&quot;&gt;6.5.5&lt;/a&gt;. 405 Method Not Allowed 
           &lt;a href=&quot;#section-6.5.6&quot;&gt;6.5.6&lt;/a&gt;. 406 Not Acceptable 
           &lt;a href=&quot;#section-6.5.7&quot;&gt;6.5.7&lt;/a&gt;. 408 Request Timeout 
           &lt;a href=&quot;#section-6.5.8&quot;&gt;6.5.8&lt;/a&gt;. 409 Conflict 
           &lt;a href=&quot;#section-6.5.9&quot;&gt;6.5.9&lt;/a&gt;. 410 Gone 
           &lt;a href=&quot;#section-6.5.10&quot;&gt;6.5.10&lt;/a&gt;. 411 Length Required 
           &lt;a href=&quot;#section-6.5.11&quot;&gt;6.5.11&lt;/a&gt;. 413 Payload Too Large 
           &lt;a href=&quot;#section-6.5.12&quot;&gt;6.5.12&lt;/a&gt;. 414 URI Too Long 
           &lt;a href=&quot;#section-6.5.13&quot;&gt;6.5.13&lt;/a&gt;. 415 Unsupported Media Type 
           &lt;a href=&quot;#section-6.5.14&quot;&gt;6.5.14&lt;/a&gt;. 417 Expectation Failed 
           &lt;a href=&quot;#section-6.5.15&quot;&gt;6.5.15&lt;/a&gt;. 426 Upgrade Required 
      &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;. Server Error 5xx 
           &lt;a href=&quot;#section-6.6.1&quot;&gt;6.6.1&lt;/a&gt;. 500 Internal Server Error 
           &lt;a href=&quot;#section-6.6.2&quot;&gt;6.6.2&lt;/a&gt;. 501 Not Implemented 
           &lt;a href=&quot;#section-6.6.3&quot;&gt;6.6.3&lt;/a&gt;. 502 Bad Gateway 
           &lt;a href=&quot;#section-6.6.4&quot;&gt;6.6.4&lt;/a&gt;. 503 Service Unavailable 
           &lt;a href=&quot;#section-6.6.5&quot;&gt;6.6.5&lt;/a&gt;. 504 Gateway Timeout 
           &lt;a href=&quot;#section-6.6.6&quot;&gt;6.6.6&lt;/a&gt;. 505 HTTP Version Not Supported 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Response Header Fields 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Control Data 
ed            7.1.1. Origination Date 
           &lt;a href=&quot;#section-7.1.2&quot;&gt;7.1.2&lt;/a&gt;. Location 
           &lt;a href=&quot;#section-7.1.3&quot;&gt;7.1.3&lt;/a&gt;. Retry-After ........................................ 

           &lt;a href=&quot;#section-7.1.4&quot;&gt;7.1.4&lt;/a&gt;. Vary 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Validator Header Fields 
      &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;. Authentication Challenges 
      &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt;. Response Context 
           &lt;a href=&quot;#section-7.4.1&quot;&gt;7.4.1&lt;/a&gt;. Allow 
           &lt;a href=&quot;#section-7.4.2&quot;&gt;7.4.2&lt;/a&gt;. Server 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Method Registry 
           &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt;. Considerations for New Methods 
           &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1.3&lt;/a&gt;. Registrations 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Status Code Registry 
           &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt;. Considerations for New Status Codes 
           &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3&lt;/a&gt;. Registrations 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. Header Field Registry 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. Considerations for New Header Fields 
           &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt;. Registrations 
      &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;. Content Coding Registry 
           &lt;a href=&quot;#section-8.4.1&quot;&gt;8.4.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-8.4.2&quot;&gt;8.4.2&lt;/a&gt;. Registrations 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. Attacks Based on File and Path Names 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. Attacks Based on Command, Code, or Query Injection 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. Disclosure of Personal Information 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. Disclosure of Sensitive Information in URIs 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. Disclosure of Fragment after Redirects 
      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. Disclosure of Product Information 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. Browser Fingerprinting 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. Acknowledgments 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. References 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Differences between HTTP and MIME 
      &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt;. MIME-Version 
      &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt;. Conversion to Canonical Form 
      &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt;. Conversion of Date Formats 
      &lt;a href=&quot;#appendix-A.4&quot;&gt;A.4&lt;/a&gt;. Conversion of Content-Encoding 
      &lt;a href=&quot;#appendix-A.5&quot;&gt;A.5&lt;/a&gt;. Conversion of Content-Transfer-Encoding 
      &lt;a href=&quot;#appendix-A.6&quot;&gt;A.6&lt;/a&gt;. MHTML and Line Length Limitations 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;&lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. Imported ABNF 
   &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt;. Collected ABNF 
   Index .............................................................</source>
          <target state="translated">Аннотация Протокол передачи гипертекста (HTTP) - это протокол уровня приложений без сохранения состояния для распределенных, совместных гипертекстовых информационных систем. Этот документ определяет семантику сообщений HTTP / 1.1, выраженную методами запроса, полями заголовка запроса, кодами состояния ответа и полями заголовка ответа, а также полезную нагрузку сообщений (метаданные и содержимое тела) и механизмы согласования содержимого. Статус этой памятки. Это документ, посвященный стандартам Интернета. Этот документ является продуктом Инженерной группы Интернета (IETF). Он представляет собой консенсус сообщества IETF. Он прошел общественное рассмотрение и был одобрен для публикации Руководящей группой Интернет-разработок (IESG). Дополнительная информация о стандартах Интернета доступна в&lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Раздел 2 RFC 5741&lt;/a&gt; . Информацию о текущем статусе этого документа, обнаруженных ошибках и способах обратной связи можно получить по адресу &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7231&quot;&gt;http://www.rfc-editor.org/info/rfc7231&lt;/a&gt; . Уведомление об авторских правах Авторские права (c) 2014 IETF Trust и лица, указанные в качестве авторов документа. Все права защищены. Этот документ регулируется &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; и Правовыми положениями IETF Trust, касающимися документов IETF ( &lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) действует на дату публикации этого документа. Пожалуйста, внимательно ознакомьтесь с этими документами, поскольку они описывают ваши права и ограничения в отношении этого документа. Компоненты кода, извлеченные из этого документа, должны включать упрощенный текст лицензии BSD, как описано в разделе 4.e Правовых положений Trust, и предоставляются без гарантии, как описано в упрощенной лицензии BSD. Этот документ может содержать материалы из Документов IETF или Вкладов IETF, опубликованных или сделанных общедоступными до 10 ноября 2008 г. Лицо (лица), контролирующее авторские права на некоторые из этих материалов, возможно, не предоставило IETF Trust право разрешать модификации таких материалов. вне процесса стандартизации IETF.Без получения соответствующей лицензии от лица (лиц), контролирующего авторские права на такие материалы, этот документ не может быть изменен за пределами Процесса стандартизации IETF, и его производные работы не могут быть созданы вне Процесса стандартизации IETF, за исключением форматирования его для публикация в виде RFC или перевод на другие языки, кроме английского. Оглавление &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . Введение &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; . Соответствие и обработка ошибок &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; . Обозначение синтаксиса &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . Ресурсы &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . Представления &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; . Метаданные представления &lt;a href=&quot;#section-3.1.1&quot;&gt;3.1.1&lt;/a&gt; . Обработка репрезентативных данных &lt;a href=&quot;#section-3.1.2&quot;&gt;3.1.2&lt;/a&gt; . Кодирование для сжатия или целостности &lt;a href=&quot;#section-3.1.3&quot;&gt;3.1.3&lt;/a&gt; . Язык аудитории &lt;a href=&quot;#section-3.1.4&quot;&gt;3.1.4&lt;/a&gt; . Идентификация &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; . Данные представления &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; . Семантика полезной нагрузки &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; . Согласование содержания &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1&lt;/a&gt; . Проактивные переговоры &lt;a href=&quot;#section-3.4.2&quot;&gt;3.4.2&lt;/a&gt; . Реактивное согласование &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . Способы запроса &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . Обзор &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . Общие свойства метода &lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1&lt;/a&gt; . Безопасные методы &lt;a href=&quot;#section-4.2.2&quot;&gt;4.2.2&lt;/a&gt; . Идемпотентные методы &lt;a href=&quot;#section-4.2.3&quot;&gt;4.2.3&lt;/a&gt; . Кэшируемые методы &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . Определения методов &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt; . ПОЛУЧИТЬ &lt;a href=&quot;#section-4.3.2&quot;&gt;4.3.2&lt;/a&gt; . ГОЛОВКА &lt;a href=&quot;#section-4.3.3&quot;&gt;4.3.3&lt;/a&gt; . ПОСТ &lt;a href=&quot;#section-4.3.4&quot;&gt;4.3.4&lt;/a&gt; . ПОСТАВИТЬ &lt;a href=&quot;#section-4.3.5&quot;&gt;4.3.5&lt;/a&gt; . УДАЛИТЬ &lt;a href=&quot;#section-4.3.6&quot;&gt;4.3.6&lt;/a&gt; . ПОДКЛЮЧИТЬ &lt;a href=&quot;#section-4.3.7&quot;&gt;4.3.7&lt;/a&gt; . ОПЦИИ &lt;a href=&quot;#section-4.3.8&quot;&gt;4.3.8&lt;/a&gt;, СЛЕД &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; . Поля заголовка запроса &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; . Органы управления &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt; . Ожидайте &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt; . Макс-вперед &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; . Условные &lt;a href=&quot;#section-5.3&quot;&gt;выражения 5.3&lt;/a&gt; . Согласование содержания &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1&lt;/a&gt; . Ценности качества &lt;a href=&quot;#section-5.3.2&quot;&gt;5.3.2&lt;/a&gt; . Принимаю &lt;a href=&quot;#section-5.3.3&quot;&gt;5.3.3&lt;/a&gt; . Accept-Charset &lt;a href=&quot;#section-5.3.4&quot;&gt;5.3.4&lt;/a&gt; . Принятие кодирования &lt;a href=&quot;#section-5.3.5&quot;&gt;5.3.5&lt;/a&gt; . Accept-Language &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt; . Учетные данные для аутентификации &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt; . Контекст запроса &lt;a href=&quot;#section-5.5.1&quot;&gt;5.5.1&lt;/a&gt; . Начиная с &lt;a href=&quot;#section-5.5.2&quot;&gt;5.5.2&lt;/a&gt;, Referer &lt;a href=&quot;#section-5.5.3&quot;&gt;5.5.3&lt;/a&gt; . Пользовательский агент ......................................... &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . Коды состояния ответа &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; . Обзор кодов состояния &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; . Информационная 1хх &lt;a href=&quot;#section-6.2.1&quot;&gt;6.2.1&lt;/a&gt; . 100 Продолжить &lt;a href=&quot;#section-6.2.2&quot;&gt;6.2.2&lt;/a&gt; . 101 Протоколы переключения &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; . Успешно 2xx &lt;a href=&quot;#section-6.3.1&quot;&gt;6.3.1&lt;/a&gt; . 200 ОК &lt;a href=&quot;#section-6.3.2&quot;&gt;6.3.2&lt;/a&gt; . 201 Создано &lt;a href=&quot;#section-6.3.3&quot;&gt;6.3.3&lt;/a&gt; . 202 Принимается &lt;a href=&quot;#section-6.3.4&quot;&gt;6.3.4&lt;/a&gt; . 203 Неавторизованная информация &lt;a href=&quot;#section-6.3.5&quot;&gt;6.3.5&lt;/a&gt; . 204 Нет содержимого &lt;a href=&quot;#section-6.3.6&quot;&gt;6.3.6&lt;/a&gt; . 205 Сбросить содержимое &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt; . Перенаправление 3хх &lt;a href=&quot;#section-6.4.1&quot;&gt;6.4.1&lt;/a&gt; . 300 множественных выборов &lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt; . 301 перемещен навсегда &lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt; . 302 Найдено &lt;a href=&quot;#section-6.4.4&quot;&gt;6.4.4&lt;/a&gt; . 303 См. Прочее &lt;a href=&quot;#section-6.4.5&quot;&gt;6.4.5&lt;/a&gt; . 305 Использовать прокси &lt;a href=&quot;#section-6.4.6&quot;&gt;6.4.6&lt;/a&gt; . 306 (Не используется) &lt;a href=&quot;#section-6.4.7&quot;&gt;6.4.7&lt;/a&gt; . 307 Временное перенаправление &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt; . Ошибка клиента 4xx &lt;a href=&quot;#section-6.5.1&quot;&gt;6.5.1&lt;/a&gt; . 400 неверный запрос &lt;a href=&quot;#section-6.5.2&quot;&gt;6.5.2&lt;/a&gt; . 402 Требуется оплата &lt;a href=&quot;#section-6.5.3&quot;&gt;6.5.3&lt;/a&gt; . 403 Запрещено &lt;a href=&quot;#section-6.5.4&quot;&gt;6.5.4&lt;/a&gt; . 404 не найдено &lt;a href=&quot;#section-6.5.5&quot;&gt;6.5.5&lt;/a&gt; . 405 Метод не разрешен &lt;a href=&quot;#section-6.5.6&quot;&gt;6.5.6&lt;/a&gt; . 406 Неприемлемо &lt;a href=&quot;#section-6.5.7&quot;&gt;6.5.7&lt;/a&gt; . 408 Тайм-аут запроса &lt;a href=&quot;#section-6.5.8&quot;&gt;6.5.8&lt;/a&gt; . 409 Конфликт &lt;a href=&quot;#section-6.5.9&quot;&gt;6.5.9&lt;/a&gt; . 410 Gone &lt;a href=&quot;#section-6.5.10&quot;&gt;6.5.10&lt;/a&gt; . 411 Требуемая длина &lt;a href=&quot;#section-6.5.11&quot;&gt;6.5.11&lt;/a&gt; . 413 Слишком большая &lt;a href=&quot;#section-6.5.12&quot;&gt;полезная&lt;/a&gt; нагрузка 6.5.12 . 414 URI слишком длинный &lt;a href=&quot;#section-6.5.13&quot;&gt;6.5.13&lt;/a&gt; . 415 Неподдерживаемый тип &lt;a href=&quot;#section-6.5.14&quot;&gt;носителя 6.5.14&lt;/a&gt; . 417 Неудачное ожидание &lt;a href=&quot;#section-6.5.15&quot;&gt;6.5.15&lt;/a&gt; . 426 Требуется обновление &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt; . Ошибка сервера 5xx &lt;a href=&quot;#section-6.6.1&quot;&gt;6.6.1&lt;/a&gt; . 500 Внутренняя ошибка сервера &lt;a href=&quot;#section-6.6.2&quot;&gt;6.6.2&lt;/a&gt; . 501 Не реализовано &lt;a href=&quot;#section-6.6.3&quot;&gt;6.6.3&lt;/a&gt;, 502 Bad Gateway &lt;a href=&quot;#section-6.6.4&quot;&gt;6.6.4&lt;/a&gt; . 503 Служба недоступна &lt;a href=&quot;#section-6.6.5&quot;&gt;6.6.5&lt;/a&gt; . 504 Тайм-аут шлюза &lt;a href=&quot;#section-6.6.6&quot;&gt;6.6.6&lt;/a&gt; . 505 Версия HTTP не поддерживается &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . Поля заголовка ответа &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; . Контрольные данные под ред. 7.1.1. Дата &lt;a href=&quot;#section-7.1.2&quot;&gt;возникновения 7.1.2&lt;/a&gt; . Расположение &lt;a href=&quot;#section-7.1.3&quot;&gt;7.1.3&lt;/a&gt; . Retry-After ....................................... &lt;a href=&quot;#section-7.1.4&quot;&gt;7.1.4&lt;/a&gt; . Вариант &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; . Поля заголовка валидатора &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt; . Проблемы аутентификации &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt; . Контекст ответа &lt;a href=&quot;#section-7.4.1&quot;&gt;7.4.1&lt;/a&gt; . Разрешить &lt;a href=&quot;#section-7.4.2&quot;&gt;7.4.2&lt;/a&gt;, Сервер &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . Соображения IANA &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; . Реестр методов &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt; . Порядок &lt;a href=&quot;#section-8.1.2&quot;&gt;действий 8.1.2&lt;/a&gt; . Соображения по &lt;a href=&quot;#section-8.1.3&quot;&gt;поводу&lt;/a&gt; новых методов 8.1.3 . Регистрации &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; . Реестр кодов состояния &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt; . Процедура &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt; . Соображения по &lt;a href=&quot;#section-8.2.3&quot;&gt;поводу&lt;/a&gt; новых кодов состояния 8.2.3 . Регистрации &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt; . Реестр поля заголовка &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt; . Соображения по поводу новых полей заголовков &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt; . Регистрации &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt; . Реестр кодирования контента &lt;a href=&quot;#section-8.4.1&quot;&gt;8.4.1&lt;/a&gt; . Процедура &lt;a href=&quot;#section-8.4.2&quot;&gt;8.4.2&lt;/a&gt; . Регистрации &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; . Соображения безопасности &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; . Атаки на основе имен файлов и путей &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; . Атаки, основанные на введении команды, кода или запроса &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; . Раскрытие личной информации &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt; . Раскрытие конфиденциальной информации в URI &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt; . Раскрытие фрагмента после перенаправления &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; . Раскрытие информации о продукте &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt; . Отпечатки браузера &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; . Благодарности &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; . Ссылки &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt; . Нормативные ссылки &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt; . Информативные ссылки &lt;a href=&quot;#appendix-A&quot;&gt;Приложение A&lt;/a&gt; . Различия между HTTP и MIME &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt; . MIME-версия &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt; . Преобразование в каноническую форму &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt; . Преобразование форматов даты &lt;a href=&quot;#appendix-A.4&quot;&gt;A.4&lt;/a&gt; . Преобразование Content-Encoding &lt;a href=&quot;#appendix-A.5&quot;&gt;A.5&lt;/a&gt; . Преобразование Content-Transfer-Encoding &lt;a href=&quot;#appendix-A.6&quot;&gt;A.6&lt;/a&gt; . MHTML и линия Длина Ограничения &lt;a href=&quot;#appendix-B&quot;&gt;Приложение B&lt;/a&gt; . Изменения по сравнению с &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616 &lt;/a&gt;&lt;a href=&quot;#appendix-C&quot;&gt;Приложение C&lt;/a&gt; . Imported ABNF &lt;a href=&quot;#appendix-D&quot;&gt;Приложение D&lt;/a&gt; . Собранный индекс ABNF ............................................... ..............</target>
        </trans-unit>
        <trans-unit id="40af3a9e68d967dfc1ebb5c1482c0bb1ee2a2de4" translate="yes" xml:space="preserve">
          <source>Abstract

   The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level protocol for distributed, collaborative, hypertext information
   systems.  This document provides an overview of HTTP architecture and
   its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform
   Resource Identifier (URI) schemes, defines the HTTP/1.1 message
   syntax and parsing requirements, and describes related security
   concerns for implementations.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Section&amp;nbsp;2 of RFC 5741&lt;/a&gt;.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7230&quot;&gt;http://www.rfc-editor.org/info/rfc7230&lt;/a&gt;. 

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
      &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;. Requirements Notation 
      &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;. Syntax Notation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Architecture 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. Client/Server Messaging 
      &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;. Implementation Diversity 
      &lt;a href=&quot;#section-2.3&quot;&gt;2.3&lt;/a&gt;. Intermediaries 
      &lt;a href=&quot;#section-2.4&quot;&gt;2.4&lt;/a&gt;. Caches 
      &lt;a href=&quot;#section-2.5&quot;&gt;2.5&lt;/a&gt;. Conformance and Error Handling 
      &lt;a href=&quot;#section-2.6&quot;&gt;2.6&lt;/a&gt;. Protocol Versioning 
      &lt;a href=&quot;#section-2.7&quot;&gt;2.7&lt;/a&gt;. Uniform Resource Identifiers 
           &lt;a href=&quot;#section-2.7.1&quot;&gt;2.7.1&lt;/a&gt;. http URI Scheme 
           &lt;a href=&quot;#section-2.7.2&quot;&gt;2.7.2&lt;/a&gt;. https URI Scheme 
           &lt;a href=&quot;#section-2.7.3&quot;&gt;2.7.3&lt;/a&gt;. http and https URI Normalization and Comparison 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Message Format 
      &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;. Start Line 
           &lt;a href=&quot;#section-3.1.1&quot;&gt;3.1.1&lt;/a&gt;. Request Line 
           &lt;a href=&quot;#section-3.1.2&quot;&gt;3.1.2&lt;/a&gt;. Status Line 
      &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;. Header Fields ............................................. 

           &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;. Field Extensibility 
           &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt;. Field Order 
           &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt;. Whitespace 
           &lt;a href=&quot;#section-3.2.4&quot;&gt;3.2.4&lt;/a&gt;. Field Parsing 
           &lt;a href=&quot;#section-3.2.5&quot;&gt;3.2.5&lt;/a&gt;. Field Limits 
           &lt;a href=&quot;#section-3.2.6&quot;&gt;3.2.6&lt;/a&gt;. Field Value Components 
      &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;. Message Body 
           &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;. Transfer-Encoding 
           &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt;. Content-Length 
           &lt;a href=&quot;#section-3.3.3&quot;&gt;3.3.3&lt;/a&gt;. Message Body Length 
      &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt;. Handling Incomplete Messages 
      &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt;. Message Parsing Robustness 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Transfer Codings 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. Chunked Transfer Coding 
           &lt;a href=&quot;#section-4.1.1&quot;&gt;4.1.1&lt;/a&gt;. Chunk Extensions 
           &lt;a href=&quot;#section-4.1.2&quot;&gt;4.1.2&lt;/a&gt;. Chunked Trailer Part 
           &lt;a href=&quot;#section-4.1.3&quot;&gt;4.1.3&lt;/a&gt;. Decoding Chunked 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Compression Codings 
           &lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1&lt;/a&gt;. Compress Coding 
           &lt;a href=&quot;#section-4.2.2&quot;&gt;4.2.2&lt;/a&gt;. Deflate Coding 
           &lt;a href=&quot;#section-4.2.3&quot;&gt;4.2.3&lt;/a&gt;. Gzip Coding 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. TE 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Trailer 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Message Routing 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Identifying a Target Resource 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Connecting Inbound 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Request Target 
           &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1&lt;/a&gt;. origin-form 
           &lt;a href=&quot;#section-5.3.2&quot;&gt;5.3.2&lt;/a&gt;. absolute-form 
           &lt;a href=&quot;#section-5.3.3&quot;&gt;5.3.3&lt;/a&gt;. authority-form 
           &lt;a href=&quot;#section-5.3.4&quot;&gt;5.3.4&lt;/a&gt;. asterisk-form 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Host 
      &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;. Effective Request URI 
      &lt;a href=&quot;#section-5.6&quot;&gt;5.6&lt;/a&gt;. Associating a Response to a Request 
      &lt;a href=&quot;#section-5.7&quot;&gt;5.7&lt;/a&gt;. Message Forwarding 
           &lt;a href=&quot;#section-5.7.1&quot;&gt;5.7.1&lt;/a&gt;. Via 
           &lt;a href=&quot;#section-5.7.2&quot;&gt;5.7.2&lt;/a&gt;. Transformations 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Connection Management 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Connection 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Establishment 
      &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;. Persistence 
           &lt;a href=&quot;#section-6.3.1&quot;&gt;6.3.1&lt;/a&gt;. Retrying Requests 
           &lt;a href=&quot;#section-6.3.2&quot;&gt;6.3.2&lt;/a&gt;. Pipelining 
      &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt;. Concurrency 
      &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt;. Failures and Timeouts 
      &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;. Tear-down 
      &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt;. Upgrade 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. ABNF List Extension: #rule ..................................... 

   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Header Field Registration 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. URI Scheme Registration 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. Internet Media Type Registration 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. Internet Media Type message/http 
           &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt;. Internet Media Type application/http 
      &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;. Transfer Coding Registry 
           &lt;a href=&quot;#section-8.4.1&quot;&gt;8.4.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-8.4.2&quot;&gt;8.4.2&lt;/a&gt;. Registration 
      &lt;a href=&quot;#section-8.5&quot;&gt;8.5&lt;/a&gt;. Content Coding Registration 
      &lt;a href=&quot;#section-8.6&quot;&gt;8.6&lt;/a&gt;. Upgrade Token Registry 
           &lt;a href=&quot;#section-8.6.1&quot;&gt;8.6.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-8.6.2&quot;&gt;8.6.2&lt;/a&gt;. Upgrade Token Registration 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. Establishing Authority 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. Risks of Intermediaries 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. Attacks via Protocol Element Length 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. Response Splitting 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. Request Smuggling 
      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. Message Integrity 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. Message Confidentiality 
      &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;. Privacy of Server Log Information 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. Acknowledgments 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. References 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. HTTP Version History 
      &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt;. Changes from HTTP/1.0  
           &lt;a href=&quot;#appendix-A.1.1&quot;&gt;A.1.1&lt;/a&gt;.  Multihomed Web Servers 
           &lt;a href=&quot;#appendix-A.1.2&quot;&gt;A.1.2&lt;/a&gt;.  Keep-Alive Connections 
           &lt;a href=&quot;#appendix-A.1.3&quot;&gt;A.1.3&lt;/a&gt;.  Introduction of Transfer-Encoding 
      &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt;.  Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;&lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Collected ABNF 
   Index .............................................................</source>
          <target state="translated">Аннотация Протокол передачи гипертекста (HTTP) - это протокол уровня приложений без сохранения состояния для распределенных, совместных гипертекстовых информационных систем. В этом документе представлен обзор архитектуры HTTP и связанной с ней терминологии, определены схемы универсального идентификатора ресурса (URI) &amp;laquo;http&amp;raquo; и &amp;laquo;https&amp;raquo;, определены синтаксис сообщений HTTP / 1.1 и требования к синтаксическому анализу, а также описаны связанные проблемы безопасности для реализаций. Статус этой памятки. Это документ, посвященный стандартам Интернета. Этот документ является продуктом Инженерной группы Интернета (IETF). Он представляет собой консенсус сообщества IETF. Он прошел общественное рассмотрение и был одобрен для публикации Руководящей группой Интернет-разработок (IESG).Дополнительная информация о стандартах Интернета доступна в&lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Раздел 2 RFC 5741&lt;/a&gt; . Информацию о текущем статусе этого документа, любых ошибках и способах обратной связи по нему можно получить по адресу &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7230&quot;&gt;http://www.rfc-editor.org/info/rfc7230&lt;/a&gt; . Уведомление об авторских правах Авторские права (c) 2014 IETF Trust и лица, указанные в качестве авторов документа. Все права защищены. Этот документ регулируется &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; и Правовыми положениями IETF Trust, касающимися документов IETF ( &lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) действует на дату публикации этого документа. Пожалуйста, внимательно ознакомьтесь с этими документами, поскольку они описывают ваши права и ограничения в отношении этого документа. Компоненты кода, извлеченные из этого документа, должны включать упрощенный текст лицензии BSD, как описано в разделе 4.e Правовых положений Trust, и предоставляются без гарантии, как описано в упрощенной лицензии BSD. Этот документ может содержать материалы из Документов IETF или Вкладов IETF, опубликованных или сделанных общедоступными до 10 ноября 2008 г. Лицо (лица), контролирующее авторские права на некоторые из этих материалов, возможно, не предоставило IETF Trust право разрешать модификации таких материалов. вне процесса стандартизации IETF.Без получения соответствующей лицензии от лица (лиц), контролирующего авторские права на такие материалы, этот документ не может быть изменен за пределами Процесса стандартизации IETF, и его производные работы не могут быть созданы вне Процесса стандартизации IETF, за исключением форматирования его для публикация в виде RFC или перевод на другие языки, кроме английского. Оглавление &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . Введение &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; . Обозначение требований &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; . Обозначение синтаксиса &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . Архитектура &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; . Обмен сообщениями клиент / сервер &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; . Разнообразие реализации &lt;a href=&quot;#section-2.3&quot;&gt;2.3&lt;/a&gt; . Посредники &lt;a href=&quot;#section-2.4&quot;&gt;2.4&lt;/a&gt; . Кеши &lt;a href=&quot;#section-2.5&quot;&gt;2.5&lt;/a&gt; . Соответствие и обработка ошибок &lt;a href=&quot;#section-2.6&quot;&gt;2.6&lt;/a&gt; . Управление версиями протокола &lt;a href=&quot;#section-2.7&quot;&gt;2.7&lt;/a&gt; . Единые идентификаторы ресурсов &lt;a href=&quot;#section-2.7.1&quot;&gt;2.7.1&lt;/a&gt; . Схема http URI &lt;a href=&quot;#section-2.7.2&quot;&gt;2.7.2&lt;/a&gt; . Схема https URI &lt;a href=&quot;#section-2.7.3&quot;&gt;2.7.3&lt;/a&gt; . Нормализация и сравнение http и https URI &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;, Формат сообщения &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; . Старт &lt;a href=&quot;#section-3.1.1&quot;&gt;3.1.1&lt;/a&gt; . Строка запроса &lt;a href=&quot;#section-3.1.2&quot;&gt;3.1.2&lt;/a&gt; . Строка состояния &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; . Поля заголовка ............................................. &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt; , Расширяемость полей &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt; . Порядок полей &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt; . Пробел &lt;a href=&quot;#section-3.2.4&quot;&gt;3.2.4&lt;/a&gt; . Анализ поля &lt;a href=&quot;#section-3.2.5&quot;&gt;3.2.5&lt;/a&gt; . Пределы полей &lt;a href=&quot;#section-3.2.6&quot;&gt;3.2.6&lt;/a&gt; . Компоненты значения поля &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; . Тело сообщения &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt; . Кодирование передачи &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt; . Content-Length &lt;a href=&quot;#section-3.3.3&quot;&gt;3.3.3&lt;/a&gt;, Длина тела сообщения &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; . Обработка неполных сообщений &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt; . Устойчивость анализа сообщений &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . Трансферные кодировки &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . Кодирование передачи по частям &lt;a href=&quot;#section-4.1.1&quot;&gt;4.1.1&lt;/a&gt; . Расширения чанков &lt;a href=&quot;#section-4.1.2&quot;&gt;4.1.2&lt;/a&gt; . Разделенный трейлер Часть &lt;a href=&quot;#section-4.1.3&quot;&gt;4.1.3&lt;/a&gt; . Декодирование по фрагментам &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . Кодирование сжатия &lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1&lt;/a&gt; . Сжатие кодирования &lt;a href=&quot;#section-4.2.2&quot;&gt;4.2.2&lt;/a&gt; . Кодирование Deflate &lt;a href=&quot;#section-4.2.3&quot;&gt;4.2.3&lt;/a&gt; . Кодирование Gzip &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . TE &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; . Прицеп &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; . Маршрутизация сообщений &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; . Определение целевого ресурса &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; . Подключение входящего &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; . Цель запроса &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1&lt;/a&gt; . форма происхождения &lt;a href=&quot;#section-5.3.2&quot;&gt;5.3.2&lt;/a&gt; . абсолютная форма &lt;a href=&quot;#section-5.3.3&quot;&gt;5.3.3&lt;/a&gt; . авторитетная форма &lt;a href=&quot;#section-5.3.4&quot;&gt;5.3.4&lt;/a&gt; . звездочка &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt; . Хост &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt; . Действующий URI запроса &lt;a href=&quot;#section-5.6&quot;&gt;5.6&lt;/a&gt; . Привязка ответа к запросу &lt;a href=&quot;#section-5.7&quot;&gt;5.7&lt;/a&gt; . Пересылка сообщений &lt;a href=&quot;#section-5.7.1&quot;&gt;5.7.1&lt;/a&gt; . Через &lt;a href=&quot;#section-5.7.2&quot;&gt;5.7.2&lt;/a&gt; . Преобразования &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . Управление подключением &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;, Подключение &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; . Создание &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; . Стойкость &lt;a href=&quot;#section-6.3.1&quot;&gt;6.3.1&lt;/a&gt; . Повторные запросы &lt;a href=&quot;#section-6.3.2&quot;&gt;6.3.2&lt;/a&gt; . Конвейерная обработка &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt; . Параллелизм &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt; . Сбои и таймауты &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt; . Разборка &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt; . Обновление &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . Расширение списка ABNF: #rule ..................................... &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . Соображения IANA &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; . Регистрация поля заголовка &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; . Регистрация схемы URI &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt; . Регистрация типа Интернет-СМИ &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;, Сообщение Internet Media Type / http &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt; . Приложение Internet Media Type / http &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt; . Реестр трансферного кодирования &lt;a href=&quot;#section-8.4.1&quot;&gt;8.4.1&lt;/a&gt; . Процедура &lt;a href=&quot;#section-8.4.2&quot;&gt;8.4.2&lt;/a&gt; . Регистрация &lt;a href=&quot;#section-8.5&quot;&gt;8.5&lt;/a&gt; . Регистрация Content Coding &lt;a href=&quot;#section-8.6&quot;&gt;8.6&lt;/a&gt; . Обновить реестр токенов &lt;a href=&quot;#section-8.6.1&quot;&gt;8.6.1&lt;/a&gt; . Процедура &lt;a href=&quot;#section-8.6.2&quot;&gt;8.6.2&lt;/a&gt; . Обновите регистрацию токена &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; . Соображения безопасности &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; . Учреждение власти &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; . Риски посредников &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; . Атаки через элемент протокола длиной &lt;a href=&quot;#section-9.4&quot;&gt;9,4&lt;/a&gt;, Разделение ответа &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt; . Запрос на контрабанду &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; . Целостность сообщения &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt; . Конфиденциальность сообщений &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; . Конфиденциальность информации журнала сервера &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; . Благодарности &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; . Ссылки &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt; . Нормативные ссылки &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt; . Информативные ссылки &lt;a href=&quot;#appendix-A&quot;&gt;Приложение A&lt;/a&gt; . История версий HTTP &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt; . Отличия от HTTP / 1.0 &lt;a href=&quot;#appendix-A.1.1&quot;&gt;A.1.1&lt;/a&gt; . Многосетевые веб-серверы &lt;a href=&quot;#appendix-A.1.2&quot;&gt;A.1.2&lt;/a&gt; . Соединения Keep-Alive &lt;a href=&quot;#appendix-A.1.3&quot;&gt;A.1.3&lt;/a&gt; . Введение в Transfer-Encoding &lt;a href=&quot;#appendix-A.2&quot;&gt;А.2&lt;/a&gt; . Изменения по сравнению с &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616 &lt;/a&gt;&lt;a href=&quot;#appendix-B&quot;&gt;Приложение B&lt;/a&gt; . Собранный индекс ABNF ............................................... ..............</target>
        </trans-unit>
        <trans-unit id="169ce4ffcc45df2dca538209a9b8308901d5a3b7" translate="yes" xml:space="preserve">
          <source>Abstract

   This specification describes an optimized expression of the semantics
   of the Hypertext Transfer Protocol (HTTP), referred to as HTTP
   version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network
   resources and a reduced perception of latency by introducing header
   field compression and allowing multiple concurrent exchanges on the
   same connection.  It also introduces unsolicited push of
   representations from servers to clients.

   This specification is an alternative to, but does not obsolete, the
   HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Section&amp;nbsp;2 of RFC 5741&lt;/a&gt;.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7540&quot;&gt;http://www.rfc-editor.org/info/rfc7540&lt;/a&gt;. 

Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. HTTP/2 Protocol Overview 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. Document Organization 
      &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;. Conventions and Terminology 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Starting HTTP/2 
      &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;. HTTP/2 Version Identification 
      &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;. Starting HTTP/2 for &quot;http&quot; URIs 
           &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;. HTTP2-Settings Header Field 
      &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;. Starting HTTP/2 for &quot;https&quot; URIs 
      &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt;. Starting HTTP/2 with Prior Knowledge 
      &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt;. HTTP/2 Connection Preface 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. HTTP Frames 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. Frame Format 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Frame Size 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Header Compression and Decompression 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Streams and Multiplexing 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Stream States 
           &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt;. Stream Identifiers 
           &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;. Stream Concurrency 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Flow Control 
           &lt;a href=&quot;#section-5.2.1&quot;&gt;5.2.1&lt;/a&gt;. Flow-Control Principles 
           &lt;a href=&quot;#section-5.2.2&quot;&gt;5.2.2&lt;/a&gt;. Appropriate Use of Flow Control 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Stream Priority 
           &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1&lt;/a&gt;. Stream Dependencies 
           &lt;a href=&quot;#section-5.3.2&quot;&gt;5.3.2&lt;/a&gt;. Dependency Weighting 
           &lt;a href=&quot;#section-5.3.3&quot;&gt;5.3.3&lt;/a&gt;. Reprioritization 
           &lt;a href=&quot;#section-5.3.4&quot;&gt;5.3.4&lt;/a&gt;. Prioritization State Management 
           &lt;a href=&quot;#section-5.3.5&quot;&gt;5.3.5&lt;/a&gt;. Default Priorities 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Error Handling 
           &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt;. Connection Error Handling 
           &lt;a href=&quot;#section-5.4.2&quot;&gt;5.4.2&lt;/a&gt;. Stream Error Handling .............................. 

           &lt;a href=&quot;#section-5.4.3&quot;&gt;5.4.3&lt;/a&gt;. Connection Termination 
      &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;. Extending HTTP/2 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Frame Definitions 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. DATA 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. HEADERS 
      &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;. PRIORITY 
      &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt;. RST_STREAM 
      &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt;. SETTINGS 
           &lt;a href=&quot;#section-6.5.1&quot;&gt;6.5.1&lt;/a&gt;. SETTINGS Format 
           &lt;a href=&quot;#section-6.5.2&quot;&gt;6.5.2&lt;/a&gt;. Defined SETTINGS Parameters 
           &lt;a href=&quot;#section-6.5.3&quot;&gt;6.5.3&lt;/a&gt;. Settings Synchronization 
      &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;. PUSH_PROMISE 
      &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt;. PING 
      &lt;a href=&quot;#section-6.8&quot;&gt;6.8&lt;/a&gt;. GOAWAY 
      &lt;a href=&quot;#section-6.9&quot;&gt;6.9&lt;/a&gt;. WINDOW_UPDATE 
           &lt;a href=&quot;#section-6.9.1&quot;&gt;6.9.1&lt;/a&gt;. The Flow-Control Window 
           &lt;a href=&quot;#section-6.9.2&quot;&gt;6.9.2&lt;/a&gt;. Initial Flow-Control Window Size 
           &lt;a href=&quot;#section-6.9.3&quot;&gt;6.9.3&lt;/a&gt;. Reducing the Stream Window Size 
      &lt;a href=&quot;#section-6.10&quot;&gt;6.10&lt;/a&gt;. CONTINUATION 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Error Codes 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. HTTP Message Exchanges 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. HTTP Request/Response Exchange 
           &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt;. Upgrading from HTTP/2 
           &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt;. HTTP Header Fields 
           &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1.3&lt;/a&gt;. Examples 
           &lt;a href=&quot;#section-8.1.4&quot;&gt;8.1.4&lt;/a&gt;. Request Reliability Mechanisms in HTTP/2 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Server Push 
           &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt;. Push Requests 
           &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt;. Push Responses 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. The CONNECT Method 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Additional HTTP Requirements/Considerations 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. Connection Management 
           &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;. Connection Reuse 
           &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;. The 421 (Misdirected Request) Status Code 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. Use of TLS Features 
           &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;. TLS 1.2 Features 
           &lt;a href=&quot;#section-9.2.2&quot;&gt;9.2.2&lt;/a&gt;. TLS 1.2 Cipher Suites 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. Server Authority 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. Cross-Protocol Attacks 
      &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;. Intermediary Encapsulation Attacks 
      &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;. Cacheability of Pushed Responses 
      &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;. Denial-of-Service Considerations 
           &lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1&lt;/a&gt;. Limits on Header Block Size 
           &lt;a href=&quot;#section-10.5.2&quot;&gt;10.5.2&lt;/a&gt;. CONNECT Issues 
      &lt;a href=&quot;#section-10.6&quot;&gt;10.6&lt;/a&gt;. Use of Compression 
      &lt;a href=&quot;#section-10.7&quot;&gt;10.7&lt;/a&gt;. Use of Padding 
      &lt;a href=&quot;#section-10.8&quot;&gt;10.8&lt;/a&gt;. Privacy Considerations ................................... 

   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. Registration of HTTP/2 Identification Strings 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. Frame Type Registry 
      &lt;a href=&quot;#section-11.3&quot;&gt;11.3&lt;/a&gt;. Settings Registry 
      &lt;a href=&quot;#section-11.4&quot;&gt;11.4&lt;/a&gt;. Error Code Registry 
      &lt;a href=&quot;#section-11.5&quot;&gt;11.5&lt;/a&gt;. HTTP2-Settings Header Field Registration 
      &lt;a href=&quot;#section-11.6&quot;&gt;11.6&lt;/a&gt;. PRI Method Registration 
      &lt;a href=&quot;#section-11.7&quot;&gt;11.7&lt;/a&gt;. The 421 (Misdirected Request) HTTP Status Code 
      &lt;a href=&quot;#section-11.8&quot;&gt;11.8&lt;/a&gt;. The h2c Upgrade Token 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;. References 
      &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. TLS 1.2 Cipher Suite Black List 
   Acknowledgements 
   Authors' Addresses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088fbdf0be09f2b57f797db06f694f1729caf35d" translate="yes" xml:space="preserve">
          <source>Accelerometer</source>
          <target state="translated">Accelerometer</target>
        </trans-unit>
        <trans-unit id="4a6020ab1c5517bd5d30e781beba5515f12cafd7" translate="yes" xml:space="preserve">
          <source>Accelerometer&lt;br/&gt;&lt;small&gt;The definition of 'Accelerometer' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb54db510a92908a5a4df79fc1ad1eae8df50ec3" translate="yes" xml:space="preserve">
          <source>Accept</source>
          <target state="translated">Accept</target>
        </trans-unit>
        <trans-unit id="87fbce3fda446208ef2acea7678d689afb9f87e9" translate="yes" xml:space="preserve">
          <source>Accept (RFC 2616)</source>
          <target state="translated">Принять (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="0dcc20ef513587031d3a72165f89c3586e57c7de" translate="yes" xml:space="preserve">
          <source>Accept (RFC 7231)</source>
          <target state="translated">Принять (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="4e7eb8a9e22a94e3c88a689612ab6a2a6f4c8e4f" translate="yes" xml:space="preserve">
          <source>Accept request-headers can reveal information about the user to all
   servers which are accessed. The Accept-Language header in particular
   can reveal information the user would consider to be of a private
   nature, because the understanding of particular languages is often 

   strongly correlated to the membership of a particular ethnic group.
   User agents which offer the option to configure the contents of an
   Accept-Language header to be sent in every request are strongly
   encouraged to let the configuration process include a message which
   makes the user aware of the loss of privacy involved.

   An approach that limits the loss of privacy would be for a user agent
   to omit the sending of Accept-Language headers by default, and to ask
   the user whether or not to start sending Accept-Language headers to a
   server if it detects, by looking for any Vary response-header fields
   generated by the server, that such sending could improve the quality
   of service.

   Elaborate user-customized accept header fields sent in every request,
   in particular if these include quality values, can be used by servers
   as relatively reliable and long-lived user identifiers. Such user
   identifiers would allow content providers to do click-trail tracking,
   and would allow collaborating content providers to match cross-server
   click-trails or form submissions of individual users. Note that for
   many users not behind a proxy, the network address of the host
   running the user agent will also serve as a long-lived user
   identifier. In environments where proxies are used to enhance
   privacy, user agents ought to be conservative in offering accept
   header configuration options to end users. As an extreme privacy
   measure, proxies could filter the accept headers in relayed requests.
   General purpose user agents which provide a high degree of header
   configurability SHOULD warn users about the loss of privacy which can
   be involved.</source>
          <target state="translated">Заголовки запросов Accept requestest-headers могут раскрывать информацию о пользователе на всех серверах,к которым осуществляется доступ.В частности,заголовок Accept-Language (Язык принятия)может раскрыть информацию,которую пользователь считает конфиденциальной,так как понимание определенных языков часто тесно связано с принадлежностью к определенной этнической группе.Пользовательским агентам,которые предлагают возможность настройки содержимого языкового заголовка Accept-Language для отправки в каждом запросе,настоятельно рекомендуется,чтобы процесс настройки включал в себя сообщение,которое информирует пользователя о потере конфиденциальности.Подход,ограничивающий потерю конфиденциальности,заключается в том,чтобы пользовательский агент по умолчанию не отправлял языковые заголовки Accept-Language и спрашивал пользователя,следует ли начинать отправку языковых заголовков Accept-Language на сервер,если он обнаруживает,путем поиска любых полей заголовка Vary response-header,генерируемых сервером,что такая отправка может улучшить качество обслуживания.Разработанные пользователем поля заголовков приема,отправляемые в каждом запросе,в частности,если они включают в себя значения качества,могут быть использованы серверами в качестве относительно надежных и долговечных идентификаторов пользователей.Такие идентификаторы пользователей позволят контент-провайдерам отслеживать клик-потоки,а сотрудничающим контент-провайдерам-сопоставлять клик-потоки по кросс-серверу или формировать заявки отдельных пользователей.Обратите внимание,что для многих пользователей,не находящихся за прокси-сервером,сетевой адрес хоста,на котором работает пользовательский агент,также будет служить в качестве долгоживущего идентификатора пользователя.В средах,где прокси-серверы используются для повышения конфиденциальности,пользовательские агенты должны быть консервативными,предлагая конечным пользователям опции настройки заголовков.В качестве крайней меры конфиденциальности,прокси-серверы могут фильтровать заголовки приема в ретранслируемых запросах.Пользовательские агенты общего назначения,которые обеспечивают высокую степень настраиваемости заголовков,ДОЛЖНЫ предупреждать пользователей о потере конфиденциальности,которая может быть вовлечена.</target>
        </trans-unit>
        <trans-unit id="cbf7652dda9b574ee3d8fa9ba1a981f6e580b50c" translate="yes" xml:space="preserve">
          <source>Accept-CH</source>
          <target state="translated">Accept-CH</target>
        </trans-unit>
        <trans-unit id="36d96a263709e34be5a5041f8061f37f18742f90" translate="yes" xml:space="preserve">
          <source>Accept-CH-Lifetime</source>
          <target state="translated">Accept-CH-Lifetime</target>
        </trans-unit>
        <trans-unit id="aaf67685a1d81108695f45293bf84f12a0c9cb46" translate="yes" xml:space="preserve">
          <source>Accept-Charset</source>
          <target state="translated">Accept-Charset</target>
        </trans-unit>
        <trans-unit id="1eb70f6fb0b92415ec54f2514f66fef0477c9d03" translate="yes" xml:space="preserve">
          <source>Accept-Charset (RFC 2616)</source>
          <target state="translated">Приемка-Карсет (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="d46e62b664d44c5c0ad50b6fbfcf9b7ffd34c78f" translate="yes" xml:space="preserve">
          <source>Accept-Charset (RFC 7231)</source>
          <target state="translated">Приемка-Карсет (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="05a25bf4449549e9b5ee96afc9f36857b37fc6e8" translate="yes" xml:space="preserve">
          <source>Accept-Charset is no more</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177429157553dbb71c8bab30aac57a62d268cc1c" translate="yes" xml:space="preserve">
          <source>Accept-Encoding</source>
          <target state="translated">Accept-Encoding</target>
        </trans-unit>
        <trans-unit id="a80413a74e8c6a5ee7628707c28264f5fc57f11c" translate="yes" xml:space="preserve">
          <source>Accept-Encoding (RFC 2616)</source>
          <target state="translated">Приемка-раскодировка (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="d76f042c2a36b8346c52df9cd05152e174c68474" translate="yes" xml:space="preserve">
          <source>Accept-Encoding (RFC 7231)</source>
          <target state="translated">Приемка-раскодировка (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="58385b3fba0471cb7c233041f9d15c4b6ccf18fe" translate="yes" xml:space="preserve">
          <source>Accept-Language</source>
          <target state="translated">Accept-Language</target>
        </trans-unit>
        <trans-unit id="8a194a37a0fab016d1dac628a2d4a8bdc2847fc0" translate="yes" xml:space="preserve">
          <source>Accept-Language (RFC 2616)</source>
          <target state="translated">Язык принятия (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="6a5d4a129ec209d245a79d6c3f2edfdd87668589" translate="yes" xml:space="preserve">
          <source>Accept-Language (RFC 7231)</source>
          <target state="translated">Язык принятия (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="ea739811444a8e5f6504b6782269b732b928cc75" translate="yes" xml:space="preserve">
          <source>Accept-Patch</source>
          <target state="translated">Accept-Patch</target>
        </trans-unit>
        <trans-unit id="e22e9df1bfaf7e154b76461094ccdcabf7952070" translate="yes" xml:space="preserve">
          <source>Accept-Post</source>
          <target state="translated">Accept-Post</target>
        </trans-unit>
        <trans-unit id="02910fe72aef1e79d1ce552b0125fe9d6e734463" translate="yes" xml:space="preserve">
          <source>Accept-Ranges</source>
          <target state="translated">Accept-Ranges</target>
        </trans-unit>
        <trans-unit id="0e716e0e0b978d47436d93b491a16aeaac22f9e5" translate="yes" xml:space="preserve">
          <source>Accept-Ranges (RFC 2616)</source>
          <target state="translated">Приемка диапазонов (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="764a440a698a17aa1dc774708163b405c87ff4bd" translate="yes" xml:space="preserve">
          <source>Accept-Ranges (RFC 7233)</source>
          <target state="translated">Приемка диапазонов (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="bc19e40eb87eca9ddb4a92e3a97c67ee6143d7d5" translate="yes" xml:space="preserve">
          <source>Access Authentication (RFC 2616)</source>
          <target state="translated">Аутентификация доступа (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="6a77d7667269bf6db4712e4162088af68dbec9fc" translate="yes" xml:space="preserve">
          <source>Access Authentication Framework (RFC 7235)</source>
          <target state="translated">Структура аутентификации доступа (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="c22573ef8df23292ff057255b9a28b1bea0f5bec" translate="yes" xml:space="preserve">
          <source>Access control is a security technique that can be used to regulate who or what can view or use resources in a computing environment.</source>
          <target state="translated">Контроль доступа-это техника безопасности,которая может использоваться для регулирования того,кто или что может просматривать или использовать ресурсы в вычислительной среде.</target>
        </trans-unit>
        <trans-unit id="f81413e1c5136d3c3d54929c9e2b0c8e7144bc04" translate="yes" xml:space="preserve">
          <source>Access control systems perform &lt;a href=&quot;http://searchsoftwarequality.techtarget.com/definition/authorization&quot;&gt;authorization&lt;/a&gt; identification, &lt;a href=&quot;http://searchsecurity.techtarget.com/definition/authentication&quot;&gt;authentication&lt;/a&gt;, access approval, and accountability of entities through login credentials including &lt;a href=&quot;http://searchsecurity.techtarget.com/definition/password&quot;&gt;passwords&lt;/a&gt;, personal identification numbers (PINs), &lt;a href=&quot;http://searchsecurity.techtarget.com/definition/biometrics&quot;&gt;biometric&lt;/a&gt; scans, and physical or electronic keys.</source>
          <target state="translated">Системы контроля доступа выполняют идентификацию &lt;a href=&quot;http://searchsoftwarequality.techtarget.com/definition/authorization&quot;&gt;авторизации&lt;/a&gt; , &lt;a href=&quot;http://searchsecurity.techtarget.com/definition/authentication&quot;&gt;аутентификацию&lt;/a&gt; , утверждение доступа и подотчетность субъектов посредством учетных данных для входа, включая &lt;a href=&quot;http://searchsecurity.techtarget.com/definition/password&quot;&gt;пароли&lt;/a&gt; , личные идентификационные номера (ПИН-коды), &lt;a href=&quot;http://searchsecurity.techtarget.com/definition/biometrics&quot;&gt;биометрическое&lt;/a&gt; сканирование, а также физические или электронные ключи.</target>
        </trans-unit>
        <trans-unit id="d810350110ab0e795aa4da0b30363f0a9f966603" translate="yes" xml:space="preserve">
          <source>Access forbidden</source>
          <target state="translated">Доступ запрещен</target>
        </trans-unit>
        <trans-unit id="80c707124192246c159bfaa608d8114812340fa4" translate="yes" xml:space="preserve">
          <source>Access using credentials in the URL</source>
          <target state="translated">Доступ с использованием учетных данных в URL-адресе</target>
        </trans-unit>
        <trans-unit id="09fbec75ee860af401feca052767eb8d2119fc55" translate="yes" xml:space="preserve">
          <source>Access-Control-Allow-Credentials</source>
          <target state="translated">Access-Control-Allow-Credentials</target>
        </trans-unit>
        <trans-unit id="2d66b46792a018ad2020282cc416e9ee8f06f861" translate="yes" xml:space="preserve">
          <source>Access-Control-Allow-Headers</source>
          <target state="translated">Access-Control-Allow-Headers</target>
        </trans-unit>
        <trans-unit id="2a2a0c7e0ef78c7c6bd13f7ae4ec973cd75d4f40" translate="yes" xml:space="preserve">
          <source>Access-Control-Allow-Methods</source>
          <target state="translated">Access-Control-Allow-Methods</target>
        </trans-unit>
        <trans-unit id="c4f2dafa374f61f543d5c6c14d4bdbb5b6456db0" translate="yes" xml:space="preserve">
          <source>Access-Control-Allow-Origin</source>
          <target state="translated">Access-Control-Allow-Origin</target>
        </trans-unit>
        <trans-unit id="313ef5554833c1d023f8841fd3ca07c129f4dabb" translate="yes" xml:space="preserve">
          <source>Access-Control-Expose-Headers</source>
          <target state="translated">Access-Control-Expose-Headers</target>
        </trans-unit>
        <trans-unit id="4196525184a54a54617a46e60664f7d0e4576b20" translate="yes" xml:space="preserve">
          <source>Access-Control-Max-Age</source>
          <target state="translated">Access-Control-Max-Age</target>
        </trans-unit>
        <trans-unit id="19e900248599e307979b6e63f1848ccf43a39cde" translate="yes" xml:space="preserve">
          <source>Access-Control-Request-Headers</source>
          <target state="translated">Access-Control-Request-Headers</target>
        </trans-unit>
        <trans-unit id="95705e26c9fe99470c7ef1269a9e4c14d288b849" translate="yes" xml:space="preserve">
          <source>Access-Control-Request-Method</source>
          <target state="translated">Access-Control-Request-Method</target>
        </trans-unit>
        <trans-unit id="07e4b36adfd07ceb756a5d56381f00df21670fde" translate="yes" xml:space="preserve">
          <source>Add Android version to Fennec UA String (bug 1169772)</source>
          <target state="translated">Добавить версию для Android в Fennec UA String (ошибка 1169772)</target>
        </trans-unit>
        <trans-unit id="3858ee0b1cf51a7d707eae259a28585eabdbec88" translate="yes" xml:space="preserve">
          <source>Add the following line to the Web.config file to send the &lt;code&gt;Public-Key-Pins&lt;/code&gt; header:</source>
          <target state="translated">Добавьте следующую строку в файл Web.config, чтобы отправить заголовок &lt;code&gt;Public-Key-Pins&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="87343a4ec44d6166bd6139504ce40cd88c57d49d" translate="yes" xml:space="preserve">
          <source>Added &lt;code&gt;frame-src&lt;/code&gt;, &lt;code&gt;manifest-src&lt;/code&gt; and &lt;code&gt;worker-src&lt;/code&gt; as defaults.</source>
          <target state="translated">Добавлены &lt;code&gt;frame-src&lt;/code&gt; , &lt;code&gt;manifest-src&lt;/code&gt; и &lt;code&gt;worker-src&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="760223db38df00fd781c0887ee7e1f480b28b1c4" translate="yes" xml:space="preserve">
          <source>Added by a proxy if it applies any transformation to the representation, such as changing the content-coding, media-type or the like.</source>
          <target state="translated">Добавляется прокси-сервером,если он применяет какое-либо преобразование к представлению,например,изменение кодирования контента,медиа-типа и т.п.</target>
        </trans-unit>
        <trans-unit id="1f6aba7e1c260b1e97306b61055dc5586e639243" translate="yes" xml:space="preserve">
          <source>Added by proxies, both forward and reverse proxies, and can appear in the request headers and the response headers.</source>
          <target state="translated">Добавляются прокси,как прямой,так и обратный,и могут появляться в заголовках запросов и заголовках ответов.</target>
        </trans-unit>
        <trans-unit id="c6b68b9b3bb4cdd89081228b70979f9dc4741b29" translate="yes" xml:space="preserve">
          <source>Adding a line similar to the following to your webserver's config will enable HPKP on your Apache. This requires &lt;code&gt;mod_headers&lt;/code&gt; enabled.</source>
          <target state="translated">Добавление строки, подобной следующей, в конфигурацию вашего веб-сервера, включит HPKP на вашем Apache. Для этого необходимо включить &lt;code&gt;mod_headers&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dd6d658aa94b5d065ce37a8745178e4946d3138" translate="yes" xml:space="preserve">
          <source>Adding a new user through a signup modal;</source>
          <target state="translated">Добавление нового пользователя через модальную регистрацию;</target>
        </trans-unit>
        <trans-unit id="0b33cfd7eec93815656866755a3c74843234ba55" translate="yes" xml:space="preserve">
          <source>Adding the following line and inserting the appropriate &lt;code&gt;pin-sha256=&quot;...&quot;&lt;/code&gt; values will enable HPKP on your nginx. This requires the &lt;code&gt;ngx_http_headers_module.&lt;/code&gt;</source>
          <target state="translated">Добавление следующей строки и вставка соответствующих &lt;code&gt;pin-sha256=&quot;...&quot;&lt;/code&gt; включит HPKP на вашем nginx. Для этого требуется &lt;code&gt;ngx_http_headers_module.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e4beeace5c1da3ea1621f1d80ef923b85ae8c3d" translate="yes" xml:space="preserve">
          <source>Additional HTTP Status Codes</source>
          <target state="translated">Дополнительные коды статуса HTTP</target>
        </trans-unit>
        <trans-unit id="1967bb490854e6f28ca3226c89aac1f8fefbf865" translate="yes" xml:space="preserve">
          <source>Additional cache control mechanisms have been introduced.</source>
          <target state="translated">Были введены дополнительные механизмы контроля кэша.</target>
        </trans-unit>
        <trans-unit id="4ca7b9663ad28e00bad95a214ec91b0b6850abe7" translate="yes" xml:space="preserve">
          <source>Addresses</source>
          <target state="translated">Addresses</target>
        </trans-unit>
        <trans-unit id="995ce128c900d1dd4799f4d03800bc30f8a436b1" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;base-uri&lt;/code&gt;, &lt;code&gt;child-src&lt;/code&gt;, &lt;code&gt;form-action&lt;/code&gt;, &lt;code&gt;frame-ancestors&lt;/code&gt;, &lt;code&gt;plugin-types&lt;/code&gt;, &lt;code&gt;referrer&lt;/code&gt;, and &lt;code&gt;report-uri&lt;/code&gt;. Deprecates &lt;code&gt;frame-src&lt;/code&gt;.</source>
          <target state="translated">Добавляет &lt;code&gt;base-uri&lt;/code&gt; , &lt;code&gt;child-src&lt;/code&gt; , &lt;code&gt;form-action&lt;/code&gt; , &lt;code&gt;frame-ancestors&lt;/code&gt; , &lt;code&gt;plugin-types&lt;/code&gt; , &lt;code&gt;referrer&lt;/code&gt; и &lt;code&gt;report-uri&lt;/code&gt; . Устарела &lt;code&gt;frame-src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fdd0faf0766b83c157ed1bedec26ec4f6e1bf8e" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;block-all-mixed-content&lt;/code&gt;.</source>
          <target state="translated">Добавляет &lt;code&gt;block-all-mixed-content&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="698c1f11ceb6668338bb9d2d17bb8f430c4a92aa" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;disown-opener&lt;/code&gt;, &lt;code&gt;manifest-src&lt;/code&gt;, &lt;code&gt;navigate-to&lt;/code&gt;, &lt;code&gt;report-to&lt;/code&gt;, &lt;code&gt;strict-dynamic&lt;/code&gt;, &lt;code&gt;worker-src&lt;/code&gt;. Undeprecates &lt;code&gt;frame-src&lt;/code&gt;. Deprecates &lt;code&gt;report-uri&lt;/code&gt; in favor if &lt;code&gt;report-to&lt;/code&gt;.</source>
          <target state="translated">Добавляет &lt;code&gt;disown-opener&lt;/code&gt; , &lt;code&gt;manifest-src&lt;/code&gt; , &lt;code&gt;navigate-to&lt;/code&gt; , &lt;code&gt;report-to&lt;/code&gt; , &lt;code&gt;strict-dynamic&lt;/code&gt; , &lt;code&gt;worker-src&lt;/code&gt; . Не устаревает &lt;code&gt;frame-src&lt;/code&gt; . Принижает &lt;code&gt;report-uri&lt;/code&gt; в пользу , если &lt;code&gt;report-to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9d53db6af9b950aa6111bf9a5dda8ffb5ba7a6b" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;manifest-src&lt;/code&gt;, &lt;code&gt;navigate-to&lt;/code&gt;, &lt;code&gt;report-to&lt;/code&gt;, &lt;code&gt;strict-dynamic&lt;/code&gt;, &lt;code&gt;worker-src&lt;/code&gt;. Undeprecates &lt;code&gt;frame-src&lt;/code&gt;. Deprecates &lt;code&gt;report-uri&lt;/code&gt; in favor if &lt;code&gt;report-to&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3f4d3e4268a9bb85346c045c680766b2c7af4b" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;require-sri-for&lt;/code&gt;.</source>
          <target state="translated">Добавляет &lt;code&gt;require-sri-for&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc23a4d8adf978e596103328ec8522255dce7f76" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;upgrade-insecure-requests&lt;/code&gt;.</source>
          <target state="translated">Добавляет &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="455a3de4efcb11c6f35e14a41277f553dccf6ef8" translate="yes" xml:space="preserve">
          <source>Adobe &lt;a href=&quot;https://acrobat.adobe.com/us/en/why-adobe/about-adobe-pdf.html&quot;&gt;Portable Document Format&lt;/a&gt; (PDF)</source>
          <target state="translated">&lt;a href=&quot;https://acrobat.adobe.com/us/en/why-adobe/about-adobe-pdf.html&quot;&gt;Формат переносимого документа&lt;/a&gt; Adobe (PDF)</target>
        </trans-unit>
        <trans-unit id="c6442c85da3c85db38a1dc41c371e4303bfaa1ab" translate="yes" xml:space="preserve">
          <source>Adopting a strict policy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="705cc20005888890de14a5894736ddb464edf2fe" translate="yes" xml:space="preserve">
          <source>Advice on using a www-prefixed domain or not, this article explains the consequences of the choice as well as how to make it.</source>
          <target state="translated">Совет по использованию www-префиксного домена или нет,в этой статье объясняются последствия выбора,а также то,как его сделать.</target>
        </trans-unit>
        <trans-unit id="733cfd6083d3dd3e2cb74c180509e4b0f99a5baa" translate="yes" xml:space="preserve">
          <source>Advisory text describing the error.</source>
          <target state="translated">Консультативный текст с описанием ошибки.</target>
        </trans-unit>
        <trans-unit id="70bf82aa792195fb9abd5a33a491d7ed6007e8d4" translate="yes" xml:space="preserve">
          <source>After a successful COPY invocation, all dead properties on the source
   resource SHOULD be duplicated on the destination resource.  Live
   properties described in this document SHOULD be duplicated as
   identically behaving live properties at the destination resource, but
   not necessarily with the same values.  Servers SHOULD NOT convert
   live properties into dead properties on the destination resource,
   because clients may then draw incorrect conclusions about the state
   or functionality of a resource.  Note that some live properties are
   defined such that the absence of the property has a specific meaning
   (e.g., a flag with one meaning if present, and the opposite if
   absent), and in these cases, a successful COPY might result in the
   property being reported as &quot;Not Found&quot; in subsequent requests.

   When the destination is an unmapped URL, a COPY operation creates a
   new resource much like a PUT operation does.  Live properties that
   are related to resource creation (such as DAV:creationdate) should
   have their values set accordingly.</source>
          <target state="translated">После успешного вызова COPY все мертвые свойства на ресурсе-источнике ДОЛЖНЫ быть продублированы на ресурсе-получателе.Живые свойства,описанные в этом документе ДОЛЖНЫ быть продублированы как идентично ведущие себя живые свойства на целевом ресурсе,но не обязательно с одинаковыми значениями.Серверы НЕ ДОЛЖНЫ преобразовывать живые свойства в мертвые на ресурсе назначения,поскольку в этом случае клиенты могут сделать неверные выводы о состоянии или функциональности ресурса.Обратите внимание,что некоторые &quot;живые&quot; свойства определяются таким образом,что отсутствие свойства имеет определенное значение (например,флаг с одним значением,если он присутствует,и обратное,если оно отсутствует),и в этих случаях успешное COPY может привести к тому,что в последующих запросах свойство будет сообщено как &quot;Not Found&quot; (&quot;Не найдено&quot;).Когда назначение-это нераскрытый URL,операция COPY создает новый ресурс так же,как и операция PUT.Живые свойства,которые связаны с созданием ресурса (такие как DAV:createdate)должны иметь соответствующие значения.</target>
        </trans-unit>
        <trans-unit id="e07104f09b3d658fa8a7e37d72c9f233c219006d" translate="yes" xml:space="preserve">
          <source>After receiving an HTTP request, a server can send one or more &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; headers with the response. The cookie is usually stored by the browser, and then the cookie is sent with requests made to the same server inside a &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; HTTP header. An expiration date or duration can be specified, after which the cookie is no longer sent. Additional restrictions to a specific domain and path can be set, limiting where the cookie is sent. For details about the header attributes mentioned below, refer to the &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; reference article.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14481714e36484442aceaedae4c2cd14105aca4" translate="yes" xml:space="preserve">
          <source>After receiving and interpreting a request message, a server responds
   with an HTTP response message.

       Response      = Status-Line               ; &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;
                       *(( general-header        ; &lt;a href=&quot;#section-4.5&quot;&gt;Section 4.5&lt;/a&gt;
                        | response-header        ; &lt;a href=&quot;#section-6.2&quot;&gt;Section 6.2&lt;/a&gt;
                        | entity-header ) CRLF)  ; &lt;a href=&quot;#section-7.1&quot;&gt;Section 7.1&lt;/a&gt;
                       CRLF
                       [ message-body ]          ; &lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;</source>
          <target state="translated">После получения и интерпретации сообщения запроса сервер отвечает сообщением ответа HTTP. Ответ = Строка состояния; &lt;a href=&quot;#section-6.1&quot;&gt;Раздел 6.1&lt;/a&gt; * ((общий-заголовок; &lt;a href=&quot;#section-4.5&quot;&gt;Раздел 4.5&lt;/a&gt; | заголовок-ответа; &lt;a href=&quot;#section-6.2&quot;&gt;Раздел 6.2&lt;/a&gt; | заголовок объекта) CRLF); &lt;a href=&quot;#section-7.1&quot;&gt;Раздел 7.1&lt;/a&gt; CRLF [тело сообщения]; &lt;a href=&quot;#section-7.2&quot;&gt;Раздел 7.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd41b49b28657546d8abb377c969ab355261d840" translate="yes" xml:space="preserve">
          <source>After reviewing all of the above better alternatives to user agent sniffing, there are still some potential cases where user agent sniffing is appropriate and justified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1797b05d9266d8b1fa009268c07e98d87828a9" translate="yes" xml:space="preserve">
          <source>After sending the PUSH_PROMISE frame, the server can begin delivering
   the pushed response as a response (&lt;a href=&quot;#section-8.1.2.4&quot;&gt;Section 8.1.2.4&lt;/a&gt;) on a server-
   initiated stream that uses the promised stream identifier.  The
   server uses this stream to transmit an HTTP response, using the same
   sequence of frames as defined in &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.  This stream becomes
   &quot;half-closed&quot; to the client (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;) after the initial HEADERS
   frame is sent.

   Once a client receives a PUSH_PROMISE frame and chooses to accept the
   pushed response, the client SHOULD NOT issue any requests for the
   promised response until after the promised stream has closed.

   If the client determines, for any reason, that it does not wish to
   receive the pushed response from the server or if the server takes
   too long to begin sending the promised response, the client can send
   a RST_STREAM frame, using either the CANCEL or REFUSED_STREAM code
   and referencing the pushed stream's identifier.

   A client can use the SETTINGS_MAX_CONCURRENT_STREAMS setting to limit
   the number of responses that can be concurrently pushed by a server.
   Advertising a SETTINGS_MAX_CONCURRENT_STREAMS value of zero disables
   server push by preventing the server from creating the necessary
   streams.  This does not prohibit a server from sending PUSH_PROMISE
   frames; clients need to reset any promised streams that are not
   wanted.

   Clients receiving a pushed response MUST validate that either the
   server is authoritative (see &lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;) or the proxy that provided
   the pushed response is configured for the corresponding request.  For
   example, a server that offers a certificate for only the
   &quot;example.com&quot; DNS-ID or Common Name is not permitted to push a
   response for &quot;https://www.example.org/doc&quot;.

   The response for a PUSH_PROMISE stream begins with a HEADERS frame,
   which immediately puts the stream into the &quot;half-closed (remote)&quot;
   state for the server and &quot;half-closed (local)&quot; state for the client,
   and ends with a frame bearing END_STREAM, which places the stream in
   the &quot;closed&quot; state.

      Note: The client never sends a frame with the END_STREAM flag for
      a server push.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef923924b84276758cd6220f7c2e0df0c688265" translate="yes" xml:space="preserve">
          <source>After the HTTP/1.1 header and the blank line that indicates the end of the header, the server will immediately include the server connection preface, starting with a &lt;code&gt;SETTINGS&lt;/code&gt; frame.</source>
          <target state="translated">После заголовка HTTP / 1.1 и пустой строки, обозначающей конец заголовка, сервер немедленно включит предисловие для подключения к серверу, начиная с кадра &lt;code&gt;SETTINGS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d6a047137bbfac123a894e86187dc3649969994" translate="yes" xml:space="preserve">
          <source>After the connected agent has sent its request, the web server processes it, and ultimately returns a response. Similar to a client request, a server response is formed of text directives, separated by CRLF, though divided into three blocks:</source>
          <target state="translated">После того,как подключенный агент отправил свой запрос,веб-сервер обрабатывает его,и в конце концов возвращает ответ.Как и в случае с клиентским запросом,ответ сервера формируется из текстовых директив,разделенных CRLF,хотя и разделенных на три блока:</target>
        </trans-unit>
        <trans-unit id="26b7ae2775e7780938b8a0d7dbb2cdbf0eb3bc68" translate="yes" xml:space="preserve">
          <source>Again, use of the DNS server in the above can be minimized by adding redundant rules in the beginning:</source>
          <target state="translated">Опять же,использование DNS сервера в вышеперечисленных случаях можно свести к минимуму путем добавления избыточных правил в начале:</target>
        </trans-unit>
        <trans-unit id="ff9f1ff32120d8b893c1ded522d49590353b29a6" translate="yes" xml:space="preserve">
          <source>Age</source>
          <target state="translated">Age</target>
        </trans-unit>
        <trans-unit id="55c793215f8562190a36c5bf36bf9466ad683e17" translate="yes" xml:space="preserve">
          <source>Age (RFC 2616)</source>
          <target state="translated">Возраст (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="e4b4c54419afac8726deafd7435dab4615c9a68e" translate="yes" xml:space="preserve">
          <source>Age (RFC 7234)</source>
          <target state="translated">Возраст (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="52f86c4884cf6979487407f1bfb260fe6dc008d2" translate="yes" xml:space="preserve">
          <source>Agent-driven negotiation</source>
          <target state="translated">Переговоры с участием агентов</target>
        </trans-unit>
        <trans-unit id="82e63706ff054e31f88909b903c540eb9fab7bf0" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content&quot;&gt;mixed content&lt;/a&gt; resource requests are blocked, including both active and passive mixed content. This also applies to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; documents, ensuring the entire page is mixed content free.</source>
          <target state="translated">Все запросы ресурсов &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content&quot;&gt;смешанного содержимого&lt;/a&gt; блокируются, включая как активное, так и пассивное смешанное содержимое. Это также относится к документам &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; , гарантируя, что вся страница не содержит смешанного содержимого.</target>
        </trans-unit>
        <trans-unit id="3f8728ba6de2afc5f460293bf5467790c482e2a7" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content&quot;&gt;mixed content&lt;/a&gt; resource requests are blocked, including both active and passive mixed content. This also applies to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; documents, ensuring the entire page is mixed content-free.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a928697259543059b585ea4af2c89236a67a72" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;text&lt;/code&gt; JavaScript types have been deprecated by &lt;a href=&quot;https://tools.ietf.org/html/rfc4329&quot;&gt;RFC 4329&lt;/a&gt;.</source>
          <target state="translated">Все типы &lt;code&gt;text&lt;/code&gt; JavaScript устарели в соответствии с &lt;a href=&quot;https://tools.ietf.org/html/rfc4329&quot;&gt;RFC 4329&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44f2895fb52823cefc3e500436bf5266b5f12474" translate="yes" xml:space="preserve">
          <source>All DAV headers follow the same basic formatting rules as HTTP
   headers.  This includes rules like line continuation and how to
   combine (or separate) multiple instances of the same header using
   commas.

   WebDAV adds two new conditional headers to the set defined in HTTP:
   the If and Overwrite headers.</source>
          <target state="translated">Все DAV-заголовки следуют тем же базовым правилам форматирования,что и HTTP-заголовки.Сюда входят такие правила,как продолжение строки и как комбинировать (или разделять)несколько экземпляров одного и того же заголовка с помощью запятых.WebDAV добавляет два новых условных заголовка в набор,определенный в HTTP:заголовки If и Overwrite.</target>
        </trans-unit>
        <trans-unit id="7bb7c13dc794c86beb6b5eb454b43a1af1effca0" translate="yes" xml:space="preserve">
          <source>All HTML content should be served with this type. Alternative MIME types for XHTML (like &lt;code&gt;application/xhtml+xml&lt;/code&gt;) are mostly useless nowadays.</source>
          <target state="translated">Все содержимое HTML должно обслуживаться этим типом. Альтернативные типы MIME для XHTML (например, &lt;code&gt;application/xhtml+xml&lt;/code&gt; ) в настоящее время в основном бесполезны.</target>
        </trans-unit>
        <trans-unit id="c02d32fb5d5640d2efd7ae1d94e1efc7987916ea" translate="yes" xml:space="preserve">
          <source>All HTTP/1.1 messages consist of a start-line followed by a sequence
   of octets in a format similar to the Internet Message Format
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;]: zero or more header fields (collectively referred to as
   the &quot;headers&quot; or the &quot;header section&quot;), an empty line indicating the
   end of the header section, and an optional message body.

     HTTP-message   = start-line
                      *( header-field CRLF )
                      CRLF
                      [ message-body ] 

   The normal procedure for parsing an HTTP message is to read the
   start-line into a structure, read each header field into a hash table
   by field name until the empty line, and then use the parsed data to
   determine if a message body is expected.  If a message body has been
   indicated, then it is read as a stream until an amount of octets
   equal to the message body length is read or the connection is closed.

   A recipient MUST parse an HTTP message as a sequence of octets in an
   encoding that is a superset of US-ASCII [&lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt;].  Parsing an HTTP
   message as a stream of Unicode characters, without regard for the
   specific encoding, creates security vulnerabilities due to the
   varying ways that string processing libraries handle invalid
   multibyte character sequences that contain the octet LF (%x0A).
   String-based parsers can only be safely used within protocol elements
   after the element has been extracted from the message, such as within
   a header field-value after message parsing has delineated the
   individual fields.

   An HTTP message can be parsed as a stream for incremental processing
   or forwarding downstream.  However, recipients cannot rely on
   incremental delivery of partial messages, since some implementations
   will buffer or delay message forwarding for the sake of network
   efficiency, security checks, or payload transformations.

   A sender MUST NOT send whitespace between the start-line and the
   first header field.  A recipient that receives whitespace between the
   start-line and the first header field MUST either reject the message
   as invalid or consume each whitespace-preceded line without further
   processing of it (i.e., ignore the entire line, along with any
   subsequent lines preceded by whitespace, until a properly formed
   header field is received or the header section is terminated).

   The presence of such whitespace in a request might be an attempt to
   trick a server into ignoring that field or processing the line after
   it as a new request, either of which might result in a security
   vulnerability if other implementations within the request chain
   interpret the same message differently.  Likewise, the presence of
   such whitespace in a response might be ignored by some clients or
   cause others to cease parsing.</source>
          <target state="translated">Все сообщения HTTP / 1.1 состоят из начальной строки, за которой следует последовательность октетов в формате, аналогичном формату Интернет-сообщений [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;]: ноль или более полей заголовка (вместе именуемые &amp;laquo;заголовки&amp;raquo; или &amp;laquo;раздел заголовка&amp;raquo;), пустая строка, указывающая конец раздела заголовка, и необязательное тело сообщения. HTTP-message = start-line * (поле заголовка CRLF) CRLF [message-body] Обычная процедура для синтаксического анализа HTTP-сообщения - считывание начальной строки в структуру, считывание каждого поля заголовка в хеш-таблицу по имени поля до пустой строки, а затем используйте проанализированные данные, чтобы определить, ожидается ли тело сообщения. Если указано тело сообщения, оно читается как поток, пока не будет прочитано количество октетов, равное длине тела сообщения, или пока соединение не будет закрыто.Получатель ДОЛЖЕН анализировать HTTP-сообщение как последовательность октетов в кодировке, которая является надмножеством US-ASCII [&lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt;]. Анализ HTTP-сообщения как потока символов Юникода без учета конкретной кодировки создает уязвимости безопасности из-за различных способов, которыми библиотеки обработки строк обрабатывают недопустимые многобайтовые последовательности символов, содержащие октет LF (% x0A). Анализаторы на основе строк можно безопасно использовать в элементах протокола только после того, как элемент был извлечен из сообщения, например, в пределах значения поля заголовка после того, как синтаксический анализ сообщения выделил отдельные поля. Сообщение HTTP может быть проанализировано как поток для дополнительной обработки или пересылки в нисходящем направлении. Однако получатели не могут полагаться на инкрементную доставку частичных сообщений, поскольку некоторые реализации будут буферизовать или задерживать пересылку сообщений для повышения эффективности сети, проверки безопасности или преобразования полезной нагрузки.Отправитель НЕ ДОЛЖЕН отправлять пробелы между начальной строкой и первым полем заголовка. Получатель, который получает пробел между начальной строкой и первым полем заголовка, ДОЛЖЕН либо отклонить сообщение как недопустимое, либо использовать каждую строку с пробелом без дальнейшей обработки (т. Е. Игнорировать всю строку вместе с любыми последующими строками, которым предшествует пробел. , пока не будет получено правильно сформированное поле заголовка или пока раздел заголовка не будет завершен). Наличие таких пробелов в запросе может быть попыткой обмануть сервер, чтобы он проигнорировал это поле или обработал строку после него как новый запрос, любой из которых может привести к уязвимости безопасности, если другие реализации в цепочке запросов интерпретируют то же самое. сообщение иначе. Точно так же,присутствие таких пробелов в ответе может игнорироваться некоторыми клиентами или заставлять других прекращать синтаксический анализ.</target>
        </trans-unit>
        <trans-unit id="fc6d70014fb3882dcf60f571eb265b4ead440816" translate="yes" xml:space="preserve">
          <source>All conditional headers try to check if the resource stored on the server matches a specific version. To achieve this, the conditional requests need to indicate the version of the resource. As comparing the whole resource byte to byte is impracticable, and not always what is wanted, the request transmits a value describing the version. Such values are called &lt;em&gt;validators&lt;/em&gt;, and are of two kinds:</source>
          <target state="translated">Все условные заголовки пытаются проверить, соответствует ли ресурс, хранящийся на сервере, определенной версии. Для этого в условных запросах необходимо указывать версию ресурса. Поскольку сравнение всего байта ресурса с байтом невозможно, и не всегда то, что требуется, запрос передает значение, описывающее версию. Такие значения называются &lt;em&gt;валидаторами&lt;/em&gt; и бывают двух видов:</target>
        </trans-unit>
        <trans-unit id="296ff2d47f9455e021f2222fa33a39e88b9c1dd8" translate="yes" xml:space="preserve">
          <source>All dependent streams are allocated an integer weight between 1 and
   256 (inclusive).

   Streams with the same parent SHOULD be allocated resources
   proportionally based on their weight.  Thus, if stream B depends on
   stream A with weight 4, stream C depends on stream A with weight 12,
   and no progress can be made on stream A, stream B ideally receives
   one-third of the resources allocated to stream C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea1578a24664dc2977454167c38e76bf6096f7f" translate="yes" xml:space="preserve">
          <source>All directives must comply with the &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;quoted-string grammar&lt;/a&gt;. A directive that does not include the double quotes is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee4674f00380d123974f659bcae306656f636284" translate="yes" xml:space="preserve">
          <source>All documents in the &lt;code&gt;images/&lt;/code&gt; directory will redirect to a different domain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86032829f23613e0e2c883c0ed233cfc98f34429" translate="yes" xml:space="preserve">
          <source>All documents in the &lt;code&gt;images/&lt;/code&gt; folder will be redirected to a different domain.</source>
          <target state="translated">Все документы в папке &lt;code&gt;images/&lt;/code&gt; будут перенаправлены в другой домен.</target>
        </trans-unit>
        <trans-unit id="151f06c99b273134876a0a499da72571a2000294" translate="yes" xml:space="preserve">
          <source>All frames begin with a fixed 9-octet header followed by a variable-
   length payload.

    +-----------------------------------------------+
    |                 Length (24)                   |
    +---------------+---------------+---------------+
    |   Type (8)    |   Flags (8)   |
    +-+-------------+---------------+-------------------------------+
    |R|                 Stream Identifier (31)                      |
    +=+=============================================================+
    |                   Frame Payload (0...)                      
    +---------------------------------------------------------------+

                          Figure 1: Frame Layout

   The fields of the frame header are defined as:

   Length:  The length of the frame payload expressed as an unsigned
      24-bit integer.  Values greater than 2^14 (16,384) MUST NOT be
      sent unless the receiver has set a larger value for
      SETTINGS_MAX_FRAME_SIZE.

      The 9 octets of the frame header are not included in this value. 

   Type:  The 8-bit type of the frame.  The frame type determines the
      format and semantics of the frame.  Implementations MUST ignore
      and discard any frame that has a type that is unknown.

   Flags:  An 8-bit field reserved for boolean flags specific to the
      frame type.

      Flags are assigned semantics specific to the indicated frame type.
      Flags that have no defined semantics for a particular frame type
      MUST be ignored and MUST be left unset (0x0) when sending.

   R: A reserved 1-bit field.  The semantics of this bit are undefined,
      and the bit MUST remain unset (0x0) when sending and MUST be
      ignored when receiving.

   Stream Identifier:  A stream identifier (see &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;) expressed
      as an unsigned 31-bit integer.  The value 0x0 is reserved for
      frames that are associated with the connection as a whole as
      opposed to an individual stream.

   The structure and content of the frame payload is dependent entirely
   on the frame type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c6c99a024c7f251148642ab153c93b1834f5d1" translate="yes" xml:space="preserve">
          <source>All hosts which aren't fully qualified, or the ones that are in local domain, will be connected to directly. Everything else will go through &lt;code&gt;w3proxy.mozilla.org:8080&lt;/code&gt;. If the proxy goes down, connections become direct automatically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2556a3f65b2016a6f4465c2cba6687d885b96f50" translate="yes" xml:space="preserve">
          <source>All hosts which aren't fully qualified, or the ones that are in local domain, will be connected to directly. Everything else will go through w3proxy:8080. If the proxy goes down, connections become direct automatically:</source>
          <target state="translated">Все хосты,которые не полностью квалифицированы,или те,которые находятся в локальном домене,будут подключены напрямую.Все остальное будет проходить через w3proxy:8080.Если прокси выйдет из строя,соединения станут прямыми автоматически:</target>
        </trans-unit>
        <trans-unit id="9e7d8118d9f750540c3d405da3bd825af374930a" translate="yes" xml:space="preserve">
          <source>All iframes inherit the policy of their parent page. If the iframe has an &lt;code&gt;allow&lt;/code&gt; attribute, the policies of the parent page and the &lt;code&gt;allow&lt;/code&gt; attribute are combined, using the most restrictive subset. For an iframe to have a feature enabled, the origin must be in the allowlist for both the parent page and the allow attribute.</source>
          <target state="translated">Все фреймы наследуют политику своей родительской страницы. Если iframe имеет атрибут &lt;code&gt;allow&lt;/code&gt; , политики родительской страницы и атрибута &lt;code&gt;allow&lt;/code&gt; объединяются с использованием наиболее ограничительного подмножества. Чтобы функция iframe была включена, источник должен находиться в списке разрешений как для родительской страницы, так и для атрибута allow.</target>
        </trans-unit>
        <trans-unit id="14f1bc03c603d449cb2f82a18478f537735beda9" translate="yes" xml:space="preserve">
          <source>All local accesses are desired to be direct. All proxy servers run on the port 8080 (they don't need to). Note how strings can be concatenated with the &lt;strong&gt;+&lt;/strong&gt; operator in JavaScript.</source>
          <target state="translated">Желательно, чтобы все локальные доступы были прямыми. Все прокси-серверы работают на порту 8080 (в этом нет необходимости). Обратите внимание, как строки могут быть объединены с помощью оператора &lt;strong&gt;+&lt;/strong&gt; в JavaScript.</target>
        </trans-unit>
        <trans-unit id="871fee64cdc73fa544bed4b409dd8bfda18bd570" translate="yes" xml:space="preserve">
          <source>All local accesses are desired to be direct. All proxy servers run on the port 8080 (they don't need to, you can just change your port but remember to modify your configuations on both side). Note how strings can be concatenated with the &lt;code&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;/code&gt; operator in JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f43d7619bd14afa48b80f4f69322e3d75a1bed" translate="yes" xml:space="preserve">
          <source>All methods that might be expected to cause modifications to the
   origin server's resources MUST be written through to the origin
   server. This currently includes all methods except for GET and HEAD.
   A cache MUST NOT reply to such a request from a client before having
   transmitted the request to the inbound server, and having received a
   corresponding response from the inbound server. This does not prevent
   a proxy cache from sending a 100 (Continue) response before the
   inbound server has sent its final reply.

   The alternative (known as &quot;write-back&quot; or &quot;copy-back&quot; caching) is not
   allowed in HTTP/1.1, due to the difficulty of providing consistent
   updates and the problems arising from server, cache, or network
   failure prior to write-back.</source>
          <target state="translated">Все методы,которые могут вызвать изменения в ресурсах сервера-источника,ДОЛЖНЫ быть записаны на сервер-источник.В настоящее время это включает в себя все методы,за исключением GET и HEAD.Кэш НЕ ДОЛЖЕН отвечать на такой запрос от клиента,прежде чем передать запрос на входящий сервер и получить соответствующий ответ от входящего сервера.Это не мешает кэшу прокси отправить 100 (Продолжить)ответов до того,как входящий сервер отправит свой окончательный ответ.Альтернатива (известная как кэширование &quot;write-back&quot; или &quot;copy-back&quot;)не разрешена в HTTP/1.1 из-за сложности обеспечения последовательных обновлений и проблем,возникающих из-за сбоя сервера,кэша или сети до &quot;write-back&quot;.</target>
        </trans-unit>
        <trans-unit id="d6a76bce8ed4b24dc82bafad92dd9740f7195e9c" translate="yes" xml:space="preserve">
          <source>All modern browsers and servers do support it and the only thing to negotiate is the compression algorithm to use. These algorithm are optimized for text. In the 1990s, compression technology was advancing at a rapid pace and numerous successive algorithms have been added to the set of possible choices. Nowadays, only two are relevant: &lt;code&gt;gzip&lt;/code&gt;, the most common one, and &lt;code&gt;br&lt;/code&gt; the new challenger.</source>
          <target state="translated">Все современные браузеры и серверы поддерживают его, и единственное, что нужно согласовать, - это алгоритм сжатия. Эти алгоритмы оптимизированы для текста. В 1990-х технология сжатия развивалась быстрыми темпами, и к набору возможных вариантов были добавлены многочисленные последовательные алгоритмы. В настоящее время актуальны только два: самый распространенный &lt;code&gt;gzip&lt;/code&gt; и новый претендент &lt;code&gt;br&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7efabba7ae41c2653d1f20ea222b6e6ae7445249" translate="yes" xml:space="preserve">
          <source>All of the mechanisms specified in this document are described in
   both prose and an augmented Backus-Naur Form (BNF) similar to that
   used by &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Implementors will need to be familiar with the
   notation in order to understand this specification. The augmented BNF
   includes the following constructs:

   name = definition
      The name of a rule is simply the name itself (without any
      enclosing &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot;) and is separated from its definition by the
      equal &quot;=&quot; character. White space is only significant in that
      indentation of continuation lines is used to indicate a rule
      definition that spans more than one line. Certain basic rules are
      in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc. Angle
      brackets are used within definitions whenever their presence will
      facilitate discerning the use of rule names.

   &quot;literal&quot;
      Quotation marks surround literal text. Unless stated otherwise,
      the text is case-insensitive.

   rule1 | rule2
      Elements separated by a bar (&quot;|&quot;) are alternatives, e.g., &quot;yes |
      no&quot; will accept yes or no.

   (rule1 rule2)
      Elements enclosed in parentheses are treated as a single element.
      Thus, &quot;(elem (foo | bar) elem)&quot; allows the token sequences &quot;elem
      foo elem&quot; and &quot;elem bar elem&quot;.

   *rule
      The character &quot;*&quot; preceding an element indicates repetition. The
      full form is &quot;&amp;lt;n&amp;gt;*&amp;lt;m&amp;gt;element&quot; indicating at least &amp;lt;n&amp;gt; and at most
      &amp;lt;m&amp;gt; occurrences of element. Default values are 0 and infinity so
      that &quot;*(element)&quot; allows any number, including zero; &quot;1*element&quot;
      requires at least one; and &quot;1*2element&quot; allows one or two.

   [&lt;a id=&quot;ref-rule&quot; name=&quot;ref-rule&quot;&gt;rule&lt;/a&gt;]
      Square brackets enclose optional elements; &quot;[foo bar]&quot; is
      equivalent to &quot;*1(foo bar)&quot;. 

   N rule
      Specific repetition: &quot;&amp;lt;n&amp;gt;(element)&quot; is equivalent to
      &quot;&amp;lt;n&amp;gt;*&amp;lt;n&amp;gt;(element)&quot;; that is, exactly &amp;lt;n&amp;gt; occurrences of (element).
      Thus 2DIGIT is a 2-digit number, and 3ALPHA is a string of three
      alphabetic characters.

   #rule
      A construct &quot;#&quot; is defined, similar to &quot;*&quot;, for defining lists of
      elements. The full form is &quot;&amp;lt;n&amp;gt;#&amp;lt;m&amp;gt;element&quot; indicating at least
      &amp;lt;n&amp;gt; and at most &amp;lt;m&amp;gt; elements, each separated by one or more commas
      (&quot;,&quot;) and OPTIONAL linear white space (LWS). This makes the usual
      form of lists very easy; a rule such as
         ( *LWS element *( *LWS &quot;,&quot; *LWS element ))
      can be shown as
         1#element
      Wherever this construct is used, null elements are allowed, but do
      not contribute to the count of elements present. That is,
      &quot;(element), , (element) &quot; is permitted, but counts as only two
      elements. Therefore, where at least one element is required, at
      least one non-null element MUST be present. Default values are 0
      and infinity so that &quot;#element&quot; allows any number, including zero;
      &quot;1#element&quot; requires at least one; and &quot;1#2element&quot; allows one or
      two.

   ; comment
      A semi-colon, set off some distance to the right of rule text,
      starts a comment that continues to the end of line. This is a
      simple way of including useful notes in parallel with the
      specifications.

   implied *LWS
      The grammar described by this specification is word-based. Except
      where noted otherwise, linear white space (LWS) can be included
      between any two adjacent words (token or quoted-string), and
      between adjacent words and separators, without changing the
      interpretation of a field. At least one delimiter (LWS and/or

      separators) MUST exist between any two tokens (for the definition
      of &quot;token&quot; below), since they would otherwise be interpreted as a
      single token.</source>
          <target state="translated">Все механизмы, указанные в этом документе, описаны как в тексте, так и в расширенной форме Бэкуса-Наура (BNF), аналогичной той, которая используется в &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Разработчики должны быть знакомы с обозначениями, чтобы понять эту спецификацию. Расширенный BNF включает в себя следующие конструкции: name = definition Имя правила - это просто само имя (без каких-либо заключительных &amp;laquo;&amp;lt;&amp;raquo; и &amp;laquo;&amp;gt;&amp;raquo;) и отделено от его определения знаком равенства &amp;laquo;=&amp;raquo;. Пробелы имеют значение только в том случае, если отступ строк продолжения используется для обозначения определения правила, которое охватывает более одной строки. Некоторые основные правила пишутся прописными буквами, например SP, LWS, HT, CRLF, DIGIT, ALPHA и т. Д. Угловые скобки используются в определениях всякий раз, когда их наличие облегчает распознавание использования имен правил. &quot;literal&quot; Буквальный текст окружен кавычками. Если не указано иное,в тексте регистр не учитывается. rule1 | rule2 Элементы, разделенные чертой (&amp;laquo;|&amp;raquo;), являются альтернативными, например, &amp;laquo;да | нет&amp;raquo; примет &amp;laquo;да&amp;raquo; или &amp;laquo;нет&amp;raquo;. (правило1 правило2) Элементы, заключенные в круглые скобки, рассматриваются как один элемент. Таким образом, &amp;laquo;(elem (foo | bar) elem)&amp;raquo; разрешает токен-последовательности &amp;laquo;elem foo elem&amp;raquo; и &amp;laquo;elem bar elem&amp;raquo;. * правило Символ &amp;laquo;*&amp;raquo; перед элементом указывает на повторение. Полная форма - &amp;laquo;&amp;lt;n&amp;gt; * &amp;lt;m&amp;gt; element&amp;raquo;, указывающая как минимум &amp;lt;n&amp;gt; и самое большее &amp;lt;m&amp;gt; вхождений элемента. Значения по умолчанию - 0 и бесконечность, поэтому &quot;* (element)&quot; допускает любое число, включая ноль; &amp;laquo;1 * элемент&amp;raquo; требует хотя бы одного; а &amp;laquo;1 * 2элемент&amp;raquo; позволяет один или два. [[[rule1 | rule2 Элементы, разделенные чертой (&amp;laquo;|&amp;raquo;), являются альтернативными, например, &amp;laquo;да | нет&amp;raquo; примет &amp;laquo;да&amp;raquo; или &amp;laquo;нет&amp;raquo;. (правило1 правило2) Элементы, заключенные в круглые скобки, рассматриваются как один элемент. Таким образом, &amp;laquo;(elem (foo | bar) elem)&amp;raquo; разрешает последовательности лексем &amp;laquo;elem foo elem&amp;raquo; и &amp;laquo;elem bar elem&amp;raquo;. * rule Знак &amp;laquo;*&amp;raquo; перед элементом указывает на повторение. Полная форма - это &amp;laquo;&amp;lt;n&amp;gt; * &amp;lt;m&amp;gt; element&amp;raquo;, указывающая не менее &amp;lt;n&amp;gt; и не более &amp;lt;m&amp;gt; вхождений элемента. Значения по умолчанию - 0 и бесконечность, поэтому &quot;* (element)&quot; допускает любое число, включая ноль; &amp;laquo;1 * элемент&amp;raquo; требует хотя бы одного; а &amp;laquo;1 * 2элемент&amp;raquo; позволяет один или два. [rule1 | rule2 Элементы, разделенные чертой (&amp;laquo;|&amp;raquo;), являются альтернативными, например, &amp;laquo;да | нет&amp;raquo; примет &amp;laquo;да&amp;raquo; или &amp;laquo;нет&amp;raquo;. (правило1 правило2) Элементы, заключенные в круглые скобки, рассматриваются как один элемент. Таким образом, &amp;laquo;(elem (foo | bar) elem)&amp;raquo; разрешает последовательности лексем &amp;laquo;elem foo elem&amp;raquo; и &amp;laquo;elem bar elem&amp;raquo;. * правило Символ &amp;laquo;*&amp;raquo; перед элементом указывает на повторение. Полная форма - это &amp;laquo;&amp;lt;n&amp;gt; * &amp;lt;m&amp;gt; element&amp;raquo;, указывающая не менее &amp;lt;n&amp;gt; и не более &amp;lt;m&amp;gt; вхождений элемента. Значения по умолчанию - 0 и бесконечность, поэтому &quot;* (element)&quot; допускает любое число, включая ноль; &amp;laquo;1 * элемент&amp;raquo; требует хотя бы одного; а &amp;laquo;1 * 2элемент&amp;raquo; позволяет один или два. [[[да | no &quot;будет принимать да или нет. (rule1 rule2) Элементы, заключенные в круглые скобки, рассматриваются как один элемент. Таким образом,&quot; (elem (foo | bar) elem) &quot;разрешает последовательность токенов&quot; elem foo elem &quot;и&quot; elem bar elem Правило &quot;. *&quot; Символ &quot;*&quot;, предшествующий элементу, указывает на повторение. Полная форма - это &quot;&amp;lt;n&amp;gt; * &amp;lt;m&amp;gt; element&quot;, указывающая не менее &amp;lt;n&amp;gt; и не более &amp;lt;m&amp;gt; вхождений элемента. Значения по умолчанию - 0 и бесконечность, так что &quot;* (element)&quot; допускает любое число, включая ноль; &quot;1 * element&quot; требует как минимум один; и &quot;1 * 2element&quot; допускает один или два. [да | no &quot;будет принимать да или нет. (rule1 rule2) Элементы, заключенные в круглые скобки, рассматриваются как один элемент. Таким образом,&quot; (elem (foo | bar) elem) &quot;разрешает последовательность токенов&quot; elem foo elem &quot;и&quot; elem bar elem Правило &quot;. *&quot; Символ &quot;*&quot;, предшествующий элементу, указывает на повторение. Полная форма - это &quot;&amp;lt;n&amp;gt; * &amp;lt;m&amp;gt; element&quot;, указывающая не менее &amp;lt;n&amp;gt; и не более &amp;lt;m&amp;gt; вхождений элемента. Значения по умолчанию - 0 и бесконечность, так что &quot;* (element)&quot; допускает любое число, включая ноль; &quot;1 * element&quot; требует как минимум один; и &quot;1 * 2element&quot; допускает один или два. [(elem (foo | bar) elem) &quot;позволяет использовать последовательности токенов&quot; elem foo elem &quot;и&quot; elem bar elem &quot;. * rule Символ&quot; * &quot;, предшествующий элементу, указывает на повторение. Полная форма:&quot; &amp;lt;n&amp;gt; * &amp;lt;m &amp;gt; element &quot;, указывающий не менее &amp;lt;n&amp;gt; и не более &amp;lt;m&amp;gt; вхождений элемента. Значения по умолчанию - 0 и бесконечность, так что&quot; * (element) &quot;допускает любое число, включая ноль;&quot; 1 * element &quot;требует хотя бы одного; а &quot;1 * 2element&quot; - один или два. [(elem (foo | bar) elem) &quot;позволяет использовать последовательности токенов&quot; elem foo elem &quot;и&quot; elem bar elem &quot;. * rule Символ&quot; * &quot;, предшествующий элементу, указывает на повторение. Полная форма:&quot; &amp;lt;n&amp;gt; * &amp;lt;m &amp;gt; element &quot;, указывающий не менее &amp;lt;n&amp;gt; и не более &amp;lt;m&amp;gt; вхождений элемента. Значения по умолчанию - 0 и бесконечность, так что&quot; * (element) &quot;допускает любое число, включая ноль;&quot; 1 * element &quot;требует хотя бы одного; а &quot;1 * 2element&quot; - один или два. [и не более &amp;lt;m&amp;gt; вхождений element. Значения по умолчанию - 0 и бесконечность, поэтому &quot;* (element)&quot; допускает любое число, включая ноль; &amp;laquo;1 * элемент&amp;raquo; требует хотя бы одного; а &amp;laquo;1 * 2элемент&amp;raquo; позволяет один или два. [и не более &amp;lt;m&amp;gt; вхождений element. Значения по умолчанию - 0 и бесконечность, поэтому &quot;* (element)&quot; допускает любое число, включая ноль; &amp;laquo;1 * элемент&amp;raquo; требует хотя бы одного; а &amp;laquo;1 * 2элемент&amp;raquo; позволяет один или два. [&lt;a id=&quot;ref-rule&quot; name=&quot;ref-rule&quot;&gt;правило&lt;/a&gt;] В квадратные скобки заключены необязательные элементы; &amp;laquo;[foo bar]&amp;raquo; эквивалентно &amp;laquo;* 1 (foo bar)&amp;raquo;. N правило Конкретное повторение: &amp;laquo;&amp;lt;n&amp;gt; (элемент)&amp;raquo; эквивалентно &amp;laquo;&amp;lt;n&amp;gt; * &amp;lt;n&amp;gt; (элемент)&amp;raquo;; то есть ровно &amp;lt;n&amp;gt; вхождений (element). Таким образом, 2DIGIT - это двухзначное число, а 3ALPHA - это строка из трех буквенных символов. #rule Конструкция &amp;laquo;#&amp;raquo; определена аналогично &amp;laquo;*&amp;raquo; для определения списков элементов. Полная форма - &amp;laquo;&amp;lt;n&amp;gt; # &amp;lt;m&amp;gt; element&amp;raquo;, обозначающая как минимум &amp;lt;n&amp;gt; и максимум &amp;lt;m&amp;gt; элементов, каждый из которых разделен одной или несколькими запятыми (&amp;laquo;,&amp;raquo;) и НЕОБЯЗАТЕЛЬНЫМ линейным пробелом (LWS). Это упрощает обычную форму списков; такое правило, как (* элемент LWS * (* LWS &quot;,&quot;* Элемент LWS)) может отображаться как элемент 1 # Где бы ни использовалась эта конструкция, пустые элементы разрешены, но не участвуют в подсчете присутствующих элементов. То есть,&quot; (элемент),, (элемент) &quot;разрешено , но считается только за два элемента. Поэтому, если требуется хотя бы один элемент, ДОЛЖЕН присутствовать хотя бы один ненулевой элемент. Значения по умолчанию - 0 и бесконечность, так что &quot;#element&quot; допускает любое число, включая ноль; &quot;1 #element &quot;требует как минимум один; а&quot; 1 # 2element &quot;допускает один или два.; comment Точка с запятой, установленная на некотором расстоянии справа от текста правила, начинает комментарий, который продолжается до конца строки. Это простой способ включения полезных примечаний параллельно со спецификациями.подразумеваемый * LWS Грамматика, описанная в этой спецификации, основана на словах. Если не указано иное, линейные пробелы (LWS) могут быть включены между любыми двумя соседними словами (токеном или строкой в ​​кавычках), а также между соседними словами и разделителями без изменения интерпретации поля. По крайней мере, один разделитель (LWS и / или разделители) ДОЛЖЕН существовать между любыми двумя токенами (для определения &amp;laquo;токена&amp;raquo; ниже), поскольку в противном случае они были бы интерпретированы как один токен.По крайней мере, один разделитель (LWS и / или разделители) ДОЛЖЕН существовать между любыми двумя токенами (для определения &amp;laquo;токена&amp;raquo; ниже), поскольку в противном случае они были бы интерпретированы как один токен.По крайней мере, один разделитель (LWS и / или разделители) ДОЛЖЕН существовать между любыми двумя токенами (для определения &amp;laquo;токена&amp;raquo; ниже), поскольку в противном случае они были бы интерпретированы как один токен.</target>
        </trans-unit>
        <trans-unit id="d9826d3b0aadb4c0d991f77ab80bce5d93271a5e" translate="yes" xml:space="preserve">
          <source>All present and future subdomains will be HTTPS for a max-age of 1 year. This blocks access to pages or sub domains that can only be served over HTTP.</source>
          <target state="translated">Все существующие и будущие поддомены будут иметь HTTPS в течение максимум 1 года.Это блокирует доступ к страницам или субдоменам,которые могут обслуживаться только по HTTP.</target>
        </trans-unit>
        <trans-unit id="efb3018ed7ba81bc986a32dff4c272b1fc5af94f" translate="yes" xml:space="preserve">
          <source>All responses with one of these status codes send a &lt;code&gt;Location&lt;/code&gt; header.</source>
          <target state="translated">Все ответы с одним из этих кодов состояния отправляют заголовок &lt;code&gt;Location&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f69c00231b6bb7e2418bf271e61ffc7333b84fb8" translate="yes" xml:space="preserve">
          <source>All streams are initially assigned a non-exclusive dependency on
   stream 0x0.  Pushed streams (&lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt;) initially depend on their
   associated stream.  In both cases, streams are assigned a default
   weight of 16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31998230cdc3b967cea6c7d6edfed8e8ab8ab57f" translate="yes" xml:space="preserve">
          <source>All you need to do is combine multiple &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; headers into a single one, with commas separating the origins gathered from each copy of the header.</source>
          <target state="translated">Все, что вам нужно сделать, это объединить несколько заголовков &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; в один с запятыми, разделяющими источники, собранные из каждой копии заголовка.</target>
        </trans-unit>
        <trans-unit id="3ad0e3698278f45b2af94445396e9865f213f617" translate="yes" xml:space="preserve">
          <source>Allow</source>
          <target state="translated">Allow</target>
        </trans-unit>
        <trans-unit id="fd3431f3358696a8f688eedd078d377a2bef938b" translate="yes" xml:space="preserve">
          <source>Allow (RFC 2616)</source>
          <target state="translated">Разрешение (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="2a254a8dafebfc7a8b81cab0f55d1468af9cf5e7" translate="yes" xml:space="preserve">
          <source>Allow (RFC 7231)</source>
          <target state="translated">Разрешение (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="78637188ae6e129684b8ed4d25b294e489fcaddf" translate="yes" xml:space="preserve">
          <source>Allow commas in Accept, Accept-Language, and Content-Language request headers for simple CORS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7700064d34b89eae4fcb61ae4f9c3f1965adc23" translate="yes" xml:space="preserve">
          <source>Allow credentials:</source>
          <target state="translated">Разрешить полномочия:</target>
        </trans-unit>
        <trans-unit id="85317a1ad2b956cae1168d9078911413cee98254" translate="yes" xml:space="preserve">
          <source>Allow iframes to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API&quot;&gt;fullscreen API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="464b3413d2c92ce5d1cdddc36fca2e60307a278a" translate="yes" xml:space="preserve">
          <source>Allow iframes to use the fullscreen API.</source>
          <target state="translated">Разрешите iframes использовать полноэкранный API.</target>
        </trans-unit>
        <trans-unit id="de76bcbe1f2fb18c478a0f6fa30885454a59cea6" translate="yes" xml:space="preserve">
          <source>Allowed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML forms&lt;/a&gt;</source>
          <target state="translated">Разрешено в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML-формах&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0fda3a8172ffd809fcbe4f6321f7fa38cb061525" translate="yes" xml:space="preserve">
          <source>Allowed in HTML forms</source>
          <target state="translated">Разрешено в HTML-формах</target>
        </trans-unit>
        <trans-unit id="81c74e599caf074409d91e89aa90f8b48ef77e84" translate="yes" xml:space="preserve">
          <source>Allowing Flash content</source>
          <target state="translated">Разрешение на использование Flash-контента</target>
        </trans-unit>
        <trans-unit id="e8cb5b34df4d8b6d0f67236dd55dc2d559fc1e85" translate="yes" xml:space="preserve">
          <source>Allowing Java applets</source>
          <target state="translated">Разрешение Java-апплетов</target>
        </trans-unit>
        <trans-unit id="38a5368250d0af35f902c906a91e772c1f7312b2" translate="yes" xml:space="preserve">
          <source>Allowing users to opt out of receiving some or all cookies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5611e2c410b0178775a61e246c3d79485afc2e9" translate="yes" xml:space="preserve">
          <source>Allowing users to use the bulk of your service without receiving cookies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6534d14b65c6f01882f09b9bc7625ec45018e6" translate="yes" xml:space="preserve">
          <source>Allows a sandboxed document to open new windows without forcing the sandboxing flags upon them. This will allow, for example, a third-party advertisement to be safely sandboxed without forcing the same restrictions upon a landing page.</source>
          <target state="translated">Позволяет документу в песочнице открывать новые окна,не нажимая на них флаги песочницы.Это позволит,например,реклама третьей стороны,чтобы быть безопасным песочницы без принуждения же ограничения на целевую страницу.</target>
        </trans-unit>
        <trans-unit id="bd9d1abd82bff4013e4d8b034e274de5b3c1cd64" translate="yes" xml:space="preserve">
          <source>Allows a server to declare an embedder policy for a given document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c9b4234b2a3be8eb41cdf957e42821c7296b4df" translate="yes" xml:space="preserve">
          <source>Allows embedders to have control over whether an iframe can start a presentation session.</source>
          <target state="translated">Позволяет встраивателям контролировать,может ли iframe начать сеанс презентации.</target>
        </trans-unit>
        <trans-unit id="cc5d5f3bfec8b9763df60e08f7fe09fc818a1534" translate="yes" xml:space="preserve">
          <source>Allows enabling specific inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Event_handlers&quot;&gt;event handlers&lt;/a&gt;. If you only need to allow inline event handlers and not inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements or &lt;code&gt;javascript:&lt;/code&gt; URLs, this is a safer method than using the &lt;code&gt;unsafe-inline&lt;/code&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2dccfc3d16fbd6966ea66bf8065e453d70002c8" translate="yes" xml:space="preserve">
          <source>Allows for creating policies with a name that was already used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a6156330c202b6a59a4dd9cbf9d1fc74688899" translate="yes" xml:space="preserve">
          <source>Allows for downloads to occur without a gesture from the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a9b362468a49f0fc591066164c814185eb3f1f" translate="yes" xml:space="preserve">
          <source>Allows popups (like from &lt;code&gt;window.open&lt;/code&gt;, &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt;, &lt;code&gt;showModalDialog&lt;/code&gt;). If this keyword is not used, that functionality will silently fail.</source>
          <target state="translated">Разрешает всплывающие окна (например, из &lt;code&gt;window.open&lt;/code&gt; , &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; , &lt;code&gt;showModalDialog&lt;/code&gt; ). Если это ключевое слово не используется, эта функция автоматически выйдет из строя.</target>
        </trans-unit>
        <trans-unit id="772ca43b3ac605b73ba1b10b87801c9eb255da4d" translate="yes" xml:space="preserve">
          <source>Allows servers to assert that a cookie ought not to be sent along with cross-site requests, which provides some protection against cross-site request forgery attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRF&lt;/a&gt;).</source>
          <target state="translated">Позволяет серверам утверждать, что cookie не следует отправлять вместе с межсайтовыми запросами, что обеспечивает некоторую защиту от атак с подделкой межсайтовых запросов ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRF&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8884a66b5c1071e7a925fac5c26c615146d4a1b8" translate="yes" xml:space="preserve">
          <source>Allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed. When a site enables the Expect-CT header, they are requesting that Chrome check that any certificate for that site appears in public CT logs.</source>
          <target state="translated">Позволяет сайтам выбирать отчетность и/или соблюдение требований прозрачности сертификатов,что предотвращает незамеченным использование сертификатов,поданных в суд на этот сайт.Когда сайт включает заголовок Expect-CT,они просят Chrome проверить,что любой сертификат для этого сайта появляется в публичных журналах КТ.</target>
        </trans-unit>
        <trans-unit id="0410e69274a5c7230756b0a2cd3597d21bf3033b" translate="yes" xml:space="preserve">
          <source>Allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements.</source>
          <target state="translated">Позволяет сайтам выбирать отчетность и/или соблюдение требований прозрачности сертификатов.</target>
        </trans-unit>
        <trans-unit id="4d5d66c72c2c3237333bd488a07baf5da98b6794" translate="yes" xml:space="preserve">
          <source>Allows the content to be treated as being from its normal origin. If this keyword is not used, the embedded content is treated as being from a unique origin.</source>
          <target state="translated">Позволяет рассматривать содержимое как имеющее обычное происхождение.Если это ключевое слово не используется,то встроенный контент рассматривается как имеющий уникальное происхождение.</target>
        </trans-unit>
        <trans-unit id="741605ef4e45ee0618904121cc3fd5f417c8880d" translate="yes" xml:space="preserve">
          <source>Allows the embedded browsing context to disable the ability to lock the screen orientation.</source>
          <target state="translated">Позволяет отключить встроенный контекст просмотра для блокировки ориентации экрана.</target>
        </trans-unit>
        <trans-unit id="a01ecc6028bdc4a32cc774eaf65dc48562b4acc1" translate="yes" xml:space="preserve">
          <source>Allows the embedded browsing context to navigate (load) content to the top-level browsing context. If this keyword is not used, this operation is not allowed.</source>
          <target state="translated">Позволяет встроенному контексту просмотра перемещаться (загружать)контент в контекст просмотра верхнего уровня.Если это ключевое слово не используется,данная операция не разрешена.</target>
        </trans-unit>
        <trans-unit id="bf9916914f8c66adba9d7f2f9c9a589c27a1dda4" translate="yes" xml:space="preserve">
          <source>Allows the embedded browsing context to open modal windows.</source>
          <target state="translated">Позволяет встроенному контексту просмотра открывать модальные окна.</target>
        </trans-unit>
        <trans-unit id="d0f95216587dc88511ecf6c58e7bdf8112265979" translate="yes" xml:space="preserve">
          <source>Allows the embedded browsing context to run scripts (but not create pop-up windows). If this keyword is not used, this operation is not allowed.</source>
          <target state="translated">Позволяет встроенному контексту просмотра запускать скрипты (но не создавать всплывающие окна).Если это ключевое слово не используется,данная операция не разрешена.</target>
        </trans-unit>
        <trans-unit id="0419c62683b1201e44580c6c185018bb2fc4aa4a" translate="yes" xml:space="preserve">
          <source>Allows the embedded browsing context to submit forms. If this keyword is not used, this operation is not allowed.</source>
          <target state="translated">Позволяет встроенный контекст просмотра для отправки форм.Если это ключевое слово не используется,данная операция не разрешена.</target>
        </trans-unit>
        <trans-unit id="f2c89b61af6c6f17a8c09714a97165e2cf23d19e" translate="yes" xml:space="preserve">
          <source>Allows the embedded browsing context to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/WebAPI/Pointer_Lock&quot;&gt;Pointer Lock API&lt;/a&gt;.</source>
          <target state="translated">Позволяет встроенному контексту просмотра использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/WebAPI/Pointer_Lock&quot;&gt;API блокировки указателя&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d47be6416ef63d9adb3f32563ed73e211a7ca688" translate="yes" xml:space="preserve">
          <source>Allows the page to disable the ability to lock the screen orientation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33838b0859b41b03a423bfc2b34752d52297549b" translate="yes" xml:space="preserve">
          <source>Allows the page to navigate (load) content to the top-level browsing context. If this keyword is not used, this operation is not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efefb75a2a3ce03432240765afc717dab3a1111d" translate="yes" xml:space="preserve">
          <source>Allows the page to open modal windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d2730a7964a8927d460300290addb305c20e3b" translate="yes" xml:space="preserve">
          <source>Allows the page to run scripts (but not create pop-up windows). If this keyword is not used, this operation is not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a9a180c669b480f86657cd6f967b3c5b030d21" translate="yes" xml:space="preserve">
          <source>Allows the page to submit forms. If this keyword is not used, this operation is not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f5ac4d66b40e0417e5931f2cd52e670042101b" translate="yes" xml:space="preserve">
          <source>Allows the page to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/WebAPI/Pointer_Lock&quot;&gt;Pointer Lock API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa9af97868bcd3e0e5abf7dded6f81f5e4562003" translate="yes" xml:space="preserve">
          <source>Allows the sender to include additional fields at the end of chunked message.</source>
          <target state="translated">Позволяет отправителю включать дополнительные поля в конце блочного сообщения.</target>
        </trans-unit>
        <trans-unit id="08a8ebd4fc62c0a4cb8521f9866243f0e1c6ea8b" translate="yes" xml:space="preserve">
          <source>Allows the use of &lt;code&gt;eval()&lt;/code&gt; and similar methods for creating code from strings. You must include the single quotes.</source>
          <target state="translated">Позволяет использовать &lt;code&gt;eval()&lt;/code&gt; и аналогичные методы для создания кода из строк. Вы должны использовать одинарные кавычки.</target>
        </trans-unit>
        <trans-unit id="01d7fdad360cfdc2e901b1df4a68463e1a02b8e8" translate="yes" xml:space="preserve">
          <source>Allows the use of inline resources, such as inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, &lt;code&gt;javascript:&lt;/code&gt; URLs, inline event handlers, and inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements. The single quotes are required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd1bd87864a04cf3add283dce271e5f814f1e28" translate="yes" xml:space="preserve">
          <source>Allows the use of inline resources, such as inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, &lt;code&gt;javascript:&lt;/code&gt; URLs, inline event handlers, and inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements. You must include the single quotes.</source>
          <target state="translated">Позволяет использовать встроенные ресурсы, такие как встроенные элементы &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;javascript:&lt;/code&gt; URL-адреса, встроенные обработчики событий и встроенные элементы &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; . Вы должны использовать одинарные кавычки.</target>
        </trans-unit>
        <trans-unit id="51e3ac5152db55dda9ebbbe8483aa28291ace912" translate="yes" xml:space="preserve">
          <source>Allows web developers to experiment with policies by monitoring (but not enforcing) their effects. These violation reports consist of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; documents sent via an HTTP &lt;code&gt;POST&lt;/code&gt; request to the specified URI.</source>
          <target state="translated">Позволяет веб-разработчикам экспериментировать с политиками, отслеживая (но не применяя) их эффекты. Эти отчеты о нарушениях состоят из документов &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON,&lt;/a&gt; отправленных через HTTP- запрос &lt;code&gt;POST&lt;/code&gt; на указанный URI.</target>
        </trans-unit>
        <trans-unit id="84ad2a25c230050cfbdb31526527d5fcf1288905" translate="yes" xml:space="preserve">
          <source>Allows web developers to experiment with policies by monitoring, but not enforcing, their effects. These violation reports consist of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; documents sent via an HTTP &lt;code&gt;POST&lt;/code&gt; request to the specified URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c57719b8c00db1084bb9759e63a3f932a7629f6" translate="yes" xml:space="preserve">
          <source>Also try to move less relevant/important information down to the bottom and group the page's content together meaningfully. Although it is off-topic, perhaps the following detailed example might give you insights and ideas that persuade you to forgo user agent sniffing. Let us imagine a page composed of boxes of information; each box is about a different feline breed or canine breed. Each box has an image, an overview, and a historical funfact. The pictures are kept to a maximum reasonable size even on large screens. For the purposes of grouping the content meaningfully, all the cat boxes are separated from all the dog boxes such that the cat and dog boxes are not intermixed together. On a large screen, it saves space to have multiple columns to reduce the space wasted to the left and to the right of the pictures. The boxes can be separated into multiple columns via two equally fair method. From this point on, we shall assume that all the dog boxes are at the top of the source code, that all the cat boxes are at the bottom of the source code, and that all these boxes have the same parent element. There a single instance of a dog box immediately above a cat box, of course. The first method uses horizontal &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox&quot;&gt;Flexboxes&lt;/a&gt; to group the content such that when the page is displayed to the end user, all the dogs boxes are at the top of the page and all the cat boxes are lower on the page. The second method uses a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Layout_cookbook/Column_layouts&quot;&gt;Column&lt;/a&gt; layout and resents all the dogs to the left and all the cats to the right. Only in this particular scenario, it is appropriate to provide no fallback for the flexboxes/multicolumns, resulting in a single column of very wide boxes on old browsers. Also consider the following. If more people visit the webpage to see the cats, then it might be a good idea to put all the cats higher in the source code than the dogs so that more people can find what they are looking for faster on smaller screens where the content collapses down to one column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="197ef715f3c646e6b397719edb24cab181a5e5e8" translate="yes" xml:space="preserve">
          <source>Also, by default, prefetching of embedded link hostnames is not performed on documents loaded over &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;. On Firefox, this can be changed by setting the &lt;code&gt;network.dns.disablePrefetchFromHTTPS&lt;/code&gt; preference to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Кроме того, по умолчанию предварительная выборка имен хостов встроенных ссылок не выполняется для документов, загружаемых через &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; . В Firefox это можно изменить, установив для параметра &lt;code&gt;network.dns.disablePrefetchFromHTTPS&lt;/code&gt; значение &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2786b01f7fddba1a4761b75f4be96f18c612dfea" translate="yes" xml:space="preserve">
          <source>Also, pay attention not to use a simple regular expression on the BrowserName, user agents also contain strings outside the Keyword/Value syntax. Safari &amp;amp; Chrome contain the string 'like Gecko', for instance.</source>
          <target state="translated">Также обратите внимание, чтобы не использовать простое регулярное выражение для BrowserName, пользовательские агенты также содержат строки вне синтаксиса Keyword / Value. Например, Safari и Chrome содержат строку &amp;laquo;like Gecko&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a39f383ce421cfb82712ee700637b63b224f71b2" translate="yes" xml:space="preserve">
          <source>Alt-Svc</source>
          <target state="translated">Alt-Svc</target>
        </trans-unit>
        <trans-unit id="969f9938b9e9ad46cc407e83f40599f28ad451b1" translate="yes" xml:space="preserve">
          <source>Alternative way of specifying redirections</source>
          <target state="translated">Альтернативный способ указания перенаправлений</target>
        </trans-unit>
        <trans-unit id="aafaa60231bd948348513cfbf048fba3ee9420b0" translate="yes" xml:space="preserve">
          <source>Alternatively, a &lt;code&gt;noreferrer&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types&quot;&gt;link relation&lt;/a&gt; on an &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;area&lt;/code&gt;, or &lt;code&gt;link&lt;/code&gt; element can be set:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28d99eac48e2150a7854ebf5ed41a547fcb7ff26" translate="yes" xml:space="preserve">
          <source>Alternatively, a &lt;code&gt;noreferrer&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types&quot;&gt;link relation&lt;/a&gt; on an a, area, or link element can be set:</source>
          <target state="translated">В качестве альтернативы можно &lt;code&gt;noreferrer&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types&quot;&gt;отношение ссылки &lt;/a&gt;noreferrer для элемента a, area или link:</target>
        </trans-unit>
        <trans-unit id="0a8e3d200820a58b6e0b8358c248b25476e1c5f5" translate="yes" xml:space="preserve">
          <source>Alternatively, in newer versions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9bb9cbc60c02f0889f6ac3194244c3ea1b935e7" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element can be used to configure a policy, for example: &lt;code&gt;&amp;lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src 'self'; img-src https://*; child-src 'none';&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Как вариант, элемент &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; можно использовать для настройки политики, например: &lt;code&gt;&amp;lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src 'self'; img-src https://*; child-src 'none';&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb21b29ffd21c7c82658bce444d0d375ea5eb7ac" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create hashes from your inline scripts. CSP supports sha256, sha384 and sha512.</source>
          <target state="translated">Кроме того,вы можете создавать хэши из встроенных скриптов.CSP поддерживает sha256,sha384 и sha512.</target>
        </trans-unit>
        <trans-unit id="c96489cbf1e84a29d50323c0d62b764cf352a52a" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create hashes from your inline styles. CSP supports sha256, sha384 and sha512.</source>
          <target state="translated">Кроме того,вы можете создавать хэши из встроенных стилей.CSP поддерживает sha256,sha384 и sha512.</target>
        </trans-unit>
        <trans-unit id="52a25e02a82ef60d93cd242f5fb2c709e891fe3d" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create hashes from your inline styles. CSP supports sha256, sha384 and sha512. The &lt;strong&gt;binary&lt;/strong&gt; form of the hash has to be encoded with base64. You can obtain the hash of a string on the command line via the &lt;code&gt;openssl&lt;/code&gt; program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45516a24ea8f0e4a83ad34f9d135e93d5d83f7b" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use frameguard directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7028d055906f785a2824cddbc861da7d354ff8c" translate="yes" xml:space="preserve">
          <source>Although &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header&quot;&gt;CORS-safelisted request headers&lt;/a&gt; are always allowed and don't usually need to be listed in &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;, listing them anyway will circumvent the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header#Additional_restrictions&quot;&gt;additional restrictions&lt;/a&gt; that apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1557091a03ff09f7dee02267939f1e7e6affdd2" translate="yes" xml:space="preserve">
          <source>Although Firefox supports &lt;code&gt;data&lt;/code&gt; URLs of essentially unlimited length, browsers are not required to support any particular maximum length of data. For example, the Opera 11 browser limited URLs to 65535 characters long which limits &lt;code&gt;data&lt;/code&gt; URLs to 65529 characters (65529 characters being the length of the encoded data, not the source, if you use the plain &lt;code&gt;data:&lt;/code&gt;, without specifying a MIME type).</source>
          <target state="translated">Хотя Firefox поддерживает &lt;code&gt;data&lt;/code&gt; адреса практически неограниченную длину, браузеры не обязаны поддерживать какую - либо конкретную максимальную длину данных. Например, браузер Opera 11 ограничил длину URL-адресов 65535 символами, что ограничивает URL-адреса &lt;code&gt;data&lt;/code&gt; 65529 символами (65529 символов - это длина закодированных данных, а не источник, если вы используете простые &lt;code&gt;data:&lt;/code&gt; без указания типа MIME).</target>
        </trans-unit>
        <trans-unit id="95896d4301d000a02f900c6b86de14488ddbcde0" translate="yes" xml:space="preserve">
          <source>Although fragment identifiers used within URI references are not sent
   in requests, implementers ought to be aware that they will be visible
   to the user agent and any extensions or scripts running as a result
   of the response.  In particular, when a redirect occurs and the
   original request's fragment identifier is inherited by the new
   reference in Location (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;), this might have the effect of
   disclosing one site's fragment to another site.  If the first site
   uses personal information in fragments, it ought to ensure that
   redirects to other sites include a (possibly empty) fragment
   component in order to block that inheritance.</source>
          <target state="translated">Хотя идентификаторы фрагментов, используемые в ссылках URI, не отправляются в запросах, разработчики должны знать, что они будут видимы для пользовательского агента и любых расширений или сценариев, запущенных в результате ответа. В частности, когда происходит перенаправление и идентификатор фрагмента исходного запроса наследуется новой ссылкой в ​​Location ( &lt;a href=&quot;#section-7.1.2&quot;&gt;раздел 7.1.2&lt;/a&gt; ), это может привести к раскрытию фрагмента одного сайта другому сайту. Если первый сайт использует личную информацию в виде фрагментов, он должен гарантировать, что перенаправления на другие сайты включают (возможно, пустой) компонент фрагмента, чтобы заблокировать это наследование.</target>
        </trans-unit>
        <trans-unit id="31287a55ab92ee46df59edd609b16221b3daba2a" translate="yes" xml:space="preserve">
          <source>Although it is &lt;strong&gt;strongly discouraged&lt;/strong&gt; by Mozilla, some handset manufacturers unfortunately include a token in their device's UA string that represents their device id. If this is the case, the Firefox OS UA string will look like the device-specific string in the table above, where &lt;em&gt;&lt;strong&gt;nnnn;&lt;/strong&gt;&lt;/em&gt; is the manufacturer's code for the device (see &lt;a href=&quot;https://wiki.mozilla.org/B2G/User_Agent/Device_Model_Inclusion_Requirements&quot;&gt;Guidelines&lt;/a&gt;). Some of them we have noticed are of the form &quot;&lt;strong&gt;NexusOne;&lt;/strong&gt;&quot;, &quot;&lt;strong&gt;ZTEOpen;&lt;/strong&gt;&quot;, or &quot;&lt;strong&gt;Open C;&lt;/strong&gt;&quot; (note that putting space is also discouraged). We provide this information to assist with your UA detection logic, but Mozilla discourages the detection of a device id in UA strings.</source>
          <target state="translated">Хотя Mozilla &lt;strong&gt;настоятельно не рекомендует&lt;/strong&gt; это делать, некоторые производители мобильных телефонов, к сожалению, включают токен в строку UA своего устройства, которая представляет их идентификатор устройства. В этом случае строка UA Firefox OS будет выглядеть как строка для конкретного устройства в приведенной выше таблице, где &lt;em&gt;&lt;strong&gt;nnnn;&lt;/strong&gt;&lt;/em&gt; - код производителя устройства (см. &lt;a href=&quot;https://wiki.mozilla.org/B2G/User_Agent/Device_Model_Inclusion_Requirements&quot;&gt;Руководство&lt;/a&gt; ). Некоторые из них, которые мы заметили, имеют форму &amp;laquo; &lt;strong&gt;NexusOne;&lt;/strong&gt; &amp;raquo;, &amp;laquo; &lt;strong&gt;ZTEOpen;&lt;/strong&gt; &amp;raquo; или &amp;laquo; &lt;strong&gt;Open C;&lt;/strong&gt; &amp;raquo; (обратите внимание, что размещение пробелов также не рекомендуется). Мы предоставляем эту информацию, чтобы помочь в логике обнаружения UA, но Mozilla не рекомендует обнаруживать идентификатор устройства в строках UA.</target>
        </trans-unit>
        <trans-unit id="1d3b41d03b9a3434a867d7f122dd20caa1d4ef01" translate="yes" xml:space="preserve">
          <source>Although line 10 contains the Cookie destined for the content on &lt;code&gt;http://bar.other&lt;/code&gt;, if bar.other did not respond with an &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; (line 17) the response would be ignored and not made available to web content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e784d0202a94833f035a84e2685a288c242330e" translate="yes" xml:space="preserve">
          <source>Although line 11 contains the Cookie destined for the content on &lt;code&gt;http://bar.other&lt;/code&gt;, if bar.other did not respond with an &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; (line 19) the response would be ignored and not made available to web content.</source>
          <target state="translated">Хотя строка 11 содержит &lt;code&gt;http://bar.other&lt;/code&gt; , предназначенный для содержимого на http: //bar.other , если bar.other не ответил с помощью &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: true&lt;/code&gt; (строка 19), ответ будет проигнорирован и не станет доступным. к веб-контенту.</target>
        </trans-unit>
        <trans-unit id="46a72e7d1df557890c548f429dfcfe446b549d89" translate="yes" xml:space="preserve">
          <source>Although the HTTP standard specifies &quot;unauthorized&quot;, semantically this response means &quot;unauthenticated&quot;. That is, the client must authenticate itself to get the requested response.</source>
          <target state="translated">Хотя стандарт HTTP указывает &quot;неавторизованный&quot;,семантически этот ответ означает &quot;неаутентифицированный&quot;.То есть,клиент должен аутентифицироваться,чтобы получить запрошенный ответ.</target>
        </trans-unit>
        <trans-unit id="772d6209abf255884251d1e63fc5494b4017ee80" translate="yes" xml:space="preserve">
          <source>Although the write locks provide some help in preventing lost
   updates, they cannot guarantee that updates will never be lost.
   Consider the following scenario:

   Two clients A and B are interested in editing the resource
   'index.html'.  Client A is an HTTP client rather than a WebDAV
   client, and so does not know how to perform locking.

   Client A doesn't lock the document, but does a GET, and begins
   editing.

   Client B does LOCK, performs a GET and begins editing.

   Client B finishes editing, performs a PUT, then an UNLOCK.

   Client A performs a PUT, overwriting and losing all of B's changes.

   There are several reasons why the WebDAV protocol itself cannot
   prevent this situation.  First, it cannot force all clients to use
   locking because it must be compatible with HTTP clients that do not
   comprehend locking.  Second, it cannot require servers to support
   locking because of the variety of repository implementations, some of
   which rely on reservations and merging rather than on locking.
   Finally, being stateless, it cannot enforce a sequence of operations
   like LOCK / GET / PUT / UNLOCK.

   WebDAV servers that support locking can reduce the likelihood that
   clients will accidentally overwrite each other's changes by requiring
   clients to lock resources before modifying them.  Such servers would
   effectively prevent HTTP 1.0 and HTTP 1.1 clients from modifying
   resources.

   WebDAV clients can be good citizens by using a lock / retrieve /
   write /unlock sequence of operations (at least by default) whenever
   they interact with a WebDAV server that supports locking. 

   HTTP 1.1 clients can be good citizens, avoiding overwriting other
   clients' changes, by using entity tags in If-Match headers with any
   requests that would modify resources.

   Information managers may attempt to prevent overwrites by
   implementing client-side procedures requiring locking before
   modifying WebDAV resources.</source>
          <target state="translated">Хотя блокировки записи обеспечивают некоторую помощь в предотвращении потери обновлений,они не могут гарантировать,что обновления никогда не будут потеряны.Рассмотрим следующий сценарий:Два клиента A и B заинтересованы в редактировании ресурса 'index.html'.Клиент А-это HTTP-клиент,а не WebDAV-клиент,и поэтому не знает,как выполнить блокировку.Клиент А не блокирует документ,а делает GET,и начинает редактировать.Клиент B делает БЛОКИРОВКУ,выполняет GET и начинает редактирование.Клиент B заканчивает редактирование,выполняет PUT,затем UNLOCK.Клиент А выполняет PUT,перезаписывает и теряет все изменения Б.Есть несколько причин,по которым сам протокол WebDAV не может предотвратить такую ситуацию.Во-первых,он не может заставить всех клиентов использовать блокировку,потому что он должен быть совместим с HTTP клиентами,которые не понимают блокировки.Во-вторых,он не может требовать от серверов поддержки блокировки из-за разнообразия реализаций репозиториев,некоторые из которых полагаются на резервирование и слияние,а не на блокировку.Наконец,будучи апатридом,он не может внедрить последовательность операций,таких как LOCK/GET/PUT/UNLOCK.Серверы WebDAV,поддерживающие блокировку,могут уменьшить вероятность того,что клиенты случайно перезапишут изменения друг друга,требуя от клиентов блокировки ресурсов перед их модификацией.Такие серверы эффективно предотвращают модификацию ресурсов клиентами по протоколам HTTP 1.0 и HTTP 1.1.Клиенты WebDAV могут быть хорошими гражданами,используя последовательность операций блокировки/извлечения/записи/разблокировки (по крайней мере,по умолчанию)всякий раз,когда они взаимодействуют с WebDAV сервером,который поддерживает блокировку.Клиенты HTTP 1.1 могут быть хорошими гражданами,избегая перезаписи изменений других клиентов,используя теги сущностей в заголовках If-Match с любыми запросами,которые могут изменить ресурсы.Информационные менеджеры могут попытаться предотвратить перезапись,применяя клиентские процедуры,требующие блокировки перед модификацией WebDAV ресурсов.</target>
        </trans-unit>
        <trans-unit id="ae6fcea0d3527546dbc2efecb9c0488c56577892" translate="yes" xml:space="preserve">
          <source>Although this document specifies the requirements for the generation
   of HTTP/1.1 messages, not all applications will be correct in their
   implementation. We therefore recommend that operational applications
   be tolerant of deviations whenever those deviations can be
   interpreted unambiguously.

   Clients SHOULD be tolerant in parsing the Status-Line and servers
   tolerant when parsing the Request-Line. In particular, they SHOULD
   accept any amount of SP or HT characters between fields, even though
   only a single SP is required.

   The line terminator for message-header fields is the sequence CRLF.
   However, we recommend that applications, when parsing such headers,
   recognize a single LF as a line terminator and ignore the leading CR.

   The character set of an entity-body SHOULD be labeled as the lowest
   common denominator of the character codes used within that body, with
   the exception that not labeling the entity is preferred over labeling
   the entity with the labels US-ASCII or ISO-8859-1. See &lt;a href=&quot;#section-3.7.1&quot;&gt;section 3.7.1&lt;/a&gt;
   and 3.4.1.

   Additional rules for requirements on parsing and encoding of dates
   and other potential problems with date encodings include:

      - HTTP/1.1 clients and caches SHOULD assume that an &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC-850&lt;/a&gt; date
        which appears to be more than 50 years in the future is in fact
        in the past (this helps solve the &quot;year 2000&quot; problem).

      - An HTTP/1.1 implementation MAY internally represent a parsed
        Expires date as earlier than the proper value, but MUST NOT
        internally represent a parsed Expires date as later than the
        proper value.

      - All expiration-related calculations MUST be done in GMT. The
        local time zone MUST NOT influence the calculation or comparison
        of an age or expiration time. 

      - If an HTTP header incorrectly carries a date value with a time
        zone other than GMT, it MUST be converted into GMT using the
        most conservative possible conversion.</source>
          <target state="translated">Хотя этот документ определяет требования к генерации сообщений HTTP / 1.1, не все приложения будут правильными в их реализации. Поэтому мы рекомендуем, чтобы рабочие приложения были терпимы к отклонениям, если эти отклонения можно интерпретировать однозначно. Клиенты ДОЛЖНЫ быть терпимыми при синтаксическом анализе строки состояния, а серверы - терпимыми при анализе строки запроса. В частности, они ДОЛЖНЫ принимать любое количество символов SP или HT между полями, даже если требуется только один SP. Знак конца строки для полей заголовка сообщения - это последовательность CRLF. Однако мы рекомендуем, чтобы приложения при синтаксическом анализе таких заголовков распознавали одиночный LF как признак конца строки и игнорировали начальный CR.Набор символов тела объекта СЛЕДУЕТ помечать как наименьший общий знаменатель кодов символов, используемых в этом теле, за исключением того, что отказ от маркировки объекта предпочтительнее маркировки объекта с помощью ярлыков US-ASCII или ISO-8859- 1. Видеть&lt;a href=&quot;#section-3.7.1&quot;&gt;раздел 3.7.1&lt;/a&gt; и 3.4.1. Дополнительные правила для требований к синтаксическому анализу и кодированию дат и другим потенциальным проблемам с кодировкой дат включают: - HTTP / 1.1 клиенты и кеши ДОЛЖНЫ предполагать, что &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC-850&lt;/a&gt;дата, которая кажется более чем 50-летней в будущем, на самом деле в прошлом (это помогает решить проблему &amp;laquo;2000 года&amp;raquo;). - Реализация HTTP / 1.1 МОЖЕТ внутренне представлять проанализированную дату Expires как более раннюю, чем правильное значение, но НЕ ДОЛЖНА внутренне представлять проанализированную дату Expires как более позднюю, чем правильное значение. - Все расчеты, связанные с истечением срока, ДОЛЖНЫ выполняться в GMT. Местный часовой пояс НЕ ДОЛЖЕН влиять на расчет или сравнение срока действия или срока действия. - Если HTTP-заголовок неправильно содержит значение даты с часовым поясом, отличным от GMT, он ДОЛЖЕН быть преобразован в GMT с использованием наиболее консервативного преобразования.</target>
        </trans-unit>
        <trans-unit id="d7059fa05c2bada2fecf12f49096ca50d8fbd471" translate="yes" xml:space="preserve">
          <source>Although this status code is intended to describe a response with no body, servers may erroneously include data following the headers. The protocol allows user agents to vary in how they process such responses (&lt;a href=&quot;https://github.com/httpwg/http11bis/issues/26&quot;&gt;discussion regarding this specification text can be found here&lt;/a&gt;). This is observable in persistent connections, where the invalid body may include a distinct response to a subsequent request.</source>
          <target state="translated">Хотя этот код состояния предназначен для описания ответа без тела, серверы могут ошибочно включать данные, следующие за заголовками. Протокол позволяет пользовательским агентам по-разному обрабатывать такие ответы ( &lt;a href=&quot;https://github.com/httpwg/http11bis/issues/26&quot;&gt;обсуждение этого текста спецификации можно найти здесь&lt;/a&gt; ). Это наблюдается в постоянных соединениях, где недопустимое тело может включать отдельный ответ на последующий запрос.</target>
        </trans-unit>
        <trans-unit id="cdf07a548d7dfec43b202a1786fb9188645f2387" translate="yes" xml:space="preserve">
          <source>Amazon Kindle eBook format</source>
          <target state="translated">Формат электронной книги Amazon Kindle</target>
        </trans-unit>
        <trans-unit id="af7c29965f74dbcaf148b9acaea604efc27c6cbf" translate="yes" xml:space="preserve">
          <source>Ambient light sensor</source>
          <target state="translated">Датчик внешнего освещения</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="615b8c7998d5277881578a2abc74d98135448bfa" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;allowlist&lt;/code&gt; is a list of origins that takes one or more of the following values, separated by spaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b4e8bf14b8c6f1d264a99cfc4165e21e00334c4" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;&lt;a href=&quot;methods&quot;&gt;HTTP method&lt;/a&gt;&lt;/em&gt;, a verb (like &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;) or a noun (like &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt;), that describes the action to be performed. For example, &lt;code&gt;GET&lt;/code&gt; indicates that a resource should be fetched or &lt;code&gt;POST&lt;/code&gt; means that data is pushed to the server (creating or modifying a resource, or generating a temporary document to send back).</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;methods&quot;&gt;Метод HTTP&lt;/a&gt;&lt;/em&gt; , глагол (например , &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; ) или существительное (например , &lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; ), который описывает действие , которое должно быть выполнено. Например, &lt;code&gt;GET&lt;/code&gt; указывает, что ресурс должен быть извлечен, или &lt;code&gt;POST&lt;/code&gt; означает, что данные отправляются на сервер (создание или изменение ресурса или создание временного документа для отправки обратно).</target>
        </trans-unit>
        <trans-unit id="86440ab578a3769337d5800e98b7fd98176177d7" translate="yes" xml:space="preserve">
          <source>An Atom Publishing Protocol Category Document, when serialized as XML
   1.0, can be identified with the following media type:

   MIME media type name:  application

   MIME subtype name:  atomcat+xml

   Required parameters:  None.

   Optional parameters:

      &quot;charset&quot;:  This parameter has identical semantics to the charset
         parameter of the &quot;application/xml&quot; media type as specified in
         [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;].

   Encoding considerations:  Identical to those of &quot;application/xml&quot; as
      described in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023], Section&amp;nbsp;3.2&lt;/a&gt;. 

   Security considerations:  As defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;.

      In addition, as this media type uses the &quot;+xml&quot; convention, it
      shares the same security considerations as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-10&quot;&gt;[RFC3023],
      Section&amp;nbsp;10&lt;/a&gt;.

   Interoperability considerations:  There are no known interoperability
      issues.

   Published specification:  &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;.

   Applications that use this media type:  No known applications
      currently use this media type.

   Additional information:

   Magic number(s):  As specified for &quot;application/xml&quot; in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023],
      Section&amp;nbsp;3.2&lt;/a&gt;.

   File extension:  .atomcat

   Fragment identifiers:  As specified for &quot;application/xml&quot; in
      &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-5&quot;&gt;[RFC3023], Section&amp;nbsp;5&lt;/a&gt;.

   Base URI:  As specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-6&quot;&gt;[RFC3023], Section&amp;nbsp;6&lt;/a&gt;.

   Macintosh file type code:  TEXT

   Person &amp;amp; email address to contact for further information:
      Joe Gregorio &amp;lt;joe@bitworking.org&amp;gt;

   Intended usage:  COMMON

   Author/Change controller:  IETF (iesg@ietf.org) Internet Engineering
      Task Force</source>
          <target state="translated">Документ категории протокола публикации Atom, когда он сериализован как XML 1.0, может быть идентифицирован с помощью следующего типа носителя: Имя типа носителя MIME: имя подтипа MIME приложения: atomcat + xml Обязательные параметры: Нет. Необязательные параметры: &amp;laquo;charset&amp;raquo;: этот параметр имеет семантику, идентичную параметру charset для типа носителя &amp;laquo;application / xml&amp;raquo;, как указано в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt; ]. Замечания по кодированию: идентичны таковым для &amp;laquo;application / xml&amp;raquo;, как описано в &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023], раздел 3.2&lt;/a&gt; . Соображения безопасности: как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt; . Кроме того, поскольку этот тип носителя использует соглашение &amp;laquo;+ xml&amp;raquo;, он разделяет те же соображения безопасности, что описаны в &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-10&quot;&gt;[RFC3023],Раздел 10&lt;/a&gt;, Соображения по совместимости: нет известных проблем с совместимостью. Опубликованная спецификация: &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt; . Приложения, использующие этот тип мультимедиа: в настоящее время ни одно из известных приложений не использует этот тип мультимедиа. Дополнительная информация: Магическое число (а): Как указано для &quot;application / xml&quot; в &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023], раздел 3.2&lt;/a&gt; . Расширение файла: .atomcat Идентификаторы фрагментов: Как указано для &quot;application / xml&quot; в &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-5&quot;&gt;[RFC3023], раздел 5&lt;/a&gt; . Базовый URI: как указано в &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-6&quot;&gt;[RFC3023], раздел 6&lt;/a&gt;, Код типа файла Macintosh: ТЕКСТ. Лицо и адрес электронной почты, с которыми можно связаться для получения дополнительной информации: Джо Грегорио &amp;lt;joe@bitworking.org&amp;gt; Предполагаемое использование: ОБЩИЙ Автор / Контроллер изменений: IETF (iesg@ietf.org) Инженерная группа Интернета</target>
        </trans-unit>
        <trans-unit id="cf6c4aedb53226da5214a23ca75c1a0eb3cafdc2" translate="yes" xml:space="preserve">
          <source>An Atom Publishing Protocol Service Document, when serialized as XML
   1.0, can be identified with the following media type:

   MIME media type name:  application

   MIME subtype name:  atomsvc+xml

   Required parameters:  None. 

   Optional parameters:

      &quot;charset&quot;:  This parameter has identical semantics to the charset
         parameter of the &quot;application/xml&quot; media type as specified in
         [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;].

   Encoding considerations:  Identical to those of &quot;application/xml&quot; as
      described in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023], Section&amp;nbsp;3.2&lt;/a&gt;.

   Security considerations:  As defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;.

      In addition, as this media type uses the &quot;+xml&quot; convention, it
      shares the same security considerations as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-10&quot;&gt;[RFC3023],
      Section&amp;nbsp;10&lt;/a&gt;.

   Interoperability considerations:  There are no known interoperability
      issues.

   Published specification:  &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;.

   Applications that use this media type:  No known applications
      currently use this media type.

   Additional information:

   Magic number(s):  As specified for &quot;application/xml&quot; in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023],
      Section&amp;nbsp;3.2&lt;/a&gt;.

   File extension:  .atomsvc

   Fragment identifiers:  As specified for &quot;application/xml&quot; in
      &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-5&quot;&gt;[RFC3023], Section&amp;nbsp;5&lt;/a&gt;.

   Base URI:  As specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-6&quot;&gt;[RFC3023], Section&amp;nbsp;6&lt;/a&gt;.

   Macintosh file type code:  TEXT

   Person and email address to contact for further information:  Joe
      Gregorio &amp;lt;joe@bitworking.org&amp;gt;

   Intended usage:  COMMON

   Author/Change controller:  IETF (iesg@ietf.org) Internet Engineering
      Task Force</source>
          <target state="translated">Документ службы протокола публикации Atom, сериализованный как XML 1.0, может быть идентифицирован по следующему типу носителя: Имя типа носителя MIME: имя подтипа MIME приложения: atomvc + xml Обязательные параметры: Нет. Необязательные параметры: &amp;laquo;charset&amp;raquo;: этот параметр имеет семантику, идентичную параметру charset для типа носителя &amp;laquo;application / xml&amp;raquo;, как указано в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt; ]. Замечания по кодированию: идентичны таковым для &amp;laquo;application / xml&amp;raquo;, как описано в &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023], раздел 3.2&lt;/a&gt; . Соображения безопасности: как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt; . Кроме того, поскольку этот тип носителя использует соглашение &amp;laquo;+ xml&amp;raquo;, он разделяет те же соображения безопасности, что описаны в &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-10&quot;&gt;[RFC3023],Раздел 10&lt;/a&gt;, Соображения по совместимости: нет известных проблем с совместимостью. Опубликованная спецификация: &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt; . Приложения, использующие этот тип мультимедиа: в настоящее время ни одно из известных приложений не использует этот тип мультимедиа. Дополнительная информация: Магическое число (а): Как указано для &quot;application / xml&quot; в &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023], раздел 3.2&lt;/a&gt; . Расширение файла: .atomsvc ​​Идентификаторы фрагментов: Как указано для &quot;application / xml&quot; в &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-5&quot;&gt;[RFC3023], раздел 5&lt;/a&gt; . Базовый URI: как указано в &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-6&quot;&gt;[RFC3023], раздел 6&lt;/a&gt;, Код типа файла Macintosh: ТЕКСТ. Лицо и адрес электронной почты, с которыми можно связаться для получения дополнительной информации: Джо Грегорио &amp;lt;joe@bitworking.org&amp;gt; Предполагаемое использование: ОБЩИЙ Автор / Контроллер изменений: IETF (iesg@ietf.org) Инженерная группа Интернета</target>
        </trans-unit>
        <trans-unit id="7254bd871c63a8e62a9d5239377ac0b3fc259331" translate="yes" xml:space="preserve">
          <source>An HTML document that executes a JavaScript alert. Note that the closing script tag is required.</source>
          <target state="translated">HTML-документ,выполняющий предупреждение JavaScript.Обратите внимание,что требуется закрывающий тег скрипта.</target>
        </trans-unit>
        <trans-unit id="303f58f13dce71a0e7fad3c11eac5eff7ef589df" translate="yes" xml:space="preserve">
          <source>An HTML document with &lt;code&gt;&amp;lt;h1&amp;gt;Hello, World!&amp;lt;/h1&amp;gt;&lt;/code&gt;</source>
          <target state="translated">HTML-документ с &lt;code&gt;&amp;lt;h1&amp;gt;Hello, World!&amp;lt;/h1&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f190ae58e3762585b81fc8fc127a43daf1651695" translate="yes" xml:space="preserve">
          <source>An HTTP &lt;a href=&quot;methods&quot;&gt;method&lt;/a&gt;, usually a verb like &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or a noun like &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; that defines the operation the client wants to perform. Typically, a client wants to fetch a resource (using &lt;code&gt;GET&lt;/code&gt;) or post the value of an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML form&lt;/a&gt; (using &lt;code&gt;POST&lt;/code&gt;), though more operations may be needed in other cases.</source>
          <target state="translated">&lt;a href=&quot;methods&quot;&gt;Метод&lt;/a&gt; HTTP , обычно это глагол типа &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; или существительное, например &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; ,&lt;/a&gt; который определяет операцию, которую хочет выполнить клиент. Обычно клиент хочет получить ресурс (с помощью &lt;code&gt;GET&lt;/code&gt; ) или опубликовать значение &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML-формы&lt;/a&gt; (с помощью &lt;code&gt;POST&lt;/code&gt; ), хотя в других случаях может потребоваться больше операций.</target>
        </trans-unit>
        <trans-unit id="e084db9952eabe09407577846f46c517a44d7f7d" translate="yes" xml:space="preserve">
          <source>An HTTP Extension Framework</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224b4c4e69b1e3dc55d55f1ba353682c6c99e28c" translate="yes" xml:space="preserve">
          <source>An HTTP Status Code to Report Legal Obstacles</source>
          <target state="translated">Статусный код HTTP для сообщения о правовых препятствиях</target>
        </trans-unit>
        <trans-unit id="606a7f78aa2b9bb237bbb97da4be73cfcfdc8923" translate="yes" xml:space="preserve">
          <source>An HTTP message can be either a request from client to server or a
   response from server to client.  Syntactically, the two types of
   message differ only in the start-line, which is either a request-line
   (for requests) or a status-line (for responses), and in the algorithm
   for determining the length of the message body (&lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;). 

   In theory, a client could receive requests and a server could receive
   responses, distinguishing them by their different start-line formats,
   but, in practice, servers are implemented to only expect a request (a
   response is interpreted as an unknown or invalid request method) and
   clients are implemented to only expect a response.

     start-line     = request-line / status-line</source>
          <target state="translated">HTTP-сообщение может быть либо запросом от клиента к серверу, либо ответом от сервера к клиенту. Синтаксически эти два типа сообщений различаются только начальной строкой, которая является либо строкой запроса (для запросов), либо строкой состояния (для ответов), а также алгоритмом определения длины тела сообщения ( &lt;a href=&quot;#section-3.3&quot;&gt;раздел 3.3&lt;/a&gt; ). Теоретически клиент может получать запросы, а сервер может получать ответы, различая их по разным форматам начальной строки, но на практике серверы реализованы так, чтобы только ожидать запроса (ответ интерпретируется как неизвестный или недопустимый метод запроса. ), а клиенты реализованы так, чтобы только ожидать ответа. начальная строка = строка запроса / строка состояния</target>
        </trans-unit>
        <trans-unit id="daaec2180aef0e0c15dca19ff80c20ef6a2edd19" translate="yes" xml:space="preserve">
          <source>An HTTP-date timestamp.</source>
          <target state="translated">Штемпель времени HTTP-даты.</target>
        </trans-unit>
        <trans-unit id="bda182a3078d6fee0f6ff4a7deb6d570e58ba8a3" translate="yes" xml:space="preserve">
          <source>An HTTP/1.1 (or later) client sending a message-body SHOULD monitor
   the network connection for an error status while it is transmitting
   the request. If the client sees an error status, it SHOULD
   immediately cease transmitting the body. If the body is being sent
   using a &quot;chunked&quot; encoding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;), a zero length chunk and
   empty trailer MAY be used to prematurely mark the end of the message.
   If the body was preceded by a Content-Length header, the client MUST
   close the connection.</source>
          <target state="translated">Клиент HTTP / 1.1 (или более поздняя версия), отправляющий тело сообщения, ДОЛЖЕН отслеживать сетевое соединение на предмет наличия ошибки во время передачи запроса. Если клиент видит статус ошибки, он ДОЛЖЕН немедленно прекратить передачу тела. Если тело отправляется с использованием &amp;laquo;фрагментированной&amp;raquo; кодировки ( &lt;a href=&quot;#section-3.6&quot;&gt;раздел 3.6&lt;/a&gt; ), фрагмент нулевой длины и пустой трейлер МОГУТ использоваться для преждевременной отметки конца сообщения. Если телу предшествовал заголовок Content-Length, клиент ДОЛЖЕН закрыть соединение.</target>
        </trans-unit>
        <trans-unit id="287c4eeafec6189b6edc5e8b172c0314056ae7c7" translate="yes" xml:space="preserve">
          <source>An HTTP/1.1 &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is used as request method. In the case of a POST, the &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of the request body is one of &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain.&lt;/code&gt;</source>
          <target state="translated">В качестве метода запроса используется HTTP / 1.1 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; . В случае POST &lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; тела запроса может быть одним из &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; , &lt;code&gt;multipart/form-data&lt;/code&gt; или &lt;code&gt;text/plain.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43150375aa6dfc8cbdc9d2576d9ab158a71ecc43" translate="yes" xml:space="preserve">
          <source>An HTTP/1.1 server MAY assume that a HTTP/1.1 client intends to
   maintain a persistent connection unless a Connection header including
   the connection-token &quot;close&quot; was sent in the request. If the server
   chooses to close the connection immediately after sending the
   response, it SHOULD send a Connection header including the
   connection-token close.

   An HTTP/1.1 client MAY expect a connection to remain open, but would
   decide to keep it open based on whether the response from a server
   contains a Connection header with the connection-token close. In case
   the client does not want to maintain a connection for more than that
   request, it SHOULD send a Connection header including the
   connection-token close.

   If either the client or the server sends the close token in the
   Connection header, that request becomes the last one for the
   connection.

   Clients and servers SHOULD NOT assume that a persistent connection is
   maintained for HTTP versions less than 1.1 unless it is explicitly
   signaled. See &lt;a href=&quot;#section-19.6.2&quot;&gt;section 19.6.2&lt;/a&gt; for more information on backward
   compatibility with HTTP/1.0 clients.

   In order to remain persistent, all messages on the connection MUST
   have a self-defined message length (i.e., one not defined by closure
   of the connection), as described in &lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;.</source>
          <target state="translated">Сервер HTTP / 1.1 МОЖЕТ предполагать, что клиент HTTP / 1.1 намеревается поддерживать постоянное соединение, если в запросе не был отправлен заголовок соединения, включающий маркер соединения &amp;laquo;закрыть&amp;raquo;. Если сервер решает закрыть соединение сразу после отправки ответа, он ДОЛЖЕН отправить заголовок соединения, включая закрытие токена соединения. Клиент HTTP / 1.1 МОЖЕТ ожидать, что соединение останется открытым, но решит оставить его открытым в зависимости от того, содержит ли ответ от сервера заголовок Connection с закрытым токеном соединения. В случае, если клиент не хочет поддерживать соединение для большего количества запросов, он ДОЛЖЕН отправить заголовок соединения, включая закрытие токена соединения. Если клиент или сервер отправляют близкий токен в заголовке соединения,этот запрос становится последним для подключения. Клиентам и серверам НЕ СЛЕДУЕТ предполагать, что постоянное соединение поддерживается для версий HTTP ниже 1.1, если это явно не указано. Видеть&lt;a href=&quot;#section-19.6.2&quot;&gt;раздел 19.6.2&lt;/a&gt; для получения дополнительной информации об обратной совместимости с клиентами HTTP / 1.0. Чтобы оставаться постоянными, все сообщения в соединении ДОЛЖНЫ иметь самоопределяемую длину сообщения (т. Е. Длину, не определяемую закрытием соединения), как описано в &lt;a href=&quot;#section-4.4&quot;&gt;разделе 4.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26a5246f423e33fffe2547c2c151d27d85e6b13f" translate="yes" xml:space="preserve">
          <source>An HTTP/2 connection can demand a greater commitment of resources to
   operate than an HTTP/1.1 connection.  The use of header compression
   and flow control depend on a commitment of resources for storing a
   greater amount of state.  Settings for these features ensure that
   memory commitments for these features are strictly bounded. 

   The number of PUSH_PROMISE frames is not constrained in the same
   fashion.  A client that accepts server push SHOULD limit the number
   of streams it allows to be in the &quot;reserved (remote)&quot; state.  An
   excessive number of server push streams can be treated as a stream
   error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of type ENHANCE_YOUR_CALM.

   Processing capacity cannot be guarded as effectively as state
   capacity.

   The SETTINGS frame can be abused to cause a peer to expend additional
   processing time.  This might be done by pointlessly changing SETTINGS
   parameters, setting multiple undefined parameters, or changing the
   same setting multiple times in the same frame.  WINDOW_UPDATE or
   PRIORITY frames can be abused to cause an unnecessary waste of
   resources.

   Large numbers of small or empty frames can be abused to cause a peer
   to expend time processing frame headers.  Note, however, that some
   uses are entirely legitimate, such as the sending of an empty DATA or
   CONTINUATION frame at the end of a stream.

   Header compression also offers some opportunities to waste processing
   resources; see Section 7 of [&lt;a href=&quot;#ref-COMPRESSION&quot;&gt;COMPRESSION&lt;/a&gt;] for more details on
   potential abuses.

   Limits in SETTINGS parameters cannot be reduced instantaneously,
   which leaves an endpoint exposed to behavior from a peer that could
   exceed the new limits.  In particular, immediately after establishing
   a connection, limits set by a server are not known to clients and
   could be exceeded without being an obvious protocol violation.

   All these features -- i.e., SETTINGS changes, small frames, header
   compression -- have legitimate uses.  These features become a burden
   only when they are used unnecessarily or to excess.

   An endpoint that doesn't monitor this behavior exposes itself to a
   risk of denial-of-service attack.  Implementations SHOULD track the
   use of these features and set limits on their use.  An endpoint MAY
   treat activity that is suspicious as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type ENHANCE_YOUR_CALM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee0ef68ac24c01079c045790e35074016c60661" translate="yes" xml:space="preserve">
          <source>An HTTP/2 connection is an application-layer protocol running on top
   of a TCP connection ([&lt;a href=&quot;#ref-TCP&quot;&gt;TCP&lt;/a&gt;]).  The client is the TCP connection
   initiator.

   HTTP/2 uses the same &quot;http&quot; and &quot;https&quot; URI schemes used by HTTP/1.1.
   HTTP/2 shares the same default port numbers: 80 for &quot;http&quot; URIs and
   443 for &quot;https&quot; URIs.  As a result, implementations processing
   requests for target resource URIs like &quot;http://example.org/foo&quot; or
   &quot;https://example.com/bar&quot; are required to first discover whether the
   upstream server (the immediate peer to which the client wishes to
   establish a connection) supports HTTP/2.

   The means by which support for HTTP/2 is determined is different for
   &quot;http&quot; and &quot;https&quot; URIs.  Discovery for &quot;http&quot; URIs is described in
   &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;.  Discovery for &quot;https&quot; URIs is described in &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6701a3501f8b2c3f6e37a5b1513ec20fdcb01fb9" translate="yes" xml:space="preserve">
          <source>An HTTP/2 implementation MAY treat the negotiation of any of the
   following cipher suites with TLS 1.2 as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type INADEQUATE_SECURITY:

   o  TLS_NULL_WITH_NULL_NULL

   o  TLS_RSA_WITH_NULL_MD5

   o  TLS_RSA_WITH_NULL_SHA

   o  TLS_RSA_EXPORT_WITH_RC4_40_MD5

   o  TLS_RSA_WITH_RC4_128_MD5

   o  TLS_RSA_WITH_RC4_128_SHA

   o  TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5

   o  TLS_RSA_WITH_IDEA_CBC_SHA

   o  TLS_RSA_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_RSA_WITH_DES_CBC_SHA

   o  TLS_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DH_DSS_WITH_DES_CBC_SHA

   o  TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA

   o  TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DH_RSA_WITH_DES_CBC_SHA

   o  TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DHE_DSS_WITH_DES_CBC_SHA

   o  TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA

   o  TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA 

   o  TLS_DHE_RSA_WITH_DES_CBC_SHA

   o  TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_DH_anon_EXPORT_WITH_RC4_40_MD5

   o  TLS_DH_anon_WITH_RC4_128_MD5

   o  TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DH_anon_WITH_DES_CBC_SHA

   o  TLS_DH_anon_WITH_3DES_EDE_CBC_SHA

   o  TLS_KRB5_WITH_DES_CBC_SHA

   o  TLS_KRB5_WITH_3DES_EDE_CBC_SHA

   o  TLS_KRB5_WITH_RC4_128_SHA

   o  TLS_KRB5_WITH_IDEA_CBC_SHA

   o  TLS_KRB5_WITH_DES_CBC_MD5

   o  TLS_KRB5_WITH_3DES_EDE_CBC_MD5

   o  TLS_KRB5_WITH_RC4_128_MD5

   o  TLS_KRB5_WITH_IDEA_CBC_MD5

   o  TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA

   o  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA

   o  TLS_KRB5_EXPORT_WITH_RC4_40_SHA

   o  TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5

   o  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5

   o  TLS_KRB5_EXPORT_WITH_RC4_40_MD5

   o  TLS_PSK_WITH_NULL_SHA

   o  TLS_DHE_PSK_WITH_NULL_SHA

   o  TLS_RSA_PSK_WITH_NULL_SHA 

   o  TLS_RSA_WITH_AES_128_CBC_SHA

   o  TLS_DH_DSS_WITH_AES_128_CBC_SHA

   o  TLS_DH_RSA_WITH_AES_128_CBC_SHA

   o  TLS_DHE_DSS_WITH_AES_128_CBC_SHA

   o  TLS_DHE_RSA_WITH_AES_128_CBC_SHA

   o  TLS_DH_anon_WITH_AES_128_CBC_SHA

   o  TLS_RSA_WITH_AES_256_CBC_SHA

   o  TLS_DH_DSS_WITH_AES_256_CBC_SHA

   o  TLS_DH_RSA_WITH_AES_256_CBC_SHA

   o  TLS_DHE_DSS_WITH_AES_256_CBC_SHA

   o  TLS_DHE_RSA_WITH_AES_256_CBC_SHA

   o  TLS_DH_anon_WITH_AES_256_CBC_SHA

   o  TLS_RSA_WITH_NULL_SHA256

   o  TLS_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_RSA_WITH_AES_256_CBC_SHA256

   o  TLS_DH_DSS_WITH_AES_128_CBC_SHA256

   o  TLS_DH_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_DHE_DSS_WITH_AES_128_CBC_SHA256

   o  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA 

   o  TLS_DHE_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_DH_DSS_WITH_AES_256_CBC_SHA256

   o  TLS_DH_RSA_WITH_AES_256_CBC_SHA256

   o  TLS_DHE_DSS_WITH_AES_256_CBC_SHA256

   o  TLS_DHE_RSA_WITH_AES_256_CBC_SHA256

   o  TLS_DH_anon_WITH_AES_128_CBC_SHA256

   o  TLS_DH_anon_WITH_AES_256_CBC_SHA256

   o  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_PSK_WITH_RC4_128_SHA

   o  TLS_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_PSK_WITH_AES_128_CBC_SHA

   o  TLS_PSK_WITH_AES_256_CBC_SHA

   o  TLS_DHE_PSK_WITH_RC4_128_SHA

   o  TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_DHE_PSK_WITH_AES_128_CBC_SHA

   o  TLS_DHE_PSK_WITH_AES_256_CBC_SHA

   o  TLS_RSA_PSK_WITH_RC4_128_SHA

   o  TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_RSA_PSK_WITH_AES_128_CBC_SHA 

   o  TLS_RSA_PSK_WITH_AES_256_CBC_SHA

   o  TLS_RSA_WITH_SEED_CBC_SHA

   o  TLS_DH_DSS_WITH_SEED_CBC_SHA

   o  TLS_DH_RSA_WITH_SEED_CBC_SHA

   o  TLS_DHE_DSS_WITH_SEED_CBC_SHA

   o  TLS_DHE_RSA_WITH_SEED_CBC_SHA

   o  TLS_DH_anon_WITH_SEED_CBC_SHA

   o  TLS_RSA_WITH_AES_128_GCM_SHA256

   o  TLS_RSA_WITH_AES_256_GCM_SHA384

   o  TLS_DH_RSA_WITH_AES_128_GCM_SHA256

   o  TLS_DH_RSA_WITH_AES_256_GCM_SHA384

   o  TLS_DH_DSS_WITH_AES_128_GCM_SHA256

   o  TLS_DH_DSS_WITH_AES_256_GCM_SHA384

   o  TLS_DH_anon_WITH_AES_128_GCM_SHA256

   o  TLS_DH_anon_WITH_AES_256_GCM_SHA384

   o  TLS_PSK_WITH_AES_128_GCM_SHA256

   o  TLS_PSK_WITH_AES_256_GCM_SHA384

   o  TLS_RSA_PSK_WITH_AES_128_GCM_SHA256

   o  TLS_RSA_PSK_WITH_AES_256_GCM_SHA384

   o  TLS_PSK_WITH_AES_128_CBC_SHA256

   o  TLS_PSK_WITH_AES_256_CBC_SHA384

   o  TLS_PSK_WITH_NULL_SHA256

   o  TLS_PSK_WITH_NULL_SHA384

   o  TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 

   o  TLS_DHE_PSK_WITH_AES_256_CBC_SHA384

   o  TLS_DHE_PSK_WITH_NULL_SHA256

   o  TLS_DHE_PSK_WITH_NULL_SHA384

   o  TLS_RSA_PSK_WITH_AES_128_CBC_SHA256

   o  TLS_RSA_PSK_WITH_AES_256_CBC_SHA384

   o  TLS_RSA_PSK_WITH_NULL_SHA256

   o  TLS_RSA_PSK_WITH_NULL_SHA384

   o  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_EMPTY_RENEGOTIATION_INFO_SCSV

   o  TLS_ECDH_ECDSA_WITH_NULL_SHA

   o  TLS_ECDH_ECDSA_WITH_RC4_128_SHA

   o  TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA 

   o  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_NULL_SHA

   o  TLS_ECDHE_ECDSA_WITH_RC4_128_SHA

   o  TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDH_RSA_WITH_NULL_SHA

   o  TLS_ECDH_RSA_WITH_RC4_128_SHA

   o  TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA

   o  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_RSA_WITH_NULL_SHA

   o  TLS_ECDHE_RSA_WITH_RC4_128_SHA

   o  TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA

   o  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDH_anon_WITH_NULL_SHA

   o  TLS_ECDH_anon_WITH_RC4_128_SHA

   o  TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDH_anon_WITH_AES_128_CBC_SHA

   o  TLS_ECDH_anon_WITH_AES_256_CBC_SHA

   o  TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA

   o  TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA 

   o  TLS_SRP_SHA_WITH_AES_128_CBC_SHA

   o  TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA

   o  TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA

   o  TLS_SRP_SHA_WITH_AES_256_CBC_SHA

   o  TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA

   o  TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256

   o  TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384

   o  TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256

   o  TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384

   o  TLS_ECDHE_PSK_WITH_RC4_128_SHA

   o  TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA

   o  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256

   o  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 

   o  TLS_ECDHE_PSK_WITH_NULL_SHA

   o  TLS_ECDHE_PSK_WITH_NULL_SHA256

   o  TLS_ECDHE_PSK_WITH_NULL_SHA384

   o  TLS_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256

   o  TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384

   o  TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256

   o  TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384

   o  TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_DH_anon_WITH_ARIA_128_CBC_SHA256

   o  TLS_DH_anon_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_RSA_WITH_ARIA_128_GCM_SHA256 

   o  TLS_RSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256

   o  TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256

   o  TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384

   o  TLS_DH_anon_WITH_ARIA_128_GCM_SHA256

   o  TLS_DH_anon_WITH_ARIA_256_GCM_SHA384

   o  TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256

   o  TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256

   o  TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_PSK_WITH_ARIA_128_GCM_SHA256

   o  TLS_PSK_WITH_ARIA_256_GCM_SHA384

   o  TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256

   o  TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384

   o  TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 

   o  TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 

   o  TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_RSA_WITH_AES_128_CCM

   o  TLS_RSA_WITH_AES_256_CCM

   o  TLS_RSA_WITH_AES_128_CCM_8

   o  TLS_RSA_WITH_AES_256_CCM_8

   o  TLS_PSK_WITH_AES_128_CCM

   o  TLS_PSK_WITH_AES_256_CCM

   o  TLS_PSK_WITH_AES_128_CCM_8

   o  TLS_PSK_WITH_AES_256_CCM_8

      Note: This list was assembled from the set of registered TLS
      cipher suites at the time of writing.  This list includes those
      cipher suites that do not offer an ephemeral key exchange and
      those that are based on the TLS null, stream, or block cipher type
      (as defined in Section 6.2.3 of [&lt;a href=&quot;#ref-TLS12&quot;&gt;TLS12&lt;/a&gt;]).  Additional cipher
      suites with these properties could be defined; these would not be
      explicitly prohibited. 

Acknowledgements

   This document includes substantial input from the following
   individuals:

   o  Adam Langley, Wan-Teh Chang, Jim Morrison, Mark Nottingham, Alyssa
      Wilk, Costin Manolache, William Chan, Vitaliy Lvin, Joe Chan, Adam
      Barth, Ryan Hamilton, Gavin Peters, Kent Alstad, Kevin Lindsay,
      Paul Amer, Fan Yang, and Jonathan Leighton (SPDY contributors).

   o  Gabriel Montenegro and Willy Tarreau (Upgrade mechanism).

   o  William Chan, Salvatore Loreto, Osama Mazahir, Gabriel Montenegro,
      Jitu Padhye, Roberto Peon, and Rob Trace (Flow control).

   o  Mike Bishop (Extensibility).

   o  Mark Nottingham, Julian Reschke, James Snell, Jeff Pinner, Mike
      Bishop, and Herve Ruellan (Substantial editorial contributions).

   o  Kari Hurtta, Tatsuhiro Tsujikawa, Greg Wilkins, Poul-Henning Kamp,
      and Jonathan Thackray.

   o  Alexey Melnikov, who was an editor of this document in 2013.

   A substantial proportion of Martin's contribution was supported by
   Microsoft during his employment there.

   The Japanese HTTP/2 community provided invaluable contributions,
   including a number of implementations as well as numerous technical
   and editorial contributions. 

Authors' Addresses

   Mike Belshe
   BitGo

   EMail: mike@belshe.com


   Roberto Peon
   Google, Inc

   EMail: fenix@google.com


   Martin Thomson (editor)
   Mozilla
   331 E Evelyn Street
   Mountain View, CA  94041
   United States

   EMail: martin.thomson@gmail.com


Belshe, et al.               Standards Track                   [Page 96]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e198b1f69badcd0d294bae2afb6df6ba9df42c" translate="yes" xml:space="preserve">
          <source>An IANA registry maintains &lt;a href=&quot;http://www.iana.org/assignments/http-parameters/http-parameters.xml#http-parameters-1&quot;&gt;a complete list of official content encodings&lt;/a&gt;.</source>
          <target state="translated">Реестр IANA поддерживает &lt;a href=&quot;http://www.iana.org/assignments/http-parameters/http-parameters.xml#http-parameters-1&quot;&gt;полный список официальных кодировок контента&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f6bd1f61bcbf82ca97f280b68dcf8ec1c7ecb18" translate="yes" xml:space="preserve">
          <source>An IANA registry maintains &lt;a href=&quot;https://www.iana.org/assignments/http-parameters/http-parameters.xml#http-parameters-1&quot;&gt;a complete list of official content encodings&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc3cd64d927c27e2c875db1e4f0241b2d475f24e" translate="yes" xml:space="preserve">
          <source>An absolute or partial address of the previous web page from which a link to the currently requested page was followed. URL fragments (i.e. &quot;#section&quot;) and userinfo (i.e. &quot;username:password&quot; in &quot;https://username:password@example.com/foo/bar/&quot;) are not included.</source>
          <target state="translated">Абсолютный или частичный адрес предыдущей веб-страницы,с которой была сделана ссылка на запрашиваемую в настоящее время страницу.Фрагменты URL-адреса (т.е.&quot;#секция&quot;)и информация пользователя (т.е.&quot;имя пользователя:пароль&quot; в &quot;_COPY16@example.com/foo/bar/&quot;)не включены.</target>
        </trans-unit>
        <trans-unit id="88d7d1ee9799639ae7a725a7df1453133be8aff7" translate="yes" xml:space="preserve">
          <source>An absolute path, ultimately followed by a &lt;code&gt;'?'&lt;/code&gt; and query string. This is the most common form, known as the &lt;em&gt;origin form&lt;/em&gt;, and is used with &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;, and &lt;code&gt;OPTIONS&lt;/code&gt; methods.</source>
          <target state="translated">Абсолютный путь, за которым следует знак &lt;code&gt;'?'&lt;/code&gt; и строка запроса. Это наиболее распространенная форма, известная как &lt;em&gt;исходная форма&lt;/em&gt; , и используется с методами &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;HEAD&lt;/code&gt; и &lt;code&gt;OPTIONS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5094c29882d093c531b3991dab04140b27dc3c2" translate="yes" xml:space="preserve">
          <source>An allow-list for specific inline scripts using a cryptographic nonce (number used once). The server must generate a unique nonce value each time it transmits a policy. It is critical to provide an unguessable nonce, as bypassing a resource&amp;rsquo;s policy is otherwise trivial. See &lt;a href=&quot;script-src#Unsafe_inline_script&quot;&gt;unsafe inline script&lt;/a&gt; for an example. Specifying nonce makes a modern browser ignore &lt;code&gt;'unsafe-inline'&lt;/code&gt; which could still be set for older browsers without nonce support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7612f8d608c3f6e8f180ad8653c5d57a276d94" translate="yes" xml:space="preserve">
          <source>An allowlist is a list of origins that takes one or more of the following values:</source>
          <target state="translated">Разрешительный список-это список происхождения,который принимает одно или несколько из следующих значений:</target>
        </trans-unit>
        <trans-unit id="4bb11d5976a64d2ae62179eb46982158c56bbed3" translate="yes" xml:space="preserve">
          <source>An attempt to validate the response failed, due to an inability to reach the server.</source>
          <target state="translated">Попытка проверки ответа не удалась из-за невозможности дозвониться до сервера.</target>
        </trans-unit>
        <trans-unit id="5712cd588fbe7cbcb4437f68372abb9b405a060c" translate="yes" xml:space="preserve">
          <source>An audio file in the OGG container format. Vorbis is the most common audio codec used in such a container.</source>
          <target state="translated">Звуковой файл в формате OGG-контейнера.Vorbis-наиболее распространенный аудиокодек,используемый в таком контейнере.</target>
        </trans-unit>
        <trans-unit id="81b348b0f03b452c6893ff611a8d9c735c690bbe" translate="yes" xml:space="preserve">
          <source>An audio file in the Ogg container format. Vorbis is the most common audio codec used in such a container; however, Opus is now supported by Ogg as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275274da827a5e3fea5040e1aba9e600308dbbfb" translate="yes" xml:space="preserve">
          <source>An audio file in the WAVE container format. The PCM audio codec (WAVE codec &quot;1&quot;) is often supported, but other codecs have limited support (if any).</source>
          <target state="translated">Звуковой файл в формате контейнера WAVE.Часто поддерживается PCM аудиокодек (WAVE-кодек &quot;1&quot;),но другие кодеки имеют ограниченную поддержку (если таковая имеется).</target>
        </trans-unit>
        <trans-unit id="0a0a6088f473bc9a3adf41b833d943e48b7fa5e7" translate="yes" xml:space="preserve">
          <source>An audio file in the WebM container format. Vorbis and Opus are the codecs officially supported by the WebM specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f3d314e777f96d5cb8022250e30f26ec18d095" translate="yes" xml:space="preserve">
          <source>An audio file in the WebM container format. Vorbis and Opus are the most common audio codecs.</source>
          <target state="translated">Звуковой файл в формате WebM-контейнера.Наиболее распространенные аудиокодеки-Vorbis и Opus.</target>
        </trans-unit>
        <trans-unit id="6d9bc7bf062074940f71cffe41ac4324eaa5605c" translate="yes" xml:space="preserve">
          <source>An audio or video file using the OGG container format. Theora is the usual video codec used within it; Vorbis is the usual audio codec.</source>
          <target state="translated">Аудио или видео файл,использующий формат OGG-контейнера.Theora-обычный видеокодек,используемый в нем;Vorbis-обычный аудиокодек.</target>
        </trans-unit>
        <trans-unit id="28a4ce6138e5a1b915452926382ff3f84bda1947" translate="yes" xml:space="preserve">
          <source>An audio or video file using the Ogg container format. Theora is the usual video codec used within it; Vorbis is the usual audio codec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bab7fe5b73a7d6c377d59fdf9559bcf2ea5f6e5" translate="yes" xml:space="preserve">
          <source>An entity tag uniquely representing the requested resource. It is a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;) and may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that the weak comparison algorithm should be used.</source>
          <target state="translated">Тег объекта, однозначно представляющий запрошенный ресурс. Это строка символов ASCII, помещенная в двойные кавычки (например, &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; ), и может иметь префикс &lt;code&gt;W/&lt;/code&gt; чтобы указать, что следует использовать алгоритм слабого сравнения.</target>
        </trans-unit>
        <trans-unit id="8351e98570f813491d441d5ddd55a80b35cfdc7d" translate="yes" xml:space="preserve">
          <source>An example HTTP request:</source>
          <target state="translated">Пример HTTP-запроса:</target>
        </trans-unit>
        <trans-unit id="937401682bbf56d33e1065700936f4be12544c64" translate="yes" xml:space="preserve">
          <source>An example of a &lt;a href=&quot;#Preflighted_requests&quot;&gt;preflight request is given above&lt;/a&gt;, including an example which sends this header to the browser.</source>
          <target state="translated">Пример &lt;a href=&quot;#Preflighted_requests&quot;&gt;запроса&lt;/a&gt; предварительной проверки приведен выше , включая пример, который отправляет этот заголовок в браузер.</target>
        </trans-unit>
        <trans-unit id="18c03540d76fb7a3ce87da945d5bbdc9444de704" translate="yes" xml:space="preserve">
          <source>An example of a cross-origin request: The frontend JavaScript code for a web application served from &lt;code&gt;http://domain-a.com&lt;/code&gt; uses &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; to make a request for &lt;code&gt;http://api.domain-b.com/data.json&lt;/code&gt;.</source>
          <target state="translated">Пример запроса из разных источников: код JavaScript внешнего интерфейса для веб-приложения, обслуживаемого с &lt;code&gt;http://domain-a.com&lt;/code&gt; , использует &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; для выполнения запроса для &lt;code&gt;http://api.domain-b.com/data.json&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="3394f284d7025377699f6e1e4fd6fb1b485373b4" translate="yes" xml:space="preserve">
          <source>An example of a cross-origin request: the front-end JavaScript code served from &lt;code&gt;https://domain-a.com&lt;/code&gt; uses &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; to make a request for &lt;code&gt;https://domain-b.com/data.json&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa1717cd1d978e6cae9d3ef7affa2c14bef3a08" translate="yes" xml:space="preserve">
          <source>An example of an HTML form posted using the &lt;code&gt;multipart/form-data&lt;/code&gt; format that makes use of the &lt;code&gt;Content-Disposition&lt;/code&gt; header:</source>
          <target state="translated">Пример HTML-формы, опубликованной с использованием формата &lt;code&gt;multipart/form-data&lt;/code&gt; , который использует заголовок &lt;code&gt;Content-Disposition&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0eb7d8b63d836dc8b48fea64e497eee88c8fc37a" translate="yes" xml:space="preserve">
          <source>An example response:</source>
          <target state="translated">Пример ответа:</target>
        </trans-unit>
        <trans-unit id="d06bdca7c09b88f2f4a910e920b7d53770584980" translate="yes" xml:space="preserve">
          <source>An example scenario</source>
          <target state="translated">Примерный сценарий</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">Пример:</target>
        </trans-unit>
        <trans-unit id="524d76d400d5cb73fc54737fb4d856fc9ec10a9a" translate="yes" xml:space="preserve">
          <source>An identifier disclosing the information that is altered or lost when using a proxy. This can be either:</source>
          <target state="translated">Идентификатор,раскрывающий информацию,которая была изменена или утеряна при использовании прокси-сервера.Это может быть также:</target>
        </trans-unit>
        <trans-unit id="ae6172d2a45cf37f2f2799154f23922f58940acb" translate="yes" xml:space="preserve">
          <source>An integer in the given unit indicating the beginning of the request range.</source>
          <target state="translated">Целое число в данной единице,указывающее на начало диапазона запроса.</target>
        </trans-unit>
        <trans-unit id="5f15168b132abe2a60f0170a67ead71d262beaa6" translate="yes" xml:space="preserve">
          <source>An integer in the given unit indicating the end of the requested range.</source>
          <target state="translated">Целое число в данной единице,указывающее на конец запрашиваемого диапазона.</target>
        </trans-unit>
        <trans-unit id="fb3aa033dddb2a858401595eeaf3ab8db26849c4" translate="yes" xml:space="preserve">
          <source>An integer in the given unit indicating the end of the requested range. This value is optional and, if omitted, the end of the document is taken as the end of the range.</source>
          <target state="translated">Целое число в данной единице,указывающее на конец запрашиваемого диапазона.Это значение является необязательным,и если оно опущено,за конец диапазона принимается конец документа.</target>
        </trans-unit>
        <trans-unit id="a73313ed84e91191f3d2b2b90684cde52ec8f101" translate="yes" xml:space="preserve">
          <source>An integer in the given unit indicating the number of units at the end of the file to return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0e19474dd59d2467fd56601368eedbd6a3f2cd" translate="yes" xml:space="preserve">
          <source>An intermediate cache or proxy cannot edit the response body, &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;. It therefore forbids a proxy or browser feature, such as &lt;a href=&quot;https://support.google.com/webmasters/answer/6211428&quot;&gt;Google&amp;rsquo;s Web Light&lt;/a&gt;, from converting images to minimize data for a cache store or slow connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978df3d581d5f2123e6d6e2fbfff4d060ccce54e" translate="yes" xml:space="preserve">
          <source>An optional &lt;em&gt;body&lt;/em&gt; containing data associated with the request (like content of an HTML form), or the document associated with a response. The presence of the body and its size is specified by the start-line and HTTP headers.</source>
          <target state="translated">Необязательное &lt;em&gt;тело,&lt;/em&gt; содержащее данные, связанные с запросом (например, содержимое HTML-формы), или документ, связанный с ответом. Наличие тела и его размер определяется начальной строкой и заголовками HTTP.</target>
        </trans-unit>
        <trans-unit id="08d7e405f02128c6b7b24a0361c7298994da77d1" translate="yes" xml:space="preserve">
          <source>An optional &lt;strong&gt;parameter&lt;/strong&gt; can be added to provide additional details:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258eb51f5d78b7afb24633c632b091d4e2519fd6" translate="yes" xml:space="preserve">
          <source>An optional set of &lt;em&gt;HTTP headers&lt;/em&gt; specifying the request, or describing the body included in the message.</source>
          <target state="translated">Необязательный набор &lt;em&gt;заголовков HTTP,&lt;/em&gt; определяющих запрос или описывающих тело, включенное в сообщение.</target>
        </trans-unit>
        <trans-unit id="599d0e853eca77f2daf81b1d2e0984db369b73c0" translate="yes" xml:space="preserve">
          <source>An origin considered secure by the browser is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6a0c0ce21b968ca2bae147ce0e590ec11226ee" translate="yes" xml:space="preserve">
          <source>An origin server SHOULD send Last-Modified for any selected
   representation for which a last modification date can be reasonably
   and consistently determined, since its use in conditional requests
   and evaluating cache freshness ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]) results in a substantial
   reduction of HTTP traffic on the Internet and can be a significant
   factor in improving service scalability and reliability.

   A representation is typically the sum of many parts behind the
   resource interface.  The last-modified time would usually be the most
   recent time that any of those parts were changed.  How that value is
   determined for any given resource is an implementation detail beyond
   the scope of this specification.  What matters to HTTP is how
   recipients of the Last-Modified header field can use its value to
   make conditional requests and test the validity of locally cached
   responses.

   An origin server SHOULD obtain the Last-Modified value of the
   representation as close as possible to the time that it generates the
   Date field value for its response.  This allows a recipient to make
   an accurate assessment of the representation's modification time,
   especially if the representation changes near the time that the
   response is generated.

   An origin server with a clock MUST NOT send a Last-Modified date that
   is later than the server's time of message origination (Date).  If
   the last modification time is derived from implementation-specific 

   metadata that evaluates to some time in the future, according to the
   origin server's clock, then the origin server MUST replace that value
   with the message origination date.  This prevents a future
   modification date from having an adverse impact on cache validation.

   An origin server without a clock MUST NOT assign Last-Modified values
   to a response unless these values were associated with the resource
   by some other system or user with a reliable clock.</source>
          <target state="translated">Исходный сервер ДОЛЖЕН отправлять Last-Modified для любого выбранного представления, для которого можно разумно и последовательно определить дату последнего изменения, поскольку его использование в условных запросах и оценке &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;актуальности&lt;/a&gt; кеша ([ RFC7234]) приводит к существенному сокращению HTTP-трафика в Интернете и может стать важным фактором повышения масштабируемости и надежности службы. Представление обычно представляет собой сумму многих частей за интерфейсом ресурса. Время последнего изменения обычно будет самым последним временем изменения любой из этих частей. То, как это значение определяется для любого данного ресурса, является деталью реализации, выходящей за рамки данной спецификации. Для HTTP важно то, как получатели поля заголовка Last-Modified могут использовать его значение для выполнения условных запросов и проверки достоверности локально кэшированных ответов. Исходный сервер ДОЛЖЕН получить значение Last-Modified представления как можно ближе ко времени, когда он генерирует значение поля Date для своего ответа.Это позволяет получателю точно оценить время модификации представления, особенно если представление изменяется примерно в то время, когда создается ответ. Исходный сервер с часами НЕ ДОЛЖЕН отправлять дату последнего изменения, которая позже, чем время отправления сообщения сервером (дата). Если время последней модификации получено из метаданных, зависящих от реализации, которые относятся к некоторому времени в будущем по часам исходного сервера, то исходный сервер ДОЛЖЕН заменить это значение датой создания сообщения. Это предотвращает негативное влияние даты будущей модификации на проверку кэша.Сервер-источник без часов НЕ ДОЛЖЕН присваивать ответу значения Last-Modified, если только эти значения не были связаны с ресурсом какой-либо другой системой или пользователем с надежными часами.</target>
        </trans-unit>
        <trans-unit id="d0c39f83da17a248ad712c0819b8703fb2f5ef34" translate="yes" xml:space="preserve">
          <source>An unsecured HTTP request is used and the referring page was received with a secure protocol (HTTPS).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b6110e3591ac90aa132e8d09ccc7a10f3c9f89c" translate="yes" xml:space="preserve">
          <source>And the MIME type set to:</source>
          <target state="translated">И тип MIME установлен:</target>
        </trans-unit>
        <trans-unit id="6e13d60348da6215250058b98e62629552950b15" translate="yes" xml:space="preserve">
          <source>And the MIME type should be set to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d93a0e0e6b94c85ab246f096bdfe11ac7c7be5" translate="yes" xml:space="preserve">
          <source>Android (version 40 and below)</source>
          <target state="translated">Android (версия 40 и ниже)</target>
        </trans-unit>
        <trans-unit id="9d181bb566f9337c1f23f7fa7129fbabf5cee58d" translate="yes" xml:space="preserve">
          <source>Android (version 41 and above)</source>
          <target state="translated">Android (версия 41 и выше)</target>
        </trans-unit>
        <trans-unit id="a5b93109d2910f83b46a8f8b84565a2b90f04e8f" translate="yes" xml:space="preserve">
          <source>Android webview</source>
          <target state="translated">Android веб-просмотр</target>
        </trans-unit>
        <trans-unit id="8a128a9589c315d21634acc57ea259fa0a700af6" translate="yes" xml:space="preserve">
          <source>Animated Portable Network Graphics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2272152aaed514a90142950fb3ee1816c7074cb" translate="yes" xml:space="preserve">
          <source>Annotation of existing resources</source>
          <target state="translated">Аннотация существующих ресурсов</target>
        </trans-unit>
        <trans-unit id="8642c3a715dbd6efdfc0bb89f8eb0afbc3cede8d" translate="yes" xml:space="preserve">
          <source>Another (implicit) indication that &lt;code&gt;PATCH&lt;/code&gt; is allowed, is the presence of the &lt;a href=&quot;../headers/accept-patch&quot;&gt;&lt;code&gt;Accept-Patch&lt;/code&gt;&lt;/a&gt; header, which specifies the patch document formats accepted by the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a34db762af17ee412c2a1fc9d092bc9dce7999" translate="yes" xml:space="preserve">
          <source>Another (implicit) indication that PATCH is allowed, is the presence of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Patch&quot;&gt;&lt;code&gt;Accept-Patch&lt;/code&gt;&lt;/a&gt; header, which specifies the patch document formats accepted by the server.</source>
          <target state="translated">Другим (неявным) признаком того, что PATCH разрешен, является наличие заголовка &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Patch&quot;&gt; &lt;code&gt;Accept-Patch&lt;/code&gt; &lt;/a&gt; , который указывает форматы документов исправления, принимаемые сервером.</target>
        </trans-unit>
        <trans-unit id="2ea2ea80d736402d761cc48753f37ae87a7086f1" translate="yes" xml:space="preserve">
          <source>Another API, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;server-sent events&lt;/a&gt;, is a one-way service that allows a server to send events to the client, using HTTP as a transport mechanism. Using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource&quot;&gt;&lt;code&gt;EventSource&lt;/code&gt;&lt;/a&gt; interface, the client opens a connection and establishes event handlers. The client browser automatically converts the messages that arrive on the HTTP stream into appropriate &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; objects, delivering them to the event handlers that have been registered for the events' &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event/type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; if known, or to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/onmessage&quot;&gt;&lt;code&gt;onmessage&lt;/code&gt;&lt;/a&gt; event handler if no type-specific event handler was established.</source>
          <target state="translated">Другой API, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;события&lt;/a&gt; , отправленные сервером , представляет собой одностороннюю службу, которая позволяет серверу отправлять события клиенту, используя HTTP в качестве транспортного механизма. Используя интерфейс &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource&quot;&gt; &lt;code&gt;EventSource&lt;/code&gt; &lt;/a&gt; , клиент открывает соединение и устанавливает обработчики событий. Обозреватель клиента автоматически преобразует сообщения, поступающие в поток HTTP, в соответствующие объекты &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; , доставляя их обработчикам событий, которые были зарегистрированы для &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event/type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; событий, если они известны, или обработчику событий &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/onmessage&quot;&gt; &lt;code&gt;onmessage&lt;/code&gt; ,&lt;/a&gt; если обработчик событий определенного типа не был установлено.</target>
        </trans-unit>
        <trans-unit id="9db32006413a6e691ae3fb773aa031a903fdfbff" translate="yes" xml:space="preserve">
          <source>Another approach to storing data in the browser is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API&quot;&gt;Web Storage API&lt;/a&gt;. The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage&quot;&gt;window.sessionStorage&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;window.localStorage&lt;/a&gt; properties correspond to session and permanent cookies in duration, but have larger storage limits than cookies, and are never sent to a server. More structured and larger amounts of data can be stored using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API&quot;&gt;IndexedDB API&lt;/a&gt;, or a library built on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522f7fe585152d75fdebc26d8febeb7c023ce78b" translate="yes" xml:space="preserve">
          <source>Another such case is for fixing bugs in browsers that do not automatically update. Internet Explorer (on Windows) and Webkit (on iOS) are two perfect examples. Prior to version 9, Internet Explorer had unbelievable issues with rendering bugs, CSS bugs, API bugs, and so forth. However, Internet Explorer was such a special little &lt;s&gt;wasp&lt;/s&gt; exception prior to version 9 that it was very easy to detect the browser based upon the browser-specific features available. Webkit is a bit worse because Apple forces all of the browsers on IOS to use Webkit internally, thus the user has no way to get a better more updated browser on older devices. Most bugs can be detected, but some bugs take more effort to detect than others. In such cases, it might be beneficial to use user agent sniffing to save on performance. For example, Webkit 6 has a bug whereby when the device orientation changes, the browser might not fire &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList&quot;&gt;MediaQueryList&lt;/a&gt; listeners when it should. To overcome this bug, observe the code below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82dda038aa2cce2ed80f2fe178807efbf3638a7c" translate="yes" xml:space="preserve">
          <source>Another typical use case of the &lt;code&gt;ETag&lt;/code&gt; header is to cache resources that are unchanged. If a user visits a given URL again (that has an &lt;code&gt;ETag&lt;/code&gt; set), and it is &lt;em&gt;stale&lt;/em&gt;, that is too old to be considered usable, the client will send the value of its &lt;code&gt;ETag&lt;/code&gt; along in an &lt;a href=&quot;if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; header field:</source>
          <target state="translated">Другой типичный вариант использования заголовка &lt;code&gt;ETag&lt;/code&gt; - кэширование неизменных ресурсов. Если пользователь посещает данный URL еще раз (что имеет &lt;code&gt;ETag&lt;/code&gt; множество), и это &lt;em&gt;черствый&lt;/em&gt; , что слишком стар , чтобы считаться полезной, клиент будет отправлять значение его &lt;code&gt;ETag&lt;/code&gt; вместе в &lt;a href=&quot;if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; поле заголовка:</target>
        </trans-unit>
        <trans-unit id="013822625b21f9cdd212bedabde063e3b082d165" translate="yes" xml:space="preserve">
          <source>Another typical use of the &lt;code&gt;ETag&lt;/code&gt; header is to cache resources that are unchanged. If a user visits a given URL again (that has an &lt;code&gt;ETag&lt;/code&gt; set), and it is &lt;em&gt;stale&lt;/em&gt; (too old to be considered usable), the client will send the value of its &lt;code&gt;ETag&lt;/code&gt; along in an &lt;a href=&quot;if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; header field:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e02264f317d706ccbea92e11ccd2f204223b4b4" translate="yes" xml:space="preserve">
          <source>Any MIME type</source>
          <target state="translated">Любой MIME-тип</target>
        </trans-unit>
        <trans-unit id="664cc5e88f68df83f7fdaca487b2f0a350552a8c" translate="yes" xml:space="preserve">
          <source>Any attempt to identify the entity ultimately responsible for the resource being unavailable belongs in the response body, not in the &lt;code&gt;rel=&quot;blocked-by&quot;&lt;/code&gt; link. This includes the name of the person or organization that made a legal demand resulting in the content's removal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d073236284623914133cba02aa3f08d7e4a1a8da" translate="yes" xml:space="preserve">
          <source>Any attempt to identify the entity ultimately responsible for the resource being unavailable, such as the name of the person or organization that made a legal demand resulting in the content's removal belongs in the response body, not in the &lt;code&gt;rel=&quot;blocked-by&quot;&lt;/code&gt; link.</source>
          <target state="translated">Любая попытка определить лицо, в конечном счете ответственное за недоступность ресурса, например имя человека или организации, которые предъявили законное требование, приводящее к удалению контента, относится к тексту ответа, а не &lt;code&gt;rel=&quot;blocked-by&quot;&lt;/code&gt; ссылке rel = &quot;blocked-by&quot;. ,</target>
        </trans-unit>
        <trans-unit id="2f93939c7c6cb77a4b58edcc0e622cd4847d28e7" translate="yes" xml:space="preserve">
          <source>Any charset not mentioned elsewhere in the header; &lt;code&gt;'*'&lt;/code&gt; being used as a wildcard.</source>
          <target state="translated">Любая кодировка, не упомянутая в другом месте в заголовке; &lt;code&gt;'*'&lt;/code&gt; используется как подстановочный знак.</target>
        </trans-unit>
        <trans-unit id="1fc5d287b6ce02126912e6b9a448430e3c10e833" translate="yes" xml:space="preserve">
          <source>Any charset not mentioned elsewhere in the header; &lt;code&gt;*&lt;/code&gt; is used as a wildcard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cffac48fe322697cea7b86272c21674cea37081d" translate="yes" xml:space="preserve">
          <source>Any document that contains text and is theoretically human readable</source>
          <target state="translated">Любой документ,содержащий текст и теоретически доступный для чтения человеком.</target>
        </trans-unit>
        <trans-unit id="2222f9e23d53ca401d68b85209e6a60c148699f8" translate="yes" xml:space="preserve">
          <source>Any dotted address such as an IP address or mask.</source>
          <target state="translated">Любой точечный адрес,например,IP-адрес или маска.</target>
        </trans-unit>
        <trans-unit id="6dd2b19bd700bc5770d5e2ddd162cb6829cc8561" translate="yes" xml:space="preserve">
          <source>Any encoding is placed in an order of preference, expressed using a relative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/quality_values&quot;&gt;quality value&lt;/a&gt; called the &lt;em&gt;weight&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="019e0e72fd8d034b92757591b2abd6fca20d6e93" translate="yes" xml:space="preserve">
          <source>Any kind of audio file</source>
          <target state="translated">Любой тип аудиофайла</target>
        </trans-unit>
        <trans-unit id="dd4445bb33a492123fee27932f107bd3fb3d96ab" translate="yes" xml:space="preserve">
          <source>Any kind of binary data</source>
          <target state="translated">Любой вид двоичных данных</target>
        </trans-unit>
        <trans-unit id="3c78c30698ff4d77228e78708753b01ba8b332fc" translate="yes" xml:space="preserve">
          <source>Any kind of binary data that doesn't fall explicitly into one of the other types; either data that will be executed or interpreted in some way or binary data that requires a specific application or category of application to use. Generic binary data (or binary data whose true type is unknown) is &lt;code&gt;application/octet-stream&lt;/code&gt;. Other common examples include &lt;code&gt;application/pdf&lt;/code&gt;, &lt;code&gt;application/pkcs8&lt;/code&gt;, and &lt;code&gt;application/zip&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6114a2f683fe140d2073d3c42d6efbc65bb0052" translate="yes" xml:space="preserve">
          <source>Any kind of binary data, especially data that will be executed or interpreted somehow.</source>
          <target state="translated">Любые бинарные данные,особенно данные,которые будут каким-то образом выполняться или интерпретироваться.</target>
        </trans-unit>
        <trans-unit id="1efabcb6609afdf043de0f7cdb84bbe7f95e6d79" translate="yes" xml:space="preserve">
          <source>Any kind of image. Videos are not included, though animated images (like animated GIF) are described with an image type.</source>
          <target state="translated">Любое изображение.Видео не включено,хотя анимированные изображения (например,анимированный GIF)описаны с типом изображения.</target>
        </trans-unit>
        <trans-unit id="01b107a882caf2ec54e57571bc8a5b70f3cfd436" translate="yes" xml:space="preserve">
          <source>Any kind of video file</source>
          <target state="translated">Любой вид видеофайла</target>
        </trans-unit>
        <trans-unit id="1bebfb3250f36aea1f47b92ea11652dd128e36ff" translate="yes" xml:space="preserve">
          <source>Any language; &lt;code&gt;'*'&lt;/code&gt; is used as a wildcard.</source>
          <target state="translated">Любой язык; &lt;code&gt;'*'&lt;/code&gt; используется как подстановочный знак.</target>
        </trans-unit>
        <trans-unit id="fa2b54a4202ec978d3ce61340b71c764fd12c522" translate="yes" xml:space="preserve">
          <source>Any of those URLs can be typed into your browser's address bar to tell it to load the associated page (resource).</source>
          <target state="translated">Любой из этих URL может быть введен в адресную строку вашего браузера,чтобы указать ему на загрузку соответствующей страницы (ресурса).</target>
        </trans-unit>
        <trans-unit id="a55969e44ed3bb85f72438df20e0888b1d448e7d" translate="yes" xml:space="preserve">
          <source>Any request can contain a conditional header defined in HTTP (If-
   Match, If-Modified-Since, etc.) or the &quot;If&quot; or &quot;Overwrite&quot;
   conditional headers defined in this specification.  If the server
   evaluates a conditional header, and if that condition fails to hold,
   then this error code MUST be returned.  On the other hand, if the
   client did not include a conditional header in the request, then the
   server MUST NOT use this status code.</source>
          <target state="translated">Любой запрос может содержать условный заголовок,определенный в HTTP (If-Match,If-Modified-Since и т.д.)или условные заголовки &quot;If&quot; или &quot;Overwrite&quot;,определенные в данной спецификации.Если сервер оценивает условный заголовок,и если условие не удается выполнить,то этот код ошибки ДОЛЖЕН быть возвращен.С другой стороны,если клиент не включил условный заголовок в запрос,то сервер НЕ ДОЛЖЕН использовать этот код статуса.</target>
        </trans-unit>
        <trans-unit id="7cdc0894205bef818ccb78426bec4fd87c774e5d" translate="yes" xml:space="preserve">
          <source>Any script inspecting the response is permitted to read the values of the &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8478316470e4f240737c39611f11363ddfca7c9b" translate="yes" xml:space="preserve">
          <source>Any value is placed in an order of preference expressed using a relative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; called &lt;em&gt;weight&lt;/em&gt;.</source>
          <target state="translated">Любое значение размещается в порядке предпочтения, выраженного с помощью относительного &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;значения качества,&lt;/a&gt; называемого &lt;em&gt;весом&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0362e9377af962c1e1e3c9526a03e0bd8afd66f5" translate="yes" xml:space="preserve">
          <source>Any value is placed in an order of preference expressed using a relative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; called the &lt;em&gt;weight&lt;/em&gt;.</source>
          <target state="translated">Любое значение размещается в порядке предпочтения, выраженного с использованием &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;значения&lt;/a&gt; относительного качества, называемого &lt;em&gt;весом&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2511c542d2415f42594a069865e3cebb0df0bdbf" translate="yes" xml:space="preserve">
          <source>Any value placed in an order of preference expressed using a relative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; called &lt;em&gt;weight&lt;/em&gt;.</source>
          <target state="translated">Любое значение, расположенное в порядке предпочтения, выраженное с использованием &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;значения&lt;/a&gt; относительного качества, называемого &lt;em&gt;весом&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="028f46051e76ed93ba7b2778ec6eb36735319f74" translate="yes" xml:space="preserve">
          <source>Any value used is placed in an order of preference expressed using relative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; called the &lt;em&gt;weight&lt;/em&gt;.</source>
          <target state="translated">Любое используемое значение размещается в порядке предпочтения, выраженного с использованием &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;значения&lt;/a&gt; относительного качества, называемого &lt;em&gt;весом&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0b5958b0f53cb499388dd9ee04a106a30b02c5d1" translate="yes" xml:space="preserve">
          <source>Apache</source>
          <target state="translated">Apache</target>
        </trans-unit>
        <trans-unit id="8999d296169b8dd735b6c2a66a1890fdaeaf65ac" translate="yes" xml:space="preserve">
          <source>Apache (.htaccess)</source>
          <target state="translated">Apache (.htaccess)</target>
        </trans-unit>
        <trans-unit id="7723239d4f8c294f39821b7409607014e4779e8f" translate="yes" xml:space="preserve">
          <source>Apache configuration</source>
          <target state="translated">конфигурация Apache</target>
        </trans-unit>
        <trans-unit id="aa0a9cd5c584e9e02295690438c89eb9804a2974" translate="yes" xml:space="preserve">
          <source>Apache examples</source>
          <target state="translated">Примеры апачей</target>
        </trans-unit>
        <trans-unit id="c418bff5ffb1981f5504dddf5424420a352c8db4" translate="yes" xml:space="preserve">
          <source>Apache supports compression and uses &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_deflate.html&quot;&gt;mod_deflate&lt;/a&gt;; for nginx there is &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_gzip_module.html&quot;&gt;ngx_http_gzip_module&lt;/a&gt;; for IIS, the &lt;code&gt;&lt;a href=&quot;https://www.iis.net/configreference/system.webserver/httpcompression&quot;&gt;&amp;lt;httpCompression&amp;gt;&lt;/a&gt;&lt;/code&gt; element.</source>
          <target state="translated">Apache поддерживает сжатие и использует &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_deflate.html&quot;&gt;mod_deflate&lt;/a&gt; ; для nginx есть &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_gzip_module.html&quot;&gt;ngx_http_gzip_module&lt;/a&gt; ; для IIS - элемент &lt;code&gt;&lt;a href=&quot;https://www.iis.net/configreference/system.webserver/httpcompression&quot;&gt;&amp;lt;httpCompression&amp;gt;&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb97b025af5b9508c5b771e7550a47edd3292e52" translate="yes" xml:space="preserve">
          <source>Apache supports compression and uses &lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_deflate.html&quot;&gt;mod_deflate&lt;/a&gt;; for nginx there is &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_gzip_module.html&quot;&gt;ngx_http_gzip_module&lt;/a&gt;; for IIS, the &lt;code&gt;&lt;a href=&quot;https://www.iis.net/configreference/system.webserver/httpcompression&quot;&gt;&amp;lt;httpCompression&amp;gt;&lt;/a&gt;&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faca6e6d39fcc2dddfd17aac8a4b697f78f0b4a5" translate="yes" xml:space="preserve">
          <source>Apart from the headers automatically set by the user agent (for example, &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://fetch.spec.whatwg.org/#forbidden-header-name&quot;&gt;the other headers defined in the Fetch spec as a &amp;ldquo;forbidden header name&amp;rdquo;&lt;/a&gt;), the only headers which are allowed to be manually set are &lt;a href=&quot;https://fetch.spec.whatwg.org/#cors-safelisted-request-header&quot;&gt;those which the Fetch spec defines as a &amp;ldquo;CORS-safelisted request-header&amp;rdquo;&lt;/a&gt;, which are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970faa6cb472b485c0f707488c5cdc08b7986c8b" translate="yes" xml:space="preserve">
          <source>Apart from the headers set automatically by the user agent (for example, &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://fetch.spec.whatwg.org/#forbidden-header-name&quot;&gt;any of the other headers with names defined in the Fetch spec as a &amp;ldquo;forbidden header name&amp;rdquo;&lt;/a&gt;), the only headers which are allowed to be manually set are &lt;a href=&quot;https://fetch.spec.whatwg.org/#cors-safelisted-request-header&quot;&gt;those which the Fetch spec defines as being a &amp;ldquo;CORS-safelisted request-header&amp;rdquo;&lt;/a&gt;, which are:</source>
          <target state="translated">Помимо заголовков, автоматически устанавливаемых пользовательским агентом (например, &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://fetch.spec.whatwg.org/#forbidden-header-name&quot;&gt;любые другие заголовки с именами, определенными в спецификации Fetch как &amp;laquo;запрещенное имя заголовка&amp;raquo;&lt;/a&gt; ), единственные заголовки, которые могут быть вручную устанавливаются &lt;a href=&quot;https://fetch.spec.whatwg.org/#cors-safelisted-request-header&quot;&gt;те, которые в спецификации Fetch определены как &amp;laquo;заголовок запроса в безопасном списке CORS&amp;raquo;&lt;/a&gt; , а именно:</target>
        </trans-unit>
        <trans-unit id="1aa865a302682de3015e0ace4594cebfe9d891b1" translate="yes" xml:space="preserve">
          <source>AppCache,</source>
          <target state="translated">AppCache,</target>
        </trans-unit>
        <trans-unit id="f4f943fdac0850a40c1e416faae62566138da37d" translate="yes" xml:space="preserve">
          <source>Appendix A.  Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;</source>
          <target state="translated">Приложение A. Отличия от &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="918d2c04181755c7d2a2da27da64eb8b93bdb750" translate="yes" xml:space="preserve">
          <source>Appendix A.  Changes from RFCs 2616 and 2617</source>
          <target state="translated">Приложение А.Изменения по сравнению с КСФ 2616 и 2617</target>
        </trans-unit>
        <trans-unit id="b43034e2e81ab244701cc36ac5fa225c7d47a6b7" translate="yes" xml:space="preserve">
          <source>Appendix A.  Contributors</source>
          <target state="translated">Приложение А.Авторы</target>
        </trans-unit>
        <trans-unit id="81248f72eaaeaa9ce24d21fe4f273f8ddcbc8c1d" translate="yes" xml:space="preserve">
          <source>Appendix A.  Differences between HTTP and MIME</source>
          <target state="translated">Приложение А.Различия между HTTP и MIME</target>
        </trans-unit>
        <trans-unit id="7952612f081e615aa7bd03aa23dc4c518656090e" translate="yes" xml:space="preserve">
          <source>Appendix A.  HTTP Version History</source>
          <target state="translated">Приложение А.История версий HTTP</target>
        </trans-unit>
        <trans-unit id="6a6a944bd171bde6db3410fdca99b9555cb916eb" translate="yes" xml:space="preserve">
          <source>Appendix A.  Internet Media Type multipart/byteranges</source>
          <target state="translated">Приложение А.Тип Интернет-носителя многочастичный/байтерансферный</target>
        </trans-unit>
        <trans-unit id="5a342778d6d38dec85304f64cb11f4d4619e78db" translate="yes" xml:space="preserve">
          <source>Appendix A.  Notes on Processing XML Elements</source>
          <target state="translated">Приложение А.Примечания по обработке элементов XML</target>
        </trans-unit>
        <trans-unit id="a31c03a24bf30a70f8618d83f8525ac0d5fb0b3b" translate="yes" xml:space="preserve">
          <source>Appendix A.  TLS 1.2 Cipher Suite Black List</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee9c6db5c064e35f5da900ad01918c6a6eb39c9" translate="yes" xml:space="preserve">
          <source>Appendix B.  Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;</source>
          <target state="translated">Приложение B. Отличия от &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="66e5d9de6262db2adaa063f2f1cfab6dede8a9d3" translate="yes" xml:space="preserve">
          <source>Appendix B.  Collected ABNF</source>
          <target state="translated">Приложение В.Собрание ABNF</target>
        </trans-unit>
        <trans-unit id="4047ada28894f318e92d4c1e37bfb1baca1a4956" translate="yes" xml:space="preserve">
          <source>Appendix B.  Imported ABNF</source>
          <target state="translated">Приложение В.Импортируемый АБНФ</target>
        </trans-unit>
        <trans-unit id="e8da15ad98d1a9ffbcd6d66ba2fd87d4baebf827" translate="yes" xml:space="preserve">
          <source>Appendix B.  Notes on HTTP Client Compatibility</source>
          <target state="translated">Приложение В.Примечания по совместимости HTTP-клиентов</target>
        </trans-unit>
        <trans-unit id="4bc7060239451790c0c340964acba077f07d510e" translate="yes" xml:space="preserve">
          <source>Appendix B.  RELAX NG Compact Schema</source>
          <target state="translated">Приложение В.Компактная схема RELAX NG</target>
        </trans-unit>
        <trans-unit id="058387e6d5459c618bca63d6f49f8d5971089303" translate="yes" xml:space="preserve">
          <source>Appendix C.  Collected ABNF</source>
          <target state="translated">Приложение С.Собрание ABNF</target>
        </trans-unit>
        <trans-unit id="977523ad17c09cc35f1c89152295090a33b58a76" translate="yes" xml:space="preserve">
          <source>Appendix C.  Imported ABNF</source>
          <target state="translated">Приложение С.Импортируемый ABNF</target>
        </trans-unit>
        <trans-unit id="de902e4f9b3096f5f049db4d8e97c98cde2df389" translate="yes" xml:space="preserve">
          <source>Appendix C.  The 'opaquelocktoken' Scheme and URIs</source>
          <target state="translated">Приложение С.Схема &quot;непрозрачности&quot; и URI.</target>
        </trans-unit>
        <trans-unit id="ce8263e94ec9fefd83f8c080b1172f0fb08a91c8" translate="yes" xml:space="preserve">
          <source>Appendix D.  Collected ABNF</source>
          <target state="translated">Приложение D.Собрание ABNF</target>
        </trans-unit>
        <trans-unit id="0d9be62baed7f2691c136ca29f5d801725b346de" translate="yes" xml:space="preserve">
          <source>Appendix D.  Lock-null Resources</source>
          <target state="translated">Приложение D.Ресурсы по принципу &quot;заткнись,заткнись</target>
        </trans-unit>
        <trans-unit id="b843d7a45c5fbfe004e6dab880398f2c109d318b" translate="yes" xml:space="preserve">
          <source>Appendix E.  Guidance for Clients Desiring to Authenticate</source>
          <target state="translated">Приложение Е.Руководство для клиентов,желающих удостовериться в подлинности</target>
        </trans-unit>
        <trans-unit id="1e32692b4682e33761a3d401d643e95f4fc629c6" translate="yes" xml:space="preserve">
          <source>Appendix F.  Summary of Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;</source>
          <target state="translated">Приложение F. Обзор изменений по &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;сравнению&lt;/a&gt; с RFC 2518</target>
        </trans-unit>
        <trans-unit id="a6b70da19fe698facbbf74a7c6848c10082c6db6" translate="yes" xml:space="preserve">
          <source>Apple Installer Package</source>
          <target state="translated">Инсталляционный пакет Apple</target>
        </trans-unit>
        <trans-unit id="594c277ced56ff92f49f5549dcb6e9bb01873e08" translate="yes" xml:space="preserve">
          <source>Apple Safari rejects any such data. Google Chrome and Microsoft Edge discard up to four invalid bytes preceding a valid response. Firefox tolerates in excess of a kilobyte of invalid data preceding a valid response.</source>
          <target state="translated">Apple Safari отклоняет любые такие данные.Google Chrome и Microsoft Edge отбрасывают до четырех недействительных байт,предшествующих действительному ответу.Firefox допускает превышение килобайта недействительных данных,предшествующих действительному ответу.</target>
        </trans-unit>
        <trans-unit id="a7e444ff8fa9777e03d5103a61265a5f5c06bddc" translate="yes" xml:space="preserve">
          <source>AppleWebKit/xyz</source>
          <target state="translated">AppleWebKit/xyz</target>
        </trans-unit>
        <trans-unit id="978492a43f30387de57a216152fb92287c408810" translate="yes" xml:space="preserve">
          <source>April 1st joke spec</source>
          <target state="translated">анекдот 1 апреля</target>
        </trans-unit>
        <trans-unit id="c3cfa2d1b2b69734300d2888ba207ad587d929b9" translate="yes" xml:space="preserve">
          <source>Arbitrary, non-specific warning</source>
          <target state="translated">Произвольное,неспецифическое предупреждение</target>
        </trans-unit>
        <trans-unit id="ef596164d3adddb52527e23859760cbb72f418cb" translate="yes" xml:space="preserve">
          <source>Architecture (RFC 7230)</source>
          <target state="translated">Архитектура (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="2cd9571b02d0b5f97d07115fe12dfba195dd6de2" translate="yes" xml:space="preserve">
          <source>Archive document (multiple files embedded)</source>
          <target state="translated">Архивный документ (несколько встроенных файлов)</target>
        </trans-unit>
        <trans-unit id="96df099182a80fa56639e210174f84a1514aeddb" translate="yes" xml:space="preserve">
          <source>Are you trying to check for the existence of a specific feature?</source>
          <target state="translated">Вы пытаетесь проверить на существование определенной функции?</target>
        </trans-unit>
        <trans-unit id="22374513ed4cb776e85f41fade4e611b7089d973" translate="yes" xml:space="preserve">
          <source>Are you trying to work around a specific bug in some version of a browser?</source>
          <target state="translated">Вы пытаетесь обойти конкретную ошибку в какой-то версии браузера?</target>
        </trans-unit>
        <trans-unit id="8c498b25da0ee315015a3c8c5220c1550df792eb" translate="yes" xml:space="preserve">
          <source>Arguably the most common use and misuse of user agent sniffing is to detect if the device is a mobile device. However, people too often overlook what they are really after. People use user agent sniffing to detect if the users' device is touch-friendly and has a small screen so they can optimize their website accordingly. While user agent sniffing can sometimes detect these, not all devices are the same: some mobile devices have big screen sizes, some desktops have a small touchscreen, some people use smart TV's which are an entirely different ballgame altogether, and some people can dynamically change the width and height of their screen by flipping their tablet on its side! So, user agent sniffing is definitely not the way to go. Thankfully, there are much better alternatives. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/maxTouchPoints&quot;&gt;Navigator.maxTouchPoints&lt;/a&gt; to detect if the user's device has a touchscreen. Then, default back to checking the user agent screen only &lt;em&gt;if (!(&quot;maxTouchPoints&quot; in navigator)) { /*Code here*/}&lt;/em&gt;. Using this information of whether the device has a touchscreen, do not change the entire layout of the website just for touch devices: you will only create more work and maintenance for yourself. Rather, add in touch conveniences such as bigger, more easily clickable buttons (you can do this using CSS by simply increasing the font size). Here is an example of code that increases the padding of #exampleButton to 1em on mobile devices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cab0add88f8e2a278cfb8a5e8b164090488d38a" translate="yes" xml:space="preserve">
          <source>Arguably the most common use and misuse of user agent sniffing is to detect if the device is a mobile device. However, what is failed to be accountable is what they're really after. People use user agent sniffing to detect if the users' device is touch-friendly and has a small screen so they can optimize their website accordingly. While user agent sniffing can sometimes detect these, not all devices are the same. Some mobile devices have big screen sizes, some desktops have a small touchscreen, some people use smart TV's which are an entirely different ballgame altogether, some people can dynamically change the width and height of their screen by flipping their tablet on its side! So, user agent sniffing is definitely not the way to go. But, there are much better alternatives. Use &lt;em&gt;Navigator.maxTouchPoints&lt;/em&gt; to detect if the user's device has a touchscreen. Then, default back to checking the user agent screen only &lt;em&gt;if (!(&quot;maxTouchPoints&quot; in Navigator)) { /*Code here*/}&lt;/em&gt;. Using this information of whether the device has a touchscreen, do not change the entire layout of the website just for touch devices: you will only create more work and maintenance for yourself. Rather, add in touch conveniences such as bigger, more easily clickable buttons (you can do this using CSS by simply increasing the font size). As for the screen size, simply use &lt;em&gt;window.innerWidth&lt;/em&gt; and &lt;em&gt;window.addEventListener(&quot;resize&quot;, function(){ /*refresh screen size dependent things*/ })&lt;/em&gt;. What you want to do for screen size is not slash off information on smaller screens. That will only annoy people because it will force them to use the desktop version. Rather, try to have fewer columns of information in a longer page on smaller screens while having more columns with a shorter page on larger screen sizes. This effect can be easily achieved using CSS flexboxes. Next, always make your code dynamic. The user can flip their mobile device on its side, changing the width and height of the page. Never be satisfied with your webpage until you can open up the dev tools side panel and resize the screen while the webpage looks smooth, fluid, and dynamically resized.</source>
          <target state="translated">Возможно, наиболее распространенное и неправильное использование сниффинга пользовательского агента - это определение того, является ли устройство мобильным устройством. Однако то, что не удается привлечь к ответственности, - это то, чего они действительно хотят. Люди используют сниффинг пользовательского агента, чтобы определить, является ли устройство пользователей сенсорным и имеет ли небольшой экран, чтобы они могли соответствующим образом оптимизировать свой веб-сайт. Хотя анализ пользовательского агента иногда может их обнаружить, не все устройства одинаковы. Некоторые мобильные устройства имеют большие размеры экрана, некоторые настольные компьютеры имеют небольшой сенсорный экран, некоторые люди используют смарт-телевизоры, которые представляют собой совершенно другую игру, некоторые люди могут динамически изменять ширину и высоту своего экрана, перевернув планшет на бок! Таким образом, сниффинг пользовательского агента определенно не подходит. Но есть гораздо лучшие альтернативы. Используйте &lt;em&gt;Navigator.maxTouchPoints&lt;/em&gt;чтобы определить, есть ли на устройстве пользователя сенсорный экран. Затем по умолчанию вернитесь к проверке экрана пользовательского агента, только &lt;em&gt;если (! (&quot;MaxTouchPoints&quot; в навигаторе)) {/ * Код здесь * /}&lt;/em&gt; . Используя эту информацию о том, есть ли у устройства сенсорный экран, не изменяйте всю компоновку веб-сайта только для сенсорных устройств: вы только создадите больше работы и обслуживания для себя. Лучше добавьте сенсорные удобства, такие как более крупные, более удобные для нажатия кнопки (вы можете сделать это с помощью CSS, просто увеличив размер шрифта). Что касается размера экрана, просто используйте &lt;em&gt;window.innerWidth&lt;/em&gt; и &lt;em&gt;window.addEventListener (&quot;resize&quot;, function () {/ * обновлять параметры, зависящие от размера экрана * /})&lt;/em&gt;, Что вы хотите сделать с размером экрана, так это не вырезать информацию на экранах меньшего размера. Это будет только раздражать людей, потому что заставит их использовать настольную версию. Лучше постарайтесь иметь меньше столбцов информации на более длинной странице на экранах меньшего размера, но при этом иметь больше столбцов с более короткой страницей на экранах большего размера. Этого эффекта легко добиться с помощью CSS-флексбоксов. Далее всегда делайте свой код динамичным. Пользователь может переворачивать мобильное устройство на бок, изменяя ширину и высоту страницы. Никогда не довольствуйтесь своей веб-страницей, пока не откроете боковую панель инструментов разработчика и не измените размер экрана, пока веб-страница выглядит гладкой, плавной и динамически изменяемой.</target>
        </trans-unit>
        <trans-unit id="aec8c8505f13b416d6485fc08c67f5112086e6ad" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      #field-name

   The &quot;no-cache&quot; response directive indicates that the response MUST
   NOT be used to satisfy a subsequent request without successful
   validation on the origin server.  This allows an origin server to
   prevent a cache from using it to satisfy a request without contacting
   it, even by caches that have been configured to send stale responses.

   If the no-cache response directive specifies one or more field-names,
   then a cache MAY use the response to satisfy a subsequent request,
   subject to any other restrictions on caching.  However, any header
   fields in the response that have the field-name(s) listed MUST NOT be
   sent in the response to a subsequent request without successful
   revalidation with the origin server.  This allows an origin server to
   prevent the re-use of certain header fields in a response, while
   still allowing caching of the rest of the response.

   The field-names given are not limited to the set of header fields
   defined by this specification.  Field names are case-insensitive. 

   This directive uses the quoted-string form of the argument syntax.  A
   sender SHOULD NOT generate the token form (even if quoting appears
   not to be needed for single-entry lists).

   Note: Although it has been back-ported to many implementations, some
   HTTP/1.0 caches will not recognize or obey this directive.  Also,
   no-cache response directives with field-names are often handled by
   caches as if an unqualified no-cache directive was received; i.e.,
   the special handling for the qualified form is not widely
   implemented.</source>
          <target state="translated">Синтаксис аргументов:#field-name Директива ответа &quot;no-cache&quot; указывает,что ответ НЕ ДОЛЖЕН использоваться для удовлетворения последующего запроса без успешной проверки на исходном сервере.Это позволяет серверу-источнику предотвратить использование кэша для удовлетворения запроса без обращения к нему,даже если кэш был настроен на отправку несвежих ответов.Если директива no-cache response указывает одно или несколько имен поля,то кэш MAY использует ответ для удовлетворения последующего запроса,с учетом любых других ограничений на кэширование.Однако,любые поля заголовков в ответе,которые содержат имя(и)поля,перечисленные в списке,НЕ ДОЛЖНЫ быть отправлены в ответе на последующий запрос без успешной повторной проверки с сервером-источником.Это позволяет серверу-источнику предотвратить повторное использование определенных полей заголовков в ответе,в то же время позволяя кэшировать остальную часть ответа.Имена полей не ограничиваются набором полей заголовка,определенных данной спецификацией.Имена полей не чувствительны к регистру.Эта директива использует синтаксис аргумента в кавычках.Отправитель НЕ должен генерировать форму токена (даже если кавычки не нужны для списков с одним входом).Замечание:Несмотря на то,что она была перенесена во многие реализации,некоторые кэши HTTP/1.0 не распознают эту директиву или не подчиняются ей.Кроме того,директивы ответа no-cache с именами полей часто обрабатываются кэшами так,как будто была получена неквалифицированная директива no-cache;т.е.специальная обработка квалифицированной формы реализована не очень широко.</target>
        </trans-unit>
        <trans-unit id="d1831ae5ad42c135eef58117ca5beea27918ee39" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      #field-name 

   The &quot;private&quot; response directive indicates that the response message
   is intended for a single user and MUST NOT be stored by a shared
   cache.  A private cache MAY store the response and reuse it for later
   requests, even if the response would normally be non-cacheable.

   If the private response directive specifies one or more field-names,
   this requirement is limited to the field-values associated with the
   listed response header fields.  That is, a shared cache MUST NOT
   store the specified field-names(s), whereas it MAY store the
   remainder of the response message.

   The field-names given are not limited to the set of header fields
   defined by this specification.  Field names are case-insensitive.

   This directive uses the quoted-string form of the argument syntax.  A
   sender SHOULD NOT generate the token form (even if quoting appears
   not to be needed for single-entry lists).

   Note: This usage of the word &quot;private&quot; only controls where the
   response can be stored; it cannot ensure the privacy of the message
   content.  Also, private response directives with field-names are
   often handled by caches as if an unqualified private directive was
   received; i.e., the special handling for the qualified form is not
   widely implemented.</source>
          <target state="translated">Синтаксис аргументов:#field-name Директива ответа &quot;private&quot; указывает,что ответное сообщение предназначено для одного пользователя и НЕ ДОЛЖНО храниться в общем кэше.Частный кэш ОБЯЗАТЕЛЬНО хранит ответ и повторно использует его для более поздних запросов,даже если ответ обычно не кэшируется.Если директива private response указывает одно или несколько имен поля,то это требование ограничивается значениями поля,связанными с полями заголовка перечисленного ответа.То есть,общий кэш НЕ ДОЛЖЕН хранить указанные имена,в то время как он ДОЛЖЕН хранить оставшуюся часть ответного сообщения.Приведенные имена не ограничиваются набором полей заголовков,определенных данной спецификацией.Имена полей не чувствительны к регистру.Эта директива использует синтаксис аргумента в кавычках.Отправитель НЕ должен генерировать форму токена (даже если кавычки не нужны для списков с одним входом).Замечание:Использование слова &quot;private&quot; контролирует только то,где может быть сохранен ответ;оно не может обеспечить конфиденциальность содержимого сообщения.Кроме того,директивы приватного ответа с именами полей часто обрабатываются кэшем так,как будто была получена неквалифицированная приватная директива;т.е.специальная обработка квалифицированной формы реализована не очень широко.</target>
        </trans-unit>
        <trans-unit id="4aefbf84315b53b56a158fafd1e4047cf84680b4" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      delta-seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;)

   The &quot;max-age&quot; request directive indicates that the client is
   unwilling to accept a response whose age is greater than the
   specified number of seconds.  Unless the max-stale request directive
   is also present, the client is not willing to accept a stale
   response.

   This directive uses the token form of the argument syntax: e.g.,
   'max-age=5' not 'max-age=&quot;5&quot;'.  A sender SHOULD NOT generate the
   quoted-string form.</source>
          <target state="translated">Синтаксис аргумента: дельта-секунды (см. &lt;a href=&quot;#section-1.2.1&quot;&gt;Раздел 1.2.1&lt;/a&gt; ) Директива запроса &amp;laquo;max-age&amp;raquo; указывает, что клиент не желает принимать ответ, возраст которого превышает указанное количество секунд. Если также не присутствует директива max-stale request, клиент не желает принимать устаревший ответ. В этой директиве используется токен-форма синтаксиса аргумента: например, &amp;laquo;max-age = 5&amp;raquo;, а не &amp;laquo;max-age =&amp;laquo; 5 &amp;raquo;&amp;raquo;. Отправителю НЕ СЛЕДУЕТ создавать форму строки в кавычках.</target>
        </trans-unit>
        <trans-unit id="13b97b4c1790a5d1690e4603b26402d86eb7b629" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      delta-seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;)

   The &quot;max-age&quot; response directive indicates that the response is to be
   considered stale after its age is greater than the specified number
   of seconds.

   This directive uses the token form of the argument syntax: e.g.,
   'max-age=5' not 'max-age=&quot;5&quot;'.  A sender SHOULD NOT generate the
   quoted-string form.</source>
          <target state="translated">Синтаксис аргумента: дельта-секунды (см. &lt;a href=&quot;#section-1.2.1&quot;&gt;Раздел 1.2.1&lt;/a&gt; ) Директива ответа &quot;max-age&quot; указывает, что ответ считается устаревшим после того, как его возраст превышает указанное количество секунд. В этой директиве используется токен-форма синтаксиса аргумента: например, 'max-age = 5', а не 'max-age = &quot;5&quot;'. Отправителю НЕ СЛЕДУЕТ создавать форму строки в кавычках.</target>
        </trans-unit>
        <trans-unit id="06cca4dcd60697e3d0f6bcb9d03459f0446ded37" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      delta-seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;)

   The &quot;max-stale&quot; request directive indicates that the client is
   willing to accept a response that has exceeded its freshness
   lifetime.  If max-stale is assigned a value, then the client is
   willing to accept a response that has exceeded its freshness lifetime
   by no more than the specified number of seconds.  If no value is
   assigned to max-stale, then the client is willing to accept a stale
   response of any age.

   This directive uses the token form of the argument syntax: e.g.,
   'max-stale=10' not 'max-stale=&quot;10&quot;'.  A sender SHOULD NOT generate
   the quoted-string form.</source>
          <target state="translated">Синтаксис аргумента: дельта-секунды (см. &lt;a href=&quot;#section-1.2.1&quot;&gt;Раздел 1.2.1&lt;/a&gt; ) Директива запроса &amp;laquo;max-stale&amp;raquo; указывает, что клиент готов принять ответ, срок действия которого истек. Если max-stale присвоено значение, то клиент готов принять ответ, срок действия которого превысил срок действия не более, чем на указанное количество секунд. Если max-stale не присвоено никакого значения, то клиент готов принять устаревший ответ любого возраста. Эта директива использует форму токена синтаксиса аргумента: например, 'max-stale = 10', а не 'max-stale = &quot;10&quot;'. Отправителю НЕ СЛЕДУЕТ создавать форму строки в кавычках.</target>
        </trans-unit>
        <trans-unit id="a825cbd8ee60bf462c6dee710ec7c6f4b00811e3" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      delta-seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;)

   The &quot;s-maxage&quot; response directive indicates that, in shared caches,
   the maximum age specified by this directive overrides the maximum age
   specified by either the max-age directive or the Expires header
   field.  The s-maxage directive also implies the semantics of the
   proxy-revalidate response directive.

   This directive uses the token form of the argument syntax: e.g.,
   's-maxage=10' not 's-maxage=&quot;10&quot;'.  A sender SHOULD NOT generate the
   quoted-string form.</source>
          <target state="translated">Синтаксис аргумента: дельта-секунды (см. &lt;a href=&quot;#section-1.2.1&quot;&gt;Раздел 1.2.1&lt;/a&gt; ). Директива ответа &amp;laquo;s-maxage&amp;raquo; указывает, что в общих кэшах максимальный возраст, указанный в этой директиве, имеет приоритет над максимальным возрастом, указанным либо в директиве max-age, либо в Expires. поле заголовка. Директива s-maxage также подразумевает семантику директивы ответа proxy-revalidate. В этой директиве используется форма токена синтаксиса аргумента: например, 's-maxage = 10', а не 's-maxage = &quot;10&quot;'. Отправителю НЕ СЛЕДУЕТ создавать форму строки в кавычках.</target>
        </trans-unit>
        <trans-unit id="ecc2f52fea65ff20c3fe05e836282a0ecfcb5341" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      delta-seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;) 

   The &quot;min-fresh&quot; request directive indicates that the client is
   willing to accept a response whose freshness lifetime is no less than
   its current age plus the specified time in seconds.  That is, the
   client wants a response that will still be fresh for at least the
   specified number of seconds.

   This directive uses the token form of the argument syntax: e.g.,
   'min-fresh=20' not 'min-fresh=&quot;20&quot;'.  A sender SHOULD NOT generate
   the quoted-string form.</source>
          <target state="translated">Синтаксис аргумента: дельта-секунды (см. &lt;a href=&quot;#section-1.2.1&quot;&gt;Раздел 1.2.1&lt;/a&gt; ) Директива запроса min-fresh указывает, что клиент готов принять ответ, время жизни которого не меньше его текущего возраста плюс указанное время в секундах. То есть клиент хочет, чтобы ответ был свежим в течение как минимум указанного количества секунд. В этой директиве используется токен-форма синтаксиса аргумента: например, min-fresh = 20, а не min-fresh = &quot;20&quot; '. Отправителю НЕ СЛЕДУЕТ создавать форму строки в кавычках.</target>
        </trans-unit>
        <trans-unit id="7c422841b7e3951946583038790545c4ed38481b" translate="yes" xml:space="preserve">
          <source>Articles</source>
          <target state="translated">Articles</target>
        </trans-unit>
        <trans-unit id="6927f0a6d5b5b7a8990677811eb75f75899710be" translate="yes" xml:space="preserve">
          <source>As a &lt;a href=&quot;https://en.wikipedia.org/wiki/Defense_in_depth_(computing)&quot;&gt;defence-in-depth measure&lt;/a&gt;, however, it is possible to use &lt;em&gt;cookie prefixes&lt;/em&gt; to assert specific facts about the cookie. Two prefixes are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbe5fd2ae86fbae88e539aaddac116ef8cfd88d6" translate="yes" xml:space="preserve">
          <source>As a header for a multipart body</source>
          <target state="translated">Как заголовок для тела,состоящего из нескольких частей</target>
        </trans-unit>
        <trans-unit id="4db566644cc9fbe6a83b2c42804119cde6babd72" translate="yes" xml:space="preserve">
          <source>As a multipart document format, it consists of different parts, delimited by a boundary (a string starting with a double dash &lt;code&gt;'--'&lt;/code&gt;). Each part is its own entity with its own HTTP headers, &lt;a href=&quot;../headers/content-disposition&quot;&gt;&lt;code&gt;Content-Disposition&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; for file uploading fields.</source>
          <target state="translated">Как формат документа, состоящего из нескольких частей, он состоит из разных частей, разделенных границей (строка, начинающаяся с двойного тире &lt;code&gt;'--'&lt;/code&gt; ). Каждая часть представляет собой отдельный объект со своими собственными заголовками HTTP, &lt;a href=&quot;../headers/content-disposition&quot;&gt; &lt;code&gt;Content-Disposition&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; для полей загрузки файлов.</target>
        </trans-unit>
        <trans-unit id="178623dce37dff8814bd5d7a8ed3496b3a38d15c" translate="yes" xml:space="preserve">
          <source>As a multipart document format, it consists of different parts, delimited by a boundary (a string starting with a double dash &lt;code&gt;--&lt;/code&gt;). Each part is its own entity with its own HTTP headers, &lt;a href=&quot;../headers/content-disposition&quot;&gt;&lt;code&gt;Content-Disposition&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; for file uploading fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c3d44cd58fb8f4d3b3944cc4bb1a87c5213f6f" translate="yes" xml:space="preserve">
          <source>As a response header for the main body</source>
          <target state="translated">В качестве ответного заголовка для основного тела</target>
        </trans-unit>
        <trans-unit id="fe358a19fe3a891412dc63b31012cfff7e86b53a" translate="yes" xml:space="preserve">
          <source>As above, but use proxy for local servers which are outside the firewall</source>
          <target state="translated">Как было сказано выше,но используйте прокси для локальных серверов,которые находятся за пределами брандмауэра.</target>
        </trans-unit>
        <trans-unit id="21bb09d2ae7faa16332b73a9ff9b212546d3db2e" translate="yes" xml:space="preserve">
          <source>As an HTTP/1.x connection is serializing requests, even without any ordering, it can't be optimal without large enough available bandwidth. As a solution, browsers open several connections to each domain, sending parallel requests. Default was once 2 to 3 connections, but this has now increased to a more common use of 6 parallel connections. There is a risk of triggering &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DOS_attack&quot;&gt;DoS&lt;/a&gt; protection on the server side if attempting more than this number.</source>
          <target state="translated">Поскольку соединение HTTP / 1.x сериализует запросы, даже без упорядочивания, оно не может быть оптимальным без достаточно большой доступной полосы пропускания. В качестве решения браузеры открывают несколько подключений к каждому домену, отправляя параллельные запросы. По умолчанию когда-то было от 2 до 3 соединений, но теперь это увеличилось до более распространенного использования 6 параллельных соединений. Существует риск срабатывания защиты от &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DOS_attack&quot;&gt;DoS&lt;/a&gt; на стороне сервера при попытке увеличить число, превышающее это число.</target>
        </trans-unit>
        <trans-unit id="ac2caa651e1c42338fb211a69aa78825a0cefdcd" translate="yes" xml:space="preserve">
          <source>As an ultimate form of protection, sites that want to never allow scripts to be executed can opt to globally disallow script execution.</source>
          <target state="translated">В качестве конечной формы защиты сайты,которые хотят никогда не позволять выполнение скриптов,могут глобально запретить выполнение скриптов.</target>
        </trans-unit>
        <trans-unit id="9c5fdf8f8fd2b7a8d4e1fc4e882626af24bfa4c2" translate="yes" xml:space="preserve">
          <source>As compression brings significant performance improvements, it is recommended to activate it for all files, but already compressed ones like images, audio files and videos.</source>
          <target state="translated">Так как сжатие приносит значительные улучшения производительности,рекомендуется активировать его для всех файлов,но уже сжатых,таких как изображения,аудиофайлы и видео.</target>
        </trans-unit>
        <trans-unit id="07e3361838eead49089d2124cc5527647d9a433d" translate="yes" xml:space="preserve">
          <source>As compression works better on a specific kind of files, it usually provides nothing to compress them a second time. In fact, this is often counter productive as the cost of the overhead (algorithms usually need a dictionary that add to the initial size) can be higher than the extra gain in compression resulting in a larger file. Do not use the two following techniques for files in a compressed format.</source>
          <target state="translated">Так как сжатие лучше работает на конкретном типе файлов,оно обычно не дает ничего,чтобы сжать их во второй раз.На самом деле,это часто контрпродуктивно,поскольку стоимость накладных расходов (алгоритмам обычно нужен словарь,который добавляется к исходному размеру)может быть выше,чем дополнительный выигрыш в сжатии,в результате чего получается файл большего размера.Не используйте два следующих метода для файлов в сжатом формате.</target>
        </trans-unit>
        <trans-unit id="81962caea1092807ea8b2efefdcc4ff1e7fe59fa" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;, intermediaries can serve a variety of
   roles in the processing of HTTP requests and responses.  Some
   intermediaries are used to improve performance or availability.
   Others are used for access control or to filter content.  Since an
   HTTP stream has characteristics similar to a pipe-and-filter
   architecture, there are no inherent limits to the extent an
   intermediary can enhance (or interfere) with either direction of the
   stream.

   An intermediary not acting as a tunnel MUST implement the Connection
   header field, as specified in &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;, and exclude fields from
   being forwarded that are only intended for the incoming connection.

   An intermediary MUST NOT forward a message to itself unless it is
   protected from an infinite request loop.  In general, an intermediary
   ought to recognize its own server names, including any aliases, local
   variations, or literal IP addresses, and respond to such requests
   directly.</source>
          <target state="translated">Как описано в &lt;a href=&quot;#section-2.3&quot;&gt;разделе 2.3&lt;/a&gt; , посредники могут выполнять самые разные роли при обработке HTTP-запросов и ответов. Некоторые посредники используются для повышения производительности или доступности. Другие используются для управления доступом или для фильтрации содержимого. Поскольку HTTP-поток имеет характеристики, аналогичные архитектуре &amp;laquo;конвейер и фильтр&amp;raquo;, нет никаких внутренних ограничений на то, насколько посредник может улучшать (или мешать) любому направлению потока. Посредник, не действующий в качестве туннеля, ДОЛЖЕН реализовать поле заголовка соединения, как указано в &lt;a href=&quot;#section-6.1&quot;&gt;разделе 6.1.&lt;/a&gt;, и исключить из переадресации поля, предназначенные только для входящего соединения. Посредник НЕ ДОЛЖЕН пересылать сообщение самому себе, если он не защищен от бесконечного цикла запросов. Как правило, посредник должен распознавать свои собственные имена серверов, включая любые псевдонимы, локальные варианты или буквальные IP-адреса, и напрямую отвечать на такие запросы.</target>
        </trans-unit>
        <trans-unit id="f43788db4540801d9e9c8e83df8533bea5ea3e5a" translate="yes" xml:space="preserve">
          <source>As discussed above, caching servers will by default match future requests &lt;em&gt;only&lt;/em&gt; to requests with &lt;em&gt;exactly&lt;/em&gt; the same headers and header values. That means a request will be made to the origin and a new cache will be created for every slight variant that might be specified by different user-agents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d3139df0524707e53ec9e8cd4a5811fa59a90a9" translate="yes" xml:space="preserve">
          <source>As for MIME types of audio or video files, they typically specify the container format (file type). The optional &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter&quot;&gt;codecs parameter&lt;/a&gt; can be added to the MIME type to further specify which codecs to use and what options were used to encode the media, such as codec profile, level, or other such information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc03353444641fab750adbd74e2bf1df56aa6e5" translate="yes" xml:space="preserve">
          <source>As for the screen size, simply use &lt;em&gt;window.innerWidth&lt;/em&gt; and window.addEventListener(&quot;resize&quot;, function(){ /*refresh screen size dependent things*/ }). What you want to do for screen size is not slash off information on smaller screens. That will only annoy people because it will force them to use the desktop version. Rather, try to have fewer columns of information in a longer page on smaller screens while having more columns with a shorter page on larger screen sizes. This effect can be easily achieved using CSS &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox&quot;&gt;flexboxes&lt;/a&gt;, sometimes with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Floats&quot;&gt;floats&lt;/a&gt; as a partial fallback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0808a49d5ce5e6736477468b862009c7c3fdd1ef" translate="yes" xml:space="preserve">
          <source>As introduced in &lt;a href=&quot;#section-8.7&quot;&gt;Section 8.7&lt;/a&gt;, extra information on error conditions
   can be included in the body of many status responses.  This section
   makes requirements on the use of the error body mechanism and
   introduces a number of precondition and postcondition codes.

   A &quot;precondition&quot; of a method describes the state of the server that
   must be true for that method to be performed.  A &quot;postcondition&quot; of a
   method describes the state of the server that must be true after that
   method has been completed.

   Each precondition and postcondition has a unique XML element
   associated with it.  In a 207 Multi-Status response, the XML element
   MUST appear inside an 'error' element in the appropriate 'propstat or
   'response' element depending on whether the condition applies to one
   or more properties or to the resource as a whole.  In all other error
   responses where this specification's 'error' body is used, the
   precondition/postcondition XML element MUST be returned as the child
   of a top-level 'error' element in the response body, unless otherwise
   negotiated by the request, along with an appropriate response status.
   The most common response status codes are 403 (Forbidden) if the
   request should not be repeated because it will always fail, and 409
   (Conflict) if it is expected that the user might be able to resolve
   the conflict and resubmit the request.  The 'error' element MAY
   contain child elements with specific error information and MAY be
   extended with any custom child elements.

   This mechanism does not take the place of using a correct numeric
   status code as defined here or in HTTP, because the client must
   always be able to take a reasonable course of action based only on
   the numeric code.  However, it does remove the need to define new
   numeric codes.  The new machine-readable codes used for this purpose
   are XML elements classified as preconditions and postconditions, so
   naturally, any group defining a new condition code can use their own
   namespace.  As always, the &quot;DAV:&quot; namespace is reserved for use by
   IETF-chartered WebDAV working groups. 

   A server supporting this specification SHOULD use the XML error
   whenever a precondition or postcondition defined in this document is
   violated.  For error conditions not specified in this document, the
   server MAY simply choose an appropriate numeric status and leave the
   response body blank.  However, a server MAY instead use a custom
   condition code and other supporting text, because even when clients
   do not automatically recognize condition codes, they can be quite
   useful in interoperability testing and debugging.

   Example - Response with precondition code

   &amp;gt;&amp;gt;Response

      HTTP/1.1 423 Locked
      Content-Type: application/xml; charset=&quot;utf-8&quot;
      Content-Length: xxxx

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:error xmlns:D=&quot;DAV:&quot;&amp;gt;
        &amp;lt;D:lock-token-submitted&amp;gt;
          &amp;lt;D:href&amp;gt;/workspace/webdav/&amp;lt;/D:href&amp;gt;
        &amp;lt;/D:lock-token-submitted&amp;gt;
      &amp;lt;/D:error&amp;gt;

   In this example, a client unaware of a depth-infinity lock on the
   parent collection &quot;/workspace/webdav/&quot; attempted to modify the
   collection member &quot;/workspace/webdav/proposal.doc&quot;.

   Some other useful preconditions and postconditions have been defined
   in other specifications extending WebDAV, such as [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;] (see
   particularly &lt;a href=&quot;#section-7.1.1&quot;&gt;Section 7.1.1&lt;/a&gt;), [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;], and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3648&quot;&gt;RFC3648&lt;/a&gt;].

   All these elements are in the &quot;DAV:&quot; namespace.  If not specified
   otherwise, the content for each condition's XML element is defined to
   be empty.


   Name:  lock-token-matches-request-uri

   Use with:  409 Conflict

   Purpose:  (precondition) -- A request may include a Lock-Token header
      to identify a lock for the UNLOCK method.  However, if the
      Request-URI does not fall within the scope of the lock identified
      by the token, the server SHOULD use this error.  The lock may have
      a scope that does not include the Request-URI, or the lock could
      have disappeared, or the token may be invalid. 

   Name:  lock-token-submitted (precondition)

   Use with:  423 Locked

   Purpose:  The request could not succeed because a lock token should
      have been submitted.  This element, if present, MUST contain at
      least one URL of a locked resource that prevented the request.  In
      cases of MOVE, COPY, and DELETE where collection locks are
      involved, it can be difficult for the client to find out which
      locked resource made the request fail -- but the server is only
      responsible for returning one such locked resource.  The server
      MAY return every locked resource that prevented the request from
      succeeding if it knows them all.

   &amp;lt;!ELEMENT lock-token-submitted (href+) &amp;gt;


   Name:  no-conflicting-lock (precondition)

   Use with:  Typically 423 Locked

   Purpose:  A LOCK request failed due the presence of an already
      existing conflicting lock.  Note that a lock can be in conflict
      although the resource to which the request was directed is only
      indirectly locked.  In this case, the precondition code can be
      used to inform the client about the resource that is the root of
      the conflicting lock, avoiding a separate lookup of the
      &quot;lockdiscovery&quot; property.

   &amp;lt;!ELEMENT no-conflicting-lock (href)* &amp;gt;


   Name:  no-external-entities

   Use with:  403 Forbidden

   Purpose:  (precondition) -- If the server rejects a client request
      because the request body contains an external entity, the server
      SHOULD use this error.


   Name:  preserved-live-properties

   Use with:  409 Conflict

   Purpose:  (postcondition) -- The server received an otherwise-valid
      MOVE or COPY request, but cannot maintain the live properties with
      the same behavior at the destination.  It may be that the server 

      only supports some live properties in some parts of the
      repository, or simply has an internal error.


   Name:  propfind-finite-depth

   Use with:  403 Forbidden

   Purpose:  (precondition) -- This server does not allow infinite-depth
      PROPFIND requests on collections.


   Name:  cannot-modify-protected-property

   Use with:  403 Forbidden

   Purpose:  (precondition) -- The client attempted to set a protected
      property in a PROPPATCH (such as DAV:getetag).  See also
      &lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-3.12&quot;&gt;[RFC3253], Section&amp;nbsp;3.12&lt;/a&gt;.</source>
          <target state="translated">Как описано в &lt;a href=&quot;#section-8.7&quot;&gt;Разделе 8.7&lt;/a&gt;дополнительная информация об условиях ошибки может быть включена в тело многих ответов о состоянии. В этом разделе предъявляются требования к использованию механизма тела ошибки и вводится ряд кодов предварительного и постусловия. &amp;laquo;Предварительное условие&amp;raquo; метода описывает состояние сервера, которое должно быть истинным для выполнения этого метода. &amp;laquo;Постусловие&amp;raquo; метода описывает состояние сервера, которое должно быть истинным после завершения этого метода. С каждым предусловием и постусловием связан уникальный элемент XML. В ответе 207 Multi-Status элемент XML ДОЛЖЕН появляться внутри элемента 'error' в соответствующем 'propstat' или 'response'.в зависимости от того, применяется ли условие к одному или нескольким свойствам или к ресурсу в целом. Во всех других сообщениях об ошибках, в которых используется тело ошибки этой спецификации, элемент XML предусловия / постусловия ДОЛЖЕН быть возвращен как дочерний элемент верхнего уровня элемента error в теле ответа, если иное не согласовано запросом, вместе с соответствующий статус ответа. Наиболее распространенными кодами состояния ответа являются 403 (Запрещено), если запрос не следует повторять, потому что он всегда будет терпеть неудачу, и 409 (Конфликт), если ожидается, что пользователь сможет разрешить конфликт и повторно отправить запрос. Элемент error МОЖЕТ содержать дочерние элементы с конкретной информацией об ошибке и МОЖЕТ быть расширен любыми настраиваемыми дочерними элементами.Этот механизм не заменяет использование правильного числового кода состояния, как определено здесь или в HTTP, потому что клиент всегда должен иметь возможность предпринять разумные действия, основанные только на числовом коде. Однако он устраняет необходимость определять новые числовые коды. Новые машиночитаемые коды, используемые для этой цели, представляют собой элементы XML, классифицируемые как предусловия и постусловия, поэтому, естественно, любая группа, определяющая новый код условия, может использовать свое собственное пространство имен. Как всегда, пространство имен &amp;laquo;DAV:&amp;raquo; зарезервировано для использования рабочими группами WebDAV, учрежденными IETF. Серверу, поддерживающему эту спецификацию, СЛЕДУЕТ использовать ошибку XML всякий раз, когда нарушается предусловие или постусловие, определенные в этом документе. Для условий ошибки, не указанных в этом документе,сервер МОЖЕТ просто выбрать соответствующий числовой статус и оставить тело ответа пустым. Однако сервер МОЖЕТ вместо этого использовать настраиваемый код условия и другой вспомогательный текст, потому что даже когда клиенты не распознают коды условий автоматически, они могут быть весьма полезны при тестировании совместимости и отладке. Пример - ответ с кодом предварительного условия &amp;gt;&amp;gt; Ответ HTTP / 1.1 423 Locked Content-Type: application / xml; charset = &quot;utf-8&quot; Content-Length: xxxx &amp;lt;? xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D: error xmlns: D = &quot;DAV:&quot;&amp;gt; &amp;lt;D: отправлено токен-блокировки &amp;gt; &amp;lt;D: href&amp;gt; / workspace / webdav / &amp;lt;/ D: href&amp;gt; &amp;lt;/ D: lock-token-submit&amp;gt; &amp;lt;/ D: error&amp;gt; В этом примереклиент, не знающий о блокировке бесконечности глубины в родительской коллекции &amp;laquo;/ workspace / webdav /&amp;raquo;, попытался изменить член коллекции &amp;laquo;/workspace/webdav/proposal.doc&amp;raquo;. Некоторые другие полезные предварительные условия и постусловия были определены в других спецификациях, расширяющих WebDAV, например [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt; ] (см., В частности, &lt;a href=&quot;#section-7.1.1&quot;&gt;раздел 7.1.1&lt;/a&gt; ), [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ] и [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3648&quot;&gt;RFC3648&lt;/a&gt;]. Все эти элементы находятся в пространстве имен &amp;laquo;DAV:&amp;raquo;. Если не указано иное, содержимое XML-элемента каждого условия определяется как пустое. Имя: lock-token-matches-request-uri Использование с: 409 Conflict Цель: (предварительное условие) - запрос может включать в себя заголовок Lock-Token для идентификации блокировки для метода UNLOCK. Однако, если Request-URI не попадает в область действия блокировки, определенной токеном, сервер ДОЛЖЕН использовать эту ошибку. Блокировка может иметь область, которая не включает Request-URI, или блокировка могла исчезнуть, или токен может быть недействительным. Имя: отправленный токен блокировки (предварительное условие) Использование с: 423 Заблокировано Цель: запрос не может быть успешным, поскольку должен быть отправлен токен блокировки. Этот элемент, если он присутствует,ДОЛЖЕН содержать хотя бы один URL-адрес заблокированного ресурса, который предотвратил запрос. В случаях MOVE, COPY и DELETE, когда задействованы блокировки сбора, клиенту может быть сложно выяснить, какой заблокированный ресурс привел к сбою запроса, но сервер отвечает только за возврат одного такого заблокированного ресурса. Сервер МОЖЕТ вернуть каждый заблокированный ресурс, который помешал выполнению запроса, если он знает их все. &amp;lt;! ELEMENT lock-token-submit (href +)&amp;gt; Имя: no-Conflicting-lock (предварительное условие) Использование с: Обычно 423 Заблокировано Цель: запрос LOCK не выполнен из-за наличия уже существующей конфликтующей блокировки. Обратите внимание, что блокировка может конфликтовать, хотя ресурс, на который был направлен запрос, заблокирован только косвенно. В таком случае,код предварительного условия может использоваться для информирования клиента о ресурсе, который является корнем конфликтующей блокировки, избегая отдельного поиска свойства &amp;laquo;lockdiscovery&amp;raquo;. &amp;lt;! ELEMENT no-Conflicting-lock (href) *&amp;gt; Имя: no-external-entity Использование с: 403 Запрещено Назначение: (предварительное условие) - Если сервер отклоняет запрос клиента, потому что тело запроса содержит внешнюю сущность, сервер СЛЕДУЕТ использовать эту ошибку. Имя: saved-live-properties Использование с: 409 Конфликт Цель: (постусловие) - сервер получил действительный запрос MOVE или COPY, но не может поддерживать текущие свойства с таким же поведением в месте назначения. Может случиться так, что сервер поддерживает только некоторые живые свойства в некоторых частях репозитория,или просто имеет внутреннюю ошибку. Имя: propfind-конечная глубина Использование с: 403 Запрещено Цель: (предварительное условие) - этот сервер не разрешает запросы PROPFIND бесконечной глубины для коллекций. Имя: cannot-modify-protected-property Использование с: 403 Запрещено Цель: (предварительное условие) - клиент попытался установить защищенное свойство в PROPPATCH (например, DAV: getetag). Смотрите также &lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-3.12&quot;&gt;[RFC3253], раздел 3.12&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e578d6e0863762b2b392e523d033651de5872ee8" translate="yes" xml:space="preserve">
          <source>As is the case for images, HTML doesn't mandate that web browsers support any specific file and codec types for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, so it's important to consider your target audience and the range of browsers (and versions of those browsers) they may be using when choosing the file type and codecs to use for media.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe77ba78e510c9166dbea1c2b28c359c08ac3d8" translate="yes" xml:space="preserve">
          <source>As long as the &lt;code&gt;identity&lt;/code&gt; value, meaning no encoding, is not explicitly forbidden, by an &lt;code&gt;identity;q=0&lt;/code&gt; or a &lt;code&gt;*;q=0&lt;/code&gt; without another explicitly set value for identity, the server must never send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Acceptable&lt;/code&gt; error.</source>
          <target state="translated">Пока значение &lt;code&gt;identity&lt;/code&gt; , означающее отсутствие кодирования, явно не запрещено &lt;code&gt;identity;q=0&lt;/code&gt; или a &lt;code&gt;*;q=0&lt;/code&gt; без другого явно установленного значения для идентификатора, сервер никогда не должен отправлять обратно ошибку &lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Acceptable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74200951f8f3fa2318cb0493483bd1ef3add00e6" translate="yes" xml:space="preserve">
          <source>As long as the cache is not stale, no requests are issued at all. But once it has become stale, this is mostly controlled by the &lt;a href=&quot;headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header, the client doesn't use the cached value directly but issues a &lt;em&gt;conditional request&lt;/em&gt;. The value of the validator is used as a parameter of the &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; headers.</source>
          <target state="translated">Пока кеш не устарел, запросы вообще не отправляются. Но как только он устарел, это в основном контролируется заголовком &lt;a href=&quot;headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; , клиент не использует кешированное значение напрямую, а выдает &lt;em&gt;условный запрос&lt;/em&gt; . Значение валидатора используется как параметр заголовков &lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85a5d6853183730de2675bcbb36ff69a7b45767b" translate="yes" xml:space="preserve">
          <source>As of Firefox 68, &lt;code&gt;https&lt;/code&gt; pages are not permitted to access &lt;code&gt;http://localhost&lt;/code&gt;, although this may be changed by &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1488740&quot;&gt;Bug 1488740&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39de7dbf0fcbd56548611790fd4f9d1859fcff38" translate="yes" xml:space="preserve">
          <source>As of HTTP/1.1, the connection is no longer closed after completing the third phase, and the client is now granted a further request: this means the second and third phases can now be performed any number of times.</source>
          <target state="translated">Начиная с HTTP/1.1,соединение больше не закрывается после завершения третьей фазы,и клиент теперь получает дополнительный запрос:это означает,что вторая и третья фазы теперь могут быть выполнены любое количество раз.</target>
        </trans-unit>
        <trans-unit id="3267856a66c8d58fa6c67469981a2b6478095c6a" translate="yes" xml:space="preserve">
          <source>As of June 2019, the &lt;a href=&quot;https://wicg.github.io/picture-in-picture/#feature-policy&quot;&gt;spec draft&lt;/a&gt; and &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=806249#c17&quot;&gt;Google Chrome&lt;/a&gt; set default allow list to &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06cf4063f7dac467fae6879bda8095e3ff5808d1" translate="yes" xml:space="preserve">
          <source>As seen above, the &lt;code&gt;noreferrer&lt;/code&gt; link relation is written without a dash &amp;mdash; &lt;code&gt;noreferrer&lt;/code&gt;. When the referrer policy is specified for the entire document with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element, it's written &lt;em&gt;with&lt;/em&gt; a dash: &lt;code&gt;&amp;lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10737eb038a18f448d914366beb682e160b36994" translate="yes" xml:space="preserve">
          <source>As seen earlier, in most cases, looking for the rendering engine is a better way to go. This will help to not exclude lesser known browsers. Browsers sharing a common rendering engine will display a page in the same way: it is often a fair assumption that what will work in one will work in the other.</source>
          <target state="translated">Как мы видели ранее,в большинстве случаев,поиск движка рендеринга-лучший способ.Это поможет не исключать менее известные браузеры.Браузеры,имеющие общий рендеринговый движок,будут отображать страницу таким же образом:часто справедливо предположить,что то,что будет работать в одном,будет работать в другом.</target>
        </trans-unit>
        <trans-unit id="78c188cf3444dcabae8c9d4a1f5961a9553d9194" translate="yes" xml:space="preserve">
          <source>As several representations of a given resource are sent, shared caches are less efficient and server implementations are more complex.</source>
          <target state="translated">По мере отправки нескольких представлений данного ресурса,общие кэши менее эффективны,а серверные реализации более сложны.</target>
        </trans-unit>
        <trans-unit id="7377d313a5ee9a8718b11c2ecd95fc7f352f8569" translate="yes" xml:space="preserve">
          <source>As the above code demonstrates, there is &lt;strong&gt;always &lt;/strong&gt;a way to test browser support on anything, no exceptions. There &lt;strong&gt;never &lt;/strong&gt;any reason to check the user string for this.</source>
          <target state="translated">Как показывает приведенный выше код, &lt;strong&gt;всегда&lt;/strong&gt; есть способ проверить поддержку браузера на чем угодно, без исключений. Там &lt;strong&gt;никогда не&lt;/strong&gt; какая - либо причины , чтобы проверить строку пользователя для этого.</target>
        </trans-unit>
        <trans-unit id="bd630c3d2c38cd17c79f057386bd9dee90389bcb" translate="yes" xml:space="preserve">
          <source>As the above code demonstrates, there is &lt;strong&gt;always&lt;/strong&gt; a way to test browser support without user agent sniffing. There is &lt;strong&gt;never&lt;/strong&gt; any reason to check the user agent string for this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1896c32232ae10635b0e9d7b6084cf07068dbb" translate="yes" xml:space="preserve">
          <source>As the name implies, a reverse proxy does the opposite of what a forward proxy does: A forward proxy acts in behalf of clients (or requesting hosts), a reverse proxy acts in behalf of servers. Forward proxies can hide the identities of clients whereas reverse proxies can hide the identities of servers. Reverse proxies have several use cases, a few are:</source>
          <target state="translated">Как следует из названия,реверсивный прокси делает то же самое,что и форвардный:Форвардный прокси действует от имени клиентов (или запрашивающих хосты),обратный-от имени серверов.Форвардные прокси могут скрывать идентификационные данные клиентов,в то время как реверсные прокси могут скрывать идентификационные данные серверов.Реверсивные прокси имеют несколько вариантов использования:</target>
        </trans-unit>
        <trans-unit id="40dbdc58bd286d3f6c3860a41b01365fe8a90574" translate="yes" xml:space="preserve">
          <source>As the name implies, a reverse proxy does the opposite of what a forward proxy does: A forward proxy acts on behalf of clients (or requesting hosts). Forward proxies can hide the identities of clients whereas reverse proxies can hide the identities of servers. Reverse proxies have several use cases, a few are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fdf182c8fbdda48a83dae747cba9e04f53c39b9" translate="yes" xml:space="preserve">
          <source>As the user ID and password are passed over the network as clear text (it is base64 encoded, but base64 is a reversible encoding), the basic authentication scheme &lt;strong&gt;is not secure&lt;/strong&gt;. HTTPS/TLS should be used with basic authentication. Without these additional security enhancements, basic authentication should not be used to protect sensitive or valuable information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444c366dc18e9c8a26e52d6d891adf57495dae72" translate="yes" xml:space="preserve">
          <source>As the user ID and password are passed over the network as clear text (it is base64 encoded, but base64 is a reversible encoding), the basic authentication scheme is not secure. HTTPS / TLS should be used in conjunction with basic authentication. Without these additional security enhancements, basic authentication should not be used to protect sensitive or valuable information.</source>
          <target state="translated">Так как идентификатор пользователя и пароль передаются по сети в виде чистого текста (это кодировка base64,но base64-обратимая кодировка),то основная схема аутентификации небезопасна.HTTPS/TLS следует использовать совместно с базовой аутентификацией.Без этих дополнительных улучшений безопасности базовая аутентификация не должна использоваться для защиты конфиденциальной или ценной информации.</target>
        </trans-unit>
        <trans-unit id="a6c3ae8778eda348525a5dd269ea2b796710e51f" translate="yes" xml:space="preserve">
          <source>As there is no uniformity of the different part of the user agent string, this is the tricky part.</source>
          <target state="translated">Так как нет однородности различной части строки пользовательского агента,это и есть хитрая часть.</target>
        </trans-unit>
        <trans-unit id="bc6ee085f0ae97c37cea4781b55609b159806f1f" translate="yes" xml:space="preserve">
          <source>As this policy is expressed via a &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Response_header&quot;&gt;response header&lt;/a&gt;&lt;/em&gt;, the actual request is not prevented&amp;mdash;rather, the browser prevents the &lt;em&gt;result&lt;/em&gt; from being leaked by stripping the response body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ddb1d34141f0f1a53b5fad16b4bdbb2de512647" translate="yes" xml:space="preserve">
          <source>As well as styles that are applied in JavaScript by setting the &lt;code&gt;style&lt;/code&gt; attribute directly, or by setting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/cssText&quot;&gt;&lt;code&gt;cssText&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17fdcd20e92320a37954cc0aaa2c4492b1c32a15" translate="yes" xml:space="preserve">
          <source>As well as styles that are applied in Javascript by setting the &lt;code&gt;style&lt;/code&gt; attribute directly, or by setting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/cssText&quot;&gt;&lt;code&gt;cssText&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">А также стили, которые применяются в Javascript путем непосредственной установки атрибута &lt;code&gt;style&lt;/code&gt; или установки &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/cssText&quot;&gt; &lt;code&gt;cssText&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d02d7f17a2dcce723df40692e0f522ac350d18cf" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;, input filtering is important.</source>
          <target state="translated">Как и в случае с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; , важна входная фильтрация.</target>
        </trans-unit>
        <trans-unit id="2ea5b0bb9c6a34b711f367b6b2d6d55f8f5e966a" translate="yes" xml:space="preserve">
          <source>As you can see, the report includes the full path to the violating resource in &lt;code&gt;blocked-uri&lt;/code&gt;. This is not always the case. For example, if the &lt;code&gt;signup.html&lt;/code&gt; attempted to load CSS from &lt;code&gt;http://anothercdn.example.com/stylesheet.css&lt;/code&gt;, the browser would &lt;em&gt;not&lt;/em&gt; include the full path, but only the origin (&lt;code&gt;http://anothercdn.example.com&lt;/code&gt;). The CSP specification &lt;a href=&quot;http://www.w3.org/TR/CSP/#security-violation-reports&quot;&gt;gives an explanation&lt;/a&gt; of this odd behaviour. In summary, this is done to prevent leaking sensitive information about cross-origin resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090adf7d66d69b3cc82ada8155a31b95b1d5cc05" translate="yes" xml:space="preserve">
          <source>As you can see, the report includes the full path to the violating resource in &lt;code&gt;blocked-uri&lt;/code&gt;. This is not always the case. For example, when the &lt;code&gt;signup.html&lt;/code&gt; would attempt to load CSS from &lt;a href=&quot;http://anothercdn.example.com/stylesheet.css&quot;&gt;&lt;code&gt;http://anothercdn.example.com/stylesheet.css&lt;/code&gt;&lt;/a&gt;, the browser would &lt;em&gt;not&lt;/em&gt; include the full path but only the origin (&lt;code&gt;http://anothercdn.example.com&lt;/code&gt;). The CSP specification &lt;a href=&quot;http://www.w3.org/TR/CSP/#security-violation-reports&quot;&gt;gives an explanation&lt;/a&gt; of this odd behaviour. In summary, this is done to prevent leaking sensitive information about cross-origin resources.</source>
          <target state="translated">Как видите, отчет включает в себя полный путь к нарушающему ресурсу в &lt;code&gt;blocked-uri&lt;/code&gt; . Это не всегда так. Например, когда &lt;code&gt;signup.html&lt;/code&gt; попытается загрузить CSS из &lt;a href=&quot;http://anothercdn.example.com/stylesheet.css&quot;&gt; &lt;code&gt;http://anothercdn.example.com/stylesheet.css&lt;/code&gt; &lt;/a&gt; , браузер &lt;em&gt;не&lt;/em&gt; будет включать полный путь, а только источник ( &lt;code&gt;http://anothercdn.example.com&lt;/code&gt; ). Спецификация CSP &lt;a href=&quot;http://www.w3.org/TR/CSP/#security-violation-reports&quot;&gt;дает объяснение&lt;/a&gt; этому странному поведению. Таким образом, это сделано для предотвращения утечки конфиденциальной информации о ресурсах из разных источников.</target>
        </trans-unit>
        <trans-unit id="ec92124be22f59c3429bab49ee1de958a60686bc" translate="yes" xml:space="preserve">
          <source>As you can see, the report includes the full path to the violating resource in &lt;code&gt;blocked-uri&lt;/code&gt;. This is not always the case. For example, when the &lt;code&gt;signup.html&lt;/code&gt; would attempt to load CSS from &lt;code&gt;http://anothercdn.example.com/stylesheet.css&lt;/code&gt;, the browser would &lt;em&gt;not&lt;/em&gt; include the full path but only the origin (&lt;code&gt;http://anothercdn.example.com&lt;/code&gt;). This is done to prevent leaking sensitive information about cross-origin resources.</source>
          <target state="translated">Как видите, отчет включает в себя полный путь к нарушающему ресурсу в &lt;code&gt;blocked-uri&lt;/code&gt; . Это не всегда так. Например, когда &lt;code&gt;signup.html&lt;/code&gt; попытается загрузить CSS из &lt;code&gt;http://anothercdn.example.com/stylesheet.css&lt;/code&gt; , браузер &lt;em&gt;не&lt;/em&gt; будет включать полный путь, а только источник ( &lt;code&gt;http://anothercdn.example.com&lt;/code&gt; ). Это сделано для предотвращения утечки конфиденциальной информации о ресурсах из разных источников.</target>
        </trans-unit>
        <trans-unit id="5181c200a5bc4c79427bf4adcaa2c1205fdeba26" translate="yes" xml:space="preserve">
          <source>Asserts that a cookie must not be sent with cross-origin requests, providing some protection against cross-site request forgery attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRF&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d2597783f8778af171536ba979953d5e5baf049" translate="yes" xml:space="preserve">
          <source>Associates a specific cryptographic public key with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates.</source>
          <target state="translated">Связывает конкретный криптографический открытый ключ с определенным веб-сервером, чтобы снизить риск атак &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; с поддельными сертификатами.</target>
        </trans-unit>
        <trans-unit id="4423c564a6dd958705092c9f3f6196baaeb909f9" translate="yes" xml:space="preserve">
          <source>At this point, a typical request and response looked like this:</source>
          <target state="translated">На данный момент типичный запрос и ответ выглядели следующим образом:</target>
        </trans-unit>
        <trans-unit id="640a65ab124efd895e7362db6ab879724f9f4606" translate="yes" xml:space="preserve">
          <source>Atom Entry and Feed Documents can contain XML Digital Signatures
   [&lt;a href=&quot;#ref-REC-xmldsig-core&quot;&gt;REC-xmldsig-core&lt;/a&gt;] and can be encrypted using XML Encryption
   [&lt;a href=&quot;#ref-REC-xmlenc-core&quot;&gt;REC-xmlenc-core&lt;/a&gt;] as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-5&quot;&gt;Section&amp;nbsp;5 of [RFC4287]&lt;/a&gt;.  Handling
   of signatures and encrypted elements in Atom documents is discussed
   in Sections &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; and &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].

   Neither servers nor clients are under any obligation to support
   encryption and digital signature of Entries or Feeds, although it is
   certainly possible that in some installations, clients or servers
   might require signing or encrypting of the documents exchanged in the
   Atom Protocol.

   Because servers are allowed (and in some cases, expected) to modify
   the contents of an Entry Document before publishing it, signatures
   within an entry are only likely to be useful to the server to which
   the entry is being sent.  Clients cannot assume that the signature
   will be valid when viewed by a third party, or even that the server
   will publish the client's signature.

   A server is allowed to strip client-applied signatures, to strip
   client-applied signatures and then re-sign with its own public key,
   and to oversign an entry with its own public key.  The meaning to a
   third party of a signature applied by a server is the same as a
   signature from anyone, as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].  It is RECOMMENDED
   that a server that is aware that it has changed any part of an Entry
   Document that was signed by the client should strip that signature
   before publishing the entry in order to prevent third parties from
   trying to interpret a signature that cannot be validated.</source>
          <target state="translated">Документы Atom Entry и Feed могут содержать цифровые подписи XML [ &lt;a href=&quot;#ref-REC-xmldsig-core&quot;&gt;REC-xmldsig-core&lt;/a&gt; ] и могут быть зашифрованы с использованием шифрования XML [ &lt;a href=&quot;#ref-REC-xmlenc-core&quot;&gt;REC-xmlenc-core&lt;/a&gt; ], как указано в &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-5&quot;&gt;разделе 5 [RFC4287]&lt;/a&gt; . Обработка подписей и зашифрованных элементов в документах Atom обсуждается в разделах &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; и &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287].&lt;/a&gt;]. Ни серверы, ни клиенты не обязаны поддерживать шифрование и цифровую подпись записей или каналов, хотя, безусловно, возможно, что в некоторых установках клиенты или серверы могут потребовать подписи или шифрования документов, которыми обмениваются по протоколу Atom. Поскольку серверам разрешено (а в некоторых случаях ожидается) изменять содержимое документа ввода перед его публикацией, подписи внутри записи могут быть полезны только серверу, на который отправляется запись. Клиенты не могут предполагать, что подпись будет действительной при просмотре третьей стороной, или даже что сервер опубликует подпись клиента. Серверу разрешено удалять подписи, применяемые клиентом, снимать подписи, применяемые клиентом, а затем повторно подписывать его собственным открытым ключом,и подписывать запись своим собственным открытым ключом. Значение подписи, применяемой сервером для третьей стороны, такое же, как подпись от кого-либо, как описано в [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]. РЕКОМЕНДУЕТСЯ, чтобы сервер, который знает, что он изменил любую часть входного документа, который был подписан клиентом, должен удалить эту подпись перед публикацией записи, чтобы предотвратить попытки третьих лиц интерпретировать подпись, которая не может быть проверена.</target>
        </trans-unit>
        <trans-unit id="c5aa3a3e4c19a0f5bd9d139cb1cf724de62f5c3f" translate="yes" xml:space="preserve">
          <source>Atom Feed and Entry Documents can contain XML External Entities as
   defined in Section 4.2.2 of [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].  Atom implementations are not
   required to load external entities.  External entities are subject to
   the same security concerns as any network operation and can alter the
   semantics of an Atom document.  The same issues exist for Resources
   linked to by Atom elements such as atom:link and atom:content.</source>
          <target state="translated">Документы Atom Feed и Entry могут содержать внешние объекты XML, как определено в разделе 4.2.2 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ]. Реализации Atom не требуются для загрузки внешних сущностей. Внешние объекты подвержены тем же проблемам безопасности, что и любая сетевая операция, и могут изменять семантику документа Atom. Те же проблемы существуют для ресурсов, связанных с такими элементами Atom, как atom: link и atom: content.</target>
        </trans-unit>
        <trans-unit id="eb39269091e71d2cf80365bde28208d78373e852" translate="yes" xml:space="preserve">
          <source>Atom Feed and Entry Documents can contain a broad range of content
   types including code that might be executable in some contexts.
   Malicious clients could attempt to attack servers or other clients by
   injecting code into a Collection Document's Entry or Media Resources.

   Server implementations are strongly encouraged to verify that client-
   supplied content is safe prior to accepting, processing, or
   publishing it.  In the case of HTML, experience indicates that
   verification based on a white list of acceptable content is more
   effective than a black list of forbidden content.

   Additional information about XHTML and HTML content safety can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-8.1&quot;&gt;Section&amp;nbsp;8.1 of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">Канал Atom и входные документы могут содержать широкий спектр типов контента, включая код, который может быть исполняемым в некоторых контекстах. Вредоносные клиенты могут попытаться атаковать серверы или других клиентов, внедряя код во вход документа коллекции или медиаресурсы. При реализации сервера настоятельно рекомендуется проверять безопасность предоставляемого клиентом контента перед его приемом, обработкой или публикацией. В случае HTML опыт показывает, что проверка на основе белого списка допустимого содержимого более эффективна, чем черный список запрещенного содержимого. Дополнительную информацию о безопасности содержимого XHTML и HTML можно найти в &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-8.1&quot;&gt;разделе 8.1 [RFC4287]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f30f294721759bc8f3b4c8af76920be111f1ebd" translate="yes" xml:space="preserve">
          <source>Atom Protocol Document formats are specified in terms of the XML
   Information Set [&lt;a href=&quot;#ref-REC-xml-infoset&quot;&gt;REC-xml-infoset&lt;/a&gt;], serialized as XML 1.0 [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].

   The Infoset terms &quot;Element Information Item&quot; and &quot;Attribute
   Information Item&quot; are shortened to &quot;element&quot; and &quot;attribute&quot;
   respectively.  Therefore, when this specification uses the term
   &quot;element&quot;, it is referring to an Element Information Item, and when
   it uses the term &quot;attribute&quot;, it is referring to an Attribute
   Information Item.</source>
          <target state="translated">Форматы документов протокола Atom определены в виде набора информации XML [ &lt;a href=&quot;#ref-REC-xml-infoset&quot;&gt;REC-xml-infoset&lt;/a&gt; ], сериализованного как XML 1.0 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ]. Термины информационного набора &amp;laquo;элемент информации об элементе&amp;raquo; и &amp;laquo;элемент информации об атрибуте&amp;raquo; сокращаются до &amp;laquo;элемент&amp;raquo; и &amp;laquo;атрибут&amp;raquo; соответственно. Следовательно, когда в этой спецификации используется термин &amp;laquo;элемент&amp;raquo;, он относится к элементу информации об элементе, а когда в ней используется термин &amp;laquo;атрибут&amp;raquo;, он относится к элементу информации об атрибуте.</target>
        </trans-unit>
        <trans-unit id="2e1b50db6b134e88169d0061fffd21c5907dcc49" translate="yes" xml:space="preserve">
          <source>Atom Protocol documents allow the use of IRIs [&lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt;] as well as
   URIs [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;] to identify Resources.  Before an IRI in a document is
   used by HTTP, the IRI is first converted to a URI according to the
   procedure defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3987#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC3987]&lt;/a&gt;.  In accordance with
   that specification, the conversion SHOULD be applied as late as
   possible.  Conversion does not imply Resource creation -- the IRI and
   the URI into which it is converted identify the same Resource.

   While the Atom Protocol specifies the formats of the representations
   that are exchanged and the actions that can be performed on the IRIs
   embedded in those representations, it does not constrain the form of
   the URIs that are used.  HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] specifies that the URI space
   of each server is controlled by that server, and this protocol
   imposes no further constraints on that control.</source>
          <target state="translated">Документы протокола Atom позволяют использовать IRI [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt; ], а также URI [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ] для идентификации ресурсов. Прежде чем IRI в документе будет использоваться HTTP, IRI сначала преобразуется в URI в соответствии с процедурой, определенной в &lt;a href=&quot;https://tools.ietf.org/html/rfc3987#section-3.1&quot;&gt;разделе 3.1 [RFC3987]&lt;/a&gt; . В соответствии с этой спецификацией преобразование СЛЕДУЕТ применять как можно позже. Преобразование не подразумевает создание ресурса - IRI и URI, в который он преобразован, идентифицируют один и тот же ресурс. Хотя протокол Atom определяет форматы представлений, которыми обмениваются, и действия, которые могут выполняться с IRI, встроенными в эти представления, он не ограничивает форму используемых URI. HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] указывает, что пространство URI каждого сервера контролируется этим сервером, и этот протокол не налагает дополнительных ограничений на этот элемент управления.</target>
        </trans-unit>
        <trans-unit id="736c134a608fda6f7298f3bba3cfd72a9fdecd9a" translate="yes" xml:space="preserve">
          <source>Atom Publishing Protocol implementations are susceptible to a variety
   of spoofing attacks.  Malicious clients might send Atom Entries
   containing inaccurate information anywhere in the document.</source>
          <target state="translated">Реализации протокола публикации атомов подвержены различным атакам спуфинга.Вредоносные клиенты могут посылать Atom Entries,содержащие неточную информацию,куда угодно в документе.</target>
        </trans-unit>
        <trans-unit id="bcde284149405876b277c263099cd3f0fe408f3d" translate="yes" xml:space="preserve">
          <source>Atom Publishing Protocol implementations handle URIs and IRIs.  See
   &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-7&quot;&gt;Section&amp;nbsp;7 of [RFC3986]&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc3987#section-8&quot;&gt;Section&amp;nbsp;8 of [RFC3987]&lt;/a&gt; for security
   considerations related to their handling and use. 

   The Atom Publishing Protocol leaves the server in control of minting
   URIs.  The use of any client-supplied data for creating new URIs is
   subject to the same concerns as described in the next section.</source>
          <target state="translated">Реализации протокола публикации Atom обрабатывают URI и IRI. См. &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-7&quot;&gt;Раздел 7 [RFC3986]&lt;/a&gt; и &lt;a href=&quot;https://tools.ietf.org/html/rfc3987#section-8&quot;&gt;раздел 8 [RFC3987]&lt;/a&gt; для ознакомления с соображениями безопасности, связанными с их обработкой и использованием. Протокол публикации Atom оставляет за сервером контроль над созданием URI. Использование любых данных, предоставленных клиентом, для создания новых URI связано с теми же проблемами, что описаны в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="43c64fa2cad1ec9b5d7097b9637cf7e73d027deb" translate="yes" xml:space="preserve">
          <source>Atom Publishing Protocol server implementations are susceptible to
   replay attacks.  Specifically, this specification does not define a
   means of detecting duplicate requests.  Accidentally sent duplicate
   requests are indistinguishable from intentional and malicious replay
   attacks.</source>
          <target state="translated">Реализации серверов Atom Publishing Protocol подвержены повторным атакам.В частности,данная спецификация не определяет средства обнаружения дублирующих запросов.Случайно отправленные дубликаты запросов неотличимы от преднамеренных и злонамеренных повторных атак.</target>
        </trans-unit>
        <trans-unit id="2972250359d4c37b4863cb1f87236835622705f3" translate="yes" xml:space="preserve">
          <source>Atom Publishing Protocol server implementations need to take adequate
   precautions to ensure malicious clients cannot consume excessive
   server resources (CPU, memory, disk, etc.).</source>
          <target state="translated">Реализации серверов Atom Publishing Protocol должны принимать адекватные меры предосторожности,чтобы гарантировать,что вредоносные клиенты не смогут потреблять чрезмерные ресурсы сервера (процессор,память,диск и т.д.).</target>
        </trans-unit>
        <trans-unit id="8c002bc6355801197a02bfae106d0ff5c2ac8619" translate="yes" xml:space="preserve">
          <source>Attribute Value:  edit

   Description:  An IRI of an editable Member Entry.  When appearing
      within an atom:entry, the href IRI can be used to retrieve,
      update, and delete the Resource represented by that Entry.

   Expected display characteristics:  Undefined; this relation can be
      used for background processing or to provide extended
      functionality without displaying its value.

   Security considerations:  Automated agents should take care when this
      relation crosses administrative domains (e.g., the URI has a
      different authority than the current document).</source>
          <target state="translated">Значение атрибута:редактировать Описание:IRI редактируемой записи члена.При появлении в atom:entry,href IRI может быть использован для получения,обновления и удаления ресурса,представленного этой записью.Ожидаемые характеристики отображения:Не определено;это отношение может быть использовано для фоновой обработки или для обеспечения расширенной функциональности без отображения ее значения.Соображения безопасности:Автоматизированные агенты должны позаботиться о том,чтобы это отношение пересекало административные домены (например,URI имеет иной авторитет,чем текущий документ).</target>
        </trans-unit>
        <trans-unit id="37137689e8aac586d2a2206e3451c0c78ed0404b" translate="yes" xml:space="preserve">
          <source>Attribute Value:  edit-media

   Description:  An IRI of an editable Media Resource.  When appearing
      within an atom:entry, the href IRI can be used to retrieve,
      update, and delete the Media Resource associated with that Entry.

   Expected display characteristics:  Undefined; this relation can be
      used for background processing or to provide extended
      functionality without displaying its value.

   Security considerations:  Automated agents should take care when this
      relation crosses administrative domains (e.g., the URI has a
      different authority than the current document).</source>
          <target state="translated">Значение атрибута:edit-media Описание:IRI редактируемого медиа-ресурса.При появлении в atom:entry,href IRI может быть использован для получения,обновления и удаления Медиа-ресурса,связанного с этой записью.Ожидаемые характеристики отображения:Не определено;это отношение может быть использовано для фоновой обработки или для обеспечения расширенных функциональных возможностей без отображения его значения.Соображения безопасности:Автоматизированные агенты должны позаботиться о том,чтобы это отношение пересекало административные домены (например,URI имеет иной авторитет,чем текущий документ).</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="f249c1f3c78b5d8dfebf667cc36b2ac178b2dfce" translate="yes" xml:space="preserve">
          <source>Audio and video types</source>
          <target state="translated">Типы аудио и видео</target>
        </trans-unit>
        <trans-unit id="e6d4341caf182975ff694c881dad755bd726c7a8" translate="yes" xml:space="preserve">
          <source>Audio and video. Only resources with the correct MIME Type will be played in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; elements. Be sure to &lt;a href=&quot;https://developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements&quot;&gt;use the correct type for audio and video&lt;/a&gt;.</source>
          <target state="translated">Аудио и видео. В элементах &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; будут воспроизводиться только ресурсы с правильным типом MIME . Убедитесь, что вы &lt;a href=&quot;https://developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements&quot;&gt;используете правильный тип для аудио и видео&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7e617aec809a52d5e6a3a74811a5f9fd204a3f1" translate="yes" xml:space="preserve">
          <source>Audio and video. Only resources with the correct MIME Type will be played in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; elements. Be sure to specify the correct &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats&quot;&gt;media type for audio and video&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76247395f996d3bf715facd1a789b21b73e56939" translate="yes" xml:space="preserve">
          <source>Audio or music data. Examples include &lt;code&gt;audio/mpeg&lt;/code&gt;, &lt;code&gt;audio/vorbis&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147b0d392949573e61339af923f0d61f3d4158e3" translate="yes" xml:space="preserve">
          <source>Audio or video type</source>
          <target state="translated">Тип аудио или видео</target>
        </trans-unit>
        <trans-unit id="ee1acfa55eb1476c86c5c4a68f256a67b25289ab" translate="yes" xml:space="preserve">
          <source>Authentication</source>
          <target state="translated">Authentication</target>
        </trans-unit>
        <trans-unit id="fc6c8170f13d7b26f5b4b7880a4d642545c57a00" translate="yes" xml:space="preserve">
          <source>Authentication challenges indicate what mechanisms are available for
   the client to provide authentication credentials in future requests.

   +--------------------+--------------------------+
   | Header Field Name  | Defined in...            |
   +--------------------+--------------------------+
   | WWW-Authenticate   | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7235]&lt;/a&gt; |
   | Proxy-Authenticate | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.3&quot;&gt;Section&amp;nbsp;4.3 of [RFC7235]&lt;/a&gt; |
   +--------------------+--------------------------+</source>
          <target state="translated">Проблемы аутентификации указывают, какие механизмы доступны для клиента для предоставления учетных данных аутентификации в будущих запросах. + -------------------- + -------------------------- + | Имя поля заголовка | Определено в ... | + -------------------- + -------------------------- + | WWW-аутентификация | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.1&quot;&gt;Раздел 4.1 [RFC7235]&lt;/a&gt; | | Прокси-аутентификация | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.3&quot;&gt;Раздел 4.3 [RFC7235]&lt;/a&gt; | + -------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="153bcddcdfb94a1c4fcc1b07386bec94f199b549" translate="yes" xml:space="preserve">
          <source>Authentication of cross-origin images</source>
          <target state="translated">Аутентификация перекрестных изображений</target>
        </trans-unit>
        <trans-unit id="76f2d621f56ba98464057328fa277805b179a4c3" translate="yes" xml:space="preserve">
          <source>Authentication schemes</source>
          <target state="translated">Схемы аутентификации</target>
        </trans-unit>
        <trans-unit id="82c6eeec306dfcdeb221624f2ddf32ce5652cd2a" translate="yes" xml:space="preserve">
          <source>Authentication schemes that solely rely on the &quot;realm&quot; mechanism for
   establishing a protection space will expose credentials to all
   resources on an origin server.  Clients that have successfully made
   authenticated requests with a resource can use the same
   authentication credentials for other resources on the same origin
   server.  This makes it possible for a different resource to harvest
   authentication credentials for other resources.

   This is of particular concern when an origin server hosts resources
   for multiple parties under the same canonical root URI (&lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;).
   Possible mitigation strategies include restricting direct access to
   authentication credentials (i.e., not making the content of the
   Authorization request header field available), and separating
   protection spaces by using a different host name (or port number) for
   each party.</source>
          <target state="translated">Схемы аутентификации, которые полагаются исключительно на механизм &amp;laquo;области&amp;raquo; для создания пространства защиты, будут предоставлять учетные данные всем ресурсам на исходном сервере. Клиенты, которые успешно выполнили аутентифицированные запросы к ресурсу, могут использовать те же учетные данные аутентификации для других ресурсов на том же исходном сервере. Это позволяет другому ресурсу собирать учетные данные аутентификации для других ресурсов. Это вызывает особую озабоченность, когда исходный сервер размещает ресурсы для нескольких сторон под одним и тем же каноническим корневым URI ( &lt;a href=&quot;#section-2.2&quot;&gt;раздел 2.2.&lt;/a&gt;). Возможные стратегии смягчения последствий включают ограничение прямого доступа к учетным данным аутентификации (т. Е. Запрет на доступ к содержимому поля заголовка запроса авторизации) и разделение пространств защиты путем использования разных имен хостов (или номеров портов) для каждой стороны.</target>
        </trans-unit>
        <trans-unit id="7e8fe0af4751860c096cd4a38e3b9eeae02683be" translate="yes" xml:space="preserve">
          <source>Authentification for AWS servers (&lt;code&gt;AWS4-HMAC-SHA256&lt;/code&gt;)</source>
          <target state="translated">Аутентификация для серверов AWS ( &lt;code&gt;AWS4-HMAC-SHA256&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="97a9869cf89f831749f9533eebd33a7ff2d561cb" translate="yes" xml:space="preserve">
          <source>Authority</source>
          <target state="translated">Authority</target>
        </trans-unit>
        <trans-unit id="5e25ce007aa95ea2ea8b158aee9c630a32ea5616" translate="yes" xml:space="preserve">
          <source>Authorization</source>
          <target state="translated">Authorization</target>
        </trans-unit>
        <trans-unit id="3224c382af3d5fca4ce96ea1f1e751cb8cb2158f" translate="yes" xml:space="preserve">
          <source>Authorization (RFC 2616)</source>
          <target state="translated">Разрешение (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="bae9490e931f2a313f9d9d7c5b0605ca243c7183" translate="yes" xml:space="preserve">
          <source>Authorization (RFC 7235)</source>
          <target state="translated">Авторизация (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="d4fee4c08f75764f9229f565110251d77f383d11" translate="yes" xml:space="preserve">
          <source>Authorization and Proxy-Authorization headers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95619b532fe893a1b62f3f25950021c4a689dd4d" translate="yes" xml:space="preserve">
          <source>Autoplay</source>
          <target state="translated">Autoplay</target>
        </trans-unit>
        <trans-unit id="68600483f20f1dc6f59f6bc5af1b4286e5f91bc8" translate="yes" xml:space="preserve">
          <source>Avoid overly-detailed &lt;code&gt;Server&lt;/code&gt; values, as they can reveal information that might make it (slightly) easier for attackers to exploit known security holes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdb07e7f031ea64baa50d4fba0ccadf646f5986" translate="yes" xml:space="preserve">
          <source>Avoiding COEP blockage with CORS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2caaa3b5ae832f6f7280b3a4c0e89023587c880" translate="yes" xml:space="preserve">
          <source>Avoiding mid-air collisions</source>
          <target state="translated">Предотвращение столкновений в воздухе</target>
        </trans-unit>
        <trans-unit id="cff193e7487bbc8578fa13e29841eaf30a9bedc1" translate="yes" xml:space="preserve">
          <source>Avoiding the lost update problem with optimistic locking</source>
          <target state="translated">Предотвращение проблемы потерянных обновлений с оптимистической блокировкой</target>
        </trans-unit>
        <trans-unit id="8d576102d4917836a687b68a54b6ec02b0270e5d" translate="yes" xml:space="preserve">
          <source>Avoiding user agent detection</source>
          <target state="translated">Избежать обнаружения агента пользователя</target>
        </trans-unit>
        <trans-unit id="76b2165174f526621c2ceebcd2a4d6f508b46aba" translate="yes" xml:space="preserve">
          <source>BCP 47</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8306a543f91f1fd548cb382031a57ef6cd3bdffb" translate="yes" xml:space="preserve">
          <source>BMP</source>
          <target state="translated">BMP</target>
        </trans-unit>
        <trans-unit id="ecd4ecba402cd2d1689af61cc723efcbd052a8bf" translate="yes" xml:space="preserve">
          <source>BWS = OWS

   Connection = *( &quot;,&quot; OWS ) connection-option *( OWS &quot;,&quot; [ OWS
    connection-option ] )

   Content-Length = 1*DIGIT

   HTTP-message = start-line *( header-field CRLF ) CRLF [ message-body
    ]
   HTTP-name = %x48.54.54.50 ; HTTP
   HTTP-version = HTTP-name &quot;/&quot; DIGIT &quot;.&quot; DIGIT
   Host = uri-host [ &quot;:&quot; port ]

   OWS = *( SP / HTAB )

   RWS = 1*( SP / HTAB )

   TE = [ ( &quot;,&quot; / t-codings ) *( OWS &quot;,&quot; [ OWS t-codings ] ) ]
   Trailer = *( &quot;,&quot; OWS ) field-name *( OWS &quot;,&quot; [ OWS field-name ] )
   Transfer-Encoding = *( &quot;,&quot; OWS ) transfer-coding *( OWS &quot;,&quot; [ OWS
    transfer-coding ] )

   URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.1&quot;&gt;[RFC3986], Section&amp;nbsp;4.1&lt;/a&gt;&amp;gt;
   Upgrade = *( &quot;,&quot; OWS ) protocol *( OWS &quot;,&quot; [ OWS protocol ] )

   Via = *( &quot;,&quot; OWS ) ( received-protocol RWS received-by [ RWS comment
    ] ) *( OWS &quot;,&quot; [ OWS ( received-protocol RWS received-by [ RWS
    comment ] ) ] )

   absolute-URI = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986], Section&amp;nbsp;4.3&lt;/a&gt;&amp;gt;
   absolute-form = absolute-URI
   absolute-path = 1*( &quot;/&quot; segment )
   asterisk-form = &quot;*&quot;
   authority = &amp;lt;authority, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
   authority-form = authority 

   chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF
   chunk-data = 1*OCTET
   chunk-ext = *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )
   chunk-ext-name = token
   chunk-ext-val = token / quoted-string
   chunk-size = 1*HEXDIG
   chunked-body = *chunk last-chunk trailer-part CRLF
   comment = &quot;(&quot; *( ctext / quoted-pair / comment ) &quot;)&quot;
   connection-option = token
   ctext = HTAB / SP / %x21-27 ; '!'-'''
    / %x2A-5B ; '*'-'['
    / %x5D-7E ; ']'-'~'
    / obs-text

   field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
   field-name = token
   field-value = *( field-content / obs-fold )
   field-vchar = VCHAR / obs-text
   fragment = &amp;lt;fragment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], Section&amp;nbsp;3.5&lt;/a&gt;&amp;gt;

   header-field = field-name &quot;:&quot; OWS field-value OWS
   http-URI = &quot;http://&quot; authority path-abempty [ &quot;?&quot; query ] [ &quot;#&quot;
    fragment ]
   https-URI = &quot;https://&quot; authority path-abempty [ &quot;?&quot; query ] [ &quot;#&quot;
    fragment ]

   last-chunk = 1*&quot;0&quot; [ chunk-ext ] CRLF

   message-body = *OCTET
   method = token

   obs-fold = CRLF 1*( SP / HTAB )
   obs-text = %x80-FF
   origin-form = absolute-path [ &quot;?&quot; query ]

   partial-URI = relative-part [ &quot;?&quot; query ]
   path-abempty = &amp;lt;path-abempty, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.3&lt;/a&gt;&amp;gt;
   port = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
   protocol = protocol-name [ &quot;/&quot; protocol-version ]
   protocol-name = token
   protocol-version = token
   pseudonym = token

   qdtext = HTAB / SP / &quot;!&quot; / %x23-5B ; '#'-'['
    / %x5D-7E ; ']'-'~'
    / obs-text
   query = &amp;lt;query, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.4&quot;&gt;[RFC3986], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;
   quoted-pair = &quot;\&quot; ( HTAB / SP / VCHAR / obs-text ) 

   quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE

   rank = ( &quot;0&quot; [ &quot;.&quot; *3DIGIT ] ) / ( &quot;1&quot; [ &quot;.&quot; *3&quot;0&quot; ] )
   reason-phrase = *( HTAB / SP / VCHAR / obs-text )
   received-by = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
   received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
   relative-part = &amp;lt;relative-part, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], Section&amp;nbsp;4.2&lt;/a&gt;&amp;gt;
   request-line = method SP request-target SP HTTP-version CRLF
   request-target = origin-form / absolute-form / authority-form /
    asterisk-form

   scheme = &amp;lt;scheme, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986], Section&amp;nbsp;3.1&lt;/a&gt;&amp;gt;
   segment = &amp;lt;segment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.3&lt;/a&gt;&amp;gt;
   start-line = request-line / status-line
   status-code = 3DIGIT
   status-line = HTTP-version SP status-code SP reason-phrase CRLF

   t-codings = &quot;trailers&quot; / ( transfer-coding [ t-ranking ] )
   t-ranking = OWS &quot;;&quot; OWS &quot;q=&quot; rank
   tchar = &quot;!&quot; / &quot;#&quot; / &quot;$&quot; / &quot;%&quot; / &quot;&amp;amp;&quot; / &quot;'&quot; / &quot;*&quot; / &quot;+&quot; / &quot;-&quot; / &quot;.&quot; /
    &quot;^&quot; / &quot;_&quot; / &quot;`&quot; / &quot;|&quot; / &quot;~&quot; / DIGIT / ALPHA
   token = 1*tchar
   trailer-part = *( header-field CRLF )
   transfer-coding = &quot;chunked&quot; / &quot;compress&quot; / &quot;deflate&quot; / &quot;gzip&quot; /
    transfer-extension
   transfer-extension = token *( OWS &quot;;&quot; OWS transfer-parameter )
   transfer-parameter = token BWS &quot;=&quot; BWS ( token / quoted-string )

   uri-host = &amp;lt;host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.2&lt;/a&gt;&amp;gt; 

Index

   A
      absolute-form (of request-target)  42
      accelerator  10
      application/http Media Type  63
      asterisk-form (of request-target)  43
      authoritative response  67
      authority-form (of request-target)  42-43

   B
      browser  7

   C
      cache  11
      cacheable  12
      captive portal  11
      chunked (Coding Format)  28, 32, 36
      client  7
      close  51, 56
      compress (Coding Format)  38
      connection  7
      Connection header field  51, 56
      Content-Length header field  30

   D
      deflate (Coding Format)  38
      Delimiters  27
      downstream  10

   E
      effective request URI  45

   G
      gateway  10
      Grammar
         absolute-form  42
         absolute-path  16
         absolute-URI  16
         ALPHA  6
         asterisk-form  41, 43
         authority  16
         authority-form  42-43
         BWS  25
         chunk  36
         chunk-data  36
         chunk-ext  36
         chunk-ext-name  36 

         chunk-ext-val  36
         chunk-size  36
         chunked-body  36
         comment  27
         Connection  51
         connection-option  51
         Content-Length  30
         CR  6
         CRLF  6
         ctext  27
         CTL  6
         DIGIT  6
         DQUOTE  6
         field-content  23
         field-name  23, 40
         field-value  23
         field-vchar  23
         fragment  16
         header-field  23, 37
         HEXDIG  6
         Host  44
         HTAB  6
         HTTP-message  19
         HTTP-name  14
         http-URI  17
         HTTP-version  14
         https-URI  18
         last-chunk  36
         LF  6
         message-body  28
         method  21
         obs-fold  23
         obs-text  27
         OCTET  6
         origin-form  42
         OWS  25
         partial-URI  16
         port  16
         protocol-name  47
         protocol-version  47
         pseudonym  47
         qdtext  27
         query  16
         quoted-pair  27
         quoted-string  27
         rank  39
         reason-phrase  22
         received-by  47 

         received-protocol  47
         request-line  21
         request-target  41
         RWS  25
         scheme  16
         segment  16
         SP  6
         start-line  21
         status-code  22
         status-line  22
         t-codings  39
         t-ranking  39
         tchar  27
         TE  39
         token  27
         Trailer  40
         trailer-part  37
         transfer-coding  35
         Transfer-Encoding  28
         transfer-extension  35
         transfer-parameter  35
         Upgrade  57
         uri-host  16
         URI-reference  16
         VCHAR  6
         Via  47
      gzip (Coding Format)  39

   H
      header field  19
      header section  19
      headers  19
      Host header field  44
      http URI scheme  17
      https URI scheme  17
   I
      inbound  9
      interception proxy  11
      intermediary  9

   M
      Media Type
         application/http  63
         message/http  62
      message  7
      message/http Media Type  62
      method  21 

   N
      non-transforming proxy  49

   O
      origin server  7
      origin-form (of request-target)  42
      outbound  10

   P
      phishing  67
      proxy  10

   R
      recipient  7
      request  7
      request-target  21
      resource  16
      response  7
      reverse proxy  10

   S
      sender  7
      server  7
      spider  7

   T
      target resource  40
      target URI  40
      TE header field  39
      Trailer header field  40
      Transfer-Encoding header field  28
      transforming proxy  49
      transparent proxy  11
      tunnel  10

   U
      Upgrade header field  57
      upstream  9
      URI scheme
         http  17
         https  17
      user agent  7

   V
      Via header field  47 

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding &amp;amp; Reschke           Standards Track                   [Page 89]</source>
          <target state="translated">BWS = OWS Connection = * (&quot;,&quot; OWS) опция подключения * (OWS &quot;,&quot; [OWS connection-option]) Content-Length = 1 * ЦИФРОВОЕ HTTP-сообщение = начальная строка * (поле заголовка CRLF) CRLF [тело сообщения] HTTP-имя =% x48.54.54.50; HTTP HTTP-версия = HTTP-имя &quot;/&quot; ЦИФРА &quot;.&quot; DIGIT Host = uri-host [&quot;:&quot; порт] OWS = * (SP / HTAB) RWS = 1 * (SP / HTAB) TE = [(&quot;,&quot; / t-codings) * (OWS &quot;,&quot; [OWS t -codings])] Trailer = * (&quot;,&quot; OWS) имя-поля * (OWS &quot;,&quot; [OWS field-name]) Transfer-Encoding = * (&quot;,&quot; OWS) transfer-coding * (OWS &quot;,&quot; [Кодирование передачи OWS]) URI-ссылка = &amp;lt;URI-ссылка, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.1&quot;&gt;[RFC3986], раздел 4.1.&lt;/a&gt;&amp;gt; Upgrade = * (&quot;,&quot; OWS) протокол * (OWS &quot;,&quot; [OWS protocol]) Через = * (&quot;,&quot; OWS) (получено-протокол RWS получено [комментарий RWS]) * (OWS &quot;,&quot; [OWS (RWS полученного протокола, полученного [комментарий RWS])]) absolute-URI = &amp;lt;absolute-URI, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986], раздел 4.3&lt;/a&gt; &amp;gt; absolute-form = absolute-URI absolute-path = 1 * (&quot;/ &quot;сегмент) asterisk-form =&quot; * &quot;авторитет = &amp;lt;авторитет, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986], раздел 3.2&lt;/a&gt;&amp;gt; Author-form = Authority chunk = chunk-size [chunk-ext] CRLF chunk-data CRLF chunk-data = 1 * OCTET chunk-ext = * (&quot;;&quot; chunk-ext-name [&quot;=&quot; chunk-ext- val]) chunk-ext-name = token chunk-ext-val = token / quoted-string chunk-size = 1 * HEXDIG chunked-body = * chunk last-chunk часть-трейлер CRLF comment = &quot;(&quot; * (ctext / пара кавычек / комментарий) &quot;)&quot; параметр-подключения = токен ctext = HTAB / SP /% x21-27; '!' - '' '/% x2A-5B; '*' - '[' /% x5D-7E; ']' - '~' / obs-text field-content = field-vchar [1 * (SP / HTAB) field-vchar] field-name = token field-value = * (field-content / obs-fold) поле -vchar = VCHAR / obs-text fragment = &amp;lt;fragment, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], раздел 3.5&lt;/a&gt;&amp;gt; header-field = field-name &quot;:&quot; Значение поля OWS OWS http-URI = &quot;http: //&quot; abempty [&quot;?&quot; query] [фрагмент &quot;#&quot;] https-URI = &quot;https: //&quot; путь к авторизации-abempty [&quot;?&quot; query] [фрагмент &quot;#&quot;] last-chunk = 1 * &quot;0&quot; [chunk-ext] CRLF message-body = * OCTET method = token obs-fold = CRLF 1 * (SP / HTAB) obs-text =% x80 -FF origin-form = absolute-path [&quot;?&quot; запрос] partial-URI = relative-part [&quot;?&quot; query] path-abempty = &amp;lt;path-abempty, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], раздел 3.3&lt;/a&gt; &amp;gt; port = &amp;lt;port, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.3&quot;&gt;[RFC3986], раздел 3.2.3&lt;/a&gt;&amp;gt; protocol = имя-протокола [&quot;/&quot; версия-протокола] имя-протокола = токен версия-протокола = токен псевдоним = токен qdtext = HTAB / SP / &quot;!&quot; /% x23-5B; '#' - '[' /% x5D-7E; ']' - '~' / obs-text query = &amp;lt;query, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.4&quot;&gt;[RFC3986], раздел 3.4&lt;/a&gt; &amp;gt; quoted-pair = &quot;\&quot; (HTAB / SP / VCHAR / obs-text) quoted-string = DQUOTE * (qdtext / quoted-pair) DQUOTE rank = (&quot;0&quot; [&quot;.&quot; * 3DIGIT]) / (&quot;1&quot; [&quot;.&quot; * 3 &quot;0&quot;]) причина-фраза = * (HTAB / SP / VCHAR / obs- текст) полученный = (uri-host [&quot;:&quot; порт]) / псевдоним полученный-протокол = [имя-протокола &quot;/&quot;] версия-протокола относительная-часть = &amp;lt;относительная-часть, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], раздел 4.2&lt;/a&gt;&amp;gt; строка-запроса = метод ЦП-запроса SP Версия HTTP-запроса CRLF-цель-запроса = форма-источника / абсолютная-форма / форма-полномочий / форма-звездочки схема = &amp;lt;схема, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986], раздел 3.1&lt;/a&gt; &amp;gt; сегмент = &amp;lt; сегмент, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], раздел 3.3&lt;/a&gt;&amp;gt; start-line = request-line / status-line status-code = 3DIGIT status-line = HTTP-версия SP status-code SP-причина-фраза CRLF t-codings = &quot;trailers&quot; / (кодирование передачи [t-rank] ) t-rank = OWS &quot;;&quot; OWS &quot;q =&quot; rank tchar = &quot;!&quot; / &quot;#&quot; / &quot;$&quot; / &quot;%&quot; / &quot;&amp;amp;&quot; / &quot;'&quot; / &quot;*&quot; / &quot;+&quot; / &quot;-&quot; / &quot;.&quot; / &quot;^&quot; / &quot;_&quot; / &quot;` &quot;/&quot; | &quot; / &quot;~&quot; / DIGIT / ALPHA token = 1 * tchar Trailer-part = * (поле заголовка CRLF) transfer-coding = &quot;chunked&quot; / &quot;compress&quot; / &quot;deflate&quot; / &quot;gzip&quot; / transfer-extension transfer-extension = токен * (OWS &quot;;&quot; параметр передачи OWS) параметр передачи = токен BWS &quot;= &quot;BWS (токен / строка в кавычках) uri-host = &amp;lt;host, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], раздел 3.2.2.&lt;/a&gt;&amp;gt; Индекс Абсолютная форма (целевой-запроса) 42 ускоритель 10 приложение / http Тип носителя 63 звездочка-форма (целевой-запроса) 43 авторитетный ответ 67 авторитетная форма (целевой-запроса) 42-43 B браузер 7 C кэш 11 кэшируемый 12 захватывающий портал 11 фрагментированный (формат кодирования) 28, 32, 36 клиент 7 закрытие 51, 56 сжатие (формат кодирования) 38 соединение 7 поле заголовка соединения 51, 56 поле заголовка Content-Length 30 D deflate (формат кодирования) 38 Разделители 27 в нисходящем направлении 10 E эффективный URI запроса 45 шлюз G 10 Грамматика в абсолютной форме 42 абсолютный путь 16 абсолютный URI 16 АЛЬФА 6 в форме звездочки 41,43 авторитет 16 авторитетная форма 42-43 BWS 25 фрагмент 36 данные фрагмента 36 расширенный фрагмент 36 расширенное имя фрагмента 36 расширение фрагмента 36 размер фрагмента 36 тело фрагмента 36 комментарий 27 Соединение 51 параметр подключения 51 Содержимое -Length 30 CR 6 CRLF 6 ctext 27 CTL 6 DIGIT 6 DQUOTE 6 field-content 23 field-name 23, 40 field-value 23 field-vchar 23 fragment 16 header-field 23,37 HEXDIG 6 Host 44 HTAB 6 HTTP-сообщение 19 HTTP-имя 14 http-URI 17 HTTP-версия 14 https-URI 18 последний блок 36 LF 6 тело сообщения 28 метод 21 obs-fold 23 obs-text 27 OCTET 6 origin -form 42 OWS 25 частичный URI 16 порт 16 имя-протокола 47 версия-протокола 47 псевдоним 47 qdtext 27 запрос 16 пара в кавычках 27 строка в кавычках 27 ранг 39 фраза-причина 22 получено-47 получено-протокол 47 строка запроса 21 цель-запрос 41 RWS 25 схема 16 сегмент 16 SP 6 начальная строка 21 код состояния22 строка состояния 22 t-кодировки 39 t-ранжирование 39 tchar 27 TE 39 токен 27 трейлер 40 часть трейлера 37 кодирование передачи 35 кодирование передачи 28 расширение передачи 35 параметр передачи 35 Обновление 57 uri-host 16 URI-ссылка 16 VCHAR 6 Через 47 gzip (формат кодирования) 39 поле заголовка H 19 раздел заголовка 19 заголовков 19 поле заголовка хоста 44 схема http URI 17 схема https URI 17 I входящий 9 прокси перехвата 11 посредник 9 M тип носителя приложение / http 63 сообщение / http 62 сообщение 7 сообщение / HTTP Тип носителя 62 метод 21 N прокси без преобразования 49 Oисходный сервер 7 исходная форма (запрос-цель) 42 исходящий 10 P фишинг 67 прокси 10 R получатель 7 запрос 7 запрос-цель 21 ресурс 16 ответ 7 обратный прокси 10 S отправитель 7 сервер 7 паук 7 T целевой ресурс 40 целевой URI 40 Поле заголовка TE 39 Поле заголовка трейлера 40 Поле заголовка Transfer-Encoding 28 прокси-сервер преобразования 49 прозрачный прокси 11 туннель 10 U Поле заголовка обновления 57 восходящий поток 9 Схема URI http 17 https 17 агент пользователя 7 V Через поле заголовка 47 Адреса авторов Рой Т. Филдинг (редактор) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA Электронная почта: fielding@gbiv.com URI: &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Джулиан Ф. Решке (редактор) greenbytes GmbH Hafenweg 16 Muenster, NW 48155 Германия Электронная почта: julian.reschke@greenbytes.de URI: &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt; Fielding &amp;amp; Reschke Standards Track [Страница 89]</target>
        </trans-unit>
        <trans-unit id="5f38d91a98f445cfaf31a1b87315c344133fcf77" translate="yes" xml:space="preserve">
          <source>BZip archive</source>
          <target state="translated">BZip-архив</target>
        </trans-unit>
        <trans-unit id="9268ec259738e5664244ab3e240148d4cb02f539" translate="yes" xml:space="preserve">
          <source>BZip2 archive</source>
          <target state="translated">BZip2 архив</target>
        </trans-unit>
        <trans-unit id="b1ff57d696aa3ec09bd76c88944e1a7097ee37a3" translate="yes" xml:space="preserve">
          <source>Bad:</source>
          <target state="translated">Bad:</target>
        </trans-unit>
        <trans-unit id="6b6c8e8e9e899e58c8a82dcfe5a52c51d8589bc9" translate="yes" xml:space="preserve">
          <source>Base64 encoding and decoding</source>
          <target state="translated">Кодирование и декодирование Base64</target>
        </trans-unit>
        <trans-unit id="dd485ec404c88c9bc1169c18d4946d7741390c2a" translate="yes" xml:space="preserve">
          <source>Base64 encoding of a file or string on Linux and Mac OS X systems can be achieved using the command-line &lt;code&gt;base64&lt;/code&gt; (or, as an alternative, the &lt;code&gt;uuencode&lt;/code&gt; utility with &lt;code&gt;-m&lt;/code&gt; argument).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a6c4738838e4b0a166434348297e34cf13d0aa" translate="yes" xml:space="preserve">
          <source>Base64 is a group of binary-to-text encoding schemes that represent binary data in an ASCII string format by translating it into a radix-64 representation. By consisting only in ASCII characters, base64 strings are generally url-safe, and that's why they can be used to encode data in Data URLs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f89697a7bc4483ffe13d2dcbf8d58f7b7c1be20" translate="yes" xml:space="preserve">
          <source>Basic aspects of HTTP</source>
          <target state="translated">Основные аспекты HTTP</target>
        </trans-unit>
        <trans-unit id="f1141fef0f5d80de5637d17a79c2912b21db48fe" translate="yes" xml:space="preserve">
          <source>Basic authentication scheme</source>
          <target state="translated">Базовая схема аутентификации</target>
        </trans-unit>
        <trans-unit id="8a8d7195474f74b23cfe43ea9439aa2d6b6b0acb" translate="yes" xml:space="preserve">
          <source>Basic operation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e2b3aff207a2929af920ad2047a4854ec8d687" translate="yes" xml:space="preserve">
          <source>Basic support</source>
          <target state="translated">Базовая поддержка</target>
        </trans-unit>
        <trans-unit id="81efe3a6d9678e29a4c810740a95dcc9bb4f25f2" translate="yes" xml:space="preserve">
          <source>Basics of HTTP</source>
          <target state="translated">Основы HTTP</target>
        </trans-unit>
        <trans-unit id="e0cd046975ac459ab156bc7edc2ad7f0be4cd40d" translate="yes" xml:space="preserve">
          <source>Battery Status API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a186f451d47a315ace213770793074f6621919f" translate="yes" xml:space="preserve">
          <source>Battery Status API&lt;br/&gt;&lt;small&gt;The definition of 'Feature Policy integration' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="029209c4aa3fd234305ceec4958ac95bfc012cd5" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Upgrade&lt;/code&gt; is a hop-by-hop header, it also needs to be listed in the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header field. This means that a typical request that includes Upgrade would look something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2390d6f45ac482880e651868f977b3b748a0f6b2" translate="yes" xml:space="preserve">
          <source>Because HTTP uses mostly textual, character-delimited fields, parsers
   are often vulnerable to attacks based on sending very long (or very
   slow) streams of data, particularly where an implementation is
   expecting a protocol element with no predefined length.

   To promote interoperability, specific recommendations are made for
   minimum size limits on request-line (&lt;a href=&quot;#section-3.1.1&quot;&gt;Section 3.1.1&lt;/a&gt;) and header fields
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;).  These are minimum recommendations, chosen to be
   supportable even by implementations with limited resources; it is
   expected that most implementations will choose substantially higher
   limits.

   A server can reject a message that has a request-target that is too
   long (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.12&quot;&gt;Section&amp;nbsp;6.5.12 of [RFC7231]&lt;/a&gt;) or a request payload that is too
   large (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.11&quot;&gt;Section&amp;nbsp;6.5.11 of [RFC7231]&lt;/a&gt;).  Additional status codes related
   to capacity limits have been defined by extensions to HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC6585&lt;/a&gt;].

   Recipients ought to carefully limit the extent to which they process
   other protocol elements, including (but not limited to) request
   methods, response status phrases, header field-names, numeric values,
   and body chunks.  Failure to limit such processing can result in
   buffer overflows, arithmetic overflows, or increased vulnerability to
   denial-of-service attacks.</source>
          <target state="translated">Поскольку HTTP использует в основном текстовые поля с разделителями, синтаксические анализаторы часто уязвимы для атак, основанных на отправке очень длинных (или очень медленных) потоков данных, особенно когда реализация ожидает элемент протокола без предопределенной длины. Чтобы способствовать взаимодействию, даются конкретные рекомендации по минимальным ограничениям размера для строки запроса ( &lt;a href=&quot;#section-3.1.1&quot;&gt;раздел 3.1.1&lt;/a&gt; ) и полей заголовка ( &lt;a href=&quot;#section-3.2&quot;&gt;раздел 3.2&lt;/a&gt; ). Это минимум рекомендаций, выбранных для поддержки даже в реализациях с ограниченными ресурсами; ожидается, что большинство реализаций выберут существенно более высокие пределы. Сервер может отклонить сообщение, у которого слишком длинная цель запроса ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.12&quot;&gt;раздел 6.5.12 [RFC7231]&lt;/a&gt;) или слишком большие &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.11&quot;&gt;полезные данные запроса&lt;/a&gt; ( раздел 6.5.11 [RFC7231] ). Дополнительные коды состояния, связанные с ограничениями емкости, были определены расширениями HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC6585&lt;/a&gt; ]. Получатели должны тщательно ограничивать степень, в которой они обрабатывают другие элементы протокола, включая (но не ограничиваясь) методы запроса, фразы состояния ответа, имена полей заголовка, числовые значения и фрагменты тела. Неспособность ограничить такую ​​обработку может привести к переполнению буфера, арифметическому переполнению или повышенной уязвимости для атак типа &amp;laquo;отказ в обслуживании&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e347f7f4e0eb64be97283fb708464f948f15cd41" translate="yes" xml:space="preserve">
          <source>Because a client might be receiving responses via multiple paths, so
   that some responses flow through one set of caches and other
   responses flow through a different set of caches, a client might
   receive responses in an order different from that in which the origin
   server sent them. We would like the client to use the most recently
   generated response, even if older responses are still apparently
   fresh.

   Neither the entity tag nor the expiration value can impose an
   ordering on responses, since it is possible that a later response
   intentionally carries an earlier expiration time. The Date values are
   ordered to a granularity of one second.

   When a client tries to revalidate a cache entry, and the response it
   receives contains a Date header that appears to be older than the one
   for the existing entry, then the client SHOULD repeat the request
   unconditionally, and include

       Cache-Control: max-age=0

   to force any intermediate caches to validate their copies directly
   with the origin server, or

       Cache-Control: no-cache

   to force any intermediate caches to obtain a new copy from the origin
   server. 

   If the Date values are equal, then the client MAY use either response
   (or MAY, if it is being extremely prudent, request a new response).
   Servers MUST NOT depend on clients being able to choose
   deterministically between responses generated during the same second,
   if their expiration times overlap.</source>
          <target state="translated">Поскольку клиент может получать ответы несколькими путями,так что некоторые ответы проходят через один набор кэшей,а другие-через другой набор кэшей,клиент может получать ответы в порядке,отличном от того,в котором их отправлял сервер происхождения.Мы бы хотели,чтобы клиент использовал самые последние сгенерированные ответы,даже если старые ответы все еще кажутся свежими.Ни тег сущности,ни значение срока годности не могут накладывать порядок на ответы,так как возможно,что более поздний ответ намеренно несет более раннее время истечения срока годности.Значения даты упорядочиваются с точностью до секунды.Когда клиент пытается перепроверить запись в кэше,и полученный им ответ содержит заголовок Date,который кажется старше,чем для существующей записи,то клиент ДОЛЖЕН повторить запрос безоговорочно,и включить Cache-Control:max-age=0 для того,чтобы заставить промежуточные кэши подтвердить свои копии непосредственно на исходном сервере,или Cache-Control:no-cache для того,чтобы заставить промежуточные кэши получить новую копию с исходного сервера.Если значения Date равны,то клиент MAY использует либо ответ (либо MAY,если это очень предусмотрительно,запросить новый ответ).Серверы НЕ ДОЛЖНЫ зависеть от того,могут ли клиенты детерминированно выбирать между ответами,генерируемыми в одну и ту же секунду,если их время истечения срока действия совпадает.</target>
        </trans-unit>
        <trans-unit id="86455b35c9696e2ada5790776540ffdd90e87107" translate="yes" xml:space="preserve">
          <source>Because expiration values are assigned optimistically, it is possible
   for two caches to contain fresh values for the same resource that are
   different.

   If a client performing a retrieval receives a non-first-hand response
   for a request that was already fresh in its own cache, and the Date
   header in its existing cache entry is newer than the Date on the new
   response, then the client MAY ignore the response. If so, it MAY
   retry the request with a &quot;Cache-Control: max-age=0&quot; directive (see
   &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;), to force a check with the origin server.

   If a cache has two fresh responses for the same representation with
   different validators, it MUST use the one with the more recent Date
   header. This situation might arise because the cache is pooling
   responses from other caches, or because a client has asked for a
   reload or a revalidation of an apparently fresh cache entry.</source>
          <target state="translated">Поскольку значения срока действия назначаются оптимистично, два кэша могут содержать свежие значения для одного и того же ресурса, которые отличаются. Если клиент, выполняющий поиск, получает ответ не из первых рук на запрос, который уже был свежим в его собственном кэше, и заголовок Date в его существующей записи кэша новее, чем Date в новом ответе, то клиент МОЖЕТ игнорировать ответ. В таком случае он МОЖЕТ повторить запрос с помощью директивы Cache-Control: max-age = 0 (см. &lt;a href=&quot;#section-14.9&quot;&gt;Раздел 14.9.&lt;/a&gt;), чтобы принудительно проверить исходный сервер. Если в кэше есть два новых ответа для одного и того же представления с разными валидаторами, он ДОЛЖЕН использовать тот, который имеет более свежий заголовок Date. Эта ситуация может возникнуть из-за того, что кеш объединяет ответы из других кешей или потому, что клиент запросил перезагрузку или повторную проверку явно новой записи кэша.</target>
        </trans-unit>
        <trans-unit id="c8925ede0629c5d28bf60e237373ba50709672d6" translate="yes" xml:space="preserve">
          <source>Because some of the information shared by &lt;code&gt;resource:&lt;/code&gt; URLs is available to websites, a web page could run internal scripts and inspect internal resources of Firefox, including the default preferences, which could be a serious security and privacy issue.</source>
          <target state="translated">Поскольку некоторая информация, совместно используемая URL-адресами &lt;code&gt;resource:&lt;/code&gt; , доступна веб-сайтам, веб-страница может запускать внутренние сценарии и проверять внутренние ресурсы Firefox, включая настройки по умолчанию, что может быть серьезной проблемой безопасности и конфиденциальности.</target>
        </trans-unit>
        <trans-unit id="546f4d232503e1d341d388da112b0bb01eea4130" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; header value is different (&quot;varies&quot;) for mobile and desktop clients, caches will not be used to serve mobile content mistakenly to desktop users or vice versa.</source>
          <target state="translated">Поскольку значение заголовка &lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; отличается (&amp;laquo;различается&amp;raquo;) для мобильных и настольных клиентов, кеши не будут использоваться для ошибочного обслуживания мобильного контента для пользователей настольных компьютеров или наоборот.</target>
        </trans-unit>
        <trans-unit id="b675dee5907b6c94664883b5699f8243f8d18b2d" translate="yes" xml:space="preserve">
          <source>Because the request headers in the above example include a &lt;code&gt;Cookie&lt;/code&gt; header, the request would fail if the value of the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header was &quot;*&quot;. But it does not fail: Because the value of the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header is &quot;&lt;code&gt;http://foo.example&lt;/code&gt;&quot; (an actual origin) rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, the credential-cognizant content is returned to the invoking web content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8cadc83ac6b7350fa14508ccacb5caa822a4e4b" translate="yes" xml:space="preserve">
          <source>Because the request headers in the above example include a &lt;code&gt;Cookie&lt;/code&gt; header, the request would fail if the value of the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header were &quot;*&quot;. But it does not fail: Because the value of the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header is &quot;&lt;code&gt;http://foo.example&lt;/code&gt;&quot; (an actual origin) rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, the credential-cognizant content is returned to the invoking web content.</source>
          <target state="translated">Поскольку заголовки запроса в приведенном выше примере включают заголовок &lt;code&gt;Cookie&lt;/code&gt; , запрос завершится ошибкой, если значение заголовка &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; равно &amp;laquo;*&amp;raquo;. Но это не сработает: поскольку значение заголовка &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; равно &amp;laquo; &lt;code&gt;http://foo.example&lt;/code&gt; &amp;raquo; (фактическое происхождение), а не подстановочный знак &amp;laquo; &lt;code&gt;*&lt;/code&gt; &amp;raquo;, содержимое с учетными данными возвращается в вызывающий веб-контент.</target>
        </trans-unit>
        <trans-unit id="9f1e2820de19096a78681bfbbd2529f24bd989c8" translate="yes" xml:space="preserve">
          <source>Because the source of a link might be private information or might
   reveal an otherwise private information source, it is strongly
   recommended that the user be able to select whether or not the
   Referer field is sent. For example, a browser client could have a
   toggle switch for browsing openly/anonymously, which would
   respectively enable/disable the sending of Referer and From
   information.

   Clients SHOULD NOT include a Referer header field in a (non-secure)
   HTTP request if the referring page was transferred with a secure
   protocol.

   Authors of services which use the HTTP protocol SHOULD NOT use GET
   based forms for the submission of sensitive data, because this will
   cause this data to be encoded in the Request-URI. Many existing
   servers, proxies, and user agents will log the request URI in some
   place where it might be visible to third parties. Servers can use
   POST-based form submission instead</source>
          <target state="translated">Поскольку источником ссылки может быть частная информация или может быть раскрыт другой источник частной информации,настоятельно рекомендуется,чтобы пользователь мог выбрать,отправляется ли поле Referer или нет.Например,в клиенте браузера может быть установлен тумблер для открытого/анонимного просмотра,который соответственно включает/отключает отправку информации о реферере и от него.Клиенты НЕ ДОЛЖНЫ включать поле заголовка Referer в (небезопасный)HTTP-запрос,если ссылающаяся страница была передана по защищенному протоколу.Авторы сервисов,использующих протокол HTTP,НЕ ДОЛЖНЫ использовать формы на основе GET для передачи конфиденциальных данных,так как это приведет к кодированию этих данных в Request-URI.Многие существующие серверы,прокси-серверы и пользовательские агенты будут протоколировать URI запроса в том месте,где он может быть виден третьим лицам.Вместо этого серверы могут использовать отправку форм на основе POST</target>
        </trans-unit>
        <trans-unit id="89777ff4d87ff412faf166b9388ba8bd9eb18838" translate="yes" xml:space="preserve">
          <source>Because unsafe request methods (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7231]&lt;/a&gt;) such as
   PUT, POST or DELETE have the potential for changing state on the
   origin server, intervening caches can use them to keep their contents
   up to date.

   A cache MUST invalidate the effective Request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of
   [RFC7230]&lt;/a&gt;) as well as the URI(s) in the Location and Content-Location
   response header fields (if present) when a non-error status code is
   received in response to an unsafe request method.

   However, a cache MUST NOT invalidate a URI from a Location or
   Content-Location response header field if the host part of that URI
   differs from the host part in the effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5
   of [RFC7230]&lt;/a&gt;).  This helps prevent denial-of-service attacks.

   A cache MUST invalidate the effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of
   [RFC7230]&lt;/a&gt;) when it receives a non-error response to a request with a
   method whose safety is unknown.

   Here, a &quot;non-error response&quot; is one with a 2xx (Successful) or 3xx
   (Redirection) status code.  &quot;Invalidate&quot; means that the cache will
   either remove all stored responses related to the effective request
   URI or will mark these as &quot;invalid&quot; and in need of a mandatory
   validation before they can be sent in response to a subsequent
   request.

   Note that this does not guarantee that all appropriate responses are
   invalidated.  For example, a state-changing request might invalidate
   responses in the caches it travels through, but relevant responses
   still might be stored in other caches that it has not.</source>
          <target state="translated">Поскольку небезопасные методы запроса ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;раздел 4.2.1 [RFC7231]&lt;/a&gt; ), такие как PUT, POST или DELETE, могут изменять состояние на исходном сервере, промежуточные кеши могут использовать их для поддержания своего содержимого в актуальном состоянии. Кэш ДОЛЖЕН сделать недействительным действующий URI запроса ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;раздел 5.5 [RFC7230]&lt;/a&gt; ), а также URI в полях заголовка ответа Location и Content-Location (если есть), когда в ответ на сообщение получен код состояния, не связанный с ошибкой. небезопасный метод запроса. Однако кэш НЕ ДОЛЖЕН делать недействительным URI из поля заголовка ответа Location или Content-Location, если часть хоста этого URI отличается от части хоста в действующем URI запроса ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;раздел 5.5 [RFC7230]&lt;/a&gt;). Это помогает предотвратить атаки типа &amp;laquo;отказ в обслуживании&amp;raquo;. Кэш ДОЛЖЕН сделать недействительным действующий URI запроса ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;раздел 5.5 [RFC7230]&lt;/a&gt;), когда он получает ответ без ошибки на запрос с методом, безопасность которого неизвестна. Здесь &amp;laquo;безошибочный ответ&amp;raquo; - это ответ с кодом состояния 2xx (Успешно) или 3xx (Перенаправление). &amp;laquo;Недействительный&amp;raquo; означает, что кэш либо удалит все сохраненные ответы, связанные с действующим URI запроса, либо пометит их как &amp;laquo;недействительные&amp;raquo; и требующие обязательной проверки, прежде чем они могут быть отправлены в ответ на последующий запрос. Обратите внимание, что это не гарантирует, что все соответствующие ответы будут признаны недействительными. Например, запрос на изменение состояния может сделать недействительными ответы в кешах, через которые он проходит, но соответствующие ответы все равно могут храниться в других кэшах, которых у него нет.</target>
        </trans-unit>
        <trans-unit id="7164b8ce21f524d63c0906c78c5305985077fd8f" translate="yes" xml:space="preserve">
          <source>Before Firefox 58, &lt;code&gt;frame-ancestors&lt;/code&gt; is ignored in &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;.</source>
          <target state="translated">До Firefox 58 &lt;code&gt;frame-ancestors&lt;/code&gt; игнорировались в &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee3fc8de372dabedbc1b9fd227e55db192bded9b" translate="yes" xml:space="preserve">
          <source>Before Firefox 80, applying &lt;code&gt;fullscreen&lt;/code&gt; to an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; (i.e. via the &lt;code&gt;allow&lt;/code&gt; attribute) does not work unless the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute is also present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1aa5f2715f87eb515763d2edd53baeae3f8d201" translate="yes" xml:space="preserve">
          <source>Before Firefox for Android 58, &lt;code&gt;frame-ancestors&lt;/code&gt; is ignored in &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;.</source>
          <target state="translated">До Firefox для Android 58 &lt;code&gt;frame-ancestors&lt;/code&gt; игнорировались в &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9418490a330c1f1a821e30ad652b77665cb8b536" translate="yes" xml:space="preserve">
          <source>Before a client and server can exchange an HTTP request/response pair, they must establish a TCP connection, a process which requires several round-trips. The default behavior of HTTP/1.0 is to open a separate TCP connection for each HTTP request/response pair. This is less efficient than sharing a single TCP connection when multiple requests are sent in close succession.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98afb5d15000b90ef6856f9873a69ca2c0709aba" translate="yes" xml:space="preserve">
          <source>Before later builds of Chrome 64, invalid Expect-CT reports would be sent. Newer versions do not send reports after 10 weeks from the build date. See &lt;a href=&quot;https://crbug.com/786563&quot;&gt;bug 786563&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62fc5c2bc1f37893a14f09a3227f0a7bbc9e9b1c" translate="yes" xml:space="preserve">
          <source>Beginning in version 41, Firefox for Android will contain the Android version as part of the &lt;var&gt;platform&lt;/var&gt; token. For increased interoperability, if the browser is running on a version below 4 it will report 4.4. Android versions 4 and above will report the version accurately. Note that the same Gecko&amp;mdash;with the same capabilities&amp;mdash;is shipped to all versions of Android.</source>
          <target state="translated">Начиная с версии 41, Firefox для Android будет содержать версию Android как часть токена &lt;var&gt;platform&lt;/var&gt; . Для повышения совместимости, если браузер работает с версией ниже 4, он сообщит 4.4. Android версии 4 и выше сообщит версию точно. Обратите внимание, что один и тот же Gecko - с одинаковыми возможностями - поставляется для всех версий Android.</target>
        </trans-unit>
        <trans-unit id="3dac22f5a23b1f3829fde1d94704586ae962f362" translate="yes" xml:space="preserve">
          <source>Below, the client creates a Member Entry using POST:

       POST /myblog/entries HTTP/1.1
       Host: example.org
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Type: application/atom+xml;type=entry
       Content-Length: nnn
       Slug: First Post

       &amp;lt;?xml version=&quot;1.0&quot; ?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;Atom-Powered Robots Run Amok&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2007-02-123T17:09:02Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Captain Lansing&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content&amp;gt;It's something moving... solid metal&amp;lt;/content&amp;gt;
       &amp;lt;/entry&amp;gt;

   The server signals a successful creation with a status code of 201,
   and returns an ETag header in the response.  Because, in this case,
   the server returned a Content-Location header and Location header
   with the same value, the returned Entry representation can be
   understood to be a complete representation of the newly created Entry
   (see &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;).

       HTTP/1.1 201 Created
       Date: Fri, 23 Feb 2007 21:17:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry
       Location: http://example.org/edit/first-post.atom
       Content-Location: http://example.org/edit/first-post.atom
       ETag: &quot;e180ee84f0671b1&quot;

       &amp;lt;?xml version=&quot;1.0&quot; ?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;Atom-Powered Robots Run Amok&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2007-02-123T17:09:02Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Captain Lansing&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content&amp;gt;It's something moving... solid metal&amp;lt;/content&amp;gt;
       &amp;lt;/entry&amp;gt;

   The client can, if it wishes, use the returned ETag value to later
   construct a &quot;Conditional GET&quot; as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  In this case,
   prior to editing, the client sends the ETag value for the Member
   using the If-None-Match header. 

       GET /edit/first-post.atom HTTP/1.1
       Host: example.org
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       If-None-Match: &quot;e180ee84f0671b1&quot;

   If the Entry has not been modified, the response will be a status
   code of 304 (&quot;Not Modified&quot;).  This allows the client to determine
   whether it still has the most recent representation of the Entry at
   the time of editing.

       HTTP/1.1 304 Not Modified
       Date: Sat, 24 Feb 2007 13:17:11 GMT

   After editing, the client can PUT the Entry and send the ETag entity
   value in an If-Match header, informing the server to accept the entry
   on the condition that the entity value sent still matches the
   server's.

       PUT /edit/first-post.atom HTTP/1.1
       Host: example.org
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Type: application/atom+xml;type=entry
       Content-Length: nnn
       If-Match: &quot;e180ee84f0671b1&quot;

       &amp;lt;?xml version=&quot;1.0&quot; ?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;Atom-Powered Robots Run Amok&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2007-02-24T16:34:06Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Captain Lansing&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content&amp;gt;Update: it's a hoax!&amp;lt;/content&amp;gt;
       &amp;lt;/entry&amp;gt;

   The server however has since received a more recent copy than the
   client's, and it responds with a status code of 412 (&quot;Precondition
   Failed&quot;).

       HTTP/1.1 412 Precondition Failed
       Date: Sat, 24 Feb 2007 16:34:11 GMT

   This informs the client that the server has a more recent version of
   the Entry and will not allow the sent entity to be stored.</source>
          <target state="translated">Ниже клиент создает запись участника, используя POST: POST / myblog / entries HTTP / 1.1 Host: example.org Авторизация: базовая ZGFmZnk6c2VjZXJldA == Content-Type: application / atom + xml; type = entry Content-Length: nnn Slug: Первое сообщение &amp;lt;? Xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;Entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; Роботы, работающие на атомах, выходят из-под контроля &amp;lt;/title&amp;gt; &amp;lt;id&amp;gt; urn: uuid: 1225c695-cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/id&amp;gt; &amp;lt;updated&amp;gt; 2007-02-123T17: 09: 02Z &amp;lt;/updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Капитан Лансинг &amp;lt;/name&amp;gt; &amp;lt;/author&amp;gt; &amp;lt;content&amp;gt; Это что-то движущееся ... твердый металл &amp;lt;/content&amp;gt; &amp;lt;/entry&amp;gt; Сервер сигнализирует об успешном создании с кодом состояния 201,и возвращает в ответ заголовок ETag. Поскольку в этом случае сервер вернул заголовок Content-Location и заголовок Location с одним и тем же значением, возвращаемое представление Entry можно понимать как полное представление вновь созданной записи (см.&lt;a href=&quot;#section-9.2&quot;&gt;Раздел 9.2&lt;/a&gt; ). HTTP / 1.1 201 Дата создания: Пт, 23 февраля 2007 г., 21:17:11 GMT Content-Length: nnn Content-Type: application / atom + xml; type = entry Расположение: http://example.org/edit/first- post.atom Content-Location: http://example.org/edit/first-post.atom ETag: &quot;e180ee84f0671b1&quot; &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http: //www.w3. org / 2005 / Atom &quot;&amp;gt; &amp;lt;title&amp;gt; Роботы на базе Atom выходят из-под контроля &amp;lt;/title&amp;gt; &amp;lt;id&amp;gt; urn: uuid: 1225c695-cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/id&amp;gt; &amp;lt;updated&amp;gt; 2007-02-123T17: 09 : 02Z &amp;lt;/updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Капитан Лансинг &amp;lt;/name&amp;gt; &amp;lt;/author&amp;gt; &amp;lt;content&amp;gt; Это что-то движущееся ... твердый металл &amp;lt;/content&amp;gt; &amp;lt;/entry&amp;gt;При желании клиент может использовать возвращенное значение ETag для последующего создания &amp;laquo;условного GET&amp;raquo;, как определено в [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]. В этом случае перед редактированием клиент отправляет значение ETag для элемента, используя заголовок If-None-Match. GET /edit/first-post.atom HTTP / 1.1 Хост: example.org Авторизация: Базовая ZGFmZnk6c2VjZXJldA == If-None-Match: &quot;e180ee84f0671b1&quot; Если запись не была изменена, ответ будет иметь код состояния 304 ( &amp;laquo;Не изменено&amp;raquo;). Это позволяет клиенту определить, есть ли у него самое последнее представление записи на момент редактирования. HTTP / 1.1 304 Не изменено Дата: Суббота, 24 февраля 2007 г., 13:17:11 GMT После редактирования клиент может ПОСТАВИТЬ запись и отправить значение объекта ETag в заголовке If-Match, информируя сервер о принятии записи на условие, что отправленное значение объекта все еще совпадает со значением сервера.PUT /edit/first-post.atom HTTP / 1.1 Хост: example.org Авторизация: Базовая ZGFmZnk6c2VjZXJldA == Content-Type: application / atom + xml; type = entry Content-Length: nnn If-Match: &quot;e180ee84f0671b1&quot; &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; Роботы, работающие на атомах, выходят из-под контроля &amp;lt;/title&amp;gt; &amp;lt;id&amp;gt; urn: uuid: 1225c695- cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/id&amp;gt; &amp;lt;updated&amp;gt; 2007-02-24T16: 34: 06Z &amp;lt;/updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Captain Lansing &amp;lt;/name&amp;gt; &amp;lt;/author&amp;gt; &amp;lt;content&amp;gt; Обновление: это обман! &amp;lt;/content&amp;gt; &amp;lt;/entry&amp;gt; Сервер, однако, получил более свежую копию, чем клиентская,и он отвечает кодом состояния 412 (&amp;laquo;Предварительное условие не выполнено&amp;raquo;). HTTP / 1.1 412 Precondition Failed Дата: Суббота, 24 февраля 2007 г., 16:34:11 GMT Это информирует клиента о том, что на сервере установлена ​​более свежая версия записи, и не позволяет сохранить отправленный объект.</target>
        </trans-unit>
        <trans-unit id="c0330bfb1138bf9fb6ae44f78a5af3bf13c6fff6" translate="yes" xml:space="preserve">
          <source>Below, the client sends a POST request containing a PNG image to the
   URI of a Collection that accepts PNG images:

       POST /edit/ HTTP/1.1
       Host: media.example.org
       Content-Type: image/png
       Slug: The Beach
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   The server signals a successful creation with a status code of 201.
   The response includes a Location header indicating the Member URI of
   the Media Link Entry and a representation of that entry in the body
   of the response.  The Media Link Entry includes a content element
   with a &quot;src&quot; attribute.  It also contains a link with a link relation
   of &quot;edit-media&quot;, specifying the IRI to be used for modifying the
   Media Resource.

       HTTP/1.1 201 Created
       Date: Fri, 7 Oct 2005 17:17:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry;charset=&quot;utf-8&quot;
       Location: http://example.org/media/edit/the_beach.atom

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;The Beach&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:17:08Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;summary type=&quot;text&quot; /&amp;gt;
         &amp;lt;content type=&quot;image/png&quot;
            src=&quot;http://media.example.org/the_beach.png&quot;/&amp;gt;
         &amp;lt;link rel=&quot;edit-media&quot;
            href=&quot;http://media.example.org/edit/the_beach.png&quot; /&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
            href=&quot;http://example.org/media/edit/the_beach.atom&quot; /&amp;gt;
       &amp;lt;/entry&amp;gt; 

   Later, the client sends a PUT request containing the new PNG using
   the URI indicated in the Media Link Entry's &quot;edit-media&quot; link:

       PUT /edit/the_beach.png HTTP/1.1
       Host: media.example.org
       Content-Type: image/png
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   The server signals a successful edit with a status code of 200.

       HTTP/1.1 200 Ok
       Date: Fri, 8 Oct 2006 17:17:11 GMT

   The client can edit the metadata for the picture.  First GET the
   Media Link Entry:

       GET /media/edit/the_beach.atom HTTP/1.1
       Host: example.org
       Authorization: Basic ZGFmZnk6c2VjZXJldA==

   The Media Link Entry is returned.

       HTTP/1.1 200 Ok
       Date: Fri, 7 Oct 2005 17:18:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry;charset=&quot;utf-8&quot;
       ETag: &quot;c181bb840673b5&quot;

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;The Beach&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:17:08Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;summary type=&quot;text&quot; /&amp;gt;
         &amp;lt;content type=&quot;image/png&quot;
            src=&quot;http://media.example.org/the_beach.png&quot;/&amp;gt;
         &amp;lt;link rel=&quot;edit-media&quot;
            href=&quot;http://media.example.org/edit/the_beach.png&quot; /&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
            href=&quot;http://example.org/media/edit/the_beach.atom&quot; /&amp;gt;
       &amp;lt;/entry&amp;gt;

   The metadata can be updated, in this case to add a summary, and then
   PUT back to the server. 

       PUT /media/edit/the_beach.atom HTTP/1.1
       Host: example.org
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Type: application/atom+xml;type=entry
       Content-Length: nnn
       If-Match: &quot;c181bb840673b5&quot;

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;The Beach&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:17:08Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;summary type=&quot;text&quot;&amp;gt;
             A nice sunset picture over the water.
         &amp;lt;/summary&amp;gt;
         &amp;lt;content type=&quot;image/png&quot;
            src=&quot;http://media.example.org/the_beach.png&quot;/&amp;gt;
         &amp;lt;link rel=&quot;edit-media&quot;
            href=&quot;http://media.example.org/edit/the_beach.png&quot; /&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
            href=&quot;http://example.org/media/edit/the_beach.atom&quot; /&amp;gt;
       &amp;lt;/entry&amp;gt;

   The update was successful.

       HTTP/1.1 200 Ok
       Date: Fri, 7 Oct 2005 17:19:11 GMT
       Content-Length: 0

   Multiple Media Resources can be added to the Collection.

       POST /edit/ HTTP/1.1
       Host: media.example.org
       Content-Type: image/png
       Slug: The Pier
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   The Resource is created successfully.

       HTTP/1.1 201 Created
       Date: Fri, 7 Oct 2005 17:17:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry;charset=&quot;utf-8&quot;
       Location: http://example.org/media/edit/the_pier.atom 

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;The Pier&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efe6b&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:26:43Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;summary type=&quot;text&quot; /&amp;gt;
         &amp;lt;content type=&quot;image/png&quot;
            src=&quot;http://media.example.org/the_pier.png&quot;/&amp;gt;
         &amp;lt;link rel=&quot;edit-media&quot;
            href=&quot;http://media.example.org/edit/the_pier.png&quot; /&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
            href=&quot;http://example.org/media/edit/the_pier.atom&quot; /&amp;gt;
       &amp;lt;/entry&amp;gt;

   The client can now create a new Atom Entry in the blog Entry
   Collection that references the two newly created Media Resources.

       POST /blog/ HTTP/1.1
       Host: example.org
       Content-Type: application/atom+xml;type=entry
       Slug: A day at the beach
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;A fun day at the beach&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6b&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:40:02Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content type=&quot;xhtml&quot;&amp;gt;
             &amp;lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
                 &amp;lt;xhtml:p&amp;gt;We had a good day at the beach.
                     &amp;lt;xhtml:img alt=&quot;the beach&quot;
                         src=&quot;http://media.example.org/the_beach.png&quot;/&amp;gt;
                 &amp;lt;/xhtml:p&amp;gt;
                 &amp;lt;xhtml:p&amp;gt;Later we walked down to the pier.
                     &amp;lt;xhtml:img  alt=&quot;the pier&quot;
                         src=&quot;http://media.example.org/the_pier.png&quot;/&amp;gt;
                 &amp;lt;/xhtml:p&amp;gt;
             &amp;lt;/xhtml:div&amp;gt;
         &amp;lt;/content&amp;gt;
       &amp;lt;/entry&amp;gt;

   The Resource is created successfully. 

       HTTP/1.1 200 Ok
       Date: Fri, 7 Oct 2005 17:20:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry;charset=&quot;utf-8&quot;
       Location: http://example.org/blog/atom/a-day-at-the-beach.atom

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;A fun day at the beach&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;http://example.org/blog/a-day-at-the-beach.xhtml&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:43:07Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content type=&quot;xhtml&quot;&amp;gt;
             &amp;lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
                 &amp;lt;xhtml:p&amp;gt;We had a good day at the beach.
                     &amp;lt;xhtml:img alt=&quot;the beach&quot;
                        src=&quot;http://media.example.org/the_beach.png&quot;/&amp;gt;
                 &amp;lt;/xhtml:p&amp;gt;
                 &amp;lt;xhtml:p&amp;gt;Later we walked down to the pier.
                     &amp;lt;xhtml:img alt=&quot;the pier&quot;
                        src=&quot;http://media.example.org/the_pier.png&quot;/&amp;gt;
                 &amp;lt;/xhtml:p&amp;gt;
             &amp;lt;/xhtml:div&amp;gt;
         &amp;lt;/content&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
           href=&quot;http://example.org/blog/edit/a-day-at-the-beach.atom&quot;/&amp;gt;
         &amp;lt;link rel=&quot;alternate&quot; type=&quot;text/html&quot;
           href=&quot;http://example.org/blog/a-day-at-the-beach.html&quot;/&amp;gt;
       &amp;lt;/entry&amp;gt;

   Note that the returned Entry contains a link with a relation of
   &quot;alternate&quot; that points to the associated HTML page that was created
   -- this is not required by this specification, but is included to
   show the kinds of changes a server can make to an Entry.</source>
          <target state="translated">Ниже клиент отправляет POST-запрос, содержащий изображение PNG, на URI Коллекции, которая принимает изображения PNG: POST / edit / HTTP / 1.1 Host: media.example.org Content-Type: image / png Slug: Авторизация на пляже: Базовый ZGFmZnk6c2VjZXJldA == Content-Length: nnn ... двоичные данные Сервер сигнализирует об успешном создании с кодом состояния 201. Ответ включает заголовок Location, указывающий URI участника записи Media Link и представление этой записи в тело ответа. Запись медиа-ссылки включает элемент содержимого с атрибутом &amp;laquo;src&amp;raquo;. Он также содержит ссылку с отношением ссылки &quot;edit-media&quot;, определяющую IRI, который будет использоваться для изменения медиаресурса. HTTP / 1.1 201 Дата создания: 7 октября 2005 г., пт, 17:17:11 GMT Content-Length: nnn Content-Type: application / atom + xml; type = entry; charset = &quot;utf-8&quot; Расположение: http://example.org/media/edit/the_beach.atom &amp;lt;? Xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;Entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; Пляж &amp;lt;/title&amp;gt; &amp;lt;id&amp;gt; urn: uuid: 1225c695-cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17: 17: 08Z &amp;lt;/updated&amp;gt; &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt; &amp;lt;/author&amp;gt; &amp;lt;summary type = &quot;text&quot; /&amp;gt; &amp;lt;content type = &quot;image / png &quot;src =&quot; http://media.example.org/the_beach.png &quot;/&amp;gt; &amp;lt;link rel =&quot; edit-media &quot;href =&quot; http://media.example.org/edit/the_beach.png &quot; /&amp;gt; &amp;lt;link rel = &quot;edit&quot; href = &quot;http://example.org/media/edit/the_beach.atom&quot; /&amp;gt; &amp;lt;/entry&amp;gt; Позже клиент отправляет запрос PUT, содержащий новый PNG, используя URI, указанный в Media Ссылка Ссылка &quot;edit-media&quot; для записи: PUT /edit/the_beach.png HTTP / 1.1 Host: media.example.org Content-Type: image / png Авторизация: Basic ZGFmZnk6c2VjZXJldA == Content-Length: nnn ... двоичные данные сервер сигнализирует об успешном редактировании кодом состояния 200. HTTP / 1.1 200 Ok Дата: Пт, 8 октября 2006 г. 17:17:11 GMT Клиент может редактировать метаданные для изображения. Сначала ПОЛУЧИТЕ запись медиа-ссылки: GET /media/edit/the_beach.atom HTTP / 1.1 Host: example.org Авторизация:Базовый ZGFmZnk6c2VjZXJldA == Возвращается запись Media Link. HTTP / 1.1 200 Ok Дата: пт, 7 октября 2005 г. 17:18:11 GMT Content-Length: nnn Content-Type: application / atom + xml; type = entry; charset = &quot;utf-8&quot; ETag: &quot;c181bb840673b5&quot; &amp;lt; ? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; Пляж &amp;lt;/title&amp;gt; &amp;lt;id&amp;gt; urn: uuid: 1225c695-cfb8-4ebb -aaaa-80da344efa6a &amp;lt;/id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17: 17: 08Z &amp;lt;/updated&amp;gt; &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt; &amp;lt;/author&amp;gt; &amp;lt;summary type = &quot;text&quot; /&amp;gt; &amp;lt;content type = &quot;image / png&quot; src = &quot;http://media.example.org/the_beach.png&quot; /&amp;gt; &amp;lt;link rel = &quot;edit-media&quot;href = &quot;http://media.example.org/edit/the_beach.png&quot; /&amp;gt; &amp;lt;link rel = &quot;edit&quot; href = &quot;http://example.org/media/edit/the_beach.atom&quot; /&amp;gt; &amp;lt; / entry&amp;gt; Метаданные можно обновить, в этом случае добавить сводку, а затем вернуть их на сервер. PUT /media/edit/the_beach.atom HTTP / 1.1 Хост: example.org Авторизация: Базовая ZGFmZnk6c2VjZXJldA == Content-Type: application / atom + xml; type = entry Content-Length: nnn If-Match: &quot;c181bb840673b5&quot; &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; Пляж &amp;lt;/title&amp;gt; &amp;lt;id&amp;gt; urn: uuid: 1225c695-cfb8-4ebb- aaaa-80da344efa6a &amp;lt;/id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17: 17: 08Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt; &amp;lt;/author&amp;gt; &amp;lt;summary type = &quot;text&quot;&amp;gt; Красивый закат над водой. &amp;lt;/summary&amp;gt; &amp;lt;content type = &quot;image / png&quot; src = &quot;http://media.example.org/the_beach.png&quot; /&amp;gt; &amp;lt;link rel = &quot;edit-media&quot; href = &quot;http: // media. example.org/edit/the_beach.png &quot;/&amp;gt; &amp;lt;link rel =&quot; edit &quot;href =&quot; http://example.org/media/edit/the_beach.atom &quot;/&amp;gt; &amp;lt;/entry&amp;gt; Обновление прошло успешно. HTTP / 1.1 200 Ok Дата: Пт, 7 октября 2005 г., 17:19:11 GMT Content-Length: 0 В коллекцию можно добавить несколько медиаресурсов. POST / edit / HTTP / 1.1 Хост: media.example.org Тип содержимого:image / png Слаг: Пирс Авторизация: Базовая ZGFmZnk6c2VjZXJldA == Content-Length: nnn ... двоичные данные Ресурс успешно создан. HTTP / 1.1 201 Дата создания: пятница, 7 октября 2005 г. 17:17:11 GMT Content-Length: nnn Content-Type: application / atom + xml; type = entry; charset = &quot;utf-8&quot; Расположение: http: // example.org/media/edit/the_pier.atom &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; Пирс &amp;lt;/title&amp;gt; &amp;lt;id&amp;gt; urn: uuid: 1225c695-cfb8-4ebb-aaaa-80da344efe6b &amp;lt;/id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17: 26: 43Z &amp;lt;/updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Даффи &amp;lt;/name&amp;gt; &amp;lt;/ author &amp;gt; &amp;lt;summary type = &quot;text&quot; /&amp;gt; &amp;lt;content type = &quot;image / png &quot;src =&quot; http://media.example.org/the_pier.png &quot;/&amp;gt; &amp;lt;link rel =&quot; edit-media &quot;href =&quot; http://media.example.org/edit/the_pier.png &quot;/&amp;gt; &amp;lt;link rel =&quot; edit &quot;href =&quot; http://example.org/media/edit/the_pier.atom &quot;/&amp;gt; &amp;lt;/entry&amp;gt; Теперь клиент может создать новую запись Atom в коллекции записей блога, которая ссылается на два недавно созданных медиаресурса. POST / blog / HTTP / 1.1 Host: example.org Content-Type: application / atom + xml; type = entry Slug: День на пляже Авторизация: Basic ZGFmZnk6c2VjZXJldA == Content-Length: nnn &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; Веселый день на пляже &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn: uuid: 1225c695-cfb8-4ebb-aaaa-80da344efa6b &amp;lt;/id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17: 40: 02Z &amp;lt;/updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Даффи &amp;lt;/name&amp;gt; &amp;lt;/author&amp;gt; &amp;lt;content type = &quot;xhtml&quot;&amp;gt; &amp;lt;xhtml: div xmlns: xhtml = &quot;http://www.w3.org/1999/xhtml&quot;&amp;gt; &amp;lt;xhtml: p&amp;gt; У нас был хороший день на пляже. &amp;lt;xhtml: img alt = &quot;the beach&quot; src = &quot;http://media.example.org/the_beach.png&quot; /&amp;gt; &amp;lt;/ xhtml: p&amp;gt; &amp;lt;xhtml: p&amp;gt; Позже мы спустились к пирсу. &amp;lt;xhtml: img alt = &quot;пирс&quot; src = &quot;http://media.example.org/the_pier.png&quot; /&amp;gt; &amp;lt;/ xhtml: p&amp;gt; &amp;lt;/ xhtml: div&amp;gt; &amp;lt;/content&amp;gt; &amp;lt;/entry&amp;gt; Ресурс успешно создан. HTTP / 1.1 200 Ok Дата: пт, 7 октября 2005 г. 17:20:11 GMT Content-Length: nnn Content-Type: application / atom + xml; type = entry; charset = &quot;utf-8&quot; Расположение: http: // example.org/blog/atom/a-day-at-the-beach.atom &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt; title&amp;gt; Веселый день на пляже &amp;lt;/title&amp;gt; &amp;lt;id&amp;gt; http://example.org/blog/a-day-at-the-beach.xhtml &amp;lt;/id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17: 43 : 07Z &amp;lt;/updated&amp;gt; &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt; &amp;lt;/author&amp;gt; &amp;lt;content type = &quot;xhtml&quot;&amp;gt; &amp;lt;xhtml: div xmlns: xhtml = &quot;http://www.w3.org/1999/ XHTML &quot;&amp;gt;&amp;lt;xhtml: p&amp;gt; У нас был хороший день на пляже. &amp;lt;xhtml: img alt = &quot;the beach&quot; src = &quot;http://media.example.org/the_beach.png&quot; /&amp;gt; &amp;lt;/ xhtml: p&amp;gt; &amp;lt;xhtml: p&amp;gt; Позже мы спустились к пирсу. &amp;lt;xhtml: img alt = &quot;пирс&quot; src = &quot;http://media.example.org/the_pier.png&quot; /&amp;gt; &amp;lt;/ xhtml: p&amp;gt; &amp;lt;/ xhtml: div&amp;gt; &amp;lt;/content&amp;gt; &amp;lt;link rel = &quot; отредактируйте &quot;href =&quot; http://example.org/blog/edit/a-day-at-the-beach.atom &quot;/&amp;gt; &amp;lt;link rel =&quot; alternate &quot;type =&quot; text / html &quot;href =&quot; http: //example.org/blog/a-day-at-the-beach.html &quot;/&amp;gt; &amp;lt;/entry&amp;gt;Обратите внимание, что возвращенная запись содержит ссылку с отношением &amp;laquo;альтернатива&amp;raquo;, которая указывает на связанную HTML-страницу, которая была создана - это не требуется данной спецификацией, но включено, чтобы показать виды изменений, которые сервер может внести в Вступление.</target>
        </trans-unit>
        <trans-unit id="be9cb09a54952403acfaab07ff33017f6f0fca24" translate="yes" xml:space="preserve">
          <source>Below, the client sends a POST request containing an Atom Entry
   representation using the URI of the Collection:

       POST /edit/ HTTP/1.1
       Host: example.org
       User-Agent: Thingio/1.0
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Type: application/atom+xml;type=entry
       Content-Length: nnn
       Slug: First Post

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;Atom-Powered Robots Run Amok&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2003-12-13T18:30:02Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content&amp;gt;Some text.&amp;lt;/content&amp;gt;
       &amp;lt;/entry&amp;gt;

   The server signals a successful creation with a status code of 201.
   The response includes a Location header indicating the Member Entry
   URI of the Atom Entry, and a representation of that Entry in the body
   of the response.

       HTTP/1.1 201 Created
       Date: Fri, 7 Oct 2005 17:17:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry;charset=&quot;utf-8&quot;
       Location: http://example.org/edit/first-post.atom
       ETag: &quot;c180de84f991g8&quot; 

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;Atom-Powered Robots Run Amok&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2003-12-13T18:30:02Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content&amp;gt;Some text.&amp;lt;/content&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
             href=&quot;http://example.org/edit/first-post.atom&quot;/&amp;gt;
       &amp;lt;/entry&amp;gt;

   The Entry created and returned by the Collection might not match the
   Entry POSTed by the client.  A server MAY change the values of
   various elements in the Entry, such as the atom:id, atom:updated, and
   atom:author values, and MAY choose to remove or add other elements
   and attributes, or change element content and attribute values.</source>
          <target state="translated">Ниже клиент отправляет запрос POST, содержащий представление Atom Entry, используя URI коллекции: POST / edit / HTTP / 1.1 Host: example.org User-Agent: Thingio / 1.0 Авторизация: Basic ZGFmZnk6c2VjZXJldA == Content-Type: application / atom + xml; type = entry Длина содержимого: nnn Слаг: первое сообщение &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; Роботы на базе атома энергии выходят из-под контроля &amp;lt;/title&amp;gt; &amp;lt;id&amp;gt; urn: uuid: 1225c695-cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/id&amp;gt; &amp;lt;updated&amp;gt; 2003-12-13T18: 30: 02Z &amp;lt;/updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt; name&amp;gt; Джон Доу &amp;lt;/name&amp;gt; &amp;lt;/author&amp;gt; &amp;lt;content&amp;gt; Немного текста. &amp;lt;/content&amp;gt; &amp;lt;/entry&amp;gt;Сервер сигнализирует об успешном создании с кодом состояния 201. Ответ включает в себя заголовок Location, указывающий URI элемента-элемента записи Atom, и представление этой записи в теле ответа. HTTP / 1.1 201 Дата создания: пт, 7 октября 2005 г. 17:17:11 GMT Content-Length: nnn Content-Type: application / atom + xml; type = entry; charset = &quot;utf-8&quot; Расположение: http: // example.org/edit/first-post.atom ETag: &quot;c180de84f991g8&quot; &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; Atom -Питательные роботы выходят из-под контроля &amp;lt;/title&amp;gt; &amp;lt;id&amp;gt; urn: uuid: 1225c695-cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/id&amp;gt; &amp;lt;updated&amp;gt; 2003-12-13T18: 30: 02Z &amp;lt;/updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Джон Доу &amp;lt;/name&amp;gt; &amp;lt;/author&amp;gt; &amp;lt;content&amp;gt; Немного текста. &amp;lt;/content&amp;gt; &amp;lt;link rel = &quot;edit&quot; href = &quot;http://example.org/edit/first-post.atom&quot; /&amp;gt; &amp;lt;/entry&amp;gt; Запись, созданная и возвращенная коллекцией, может не совпадать с записью, отправленной клиентом. Сервер МОЖЕТ изменить значения различных элементов в записи, таких как значения atom: id, atom: updated и atom: author, и МОЖЕТ выбрать удаление или добавление других элементов и атрибутов или изменение содержимого элемента и значений атрибутов.Запись, созданная и возвращенная коллекцией, может не соответствовать записи, отправленной клиентом. Сервер МОЖЕТ изменить значения различных элементов в записи, таких как значения atom: id, atom: updated и atom: author, и МОЖЕТ выбрать удаление или добавление других элементов и атрибутов или изменение содержимого элемента и значений атрибутов.Запись, созданная и возвращенная коллекцией, может не соответствовать записи, отправленной клиентом. Сервер МОЖЕТ изменить значения различных элементов в записи, таких как значения atom: id, atom: updated и atom: author, и МОЖЕТ выбрать удаление или добавление других элементов и атрибутов или изменение содержимого элемента и значений атрибутов.</target>
        </trans-unit>
        <trans-unit id="552d2669fbc3963dfa12ac837a60570b8d21b825" translate="yes" xml:space="preserve">
          <source>Besides the setting of the validators on the server side, this mechanism is transparent: all browsers manage a cache and send such conditional requests without any special work to be done by Web developers.</source>
          <target state="translated">Кроме настройки валидаторов на стороне сервера,этот механизм прозрачен:все браузеры управляют кэшем и отправляют такие условные запросы без какой-либо специальной работы со стороны веб-разработчиков.</target>
        </trans-unit>
        <trans-unit id="95a31c7b8d5f0b04cb1a96329834684da05258b3" translate="yes" xml:space="preserve">
          <source>Best Practices for Using the Vary Header &amp;ndash; fastly.com</source>
          <target state="translated">Рекомендации по использованию Vary Header - fastly.com</target>
        </trans-unit>
        <trans-unit id="3696a45b0fbbf421a242df5da5ec4b688f7df3d0" translate="yes" xml:space="preserve">
          <source>Best practices for good user experiences</source>
          <target state="translated">Лучшие практики для хорошего опыта пользователей</target>
        </trans-unit>
        <trans-unit id="e8192d28d193fb637729d7681a715b53c8d8e6fa" translate="yes" xml:space="preserve">
          <source>Between the Web browser and the server, numerous computers and machines relay the HTTP messages. Due to the layered structure of the Web stack, most of these operate at either the transport, network or physical levels, becoming transparent at the HTTP layer and potentially making a significant impact on performance. Those operating at the application layers are generally called &lt;strong&gt;proxies&lt;/strong&gt;. These can be transparent, or not (changing requests going through them), and may perform numerous functions:</source>
          <target state="translated">Между веб-браузером и сервером множество компьютеров и машин передают сообщения HTTP. Из-за многоуровневой структуры веб-стека большинство из них работают на транспортном, сетевом или физическом уровнях, становясь прозрачными на уровне HTTP и потенциально оказывая значительное влияние на производительность. Те, которые работают на уровне приложений, обычно называются &lt;strong&gt;прокси&lt;/strong&gt; . Они могут быть прозрачными или нет (изменение запросов, проходящих через них) и могут выполнять множество функций:</target>
        </trans-unit>
        <trans-unit id="0a8c80fd5bfdf982f1a24e39074b4f6a15dfc943" translate="yes" xml:space="preserve">
          <source>Between the Web browser and the server, numerous computers and machines relay the HTTP messages. Due to the layered structure of the Web stack, most of these operate at the transport, network or physical levels, becoming transparent at the HTTP layer and potentially making a significant impact on performance. Those operating at the application layers are generally called &lt;strong&gt;proxies&lt;/strong&gt;. These can be transparent, forwarding on the requests they receive without altering them in any way, or non-transparent, in which case they will change the request in some way before passing it along to the server. Proxies may perform numerous functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43d1533f1d10a317b9afc62ab5e7c5e6d08f4b9" translate="yes" xml:space="preserve">
          <source>Bitmap file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e7b5639c2d5c6aefb6a4756b1924c7615e2b7af" translate="yes" xml:space="preserve">
          <source>Blink</source>
          <target state="translated">Blink</target>
        </trans-unit>
        <trans-unit id="d47c2c9d44766d5026529dab6ab5f38489055deb" translate="yes" xml:space="preserve">
          <source>Blink-based (Chromium, Google Chrome, Opera 15+)</source>
          <target state="translated">На основе мигания (Chromium,Google Chrome,Opera 15+).</target>
        </trans-unit>
        <trans-unit id="46790d0844afe283d3a8ad292d2479e6b7f8de27" translate="yes" xml:space="preserve">
          <source>Blink-based (Chromium, Google Chrome, Opera 15+, Edge on Android)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12dcd04f8772116c748e7a1686d74433478cbbb7" translate="yes" xml:space="preserve">
          <source>Block pages from loading when they detect reflected XSS attacks:</source>
          <target state="translated">Блокировать страницы от загрузки,когда они обнаруживают отраженные XSS-атаки:</target>
        </trans-unit>
        <trans-unit id="72005736b3d633e161ec04f9f5626d8efc05d101" translate="yes" xml:space="preserve">
          <source>Block the use of outdated APIs like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest&quot;&gt;synchronous XHR&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/write&quot;&gt;&lt;code&gt;document.write()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Заблокируйте использование устаревших API, таких как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest&quot;&gt;синхронный XHR&lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/write&quot;&gt; &lt;code&gt;document.write()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1284de1552841a2d74b9dd9edf7b2b69b49a7a36" translate="yes" xml:space="preserve">
          <source>Blocks a request if the request destination is of type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae08957fc64f7c37c7fd78d3088b53f4a0ac969" translate="yes" xml:space="preserve">
          <source>Blocks a request if the requested type is</source>
          <target state="translated">Блокирует запрос,если запрашиваемый тип является</target>
        </trans-unit>
        <trans-unit id="46c32d078786c9c754da18021b9cdd7c2ac0a06f" translate="yes" xml:space="preserve">
          <source>Blog post: &lt;a href=&quot;http://blog.sidstamm.com/2010/08/http-strict-transport-security-has.html&quot;&gt;HTTP Strict Transport Security has landed!&lt;/a&gt;</source>
          <target state="translated">Сообщение в блоге: &lt;a href=&quot;http://blog.sidstamm.com/2010/08/http-strict-transport-security-has.html&quot;&gt;Строгая безопасность транспорта HTTP приземлилась!&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f7b0d6ecddd36325803a206713ad475fcf71d8b" translate="yes" xml:space="preserve">
          <source>Blog post: &lt;a href=&quot;http://hacks.mozilla.org/2010/08/firefox-4-http-strict-transport-security-force-https/&quot;&gt;HTTP Strict Transport Security (force HTTPS)&lt;/a&gt;</source>
          <target state="translated">Сообщение в блоге: &lt;a href=&quot;http://hacks.mozilla.org/2010/08/firefox-4-http-strict-transport-security-force-https/&quot;&gt;HTTP Strict Transport Security (принудительный HTTPS)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b8bbcb0cbe3103f54b01e581bd5b4dcf154fe100" translate="yes" xml:space="preserve">
          <source>Blog post: &lt;a href=&quot;https://blog.sidstamm.com/2010/08/http-strict-transport-security-has.html&quot;&gt;HTTP Strict Transport Security has landed!&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37f2aceceb8d0bab8adfd81677e137c925113f15" translate="yes" xml:space="preserve">
          <source>Blog post: &lt;a href=&quot;https://hacks.mozilla.org/2010/08/firefox-4-http-strict-transport-security-force-https/&quot;&gt;HTTP Strict Transport Security (force HTTPS)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8874edbfb3bde7b175aaba19f751935d9beacccf" translate="yes" xml:space="preserve">
          <source>Bodies can be broadly divided into three categories:</source>
          <target state="translated">Тела можно разделить на три категории:</target>
        </trans-unit>
        <trans-unit id="2274273379451e1b300d8da8d1d55a10464ef909" translate="yes" xml:space="preserve">
          <source>Bodies can be broadly divided into two categories:</source>
          <target state="translated">Тела можно разделить на две категории:</target>
        </trans-unit>
        <trans-unit id="718a7e8a582e982e452dd5700addba4ffc1cf40d" translate="yes" xml:space="preserve">
          <source>Body</source>
          <target state="translated">Body</target>
        </trans-unit>
        <trans-unit id="c11c5c92eb4bb23f4e3a2e484b5d01a2f02ca7c0" translate="yes" xml:space="preserve">
          <source>Bourne shell script</source>
          <target state="translated">скрипт Борна</target>
        </trans-unit>
        <trans-unit id="35387df992c10423a1e97a8fdd9850a0e2b7c2bb" translate="yes" xml:space="preserve">
          <source>Brotli Compressed Data Format</source>
          <target state="translated">Формат сжатых данных Бротли</target>
        </trans-unit>
        <trans-unit id="ebd022bdbe14f7ec31423f0eeb91b8cd71a827f2" translate="yes" xml:space="preserve">
          <source>Browse through detailed HTTP reference documentation.</source>
          <target state="translated">Просмотрите подробную справочную документацию по HTTP.</target>
        </trans-unit>
        <trans-unit id="54a2cf5e634dbba0be2bf8a55f79252f5c790bdb" translate="yes" xml:space="preserve">
          <source>Browser</source>
          <target state="translated">Browser</target>
        </trans-unit>
        <trans-unit id="aac7378f1efd1829430797b0495fda2b1605e7e6" translate="yes" xml:space="preserve">
          <source>Browser Compatibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63fac1fb83ccf0b03f982fe1fa1a1b2cd86ed72c" translate="yes" xml:space="preserve">
          <source>Browser Name</source>
          <target state="translated">Имя браузера</target>
        </trans-unit>
        <trans-unit id="d18eb74e69d3d38bec47169d773de18efefdfab3" translate="yes" xml:space="preserve">
          <source>Browser behavior differs if this response erroneously includes a body on persistent connections See &lt;a href=&quot;204&quot;&gt;204 No Content&lt;/a&gt; for more detail.</source>
          <target state="translated">Поведение обозревателя отличается, если этот ответ ошибочно включает текст в постоянных соединениях. См. Дополнительные сведения в разделе &lt;a href=&quot;204&quot;&gt;204 Нет содержимого&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b99b91e559917941bb0e259fb1c7151b747a651d" translate="yes" xml:space="preserve">
          <source>Browser compatibility</source>
          <target state="translated">Совместимость с браузерами</target>
        </trans-unit>
        <trans-unit id="b36b7a67afaec4b763f7afbae4c6ac08d5194f85" translate="yes" xml:space="preserve">
          <source>Browser compatibility is not relevant for this header (header is sent by server, and the specification does not define client behaviour).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9596fac5cc2ce26e02f68794e8302c229989e32" translate="yes" xml:space="preserve">
          <source>Browser compatibility&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;Update compatibility data on GitHub&lt;/a&gt;</source>
          <target state="translated">Совместимость браузера &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;Обновление данных о совместимости на GitHub&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7fa3ab903e2b10d31d9550e3d19e0235e67965c5" translate="yes" xml:space="preserve">
          <source>Browser detection using the user agent</source>
          <target state="translated">Обнаружение браузера с помощью агента пользователя</target>
        </trans-unit>
        <trans-unit id="b250936e425b70355734e2e64ef7dec7333eb610" translate="yes" xml:space="preserve">
          <source>Browser fingerprinting is a set of techniques for identifying a
   specific user agent over time through its unique set of
   characteristics.  These characteristics might include information
   related to its TCP behavior, feature capabilities, and scripting
   environment, though of particular interest here is the set of unique
   characteristics that might be communicated via HTTP.  Fingerprinting
   is considered a privacy concern because it enables tracking of a user
   agent's behavior over time without the corresponding controls that
   the user might have over other forms of data collection (e.g.,
   cookies).  Many general-purpose user agents (i.e., Web browsers) have
   taken steps to reduce their fingerprints.

   There are a number of request header fields that might reveal
   information to servers that is sufficiently unique to enable
   fingerprinting.  The From header field is the most obvious, though it
   is expected that From will only be sent when self-identification is
   desired by the user.  Likewise, Cookie header fields are deliberately 

   designed to enable re-identification, so fingerprinting concerns only
   apply to situations where cookies are disabled or restricted by the
   user agent's configuration.

   The User-Agent header field might contain enough information to
   uniquely identify a specific device, usually when combined with other
   characteristics, particularly if the user agent sends excessive
   details about the user's system or extensions.  However, the source
   of unique information that is least expected by users is proactive
   negotiation (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;), including the Accept, Accept-Charset,
   Accept-Encoding, and Accept-Language header fields.

   In addition to the fingerprinting concern, detailed use of the
   Accept-Language header field can reveal information the user might
   consider to be of a private nature.  For example, understanding a
   given language set might be strongly correlated to membership in a
   particular ethnic group.  An approach that limits such loss of
   privacy would be for a user agent to omit the sending of
   Accept-Language except for sites that have been whitelisted, perhaps
   via interaction after detecting a Vary header field that indicates
   language negotiation might be useful.

   In environments where proxies are used to enhance privacy, user
   agents ought to be conservative in sending proactive negotiation
   header fields.  General-purpose user agents that provide a high
   degree of header field configurability ought to inform users about
   the loss of privacy that might result if too much detail is provided.
   As an extreme privacy measure, proxies could filter the proactive
   negotiation header fields in relayed requests.</source>
          <target state="translated">Отпечатки браузера - это набор методов для идентификации определенного пользовательского агента с течением времени с помощью его уникального набора характеристик. Эти характеристики могут включать информацию, относящуюся к его поведению TCP, возможностям функций и среде сценариев, хотя особый интерес здесь представляет набор уникальных характеристик, которые могут передаваться через HTTP. Отпечатки пальцев считаются проблемой конфиденциальности, потому что они позволяют отслеживать поведение пользовательского агента с течением времени без соответствующих элементов управления, которые пользователь может иметь над другими формами сбора данных (например, файлы cookie). Многие пользовательские агенты общего назначения (например, веб-браузеры) предприняли шаги, чтобы уменьшить количество отпечатков пальцев.Существует ряд полей заголовка запроса, которые могут раскрывать серверам информацию, которая достаточно уникальна для включения снятия отпечатков пальцев. Поле заголовка From является наиболее очевидным, хотя ожидается, что From будет отправляться только тогда, когда пользователь желает самоидентификации. Точно так же поля заголовка файлов cookie специально разработаны для обеспечения возможности повторной идентификации, поэтому проблемы с отпечатками пальцев относятся только к ситуациям, когда файлы cookie отключены или ограничены конфигурацией пользовательского агента. Поле заголовка User-Agent может содержать достаточно информации, чтобы однозначно идентифицировать конкретное устройство, обычно в сочетании с другими характеристиками, особенно если пользовательский агент отправляет чрезмерные сведения о системе или расширениях пользователя. Тем не мение,источником уникальной информации, которой меньше всего ожидают пользователи, являются проактивные переговоры (&lt;a href=&quot;#section-5.3&quot;&gt;Раздел 5.3&lt;/a&gt;), включая поля заголовка Accept, Accept-Charset, Accept-Encoding и Accept-Language. В дополнение к проблеме снятия отпечатков пальцев, подробное использование поля заголовка Accept-Language может раскрыть информацию, которую пользователь может счесть конфиденциальной. Например, понимание данного языкового набора может быть сильно коррелировано с принадлежностью к определенной этнической группе. Подход, ограничивающий такую ​​потерю конфиденциальности, заключался бы в том, чтобы пользовательский агент не отправлял Accept-Language, за исключением сайтов, которые были внесены в белый список, возможно, через взаимодействие после обнаружения поля заголовка Vary, которое указывает, что согласование языка может быть полезным. В средах, где прокси-серверы используются для повышения конфиденциальности, пользовательские агенты должны быть консервативными при отправке полей заголовка упреждающего согласования.Пользовательские агенты общего назначения, которые обеспечивают высокую степень настраиваемости поля заголовка, должны информировать пользователей о потере конфиденциальности, которая может произойти, если будет предоставлено слишком много деталей. В качестве крайней меры конфиденциальности прокси-серверы могут фильтровать поля заголовка упреждающего согласования в ретранслируемых запросах.</target>
        </trans-unit>
        <trans-unit id="2ed002e27e188e607dd038f852e9932680fbaaf2" translate="yes" xml:space="preserve">
          <source>Browser implementation is being discussed in &lt;a href=&quot;https://github.com/w3c/web-share/issues/169&quot;&gt;https://github.com/w3c/web-share/issues/169&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70dd2cd112b43ff0945574d1dda0f74996baa01" translate="yes" xml:space="preserve">
          <source>Browser specific notes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc469bc098ba2e7153a183b517baa5e07dc2864" translate="yes" xml:space="preserve">
          <source>Browser test site: &lt;a href=&quot;https://projects.dm.id.lv/Public-Key-Pins_test&quot;&gt;HSTS and HPKP test&lt;/a&gt;</source>
          <target state="translated">Сайт тестирования браузера: тест &lt;a href=&quot;https://projects.dm.id.lv/Public-Key-Pins_test&quot;&gt;HSTS и HPKP&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1d7e0a33cf80fe452070f36fa8edcaff2499ee3" translate="yes" xml:space="preserve">
          <source>Browser version</source>
          <target state="translated">Версия браузера</target>
        </trans-unit>
        <trans-unit id="d09fda30e9d38d9aabf757744c9bcebdabaa3f5c" translate="yes" xml:space="preserve">
          <source>Browsers &lt;strong&gt;ignore&lt;/strong&gt; the &lt;code&gt;Expect-CT&lt;/code&gt; header over HTTP; the header only has effect on HTTPS connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c3bd867e8f023b1e9b10989759e0116b284ac8" translate="yes" xml:space="preserve">
          <source>Browsers are migrating to have &lt;a href=&quot;https://www.chromestatus.com/feature/5088147346030592&quot;&gt;cookies default to &lt;code&gt;SameSite=Lax&lt;/code&gt;&lt;/a&gt;. If a cookie is needed to be sent cross-origin, opt out of the &lt;code&gt;SameSite&lt;/code&gt; restriction using the &lt;code&gt;None&lt;/code&gt; value. The &lt;code&gt;None&lt;/code&gt; value requires the &lt;a href=&quot;#Secure&quot;&gt;&lt;code&gt;Secure&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f273cb65b42c95174f6e5a89129c85c242b47c" translate="yes" xml:space="preserve">
          <source>Browsers are migrating to have &lt;a href=&quot;https://www.chromestatus.com/feature/5088147346030592&quot;&gt;cookies default to &lt;code&gt;SameSite=Lax&lt;/code&gt;&lt;/a&gt;. If a cookie is needed to be sent cross-origin, opt out of the SameSite restriction by using the &lt;code&gt;None&lt;/code&gt; directive. The &lt;code&gt;None&lt;/code&gt; directive requires that the &lt;a href=&quot;#Secure_and_HttpOnly_cookies&quot;&gt;&lt;code&gt;Secure&lt;/code&gt;&lt;/a&gt; attribute also be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="040b9395d8c1be97fa38d9005cfb38d82433885b" translate="yes" xml:space="preserve">
          <source>Browsers block frontend JavaScript code from accessing the &lt;code&gt;Set Cookie&lt;/code&gt; header, as required by the Fetch spec, which defines &lt;code&gt;Set-Cookie&lt;/code&gt; as a &lt;a href=&quot;https://fetch.spec.whatwg.org/#forbidden-response-header-name&quot;&gt;forbidden response-header name&lt;/a&gt; that &lt;a href=&quot;https://fetch.spec.whatwg.org/#ref-for-forbidden-response-header-name%E2%91%A0&quot;&gt;must be filtered out&lt;/a&gt; from any response exposed to frontend code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a862ea052d45f44e70d62ee3df599d55e7a99307" translate="yes" xml:space="preserve">
          <source>Browsers send specific &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; for cross-site requests initiated from within &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;. It also expects to see specific HTTP headers sent back with cross-site responses. An overview of these headers, including sample JavaScript code that initiates requests and processes responses from the server, as well as a discussion of each header, &lt;a href=&quot;cors&quot;&gt;can be found in the HTTP Access Control (CORS) article&lt;/a&gt; and should be read as a companion article to this one. This article covers processing &lt;strong&gt;Access Control Requests&lt;/strong&gt; and formulating &lt;strong&gt;Access Control Responses&lt;/strong&gt; in PHP. The target audience for this article are server programmers or administrators. Although the code samples shown here are in PHP, similar concepts apply for ASP.net, Perl, Python, Java, etc.; in general, these concepts can be applied to any server-side programming environment that processes HTTP requests and dynamically formulates HTTP responses.</source>
          <target state="translated">Браузеры отправляют определенные &lt;a href=&quot;headers&quot;&gt;заголовки HTTP&lt;/a&gt; для межсайтовых запросов, инициированных из &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; . Он также ожидает, что определенные HTTP-заголовки будут отправлены обратно с межсайтовыми ответами. Обзор этих заголовков, включая образец кода JavaScript, который инициирует запросы и обрабатывает ответы от сервера, а также обсуждение каждого заголовка &lt;a href=&quot;cors&quot;&gt;можно найти в статье HTTP Access Control (CORS),&lt;/a&gt; и ее следует читать как сопутствующую статью к вот этот. В этой статье рассматривается обработка &lt;strong&gt;запросов управления доступом&lt;/strong&gt; и формулирование &lt;strong&gt;ответов на управление доступом.&lt;/strong&gt;в PHP. Целевая аудитория этой статьи - серверные программисты или администраторы. Хотя примеры кода, показанные здесь, написаны на PHP, аналогичные концепции применимы к ASP.net, Perl, Python, Java и т. Д .; В общем, эти концепции могут применяться к любой серверной среде программирования, которая обрабатывает HTTP-запросы и динамически формулирует HTTP-ответы.</target>
        </trans-unit>
        <trans-unit id="f862e5c244452929ab40c4ceda509655ef249fcb" translate="yes" xml:space="preserve">
          <source>Browsers use &lt;code&gt;utf-8&lt;/code&gt; encoding for usernames and passwords.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d0e2f5033f06ac6f49cc655a388250e954dd48" translate="yes" xml:space="preserve">
          <source>Browsers use &lt;code&gt;utf-8&lt;/code&gt; encoding for usernames and passwords. Firefox used to use &lt;code&gt;ISO-8859-1&lt;/code&gt;, but changed over to &lt;code&gt;utf-8&lt;/code&gt; for parity with other browsers, and to avoid potential problems as described in &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1419658&quot;&gt;bug 1419658&lt;/a&gt;.</source>
          <target state="translated">Браузеры используют кодировку &lt;code&gt;utf-8&lt;/code&gt; для имен пользователей и паролей. Firefox использовал &lt;code&gt;ISO-8859-1&lt;/code&gt; , но перешел на &lt;code&gt;utf-8&lt;/code&gt; для паритета с другими браузерами и во избежание потенциальных проблем, как описано в &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1419658&quot;&gt;ошибке 1419658&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a63957685418f827a422303f2aa0c711fe3143d4" translate="yes" xml:space="preserve">
          <source>Browsers use the MIME type, &lt;strong&gt;not the file extension&lt;/strong&gt;, to determine how to process a URL &amp;mdash; it is important that servers send the correct MIME type in the response's &lt;a href=&quot;../headers/content-type&quot;&gt;Content-Type header&lt;/a&gt;.</source>
          <target state="translated">Браузеры используют тип MIME, а &lt;strong&gt;не расширение файла&lt;/strong&gt; , чтобы определить, как обрабатывать URL-адрес - важно, чтобы серверы отправляли правильный тип MIME в &lt;a href=&quot;../headers/content-type&quot;&gt;заголовке Content-Type&lt;/a&gt; ответа .</target>
        </trans-unit>
        <trans-unit id="2e9afcf709277aae6a6520057ea60bf3be39c90b" translate="yes" xml:space="preserve">
          <source>Browsers will not remember an &lt;code&gt;Expect-CT&lt;/code&gt; policy, unless the site has 'proven' it can serve a certificate satisfying the certificate transparency requirements. Browsers implement their own trust model regarding which CT logs are considered trusted for the certificate to have been logged to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc12d6c5418def433565d97fa4386bb760ddfa9" translate="yes" xml:space="preserve">
          <source>Buggy &lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_server&quot;&gt;proxies&lt;/a&gt; are still common and these lead to strange and erratic behaviors that Web developers cannot foresee and diagnose easily.</source>
          <target state="translated">Прокси- &lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_server&quot;&gt;серверы с ошибками&lt;/a&gt; все еще распространены, и они приводят к странному и неустойчивому поведению, которое веб-разработчики не могут легко предвидеть и диагностировать.</target>
        </trans-unit>
        <trans-unit id="a08f5341fe1477c327aaa2ec714bb0a54bdba4f3" translate="yes" xml:space="preserve">
          <source>Bugzilla bug 1459573</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82fd0d6dc5b3bab8b83886f108ed9c6addec57a9" translate="yes" xml:space="preserve">
          <source>Builds of Chrome are designed to stop enforcing the &lt;code&gt;Expect-CT&lt;/code&gt; policy 10 weeks after the installation's build date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3838036b670cc0248afd246abbe594ee328cf4de" translate="yes" xml:space="preserve">
          <source>But browsers and standards are not perfect, and there are still some edge cases where detecting the browser is needed. Using the user agent to detect the browser looks simple, but doing it well is, in fact, a very hard problem. This document will guide you in doing this as correctly as possible.</source>
          <target state="translated">Но браузеры и стандарты не совершенны,и все еще есть некоторые крайние случаи,когда необходимо обнаружить браузер.Использование пользовательского агента для обнаружения браузера выглядит просто,но делать это хорошо-это,на самом деле,очень сложная проблема.Этот документ поможет вам сделать это как можно правильнее.</target>
        </trans-unit>
        <trans-unit id="7c8e3ceffa66e087ea7c8b96aa7587bcaf4d90e8" translate="yes" xml:space="preserve">
          <source>But if it&amp;rsquo;s not possible to make those changes, then another way that may be possible is to this:</source>
          <target state="translated">Но если эти изменения внести невозможно, то возможен другой способ:</target>
        </trans-unit>
        <trans-unit id="d7241a2b594de7bc64154d28757129ce26170606" translate="yes" xml:space="preserve">
          <source>By default the policy is set to &lt;code&gt;*&lt;/code&gt;, which means synchronous requests are allowed in all frames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95da926485cbe7c1b54926edc5fadc82e556e609" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP&lt;/a&gt; requests are issued sequentially. The next request is only issued once the response to the current request has been received. As they are affected by network latencies and bandwidth limitations, this can result in significant delay before the next request is &lt;em&gt;seen&lt;/em&gt; by the server.</source>
          <target state="translated">По умолчанию запросы &lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP&lt;/a&gt; отправляются последовательно. Следующий запрос выдается только после получения ответа на текущий запрос. Поскольку на них влияют задержки сети и ограничения полосы пропускания, это может привести к значительной задержке до того, как следующий запрос будет &lt;em&gt;виден&lt;/em&gt; сервером.</target>
        </trans-unit>
        <trans-unit id="6abb5b1e0911f25ada48f489e06f7debe4790d8f" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; requests are issued sequentially. The next request is only issued once the response to the current request has been received. As they are affected by network latencies and bandwidth limitations, this can result in significant delay before the next request is &lt;em&gt;seen&lt;/em&gt; by the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbfb748d8e0737c34e1264e5236d921dd7f9917f" translate="yes" xml:space="preserve">
          <source>By default, a response is cacheable if the requirements of the
   request method, request header fields, and the response status
   indicate that it is cacheable. &lt;a href=&quot;#section-13.4&quot;&gt;Section 13.4&lt;/a&gt; summarizes these defaults
   for cacheability. The following Cache-Control response directives
   allow an origin server to override the default cacheability of a
   response:

   public
      Indicates that the response MAY be cached by any cache, even if it
      would normally be non-cacheable or cacheable only within a non-
      shared cache. (See also Authorization, &lt;a href=&quot;#section-14.8&quot;&gt;section 14.8&lt;/a&gt;, for
      additional details.)

   private
      Indicates that all or part of the response message is intended for
      a single user and MUST NOT be cached by a shared cache. This
      allows an origin server to state that the specified parts of the 

      response are intended for only one user and are not a valid
      response for requests by other users. A private (non-shared) cache
      MAY cache the response.

       Note: This usage of the word private only controls where the
       response may be cached, and cannot ensure the privacy of the
       message content.

   no-cache
       If the no-cache directive does not specify a field-name, then a
      cache MUST NOT use the response to satisfy a subsequent request
      without successful revalidation with the origin server. This
      allows an origin server to prevent caching even by caches that
      have been configured to return stale responses to client requests.

      If the no-cache directive does specify one or more field-names,
      then a cache MAY use the response to satisfy a subsequent request,
      subject to any other restrictions on caching. However, the
      specified field-name(s) MUST NOT be sent in the response to a
      subsequent request without successful revalidation with the origin
      server. This allows an origin server to prevent the re-use of
      certain header fields in a response, while still allowing caching
      of the rest of the response.

       Note: Most HTTP/1.0 caches will not recognize or obey this
       directive.</source>
          <target state="translated">По умолчанию ответ кэшируется, если требования метода запроса, полей заголовка запроса и состояния ответа указывают, что он кэшируется. &lt;a href=&quot;#section-13.4&quot;&gt;Раздел 13.4&lt;/a&gt; суммирует эти значения по умолчанию для кэшируемости. Следующие директивы ответа Cache-Control позволяют исходному серверу переопределить кэшируемость ответа по умолчанию: public Указывает, что ответ МОЖЕТ быть кэширован любым кешем, даже если он обычно не кэшируется или кешируется только в необщем кэше , (См. Также Авторизация, &lt;a href=&quot;#section-14.8&quot;&gt;раздел 14.8.&lt;/a&gt;, для получения дополнительной информации.) private Указывает, что все или часть ответного сообщения предназначена для одного пользователя и НЕ ДОЛЖНА кэшироваться в общем кэше. Это позволяет исходному серверу утверждать, что указанные части ответа предназначены только для одного пользователя и не являются допустимым ответом для запросов других пользователей. Частный (не общий) кеш МОЖЕТ кэшировать ответ. Примечание. Такое использование слова &amp;laquo;частный&amp;raquo; контролирует только то, где можно кэшировать ответ, и не может гарантировать конфиденциальность содержимого сообщения. no-cache Если директива no-cache не определяет имя поля, то кэш НЕ ДОЛЖЕН использовать ответ для удовлетворения последующего запроса без успешной повторной проверки на исходном сервере.Это позволяет исходному серверу предотвращать кеширование даже кешами, которые были настроены для возврата устаревших ответов на запросы клиентов. Если директива no-cache указывает одно или несколько имен полей, то кеш МОЖЕТ использовать ответ для удовлетворения последующего запроса с учетом любых других ограничений на кэширование. Однако указанные имена полей НЕ ДОЛЖНЫ быть отправлены в ответе на последующий запрос без успешной повторной проверки исходным сервером. Это позволяет исходному серверу предотвращать повторное использование определенных полей заголовка в ответе, сохраняя при этом возможность кэширования остальной части ответа. Примечание. Большинство кешей HTTP / 1.0 не распознают эту директиву и не подчиняются ей.Если директива no-cache указывает одно или несколько имен полей, то кеш МОЖЕТ использовать ответ для удовлетворения последующего запроса с учетом любых других ограничений на кэширование. Однако указанные имена полей НЕ ДОЛЖНЫ быть отправлены в ответе на последующий запрос без успешной повторной проверки исходным сервером. Это позволяет исходному серверу предотвращать повторное использование определенных полей заголовка в ответе, сохраняя при этом возможность кэширования остальной части ответа. Примечание. Большинство кешей HTTP / 1.0 не распознают эту директиву и не подчиняются ей.Если директива no-cache указывает одно или несколько имен полей, то кеш МОЖЕТ использовать ответ для удовлетворения последующего запроса с учетом любых других ограничений на кэширование. Однако указанные имена полей НЕ ДОЛЖНЫ отправляться в ответе на последующий запрос без успешной повторной проверки исходным сервером. Это позволяет исходному серверу предотвращать повторное использование определенных полей заголовка в ответе, сохраняя при этом возможность кэширования остальной части ответа. Примечание. Большинство кешей HTTP / 1.0 не распознают эту директиву и не подчиняются ей.указанные имена полей НЕ ДОЛЖНЫ быть отправлены в ответ на последующий запрос без успешной повторной проверки исходным сервером. Это позволяет исходному серверу предотвращать повторное использование определенных полей заголовка в ответе, сохраняя при этом возможность кэширования остальной части ответа. Примечание. Большинство кешей HTTP / 1.0 не распознают эту директиву и не подчиняются ей.указанные имена полей НЕ ДОЛЖНЫ быть отправлены в ответ на последующий запрос без успешной повторной проверки исходным сервером. Это позволяет исходному серверу предотвращать повторное использование определенных полей заголовка в ответе, сохраняя при этом возможность кэширования остальной части ответа. Примечание. Большинство кешей HTTP / 1.0 не распознают эту директиву и не подчиняются ей.</target>
        </trans-unit>
        <trans-unit id="11cebe099b732834a230be98a924681140743e7e" translate="yes" xml:space="preserve">
          <source>By default, only the 6 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Simple_response_header&quot;&gt;simple response headers&lt;/a&gt; are exposed:</source>
          <target state="translated">По умолчанию отображаются только 6 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Simple_response_header&quot;&gt;простых заголовков ответа&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="fa262e31090b07e93005688b0506414a054e9ae2" translate="yes" xml:space="preserve">
          <source>By default, only the 7 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_response_header&quot;&gt;CORS-safelisted response headers&lt;/a&gt; are exposed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f534edc05bd142ea112ee3efccba58b43dd4c66" translate="yes" xml:space="preserve">
          <source>By default, the Geolocation API can be used within top-level documents and their same-origin child frames. This directive allows or prevents cross-origin frames from accessing geolocation. This includes same-origin frames.</source>
          <target state="translated">По умолчанию Geolocation API может использоваться внутри документов верхнего уровня и их дочерних фреймов одинакового происхождения.Эта директива разрешает или запрещает доступ к геолокации фреймов перекрестного происхождения.Это включает в себя фреймы однотипного происхождения.</target>
        </trans-unit>
        <trans-unit id="e044c03f1a747bedf5cf5499ef70c090ed113f76" translate="yes" xml:space="preserve">
          <source>By default, top-level documents and their same-origin child frames can request and enter fullscreen mode. This directive allows or prevents cross-origin frames from using fullscreen mode. This includes same-origin frames.</source>
          <target state="translated">По умолчанию документы верхнего уровня и их дочерние кадры однородного происхождения могут запрашивать и входить в полноэкранный режим.Эта директива позволяет или запрещает использовать кросс-оригинальные кадры в полноэкранном режиме.Она включает в себя кадры однотипного происхождения.</target>
        </trans-unit>
        <trans-unit id="d23c07d6cec707b5f2b899cf897854aba60b3de4" translate="yes" xml:space="preserve">
          <source>By default, violation reports aren't sent. To enable violation reporting, you need to specify the &lt;a href=&quot;headers/content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; policy directive, providing at least one URI to which to deliver the reports:</source>
          <target state="translated">По умолчанию отчеты о нарушениях не отправляются. Чтобы включить отчет о нарушениях, вам необходимо указать директиву политики &lt;a href=&quot;headers/content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; , указав хотя бы один URI, по которому будут доставляться отчеты:</target>
        </trans-unit>
        <trans-unit id="8029f70a8cb4b060850538e53207e165c56eb9a2" translate="yes" xml:space="preserve">
          <source>By far, the most common use case for upgrading an HTTP connection is to use WebSockets, which are always implemented by upgrading an HTTP or HTTPS connection. Keep in mind that if you're opening a new connection using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&quot;&gt;WebSocket API&lt;/a&gt;, or any library that does WebSockets, most or all of this is done for you. For example, opening a WebSocket connection is as simple as:</source>
          <target state="translated">Безусловно, наиболее распространенным вариантом обновления HTTP-соединения является использование WebSockets, которые всегда реализуются путем обновления HTTP- или HTTPS-соединения. Имейте в виду, что если вы открываете новое соединение с помощью &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&quot;&gt;API WebSocket&lt;/a&gt; или любой библиотеки, которая выполняет WebSockets, большая часть или все это делается за вас. Например, открыть соединение WebSocket очень просто:</target>
        </trans-unit>
        <trans-unit id="8e0591ef828136aecdfc13e9fe74e5b53dd0d8e6" translate="yes" xml:space="preserve">
          <source>By specifying the &lt;code&gt;'none'&lt;/code&gt; keyword for the origin list, the specified features will be disabled for all browsing contexts (this includes all iframes), regardless of their origin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8358024c4d3220c8cee184585d77cac9c14c31ac" translate="yes" xml:space="preserve">
          <source>By specifying the &lt;code&gt;'none'&lt;/code&gt; keyword for the origin list, the specified features will be disabled for all browsing contexts, regardless of their origin.</source>
          <target state="translated">Если указать ключевое слово &lt;code&gt;'none'&lt;/code&gt; для исходного списка, указанные функции будут отключены для всех контекстов просмотра, независимо от их происхождения.</target>
        </trans-unit>
        <trans-unit id="424fa2e5f873eae608f951882e066b4cbc6e7248" translate="yes" xml:space="preserve">
          <source>By their very nature, HTTP intermediaries are men-in-the-middle and,
   thus, represent an opportunity for man-in-the-middle attacks.
   Compromise of the systems on which the intermediaries run can result
   in serious security and privacy problems.  Intermediaries might have
   access to security-related information, personal information about
   individual users and organizations, and proprietary information
   belonging to users and content providers.  A compromised
   intermediary, or an intermediary implemented or configured without
   regard to security and privacy considerations, might be used in the
   commission of a wide range of potential attacks.

   Intermediaries that contain a shared cache are especially vulnerable
   to cache poisoning attacks, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-8&quot;&gt;Section&amp;nbsp;8 of [RFC7234]&lt;/a&gt;. 

   Implementers need to consider the privacy and security implications
   of their design and coding decisions, and of the configuration
   options they provide to operators (especially the default
   configuration).

   Users need to be aware that intermediaries are no more trustworthy
   than the people who run them; HTTP itself cannot solve this problem.</source>
          <target state="translated">По самой своей природе посредники HTTP являются посредниками и, таким образом, представляют возможность для атак типа &amp;laquo;злоумышленник посередине&amp;raquo;. Компрометация систем, в которых работают посредники, может привести к серьезным проблемам с безопасностью и конфиденциальностью. Посредники могут иметь доступ к информации, связанной с безопасностью, личной информации об отдельных пользователях и организациях, а также частной информации, принадлежащей пользователям и поставщикам контента. Скомпрометированный посредник или посредник, реализованный или настроенный без учета соображений безопасности и конфиденциальности, может использоваться для совершения широкого спектра потенциальных атак. Посредники, содержащие общий кеш, особенно уязвимы для атак с отравлением кеша, как описано в &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-8&quot;&gt;разделе 8 [RFC7234]&lt;/a&gt;, Разработчикам необходимо учитывать последствия своих решений по проектированию и кодированию для конфиденциальности и безопасности, а также параметры конфигурации, которые они предоставляют операторам (особенно конфигурацию по умолчанию). Пользователи должны знать, что посредники заслуживают доверия не больше, чем люди, которые ими управляют; Сам HTTP не может решить эту проблему.</target>
        </trans-unit>
        <trans-unit id="068b79ba257daf146b30abe76ed868aecb1b606b" translate="yes" xml:space="preserve">
          <source>By their very nature, HTTP proxies are men-in-the-middle, and
   represent an opportunity for man-in-the-middle attacks. Compromise of
   the systems on which the proxies run can result in serious security
   and privacy problems. Proxies have access to security-related
   information, personal information about individual users and
   organizations, and proprietary information belonging to users and
   content providers. A compromised proxy, or a proxy implemented or
   configured without regard to security and privacy considerations,
   might be used in the commission of a wide range of potential attacks.

   Proxy operators should protect the systems on which proxies run as
   they would protect any system that contains or transports sensitive
   information. In particular, log information gathered at proxies often
   contains highly sensitive personal information, and/or information
   about organizations. Log information should be carefully guarded, and
   appropriate guidelines for use developed and followed. (&lt;a href=&quot;#section-15.1.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt;). 

   Caching proxies provide additional potential vulnerabilities, since
   the contents of the cache represent an attractive target for
   malicious exploitation. Because cache contents persist after an HTTP
   request is complete, an attack on the cache can reveal information
   long after a user believes that the information has been removed from
   the network. Therefore, cache contents should be protected as
   sensitive information.

   Proxy implementors should consider the privacy and security
   implications of their design and coding decisions, and of the
   configuration options they provide to proxy operators (especially the
   default configuration).

   Users of a proxy need to be aware that they are no trustworthier than
   the people who run the proxy; HTTP itself cannot solve this problem.

   The judicious use of cryptography, when appropriate, may suffice to
   protect against a broad range of security and privacy attacks. Such
   cryptography is beyond the scope of the HTTP/1.1 specification.</source>
          <target state="translated">По самой своей природе прокси-серверы HTTP являются посредниками и представляют собой возможность для атак типа &amp;laquo;злоумышленник посередине&amp;raquo;. Компрометация систем, на которых работают прокси, может привести к серьезным проблемам с безопасностью и конфиденциальностью. Прокси-серверы имеют доступ к информации, связанной с безопасностью, личной информации об отдельных пользователях и организациях, а также частной информации, принадлежащей пользователям и поставщикам контента. Скомпрометированный прокси-сервер или прокси-сервер, реализованный или настроенный без учета соображений безопасности и конфиденциальности, может использоваться для совершения широкого спектра потенциальных атак. Операторы прокси должны защищать системы, на которых работают прокси, так же, как они защищают любую систему, которая содержит или передает конфиденциальную информацию. В частности,Информация журнала, собранная через прокси, часто содержит очень важную личную информацию и / или информацию об организациях. Информация в журнале должна тщательно храниться, а соответствующие инструкции по использованию должны быть разработаны и соблюдаться. (&lt;a href=&quot;#section-15.1.1&quot;&gt;Раздел &lt;/a&gt;&lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt;). Кэширующие прокси-серверы предоставляют дополнительные потенциальные уязвимости, поскольку содержимое кеша представляет собой привлекательную цель для злонамеренного использования. Поскольку содержимое кеша сохраняется после завершения HTTP-запроса, атака на кеш может раскрыть информацию еще долгое время после того, как пользователь считает, что информация была удалена из сети. Следовательно, содержимое кеша следует защищать как конфиденциальную информацию. Разработчики прокси должны учитывать последствия для конфиденциальности и безопасности своих решений по проектированию и кодированию, а также параметры конфигурации, которые они предоставляют операторам прокси (особенно конфигурация по умолчанию). Пользователи прокси должны знать, что они не заслуживают большего доверия, чем люди, которые запускают прокси; Сам HTTP не может решить эту проблему. Разумное использование криптографии,при необходимости, может быть достаточно для защиты от широкого спектра атак на безопасность и конфиденциальность. Такая криптография выходит за рамки спецификации HTTP / 1.1.</target>
        </trans-unit>
        <trans-unit id="0385baee4e5a7514e39184b6448baf26de0bf842" translate="yes" xml:space="preserve">
          <source>Bypassing additional restrictions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dfb40a9e84e63716a4b33d9963c4cfd678075a5" translate="yes" xml:space="preserve">
          <source>Byte Ranges (RFC 7233)</source>
          <target state="translated">Диапазон байт (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="b18368c56eb40788963923a6e1129947a0d58087" translate="yes" xml:space="preserve">
          <source>C-Shell script</source>
          <target state="translated">скрипт на C-Shell</target>
        </trans-unit>
        <trans-unit id="6e288959d3443bcec62386f7d9014542f6872829" translate="yes" xml:space="preserve">
          <source>CONNECT</source>
          <target state="translated">CONNECT</target>
        </trans-unit>
        <trans-unit id="2600bf1e8e192e1bd65ac3bc3a4d82977f60d6da" translate="yes" xml:space="preserve">
          <source>CONNECT (RFC 7231)</source>
          <target state="translated">СОЕДИНИТЬСЯ (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="3f06f1ede16af06a408e9c55accedff143ec05ac" translate="yes" xml:space="preserve">
          <source>COOP will process-isolate your document and potential attackers can't access to your global object if they were opening it in a popup, preventing a set of cross-origin attacks dubbed &lt;a href=&quot;https://github.com/xsleaks/xsleaks&quot;&gt;XS-Leaks&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b0c89f90f23a658ff74ef5bd072768c76288f7" translate="yes" xml:space="preserve">
          <source>CORP is an additional layer of protection beyond the default &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. Cross-Origin Resource Policy complements &lt;a href=&quot;https://fetch.spec.whatwg.org/#corb&quot;&gt;Cross-Origin Read Blocking&lt;/a&gt; (CORB), which is a mechanism to prevent some cross-origin reads by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2139aadec237bbecb581e62932f94bc3bce7a704" translate="yes" xml:space="preserve">
          <source>CORS</source>
          <target state="translated">CORS</target>
        </trans-unit>
        <trans-unit id="6296a1fd2a34552fbb648aabe29411711a0e4595" translate="yes" xml:space="preserve">
          <source>CORS and caching</source>
          <target state="translated">CORS и кэширование</target>
        </trans-unit>
        <trans-unit id="3c63268612970c5bd579c70dbeed257045fe1f70" translate="yes" xml:space="preserve">
          <source>CORS enabled image</source>
          <target state="translated">CORS включенное изображение</target>
        </trans-unit>
        <trans-unit id="e825c1a70b304027f50005fcb1118744bfcdf168" translate="yes" xml:space="preserve">
          <source>CORS error messages</source>
          <target state="translated">сообщения об ошибках CORS</target>
        </trans-unit>
        <trans-unit id="184d3111cdadf6b3fad8c042206c94ffd04e65c3" translate="yes" xml:space="preserve">
          <source>CORS errors</source>
          <target state="translated">CORS-ошибки</target>
        </trans-unit>
        <trans-unit id="d1cb428716c692d19e9dc06754cff0043e662a41" translate="yes" xml:space="preserve">
          <source>CORS failures result in errors, but for security reasons, specifics about the error &lt;em&gt;are not available to JavaScript&lt;/em&gt;. All the code knows is that an error occurred. The only way to determine what specifically went wrong is to look at the browser's console for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e389a185748256670e3bef3e9d485d4db6698009" translate="yes" xml:space="preserve">
          <source>CORS failures result in errors, but for security reasons, specifics about what went wrong &lt;em&gt;are not available to JavaScript code&lt;/em&gt;. All the code knows is that an error occurred. The only way to determine what specifically went wrong is to look at the browser's console for details.</source>
          <target state="translated">Сбои CORS приводят к ошибкам, но по соображениям безопасности подробности о том, что пошло &lt;em&gt;не так, недоступны для кода JavaScript&lt;/em&gt; . Код знает, что произошла ошибка. Единственный способ определить, что именно пошло не так, - посмотреть подробности в консоли браузера.</target>
        </trans-unit>
        <trans-unit id="de24c9d37107bb00fdf3a04f2c2a9d24eabcbabc" translate="yes" xml:space="preserve">
          <source>CORS introduction</source>
          <target state="translated">внедрение CORS</target>
        </trans-unit>
        <trans-unit id="ee0eba3ae2bb3a8277a088b3fe2cba0700041b16" translate="yes" xml:space="preserve">
          <source>CORS settings attributes</source>
          <target state="translated">атрибуты настроек CORS</target>
        </trans-unit>
        <trans-unit id="089d646aeb28f1767e0d39506004c44f044e2a50" translate="yes" xml:space="preserve">
          <source>CORS-safelisted request header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c658a0ab02da27fa9bc91475d5f929983201d0e9" translate="yes" xml:space="preserve">
          <source>CORS-safelisted request-header</source>
          <target state="translated">Заголовок запроса,защищенный системой CORS.</target>
        </trans-unit>
        <trans-unit id="303b72d3bf7642992ec9938ae19c4e19cbd5022d" translate="yes" xml:space="preserve">
          <source>CORS-safelisted response header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4822cee4b44a5acfdf824aef5c202c725aa2e1ef" translate="yes" xml:space="preserve">
          <source>CORS-safelisted response-header</source>
          <target state="translated">CORS-безопасный заголовок ответа</target>
        </trans-unit>
        <trans-unit id="3115498a58c30161e8334af0606a41f44c318e04" translate="yes" xml:space="preserve">
          <source>CSP</source>
          <target state="translated">CSP</target>
        </trans-unit>
        <trans-unit id="70771af22a8b356fbf094cdf8ec696e798056732" translate="yes" xml:space="preserve">
          <source>CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive</source>
          <target state="translated">Директива CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="44f87a469d5fa9f5e3c9a3ab2c29c19df8341c51" translate="yes" xml:space="preserve">
          <source>CSP &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive</source>
          <target state="translated">Директива CSP &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2e0d3366da966d21d7a419c2ed0bbe7fe3d112f6" translate="yes" xml:space="preserve">
          <source>CSP Level 2 frame-ancestors directive</source>
          <target state="translated">Директива CSP фрейм-анцесторов 2-го уровня</target>
        </trans-unit>
        <trans-unit id="d9132b00c8144355d2ffb30916581bd6454aef63" translate="yes" xml:space="preserve">
          <source>CSP allows multiple policies being specified for a resource, including via the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header, the &lt;a href=&quot;content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">CSP позволяет указывать несколько политик для ресурса, в том числе через заголовок &lt;code&gt;Content-Security-Policy&lt;/code&gt; , заголовок &lt;a href=&quot;content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; и элемент &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84514b55cad8a4471776e8261e9056e00bb80eff" translate="yes" xml:space="preserve">
          <source>CSP directives</source>
          <target state="translated">директивы CSP</target>
        </trans-unit>
        <trans-unit id="6edf30c08fbe221348e45d46487682ad464890a5" translate="yes" xml:space="preserve">
          <source>CSP directives (&lt;a href=&quot;https://www.w3.org/TR/CSP/#csp-directives&quot;&gt;https://www.w3.org/TR/CSP/#csp-directives&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da26228b4f698331031c5864aacaf5b9f95766d7" translate="yes" xml:space="preserve">
          <source>CSP for Web Workers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="612d537b7ed50a4dda4dafd9890db5ab966fe8e6" translate="yes" xml:space="preserve">
          <source>CSP in Web Workers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7e232a207938fbc334d7ae81fd9271bdea2b5f" translate="yes" xml:space="preserve">
          <source>CSP in workers</source>
          <target state="translated">CSP в рабочих</target>
        </trans-unit>
        <trans-unit id="62becf9c2b19df7737b78178e6297a23a4286119" translate="yes" xml:space="preserve">
          <source>CSP is designed to be fully backward compatible (except CSP version 2 where there are some explicitly-mentioned inconsistencies in backward compatibility; more details &lt;a href=&quot;https://www.w3.org/TR/CSP2&quot;&gt;here&lt;/a&gt; section 1.1). Browsers that don't support it still work with servers that implement it, and vice-versa: browsers that don't support CSP simply ignore it, functioning as usual, defaulting to the standard same-origin policy for web content. If the site doesn't offer the CSP header, browsers likewise use the standard &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;.</source>
          <target state="translated">CSP предназначен для полной обратной совместимости (кроме НСП версии 2 , где есть некоторые эксплицитно упомянутые противоречия в обратной совместимости; более подробно &lt;a href=&quot;https://www.w3.org/TR/CSP2&quot;&gt;здесь&lt;/a&gt; раздел 1.1). Браузеры, которые не поддерживают его, по-прежнему работают с серверами, которые его реализуют, и наоборот: браузеры, не поддерживающие CSP, просто игнорируют его, функционируя как обычно, по умолчанию применяя стандартную политику одного происхождения для веб-контента. Если сайт не предлагает заголовок CSP, браузеры также используют стандартную &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;политику одного и того же происхождения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c066fd6908e5e3d0bb62d17e654cbfe8a428f91" translate="yes" xml:space="preserve">
          <source>CSP makes it possible for server administrators to reduce or eliminate the vectors by which XSS can occur by specifying the domains that the browser should consider to be valid sources of executable scripts. A CSP compatible browser will then only execute scripts loaded in source files received from those allowlisted domains, ignoring all other script (including inline scripts and event-handling HTML attributes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc54f753bc7cbbc002ef53de42786ebf31429cfa" translate="yes" xml:space="preserve">
          <source>CSP makes it possible for server administrators to reduce or eliminate the vectors by which XSS can occur by specifying the domains that the browser should consider to be valid sources of executable scripts. A CSP compatible browser will then only execute scripts loaded in source files received from those whitelisted domains, ignoring all other script (including inline scripts and event-handling HTML attributes).</source>
          <target state="translated">CSP позволяет администраторам серверов уменьшить или устранить векторы,по которым может происходить XSS,указав домены,которые браузер должен рассматривать как действительные источники исполняемых скриптов.В этом случае браузер,совместимый с CSP,будет выполнять только скрипты,загруженные в исходные файлы,полученные из этих белых списков доменов,игнорируя все остальные скрипты (включая встроенные скрипты и атрибуты HTML,обрабатывающие события).</target>
        </trans-unit>
        <trans-unit id="7031a0ce63915761c940ed51b1837a242dbd3b4b" translate="yes" xml:space="preserve">
          <source>CSP version</source>
          <target state="translated">версия CSP</target>
        </trans-unit>
        <trans-unit id="a3d4a5f94061540e9f0aa3594fa2f993bb976f3b" translate="yes" xml:space="preserve">
          <source>CSP: base-uri</source>
          <target state="translated">CSP:базисный авгур</target>
        </trans-unit>
        <trans-unit id="e1f387bd5a0bc1c97fc48409c2910b8698c8640e" translate="yes" xml:space="preserve">
          <source>CSP: block-all-mixed-content</source>
          <target state="translated">CSP:блок-смешанный контент</target>
        </trans-unit>
        <trans-unit id="b25eb56df44cb67b582b21cd3edbd78acfb7b3e7" translate="yes" xml:space="preserve">
          <source>CSP: child-src</source>
          <target state="translated">CSP:child-src</target>
        </trans-unit>
        <trans-unit id="d8d4703b593508b27eaeff8d0aebcd15f991e8e2" translate="yes" xml:space="preserve">
          <source>CSP: connect-src</source>
          <target state="translated">CSP:connect-src</target>
        </trans-unit>
        <trans-unit id="68907bfebcb9f7aaac284a06b0682cb8062e8905" translate="yes" xml:space="preserve">
          <source>CSP: default-src</source>
          <target state="translated">CSP:default-src</target>
        </trans-unit>
        <trans-unit id="33201263305688f8d0319035bf86905e02a74b2e" translate="yes" xml:space="preserve">
          <source>CSP: font-src</source>
          <target state="translated">CSP:шрифт-src</target>
        </trans-unit>
        <trans-unit id="288f4f31fbc4626f98b2f869fd485b9fad754b76" translate="yes" xml:space="preserve">
          <source>CSP: form-action</source>
          <target state="translated">CSP:форма действия</target>
        </trans-unit>
        <trans-unit id="1110c66ccba3f4594386963f17efd01ebfc1cd32" translate="yes" xml:space="preserve">
          <source>CSP: frame-ancestors</source>
          <target state="translated">CSP:каркасно-анцесторы</target>
        </trans-unit>
        <trans-unit id="a9d7881b7f2e872886dea3318b9ec4ad54690900" translate="yes" xml:space="preserve">
          <source>CSP: frame-src</source>
          <target state="translated">CSP:frame-src</target>
        </trans-unit>
        <trans-unit id="21056b59bbdeaabbcbf48e5b78e6825df16fd152" translate="yes" xml:space="preserve">
          <source>CSP: img-src</source>
          <target state="translated">CSP:img-src</target>
        </trans-unit>
        <trans-unit id="5b7bbbea8fbb911ad61a95926c52038e17270734" translate="yes" xml:space="preserve">
          <source>CSP: manifest-src</source>
          <target state="translated">CSP:манифест-src</target>
        </trans-unit>
        <trans-unit id="216739951c2911845bfa3c58a3e1759ef762351f" translate="yes" xml:space="preserve">
          <source>CSP: media-src</source>
          <target state="translated">CSP:media-src</target>
        </trans-unit>
        <trans-unit id="d27ff0f1654b7502333c88f9af77e32304f80495" translate="yes" xml:space="preserve">
          <source>CSP: navigate-to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b0f2d6ea1745b227865a7908c705926a5818865" translate="yes" xml:space="preserve">
          <source>CSP: object-src</source>
          <target state="translated">CSP:object-src</target>
        </trans-unit>
        <trans-unit id="9310170277ea799be8285b0064422067334219b7" translate="yes" xml:space="preserve">
          <source>CSP: plugin-types</source>
          <target state="translated">CSP:типы плагинов</target>
        </trans-unit>
        <trans-unit id="caf04f49fb12869875e5809bb62ca18f1dc04233" translate="yes" xml:space="preserve">
          <source>CSP: prefetch-src</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f55d98b5a3ac85d047f911ee4a486f34144e3d" translate="yes" xml:space="preserve">
          <source>CSP: referrer</source>
          <target state="translated">CSP:референт</target>
        </trans-unit>
        <trans-unit id="a53be58aafa7031586553deadc48190f849f218d" translate="yes" xml:space="preserve">
          <source>CSP: report-to</source>
          <target state="translated">CSP:отчётность-до</target>
        </trans-unit>
        <trans-unit id="865f9627c1b6ca237d57e68fc76c695bc3af6d64" translate="yes" xml:space="preserve">
          <source>CSP: report-uri</source>
          <target state="translated">CSP:отчёт-uri</target>
        </trans-unit>
        <trans-unit id="360c612795c5fa6ec239445c2a3549cdd177ae8f" translate="yes" xml:space="preserve">
          <source>CSP: require-sri-for</source>
          <target state="translated">CSP:require-sri-for</target>
        </trans-unit>
        <trans-unit id="5b9a9a7b030ff638c13fe5252ac9605de9bd9a33" translate="yes" xml:space="preserve">
          <source>CSP: require-trusted-types-for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95233e49e595781c9ba6c45123a969ceace0209c" translate="yes" xml:space="preserve">
          <source>CSP: sandbox</source>
          <target state="translated">CSP:песочница</target>
        </trans-unit>
        <trans-unit id="746f3a678a7fdd2c8e56ab69cf9f85ffa266928d" translate="yes" xml:space="preserve">
          <source>CSP: script-src</source>
          <target state="translated">CSP:script-src</target>
        </trans-unit>
        <trans-unit id="74e0def20d9663d6b9402691f4938dcedcc472f5" translate="yes" xml:space="preserve">
          <source>CSP: script-src-attr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c49dd9c01c9002a8c1ca0b0e20c73e1ea7e83d" translate="yes" xml:space="preserve">
          <source>CSP: script-src-elem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="073f20d15a570fd6d41695506e3f4b44db4ec9c8" translate="yes" xml:space="preserve">
          <source>CSP: style-src</source>
          <target state="translated">CSP:style-src</target>
        </trans-unit>
        <trans-unit id="976a77859491cd1ef47e641e7311bb890156672f" translate="yes" xml:space="preserve">
          <source>CSP: style-src-attr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f967c2c8d4a89149755f714e13243120974c7c" translate="yes" xml:space="preserve">
          <source>CSP: style-src-elem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef6a35189958c52fc4d11428c18472eb8ebbc1b7" translate="yes" xml:space="preserve">
          <source>CSP: trusted-types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdec421ab6d7add012ba02e55c66584a25b4ae24" translate="yes" xml:space="preserve">
          <source>CSP: upgrade-insecure-requests</source>
          <target state="translated">CSP:обновления-небезопасные-запросы</target>
        </trans-unit>
        <trans-unit id="fb8f32fe79e286807b14bcfd102e8d5b1bd01893" translate="yes" xml:space="preserve">
          <source>CSP: worker-src</source>
          <target state="translated">CSP:рабочий-src</target>
        </trans-unit>
        <trans-unit id="63b89c4cbe4e07b5d318b0db30585680356a57b5" translate="yes" xml:space="preserve">
          <source>CSS &lt;code&gt;url()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;url()&lt;/code&gt; CSS ()</target>
        </trans-unit>
        <trans-unit id="7be6c2d6b0a547250410b1a2318dda4537f080e3" translate="yes" xml:space="preserve">
          <source>CSS @media feature &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-data&quot;&gt;prefers-reduced-data&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b735f2f9a96efb6f279ab57aab6386d338a0c8dc" translate="yes" xml:space="preserve">
          <source>CSS Shapes from images.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5b4a629abbfbd5eccc6eedfa9f028a8215b669" translate="yes" xml:space="preserve">
          <source>CSS can fetch resources referenced from stylesheets. These resources are following a referrer policy as well.</source>
          <target state="translated">CSS может получать ресурсы,на которые есть ссылки,из таблиц стилей.Эти ресурсы также следуют политике перенаправления.</target>
        </trans-unit>
        <trans-unit id="428ac0eae6ca052836b3b2ffa97a6afe49df6977" translate="yes" xml:space="preserve">
          <source>CSS can fetch resources referenced from stylesheets. These resources follow a referrer policy as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7417538e496bd203aa442ce377a765b360b5ad7" translate="yes" xml:space="preserve">
          <source>CSS files</source>
          <target state="translated">CSS-файлы</target>
        </trans-unit>
        <trans-unit id="b7a02370a133e45105b3a6f51aad72447007c06f" translate="yes" xml:space="preserve">
          <source>CSS files used to style a Web page &lt;strong&gt;must&lt;/strong&gt; be sent with &lt;code&gt;text/css&lt;/code&gt;. If a server doesn't recognize the &lt;code&gt;.css&lt;/code&gt; suffix for CSS files, it may send them with &lt;code&gt;text/plain&lt;/code&gt; or &lt;code&gt;application/octet-stream&lt;/code&gt; MIME types. If so, they won't be recognized as CSS by most browsers and will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a58e854c19a4742126d3d6571cf7bf2c94f204" translate="yes" xml:space="preserve">
          <source>CSS files used to style a Web page&lt;strong&gt; must&lt;/strong&gt; be sent with &lt;code&gt;text/css&lt;/code&gt;. If a server doesn't recognize the &lt;code&gt;.css&lt;/code&gt; suffix for CSS files, it may send them with &lt;code&gt;text/plain&lt;/code&gt; or &lt;code&gt;application/octet-stream&lt;/code&gt; MIME types. If so, they won't be recognized as CSS by most browsers and will be ignored.</source>
          <target state="translated">Файлы CSS, используемые для стилизации веб-страницы, &lt;strong&gt;должны&lt;/strong&gt; отправляться с &lt;code&gt;text/css&lt;/code&gt; . Если сервер не распознает суффикс &lt;code&gt;.css&lt;/code&gt; для файлов CSS, он может отправлять их с типами MIME &lt;code&gt;text/plain&lt;/code&gt; или &lt;code&gt;application/octet-stream&lt;/code&gt; . В этом случае они не будут распознаваться большинством браузеров как CSS и будут проигнорированы.</target>
        </trans-unit>
        <trans-unit id="1964934d77bf5d32bc29b25c72e40d0a04b94a48" translate="yes" xml:space="preserve">
          <source>CT requirements can be satisfied via any one of the following mechanisms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97a250a6d2c0f59f2f4c22e8e9f5dd5b39d8624" translate="yes" xml:space="preserve">
          <source>Cache but revalidate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9387eaae83736c3d69453fd21bd568dec8f4524" translate="yes" xml:space="preserve">
          <source>Cache handling of a response to a conditional request is dependent
   upon its status code:

   o  A 304 (Not Modified) response status code indicates that the
      stored response can be updated and reused; see &lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;.

   o  A full response (i.e., one with a payload body) indicates that
      none of the stored responses nominated in the conditional request
      is suitable.  Instead, the cache MUST use the full response to
      satisfy the request and MAY replace the stored response(s).

   o  However, if a cache receives a 5xx (Server Error) response while
      attempting to validate a response, it can either forward this
      response to the requesting client, or act as if the server failed
      to respond.  In the latter case, the cache MAY send a previously
      stored response (see &lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;).</source>
          <target state="translated">Обработка кеш-памяти ответа на условный запрос зависит от его кода состояния: o Код состояния ответа 304 (Не изменен) указывает, что сохраненный ответ может быть обновлен и повторно использован; см. &lt;a href=&quot;#section-4.3.4&quot;&gt;раздел 4.3.4&lt;/a&gt; . o Полный ответ (т. е. ответ с телом полезной нагрузки) указывает, что ни один из сохраненных ответов, указанных в условном запросе, не подходит. Вместо этого кэш ДОЛЖЕН использовать полный ответ для удовлетворения запроса и МОЖЕТ заменить сохраненный ответ (ответы). o Однако, если кэш получает ответ 5xx (ошибка сервера) при попытке проверить ответ, он может либо переслать этот ответ запрашивающему клиенту, либо действовать так, как если бы сервер не ответил. В последнем случае кеш МОЖЕТ отправить ранее сохраненный ответ (см.&lt;a href=&quot;#section-4.2.4&quot;&gt;Раздел 4.2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9eca146b7d059bac1fffb373a3b4ac5a46895065" translate="yes" xml:space="preserve">
          <source>Cache refresh: this indicates that the cache value is still fresh and can be used.</source>
          <target state="translated">Обновление кэша:это указывает на то,что значение кэша все еще свежее и может быть использовано.</target>
        </trans-unit>
        <trans-unit id="797e92b9fd4173be50b6906927ba56a7e66b9d27" translate="yes" xml:space="preserve">
          <source>Cache request directives</source>
          <target state="translated">Директивы запроса кэша</target>
        </trans-unit>
        <trans-unit id="0b943ff4cafdda6a82e806c4186ad1f27a30b226" translate="yes" xml:space="preserve">
          <source>Cache response directives</source>
          <target state="translated">Директивы реакции кэша</target>
        </trans-unit>
        <trans-unit id="363657bc3c95ae010a3ed0bae48a02dfa27c59c4" translate="yes" xml:space="preserve">
          <source>Cache results of a preflight request for 10 minutes:</source>
          <target state="translated">Кэширование результатов предполетного запроса в течение 10 минут:</target>
        </trans-unit>
        <trans-unit id="0426eb019de93cd2ae1c3a3a04b09dc6cfd746ab" translate="yes" xml:space="preserve">
          <source>Cache static content: offload the web servers by caching static content like pictures,</source>
          <target state="translated">Кэширование статического содержимого:выгрузите веб-серверы,кэшируя статический контент,такой как картинки,</target>
        </trans-unit>
        <trans-unit id="8cc8d7aabbcac8d512fa7176f44889e337cb29b2" translate="yes" xml:space="preserve">
          <source>Cache update</source>
          <target state="translated">Обновление кэша</target>
        </trans-unit>
        <trans-unit id="f39c0f09e8619679ee8854f8b7b8e45d8271d16d" translate="yes" xml:space="preserve">
          <source>Cache validation</source>
          <target state="translated">проверка кэша</target>
        </trans-unit>
        <trans-unit id="9b09c51972b24aaf8bff4e23301b40da54c025b6" translate="yes" xml:space="preserve">
          <source>Cache-Control</source>
          <target state="translated">Cache-Control</target>
        </trans-unit>
        <trans-unit id="96c175aa287942740a4c9dc0851f228f568c2dd0" translate="yes" xml:space="preserve">
          <source>Cache-Control (RFC 2616)</source>
          <target state="translated">Кэш-управление (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="db46bd114028441fc2cb90df358efa899df9e03d" translate="yes" xml:space="preserve">
          <source>Cache-Control (RFC 7234)</source>
          <target state="translated">Cache-Control (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="f831d9e40838da8be7663f96e7bf5e81e81f1527" translate="yes" xml:space="preserve">
          <source>Cacheability</source>
          <target state="translated">Cacheability</target>
        </trans-unit>
        <trans-unit id="ab9c8d4b22f42d6e20f2de04cee4a87194c9b2ff" translate="yes" xml:space="preserve">
          <source>Cacheable</source>
          <target state="translated">Cacheable</target>
        </trans-unit>
        <trans-unit id="367eb2cade8f9a82f981b9ecbd24bcbcccc4234d" translate="yes" xml:space="preserve">
          <source>Cacheable Methods (RFC 7231)</source>
          <target state="translated">Методы кэширования (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="60790f7c84170a8b87051d7e857118ffeb0465ee" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="translated">Caching</target>
        </trans-unit>
        <trans-unit id="6d4faa9c38ae0bea36b2a77a74f1c5565404a706" translate="yes" xml:space="preserve">
          <source>Caching FAQ</source>
          <target state="translated">Часто задаваемые вопросы по кэшированию</target>
        </trans-unit>
        <trans-unit id="c30dddf76b8532fde16158f240307de27191ec53" translate="yes" xml:space="preserve">
          <source>Caching Tutorial &amp;ndash; Mark Nottingham</source>
          <target state="translated">Учебное пособие по кешированию - Марк Ноттингем</target>
        </trans-unit>
        <trans-unit id="e7969efad7a9997c2c32dfba8ba0fa3f7863eaa5" translate="yes" xml:space="preserve">
          <source>Caching Tutorial for Web Authors and Webmasters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4f6bae82cc7d9cc7d1831819fc166adba3c40b" translate="yes" xml:space="preserve">
          <source>Caching directives have the following rules to be valid:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0587c95421ffd96422e6ce52f99b0eeb12897612" translate="yes" xml:space="preserve">
          <source>Caching in HTTP (RFC 2616)</source>
          <target state="translated">Кэширование в HTTP (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="12274da356087ef702ccbb200cdfa705f2a6cb21" translate="yes" xml:space="preserve">
          <source>Caching is a technique that stores a copy of a given resource and serves it back when requested. When a web cache has a requested resource in its store, it intercepts the request and returns its copy instead of re-downloading from the originating server. This achieves several goals: it eases the load of the server that doesn&amp;rsquo;t need to serve all clients itself, and it improves performance by being closer to the client, i.e., it takes less time to transmit the resource back. For a web site, it is a major component in achieving high performance. On the other side, it has to be configured properly as not all resources stay identical forever: it is important to cache a resource only until it changes, not longer.</source>
          <target state="translated">Кэширование - это метод, который сохраняет копию данного ресурса и возвращает ее по запросу. Когда веб-кеш имеет запрошенный ресурс в своем хранилище, он перехватывает запрос и возвращает его копию вместо повторной загрузки с исходного сервера. Это позволяет достичь нескольких целей: уменьшить нагрузку на сервер, которому не нужно обслуживать всех клиентов, и повысить производительность за счет того, что он находится ближе к клиенту, т. Е. Требуется меньше времени для передачи ресурса обратно. Для веб-сайта это важный компонент в достижении высокой производительности. С другой стороны, он должен быть правильно настроен, поскольку не все ресурсы остаются неизменными навсегда: важно кэшировать ресурс только до тех пор, пока он не изменится, а не дольше.</target>
        </trans-unit>
        <trans-unit id="d5bd9f8c4cb307c4c859ece3e85c3287fab9c02d" translate="yes" xml:space="preserve">
          <source>Caching is very important for fast Web sites. This article describes different methods of caching and how to use HTTP Headers to control them.</source>
          <target state="translated">Кэширование очень важно для быстрых веб-сайтов.В этой статье описываются различные методы кэширования и то,как использовать HTTP заголовки для управления ими.</target>
        </trans-unit>
        <trans-unit id="948ba29270deb9f483242162487c780bcfdc8dba" translate="yes" xml:space="preserve">
          <source>Caching of unchanged resources</source>
          <target state="translated">Кэширование неизменных ресурсов</target>
        </trans-unit>
        <trans-unit id="23206d16033b30654e4d04b8e38733f9a9b711e1" translate="yes" xml:space="preserve">
          <source>Caching static assets</source>
          <target state="translated">Кэширование статических активов</target>
        </trans-unit>
        <trans-unit id="224012a44d1a3dcbedc904993d8d0726b013bed5" translate="yes" xml:space="preserve">
          <source>Caching-related headers that are sent along with this response should be taken care of, as a 503 status is often a temporary condition and responses shouldn't usually be cached.</source>
          <target state="translated">Заголовки,связанные с кэшированием,которые посылаются вместе с этим ответом,должны быть приняты во внимание,так как статус 503 часто является временным состоянием,и ответы обычно не должны кэшироваться.</target>
        </trans-unit>
        <trans-unit id="72bc7dfdbfb35fbe7d280800db5164dcd1988d57" translate="yes" xml:space="preserve">
          <source>Calculating Secondary Keys with Vary (RFC 7234)</source>
          <target state="translated">Расчет вторичных ключей с Вари (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="4da9c9af9631e294961d5a16fdc681ca3d84f508" translate="yes" xml:space="preserve">
          <source>Camera</source>
          <target state="translated">Camera</target>
        </trans-unit>
        <trans-unit id="1c8974e3fdbd4a7f871b765b73b10e7d5c3e086c" translate="yes" xml:space="preserve">
          <source>Camino on Mac</source>
          <target state="translated">Камино на Маке</target>
        </trans-unit>
        <trans-unit id="34df0028992d6ae22f580333583afab1e0e37c34" translate="yes" xml:space="preserve">
          <source>Can you spot the mistake? Stylesheets are allowed to be loaded only from &lt;code&gt;cdn.example.com&lt;/code&gt;, yet the website tries to load one from its own origin (&lt;code&gt;http://example.com&lt;/code&gt;). A browser capable of enforcing CSP would send the following violation report as a POST request to &lt;code&gt;http://example.com/_/csp-reports&lt;/code&gt;, when the document is visited:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f86269acd3e77cefb32ddc78f8c4c6c9bd506e6" translate="yes" xml:space="preserve">
          <source>Can you spot the mistake? Stylesheets are only allowed to be loaded from &lt;code&gt;cdn.example.com&lt;/code&gt;, yet the website tries to load one from its own origin (&lt;code&gt;http://example.com&lt;/code&gt;). A browser capable of enforcing CSP will send the following violation report as a POST request to &lt;code&gt;&lt;a href=&quot;http://example.com/_/csp-reports&quot;&gt;http://example.com/_/csp-reports&lt;/a&gt;&lt;/code&gt;, when the document is visited:</source>
          <target state="translated">Вы можете заметить ошибку? Таблицы стилей можно загружать только с &lt;code&gt;cdn.example.com&lt;/code&gt; , однако веб-сайт пытается загрузить их из собственного источника ( &lt;code&gt;http://example.com&lt;/code&gt; ). Браузер, способный принудительно использовать CSP, отправит следующий отчет о нарушении в виде запроса POST на &lt;code&gt;&lt;a href=&quot;http://example.com/_/csp-reports&quot;&gt;http://example.com/_/csp-reports&lt;/a&gt;&lt;/code&gt; при посещении документа:</target>
        </trans-unit>
        <trans-unit id="8b35fa85102875260c5079cd9bdec0d2fdc2ee7d" translate="yes" xml:space="preserve">
          <source>Can you spot the violation? Stylesheets are only allowed to be loaded from &lt;code&gt;cdn.example.com&lt;/code&gt;, yet the website tries to load one from its own origin (&lt;code&gt;http://example.com&lt;/code&gt;). A browser capable of enforcing CSP will send the following violation report as a POST request to &lt;code&gt;http://example.com/_/csp-reports&lt;/code&gt;, when the document is visited:</source>
          <target state="translated">Вы можете заметить нарушение? Таблицы стилей можно загружать только с &lt;code&gt;cdn.example.com&lt;/code&gt; , но веб-сайт пытается загрузить их из собственного источника ( &lt;code&gt;http://example.com&lt;/code&gt; ). Браузер, способный принудительно использовать CSP, отправит следующий отчет о нарушении в виде запроса POST на &lt;code&gt;http://example.com/_/csp-reports&lt;/code&gt; при посещении документа:</target>
        </trans-unit>
        <trans-unit id="c19fa848f8d18f6a6f2a50f399649151c43d2ccf" translate="yes" xml:space="preserve">
          <source>Candidate Recommendation</source>
          <target state="translated">Рекомендация кандидата</target>
        </trans-unit>
        <trans-unit id="23538d20ac9108dc1735c5b220e319e9fe9ebfa3" translate="yes" xml:space="preserve">
          <source>Cascading Style Sheets (CSS)</source>
          <target state="translated">Каскадные таблицы стилей (Cascading Style Sheets (CSS))</target>
        </trans-unit>
        <trans-unit id="0b6458ff064d78bd1b35deea2f51916b09b5473f" translate="yes" xml:space="preserve">
          <source>Case-insensitive, but lowercase is recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1717d0e9589578b46ef62dc5cfe9cd1de83ba5" translate="yes" xml:space="preserve">
          <source>Category Documents contain lists of categories described using the
   &quot;atom:category&quot; element from the Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].
   Categories can also appear in Service Documents, where they indicate
   the categories allowed in a Collection (see &lt;a href=&quot;#section-8.3.6&quot;&gt;Section 8.3.6&lt;/a&gt;).

   Category Documents are identified with the &quot;application/atomcat+xml&quot;
   media type (see &lt;a href=&quot;#section-16.1&quot;&gt;Section 16.1&lt;/a&gt;).</source>
          <target state="translated">Документы категорий содержат списки категорий, описанных с помощью элемента &quot;atom: category&quot; из формата синдикации Atom [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]. Категории также могут отображаться в служебных документах, где они указывают категории, разрешенные в коллекции (см. &lt;a href=&quot;#section-8.3.6&quot;&gt;Раздел 8.3.6&lt;/a&gt; ). Категория Документы идентифицируются с помощью типа носителя &amp;laquo;application / atomcat + xml&amp;raquo; (см. &lt;a href=&quot;#section-16.1&quot;&gt;Раздел 16.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4953a4d35c24e7592363ade77ff9bd38b491415d" translate="yes" xml:space="preserve">
          <source>Certain features depend on cross-origin isolation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3adf629209f8f370767ac9b58ec590a278a3655" translate="yes" xml:space="preserve">
          <source>Certain features like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer&quot;&gt;&lt;code&gt;SharedArrayBuffer&lt;/code&gt;&lt;/a&gt; objects or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/now&quot;&gt;&lt;code&gt;Performance.now()&lt;/code&gt;&lt;/a&gt; with unthrottled timers are only available if your document has a COOP header with the value &lt;code&gt;same-origin&lt;/code&gt; value set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98cfdc8dc518c66839eb93c58f7c6441910d5d79" translate="yes" xml:space="preserve">
          <source>Change the default behavior of autoplay on mobile and third party videos.</source>
          <target state="translated">Измените поведение по умолчанию автоигры на мобильном и стороннем видео.</target>
        </trans-unit>
        <trans-unit id="e97cb80f95cbab0c6a227b198b72f39726ca3006" translate="yes" xml:space="preserve">
          <source>Change the default values or options that control the feature behavior.</source>
          <target state="translated">Измените значения по умолчанию или опции,контролирующие поведение функции.</target>
        </trans-unit>
        <trans-unit id="98070d26bda6abfdd501e4b5389ac0c61c5c1549" translate="yes" xml:space="preserve">
          <source>Change the request such that it is a &lt;a href=&quot;#Simple_requests&quot;&gt;simple request&lt;/a&gt; that doesn&amp;rsquo;t cause a preflight</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8080157d68fc1aa058042192fc9b1007517bb764" translate="yes" xml:space="preserve">
          <source>Change the server-side behavior to avoid the preflight and/or to avoid the redirect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="811bf2bd6edd23474dfa0570cd89845010ee8135" translate="yes" xml:space="preserve">
          <source>Character encoding of HTTP authentication</source>
          <target state="translated">Кодирование символов HTTP-аутентификации</target>
        </trans-unit>
        <trans-unit id="245374780def29c61ce1165c1fdbe13bc3583f38" translate="yes" xml:space="preserve">
          <source>Check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility table&lt;/a&gt; carefully before using this in production.</source>
          <target state="translated">Перед использованием в производстве внимательно проверьте &lt;a href=&quot;#Browser_compatibility&quot;&gt;таблицу совместимости браузера&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de85527d64c40bc55991f2429578ed63d3ac01ed" translate="yes" xml:space="preserve">
          <source>Checking if a server supports partial requests</source>
          <target state="translated">Проверка того,поддерживает ли сервер частичные запросы</target>
        </trans-unit>
        <trans-unit id="ffef88d017227b1ea1b9169e0335da32c5b6a9dd" translate="yes" xml:space="preserve">
          <source>Choosing between www and non-www URLs</source>
          <target state="translated">Выбор между www и не-www URL-адресами</target>
        </trans-unit>
        <trans-unit id="218e75c7a912404b048fff0747e40108873b6334" translate="yes" xml:space="preserve">
          <source>Chrome</source>
          <target state="translated">Chrome</target>
        </trans-unit>
        <trans-unit id="04c901a0daf91c2a0f3e8fdc0701d52f69dd276c" translate="yes" xml:space="preserve">
          <source>Chrome 59 and higher skips the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">Chrome 59 и выше пропускает директиву &lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f8f8ffcc2cbf126c04a5b0120a393e971c34f1c" translate="yes" xml:space="preserve">
          <source>Chrome 59 and higher skips the deprecated &lt;code&gt;child-src&lt;/code&gt; directive.</source>
          <target state="translated">Chrome 59 и выше пропускает устаревшую директиву &lt;code&gt;child-src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="936b3a2c1e8b0dd5e471f5ddaa07ff52d2e26abf" translate="yes" xml:space="preserve">
          <source>Chrome UA string</source>
          <target state="translated">струна Chrome UA</target>
        </trans-unit>
        <trans-unit id="d099f88b010d4398cebebe8e633ffe4874c4aa01" translate="yes" xml:space="preserve">
          <source>Chrome for Android</source>
          <target state="translated">Хром для Android</target>
        </trans-unit>
        <trans-unit id="63fa9dfaafef106782cff2f23fd6100812a2c815" translate="yes" xml:space="preserve">
          <source>Chrome has &lt;a href=&quot;https://www.chromestatus.com/feature/5021976655560704&quot;&gt;removed their XSS Auditor&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b23f33df74ac419800e0f9c00c1fee716262fb" translate="yes" xml:space="preserve">
          <source>Chrome, Edge, Firefox, Internet Explorer, Opera, Safari</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c61202a79a1fff40efdcb9dc2c09bb3207be4de" translate="yes" xml:space="preserve">
          <source>Chrome, Edge, Firefox, Opera</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865e5314adc4c753b1de74b6801e82c3bba584f4" translate="yes" xml:space="preserve">
          <source>Chrome, Edge, Firefox, Opera, Safari</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="019a920351ae1cc253d801e3029fcb49f0363eb6" translate="yes" xml:space="preserve">
          <source>Chrome/xyz</source>
          <target state="translated">Chrome/xyz</target>
        </trans-unit>
        <trans-unit id="530e72f2ef34a9545e0a5330771934b72c420c79" translate="yes" xml:space="preserve">
          <source>Chrome/xyz or Chromium/xyz</source>
          <target state="translated">Хром/ксиз или хром/ксиз</target>
        </trans-unit>
        <trans-unit id="32166e83eed3818d45d2cbecbe2e6cf85528e265" translate="yes" xml:space="preserve">
          <source>Chromium</source>
          <target state="translated">Chromium</target>
        </trans-unit>
        <trans-unit id="be78db4800418a74118cb63d7fc3c7b519d7c030" translate="yes" xml:space="preserve">
          <source>Chromium (prior to v76) &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=36&amp;amp;rcl=52002151773d8cd9ffc5f557cd7cc880fddcae3e&quot;&gt;caps at 10 minutes&lt;/a&gt; (600 seconds).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b80ad1d26c2f3aaa13597f08219cb16ea10fef" translate="yes" xml:space="preserve">
          <source>Chromium (starting in v76) &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=31&amp;amp;rcl=49e7c0b4886cac1f3d09dc046bd528c9c811a0fa&quot;&gt;caps at 2 hours&lt;/a&gt; (7200 seconds).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7817e5d6f503912e54b0784dc45d20aa97799b67" translate="yes" xml:space="preserve">
          <source>Chromium also specifies a default value of 5 seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a00534e71fb83f1f72f13c598065c49858fefc4a" translate="yes" xml:space="preserve">
          <source>Chromium/xyz</source>
          <target state="translated">Chromium/xyz</target>
        </trans-unit>
        <trans-unit id="f2e3d3255876440830fb74bf171c1d2ece3388ed" translate="yes" xml:space="preserve">
          <source>Chromium: &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=615313&quot;&gt;Issue 615313&lt;/a&gt;</source>
          <target state="translated">Хром: &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=615313&quot;&gt;ошибка 615313.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="02dae4314d1b02d0bfeeff3a285006bc4766d38a" translate="yes" xml:space="preserve">
          <source>Chunked encoding</source>
          <target state="translated">кодирование в кусочках</target>
        </trans-unit>
        <trans-unit id="0e13d13f96bc6fbff5ad281601f23302761c061e" translate="yes" xml:space="preserve">
          <source>Chunked encoding is useful when larger amounts of data are sent to the client and the total size of the response may not be known until the request has been fully processed. For example, when generating a large HTML table resulting from a database query or when transmitting large images. A chunked response looks like this:</source>
          <target state="translated">Частичная кодировка полезна,когда клиенту отправляется больший объем данных и общий размер ответа может быть неизвестен до тех пор,пока запрос не будет полностью обработан.Например,при генерации большой HTML-таблицы в результате запроса к базе данных или при передаче больших изображений.Порошкообразный ответ выглядит так:</target>
        </trans-unit>
        <trans-unit id="8220572e0102502603e5875887b5183212dd190a" translate="yes" xml:space="preserve">
          <source>Chunked responses are now also supported.</source>
          <target state="translated">В настоящее время также поддерживаются ответы в виде фрагментов.</target>
        </trans-unit>
        <trans-unit id="db3313f2827a057e3a64943f9f95e2ab49a79565" translate="yes" xml:space="preserve">
          <source>Chunked transfer encoding</source>
          <target state="translated">кодирование передачи данных в кусочках</target>
        </trans-unit>
        <trans-unit id="02f5fbe3823ae3ee8836aabcd6aedc25a237e372" translate="yes" xml:space="preserve">
          <source>Chunked transfer encoding using a trailing header</source>
          <target state="translated">Кодирование передачи в кусочках с использованием заголовка трейлинга</target>
        </trans-unit>
        <trans-unit id="5b18750fa39107d207083b7b1ced1d41dba0f08b" translate="yes" xml:space="preserve">
          <source>Clear Site Data</source>
          <target state="translated">Чистые данные сайта</target>
        </trans-unit>
        <trans-unit id="563a0adf9cc2a772ffc80a2f072b2791b10b2699" translate="yes" xml:space="preserve">
          <source>Clear-Site-Data</source>
          <target state="translated">Clear-Site-Data</target>
        </trans-unit>
        <trans-unit id="47c3b55337992becca7776593cb6ed91ea600664" translate="yes" xml:space="preserve">
          <source>Clearing cookies</source>
          <target state="translated">Очистка cookie-файлов</target>
        </trans-unit>
        <trans-unit id="cc7132c182abf9d906ed90a092216ab6aefbc162" translate="yes" xml:space="preserve">
          <source>Clears browsing data (e.g. cookies, storage, cache) associated with the requesting website.</source>
          <target state="translated">Очищает данные просмотра (например,файлы cookie,память,кэш),связанные с запрашивающим сайтом.</target>
        </trans-unit>
        <trans-unit id="7ca8349d76abe296a6950f45aded7fe82937ec47" translate="yes" xml:space="preserve">
          <source>ClickJacking Defenses - IEBlog</source>
          <target state="translated">ClickJacking Defenses-IEBlog</target>
        </trans-unit>
        <trans-unit id="04d39ef8ff1810b107a1befbb4f275d469a941cd" translate="yes" xml:space="preserve">
          <source>Client                                     Server
     |                                           |
     |  1.) DELETE to Member URI                 |
     |------------------------------------------&amp;gt;|
     |                                           |
     |  2.) 200 OK                               |
     |&amp;lt;------------------------------------------|
     |                                           |

   1.  The client sends a DELETE request to the URI of a Member
       Resource.

   2.  If the deletion is successful, the server responds with a status
       code of 200.

   A different approach is taken for deleting Media Resources; see
   &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt; for details.</source>
          <target state="translated">Клиент-сервер | | | 1.) УДАЛИТЬ в URI участника | | ------------------------------------------&amp;gt; | | | | 2.) 200 ОК | | &amp;lt;------------------------------------------ | | | 1. Клиент отправляет запрос DELETE на URI ресурса-члена. 2. Если удаление прошло успешно, сервер отвечает кодом состояния 200. Для удаления медиаресурсов используется другой подход; подробности см. в &lt;a href=&quot;#section-9.4&quot;&gt;Разделе 9.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06414e618e271894c3e9df0da8e1288e8b9d978d" translate="yes" xml:space="preserve">
          <source>Client                                     Server
     |                                           |
     |  1.) GET to Member URI                    |
     |------------------------------------------&amp;gt;|
     |                                           |
     |  2.) 200 Ok                               |
     |      Member Representation                |
     |&amp;lt;------------------------------------------|
     |                                           |

   1.  The client sends a GET request to the URI of a Member Resource to
       retrieve its representation.

   2.  The server responds with the representation of the Member
       Resource.</source>
          <target state="translated">Клиент-сервер | | | 1.) ПОЛУЧИТЬ к URI участника | | ------------------------------------------&amp;gt; | | | | 2.) 200 Ок | | Представительство членов | | &amp;lt;------------------------------------------ | | | 1. Клиент отправляет запрос GET на URI ресурса-члена, чтобы получить его представление. 2. Сервер отвечает представлением ресурса-члена.</target>
        </trans-unit>
        <trans-unit id="76876be155df9d3b1979f0004de22edc27efe8b1" translate="yes" xml:space="preserve">
          <source>Client                                     Server
     |                                           |
     |  1.) GET to Service Document URI          |
     |------------------------------------------&amp;gt;|
     |                                           |
     |  2.) 200 Ok                               |
     |      Service Document                     |
     |&amp;lt;------------------------------------------|
     |                                           |

   1.  The client sends a GET request to the URI of the Service
       Document.

   2.  The server responds with a Service Document enumerating the IRIs
       of a group of Collections and the capabilities of those
       Collections supported by the server.  The content of this
       document can vary based on aspects of the client request,
       including, but not limited to, authentication credentials.</source>
          <target state="translated">Клиент-сервер | | | 1.) ПОЛУЧИТЬ к URI сервисного документа | | ------------------------------------------&amp;gt; | | | | 2.) 200 Ок | | Сервисный документ | | &amp;lt;------------------------------------------ | | | 1. Клиент отправляет запрос GET на URI документа службы. 2. Сервер отвечает служебным документом, в котором перечисляются IRI группы коллекций и возможности тех коллекций, которые поддерживаются сервером. Содержание этого документа может варьироваться в зависимости от аспектов запроса клиента, включая, помимо прочего,учетные данные для аутентификации.</target>
        </trans-unit>
        <trans-unit id="1d5b247b01ee86613d994ca606b20cb6279035ed" translate="yes" xml:space="preserve">
          <source>Client                                     Server
     |                                           |
     |  1.) POST to Collection URI               |
     |      Member Representation                |
     |------------------------------------------&amp;gt;|
     |                                           |
     |  2.) 201 Created                          |
     |      Location: Member Entry URI           |
     |&amp;lt;------------------------------------------|
     |                                           |

   1.  The client POSTs a representation of the Member to the URI of the
       Collection.

   2.  If the Member Resource was created successfully, the server
       responds with a status code of 201 and a Location header that
       contains the IRI of the newly created Entry Resource.  Media
       Resources could have also been created and their IRIs can be
       found through the Entry Resource.  See &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt; for more
       details.</source>
          <target state="translated">Клиент-сервер | | | 1.) POST в URI коллекции | | Представительство членов | | ------------------------------------------&amp;gt; | | | | 2.) 201 Создано | | Расположение: URI входа участника | | &amp;lt;------------------------------------------ | | | 1. Клиент отправляет POST представление члена в URI Коллекции. 2. Если ресурс-член был создан успешно, сервер отвечает кодом состояния 201 и заголовком Location, который содержит IRI вновь созданного ресурса Entry.Также можно было создать медиаресурсы, и их IRI можно найти через входной ресурс. Видеть&lt;a href=&quot;#section-9.6&quot;&gt;Раздел 9.6&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="cd91d64f5ba1c2b561dc68aad78122e44b4031ba" translate="yes" xml:space="preserve">
          <source>Client                                     Server
     |                                           |
     |  1.) PUT to Member URI                    |
     |      Member Representation                |
     |------------------------------------------&amp;gt;|
     |                                           |
     |  2.) 200 OK                               |
     |&amp;lt;------------------------------------------|

   1.  The client sends a PUT request to store a representation of a
       Member Resource.

   2.  If the request is successful, the server responds with a status
       code of 200.</source>
          <target state="translated">Клиент-сервер | | | 1.) PUT в URI участника | | Представительство членов | | ------------------------------------------&amp;gt; | | | | 2.) 200 ОК | | &amp;lt;------------------------------------------ | 1. Клиент отправляет запрос PUT для хранения представления ресурса-члена. 2. Если запрос успешен, сервер отвечает кодом состояния 200.</target>
        </trans-unit>
        <trans-unit id="2ab41737272cae6324e9b264638622ce30e7016c" translate="yes" xml:space="preserve">
          <source>Client error responses</source>
          <target state="translated">Ответы Клиента на ошибки</target>
        </trans-unit>
        <trans-unit id="c82a3ee2730bab92b98bc213a8fb73492e3fdebd" translate="yes" xml:space="preserve">
          <source>Client errors (&lt;code&gt;400&lt;/code&gt;&amp;ndash;&lt;code&gt;499&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd407b441928f45e73a186d44c8d9b1022e9b952" translate="yes" xml:space="preserve">
          <source>Client hints</source>
          <target state="translated">Клиентские рекомендации</target>
        </trans-unit>
        <trans-unit id="d5d9a54cc11d8f25e2a07fd30bc5b8caf775ec8d" translate="yes" xml:space="preserve">
          <source>Client request</source>
          <target state="translated">Запрос клиента</target>
        </trans-unit>
        <trans-unit id="c5b2b8d440453db220355b3130f1ed0c4ab07917" translate="yes" xml:space="preserve">
          <source>Client-Side &amp;amp; Server-Side (Java) sample for Cross-Origin Resource Sharing (CORS)</source>
          <target state="translated">Пример на стороне клиента и на стороне сервера (Java) для совместного использования ресурсов между источниками (CORS)</target>
        </trans-unit>
        <trans-unit id="6f5874c4570fe3f1c919c21b9967af34bee3005c" translate="yes" xml:space="preserve">
          <source>Client-initiated upgrade to HTTP over TLS</source>
          <target state="translated">Инициированное клиентом обновление до HTTP по TLS</target>
        </trans-unit>
        <trans-unit id="922d22a1c7654940e60c03245c40184c1e28e1bb" translate="yes" xml:space="preserve">
          <source>Client: the user-agent</source>
          <target state="translated">Клиент:пользователь-агент</target>
        </trans-unit>
        <trans-unit id="28beb9075baceef63887e188043a5dc8f9f8abcf" translate="yes" xml:space="preserve">
          <source>Clients and servers communicate by exchanging individual messages (as opposed to a stream of data). The messages sent by the client, usually a Web browser, are called &lt;em&gt;requests&lt;/em&gt; and the messages sent by the server as an answer are called &lt;em&gt;responses&lt;/em&gt;.</source>
          <target state="translated">Клиенты и серверы общаются посредством обмена отдельными сообщениями (в отличие от потока данных). Сообщения, отправленные клиентом, обычно веб-браузером, называются &lt;em&gt;запросами,&lt;/em&gt; а сообщения, отправленные сервером в качестве ответа, называются &lt;em&gt;ответами&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f0a6c74917d2b5e80cb29e5ed1cc31e500515eb2" translate="yes" xml:space="preserve">
          <source>Clients are often privy to large amounts of personal information,
   including both information provided by the user to interact with
   resources (e.g., the user's name, location, mail address, passwords,
   encryption keys, etc.) and information about the user's browsing
   activity over time (e.g., history, bookmarks, etc.).  Implementations
   need to prevent unintentional disclosure of personal information.</source>
          <target state="translated">Клиенты часто имеют доступ к большим объемам личной информации,включая как информацию,предоставленную пользователем для взаимодействия с ресурсами (например,имя пользователя,местоположение,почтовый адрес,пароли,ключи шифрования и т.д.),так и информацию о деятельности пользователя по просмотру веб-страниц во времени (например,история,закладки и т.д.).Внедрение должно предотвратить непреднамеренное разглашение личной информации.</target>
        </trans-unit>
        <trans-unit id="c8385dd1dcb9fe615c68497e7d83ea0f53328707" translate="yes" xml:space="preserve">
          <source>Clients using HTTP rely heavily on the Domain Name Service, and are
   thus generally prone to security attacks based on the deliberate
   mis-association of IP addresses and DNS names. Clients need to be
   cautious in assuming the continuing validity of an IP number/DNS name
   association.

   In particular, HTTP clients SHOULD rely on their name resolver for
   confirmation of an IP number/DNS name association, rather than
   caching the result of previous host name lookups. Many platforms
   already can cache host name lookups locally when appropriate, and
   they SHOULD be configured to do so. It is proper for these lookups to
   be cached, however, only when the TTL (Time To Live) information
   reported by the name server makes it likely that the cached
   information will remain useful.

   If HTTP clients cache the results of host name lookups in order to
   achieve a performance improvement, they MUST observe the TTL
   information reported by DNS.

   If HTTP clients do not observe this rule, they could be spoofed when
   a previously-accessed server's IP address changes. As network
   renumbering is expected to become increasingly common [&lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt;], the
   possibility of this form of attack will grow. Observing this
   requirement thus reduces this potential security vulnerability.

   This requirement also improves the load-balancing behavior of clients
   for replicated servers using the same DNS name and reduces the
   likelihood of a user's experiencing failure in accessing sites which
   use that strategy.</source>
          <target state="translated">Клиенты, использующие HTTP, в значительной степени полагаются на службу доменных имен и, таким образом, обычно подвержены атакам на систему безопасности, основанным на преднамеренном неправильном сопоставлении IP-адресов и имен DNS. Клиенты должны быть осторожны, предполагая постоянную действительность ассоциации IP-номера / имени DNS. В частности, HTTP-клиенты ДОЛЖНЫ полагаться на свой преобразователь имен для подтверждения ассоциации IP-номера / имени DNS, а не кэшировать результат предыдущих поисков имени хоста. Многие платформы уже могут кэшировать поиск имени хоста локально, когда это необходимо, и их СЛЕДУЕТ настроить для этого. Однако эти поисковые запросы следует кэшировать только в том случае, если информация TTL (время жизни), сообщаемая сервером имен, делает вероятным, что кэшированная информация останется полезной.Если HTTP-клиенты кэшируют результаты поиска имени хоста для повышения производительности, они ДОЛЖНЫ соблюдать информацию TTL, сообщаемую DNS. Если HTTP-клиенты не соблюдают это правило, они могут быть подделаны при изменении IP-адреса ранее доступного сервера. Ожидается, что перенумерация сети станет все более распространенной [&lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt; ], вероятность такого нападения будет расти. Таким образом, соблюдение этого требования снижает потенциальную уязвимость системы безопасности. Это требование также улучшает балансировку нагрузки клиентов для реплицированных серверов, использующих одно и то же DNS-имя, и снижает вероятность отказа пользователя при доступе к сайтам, использующим эту стратегию.</target>
        </trans-unit>
        <trans-unit id="939f605954e45144b33768a5bb94ffea000db6cc" translate="yes" xml:space="preserve">
          <source>Close or reuse the connection for further requests.</source>
          <target state="translated">Закрыть или повторно использовать соединение для дальнейших запросов.</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="2a1800f5cb859b9d67e384c7da846507f055a233" translate="yes" xml:space="preserve">
          <source>Code Samples Showing &lt;code&gt;XMLHttpRequest&lt;/code&gt; and Cross-Origin Resource Sharing</source>
          <target state="translated">Примеры кода, показывающие &lt;code&gt;XMLHttpRequest&lt;/code&gt; и совместное использование ресурсов между источниками</target>
        </trans-unit>
        <trans-unit id="d674b2dea57bb6fd7e6a35edd6eb081470fbfe96" translate="yes" xml:space="preserve">
          <source>Collection Resources MUST provide representations in the form of Atom
   Feed Documents whose Entries contain the IRIs of the Members in the
   Collection.  No distinction is made between Collection Feeds and
   other kinds of Feeds -- a Feed might act both as a 'public' feed for
   subscription purposes and as a Collection Feed.

   Each Entry in the Feed Document SHOULD have an atom:link element with
   a relation of &quot;edit&quot; (see &lt;a href=&quot;#section-11.1&quot;&gt;Section 11.1&lt;/a&gt;).

   The Entries in the returned Atom Feed SHOULD be ordered by their
   &quot;app:edited&quot; property, with the most recently edited Entries coming
   first in the document order.  The app:edited value is not equivalent
   to the HTTP Last-Modified header and cannot be used to determine the
   freshness of cached responses.

   Clients MUST NOT assume that an Atom Entry returned in the Feed is a
   full representation of an Entry Resource and SHOULD perform a GET on
   the URI of the Member Entry before editing it.  See &lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt; for a
   discussion on the implications of cache control directives when
   obtaining entries.</source>
          <target state="translated">Ресурсы коллекции ДОЛЖНЫ предоставлять представления в форме документов Atom Feed, записи которых содержат IRI участников в коллекции. Не делается различий между фидами коллекций и другими типами фидов - фид может действовать как &amp;laquo;общедоступный&amp;raquo; фид для целей подписки, так и как фид коллекции. Каждая запись в документе фида ДОЛЖНА иметь элемент atom: link с отношением &amp;laquo;редактировать&amp;raquo; (см. &lt;a href=&quot;#section-11.1&quot;&gt;Раздел 11.1.&lt;/a&gt;). Записи в возвращенном фиде Atom ДОЛЖНЫ быть упорядочены по их свойству &amp;laquo;app: edited&amp;raquo;, причем самые недавно отредактированные записи идут первыми в порядке документа. Значение app: edited не эквивалентно заголовку HTTP Last-Modified и не может использоваться для определения актуальности кэшированных ответов. Клиенты НЕ ДОЛЖНЫ предполагать, что запись Atom, возвращаемая в ленте, является полным представлением ресурса записи, и ДОЛЖНЫ выполнить GET для URI записи члена перед ее редактированием. См. &lt;a href=&quot;#section-9.5&quot;&gt;Раздел 9.5&lt;/a&gt; для обсуждения последствий директив управления кешем при получении записей.</target>
        </trans-unit>
        <trans-unit id="b11e6ff9806f23d877b8f28e66ba1d2666df0aba" translate="yes" xml:space="preserve">
          <source>Collection resources differ from other resources in that they also
   act as containers.  Some HTTP methods apply only to a collection, but
   some apply to some or all of the resources inside the container
   defined by the collection.  When the scope of a method is not clear,
   the client can specify what depth to apply.  Depth can be either zero
   levels (only the collection), one level (the collection and directly
   contained resources), or infinite levels (the collection and all
   contained resources recursively).

   A collection's state consists of at least a set of mappings between
   path segments and resources, and a set of properties on the
   collection itself.  In this document, a resource B will be said to be
   contained in the collection resource A if there is a path segment
   mapping that maps to B and that is contained in A.  A collection MUST
   contain at most one mapping for a given path segment, i.e., it is
   illegal to have the same path segment mapped to more than one
   resource. 

   Properties defined on collections behave exactly as do properties on
   non-collection resources.  A collection MAY have additional state
   such as entity bodies returned by GET.

   For all WebDAV-compliant resources A and B, identified by URLs &quot;U&quot;
   and &quot;V&quot;, respectively, such that &quot;V&quot; is equal to &quot;U/SEGMENT&quot;, A MUST
   be a collection that contains a mapping from &quot;SEGMENT&quot; to B.  So, if
   resource B with URL &quot;http://example.com/bar/blah&quot; is WebDAV compliant
   and if resource A with URL &quot;http://example.com/bar/&quot; is WebDAV
   compliant, then resource A must be a collection and must contain
   exactly one mapping from &quot;blah&quot; to B.

   Although commonly a mapping consists of a single segment and a
   resource, in general, a mapping consists of a set of segments and a
   resource.  This allows a server to treat a set of segments as
   equivalent (i.e., either all of the segments are mapped to the same
   resource, or none of the segments are mapped to a resource).  For
   example, a server that performs case-folding on segments will treat
   the segments &quot;ab&quot;, &quot;Ab&quot;, &quot;aB&quot;, and &quot;AB&quot; as equivalent.  A client can
   then use any of these segments to identify the resource.  Note that a
   PROPFIND result will select one of these equivalent segments to
   identify the mapping, so there will be one PROPFIND response element
   per mapping, not one per segment in the mapping.

   Collection resources MAY have mappings to non-WebDAV-compliant
   resources in the HTTP URL namespace hierarchy but are not required to
   do so.  For example, if resource X with URL
   &quot;http://example.com/bar/blah&quot; is not WebDAV compliant and resource A
   with &quot;URL http://example.com/bar/&quot; identifies a WebDAV collection,
   then A may or may not have a mapping from &quot;blah&quot; to X.

   If a WebDAV-compliant resource has no WebDAV-compliant internal
   members in the HTTP URL namespace hierarchy, then the WebDAV-
   compliant resource is not required to be a collection.

   There is a standing convention that when a collection is referred to
   by its name without a trailing slash, the server MAY handle the
   request as if the trailing slash were present.  In this case, it
   SHOULD return a Content-Location header in the response, pointing to
   the URL ending with the &quot;/&quot;.  For example, if a client invokes a
   method on http://example.com/blah (no trailing slash), the server may
   respond as if the operation were invoked on http://example.com/blah/
   (trailing slash), and should return a Content-Location header with
   the value http://example.com/blah/.  Wherever a server produces a URL
   referring to a collection, the server SHOULD include the trailing
   slash.  In general, clients SHOULD use the trailing slash form of
   collection names.  If clients do not use the trailing slash form the
   client needs to be prepared to see a redirect response.  Clients will 

   find the DAV:resourcetype property more reliable than the URL to find
   out if a resource is a collection.

   Clients MUST be able to support the case where WebDAV resources are
   contained inside non-WebDAV resources.  For example, if an OPTIONS
   response from &quot;http://example.com/servlet/dav/collection&quot; indicates
   WebDAV support, the client cannot assume that
   &quot;http://example.com/servlet/dav/&quot; or its parent necessarily are
   WebDAV collections.

   A typical scenario in which mapped URLs do not appear as members of
   their parent collection is the case where a server allows links or
   redirects to non-WebDAV resources.  For instance, &quot;/col/link&quot; might
   not appear as a member of &quot;/col/&quot;, although the server would respond
   with a 302 status to a GET request to &quot;/col/link&quot;; thus, the URL
   &quot;/col/link&quot; would indeed be mapped.  Similarly, a dynamically-
   generated page might have a URL mapping from &quot;/col/index.html&quot;, thus
   this resource might respond with a 200 OK to a GET request yet not
   appear as a member of &quot;/col/&quot;.

   Some mappings to even WebDAV-compliant resources might not appear in
   the parent collection.  An example for this case are servers that
   support multiple alias URLs for each WebDAV-compliant resource.  A
   server may implement case-insensitive URLs, thus &quot;/col/a&quot; and
   &quot;/col/A&quot; identify the same resource, yet only either &quot;a&quot; or &quot;A&quot; is
   reported upon listing the members of &quot;/col&quot;.  In cases where a server
   treats a set of segments as equivalent, the server MUST expose only
   one preferred segment per mapping, consistently chosen, in PROPFIND
   responses.</source>
          <target state="translated">Ресурсы коллекционирования отличаются от других ресурсов тем,что они также выступают в качестве контейнеров.Некоторые методы HTTP применимы только к коллекции,но некоторые-к некоторым или ко всем ресурсам внутри контейнера,определенным коллекцией.Когда область применения метода не ясна,клиент может указать,какую глубину следует применять.Глубина может быть либо нулевым уровнем (только коллекция),одним уровнем (коллекция и непосредственно содержащиеся ресурсы),либо бесконечным уровнем (коллекция и все содержащиеся ресурсы рекурсивно).Состояние коллекции состоит,по крайней мере,из набора связок между сегментами пути и ресурсами,а также из набора свойств самой коллекции.В этом документе будет сказано,что ресурс B содержится в ресурсе коллекции A,если существует отображение сегмента пути,который отображает путь к B и который содержится в A.Коллекция ДОЛЖНА содержать,по крайней мере,одно отображение для данного сегмента пути,т.е.противозаконно иметь одно и то же отображение сегмента пути для более чем одного ресурса.Свойства,определенные на коллекциях,ведут себя точно так же,как и свойства на несобираемых ресурсах.Коллекция MAY имеет дополнительное состояние,такое как тела сущностей,возвращенные GET.Для всех WebDAV-совместимых ресурсов A и B,идентифицированных по URL &quot;U&quot; и &quot;V&quot;,соответственно,таким образом,что &quot;V&quot; равно &quot;U/SEGMENT&quot;,A ДОЛЖН быть коллекцией,которая содержит отображение от &quot;SEGMENT&quot; до B.Таким образом,если ресурс B с URL &quot;http://example.com/bar/blah&quot; является WebDAV-совместимым,и если ресурс A с URL &quot;http://example&quot;.com/bar/&quot; совместим с WebDAV,то ресурс A должен быть коллекцией и должен содержать ровно одно отображение от &quot;blah&quot; до B.Хотя обычно отображение состоит из одного сегмента и ресурса,в общем,отображение состоит из набора сегментов и ресурса.Это позволяет серверу рассматривать набор сегментов как эквивалент (т.е.либо все сегменты отображаются на один и тот же ресурс,либо ни один из сегментов не отображается на ресурс).Например,сервер,выполняющий фальцовку сегментов,будет рассматривать сегменты &quot;ab&quot;,&quot;Ab&quot;,&quot;aB&quot; и &quot;AB&quot; как эквивалент.Затем клиент может использовать любой из этих сегментов для идентификации ресурса.Обратите внимание,что результат PROPFIND выберет один из этих эквивалентных сегментов для идентификации отображения,так что будет один элемент ответа PROPFIND на отображение,а не один на сегмент в отображении.Ресурсы коллекции MAY имеют отображения к не-WebDAV-совместимым ресурсам в иерархии пространства имен HTTP URL,но не обязаны это делать.Например,если ресурс X с URL &quot;http://example.com/bar/blah&quot; не совместим с WebDAV,а ресурс A с &quot;URL http://example.com/bar/&quot; идентифицирует коллекцию WebDAV,то A может иметь или не иметь отображение от &quot;бла&quot; к X.Если ресурс,совместимый с WebDAV,не имеет WebDAV-совместимых внутренних членов в иерархии пространств имен HTTP URL,то ресурс,совместимый с WebDAV,не обязан быть коллекцией.Существует постоянное соглашение,что когда коллекция ссылается на нее по имени без трейлингового слэша,сервер MAY обрабатывает запрос так,как если бы трейлинговый слэш присутствовал.В этом случае он ДОЛЖЕН возвращать в ответе заголовок Content-Location,указывающий на URL,заканчивающийся на &quot;/&quot;.Например,если клиент вызывает метод на http://example.com/blah (без трейлинговой косынки),сервер может ответить так,как если бы операция была вызвана на http://example.com/blah/(трейлинговая косая черта),и должен вернуть Content-Location заголовок со значением http://example.com/blah/.Везде,где сервер создает URL-адрес,ссылающийся на коллекцию,сервер ДОЛЖЕН включать в него трейлинговую косую черту.В общем случае клиенты ДОЛЖНЫ использовать имена коллекций в форме трейлинговой косынки.Если клиенты не используют форму последней косой черты,они должны быть готовы к тому,чтобы увидеть ответ о перенаправлении.Клиенты найдут свойство DAV:resourcetype более надежным,чем URL,чтобы выяснить,является ли ресурс коллекцией.Клиенты ДОЛЖНЫ поддерживать случай,когда WebDAV ресурсы содержатся внутри не-WebDAV ресурсов.Например,если ответ OPTIONS от &quot;http://example.com/servlet/dav/collection&quot; указывает на поддержку WebDAV,клиент не может предполагать,что &quot;http://example.com/servlet/dav/&quot; или его родитель обязательно являются WebDAV коллекциями.Типичный сценарий,в котором отображенные URL-адреса не появляются как члены их родительской коллекции,это тот случай,когда сервер разрешает ссылки или перенаправление на не-WebDAV-ресурсы.Например,&quot;/col/link&quot; может не отображаться как член &quot;/col/&quot;,хотя сервер будет отвечать 302 статусом на запрос GET на &quot;/col/link&quot;;таким образом,URL &quot;/col/link&quot; действительно будет отображен.Аналогично,динамически генерируемая страница может иметь отображение URL из &quot;/col/index.html&quot;,таким образом,этот ресурс может ответить 200 ОК на GET-запрос,который еще не является членом &quot;/col/&quot;.Некоторые сопоставления даже с WebDAV-совместимыми ресурсами могут не появиться в родительской коллекции.Примером для этого случая являются серверы,которые поддерживают несколько псевдонимов URL для каждого WebDAV-совместимого ресурса.Сервер может реализовать нечувствительные к регистру URL,таким образом,идентификаторы &quot;/col/a&quot; и &quot;/col/A&quot;.</target>
        </trans-unit>
        <trans-unit id="92c14ed70a70a4eecdf0beb11029acb63043ecd0" translate="yes" xml:space="preserve">
          <source>Collections and Namespace Operations

   o  Due to interoperability problems, allowable formats for contents
      of 'href' elements in multistatus responses have been limited (see
      &lt;a href=&quot;#section-8.3&quot;&gt;Section 8.3&lt;/a&gt;).

   o  Due to lack of implementation, support for the 'propertybehavior'
      request body for COPY and MOVE has been removed.  Instead,
      requirements for property preservation have been clarified (see
      Sections &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; and &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;).

   Properties

   o  Strengthened server requirements for storage of property values,
      in particular persistence of language information (xml:lang),
      whitespace, and XML namespace information (see &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).

   o  Clarified requirements on which properties should be writable by
      the client; in particular, setting &quot;DAV:displayname&quot; should be
      supported by servers (see &lt;a href=&quot;#section-15&quot;&gt;Section 15&lt;/a&gt;).

   o  Only '&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date' productions are legal as values for DAV:
      getlastmodified (see &lt;a href=&quot;#section-15.7&quot;&gt;Section 15.7&lt;/a&gt;).

   Headers and Marshalling

   o  Servers are now required to do authorization checks before
      processing conditional headers (see &lt;a href=&quot;#section-8.5&quot;&gt;Section 8.5&lt;/a&gt;).

   Locking

   o  Strengthened requirement to check identity of lock creator when
      accessing locked resources (see &lt;a href=&quot;#section-6.4&quot;&gt;Section 6.4&lt;/a&gt;).  Clients should be
      aware that lock tokens returned to other principals can only be
      used to break a lock, if at all. 

   o  &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-8.10.4&quot;&gt;Section&amp;nbsp;8.10.4 of [RFC2518]&lt;/a&gt; incorrectly required servers to return
      a 409 status where a 207 status was really appropriate.  This has
      been corrected (&lt;a href=&quot;#section-9.10&quot;&gt;Section 9.10&lt;/a&gt;).</source>
          <target state="translated">Коллекции и операции с пространством имен o Из-за проблем совместимости допустимые форматы для содержимого элементов 'href' в ответах с несколькими состояниями были ограничены (см. &lt;a href=&quot;#section-8.3&quot;&gt;Раздел 8.3&lt;/a&gt; ). o Из-за отсутствия реализации поддержка тела запроса propertybehavior для COPY и MOVE была удалена. Вместо этого были уточнены требования по сохранению собственности (см. Разделы &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; и &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt; ). Свойства o Повышенные требования к серверу для хранения значений свойств, в частности постоянства языковой информации (xml: lang), пробелов и информации о пространстве имен XML (см. &lt;a href=&quot;#section-4.3&quot;&gt;Раздел 4.3.&lt;/a&gt;). o Уточнены требования о том, какие свойства должны быть доступны для записи клиенту; в частности, установка &amp;laquo;DAV: displayname&amp;raquo; должна поддерживаться серверами (см. &lt;a href=&quot;#section-15&quot;&gt;Раздел 15&lt;/a&gt; ). o Только продукция &quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt; -date&quot; допустима в качестве значений для DAV: getlastmodified (см. &lt;a href=&quot;#section-15.7&quot;&gt;Раздел 15.7&lt;/a&gt; ). Заголовки и маршалинг o Серверы теперь должны выполнять проверки авторизации перед обработкой условных заголовков (см. &lt;a href=&quot;#section-8.5&quot;&gt;Раздел 8.5&lt;/a&gt; ). Блокировка o Усилено требование проверки личности создателя блокировки при доступе к заблокированным ресурсам (см. &lt;a href=&quot;#section-6.4&quot;&gt;Раздел 6.4&lt;/a&gt;). Клиенты должны знать, что токены блокировки, возвращенные другим участникам, могут использоваться только для взлома блокировки, если вообще могут. o В &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-8.10.4&quot;&gt;разделе 8.10.4 [RFC2518]&lt;/a&gt; неверно требовалось, чтобы серверы возвращали статус 409, тогда как статус 207 был действительно подходящим. Это было исправлено ( &lt;a href=&quot;#section-9.10&quot;&gt;Раздел 9.10&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cfd2e08606ba977053d3bef5451af9337fdfae03" translate="yes" xml:space="preserve">
          <source>Collections and Namespace Operations

   o  The semantics of PROPFIND 'allprop' (&lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt;) have been
      relaxed so that servers return results including, at a minimum,
      the live properties defined in this specification, but not
      necessarily return other live properties.  The 'allprop' directive
      therefore means something more like &quot;return all properties that
      are supposed to be returned when 'allprop' is requested&quot; -- a set
      of properties that may include custom properties and properties
      defined in other specifications if those other specifications so
      require.  Related to this, 'allprop' requests can now be extended
      with the 'include' syntax to include specific named properties, 

      thereby avoiding additional requests due to changed 'allprop'
      semantics.

   o  Servers are now allowed to reject PROPFIND requests with Depth:
      Infinity.  Clients that used this will need to be able to do a
      series of Depth:1 requests instead.

   o  Multi-Status response bodies now can transport the value of HTTP's
      Location response header in the new 'location' element.  Clients
      may use this to avoid additional roundtrips to the server when
      there is a 'response' element with a 3xx status (see
      &lt;a href=&quot;#section-14.24&quot;&gt;Section 14.24&lt;/a&gt;).

   o  The definition of COPY has been relaxed so that it doesn't require
      servers to first delete the target resources anymore (this was a
      known incompatibility with [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;]).  See &lt;a href=&quot;#section-9.8&quot;&gt;Section 9.8&lt;/a&gt;.

   Headers and Marshalling

   o  The Destination and If request headers now allow absolute paths in
      addition to full URIs (see &lt;a href=&quot;#section-8.3&quot;&gt;Section 8.3&lt;/a&gt;).  This may be useful for
      clients operating through a reverse proxy that does rewrite the
      Host request header, but not WebDAV-specific headers.

   o  This specification adopts the error marshalling extensions and the
      &quot;precondition/postcondition&quot; terminology defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;] (see
      &lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;).  Related to that, it adds the &quot;error&quot; XML element
      inside multistatus response bodies (see &lt;a href=&quot;#section-14.5&quot;&gt;Section 14.5&lt;/a&gt;, however note
      that it uses a format different from the one recommended in &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;3253&lt;/a&gt;).

   o  Senders and recipients are now required to support the UTF-16
      character encoding in XML message bodies (see &lt;a href=&quot;#section-19&quot;&gt;Section 19&lt;/a&gt;).

   o  Clients are now required to send the Depth header on PROPFIND
      requests, although servers are still encouraged to support clients
      that don't.

   Locking

   o  &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;'s concept of &quot;lock-null resources&quot; (LNRs) has been
      replaced by a simplified approach, the &quot;locked empty resources&quot;
      (see &lt;a href=&quot;#section-7.3&quot;&gt;Section 7.3&lt;/a&gt;).  There are some aspects of lock-null resources
      clients cannot rely on anymore, namely, the ability to use them to
      create a locked collection or the fact that they disappear upon
      UNLOCK when no PUT or MKCOL request was issued.  Note that servers
      are still allowed to implement LNRs as per &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;. 

   o  There is no implicit refresh of locks anymore.  Locks are only
      refreshed upon explicit request (see &lt;a href=&quot;#section-9.10.2&quot;&gt;Section 9.10.2&lt;/a&gt;).

   o  Clarified that the DAV:owner value supplied in the LOCK request
      must be preserved by the server just like a dead property
      (&lt;a href=&quot;#section-14.17&quot;&gt;Section 14.17&lt;/a&gt;).  Also added the DAV:lockroot element
      (&lt;a href=&quot;#section-14.12&quot;&gt;Section 14.12&lt;/a&gt;), which allows clients to discover the root of
      lock.</source>
          <target state="translated">Коллекции и операции с пространством имен o Семантика PROPFIND 'allprop' ( &lt;a href=&quot;#section-9.1&quot;&gt;Раздел 9.1&lt;/a&gt;) были ослаблены, поэтому серверы возвращают результаты, включая, как минимум, активные свойства, определенные в этой спецификации, но не обязательно возвращают другие динамические свойства. Таким образом, директива allprop означает нечто большее, чем &amp;laquo;возвращать все свойства, которые должны быть возвращены при запросе allprop&amp;raquo; - набор свойств, который может включать настраиваемые свойства и свойства, определенные в других спецификациях, если того требуют другие спецификации. , В связи с этим запросы allprop теперь могут быть расширены синтаксисом include для включения определенных именованных свойств, что позволяет избежать дополнительных запросов из-за измененной семантики allprop. o Серверы теперь могут отклонять запросы PROPFIND с глубиной:Бесконечность. Клиенты, которые использовали это, должны будут иметь возможность вместо этого выполнять серию запросов глубины: 1. o Тела ответа Multi-Status теперь могут передавать значение HTTP-заголовка ответа Location в новом элементе location. Клиенты могут использовать это, чтобы избежать дополнительных обращений к серверу, когда есть элемент 'response' со статусом 3xx (см. &lt;a href=&quot;#section-14.24&quot;&gt;Раздел 14.24&lt;/a&gt; ). o Определение COPY было смягчено, так что для него больше не требуется, чтобы серверы сначала &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;удаляли&lt;/a&gt; целевые ресурсы (это была известная несовместимость с [ RFC3253 ]). См. &lt;a href=&quot;#section-9.8&quot;&gt;Раздел 9.8&lt;/a&gt; . Заголовки и маршалинг o Заголовки запроса &amp;laquo;Назначение&amp;raquo; и &amp;laquo;Если&amp;raquo; теперь допускают абсолютные пути в дополнение к полным URI (см. &lt;a href=&quot;#section-8.3&quot;&gt;Раздел 8.3&lt;/a&gt; ). Это может быть полезно для клиентов, работающих через обратный прокси-сервер, который перезаписывает заголовок запроса Host, но не заголовки, специфичные для WebDAV. o В этой спецификации используются расширения для сортировки ошибок и терминология &amp;laquo;предусловие / постусловие&amp;raquo;, определенная в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ] (см. &lt;a href=&quot;#section-16&quot;&gt;раздел 16&lt;/a&gt;). В связи с этим он добавляет XML-элемент &amp;laquo;error&amp;raquo; в тела мультистатусного ответа (см. &lt;a href=&quot;#section-14.5&quot;&gt;Раздел 14.5&lt;/a&gt; , однако обратите внимание, что он использует формат, отличный от рекомендованного в &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;3253&lt;/a&gt; ). o Отправители и получатели теперь должны поддерживать кодировку символов UTF-16 в телах сообщений XML (см. &lt;a href=&quot;#section-19&quot;&gt;раздел 19&lt;/a&gt; ). o Клиенты теперь должны отправлять заголовок глубины в запросах PROPFIND, хотя серверам по-прежнему рекомендуется поддерживать клиентов, которые этого не делают. Блокировка. Концепция &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; &amp;laquo;заблокированных пустых ресурсов&amp;raquo; (LNR) была заменена упрощенным подходом, &amp;laquo;заблокированными пустыми ресурсами&amp;raquo; (см. &lt;a href=&quot;#section-7.3&quot;&gt;Раздел 7.3&lt;/a&gt;). Есть некоторые аспекты ресурсов с нулевой блокировкой, на которые клиенты больше не могут полагаться, а именно, возможность использовать их для создания заблокированной коллекции или тот факт, что они исчезают при РАЗБЛОКИРОВКЕ, когда не был отправлен запрос PUT или MKCOL. Обратите внимание, что серверам по-прежнему разрешено реализовывать LNR в соответствии с &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; . o Больше нет неявного обновления блокировок. Блокировки обновляются только по явному запросу (см. &lt;a href=&quot;#section-9.10.2&quot;&gt;Раздел 9.10.2&lt;/a&gt; ). o Разъяснено, что значение DAV: owner, указанное в запросе LOCK, должно сохраняться сервером точно так же, как мертвое свойство ( &lt;a href=&quot;#section-14.17&quot;&gt;раздел 14.17&lt;/a&gt; ). Также добавлен элемент DAV: lockroot ( &lt;a href=&quot;#section-14.12&quot;&gt;раздел 14.12&lt;/a&gt; ), который позволяет клиентам обнаруживать корень блокировки.</target>
        </trans-unit>
        <trans-unit id="ea7b149981164a5bdbbf89dc8821115528f3f53c" translate="yes" xml:space="preserve">
          <source>Collections can contain large numbers of Resources.  A client such as
   a web spider or web browser might be overwhelmed if the response to a
   GET contained every Entry in a Collection -- in turn the server might
   also waste bandwidth and processing time on generating a response
   that cannot be handled.  For this reason, servers MAY respond to
   Collection GET requests with a Feed Document containing a partial
   list of the Collection's members, and a link to the next partial list
   feed, if it exists.  The first such partial list returned MUST
   contain the most recently edited member Resources and MUST have an
   atom:link with a &quot;next&quot; relation whose &quot;href&quot; value is the URI of the
   next partial list of the Collection.  This next partial list will
   contain the next most recently edited set of Member Resources (and an
   atom:link to the following partial list if it exists).

   In addition to the &quot;next&quot; relation, partial list feeds MAY contain
   link elements with &quot;rel&quot; attribute values of &quot;previous&quot;, &quot;first&quot;, and
   &quot;last&quot;, that can be used to navigate through the complete set of
   entries in the Collection.

   For instance, suppose a client is supplied the URI
   &quot;http://example.org/entries/go&quot; of a Collection of Member Entries,
   where the server as a matter of policy avoids generating Feed
   Documents containing more than 10 Entries.  The Atom Feed Document 

   for the Collection will then represent the first partial list of a
   set of 10 linked Feed Documents.  The &quot;first&quot; relation references the
   initial Feed Document in the set and the &quot;last&quot; relation references
   the final Feed Document in the set.  Within each document, the
   &quot;previous&quot; and &quot;next&quot; link relations reference the preceding and
   subsequent documents.

     &amp;lt;feed xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
       &amp;lt;link rel=&quot;first&quot;
             href=&quot;http://example.org/entries/go&quot; /&amp;gt;
       &amp;lt;link rel=&quot;next&quot;
             href=&quot;http://example.org/entries/2&quot; /&amp;gt;
       &amp;lt;link rel=&quot;last&quot;
             href=&quot;http://example.org/entries/10&quot; /&amp;gt;
       
     &amp;lt;/feed&amp;gt;

   The &quot;previous&quot; and &quot;next&quot; link elements for the partial list feed
   located at &quot;http://example.org/entries/2&quot; would look like this:

     &amp;lt;feed xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
       &amp;lt;link rel=&quot;first&quot;
             href=&quot;http://example.org/entries/go&quot; /&amp;gt;
       &amp;lt;link rel=&quot;previous&quot;
             href=&quot;http://example.org/entries/go&quot; /&amp;gt;
       &amp;lt;link rel=&quot;next&quot;
             href=&quot;http://example.org/entries/3&quot; /&amp;gt;
       &amp;lt;link rel=&quot;last&quot;
             href=&quot;http://example.org/entries/10&quot; /&amp;gt;
       
     &amp;lt;/feed&amp;gt;</source>
          <target state="translated">Коллекции могут содержать большое количество ресурсов. Клиент, такой как веб-паук или веб-браузер, может быть перегружен, если ответ на GET содержит каждую запись в коллекции - в свою очередь, сервер может также тратить полосу пропускания и время обработки на создание ответа, который не может быть обработан. По этой причине серверы МОГУТ отвечать на запросы GET коллекции с помощью документа канала, содержащего частичный список членов коллекции и ссылку на следующий канал частичного списка, если он существует. Первый такой возвращенный частичный список ДОЛЖЕН содержать последний отредактированный член Resources и ДОЛЖЕН иметь атом: ссылку с отношением &amp;laquo;следующее&amp;raquo;, значение &amp;laquo;href&amp;raquo; которого является URI следующего частичного списка Коллекции.Этот следующий частичный список будет содержать следующий последний редактированный набор ресурсов-членов (и атом: ссылка на следующий частичный список, если он существует). Помимо отношения &amp;laquo;следующий&amp;raquo;, каналы частичного списка МОГУТ содержать элементы ссылки со значениями атрибута rel, равными &amp;laquo;предыдущий&amp;raquo;, &amp;laquo;первый&amp;raquo; и &amp;laquo;последний&amp;raquo;, которые можно использовать для навигации по полному набору записей в Коллекция. Например, предположим, что клиенту предоставлен URI &quot;http://example.org/entries/go&quot; Коллекции записей участников, при этом сервер в соответствии с политикой избегает создания документов канала, содержащих более 10 записей. Затем документ Atom Feed для коллекции будет представлять собой первый частичный список из 10 связанных документов Feed. Первый&quot;отношение ссылается на исходный документ Feed в наборе, а &quot;последнее&quot; отношение ссылается на последний документ Feed в наборе. В каждом документе связи &amp;laquo;предыдущий&amp;raquo; и &amp;laquo;следующий&amp;raquo; ссылаются на предыдущий и последующий документы. &amp;lt;feed xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;link rel = &quot;first&quot; href = &quot;http://example.org/entries/go&quot; /&amp;gt; &amp;lt;link rel = &quot;next &quot;href =&quot; http://example.org/entries/2 &quot;/&amp;gt; &amp;lt;link rel =&quot; last &quot;href =&quot; http://example.org/entries/10 &quot;/&amp;gt; &amp;lt;/feed&amp;gt;&quot; предыдущий &quot; и элементы ссылки &quot;next&quot; для канала частичного списка, расположенного по адресу &quot;http://example.org/entries/2&quot;, будут выглядеть следующим образом:&amp;lt;feed xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;link rel = &quot;first&quot; href = &quot;http://example.org/entries/go&quot; /&amp;gt; &amp;lt;link rel = &quot;предыдущий &quot;href =&quot; http://example.org/entries/go &quot;/&amp;gt; &amp;lt;link rel =&quot; next &quot;href =&quot; http://example.org/entries/3 &quot;/&amp;gt; &amp;lt;link rel =&quot; last &quot;href = &quot;http://example.org/entries/10&quot; /&amp;gt; &amp;lt;/feed&amp;gt;org / entries / 3 &quot;/&amp;gt; &amp;lt;link rel =&quot; last &quot;href =&quot; http://example.org/entries/10 &quot;/&amp;gt; &amp;lt;/feed&amp;gt;org / entries / 3 &quot;/&amp;gt; &amp;lt;link rel =&quot; last &quot;href =&quot; http://example.org/entries/10 &quot;/&amp;gt; &amp;lt;/feed&amp;gt;</target>
        </trans-unit>
        <trans-unit id="19b77d56fd18f49783fa29dab7e6057a1e912b7b" translate="yes" xml:space="preserve">
          <source>Combating ClickJacking with X-Frame-Options - IEInternals</source>
          <target state="translated">Борьба с ClickJacking с помощью X-кадровых опций-IEInternals</target>
        </trans-unit>
        <trans-unit id="4b4da2aaa941fd10619ebba8b1a33ab3b456b5cf" translate="yes" xml:space="preserve">
          <source>Combining Ranges (RFC 7233)</source>
          <target state="translated">Комбинированные диапазоны (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="d9439543fdbba1e16aeffe917fc7d29f50cbcc79" translate="yes" xml:space="preserve">
          <source>Comma-delimited list of the allowed &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;.</source>
          <target state="translated">Список разрешенных &lt;a href=&quot;../methods&quot;&gt;методов HTTP-запроса,&lt;/a&gt; разделенных запятыми .</target>
        </trans-unit>
        <trans-unit id="5bb95ba15fb836d98586a3edad9ec1fd27077fa7" translate="yes" xml:space="preserve">
          <source>Comma-separated values (CSV)</source>
          <target state="translated">Значения,разделенные запятыми (CSV)</target>
        </trans-unit>
        <trans-unit id="68546dfaabacefbed271a8286b33a08186cc138e" translate="yes" xml:space="preserve">
          <source>Command line: &lt;code&gt;pactester -p ~/pacparser-master/tests/proxy.pac -u http://www.mozilla.org&lt;/code&gt;</source>
          <target state="translated">Командная строка: &lt;code&gt;pactester -p ~/pacparser-master/tests/proxy.pac -u http://www.mozilla.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62674fb494832a5696aeff81df38c79717f4136f" translate="yes" xml:space="preserve">
          <source>Command line: &lt;code&gt;pactester -p ~/pacparser-master/tests/proxy.pac -u http://www.mozilla.org&lt;/code&gt; (passes the &lt;code&gt;host&lt;/code&gt; parameter &lt;code&gt;www.mozilla.org&lt;/code&gt; and the &lt;code&gt;url&lt;/code&gt; parameter &lt;code&gt;http://www.mozilla.org&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="4861e90f90a057c5903a2cf3d60626141d9b6010" translate="yes" xml:space="preserve">
          <source>Comments to &lt;a href=&quot;news://news.mozilla.org/netscape.public.mozilla.netlib&quot;&gt;mozilla.dev.platform&lt;/a&gt;</source>
          <target state="translated">Комментарии к &lt;a href=&quot;news://news.mozilla.org/netscape.public.mozilla.netlib&quot;&gt;mozilla.dev.platform&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="355f9fe714bdefce689d0719b3940842115ebbd1" translate="yes" xml:space="preserve">
          <source>Common browsers User Agent strings</source>
          <target state="translated">Общие браузеры Строки агента пользователя</target>
        </trans-unit>
        <trans-unit id="93c3c55fe8f9dff2940ed7383aee89cb47a05822" translate="yes" xml:space="preserve">
          <source>Common causes are a server that is down for maintenance or that is overloaded. This response should be used for temporary conditions and the &lt;a href=&quot;../headers/retry-after&quot;&gt;&lt;code&gt;Retry-After&lt;/code&gt;&lt;/a&gt; HTTP header should, if possible, contain the estimated time for the recovery of the service.</source>
          <target state="translated">Типичные причины - это сервер, который не работает на техническое обслуживание или перегружен. Этот ответ следует использовать для временных условий, а HTTP-заголовок &lt;a href=&quot;../headers/retry-after&quot;&gt; &lt;code&gt;Retry-After&lt;/code&gt; &lt;/a&gt; должен, если возможно, содержать расчетное время восстановления службы.</target>
        </trans-unit>
        <trans-unit id="f52fe2765fb6c8791ca39fc493cf9ca94ef54e30" translate="yes" xml:space="preserve">
          <source>Common format for web browsers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376d942f8b1dc70a62764c08e0779e6fd0d34dc3" translate="yes" xml:space="preserve">
          <source>Common forms of caching entries are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d604abe4effd051b577737efcac0be5dd312de" translate="yes" xml:space="preserve">
          <source>Common problems</source>
          <target state="translated">Общие проблемы</target>
        </trans-unit>
        <trans-unit id="e69ef1fa14a563c69b2071931128d46e80d8fcab" translate="yes" xml:space="preserve">
          <source>Common uses for this mechanism</source>
          <target state="translated">Общее использование этого механизма</target>
        </trans-unit>
        <trans-unit id="a3e3c123b281c1fc386d6962bf0c8c55f62330c3" translate="yes" xml:space="preserve">
          <source>Communicates one or more metrics and descriptions for the given request-response cycle.</source>
          <target state="translated">Сообщает одну или несколько метрик и описаний для заданного цикла запрос-ответ.</target>
        </trans-unit>
        <trans-unit id="36eba05ecfef326403242e9b2557dc4cf61823c3" translate="yes" xml:space="preserve">
          <source>Communicating Presentation Information in Internet Messages: The Content-Disposition Header Field</source>
          <target state="translated">Передача презентационной информации в Интернет-сообщениях:Поле заголовка Content-Disposition</target>
        </trans-unit>
        <trans-unit id="bb4f07ea51666d42daa68586d151fd1eee7f250c" translate="yes" xml:space="preserve">
          <source>Comparing versions of the same resource is a bit tricky: depending on the context, there are two kinds of &lt;em&gt;equality checks&lt;/em&gt;:</source>
          <target state="translated">Сравнивать версии одного и того же ресурса немного сложно: в зависимости от контекста существует два типа &lt;em&gt;проверки равенства&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="187c3be8f0ded5cfb27cd980759930707dd51a48" translate="yes" xml:space="preserve">
          <source>Comparison to chunked &lt;code&gt;Transfer-Encoding&lt;/code&gt;</source>
          <target state="translated">Сравнение с фрагментированным &lt;code&gt;Transfer-Encoding&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cb53559d09ec4706b50627aafe05c3f74ccaf5c" translate="yes" xml:space="preserve">
          <source>Compatibility Notes</source>
          <target state="translated">Примечания по совместимости</target>
        </trans-unit>
        <trans-unit id="7d648a6dff363974f754bb78876c2b10dadd8183" translate="yes" xml:space="preserve">
          <source>Compatibility notes</source>
          <target state="translated">Примечания по совместимости</target>
        </trans-unit>
        <trans-unit id="079f93e4945f9092390a018ed062372bdcfd86bd" translate="yes" xml:space="preserve">
          <source>Complete list of MIME types</source>
          <target state="translated">Полный список типов MIME</target>
        </trans-unit>
        <trans-unit id="8a9facd0c43149e93efff61f4e5ddc45591658e4" translate="yes" xml:space="preserve">
          <source>Components of HTTP-based systems</source>
          <target state="translated">Компоненты систем на базе HTTP</target>
        </trans-unit>
        <trans-unit id="c3c91e1eed116d8885305f2a420a8509e0cc75cc" translate="yes" xml:space="preserve">
          <source>Comprehensive list of MIME types useful for Web developers.</source>
          <target state="translated">Полный список MIME-типов,полезных для веб-разработчиков.</target>
        </trans-unit>
        <trans-unit id="e99b96873911e57f5de9103e887195406f68cd32" translate="yes" xml:space="preserve">
          <source>Compressing HTTP messages is one of the most important ways to improve the performance of a Web site, it shrinks the size of the data transmitted and makes better use of the available bandwidth; browsers always send this header and the server should be configured to abide to it and to use compression.</source>
          <target state="translated">Сжатие HTTP-сообщений является одним из самых важных способов повышения производительности Web-сайта,оно уменьшает размер передаваемых данных и лучше использует доступную полосу пропускания;браузеры всегда посылают этот заголовок,а сервер должен быть настроен на его соблюдение и использование сжатия.</target>
        </trans-unit>
        <trans-unit id="b19ee5750a4f428fdbb3471286458f10f3749ac9" translate="yes" xml:space="preserve">
          <source>Compressing with gzip</source>
          <target state="translated">Сжатие с помощью цыпочек</target>
        </trans-unit>
        <trans-unit id="46ead4045fbadbc2f0b37b6046e5803972459710" translate="yes" xml:space="preserve">
          <source>Compression</source>
          <target state="translated">Compression</target>
        </trans-unit>
        <trans-unit id="5b5a0baa20c54e0050cb20d7eb082ba182a1b5ec" translate="yes" xml:space="preserve">
          <source>Compression can allow an attacker to recover secret data when it is
   compressed in the same context as data under attacker control.
   HTTP/2 enables compression of header fields (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;); the
   following concerns also apply to the use of HTTP compressed content-
   codings (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;[RFC7231], Section&amp;nbsp;3.1.2.1&lt;/a&gt;).

   There are demonstrable attacks on compression that exploit the
   characteristics of the web (e.g., [&lt;a href=&quot;#ref-BREACH&quot;&gt;BREACH&lt;/a&gt;]).  The attacker induces
   multiple requests containing varying plaintext, observing the length
   of the resulting ciphertext in each, which reveals a shorter length
   when a guess about the secret is correct. 

   Implementations communicating on a secure channel MUST NOT compress
   content that includes both confidential and attacker-controlled data
   unless separate compression dictionaries are used for each source of
   data.  Compression MUST NOT be used if the source of data cannot be
   reliably determined.  Generic stream compression, such as that
   provided by TLS, MUST NOT be used with HTTP/2 (see &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;).

   Further considerations regarding the compression of header fields are
   described in [&lt;a href=&quot;#ref-COMPRESSION&quot;&gt;COMPRESSION&lt;/a&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b0ce5a72c7b5ba41f70c30e64c6c6b62713bf9" translate="yes" xml:space="preserve">
          <source>Compression: compress and optimize content to speed up load time.</source>
          <target state="translated">Сжатие:сжатие и оптимизация содержимого для ускорения времени загрузки.</target>
        </trans-unit>
        <trans-unit id="afa306b4fc5fbd90b0a114f6bd08ca2cc8754f57" translate="yes" xml:space="preserve">
          <source>Concatenates the four dot-separated bytes into one 4-byte word and converts it to decimal.</source>
          <target state="translated">Концентрирует четыре разделенных точками байта в одно 4-байтовое слово и преобразует его в десятичный.</target>
        </trans-unit>
        <trans-unit id="b5c1cd3785db2824d1ab278c24866501932dedaf" translate="yes" xml:space="preserve">
          <source>Concepts and usage</source>
          <target state="translated">Концепции и использование</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="9a261b82a98b8bdc6d75dae90ec8ee01b54eeff4" translate="yes" xml:space="preserve">
          <source>Conditional headers</source>
          <target state="translated">Заголовки условий</target>
        </trans-unit>
        <trans-unit id="8bcd73be2170abf93875e1fa36640534488be6c5" translate="yes" xml:space="preserve">
          <source>Conditional range requests</source>
          <target state="translated">Условный диапазон запросов</target>
        </trans-unit>
        <trans-unit id="32f3486df02697cc767cdf9f317b7c01b4f54138" translate="yes" xml:space="preserve">
          <source>Conditional requests</source>
          <target state="translated">Условные запросы</target>
        </trans-unit>
        <trans-unit id="b96d7430d9350e321fe2f05974da38d1376f5101" translate="yes" xml:space="preserve">
          <source>Conditional requests allow implementing the &lt;em&gt;optimistic locking algorithm&lt;/em&gt; (used by most wikis or source control systems). The concept is to allow all clients to get copies of the resource, then let them modify it locally, controlling concurrency by successfully allowing the first client submitting an update. All subsequent updates, based on the now obsolete version of the resource, are rejected:</source>
          <target state="translated">Условные запросы позволяют реализовать &lt;em&gt;оптимистичный алгоритм блокировки&lt;/em&gt; (используется в большинстве вики-сайтов или систем управления версиями). Идея состоит в том, чтобы позволить всем клиентам получать копии ресурса, а затем позволить им изменять его локально, контролируя параллелизм, успешно разрешая первому клиенту отправлять обновление. Все последующие обновления, основанные на устаревшей версии ресурса, отклоняются:</target>
        </trans-unit>
        <trans-unit id="bb657402b08e081af170034d16476c261b3e0bd6" translate="yes" xml:space="preserve">
          <source>Conditional requests are HTTP requests [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;] that include one or
   more header fields indicating a precondition to be tested before
   applying the method semantics to the target resource.  This document
   defines the HTTP/1.1 conditional request mechanisms in terms of the
   architecture, syntax notation, and conformance criteria defined in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;].

   Conditional GET requests are the most efficient mechanism for HTTP
   cache updates [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;].  Conditionals can also be applied to
   state-changing methods, such as PUT and DELETE, to prevent the &quot;lost
   update&quot; problem: one client accidentally overwriting the work of
   another client that has been acting in parallel.

   Conditional request preconditions are based on the state of the
   target resource as a whole (its current value set) or the state as
   observed in a previously obtained representation (one value in that
   set).  A resource might have multiple current representations, each
   with its own observable state.  The conditional request mechanisms
   assume that the mapping of requests to a &quot;selected representation&quot;
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC7231]&lt;/a&gt;) will be consistent over time if the server
   intends to take advantage of conditionals.  Regardless, if the
   mapping is inconsistent and the server is unable to select the
   appropriate representation, then no harm will result when the
   precondition evaluates to false.

   The conditional request preconditions defined by this specification
   (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) are evaluated when applicable to the recipient
   (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;) according to their order of precedence (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).</source>
          <target state="translated">Условные запросы - это HTTP-запросы [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ], которые включают одно или несколько полей заголовков, указывающих предварительное условие, которое необходимо проверить перед применением семантики метода к целевому ресурсу. Этот документ определяет механизмы условного запроса HTTP / 1.1 с точки зрения архитектуры, синтаксической нотации и критериев соответствия, определенных в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]. Условные запросы GET являются наиболее эффективным механизмом обновления кеша HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]. Условные выражения также могут применяться к методам изменения состояния, таким как PUT и DELETE, чтобы предотвратить проблему &amp;laquo;потерянного обновления&amp;raquo;: один клиент случайно перезаписывает работу другого клиента, который действовал параллельно. Предварительные условия условного запроса основаны на состоянии целевого ресурса в целом (его текущий набор значений) или состоянии, наблюдаемом в ранее полученном представлении (одно значение в этом наборе). У ресурса может быть несколько текущих представлений, каждое из которых имеет собственное наблюдаемое состояние. Механизмы условных запросов предполагают, что отображение запросов на &amp;laquo;выбранное представление&amp;raquo; ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;раздел 3 [RFC7231]&lt;/a&gt;) будет согласован с течением времени, если сервер намеревается использовать условные выражения. В любом случае, если отображение несовместимо, и сервер не может выбрать подходящее представление, то при оценке предусловия как ложного не будет никакого вреда. Предварительные условия условного запроса, определенные данной спецификацией ( &lt;a href=&quot;#section-3&quot;&gt;раздел 3&lt;/a&gt; ), оцениваются, когда они применимы к получателю ( &lt;a href=&quot;#section-5&quot;&gt;раздел 5&lt;/a&gt; ), в соответствии с их порядком приоритета ( &lt;a href=&quot;#section-6&quot;&gt;раздел 6&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f8c4083d3ac1096a523190657f90870d3b790d6a" translate="yes" xml:space="preserve">
          <source>Conditional requests are a key feature of HTTP, and allow the building of efficient and complex applications. For caching or resuming downloads, the only work required for webmasters is to configure the server correctly; setting correct etags in some environments can be tricky. Once achieved, the browser will serve the expected conditional requests.</source>
          <target state="translated">Условные запросы являются ключевой особенностью HTTP и позволяют создавать эффективные и сложные приложения.Для кэширования или возобновления загрузки единственная работа,необходимая веб-мастерам,-это правильная настройка сервера;настройка правильных тегов в некоторых средах может быть непростой задачей.После этого браузер будет обслуживать ожидаемые условные запросы.</target>
        </trans-unit>
        <trans-unit id="d6a56385d0729f6ff4bf27671cc845cb6f2cfde5" translate="yes" xml:space="preserve">
          <source>Conditionals</source>
          <target state="translated">Conditionals</target>
        </trans-unit>
        <trans-unit id="168256d8522ab8aa1e488cbca9a371a273b318a6" translate="yes" xml:space="preserve">
          <source>Confidential or sensitive information should never be stored or transmitted in HTTP Cookies, as the entire mechanism is inherently insecure.</source>
          <target state="translated">Конфиденциальная или конфиденциальная информация никогда не должна храниться или передаваться в HTTP Cookies,так как весь механизм по своей природе небезопасен.</target>
        </trans-unit>
        <trans-unit id="b6f09b9822b4fcc7ee7448f402f4626bb6d634c3" translate="yes" xml:space="preserve">
          <source>Configuring Apache</source>
          <target state="translated">Настройка Apache</target>
        </trans-unit>
        <trans-unit id="5aa009cf30d646a189a2b32b2e2f211086ce4d68" translate="yes" xml:space="preserve">
          <source>Configuring Content Security Policy involves adding the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header to a web page and giving it values to control resources the user agent is allowed to load for that page. For example, a page that uploads and displays images could allow images from anywhere, but restrict a form action to a specific endpoint. A properly designed Content Security Policy helps protect a page against a cross site scripting attack. This article explains how to construct such headers properly, and provides examples.</source>
          <target state="translated">Настройка политики безопасности содержимого включает добавление HTTP-заголовка &lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; на веб-страницу и присвоение ему значений для управления ресурсами, которые пользовательский агент может загружать для этой страницы. Например, страница, которая загружает и отображает изображения, может разрешать изображения из любого места, но ограничивать действие формы определенной конечной точкой. Правильно разработанная политика безопасности контента помогает защитить страницу от атак межсайтового сценария. В этой статье объясняется, как правильно создавать такие заголовки, и приводятся примеры.</target>
        </trans-unit>
        <trans-unit id="10fe25707b2c8df561d63aa0f93126ee95f3147f" translate="yes" xml:space="preserve">
          <source>Configuring Content Security Policy involves adding the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header to a web page and giving it values to control what resources the user agent is allowed to load for that page. For example, a page that uploads and displays images could allow images from anywhere, but restrict a form action to a specific endpoint. A properly designed Content Security Policy helps protect a page against a cross site scripting attack. This article explains how to construct such headers properly, and provides examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7daf13b1f60fb4af3d6921cd3bc4aced67ab5a7a" translate="yes" xml:space="preserve">
          <source>Configuring Express</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f39d4583059888ab118eae8d20c986e51f1274e" translate="yes" xml:space="preserve">
          <source>Configuring HAProxy</source>
          <target state="translated">Настройка HAProxy</target>
        </trans-unit>
        <trans-unit id="d70d5fc578cb203b115c05b384a205e2f62a043b" translate="yes" xml:space="preserve">
          <source>Configuring IIS</source>
          <target state="translated">Настройка IIS</target>
        </trans-unit>
        <trans-unit id="2031ab4ee84e7e349fa32c5b2095aa6cafb6bd65" translate="yes" xml:space="preserve">
          <source>Configuring nginx</source>
          <target state="translated">Настройка nginx</target>
        </trans-unit>
        <trans-unit id="532521e6c325d8d9c38dfb2c90ab768c58d19d39" translate="yes" xml:space="preserve">
          <source>Configuring prefetching in the browser</source>
          <target state="translated">Настройка предварительной настройки в браузере</target>
        </trans-unit>
        <trans-unit id="cfe2338ad9f0d231c9e7e937eb36ba083fe3da49" translate="yes" xml:space="preserve">
          <source>Configuring redirects in common servers</source>
          <target state="translated">Настройка перенаправлений на общих серверах</target>
        </trans-unit>
        <trans-unit id="82949d3ffebaebf9aadf54999c74e7c2fdc71165" translate="yes" xml:space="preserve">
          <source>Conflicts are most likely to occur in response to a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; request. For example, you may get a 409 response when uploading a file which is older than the one already on the server resulting in a version control conflict.</source>
          <target state="translated">Конфликты наиболее вероятны в ответ на запрос &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; . Например, вы можете получить ответ 409 при загрузке файла, который старше, чем тот, который уже находится на сервере, что приведет к конфликту управления версиями.</target>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="32e5f579d6704066fd06ba7fbc38b931e1dbb869" translate="yes" xml:space="preserve">
          <source>Connection (RFC 2616)</source>
          <target state="translated">Подключение (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="1f3fc181701dc7eaafa3f89e076f2b6541c863f2" translate="yes" xml:space="preserve">
          <source>Connection Management (RFC 7230)</source>
          <target state="translated">Управление соединениями (RFC 7230)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
