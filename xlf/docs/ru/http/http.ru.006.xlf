<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="488c45ed82b63009ef20ba093e068984681301a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Encoding&lt;/code&gt; entity header is used to compress the media-type. When present, its value indicates which encodings were applied to the entity-body. It lets the client know how to decode in order to obtain the media-type referenced by the &lt;code&gt;Content-Type&lt;/code&gt; header.</source>
          <target state="translated">&lt;code&gt;Content-Encoding&lt;/code&gt; заголовок объекта используется для сжатия типа носителя. Когда он присутствует, его значение указывает, какие кодировки были применены к телу объекта. Он позволяет клиенту знать, как выполнить декодирование, чтобы получить тип мультимедиа, на который ссылается заголовок &lt;code&gt;Content-Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43905a4350aba1098e2a710d64c8e9ee9088db8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt; header is used to specify the &lt;strong&gt; intended audience of the page&lt;/strong&gt;, and can indicate that this is more than one language.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; заголовок используется для определения &lt;strong&gt;целевой аудитории страницы&lt;/strong&gt; , и может указать , что это более чем на одном языке.</target>
        </trans-unit>
        <trans-unit id="a7cdf9f8259b0b027b83c7eabaf300c7bb40cfcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;entity header&lt;/a&gt; is used to describe the language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;заголовок объекта&lt;/a&gt; используются для описания языка (ов) , предназначенными для зрителей, так что она позволяет пользователю различать в соответствии с собственным предпочитаемым языком пользователей.</target>
        </trans-unit>
        <trans-unit id="9ceb94b4b8102114799b44b32b66d5292b6f1285" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Length&lt;/code&gt; entity header indicates the size of the entity-body, in bytes, sent to the recipient.</source>
          <target state="translated">&lt;code&gt;Content-Length&lt;/code&gt; заголовок объект указывает размер тела объекта, в байтах, отправляется получателю.</target>
        </trans-unit>
        <trans-unit id="5d90bdb5582a8fea93b884b09c9eb8e68632eacc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Location&lt;/code&gt; header indicates an alternate location for the returned data. The principal use is to indicate the URL of a resource transmitted as the result of &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Content-Location&lt;/code&gt; заголовка указывает альтернативное расположение для возвращаемых данных. Основное использование - указать URL-адрес ресурса, переданного в результате &lt;a href=&quot;../content_negotiation&quot;&gt;согласования содержимого&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23071b7ae3831b0ab8df674533efac8686372e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Range&lt;/code&gt; response HTTP header indicates where in a full body message a partial message belongs.</source>
          <target state="translated">&lt;code&gt;Content-Range&lt;/code&gt; ответ HTTP заголовок указывает , где в полном сообщении тела принадлежит частичное сообщение.</target>
        </trans-unit>
        <trans-unit id="eda7fd480680111156c0cfd188e09b05c5966f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Type&lt;/code&gt; entity header is used to indicate the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;media type&lt;/a&gt; of the resource.</source>
          <target state="translated">&lt;code&gt;Content-Type&lt;/code&gt; заголовок объекта используется для указания &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;типа носителя&lt;/a&gt; ресурса.</target>
        </trans-unit>
        <trans-unit id="426d10d47e9cd0040a6dc32d3445f661ae1dd5ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; HTTP request header contains stored &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; previously sent by the server with the &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">&lt;code&gt;Cookie&lt;/code&gt; заголовка запроса HTTP содержит хранится &lt;a href=&quot;../cookies&quot;&gt;HTTP куки&lt;/a&gt; , ранее отправленные сервером с &lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; заголовка.</target>
        </trans-unit>
        <trans-unit id="55cd10bb3eab56fcb3aaa9ed9e419b3b3cdd6947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; header is optional and may be omitted if, for example, the browser's privacy settings block cookies.</source>
          <target state="translated">&lt;code&gt;Cookie&lt;/code&gt; заголовка не является обязательным и может быть опущено , если, например, настройки конфиденциальности браузера блокирует куки.</target>
        </trans-unit>
        <trans-unit id="82dc9f4d351ce501d0f5c9cfab64763375d85ec2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; method deletes the specified resource.</source>
          <target state="translated">Метод &lt;code&gt;DELETE&lt;/code&gt; удаляет указанный ресурс.</target>
        </trans-unit>
        <trans-unit id="52d55ecc480b283f141b3b6f98cde8cb0145d572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DNT&lt;/code&gt; (&lt;strong&gt;D&lt;/strong&gt;o &lt;strong&gt;N&lt;/strong&gt;ot &lt;strong&gt;T&lt;/strong&gt;rack) request header indicates the user's tracking preference. It lets users indicate whether they would prefer privacy rather than personalized content.</source>
          <target state="translated">&lt;code&gt;DNT&lt;/code&gt; ( &lt;strong&gt;Д&lt;/strong&gt; о &lt;strong&gt;N&lt;/strong&gt; OT &lt;strong&gt;T&lt;/strong&gt; стойки) заголовка запроса указывает на то предпочтение отслеживания пользователя. Это позволяет пользователям указать, предпочитают ли они конфиденциальность, а не персонализированный контент.</target>
        </trans-unit>
        <trans-unit id="71ac6b7e2c0b37cbc89c1ece6a483f1521bccee2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Date&lt;/code&gt; general HTTP header contains the date and time at which the message was originated.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; заголовок HTTP вообще содержит дату и время , в которое было инициировано сообщение.</target>
        </trans-unit>
        <trans-unit id="a3b1269bf21dd422aa77c2c9c23ee0803a5f37a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; directives define the &lt;em&gt;scope&lt;/em&gt; of the cookie: what URLs the cookies should be sent to.</source>
          <target state="translated">В &lt;code&gt;Domain&lt;/code&gt; и &lt;code&gt;Path&lt;/code&gt; директивы определяют &lt;em&gt;объем&lt;/em&gt; куки: что URL - куки должны быть отправлены.</target>
        </trans-unit>
        <trans-unit id="c9c5ea9e0e528b35e54f97738194b2df17917c31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ETag&lt;/code&gt; HTTP response header is an identifier for a specific version of a resource. It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other (&quot;mid-air collisions&quot;).</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; заголовок HTTP - ответа является идентификатором для конкретной версии ресурса. Это позволяет кешам быть более эффективными и экономить полосу пропускания, поскольку веб-серверу не нужно отправлять полный ответ, если содержимое не изменилось. С другой стороны, если содержимое изменилось, etags полезны для предотвращения перезаписи одновременных обновлений ресурса друг друга (&amp;laquo;воздушные столкновения&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="26733480324535c0741d6a6528e1941641f5ce19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; заголовок позволяет сайты , чтобы выбрать в отчетности и / или приведении в исполнение требований сертификата прозрачности, которая предотвращает использование misissued сертификатов для этого сайта из незамеченным.</target>
        </trans-unit>
        <trans-unit id="d45aa61794fa19b9937294984a26564b7a2b70b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed. When a site enables the &lt;code&gt;Expect-CT&lt;/code&gt; header, they are requesting that the browser check that any certificate for that site appears in public CT logs.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; заголовок позволяет сайты , чтобы выбрать в отчетности и / или приведении в исполнение требований сертификата прозрачности, которая предотвращает использование misissued сертификатов для этого сайта из незамеченным. Когда сайт включает заголовок &lt;code&gt;Expect-CT&lt;/code&gt; , он запрашивает у браузера проверку наличия любого сертификата для этого сайта в общедоступных журналах CT.</target>
        </trans-unit>
        <trans-unit id="39f567c805d3b14ec3ccf5444b3918351ca629ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect&lt;/code&gt; HTTP request header indicates expectations that need to be fulfilled by the server in order to properly handle the request.</source>
          <target state="translated">&lt;code&gt;Expect&lt;/code&gt; заголовок запроса HTTP указывает на то, что ожидания должны быть выполнены на сервере, чтобы правильно обработать запрос.</target>
        </trans-unit>
        <trans-unit id="c43b4a38f617b0e601765fc7fa48f903467c8a77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Forwarded&lt;/code&gt; header contains information from the client-facing side of proxy servers that is altered or lost when a proxy is involved in the path of the request.</source>
          <target state="translated">&lt;code&gt;Forwarded&lt;/code&gt; заголовок содержит информацию от клиента обращенной стороны прокси - серверов , которые были изменены или потеряны , когда прокси участвуют в пути запроса.</target>
        </trans-unit>
        <trans-unit id="e7acf99131e3b502a504dfc606eb81c2fa8a3438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; method requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">Метод &lt;code&gt;GET&lt;/code&gt; запрашивает представление указанного ресурса. Запросы с использованием &lt;code&gt;GET&lt;/code&gt; должны только получать данные.</target>
        </trans-unit>
        <trans-unit id="f4a622f1f455f51e4324f29b7983e11b4aa63399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">&lt;code&gt;GET&lt;/code&gt; запрашивает представление указанного ресурса. Запросы с использованием &lt;code&gt;GET&lt;/code&gt; должны только получать данные.</target>
        </trans-unit>
        <trans-unit id="fe2a61ce5f6f874b6cccf46f639263ba9a7751c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; method asks for a response identical to that of a &lt;code&gt;GET&lt;/code&gt; request, but without the response body.</source>
          <target state="translated">Метод &lt;code&gt;HEAD&lt;/code&gt; запрашивает ответ, идентичный &lt;code&gt;GET&lt;/code&gt; запроса GET , но без тела ответа.</target>
        </trans-unit>
        <trans-unit id="bcdb3000e143a76a0cbe83303746d3c1a0deba82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; requests the headers that are returned if the specified resource would be requested with an HTTP &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method. Such a request can be done before deciding to download a large resource to save bandwidth, for example.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; запрашивает заголовки, которые возвращаются , если указанный ресурс будет предложен с помощью HTTP &lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; метода. Такой запрос может быть выполнен до принятия решения о загрузке большого ресурса, например, для экономии полосы пропускания.</target>
        </trans-unit>
        <trans-unit id="25050b6d25bf48e5e860b9e13a504c685ed5f20b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HttpOnly&lt;/code&gt; cookie attribute can help to mitigate this attack by preventing access to cookie value through JavaScript.</source>
          <target state="translated">&lt;code&gt;HttpOnly&lt;/code&gt; атрибут печенья может помочь смягчить эту атаку путем предотвращения доступа к значению печенья через JavaScript.</target>
        </trans-unit>
        <trans-unit id="4db136fae95161e355b0319d6e24b7eb8dde4690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource only if it matches one of the listed &lt;code&gt;ETags&lt;/code&gt;. For &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; and other non-safe methods, it will only upload the resource in this case.</source>
          <target state="translated">&lt;code&gt;If-Match&lt;/code&gt; заголовок запроса HTTP делает запрос условна. Для методов &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; сервер отправит обратно запрошенный ресурс, только если он соответствует одному из перечисленных &lt;code&gt;ETags&lt;/code&gt; . Для &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; и других небезопасных методов он будет загружать ресурс только в этом случае.</target>
        </trans-unit>
        <trans-unit id="89b34bc5ae9734af9081d0e5ea57512f4460ba59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Modified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it has been last modified after the given date. If the request has not been modified since, the response will be a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt; without any body; the &lt;a href=&quot;last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; response header of a previous request will contain the date of last modification. Unlike &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-Modified-Since&lt;/code&gt; can only be used with a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;If-Modified-Since&lt;/code&gt; запрос HTTP заголовка делает запрос условно: сервер будет отправлять обратно запрошенный ресурс, с &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; статусом, только если оно было отредактировано после указанной даты. Если запрос не был изменен с тех пор, ответом будет &lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; без тела; &lt;a href=&quot;last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; заголовок ответа предыдущего запроса будет содержать дату последнего изменения. В отличие от &lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;If-Modified-Since&lt;/code&gt; может использоваться только с &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5986b8f11ba0994d8a72e97fe21f90cc137ceae5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-None-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it doesn't have an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; matching the given ones. For other methods, the request will be processed only if the eventually existing resource's &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; doesn't match any of the values listed.</source>
          <target state="translated">&lt;code&gt;If-None-Match&lt;/code&gt; заголовок запроса HTTP делает запрос условна. Для методов &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; сервер отправит обратно запрошенный ресурс со статусом &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; , только если у него нет &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; ,&lt;/a&gt; соответствующего данным. Для других методов запрос будет обработан только в том случае, если &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; существующего в конечном итоге ресурса не соответствует ни одному из перечисленных значений.</target>
        </trans-unit>
        <trans-unit id="2724d0a408c5f3bcd5c0014c571f5f10868e51ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Range&lt;/code&gt; HTTP request header makes a range request conditional: if the condition is fulfilled, the range request will be issued and the server sends back a &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status.</source>
          <target state="translated">&lt;code&gt;If-Range&lt;/code&gt; заголовок запроса HTTP делает запрос диапазона условно: если условие выполняется, то запрос на диапазон будет выдан и сервер отправляет обратно &lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; ответа с соответствующим органом. Если условие не выполняется, возвращается полный ресурс со статусом &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22163b61a8a59a375d09bff2ee1f49eb81aa2552" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the request has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">&lt;code&gt;If-Unmodified-Since&lt;/code&gt; запрос HTTP заголовок делает запрос условный: сервер будет отправлять обратно запрошенный ресурс, или принять его в случае &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; или другого не- &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;безопасного&lt;/a&gt; метода, если только он не был изменен после того, как последним заданным Дата. Если запрос был изменен после указанной даты, ответом будет ошибка &lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; (Ошибка предварительного условия).</target>
        </trans-unit>
        <trans-unit id="33d2652dcdd336882d1ff7dcd4aab424143119d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the resource has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">&lt;code&gt;If-Unmodified-Since&lt;/code&gt; запрос HTTP заголовок делает запрос условный: сервер будет отправлять обратно запрошенный ресурс, или принять его в случае &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; или другого не- &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;безопасного&lt;/a&gt; метода, если только он не был изменен после того, как последним заданным Дата. Если ресурс был изменен после указанной даты, ответом будет ошибка &lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; (ошибка предварительного условия).</target>
        </trans-unit>
        <trans-unit id="c6e9dbc2bd4ee3beeb7dae2fbab0d0ed4f0f0c7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Large-Allocation&lt;/code&gt; header throws warnings or error messages when used incorrectly. You'll encounter them in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;web console&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; заголовок бросает предупреждения или сообщения об ошибках при неправильном использовании. Вы встретите их в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;веб-консоли&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f7bbba0c2fe1da5cfd40ee4dbb5a457286f63d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Last-Modified&lt;/code&gt; response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. Less accurate than an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header, it is a fallback mechanism. Conditional requests containing &lt;a href=&quot;if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; headers make use of this field.</source>
          <target state="translated">&lt;code&gt;Last-Modified&lt;/code&gt; ответ HTTP заголовок содержит дату и время, когда сервер происхождения полагает ресурс последнего изменения. Он используется в качестве валидатора, чтобы определить, является ли полученный или сохраненный ресурс одинаковым. Менее точный, чем заголовок &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; , это резервный механизм. В условных запросах, содержащих &lt;a href=&quot;if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; ,&lt;/a&gt; используется это поле.</target>
        </trans-unit>
        <trans-unit id="408faa70ae199f0916e25f0545a45cf1159c3a15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Location&lt;/code&gt; response header indicates the URL to redirect a page to. It only provides a meaning when served with a &lt;code&gt;3xx&lt;/code&gt; (redirection) or &lt;code&gt;201&lt;/code&gt; (created) status response.</source>
          <target state="translated">&lt;code&gt;Location&lt;/code&gt; заголовка ответа указывает URL для перенаправления на страницу. Он имеет смысл только при предоставлении ответа статуса &lt;code&gt;3xx&lt;/code&gt; (перенаправление) или &lt;code&gt;201&lt;/code&gt; (создано).</target>
        </trans-unit>
        <trans-unit id="7d4bbe1245321cac039158aa76ac84b747faeeee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; is used to describe the communication options for the target resource. The client can specify a URL for the OPTIONS method, or an asterisk (*) to refer to the entire server.</source>
          <target state="translated">В &lt;code&gt;OPTIONS&lt;/code&gt; используется для описания параметров связи для целевого ресурса. Клиент может указать URL-адрес для метода OPTIONS или звездочку (*) для ссылки на весь сервер.</target>
        </trans-unit>
        <trans-unit id="87018d773f4ad1701e531629a9f995260745c1b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; method is used to describe the communication options for the target resource.</source>
          <target state="translated">Метод &lt;code&gt;OPTIONS&lt;/code&gt; используется для описания параметров связи для целевого ресурса.</target>
        </trans-unit>
        <trans-unit id="1a07a0f8f183e5dac76997068b2e3c2b7238732b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Origin&lt;/code&gt; request header indicates where a fetch originates from. It doesn't include any path information, but only the server name. It is sent with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests, as well as with &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests. It is similar to the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, but, unlike this header, it doesn't disclose the whole path.</source>
          <target state="translated">&lt;code&gt;Origin&lt;/code&gt; заголовок запроса указывает , где выборка происходит из. Он не включает никакой информации о пути, а только имя сервера. Он отправляется с запросами &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; , а также с запросами &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; . Он похож на заголовок &lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; , но, в отличие от этого заголовка, он не раскрывает весь путь.</target>
        </trans-unit>
        <trans-unit id="f9159e5596093f157b377894f822a924c1cb222b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PATCH&lt;/code&gt; method is used to apply partial modifications to a resource.</source>
          <target state="translated">Метод &lt;code&gt;PATCH&lt;/code&gt; используется для частичного изменения ресурса.</target>
        </trans-unit>
        <trans-unit id="1f5331c568d957daee441f1fc46cb653dfa3c711" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; method is used to submit an entity to the specified resource, often causing a change in state or side effects on the server.</source>
          <target state="translated">Метод &lt;code&gt;POST&lt;/code&gt; используется для отправки объекта указанному ресурсу, часто вызывая изменение состояния или побочные эффекты на сервере.</target>
        </trans-unit>
        <trans-unit id="3be3fad872235976dca00e40191bbd8a2412e11e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; sends data to the server. The type of the body of the request is indicated by the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; отправляет данные на сервер. Тип тела запроса указывается заголовком &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c05eb025eb7c8b4be7ac86b298f646c06fa3ba3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUT&lt;/code&gt; method replaces all current representations of the target resource with the request payload.</source>
          <target state="translated">Метод &lt;code&gt;PUT&lt;/code&gt; заменяет все текущие представления целевого ресурса полезными данными запроса.</target>
        </trans-unit>
        <trans-unit id="0c89f21cbe09b59b1b9abe85e9acdd8ee45935d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pragma&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Pragma&lt;/code&gt; заголовок</target>
        </trans-unit>
        <trans-unit id="d99324cd748dcc4ddf7bf1ab613ab29af0de9abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Proxy-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Proxy-Authenticate&lt;/code&gt; заголовка отправляется вместе с &lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31b15d048b735cd58d12cb36f1c04b433a92d0de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt; HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one &lt;code&gt;Range&lt;/code&gt; header at once, and the server may send back these ranges in a multipart document. If the server sends back ranges, it uses the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; for the response. If the ranges are invalid, the server returns the &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Range Not Satisfiable&lt;/code&gt; error. The server can also ignore the &lt;code&gt;Range&lt;/code&gt; header and return the whole document with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; заголовка запроса HTTP указывает часть документа , который сервер должен вернуть. С одним заголовком &lt;code&gt;Range&lt;/code&gt; можно запросить сразу несколько частей , и сервер может отправить обратно эти диапазоны в документе, состоящем из нескольких частей . Если сервер отправляет обратно диапазоны, он использует &lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; для ответа. Если диапазоны недействительны, сервер возвращает ошибку &lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Range Not Satisfiable&lt;/code&gt; . Сервер также может игнорировать заголовок &lt;code&gt;Range&lt;/code&gt; и возвращать весь документ с кодом состояния &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d730336d5f314e4ffb348e65cc342c819634ceb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header governs which referrer information, sent in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, should be included with requests made.</source>
          <target state="translated">&lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP заголовок определяет , какие сведения, посланные в ссылающейся &lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; заголовке, должен быть включен запросами , сделанных.</target>
        </trans-unit>
        <trans-unit id="471a084b48fd4c8723f09a90baa8df53c1cd93e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Retry-After&lt;/code&gt; response HTTP header indicates how long the user agent should wait before making a follow-up request. There are three main cases this header is used:</source>
          <target state="translated">&lt;code&gt;Retry-After&lt;/code&gt; ответа HTTP заголовка указывает на то, как долго агент пользователя должен подождать , прежде чем сделать последующий запрос. Есть три основных случая использования этого заголовка:</target>
        </trans-unit>
        <trans-unit id="6374aa4b75562bedbe4aa399825eadf45d2253c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header specifies one or more WebSocket protocols that you wish to use, in order of preference. The first one that is supported by the server will be selected and returned by the server in a &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header included in the response. You can use this more than once in the header, as well; the result is the same as if you used a comma-delineated list of subprotocol identifiers in a single header.</source>
          <target state="translated">В &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; заголовка указывает один или более WebSocket протоколы , которые вы хотите использовать, в порядке предпочтения. Первый, который поддерживается сервером, будет выбран и возвращен сервером в заголовке &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; , включенном в ответ. Вы также можете использовать это более одного раза в заголовке; результат будет таким же, как если бы вы использовали разделенный запятыми список идентификаторов подпротоколов в одном заголовке.</target>
        </trans-unit>
        <trans-unit id="bcaa9b003cfb51a580c36805f7e5708f883883c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header communicates one or more metrics and descriptions for a given request-response cycle. It is used to surface any backend server timing metrics (e.g. database read/write, CPU time, file system access, etc.) in the developer tools in the user's browser or in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt;&lt;code&gt;PerformanceServerTiming&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; заголовка передает один или несколько метрик и описания для данного цикла запрос-ответ. Он используется для отображения любых метрик синхронизации внутреннего сервера (например, чтение / запись базы данных, время ЦП, доступ к файловой системе и т. Д.) В инструментах разработчика в браузере пользователя или в интерфейсе &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt; &lt;code&gt;PerformanceServerTiming&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58ba7a6637e80a2b7ed529a9998dc728401d3c92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header may expose potentially sensitive application and infrastructure information. Consider to control which metrics are returned when and to whom on the server side. For example, you could only show metrics to authenticated users and nothing to the public.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; заголовка может выставить потенциально важную информацию приложений и инфраструктуры. Подумайте о том, чтобы контролировать, какие метрики, когда и кому возвращаются на стороне сервера. Например, вы можете показывать показатели только аутентифицированным пользователям и ничего не показывать публике.</target>
        </trans-unit>
        <trans-unit id="1e616d6c13d2c598274b6aa0d7cf7d1cc7921936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP response header is used to send cookies from the server to the user agent.</source>
          <target state="translated">&lt;code&gt;Set-Cookie&lt;/code&gt; заголовка ответа HTTP используется для отправки печенье с сервера агента пользователя.</target>
        </trans-unit>
        <trans-unit id="d633495cdc7990d58394c50c8d640450b06b2d19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; and &lt;code&gt;Cookie&lt;/code&gt; headers</source>
          <target state="translated">В &lt;code&gt;Set-Cookie&lt;/code&gt; и &lt;code&gt;Cookie&lt;/code&gt; заголовки</target>
        </trans-unit>
        <trans-unit id="4ee3227d824b48a69ef6dfb672317e9a7fe813f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SourceMap&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header links generated code to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;source map&lt;/a&gt;, enabling the browser to reconstruct the original source and present the reconstructed original in the debugger.</source>
          <target state="translated">В &lt;code&gt;SourceMap&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; заголовок ответ ссылка сгенерированный код на &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;карту источника&lt;/a&gt; , что позволяет браузер реконструировать оригинал и представить восстановленный оригинал в отладчике.</target>
        </trans-unit>
        <trans-unit id="cc48476ae000e635700cbc6cc0b3e1b52a2ba404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Strict-Transport-Security&lt;/code&gt; response header (often abbreviated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) lets a web site tell browsers that it should only be accessed using HTTPS, instead of using HTTP.</source>
          <target state="translated">&lt;code&gt;Strict-Transport-Security&lt;/code&gt; заголовок ответа (часто сокращенно &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt; ) позволяет веб - сайт , сообщить браузеру , что он должен быть доступен только через HTTPS, вместо того , чтобы использовать HTTP.</target>
        </trans-unit>
        <trans-unit id="a54300d397ddd96a89ed7e4299d868f45d6d3b45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; method performs a message loop-back test along the path to the target resource.</source>
          <target state="translated">Метод &lt;code&gt;TRACE&lt;/code&gt; выполняет проверку обратной связи сообщения на пути к целевому ресурсу.</target>
        </trans-unit>
        <trans-unit id="f4e482563cca8b6b536cb03f419ca214a60b04b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; performs a message loop-back test along the path to the target resource, providing a useful debugging mechanism.</source>
          <target state="translated">&lt;code&gt;TRACE&lt;/code&gt; выполняет тест петли обратно сообщения по пути к целевому ресурсу, обеспечивая полезный механизм отладки.</target>
        </trans-unit>
        <trans-unit id="24a6cebd134cf5267f57018cea1581d2a79160d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tk&lt;/code&gt; response header indicates the tracking status that applied to the corresponding request.</source>
          <target state="translated">&lt;code&gt;Tk&lt;/code&gt; заголовка ответа указывает на состояние отслеживания , которая применяется к соответствующему запросу.</target>
        </trans-unit>
        <trans-unit id="661d8abe462ff964e30520abb6a9490ee2f57e77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Transfer-Encoding&lt;/code&gt; header specifies the form of encoding used to safely transfer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;entity&lt;/a&gt; to the user.</source>
          <target state="translated">&lt;code&gt;Transfer-Encoding&lt;/code&gt; заголовок определяет форму кодирования используется для безопасного переноса &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;лица&lt;/a&gt; пользователя.</target>
        </trans-unit>
        <trans-unit id="48fd812100e724a16068b0d9d88fea979cbef78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Upgrade&lt;/code&gt; header specifies one or more comma-separated protocol names, in order of preference.</source>
          <target state="translated">В &lt;code&gt;Upgrade&lt;/code&gt; Header указывает один или несколько имен протоколов , разделенных запятыми, в порядке предпочтения.</target>
        </trans-unit>
        <trans-unit id="ba632e686f1f5e8841818ed95374f3d49208c686" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;User-Agent&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;User-Agent&lt;/code&gt; заголовка</target>
        </trans-unit>
        <trans-unit id="d7a5f551ef4f873a95fa7564b99b777f320ff383" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server. It is used by the server to indicate which headers it used when selecting a representation of a resource in a &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; algorithm.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; HTTP - заголовок ответа определяет , как соответствовать запросу в будущем заголовков , чтобы решить , можно ли использовать в кэше ответ , а не запрашивать свежую один из исходного сервера. Он используется сервером, чтобы указать, какие заголовки он использовал при выборе представления ресурса в алгоритме &lt;a href=&quot;../content_negotiation&quot;&gt;согласования содержимого&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="194b4e9dbe38f2da963d88dc0f228c708df4f3f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header should be set on a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; response exactly like it would have been set on an equivalent &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; response.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; заголовок должен быть установлен на &lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; ответа так же , как это было бы набор на эквивалентном &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; ответа.</target>
        </trans-unit>
        <trans-unit id="320c93529dc0245d276d67069f44ba338d5af1d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header was added in the version 1.1 of HTTP and is necessary in order to allow caches to work appropriately. A cache, in order to work with server-driven content negotiation, needs to know which criteria was used by the server to select the transmitted content. That way, the cache can replay the algorithm and will be able to serve acceptable content directly, without more request to the server. Obviously, the wildcard '&lt;code&gt;*&lt;/code&gt;' prevents caching from occurring, as the cache cannot know what element is behind it.</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; заголовок был добавлен в версии 1.1 HTTP , и необходимо для того , чтобы позволить кэши , чтобы работать должным образом. Кэш, чтобы работать с согласованием контента, управляемым сервером, должен знать, какие критерии использовались сервером для выбора переданного контента. Таким образом, кеш может воспроизвести алгоритм и сможет обслуживать приемлемый контент напрямую, без дополнительных запросов к серверу. Очевидно, что подстановочный знак &amp;laquo; &lt;code&gt;*&lt;/code&gt; &amp;raquo; предотвращает кеширование, поскольку кеш не может знать, какой элемент скрывается за ним.</target>
        </trans-unit>
        <trans-unit id="7b4bde9aa68e310507cb43566d5d20223a7c4d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; response header</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; заголовок ответа</target>
        </trans-unit>
        <trans-unit id="405a63b6723f58e2ec7f579da6d22e1185e2ba24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WWW-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; response.</source>
          <target state="translated">&lt;code&gt;WWW-Authenticate&lt;/code&gt; заголовок отправляются вместе с &lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; ответом.</target>
        </trans-unit>
        <trans-unit id="4c2052dca6314ec4744d6670a2fcfde4364c3176" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Warning&lt;/code&gt; general HTTP header contains information about possible problems with the status of the message. More than one &lt;code&gt;Warning&lt;/code&gt; header may appear in a response.</source>
          <target state="translated">Общий HTTP-заголовок &amp;laquo; &lt;code&gt;Warning&lt;/code&gt; содержит информацию о возможных проблемах со статусом сообщения. В ответе может отображаться более одного заголовка &amp;laquo; &lt;code&gt;Warning&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9e5b0e1f18626b41321a488aa80a25f985f1deb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; HTTP response header controls DNS prefetching, a feature by which browsers proactively perform domain name resolution on both links that the user may choose to follow as well as URLs for items referenced by the document, including images, CSS, JavaScript, and so forth.</source>
          <target state="translated">В &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; контролирует заголовок ответа HTTP DNS упреждающая выборка, функция , с помощью которого браузеры активно выполнять разрешение доменных имен на обеих ссылок , которые пользователь может выбрать , чтобы следовать, а также URL - адреса для элементов , упоминаемых в документе, в том числе изображений, CSS , JavaScript и так далее.</target>
        </trans-unit>
        <trans-unit id="ff3dc3f28097222bbf317e1c8c99177c20310367" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-For&lt;/code&gt; (XFF) header is a de-facto standard header for identifying the originating IP address of a client connecting to a web server through an HTTP proxy or a load balancer. When traffic is intercepted between clients and servers, server access logs contain the IP address of the proxy or load balancer only. To see the original IP address of the client, the &lt;code&gt;X-Forwarded-For&lt;/code&gt; request header is used.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-For&lt;/code&gt; (XFF) заголовка является де-факто стандартный заголовок для идентификации IP - адрес , исходящих от клиента , подключенного к веб - серверу через HTTP прокси - сервер или балансировки нагрузки. Когда трафик перехватывается между клиентами и серверами, журналы доступа к серверу содержат только IP-адрес прокси или балансировщика нагрузки. Чтобы увидеть исходный IP-адрес клиента, используется заголовок запроса &lt;code&gt;X-Forwarded-For&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="482fcec20c0b4ec16aa7ff0f4a40cd4a8e96efd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Host&lt;/code&gt; (XFH) header is a de-facto standard header for identifying the original host requested by the client in the &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; HTTP request header.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-Host&lt;/code&gt; заголовка (XFH) является стандартом де-факто заголовок для идентификации оригинального хоста , запрошенный клиентом в &lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; - заголовка запроса HTTP.</target>
        </trans-unit>
        <trans-unit id="ac80a173a5330f7e0e915503af16d57814a7f24e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; (XFP) header is a de-facto standard header for identifying the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer. Your server access logs contain the protocol used between the server and the load balancer, but not the protocol used between the client and the load balancer. To determine the protocol used between the client and the load balancer, the &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; request header can be used.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-Proto&lt;/code&gt; заголовок (XFP) является стандартом де-факто заголовок для идентификации протокола (HTTP или HTTPS) , что клиент , используемый для подключения к прокси - сервер или балансировки нагрузки. Журналы доступа к серверу содержат протокол, используемый между сервером и балансировщиком нагрузки, но не протокол, используемый между клиентом и балансировщиком нагрузки. Чтобы определить протокол, используемый между клиентом и балансировщиком нагрузки, можно использовать заголовок запроса &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7641932b013d9ddf2ffa745ed9e59704ae3a5eaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; . Sites can use this to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;clickjacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; - заголовок ответа может быть использован , чтобы указать , должен ли браузер разрешено отобразить страницу в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; . Сайты могут использовать это, чтобы избежать атак с использованием &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;кликджекинга&lt;/a&gt; , гарантируя, что их контент не встроен в другие сайты.</target>
        </trans-unit>
        <trans-unit id="691c4a3bae3f1a7c0be3c3aed1c8e618e4fcd9e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delta-seconds&lt;/code&gt; parameter indicates the number of seconds the results can be cached.</source>
          <target state="translated">Параметр &lt;code&gt;delta-seconds&lt;/code&gt; указывает количество секунд, в течение которых результаты могут быть кэшированы.</target>
        </trans-unit>
        <trans-unit id="8325de55392dc75d103db2ad034803012b8edc93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame-ancestors&lt;/code&gt; directive&amp;rsquo;s syntax is similar to a source list of other directives (e.g. &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;, but doesn't allow &lt;code&gt;'unsafe-eval'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; for example. It will also not fall back to a &lt;code&gt;default-src&lt;/code&gt; setting. Only the sources listed below are allowed:</source>
          <target state="translated">В &lt;code&gt;frame-ancestors&lt;/code&gt; синтаксис директивы похож на список источников других директив (например , по &lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; , но не позволяет &lt;code&gt;'unsafe-eval'&lt;/code&gt; или &lt;code&gt;'unsafe-inline'&lt;/code&gt; , например. Он также не падать обратно в &lt;code&gt;default-src&lt;/code&gt; . Разрешены только источники, перечисленные ниже:</target>
        </trans-unit>
        <trans-unit id="d731b7e80edba53bed02fe84939621f3420c12d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; makes it case-insensitive, and &lt;code&gt;mobi&lt;/code&gt; matches all mobile browsers.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; делаю его не чувствителен к регистру, и &lt;code&gt;mobi&lt;/code&gt; соответствует всем мобильным браузерам.</target>
        </trans-unit>
        <trans-unit id="6ff2a01caeced20b51683f18c74fcf809d0a629a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;infile&lt;/code&gt; parameter is the name of the file you wish to encode into base64 format, and &lt;code&gt;remotename&lt;/code&gt; is the remote name for the file, which isn't actually used in &lt;code&gt;data&lt;/code&gt; URLs.</source>
          <target state="translated">&lt;code&gt;infile&lt;/code&gt; параметр является именем файла , который вы хотите закодировать в формат base64 и &lt;code&gt;remotename&lt;/code&gt; это имя удаленного файл, который фактически не используется в &lt;code&gt;data&lt;/code&gt; URL.</target>
        </trans-unit>
        <trans-unit id="8e539bd2196b041a5032c2ef5a8994c7b7bde4dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mediatype&lt;/code&gt; is a MIME type string, such as &lt;code&gt;'image/jpeg'&lt;/code&gt; for a JPEG image file. If omitted, defaults to &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mediatype&lt;/code&gt; строкового типа MIME, такие как &lt;code&gt;'image/jpeg'&lt;/code&gt; для файла изображения JPEG. Если не указано, по умолчанию используется &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da52d7b321f788536d3829326d49c595d809fbf1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/byteranges&lt;/code&gt; MIME type is used to send partial responses to the browser.</source>
          <target state="translated">&lt;code&gt;multipart/byteranges&lt;/code&gt; типа MIME используются для отправки частичных ответов на браузер.</target>
        </trans-unit>
        <trans-unit id="6d4a04b22f0b8d9d9056086ed2761a4ce7474e18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/form-data&lt;/code&gt;type can be used when sending the values of a completed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Form&lt;/a&gt; from browser to server.</source>
          <target state="translated">Тип &lt;code&gt;multipart/form-data&lt;/code&gt; можно использовать при отправке значений заполненной &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML-формы&lt;/a&gt; из браузера на сервер.</target>
        </trans-unit>
        <trans-unit id="b82adb286ff040efc04b5588e84c42dc13b4b83e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict-dynamic&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. See &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; for an example.</source>
          <target state="translated">В &lt;code&gt;strict-dynamic&lt;/code&gt; выражении источника указует , что траст явно приведенный в сценарии , присутствующий в разметке, сопровождая его с одноразовым номером или хэшем, должны распространяться на все сценарии , загруженных этим корневого сценарий. В то же время любые выражения из белого списка или источника, такие как &lt;code&gt;'self'&lt;/code&gt; или &lt;code&gt;'unsafe-inline'&lt;/code&gt; будут игнорироваться. См. Пример &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3dc0a625918a10bc3cf47e685dbed66f751c4502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive is evaluated before &lt;a href=&quot;block-all-mixed-content&quot;&gt;&lt;code&gt;block-all-mixed-content&lt;/code&gt;&lt;/a&gt; and if it is set, the latter is effectively a no-op. It is recommended to set either directive, but not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">&lt;code&gt;upgrade-insecure-requests&lt;/code&gt; директива вычисляется перед &lt;a href=&quot;block-all-mixed-content&quot;&gt; &lt;code&gt;block-all-mixed-content&lt;/code&gt; &lt;/a&gt; , и если он установлен, то последний не является эффективно не оп. Рекомендуется установить любую директиву, но не обе, если только вы не хотите принудительно использовать HTTPS в старых браузерах, которые не заставляют его после перенаправления на HTTP.</target>
        </trans-unit>
        <trans-unit id="67a6354b055d21e0ec5e6eda7647d60f1e916b1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive will not ensure that users visiting your site via links on third-party sites will be upgraded to HTTPS for the top-level navigation and thus does not replace the &lt;a href=&quot;../strict-transport-security&quot;&gt;&lt;code&gt;Strict-Transport-Security&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) header, which should still be set with an appropriate &lt;code&gt;max-age&lt;/code&gt; to ensure that users are not subject to SSL stripping attacks.</source>
          <target state="translated">&lt;code&gt;upgrade-insecure-requests&lt;/code&gt; директива не будет гарантировать , что пользователи посещают сайт с помощью ссылок на сторонних сайтах будут обновлены до HTTPS для навигации верхнего уровня и , таким образом , не заменяет &lt;a href=&quot;../strict-transport-security&quot;&gt; &lt;code&gt;Strict-Transport-Security&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt; ) заголовок, который все равно должен быть установлен соответствующий &lt;code&gt;max-age&lt;/code&gt; чтобы гарантировать, что пользователи не будут подвержены атакам с удалением SSL.</target>
        </trans-unit>
        <trans-unit id="6a8d44d29e56bc0c55ce499b78519e2f545a58b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;HTTP version&lt;/em&gt;, which defines the structure of the remaining message, acting as an indicator of the expected version to use for the response.</source>
          <target state="translated">Версия &lt;em&gt;HTTP&lt;/em&gt; , которая определяет структуру оставшегося сообщения, действуя как индикатор ожидаемой версии, которая будет использоваться для ответа.</target>
        </trans-unit>
        <trans-unit id="534c7de6c70ce30d5cc7ac84f7a1d413ddee5f41" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;asterisk form&lt;/em&gt;, a simple asterisk (&lt;code&gt;'*'&lt;/code&gt;) is used with &lt;code&gt;OPTIONS&lt;/code&gt;, representing the server as a whole.</source>
          <target state="translated">Форма &lt;em&gt;звездочки&lt;/em&gt; , простая звездочка ( &lt;code&gt;'*'&lt;/code&gt; ) используется с &lt;code&gt;OPTIONS&lt;/code&gt; , представляя сервер в целом.</target>
        </trans-unit>
        <trans-unit id="e9fb04fb929e15b710da1fe284b86de9e6922e23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;protocol version&lt;/em&gt;, usually &lt;code&gt;HTTP/1.1&lt;/code&gt;.</source>
          <target state="translated">Версия &lt;em&gt;протокола&lt;/em&gt; , обычно &lt;code&gt;HTTP/1.1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57141383ea92e8d11fc4aae1bb6ea799c9f809f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request target&lt;/em&gt;, usually a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;, or the absolute path of the protocol, port, and domain are usually characterized by the request context. The format of this request target varies between different HTTP methods. It can be</source>
          <target state="translated">Цель &lt;em&gt;запроса&lt;/em&gt; , обычно &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL-адрес&lt;/a&gt; или абсолютный путь протокола, порта и домена, обычно характеризуются контекстом запроса. Формат этой цели запроса зависит от разных методов HTTP. Может быть</target>
        </trans-unit>
        <trans-unit id="f9cc4edb4b5b40b8f3c061c79a6b4c632e4c730a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user-agent&lt;/em&gt; is any tool that acts on the behalf of the user. This role is primarily performed by the Web browser; a few exceptions being programs used by engineers, and Web developers to debug their applications.</source>
          <target state="translated">&lt;em&gt;Агент пользователя&lt;/em&gt; является любым инструментом , который действует от имени пользователя. Эту роль в основном выполняет веб-браузер; за некоторыми исключениями являются программы, используемые инженерами и веб-разработчиками для отладки своих приложений.</target>
        </trans-unit>
        <trans-unit id="8b83df44d3d37a4c410b129685134339244574f5" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Alt-Svc&lt;/strong&gt; header is used to list alternate ways to reach this website.</source>
          <target state="translated">&lt;strong&gt;Alt-Svc&lt;/strong&gt; заголовок используется в список альтернативных способов достижения этого веб - сайта.</target>
        </trans-unit>
        <trans-unit id="8c3c79f7301c1c8d0fa9e587ad3fa734394dfbe4" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP DELETE request method&lt;/strong&gt; deletes the specified resource.</source>
          <target state="translated">Метод &lt;strong&gt;запроса HTTP DELETE&lt;/strong&gt; удаляет указанный ресурс.</target>
        </trans-unit>
        <trans-unit id="8f98d07b9e286fdee4af0bfd151e3fef8b4e1fdf" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PATCH request method&lt;/strong&gt; applies partial modifications to a resource.</source>
          <target state="translated">Метод &lt;strong&gt;запроса HTTP PATCH&lt;/strong&gt; применяет частичные изменения к ресурсу.</target>
        </trans-unit>
        <trans-unit id="2f72c255d4cd8cf0faaa3dfd5ef732d3c26ae02b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PUT request method&lt;/strong&gt; creates a new resource or replaces a representation of the target resource with the request payload.</source>
          <target state="translated">Метод &lt;strong&gt;запроса HTTP PUT&lt;/strong&gt; создает новый ресурс или заменяет представление целевого ресурса полезными данными запроса.</target>
        </trans-unit>
        <trans-unit id="617a279a7f85aa11b7e9119c0549c65940ed8bdb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Sec-WebSocket-Accept&lt;/strong&gt; header is used in the websocket opening handshake. It would appear in the response headers. That is, this is header is sent from server to client to inform that server is willing to initiate a websocket connection.</source>
          <target state="translated">&lt;strong&gt;Втор-WebSocket-Accept&lt;/strong&gt; заголовок используется в открытии WebSocket квитирования. Он появится в заголовках ответов. То есть этот заголовок отправляется от сервера к клиенту, чтобы сообщить, что сервер готов инициировать соединение через веб-сокет.</target>
        </trans-unit>
        <trans-unit id="fec1b2ea30a4b23ec6ed613fb4a58917ff6f2e5d" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Trailer&lt;/strong&gt; response header allows the sender to include additional fields at the end of chunked messages in order to supply metadata that might be dynamically generated while the message body is sent, such as a message integrity check, digital signature, or post-processing status.</source>
          <target state="translated">&lt;strong&gt;Трейлер&lt;/strong&gt; заголовок ответа позволяет отправителю включать в себя дополнительные поля в конце фрагментированных сообщений для того , чтобы метаданные питания , которые могут быть динамически генерируемым в то время как тело сообщения посылаются, например, проверка целостности сообщения, цифровая подпись, или статус поста-обработки.</target>
        </trans-unit>
        <trans-unit id="72b737b3f7ebb245858f1a5344bbb6bcfd1d296b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;User-Agent&lt;/strong&gt; request header contains a characteristic string that allows the network protocol peers to identify the application type, operating system, software vendor or software version of the requesting software user agent.</source>
          <target state="translated">&lt;strong&gt;User-Agent&lt;/strong&gt; заголовок запроса содержит характерную строку , которая позволяет сверстникам сетевого протокола , чтобы идентифицировать тип приложения, операционную систему, программное обеспечение от поставщика или версии программного обеспечения запрашивающего пользователя программного агента.</target>
        </trans-unit>
        <trans-unit id="ab7fb45a1dfda8bd680e10b36530ac6598af98b2" translate="yes" xml:space="preserve">
          <source>The Accept request-header field can be used to specify certain media
   types which are acceptable for the response. Accept headers can be
   used to indicate that the request is specifically limited to a small
   set of desired types, as in the case of a request for an in-line
   image.

       Accept         = &quot;Accept&quot; &quot;:&quot;
                        #( media-range [ accept-params ] )

       media-range    = ( &quot;*/*&quot;
                        | ( type &quot;/&quot; &quot;*&quot; )
                        | ( type &quot;/&quot; subtype )
                        ) *( &quot;;&quot; parameter )
       accept-params  = &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue *( accept-extension )
       accept-extension = &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]

   The asterisk &quot;*&quot; character is used to group media types into ranges,
   with &quot;*/*&quot; indicating all media types and &quot;type/*&quot; indicating all
   subtypes of that type. The media-range MAY include media type
   parameters that are applicable to that range.

   Each media-range MAY be followed by one or more accept-params,
   beginning with the &quot;q&quot; parameter for indicating a relative quality
   factor. The first &quot;q&quot; parameter (if any) separates the media-range
   parameter(s) from the accept-params. Quality factors allow the user
   or user agent to indicate the relative degree of preference for that
   media-range, using the qvalue scale from 0 to 1 (&lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;). The
   default value is q=1.

      Note: Use of the &quot;q&quot; parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice. Although this prevents any media type parameter named
      &quot;q&quot; from being used with a media range, such an event is believed
      to be unlikely given the lack of any &quot;q&quot; parameters in the IANA
      media type registry and the rare usage of any media type
      parameters in Accept. Future media types are discouraged from
      registering any parameter named &quot;q&quot;. 

   The example

       Accept: audio/*; q=0.2, audio/basic

   SHOULD be interpreted as &quot;I prefer audio/basic, but send me any audio
   type if it is the best available after an 80% mark-down in quality.&quot;

   If no Accept header field is present, then it is assumed that the
   client accepts all media types. If an Accept header field is present,
   and if the server cannot send a response which is acceptable
   according to the combined Accept field value, then the server SHOULD
   send a 406 (not acceptable) response.

   A more elaborate example is

       Accept: text/plain; q=0.5, text/html,
               text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as &quot;text/html and text/x-c are
   the preferred media types, but if they do not exist, then send the
   text/x-dvi entity, and if that does not exist, send the text/plain
   entity.&quot;

   Media ranges can be overridden by more specific media ranges or
   specific media types. If more than one media range applies to a given
   type, the most specific reference has precedence. For example,

       Accept: text/*, text/html, text/html;level=1, */*

   have the following precedence:

       1) text/html;level=1
       2) text/html
       3) text/*
       4) */*

   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   which matches that type. For example,

       Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
               text/html;level=2;q=0.4, */*;q=0.5

   would cause the following values to be associated:

       text/html;level=1         = 1
       text/html                 = 0.7
       text/plain                = 0.3 

       image/jpeg                = 0.5
       text/html;level=2         = 0.4
       text/html;level=3         = 0.7

      Note: A user agent might be provided with a default set of quality
      values for certain media ranges. However, unless the user agent is
      a closed system which cannot interact with other rendering agents,
      this default set ought to be configurable by the user.</source>
          <target state="translated">Поле заголовка запроса Accept может использоваться для указания определенных типов мультимедиа, приемлемых для ответа. Заголовки принятия могут использоваться, чтобы указать, что запрос конкретно ограничен небольшим набором желаемых типов, как в случае запроса встроенного изображения. Accept = &quot;Accept&quot; &quot;:&quot; # (media-range [accept-params]) media-range = (&quot;* / *&quot; | (type &quot;/&quot; &quot;*&quot;) | (type &quot;/&quot; подтип)) * ( &quot;;&quot; параметр) accept-params = &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue * (accept-extension) accept-extension = &quot;;&quot; токен [&quot;=&quot; (токен | строка в кавычках)] Звездочка &quot;*&quot;Символ используется для группировки типов мультимедиа в диапазоны, где &amp;laquo;* / *&amp;raquo; указывает все типы мультимедиа, а &amp;laquo;type / *&amp;raquo; указывает все подтипы этого типа. Медиа-диапазон МОЖЕТ включать в себя параметры типа носителя, применимые к этому диапазону. За каждым медиа-диапазоном МОЖЕТ следовать один или несколько accept-params, начиная с параметра &amp;laquo;q&amp;raquo; для указания относительного коэффициента качества. Первый параметр &amp;laquo;q&amp;raquo; (если есть) отделяет параметр (ы) медиа-диапазона от принимаемых параметров. Коэффициенты качества позволяют пользователю или пользовательскому агенту указать относительную степень предпочтения для этого диапазона мультимедиа, используя шкалу qvalue от 0 до 1 (Медиа-диапазон МОЖЕТ включать в себя параметры типа носителя, применимые к этому диапазону. За каждым медиа-диапазоном МОЖЕТ следовать один или несколько accept-params, начиная с параметра &amp;laquo;q&amp;raquo; для указания относительного коэффициента качества. Первый параметр &amp;laquo;q&amp;raquo; (если есть) отделяет параметр (ы) медиа-диапазона от принимаемых параметров. Коэффициенты качества позволяют пользователю или пользовательскому агенту указать относительную степень предпочтения для этого диапазона мультимедиа, используя шкалу qvalue от 0 до 1 (Медиа-диапазон МОЖЕТ включать в себя параметры типа носителя, применимые к этому диапазону. За каждым медиа-диапазоном МОЖЕТ следовать один или несколько accept-params, начиная с параметра &amp;laquo;q&amp;raquo; для указания относительного коэффициента качества. Первый параметр &amp;laquo;q&amp;raquo; (если есть) отделяет параметр (ы) медиа-диапазона от принимаемых параметров. Коэффициенты качества позволяют пользователю или пользовательскому агенту указать относительную степень предпочтения для этого диапазона мультимедиа, используя шкалу qvalue от 0 до 1 (Коэффициенты качества позволяют пользователю или пользовательскому агенту указать относительную степень предпочтения для этого диапазона мультимедиа, используя шкалу qvalue от 0 до 1 (Коэффициенты качества позволяют пользователю или пользовательскому агенту указать относительную степень предпочтения для этого диапазона мультимедиа, используя шкалу qvalue от 0 до 1 (&lt;a href=&quot;#section-3.9&quot;&gt;Раздел 3.9&lt;/a&gt;). Значение по умолчанию - q = 1. Примечание. Использование имени параметра &amp;laquo;q&amp;raquo; для отделения параметров типа мультимедиа от параметров расширения Accept связано с исторической практикой. Хотя это предотвращает использование любого параметра типа носителя с именем &amp;laquo;q&amp;raquo; с диапазоном носителей, такое событие считается маловероятным, учитывая отсутствие каких-либо параметров &amp;laquo;q&amp;raquo; в реестре типов носителей IANA и редкое использование любого типа носителя. параметры в Accept. В будущих типах носителей не рекомендуется регистрировать какой-либо параметр с именем &amp;laquo;q&amp;raquo;. Пример Accept: audio / *; q = 0,2, audio / basic СЛЕДУЕТ интерпретировать как &amp;laquo;Я предпочитаю audio / basic, но присылайте мне любой тип звука, если он является лучшим из доступных после снижения качества на 80%&amp;raquo;. Если поле заголовка Accept отсутствует,тогда предполагается, что клиент принимает все типы носителей. Если присутствует поле заголовка Accept, и если сервер не может отправить ответ, который является приемлемым в соответствии с объединенным значением поля Accept, то серверу СЛЕДУЕТ отправить ответ 406 (неприемлемо). Более сложный пример - Accept: text / plain; q = 0,5, текст / HTML, текст / x-dvi; q = 0.8, text / xc На словах это будет интерпретироваться как &amp;laquo;text / html и text / xc являются предпочтительными типами мультимедиа, но если они не существуют, отправьте объект text / x-dvi, и если это не так. существуют, отправьте текст / простой объект &quot;. Диапазоны носителей могут быть переопределены более конкретными диапазонами носителей или конкретными типами носителей. Если к данному типу применяется более одного диапазона носителей, приоритет имеет наиболее конкретная ссылка. Например, Принять:text / *, text / html, text / html; level = 1, * / * имеют следующий приоритет: 1) text / html; level = 1 2) text / html 3) text / * 4) * / * Медиа Фактор качества, связанный с данным типом, определяется путем нахождения диапазона носителей с наивысшим приоритетом, который соответствует этому типу. Например, Accept: text / *; q = 0,3, text / html; q = 0,7, text / html; level = 1, text / html; level = 2; q = 0,4, * / *; q = 0,5 вызовет следующие значения должны быть связаны: text / html; level = 1 = 1 text / html = 0.7 text / plain = 0.3 image / jpeg = 0.5 text / html; level = 2 = 0.4 text / html; level = 3 = 0.7 Примечание. : Агенту пользователя может быть предоставлен набор значений качества по умолчанию для определенных диапазонов мультимедиа.Однако, если пользовательский агент не является закрытой системой, которая не может взаимодействовать с другими агентами рендеринга, этот набор по умолчанию должен быть настроен пользователем.</target>
        </trans-unit>
        <trans-unit id="234dfa2f1729dd01886001e7daa88ee0bafe27f6" translate="yes" xml:space="preserve">
          <source>The Accept-Charset request-header field can be used to indicate what
   character sets are acceptable for the response. This field allows
   clients capable of understanding more comprehensive or special-
   purpose character sets to signal that capability to a server which is
   capable of representing documents in those character sets.

      Accept-Charset = &quot;Accept-Charset&quot; &quot;:&quot;
              1#( ( charset | &quot;*&quot; )[ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )


   Character set values are described in &lt;a href=&quot;#section-3.4&quot;&gt;section 3.4&lt;/a&gt;. Each charset MAY
   be given an associated quality value which represents the user's
   preference for that charset. The default value is q=1. An example is

      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

   The special value &quot;*&quot;, if present in the Accept-Charset field,
   matches every character set (including ISO-8859-1) which is not
   mentioned elsewhere in the Accept-Charset field. If no &quot;*&quot; is present
   in an Accept-Charset field, then all character sets not explicitly
   mentioned get a quality value of 0, except for ISO-8859-1, which gets
   a quality value of 1 if not explicitly mentioned.

   If no Accept-Charset header is present, the default is that any
   character set is acceptable. If an Accept-Charset header is present,
   and if the server cannot send a response which is acceptable
   according to the Accept-Charset header, then the server SHOULD send
   an error response with the 406 (not acceptable) status code, though
   the sending of an unacceptable response is also allowed.</source>
          <target state="translated">Поле заголовка запроса Accept-Charset может использоваться, чтобы указать, какие наборы символов приемлемы для ответа. Это поле позволяет клиентам, способным понимать более полные или специальные наборы символов, сигнализировать об этой возможности серверу, который способен представлять документы в этих наборах символов. Accept-Charset = &quot;Accept-Charset&quot; &quot;:&quot; 1 # ((charset | &quot;*&quot;) [&quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue]) Значения набора символов описаны в &lt;a href=&quot;#section-3.4&quot;&gt;разделе 3.4.&lt;/a&gt;, Каждой кодировке МОЖЕТ быть присвоено соответствующее значение качества, которое представляет предпочтения пользователя для этой кодировки. Значение по умолчанию - q = 1. Пример: Accept-Charset: iso-8859-5, unicode-1-1; q = 0.8 Специальное значение &amp;laquo;*&amp;raquo;, если оно присутствует в поле Accept-Charset, соответствует каждому набору символов (включая ISO-8859-1) который не упоминается в другом месте в поле Accept-Charset. Если &quot;*&quot; не присутствует в поле Accept-Charset, тогда все наборы символов, не упомянутые явно, получают значение качества 0, за исключением ISO-8859-1, который получает значение качества 1, если не указано явно. Если заголовок Accept-Charset отсутствует, по умолчанию допустим любой набор символов. Если присутствует заголовок Accept-Charset,и если сервер не может отправить ответ, который является приемлемым в соответствии с заголовком Accept-Charset, то сервер ДОЛЖЕН отправить ответ об ошибке с кодом состояния 406 (неприемлемо), хотя отправка неприемлемого ответа также разрешена.</target>
        </trans-unit>
        <trans-unit id="2e57729d1ed38c6ddc068a85cca9d470a3c1d181" translate="yes" xml:space="preserve">
          <source>The Accept-Encoding request-header field is similar to Accept, but
   restricts the content-codings (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;) that are acceptable in
   the response.

       Accept-Encoding  = &quot;Accept-Encoding&quot; &quot;:&quot; 

                          1#( codings [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       codings          = ( content-coding | &quot;*&quot; )

   Examples of its use are:

       Accept-Encoding: compress, gzip
       Accept-Encoding:
       Accept-Encoding: *
       Accept-Encoding: compress;q=0.5, gzip;q=1.0
       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

   A server tests whether a content-coding is acceptable, according to
   an Accept-Encoding field, using these rules:

      1. If the content-coding is one of the content-codings listed in
         the Accept-Encoding field, then it is acceptable, unless it is
         accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;)

      2. The special &quot;*&quot; symbol in an Accept-Encoding field matches any
         available content-coding not explicitly listed in the header
         field.

      3. If multiple content-codings are acceptable, then the acceptable
         content-coding with the highest non-zero qvalue is preferred.

      4. The &quot;identity&quot; content-coding is always acceptable, unless
         specifically refused because the Accept-Encoding field includes
         &quot;identity;q=0&quot;, or because the field includes &quot;*;q=0&quot; and does
         not explicitly include the &quot;identity&quot; content-coding. If the
         Accept-Encoding field-value is empty, then only the &quot;identity&quot;
         encoding is acceptable.

   If an Accept-Encoding field is present in a request, and if the
   server cannot send a response which is acceptable according to the
   Accept-Encoding header, then the server SHOULD send an error response
   with the 406 (Not Acceptable) status code.

   If no Accept-Encoding field is present in a request, the server MAY
   assume that the client will accept any content coding. In this case,
   if &quot;identity&quot; is one of the available content-codings, then the
   server SHOULD use the &quot;identity&quot; content-coding, unless it has
   additional information that a different content-coding is meaningful
   to the client.

      Note: If the request does not include an Accept-Encoding field,
      and if the &quot;identity&quot; content-coding is unavailable, then
      content-codings commonly understood by HTTP/1.0 clients (i.e., 

      &quot;gzip&quot; and &quot;compress&quot;) are preferred; some older clients
      improperly display messages sent with other content-codings.  The
      server might also make this decision based on information about
      the particular user-agent or client.

      Note: Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings. This means that qvalues will not
      work and are not permitted with x-gzip or x-compress.</source>
          <target state="translated">Поле заголовка запроса Accept-Encoding похоже на Accept, но ограничивает кодирование содержимого ( &lt;a href=&quot;#section-3.5&quot;&gt;раздел 3.5&lt;/a&gt;), которые приемлемы в ответе. Accept-Encoding = &quot;Accept-Encoding&quot; &quot;:&quot; 1 # (codings [&quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue]) codings = (content-coding | &quot;*&quot;) Примеры его использования: Accept-Encoding: сжатие, gzip Accept-Encoding: Accept-Encoding: * Accept-Encoding: compress; q = 0,5, gzip; q = 1.0 Accept-Encoding: gzip; q = 1.0, identity; q = 0,5, *; q = 0 Сервер проверяет, приемлемо ли кодирование содержимого, в соответствии с полем Accept-Encoding, используя следующие правила: 1. Если кодирование содержимого является одним из кодировок содержимого, перечисленных в Accept-Encoding. -Encoding, тогда это приемлемо, если оно не сопровождается qvalue, равным 0. (Как определено в &lt;a href=&quot;#section-3.9&quot;&gt;разделе 3.9.&lt;/a&gt;, qvalue 0 означает &amp;laquo;неприемлемо&amp;raquo;.) 2. Специальный символ &amp;laquo;*&amp;raquo; в поле Accept-Encoding соответствует любому доступному кодированию содержимого, не указанному явно в поле заголовка. 3. Если допустимо несколько кодировок содержимого, то предпочтительным является приемлемое кодирование содержимого с наивысшим ненулевым значением q. 4. &amp;laquo;Идентификационное&amp;raquo; кодирование содержимого всегда приемлемо, если специально не отказано, потому что поле Accept-Encoding включает &amp;laquo;identity; q = 0&amp;raquo;, или потому что поле включает &amp;laquo;*; q = 0&amp;raquo; и не включает явно &amp;raquo; идентичность &quot;контент-кодирование. Если значение поля Accept-Encoding пусто, то приемлемой является только &quot;идентификационная&quot; кодировка.Если в запросе присутствует поле Accept-Encoding, и если сервер не может отправить ответ, который является приемлемым в соответствии с заголовком Accept-Encoding, то сервер ДОЛЖЕН отправить ответ об ошибке с кодом состояния 406 (Not Acceptable). Если в запросе нет поля Accept-Encoding, сервер МОЖЕТ предположить, что клиент примет любое кодирование содержимого. В этом случае, если &amp;laquo;идентичность&amp;raquo; является одним из доступных кодировок контента, то серверу СЛЕДУЕТ использовать &amp;laquo;идентичность&amp;raquo; кодирования контента, если только у него нет дополнительной информации о том, что другое кодирование контента имеет значение для клиента. Примечание. Если запрос не включает поле Accept-Encoding, и если &quot;идентификационное&quot; кодирование содержимого недоступно, то кодирование содержимого обычно понимается клиентами HTTP / 1.0 (т. Е.gzip и compress) предпочтительны; некоторые старые клиенты неправильно отображают сообщения, отправленные с другим кодированием содержимого. Сервер также может принять это решение на основе информации о конкретном пользовательском агенте или клиенте. Примечание. Большинство приложений HTTP / 1.0 не распознают и не подчиняются значениям qvalue, связанным с кодированием содержимого. Это означает, что qvalues ​​не будут работать и не разрешены с x-gzip или x-compress.Это означает, что qvalues ​​не будут работать и не разрешены с x-gzip или x-compress.Это означает, что qvalues ​​не будут работать и не разрешены с x-gzip или x-compress.</target>
        </trans-unit>
        <trans-unit id="2ba115d77d254ca318ebb9337409d39d8d2c75fa" translate="yes" xml:space="preserve">
          <source>The Accept-Language request-header field is similar to Accept, but
   restricts the set of natural languages that are preferred as a
   response to the request. Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;.

       Accept-Language = &quot;Accept-Language&quot; &quot;:&quot;
                         1#( language-range [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       language-range  = ( ( 1*8ALPHA *( &quot;-&quot; 1*8ALPHA ) ) | &quot;*&quot; )

   Each language-range MAY be given an associated quality value which
   represents an estimate of the user's preference for the languages
   specified by that range. The quality value defaults to &quot;q=1&quot;. For
   example,

       Accept-Language: da, en-gb;q=0.8, en;q=0.7

   would mean: &quot;I prefer Danish, but will accept British English and
   other types of English.&quot; A language-range matches a language-tag if
   it exactly equals the tag, or if it exactly equals a prefix of the
   tag such that the first tag character following the prefix is &quot;-&quot;.
   The special range &quot;*&quot;, if present in the Accept-Language field,
   matches every tag not matched by any other range present in the
   Accept-Language field.

      Note: This use of a prefix matching rule does not imply that
      language tags are assigned to languages in such a way that it is
      always true that if a user understands a language with a certain
      tag, then this user will also understand all languages with tags
      for which this tag is a prefix. The prefix rule simply allows the
      use of prefix tags if this is the case.

   The language quality factor assigned to a language-tag by the
   Accept-Language field is the quality value of the longest language-
   range in the field that matches the language-tag. If no language-
   range in the field matches the tag, the language quality factor
   assigned is 0. If no Accept-Language header is present in the
   request, the server 

   SHOULD assume that all languages are equally acceptable. If an
   Accept-Language header is present, then all languages which are
   assigned a quality factor greater than 0 are acceptable.

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header with the complete linguistic preferences of
   the user in every request. For a discussion of this issue, see
   &lt;a href=&quot;#section-15.1.4&quot;&gt;section 15.1.4&lt;/a&gt;.

   As intelligibility is highly dependent on the individual user, it is
   recommended that client applications make the choice of linguistic
   preference available to the user. If the choice is not made
   available, then the Accept-Language header field MUST NOT be given in
   the request.

      Note: When making the choice of linguistic preference available to
      the user, we remind implementors of  the fact that users are not
      familiar with the details of language matching as described above,
      and should provide appropriate guidance. As an example, users
      might assume that on selecting &quot;en-gb&quot;, they will be served any
      kind of English document if British English is not available. A
      user agent might suggest in such a case to add &quot;en&quot; to get the
      best matching behavior.</source>
          <target state="translated">Поле заголовка запроса Accept-Language аналогично Accept, но ограничивает набор естественных языков, которые предпочтительны в качестве ответа на запрос. Языковые теги определены в &lt;a href=&quot;#section-3.10&quot;&gt;разделе 3.10.&lt;/a&gt;, Accept-Language = &quot;Accept-Language&quot; &quot;:&quot; 1 # (language-range [&quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue]) language-range = ((1 * 8ALPHA * (&quot;-&quot; 1 * 8ALPHA)) | &quot;*&quot;) Каждому языковому диапазону МОЖЕТ быть присвоено соответствующее значение качества, которое представляет собой оценку предпочтений пользователя в отношении языков, указанных в этом диапазоне. Значение качества по умолчанию &amp;laquo;q = 1&amp;raquo;. Например, Accept-Language: da, en-gb; q = 0,8, en; q = 0,7 будет означать: &amp;laquo;Я предпочитаю датский, но буду принимать британский английский и другие типы английского&amp;raquo;. Языковой диапазон соответствует языковому тегу, если он в точности совпадает с тегом или если он в точности соответствует префиксу тега, так что первый символ тега, следующий за префиксом, равен &amp;laquo;-&amp;raquo;.Специальный диапазон &amp;laquo;*&amp;raquo;, если он присутствует в поле Accept-Language, соответствует каждому тегу, не совпадающему ни с каким другим диапазоном, представленным в поле Accept-Language. Примечание: это использование правила сопоставления префиксов не означает, что языковые теги назначаются языкам таким образом, что всегда верно, что если пользователь понимает язык с определенным тегом, то этот пользователь также будет понимать все языки с тегами. для которых этот тег является префиксом. Правило префикса просто позволяет использовать префиксные теги, если это так. Фактор качества языка, присвоенный языковому тегу полем Accept-Language, является значением качества самого длинного языкового диапазона в поле, которое соответствует языковому тегу. Если ни один языковой диапазон в поле не соответствует тегу, присвоенный коэффициент качества языка равен 0.Если в запросе отсутствует заголовок Accept-Language, серверу СЛЕДУЕТ предполагать, что все языки одинаково приемлемы. Если присутствует заголовок Accept-Language, то приемлемы все языки, которым назначен коэффициент качества больше 0. Отправка заголовка Accept-Language с полными языковыми предпочтениями пользователя в каждом запросе может противоречить ожиданиям пользователя о конфиденциальности. Для обсуждения этого вопроса см.Отправка заголовка Accept-Language с полными языковыми предпочтениями пользователя в каждом запросе может противоречить ожиданиям пользователя о конфиденциальности. Для обсуждения этого вопроса см.Отправка заголовка Accept-Language с полными языковыми предпочтениями пользователя в каждом запросе может противоречить ожиданиям пользователя о конфиденциальности. Для обсуждения этого вопроса см. &lt;a href=&quot;#section-15.1.4&quot;&gt;раздел 15.1.4&lt;/a&gt;, Поскольку разборчивость во многом зависит от отдельного пользователя, рекомендуется, чтобы клиентские приложения предоставляли пользователю возможность выбора языковых предпочтений. Если выбор недоступен, то поле заголовка Accept-Language НЕ ДОЛЖНО указываться в запросе. Примечание. Делая выбор языковых предпочтений доступным для пользователя, мы напоминаем разработчикам о том, что пользователи не знакомы с деталями сопоставления языков, как описано выше, и должны предоставить соответствующие инструкции. Например, пользователи могут предположить, что при выборе &amp;laquo;en-gb&amp;raquo; им будет предоставлен любой документ на английском языке, если британский английский недоступен. В этом случае пользовательский агент может предложить добавить &amp;laquo;en&amp;raquo;, чтобы добиться наилучшего соответствия.</target>
        </trans-unit>
        <trans-unit id="dceeccc14ca79697274f5080fd10fd4f709e2583" translate="yes" xml:space="preserve">
          <source>The Accept-Ranges response-header field allows the server to
      indicate its acceptance of range requests for a resource:

          Accept-Ranges     = &quot;Accept-Ranges&quot; &quot;:&quot; acceptable-ranges
          acceptable-ranges = 1#range-unit | &quot;none&quot;

      Origin servers that accept byte-range requests MAY send

          Accept-Ranges: bytes

      but are not required to do so. Clients MAY generate byte-range
      requests without having received this header for the resource
      involved. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

      Servers that do not accept any kind of range request for a
      resource MAY send

          Accept-Ranges: none

      to advise the client not to attempt a range request.</source>
          <target state="translated">Поле заголовка ответа Accept-Ranges позволяет серверу указывать, что он принимает запросы диапазона для ресурса: Accept-Ranges = &quot;Accept-Ranges&quot; &quot;:&quot; Допустимые диапазоны диапазонов = 1 # единица измерения диапазона | &quot;none&quot; Серверы происхождения, которые принимают запросы диапазона байтов, МОГУТ отправлять Accept-Ranges: bytes, но не обязаны это делать. Клиенты МОГУТ генерировать запросы байтового диапазона, не получив этот заголовок для задействованного ресурса. Единицы измерения определены в &lt;a href=&quot;#section-3.12&quot;&gt;разделе 3.12&lt;/a&gt; . Серверы, которые не принимают какие-либо запросы диапазона для ресурса, МОГУТ отправлять Accept-Ranges: none, чтобы посоветовать клиенту не пытаться выполнить запрос диапазона.</target>
        </trans-unit>
        <trans-unit id="20fe0a78765b42653f8af73cd9564f1524ef0e69" translate="yes" xml:space="preserve">
          <source>The Age header field is used to convey an estimated age of the
   response message when obtained from a cache.  The Age field value is
   the cache's estimate of the number of seconds since the response was
   generated or validated by the origin server.  In essence, the Age 

   value is the sum of the time that the response has been resident in
   each of the caches along the path from the origin server, plus the
   amount of time it has been in transit along network paths.

   The following data is used for the age calculation:

   age_value

      The term &quot;age_value&quot; denotes the value of the Age header field
      (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;), in a form appropriate for arithmetic operation; or
      0, if not available.

   date_value

      The term &quot;date_value&quot; denotes the value of the Date header field,
      in a form appropriate for arithmetic operations.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;7.1.1.2 of [RFC7231]&lt;/a&gt; for the definition of the Date header field,
      and for requirements regarding responses without it.

   now

      The term &quot;now&quot; means &quot;the current value of the clock at the host
      performing the calculation&quot;.  A host ought to use NTP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;])
      or some similar protocol to synchronize its clocks to Coordinated
      Universal Time.

   request_time

      The current value of the clock at the host at the time the request
      resulting in the stored response was made.

   response_time

      The current value of the clock at the host at the time the
      response was received.

   A response's age can be calculated in two entirely independent ways:

   1.  the &quot;apparent_age&quot;: response_time minus date_value, if the local
       clock is reasonably well synchronized to the origin server's
       clock.  If the result is negative, the result is replaced by
       zero.

   2.  the &quot;corrected_age_value&quot;, if all of the caches along the
       response path implement HTTP/1.1.  A cache MUST interpret this
       value relative to the time the request was initiated, not the
       time that the response was received. 

     apparent_age = max(0, response_time - date_value);

     response_delay = response_time - request_time;
     corrected_age_value = age_value + response_delay;

   These are combined as

     corrected_initial_age = max(apparent_age, corrected_age_value);

   unless the cache is confident in the value of the Age header field
   (e.g., because there are no HTTP/1.0 hops in the Via header field),
   in which case the corrected_age_value MAY be used as the
   corrected_initial_age.

   The current_age of a stored response can then be calculated by adding
   the amount of time (in seconds) since the stored response was last
   validated by the origin server to the corrected_initial_age.

     resident_time = now - response_time;
     current_age = corrected_initial_age + resident_time;</source>
          <target state="translated">Поле заголовка Age используется для передачи предполагаемого возраста ответного сообщения при получении из кеша. Значение поля Age - это оценка кэша количества секунд с момента создания или проверки ответа исходным сервером. По сути, значение Age - это сумма времени, в течение которого ответ находился в каждом из кешей на пути от исходного сервера, плюс время, в течение которого он находился в пути по сетевым путям. Для вычисления возраста используются следующие данные: age_value Термин age_value обозначает значение поля заголовка Age ( &lt;a href=&quot;#section-5.1&quot;&gt;Раздел 5.1&lt;/a&gt;) в форме, подходящей для арифметических операций; или 0, если недоступен. date_value Термин &amp;laquo;date_value&amp;raquo; обозначает значение поля заголовка Date в форме, подходящей для арифметических операций. См. &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Раздел &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;7.1.1.2 [RFC7231]&lt;/a&gt; для определения поля заголовка Date и требований к ответам без него. now Термин &amp;laquo;сейчас&amp;raquo; означает &amp;laquo;текущее значение часов на хосте, выполняющем расчет&amp;raquo;. Хост должен использовать NTP ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;]) или подобный протокол для синхронизации часов по всемирному координированному времени. request_time Текущее значение часов на хосте в момент выполнения запроса, в результате которого был получен сохраненный ответ. response_time Текущее значение часов на хосте на момент получения ответа. Возраст ответа может быть вычислен двумя совершенно независимыми способами: 1. &amp;laquo;видимый_ возраст&amp;raquo;: время ответа минус значение_даты, если локальные часы достаточно хорошо синхронизированы с часами исходного сервера. Если результат отрицательный, результат заменяется нулем. 2. &amp;laquo;corrected_age_value&amp;raquo;, если все кеши на пути ответа реализуют HTTP / 1.1.Кэш ДОЛЖЕН интерпретировать это значение относительно времени, когда запрос был инициирован, а не времени, когда был получен ответ. кажущийся возраст = макс (0, время_ответа - значение_даты); response_delay = response_time - время_запроса; corrected_age_value = age_value + response_delay; Они объединяются как corrected_initial_age = max (visible_age, corrected_age_value); если только кэш не уверен в значении поля заголовка Age (например, потому что в поле заголовка Via нет переходов HTTP / 1.0), и в этом случае значение corrected_age_value МОЖЕТ использоваться как corrected_initial_age. Current_age сохраненного ответа затем может быть вычислено путем добавления количества времени (в секундах) с момента последней проверки сохраненного ответа исходным сервером к corrected_initial_age.resident_time = now - response_time; current_age = исправленный_initial_age + resident_time;</target>
        </trans-unit>
        <trans-unit id="fdef55523947f477881a984ce9c7d78915e916d7" translate="yes" xml:space="preserve">
          <source>The Age response-header field conveys the sender's estimate of the
      amount of time since the response (or its revalidation) was
      generated at the origin server. A cached response is &quot;fresh&quot; if
      its age does not exceed its freshness lifetime. Age values are
      calculated as specified in &lt;a href=&quot;#section-13.2.3&quot;&gt;section 13.2.3&lt;/a&gt;.

           Age = &quot;Age&quot; &quot;:&quot; age-value
           age-value = delta-seconds

      Age values are non-negative decimal integers, representing time in
      seconds.

      If a cache receives a value larger than the largest positive
      integer it can represent, or if any of its age calculations
      overflows, it MUST transmit an Age header with a value of
      2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST
      include an Age header field in every response generated from its
      own cache. Caches SHOULD use an arithmetic type of at least 31
      bits of range.</source>
          <target state="translated">Поле заголовка ответа Age передает оценку отправителя количества времени, прошедшего с момента создания ответа (или его повторной проверки) на исходном сервере. Кешированный ответ считается &amp;laquo;свежим&amp;raquo;, если его возраст не превышает срок его действия. Значения возраста рассчитываются, как указано в &lt;a href=&quot;#section-13.2.3&quot;&gt;разделе 13.2.3.&lt;/a&gt;, Age = &quot;Age&quot; &quot;:&quot; age-value age-value = delta-seconds Значения возраста являются неотрицательными десятичными целыми числами, представляющими время в секундах. Если кэш получает значение, превышающее наибольшее положительное целое число, которое он может представить, или если какие-либо из его вычислений возраста переполняются, он ДОЛЖЕН передать заголовок Age со значением 2147483648 (2 ^ 31). Сервер HTTP / 1.1, который включает кеш, ДОЛЖЕН включать поле заголовка Age в каждый ответ, сгенерированный из его собственного кеша. Кэш ДОЛЖЕН использовать арифметический тип с диапазоном не менее 31 бита.</target>
        </trans-unit>
        <trans-unit id="d37b3ed1a7bd53de7b0c73a5ae6518e139d2ed9d" translate="yes" xml:space="preserve">
          <source>The Allow entity-header field lists the set of methods supported
      by the resource identified by the Request-URI. The purpose of this
      field is strictly to inform the recipient of valid methods
      associated with the resource. An Allow header field MUST be
      present in a 405 (Method Not Allowed) response.

          Allow   = &quot;Allow&quot; &quot;:&quot; #Method

      Example of use:

          Allow: GET, HEAD, PUT

      This field cannot prevent a client from trying other methods.
      However, the indications given by the Allow header field value
      SHOULD be followed. The actual set of allowed methods is defined
      by the origin server at the time of each request.

      The Allow header field MAY be provided with a PUT request to
      recommend the methods to be supported by the new or modified
      resource. The server is not required to support these methods and
      SHOULD include an Allow header in the response giving the actual
      supported methods. 

      A proxy MUST NOT modify the Allow header field even if it does not
      understand all the methods specified, since the user agent might
      have other means of communicating with the origin server.</source>
          <target state="translated">В поле Allow entity-header (Разрешить)перечислен набор методов,поддерживаемых ресурсом,определенным в Request-URI.Целью данного поля является строгое информирование получателя о допустимых методах,связанных с ресурсом.Поле Allow header (Разрешить заголовок)ДОЛЖНО присутствовать в ответе 405 (Метод не разрешен).Разрешить=&quot;Разрешить&quot; &quot;:&quot; #Пример использования метода:Разрешить:GET,HEAD,PUT Это поле не может запретить клиенту пробовать другие методы.Однако,необходимо следовать указаниям,данным в поле Allow header value SHOULD.Реальный набор разрешенных методов определяется сервером-источником в момент каждого запроса.Поле Allow header MAY (Разрешить заголовок)МАЙЯ получает PUT-запрос,чтобы рекомендовать методы,которые будут поддерживаться новым или измененным ресурсом.Сервер не обязан поддерживать эти методы и ДОЛЖЕН включать Allow header (Разрешительный заголовок)в ответ,дающий реально поддерживаемые методы.Прокси-сервер НЕ ДОЛЖЕН изменять поле Allow header (Разрешить заголовок),даже если он не понимает все указанные методы,так как пользовательский агент может иметь другие средства связи с исходным сервером.</target>
        </trans-unit>
        <trans-unit id="13a4fef575d5af4e237a81912fe641b20dff803a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol imposes few restrictions on the actions of servers.
   Unless a constraint is specified here, servers can be expected to
   vary in behavior, in particular around the manipulation of Atom
   Entries sent by clients.  For example, although this specification
   only defines the expected behavior of Collections with respect to GET
   and POST, this does not imply that PUT, DELETE, PROPPATCH, and others
   are forbidden on Collection Resources -- only that this specification
   does not define what the server's response would be to those methods.
   Similarly, while some HTTP status codes are mentioned explicitly,
   clients ought to be prepared to handle any status code from a server.
   Servers can choose to accept, reject, delay, moderate, censor,
   reformat, translate, relocate, or re-categorize the content submitted
   to them.  Only some of these choices are immediately relayed back to
   the client in responses to client requests; other choices may only
   become apparent later, in the feed or published entries.  The same
   series of requests to two different publishing sites can result in a
   different series of HTTP responses, different resulting feeds, or
   different entry contents.

   As a result, client software has to be written flexibly to accept
   what the server decides are the results of its submissions.  Any
   server response or server content modification not explicitly
   forbidden by this specification or HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] is therefore
   allowed.</source>
          <target state="translated">Протокол Atom налагает несколько ограничений на действия серверов. Если здесь не указано ограничение, можно ожидать, что серверы будут различаться по поведению, в частности, в отношении манипуляций с записями Atom, отправляемыми клиентами. Например, хотя эта спецификация определяет только ожидаемое поведение коллекций в отношении GET и POST, это не означает, что PUT, DELETE, PROPPATCH и другие запрещены для ресурсов коллекции - только эта спецификация не определяет, что сервер ответ будет на эти методы. Точно так же, хотя некоторые коды состояния HTTP упоминаются явно, клиенты должны быть готовы обрабатывать любой код состояния с сервера. Серверы могут выбрать принятие, отклонение, задержку, модерацию, цензуру, переформатирование, перевод, перемещение,или измените категорию представленного им контента. Только некоторые из этих вариантов немедленно передаются обратно клиенту в ответах на запросы клиента; другие варианты могут стать очевидными только позже, в ленте или опубликованных записях. Одна и та же серия запросов к двум разным сайтам публикации может привести к разным сериям HTTP-ответов, разным результирующим каналам или разному содержимому записей. В результате клиентское программное обеспечение должно быть гибко написано, чтобы принимать то, что сервер решает как результат его представлений. Любой ответ сервера или изменение содержимого сервера, не запрещенные явно данной спецификацией или HTTP [в ленте или опубликованных записях. Одна и та же серия запросов к двум разным сайтам публикации может привести к разным сериям HTTP-ответов, разным результирующим каналам или разному содержимому записей. В результате клиентское программное обеспечение должно быть гибко написано, чтобы принимать то, что сервер решает как результат его представлений. Любой ответ сервера или изменение содержимого сервера, не запрещенные явно данной спецификацией или HTTP [в ленте или опубликованных записях. Одна и та же серия запросов к двум разным сайтам публикации может привести к разным сериям HTTP-ответов, разным результирующим каналам или разному содержимому записей. В результате клиентское программное обеспечение должно быть гибко написано, чтобы принимать то, что сервер решает как результат его представлений. Любой ответ сервера или изменение содержимого сервера, не запрещенные явно данной спецификацией или HTTP [Любой ответ сервера или изменение содержимого сервера, не запрещенные явно данной спецификацией или HTTP [Любой ответ сервера или изменение содержимого сервера, не запрещенные явно данной спецификацией или HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] поэтому допускается.</target>
        </trans-unit>
        <trans-unit id="3007c47f9b138e0499c5f1a7d9a65013178447c8" translate="yes" xml:space="preserve">
          <source>The Atom Protocol specifies operations for publishing and editing
   Resources using HTTP.  It uses Atom-formatted representations to
   describe the state and metadata of those Resources.  It defines how
   Collections of Resources can be organized, and it specifies formats
   to support their discovery, grouping and categorization.</source>
          <target state="translated">Протокол Atom определяет операции по публикации и редактированию Ресурсов с использованием HTTP.Он использует Атом-форматированные представления для описания состояния и метаданных этих Ресурсов.Он определяет,как могут быть организованы Коллекции Ресурсов,и определяет форматы для поддержки их обнаружения,группировки и категоризации.</target>
        </trans-unit>
        <trans-unit id="3a69850b360c5d4d12134d47ffb0f4087be9cb1a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol uses the response status codes defined in HTTP to
   indicate the success or failure of an operation.  Consult the HTTP
   specification [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] for detailed definitions of each status code.

   Implementers are asked to note that according to the HTTP
   specification, HTTP 4xx and 5xx response entities SHOULD include a
   human-readable explanation of the error.</source>
          <target state="translated">Протокол Atom использует коды состояния ответа, определенные в HTTP, чтобы указать успех или неудачу операции. См. Подробные определения каждого кода состояния в спецификации HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]. Разработчиков просят отметить, что в соответствии со спецификацией HTTP, объекты ответа HTTP 4xx и 5xx ДОЛЖНЫ включать понятное для человека объяснение ошибки.</target>
        </trans-unit>
        <trans-unit id="169d7cc9960872ff8dd439fd04a8242bd3b29ed5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol</source>
          <target state="translated">Протокол публикации атомов</target>
        </trans-unit>
        <trans-unit id="aa8edeb1773be5498439f67a0412dde5980a08ac" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is an application-level protocol for
   publishing and editing Web Resources using HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and XML 1.0
   [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].  The protocol supports the creation of Web Resources and
   provides facilities for:

   o  Collections: Sets of Resources, which can be retrieved in whole or
      in part.

   o  Services: Discovery and description of Collections.

   o  Editing: Creating, editing, and deleting Resources.

   The Atom Publishing Protocol is different from many contemporary
   protocols in that the server is given wide latitude in processing
   requests from clients.  See &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; for more details.</source>
          <target state="translated">Протокол публикации Atom - это протокол уровня приложения для публикации и редактирования веб-ресурсов с использованием HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] и XML 1.0 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ]. Протокол поддерживает создание веб-ресурсов и предоставляет возможности для: o Коллекций: наборов ресурсов, которые могут быть получены полностью или частично. o Услуги: открытие и описание коллекций. o Редактирование: создание, редактирование и удаление ресурсов. Протокол публикации Atom отличается от многих современных протоколов тем, что серверу предоставляется широкая свобода действий при обработке запросов от клиентов. См. &lt;a href=&quot;#section-4.4&quot;&gt;Раздел 4.4&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="091cad87f70ba141ab92f1e05e1c2c4c7b6a0753" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP and thus subject to the
   security considerations found in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;Section&amp;nbsp;15 of [RFC2616]&lt;/a&gt;.

   The threats listed in this section apply to many protocols that run
   under HTTP.  The Atompub Working Group decided that the protection
   afforded by running authenticated HTTP under TLS (as described in
   &lt;a href=&quot;#section-14&quot;&gt;Section 14&lt;/a&gt;) was sufficient to mitigate many of the problems presented
   by the attacks listed in this section.</source>
          <target state="translated">Протокол публикации Atom основан на HTTP и, следовательно, подчиняется соображениям безопасности, изложенным в &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;разделе 15 [RFC2616]&lt;/a&gt; . Угрозы, перечисленные в этом разделе, относятся ко многим протоколам, работающим по протоколу HTTP. Рабочая группа Atompub решила, что защиты, обеспечиваемой запуском аутентифицированного HTTP под TLS (как описано в &lt;a href=&quot;#section-14&quot;&gt;разделе 14&lt;/a&gt; ), достаточно для смягчения многих проблем, связанных с атаками, перечисленными в этом разделе.</target>
        </trans-unit>
        <trans-unit id="5d125ad81e218339dcf924271a55cccc89e9d5f5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP.  Authentication
   requirements for HTTP are covered in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;Section&amp;nbsp;11 of [RFC2616]&lt;/a&gt;.

   The use of authentication mechanisms to prevent POSTing or editing by
   unknown or unauthorized clients is RECOMMENDED but not required.
   When authentication is not used, clients and servers are vulnerable
   to trivial spoofing, denial-of-service, and defacement attacks.
   However, in some contexts, this is an acceptable risk.

   The type of authentication deployed is a local decision made by the
   server operator.  Clients are likely to face authentication schemes
   that vary across server deployments.  At a minimum, client and server
   implementations MUST be capable of being configured to use HTTP Basic
   Authentication [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] in conjunction with a connection made with
   TLS 1.0 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt;] or a subsequent standards-track version of TLS
   (such as [&lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt;]), supporting the conventions for using HTTP over
   TLS described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]. 

   The choice of authentication mechanism will impact interoperability.
   The minimum level of security referenced above (Basic Authentication
   with TLS) is considered good practice for Internet applications at
   the time of publication of this specification and sufficient for
   establishing a baseline for interoperability.  Implementers are
   encouraged to investigate and use alternative mechanisms regarded as
   equivalently good or better at the time of deployment.  It is
   RECOMMENDED that clients be implemented in such a way that new
   authentication schemes can be deployed.

   Because this protocol uses HTTP response status codes as the primary
   means of reporting the result of a request, servers are advised to
   respond to unauthorized or unauthenticated requests using an
   appropriate 4xx HTTP response code (e.g., 401 &quot;Unauthorized&quot; or 403
   &quot;Forbidden&quot;) in accordance with [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;].</source>
          <target state="translated">Протокол публикации Atom основан на HTTP. Требования аутентификации для HTTP описаны в &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;разделе 11 [RFC2616]&lt;/a&gt; . РЕКОМЕНДУЕТСЯ, но не обязательно использовать механизмы аутентификации для предотвращения отправки или редактирования неизвестными или неавторизованными клиентами. Когда аутентификация не используется, клиенты и серверы уязвимы для банального спуфинга, отказа в обслуживании и атак искажения. Однако в некоторых случаях это приемлемый риск. Тип развернутой аутентификации - это локальное решение, принимаемое оператором сервера. Клиенты могут столкнуться со схемами аутентификации, которые различаются в зависимости от развертывания сервера. Как минимум, реализации клиента и сервера ДОЛЖНЫ быть настроены на использование базовой аутентификации HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] в сочетании с подключением, выполненным с помощью TLS 1.0 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt; ] или последующей версии TLS, соответствующей стандартам (например, [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt; ]), поддерживая соглашения об использовании HTTP поверх TLS, описанные в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]. Выбор механизма аутентификации повлияет на взаимодействие. Упомянутый выше минимальный уровень безопасности (базовая аутентификация с TLS) считается хорошей практикой для Интернет-приложений на момент публикации данной спецификации и достаточен для установления базового уровня взаимодействия. Разработчикам рекомендуется изучить и использовать альтернативные механизмы, которые на момент развертывания считаются равноценными или лучшими. РЕКОМЕНДУЕТСЯ, чтобы клиенты были реализованы таким образом, чтобы можно было развертывать новые схемы аутентификации. Поскольку этот протокол использует коды состояния ответа HTTP в качестве основного средства сообщения о результате запроса, серверам рекомендуется отвечать на неавторизованные или неаутентифицированные запросы, используя соответствующий код ответа HTTP 4xx (например,401 &amp;laquo;Несанкционированный&amp;raquo; или 403 &amp;laquo;Запрещенный&amp;raquo;) в соответствии с [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="b27e5a48d6a66251fa9d4883723e1c6d86c30969" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol uses HTTP methods to author Member
   Resources as follows:

   o  GET is used to retrieve a representation of a known Resource.

   o  POST is used to create a new, dynamically named, Resource.  When
      the client submits non-Atom-Entry representations to a Collection
      for creation, two Resources are always created -- a Media Entry
      for the requested Resource, and a Media Link Entry for metadata
      about the Resource that will appear in the Collection.

   o  PUT is used to edit a known Resource.  It is not used for Resource
      creation.

   o  DELETE is used to remove a known Resource.

   The Atom Protocol only covers the creating, editing, and deleting of
   Entry and Media Resources.  Other Resources could be created, edited,
   and deleted as the result of manipulating a Collection, but the
   number of those Resources, their media types, and effects of Atom
   Protocol operations on them are outside the scope of this
   specification. 

   Since all aspects of client-server interaction are defined in terms
   of HTTP, [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] should be consulted for any areas not covered in
   this specification.</source>
          <target state="translated">Протокол публикации Atom использует методы HTTP для создания ресурсов участников следующим образом: o GET используется для получения представления известного ресурса. o POST используется для создания нового ресурса с динамическим именем. Когда клиент отправляет представления, не относящиеся к записи Atom, в коллекцию для создания, всегда создаются два ресурса - запись мультимедиа для запрошенного ресурса и запись связи мультимедиа для метаданных о ресурсе, который будет отображаться в коллекции. o PUT используется для редактирования известного ресурса. Он не используется для создания Ресурса. o DELETE используется для удаления известного ресурса. Протокол Atom охватывает только создание, редактирование и удаление входных и медиаресурсов. Другие ресурсы можно было создавать, редактировать и удалять в результате манипулирования Коллекцией,но количество этих ресурсов, их типы носителей и влияние операций на них протокола Atom выходят за рамки данной спецификации. Поскольку все аспекты взаимодействия клиент-сервер определены в терминах HTTP, [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] следует обращаться к любым областям, не охваченным в этой спецификации.</target>
        </trans-unit>
        <trans-unit id="42d277116045b96cf12bbfe45ba81c76ae3ef5f2" translate="yes" xml:space="preserve">
          <source>The Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] defines the &quot;application/
   atom+xml&quot; media type to identify both Atom Feed and Atom Entry
   Documents.  Implementation experience has demonstrated that Atom Feed
   and Entry Documents can have different processing models and that
   there are situations where they need to be differentiated.  This
   specification defines a &quot;type&quot; parameter used to differentiate the
   two types of Atom documents.</source>
          <target state="translated">Формат синдикации Atom [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] определяет тип носителя &amp;laquo;application / atom + xml&amp;raquo; для идентификации как Atom Feed, так и документов Atom Entry. Опыт внедрения показал, что Atom Feed и Entry Documents могут иметь разные модели обработки и что есть ситуации, в которых их необходимо различать. Эта спецификация определяет параметр &amp;laquo;тип&amp;raquo;, используемый для различения двух типов документов Atom.</target>
        </trans-unit>
        <trans-unit id="6a14656993634aa0a74177de15aa55441d492abb" translate="yes" xml:space="preserve">
          <source>The CONNECT method requests that the recipient establish a tunnel to
   the destination origin server identified by the request-target and,
   if successful, thereafter restrict its behavior to blind forwarding
   of packets, in both directions, until the tunnel is closed.  Tunnels
   are commonly used to create an end-to-end virtual connection, through
   one or more proxies, which can then be secured using TLS (Transport
   Layer Security, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]).

   CONNECT is intended only for use in requests to a proxy.  An origin
   server that receives a CONNECT request for itself MAY respond with a
   2xx (Successful) status code to indicate that a connection is
   established.  However, most origin servers do not implement CONNECT.

   A client sending a CONNECT request MUST send the authority form of
   request-target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;); i.e., the request-target
   consists of only the host name and port number of the tunnel
   destination, separated by a colon.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80

   The recipient proxy can establish a tunnel either by directly
   connecting to the request-target or, if configured to use another
   proxy, by forwarding the CONNECT request to the next inbound proxy.
   Any 2xx (Successful) response indicates that the sender (and all 

   inbound proxies) will switch to tunnel mode immediately after the
   blank line that concludes the successful response's header section;
   data received after that blank line is from the server identified by
   the request-target.  Any response other than a successful response
   indicates that the tunnel has not yet been formed and that the
   connection remains governed by HTTP.

   A tunnel is closed when a tunnel intermediary detects that either
   side has closed its connection: the intermediary MUST attempt to send
   any outstanding data that came from the closed side to the other
   side, close both connections, and then discard any remaining data
   left undelivered.

   Proxy authentication might be used to establish the authority to
   create a tunnel.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80
     Proxy-Authorization: basic aGVsbG86d29ybGQ=

   There are significant risks in establishing a tunnel to arbitrary
   servers, particularly when the destination is a well-known or
   reserved TCP port that is not intended for Web traffic.  For example,
   a CONNECT to a request-target of &quot;example.com:25&quot; would suggest that
   the proxy connect to the reserved port for SMTP traffic; if allowed,
   that could trick the proxy into relaying spam email.  Proxies that
   support CONNECT SHOULD restrict its use to a limited set of known
   ports or a configurable whitelist of safe request targets.

   A server MUST NOT send any Transfer-Encoding or Content-Length header
   fields in a 2xx (Successful) response to CONNECT.  A client MUST
   ignore any Content-Length or Transfer-Encoding header fields received
   in a successful response to CONNECT.

   A payload within a CONNECT request message has no defined semantics;
   sending a payload body on a CONNECT request might cause some existing
   implementations to reject the request.

   Responses to the CONNECT method are not cacheable.</source>
          <target state="translated">Метод CONNECT требует, чтобы получатель установил туннель к исходному серверу назначения, идентифицированному целевым объектом запроса, и, в случае успеха, после этого ограничил свое поведение слепой пересылкой пакетов в обоих направлениях, пока туннель не будет закрыт. Туннели обычно используются для создания сквозного виртуального соединения через один или несколько прокси-серверов, которые затем могут быть защищены с помощью TLS (Transport Layer Security, [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246]&lt;/a&gt;]). CONNECT предназначен только для использования в запросах к прокси. Исходный сервер, который получает запрос CONNECT для себя, МОЖЕТ ответить кодом состояния 2xx (Успешно), чтобы указать, что соединение установлено. Однако большинство исходных серверов не поддерживают CONNECT. Клиент, отправляющий запрос CONNECT, ДОЛЖЕН отправить форму полномочий request-target ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;раздел 5.3 [RFC7230]).&lt;/a&gt;); то есть цель запроса состоит только из имени хоста и номера порта назначения туннеля, разделенных двоеточием. Например, CONNECT server.example.com:80 HTTP / 1.1 Host: server.example.com:80 Прокси-сервер получателя может установить туннель либо путем прямого подключения к цели запроса, либо, если настроен на использование другого прокси, путем пересылки запрос CONNECT к следующему входящему прокси. Любой ответ 2xx (успешный) означает, что отправитель (и все входящие прокси) переключатся в туннельный режим сразу после пустой строки, завершающей раздел заголовка успешного ответа; данные, полученные после этой пустой строки, поступают с сервера, идентифицированного целью запроса.Любой ответ, кроме успешного, указывает на то, что туннель еще не сформирован и что соединение остается управляемым HTTP. Туннель закрывается, когда туннельный посредник обнаруживает, что одна из сторон закрыла свое соединение: посредник ДОЛЖЕН попытаться отправить любые незавершенные данные, которые пришли с закрытой стороны на другую сторону, закрыть оба соединения и затем отбросить все оставшиеся данные, оставшиеся недоставленными. Прокси-аутентификация может использоваться для установления полномочий для создания туннеля. Например, CONNECT server.example.com:80 HTTP / 1.1 Host: server.example.com:80 Proxy-Authorization: basic aGVsbG86d29ybGQ = Установление туннеля к произвольным серверам сопряжено со значительными рисками,особенно, когда местом назначения является хорошо известный или зарезервированный TCP-порт, который не предназначен для веб-трафика. Например, CONNECT к цели запроса &amp;laquo;example.com:25&amp;raquo; предполагает, что прокси-сервер подключается к зарезервированному порту для трафика SMTP; если разрешено, это может обманом заставить прокси-сервер пересылать спам. Прокси-серверы, поддерживающие CONNECT, ДОЛЖНЫ ограничить его использование ограниченным набором известных портов или настраиваемым белым списком безопасных целей запроса. Сервер НЕ ДОЛЖЕН отправлять какие-либо поля заголовка Transfer-Encoding или Content-Length в ответе 2xx (Успешно) на CONNECT. Клиент ДОЛЖЕН игнорировать любые поля заголовка Content-Length или Transfer-Encoding, полученные в успешном ответе на CONNECT. Полезная нагрузка в сообщении запроса CONNECT не имеет определенной семантики;отправка тела полезной нагрузки по запросу CONNECT может привести к тому, что некоторые существующие реализации отклонят запрос. Ответы на метод CONNECT не кэшируются.</target>
        </trans-unit>
        <trans-unit id="5cc173ef45538302331fa209f0189866cab3850f" translate="yes" xml:space="preserve">
          <source>The COPY method creates a duplicate of the source resource identified
   by the Request-URI, in the destination resource identified by the URI
   in the Destination header.  The Destination header MUST be present.
   The exact behavior of the COPY method depends on the type of the
   source resource.

   All WebDAV-compliant resources MUST support the COPY method.
   However, support for the COPY method does not guarantee the ability
   to copy a resource.  For example, separate programs may control
   resources on the same server.  As a result, it may not be possible to
   copy a resource to a location that appears to be on the same server.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">Метод COPY создает копию исходного ресурса, идентифицированного Request-URI, в целевом ресурсе, идентифицированном URI в заголовке Destination. ДОЛЖЕН присутствовать заголовок назначения. Точное поведение метода COPY зависит от типа исходного ресурса. Все ресурсы, совместимые с WebDAV, ДОЛЖНЫ поддерживать метод COPY. Однако поддержка метода COPY не гарантирует возможность копирования ресурса. Например, отдельные программы могут управлять ресурсами на одном сервере. В результате может оказаться невозможным скопировать ресурс в место, которое находится на том же сервере. Этот метод идемпотентен, но небезопасен (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Раздел 9.1 [RFC2616]&lt;/a&gt; ). Ответы на этот метод НЕ ДОЛЖНЫ кэшироваться.</target>
        </trans-unit>
        <trans-unit id="14111f3c8a7b4d6556d104b92402303159cbab91" translate="yes" xml:space="preserve">
          <source>The COPY method on a collection without a Depth header MUST act as if
   a Depth header with value &quot;infinity&quot; was included.  A client may
   submit a Depth header on a COPY on a collection with a value of &quot;0&quot;
   or &quot;infinity&quot;.  Servers MUST support the &quot;0&quot; and &quot;infinity&quot; Depth
   header behaviors on WebDAV-compliant resources.

   An infinite-depth COPY instructs that the collection resource
   identified by the Request-URI is to be copied to the location
   identified by the URI in the Destination header, and all its internal
   member resources are to be copied to a location relative to it,
   recursively through all levels of the collection hierarchy.  Note
   that an infinite-depth COPY of /A/ into /A/B/ could lead to infinite
   recursion if not handled correctly.

   A COPY of &quot;Depth: 0&quot; only instructs that the collection and its
   properties, but not resources identified by its internal member URLs,
   are to be copied.

   Any headers included with a COPY MUST be applied in processing every
   resource to be copied with the exception of the Destination header.

   The Destination header only specifies the destination URI for the
   Request-URI.  When applied to members of the collection identified by
   the Request-URI, the value of Destination is to be modified to
   reflect the current location in the hierarchy.  So, if the Request-
   URI is /a/ with Host header value http://example.com/ and the 

   Destination is http://example.com/b/, then when
   http://example.com/a/c/d is processed, it must use a Destination of
   http://example.com/b/c/d.

   When the COPY method has completed processing, it MUST have created a
   consistent URL namespace at the destination (see &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; for the
   definition of namespace consistency).  However, if an error occurs
   while copying an internal collection, the server MUST NOT copy any
   resources identified by members of this collection (i.e., the server
   must skip this subtree), as this would create an inconsistent
   namespace.  After detecting an error, the COPY operation SHOULD try
   to finish as much of the original copy operation as possible (i.e.,
   the server should still attempt to copy other subtrees and their
   members that are not descendants of an error-causing collection).

   So, for example, if an infinite-depth copy operation is performed on
   collection /a/, which contains collections /a/b/ and /a/c/, and an
   error occurs copying /a/b/, an attempt should still be made to copy
   /a/c/.  Similarly, after encountering an error copying a non-
   collection resource as part of an infinite-depth copy, the server
   SHOULD try to finish as much of the original copy operation as
   possible.

   If an error in executing the COPY method occurs with a resource other
   than the resource identified in the Request-URI, then the response
   MUST be a 207 (Multi-Status), and the URL of the resource causing the
   failure MUST appear with the specific error.

   The 424 (Failed Dependency) status code SHOULD NOT be returned in the
   207 (Multi-Status) response from a COPY method.  These responses can
   be safely omitted because the client will know that the progeny of a
   resource could not be copied when the client receives an error for
   the parent.  Additionally, 201 (Created)/204 (No Content) status
   codes SHOULD NOT be returned as values in 207 (Multi-Status)
   responses from COPY methods.  They, too, can be safely omitted
   because they are the default success codes.</source>
          <target state="translated">Метод COPY для коллекции без заголовка Depth ДОЛЖЕН действовать так, как если бы был включен заголовок Depth со значением &amp;laquo;бесконечность&amp;raquo;. Клиент может отправить заголовок глубины в КОПИИ коллекции со значением &amp;laquo;0&amp;raquo; или &amp;laquo;бесконечность&amp;raquo;. Серверы ДОЛЖНЫ поддерживать поведение заголовка глубины &amp;laquo;0&amp;raquo; и &amp;laquo;бесконечность&amp;raquo; на ресурсах, совместимых с WebDAV. Бесконечная копия COPY указывает, что ресурс коллекции, идентифицированный Request-URI, должен быть скопирован в местоположение, указанное URI в заголовке Destination, и все его внутренние ресурсы-члены должны быть скопированы в местоположение относительно него, рекурсивно на всех уровнях иерархии коллекций. Обратите внимание, что КОПИРОВАНИЕ / A / в / A / B / бесконечной глубины может привести к бесконечной рекурсии, если не обработано правильно. КОПИЯ &amp;laquo;Глубины:0 &quot;указывает только на то, что необходимо скопировать коллекцию и ее свойства, но не ресурсы, идентифицированные ее внутренними URL-адресами. Любые заголовки, включенные в COPY, ДОЛЖНЫ применяться при обработке каждого копируемого ресурса, за исключением заголовка Destination. Заголовок Destination указывает только URI пункта назначения для Request-URI. При применении к членам коллекции, идентифицированным Request-URI, значение Destination должно быть изменено, чтобы отражать текущее местоположение в иерархии. Итак, если Request - URI - это / a / со значением заголовка хоста http://example.com/, а назначение - http://example.com/b/, тогда при обработке http://example.com/a/c/d , он должен использовать назначение http://example.com/b/c/d. Когда метод COPY завершит обработку,он ДОЛЖЕН создать согласованное пространство имен URL в месте назначения (см.&lt;a href=&quot;#section-5.1&quot;&gt;Раздел 5.1&lt;/a&gt;для определения согласованности пространства имен). Однако, если при копировании внутренней коллекции возникает ошибка, сервер НЕ ДОЛЖЕН копировать какие-либо ресурсы, идентифицированные членами этой коллекции (т. Е. Сервер должен пропускать это поддерево), поскольку это создаст несогласованное пространство имен. После обнаружения ошибки операции КОПИРОВАТЬ СЛЕДУЕТ попытаться завершить как можно большую часть исходной операции копирования (т. Е. Сервер все равно должен пытаться скопировать другие поддеревья и их элементы, которые не являются потомками вызывающей ошибку коллекции). Так, например, если операция копирования с бесконечной глубиной выполняется для коллекции / a /, которая содержит коллекции / a / b / и / a / c /, и возникает ошибка копирования / a / b /, попытка все равно должна быть Сделать копию / a / c /. Так же,после обнаружения ошибки при копировании ресурса, не являющегося коллекцией, как части копии с бесконечной глубиной, серверу СЛЕДУЕТ попытаться завершить как можно большую часть исходной операции копирования. Если ошибка при выполнении метода COPY происходит с ресурсом, отличным от ресурса, указанного в Request-URI, то ответ ДОЛЖЕН быть 207 (Multi-Status), а URL-адрес ресурса, вызвавшего сбой, ДОЛЖЕН появиться с конкретным ошибка. Код состояния 424 (неудачная зависимость) НЕ ДОЛЖЕН возвращаться в ответе 207 (мульти-статус) от метода COPY. Эти ответы можно безопасно опустить, потому что клиент будет знать, что потомок ресурса не может быть скопирован, когда клиент получит ошибку для родителя. Дополнительно,Коды состояния 201 (Создано) / 204 (Нет содержимого) НЕ ДОЛЖНЫ возвращаться как значения в ответах 207 (Мульти-статус) от методов КОПИРОВАНИЯ. Их тоже можно безопасно опустить, потому что они являются кодами успеха по умолчанию.</target>
        </trans-unit>
        <trans-unit id="fbbf23077eb5623c9faba43d84ac7826f9fbf870" translate="yes" xml:space="preserve">
          <source>The CORS mechanism supports secure cross-origin requests and data transfers between browsers and web servers. Modern browsers use CORS in an API container such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; to help mitigate the risks of cross-origin HTTP requests.</source>
          <target state="translated">Механизм CORS поддерживает безопасные запросы из разных источников и передачу данных между браузерами и веб-серверами. Современные браузеры используют CORS в контейнере API, таком как &lt;code&gt;XMLHttpRequest&lt;/code&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch,&lt;/a&gt; чтобы снизить риски HTTP-запросов между разными источниками.</target>
        </trans-unit>
        <trans-unit id="96ee35d668c5e43e29f1dd8cb8ffc05ffe8f756d" translate="yes" xml:space="preserve">
          <source>The CORS protocol originally required that behavior but &lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;was subsequently changed to no longer require it&lt;/a&gt;. However, not all browsers have implemented the change, and so still exhibit the behavior that was originally required.</source>
          <target state="translated">Протокол CORS изначально требовал такого поведения, но &lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;впоследствии был изменен, чтобы он больше не требовался&lt;/a&gt; . Однако не все браузеры реализовали это изменение и поэтому по-прежнему демонстрируют поведение, которое требовалось изначально.</target>
        </trans-unit>
        <trans-unit id="90251c7853324d5188765c4d4396bb48f7d83e13" translate="yes" xml:space="preserve">
          <source>The CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive should be used with this header, otherwise this header will be an expensive no-op machine.</source>
          <target state="translated">С этим заголовком следует использовать директиву CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; , иначе этот заголовок будет дорогостоящим бесполезным компьютером.</target>
        </trans-unit>
        <trans-unit id="3a1440f01ca2c2191b9c319acb6ec56e362606ce" translate="yes" xml:space="preserve">
          <source>The Cache-Control general-header field is used to specify directives
   that MUST be obeyed by all caching mechanisms along the
   request/response chain. The directives specify behavior intended to
   prevent caches from adversely interfering with the request or
   response. These directives typically override the default caching
   algorithms. Cache directives are unidirectional in that the presence
   of a directive in a request does not imply that the same directive is
   to be given in the response.

      Note that HTTP/1.0 caches might not implement Cache-Control and
      might only implement Pragma: no-cache (see &lt;a href=&quot;#section-14.32&quot;&gt;section 14.32&lt;/a&gt;).

   Cache directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a cache-
   directive for a specific cache.

    Cache-Control   = &quot;Cache-Control&quot; &quot;:&quot; 1#cache-directive

    cache-directive = cache-request-directive
         | cache-response-directive

    cache-request-directive =
           &quot;no-cache&quot;                          ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                          ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds         ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;, 14.9.4
         | &quot;max-stale&quot; [ &quot;=&quot; delta-seconds ]   ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;min-fresh&quot; &quot;=&quot; delta-seconds       ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;no-transform&quot;                      ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;only-if-cached&quot;                    ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | cache-extension                     ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

     cache-response-directive =
           &quot;public&quot;                               ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;private&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ] ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-cache&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ]; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                             ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;no-transform&quot;                         ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;must-revalidate&quot;                      ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;proxy-revalidate&quot;                     ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds            ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;s-maxage&quot; &quot;=&quot; delta-seconds           ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | cache-extension                        ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

    cache-extension = token [ &quot;=&quot; ( token | quoted-string ) ] 

   When a directive appears without any 1#field-name parameter, the
   directive applies to the entire request or response. When such a
   directive appears with a 1#field-name parameter, it applies only to
   the named field or fields, and not to the rest of the request or
   response. This mechanism supports extensibility; implementations of
   future versions of the HTTP protocol might apply these directives to
   header fields not defined in HTTP/1.1.

   The cache-control directives can be broken down into these general
   categories:

      - Restrictions on what are cacheable; these may only be imposed by
        the origin server.

      - Restrictions on what may be stored by a cache; these may be
        imposed by either the origin server or the user agent.

      - Modifications of the basic expiration mechanism; these may be
        imposed by either the origin server or the user agent.

      - Controls over cache revalidation and reload; these may only be
        imposed by a user agent.

      - Control over transformation of entities.

      - Extensions to the caching system.</source>
          <target state="translated">Поле общего заголовка Cache-Control используется для определения директив, которые ДОЛЖНЫ выполняться всеми механизмами кэширования в цепочке запросов / ответов. Директивы определяют поведение, предназначенное для предотвращения неблагоприятного воздействия кэшей на запрос или ответ. Эти директивы обычно переопределяют алгоритмы кэширования по умолчанию. Директивы кэша являются однонаправленными в том смысле, что наличие директивы в запросе не означает, что та же самая директива должна быть указана в ответе. Обратите внимание, что кеши HTTP / 1.0 могут не реализовывать Cache-Control и могут реализовывать только Pragma: no-cache (см. &lt;a href=&quot;#section-14.32&quot;&gt;Раздел 14.32&lt;/a&gt;). Директивы кэша ДОЛЖНЫ передаваться прокси-сервером или приложением-шлюзом, независимо от их значимости для этого приложения, поскольку директивы могут применяться ко всем получателям в цепочке запросов / ответов. Невозможно указать директиву cache- для конкретного кеша. Cache-Control = &quot;Cache-Control&quot; &quot;:&quot; 1 # кеш-директива cache-directive = кеш-запрос-директива | кеш-ответ-директива кеш-запрос-директива = &quot;без кеша&quot;; &lt;a href=&quot;#section-14.9.1&quot;&gt;Раздел 14.9.1&lt;/a&gt; | &quot;нет магазина&quot;; &lt;a href=&quot;#section-14.9.2&quot;&gt;Раздел 14.9.2&lt;/a&gt; | &quot;max-age&quot; &quot;=&quot; дельта-секунды; &lt;a href=&quot;#section-14.9.3&quot;&gt;Раздел 14.9.3&lt;/a&gt; , 14.9.4 | &amp;laquo;Макс-затхлый&amp;raquo;[&quot;=&quot; дельта-секунды]; &lt;a href=&quot;#section-14.9.3&quot;&gt;Раздел 14.9.3&lt;/a&gt; | &quot;min-fresh&quot; &quot;=&quot; дельта-секунды; &lt;a href=&quot;#section-14.9.3&quot;&gt;Раздел 14.9.3&lt;/a&gt; | &quot;без преобразования&quot;; &lt;a href=&quot;#section-14.9.5&quot;&gt;Раздел 14.9.5&lt;/a&gt; | &quot;только при кэшировании&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;Раздел 14.9.4&lt;/a&gt; | кеш-расширение; &lt;a href=&quot;#section-14.9.6&quot;&gt;Раздел 14.9.6&lt;/a&gt; cache-response-directive = &quot;public&quot;; &lt;a href=&quot;#section-14.9.1&quot;&gt;Раздел 14.9.1&lt;/a&gt; | &quot;private&quot; [&quot;=&quot; &amp;lt;&quot;&amp;gt; 1 # имя-поля &amp;lt;&quot;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;Раздел 14.9.1&lt;/a&gt; | &quot;no-cache&quot; [&quot;=&quot; &amp;lt;&quot;&amp;gt; 1 # имя-поля &amp;lt;&quot;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;Раздел 14.9.1&lt;/a&gt; | &quot;нет магазина&quot;;&lt;a href=&quot;#section-14.9.2&quot;&gt;Раздел 14.9.2&lt;/a&gt; | &quot;без преобразования&quot;; &lt;a href=&quot;#section-14.9.5&quot;&gt;Раздел 14.9.5&lt;/a&gt; | &quot;необходимо перепроверить&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;Раздел 14.9.4&lt;/a&gt; | &quot;proxy-revalidate&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;Раздел 14.9.4&lt;/a&gt; | &quot;max-age&quot; &quot;=&quot; дельта-секунды; &lt;a href=&quot;#section-14.9.3&quot;&gt;Раздел 14.9.3&lt;/a&gt; | &quot;s-maxage&quot; &quot;=&quot; дельта-секунды; &lt;a href=&quot;#section-14.9.3&quot;&gt;Раздел 14.9.3&lt;/a&gt; | кеш-расширение; &lt;a href=&quot;#section-14.9.6&quot;&gt;Раздел 14.9.6&lt;/a&gt; cache-extension = token [&quot;=&quot; (токен | строка в кавычках)] Когда директива появляется без какого-либо 1 # параметра field-name, директива применяется ко всему запросу или ответу. Когда такая директива появляется с параметром 1 # field-name, она применяется только к названному полю или полям, а не к остальной части запроса или ответа. Этот механизм поддерживает расширяемость; реализации будущих версий протокола HTTP могут применять эти директивы к полям заголовка, не определенным в HTTP / 1.1. Директивы управления кешем можно разбить на следующие общие категории: - Ограничения на то, что кэшируется; они могут быть наложены только исходным сервером. - Ограничения на то, что может храниться в кэше; они могут быть наложены либо исходным сервером, либо пользовательским агентом.- Модификации основного механизма истечения срока действия; они могут быть наложены либо исходным сервером, либо пользовательским агентом. - Контроль повторной валидации и перезагрузки кеша; они могут быть наложены только пользовательским агентом. - Контроль трансформации юридических лиц. - Расширения к системе кеширования.</target>
        </trans-unit>
        <trans-unit id="9324bfa18c0087b8561a3281ae4b9944c65be9ca" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional assigned value.
   Informational extensions (those which do not require a change in
   cache behavior) MAY be added without changing the semantics of other
   directives. Behavioral extensions are designed to work by acting as
   modifiers to the existing base of cache directives. Both the new
   directive and the standard directive are supplied, such that
   applications which do not understand the new directive will default
   to the behavior specified by the standard directive, and those that
   understand the new directive will recognize it as modifying the
   requirements associated with the standard directive. In this way,
   extensions to the cache-control directives can be made without
   requiring changes to the base protocol.

   This extension mechanism depends on an HTTP cache obeying all of the
   cache-control directives defined for its native HTTP-version, obeying
   certain extensions, and ignoring all directives that it does not
   understand.

   For example, consider a hypothetical new response directive called
   community which acts as a modifier to the private directive. We
   define this new directive to mean that, in addition to any non-shared
   cache, any cache which is shared only by members of the community
   named within its value may cache the response. An origin server
   wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

       Cache-Control: private, community=&quot;UCI&quot;

   A cache seeing this header field will act correctly even if the cache
   does not understand the community cache-extension, since it will also
   see and understand the private directive and thus default to the safe
   behavior. 

   Unrecognized cache-directives MUST be ignored; it is assumed that any
   cache-directive likely to be unrecognized by an HTTP/1.1 cache will
   be combined with standard directives (or the response's default
   cacheability) such that the cache behavior will remain minimally
   correct even if the cache does not understand the extension(s).</source>
          <target state="translated">Поле заголовка Cache-Control может быть расширено с помощью одного или нескольких маркеров расширения кэша,каждый из которых имеет опционально назначенное значение.Информационные расширения (те,которые не требуют изменения поведения кэша)MAY могут быть добавлены без изменения семантики других директив.Поведенческие расширения предназначены для работы в качестве модификаторов к существующей базе кэш-директив.И новая директива,и стандартная директива поставляются таким образом,что приложения,которые не понимают новую директиву,будут по умолчанию соответствовать поведению,указанному стандартной директивой,а те,кто понимают новую директиву,будут распознавать ее как модифицирующую требования,связанные со стандартной директивой.Таким образом,расширения к директивам управления кэшем могут быть сделаны без необходимости внесения изменений в базовый протокол.Этот механизм расширений зависит от того,что HTTP-кэш подчиняется всем директивам управления кэшем,определенным для его родной HTTP-версии,подчиняется определенным расширениям и игнорирует все директивы,которые ему непонятны.Например,рассмотрим гипотетическую новую директиву ответа,называемую community,которая действует как модификатор к директиве private.Мы определяем эту новую директиву как означающую,что в дополнение к любому неиспользуемому кэшу,любой кэш,который является общим только для членов сообщества,названного в пределах его значения,может кэшировать ответ.Исходный сервер,желающий разрешить сообществу UCI использовать приватный ответ в своем общем кэше(ах),может сделать это,включив Cache-Control:private,community=&quot;UCI&quot; Кэш,видящий это поле заголовка,будет действовать корректно,даже если кэш не понимает расширение кэша сообщества,так как он также увидит и поймет директиву private и,таким образом,по умолчанию будет безопасным поведением.Непопознанные директивы по кэшированию ДОЛЖНЫ быть проигнорированы,предполагается,что любые директивы по кэшированию,которые могут быть нераспознаны кэшем HTTP/1.1,будут объединены со стандартными директивами (или кэшируемостью ответа по умолчанию)таким образом,что поведение кэша останется минимально корректным даже в том случае,если кэш не понимает расширения(-ий).</target>
        </trans-unit>
        <trans-unit id="f33f8e03ed1edc160f54d39609d6b7e8bfc2a2f7" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional value.  A cache
   MUST ignore unrecognized cache directives.

   Informational extensions (those that do not require a change in cache
   behavior) can be added without changing the semantics of other
   directives.

   Behavioral extensions are designed to work by acting as modifiers to
   the existing base of cache directives.  Both the new directive and
   the old directive are supplied, such that applications that do not
   understand the new directive will default to the behavior specified
   by the old directive, and those that understand the new directive
   will recognize it as modifying the requirements associated with the
   old directive.  In this way, extensions to the existing cache-control
   directives can be made without breaking deployed caches.

   For example, consider a hypothetical new response directive called
   &quot;community&quot; that acts as a modifier to the private directive: in
   addition to private caches, any cache that is shared only by members
   of the named community is allowed to cache the response.  An origin
   server wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

     Cache-Control: private, community=&quot;UCI&quot;

   A cache that recognizes such a community cache-extension could
   broaden its behavior in accordance with that extension.  A cache that
   does not recognize the community cache-extension would ignore it and
   adhere to the private directive.</source>
          <target state="translated">Поле заголовка Cache-Control может быть расширено с помощью одного или нескольких маркеров расширения кэша,каждый из которых имеет дополнительное значение.Кэш ДОЛЖЕН игнорировать нераспознанные директивы кэша.Информационные расширения (те,которые не требуют изменения поведения кэша)могут быть добавлены без изменения семантики других директив.Поведенческие расширения предназначены для работы в качестве модификаторов к существующей базе директив кэша.И новая,и старая директива поставляются таким образом,что приложения,которые не понимают новую директиву,будут по умолчанию соответствовать поведению,указанному старой директивой,а те,кто понимает новую директиву,будут распознавать ее как модифицирующую требования,связанные со старой директивой.Таким образом,расширения к существующим директивам управления кэшем могут быть сделаны без разрыва развернутого кэша.Например,рассмотрим гипотетическую новую директиву ответа,называемую &quot;community&quot;,которая действует как модификатор к директиве private:в дополнение к приватным кэшам любой кэш,совместно используемый только членами именованного сообщества,может кэшировать ответ.Исходный сервер,желающий разрешить сообществу UCI использовать приватный ответ в своем общем кэше(ах),может сделать это,включив Cache-Control:private,community=&quot;UCI&quot; Кэш,который распознает такое расширение кэша сообщества,может расширить свое поведение в соответствии с этим расширением.Кэш,который не распознает расширение community cache-extension,будет игнорировать его и придерживаться директивы private.</target>
        </trans-unit>
        <trans-unit id="e4526b0c406ce54b0f40282cbe0ea0db53127d37" translate="yes" xml:space="preserve">
          <source>The Chrome (or Chromium/blink-based engines) user agent string is similar to the Firefox format. For compatibility, it adds strings like &quot;KHTML, like Gecko&quot; and &quot;Safari&quot;.</source>
          <target state="translated">Строка пользовательского агента Chrome (или Chromium/blink-based engines)похожа на формат Firefox.Для совместимости он добавляет строки типа &quot;KHTML,как Gecko&quot; и &quot;Safari&quot;.</target>
        </trans-unit>
        <trans-unit id="4e445db7bcb2d5d8898885e114adb8cb0619ec53" translate="yes" xml:space="preserve">
          <source>The Connection general-header field allows the sender to specify
   options that are desired for that particular connection and MUST NOT
   be communicated by proxies over further connections.

   The Connection header has the following grammar:

       Connection = &quot;Connection&quot; &quot;:&quot; 1#(connection-token)
       connection-token  = token

   HTTP/1.1 proxies MUST parse the Connection header field before a
   message is forwarded and, for each connection-token in this field,
   remove any header field(s) from the message with the same name as the
   connection-token. Connection options are signaled by the presence of
   a connection-token in the Connection header field, not by any
   corresponding additional header field(s), since the additional header
   field may not be sent if there are no parameters associated with that
   connection option.

   Message headers listed in the Connection header MUST NOT include
   end-to-end headers, such as Cache-Control.

   HTTP/1.1 defines the &quot;close&quot; connection option for the sender to
   signal that the connection will be closed after completion of the
   response. For example,

       Connection: close

   in either the request or the response header fields indicates that
   the connection SHOULD NOT be considered `persistent' (&lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;)
   after the current request/response is complete.

   HTTP/1.1 applications that do not support persistent connections MUST
   include the &quot;close&quot; connection option in every message.

   A system receiving an HTTP/1.0 (or lower-version) message that
   includes a Connection header MUST, for each connection-token in this
   field, remove and ignore any header field(s) from the message with
   the same name as the connection-token. This protects against mistaken
   forwarding of such header fields by pre-HTTP/1.1 proxies. See &lt;a href=&quot;#section-19.6.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt;.</source>
          <target state="translated">Поле общего заголовка соединения позволяет отправителю указывать параметры, которые требуются для этого конкретного соединения, и НЕ ДОЛЖНЫ передаваться прокси-серверами через другие соединения. Заголовок Connection имеет следующую грамматику: Connection = &quot;Connection&quot; &quot;:&quot; 1 # (токен соединения) токен соединения = токен HTTP / 1.1 прокси ДОЛЖНЫ анализировать поле заголовка соединения перед пересылкой сообщения и для каждого токена соединения в этом поле удалите все поля заголовка из сообщения с тем же именем, что и токен соединения. Варианты подключения сигнализируются наличием токена подключения в поле заголовка подключения, а не соответствующими дополнительными полями заголовка,поскольку дополнительное поле заголовка не может быть отправлено, если с этим вариантом подключения не связаны параметры. Заголовки сообщений, перечисленные в заголовке соединения, НЕ ДОЛЖНЫ включать сквозные заголовки, такие как Cache-Control. HTTP / 1.1 определяет опцию &amp;laquo;закрытия&amp;raquo; соединения для отправителя, чтобы сообщить, что соединение будет закрыто после завершения ответа. Например, Connection: close в полях заголовка запроса или ответа указывает, что соединение НЕ СЛЕДУЕТ рассматривать как постоянное (опция соединения для отправителя, чтобы сообщить, что соединение будет закрыто после завершения ответа. Например, Connection: close в полях заголовка запроса или ответа указывает, что соединение НЕ ДОЛЖНО считаться постоянным (опция соединения для отправителя, чтобы сообщить, что соединение будет закрыто после завершения ответа. Например, Connection: close в полях заголовка запроса или ответа указывает, что соединение НЕ ДОЛЖНО считаться постоянным (&lt;a href=&quot;#section-8.1&quot;&gt;раздел 8.1&lt;/a&gt; ) после завершения текущего запроса / ответа. Приложения HTTP / 1.1, которые не поддерживают постоянные соединения, ДОЛЖНЫ включать опцию &amp;laquo;закрыть&amp;raquo; соединение в каждое сообщение. Система, получающая сообщение HTTP / 1.0 (или более ранней версии), которое включает заголовок соединения, ДОЛЖНА для каждого токена соединения в этом поле удалять и игнорировать любые поля заголовка из сообщения с тем же именем, что и соединение. маркер. Это защищает от ошибочной пересылки таких полей заголовка прокси до HTTP / 1.1. См. &lt;a href=&quot;#section-19.6.2&quot;&gt;Раздел &lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="400f4aed66b4ae488aed6a9f1d0ba0a1d48e0bf5" translate="yes" xml:space="preserve">
          <source>The Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) provides a &quot;close&quot;
   connection option that a sender SHOULD send when it wishes to close
   the connection after the current request/response pair.

   A client that sends a &quot;close&quot; connection option MUST NOT send further
   requests on that connection (after the one containing &quot;close&quot;) and
   MUST close the connection after reading the final response message
   corresponding to this request.

   A server that receives a &quot;close&quot; connection option MUST initiate a
   close of the connection (see below) after it sends the final response
   to the request that contained &quot;close&quot;.  The server SHOULD send a
   &quot;close&quot; connection option in its final response on that connection.
   The server MUST NOT process any further requests received on that
   connection.

   A server that sends a &quot;close&quot; connection option MUST initiate a close
   of the connection (see below) after it sends the response containing
   &quot;close&quot;.  The server MUST NOT process any further requests received
   on that connection.

   A client that receives a &quot;close&quot; connection option MUST cease sending
   requests on that connection and close the connection after reading
   the response message containing the &quot;close&quot;; if additional pipelined
   requests had been sent on the connection, the client SHOULD NOT
   assume that they will be processed by the server. 

   If a server performs an immediate close of a TCP connection, there is
   a significant risk that the client will not be able to read the last
   HTTP response.  If the server receives additional data from the
   client on a fully closed connection, such as another request that was
   sent by the client before receiving the server's response, the
   server's TCP stack will send a reset packet to the client;
   unfortunately, the reset packet might erase the client's
   unacknowledged input buffers before they can be read and interpreted
   by the client's HTTP parser.

   To avoid the TCP reset problem, servers typically close a connection
   in stages.  First, the server performs a half-close by closing only
   the write side of the read/write connection.  The server then
   continues to read from the connection until it receives a
   corresponding close by the client, or until the server is reasonably
   certain that its own TCP stack has received the client's
   acknowledgement of the packet(s) containing the server's last
   response.  Finally, the server fully closes the connection.

   It is unknown whether the reset problem is exclusive to TCP or might
   also be found in other transport connection protocols.</source>
          <target state="translated">Поле заголовка соединения ( &lt;a href=&quot;#section-6.1&quot;&gt;раздел 6.1&lt;/a&gt;) предоставляет опцию &amp;laquo;закрыть&amp;raquo; соединение, которую ДОЛЖЕН отправить отправитель, когда он хочет закрыть соединение после текущей пары запрос / ответ. Клиент, который отправляет опцию &amp;laquo;закрыть&amp;raquo; соединение, НЕ ДОЛЖЕН отправлять дальнейшие запросы по этому соединению (после того, который содержит &amp;laquo;закрыть&amp;raquo;) и ДОЛЖЕН закрыть соединение после прочтения окончательного ответного сообщения, соответствующего этому запросу. Сервер, который получает опцию &amp;laquo;закрыть&amp;raquo; соединение, ДОЛЖЕН инициировать закрытие соединения (см. Ниже) после того, как он отправит окончательный ответ на запрос, содержащий &amp;laquo;закрыть&amp;raquo;. Серверу СЛЕДУЕТ отправить параметр &amp;laquo;закрыть&amp;raquo; соединение в своем окончательном ответе на это соединение. Сервер НЕ ДОЛЖЕН обрабатывать дальнейшие запросы, полученные по этому соединению. Сервер, который отправляет &quot;Параметр соединения close &quot;ДОЛЖЕН инициировать закрытие соединения (см. ниже) после того, как он отправит ответ, содержащий&quot; закрыть &quot;. Сервер НЕ ДОЛЖЕН обрабатывать любые дальнейшие запросы, полученные по этому соединению. Клиент, который получает параметр соединения&quot; закрыть &quot;, ДОЛЖЕН прекратить отправка запросов по этому соединению и закрытие соединения после прочтения ответного сообщения, содержащего &quot;закрыть&quot;; если в соединении были отправлены дополнительные конвейерные запросы, клиент НЕ ДОЛЖЕН предполагать, что они будут обработаны сервером. Если сервер выполняет немедленное закрытие TCP-соединения, существует значительный риск того, что клиент не сможет прочитать последний HTTP-ответ. Если сервер получает дополнительные данные от клиента при полностью закрытом соединении,например, другой запрос, который был отправлен клиентом до получения ответа сервера, стек TCP сервера отправит клиенту пакет сброса; К сожалению, пакет сброса может стереть неподтвержденные входные буферы клиента до того, как они будут прочитаны и интерпретированы клиентским анализатором HTTP. Чтобы избежать проблемы сброса TCP, серверы обычно закрывают соединение поэтапно. Сначала сервер выполняет полузакрытие, закрывая только сторону записи соединения чтения / записи. Затем сервер продолжает чтение из соединения до тех пор, пока он не получит соответствующее закрытие от клиента или пока сервер не будет достаточно уверен, что его собственный TCP-стек получил подтверждение клиента о пакете (-ах), содержащем последний ответ сервера. В заключение,сервер полностью закрывает соединение. Неизвестно, является ли проблема сброса исключительной для TCP или также может быть обнаружена в других протоколах транспортного соединения.</target>
        </trans-unit>
        <trans-unit id="e4269110c11e8492bcb4464320596b28df93a15f" translate="yes" xml:space="preserve">
          <source>The Content-Disposition response-header field has been proposed as a
   means for the origin server to suggest a default filename if the user
   requests that the content is saved to a file. This usage is derived
   from the definition of Content-Disposition in &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; [&lt;a href=&quot;#ref-35&quot;&gt;35&lt;/a&gt;].

        content-disposition = &quot;Content-Disposition&quot; &quot;:&quot;
                              disposition-type *( &quot;;&quot; disposition-parm )
        disposition-type = &quot;attachment&quot; | disp-extension-token
        disposition-parm = filename-parm | disp-extension-parm
        filename-parm = &quot;filename&quot; &quot;=&quot; quoted-string
        disp-extension-token = token
        disp-extension-parm = token &quot;=&quot; ( token | quoted-string )

   An example is

        Content-Disposition: attachment; filename=&quot;fname.ext&quot;

   The receiving user agent SHOULD NOT respect any directory path
   information present in the filename-parm parameter, which is the only
   parameter believed to apply to HTTP implementations at this time. The
   filename SHOULD be treated as a terminal component only.

   If this header is used in a response with the application/octet-
   stream content-type, the implied suggestion is that the user agent
   should not display the response, but directly enter a `save response
   as...' dialog.

   See &lt;a href=&quot;#section-15.5&quot;&gt;section 15.5&lt;/a&gt; for Content-Disposition security issues.</source>
          <target state="translated">Поле заголовка ответа Content-Disposition было предложено в качестве средства для исходного сервера, чтобы предложить имя файла по умолчанию, если пользователь запрашивает сохранение содержимого в файл. Это использование происходит из определения Content-Disposition в &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; [ &lt;a href=&quot;#ref-35&quot;&gt;35&lt;/a&gt;]. content-disposition = &quot;Content-Disposition&quot; &quot;:&quot; disposition-type * (&quot;;&quot; disposition-parm) disposition-type = &quot;attachment&quot; | disp-extension-token disposition-parm = filename-parm | disp-extension-parm filename-parm = &quot;filename&quot; &quot;=&quot; строка в кавычках disp-extension-token = token disp-extension-parm = token &quot;=&quot; (токен | строка в кавычках) Пример: Content-Disposition: attachment ; filename = &quot;fname.ext&quot; Принимающий пользовательский агент НЕ ДОЛЖЕН учитывать любую информацию о пути к каталогу, представленную в параметре filename-parm, который является единственным параметром, который, как считается, применим к реализациям HTTP в настоящее время. Имя файла СЛЕДУЕТ рассматривать только как терминальный компонент.Если этот заголовок используется в ответе с типом содержимого application / octet-stream, подразумевается, что пользовательский агент не должен отображать ответ, а непосредственно вводить диалоговое окно &amp;laquo;сохранить ответ как ...&amp;raquo;. Видеть&lt;a href=&quot;#section-15.5&quot;&gt;раздел 15.5&lt;/a&gt; по вопросам безопасности Content-Disposition.</target>
        </trans-unit>
        <trans-unit id="22177303e5c541de4c1a2fb13e69fc833be5a044" translate="yes" xml:space="preserve">
          <source>The Content-Encoding entity-header field is used as a modifier to the
   media-type. When present, its value indicates what additional content
   codings have been applied to the entity-body, and thus what decoding
   mechanisms must be applied in order to obtain the media-type
   referenced by the Content-Type header field. Content-Encoding is
   primarily used to allow a document to be compressed without losing
   the identity of its underlying media type.

       Content-Encoding  = &quot;Content-Encoding&quot; &quot;:&quot; 1#content-coding

   Content codings are defined in &lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;. An example of its use is

       Content-Encoding: gzip

   The content-coding is a characteristic of the entity identified by
   the Request-URI. Typically, the entity-body is stored with this
   encoding and is only decoded before rendering or analogous usage.
   However, a non-transparent proxy MAY modify the content-coding if the
   new coding is known to be acceptable to the recipient, unless the
   &quot;no-transform&quot; cache-control directive is present in the message.

   If the content-coding of an entity is not &quot;identity&quot;, then the
   response MUST include a Content-Encoding entity-header (&lt;a href=&quot;#section-14.11&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;) that lists the non-identity content-coding(s) used.

   If the content-coding of an entity in a request message is not
   acceptable to the origin server, the server SHOULD respond with a
   status code of 415 (Unsupported Media Type).

   If multiple encodings have been applied to an entity, the content
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.</source>
          <target state="translated">Поле заголовка объекта Content-Encoding используется в качестве модификатора медиа-типа. Когда он присутствует, его значение указывает, какие дополнительные кодировки контента были применены к телу объекта, и, следовательно, какие механизмы декодирования должны быть применены для получения медиа-типа, на который ссылается поле заголовка Content-Type. Content-Encoding в основном используется для сжатия документа без потери идентичности его базового типа носителя. Content-Encoding = &quot;Content-Encoding&quot; &quot;:&quot; 1 # content-coding Кодирование содержимого определено в &lt;a href=&quot;#section-3.5&quot;&gt;разделе 3.5.&lt;/a&gt;, Примером его использования является Content-Encoding: gzip. Content-coding - это характеристика объекта, идентифицированного Request-URI. Обычно тело объекта сохраняется с этой кодировкой и декодируется только перед визуализацией или аналогичным использованием. Однако непрозрачный прокси МОЖЕТ изменить кодирование содержимого, если известно, что новое кодирование приемлемо для получателя, если только в сообщении не присутствует директива управления кешем &amp;laquo;без преобразования&amp;raquo;. Если кодирование содержимого объекта не является &amp;laquo;идентичностью&amp;raquo;, то ответ ДОЛЖЕН включать заголовок объекта Content-Encoding ( &lt;a href=&quot;#section-14.11&quot;&gt;раздел &lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;), в котором перечислены используемые неидентификационные коды содержимого. Если кодирование содержимого объекта в сообщении запроса неприемлемо для исходного сервера, серверу СЛЕДУЕТ ответить кодом состояния 415 (неподдерживаемый тип носителя). Если к объекту было применено несколько кодировок, кодирование контента ДОЛЖНО быть перечислено в том порядке, в котором они были применены. Дополнительная информация о параметрах кодирования МОЖЕТ быть предоставлена ​​другими полями заголовка объекта, не определенными в данной спецификации.</target>
        </trans-unit>
        <trans-unit id="78e0f66604a34d6350aaee50ec1aed948b641dff" translate="yes" xml:space="preserve">
          <source>The Content-Language entity-header field describes the natural
   language(s) of the intended audience for the enclosed entity. Note
   that this might not be equivalent to all the languages used within
   the entity-body.

       Content-Language  = &quot;Content-Language&quot; &quot;:&quot; 1#language-tag 

   Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;. The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   entities according to the user's own preferred language. Thus, if the
   body content is intended only for a Danish-literate audience, the
   appropriate field is

       Content-Language: da

   If no Content-Language is specified, the default is that the content
   is intended for all language audiences. This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.

   Multiple languages MAY be listed for content that is intended for
   multiple audiences. For example, a rendition of the &quot;Treaty of
   Waitangi,&quot; presented simultaneously in the original Maori and English
   versions, would call for

       Content-Language: mi, en

   However, just because multiple languages are present within an entity
   does not mean that it is intended for multiple linguistic audiences.
   An example would be a beginner's language primer, such as &quot;A First
   Lesson in Latin,&quot; which is clearly intended to be used by an
   English-literate audience. In this case, the Content-Language would
   properly only include &quot;en&quot;.

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.</source>
          <target state="translated">Поле заголовка объекта Content-Language описывает естественный язык (языки) целевой аудитории для вложенного объекта. Обратите внимание, что это может быть не эквивалентно всем языкам, используемым в теле объекта. Content-Language = &quot;Content-Language&quot; &quot;:&quot; 1 # language-tag Языковые теги определены в &lt;a href=&quot;#section-3.10&quot;&gt;разделе 3.10.&lt;/a&gt;, Основная цель Content-Language - позволить пользователю идентифицировать и различать объекты в соответствии с его собственным предпочтительным языком. Таким образом, если основной контент предназначен только для аудитории, владеющей датским языком, соответствующее поле - Content-Language: da Если Content-Language не указан, по умолчанию контент предназначен для всех языковых аудиторий. Это может означать, что отправитель не считает его специфичным для какого-либо естественного языка или что отправитель не знает, для какого языка он предназначен. Для контента, предназначенного для разных аудиторий, МОГУТ быть указаны несколько языков. Например, исполнение &amp;laquo;Договора Вайтанги&amp;raquo;, представленное одновременно в оригинальной маори и английской версиях, будет требовать Content-Language: mi,Common crawl ru Однако наличие нескольких языков в объекте не означает, что он предназначен для нескольких языковых аудиторий. Примером может служить учебник по языку для начинающих, такой как &amp;laquo;Первый урок латыни&amp;raquo;, который явно предназначен для англоязычной аудитории. В этом случае Content-Language правильно будет включать только &amp;laquo;en&amp;raquo;. Content-Language МОЖЕТ применяться к любому типу мультимедиа - это не ограничивается текстовыми документами.Content-Language правильно будет включать только &quot;en&quot;. Content-Language МОЖЕТ применяться к любому типу мультимедиа - это не ограничивается текстовыми документами.Content-Language правильно будет включать только &quot;en&quot;. Content-Language МОЖЕТ применяться к любому типу мультимедиа - это не ограничивается текстовыми документами.</target>
        </trans-unit>
        <trans-unit id="a1abd3b0ff945fb9c54be7f36c23b898d0262eca" translate="yes" xml:space="preserve">
          <source>The Content-Length entity-header field indicates the size of the
   entity-body, in decimal number of OCTETs, sent to the recipient or,
   in the case of the HEAD method, the size of the entity-body that
   would have been sent had the request been a GET.

       Content-Length    = &quot;Content-Length&quot; &quot;:&quot; 1*DIGIT

   An example is

       Content-Length: 3495

   Applications SHOULD use this field to indicate the transfer-length of
   the message-body, unless this is prohibited by the rules in &lt;a href=&quot;#section-4.4&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. 

   Any Content-Length greater than or equal to zero is a valid value.
   &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; describes how to determine the length of a message-body
   if a Content-Length is not given.

   Note that the meaning of this field is significantly different from
   the corresponding definition in MIME, where it is an optional field
   used within the &quot;message/external-body&quot; content-type. In HTTP, it
   SHOULD be sent whenever the message's length can be determined prior
   to being transferred, unless this is prohibited by the rules in
   &lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;.</source>
          <target state="translated">Поле заголовка объекта Content-Length указывает размер тела объекта в десятичном числе OCTET, отправленных получателю, или, в случае метода HEAD, размер тела объекта, которое было бы отправлено, если бы запрос был GET. Content-Length = &quot;Content-Length&quot; &quot;:&quot; 1 * DIGIT. Примером Content-Length: 3495 СЛЕДУЕТ использовать это поле для указания длины передачи тела сообщения, если это не запрещено правилами в &lt;a href=&quot;#section-4.4&quot;&gt;разделе &lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;4.4.&lt;/a&gt; , Любое значение Content-Length, большее или равное нулю, является допустимым значением. &lt;a href=&quot;#section-4.4&quot;&gt;Раздел 4.4&lt;/a&gt;описывает, как определить длину тела сообщения, если Content-Length не задана. Обратите внимание, что значение этого поля значительно отличается от соответствующего определения в MIME, где это необязательное поле, используемое в типе содержимого &amp;laquo;message / external-body&amp;raquo;. В HTTP его СЛЕДУЕТ отправлять всякий раз, когда длина сообщения может быть определена до передачи, если это не запрещено правилами в &lt;a href=&quot;#section-4.4&quot;&gt;разделе 4.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5000316ac8e17d070fa4e93bb14ed2071d4d60f" translate="yes" xml:space="preserve">
          <source>The Content-Location entity-header field MAY be used to supply the
   resource location for the entity enclosed in the message when that
   entity is accessible from a location separate from the requested
   resource's URI. A server SHOULD provide a Content-Location for the
   variant corresponding to the response entity; especially in the case
   where a resource has multiple entities associated with it, and those
   entities actually have separate locations by which they might be
   individually accessed, the server SHOULD provide a Content-Location
   for the particular variant which is returned.

       Content-Location = &quot;Content-Location&quot; &quot;:&quot;
                         ( absoluteURI | relativeURI )

   The value of Content-Location also defines the base URI for the
   entity.

   The Content-Location value is not a replacement for the original
   requested URI; it is only a statement of the location of the resource
   corresponding to this particular entity at the time of the request.
   Future requests MAY specify the Content-Location URI as the request-
   URI if the desire is to identify the source of that particular
   entity.

   A cache cannot assume that an entity with a Content-Location
   different from the URI used to retrieve it can be used to respond to
   later requests on that Content-Location URI. However, the Content-
   Location can be used to differentiate between multiple entities
   retrieved from a single requested resource, as described in &lt;a href=&quot;#section-13.6&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;.

   If the Content-Location is a relative URI, the relative URI is
   interpreted relative to the Request-URI.

   The meaning of the Content-Location header in PUT or POST requests is
   undefined; servers are free to ignore it in those cases.</source>
          <target state="translated">Поле заголовка объекта Content-Location МОЖЕТ использоваться для предоставления местоположения ресурса для объекта, заключенного в сообщении, когда этот объект доступен из местоположения, отдельного от URI запрошенного ресурса. Серверу СЛЕДУЕТ предоставлять Content-Location для варианта, соответствующего объекту ответа; особенно в случае, когда с ресурсом связано несколько объектов, и эти объекты фактически имеют отдельные местоположения, по которым к ним можно получить индивидуальный доступ, серверу СЛЕДУЕТ предоставить Content-Location для конкретного варианта, который возвращается. Content-Location = &quot;Content-Location&quot; &quot;:&quot; (absoluteURI | relativeURI) Значение Content-Location также определяет базовый URI для объекта.Значение Content-Location не заменяет исходный запрошенный URI; это всего лишь указание на местонахождение ресурса, соответствующего данной конкретной сущности во время запроса. В будущих запросах МОЖЕТ указывать URI Content-Location в качестве URI запроса, если желательно идентифицировать источник этого конкретного объекта. Кэш не может предполагать, что объект с Content-Location, отличным от URI, используемого для его извлечения, может использоваться для ответа на последующие запросы по этому Content-Location URI. Однако Content-Location можно использовать для различения нескольких сущностей, полученных из одного запрошенного ресурса, как описано вэто всего лишь указание на местонахождение ресурса, соответствующего данной конкретной сущности во время запроса. В будущих запросах МОЖЕТ указывать URI Content-Location в качестве URI запроса, если желательно идентифицировать источник этого конкретного объекта. Кэш не может предполагать, что объект с Content-Location, отличным от URI, используемого для его извлечения, может использоваться для ответа на последующие запросы по этому Content-Location URI. Однако Content-Location можно использовать для различения нескольких сущностей, полученных из одного запрошенного ресурса, как описано вэто всего лишь указание на местонахождение ресурса, соответствующего данной конкретной сущности во время запроса. В будущих запросах МОЖЕТ указывать URI Content-Location в качестве URI запроса, если желательно идентифицировать источник этого конкретного объекта. Кэш не может предполагать, что объект с Content-Location, отличным от URI, используемого для его извлечения, может использоваться для ответа на последующие запросы по этому Content-Location URI. Однако Content-Location можно использовать для различения нескольких сущностей, полученных из одного запрошенного ресурса, как описано вКэш не может предполагать, что объект с Content-Location, отличным от URI, используемого для его извлечения, может использоваться для ответа на последующие запросы по этому Content-Location URI. Однако Content-Location можно использовать для различения нескольких сущностей, полученных из одного запрошенного ресурса, как описано вКэш не может предполагать, что объект с Content-Location, отличным от URI, используемого для его извлечения, может использоваться для ответа на последующие запросы по этому Content-Location URI. Однако Content-Location можно использовать для различения нескольких сущностей, полученных из одного запрошенного ресурса, как описано в&lt;a href=&quot;#section-13.6&quot;&gt;раздел &lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt; . Если Content-Location является относительным URI, относительный URI интерпретируется относительно Request-URI. Значение заголовка Content-Location в запросах PUT или POST не определено; серверы могут игнорировать это в таких случаях.</target>
        </trans-unit>
        <trans-unit id="6782e7664ef97f5aa5c3c489b023d738a78d068c" translate="yes" xml:space="preserve">
          <source>The Content-MD5 entity-header field, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [&lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt;], is
   an MD5 digest of the entity-body for the purpose of providing an
   end-to-end message integrity check (MIC) of the entity-body. (Note: a
   MIC is good for detecting accidental modification of the entity-body
   in transit, but is not proof against malicious attacks.)

        Content-MD5   = &quot;Content-MD5&quot; &quot;:&quot; md5-digest
        md5-digest   = &amp;lt;base64 of 128 bit MD5 digest as per &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;&amp;gt;

   The Content-MD5 header field MAY be generated by an origin server or
   client to function as an integrity check of the entity-body. Only
   origin servers or clients MAY generate the Content-MD5 header field;
   proxies and gateways MUST NOT generate it, as this would defeat its
   value as an end-to-end integrity check. Any recipient of the entity-
   body, including gateways and proxies, MAY check that the digest value
   in this header field matches that of the entity-body as received.

   The MD5 digest is computed based on the content of the entity-body,
   including any content-coding that has been applied, but not including
   any transfer-encoding applied to the message-body. If the message is
   received with a transfer-encoding, that encoding MUST be removed
   prior to checking the Content-MD5 value against the received entity.

   This has the result that the digest is computed on the octets of the
   entity-body exactly as, and in the order that, they would be sent if
   no transfer-encoding were being applied.

   HTTP extends &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; to permit the digest to be computed for MIME
   composite media-types (e.g., multipart/* and message/rfc822), but
   this does not change how the digest is computed as defined in the
   preceding paragraph.

   There are several consequences of this. The entity-body for composite
   types MAY contain many body-parts, each with its own MIME and HTTP
   headers (including Content-MD5, Content-Transfer-Encoding, and
   Content-Encoding headers). If a body-part has a Content-Transfer-
   Encoding or Content-Encoding header, it is assumed that the content
   of the body-part has had the encoding applied, and the body-part is
   included in the Content-MD5 digest as is -- i.e., after the
   application. The Transfer-Encoding header field is not allowed within
   body-parts.

   Conversion of all line breaks to CRLF MUST NOT be done before
   computing or checking the digest: the line break convention used in
   the text actually transmitted MUST be left unaltered when computing
   the digest. 

      Note: while the definition of Content-MD5 is exactly the same for
      HTTP as in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; for MIME entity-bodies, there are several ways
      in which the application of Content-MD5 to HTTP entity-bodies
      differs from its application to MIME entity-bodies. One is that
      HTTP, unlike MIME, does not use Content-Transfer-Encoding, and
      does use Transfer-Encoding and Content-Encoding. Another is that
      HTTP more frequently uses binary content types than MIME, so it is
      worth noting that, in such cases, the byte order used to compute
      the digest is the transmission byte order defined for the type.
      Lastly, HTTP allows transmission of text types with any of several
      line break conventions and not just the canonical form using CRLF.</source>
          <target state="translated">Поле заголовка объекта Content-MD5, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [ &lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt; ], является дайджестом MD5 тела объекта с целью обеспечения сквозной проверки целостности сообщения (MIC) тела объекта. (Примечание: MIC хорош для обнаружения случайной модификации тела объекта при передаче, но не защищает от злонамеренных атак.) Content-MD5 = &quot;Content-MD5&quot; &quot;:&quot; md5-digest md5-digest = &amp;lt;base64 of 128-битный дайджест MD5 согласно &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;&amp;gt; Поле заголовка Content-MD5 МОЖЕТ быть сгенерировано исходным сервером или клиентом для работы в качестве проверки целостности тела объекта. Только исходные серверы или клиенты МОГУТ генерировать поле заголовка Content-MD5; прокси-серверы и шлюзы НЕ ДОЛЖНЫ генерировать его, поскольку это нарушит его значение как сквозную проверку целостности. Любой получатель тела объекта, включая шлюзы и прокси, МОЖЕТ проверить, что значение дайджеста в этом поле заголовка совпадает с полученным телом объекта. Дайджест MD5 вычисляется на основе содержимого тела объекта, включая любое примененное кодирование содержимого, но не включая кодирование передачи, примененное к телу сообщения. Если сообщение получено с кодировкой передачи, это кодирование ДОЛЖНО быть удалено до проверки значения Content-MD5 на полученный объект.Это приводит к тому, что дайджест вычисляется по октетам тела объекта точно так же и в том порядке, в котором они будут отправлены, если бы не применялось кодирование передачи. HTTP расширяет&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;чтобы позволить вычислять дайджест для составных медиа-типов MIME (например, multipart / * и message / rfc822), но это не меняет способ вычисления дайджеста, как определено в предыдущем абзаце. У этого есть несколько последствий. Тело объекта для составных типов МОЖЕТ содержать множество частей тела, каждая со своими собственными заголовками MIME и HTTP (включая заголовки Content-MD5, Content-Transfer-Encoding и Content-Encoding). Если у части тела есть заголовок Content-Transfer-Encoding или Content-Encoding, предполагается, что к содержимому части тела была применена кодировка, и эта часть тела включена в дайджест Content-MD5 как есть - т.е. после заявки. Поле заголовка Transfer-Encoding не допускается внутри частей тела.Преобразование всех разрывов строк в CRLF НЕ ДОЛЖНО выполняться перед вычислением или проверкой дайджеста: соглашение о переносе строк, используемое в фактически переданном тексте, ДОЛЖНО быть оставлено неизменным при вычислении дайджеста. Примечание: хотя определение Content-MD5 для HTTP точно такое же, как в&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; для тел-сущностей MIME, существует несколько способов, которыми применение Content-MD5 к телам сущностей HTTP отличается от его применения к телам сущностей MIME. Во-первых, HTTP, в отличие от MIME, не использует Content-Transfer-Encoding, а использует Transfer-Encoding и Content-Encoding. Другой заключается в том, что HTTP чаще использует двоичные типы содержимого, чем MIME, поэтому стоит отметить, что в таких случаях порядок байтов, используемый для вычисления дайджеста, является порядком байтов передачи, определенным для типа. Наконец, HTTP позволяет передавать текстовые типы с любым из нескольких соглашений о переносе строки, а не только в канонической форме с использованием CRLF.</target>
        </trans-unit>
        <trans-unit id="ff07970e216340fa2fb8373a79c1c42c82bcf1ba" translate="yes" xml:space="preserve">
          <source>The Content-Range entity-header is sent with a partial entity-body to
   specify where in the full entity-body the partial body should be
   applied. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

       Content-Range = &quot;Content-Range&quot; &quot;:&quot; content-range-spec

       content-range-spec      = byte-content-range-spec
       byte-content-range-spec = bytes-unit SP
                                 byte-range-resp-spec &quot;/&quot;
                                 ( instance-length | &quot;*&quot; )

       byte-range-resp-spec = (first-byte-pos &quot;-&quot; last-byte-pos)
                                      | &quot;*&quot;
       instance-length           = 1*DIGIT

   The header SHOULD indicate the total length of the full entity-body,
   unless this length is unknown or difficult to determine. The asterisk
   &quot;*&quot; character means that the instance-length is unknown at the time
   when the response was generated.

   Unlike byte-ranges-specifier values (see &lt;a href=&quot;#section-14.35.1&quot;&gt;section 14.35.1&lt;/a&gt;), a byte-
   range-resp-spec MUST only specify one range, and MUST contain
   absolute byte positions for both the first and last byte of the
   range.

   A byte-content-range-spec with a byte-range-resp-spec whose last-
   byte-pos value is less than its first-byte-pos value, or whose
   instance-length value is less than or equal to its last-byte-pos
   value, is invalid. The recipient of an invalid byte-content-range-
   spec MUST ignore it and any content transferred along with it.

   A server sending a response with status code 416 (Requested range not
   satisfiable) SHOULD include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;. The instance-length specifies the current length of 

   the selected resource. A response with status code 206 (Partial
   Content) MUST NOT include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;.

   Examples of byte-content-range-spec values, assuming that the entity
   contains a total of 1234 bytes:

      . The first 500 bytes:
       bytes 0-499/1234

      . The second 500 bytes:
       bytes 500-999/1234

      . All except for the first 500 bytes:
       bytes 500-1233/1234

      . The last 500 bytes:
       bytes 734-1233/1234

   When an HTTP message includes the content of a single range (for
   example, a response to a request for a single range, or to a request
   for a set of ranges that overlap without any holes), this content is
   transmitted with a Content-Range header, and a Content-Length header
   showing the number of bytes actually transferred. For example,

       HTTP/1.1 206 Partial content
       Date: Wed, 15 Nov 1995 06:25:24 GMT
       Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
       Content-Range: bytes 21010-47021/47022
       Content-Length: 26012
       Content-Type: image/gif

   When an HTTP message includes the content of multiple ranges (for
   example, a response to a request for multiple non-overlapping
   ranges), these are transmitted as a multipart message. The multipart
   media type used for this purpose is &quot;multipart/byteranges&quot; as defined
   in appendix 19.2. See appendix 19.6.3 for a compatibility issue.

   A response to a request for a single range MUST NOT be sent using the
   multipart/byteranges media type.  A response to a request for
   multiple ranges, whose result is a single range, MAY be sent as a
   multipart/byteranges media type with one part. A client that cannot
   decode a multipart/byteranges message MUST NOT ask for multiple
   byte-ranges in a single request.

   When a client requests multiple byte-ranges in one request, the
   server SHOULD return them in the order that they appeared in the
   request. 

   If the server ignores a byte-range-spec because it is syntactically
   invalid, the server SHOULD treat the request as if the invalid Range
   header field did not exist. (Normally, this means return a 200
   response containing the full entity).

   If the server receives a request (other than one including an If-
   Range request-header field) with an unsatisfiable Range request-
   header field (that is, all of whose byte-range-spec values have a
   first-byte-pos value greater than the current length of the selected
   resource), it SHOULD return a response code of 416 (Requested range
   not satisfiable) (&lt;a href=&quot;#section-10.4.17&quot;&gt;section 10.4.17&lt;/a&gt;).

      Note: clients cannot depend on servers to send a 416 (Requested
      range not satisfiable) response instead of a 200 (OK) response for
      an unsatisfiable Range request-header, since not all servers
      implement this request-header.</source>
          <target state="translated">Заголовок объекта Content-Range отправляется с частичным телом объекта, чтобы указать, где в полном теле объекта следует применить частичное тело. Единицы измерения определены в &lt;a href=&quot;#section-3.12&quot;&gt;разделе 3.12.&lt;/a&gt;, Content-Range = &quot;Content-Range&quot; &quot;:&quot; content-range-spec content-range-spec = byte-content-range-spec byte-content-range-spec = bytes-unit SP byte-range-resp-spec &quot; / &quot;(длина экземпляра |&quot; * &quot;) byte-range-resp-spec = (first-byte-pos&quot; - &quot;last-byte-pos) | &amp;laquo;*&amp;raquo; instance-length = 1 * DIGIT. Заголовок ДОЛЖЕН указывать общую длину всего тела объекта, если только эта длина неизвестна или ее трудно определить. Символ звездочки &amp;laquo;*&amp;raquo; означает, что длина экземпляра неизвестна на момент генерации ответа. В отличие от значений спецификатора диапазонов байтов (см. &lt;a href=&quot;#section-14.35.1&quot;&gt;Раздел 14.35.1&lt;/a&gt;), byte-range-resp-spec ДОЛЖЕН указывать только один диапазон и ДОЛЖЕН содержать абсолютные позиции байтов как для первого, так и для последнего байта диапазона. Byte-content-range-spec с byte-range-resp-spec, значение last-byte-pos меньше, чем его значение first-byte-pos, или чье значение длины экземпляра меньше или равно его last- значение byte-pos недействительно. Получатель недопустимой спецификации byte-content-range- ДОЛЖЕН игнорировать ее и любой контент, передаваемый вместе с ней. Серверу, отправляющему ответ с кодом состояния 416 (запрошенный диапазон не удовлетворяется), СЛЕДУЕТ включать поле Content-Range со спецификацией байтового диапазона или &quot;*&quot;. Длина экземпляра указывает текущую длину выбранного ресурса.Ответ с кодом состояния 206 (частичное содержимое) НЕ ДОЛЖЕН включать поле Content-Range с байтовым диапазоном или спецификацией &quot;*&quot;. Примеры значений byte-content-range-spec при условии, что объект содержит всего 1234 байта:. Первые 500 байт: байты 0-499 / 1234. Вторые 500 байт: байты 500-999 / 1234. Все, кроме первых 500 байтов: байты 500&amp;ndash;1233 / 1234. Последние 500 байтов: байты 734-1233 / 1234 Когда сообщение HTTP включает в себя содержимое одного диапазона (например, ответ на запрос для одного диапазона или на запрос набора диапазонов, которые перекрываются без каких-либо дыр) ), это содержимое передается с заголовком Content-Range и заголовком Content-Length, показывающим количество фактически переданных байтов. Например, HTTP / 1.1206 Частичное содержимое Дата: среда, 15 ноября 1995 г., 06:25:24 GMT Последнее изменение: среда, 15 ноября 1995 г., 04:58:08 GMT Content-Range: байты 21010-47021 / 47022 Content-Length: 26012 Content-Type : image / gif Когда HTTP-сообщение включает в себя содержимое нескольких диапазонов (например, ответ на запрос нескольких неперекрывающихся диапазонов), они передаются как составное сообщение. Тип мультимедиа multipart, используемый для этой цели, - multipart / byteranges, как определено в приложении 19.2. См. Приложение 19.6.3 по вопросу совместимости. Ответ на запрос для одного диапазона НЕ ДОЛЖЕН отправляться с использованием типа носителя multipart / byteranges. Ответ на запрос для нескольких диапазонов, результатом которого является один диапазон, МОЖЕТ быть отправлен как тип мультимедиа multipart / byteranges с одной частью.Клиент, который не может декодировать сообщение multipart / byteranges, НЕ ДОЛЖЕН запрашивать несколько диапазонов байтов в одном запросе. Когда клиент запрашивает несколько диапазонов байтов в одном запросе, серверу СЛЕДУЕТ возвращать их в том порядке, в котором они указаны в запросе. Если сервер игнорирует спецификацию байтового диапазона, потому что она синтаксически недопустима, сервер ДОЛЖЕН обрабатывать запрос так, как если бы недопустимое поле заголовка диапазона не существовало. (Обычно это означает возврат 200 ответа, содержащего полную сущность). Если сервер получает запрос (кроме того, который включает поле заголовка запроса If-Range) с неудовлетворительным полем заголовка запроса Range (то есть, все значения которого byte-range-spec имеют значение first-byte-pos больше чем текущая длина выбранного ресурса),он ДОЛЖЕН возвращать код ответа 416 (Запрошенный диапазон неудовлетворителен) (&lt;a href=&quot;#section-10.4.17&quot;&gt;раздел 10.4.17&lt;/a&gt; ). Примечание: клиенты не могут зависеть от серверов для отправки ответа 416 (Запрошенный диапазон не удовлетворяется) вместо ответа 200 (ОК) для неудовлетворительного заголовка запроса Range, поскольку не все серверы реализуют этот заголовок запроса.</target>
        </trans-unit>
        <trans-unit id="e283ef83ad0c98c2f0776bde603c318284d66f81" translate="yes" xml:space="preserve">
          <source>The Content-Type entity-header field indicates the media type of the
   entity-body sent to the recipient or, in the case of the HEAD method,
   the media type that would have been sent had the request been a GET.

       Content-Type   = &quot;Content-Type&quot; &quot;:&quot; media-type

   Media types are defined in &lt;a href=&quot;#section-3.7&quot;&gt;section 3.7&lt;/a&gt;. An example of the field is

       Content-Type: text/html; charset=ISO-8859-4

   Further discussion of methods for identifying the media type of an
   entity is provided in &lt;a href=&quot;#section-7.2.1&quot;&gt;section 7.2.1&lt;/a&gt;.</source>
          <target state="translated">Поле заголовка объекта Content-Type указывает тип носителя тела объекта, отправленного получателю, или, в случае метода HEAD, тип носителя, который был бы отправлен, если бы запрос был GET. Content-Type = &quot;Content-Type&quot; &quot;:&quot; media-type Типы мультимедиа определены в &lt;a href=&quot;#section-3.7&quot;&gt;разделе 3.7&lt;/a&gt; . Пример поля - Content-Type: text / html; charset = ISO-8859-4. Дальнейшее обсуждение методов идентификации типа носителя объекта приведено в &lt;a href=&quot;#section-7.2.1&quot;&gt;разделе 7.2.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="037f56850e2d9507141cb0bfad334028f9b60f2f" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing standard works by adding new &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; that allow servers to describe the set of origins that are permitted to read that information using a web browser. Additionally, for HTTP request methods that can cause side-effects on server's data (in particular, for HTTP methods other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or for &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; usage with certain &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &quot;preflight&quot; the request, soliciting supported methods from the server with an HTTP &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &quot;approval&quot; from the server, sending the actual request with the actual HTTP request method. Servers can also notify clients whether &quot;credentials&quot; (including &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and HTTP Authentication data) should be sent with requests.</source>
          <target state="translated">Стандарт совместного использования ресурсов между источниками работает путем добавления новых &lt;a href=&quot;headers&quot;&gt;заголовков HTTP,&lt;/a&gt; которые позволяют серверам описывать набор источников, которым разрешено читать эту информацию с помощью веб-браузера. Кроме того, для методов HTTP-запроса, которые могут вызывать побочные эффекты для данных сервера (в частности, для HTTP-методов, отличных от &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , или для использования &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; с определенными &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;типами MIME&lt;/a&gt; ), спецификация требует, чтобы браузеры выполняли предварительную проверку запроса, запрашивая поддерживаемые методы. с сервера с помощью метода запроса HTTP &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; , а затем, после &amp;laquo;утверждения&amp;raquo; с сервера, отправка фактического запроса с фактическим методом запроса HTTP. Серверы также могут уведомлять клиентов о наличии &amp;laquo;учетных данных&amp;raquo;(включая &lt;a href=&quot;cookies&quot;&gt;файлы cookie&lt;/a&gt;и данные HTTP-аутентификации) должны отправляться с запросами.</target>
        </trans-unit>
        <trans-unit id="858dfd56015c8a42c014f2e88a9adef69bbf8f6d" translate="yes" xml:space="preserve">
          <source>The DELETE method on a collection MUST act as if a &quot;Depth: infinity&quot;
   header was used on it.  A client MUST NOT submit a Depth header with
   a DELETE on a collection with any value but infinity.

   DELETE instructs that the collection specified in the Request-URI and
   all resources identified by its internal member URLs are to be
   deleted.

   If any resource identified by a member URL cannot be deleted, then
   all of the member's ancestors MUST NOT be deleted, so as to maintain
   URL namespace consistency.

   Any headers included with DELETE MUST be applied in processing every
   resource to be deleted.

   When the DELETE method has completed processing, it MUST result in a
   consistent URL namespace.

   If an error occurs deleting a member resource (a resource other than
   the resource identified in the Request-URI), then the response can be
   a 207 (Multi-Status).  Multi-Status is used here to indicate which
   internal resources could NOT be deleted, including an error code,
   which should help the client understand which resources caused the
   failure.  For example, the Multi-Status body could include a response
   with status 423 (Locked) if an internal resource was locked.

   The server MAY return a 4xx status response, rather than a 207, if
   the request failed completely.

   424 (Failed Dependency) status codes SHOULD NOT be in the 207 (Multi-
   Status) response for DELETE.  They can be safely left out because the
   client will know that the ancestors of a resource could not be
   deleted when the client receives an error for the ancestor's progeny.
   Additionally, 204 (No Content) errors SHOULD NOT be returned in the
   207 (Multi-Status).  The reason for this prohibition is that 204 (No
   Content) is the default success code.</source>
          <target state="translated">Метод DELETE на коллекции ДОЛЖЕН действовать так,как будто на ней был использован заголовок &quot;Глубина:бесконечность&quot;.Клиент НЕ ДОЛЖЕН подавать заголовок Depth с DELETE на коллекции с любым значением,но бесконечностью.DELETE инструктирует,что коллекция,указанная в Request-URI,и все ресурсы,идентифицированные по URL ее внутренних членов,должны быть удалены.Если какой-либо ресурс,идентифицируемый по URL-адресу пользователя,не может быть удален,то все предки пользователя НЕ ДОЛЖНЫ быть удалены,чтобы сохранить согласованность пространства имен URL-адресов.Любые заголовки,включенные в DELETE ДОЛЖНЫ применяться при обработке каждого удаляемого ресурса.Когда метод DELETE завершает обработку,он ДОЛЖЕН приводить к согласованному пространству имён URL.Если возникает ошибка удаления члена ресурса (ресурса,отличного от ресурса,указанного в Request-URI),то ответом может быть 207 (Multi-Status).Здесь Multi-Status используется для указания,какие внутренние ресурсы НЕ могут быть удалены,включая код ошибки,который должен помочь клиенту понять,какие ресурсы вызвали сбой.Например,тело Multi-Status может содержать ответ со статусом 423 (Locked),если внутренний ресурс заблокирован.Сервер MAY возвращает ответ со статусом 4xx,а не 207,если запрос был полностью отклонен.Коды статуса 424 (Failed Dependency)НЕ ДОЛЖНЫ быть в ответе 207 (Multi-Status)для УДАЛЕНИЯ.Они могут быть безопасно пропущены,потому что клиент будет знать,что предки ресурса не могли быть удалены,когда клиент получит ошибку для потомка предка.Кроме того,204 ошибки (No Content)НЕ ДОЛЖНЫ возвращаться в 207 (Multi-Status).Причина такого запрета заключается в том,что 204 (No Content)является кодом успеха по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e71c2610a983fa8562e2bcbd279e311806bf6084" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server delete the resource
   identified by the Request-URI. This method MAY be overridden by human
   intervention (or other means) on the origin server. The client cannot
   be guaranteed that the operation has been carried out, even if the
   status code returned from the origin server indicates that the action
   has been completed successfully. However, the server SHOULD NOT
   indicate success unless, at the time the response is given, it
   intends to delete the resource or move it to an inaccessible
   location.

   A successful response SHOULD be 200 (OK) if the response includes an
   entity describing the status, 202 (Accepted) if the action has not
   yet been enacted, or 204 (No Content) if the action has been enacted
   but the response does not include an entity.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.</source>
          <target state="translated">Метод DELETE требует,чтобы исходный сервер удалил ресурс,идентифицируемый Request-URI.Этот метод МОЖЕТ быть переопределен человеческим вмешательством (или другими способами)на исходном сервере.Клиент не может быть уверен в том,что операция была выполнена,даже если код статуса,возвращенный с исходного сервера,указывает на то,что операция была выполнена успешно.Однако,сервер НЕ ДОЛЖЕН указывать на успешное выполнение операции,если только в момент получения ответа он не намеревается удалить ресурс или переместить его в недоступное место.Успешный ответ ДОЛЖЕН быть 200 (OK),если ответ включает сущность,описывающую статус,202 (Принято),если действие еще не было предпринято,или 204 (Без содержания),если действие было предпринято,но ответ не включает сущность.Если запрос проходит через кэш и Request-URI идентифицирует одну или более сущностей,занесенных в кэш в данный момент,то эти записи ДОЛЖНЫ быть обработаны как черствые.Ответы на этот метод не кэшируются.</target>
        </trans-unit>
        <trans-unit id="c974be9fc532fcdd84db91fdeb0ba6b9b0cfa15b" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server remove the
   association between the target resource and its current
   functionality.  In effect, this method is similar to the rm command
   in UNIX: it expresses a deletion operation on the URI mapping of the
   origin server rather than an expectation that the previously
   associated information be deleted.

   If the target resource has one or more current representations, they
   might or might not be destroyed by the origin server, and the
   associated storage might or might not be reclaimed, depending
   entirely on the nature of the resource and its implementation by the
   origin server (which are beyond the scope of this specification).
   Likewise, other implementation aspects of a resource might need to be
   deactivated or archived as a result of a DELETE, such as database or
   gateway connections.  In general, it is assumed that the origin
   server will only allow DELETE on resources for which it has a
   prescribed mechanism for accomplishing the deletion.

   Relatively few resources allow the DELETE method -- its primary use
   is for remote authoring environments, where the user has some
   direction regarding its effect.  For example, a resource that was
   previously created using a PUT request, or identified via the
   Location header field after a 201 (Created) response to a POST
   request, might allow a corresponding DELETE request to undo those
   actions.  Similarly, custom user agent implementations that implement 

   an authoring function, such as revision control clients using HTTP
   for remote operations, might use DELETE based on an assumption that
   the server's URI space has been crafted to correspond to a version
   repository.

   If a DELETE method is successfully applied, the origin server SHOULD
   send a 202 (Accepted) status code if the action will likely succeed
   but has not yet been enacted, a 204 (No Content) status code if the
   action has been enacted and no further information is to be supplied,
   or a 200 (OK) status code if the action has been enacted and the
   response message includes a representation describing the status.

   A payload within a DELETE request message has no defined semantics;
   sending a payload body on a DELETE request might cause some existing
   implementations to reject the request.

   Responses to the DELETE method are not cacheable.  If a DELETE
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Метод DELETE запрашивает у исходного сервера удаление связи между целевым ресурсом и его текущими функциями. По сути, этот метод похож на команду rm в UNIX: он выражает операцию удаления в сопоставлении URI исходного сервера, а не ожидание удаления ранее связанной информации. Если целевой ресурс имеет одно или несколько текущих представлений, они могут быть или не быть уничтожены исходным сервером, а связанное хранилище может быть или не может быть восстановлено, полностью в зависимости от природы ресурса и его реализации исходным сервером ( которые выходят за рамки данной спецификации). Аналогичным образом, другие аспекты реализации ресурса могут потребоваться деактивировать или заархивировать в результате DELETE,например, соединения с базой данных или шлюзами. В общем, предполагается, что исходный сервер разрешит УДАЛЕНИЕ только для ресурсов, для которых у него есть предписанный механизм для выполнения удаления. Относительно небольшое количество ресурсов позволяет использовать метод DELETE - его основное использование - для сред удаленной разработки, где у пользователя есть определенные указания относительно его эффекта. Например, ресурс, который был ранее создан с помощью запроса PUT или идентифицирован с помощью поля заголовка Location после ответа 201 (Created) на запрос POST, может позволить соответствующему запросу DELETE отменить эти действия. Точно так же реализации настраиваемых пользовательских агентов, которые реализуют функцию создания, например клиенты управления версиями, использующие HTTP для удаленных операций, могут использовать DELETE на основе предположения, что сервер '■ Пространство URI создано для соответствия репозиторию версий. Если метод DELETE успешно применен, исходный сервер ДОЛЖЕН отправить код состояния 202 (Принято), если действие, скорее всего, будет успешным, но еще не выполнено, код состояния 204 (Нет содержимого), если действие было выполнено, и больше не будет должна быть предоставлена ​​информация или код состояния 200 (ОК), если действие было выполнено и ответное сообщение включает представление, описывающее состояние. Полезная нагрузка в сообщении запроса DELETE не имеет определенной семантики; отправка тела полезной нагрузки в запросе DELETE может привести к тому, что некоторые существующие реализации отклонят запрос. Ответы на метод DELETE не кэшируются. Если запрос DELETE проходит через кеш, в котором есть один или несколько сохраненных ответов для действующего URI запроса,эти сохраненные ответы будут признаны недействительными (см.&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Раздел 4.4 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dd290a0d44bd1aedc43b87181e19c3e8fd871af9" translate="yes" xml:space="preserve">
          <source>The Date general-header field represents the date and time at which
   the message was originated, having the same semantics as orig-date in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;. The field value is an HTTP-date, as described in &lt;a href=&quot;#section-3.3.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;; it MUST be sent in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]-date format.

       Date  = &quot;Date&quot; &quot;:&quot; HTTP-date

   An example is

       Date: Tue, 15 Nov 1994 08:12:31 GMT

   Origin servers MUST include a Date header field in all responses,
   except in these cases: 

      1. If the response status code is 100 (Continue) or 101 (Switching
         Protocols), the response MAY include a Date header field, at
         the server's option.

      2. If the response status code conveys a server error, e.g. 500
         (Internal Server Error) or 503 (Service Unavailable), and it is
         inconvenient or impossible to generate a valid Date.

      3. If the server does not have a clock that can provide a
         reasonable approximation of the current time, its responses
         MUST NOT include a Date header field. In this case, the rules
         in &lt;a href=&quot;#section-14.18.1&quot;&gt;section 14.18.1&lt;/a&gt; MUST be followed.

   A received message that does not have a Date header field MUST be
   assigned one by the recipient if the message will be cached by that
   recipient or gatewayed via a protocol which requires a Date. An HTTP
   implementation without a clock MUST NOT cache responses without
   revalidating them on every use. An HTTP cache, especially a shared
   cache, SHOULD use a mechanism, such as NTP [&lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;], to synchronize its
   clock with a reliable external standard.

   Clients SHOULD only send a Date header field in messages that include
   an entity-body, as in the case of the PUT and POST requests, and even
   then it is optional. A client without a clock MUST NOT send a Date
   header field in a request.

   The HTTP-date sent in a Date header SHOULD NOT represent a date and
   time subsequent to the generation of the message. It SHOULD represent
   the best available approximation of the date and time of message
   generation, unless the implementation has no means of generating a
   reasonably accurate date and time. In theory, the date ought to
   represent the moment just before the entity is generated. In
   practice, the date can be generated at any time during the message
   origination without affecting its semantic value.</source>
          <target state="translated">Поле общего заголовка Date представляет дату и время, когда было отправлено сообщение, и имеет ту же семантику, что и исходная дата в &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; . Значение поля - это HTTP-дата, как описано в &lt;a href=&quot;#section-3.3.1&quot;&gt;разделе &lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt; ; он ДОЛЖЕН быть отправлен в &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]-Формат даты. Date = &quot;Date&quot; &quot;:&quot; HTTP-date Пример: Date: Tue, 15 Nov 1994 08:12:31 GMT Серверы происхождения ДОЛЖНЫ включать поле заголовка Date во все ответы, за исключением следующих случаев: 1. Если статус ответа код - 100 (продолжить) или 101 (протоколы переключения), ответ МОЖЕТ включать поле заголовка даты по выбору сервера. 2. Если код состояния ответа передает ошибку сервера, например 500 (внутренняя ошибка сервера) или 503 (служба недоступна), и создать действительную дату неудобно или невозможно. 3. Если на сервере нет часов, которые могут обеспечить разумное приближение текущего времени, его ответы НЕ ДОЛЖНЫ включать поле заголовка Date. В таком случае,правила в &lt;a href=&quot;#section-14.18.1&quot;&gt;разделе 14.18.1&lt;/a&gt;НЕОБХОДИМО соблюдать. Полученное сообщение, которое не имеет поля заголовка Date, ДОЛЖНО быть назначено получателем, если сообщение будет кэшировано этим получателем или шлюзом через протокол, который требует Date. Реализация HTTP без часов НЕ ДОЛЖНА кэшировать ответы без их повторной проверки при каждом использовании. Кэш HTTP, особенно общий кеш, ДОЛЖЕН использовать такой механизм, как NTP [ &lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;], чтобы синхронизировать часы с надежным внешним стандартом. Клиенты ДОЛЖНЫ отправлять поле заголовка Date только в сообщениях, которые включают тело объекта, как в случае запросов PUT и POST, и даже в этом случае это необязательно. Клиент без часов НЕ ДОЛЖЕН отправлять поле заголовка Date в запросе. HTTP-дата, отправленная в заголовке Date, НЕ ДОЛЖНА представлять дату и время после генерации сообщения. Он ДОЛЖЕН представлять наилучшее возможное приближение даты и времени генерации сообщения, если только реализация не имеет средств для генерации достаточно точной даты и времени. Теоретически дата должна представлять момент непосредственно перед созданием объекта. На практике дата может быть сгенерирована в любой момент во время создания сообщения, не влияя на ее семантическое значение.</target>
        </trans-unit>
        <trans-unit id="6903ec22652fb8e7c29947078193d2ba673e0d45" translate="yes" xml:space="preserve">
          <source>The Depth header may be used with the LOCK method.  Values other than
   0 or infinity MUST NOT be used with the Depth header on a LOCK
   method.  All resources that support the LOCK method MUST support the
   Depth header.

   A Depth header of value 0 means to just lock the resource specified
   by the Request-URI.

   If the Depth header is set to infinity, then the resource specified
   in the Request-URI along with all its members, all the way down the
   hierarchy, are to be locked.  A successful result MUST return a
   single lock token.  Similarly, if an UNLOCK is successfully executed
   on this token, all associated resources are unlocked.  Hence, partial
   success is not an option for LOCK or UNLOCK.  Either the entire
   hierarchy is locked or no resources are locked.

   If the lock cannot be granted to all resources, the server MUST
   return a Multi-Status response with a 'response' element for at least
   one resource that prevented the lock from being granted, along with a
   suitable status code for that failure (e.g., 403 (Forbidden) or 423
   (Locked)).  Additionally, if the resource causing the failure was not
   the resource requested, then the server SHOULD include a 'response'
   element for the Request-URI as well, with a 'status' element
   containing 424 Failed Dependency.

   If no Depth header is submitted on a LOCK request, then the request
   MUST act as if a &quot;Depth:infinity&quot; had been submitted.</source>
          <target state="translated">Заголовок Глубина может быть использован с методом БЛОКИРОВКИ.Значения,отличные от 0 или бесконечности,НЕ ДОЛЖНЫ использоваться с заголовком Depth в методе LOCK.Все ресурсы,поддерживающие метод БЛОКИРОВКИ,ДОЛЖНЫ поддерживать заголовок Depth.Заголовок Depth,имеющий значение 0,означает просто заблокировать ресурс,указанный в Request-URI.Если заголовок Depth установлен на бесконечность,то ресурс,указанный в Request-URI вместе со всеми его членами,вплоть до иерархии,должен быть заблокирован.Успешный результат ДОЛЖЕН возвращать один маркер блокировки.Аналогично,в случае успешного выполнения UNLOCK на этой маркере,все связанные с ней ресурсы будут разблокированы.Следовательно,частичный успех не является вариантом для БЛОКИРОВКИ или UNLOCK.Либо блокируется вся иерархия,либо не блокируются никакие ресурсы.Если блокировка не может быть предоставлена всем ресурсам,сервер ДОЛЖЕН вернуть Multi-Status ответ с элементом 'response' по крайней мере для одного ресурса,который не смог предоставить блокировку,вместе с подходящим кодом статуса для этого отказа (например,403 (Запрещенный)или 423 (Заблокированный)).Дополнительно,если ресурс,вызвавший сбой,не был запрошенным ресурсом,то сервер ДОЛЖЕН включить элемент 'response' для Request-URI,с элементом 'status',содержащим 424 Failed Dependency (Неудачная зависимость).Если на запрос БЛОКИРОВКИ не отправлен заголовок Depth,то запрос ДОЛЖЕН действовать так,как если бы был отправлен элемент &quot;Depth:бесконечность&quot;.</target>
        </trans-unit>
        <trans-unit id="35342d84dcd43dba8096f5d5b39874e99cb4604b" translate="yes" xml:space="preserve">
          <source>The Destination request header specifies the URI that identifies a
   destination resource for methods such as COPY and MOVE, which take
   two URIs as parameters.

      Destination = &quot;Destination&quot; &quot;:&quot; Simple-ref


   If the Destination value is an absolute-URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;Section&amp;nbsp;4.3 of
   [RFC3986]&lt;/a&gt;), it may name a different server (or different port or
   scheme).  If the source server cannot attempt a copy to the remote
   server, it MUST fail the request.  Note that copying and moving
   resources to remote servers is not fully defined in this
   specification (e.g., specific error conditions). 

   If the Destination value is too long or otherwise unacceptable, the
   server SHOULD return 400 (Bad Request), ideally with helpful
   information in an error body.</source>
          <target state="translated">Заголовок запроса Destination определяет URI, который идентифицирует ресурс назначения для таких методов, как COPY и MOVE, которые принимают два URI в качестве параметров. Destination = &quot;Destination&quot; &quot;:&quot; Simple-ref. Если значение Destination является абсолютным URI ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;раздел 4.3 [RFC3986]&lt;/a&gt; ), оно может называть другой сервер (или другой порт или схему). Если исходный сервер не может попытаться скопировать на удаленный сервер, он ДОЛЖЕН не выполнить запрос. Обратите внимание, что копирование и перемещение ресурсов на удаленные серверы не полностью определены в этой спецификации (например, конкретные условия ошибки). Если значение Destination слишком длинное или неприемлемо по иным причинам, сервер ДОЛЖЕН вернуть 400 (неверный запрос), в идеале с полезной информацией в теле ошибки.</target>
        </trans-unit>
        <trans-unit id="5ec562967c3ab4eb672c7b7fd0765b0c9a09d6b8" translate="yes" xml:space="preserve">
          <source>The ETag response-header field provides the current value of the
   entity tag for the requested variant. The headers used with entity
   tags are described in sections &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;. The entity tag
   MAY be used for comparison with other entities from the same resource
   (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;).

      ETag = &quot;ETag&quot; &quot;:&quot; entity-tag

   Examples:

      ETag: &quot;xyzzy&quot;
      ETag: W/&quot;xyzzy&quot;
      ETag: &quot;&quot;</source>
          <target state="translated">Поле заголовка ответа ETag содержит текущее значение тега объекта для запрошенного варианта. Заголовки, используемые с тегами объектов, описаны в разделах &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; , &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; и &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt; . Тег объекта МОЖЕТ использоваться для сравнения с другими объектами из того же ресурса (см. &lt;a href=&quot;#section-13.3.3&quot;&gt;Раздел 13.3.3&lt;/a&gt; ). ETag = &quot;ETag&quot; &quot;:&quot; entity-tag Примеры: ETag: &quot;xyzzy&quot; ETag: W / &quot;xyzzy&quot; ETag: &quot;&quot;</target>
        </trans-unit>
        <trans-unit id="4712a2d0dd6a27be4029656072d6f063c6808073" translate="yes" xml:space="preserve">
          <source>The ETag response-header field value, an entity tag, provides for an
   &quot;opaque&quot; cache validator. This might allow more reliable validation
   in situations where it is inconvenient to store modification dates,
   where the one-second resolution of HTTP date values is not
   sufficient, or where the origin server wishes to avoid certain
   paradoxes that might arise from the use of modification dates.

   Entity Tags are described in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The headers used with
   entity tags are described in sections &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;, &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;.</source>
          <target state="translated">Значение поля заголовка ответа ETag, тег объекта, обеспечивает &amp;laquo;непрозрачный&amp;raquo; валидатор кеша. Это может обеспечить более надежную проверку в ситуациях, когда неудобно хранить даты модификации, когда односекундное разрешение значений даты HTTP недостаточно или когда исходный сервер желает избежать определенных парадоксов, которые могут возникнуть из-за использования дат изменения. , Теги сущностей описаны в &lt;a href=&quot;#section-3.11&quot;&gt;разделе 3.11&lt;/a&gt; . Заголовки, используемые с тегами &lt;a href=&quot;#section-14.19&quot;&gt;объектов&lt;/a&gt; , описаны в разделах 14.19 , &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; , &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; и &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e574d1947b2d7656ccf38b993e2056ebdd1b0a0" translate="yes" xml:space="preserve">
          <source>The Expect request-header field is used to indicate that particular
   server behaviors are required by the client.

      Expect       =  &quot;Expect&quot; &quot;:&quot; 1#expectation

      expectation  =  &quot;100-continue&quot; | expectation-extension
      expectation-extension =  token [ &quot;=&quot; ( token | quoted-string )
                               *expect-params ]
      expect-params =  &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]


   A server that does not understand or is unable to comply with any of
   the expectation values in the Expect field of a request MUST respond
   with appropriate error status. The server MUST respond with a 417
   (Expectation Failed) status if any of the expectations cannot be met
   or, if there are other problems with the request, some other 4xx
   status.

   This header field is defined with extensible syntax to allow for
   future extensions. If a server receives a request containing an
   Expect field that includes an expectation-extension that it does not
   support, it MUST respond with a 417 (Expectation Failed) status.

   Comparison of expectation values is case-insensitive for unquoted
   tokens (including the 100-continue token), and is case-sensitive for
   quoted-string expectation-extensions. 

   The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST
   return a 417 (Expectation Failed) status if it receives a request
   with an expectation that it cannot meet. However, the Expect
   request-header itself is end-to-end; it MUST be forwarded if the
   request is forwarded.

   Many older HTTP/1.0 and HTTP/1.1 applications do not understand the
   Expect header.

   See &lt;a href=&quot;#section-8.2.3&quot;&gt;section 8.2.3&lt;/a&gt; for the use of the 100 (continue) status.</source>
          <target state="translated">Поле заголовка запроса Expect используется для указания того, что конкретное поведение сервера требуется клиенту. Expect = &quot;Expect&quot; &quot;:&quot; 1 # ожидание expectation = &quot;100-continue&quot; | расширение-ожидание расширение-ожидание = токен [&quot;=&quot; (токен | строка-кавычки) * параметры-ожидания] ожидаемые параметры = &quot;;&quot; token [&quot;=&quot; (токен | строка в кавычках)] Сервер, который не понимает или не может выполнить какое-либо из ожидаемых значений в поле Expect запроса, ДОЛЖЕН ответить соответствующим статусом ошибки. Сервер ДОЛЖЕН ответить статусом 417 (Ожидание не выполнено), если какое-либо из ожиданий не может быть выполнено, или, если есть другие проблемы с запросом, каким-либо другим статусом 4xx.Это поле заголовка определено с расширяемым синтаксисом, что позволяет использовать его в будущем. Если сервер получает запрос, содержащий поле Expect, которое включает расширение ожидания, которое он не поддерживает, он ДОЛЖЕН ответить статусом 417 (Expectation Failed). При сравнении ожидаемых значений регистр не учитывается для токенов без кавычек (включая токен с продолжением 100) и учитывается регистр для расширений ожидания в кавычках. Механизм ожидания является поэтапным: то есть прокси-сервер HTTP / 1.1 ДОЛЖЕН возвращать статус 417 (ожидание не выполнено), если он получает запрос с ожиданием, которое он не может удовлетворить. Однако сам заголовок запроса Expect является сквозным; он ДОЛЖЕН быть переадресован, если запрос пересылается. Многие старые приложения HTTP / 1.0 и HTTP / 1.1 не понимают заголовок Expect. ВидетьВидетьВидетьВидетьВидетьВидетьВидетьЕсли сервер получает запрос, содержащий поле Expect, которое включает расширение ожидания, которое он не поддерживает, он ДОЛЖЕН ответить статусом 417 (Expectation Failed). При сравнении ожидаемых значений регистр не учитывается для токенов без кавычек (включая токен с продолжением 100) и учитывается регистр для расширений ожидания в кавычках. Механизм ожидания является поэтапным: то есть прокси-сервер HTTP / 1.1 ДОЛЖЕН возвращать статус 417 (ожидание не выполнено), если он получает запрос с ожиданием, которое он не может удовлетворить. Однако сам заголовок запроса Expect является сквозным; он ДОЛЖЕН быть переадресован, если запрос пересылается. Многие старые приложения HTTP / 1.0 и HTTP / 1.1 не понимают заголовок Expect. ВидетьЕсли сервер получает запрос, содержащий поле Expect, которое включает расширение ожидания, которое он не поддерживает, он ДОЛЖЕН ответить статусом 417 (Expectation Failed). При сравнении ожидаемых значений регистр не учитывается для токенов без кавычек (включая токен с продолжением 100) и учитывается регистр для расширений ожидания в кавычках. Механизм ожидания является поэтапным: то есть прокси-сервер HTTP / 1.1 ДОЛЖЕН возвращать статус 417 (ожидание не выполнено), если он получает запрос с ожиданием, которое он не может удовлетворить. Однако сам заголовок запроса Expect является сквозным; он ДОЛЖЕН быть переадресован, если запрос пересылается. Многие старые приложения HTTP / 1.0 и HTTP / 1.1 не понимают заголовок Expect. ВидетьВидетьВидетьПри сравнении ожидаемых значений регистр не учитывается для токенов без кавычек (включая токен с продолжением 100) и учитывается регистр для расширений ожидания в кавычках. Механизм ожидания является поэтапным: то есть прокси-сервер HTTP / 1.1 ДОЛЖЕН возвращать статус 417 (ожидание не выполнено), если он получает запрос с ожиданием, которое он не может удовлетворить. Однако сам заголовок запроса Expect является сквозным; он ДОЛЖЕН быть переадресован, если запрос пересылается. Многие старые приложения HTTP / 1.0 и HTTP / 1.1 не понимают заголовок Expect. ВидетьПри сравнении ожидаемых значений регистр не учитывается для токенов без кавычек (включая токен с продолжением 100) и учитывается регистр для расширений ожидания в кавычках. Механизм ожидания является поэтапным: то есть прокси-сервер HTTP / 1.1 ДОЛЖЕН возвращать статус 417 (ожидание не выполнено), если он получает запрос с ожиданием, которое он не может удовлетворить. Однако сам заголовок запроса Expect является сквозным; он ДОЛЖЕН быть переадресован, если запрос пересылается. Многие старые приложения HTTP / 1.0 и HTTP / 1.1 не понимают заголовок Expect. ВидетьПрокси-сервер 1 ДОЛЖЕН возвращать статус 417 (ожидание не выполнено), если он получает запрос с ожиданием, которое он не может удовлетворить. Однако сам заголовок запроса Expect является сквозным; он ДОЛЖЕН быть переадресован, если запрос пересылается. Многие старые приложения HTTP / 1.0 и HTTP / 1.1 не понимают заголовок Expect. ВидетьПрокси-сервер 1 ДОЛЖЕН возвращать статус 417 (ожидание не выполнено), если он получает запрос с ожиданием, которое он не может удовлетворить. Однако сам заголовок запроса Expect является сквозным; он ДОЛЖЕН быть переадресован, если запрос пересылается. Многие старые приложения HTTP / 1.0 и HTTP / 1.1 не понимают заголовок Expect. Видеть&lt;a href=&quot;#section-8.2.3&quot;&gt;раздел 8.2.3&lt;/a&gt; для использования статуса 100 (продолжить).</target>
        </trans-unit>
        <trans-unit id="99ea10caeb88c8a848354c782365979235f3abbc" translate="yes" xml:space="preserve">
          <source>The Expires entity-header field gives the date/time after which the
   response is considered stale. A stale cache entry may not normally be
   returned by a cache (either a proxy cache or a user agent cache)
   unless it is first validated with the origin server (or with an
   intermediate cache that has a fresh copy of the entity). See &lt;a href=&quot;#section-13.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; for further discussion of the expiration model.

   The presence of an Expires field does not imply that the original
   resource will change or cease to exist at, before, or after that
   time.

   The format is an absolute date and time as defined by HTTP-date in
   &lt;a href=&quot;#section-3.3.1&quot;&gt;section 3.3.1&lt;/a&gt;; it MUST be in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; date format:

      Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date

   An example of its use is

      Expires: Thu, 01 Dec 1994 16:00:00 GMT

      Note: if a response includes a Cache-Control field with the max-
      age directive (see &lt;a href=&quot;#section-14.9.3&quot;&gt;section 14.9.3&lt;/a&gt;), that directive overrides the
      Expires field.

   HTTP/1.1 clients and caches MUST treat other invalid date formats,
   especially including the value &quot;0&quot;, as in the past (i.e., &quot;already
   expired&quot;).

   To mark a response as &quot;already expired,&quot; an origin server sends an
   Expires date that is equal to the Date header value. (See the rules
   for expiration calculations in &lt;a href=&quot;#section-13.2.4&quot;&gt;section 13.2.4&lt;/a&gt;.) 

   To mark a response as &quot;never expires,&quot; an origin server sends an
   Expires date approximately one year from the time the response is
   sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one
   year in the future.

   The presence of an Expires header field with a date value of some
   time in the future on a response that otherwise would by default be
   non-cacheable indicates that the response is cacheable, unless
   indicated otherwise by a Cache-Control header field (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).</source>
          <target state="translated">В поле заголовка объекта Expires указывается дата / время, после которых ответ считается устаревшим. Устаревшая запись кэша обычно не может быть возвращена кешем (либо кешем прокси, либо кешем пользовательского агента), если она сначала не проверена на исходном сервере (или с промежуточным кешем, в котором есть свежая копия объекта). См. &lt;a href=&quot;#section-13.2&quot;&gt;Раздел &lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; для дальнейшего обсуждения модели истечения срока. Наличие поля Expires не означает, что исходный ресурс изменится или прекратит свое существование в, до или после этого времени. Формат - это абсолютная дата и время, как определено HTTP-date в &lt;a href=&quot;#section-3.3.1&quot;&gt;разделе 3.3.1&lt;/a&gt; ; это ДОЛЖНО быть в &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt;формат даты: Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date Пример его использования: Expires: Thu, 01 Dec 1994 16:00:00 GMT Примечание: если ответ включает поле Cache-Control с директивой max age (см. &lt;a href=&quot;#section-14.9.3&quot;&gt;раздел 14.9.3&lt;/a&gt; ), эта директива имеет приоритет над полем Expires. Клиенты и кеши HTTP / 1.1 ДОЛЖНЫ обрабатывать другие недопустимые форматы даты, особенно включая значение &amp;laquo;0&amp;raquo;, как в прошлом (т. Е. &amp;laquo;Срок действия уже истек&amp;raquo;). Чтобы пометить ответ как &amp;laquo;уже просроченный&amp;raquo;, исходный сервер отправляет дату Expires, которая равна значению заголовка Date. (См. Правила расчета срока действия в &lt;a href=&quot;#section-13.2.4&quot;&gt;разделе 13.2.4.&lt;/a&gt;.) Чтобы пометить ответ как &amp;laquo;никогда не истекающий&amp;raquo;, исходный сервер отправляет дату истечения примерно через год с момента отправки ответа. Серверы HTTP / 1.1 НЕ ДОЛЖНЫ отправлять даты истечения срока действия более чем на один год в будущем. Присутствие поля заголовка Expires со значением даты на некоторое время в будущем в ответе, который в противном случае по умолчанию не был бы кэшируемым, указывает на то, что ответ кэшируется, если иное не указано в поле заголовка Cache-Control ( &lt;a href=&quot;#section-14.9&quot;&gt;раздел 14.9&lt;/a&gt; ) ,</target>
        </trans-unit>
        <trans-unit id="802828c9e44a9d19272a3ae660a11b2bb9d689e1" translate="yes" xml:space="preserve">
          <source>The Feature-Policy HTTP header</source>
          <target state="translated">Функция-политика HTTP заголовок</target>
        </trans-unit>
        <trans-unit id="8b610252bef915d12d88c567e1882bdb3b137742" translate="yes" xml:space="preserve">
          <source>The From request-header field, if given, SHOULD contain an Internet
   e-mail address for the human user who controls the requesting user
   agent. The address SHOULD be machine-usable, as defined by &quot;mailbox&quot;
   in &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as updated by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]:

       From   = &quot;From&quot; &quot;:&quot; mailbox

   An example is:

       From: webmaster@w3.org

   This header field MAY be used for logging purposes and as a means for
   identifying the source of invalid or unwanted requests. It SHOULD NOT
   be used as an insecure form of access protection. The interpretation
   of this field is that the request is being performed on behalf of the
   person given, who accepts responsibility for the method performed. In
   particular, robot agents SHOULD include this header so that the
   person responsible for running the robot can be contacted if problems
   occur on the receiving end.

   The Internet e-mail address in this field MAY be separate from the
   Internet host which issued the request. For example, when a request
   is passed through a proxy the original issuer's address SHOULD be
   used.

   The client SHOULD NOT send the From header field without the user's
   approval, as it might conflict with the user's privacy interests or
   their site's security policy. It is strongly recommended that the
   user be able to disable, enable, and modify the value of this field
   at any time prior to a request.</source>
          <target state="translated">Поле заголовка запроса From, если оно задано, ДОЛЖНО содержать адрес электронной почты в Интернете для человека-пользователя, который управляет запрашивающим пользовательским агентом. Адрес ДОЛЖЕН быть машинным, как определено &quot;почтовым ящиком&quot; в &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ] и обновлено &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]: From = &quot;From&quot; &quot;:&quot; почтовый ящик Пример: From: webmaster@w3.org Это поле заголовка МОЖЕТ использоваться для ведения журнала и как средство для определения источника недействительных или нежелательных запросов. Его НЕ СЛЕДУЕТ использовать в качестве небезопасной формы защиты доступа. Интерпретация этого поля заключается в том, что запрос выполняется от имени данного лица, которое принимает на себя ответственность за выполненный метод. В частности, агенты роботов ДОЛЖНЫ включать этот заголовок, чтобы можно было связаться с лицом, ответственным за запуск робота, в случае возникновения проблем на принимающей стороне. Адрес электронной почты в Интернете в этом поле МОЖЕТ быть отдельным от узла Интернета, отправившего запрос. Например, когда запрос передается через прокси, исходный эмитент 'СЛЕДУЕТ использовать адрес s. Клиенту НЕ СЛЕДУЕТ отправлять поле заголовка From без одобрения пользователя, так как это может противоречить интересам конфиденциальности пользователя или политике безопасности его сайта. Настоятельно рекомендуется, чтобы пользователь мог отключать, включать и изменять значение этого поля в любое время до запроса.</target>
        </trans-unit>
        <trans-unit id="8a3df35a0d664c78b3c3b6d7181ee8d7a2e5448f" translate="yes" xml:space="preserve">
          <source>The GET method means retrieve whatever information (in the form of an
   entity) is identified by the Request-URI. If the Request-URI refers
   to a data-producing process, it is the produced data which shall be
   returned as the entity in the response and not the source text of the
   process, unless that text happens to be the output of the process.

   The semantics of the GET method change to a &quot;conditional GET&quot; if the
   request message includes an If-Modified-Since, If-Unmodified-Since,
   If-Match, If-None-Match, or If-Range header field. A conditional GET
   method requests that the entity be transferred only under the
   circumstances described by the conditional header field(s). The
   conditional GET method is intended to reduce unnecessary network
   usage by allowing cached entities to be refreshed without requiring
   multiple requests or transferring data already held by the client.

   The semantics of the GET method change to a &quot;partial GET&quot; if the
   request message includes a Range header field. A partial GET requests
   that only part of the entity be transferred, as described in &lt;a href=&quot;#section-14.35&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;. The partial GET method is intended to reduce unnecessary
   network usage by allowing partially-retrieved entities to be
   completed without transferring data already held by the client.

   The response to a GET request is cacheable if and only if it meets
   the requirements for HTTP caching described in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations when used for forms.</source>
          <target state="translated">Метод GET означает получение любой информации (в форме объекта), идентифицированной Request-URI. Если Request-URI относится к процессу создания данных, то в качестве объекта в ответе должны быть возвращены произведенные данные, а не исходный текст процесса, если только этот текст не является выходом процесса. Семантика метода GET изменяется на &amp;laquo;условный GET&amp;raquo;, если сообщение запроса включает поле заголовка If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match или If-Range. Условный метод GET требует, чтобы объект был передан только при обстоятельствах, описанных полями условного заголовка.Условный метод GET предназначен для уменьшения ненужного использования сети, позволяя обновлять кэшированные объекты, не требуя множественных запросов или передачи данных, уже хранящихся у клиента. Семантика метода GET изменяется на &amp;laquo;частичный GET&amp;raquo;, если сообщение запроса включает поле заголовка Range. Частичный GET-запрос передает только часть объекта, как описано в&lt;a href=&quot;#section-14.35&quot;&gt;Раздел &lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt; . Метод частичного GET предназначен для уменьшения ненужного использования сети, позволяя завершать частично извлеченные объекты без передачи данных, уже хранящихся у клиента. Ответ на запрос GET кэшируется тогда и только тогда, когда он соответствует требованиям к HTTP-кешированию, описанным в &lt;a href=&quot;#section-13&quot;&gt;разделе 13&lt;/a&gt; . См. &lt;a href=&quot;#section-15.1.3&quot;&gt;Раздел 15.1.3&lt;/a&gt; для ознакомления с соображениями безопасности при использовании форм.</target>
        </trans-unit>
        <trans-unit id="7fe6f3c8c21eb606abd80993ecfb90185941dd2b" translate="yes" xml:space="preserve">
          <source>The GET method requests transfer of a current selected representation
   for the target resource.  GET is the primary mechanism of information
   retrieval and the focus of almost all performance optimizations.
   Hence, when people speak of retrieving some identifiable information
   via HTTP, they are generally referring to making a GET request.

   It is tempting to think of resource identifiers as remote file system
   pathnames and of representations as being a copy of the contents of
   such files.  In fact, that is how many resources are implemented (see
   &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt; for related security considerations).  However, there are
   no such limitations in practice.  The HTTP interface for a resource
   is just as likely to be implemented as a tree of content objects, a
   programmatic view on various database records, or a gateway to other
   information systems.  Even when the URI mapping mechanism is tied to
   a file system, an origin server might be configured to execute the
   files with the request as input and send the output as the
   representation rather than transfer the files directly.  Regardless,
   only the origin server needs to know how each of its resource 

   identifiers corresponds to an implementation and how each
   implementation manages to select and send a current representation of
   the target resource in a response to GET.

   A client can alter the semantics of GET to be a &quot;range request&quot;,
   requesting transfer of only some part(s) of the selected
   representation, by sending a Range header field in the request
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]).

   A payload within a GET request message has no defined semantics;
   sending a payload body on a GET request might cause some existing
   implementations to reject the request.

   The response to a GET request is cacheable; a cache MAY use it to
   satisfy subsequent GET and HEAD requests unless otherwise indicated
   by the Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Метод GET запрашивает передачу текущего выбранного представления для целевого ресурса. GET - это основной механизм поиска информации, на котором сосредоточены практически все методы оптимизации производительности. Следовательно, когда люди говорят о получении некоторой идентифицируемой информации через HTTP, они обычно имеют в виду выполнение запроса GET. Заманчиво думать об идентификаторах ресурсов как о путях к удаленной файловой системе, а о представлениях - как об копиях содержимого таких файлов. Фактически, именно столько ресурсов реализовано (см. &lt;a href=&quot;#section-9.1&quot;&gt;Раздел 9.1&lt;/a&gt;по связанным соображениям безопасности). Однако на практике таких ограничений нет. Интерфейс HTTP для ресурса с такой же вероятностью будет реализован как дерево объектов контента, программное представление для различных записей базы данных или шлюз к другим информационным системам. Даже когда механизм сопоставления URI привязан к файловой системе, исходный сервер может быть настроен на выполнение файлов с запросом в качестве входных данных и отправку выходных данных в качестве представления, а не передачу файлов напрямую. Тем не менее, только исходный сервер должен знать, как каждый из его идентификаторов ресурса соответствует реализации и как каждая реализация управляет выбором и отправкой текущего представления целевого ресурса в ответ на GET. Клиент может изменить семантику GET на &quot;запрос диапазона &quot;, запрашивая передачу только части (частей) выбранного представления, отправив поле заголовка диапазона в запросе ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]). Полезные данные в сообщении запроса GET не имеют определенной семантики; отправка тела полезной нагрузки в запросе GET может привести к тому, что некоторые существующие реализации отклонят запрос. Ответ на запрос GET кэшируется; кэш МОЖЕТ использовать его для удовлетворения последующих запросов GET и HEAD, если иное не указано в поле заголовка Cache-Control ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;раздел 5.2 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7df79dab20c7e00cfdc0198d8b7108bafe0b904f" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   return a message-body in the response. The metainformation contained
   in the HTTP headers in response to a HEAD request SHOULD be identical
   to the information sent in response to a GET request. This method can
   be used for obtaining metainformation about the entity implied by the
   request without transferring the entity-body itself. This method is
   often used for testing hypertext links for validity, accessibility,
   and recent modification.

   The response to a HEAD request MAY be cacheable in the sense that the
   information contained in the response MAY be used to update a
   previously cached entity from that resource. If the new field values
   indicate that the cached entity differs from the current entity (as
   would be indicated by a change in Content-Length, Content-MD5, ETag
   or Last-Modified), then the cache MUST treat the cache entry as
   stale.</source>
          <target state="translated">Метод HEAD идентичен GET за исключением того,что сервер НЕ ДОЛЖЕН возвращать тело сообщения в ответе.Метаинформация,содержащаяся в заголовках HTTP в ответ на запрос HEAD ДОЛЖНА быть идентична информации,отправленной в ответ на запрос GET.Этот метод может быть использован для получения метаинформации о сущности,подразумеваемой запросом,без передачи самого сущности-тела.Данный метод часто используется для проверки гипертекстовых ссылок на достоверность,доступность и недавние изменения.Ответ на HEAD запрос МОЖЕТ быть кэшируемым в том смысле,что информация,содержащаяся в ответе МОЖЕТ быть использована для обновления ранее кэшированной сущности с этого ресурса.Если новые значения полей указывают на то,что кэшируемая сущность отличается от текущей (о чем свидетельствует изменение Content-Length,Content-MD5,ETag или Last-Modified),то кэш ДОЛЖЕН относиться к кэшируемой сущности как к черствой.</target>
        </trans-unit>
        <trans-unit id="af87f0a9948cd0c865e17fe40c999f5f6559a626" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   send a message body in the response (i.e., the response terminates at
   the end of the header section).  The server SHOULD send the same
   header fields in response to a HEAD request as it would have sent if
   the request had been a GET, except that the payload header fields
   (&lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;) MAY be omitted.  This method can be used for obtaining
   metadata about the selected representation without transferring the
   representation data and is often used for testing hypertext links for
   validity, accessibility, and recent modification.

   A payload within a HEAD request message has no defined semantics;
   sending a payload body on a HEAD request might cause some existing
   implementations to reject the request.

   The response to a HEAD request is cacheable; a cache MAY use it to
   satisfy subsequent HEAD requests unless otherwise indicated by the
   Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).  A HEAD
   response might also have an effect on previously cached responses to
   GET; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;Section&amp;nbsp;4.3.5 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">Метод HEAD идентичен GET, за исключением того, что сервер НЕ ДОЛЖЕН отправлять тело сообщения в ответ (т. Е. Ответ заканчивается в конце раздела заголовка). Серверу СЛЕДУЕТ отправлять в ответ на запрос HEAD те же поля заголовка, которые он отправил бы, если бы запрос был GET, за исключением того, что поля заголовка полезной нагрузки ( &lt;a href=&quot;#section-3.3&quot;&gt;раздел 3.3&lt;/a&gt;) МОЖЕТ быть опущено. Этот метод можно использовать для получения метаданных о выбранном представлении без передачи данных представления и часто используется для проверки гипертекстовых ссылок на достоверность, доступность и недавнюю модификацию. Полезная нагрузка в сообщении запроса HEAD не имеет определенной семантики; отправка тела полезной нагрузки в запросе HEAD может привести к тому, что некоторые существующие реализации отклонят запрос. Ответ на запрос HEAD кэшируется; кэш МОЖЕТ использовать его для удовлетворения последующих запросов HEAD, если иное не указано в поле заголовка Cache-Control ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;раздел 5.2 [RFC7234]&lt;/a&gt; ). Ответ HEAD также может влиять на ранее кэшированные ответы на GET; см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;раздел 4.3.5 [RFC7234]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5fa0cc40bb9e4667e351329947478703648e5a09" translate="yes" xml:space="preserve">
          <source>The HTML of &lt;code&gt;signup.html&lt;/code&gt; looks like this:</source>
          <target state="translated">HTML- &lt;code&gt;signup.html&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="f9ee255be05b605cffc50bf531b8bbc6cd52f1c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; предотвращает загрузку любых ресурсов с использованием HTTP, когда страница загружается с использованием HTTPS.</target>
        </trans-unit>
        <trans-unit id="a4307301fcd6bb5ccdab9143ff3528885084251b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ограничивает URL-адреса, которые могут быть загружены с помощью интерфейсов сценариев. Ограниченные API:</target>
        </trans-unit>
        <trans-unit id="182931c21e0e507ac442ba7fad6c85f7022aa1b1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) по &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; служит резервным вариантом для других &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;директив&lt;/a&gt; CSP fetch . Для каждой из следующих директив, которые отсутствуют, пользовательский агент будет искать директиву &lt;code&gt;default-src&lt;/code&gt; и будет использовать для нее это значение:</target>
        </trans-unit>
        <trans-unit id="df6b0aa2488b0f60a06ea64f5f84252e16a5ba40" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для шрифтов, загружаемых с использованием &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b26fdbf4c8f95b8df3d8b6830742e1c693873add" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-action&lt;/code&gt; ограничивает URL-адреса, которые могут использоваться в качестве цели для отправки формы из заданного контекста.</target>
        </trans-unit>
        <trans-unit id="e3702b120d46e550d906d2d9a8d47f7b89a394a2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; указывает допустимые родительские элементы, которые могут встраивать страницу с помощью &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7a99a281dc2a7e2980a9a7cde577543fea1d6f5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; указывает допустимые источники для загрузки вложенных контекстов просмотра с использованием таких элементов, как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="39e405945a5f6f3e5caa215c10fb1ba16c926f41" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для загрузки мультимедиа с помощью элементов &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d107e0a38faf65b9362f0868294c5f1f868d7aa" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; ограничивает набор &lt;strong&gt;подключаемых модулей,&lt;/strong&gt; которые могут быть встроены в документ, путем ограничения типов ресурсов, которые могут быть загружены.</target>
        </trans-unit>
        <trans-unit id="6ad6e328ff3b4fb09016b0d4cd3b23b2ef304500" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;../referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">Директива &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP), используемая для указания информации в заголовке &lt;a href=&quot;../referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; (с одним &lt;code&gt;r&lt;/code&gt; , поскольку это была опечатка в исходной спецификации) для ссылок за пределами страницы. Этот API устарел и удален из браузеров.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f8670f822879a6c1f70bb6696d4385c9e028089" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; директива позволяет песочницу для запрошенного ресурса аналогичен &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; атрибута. Он применяет ограничения к действиям страницы, включая предотвращение всплывающих окон, предотвращение выполнения плагинов и скриптов, а также принудительное применение политики одного происхождения.</target>
        </trans-unit>
        <trans-unit id="63d32345b8cf84239a5bf4892731d98708512218" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; указывает допустимые источники для JavaScript. Сюда входят не только URL-адреса, загружаемые непосредственно в элементы &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; , но и такие вещи, как встроенные обработчики событий сценария ( &lt;code&gt;onclick&lt;/code&gt; ) и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;таблицы стилей XSLT,&lt;/a&gt; которые могут запускать выполнение сценария.</target>
        </trans-unit>
        <trans-unit id="e2a780dcd99b14cfc49a43bc74102f1ed0b2e3e6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для таблиц стилей.</target>
        </trans-unit>
        <trans-unit id="591de896ab33256052ca0797fb955116eff15e90" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; предписывает пользовательским агентам обрабатывать все небезопасные URL-адреса сайта (обслуживаемые через HTTP), как если бы они были заменены безопасными URL-адресами (обслуживаемыми через HTTPS). Эта директива предназначена для веб-сайтов с большим количеством небезопасных устаревших URL-адресов, которые необходимо переписать.</target>
        </trans-unit>
        <trans-unit id="32ff6a8bc2363d0ff4f3086755b7248183c5b34b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; указывает допустимые источники для &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; , SharedWorker или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a8c324b7db31bcba8cef085e4b98f52d8cd17a3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает, какой &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;манифест&lt;/a&gt; можно применить к ресурсу.</target>
        </trans-unit>
        <trans-unit id="b239689551cd0c9430aba9321c015f59f5b7ee6a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники изображений и значков.</target>
        </trans-unit>
        <trans-unit id="4db12171daec1cecdac720828f51ca0a57d2ce24" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для элементов &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a75713e06f850d30f3c1d3897dfbb65c817d0a9c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; указывает клиенту требовать использования &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; для скриптов или стилей на странице.</target>
        </trans-unit>
        <trans-unit id="a32f782eaaf1368e46240e1ae4c440922d0f70d0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; ограничивает URL-адреса, которые могут использоваться в элементе &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; документа&lt;/a&gt; . Если это значение отсутствует, то разрешен любой URI. Если эта директива отсутствует, пользовательский агент будет использовать значение в элементе &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01c9ca551ef322fcef92f79b3a236ae1ba63f558" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;. The &lt;code&gt;autoplay&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">Директива &lt;code&gt;autoplay&lt;/code&gt; заголовка &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; HTTP определяет, разрешено ли текущему документу автоматически воспроизводить мультимедиа, запрошенную через интерфейс &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt; . Когда эта политика включена и пользовательских жестов не было, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; возвращаемое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt; будет отклонено с &lt;code&gt;DOMException&lt;/code&gt; . &lt;code&gt;autoplay&lt;/code&gt; атрибут &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; элементы будут игнорироваться.</target>
        </trans-unit>
        <trans-unit id="89ab43068a1ce03c2c700695396807b764653f4c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;camera&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать устройства ввода видео. Когда эта политика включена, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; возвращаемое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; будет отклонено с &lt;code&gt;NotAllowedError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0509b709eb9c12fa1d36b479d880843a32939bb2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;document-domain&lt;/code&gt; directive controls whether the current document is allowed to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, attempting to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt; will fail and cause a &lt;code&gt;SecurityError&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; to be be thrown.</source>
          <target state="translated">Директива &lt;code&gt;document-domain&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу устанавливать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt; . Когда эта политика включена, попытка установить &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt; завершится ошибкой и вызовет &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; &lt;code&gt;SecurityError&lt;/code&gt; DOMException .</target>
        </trans-unit>
        <trans-unit id="c66dd6d4d4a75699b185decdfad8e45e19e0002d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;encrypted-media&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). Когда эта политика включена, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; возвращаемое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt; будет отклонено с &lt;code&gt;DOMException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e8d5d79df5028bcf829983040e4f5d620f67f63" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива &lt;code&gt;fullscreen&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt; . Когда эта политика включена, возвращенное &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; отклоняется с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb70b85868a9918e7c850de1c73663ec03ac5340" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;geolocation&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать интерфейс &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt; . Когда эта политика включена, вызовы &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; &lt;/a&gt; будут вызывать обратные вызовы этих функций с кодом &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt; &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d88583ce1eab6212205a0ce4ec5269a6f045f6b3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;microphone&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать устройства ввода звука. Когда эта политика включена, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; возвращаемое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; будет отклонено с &lt;code&gt;NotAllowedError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f61a9280d76cca41de0c10b1bb571562297d206c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;midi&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt;&lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;midi&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt; . Когда эта политика включена, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; возвращаемое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt; &lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt; &lt;/a&gt; будет отклонено с &lt;code&gt;DOMException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad49b71ef86ec5410e8de76cba85903aa7fec02d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;payment&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;API запроса платежа&lt;/a&gt; . Если эта политика включена, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt; конструктор бросит &lt;code&gt;SecurityError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf81d231c67dd1b00b85de64c8fcc4e2241cad31" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;vr&lt;/code&gt; заголовка HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;API WebVR&lt;/a&gt; . Когда эта политика включена, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; возвращаемое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt; будет отклонено с &lt;code&gt;DOMException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90bd59abf141ac2acd0d6eb93603dfbb20ca13bb" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; предотвращает загрузку любых ресурсов с использованием HTTP, когда страница загружается с использованием HTTPS.</target>
        </trans-unit>
        <trans-unit id="2c130ba07e36557d606dab5e0daeea1174e0f829" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; ограничивает URL-адреса, которые могут быть загружены с помощью интерфейсов сценариев. Ограниченные API:</target>
        </trans-unit>
        <trans-unit id="f9e44e9310d4af0da6d15e0f9e8b89d123612c88" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) по &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; служит резервным вариантом для других &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;директив&lt;/a&gt; CSP fetch . Для каждой из следующих директив, которые отсутствуют, пользовательский агент будет искать директиву &lt;code&gt;default-src&lt;/code&gt; и будет использовать для нее это значение:</target>
        </trans-unit>
        <trans-unit id="872a0ce0f866c4f403e5c4fdabdba2ac75e64283" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для шрифтов, загружаемых с использованием &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89db1b08f92d8384d90536ecc2f476ece38912e3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-action&lt;/code&gt; ограничивает URL-адреса, которые могут использоваться в качестве цели для отправки формы из заданного контекста.</target>
        </trans-unit>
        <trans-unit id="53e746d6be4fd9b5eb3832de56d4365f491df6d6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; указывает допустимые родительские элементы, которые могут встраивать страницу с помощью &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60434b7f567fe8e897910e8b6a67bd2318a07eda" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; указывает допустимые источники для загрузки вложенных контекстов просмотра с использованием таких элементов, как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af2c302ddc10d3d222e0a67e09b8d5d05e052366" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для загрузки мультимедиа с помощью элементов &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d40cffb60b43134b32f0810a5ed2a290fe665f6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; ограничивает набор &lt;strong&gt;подключаемых модулей,&lt;/strong&gt; которые могут быть встроены в документ, путем ограничения типов ресурсов, которые могут быть загружены.</target>
        </trans-unit>
        <trans-unit id="bdd0798eaf4df1ffabbf8a0c8d7aa4c0dbd9e69b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">Директива &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP), используемая для указания информации в заголовке &lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; (с одним &lt;code&gt;r&lt;/code&gt; , поскольку это была опечатка в исходной спецификации) для ссылок за пределами страницы. Этот API устарел и удален из браузеров.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="befd663ba9deb24fd4ec2918a5d6109d2636a2d4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; директива позволяет песочницу для запрошенного ресурса аналогичен &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; атрибута. Он применяет ограничения к действиям страницы, включая предотвращение всплывающих окон, предотвращение выполнения плагинов и скриптов, а также принудительное применение политики одного происхождения.</target>
        </trans-unit>
        <trans-unit id="5b8d334a3bce170c8993d25e4d184932264ac72f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; указывает допустимые источники для JavaScript. Сюда входят не только URL-адреса, загружаемые непосредственно в элементы &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; , но и такие вещи, как встроенные обработчики событий сценария ( &lt;code&gt;onclick&lt;/code&gt; ) и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;таблицы стилей XSLT,&lt;/a&gt; которые могут запускать выполнение сценария.</target>
        </trans-unit>
        <trans-unit id="8cef37884cea47d641cdd47c4c37fa6b8ac6254c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for sources for stylesheets.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для источников для таблиц стилей.</target>
        </trans-unit>
        <trans-unit id="8a7e1c437a2a4b57d25b681153a76fdfe0cd58a0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; предписывает пользовательским агентам обрабатывать все небезопасные URL-адреса сайта (обслуживаемые через HTTP), как если бы они были заменены безопасными URL-адресами (обслуживаемыми через HTTPS). Эта директива предназначена для веб-сайтов с большим количеством небезопасных устаревших URL-адресов, которые необходимо переписать.</target>
        </trans-unit>
        <trans-unit id="c6470e7d04b8abe1f65b75c4d51906723a206d5d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; указывает допустимые источники для &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; , SharedWorker или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65fa53659e196a5f364ee4db69fef14fde746c4b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает, какой &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;манифест&lt;/a&gt; можно применить к ресурсу.</target>
        </trans-unit>
        <trans-unit id="e5534bb581250f2eb94ed31caf65205d9ee368e1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники изображений и значков.</target>
        </trans-unit>
        <trans-unit id="dc76ac8291a24a25cb87200add3759c6483c6ea1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; указывает допустимые источники для элементов &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d78f21670ba26d46502f42156fd74dce6127ca2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; указывает клиенту требовать использования &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; для скриптов или стилей на странице.</target>
        </trans-unit>
        <trans-unit id="c04dd8d66fd1dfd03e0cb89fd2b86f5466e7e9c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">Директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; ограничивает URL-адреса, которые могут использоваться в элементе &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; документа&lt;/a&gt; . Если это значение отсутствует, то разрешен любой URI. Если эта директива отсутствует, пользовательский агент будет использовать значение в элементе &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c026bd77cc15606268a474526426c47ed406dd3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Директива &lt;code&gt;fullscreen&lt;/code&gt; заголовка HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt; . Когда эта политика включена, возвращенное &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; отклоняется с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="279945c05ed4e9f8612677a6cb5333c055c3347c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;geolocation&lt;/code&gt; заголовка HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать интерфейс &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt; . Когда эта политика включена, вызовы &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; &lt;/a&gt; вызовут обратные вызовы этих функций с кодом &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt; &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b86b8ff6f832650a49ab241aa391e1a80cf0e208" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">Директива &lt;code&gt;microphone&lt;/code&gt; заголовка HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; определяет, разрешено ли текущему документу использовать устройства ввода звука. Если эта политика включена, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; возвращаемое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; будет отклонено с &lt;code&gt;NotAllowedError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a01790dc40b1842141c794cdff77d6c8665d41c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method only allows complete replacement of a document. Unlike &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt; is not idempotent, meaning successive identical patch requests &lt;em&gt;may &lt;/em&gt;have different effects. However, it is possible to issue &lt;code&gt;PATCH&lt;/code&gt; requests in such a way as to be idempotent.</source>
          <target state="translated">Метод HTTP &lt;a href=&quot;put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; позволяет только полную замену документа. В отличие от &lt;code&gt;PUT&lt;/code&gt; , &lt;code&gt;PATCH&lt;/code&gt; не идемпотентен, что означает, что последовательные одинаковые запросы исправлений &lt;em&gt;могут&lt;/em&gt; иметь разные эффекты. Однако можно &lt;code&gt;PATCH&lt;/code&gt; запросы PATCH таким образом, чтобы они были идемпотентными.</target>
        </trans-unit>
        <trans-unit id="7f334e7627368fd785cf9c286367893a77c43e45" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;100 Continue&lt;/code&gt; informational status response code indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.</source>
          <target state="translated">Код ответа информационного статуса HTTP &lt;code&gt;100 Continue&lt;/code&gt; указывает, что пока все в порядке, и что клиент должен продолжить выполнение запроса или проигнорировать его, если он уже завершен.</target>
        </trans-unit>
        <trans-unit id="278c46bdc85af7c390f125d693bcbfb316c79076" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;200 OK&lt;/code&gt; success status response code indicates that the request has succeeded. A 200 response is cacheable by default.</source>
          <target state="translated">Код ответа об успешном состоянии HTTP &lt;code&gt;200 OK&lt;/code&gt; указывает, что запрос выполнен успешно. По умолчанию ответ 200 кэшируется.</target>
        </trans-unit>
        <trans-unit id="c0eb27679053d5143a43ddd8d3a3431a539fa9ad" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;201 Created&lt;/code&gt; success status response code indicates that the request has succeeded and has led to the creation of a resource. The new resource is effectively created before this response is sent back and the new resource is returned in the body of the message, its location being either the URL of the request, or the content of the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Код ответа HTTP &lt;code&gt;201 Created&lt;/code&gt; Success status указывает, что запрос выполнен успешно и привел к созданию ресурса. Новый ресурс фактически создается до того, как этот ответ будет отправлен обратно, и новый ресурс будет возвращен в теле сообщения, его местонахождением является либо URL-адрес запроса, либо содержимое заголовка &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4d3953aeb6b99914993168434167c7b602ed71d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; response status indicates that the request was successful but the enclosed payload has been modified from that of the origin server's &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response by a transforming &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxy&lt;/a&gt;.</source>
          <target state="translated">Статус ответа HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; указывает, что запрос был успешным, но вложенные полезные данные были изменены по сравнению с ответом исходного сервера &lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;OK&lt;/code&gt; ) преобразующим &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;прокси&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8b0b238f5e41f13b1e7f817deb60c88d7d3bc20" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;204 No Content&lt;/code&gt; success status response code indicates that the request has succeeded, but that the client doesn't need to go away from its current page. A 204 response is cacheable by default. An &lt;a href=&quot;../headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header is included in such a response.</source>
          <target state="translated">Код ответа HTTP &lt;code&gt;204 No Content&lt;/code&gt; Success status указывает, что запрос выполнен успешно, но клиенту не нужно уходить со своей текущей страницы. По умолчанию ответ 204 кэшируется. &lt;a href=&quot;../headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; заголовок включен в таком ответ.</target>
        </trans-unit>
        <trans-unit id="80288ab170aee829f4cf209605eb49eadc086eef" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;205 Reset Content&lt;/code&gt; response status tells the client to reset the document view, so for example to clear the content of a form, reset a canvas state, or to refresh the UI.</source>
          <target state="translated">Статус ответа &amp;laquo; &lt;code&gt;205 Reset Content&lt;/code&gt; HTTP 205&amp;raquo; сообщает клиенту, что необходимо сбросить представление документа, например очистить содержимое формы, сбросить состояние холста или обновить пользовательский интерфейс.</target>
        </trans-unit>
        <trans-unit id="0c81546d9f0eee981bd016b4cb4e7eaa4833eb13" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; success status response code indicates that the request has succeeded and has the body contains the requested ranges of data, as described in the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header of the request.</source>
          <target state="translated">Код ответа об успешном завершении HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; указывает на то, что запрос выполнен успешно, и его тело содержит запрошенные диапазоны данных, как описано в заголовке &lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; запроса.</target>
        </trans-unit>
        <trans-unit id="3b3b5e099cd9381b1fd70b5113573795b1907f7d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.</source>
          <target state="translated">Код ответа о состоянии ошибки HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; клиент&amp;raquo; указывает на то, что запрос не был применен из-за отсутствия действительных учетных данных аутентификации для целевого ресурса.</target>
        </trans-unit>
        <trans-unit id="979b22f333764accadf3c7a12f9ce50117ebb170" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; client error status response code indicates that the server understood the request but refuses to authorize it.</source>
          <target state="translated">Код ответа HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; client error status показывает, что сервер понял запрос, но отказывается его авторизовать.</target>
        </trans-unit>
        <trans-unit id="17d3fa05f1dcd2e00101e33637b74e845046dbb5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt; that is between the browser and the server that can access the requested resource.</source>
          <target state="translated">Код ответа состояния ошибки клиента HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; указывает, что запрос не был применен из-за отсутствия действительных учетных данных для &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;прокси-сервера,&lt;/a&gt; который находится между браузером и сервером, который может получить доступ к запрошенному ресурсу.</target>
        </trans-unit>
        <trans-unit id="bbb5886db0baaa39aa591bfbfac7d405f377c2ab" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; client error response code indicates that the expectation given in the request's &lt;a href=&quot;../headers/expect&quot;&gt;&lt;code&gt;Expect&lt;/code&gt;&lt;/a&gt; header could not be met.</source>
          <target state="translated">Код ответа об ошибке клиента HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; указывает, что ожидание, указанное в заголовке &lt;a href=&quot;../headers/expect&quot;&gt; &lt;code&gt;Expect&lt;/code&gt; &lt;/a&gt; запроса, не может быть выполнено.</target>
        </trans-unit>
        <trans-unit id="0fd8eba95386e5a941324f20f703ccd45af95a3a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error response code indicates that the server refuses to brew coffee because it is a teapot. This error is a reference of Hyper Text Coffee Pot Control Protocol which was an April Fools' joke in 1998.</source>
          <target state="translated">Код ответа HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; указывает на то, что сервер отказывается варить кофе, потому что это чайник. Эта ошибка является отсылкой к протоколу Hyper Text Coffee Pot Control Protocol, который в 1998 году был первоапрельской шуткой.</target>
        </trans-unit>
        <trans-unit id="b73eb36719efddb2bf307089114ca5c1ff83bc1f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; response code indicates the protocol the server is switching to as requested by a client which sent the message including the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">Код ответа HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; указывает на протокол, на который сервер переключается по запросу клиента, который отправил сообщение, включая заголовок запроса &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7eb48272f72778b0b684676d2f608817e02eb9f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the request has more than one possible responses. The user-agent or the user should choose one of them. As there is no standardized way of choosing one of the responses, this response code is very rarely used.</source>
          <target state="translated">Код ответа состояния перенаправления HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; указывает, что запрос имеет более одного возможных ответов. Пользовательский агент или пользователь должны выбрать один из них. Поскольку не существует стандартизированного способа выбора одного из ответов, этот код ответа используется очень редко.</target>
        </trans-unit>
        <trans-unit id="de334adf5ffab7d89b3c6e50513373cd0cee8cfc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; client redirection response code indicates that there is no need to retransmit the requested resources. It is an implicit redirection to a cached resource. This happens when the request method is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, like a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request, or when the request is conditional and uses a &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Код ответа перенаправления клиента HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; указывает, что нет необходимости повторно передавать запрошенные ресурсы. Это неявное перенаправление на кэшированный ресурс. Это происходит, когда метод запроса &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;безопасен&lt;/a&gt; , например &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; , или когда запрос является условным и использует заголовок &lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="341bb159a2216d99ce107781a967531062a1c137" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server can't find the requested resource. Links which lead to a 404 page are often called broken or dead links, and can be subject to &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;link rot&lt;/a&gt;.</source>
          <target state="translated">Код ответа клиента об ошибке HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; указывает, что сервер не может найти запрошенный ресурс. Ссылки, которые ведут на страницу 404, часто называют неработающими или мертвыми ссылками, и они могут быть подвержены &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;гниению ссылок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="963eb81b613d14e6431a53b19e1087de4815c917" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; response status code indicates a request conflict with current state of the server.</source>
          <target state="translated">Код состояния ответа HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; указывает на конфликт запроса с текущим состоянием сервера.</target>
        </trans-unit>
        <trans-unit id="1e620c227a6a0b266557df35d3c5635f4241af7c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request entity is larger than limits defined by server; the server might close the connection or return a &lt;a href=&quot;../headers/retry-after&quot;&gt;&lt;code&gt;Retry-After&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">Код состояния ответа HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; указывает на то, что объект запроса превышает пределы, определенные сервером; сервер может закрыть соединение или вернуть поле заголовка &lt;a href=&quot;../headers/retry-after&quot;&gt; &lt;code&gt;Retry-After&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84e2079297e778196c8c9ae50616e31cf6eb1ce4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; response status code indicates that the URI requested by the client is longer than the server is willing to interpret.</source>
          <target state="translated">Код состояния ответа HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; указывает, что URI, запрошенный клиентом, длиннее, чем сервер готов интерпретировать.</target>
        </trans-unit>
        <trans-unit id="fd260910ed4759c1378089671fbb6c0fbbb60660" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request because the payload format is in an unsupported format.</source>
          <target state="translated">Код ответа клиента об ошибке &amp;laquo; &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; HTTP &lt;strong&gt;415&lt;/strong&gt; указывает на то, что сервер отказывается принять запрос, поскольку формат полезной нагрузки находится в неподдерживаемом формате.</target>
        </trans-unit>
        <trans-unit id="fa970ac1d28b371bc4205e842d1c6d26ad5a73c4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.</source>
          <target state="translated">Код ответа клиента об ошибке HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; указывает на то, что сервер отказывается выполнять запрос с использованием текущего протокола, но может быть готов сделать это после того, как клиент перейдет на другой протокол.</target>
        </trans-unit>
        <trans-unit id="75aa3c74acfab1e106209fd4dd08b06e3054f27c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server requires the request to be &lt;a href=&quot;../conditional_requests&quot;&gt;conditional&lt;/a&gt;.</source>
          <target state="translated">Код состояния ответа HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; указывает, что сервер требует, чтобы запрос был &lt;a href=&quot;../conditional_requests&quot;&gt;условным&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="caa3bb3b92f0cfe33012b47986779e7f954a74b6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; response status code indicates the user has sent too many requests in a given amount of time (&quot;rate limiting&quot;).</source>
          <target state="translated">Код состояния ответа HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; указывает, что пользователь отправил слишком много запросов за заданный промежуток времени (&amp;laquo;ограничение скорости&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="04093cec2709dfaadbfa7527dc5c2ce1cd0b0646" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to process the request because its header fields are too large. The request may be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">Код состояния ответа HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; указывает на то, что сервер не желает обрабатывать запрос, поскольку его поля заголовка слишком велики. Запрос может быть отправлен повторно после уменьшения размера полей заголовка запроса.</target>
        </trans-unit>
        <trans-unit id="a9ddb3645327183c13becf845f54f56cdc4fdb5b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the client needs to authenticate to gain network access.</source>
          <target state="translated">Код состояния ответа HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; указывает, что клиенту необходимо пройти аутентификацию, чтобы получить доступ к сети.</target>
        </trans-unit>
        <trans-unit id="61ba4c1907f9a2e1f56de138ea9bcbb425c864e8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; response header sends reports of pinning violation to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header but, unlike &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; still allows browsers to connect to the server if the pinning is violated.</source>
          <target state="translated">Заголовок ответа HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; отправляет отчеты о нарушении закрепления в &lt;code&gt;report-uri&lt;/code&gt; указанный в заголовке, но, в отличие от &lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; ,по-&lt;/a&gt; прежнему позволяет браузерам подключаться к серверу, если закрепление нарушено.</target>
        </trans-unit>
        <trans-unit id="2f1aca0b8602a1b4269702669b5705705488252e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; response header associates a specific cryptographic public &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;key&lt;/a&gt; with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates. If one or several keys are pinned and none of them are used by the server, the browser will not accept the response as legitimate, and will not display it.</source>
          <target state="translated">Заголовок ответа HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; связывает конкретный криптографический открытый &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;ключ&lt;/a&gt; с определенным веб-сервером, чтобы снизить риск атак &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; с поддельными сертификатами. Если один или несколько ключей закреплены и ни один из них не используется сервером, браузер не примет ответ как законный и не отобразит его.</target>
        </trans-unit>
        <trans-unit id="cc17523ceced42a997fa4ec405b48542dc6da961" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent with a server, usually after the server has responded with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; status and the &lt;a href=&quot;www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Заголовок запроса HTTP- &lt;code&gt;Authorization&lt;/code&gt; содержит учетные данные для аутентификации пользовательского агента с сервером, обычно после того, как сервер ответил статусом &lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; и заголовком &lt;a href=&quot;www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eefae1a810c845c3fa68fd46660a1ab4ceaacda0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; response header allows web developers to experiment with policies by monitoring (but not enforcing) their effects. These violation reports consist of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; documents sent via an HTTP &lt;code&gt;POST&lt;/code&gt; request to the specified URI.</source>
          <target state="translated">Заголовок ответа HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; позволяет веб-разработчикам экспериментировать с политиками, отслеживая (но не применяя) их эффекты. Эти отчеты о нарушениях состоят из документов &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON,&lt;/a&gt; отправленных через HTTP- запрос &lt;code&gt;POST&lt;/code&gt; на указанный URI.</target>
        </trans-unit>
        <trans-unit id="1cedc9503c55c7df39812e0c200c391cb9852c4a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; response header allows web site administrators to control resources the user agent is allowed to load for a given page. With a few exceptions, policies mostly involve specifying server origins and script endpoints. This helps guard against cross-site scripting attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">Заголовок ответа HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; позволяет администраторам веб-сайтов контролировать ресурсы, которые пользовательский агент может загружать для данной страницы. За некоторыми исключениями, политики в основном включают указание источников сервера и конечных точек сценария. Это помогает защититься от атак с использованием межсайтовых сценариев ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1f93db0c2b1cae96ab8007915ebdc3aee6ae9b29" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; header provides a mechanism to allow and deny the use of browser features in its own frame, and in iframes that it embeds.</source>
          <target state="translated">Заголовок HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; предоставляет механизм, позволяющий разрешать и запрещать использование функций браузера в собственном фрейме и во встроенных фреймах.</target>
        </trans-unit>
        <trans-unit id="1ee6fbdaf32a73c5d2da4ea87e0ad9941527d763" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource behind a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt;. It authenticates the request to the proxy server, allowing it to transmit the request further.</source>
          <target state="translated">Заголовок ответа HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; определяет метод аутентификации, который следует использовать для получения доступа к ресурсу за &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;прокси-сервером&lt;/a&gt; . Он аутентифицирует запрос на прокси-сервере, позволяя ему передавать запрос дальше.</target>
        </trans-unit>
        <trans-unit id="d342efd1df2902182c9b47d04c0940ea25837a75" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent to a proxy server, usually after the server has responded with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt; status and the &lt;a href=&quot;proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Заголовок запроса HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; содержит учетные данные для аутентификации пользовательского агента на прокси-сервере, как правило, после того, как сервер ответил статусом &lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; и заголовком &lt;a href=&quot;proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06706a733035595c3ca09ed579f53668680fa83e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; request header sends a signal to the server expressing the client&amp;rsquo;s preference for an encrypted and authenticated response, and that it can successfully handle the &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;CSP&lt;/a&gt; directive.</source>
          <target state="translated">Заголовок запроса HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; отправляет сигнал на сервер, выражающий предпочтение клиента в отношении зашифрованного и аутентифицированного ответа и о том, что он может успешно обрабатывать директиву &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;CSP &lt;/a&gt;&lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f27fddd57d61b2e03f1c5514e09709028f9f0a9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource.</source>
          <target state="translated">Заголовок ответа HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; определяет метод аутентификации, который следует использовать для получения доступа к ресурсу.</target>
        </trans-unit>
        <trans-unit id="aeb81534f8cc6e53ddfa06e7cb5d6c8eaf9dba55" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; response header is a feature of Internet Explorer, Chrome and Safari that stops pages from loading when they detect reflected cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;) attacks. Although these protections are largely unnecessary in modern browsers when sites implement a strong &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; that disables the use of inline JavaScript (&lt;code&gt;'unsafe-inline'&lt;/code&gt;), they can still provide protections for users of older web browsers that don't yet support &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSP&lt;/a&gt;.</source>
          <target state="translated">Заголовок ответа HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; - это функция Internet Explorer, Chrome и Safari, которая останавливает загрузку страниц при обнаружении атак с использованием отраженных межсайтовых сценариев ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; ). Хотя в современных браузерах эти средства защиты в значительной степени не нужны, когда сайты реализуют строгую &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; которая отключает использование встроенного JavaScript ( &lt;code&gt;'unsafe-inline'&lt;/code&gt; ), они все же могут обеспечивать защиту для пользователей старых веб-браузеров, которые еще не поддержка &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a09546225cff6400570e0443b16e0c6e86472fe" translate="yes" xml:space="preserve">
          <source>The HTTP Strict Transport Security header informs the browser that it should never load a site using HTTP and should automatically convert all attempts to access the site using HTTP to HTTPS requests instead.</source>
          <target state="translated">Заголовок HTTP Strict Transport Security информирует браузер о том,что он никогда не должен загружать сайт с помощью HTTP и должен автоматически преобразовывать все попытки доступа к сайту с помощью HTTP в HTTPS запросы вместо этого.</target>
        </trans-unit>
        <trans-unit id="be8b00e9c8d5d272b2e1f90c102d59e067b32a0b" translate="yes" xml:space="preserve">
          <source>The HTTP URL namespace is a hierarchical namespace where the
   hierarchy is delimited with the &quot;/&quot; character.

   An HTTP URL namespace is said to be consistent if it meets the
   following conditions: for every URL in the HTTP hierarchy there
   exists a collection that contains that URL as an internal member URL.
   The root, or top-level collection of the namespace under
   consideration, is exempt from the previous rule.  The top-level
   collection of the namespace under consideration is not necessarily
   the collection identified by the absolute path '/' -- it may be
   identified by one or more path segments (e.g., /servlets/webdav/...)

   Neither HTTP/1.1 nor WebDAV requires that the entire HTTP URL
   namespace be consistent -- a WebDAV-compatible resource may not have
   a parent collection.  However, certain WebDAV methods are prohibited
   from producing results that cause namespace inconsistencies.

   As is implicit in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;], any resource, including
   collection resources, MAY be identified by more than one URI.  For
   example, a resource could be identified by multiple HTTP URLs.</source>
          <target state="translated">Пространство имен HTTP URL - это иерархическое пространство имен, в котором иерархия ограничена знаком &amp;laquo;/&amp;raquo;. Пространство имен URL-адресов HTTP считается согласованным, если оно соответствует следующим условиям: для каждого URL-адреса в иерархии HTTP существует коллекция, содержащая этот URL-адрес в качестве URL-адреса внутреннего члена. Корневая или верхняя коллекция рассматриваемого пространства имен освобождается от предыдущего правила. Коллекция верхнего уровня рассматриваемого пространства имен не обязательно является коллекцией, идентифицируемой абсолютным путем '/' - она ​​может быть идентифицирована одним или несколькими сегментами пути (например, / servlets / webdav / ...) Ни HTTP / 1.1, ни WebDAV не требует, чтобы все пространство имен URL-адресов HTTP было согласованным - ресурс, совместимый с WebDAV, может не иметь родительской коллекции. Тем не мение,Некоторым методам WebDAV запрещено давать результаты, вызывающие несогласованность пространств имен. Как подразумевается в [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] и [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ], любой ресурс, включая ресурсы сбора, МОЖЕТ быть идентифицирован более чем одним URI. Например, ресурс может быть идентифицирован несколькими URL-адресами HTTP.</target>
        </trans-unit>
        <trans-unit id="4fce77c17c83cf3b9166ab68262d46c09171eb1b" translate="yes" xml:space="preserve">
          <source>The HTTP authentication framework does not define a single mechanism
   for maintaining the confidentiality of credentials; instead, each
   authentication scheme defines how the credentials are encoded prior
   to transmission.  While this provides flexibility for the development
   of future authentication schemes, it is inadequate for the protection
   of existing schemes that provide no confidentiality on their own, or
   that do not sufficiently protect against replay attacks.
   Furthermore, if the server expects credentials that are specific to
   each individual user, the exchange of those credentials will have the
   effect of identifying that user even if the content within
   credentials remains confidential.

   HTTP depends on the security properties of the underlying transport-
   or session-level connection to provide confidential transmission of
   header fields.  In other words, if a server limits access to
   authenticated users using this framework, the server needs to ensure
   that the connection is properly secured in accordance with the nature
   of the authentication scheme used.  For example, services that depend
   on individual user authentication often require a connection to be
   secured with TLS (&quot;Transport Layer Security&quot;, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]) prior to
   exchanging any credentials.</source>
          <target state="translated">Структура HTTP-аутентификации не определяет единого механизма для поддержания конфиденциальности учетных данных; вместо этого каждая схема аутентификации определяет, как учетные данные кодируются перед передачей. Хотя это обеспечивает гибкость для разработки будущих схем аутентификации, этого недостаточно для защиты существующих схем, которые сами по себе не обеспечивают конфиденциальности или которые не обеспечивают достаточной защиты от атак повторного воспроизведения. Кроме того, если сервер ожидает учетные данные, специфичные для каждого отдельного пользователя, обмен этими учетными данными приведет к идентификации этого пользователя, даже если содержимое в учетных данных остается конфиденциальным.HTTP зависит от свойств безопасности базового соединения на уровне транспорта или сеанса, чтобы обеспечить конфиденциальную передачу полей заголовка. Другими словами, если сервер ограничивает доступ для аутентифицированных пользователей, использующих эту структуру, сервер должен гарантировать, что соединение должным образом защищено в соответствии с характером используемой схемы аутентификации. Например, службы, зависящие от аутентификации отдельного пользователя, часто требуют, чтобы соединение было защищено с помощью TLS (&amp;laquo;Безопасность транспортного уровня&amp;raquo;, [службы, зависящие от аутентификации отдельного пользователя, часто требуют, чтобы соединение было защищено с помощью TLS (&amp;laquo;Безопасность транспортного уровня&amp;raquo;, [службы, которые зависят от аутентификации отдельного пользователя, часто требуют, чтобы соединение было защищено с помощью TLS (&amp;laquo;Transport Layer Security&amp;raquo;, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt; ]) перед обменом учетными данными.</target>
        </trans-unit>
        <trans-unit id="d8d09b5015d287016b84da909b78b11d8d4463c3" translate="yes" xml:space="preserve">
          <source>The HTTP conditional request header fields [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;] allow a client
   to place a precondition on the state of the target resource, so that
   the action corresponding to the method semantics will not be applied
   if the precondition evaluates to false.  Each precondition defined by 

   this specification consists of a comparison between a set of
   validators obtained from prior representations of the target resource
   to the current state of validators for the selected representation
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;).  Hence, these preconditions evaluate whether the state
   of the target resource has changed since a given state known by the
   client.  The effect of such an evaluation depends on the method
   semantics and choice of conditional, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;Section&amp;nbsp;5 of
   [RFC7232]&lt;/a&gt;.

   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | If-Match            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC7232]&lt;/a&gt; |
   | If-None-Match       | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7232]&lt;/a&gt; |
   | If-Modified-Since   | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7232]&lt;/a&gt; |
   | If-Unmodified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;Section&amp;nbsp;3.4 of [RFC7232]&lt;/a&gt; |
   | If-Range            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt; |
   +---------------------+--------------------------+</source>
          <target state="translated">Поля заголовка условного запроса HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ] позволяют клиенту помещать предварительное условие в состояние целевого ресурса, так что действие, соответствующее семантике метода, не будет применяться, если предварительное условие оценивается как ложное. Каждое предварительное условие, определенное этой спецификацией, состоит из сравнения между набором валидаторов, полученных из предыдущих представлений целевого ресурса, с текущим состоянием валидаторов для выбранного представления ( &lt;a href=&quot;#section-7.2&quot;&gt;раздел 7.2&lt;/a&gt; ). Следовательно, эти предварительные условия оценивают, изменилось ли состояние целевого ресурса с данного состояния, известного клиенту. Эффект такой оценки зависит от семантики метода и выбора условия, как определено в&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;Раздел 5 [RFC7232]&lt;/a&gt; . + --------------------- + -------------------------- + | Имя поля заголовка | Определено в ... | + --------------------- + -------------------------- + | If-Match | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;Раздел 3.1 [RFC7232]&lt;/a&gt; | | Если-None-Match | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Раздел 3.2 [RFC7232]&lt;/a&gt; | | If-Modified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Раздел 3.3 [RFC7232]&lt;/a&gt; | | If-Unmodified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;Раздел 3.4 [RFC7232]&lt;/a&gt; | | Если-диапазон | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Раздел 3.2 [RFC7233]&lt;/a&gt; | + --------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="db5702e7098e5089b43ae75747b9b4a1f88a17e6" translate="yes" xml:space="preserve">
          <source>The HTTP method being used by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request is not included in the list of methods specified by the response's &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header. This header specifies a comma-delineated list of the HTTP methods which may be used when using CORS to access the URL specified in the request; if the request is using any other method, this error occurs.</source>
          <target state="translated">Метод HTTP, используемый запросом &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS,&lt;/a&gt; не включен в список методов, указанный в заголовке ответа &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; . Этот заголовок определяет разделенный запятыми список методов HTTP, которые могут использоваться при использовании CORS для доступа к URL-адресу, указанному в запросе; если запрос использует какой-либо другой метод, возникает эта ошибка.</target>
        </trans-unit>
        <trans-unit id="9a5f8b591cdf4b19c28a4fbbf2ef71bf29cedf58" translate="yes" xml:space="preserve">
          <source>The HTTP protocol is a request/response protocol. A client sends a
   request to the server in the form of a request method, URI, and
   protocol version, followed by a MIME-like message containing request
   modifiers, client information, and possible body content over a
   connection with a server. The server responds with a status line,
   including the message's protocol version and a success or error code,
   followed by a MIME-like message containing server information, entity
   metainformation, and possible entity-body content. The relationship
   between HTTP and MIME is described in appendix 19.4.

   Most HTTP communication is initiated by a user agent and consists of
   a request to be applied to a resource on some origin server. In the
   simplest case, this may be accomplished via a single connection (v)
   between the user agent (UA) and the origin server (O).

          request chain ------------------------&amp;gt;
       UA -------------------v------------------- O
          &amp;lt;----------------------- response chain

   A more complicated situation occurs when one or more intermediaries
   are present in the request/response chain. There are three common
   forms of intermediary: proxy, gateway, and tunnel. A proxy is a
   forwarding agent, receiving requests for a URI in its absolute form,
   rewriting all or part of the message, and forwarding the reformatted
   request toward the server identified by the URI. A gateway is a
   receiving agent, acting as a layer above some other server(s) and, if
   necessary, translating the requests to the underlying server's
   protocol. A tunnel acts as a relay point between two connections
   without changing the messages; tunnels are used when the
   communication needs to pass through an intermediary (such as a
   firewall) even when the intermediary cannot understand the contents
   of the messages.

          request chain --------------------------------------&amp;gt;
       UA -----v----- A -----v----- B -----v----- C -----v----- O
          &amp;lt;------------------------------------- response chain

   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server. A request or response message that
   travels the whole chain will pass through four separate connections.
   This distinction is important because some HTTP communication options 

   may apply only to the connection with the nearest, non-tunnel
   neighbor, only to the end-points of the chain, or to all connections
   along the chain. Although the diagram is linear, each participant may
   be engaged in multiple, simultaneous communications. For example, B
   may be receiving requests from many clients other than A, and/or
   forwarding requests to servers other than C, at the same time that it
   is handling A's request.

   Any party to the communication which is not acting as a tunnel may
   employ an internal cache for handling requests. The effect of a cache
   is that the request/response chain is shortened if one of the
   participants along the chain has a cached response applicable to that
   request. The following illustrates the resulting chain if B has a
   cached copy of an earlier response from O (via C) for a request which
   has not been cached by UA or A.

          request chain ----------&amp;gt;
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          &amp;lt;--------- response chain

   Not all responses are usefully cacheable, and some requests may
   contain modifiers which place special requirements on cache behavior.
   HTTP requirements for cache behavior and cacheable responses are
   defined in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   In fact, there are a wide variety of architectures and configurations
   of caches and proxies currently being experimented with or deployed
   across the World Wide Web. These systems include national hierarchies
   of proxy caches to save transoceanic bandwidth, systems that
   broadcast or multicast cache entries, organizations that distribute
   subsets of cached data via CD-ROM, and so on. HTTP systems are used
   in corporate intranets over high-bandwidth links, and for access via
   PDAs with low-power radio links and intermittent connectivity. The
   goal of HTTP/1.1 is to support the wide diversity of configurations
   already deployed while introducing protocol constructs that meet the
   needs of those who build web applications that require high
   reliability and, failing that, at least reliable indications of
   failure.

   HTTP communication usually takes place over TCP/IP connections. The
   default port is TCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;], but other ports can be used. This does
   not preclude HTTP from being implemented on top of any other protocol
   on the Internet, or on other networks. HTTP only presumes a reliable
   transport; any protocol that provides such guarantees can be used;
   the mapping of the HTTP/1.1 request and response structures onto the
   transport data units of the protocol in question is outside the scope
   of this specification. 

   In HTTP/1.0, most implementations used a new connection for each
   request/response exchange. In HTTP/1.1, a connection may be used for
   one or more request/response exchanges, although connections may be
   closed for a variety of reasons (see &lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;).</source>
          <target state="translated">Протокол HTTP - это протокол запроса / ответа. Клиент отправляет запрос на сервер в форме метода запроса, URI и версии протокола, за которым следует MIME-подобное сообщение, содержащее модификаторы запроса, информацию о клиенте и возможное содержимое тела через соединение с сервером. Сервер отвечает строкой состояния, включая версию протокола сообщения и код успеха или ошибки, за которым следует MIME-подобное сообщение, содержащее информацию о сервере, метаинформацию объекта и возможное содержимое тела объекта. Связь между HTTP и MIME описана в приложении 19.4. Большинство HTTP-коммуникаций инициируется пользовательским агентом и состоит из запроса, который должен быть применен к ресурсу на каком-либо исходном сервере. В простейшем случаеэто может быть выполнено через одно соединение (v) между пользовательским агентом (UA) и исходным сервером (O). цепочка запросов ------------------------&amp;gt; UA ------------------- v-- ----------------- O &amp;lt;----------------------- цепочка ответов Более сложная ситуация возникает, когда один или несколько посредников присутствуют в цепочке запросов / ответов. Существует три распространенных формы посредника: прокси, шлюз и туннель. Прокси-сервер - это агент пересылки, принимающий запросы на URI в его абсолютной форме, перезаписывающий все или часть сообщения и пересылающий переформатированный запрос на сервер, идентифицированный URI. Шлюз - это агент-получатель, который действует как уровень над некоторыми другими серверами и, при необходимости, транслирует запросы в протокол нижележащего сервера.Туннель действует как точка ретрансляции между двумя соединениями без изменения сообщений; Туннели используются, когда связь должна проходить через посредника (например, брандмауэр), даже если посредник не может понять содержимое сообщений. цепочка запросов --------------------------------------&amp;gt; UA ----- v-- --- A ----- v ----- B ----- v ----- C ----- v ----- O &amp;lt;--------- ---------------------------- Цепочка ответов На рисунке выше показаны три посредника (A, B и C) между пользовательским агентом и источником. сервер. Сообщение запроса или ответа, которое проходит по всей цепочке, проходит через четыре отдельных соединения. Это различие важно, потому что некоторые параметры связи HTTP могут применяться только к соединению с ближайшим соседом, не являющимся туннелем,только к конечным точкам цепочки или ко всем соединениям в цепочке. Хотя диаграмма является линейной, каждый участник может участвовать в нескольких одновременных коммуникациях. Например, B может получать запросы от многих клиентов, отличных от A, и / или пересылать запросы на серверы, отличные от C, в то же время, когда он обрабатывает запрос A. Любая сторона связи, которая не действует как туннель, может использовать внутренний кэш для обработки запросов. Эффект кеширования заключается в том, что цепочка запросов / ответов укорачивается, если один из участников цепочки имеет кэшированный ответ, применимый к этому запросу. Ниже показана результирующая цепочка, если у B есть кэшированная копия более раннего ответа от O (через C) на запрос, который не был кэширован UA или A.цепочка запросов ----------&amp;gt; UA ----- v ----- A ----- v ----- B - - - - - - C - - - - - - O &amp;lt;--------- цепочка ответов Не все ответы можно кэшировать, и некоторые запросы могут содержать модификаторы, которые предъявляют особые требования к поведению кеша. Требования HTTP для поведения кеша и кешируемых ответов определены в&lt;a href=&quot;#section-13&quot;&gt;Раздел 13&lt;/a&gt;, Фактически, существует большое количество разнообразных архитектур и конфигураций кэшей и прокси-серверов, с которыми в настоящее время проводятся эксперименты или развертываются во всемирной паутине. Эти системы включают национальные иерархии прокси-кэшей для сохранения трансокеанской полосы пропускания, системы, которые транслируют или многоадресные записи кэша, организации, которые распространяют подмножества кэшированных данных через CD-ROM, и так далее. Системы HTTP используются в корпоративных интрасетях по каналам с высокой пропускной способностью, а также для доступа через КПК с маломощными радиоканалами и с прерывистой связью. Целью HTTP / 1.1 является поддержка широкого разнообразия уже развернутых конфигураций, при этом вводятся конструкции протоколов, отвечающие потребностям тех, кто создает веб-приложения, требующие высокой надежности и, в противном случае, по крайней мере надежных индикаторов сбоя.Связь HTTP обычно происходит через соединения TCP / IP. Порт по умолчанию - TCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ], но можно использовать и другие порты. Это не препятствует реализации HTTP поверх любого другого протокола в Интернете или других сетях. HTTP предполагает только надежный транспорт; может использоваться любой протокол, который предоставляет такие гарантии; отображение структур запроса и ответа HTTP / 1.1 на транспортные блоки данных рассматриваемого протокола выходит за рамки данной спецификации. В HTTP / 1.0 большинство реализаций использовали новое соединение для каждого обмена запросом / ответом. В HTTP / 1.1 соединение может использоваться для одного или нескольких обменов запросом / ответом, хотя соединения могут быть закрыты по разным причинам (см. &lt;a href=&quot;#section-8.1&quot;&gt;Раздел 8.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="711fba1dbcca7b38687dec5dcf6d2cbe1d22690a" translate="yes" xml:space="preserve">
          <source>The HTTP protocol specifies a request method called &lt;a href=&quot;methods/connect&quot;&gt;&lt;code&gt;CONNECT&lt;/code&gt;&lt;/a&gt;. It starts two-way communications with the requested resource and can be used to open a tunnel. This is how a client behind an HTTP proxy can access websites using SSL (i.e. HTTPS, port 443). Note, however, that not all proxy servers support the &lt;code&gt;CONNECT&lt;/code&gt; method or limit it to port 443 only.</source>
          <target state="translated">Протокол HTTP определяет метод запроса, называемый &lt;a href=&quot;methods/connect&quot;&gt; &lt;code&gt;CONNECT&lt;/code&gt; &lt;/a&gt; . Он запускает двустороннюю связь с запрошенным ресурсом и может использоваться для открытия туннеля. Вот как клиент, находящийся за HTTP-прокси, может получить доступ к веб-сайтам с помощью SSL (например, HTTPS, порт 443). Обратите внимание, однако, что не все прокси-серверы поддерживают метод &lt;code&gt;CONNECT&lt;/code&gt; или ограничивают его только портом 443.</target>
        </trans-unit>
        <trans-unit id="a45670933a882d376a78839281d063695249e118" translate="yes" xml:space="preserve">
          <source>The HTTP protocol used in those early phases was very simple, later dubbed HTTP/0.9, and sometimes as the one-line protocol.</source>
          <target state="translated">Протокол HTTP,используемый на этих ранних этапах,был очень простым,позже получившим название HTTP/0.9,а иногда и однострочным протоколом.</target>
        </trans-unit>
        <trans-unit id="8b8c615279d732a85c03cf31a496dadc0ee7a1e0" translate="yes" xml:space="preserve">
          <source>The HTTP request headers</source>
          <target state="translated">Заголовки HTTP-запросов</target>
        </trans-unit>
        <trans-unit id="dc91001bcd5977c42287ce1ec14f986765b8a528" translate="yes" xml:space="preserve">
          <source>The HTTP response headers</source>
          <target state="translated">Заголовки ответа HTTP</target>
        </trans-unit>
        <trans-unit id="eb8587eac722cc07a0cd8556b058eb4e29c05d63" translate="yes" xml:space="preserve">
          <source>The HTTP status code of the resource on which the global object was instantiated.</source>
          <target state="translated">HTTP код статуса ресурса,на котором был инстанцирован глобальный объект.</target>
        </trans-unit>
        <trans-unit id="7642977e6ce54243574090f3f5103dcd8214c71f" translate="yes" xml:space="preserve">
          <source>The HTTP version used in the request is not supported by the server.</source>
          <target state="translated">Версия HTTP,используемая в запросе,не поддерживается сервером.</target>
        </trans-unit>
        <trans-unit id="0cf1515c8e62f4e6628b5f0c81397855080991ba" translate="yes" xml:space="preserve">
          <source>The HTTP/1.1 standard defines list of the standard headers that start server-driven negotiation (&lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;). Though strictly speaking &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; is not in this list, it is sometimes also used to send a specific representation of the requested resource, though this is not considered as a good practice. The server uses the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header to indicate which headers it actually used for content negotiation (or more precisely the associated response headers), so that &lt;a href=&quot;caching&quot;&gt;caches&lt;/a&gt; can work optimally.</source>
          <target state="translated">Стандарт HTTP / 1.1 определяет список стандартных заголовков, которые запускают согласование на сервере ( &lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; ). Хотя, строго говоря, &lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; отсутствует в этом списке, иногда он также используется для отправки определенного представления запрошенного ресурса, хотя это не считается хорошей практикой. Сервер использует заголовок &lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; ,&lt;/a&gt; чтобы указать, какие заголовки он фактически использовал для согласования содержимого (или, точнее, связанные заголовки ответов), чтобы &lt;a href=&quot;caching&quot;&gt;кеши&lt;/a&gt; могли работать оптимально.</target>
        </trans-unit>
        <trans-unit id="ed9884f0209355d73677c39f7ea1c603c1d343ae" translate="yes" xml:space="preserve">
          <source>The HTTP/2 binary framing mechanism has been designed to not require any alteration of the APIs or config files applied: it is broadly transparent to the user.</source>
          <target state="translated">Механизм бинарного фрейминга HTTP/2 был разработан таким образом,чтобы не требовать изменения применяемых API или конфигурационных файлов:он широко прозрачен для пользователя.</target>
        </trans-unit>
        <trans-unit id="dc2a35fa99cfd317dd5558de4b34fa07535768f1" translate="yes" xml:space="preserve">
          <source>The HTTP/2 protocol has several prime differences from the HTTP/1.1 version:</source>
          <target state="translated">Протокол HTTP/2 имеет несколько основных отличий от версии HTTP/1.1:</target>
        </trans-unit>
        <trans-unit id="99fbf8dd0978f7db7e2a91bcbd770cc0ec6b4bcd" translate="yes" xml:space="preserve">
          <source>The Host request-header field specifies the Internet host and port
   number of the resource being requested, as obtained from the original
   URI given by the user or referring resource (generally an HTTP URL, 

   as described in &lt;a href=&quot;#section-3.2.2&quot;&gt;section 3.2.2&lt;/a&gt;). The Host field value MUST represent
   the naming authority of the origin server or gateway given by the
   original URL. This allows the origin server or gateway to
   differentiate between internally-ambiguous URLs, such as the root &quot;/&quot;
   URL of a server for multiple host names on a single IP address.

       Host = &quot;Host&quot; &quot;:&quot; host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-3.2.2&quot;&gt;Section 3.2.2&lt;/a&gt;

   A &quot;host&quot; without any trailing port information implies the default
   port for the service requested (e.g., &quot;80&quot; for an HTTP URL). For
   example, a request on the origin server for
   &amp;lt;&lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;&amp;gt; would properly include:

       GET /pub/WWW/ HTTP/1.1
       Host: www.w3.org

   A client MUST include a Host header field in all HTTP/1.1 request
   messages . If the requested URI does not include an Internet host
   name for the service being requested, then the Host header field MUST
   be given with an empty value. An HTTP/1.1 proxy MUST ensure that any
   request message it forwards does contain an appropriate Host header
   field that identifies the service being requested by the proxy. All
   Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request)
   status code to any HTTP/1.1 request message which lacks a Host header
   field.

   See sections &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; and &lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt; for other requirements relating to
   Host.</source>
          <target state="translated">Поле заголовка запроса Host указывает Интернет-хост и номер порта запрашиваемого ресурса, полученный из исходного URI, предоставленного пользователем или ссылающимся ресурсом (обычно это URL HTTP, как описано в &lt;a href=&quot;#section-3.2.2&quot;&gt;разделе 3.2.2&lt;/a&gt; ). Значение поля Host ДОЛЖНО представлять полномочия по присвоению имен исходного сервера или шлюза, указанные в исходном URL. Это позволяет исходному серверу или шлюзу различать внутренне неоднозначные URL-адреса, такие как корневой URL-адрес &amp;laquo;/&amp;raquo; сервера для нескольких имен хостов на одном IP-адресе. Хост = &quot;Хост&quot; &quot;:&quot; хост [&quot;:&quot; порт]; &lt;a href=&quot;#section-3.2.2&quot;&gt;Раздел 3.2.2&lt;/a&gt; &amp;laquo;Хост&amp;raquo; без какой-либо информации о конечном порте подразумевает порт по умолчанию для запрошенной службы (например, &amp;laquo;80&amp;raquo; для URL-адреса HTTP). Например, запрос на исходном сервере для &amp;lt; &lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;&amp;gt; будет правильно включать: GET / pub / WWW / HTTP / 1.1 Host: www.w3.org Клиент ДОЛЖЕН включать поле заголовка Host во все сообщения запроса HTTP / 1.1. Если запрошенный URI не включает имя Интернет-хоста для запрашиваемой услуги, тогда в поле заголовка Host ДОЛЖНО быть указано пустое значение. Прокси-сервер HTTP / 1.1 ДОЛЖЕН гарантировать, что любое пересылаемое им сообщение запроса содержит соответствующее поле заголовка Host, которое идентифицирует услугу, запрашиваемую прокси-сервером. Все Интернет-серверы HTTP / 1.1 ДОЛЖНЫ отвечать кодом состояния 400 (неверный запрос) на любое сообщение запроса HTTP / 1.1, в котором отсутствует поле заголовка узла. См. Разделы &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; и &lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt; для других требований, относящихся к Хосту.</target>
        </trans-unit>
        <trans-unit id="3b1aa4a92939a94846182a9752d0647f06200784" translate="yes" xml:space="preserve">
          <source>The Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA)</source>
          <target state="translated">Протокол управления гипертекстовым кофейником для чайных аппаратов (HTCPCP-TEA).</target>
        </trans-unit>
        <trans-unit id="6fa10aaa19ccd9183c515b022dab356e9181ff7f" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request has been received but not yet acted upon. It is non-committal, meaning that there is no way for the HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">Код состояния ответа &quot; &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; ответ&quot; протокола передачи гипертекста (HTTP) &lt;strong&gt;202&lt;/strong&gt; указывает, что запрос был получен, но еще не обработан. Это не является обязательным, что означает, что HTTP не может позже отправить асинхронный ответ, указывающий на результат обработки запроса. Он предназначен для случаев, когда другой процесс или сервер обрабатывает запрос, или для пакетной обработки.</target>
        </trans-unit>
        <trans-unit id="8da2e56e0326733411c384ee9df3d066f1be28c3" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; redirect status response code указывает, что запрошенный ресурс был окончательно перемещен на URL-адрес, указанный в заголовках &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; . Браузер перенаправляет на эту страницу, и поисковые системы обновляют свои ссылки на ресурс (в &amp;laquo;SEO-слове&amp;raquo; говорится, что &amp;laquo;сок ссылки&amp;raquo; отправляется на новый URL).</target>
        </trans-unit>
        <trans-unit id="bca235dd87a759f1a9dd3bfa9203b6546d063663" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been temporarily moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header. A browser redirects to this page but search engines don't update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is not sent to the new URL).</source>
          <target state="translated">Код ответа состояния переадресации &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; по протоколу передачи гипертекста (HTTP) указывает, что запрошенный ресурс был временно перемещен по URL-адресу, указанному в заголовке &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; . Браузер перенаправляет на эту страницу, но поисковые системы не обновляют свои ссылки на ресурс (в &amp;laquo;SEO-терминологии&amp;raquo; говорится, что &amp;laquo;сок ссылки&amp;raquo; не отправляется на новый URL).</target>
        </trans-unit>
        <trans-unit id="a0dc42b9614cba52b23ba38ea15b1e9d7488ecb2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the redirects don't link to the newly uploaded resources but to another page, like a confirmation page or an upload progress page. This response code is usually sent back as a result of &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;. The method used to display this redirected page is always &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; код ответа состояния перенаправления указывает, что перенаправления ссылаются не на вновь загруженные ресурсы, а на другую страницу, например страницу подтверждения или страницу выполнения загрузки. Этот код ответа обычно отправляется обратно в результате &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; . Для отображения этой перенаправленной страницы всегда используется метод &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3108347112af1e3d29e6704655c39459a5034ad0" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">Код ответа статуса перенаправления &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; протокола передачи гипертекста (HTTP) &lt;strong&gt;308&lt;/strong&gt; указывает, что запрошенный ресурс был окончательно перемещен по URL-адресу, указанному в заголовках &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; . Браузер перенаправляет на эту страницу, и поисковые системы обновляют свои ссылки на ресурс (в &amp;laquo;SEO-слове&amp;raquo; говорится, что &amp;laquo;сок ссылки&amp;raquo; отправляется на новый URL).</target>
        </trans-unit>
        <trans-unit id="2055230dbe836c1aaf7bd92cbe0fa85f1440c7fc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server could not understand the request due to invalid syntax.</source>
          <target state="translated">Код состояния ответа &amp;laquo; &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; протокола передачи гипертекста (HTTP) &lt;strong&gt;400&lt;/strong&gt; указывает на то, что сервер не может понять запрос из-за недопустимого синтаксиса.</target>
        </trans-unit>
        <trans-unit id="15ac14cd04fa900b118bba5f014d31ab3bbfe121" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request method is known by the server but is not supported by the target resource.</source>
          <target state="translated">Код состояния ответа &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; протокола передачи гипертекста (HTTP) указывает, что метод запроса известен серверу, но не поддерживается целевым ресурсом.</target>
        </trans-unit>
        <trans-unit id="60871008192002b75675780fc635a2b570a2bf8c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server cannot produce a response matching the list of acceptable values defined in the request's proactive &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; headers, and that the server is unwilling to supply a default representation.</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; client error code response code указывает, что сервер не может создать ответ, соответствующий списку допустимых значений, определенному в заголовках упреждающего &lt;a href=&quot;../content_negotiation&quot;&gt;согласования содержимого&lt;/a&gt; запроса , и что сервер не желает предоставлять представление по умолчанию.</target>
        </trans-unit>
        <trans-unit id="6d70feb7e34e129ebc5526b0c592e1fdbf1c816e" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; response status code means that the server would like to shut down this unused connection. It is sent on an idle connection by some servers, &lt;em&gt;even without any previous request by the client&lt;/em&gt;.</source>
          <target state="translated">Код состояния ответа &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; протокола передачи гипертекста (HTTP) означает, что сервер хотел бы закрыть это неиспользуемое соединение. Некоторые серверы отправляют его при неактивном соединении, &lt;em&gt;даже без предварительного запроса клиента&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a66fb4f3fae8e6c063276dcb5237ee845eeca4ed" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent.</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; клиентского кода ответа на ошибку указывает, что доступ к целевому ресурсу больше не доступен на исходном сервере и что это состояние, вероятно, будет постоянным.</target>
        </trans-unit>
        <trans-unit id="4b9a35e682079b0a683f989a76db71ce57aae81d" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request without a defined &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Код ответа клиента на ошибку &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; протокола передачи гипертекста (HTTP) указывает, что сервер отказывается принять запрос без определенного заголовка &lt;a href=&quot;../headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="731510b854954129731e069eb6b3d2e9019b2fdc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource has been denied. This happens with conditional requests on methods other than &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; when the condition defined by the &lt;a href=&quot;../headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; headers is not fulfilled. In that case, the request, usually an upload or a modification of a resource, cannot be made and this error response is sent back.</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; client error response code указывает, что доступ к целевому ресурсу был запрещен. Это происходит с условными запросами к методам, отличным от &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; ,&lt;/a&gt; когда условие, определенное заголовками &lt;a href=&quot;../headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; ,&lt;/a&gt; не выполняется. В этом случае запрос, обычно загрузка или изменение ресурса, не может быть выполнен, и этот ответ об ошибке отправляется обратно.</target>
        </trans-unit>
        <trans-unit id="95dad23f3e8d87cfe4b0b1791422ccff7fdb0ec9" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; error response code indicates that a server cannot serve the requested ranges. The most likely reason is that the document doesn't contain such ranges, or that the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header value, though syntactically correct, doesn't make sense.</source>
          <target state="translated">Код ответа об ошибке протокола передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; указывает, что сервер не может обслуживать запрошенные диапазоны. Наиболее вероятная причина заключается в том, что документ не содержит таких диапазонов или что значение заголовка &lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; , хотя и синтаксически правильное, не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="99f1059b5dc6332a65c7949a31d1b45cbce33ed7" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server understands the content type of the request entity, and the syntax of the request entity is correct, but it was unable to process the contained instructions.</source>
          <target state="translated">Код состояния ответа &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; протокола передачи гипертекста (HTTP) указывает, что сервер понимает тип контента сущности запроса и синтаксис сущности запроса правильный, но он не смог обработать содержащиеся инструкции.</target>
        </trans-unit>
        <trans-unit id="630618c062b0adb0b4e53d21c6ec93a1ffc8709b" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to risk processing a request that might be replayed, which creates the potential for a replay attack.</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; код состояния ответа указывает, что сервер не желает рисковать обработкой запроса, который может быть воспроизведен, что создает возможность для атаки повторного воспроизведения.</target>
        </trans-unit>
        <trans-unit id="2ba79c25bd016d25902460c531a9af1832ad5084" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the user requested a resource that is not available due to legal reasons, such as a web page for which a legal action has been issued.</source>
          <target state="translated">Код ответа об ошибке клиента протокола передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; указывает на то, что пользователь запросил ресурс, который недоступен по юридическим причинам, например веб-страницу, в отношении которой был возбужден судебный иск.</target>
        </trans-unit>
        <trans-unit id="b137e360e4b5274b152a6bc5424bdda215ece645" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.</source>
          <target state="translated">Код ответа сервера на &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; сервера HyperText Transfer Protocol (HTTP) &lt;strong&gt;500&lt;/strong&gt; указывает на то, что сервер обнаружил непредвиденное условие, которое не позволило ему выполнить запрос.</target>
        </trans-unit>
        <trans-unit id="9c744578cdc0d9bb57ba2e4e4ab0fa07c99379e2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Код ответа сервера с ошибкой &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; протоколу передачи гипертекста (HTTP) указывает, что метод запроса не поддерживается сервером и не может быть обработан. Единственные методы, которые серверы должны поддерживать (и, следовательно, не должны возвращать этот код), - это &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c56e521d7943d1bf8ac9d8be1e1d2c5a9c11ad29" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, received an invalid response from the upstream server.</source>
          <target state="translated">Код ответа на ошибку сервера &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; по протоколу передачи гипертекста (HTTP) указывает, что сервер, выступая в качестве шлюза или прокси-сервера, получил недопустимый ответ от вышестоящего сервера.</target>
        </trans-unit>
        <trans-unit id="d97095b9bce2f7dabb2319cf5e31ce5cd055c7fe" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server is not ready to handle the request.</source>
          <target state="translated">Код ответа сервера протокола передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; указывает на то, что сервер не готов обработать запрос.</target>
        </trans-unit>
        <trans-unit id="ed70120131ebb0a274691c4d30386f6dc8fc669c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, cannot get a response in time.</source>
          <target state="translated">Код ответа на ошибку сервера протокола передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; указывает на то, что сервер, действуя как шлюз или прокси, не может получить ответ вовремя.</target>
        </trans-unit>
        <trans-unit id="5206e7fbe439a4fe0558730cbd561b9d56ad71ad" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; response status code indicates that the HTTP version used in the request is not supported by the server.</source>
          <target state="translated">Код состояния ответа протокола передачи гипертекста (HTTP) &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; указывает, что версия HTTP, используемая в запросе, не поддерживается сервером.</target>
        </trans-unit>
        <trans-unit id="2e3eb482b38eeaa5e40d4ddbab8b13b92a13f7fd" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level request/response protocol that uses extensible semantics and
   self-descriptive message payloads for flexible interaction with
   network-based hypertext information systems.  This document is the
   first in a series of documents that collectively form the HTTP/1.1
   specification:

   1.  &quot;Message Syntax and Routing&quot; (this document)

   2.  &quot;Semantics and Content&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]

   3.  &quot;Conditional Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]

   4.  &quot;Range Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]

   5.  &quot;Caching&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]

   6.  &quot;Authentication&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;]

   This HTTP/1.1 specification obsoletes &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; (on HTTP
   versioning).  This specification also updates the use of CONNECT to
   establish a tunnel, previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;, and defines the
   &quot;https&quot; URI scheme that was described informally in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;.

   HTTP is a generic interface protocol for information systems.  It is
   designed to hide the details of how a service is implemented by
   presenting a uniform interface to clients that is independent of the
   types of resources provided.  Likewise, servers do not need to be
   aware of each client's purpose: an HTTP request can be considered in
   isolation rather than being associated with a specific type of client
   or a predetermined sequence of application steps.  The result is a
   protocol that can be used effectively in many different contexts and
   for which implementations can evolve independently over time.

   HTTP is also designed for use as an intermediation protocol for
   translating communication to and from non-HTTP information systems.
   HTTP proxies and gateways can provide access to alternative
   information services by translating their diverse protocols into a
   hypertext format that can be viewed and manipulated by clients in the
   same way as HTTP services.

   One consequence of this flexibility is that the protocol cannot be
   defined in terms of what occurs behind the interface.  Instead, we
   are limited to defining the syntax of communication, the intent of
   received communication, and the expected behavior of recipients.  If
   the communication is considered in isolation, then successful actions 

   ought to be reflected in corresponding changes to the observable
   interface provided by servers.  However, since multiple clients might
   act in parallel and perhaps at cross-purposes, we cannot require that
   such changes be observable beyond the scope of a single response.

   This document describes the architectural elements that are used or
   referred to in HTTP, defines the &quot;http&quot; and &quot;https&quot; URI schemes,
   describes overall network operation and connection management, and
   defines HTTP message framing and forwarding requirements.  Our goal
   is to define all of the mechanisms necessary for HTTP message
   handling that are independent of message semantics, thereby defining
   the complete set of requirements for message parsers and message-
   forwarding intermediaries.</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) - это протокол запроса / ответа уровня приложения без сохранения состояния, который использует расширяемую семантику и полезные данные самоописательных сообщений для гибкого взаимодействия с сетевыми гипертекстовыми информационными системами. Этот документ является первым в серии документов, которые вместе составляют спецификацию HTTP / 1.1: 1. &amp;laquo;Синтаксис сообщений и маршрутизация&amp;raquo; (этот документ) 2. &amp;laquo;Семантика и контент&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 3. &amp;laquo;Условные запросы&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ] 4. &amp;laquo;Запросы диапазона&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ] 5. &amp;laquo;Кэширование&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ] 6. &amp;laquo;Аутентификация&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ] Это HTTP / 1.1 спецификация устарела &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; и &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;(при управлении версиями HTTP). Эта спецификация также обновляет использование CONNECT для установления туннеля, ранее определенное в &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt; , и определяет схему URI &amp;laquo;https&amp;raquo;, которая неформально описана в &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818.&lt;/a&gt;, HTTP - это общий протокол интерфейса для информационных систем. Он разработан, чтобы скрыть детали того, как реализована служба, путем предоставления клиентам единого интерфейса, который не зависит от типов предоставляемых ресурсов. Точно так же серверам не нужно знать цель каждого клиента: HTTP-запрос можно рассматривать изолированно, а не связывать его с конкретным типом клиента или заранее определенной последовательностью шагов приложения. Результатом является протокол, который можно эффективно использовать во многих различных контекстах, и реализации которого могут развиваться независимо с течением времени. HTTP также разработан для использования в качестве протокола-посредника для передачи сообщений в информационные системы, отличные от HTTP, и обратно.Прокси-серверы и шлюзы HTTP могут предоставлять доступ к альтернативным информационным службам, переводя их различные протоколы в гипертекстовый формат, который клиенты могут просматривать и управлять ими так же, как и службы HTTP. Одним из следствий этой гибкости является то, что протокол не может быть определен в терминах того, что происходит за интерфейсом. Вместо этого мы ограничены определением синтаксиса общения, цели полученного сообщения и ожидаемого поведения получателей. Если связь рассматривается изолированно, то успешные действия должны отражаться в соответствующих изменениях наблюдаемого интерфейса, предоставляемого серверами. Однако, поскольку несколько клиентов могут действовать параллельно и, возможно, в разных целях,мы не можем требовать, чтобы такие изменения наблюдались вне рамок единственного ответа. Этот документ описывает архитектурные элементы, которые используются или упоминаются в HTTP, определяет схемы URI &amp;laquo;http&amp;raquo; и &amp;laquo;https&amp;raquo;, описывает общую работу сети и управление соединением, а также определяет требования к кадрированию и пересылке сообщений HTTP. Наша цель - определить все механизмы, необходимые для обработки сообщений HTTP, которые не зависят от семантики сообщения, тем самым определяя полный набор требований к анализаторам сообщений и посредникам для пересылки сообщений.описывает общую работу сети и управление соединениями, а также определяет требования к кадрированию и пересылке HTTP-сообщений. Наша цель - определить все механизмы, необходимые для обработки сообщений HTTP, которые не зависят от семантики сообщения, тем самым определяя полный набор требований к анализаторам сообщений и посредникам для пересылки сообщений.описывает общую работу сети и управление соединениями, а также определяет требования к кадрированию и пересылке HTTP-сообщений. Наша цель - определить все механизмы, необходимые для обработки сообщений HTTP, которые не зависят от семантики сообщения, тем самым определяя полный набор требований к анализаторам сообщений и посредникам, пересылающим сообщения.</target>
        </trans-unit>
        <trans-unit id="bfba6f949d10bf9871b3c465a4b0c721c894d894" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. HTTP has been in use by the World-Wide Web global
   information initiative since 1990. The first version of HTTP,
   referred to as HTTP/0.9, was a simple protocol for raw data transfer
   across the Internet. HTTP/1.0, as defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; [&lt;a href=&quot;#ref-6&quot;&gt;6&lt;/a&gt;], improved
   the protocol by allowing messages to be in the format of MIME-like
   messages, containing metainformation about the data transferred and
   modifiers on the request/response semantics. However, HTTP/1.0 does
   not sufficiently take into consideration the effects of hierarchical
   proxies, caching, the need for persistent connections, or virtual
   hosts. In addition, the proliferation of incompletely-implemented
   applications calling themselves &quot;HTTP/1.0&quot; has necessitated a
   protocol version change in order for two communicating applications
   to determine each other's true capabilities.

   This specification defines the protocol referred to as &quot;HTTP/1.1&quot;.
   This protocol includes more stringent requirements than HTTP/1.0 in
   order to ensure reliable implementation of its features.

   Practical information systems require more functionality than simple
   retrieval, including search, front-end update, and annotation. HTTP
   allows an open-ended set of methods and headers that indicate the
   purpose of a request [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt;]. It builds on the discipline of reference
   provided by the Uniform Resource Identifier (URI) [&lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt;], as a location
   (URL) [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] or name (URN) [&lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt;], for indicating the resource to which a 

   method is to be applied. Messages are passed in a format similar to
   that used by Internet mail [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as defined by the Multipurpose
   Internet Mail Extensions (MIME) [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;].

   HTTP is also used as a generic protocol for communication between
   user agents and proxies/gateways to other Internet systems, including
   those supported by the SMTP [&lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt;], NNTP [&lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt;], FTP [&lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt;], Gopher [&lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt;],
   and WAIS [&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt;] protocols. In this way, HTTP allows basic hypermedia
   access to resources available from diverse applications.</source>
          <target state="translated">Протокол передачи гипертекста (HTTP) - это протокол прикладного уровня для распределенных, совместных гипермедийных информационных систем. HTTP используется глобальной информационной инициативой World-Wide Web с 1990 года. Первая версия HTTP, называемая HTTP / 0.9, была простым протоколом для передачи необработанных данных через Интернет. HTTP / 1.0, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; [ &lt;a href=&quot;#ref-6&quot;&gt;6&lt;/a&gt;], улучшил протокол, позволив сообщениям быть в формате MIME-подобных сообщений, содержащих метаинформацию о передаваемых данных и модификаторы семантики запроса / ответа. Однако HTTP / 1.0 недостаточно учитывает влияние иерархических прокси, кэширования, необходимости постоянных подключений или виртуальных хостов. Кроме того, распространение не полностью реализованных приложений, называющих себя &amp;laquo;HTTP / 1.0&amp;raquo;, потребовало изменения версии протокола, чтобы два взаимодействующих приложения могли определять истинные возможности друг друга. Эта спецификация определяет протокол, называемый &amp;laquo;HTTP / 1.1&amp;raquo;. Этот протокол включает более строгие требования, чем HTTP / 1.0, для обеспечения надежной реализации его функций.Практические информационные системы требуют большей функциональности, чем простой поиск, включая поиск, обновление интерфейса и аннотации. HTTP позволяет использовать открытый набор методов и заголовков, которые указывают цель запроса [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt; ]. Он основан на дисциплине ссылки, обеспечиваемой унифицированным идентификатором ресурса (URI) [ &lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt; ] в виде местоположения (URL) [ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ] или имени (URN) [ &lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt; ], для указания ресурса, к которому должен применяться метод. , Сообщения передаются в формате, аналогичном формату, используемому почтой Интернета [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ], как определено в многоцелевых расширениях электронной почты Интернета (MIME) [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]. HTTP также используется как общий протокол для связи между пользовательскими агентами и прокси / шлюзами с другими системами Интернета, включая те, которые поддерживаются SMTP [ &lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt; ], NNTP [ &lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt; ], FTP [ &lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt; ], Gopher [ &lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt; ] и WAIS [&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt; ] протоколы. Таким образом, HTTP обеспечивает базовый доступ гипермедиа к ресурсам, доступным из различных приложений.</target>
        </trans-unit>
        <trans-unit id="1a129c42494254f3f39028a252991104523d52ce" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol Status Code 308 (Permanent Redirect)</source>
          <target state="translated">Статус протокола гипертекстовой передачи Код 308 (постоянная переадресация)</target>
        </trans-unit>
        <trans-unit id="2f67a1bb61a74c01a68383ec9ae389f39adb9d3d" translate="yes" xml:space="preserve">
          <source>The If header has two distinct purposes:

   o  The first purpose is to make a request conditional by supplying a
      series of state lists with conditions that match tokens and ETags
      to a specific resource.  If this header is evaluated and all state
      lists fail, then the request MUST fail with a 412 (Precondition
      Failed) status.  On the other hand, the request can succeed only
      if one of the described state lists succeeds.  The success
      criteria for state lists and matching functions are defined in
      Sections &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; and &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;.

   o  Additionally, the mere fact that a state token appears in an If
      header means that it has been &quot;submitted&quot; with the request.  In
      general, this is used to indicate that the client has knowledge of
      that state token.  The semantics for submitting a state token
      depend on its type (for lock tokens, please refer to &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).

   Note that these two purposes need to be treated distinctly: a state
   token counts as being submitted independently of whether the server
   actually has evaluated the state list it appears in, and also
   independently of whether or not the condition it expressed was found
   to be true.</source>
          <target state="translated">Заголовок If имеет две различные цели: o Первая цель - сделать запрос условным, предоставив серию списков состояний с условиями, которые соответствуют токенам и тегам ETag для определенного ресурса. Если этот заголовок оценивается и все списки состояний терпят неудачу, то запрос ДОЛЖЕН завершиться неудачей со статусом 412 (Precondition Failed). С другой стороны, запрос может быть успешным только в случае успешного выполнения одного из описанных списков состояний. Критерии успеха для списков состояний и функций сопоставления определены в разделах &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; и &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4.&lt;/a&gt;, o Кроме того, тот факт, что маркер состояния появляется в заголовке If, означает, что он был &amp;laquo;отправлен&amp;raquo; вместе с запросом. Обычно это используется, чтобы указать, что клиент знает этот токен состояния. Семантика отправки токена состояния зависит от его типа (токены блокировки см. В &lt;a href=&quot;#section-6&quot;&gt;разделе 6&lt;/a&gt; ). Обратите внимание, что эти две цели необходимо рассматривать отдельно: маркер состояния считается отправленным независимо от того, действительно ли сервер оценил список состояний, в котором он отображается, а также независимо от того, было ли обнаружено, что условие, которое он выражает, истинным.</target>
        </trans-unit>
        <trans-unit id="ef772a237bb19f58e37ac6262a206108449c06a7" translate="yes" xml:space="preserve">
          <source>The If request header is intended to have similar functionality to
   the If-Match header defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;Section&amp;nbsp;14.24 of [RFC2616]&lt;/a&gt;.  However,
   the If header handles any state token as well as ETags.  A typical
   example of a state token is a lock token, and lock tokens are the
   only state tokens defined in this specification.</source>
          <target state="translated">Заголовок запроса If должен иметь функциональность, аналогичную заголовку If-Match, определенному в &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;разделе 14.24 [RFC2616]&lt;/a&gt; . Однако заголовок If обрабатывает любой токен состояния, а также теги ETag. Типичным примером токена состояния является токен блокировки, и токены блокировки являются единственными токенами состояния, определенными в этой спецификации.</target>
        </trans-unit>
        <trans-unit id="f13702c8c2a26258beb9827d9b24d567b0373ca0" translate="yes" xml:space="preserve">
          <source>The If-Match request-header field is used with a method to make it
   conditional. A client that has one or more entities previously
   obtained from the resource can verify that one of those entities is
   current by including a list of their associated entity tags in the
   If-Match header field. Entity tags are defined in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The
   purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead. It is also
   used, on updating requests, to prevent inadvertent modification of
   the wrong version of a resource. As a special case, the value &quot;*&quot;
   matches any current entity of the resource.

       If-Match = &quot;If-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-Match header) on that resource, or if &quot;*&quot; is given 

   and any current entity exists for that resource, then the server MAY
   perform the requested method as if the If-Match header field did not
   exist.

   A server MUST use the strong comparison function (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;)
   to compare the entity tags in If-Match.

   If none of the entity tags match, or if &quot;*&quot; is given and no current
   entity exists, the server MUST NOT perform the requested method, and
   MUST return a 412 (Precondition Failed) response. This behavior is
   most useful when the client wants to prevent an updating method, such
   as PUT, from modifying a resource that has changed since the client
   last retrieved it.

   If the request would, without the If-Match header field, result in
   anything other than a 2xx or 412 status, then the If-Match header
   MUST be ignored.

   The meaning of &quot;If-Match: *&quot; is that the method SHOULD be performed
   if the representation selected by the origin server (or by a cache,
   possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;) exists, and
   MUST NOT be performed if the representation does not exist.

   A request intended to update a resource (e.g., a PUT) MAY include an
   If-Match header field to signal that the request method MUST NOT be
   applied if the entity corresponding to the If-Match value (a single
   entity tag) is no longer a representation of that resource. This
   allows the user to indicate that they do not wish the request to be
   successful if the resource has been changed without their knowledge.
   Examples:

       If-Match: &quot;xyzzy&quot;
       If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-Match: *

   The result of a request having both an If-Match header field and
   either an If-None-Match or an If-Modified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">Поле заголовка запроса If-Match используется с методом, чтобы сделать его условным. Клиент, у которого есть одна или несколько сущностей, ранее полученных из ресурса, может проверить, что одна из этих сущностей является текущей, включив список связанных с ними тегов сущностей в поле заголовка If-Match. Теги сущностей определены в &lt;a href=&quot;#section-3.11&quot;&gt;разделе 3.11.&lt;/a&gt;, Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Он также используется при обновлении запросов, чтобы предотвратить непреднамеренное изменение неправильной версии ресурса. В качестве особого случая значение &amp;laquo;*&amp;raquo; соответствует любой текущей сущности ресурса. If-Match = &quot;If-Match&quot; &quot;:&quot; (&quot;*&quot; | 1 # entity-tag) Если какой-либо из тегов объекта соответствует тегу объекта объекта, который был бы возвращен в ответе на аналогичный запрос GET ( без заголовка If-Match) на этом ресурсе, или если задан &quot;*&quot; и для этого ресурса существует какой-либо текущий объект, то сервер МОЖЕТ выполнить запрошенный метод, как если бы поле заголовка If-Match не существовало.Сервер ДОЛЖЕН использовать функцию &lt;a href=&quot;#section-13.3.3&quot;&gt;строгого сравнения (см. Раздел 13.3.3.&lt;/a&gt;) для сравнения тегов сущностей в If-Match. Если ни один из тегов объекта не совпадает, или если дан &quot;*&quot; и текущий объект не существует, сервер НЕ ДОЛЖЕН выполнять запрошенный метод и ДОЛЖЕН возвращать ответ 412 (Precondition Failed). Это поведение наиболее полезно, когда клиент хочет запретить методу обновления, например PUT, изменять ресурс, который изменился с момента его последнего получения клиентом. Если запрос без поля заголовка If-Match приведет к чему-либо, кроме статуса 2xx или 412, то заголовок If-Match ДОЛЖЕН игнорироваться. Значение &amp;laquo;If-Match: *&amp;raquo; состоит в том, что метод ДОЛЖЕН выполняться, если представление, выбранное исходным сервером (или кешем, возможно с использованием механизма Vary, см. &lt;a href=&quot;#section-14.44&quot;&gt;Раздел 14.44).&lt;/a&gt;) существует и НЕ ДОЛЖЕН выполняться, если представление не существует. Запрос, предназначенный для обновления ресурса (например, PUT), МОЖЕТ включать поле заголовка If-Match, чтобы сигнализировать, что метод запроса НЕ ДОЛЖЕН применяться, если объект, соответствующий значению If-Match (одиночный тег объекта), больше не представление этого ресурса. Это позволяет пользователю указать, что он не хочет, чтобы запрос был успешным, если ресурс был изменен без его ведома. Примеры: If-Match: &quot;xyzzy&quot; If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot; If-Match: * Результат запроса, имеющего как поле заголовка If-Match, так и либо If-None-Match или поля заголовка If-Modified-Since не определены этой спецификацией.</target>
        </trans-unit>
        <trans-unit id="9436a493b897cd39a84206566701a405b2d51016" translate="yes" xml:space="preserve">
          <source>The If-Modified-Since request-header field is used with a method to
   make it conditional: if the requested variant has not been modified
   since the time specified in this field, an entity will not be
   returned from the server; instead, a 304 (not modified) response will
   be returned without any message-body.

       If-Modified-Since = &quot;If-Modified-Since&quot; &quot;:&quot; HTTP-date 

   An example of the field is:

       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A GET method with an If-Modified-Since header and no Range header
   requests that the identified entity be transferred only if it has
   been modified since the date given by the If-Modified-Since header.
   The algorithm for determining this includes the following cases:

      a) If the request would normally result in anything other than a
         200 (OK) status, or if the passed If-Modified-Since date is
         invalid, the response is exactly the same as for a normal GET.
         A date which is later than the server's current time is
         invalid.

      b) If the variant has been modified since the If-Modified-Since
         date, the response is exactly the same as for a normal GET.

      c) If the variant has not been modified since a valid If-
         Modified-Since date, the server SHOULD return a 304 (Not
         Modified) response.

   The purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead.

      Note: The Range request-header field modifies the meaning of If-
      Modified-Since; see &lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt; for full details.

      Note: If-Modified-Since times are interpreted by the server, whose
      clock might not be synchronized with the client.

      Note: When handling an If-Modified-Since header field, some
      servers will use an exact date comparison function, rather than a
      less-than function, for deciding whether to send a 304 (Not
      Modified) response. To get best results when sending an If-
      Modified-Since header field for cache validation, clients are
      advised to use the exact date string received in a previous Last-
      Modified header field whenever possible.

      Note: If a client uses an arbitrary date in the If-Modified-Since
      header instead of a date taken from the Last-Modified header for
      the same request, the client should be aware of the fact that this
      date is interpreted in the server's understanding of time. The
      client should consider unsynchronized clocks and rounding problems
      due to the different encodings of time between the client and
      server. This includes the possibility of race conditions if the
      document has changed between the time it was first requested and
      the If-Modified-Since date of a subsequent request, and the 

      possibility of clock-skew-related problems if the If-Modified-
      Since date is derived from the client's clock without correction
      to the server's clock. Corrections for different time bases
      between client and server are at best approximate due to network
      latency.

   The result of a request having both an If-Modified-Since header field
   and either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">Поле заголовка запроса If-Modified-Since используется с методом, делающим его условным: если запрошенный вариант не был изменен с момента времени, указанного в этом поле, объект не будет возвращен с сервера; вместо этого будет возвращен ответ 304 (не измененный) без тела сообщения. If-Modified-Since = &quot;If-Modified-Since&quot; &quot;:&quot; HTTP-date Пример поля: If-Modified-Since: Сб, 29 октября 1994 г., 19:43:31 GMT Метод GET с If- Заголовок Modified-Since и заголовок no Range запрашивают передачу идентифицированного объекта, только если он был изменен с даты, указанной в заголовке If-Modified-Since. Алгоритм определения этого включает следующие случаи:a) Если запрос обычно приводит к чему-либо, кроме состояния 200 (OK), или если переданная дата If-Modified-Since недействительна, ответ будет таким же, как и для обычного GET. Дата, более поздняя, ​​чем текущее время сервера, недействительна. б) Если вариант был изменен после даты If-Modified-Since, ответ будет таким же, как и для обычного GET. c) Если вариант не был изменен после действительной даты If-Modified-Since, серверу СЛЕДУЕТ вернуть ответ 304 (Not Modified). Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Примечание. Поле заголовка запроса Range изменяет значение If-Modified-Since; видетьили если переданная дата If-Modified-Since недействительна, ответ будет таким же, как и для обычного GET. Дата, более поздняя, ​​чем текущее время сервера, недействительна. б) Если вариант был изменен после даты If-Modified-Since, ответ будет таким же, как и для обычного GET. c) Если вариант не был изменен после действительной даты If-Modified-Since, серверу СЛЕДУЕТ вернуть ответ 304 (Not Modified). Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Примечание. Поле заголовка запроса Range изменяет значение If-Modified-Since; видетьили если переданная дата If-Modified-Since недействительна, ответ будет таким же, как и для обычного GET. Дата, более поздняя, ​​чем текущее время сервера, недействительна. б) Если вариант был изменен после даты If-Modified-Since, ответ будет таким же, как и для обычного GET. c) Если вариант не был изменен после действительной даты If-Modified-Since, серверу СЛЕДУЕТ вернуть ответ 304 (Not Modified). Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальными затратами на транзакции. Примечание. Поле заголовка запроса Range изменяет значение If-Modified-Since; видетьДата, более поздняя, ​​чем текущее время сервера, недействительна. б) Если вариант был изменен после даты If-Modified-Since, ответ будет таким же, как и для обычного GET. c) Если вариант не был изменен с момента действительной даты If-Modified-Since, сервер ДОЛЖЕН вернуть ответ 304 (Not Modified). Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Примечание. Поле заголовка запроса Range изменяет значение If-Modified-Since; видетьДата, более поздняя, ​​чем текущее время сервера, недействительна. б) Если вариант был изменен после даты If-Modified-Since, ответ будет таким же, как и для обычного GET. c) Если вариант не был изменен после действительной даты If-Modified-Since, серверу СЛЕДУЕТ вернуть ответ 304 (Not Modified). Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Примечание. Поле заголовка запроса Range изменяет значение If-Modified-Since; видетьc) Если вариант не был изменен после действительной даты If-Modified-Since, серверу СЛЕДУЕТ вернуть ответ 304 (Not Modified). Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Примечание. Поле заголовка запроса Range изменяет значение If-Modified-Since; видетьc) Если вариант не был изменен после действительной даты If-Modified-Since, серверу СЛЕДУЕТ вернуть ответ 304 (Not Modified). Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Примечание. Поле заголовка запроса Range изменяет значение If-Modified-Since; видеть&lt;a href=&quot;#section-14.35&quot;&gt;Раздел 14.35&lt;/a&gt;для получения полной информации. Примечание. Время If-Modified-Since интерпретируется сервером, часы которого могут не синхронизироваться с клиентом. Примечание. При обработке поля заголовка If-Modified-Since некоторые серверы будут использовать функцию сравнения точных дат, а не функцию &amp;laquo;меньше чем&amp;raquo;, чтобы решить, отправлять ли ответ 304 (Not Modified). Чтобы получить наилучшие результаты при отправке поля заголовка If-Modified-Since для проверки кэша, клиентам рекомендуется по возможности использовать строку с точной датой, полученную в предыдущем поле заголовка Last-Modified. Примечание. Если клиент использует произвольную дату в заголовке If-Modified-Since вместо даты, взятой из заголовка Last-Modified для того же запроса,клиент должен знать, что эта дата интерпретируется в понимании времени сервером. Клиент должен учитывать несинхронизированные часы и проблемы с округлением из-за различий в кодировании времени между клиентом и сервером. Это включает в себя возможность состояний гонки, если документ был изменен между временем, когда он был впервые запрошен, и датой If-Modified-Since последующего запроса, а также возможность проблем, связанных со сдвигом часов, если дата If-Modified-Since выводится из часов клиента без поправки на часы сервера. Корректировки для разных временных баз между клиентом и сервером в лучшем случае приблизительны из-за задержки в сети.Результат запроса, имеющего как поле заголовка If-Modified-Since, так и поля заголовка If-Match или If-Unmodified-Since, не определен данной спецификацией.</target>
        </trans-unit>
        <trans-unit id="39e92741a96fab5452a65a932345457528d34e55" translate="yes" xml:space="preserve">
          <source>The If-None-Match request-header field is used with a method to make
   it conditional. A client that has one or more entities previously
   obtained from the resource can verify that none of those entities is
   current by including a list of their associated entity tags in the
   If-None-Match header field. The purpose of this feature is to allow
   efficient updates of cached information with a minimum amount of
   transaction overhead. It is also used to prevent a method (e.g. PUT)
   from inadvertently modifying an existing resource when the client
   believes that the resource does not exist.

   As a special case, the value &quot;*&quot; matches any current entity of the
   resource.

       If-None-Match = &quot;If-None-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-None-Match header) on that resource, or if &quot;*&quot; is
   given and any current entity exists for that resource, then the
   server MUST NOT perform the requested method, unless required to do
   so because the resource's modification date fails to match that
   supplied in an If-Modified-Since header field in the request.
   Instead, if the request method was GET or HEAD, the server SHOULD
   respond with a 304 (Not Modified) response, including the cache-
   related header fields (particularly ETag) of one of the entities that
   matched. For all other request methods, the server MUST respond with
   a status of 412 (Precondition Failed).

   See &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt; for rules on how to determine if two entities tags
   match. The weak comparison function can only be used with GET or HEAD
   requests. 

   If none of the entity tags match, then the server MAY perform the
   requested method as if the If-None-Match header field did not exist,
   but MUST also ignore any If-Modified-Since header field(s) in the
   request. That is, if no entity tags match, then the server MUST NOT
   return a 304 (Not Modified) response.

   If the request would, without the If-None-Match header field, result
   in anything other than a 2xx or 304 status, then the If-None-Match
   header MUST be ignored. (See &lt;a href=&quot;#section-13.3.4&quot;&gt;section 13.3.4&lt;/a&gt; for a discussion of
   server behavior when both If-Modified-Since and If-None-Match appear
   in the same request.)

   The meaning of &quot;If-None-Match: *&quot; is that the method MUST NOT be
   performed if the representation selected by the origin server (or by
   a cache, possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;)
   exists, and SHOULD be performed if the representation does not exist.
   This feature is intended to be useful in preventing races between PUT
   operations.

   Examples:

       If-None-Match: &quot;xyzzy&quot;
       If-None-Match: W/&quot;xyzzy&quot;
       If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
       If-None-Match: *

   The result of a request having both an If-None-Match header field and
   either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">Поле заголовка запроса If-None-Match используется с методом, чтобы сделать его условным. Клиент, у которого есть одна или несколько сущностей, ранее полученных из ресурса, может проверить, что ни одна из этих сущностей не является текущей, включив список связанных с ними тегов сущностей в поле заголовка If-None-Match. Цель этой функции - обеспечить эффективное обновление кэшированной информации с минимальным объемом транзакций. Он также используется для предотвращения непреднамеренного изменения существующего ресурса методом (например, PUT), когда клиент считает, что этот ресурс не существует. В качестве особого случая значение &amp;laquo;*&amp;raquo; соответствует любой текущей сущности ресурса. If-None-Match = &quot;If-None-Match&quot; &quot;:&quot; (&quot;*&quot;| 1 # entity-tag) Если какой-либо из тегов объекта соответствует тегу объекта объекта, который был бы возвращен в ответ на аналогичный запрос GET (без заголовка If-None-Match) для этого ресурса, или если &quot;* &quot;задан, и для этого ресурса существует какой-либо текущий объект, то сервер НЕ ДОЛЖЕН выполнять запрошенный метод, если это не требуется, потому что дата модификации ресурса не соответствует дате, указанной в поле заголовка If-Modified-Since в запросе. Вместо этого, если метод запроса был GET или HEAD, серверу СЛЕДУЕТ ответить ответом 304 (Not Modified), включая поля заголовка, связанные с кешем (в частности, ETag) одного из сопоставленных объектов. Для всех других методов запроса сервер ДОЛЖЕН ответить статусом 412 (предварительное условие не выполнено). ВидетьВидетьВидетьВидетьВидетьтогда сервер НЕ ДОЛЖЕН выполнять запрошенный метод, если это не требуется, потому что дата модификации ресурса не соответствует дате, указанной в поле заголовка If-Modified-Since в запросе. Вместо этого, если метод запроса был GET или HEAD, серверу СЛЕДУЕТ ответить ответом 304 (Not Modified), включая поля заголовка, связанные с кешем (в частности, ETag) одного из сопоставленных объектов. Для всех других методов запроса сервер ДОЛЖЕН ответить статусом 412 (предварительное условие не выполнено). Видетьтогда сервер НЕ ДОЛЖЕН выполнять запрошенный метод, если это не требуется, потому что дата модификации ресурса не соответствует дате, указанной в поле заголовка If-Modified-Since в запросе. Вместо этого, если метод запроса был GET или HEAD, серверу СЛЕДУЕТ ответить ответом 304 (Not Modified), включая поля заголовка, связанные с кешем (в частности, ETag) одного из сопоставленных объектов. Для всех других методов запроса сервер ДОЛЖЕН ответить статусом 412 (предварительное условие не выполнено). Видетьсерверу СЛЕДУЕТ ответить ответом 304 (Not Modified), включая связанные с кешем поля заголовка (в частности, ETag) одного из сопоставленных объектов. Для всех других методов запроса сервер ДОЛЖЕН ответить статусом 412 (предварительное условие не выполнено). Видетьсерверу СЛЕДУЕТ ответить ответом 304 (Not Modified), включая связанные с кешем поля заголовка (в частности, ETag) одного из сопоставленных объектов. Для всех других методов запроса сервер ДОЛЖЕН ответить статусом 412 (предварительное условие не выполнено). Видеть&lt;a href=&quot;#section-13.3.3&quot;&gt;раздел 13.3.3&lt;/a&gt; о правилах определения совпадения двух тегов сущностей. Функция слабого сравнения может использоваться только с запросами GET или HEAD. Если ни один из тегов объекта не совпадает, тогда сервер МОЖЕТ выполнить запрошенный метод, как если бы поле заголовка If-None-Match не существовало, но ДОЛЖЕН также игнорировать любые поля заголовка If-Modified-Since в запросе. То есть, если ни один тег объекта не совпадает, сервер НЕ ДОЛЖЕН возвращать ответ 304 (Not Modified). Если запрос без поля заголовка If-None-Match приведет к чему-либо, кроме статуса 2xx или 304, тогда заголовок If-None-Match ДОЛЖЕН игнорироваться. (См. &lt;a href=&quot;#section-13.3.4&quot;&gt;Раздел 13.3.4.&lt;/a&gt;для обсуждения поведения сервера, когда и If-Modified-Since, и If-None-Match появляются в одном запросе.) Значение &amp;laquo;If-None-Match: *&amp;raquo; состоит в том, что метод НЕ ДОЛЖЕН выполняться, если выбрано представление исходным сервером (или кешем, возможно, с использованием механизма Vary, см. &lt;a href=&quot;#section-14.44&quot;&gt;раздел 14.44).&lt;/a&gt;) существует, и ДОЛЖЕН выполняться, если представление не существует. Эта функция предназначена для предотвращения скачков между операциями PUT. Примеры: If-None-Match: &quot;xyzzy&quot; If-None-Match: W / &quot;xyzzy&quot; If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot; If-None-Match: W / &quot;xyzzy&quot; , W / &quot;r2d2xxxx&quot;, W / &quot;c3piozzzz&quot; If-None-Match: * Результат запроса, имеющего как поле заголовка If-None-Match, так и поля заголовка If-Match или If-Unmodified-Since, является не определено данной спецификацией.</target>
        </trans-unit>
        <trans-unit id="a77607d9e035711baba5b97bc67fee22711422dd" translate="yes" xml:space="preserve">
          <source>The If-Unmodified-Since request-header field is used with a method to
   make it conditional. If the requested resource has not been modified
   since the time specified in this field, the server SHOULD perform the
   requested operation as if the If-Unmodified-Since header were not
   present.

   If the requested variant has been modified since the specified time,
   the server MUST NOT perform the requested operation, and MUST return
   a 412 (Precondition Failed).

      If-Unmodified-Since = &quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-date

   An example of the field is:

       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   If the request normally (i.e., without the If-Unmodified-Since
   header) would result in anything other than a 2xx or 412 status, the
   If-Unmodified-Since header SHOULD be ignored.

   If the specified date is invalid, the header is ignored.

   The result of a request having both an If-Unmodified-Since header
   field and either an If-None-Match or an If-Modified-Since header
   fields is undefined by this specification.</source>
          <target state="translated">Поле If-Unmodified-Since request-header используется с методом для того,чтобы сделать его условным.Если с момента,указанного в данном поле,запрашиваемый ресурс не был изменён,то сервер ДОЛЖЕН выполнить запрошенную операцию так,как если бы заголовок If-Unmodified-Since отсутствовал.Если запрашиваемый вариант был изменен с указанного времени,то сервер ДОЛЖЕН НЕ выполнять запрашиваемую операцию,а возвращать 412 (Precondition Failed).If-Unmodified-Since=&quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-дата Пример поля:If-Unmodified-Since:Sat,29 Oct 1994 19:43:31 GMT Если запрос в обычном режиме (т.е.без заголовка If-Unmodified-Since)приведет к чему-либо,кроме статуса 2xx или 412,заголовок If-Unmodified-Since ДОЛЖЕН быть проигнорирован.Если указанная дата недействительна,заголовок игнорируется.Результат запроса,имеющего как поле заголовка If-Unmodified-Since,так и поле заголовка If-None-Match или If-Modified-Since,не определяется данной спецификацией.</target>
        </trans-unit>
        <trans-unit id="fdfb0dc451f3880ef0d4f67dac2ee95582caadcf" translate="yes" xml:space="preserve">
          <source>The JavaScript function returns a single string</source>
          <target state="translated">Функция JavaScript возвращает единственную строку</target>
        </trans-unit>
        <trans-unit id="703e778a54d67833e0037322f76c267a64284bbc" translate="yes" xml:space="preserve">
          <source>The JavaScript function should always be saved to a file by itself and not be embedded in HTML.</source>
          <target state="translated">Функция JavaScript всегда должна быть сохранена в файле сама по себе и не должна быть встроена в HTML.</target>
        </trans-unit>
        <trans-unit id="ae3233de7c368a8e5f19a8ef2604664291230823" translate="yes" xml:space="preserve">
          <source>The JavaScript snippets included in these sections (and running instances of the server-code that correctly handles these cross-site requests) can be found &quot;in action&quot; at &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http://arunranga.com/examples/access-control/&lt;/a&gt;, and will work in browsers that support cross-site &lt;code&gt;XMLHttpRequest&lt;/code&gt;.</source>
          <target state="translated">Фрагменты JavaScript, включенные в эти разделы (и запущенные экземпляры серверного кода, который правильно обрабатывает эти межсайтовые запросы), можно найти &amp;laquo;в действии&amp;raquo; по адресу &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http://arunranga.com/examples/access-control/&lt;/a&gt; , и они будут работать в браузерах, поддерживающих межсайтовый &lt;code&gt;XMLHttpRequest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="925661df194abc683169e90bef883c4c078be359" translate="yes" xml:space="preserve">
          <source>The Keep-Alive Header (Experimental specification)</source>
          <target state="translated">Заголовок &quot;Keep-Alive&quot; (Экспериментальная спецификация)</target>
        </trans-unit>
        <trans-unit id="db2749cedc967fd4ef7ed7614b130c614deab08c" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field indicates the date and time at
   which the origin server believes the variant was last modified.

       Last-Modified  = &quot;Last-Modified&quot; &quot;:&quot; HTTP-date 

   An example of its use is

       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT

   The exact meaning of this header field depends on the implementation
   of the origin server and the nature of the original resource. For
   files, it may be just the file system last-modified time. For
   entities with dynamically included parts, it may be the most recent
   of the set of last-modify times for its component parts. For database
   gateways, it may be the last-update time stamp of the record. For
   virtual objects, it may be the last time the internal state changed.

   An origin server MUST NOT send a Last-Modified date which is later
   than the server's time of message origination. In such cases, where
   the resource's last modification would indicate some time in the
   future, the server MUST replace that date with the message
   origination date.

   An origin server SHOULD obtain the Last-Modified value of the entity
   as close as possible to the time that it generates the Date value of
   its response. This allows a recipient to make an accurate assessment
   of the entity's modification time, especially if the entity changes
   near the time that the response is generated.

   HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.</source>
          <target state="translated">В поле Last-Modified entity-header (Заголовок структуры)указывается дата и время,когда сервер происхождения считает,что вариант был в последний раз изменен.Last-Modified=&quot;Last-Modified&quot; &quot;:&quot; HTTP-date Примером его использования является Last-Modified:Tue,15 Nov 1994 12:45:26 GMT Точное значение этого поля заголовка зависит от реализации сервера-источника и природы исходного ресурса.Для файлов это может быть только время последней модификации файловой системы.Для сущностей с динамически включаемыми частями,оно может быть самым последним из множества последних модифицированных времен для их составных частей.Для шлюзов баз данных это может быть последняя метка времени записи.Для виртуальных объектов это может быть последний раз,когда внутреннее состояние изменилось.Сервер происхождения НЕ ДОЛЖЕН посылать последнюю измененную дату,которая является более поздней,чем время отправки сообщения сервером.В таких случаях,когда последняя модификация ресурса будет указывать на некоторое время в будущем,сервер ДОЛЖЕН заменить эту дату на дату возникновения сообщения.Сервер происхождения ДОЛЖЕН получить значение Last-Modified сущности как можно ближе к тому времени,когда он генерирует значение Date своего ответа.Это позволяет получателю точно оценить время модификации сущности,особенно если сущность изменяется близко ко времени генерации ответа.HTTP/1.1 серверы ДОЛЖНЫ посылать последнюю модификацию,когда это возможно.</target>
        </trans-unit>
        <trans-unit id="528a83f631c94edde30298fe82ad4b470dc52fd6" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field value is often used as a cache
   validator. In simple terms, a cache entry is considered to be valid
   if the entity has not been modified since the Last-Modified value.</source>
          <target state="translated">Значение поля &quot;Last-Modified entity-header&quot; часто используется в качестве валидатора кэша.Проще говоря,запись в кэше считается действительной,если сущность не была изменена после значения Last-Modified.</target>
        </trans-unit>
        <trans-unit id="017625ae11b1cf3babbe1d1e9f72538a1d0bcdba" translate="yes" xml:space="preserve">
          <source>The Location response-header field is used to redirect the recipient
   to a location other than the Request-URI for completion of the
   request or identification of a new resource. For 201 (Created)
   responses, the Location is that of the new resource which was created
   by the request. For 3xx responses, the location SHOULD indicate the
   server's preferred URI for automatic redirection to the resource. The
   field value consists of a single absolute URI.

       Location       = &quot;Location&quot; &quot;:&quot; absoluteURI

   An example is:

       Location: &lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http://www.w3.org/pub/WWW/People.html&lt;/a&gt;

      Note: The Content-Location header field (&lt;a href=&quot;#section-14.14&quot;&gt;section 14.14&lt;/a&gt;) differs
      from Location in that the Content-Location identifies the original
      location of the entity enclosed in the request. It is therefore
      possible for a response to contain header fields for both Location
      and Content-Location. Also see &lt;a href=&quot;#section-13.10&quot;&gt;section 13.10&lt;/a&gt; for cache
      requirements of some methods.</source>
          <target state="translated">Поле заголовка ответа Location используется для перенаправления получателя в местоположение, отличное от Request-URI, для завершения запроса или идентификации нового ресурса. Для 201 (Созданного) ответа Location - это местоположение нового ресурса, который был создан запросом. Для ответов 3xx расположение ДОЛЖНО указывать предпочтительный URI сервера для автоматического перенаправления на ресурс. Значение поля состоит из одного абсолютного URI. Location = &quot;Location&quot; &quot;:&quot; absoluteURI Пример: Location: &lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http://www.w3.org/pub/WWW/People.html&lt;/a&gt; Примечание. Поле заголовка Content-Location ( &lt;a href=&quot;#section-14.14&quot;&gt;раздел 14.14&lt;/a&gt;) отличается от Location тем, что Content-Location идентифицирует исходное местоположение объекта, включенного в запрос. Следовательно, ответ может содержать поля заголовка как для Location, так и для Content-Location. Также см. &lt;a href=&quot;#section-13.10&quot;&gt;Раздел 13.10&lt;/a&gt; о требованиях к кешированию некоторых методов.</target>
        </trans-unit>
        <trans-unit id="5bc7ceee0f881c0002d5d80140938c1e7f80c8e7" translate="yes" xml:space="preserve">
          <source>The MIME type of audiovisual files mostly indicate the container formats. The most common ones on the Web are:</source>
          <target state="translated">MIME-тип аудиовизуальных файлов в основном указывает на форматы контейнеров.Наиболее распространенные из них в Сети:</target>
        </trans-unit>
        <trans-unit id="7e997fc9b96d9d0ec4b11746c0834f2c40378a91" translate="yes" xml:space="preserve">
          <source>The MOVE operation on a non-collection resource is the logical
   equivalent of a copy (COPY), followed by consistency maintenance
   processing, followed by a delete of the source, where all three
   actions are performed in a single operation.  The consistency
   maintenance step allows the server to perform updates caused by the
   move, such as updating all URLs, other than the Request-URI that
   identifies the source resource, to point to the new destination
   resource. 

   The Destination header MUST be present on all MOVE methods and MUST
   follow all COPY requirements for the COPY part of the MOVE method.
   All WebDAV-compliant resources MUST support the MOVE method.

   Support for the MOVE method does not guarantee the ability to move a
   resource to a particular destination.  For example, separate programs
   may actually control different sets of resources on the same server.
   Therefore, it may not be possible to move a resource within a
   namespace that appears to belong to the same server.

   If a resource exists at the destination, the destination resource
   will be deleted as a side-effect of the MOVE operation, subject to
   the restrictions of the Overwrite header.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">Операция MOVE для ресурса, не являющегося сборником, является логическим эквивалентом копирования (COPY), за которым следует обработка поддержания согласованности, за которой следует удаление источника, где все три действия выполняются за одну операцию. Этап поддержания согласованности позволяет серверу выполнять обновления, вызванные перемещением, такие как обновление всех URL-адресов, кроме Request-URI, который идентифицирует исходный ресурс, для указания на новый целевой ресурс. Заголовок Destination ДОЛЖЕН присутствовать во всех методах MOVE и ДОЛЖЕН соответствовать всем требованиям COPY для части COPY метода MOVE. Все ресурсы, совместимые с WebDAV, ДОЛЖНЫ поддерживать метод MOVE. Поддержка метода MOVE не гарантирует возможность перемещения ресурса в конкретное место назначения. Например,отдельные программы могут фактически управлять разными наборами ресурсов на одном сервере. Следовательно, может оказаться невозможным переместить ресурс в пространстве имен, которое кажется принадлежащим тому же серверу. Если ресурс существует в месте назначения, ресурс назначения будет удален как побочный эффект операции MOVE с учетом ограничений заголовка Overwrite. Этот метод идемпотентен, но небезопасен (см.&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Раздел 9.1 [RFC2616]&lt;/a&gt; ). Ответы на этот метод НЕ ДОЛЖНЫ кэшироваться.</target>
        </trans-unit>
        <trans-unit id="cb1023831cad3159839df21a4251dd372a13a0bc" translate="yes" xml:space="preserve">
          <source>The Max-Forwards request-header field provides a mechanism with the
   TRACE (&lt;a href=&quot;#section-9.8&quot;&gt;section 9.8&lt;/a&gt;) and OPTIONS (&lt;a href=&quot;#section-9.2&quot;&gt;section 9.2&lt;/a&gt;) methods to limit the
   number of proxies or gateways that can forward the request to the
   next inbound server. This can be useful when the client is attempting
   to trace a request chain which appears to be failing or looping in
   mid-chain.

       Max-Forwards   = &quot;Max-Forwards&quot; &quot;:&quot; 1*DIGIT

   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message may be forwarded.

   Each proxy or gateway recipient of a TRACE or OPTIONS request
   containing a Max-Forwards header field MUST check and update its
   value prior to forwarding the request. If the received value is zero
   (0), the recipient MUST NOT forward the request; instead, it MUST
   respond as the final recipient. If the received Max-Forwards value is
   greater than zero, then the forwarded message MUST contain an updated
   Max-Forwards field with a value decremented by one (1).

   The Max-Forwards header field MAY be ignored for all other methods
   defined by this specification and for any extension methods for which
   it is not explicitly referred to as part of that method definition.</source>
          <target state="translated">Поле заголовка запроса Max-Forwards обеспечивает механизм с TRACE ( &lt;a href=&quot;#section-9.8&quot;&gt;раздел 9.8&lt;/a&gt; ) и OPTIONS ( &lt;a href=&quot;#section-9.2&quot;&gt;раздел 9.2).&lt;/a&gt;), чтобы ограничить количество прокси или шлюзов, которые могут перенаправить запрос на следующий входящий сервер. Это может быть полезно, когда клиент пытается отследить цепочку запросов, которая, похоже, дает сбой или зацикливается в середине цепочки. Max-Forwards = &quot;Max-Forwards&quot; &quot;:&quot; 1 * DIGIT Значение Max-Forwards представляет собой десятичное целое число, указывающее оставшееся количество раз, когда это сообщение запроса может быть переадресовано. Каждый прокси-сервер или шлюз-получатель запроса TRACE или OPTIONS, содержащего поле заголовка Max-Forwards, ДОЛЖЕН проверить и обновить его значение до пересылки запроса. Если полученное значение равно нулю (0), получатель НЕ ДОЛЖЕН пересылать запрос; вместо этого он ДОЛЖЕН отвечать как конечный получатель. Если полученное значение Max-Forwards больше нуля,тогда переадресованное сообщение ДОЛЖНО содержать обновленное поле Max-Forwards со значением, уменьшенным на единицу (1). Поле заголовка Max-Forwards МОЖЕТ игнорироваться для всех других методов, определенных в этой спецификации, и для любых методов расширения, для которых оно явно не упоминается как часть этого определения метода.</target>
        </trans-unit>
        <trans-unit id="b9679bb7ec73b85f439581526aa5e2f804e20f5f" translate="yes" xml:space="preserve">
          <source>The Member URI allows clients to retrieve, edit, and delete a Member
   Resource using HTTP's GET, PUT, and DELETE methods.  Entry Resources
   are represented as Atom Entry documents.

   Member URIs appear in two places.  They are returned in a Location
   header after successful Resource creation using POST, as described in
   &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt; below.  They can also appear in a Collection Feed's
   Entries, as atom:link elements with a link relation of &quot;edit&quot;.

   A Member Entry SHOULD contain such an atom:link element with a link
   relation of &quot;edit&quot;, which indicates the Member URI.</source>
          <target state="translated">URI участника позволяет клиентам получать, редактировать и удалять ресурс участника с помощью методов HTTP GET, PUT и DELETE. Входные ресурсы представлены как входные документы Atom. URI участников появляются в двух местах. Они возвращаются в заголовке Location после успешного создания ресурса с помощью POST, как описано в &lt;a href=&quot;#section-9.2&quot;&gt;Разделе 9.2&lt;/a&gt; ниже. Они также могут появляться в записях фида подборки как элементы atom: link с отношением ссылки &amp;laquo;редактировать&amp;raquo;. Запись участника ДОЛЖНА содержать такой элемент atom: link с отношением ссылки &amp;laquo;редактировать&amp;raquo;, которое указывает URI участника.</target>
        </trans-unit>
        <trans-unit id="8bc27eaceea013a32bec84be620f4a677881aac7" translate="yes" xml:space="preserve">
          <source>The Method  token indicates the method to be performed on the
   resource identified by the Request-URI. The method is case-sensitive.

       Method         = &quot;OPTIONS&quot;                ; &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;
                      | &quot;GET&quot;                    ; &lt;a href=&quot;#section-9.3&quot;&gt;Section 9.3&lt;/a&gt;
                      | &quot;HEAD&quot;                   ; &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt;
                      | &quot;POST&quot;                   ; &lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;
                      | &quot;PUT&quot;                    ; &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;
                      | &quot;DELETE&quot;                 ; &lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;
                      | &quot;TRACE&quot;                  ; &lt;a href=&quot;#section-9.8&quot;&gt;Section 9.8&lt;/a&gt;
                      | &quot;CONNECT&quot;                ; &lt;a href=&quot;#section-9.9&quot;&gt;Section 9.9&lt;/a&gt;
                      | extension-method
       extension-method = token

   The list of methods allowed by a resource can be specified in an
   Allow header field (&lt;a href=&quot;#section-14.7&quot;&gt;section 14.7&lt;/a&gt;). The return code of the response
   always notifies the client whether a method is currently allowed on a
   resource, since the set of allowed methods can change dynamically. An
   origin server SHOULD return the status code 405 (Method Not Allowed)
   if the method is known by the origin server but not allowed for the
   requested resource, and 501 (Not Implemented) if the method is
   unrecognized or not implemented by the origin server. The methods GET
   and HEAD MUST be supported by all general-purpose servers. All other
   methods are OPTIONAL; however, if the above methods are implemented,
   they MUST be implemented with the same semantics as those specified
   in &lt;a href=&quot;#section-9&quot;&gt;section 9&lt;/a&gt;.</source>
          <target state="translated">Маркер метода указывает метод, который будет выполняться для ресурса, указанного в Request-URI. В методе учитывается регистр. Метод = &quot;ОПЦИИ&quot;; &lt;a href=&quot;#section-9.2&quot;&gt;Раздел 9.2&lt;/a&gt; | &quot;ПОЛУЧИТЬ&quot; ; &lt;a href=&quot;#section-9.3&quot;&gt;Раздел 9.3&lt;/a&gt; | &quot;ГЛАВА&quot; ; &lt;a href=&quot;#section-9.4&quot;&gt;Раздел 9.4&lt;/a&gt; | &quot;ПОЧТА&quot; ; &lt;a href=&quot;#section-9.5&quot;&gt;Раздел 9.5&lt;/a&gt; | &quot;СТАВИТЬ&quot; ; &lt;a href=&quot;#section-9.6&quot;&gt;Раздел 9.6&lt;/a&gt; | &quot;УДАЛИТЬ&quot; ; &lt;a href=&quot;#section-9.7&quot;&gt;Раздел 9.7&lt;/a&gt; | &amp;laquo;СЛЕД&amp;raquo;; &lt;a href=&quot;#section-9.8&quot;&gt;Раздел 9.8&lt;/a&gt; | &quot;CONNECT&quot;; &lt;a href=&quot;#section-9.9&quot;&gt;Раздел 9.9&lt;/a&gt; | extension-method extension-method = token Список методов, разрешенных ресурсом, может быть указан в поле заголовка Allow ( &lt;a href=&quot;#section-14.7&quot;&gt;раздел 14.7&lt;/a&gt;). Код возврата ответа всегда уведомляет клиента о том, разрешен ли метод в данный момент для ресурса, поскольку набор разрешенных методов может изменяться динамически. Исходный сервер ДОЛЖЕН возвращать код состояния 405 (метод не разрешен), если метод известен исходному серверу, но не разрешен для запрошенного ресурса, и 501 (не реализован), если метод нераспознан или не реализован исходным сервером. Методы GET и HEAD ДОЛЖНЫ поддерживаться всеми серверами общего назначения. Все остальные методы НЕОБЯЗАТЕЛЬНЫ; однако, если вышеупомянутые методы реализованы, они ДОЛЖНЫ быть реализованы с той же семантикой, что и те, которые указаны в &lt;a href=&quot;#section-9&quot;&gt;разделе 9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b472ea77a890edf2b85c6971105718fc4fd6fc42" translate="yes" xml:space="preserve">
          <source>The OPTIONS method represents a request for information about the
   communication options available on the request/response chain
   identified by the Request-URI. This method allows the client to
   determine the options and/or requirements associated with a resource,
   or the capabilities of a server, without implying a resource action
   or initiating a resource retrieval.

   Responses to this method are not cacheable.

   If the OPTIONS request includes an entity-body (as indicated by the
   presence of Content-Length or Transfer-Encoding), then the media type
   MUST be indicated by a Content-Type field. Although this
   specification does not define any use for such a body, future
   extensions to HTTP might use the OPTIONS body to make more detailed
   queries on the server. A server that does not support such an
   extension MAY discard the request body.

   If the Request-URI is an asterisk (&quot;*&quot;), the OPTIONS request is
   intended to apply to the server in general rather than to a specific
   resource. Since a server's communication options typically depend on
   the resource, the &quot;*&quot; request is only useful as a &quot;ping&quot; or &quot;no-op&quot;
   type of method; it does nothing beyond allowing the client to test
   the capabilities of the server. For example, this can be used to test
   a proxy for HTTP/1.1 compliance (or lack thereof).

   If the Request-URI is not an asterisk, the OPTIONS request applies
   only to the options that are available when communicating with that
   resource.

   A 200 response SHOULD include any header fields that indicate
   optional features implemented by the server and applicable to that
   resource (e.g., Allow), possibly including extensions not defined by
   this specification. The response body, if any, SHOULD also include
   information about the communication options. The format for such a 

   body is not defined by this specification, but might be defined by
   future extensions to HTTP. Content negotiation MAY be used to select
   the appropriate response format. If no response body is included, the
   response MUST include a Content-Length field with a field-value of
   &quot;0&quot;.

   The Max-Forwards request-header field MAY be used to target a
   specific proxy in the request chain. When a proxy receives an OPTIONS
   request on an absoluteURI for which request forwarding is permitted,
   the proxy MUST check for a Max-Forwards field. If the Max-Forwards
   field-value is zero (&quot;0&quot;), the proxy MUST NOT forward the message;
   instead, the proxy SHOULD respond with its own communication options.
   If the Max-Forwards field-value is an integer greater than zero, the
   proxy MUST decrement the field-value when it forwards the request. If
   no Max-Forwards field is present in the request, then the forwarded
   request MUST NOT include a Max-Forwards field.</source>
          <target state="translated">Метод OPTIONS (ВАРИАНТ)представляет собой запрос информации о вариантах коммуникации,доступных в цепочке запрос/реакция,обозначенной в Request-URI (Запросы-URI).Этот метод позволяет клиенту определить опции и/или требования,связанные с ресурсом или возможностями сервера,не подразумевая действий с ресурсом и не инициируя его извлечение.Ответы на этот метод не являются кэшируемыми.Если запрос OPTIONS включает в себя сущность-тело (на что указывает наличие Content-Length или Transfer-Encoding),то тип носителя ДОЛЖЕН быть обозначен полем Content-Type.Хотя эта спецификация не определяет использование такого тела,будущие расширения HTTP могут использовать тело OPTIONS для более детальных запросов на сервере.Сервер,не поддерживающий такое расширение,МОЖЕТ отбросить тело запроса.Если Request-URI помечен звездочкой (&quot;*&quot;),то запрос OPTIONS предназначен для применения к серверу в целом,а не к конкретному ресурсу.Так как варианты взаимодействия сервера обычно зависят от ресурса,то запрос &quot;*&quot; полезен только как метод &quot;ping&quot; или &quot;no-op&quot;;он ничего не делает,кроме как позволяет клиенту проверить возможности сервера.Например,это может быть использовано для проверки прокси на соответствие HTTP/1.1 (или его отсутствие).Если запрос Request-URI не помечен звездочкой,то запрос OPTIONS применяется только к тем опциям,которые доступны при общении с этим ресурсом.Поле 200 ответа SHOULD включает в себя любые поля заголовка,которые указывают на необязательные опции,реализованные сервером и применимые к этому ресурсу (например,Allow),возможно,включая расширения,не определенные данной спецификацией.Тело ответа,если таковое имеется,SHOULD также включает информацию о вариантах обмена данными.Формат такого тела не определен данной спецификацией,но может быть определен будущими расширениями HTTP.Согласование содержания МОЖЕТ быть использовано для выбора соответствующего формата ответа.Если тело ответа не включено,то ответ ДОЛЖЕН содержать поле Content-Length со значением поля &quot;0&quot;.Поле Max-Forwards-заголовок запроса MAY должно использоваться для назначения конкретного прокси-сервера в цепочке запросов.Когда прокси-сервер получает запрос OPTIONS на абсолютном уровне,для которого разрешена переадресация запроса,он ДОЛЖЕН проверять поле Max-Forwards.Если значение поля Max-Forwards равно нулю (&quot;0&quot;),прокси-сервер НЕ ДОЛЖЕН пересылать сообщение;вместо этого прокси-сервер ДОЛЖЕН отвечать собственными опциями связи.Если значение поля Max-Forwards больше нуля,то при пересылке запроса прокси-сервер ДОЛЖЕН уменьшать значение поля.Если в запросе отсутствует поле Max-Forwards,то пересылаемый запрос НЕ ДОЛЖЕН включать поле Max-Forwards.</target>
        </trans-unit>
        <trans-unit id="49820b72a266a24d241c6570cc10be88c4ce50ca" translate="yes" xml:space="preserve">
          <source>The OPTIONS method requests information about the communication
   options available for the target resource, at either the origin
   server or an intervening intermediary.  This method allows a client
   to determine the options and/or requirements associated with a
   resource, or the capabilities of a server, without implying a
   resource action. 

   An OPTIONS request with an asterisk (&quot;*&quot;) as the request-target
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;) applies to the server in general rather
   than to a specific resource.  Since a server's communication options
   typically depend on the resource, the &quot;*&quot; request is only useful as a
   &quot;ping&quot; or &quot;no-op&quot; type of method; it does nothing beyond allowing the
   client to test the capabilities of the server.  For example, this can
   be used to test a proxy for HTTP/1.1 conformance (or lack thereof).

   If the request-target is not an asterisk, the OPTIONS request applies
   to the options that are available when communicating with the target
   resource.

   A server generating a successful response to OPTIONS SHOULD send any
   header fields that might indicate optional features implemented by
   the server and applicable to the target resource (e.g., Allow),
   including potential extensions not defined by this specification.
   The response payload, if any, might also describe the communication
   options in a machine or human-readable representation.  A standard
   format for such a representation is not defined by this
   specification, but might be defined by future extensions to HTTP.  A
   server MUST generate a Content-Length field with a value of &quot;0&quot; if no
   payload body is to be sent in the response.

   A client MAY send a Max-Forwards header field in an OPTIONS request
   to target a specific recipient in the request chain (see
   &lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;).  A proxy MUST NOT generate a Max-Forwards header
   field while forwarding a request unless that request was received
   with a Max-Forwards field.

   A client that generates an OPTIONS request containing a payload body
   MUST send a valid Content-Type header field describing the
   representation media type.  Although this specification does not
   define any use for such a payload, future extensions to HTTP might
   use the OPTIONS body to make more detailed queries about the target
   resource.

   Responses to the OPTIONS method are not cacheable.</source>
          <target state="translated">Метод OPTIONS запрашивает информацию о вариантах связи, доступных для целевого ресурса, либо на исходном сервере, либо на промежуточном посреднике. Этот метод позволяет клиенту определять параметры и / или требования, связанные с ресурсом, или возможности сервера, не подразумевая действие ресурса. Запрос OPTIONS со звездочкой (&amp;laquo;*&amp;raquo;) в качестве цели запроса ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;раздел 5.3 [RFC7230]&lt;/a&gt;) применяется к серверу в целом, а не к конкретному ресурсу. Поскольку параметры связи сервера обычно зависят от ресурса, запрос &amp;laquo;*&amp;raquo; полезен только как метод типа &amp;laquo;ping&amp;raquo; или &amp;laquo;no-op&amp;raquo;; он не делает ничего, кроме того, что позволяет клиенту проверить возможности сервера. Например, это можно использовать для проверки прокси-сервера на соответствие HTTP / 1.1 (или его отсутствие). Если цель запроса не является звездочкой, запрос OPTIONS применяется к параметрам, которые доступны при взаимодействии с целевым ресурсом. Сервер, генерирующий успешный ответ на OPTIONS, ДОЛЖЕН отправить любые поля заголовка, которые могут указывать на дополнительные функции, реализованные сервером и применимые к целевому ресурсу (например, Allow),включая потенциальные расширения, не определенные в данной спецификации. Полезная нагрузка ответа, если таковая имеется, может также описывать варианты связи в машинном или удобочитаемом представлении. Стандартный формат для такого представления не определен в этой спецификации, но может быть определен в будущих расширениях HTTP. Сервер ДОЛЖЕН сгенерировать поле Content-Length со значением &amp;laquo;0&amp;raquo;, если в ответе не требуется отправлять тело полезной нагрузки. Клиент МОЖЕТ отправить поле заголовка Max-Forwards в запросе OPTIONS для нацеливания на конкретного получателя в цепочке запросов (см.но может быть определен в будущих расширениях HTTP. Сервер ДОЛЖЕН сгенерировать поле Content-Length со значением &amp;laquo;0&amp;raquo;, если в ответе не требуется отправлять тело полезной нагрузки. Клиент МОЖЕТ отправить поле заголовка Max-Forwards в запросе OPTIONS для нацеливания на конкретного получателя в цепочке запросов (см.но может быть определен в будущих расширениях HTTP. Сервер ДОЛЖЕН сгенерировать поле Content-Length со значением &amp;laquo;0&amp;raquo;, если в ответе не требуется отправлять тело полезной нагрузки. Клиент МОЖЕТ отправить поле заголовка Max-Forwards в запросе OPTIONS для нацеливания на конкретного получателя в цепочке запросов (см. &lt;a href=&quot;#section-5.1.2&quot;&gt;Раздел 5.1.2&lt;/a&gt; ). Прокси-сервер НЕ ДОЛЖЕН генерировать поле заголовка Max-Forwards при пересылке запроса, если этот запрос не был получен с полем Max-Forwards. Клиент, который генерирует запрос OPTIONS, содержащий тело полезной нагрузки, ДОЛЖЕН отправить допустимое поле заголовка Content-Type, описывающее тип носителя представления. Хотя эта спецификация не определяет какое-либо использование такой полезной нагрузки, будущие расширения HTTP могут использовать тело OPTIONS для выполнения более подробных запросов о целевом ресурсе. Ответы на метод OPTIONS не кэшируются.</target>
        </trans-unit>
        <trans-unit id="1d0b5a78c1f599442b880ea6a8403854d20e3ef6" translate="yes" xml:space="preserve">
          <source>The Opera browser is also based on the blink engine, which is why it almost looks the same, but adds &quot;OPR/&amp;lt;version&amp;gt;&quot;.</source>
          <target state="translated">Браузер Opera также основан на движке мигания, поэтому выглядит почти так же, но добавляет &amp;laquo;OPR / &amp;lt;version&amp;gt;&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="1a9fb731478c28f4fa3740727c3862c0e8280261" translate="yes" xml:space="preserve">
          <source>The Operating System is given in most User Agent strings (although not web-focused platforms like Firefox OS), but the format varies a lot. It is a fixed string between two semi-colons, in the comment part of the User Agent. These strings are specific for each browser. They indicate the OS, but also often its version and information on the relying hardware (32 or 64 bits, or Intel/PPC for Mac).</source>
          <target state="translated">Операционная система представлена в большинстве строк User Agent (хотя и не ориентирована на веб-платформы,такие как Firefox OS),но формат сильно варьируется.Это фиксированная строка между двумя полуколоннами,в комментаторской части Пользовательского агента.Эти строки специфичны для каждого браузера.Они указывают не только на операционную систему,но и часто ее версию и информацию о полагающемся оборудовании (32 или 64 бита,или Intel/PPC для Mac).</target>
        </trans-unit>
        <trans-unit id="1f9837bd9139ad48f4cd2dd0906bd1f2401fbe7f" translate="yes" xml:space="preserve">
          <source>The PAC file is named proxy.pac</source>
          <target state="translated">Файл PAC называется proxy.pac.</target>
        </trans-unit>
        <trans-unit id="ad2834ac0702672d145d7ca3894c53d5a21fd051" translate="yes" xml:space="preserve">
          <source>The PHP snippets (and the JavaScript invocations to the server) in subsequent sections are taken from &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;the working code samples posted here.&lt;/a&gt; These will work in browsers that implement cross-site &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Фрагменты PHP (и вызовы JavaScript на сервере) в последующих разделах взяты из &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;размещенных здесь примеров рабочего кода.&lt;/a&gt; Они будут работать в браузерах, реализующих межсайтовый &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d84539c58092eb061728beac8d3510599c78d9e2" translate="yes" xml:space="preserve">
          <source>The POST method is used to request that the origin server accept the
   entity enclosed in the request as a new subordinate of the resource
   identified by the Request-URI in the Request-Line. POST is designed
   to allow a uniform method to cover the following functions:

      - Annotation of existing resources;

      - Posting a message to a bulletin board, newsgroup, mailing list,
        or similar group of articles;

      - Providing a block of data, such as the result of submitting a
        form, to a data-handling process;

      - Extending a database through an append operation.

   The actual function performed by the POST method is determined by the
   server and is usually dependent on the Request-URI. The posted entity
   is subordinate to that URI in the same way that a file is subordinate
   to a directory containing it, a news article is subordinate to a
   newsgroup to which it is posted, or a record is subordinate to a
   database.

   The action performed by the POST method might not result in a
   resource that can be identified by a URI. In this case, either 200
   (OK) or 204 (No Content) is the appropriate response status,
   depending on whether or not the response includes an entity that
   describes the result. 

   If a resource has been created on the origin server, the response
   SHOULD be 201 (Created) and contain an entity which describes the
   status of the request and refers to the new resource, and a Location
   header (see &lt;a href=&quot;#section-14.30&quot;&gt;section 14.30&lt;/a&gt;).

   Responses to this method are not cacheable, unless the response
   includes appropriate Cache-Control or Expires header fields. However,
   the 303 (See Other) response can be used to direct the user agent to
   retrieve a cacheable resource.

   POST requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">Метод POST используется для запроса, чтобы исходный сервер принял объект, заключенный в запросе, как новый подчиненный ресурс, идентифицированный Request-URI в строке запроса. POST разработан, чтобы позволить единообразному методу охватить следующие функции: - Аннотации существующих ресурсов; - размещение сообщения на доске объявлений, в группе новостей, в списке рассылки или в аналогичной группе статей; - Предоставление блока данных, такого как результат отправки формы, процессу обработки данных; - Расширение базы данных с помощью операции добавления. Фактическая функция, выполняемая методом POST, определяется сервером и обычно зависит от Request-URI. Опубликованный объект подчиняется этому URI так же, как файл подчиняется каталогу, содержащему его,новостная статья подчиняется группе новостей, в которой она размещена, или запись подчиняется базе данных. Действие, выполняемое методом POST, может не привести к созданию ресурса, который можно идентифицировать по URI. В этом случае подходящим статусом ответа является либо 200 (ОК), либо 204 (Нет содержимого), в зависимости от того, включает ли ответ сущность, описывающую результат. Если ресурс был создан на исходном сервере, ответ ДОЛЖЕН быть 201 (Создан) и содержать объект, который описывает статус запроса и ссылается на новый ресурс, и заголовок Location (см.В этом случае подходящим статусом ответа является либо 200 (ОК), либо 204 (Нет содержимого), в зависимости от того, включает ли ответ сущность, описывающую результат. Если ресурс был создан на исходном сервере, ответ ДОЛЖЕН быть 201 (Создан) и содержать объект, который описывает статус запроса и ссылается на новый ресурс, и заголовок Location (см.В этом случае подходящим статусом ответа является либо 200 (ОК), либо 204 (Нет содержимого), в зависимости от того, включает ли ответ сущность, описывающую результат. Если ресурс был создан на исходном сервере, ответ ДОЛЖЕН быть 201 (Создан) и содержать объект, который описывает статус запроса и ссылается на новый ресурс, и заголовок Location (см.&lt;a href=&quot;#section-14.30&quot;&gt;раздел 14.30&lt;/a&gt; ). Ответы на этот метод не кэшируются, если ответ не включает соответствующие поля заголовка Cache-Control или Expires. Однако ответ 303 (см. Прочее) может использоваться для указания пользовательскому агенту получить кэшируемый ресурс. Запросы POST ДОЛЖНЫ соответствовать требованиям к передаче сообщений, изложенным в &lt;a href=&quot;#section-8.2&quot;&gt;разделе 8.2&lt;/a&gt; . См. &lt;a href=&quot;#section-15.1.3&quot;&gt;Раздел 15.1.3&lt;/a&gt; по соображениям безопасности.</target>
        </trans-unit>
        <trans-unit id="a7c4a0540415d773e2957d84d1e4f16f405d585a" translate="yes" xml:space="preserve">
          <source>The POST method requests that the target resource process the
   representation enclosed in the request according to the resource's
   own specific semantics.  For example, POST is used for the following
   functions (among others):

   o  Providing a block of data, such as the fields entered into an HTML
      form, to a data-handling process; 

   o  Posting a message to a bulletin board, newsgroup, mailing list,
      blog, or similar group of articles;

   o  Creating a new resource that has yet to be identified by the
      origin server; and

   o  Appending data to a resource's existing representation(s).

   An origin server indicates response semantics by choosing an
   appropriate status code depending on the result of processing the
   POST request; almost all of the status codes defined by this
   specification might be received in a response to POST (the exceptions
   being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not
   Satisfiable)).

   If one or more resources has been created on the origin server as a
   result of successfully processing a POST request, the origin server
   SHOULD send a 201 (Created) response containing a Location header
   field that provides an identifier for the primary resource created
   (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;) and a representation that describes the status of the
   request while referring to the new resource(s).

   Responses to POST requests are only cacheable when they include
   explicit freshness information (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7234]&lt;/a&gt;).
   However, POST caching is not widely implemented.  For cases where an
   origin server wishes the client to be able to cache the result of a
   POST in a way that can be reused by a later GET, the origin server
   MAY send a 200 (OK) response containing the result and a
   Content-Location header field that has the same value as the POST's
   effective request URI (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;).

   If the result of processing a POST would be equivalent to a
   representation of an existing resource, an origin server MAY redirect
   the user agent to that resource by sending a 303 (See Other) response
   with the existing resource's identifier in the Location field.  This
   has the benefits of providing the user agent a resource identifier
   and transferring the representation via a method more amenable to
   shared caching, though at the cost of an extra request if the user
   agent does not already have the representation cached.</source>
          <target state="translated">Метод POST требует, чтобы целевой ресурс обработал представление, заключенное в запросе, в соответствии с собственной конкретной семантикой ресурса. Например, POST используется для следующих функций (среди прочего): o Предоставление блока данных, такого как поля, введенные в форму HTML, процессу обработки данных; o Размещение сообщения на доске объявлений, в группе новостей, в списке рассылки, в блоге или в аналогичной группе статей; o Создание нового ресурса, который еще не идентифицирован исходным сервером; и o Добавление данных к существующим представлениям ресурса. Исходный сервер указывает семантику ответа, выбирая соответствующий код состояния в зависимости от результата обработки запроса POST;почти все коды состояния, определенные этой спецификацией, могут быть получены в ответе на POST (за исключением 206 (частичное содержимое), 304 (не изменено) и 416 (диапазон не удовлетворяется)). Если один или несколько ресурсов были созданы на исходном сервере в результате успешной обработки запроса POST, исходный сервер ДОЛЖЕН отправить ответ 201 (Created), содержащий поле заголовка Location, которое предоставляет идентификатор для созданного основного ресурса (исходному серверу СЛЕДУЕТ отправить ответ 201 (Created), содержащий поле заголовка Location, которое предоставляет идентификатор для созданного первичного ресурса (исходному серверу СЛЕДУЕТ отправить ответ 201 (Created), содержащий поле заголовка Location, которое предоставляет идентификатор для созданного первичного ресурса (&lt;a href=&quot;#section-7.1.2&quot;&gt;Раздел 7.1.2&lt;/a&gt; ) и представление, которое описывает статус запроса при ссылке на новый ресурс (ресурсы). Ответы на запросы POST кэшируются только в том случае, если они включают явную информацию о свежести (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;Раздел 4.2.1 [RFC7234]&lt;/a&gt; ). Однако кэширование POST широко не применяется. В случаях, когда исходный сервер желает, чтобы клиент имел возможность кэшировать результат POST таким образом, чтобы его можно было повторно использовать более поздним GET, исходный сервер МОЖЕТ отправить ответ 200 (OK), содержащий результат и Content-Location. поле заголовка, которое имеет то же значение, что и действующий URI запроса POST ( &lt;a href=&quot;#section-3.1.4.2&quot;&gt;раздел 3.1.4.2&lt;/a&gt;). Если результат обработки POST будет эквивалентен представлению существующего ресурса, исходный сервер МОЖЕТ перенаправить пользовательский агент на этот ресурс, отправив ответ 303 (см. Другое) с идентификатором существующего ресурса в поле Location. Это дает преимущества предоставления пользовательскому агенту идентификатора ресурса и передачи представления с помощью метода, более подходящего для совместного кэширования, хотя и за счет дополнительного запроса, если пользовательский агент еще не кэшировал представление.</target>
        </trans-unit>
        <trans-unit id="babc13478772ae526be737f6ddcf858ed85d894b" translate="yes" xml:space="preserve">
          <source>The PROPFIND method retrieves properties defined on the resource
   identified by the Request-URI, if the resource does not have any
   internal members, or on the resource identified by the Request-URI
   and potentially its member resources, if the resource is a collection
   that has internal member URLs.  All DAV-compliant resources MUST
   support the PROPFIND method and the propfind XML element
   (&lt;a href=&quot;#section-14.20&quot;&gt;Section 14.20&lt;/a&gt;) along with all XML elements defined for use with that
   element.

   A client MUST submit a Depth header with a value of &quot;0&quot;, &quot;1&quot;, or
   &quot;infinity&quot; with a PROPFIND request.  Servers MUST support &quot;0&quot; and &quot;1&quot;
   depth requests on WebDAV-compliant resources and SHOULD support
   &quot;infinity&quot; requests.  In practice, support for infinite-depth
   requests MAY be disabled, due to the performance and security
   concerns associated with this behavior.  Servers SHOULD treat a
   request without a Depth header as if a &quot;Depth: infinity&quot; header was
   included. 

   A client may submit a 'propfind' XML element in the body of the
   request method describing what information is being requested.  It is
   possible to:

   o  Request particular property values, by naming the properties
      desired within the 'prop' element (the ordering of properties in
      here MAY be ignored by the server),

   o  Request property values for those properties defined in this
      specification (at a minimum) plus dead properties, by using the
      'allprop' element (the 'include' element can be used with
      'allprop' to instruct the server to also include additional live
      properties that may not have been returned otherwise),

   o  Request a list of names of all the properties defined on the
      resource, by using the 'propname' element.

   A client may choose not to submit a request body.  An empty PROPFIND
   request body MUST be treated as if it were an 'allprop' request.

   Note that 'allprop' does not return values for all live properties.
   WebDAV servers increasingly have expensively-calculated or lengthy
   properties (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]) and do not return all
   properties already.  Instead, WebDAV clients can use propname
   requests to discover what live properties exist, and request named
   properties when retrieving values.  For a live property defined
   elsewhere, that definition can specify whether or not that live
   property would be returned in 'allprop' requests.

   All servers MUST support returning a response of content type text/
   xml or application/xml that contains a multistatus XML element that
   describes the results of the attempts to retrieve the various
   properties.

   If there is an error retrieving a property, then a proper error
   result MUST be included in the response.  A request to retrieve the
   value of a property that does not exist is an error and MUST be noted
   with a 'response' XML element that contains a 404 (Not Found) status
   value.

   Consequently, the 'multistatus' XML element for a collection resource
   MUST include a 'response' XML element for each member URL of the
   collection, to whatever depth was requested.  It SHOULD NOT include
   any 'response' elements for resources that are not WebDAV-compliant.
   Each 'response' element MUST contain an 'href' element that contains
   the URL of the resource on which the properties in the prop XML
   element are defined.  Results for a PROPFIND on a collection resource
   are returned as a flat list whose order of entries is not 

   significant.  Note that a resource may have only one value for a
   property of a given name, so the property may only show up once in
   PROPFIND responses.

   Properties may be subject to access control.  In the case of
   'allprop' and 'propname' requests, if a principal does not have the
   right to know whether a particular property exists, then the property
   MAY be silently excluded from the response.

   Some PROPFIND results MAY be cached, with care, as there is no cache
   validation mechanism for most properties.  This method is both safe
   and idempotent (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of [RFC2616]&lt;/a&gt;).</source>
          <target state="translated">Метод PROPFIND извлекает свойства, определенные в ресурсе, идентифицированном Request-URI, если ресурс не имеет внутренних членов, или в ресурсе, идентифицированном Request-URI и, возможно, его ресурсах-членах, если ресурс является коллекцией, имеющей внутренние URL-адреса участников. Все DAV-совместимые ресурсы ДОЛЖНЫ поддерживать метод PROPFIND и XML-элемент propfind ( &lt;a href=&quot;#section-14.20&quot;&gt;раздел 14.20.&lt;/a&gt;) вместе со всеми элементами XML, определенными для использования с этим элементом. Клиент ДОЛЖЕН отправить заголовок глубины со значением &amp;laquo;0&amp;raquo;, &amp;laquo;1&amp;raquo; или &amp;laquo;бесконечность&amp;raquo; с запросом PROPFIND. Серверы ДОЛЖНЫ поддерживать запросы глубины &amp;laquo;0&amp;raquo; и &amp;laquo;1&amp;raquo; для ресурсов, совместимых с WebDAV, и ДОЛЖНЫ поддерживать запросы &amp;laquo;бесконечности&amp;raquo;. На практике поддержка запросов бесконечной глубины МОЖЕТ быть отключена из-за проблем производительности и безопасности, связанных с этим поведением. Серверы ДОЛЖНЫ обрабатывать запрос без заголовка Depth, как если бы был включен заголовок &amp;laquo;Depth: infinity&amp;raquo;. Клиент может отправить XML-элемент propfind в теле метода запроса, описывающий, какая информация запрашивается. Можно: o Запросить определенные значения свойств,путем наименования желаемых свойств в элементе 'prop' (порядок свойств здесь МОЖЕТ игнорироваться сервером), o Запросить значения свойств для тех свойств, которые определены в этой спецификации (как минимум), плюс мертвые свойства, используя ' allprop '(элемент' include 'может использоваться с' allprop ', чтобы указать серверу также включать дополнительные живые свойства, которые в противном случае могли бы не быть возвращены), o Запросите список имен всех свойств, определенных для ресурса, с помощью элемента 'propname'. Клиент может отказаться от отправки тела запроса. Пустое тело запроса PROPFIND ДОЛЖНО обрабатываться, как если бы это был запрос allprop. Обратите внимание, что allprop не возвращает значения для всех действующих свойств.Серверы WebDAV все чаще имеют дорогостоящие или длительные свойства (см. [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ] и [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]) и уже не возвращать все свойства. Вместо этого клиенты WebDAV могут использовать запросы propname, чтобы обнаружить, какие существующие свойства существуют, и запрашивать именованные свойства при извлечении значений. Для живого свойства, определенного в другом месте, это определение может указывать, будет ли это живое свойство возвращаться в запросах allprop. Все серверы ДОЛЖНЫ поддерживать возврат ответа типа содержимого text / xml или application / xml, который содержит элемент XML с несколькими состояниями, который описывает результаты попыток получить различные свойства. Если при получении свойства произошла ошибка, то в ответ ДОЛЖЕН быть включен правильный результат ошибки. Запрос на получение значения несуществующего свойства является ошибкой и ДОЛЖЕН быть отмечен как &amp;laquo;ответ&amp;raquo;.Элемент XML, содержащий значение статуса 404 (не найдено). Следовательно, элемент XML &amp;laquo;мультистатус&amp;raquo; для ресурса коллекции ДОЛЖЕН включать элемент XML &amp;laquo;ответ&amp;raquo; для каждого URL-адреса члена коллекции, независимо от запрошенной глубины. Он НЕ ДОЛЖЕН включать никаких элементов ответа для ресурсов, не совместимых с WebDAV. Каждый элемент response ДОЛЖЕН содержать элемент href, который содержит URL ресурса, для которого определены свойства в элементе prop XML. Результаты для PROPFIND на ресурсе коллекции возвращаются в виде плоского списка, порядок записей которого не имеет значения. Обратите внимание, что ресурс может иметь только одно значение для свойства с заданным именем, поэтому свойство может отображаться только один раз в ответах PROPFIND.Свойства могут подлежать контролю доступа. В случае запросов allprop и propname, если принципал не имеет права знать, существует ли конкретное свойство, то свойство МОЖЕТ быть молча исключено из ответа. Некоторые результаты PROPFIND МОГУТ быть кэшированы с осторожностью, так как для большинства свойств нет механизма проверки кеша. Этот метод безопасен и идемпотентен (см.&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Раздел 9.1 [RFC2616]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="63b7604adf362cf9b58baac42bf0c778df2e71b7" translate="yes" xml:space="preserve">
          <source>The PROPPATCH method processes instructions specified in the request
   body to set and/or remove properties defined on the resource
   identified by the Request-URI.

   All DAV-compliant resources MUST support the PROPPATCH method and
   MUST process instructions that are specified using the
   propertyupdate, set, and remove XML elements.  Execution of the
   directives in this method is, of course, subject to access control
   constraints.  DAV-compliant resources SHOULD support the setting of
   arbitrary dead properties.

   The request message body of a PROPPATCH method MUST contain the
   propertyupdate XML element.

   Servers MUST process PROPPATCH instructions in document order (an
   exception to the normal rule that ordering is irrelevant).
   Instructions MUST either all be executed or none executed.  Thus, if
   any error occurs during processing, all executed instructions MUST be
   undone and a proper error result returned.  Instruction processing
   details can be found in the definition of the set and remove
   instructions in Sections &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; and &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;.

   If a server attempts to make any of the property changes in a
   PROPPATCH request (i.e., the request is not rejected for high-level
   errors before processing the body), the response MUST be a Multi-
   Status response as described in &lt;a href=&quot;#section-9.2.1&quot;&gt;Section 9.2.1&lt;/a&gt;.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">Метод PROPPATCH обрабатывает инструкции, указанные в теле запроса, для установки и / или удаления свойств, определенных для ресурса, идентифицированного Request-URI. Все DAV-совместимые ресурсы ДОЛЖНЫ поддерживать метод PROPPATCH и ДОЛЖНЫ обрабатывать инструкции, указанные с помощью элементов XML propertyupdate, set и remove. Выполнение директив в этом методе, конечно, зависит от ограничений управления доступом. Ресурсы, совместимые с DAV, ДОЛЖНЫ поддерживать установку произвольных мертвых свойств. Тело сообщения запроса метода PROPPATCH ДОЛЖНО содержать XML-элемент propertyupdate. Серверы ДОЛЖНЫ обрабатывать инструкции PROPPATCH в порядке документа (исключение из обычного правила, что порядок не имеет значения). Инструкции ДОЛЖНЫ выполняться либо все, либо ни одна из них. Таким образом,если во время обработки возникает какая-либо ошибка, все выполненные инструкции ДОЛЖНЫ быть отменены и возвращен правильный результат ошибки. Подробности обработки инструкций можно найти в определении инструкций установки и удаления в разделах&lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; и &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; . Если сервер пытается внести какие-либо изменения свойств в запросе PROPPATCH (т. Е. Запрос не отклоняется из-за ошибок высокого уровня до обработки тела), ответ ДОЛЖЕН быть ответом с несколькими состояниями, как описано в &lt;a href=&quot;#section-9.2.1&quot;&gt;разделе 9.2.1.&lt;/a&gt; , Этот метод идемпотентен, но небезопасен (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Раздел 9.1 [RFC2616]&lt;/a&gt; ). Ответы на этот метод НЕ ДОЛЖНЫ кэшироваться.</target>
        </trans-unit>
        <trans-unit id="1975f22fa255d880d63431b9c6a1e839eaebbdbb" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the enclosed entity be stored under the
   supplied Request-URI. If the Request-URI refers to an already
   existing resource, the enclosed entity SHOULD be considered as a
   modified version of the one residing on the origin server. If the
   Request-URI does not point to an existing resource, and that URI is
   capable of being defined as a new resource by the requesting user
   agent, the origin server can create the resource with that URI. If a
   new resource is created, the origin server MUST inform the user agent
   via the 201 (Created) response. If an existing resource is modified,
   either the 200 (OK) or 204 (No Content) response codes SHOULD be sent
   to indicate successful completion of the request. If the resource
   could not be created or modified with the Request-URI, an appropriate
   error response SHOULD be given that reflects the nature of the
   problem. The recipient of the entity MUST NOT ignore any Content-*
   (e.g. Content-Range) headers that it does not understand or implement
   and MUST return a 501 (Not Implemented) response in such cases.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.

   The fundamental difference between the POST and PUT requests is
   reflected in the different meaning of the Request-URI. The URI in a
   POST request identifies the resource that will handle the enclosed
   entity. That resource might be a data-accepting process, a gateway to
   some other protocol, or a separate entity that accepts annotations.
   In contrast, the URI in a PUT request identifies the entity enclosed
   with the request -- the user agent knows what URI is intended and the
   server MUST NOT attempt to apply the request to some other resource.
   If the server desires that the request be applied to a different URI, 

   it MUST send a 301 (Moved Permanently) response; the user agent MAY
   then make its own decision regarding whether or not to redirect the
   request.

   A single resource MAY be identified by many different URIs. For
   example, an article might have a URI for identifying &quot;the current
   version&quot; which is separate from the URI identifying each particular
   version. In this case, a PUT request on a general URI might result in
   several other URIs being defined by the origin server.

   HTTP/1.1 does not define how a PUT method affects the state of an
   origin server.

   PUT requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   Unless otherwise specified for a particular entity-header, the
   entity-headers in the PUT request SHOULD be applied to the resource
   created or modified by the PUT.</source>
          <target state="translated">Метод PUT запрашивает, чтобы закрытый объект был сохранен под предоставленным Request-URI. Если Request-URI относится к уже существующему ресурсу, вложенный объект СЛЕДУЕТ рассматривать как модифицированную версию того, что находится на исходном сервере. Если Request-URI не указывает на существующий ресурс и этот URI может быть определен как новый ресурс запрашивающим пользовательским агентом, исходный сервер может создать ресурс с этим URI. Если создается новый ресурс, исходный сервер ДОЛЖЕН проинформировать пользовательский агент через ответ 201 (Created). Если существующий ресурс изменен, ДОЛЖНЫ быть отправлены коды ответа 200 (ОК) или 204 (Нет содержимого), чтобы указать на успешное завершение запроса. Если ресурс не может быть создан или изменен с помощью Request-URI,ДОЛЖЕН быть предоставлен соответствующий ответ об ошибке, который отражает характер проблемы. Получатель объекта НЕ ДОЛЖЕН игнорировать какие-либо заголовки Content- * (например, Content-Range), которые он не понимает или не реализует, и ДОЛЖЕН возвращать ответ 501 (не реализовано) в таких случаях. Если запрос проходит через кеш и Request-URI идентифицирует один или несколько кэшированных в данный момент объектов, эти записи СЛЕДУЕТ рассматривать как устаревшие. Ответы на этот метод не кэшируются. Принципиальная разница между запросами POST и PUT отражается в различном значении Request-URI. URI в запросе POST определяет ресурс, который будет обрабатывать вложенный объект. Этот ресурс может быть процессом приема данных, шлюзом к другому протоколу или отдельным объектом, который принимает аннотации.Напротив, URI в запросе PUT идентифицирует объект, заключенный с запросом - пользовательский агент знает, какой URI предназначен, и сервер НЕ ДОЛЖЕН пытаться применить запрос к какому-либо другому ресурсу. Если сервер желает, чтобы запрос был применен к другому URI, он ДОЛЖЕН отправить ответ 301 (перемещен навсегда); затем пользовательский агент МОЖЕТ принять собственное решение относительно перенаправления запроса. Один ресурс МОЖЕТ идентифицироваться множеством разных URI. Например, статья может иметь URI для идентификации &amp;laquo;текущей версии&amp;raquo;, который отличается от URI, идентифицирующего каждую конкретную версию. В этом случае запрос PUT для общего URI может привести к тому, что сервер-источник определит несколько других URI. HTTP / 1.1 не определяет, как метод PUT влияет на состояние исходного сервера. Запросы PUT ДОЛЖНЫ подчиняться требованиям передачи сообщений, изложенным в&lt;a href=&quot;#section-8.2&quot;&gt;раздел 8.2&lt;/a&gt; . Если иное не указано для конкретного заголовка объекта, заголовки объекта в запросе PUT ДОЛЖНЫ применяться к ресурсу, созданному или измененному PUT.</target>
        </trans-unit>
        <trans-unit id="7beb3539a595c62f6de09ee642f7b3a560d38b59" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the state of the target resource be
   created or replaced with the state defined by the representation
   enclosed in the request message payload.  A successful PUT of a given
   representation would suggest that a subsequent GET on that same
   target resource will result in an equivalent representation being
   sent in a 200 (OK) response.  However, there is no guarantee that 

   such a state change will be observable, since the target resource
   might be acted upon by other user agents in parallel, or might be
   subject to dynamic processing by the origin server, before any
   subsequent GET is received.  A successful response only implies that
   the user agent's intent was achieved at the time of its processing by
   the origin server.

   If the target resource does not have a current representation and the
   PUT successfully creates one, then the origin server MUST inform the
   user agent by sending a 201 (Created) response.  If the target
   resource does have a current representation and that representation
   is successfully modified in accordance with the state of the enclosed
   representation, then the origin server MUST send either a 200 (OK) or
   a 204 (No Content) response to indicate successful completion of the
   request.

   An origin server SHOULD ignore unrecognized header fields received in
   a PUT request (i.e., do not save them as part of the resource state).

   An origin server SHOULD verify that the PUT representation is
   consistent with any constraints the server has for the target
   resource that cannot or will not be changed by the PUT.  This is
   particularly important when the origin server uses internal
   configuration information related to the URI in order to set the
   values for representation metadata on GET responses.  When a PUT
   representation is inconsistent with the target resource, the origin
   server SHOULD either make them consistent, by transforming the
   representation or changing the resource configuration, or respond
   with an appropriate error message containing sufficient information
   to explain why the representation is unsuitable.  The 409 (Conflict)
   or 415 (Unsupported Media Type) status codes are suggested, with the
   latter being specific to constraints on Content-Type values.

   For example, if the target resource is configured to always have a
   Content-Type of &quot;text/html&quot; and the representation being PUT has a
   Content-Type of &quot;image/jpeg&quot;, the origin server ought to do one of:

   a.  reconfigure the target resource to reflect the new media type;

   b.  transform the PUT representation to a format consistent with that
       of the resource before saving it as the new resource state; or,

   c.  reject the request with a 415 (Unsupported Media Type) response
       indicating that the target resource is limited to &quot;text/html&quot;,
       perhaps including a link to a different resource that would be a
       suitable target for the new representation. 

   HTTP does not define exactly how a PUT method affects the state of an
   origin server beyond what can be expressed by the intent of the user
   agent request and the semantics of the origin server response.  It
   does not define what a resource might be, in any sense of that word,
   beyond the interface provided via HTTP.  It does not define how
   resource state is &quot;stored&quot;, nor how such storage might change as a
   result of a change in resource state, nor how the origin server
   translates resource state into representations.  Generally speaking,
   all implementation details behind the resource interface are
   intentionally hidden by the server.

   An origin server MUST NOT send a validator header field
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;), such as an ETag or Last-Modified field, in a
   successful response to PUT unless the request's representation data
   was saved without any transformation applied to the body (i.e., the
   resource's new representation data is identical to the representation
   data received in the PUT request) and the validator field value
   reflects the new representation.  This requirement allows a user
   agent to know when the representation body it has in memory remains
   current as a result of the PUT, thus not in need of being retrieved
   again from the origin server, and that the new validator(s) received
   in the response can be used for future conditional requests in order
   to prevent accidental overwrites (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

   The fundamental difference between the POST and PUT methods is
   highlighted by the different intent for the enclosed representation.
   The target resource in a POST request is intended to handle the
   enclosed representation according to the resource's own semantics,
   whereas the enclosed representation in a PUT request is defined as
   replacing the state of the target resource.  Hence, the intent of PUT
   is idempotent and visible to intermediaries, even though the exact
   effect is only known by the origin server.

   Proper interpretation of a PUT request presumes that the user agent
   knows which target resource is desired.  A service that selects a
   proper URI on behalf of the client, after receiving a state-changing
   request, SHOULD be implemented using the POST method rather than PUT.
   If the origin server will not make the requested PUT state change to
   the target resource and instead wishes to have it applied to a
   different resource, such as when the resource has been moved to a
   different URI, then the origin server MUST send an appropriate 3xx
   (Redirection) response; the user agent MAY then make its own decision
   regarding whether or not to redirect the request.

   A PUT request applied to the target resource can have side effects on
   other resources.  For example, an article might have a URI for
   identifying &quot;the current version&quot; (a resource) that is separate from
   the URIs identifying each particular version (different resources 

   that at one point shared the same state as the current version
   resource).  A successful PUT request on &quot;the current version&quot; URI
   might therefore create a new version resource in addition to changing
   the state of the target resource, and might also cause links to be
   added between the related resources.

   An origin server that allows PUT on a given target resource MUST send
   a 400 (Bad Request) response to a PUT request that contains a
   Content-Range header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7233]&lt;/a&gt;), since the
   payload is likely to be partial content that has been mistakenly PUT
   as a full representation.  Partial content updates are possible by
   targeting a separately identified resource with state that overlaps a
   portion of the larger resource, or by using a different method that
   has been specifically defined for partial updates (for example, the
   PATCH method defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt;]).

   Responses to the PUT method are not cacheable.  If a successful PUT
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">Метод PUT требует, чтобы состояние целевого ресурса было создано или заменено состоянием, определенным представлением, заключенным в полезные данные сообщения запроса. Успешный PUT данного представления предполагает, что последующий GET для того же целевого ресурса приведет к отправке эквивалентного представления в ответе 200 (OK). Однако нет никакой гарантии, что такое изменение состояния будет наблюдаемым, поскольку целевой ресурс может обрабатываться другими пользовательскими агентами параллельно или может подвергаться динамической обработке исходным сервером до получения любого последующего GET. Успешный ответ только означает, что намерение пользовательского агента было достигнуто во время его обработки исходным сервером.Если целевой ресурс не имеет текущего представления и PUT успешно его создает, то исходный сервер ДОЛЖЕН проинформировать пользовательский агент, отправив ответ 201 (Создано). Если целевой ресурс действительно имеет текущее представление и это представление успешно модифицируется в соответствии с состоянием вложенного представления, то исходный сервер ДОЛЖЕН отправить ответ 200 (ОК) или 204 (Нет содержимого), чтобы указать на успешное завершение запрос. Сервер-источник ДОЛЖЕН игнорировать нераспознанные поля заголовка, полученные в запросе PUT (т. Е. Не сохранять их как часть состояния ресурса). Исходный сервер ДОЛЖЕН проверять, что представление PUT согласуется с любыми ограничениями, которые сервер имеет для целевого ресурса, которые не могут или не будут изменены PUT.Это особенно важно, когда исходный сервер использует внутреннюю информацию о конфигурации, связанную с URI, для установки значений для метаданных представления в ответах GET. Когда представление PUT несовместимо с целевым ресурсом, исходный сервер ДОЛЖЕН либо сделать их согласованными, преобразовав представление или изменив конфигурацию ресурса, либо ответить соответствующим сообщением об ошибке, содержащим достаточно информации, чтобы объяснить, почему представление непригодно. Предлагаются коды состояния 409 (конфликт) или 415 (неподдерживаемый тип носителя), причем последний относится к ограничениям на значения Content-Type. Например, если целевой ресурс настроен так, чтобы всегда иметь Content-Type &amp;laquo;text / html&amp;raquo;и представление PUT имеет Content-Type &quot;image / jpeg&quot;, исходный сервер должен выполнить одно из следующих действий: a. перенастроить целевой ресурс для отражения нового типа носителя; б. преобразовать представление PUT в формат, совместимый с форматом ресурса, перед сохранением его в качестве нового состояния ресурса; или, c. отклонить запрос с ответом 415 (неподдерживаемый тип мультимедиа), указывающим, что целевой ресурс ограничен &amp;laquo;текстом / html&amp;raquo;, возможно, включая ссылку на другой ресурс, который будет подходящей целью для нового представления. HTTP не определяет точно, как метод PUT влияет на состояние исходного сервера, помимо того, что может быть выражено намерением запроса пользовательского агента и семантикой ответа исходного сервера.Он не определяет, каким может быть ресурс в любом смысле этого слова, помимо интерфейса, предоставляемого через HTTP. Он не определяет, как &amp;laquo;сохраняется&amp;raquo; состояние ресурса, ни то, как такое хранилище может измениться в результате изменения состояния ресурса, ни то, как исходный сервер переводит состояние ресурса в представления. Вообще говоря, все детали реализации интерфейса ресурса намеренно скрыты сервером. Исходный сервер НЕ ДОЛЖЕН отправлять поле заголовка валидатора (все детали реализации за интерфейсом ресурса намеренно скрыты сервером. Исходный сервер НЕ ДОЛЖЕН отправлять поле заголовка валидатора (все детали реализации за интерфейсом ресурса намеренно скрыты сервером. Исходный сервер НЕ ДОЛЖЕН отправлять поле заголовка валидатора (&lt;a href=&quot;#section-7.2&quot;&gt;Раздел 7.2&lt;/a&gt; ), например, поле ETag или Last-Modified, в успешном ответе на PUT, если данные представления запроса не были сохранены без какого-либо преобразования, примененного к телу (т. Е. Новые данные представления ресурса идентичны данным представления, полученным в запрос PUT), а значение поля валидатора отражает новое представление. Это требование позволяет пользовательскому агенту знать, когда тело представления, которое он имеет в памяти, остается текущим в результате PUT, таким образом, не нуждается в повторном получении с исходного сервера, и что новый валидатор (-ы), полученный в ответе может использоваться для будущих условных запросов, чтобы предотвратить случайную перезапись ( &lt;a href=&quot;#section-5.2&quot;&gt;Раздел 5.2&lt;/a&gt;). Принципиальное различие между методами POST и PUT подчеркивается разным предназначением вложенного представления. Целевой ресурс в запросе POST предназначен для обработки вложенного представления в соответствии с собственной семантикой ресурса, тогда как вложенное представление в запросе PUT определяется как заменяющее состояние целевого ресурса. Следовательно, цель PUT идемпотентна и видна посредникам, даже если точный эффект известен только исходному серверу. Правильная интерпретация запроса PUT предполагает, что пользовательский агент знает, какой целевой ресурс требуется. Сервис, который выбирает правильный URI от имени клиента после получения запроса на изменение состояния, ДОЛЖЕН быть реализован с использованием метода POST, а не PUT.Если исходный сервер не будет выполнять запрошенное изменение состояния PUT для целевого ресурса и вместо этого хочет, чтобы оно было применено к другому ресурсу, например, когда ресурс был перемещен на другой URI, тогда исходный сервер ДОЛЖЕН отправить соответствующий 3xx (Перенаправление) ответ; затем пользовательский агент МОЖЕТ принять собственное решение относительно перенаправления запроса. Запрос PUT, примененный к целевому ресурсу, может иметь побочные эффекты для других ресурсов. Например, статья может иметь URI для идентификации &amp;laquo;текущей версии&amp;raquo; (ресурса), который отличается от URI, идентифицирующих каждую конкретную версию (разные ресурсы, которые в какой-то момент имели то же состояние, что и ресурс текущей версии). Успешный запрос PUT для &amp;laquo;текущей версии&amp;raquo;Таким образом, URI может создавать ресурс новой версии в дополнение к изменению состояния целевого ресурса, а также может вызывать добавление ссылок между связанными ресурсами. Сервер-источник, который разрешает PUT для данного целевого ресурса, ДОЛЖЕН отправить ответ 400 (Bad Request) на запрос PUT, который содержит поле заголовка Content-Range (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;Раздел 4.2 [RFC7233]&lt;/a&gt; ), поскольку полезная нагрузка, скорее всего, является частичным содержанием, которое было ошибочно PUT как полное представление. Частичные обновления контента возможны путем нацеливания на отдельно идентифицированный ресурс с состоянием, которое перекрывает часть большего ресурса, или с использованием другого метода, который был специально определен для частичных обновлений (например, метод PATCH, определенный в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt; ]). Ответы на метод PUT не кэшируются. Если успешный запрос PUT проходит через кеш, в котором есть один или несколько сохраненных ответов для действующего URI запроса, эти сохраненные ответы будут признаны недействительными (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Раздел 4.4 [RFC7234]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6e42dfbab6315a9d1786cb94b26bfc16b764a831" translate="yes" xml:space="preserve">
          <source>The Pragma general-header field is used to include implementation-
   specific directives that might apply to any recipient along the
   request/response chain. All pragma directives specify optional
   behavior from the viewpoint of the protocol; however, some systems
   MAY require that behavior be consistent with the directives.

       Pragma            = &quot;Pragma&quot; &quot;:&quot; 1#pragma-directive
       pragma-directive  = &quot;no-cache&quot; | extension-pragma
       extension-pragma  = token [ &quot;=&quot; ( token | quoted-string ) ]

   When the no-cache directive is present in a request message, an
   application SHOULD forward the request toward the origin server even
   if it has a cached copy of what is being requested. This pragma
   directive has the same semantics as the no-cache cache-directive (see
   &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;) and is defined here for backward compatibility with
   HTTP/1.0. Clients SHOULD include both header fields when a no-cache
   request is sent to a server not known to be HTTP/1.1 compliant. 

   Pragma directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a pragma for a
   specific recipient; however, any pragma directive not relevant to a
   recipient SHOULD be ignored by that recipient.

   HTTP/1.1 caches SHOULD treat &quot;Pragma: no-cache&quot; as if the client had
   sent &quot;Cache-Control: no-cache&quot;. No new Pragma directives will be
   defined in HTTP.

      Note: because the meaning of &quot;Pragma: no-cache as a response
      header field is not actually specified, it does not provide a
      reliable replacement for &quot;Cache-Control: no-cache&quot; in a response</source>
          <target state="translated">Поле общего заголовка Pragma используется для включения директив, зависящих от реализации, которые могут применяться к любому получателю в цепочке запроса / ответа. Все директивы pragma определяют необязательное поведение с точки зрения протокола; однако некоторые системы МОГУТ требовать, чтобы поведение соответствовало директивам. Pragma = &quot;Pragma&quot; &quot;:&quot; 1 # директива-директива pragma-directive = &quot;no-cache&quot; | extension-pragma extension-pragma = token [&quot;=&quot; (token | quoted-string)] Когда директива no-cache присутствует в сообщении запроса, приложение ДОЛЖНО пересылать запрос исходному серверу, даже если у него есть кешированная копия того, что запрашивается. Эта директива pragma имеет ту же семантику, что и директива кеширования no-cache (см. &lt;a href=&quot;#section-14.9&quot;&gt;Раздел 14.9.&lt;/a&gt;) и определен здесь для обратной совместимости с HTTP / 1.0. Клиенты ДОЛЖНЫ включать оба поля заголовка, когда запрос без кеширования отправляется на сервер, который, как известно, не совместим с HTTP / 1.1. Директивы Pragma ДОЛЖНЫ проходить через прокси-сервер или приложение-шлюз, независимо от их значения для этого приложения, поскольку директивы могут применяться ко всем получателям в цепочке запросов / ответов. Невозможно указать прагму для конкретного получателя; однако любая директива pragma, не относящаяся к получателю, ДОЛЖНА игнорироваться этим получателем. Кеши HTTP / 1.1 ДОЛЖНЫ обрабатывать &amp;laquo;Pragma: no-cache&amp;raquo;, как если бы клиент отправил &amp;laquo;Cache-Control: no-cache&amp;raquo;. Никакие новые директивы Pragma не будут определены в HTTP. Примечание: поскольку значение &amp;laquo;Прагма:no-cache в качестве поля заголовка ответа на самом деле не указано, он не обеспечивает надежную замену &quot;Cache-Control: no-cache&quot; в ответе</target>
        </trans-unit>
        <trans-unit id="871bcdf53c1b79539586617d7fc176e073aa2706" translate="yes" xml:space="preserve">
          <source>The Proxy-Authenticate response-header field MUST be included as part
   of a 407 (Proxy Authentication Required) response. The field value
   consists of a challenge that indicates the authentication scheme and
   parameters applicable to the proxy for this Request-URI.

       Proxy-Authenticate  = &quot;Proxy-Authenticate&quot; &quot;:&quot; 1#challenge

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. Unlike
   WWW-Authenticate, the Proxy-Authenticate header field applies only to
   the current connection and SHOULD NOT be passed on to downstream
   clients. However, an intermediate proxy might need to obtain its own
   credentials by requesting them from the downstream client, which in
   some circumstances will appear as if the proxy is forwarding the
   Proxy-Authenticate header field.</source>
          <target state="translated">Поле заголовка ответа Proxy-Authenticate ДОЛЖНО быть включено как часть ответа 407 (Proxy Authentication Required). Значение поля состоит из запроса, который указывает схему аутентификации и параметры, применимые к прокси для этого Request-URI. Proxy-Authenticate = &quot;Proxy-Authenticate&quot; &quot;:&quot; 1 # проблема Процесс аутентификации HTTP-доступа описан в &quot;HTTP-аутентификации: базовая и дайджест-аутентификация доступа&quot; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. В отличие от WWW-Authenticate, поле заголовка Proxy-Authenticate применяется только к текущему соединению и НЕ ДОЛЖНО передаваться нижестоящим клиентам. Однако промежуточному прокси-серверу может потребоваться получить свои собственные учетные данные, запросив их у нижестоящего клиента, что в некоторых случаях будет выглядеть так, как если бы прокси пересылал поле заголовка Proxy-Authenticate.</target>
        </trans-unit>
        <trans-unit id="ad6052a85e2e7f8497d8ed5920ca77e487770b52" translate="yes" xml:space="preserve">
          <source>The Proxy-Authorization request-header field allows the client to
   identify itself (or its user) to a proxy which requires
   authentication. The Proxy-Authorization field value consists of
   credentials containing the authentication information of the user
   agent for the proxy and/or realm of the resource being requested.

       Proxy-Authorization     = &quot;Proxy-Authorization&quot; &quot;:&quot; credentials

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;] . Unlike
   Authorization, the Proxy-Authorization header field applies only to
   the next outbound proxy that demanded authentication using the Proxy-
   Authenticate field. When multiple proxies are used in a chain, the 

   Proxy-Authorization header field is consumed by the first outbound
   proxy that was expecting to receive credentials. A proxy MAY relay
   the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.</source>
          <target state="translated">Поле заголовка запроса Proxy-Authorization позволяет клиенту идентифицировать себя (или своего пользователя) для прокси, который требует аутентификации. Значение поля Proxy-Authorization состоит из учетных данных, содержащих информацию аутентификации пользовательского агента для прокси и / или области запрашиваемого ресурса. Proxy-Authorization = &quot;Proxy-Authorization&quot; &quot;:&quot; учетные данные Процесс аутентификации HTTP-доступа описан в &quot;HTTP-аутентификации: базовая и дайджест-аутентификация доступа&quot; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. В отличие от авторизации, поле заголовка Proxy-Authorization применяется только к следующему исходящему прокси-серверу, который потребовал аутентификации с использованием поля Proxy-Authenticate. Когда в цепочке используются несколько прокси, поле заголовка Proxy-Authorization используется первым исходящим прокси, который ожидал получить учетные данные. Прокси-сервер МОЖЕТ передавать учетные данные из клиентского запроса следующему прокси-серверу, если это механизм, с помощью которого прокси-серверы совместно аутентифицируют данный запрос.</target>
        </trans-unit>
        <trans-unit id="a2e20c61425846c0564c678e617e3a0e40ac8e14" translate="yes" xml:space="preserve">
          <source>The Referer[sic] request-header field allows the client to specify,
   for the server's benefit, the address (URI) of the resource from
   which the Request-URI was obtained (the &quot;referrer&quot;, although the
   header field is misspelled.) The Referer request-header allows a
   server to generate lists of back-links to resources for interest,
   logging, optimized caching, etc. It also allows obsolete or mistyped
   links to be traced for maintenance. The Referer field MUST NOT be
   sent if the Request-URI was obtained from a source that does not have
   its own URI, such as input from the user keyboard.

       Referer        = &quot;Referer&quot; &quot;:&quot; ( absoluteURI | relativeURI )

   Example:

       Referer: &lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http://www.w3.org/hypertext/DataSources/Overview.html&lt;/a&gt; 

   If the field value is a relative URI, it SHOULD be interpreted
   relative to the Request-URI. The URI MUST NOT include a fragment. See
   &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">Поле заголовка запроса Referer [sic] позволяет клиенту указать, для удобства сервера, адрес (URI) ресурса, из которого был получен Request-URI (&quot;реферер&quot;, хотя в поле заголовка написано с ошибкой). Заголовок запроса Referer позволяет серверу создавать списки обратных ссылок на ресурсы для интереса, ведения журнала, оптимизированного кэширования и т. Д. Он также позволяет отслеживать устаревшие или ошибочно введенные ссылки для обслуживания. Поле Referer НЕ ДОЛЖНО отправляться, если Request-URI был получен из источника, не имеющего своего собственного URI, такого как ввод с пользовательской клавиатуры. Referer = &quot;Referer&quot; &quot;:&quot; (absoluteURI | relativeURI) Пример: Referer: &lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http://www.w3.org/hypertext/DataSources/Overview.html&lt;/a&gt; Если значение поля является относительным URI, его СЛЕДУЕТ интерпретировать относительно Request-URI. URI НЕ ДОЛЖЕН включать фрагмент. См. &lt;a href=&quot;#section-15.1.3&quot;&gt;Раздел 15.1.3&lt;/a&gt; по соображениям безопасности.</target>
        </trans-unit>
        <trans-unit id="ada285615064adfa5d8e8460b22e8d2e1a9f7a60" translate="yes" xml:space="preserve">
          <source>The Request-Line begins with a method token, followed by the
   Request-URI and the protocol version, and ending with CRLF. The
   elements are separated by SP characters. No CR or LF is allowed
   except in the final CRLF sequence.

        Request-Line   = Method SP Request-URI SP HTTP-Version CRLF</source>
          <target state="translated">Линия запросов начинается с маркера метода,за которым следует Request-URI и версия протокола,и заканчивается CRLF.Элементы разделены символами SP.Ни CR,ни LF не допускаются,кроме как в окончательной последовательности CRLF.Request-Line=метод SP Request-URI SP HTTP-Version CRLF.</target>
        </trans-unit>
        <trans-unit id="8314c65661bfa76aafcdfccc2a0cabd4c8b07f40" translate="yes" xml:space="preserve">
          <source>The Request-URI is a Uniform Resource Identifier (&lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;) and
   identifies the resource upon which to apply the request.

       Request-URI    = &quot;*&quot; | absoluteURI | abs_path | authority

   The four options for Request-URI are dependent on the nature of the
   request. The asterisk &quot;*&quot; means that the request does not apply to a
   particular resource, but to the server itself, and is only allowed
   when the method used does not necessarily apply to a resource. One
   example would be

       OPTIONS * HTTP/1.1

   The absoluteURI form is REQUIRED when the request is being made to a
   proxy. The proxy is requested to forward the request or service it
   from a valid cache, and return the response. Note that the proxy MAY
   forward the request on to another proxy or directly to the server 

   specified by the absoluteURI. In order to avoid request loops, a
   proxy MUST be able to recognize all of its server names, including
   any aliases, local variations, and the numeric IP address. An example
   Request-Line would be:

       GET &lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP/1.1

   To allow for transition to absoluteURIs in all requests in future
   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI
   form in requests, even though HTTP/1.1 clients will only generate
   them in requests to proxies.

   The authority form is only used by the CONNECT method (&lt;a href=&quot;#section-9.9&quot;&gt;section 9.9&lt;/a&gt;).

   The most common form of Request-URI is that used to identify a
   resource on an origin server or gateway. In this case the absolute
   path of the URI MUST be transmitted (see &lt;a href=&quot;#section-3.2.1&quot;&gt;section 3.2.1&lt;/a&gt;, abs_path) as
   the Request-URI, and the network location of the URI (authority) MUST
   be transmitted in a Host header field. For example, a client wishing
   to retrieve the resource above directly from the origin server would
   create a TCP connection to port 80 of the host &quot;www.w3.org&quot; and send
   the lines:

       GET /pub/WWW/TheProject.html HTTP/1.1
       Host: www.w3.org

   followed by the remainder of the Request. Note that the absolute path
   cannot be empty; if none is present in the original URI, it MUST be
   given as &quot;/&quot; (the server root).

   The Request-URI is transmitted in the format specified in &lt;a href=&quot;#section-3.2.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;. If the Request-URI is encoded using the &quot;% HEX HEX&quot; encoding
   [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;], the origin server MUST decode the Request-URI in order to
   properly interpret the request. Servers SHOULD respond to invalid
   Request-URIs with an appropriate status code.

   A transparent proxy MUST NOT rewrite the &quot;abs_path&quot; part of the
   received Request-URI when forwarding it to the next inbound server,
   except as noted above to replace a null abs_path with &quot;/&quot;.

      Note: The &quot;no rewrite&quot; rule prevents the proxy from changing the
      meaning of the request when the origin server is improperly using
      a non-reserved URI character for a reserved purpose.  Implementors
      should be aware that some pre-HTTP/1.1 proxies have been known to
      rewrite the Request-URI.</source>
          <target state="translated">Request-URI - это универсальный идентификатор ресурса ( &lt;a href=&quot;#section-3.2&quot;&gt;раздел 3.2.&lt;/a&gt;) и определяет ресурс, к которому следует применить запрос. Request-URI = &quot;*&quot; | absoluteURI | abs_path | Authority Четыре варианта Request-URI зависят от характера запроса. Звездочка &amp;laquo;*&amp;raquo; означает, что запрос не применяется к определенному ресурсу, а к самому серверу, и разрешен только в том случае, если используемый метод не обязательно применим к ресурсу. Одним из примеров может быть OPTIONS * HTTP / 1.1. Форма absoluteURI НЕОБХОДИМА, когда запрос делается к прокси. Прокси-сервер запрашивается для пересылки запроса или обслуживания его из допустимого кеша и возврата ответа. Обратите внимание, что прокси МОЖЕТ перенаправить запрос на другой прокси или непосредственно на сервер, указанный в absoluteURI. Чтобы избежать зацикливания запросов,прокси-сервер ДОЛЖЕН быть в состоянии распознавать все свои имена серверов, включая любые псевдонимы, локальные варианты и числовой IP-адрес. Пример строки запроса: GET&lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP / 1.1 Чтобы разрешить переход на absoluteURI во всех запросах в будущих версиях HTTP, все серверы HTTP / 1.1 ДОЛЖНЫ принимать форму absoluteURI в запросах, даже если Клиенты HTTP / 1.1 будут генерировать их только в запросах к прокси. Форма полномочий используется только методом CONNECT ( &lt;a href=&quot;#section-9.9&quot;&gt;раздел 9.9&lt;/a&gt; ). Наиболее распространенная форма Request-URI - это та, которая используется для идентификации ресурса на исходном сервере или шлюзе. В этом случае ДОЛЖЕН быть передан абсолютный путь URI (см. &lt;a href=&quot;#section-3.2.1&quot;&gt;Раздел 3.2.1.&lt;/a&gt;, abs_path) как Request-URI, а сетевое местоположение URI (полномочия) ДОЛЖНО передаваться в поле заголовка Host. Например, клиент, желающий получить указанный выше ресурс непосредственно с исходного сервера, должен создать TCP-соединение с портом 80 хоста &amp;laquo;www.w3.org&amp;raquo; и отправить строки: GET /pub/WWW/TheProject.html HTTP / 1.1 Хост: www.w3.org, за которым следует оставшаяся часть запроса. Обратите внимание, что абсолютный путь не может быть пустым; если в исходном URI ничего нет, он ДОЛЖЕН быть указан как &amp;laquo;/&amp;raquo; (корень сервера). Request-URI передается в формате, указанном в &lt;a href=&quot;#section-3.2.1&quot;&gt;разделе &lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt; . Если Request-URI закодирован с использованием кодировки &quot;% HEX HEX&quot; [ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;], исходный сервер ДОЛЖЕН декодировать Request-URI, чтобы правильно интерпретировать запрос. Серверы ДОЛЖНЫ отвечать на недопустимые Request-URI с соответствующим кодом состояния. Прозрачный прокси-сервер НЕ ДОЛЖЕН переписывать часть &amp;laquo;abs_path&amp;raquo; полученного Request-URI при пересылке его на следующий входящий сервер, за исключением случаев, указанных выше, для замены нулевого abs_path на &amp;laquo;/&amp;raquo;. Примечание. Правило &amp;laquo;без перезаписи&amp;raquo; не позволяет прокси-серверу изменять значение запроса, когда исходный сервер неправильно использует незарезервированный символ URI для зарезервированной цели. Разработчики должны знать, что некоторые прокси до HTTP / 1.1, как известно, переписывают Request-URI.</target>
        </trans-unit>
        <trans-unit id="27df10f6e52fad72f86af47082d4aed616c53e54" translate="yes" xml:space="preserve">
          <source>The Retry-After response-header field can be used with a 503 (Service
   Unavailable) response to indicate how long the service is expected to
   be unavailable to the requesting client. This field MAY also be used
   with any 3xx (Redirection) response to indicate the minimum time the
   user-agent is asked wait before issuing the redirected request. The
   value of this field can be either an HTTP-date or an integer number
   of seconds (in decimal) after the time of the response.

       Retry-After  = &quot;Retry-After&quot; &quot;:&quot; ( HTTP-date | delta-seconds )

   Two examples of its use are

       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
       Retry-After: 120

   In the latter example, the delay is 2 minutes.</source>
          <target state="translated">Поле заголовка ответа Retry-After может быть использовано с ответом 503 (Service Unavailable)для указания того,как долго сервис,как ожидается,будет недоступен запрашивающему клиенту.Это поле MAY также может использоваться с любым 3xx (перенаправленным)ответом для указания минимального времени,в течение которого пользователь-агент должен подождать,прежде чем отправить перенаправленный запрос.Значение этого поля может быть либо HTTP-датой,либо целым числом секунд (в десятичных числах)после времени ответа.Повтор-после=&quot;Повтор-после&quot; &quot;:&quot;(HTTP-дата | дельта-секунды)Два примера его использования-повтор-после:Fri,31 Dec.1999 23:59:59 GMT Retry-After:120 В последнем примере задержка составляет 2 минуты.</target>
        </trans-unit>
        <trans-unit id="f351e70802256078de6c82adb6c9f8135e4ad1a4" translate="yes" xml:space="preserve">
          <source>The Server response-header field contains information about the
   software used by the origin server to handle the request. The field
   can contain multiple product tokens (&lt;a href=&quot;#section-3.8&quot;&gt;section 3.8&lt;/a&gt;) and comments
   identifying the server and any significant subproducts. The product
   tokens are listed in order of their significance for identifying the
   application.

       Server         = &quot;Server&quot; &quot;:&quot; 1*( product | comment )

   Example:

       Server: CERN/3.0 libwww/2.17

   If the response is being forwarded through a proxy, the proxy
   application MUST NOT modify the Server response-header. Instead, it
   SHOULD include a Via field (as described in &lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;).

      Note: Revealing the specific software version of the server might
      allow the server machine to become more vulnerable to attacks
      against software that is known to contain security holes. Server
      implementors are encouraged to make this field a configurable
      option.</source>
          <target state="translated">Поле заголовка ответа сервера содержит информацию о программном обеспечении, используемом исходным сервером для обработки запроса. Поле может содержать несколько токенов продукта ( &lt;a href=&quot;#section-3.8&quot;&gt;раздел 3.8&lt;/a&gt; ) и комментарии, идентифицирующие сервер и любые важные субпродукты. Жетоны продуктов перечислены в порядке их значимости для идентификации приложения. Server = &quot;Server&quot; &quot;:&quot; 1 * (product | comment) Пример: Сервер: CERN / 3.0 libwww / 2.17 Если ответ пересылается через прокси, прокси-приложение НЕ ДОЛЖНО изменять заголовок ответа сервера. Вместо этого он ДОЛЖЕН включать поле Via (как описано в &lt;a href=&quot;#section-14.45&quot;&gt;разделе 14.45.&lt;/a&gt;). Примечание. Выявление конкретной версии программного обеспечения сервера может сделать серверный компьютер более уязвимым для атак на программное обеспечение, которое, как известно, содержит бреши в безопасности. Разработчикам серверов рекомендуется сделать это поле настраиваемой опцией.</target>
        </trans-unit>
        <trans-unit id="87ed514ae2ccfa3b72514fa6a84c466f301be7c1" translate="yes" xml:space="preserve">
          <source>The Status-Code element is a 3-digit integer result code of the
   attempt to understand and satisfy the request. These codes are fully
   defined in &lt;a href=&quot;#section-10&quot;&gt;section 10&lt;/a&gt;. The Reason-Phrase is intended to give a short
   textual description of the Status-Code. The Status-Code is intended
   for use by automata and the Reason-Phrase is intended for the human
   user. The client is not required to examine or display the Reason-
   Phrase. 

   The first digit of the Status-Code defines the class of response. The
   last two digits do not have any categorization role. There are 5
   values for the first digit:

      - 1xx: Informational - Request received, continuing process

      - 2xx: Success - The action was successfully received,
        understood, and accepted

      - 3xx: Redirection - Further action must be taken in order to
        complete the request

      - 4xx: Client Error - The request contains bad syntax or cannot
        be fulfilled

      - 5xx: Server Error - The server failed to fulfill an apparently
        valid request

   The individual values of the numeric status codes defined for
   HTTP/1.1, and an example set of corresponding Reason-Phrase's, are
   presented below. The reason phrases listed here are only
   recommendations -- they MAY be replaced by local equivalents without
   affecting the protocol.

      Status-Code    =
            &quot;100&quot;  ; &lt;a href=&quot;#section-10.1.1&quot;&gt;Section 10.1.1&lt;/a&gt;: Continue
          | &quot;101&quot;  ; &lt;a href=&quot;#section-10.1.2&quot;&gt;Section 10.1.2&lt;/a&gt;: Switching Protocols
          | &quot;200&quot;  ; &lt;a href=&quot;#section-10.2.1&quot;&gt;Section 10.2.1&lt;/a&gt;: OK
          | &quot;201&quot;  ; &lt;a href=&quot;#section-10.2.2&quot;&gt;Section 10.2.2&lt;/a&gt;: Created
          | &quot;202&quot;  ; &lt;a href=&quot;#section-10.2.3&quot;&gt;Section 10.2.3&lt;/a&gt;: Accepted
          | &quot;203&quot;  ; &lt;a href=&quot;#section-10.2.4&quot;&gt;Section 10.2.4&lt;/a&gt;: Non-Authoritative Information
          | &quot;204&quot;  ; &lt;a href=&quot;#section-10.2.5&quot;&gt;Section 10.2.5&lt;/a&gt;: No Content
          | &quot;205&quot;  ; &lt;a href=&quot;#section-10.2.6&quot;&gt;Section 10.2.6&lt;/a&gt;: Reset Content
          | &quot;206&quot;  ; &lt;a href=&quot;#section-10.2.7&quot;&gt;Section 10.2.7&lt;/a&gt;: Partial Content
          | &quot;300&quot;  ; &lt;a href=&quot;#section-10.3.1&quot;&gt;Section 10.3.1&lt;/a&gt;: Multiple Choices
          | &quot;301&quot;  ; &lt;a href=&quot;#section-10.3.2&quot;&gt;Section 10.3.2&lt;/a&gt;: Moved Permanently
          | &quot;302&quot;  ; &lt;a href=&quot;#section-10.3.3&quot;&gt;Section 10.3.3&lt;/a&gt;: Found
          | &quot;303&quot;  ; &lt;a href=&quot;#section-10.3.4&quot;&gt;Section 10.3.4&lt;/a&gt;: See Other
          | &quot;304&quot;  ; &lt;a href=&quot;#section-10.3.5&quot;&gt;Section 10.3.5&lt;/a&gt;: Not Modified
          | &quot;305&quot;  ; &lt;a href=&quot;#section-10.3.6&quot;&gt;Section 10.3.6&lt;/a&gt;: Use Proxy
          | &quot;307&quot;  ; &lt;a href=&quot;#section-10.3.8&quot;&gt;Section 10.3.8&lt;/a&gt;: Temporary Redirect
          | &quot;400&quot;  ; &lt;a href=&quot;#section-10.4.1&quot;&gt;Section 10.4.1&lt;/a&gt;: Bad Request
          | &quot;401&quot;  ; &lt;a href=&quot;#section-10.4.2&quot;&gt;Section 10.4.2&lt;/a&gt;: Unauthorized
          | &quot;402&quot;  ; &lt;a href=&quot;#section-10.4.3&quot;&gt;Section 10.4.3&lt;/a&gt;: Payment Required
          | &quot;403&quot;  ; &lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;: Forbidden
          | &quot;404&quot;  ; &lt;a href=&quot;#section-10.4.5&quot;&gt;Section 10.4.5&lt;/a&gt;: Not Found
          | &quot;405&quot;  ; &lt;a href=&quot;#section-10.4.6&quot;&gt;Section 10.4.6&lt;/a&gt;: Method Not Allowed
          | &quot;406&quot;  ; &lt;a href=&quot;#section-10.4.7&quot;&gt;Section 10.4.7&lt;/a&gt;: Not Acceptable 

          | &quot;407&quot;  ; &lt;a href=&quot;#section-10.4.8&quot;&gt;Section 10.4.8&lt;/a&gt;: Proxy Authentication Required
          | &quot;408&quot;  ; &lt;a href=&quot;#section-10.4.9&quot;&gt;Section 10.4.9&lt;/a&gt;: Request Time-out
          | &quot;409&quot;  ; &lt;a href=&quot;#section-10.4.10&quot;&gt;Section 10.4.10&lt;/a&gt;: Conflict
          | &quot;410&quot;  ; &lt;a href=&quot;#section-10.4.11&quot;&gt;Section 10.4.11&lt;/a&gt;: Gone
          | &quot;411&quot;  ; &lt;a href=&quot;#section-10.4.12&quot;&gt;Section 10.4.12&lt;/a&gt;: Length Required
          | &quot;412&quot;  ; &lt;a href=&quot;#section-10.4.13&quot;&gt;Section 10.4.13&lt;/a&gt;: Precondition Failed
          | &quot;413&quot;  ; &lt;a href=&quot;#section-10.4.14&quot;&gt;Section 10.4.14&lt;/a&gt;: Request Entity Too Large
          | &quot;414&quot;  ; &lt;a href=&quot;#section-10.4.15&quot;&gt;Section 10.4.15&lt;/a&gt;: Request-URI Too Large
          | &quot;415&quot;  ; &lt;a href=&quot;#section-10.4.16&quot;&gt;Section 10.4.16&lt;/a&gt;: Unsupported Media Type
          | &quot;416&quot;  ; &lt;a href=&quot;#section-10.4.17&quot;&gt;Section 10.4.17&lt;/a&gt;: Requested range not satisfiable
          | &quot;417&quot;  ; &lt;a href=&quot;#section-10.4.18&quot;&gt;Section 10.4.18&lt;/a&gt;: Expectation Failed
          | &quot;500&quot;  ; &lt;a href=&quot;#section-10.5.1&quot;&gt;Section 10.5.1&lt;/a&gt;: Internal Server Error
          | &quot;501&quot;  ; &lt;a href=&quot;#section-10.5.2&quot;&gt;Section 10.5.2&lt;/a&gt;: Not Implemented
          | &quot;502&quot;  ; &lt;a href=&quot;#section-10.5.3&quot;&gt;Section 10.5.3&lt;/a&gt;: Bad Gateway
          | &quot;503&quot;  ; &lt;a href=&quot;#section-10.5.4&quot;&gt;Section 10.5.4&lt;/a&gt;: Service Unavailable
          | &quot;504&quot;  ; &lt;a href=&quot;#section-10.5.5&quot;&gt;Section 10.5.5&lt;/a&gt;: Gateway Time-out
          | &quot;505&quot;  ; &lt;a href=&quot;#section-10.5.6&quot;&gt;Section 10.5.6&lt;/a&gt;: HTTP Version not supported
          | extension-code

      extension-code = 3DIGIT
      Reason-Phrase  = *&amp;lt;TEXT, excluding CR, LF&amp;gt;

   HTTP status codes are extensible. HTTP applications are not required
   to understand the meaning of all registered status codes, though such
   understanding is obviously desirable. However, applications MUST
   understand the class of any status code, as indicated by the first
   digit, and treat any unrecognized response as being equivalent to the
   x00 status code of that class, with the exception that an
   unrecognized response MUST NOT be cached. For example, if an
   unrecognized status code of 431 is received by the client, it can
   safely assume that there was something wrong with its request and
   treat the response as if it had received a 400 status code. In such
   cases, user agents SHOULD present to the user the entity returned
   with the response, since that entity is likely to include human-
   readable information which will explain the unusual status.</source>
          <target state="translated">Элемент Status-Code представляет собой трехзначный целочисленный код результата попытки понять и удовлетворить запрос. Эти коды полностью определены в &lt;a href=&quot;#section-10&quot;&gt;разделе 10.&lt;/a&gt;, Фраза-причина предназначена для краткого текстового описания кода состояния. Код состояния предназначен для использования автоматами, а фраза-причина предназначена для пользователя-человека. От клиента не требуется изучать или отображать фразу-причину. Первая цифра кода состояния определяет класс ответа. Последние две цифры не имеют роли категоризации. Первая цифра имеет 5 значений: - 1xx: информационное - запрос получен, процесс продолжается - 2xx: успех - действие было успешно получено, понято и принято - 3xx: перенаправление - для выполнения запроса необходимо предпринять дальнейшие действия - 4xx: ошибка клиента - запрос содержит неверный синтаксис или не может быть выполнен - ​​5xx:Ошибка сервера - серверу не удалось выполнить явно действительный запрос. Ниже представлены отдельные значения числовых кодов состояния, определенных для HTTP / 1.1, и примерный набор соответствующих фраз-причин. Фразы причин, перечисленные здесь, являются всего лишь рекомендациями - они МОГУТ быть заменены местными эквивалентами, не влияя на протокол. Код состояния = &quot;100&quot;;&lt;a href=&quot;#section-10.1.1&quot;&gt;Раздел 10.1.1&lt;/a&gt; : Продолжить | &amp;laquo;101&amp;raquo;; &lt;a href=&quot;#section-10.1.2&quot;&gt;Раздел 10.1.2&lt;/a&gt; : Переключение протоколов | &amp;laquo;200&amp;raquo;; &lt;a href=&quot;#section-10.2.1&quot;&gt;Раздел 10.2.1&lt;/a&gt; : ОК | &amp;laquo;201&amp;raquo;; &lt;a href=&quot;#section-10.2.2&quot;&gt;Раздел 10.2.2&lt;/a&gt; : Создано | &amp;laquo;202&amp;raquo;; &lt;a href=&quot;#section-10.2.3&quot;&gt;Раздел 10.2.3&lt;/a&gt; : Принято | &amp;laquo;203&amp;raquo;; &lt;a href=&quot;#section-10.2.4&quot;&gt;Раздел 10.2.4&lt;/a&gt; : Неавторитетная информация | &amp;laquo;204&amp;raquo;; &lt;a href=&quot;#section-10.2.5&quot;&gt;Раздел 10.2.5&lt;/a&gt; : Нет содержимого | &amp;laquo;205&amp;raquo;; &lt;a href=&quot;#section-10.2.6&quot;&gt;Раздел 10.2.6&lt;/a&gt; : Сброс содержимого | &amp;laquo;206&amp;raquo;; &lt;a href=&quot;#section-10.2.7&quot;&gt;Раздел 10.2.7&lt;/a&gt; : Частичное содержимое | &amp;laquo;300&amp;raquo;; &lt;a href=&quot;#section-10.3.1&quot;&gt;Раздел 10.3.1&lt;/a&gt; : Несколько вариантов | &amp;laquo;301&amp;raquo;; &lt;a href=&quot;#section-10.3.2&quot;&gt;Раздел 10.3.&lt;/a&gt;2 : перемещен навсегда | &amp;laquo;302&amp;raquo;;&lt;a href=&quot;#section-10.3.3&quot;&gt;Раздел 10.3.3&lt;/a&gt; : Найдено | &amp;laquo;303&amp;raquo;; &lt;a href=&quot;#section-10.3.4&quot;&gt;Раздел 10.3.4&lt;/a&gt; : См. Другое | &amp;laquo;304&amp;raquo;; &lt;a href=&quot;#section-10.3.5&quot;&gt;Раздел 10.3.5&lt;/a&gt; : Не изменено | &amp;laquo;305&amp;raquo;; &lt;a href=&quot;#section-10.3.6&quot;&gt;Раздел 10.3.6&lt;/a&gt; : Использование прокси | &amp;laquo;307&amp;raquo;; &lt;a href=&quot;#section-10.3.8&quot;&gt;Раздел 10.3.8&lt;/a&gt; : Временное перенаправление | &amp;laquo;400&amp;raquo;; &lt;a href=&quot;#section-10.4.1&quot;&gt;Раздел 10.4.1&lt;/a&gt; : Неверный запрос | &amp;laquo;401&amp;raquo;; &lt;a href=&quot;#section-10.4.2&quot;&gt;Раздел 10.4.2&lt;/a&gt; : Несанкционированный | &amp;laquo;402&amp;raquo;; &lt;a href=&quot;#section-10.4.3&quot;&gt;Раздел 10.4.3&lt;/a&gt; : Требуется оплата | &amp;laquo;403&amp;raquo;; &lt;a href=&quot;#section-10.4.4&quot;&gt;Раздел 10.4.4&lt;/a&gt; : Запрещено | &amp;laquo;404&amp;raquo;; &lt;a href=&quot;#section-10.4.5&quot;&gt;Раздел 10.4.5&lt;/a&gt; : Не найдено | &amp;laquo;405&amp;raquo;; &lt;a href=&quot;#section-10.4.6&quot;&gt;Раздел 10.4.6&lt;/a&gt; :Метод не разрешен | &amp;laquo;406&amp;raquo;; &lt;a href=&quot;#section-10.4.7&quot;&gt;Раздел 10.4.7&lt;/a&gt;: Неприемлемо | &amp;laquo;407&amp;raquo;; &lt;a href=&quot;#section-10.4.8&quot;&gt;Раздел 10.4.8&lt;/a&gt; : Требуется аутентификация прокси | &amp;laquo;408&amp;raquo;; &lt;a href=&quot;#section-10.4.9&quot;&gt;Раздел 10.4.9&lt;/a&gt; : Тайм-аут запроса | &amp;laquo;409&amp;raquo;; &lt;a href=&quot;#section-10.4.10&quot;&gt;Раздел 10.4.10&lt;/a&gt; : Конфликт | &amp;laquo;410&amp;raquo;; &lt;a href=&quot;#section-10.4.11&quot;&gt;Раздел 10.4.11&lt;/a&gt; : Ушло | &amp;laquo;411&amp;raquo;; &lt;a href=&quot;#section-10.4.12&quot;&gt;Раздел 10.4.12&lt;/a&gt; : Требуемая длина | &amp;laquo;412&amp;raquo;; &lt;a href=&quot;#section-10.4.13&quot;&gt;Раздел 10.4.13&lt;/a&gt; : Ошибка предварительного условия | &amp;laquo;413&amp;raquo;; &lt;a href=&quot;#section-10.4.14&quot;&gt;Раздел 10.4.14&lt;/a&gt; : Слишком большой объект запроса | &amp;laquo;414&amp;raquo;; &lt;a href=&quot;#section-10.4.15&quot;&gt;Раздел 10.4.15&lt;/a&gt; : Слишком большой URI запроса | &amp;laquo;415&amp;raquo;; &lt;a href=&quot;#section-10.4.16&quot;&gt;Раздел 10.4.16&lt;/a&gt; : Неподдерживаемый тип носителя | &amp;laquo;416&amp;raquo;;&lt;a href=&quot;#section-10.4.17&quot;&gt;Раздел 10.4.17&lt;/a&gt;: Запрошенный диапазон не подходит | &amp;laquo;417&amp;raquo;; &lt;a href=&quot;#section-10.4.18&quot;&gt;Раздел 10.4.18&lt;/a&gt; : Ожидание не выполнено | &amp;laquo;500&amp;raquo;; &lt;a href=&quot;#section-10.5.1&quot;&gt;Раздел 10.5.1&lt;/a&gt; : Внутренняя ошибка сервера | &amp;laquo;501&amp;raquo;; &lt;a href=&quot;#section-10.5.2&quot;&gt;Раздел 10.5.2&lt;/a&gt; : Не реализовано | &amp;laquo;502&amp;raquo;; &lt;a href=&quot;#section-10.5.3&quot;&gt;Раздел 10.5.3&lt;/a&gt; : Плохой шлюз | &amp;laquo;503&amp;raquo;; &lt;a href=&quot;#section-10.5.4&quot;&gt;Раздел 10.5.4&lt;/a&gt; : Служба недоступна | &amp;laquo;504&amp;raquo;; &lt;a href=&quot;#section-10.5.5&quot;&gt;Раздел 10.5.5&lt;/a&gt; : Тайм-аут шлюза | &amp;laquo;505&amp;raquo;; &lt;a href=&quot;#section-10.5.6&quot;&gt;Раздел 10.5.6&lt;/a&gt;: Версия HTTP не поддерживается | extension-code extension-code = 3DIGIT Reason-Phrase = * &amp;lt;ТЕКСТ, исключая CR, LF&amp;gt; Коды состояния HTTP являются расширяемыми. Приложения HTTP не обязаны понимать значение всех зарегистрированных кодов состояния, хотя такое понимание, очевидно, желательно. Однако приложения ДОЛЖНЫ понимать класс любого кода состояния, обозначенного первой цифрой, и обрабатывать любой нераспознанный ответ как эквивалентный коду состояния x00 этого класса, за исключением того, что нераспознанный ответ НЕ ДОЛЖЕН кэшироваться. Например, если клиент получает нераспознанный код состояния 431, он может с уверенностью предположить, что с его запросом что-то не так, и рассматривать ответ, как если бы он получил код состояния 400. В таких случаях,пользовательские агенты ДОЛЖНЫ представлять пользователю объект, возвращенный с ответом, поскольку этот объект, вероятно, будет включать в себя читаемую человеком информацию, которая объяснит необычный статус.</target>
        </trans-unit>
        <trans-unit id="a033c5a9ee721261b9ef910b0f68478ac7363993" translate="yes" xml:space="preserve">
          <source>The TCP handshake itself is time-consuming, but a TCP connection adapts to its load, becoming more efficient with more sustained (or warm) connections. Short-lived connections do not make use of this efficiency feature of TCP, and performance degrades from optimum by persisting to transmit over a new, cold connection.</source>
          <target state="translated">Само по себе TCP рукопожатие отнимает много времени,но TCP-соединение адаптируется к его нагрузке,становясь более эффективным с более устойчивыми (или теплыми)соединениями.Короткоживущие соединения не используют эту функцию эффективности TCP,и производительность снижается до оптимального уровня,продолжая передаваться по новому,холодному соединению.</target>
        </trans-unit>
        <trans-unit id="a9a108e88ad08677b3a7b101ee6720f85b6d8f49" translate="yes" xml:space="preserve">
          <source>The TE request-header field indicates what extension transfer-codings
   it is willing to accept in the response and whether or not it is
   willing to accept trailer fields in a chunked transfer-coding. Its
   value may consist of the keyword &quot;trailers&quot; and/or a comma-separated
   list of extension transfer-coding names with optional accept
   parameters (as described in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;).

       TE        = &quot;TE&quot; &quot;:&quot; #( t-codings )
       t-codings = &quot;trailers&quot; | ( transfer-extension [ accept-params ] )

   The presence of the keyword &quot;trailers&quot; indicates that the client is
   willing to accept trailer fields in a chunked transfer-coding, as
   defined in &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt;. This keyword is reserved for use with
   transfer-coding values even though it does not itself represent a
   transfer-coding.

   Examples of its use are:

       TE: deflate
       TE:
       TE: trailers, deflate;q=0.5

   The TE header field only applies to the immediate connection.
   Therefore, the keyword MUST be supplied within a Connection header
   field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) whenever TE is present in an HTTP/1.1 message.

   A server tests whether a transfer-coding is acceptable, according to
   a TE field, using these rules:

      1. The &quot;chunked&quot; transfer-coding is always acceptable. If the
         keyword &quot;trailers&quot; is listed, the client indicates that it is
         willing to accept trailer fields in the chunked response on
         behalf of itself and any downstream clients. The implication is
         that, if given, the client is stating that either all
         downstream clients are willing to accept trailer fields in the
         forwarded response, or that it will attempt to buffer the
         response on behalf of downstream recipients.

         Note: HTTP/1.1 does not define any means to limit the size of a
         chunked response such that a client can be assured of buffering
         the entire response.

      2. If the transfer-coding being tested is one of the transfer-
         codings listed in the TE field, then it is acceptable unless it
         is accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;) 

      3. If multiple transfer-codings are acceptable, then the
         acceptable transfer-coding with the highest non-zero qvalue is
         preferred.  The &quot;chunked&quot; transfer-coding always has a qvalue
         of 1.

   If the TE field-value is empty or if no TE field is present, the only
   transfer-coding  is &quot;chunked&quot;. A message with no transfer-coding is
   always acceptable.</source>
          <target state="translated">Поле заголовка запроса TE указывает, какие расширения кодирования передачи он готов принять в ответ, и готов ли он принимать поля концевых звеньев в кодировании передачи по частям. Его значение может состоять из ключевого слова &quot;трейлеры&quot; и / или разделенного запятыми списка расширенных имен кодирования передачи с необязательными параметрами принятия (как описано в &lt;a href=&quot;#section-3.6&quot;&gt;разделе 3.6&lt;/a&gt; ). TE = &quot;TE&quot; &quot;:&quot; # (t-codings) t-codings = &quot;trailers&quot; | (расширение-передачи [accept-params]) Наличие ключевого слова &quot;трейлеры&quot; указывает на то, что клиент готов принять поля трейлера в кодировке передачи по частям, как определено в &lt;a href=&quot;#section-3.6.1&quot;&gt;разделе 3.6.1.&lt;/a&gt;, Это ключевое слово зарезервировано для использования со значениями кодирования передачи, даже если оно само не представляет собой кодирование передачи. Примеры его использования: TE: deflate TE: TE: trailers, deflate; q = 0.5 Поле заголовка TE применяется только к непосредственному соединению. Следовательно, ключевое слово ДОЛЖНО быть предоставлено в поле заголовка соединения ( &lt;a href=&quot;#section-14.10&quot;&gt;раздел 14.10.&lt;/a&gt;) всякий раз, когда TE присутствует в сообщении HTTP / 1.1. Сервер проверяет, допустимо ли кодирование передачи, в соответствии с полем TE, используя следующие правила: 1. &amp;laquo;Разделенное&amp;raquo; кодирование передачи всегда приемлемо. Если указано ключевое слово &amp;laquo;трейлеры&amp;raquo;, клиент указывает, что он готов принять поля трейлеров в фрагментированном ответе от своего имени и от имени всех нижестоящих клиентов. Подразумевается, что, если он задан, клиент заявляет, что либо все нижестоящие клиенты готовы принять поля трейлера в перенаправленном ответе, либо он попытается буферизовать ответ от имени нижестоящих получателей. Примечание: HTTP / 1.1 не определяет никаких средств для ограничения размера фрагментированного ответа, чтобы клиент мог быть уверен в буферизации всего ответа. 2. Если тестируемое кодирование передачи является одним из кодировок передачи, перечисленных в поле TE, то оно приемлемо, если оно не сопровождается значением q, равным 0. (Как определено в&lt;a href=&quot;#section-3.9&quot;&gt;в разделе 3.9&lt;/a&gt; qvalue 0 означает &amp;laquo;неприемлемо&amp;raquo;.) 3. Если допускается несколько кодировок передачи, то предпочтительным является приемлемое кодирование передачи с наивысшим ненулевым значением q. &amp;laquo;Разделенное&amp;raquo; кодирование передачи всегда имеет qvalue, равное 1. Если значение поля TE пусто или если поле TE отсутствует, единственное кодирование передачи - &amp;laquo;фрагментированное&amp;raquo;. Сообщение без кодирования передачи всегда приемлемо.</target>
        </trans-unit>
        <trans-unit id="028b36d5d9b3506526bee546184ec9c68b1e3650" translate="yes" xml:space="preserve">
          <source>The TRACE method is used to invoke a remote, application-layer loop-
   back of the request message. The final recipient of the request
   SHOULD reflect the message received back to the client as the
   entity-body of a 200 (OK) response. The final recipient is either the 

   origin server or the first proxy or gateway to receive a Max-Forwards
   value of zero (0) in the request (see &lt;a href=&quot;#section-14.31&quot;&gt;section 14.31&lt;/a&gt;). A TRACE request
   MUST NOT include an entity.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information. The value of the Via header field (&lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;) is of
   particular interest, since it acts as a trace of the request chain.
   Use of the Max-Forwards header field allows the client to limit the
   length of the request chain, which is useful for testing a chain of
   proxies forwarding messages in an infinite loop.

   If the request is valid, the response SHOULD contain the entire
   request message in the entity-body, with a Content-Type of
   &quot;message/http&quot;. Responses to this method MUST NOT be cached.</source>
          <target state="translated">Метод TRACE используется для вызова удаленной петли на уровне приложения для сообщения запроса. Конечному получателю запроса СЛЕДУЕТ отражать полученное сообщение обратно клиенту как тело объекта ответа 200 (ОК). Конечным получателем является либо исходный сервер, либо первый прокси или шлюз, получивший в запросе нулевое (0) значение Max-Forwards (см. &lt;a href=&quot;#section-14.31&quot;&gt;Раздел 14.31&lt;/a&gt; ). Запрос TRACE НЕ ДОЛЖЕН включать сущность. TRACE позволяет клиенту видеть, что получено на другом конце цепочки запросов, и использовать эти данные для тестирования или диагностической информации. Значение поля заголовка Via ( &lt;a href=&quot;#section-14.45&quot;&gt;раздел 14.45&lt;/a&gt;) is of particular interest, since it acts as a trace of the request chain. Use of the Max-Forwards header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop. If the request is valid, the response SHOULD contain the entire request message in the entity-body, with a Content-Type of &quot;message/http&quot;. Responses to this method MUST NOT be cached.</target>
        </trans-unit>
        <trans-unit id="6e96e28d353c4ec4abe9e9bc4e5f7f7754ad5448" translate="yes" xml:space="preserve">
          <source>The TRACE method requests a remote, application-level loop-back of
   the request message.  The final recipient of the request SHOULD
   reflect the message received, excluding some fields described below,
   back to the client as the message body of a 200 (OK) response with a
   Content-Type of &quot;message/http&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;Section&amp;nbsp;8.3.1 of [RFC7230]&lt;/a&gt;).  The
   final recipient is either the origin server or the first server to
   receive a Max-Forwards value of zero (0) in the request
   (&lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;). 

   A client MUST NOT generate header fields in a TRACE request
   containing sensitive data that might be disclosed by the response.
   For example, it would be foolish for a user agent to send stored user
   credentials [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;] or cookies [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] in a TRACE request.  The
   final recipient of the request SHOULD exclude any request header
   fields that are likely to contain sensitive data when that recipient
   generates the response body.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information.  The value of the Via header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;Section&amp;nbsp;5.7.1 of
   [RFC7230]&lt;/a&gt;) is of particular interest, since it acts as a trace of the
   request chain.  Use of the Max-Forwards header field allows the
   client to limit the length of the request chain, which is useful for
   testing a chain of proxies forwarding messages in an infinite loop.

   A client MUST NOT send a message body in a TRACE request.

   Responses to the TRACE method are not cacheable.</source>
          <target state="translated">Метод TRACE запрашивает удаленную обратную связь на уровне приложения для сообщения запроса. Конечному получателю запроса СЛЕДУЕТ отразить полученное сообщение, за исключением некоторых полей, описанных ниже, обратно клиенту в виде тела сообщения ответа 200 (OK) с Content-Type &amp;laquo;message / http&amp;raquo; ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;раздел 8.3.1 of [RFC7230]&lt;/a&gt; ). Конечным получателем является либо исходный сервер, либо первый сервер, получивший в запросе значение Max-Forwards, равное нулю (0) ( &lt;a href=&quot;#section-5.1.2&quot;&gt;раздел 5.1.2&lt;/a&gt; ). Клиент НЕ ДОЛЖЕН создавать поля заголовка в запросе TRACE, содержащие конфиденциальные данные, которые могут быть раскрыты ответом. Например, было бы глупо для пользовательского агента отправлять сохраненные учетные данные пользователя [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ] или файлы cookie [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] в запросе TRACE. Конечному получателю запроса СЛЕДУЕТ исключить любые поля заголовка запроса, которые могут содержать конфиденциальные данные, когда этот получатель создает тело ответа. TRACE позволяет клиенту видеть, что получено на другом конце цепочки запросов, и использовать эти данные для тестирования или диагностической информации. Значение поля заголовка Via ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;раздел 5.7.1 [RFC7230]&lt;/a&gt; ) представляет особый интерес, поскольку оно действует как трассировка цепочки запросов. Использование поля заголовка Max-Forwards позволяет клиенту ограничивать длину цепочки запросов, что полезно для тестирования цепочки прокси-серверов, пересылающих сообщения в бесконечном цикле. Клиент НЕ ДОЛЖЕН отправлять тело сообщения в запросе TRACE. Ответы на метод TRACE не кэшируются.</target>
        </trans-unit>
        <trans-unit id="03897f64a14a74fe7d2358b82a3a5d08dc5e4c2f" translate="yes" xml:space="preserve">
          <source>The Trailer general field value indicates that the given set of
   header fields is present in the trailer of a message encoded with
   chunked transfer-coding.

       Trailer  = &quot;Trailer&quot; &quot;:&quot; 1#field-name

   An HTTP/1.1 message SHOULD include a Trailer header field in a
   message using chunked transfer-coding with a non-empty trailer. Doing
   so allows the recipient to know which header fields to expect in the
   trailer.

   If no Trailer header field is present, the trailer SHOULD NOT include
   any header fields. See &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt; for restrictions on the use of
   trailer fields in a &quot;chunked&quot; transfer-coding.

   Message header fields listed in the Trailer header field MUST NOT
   include the following header fields:

      . Transfer-Encoding

      . Content-Length

      . Trailer</source>
          <target state="translated">Значение общего поля трейлера указывает, что данный набор полей заголовка присутствует в трейлере сообщения, закодированного с помощью кодирования передачи по частям. Trailer = &quot;Trailer&quot; &quot;:&quot; 1 # field-name Сообщение HTTP / 1.1 ДОЛЖНО включать поле заголовка Trailer в сообщение с использованием фрагментированного кодирования передачи с непустым трейлером. Это позволяет получателю узнать, какие поля заголовка ожидать в трейлере. Если поле заголовка трейлера отсутствует, трейлер НЕ ДОЛЖЕН включать какие-либо поля заголовка. См. &lt;a href=&quot;#section-3.6.1&quot;&gt;Раздел 3.6.1&lt;/a&gt; для получения информации об ограничениях на использование полей трейлера в &amp;laquo;фрагментированном&amp;raquo; кодировании передачи. Поля заголовка сообщения, перечисленные в поле заголовка трейлера, НЕ ДОЛЖНЫ включать следующие поля заголовка:. Передача-кодирование. Content-Length.трейлер</target>
        </trans-unit>
        <trans-unit id="5a0c272967d0d482ca0381c6f18703875d017457" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding general-header field indicates what (if any)
   type of transformation has been applied to the message body in order
   to safely transfer it between the sender and the recipient. This
   differs from the content-coding in that the transfer-coding is a
   property of the message, not of the entity.

     Transfer-Encoding       = &quot;Transfer-Encoding&quot; &quot;:&quot; 1#transfer-coding

   Transfer-codings are defined in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;. An example is:

     Transfer-Encoding: chunked 

   If multiple encodings have been applied to an entity, the transfer-
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.

   Many older HTTP/1.0 applications do not understand the Transfer-
   Encoding header.</source>
          <target state="translated">Поле общего заголовка Transfer-Encoding указывает, какой (если есть) тип преобразования был применен к телу сообщения, чтобы безопасно передать его между отправителем и получателем. Это отличается от кодирования содержимого тем, что кодирование передачи является свойством сообщения, а не объекта. Transfer-Encoding = &quot;Transfer-Encoding&quot; &quot;:&quot; 1 # transfer-coding Кодирование передачи определено в &lt;a href=&quot;#section-3.6&quot;&gt;разделе 3.6.&lt;/a&gt;, Пример: Transfer-Encoding: chunked. Если к объекту было применено несколько кодировок, они ДОЛЖНЫ быть перечислены в том порядке, в котором они были применены. Дополнительная информация о параметрах кодирования МОЖЕТ быть предоставлена ​​другими полями заголовка объекта, не определенными в данной спецификации. Многие старые приложения HTTP / 1.0 не понимают заголовок Transfer-Encoding.</target>
        </trans-unit>
        <trans-unit id="2b9c17fcff0e77e15eb4e1a1d785371389cb348c" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding header field lists the transfer coding names
   corresponding to the sequence of transfer codings that have been (or
   will be) applied to the payload body in order to form the message
   body.  Transfer codings are defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

     Transfer-Encoding = 1#transfer-coding

   Transfer-Encoding is analogous to the Content-Transfer-Encoding field
   of MIME, which was designed to enable safe transport of binary data
   over a 7-bit transport service (&lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045], Section&amp;nbsp;6&lt;/a&gt;).  However, safe
   transport has a different focus for an 8bit-clean transfer protocol.
   In HTTP's case, Transfer-Encoding is primarily intended to accurately
   delimit a dynamically generated payload and to distinguish payload
   encodings that are only applied for transport efficiency or security
   from those that are characteristics of the selected resource. 

   A recipient MUST be able to parse the chunked transfer coding
   (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) because it plays a crucial role in framing messages
   when the payload body size is not known in advance.  A sender MUST
   NOT apply chunked more than once to a message body (i.e., chunking an
   already chunked message is not allowed).  If any transfer coding
   other than chunked is applied to a request payload body, the sender
   MUST apply chunked as the final transfer coding to ensure that the
   message is properly framed.  If any transfer coding other than
   chunked is applied to a response payload body, the sender MUST either
   apply chunked as the final transfer coding or terminate the message
   by closing the connection.

   For example,

     Transfer-Encoding: gzip, chunked

   indicates that the payload body has been compressed using the gzip
   coding and then chunked using the chunked coding while forming the
   message body.

   Unlike Content-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;Section&amp;nbsp;3.1.2.1 of [RFC7231]&lt;/a&gt;),
   Transfer-Encoding is a property of the message, not of the
   representation, and any recipient along the request/response chain
   MAY decode the received transfer coding(s) or apply additional
   transfer coding(s) to the message body, assuming that corresponding
   changes are made to the Transfer-Encoding field-value.  Additional
   information about the encoding parameters can be provided by other
   header fields not defined by this specification.

   Transfer-Encoding MAY be sent in a response to a HEAD request or in a
   304 (Not Modified) response (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7232]&lt;/a&gt;) to a GET
   request, neither of which includes a message body, to indicate that
   the origin server would have applied a transfer coding to the message
   body if the request had been an unconditional GET.  This indication
   is not required, however, because any recipient on the response chain
   (including the origin server) can remove transfer codings when they
   are not needed.

   A server MUST NOT send a Transfer-Encoding header field in any
   response with a status code of 1xx (Informational) or 204 (No
   Content).  A server MUST NOT send a Transfer-Encoding header field in
   any 2xx (Successful) response to a CONNECT request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;).

   Transfer-Encoding was added in HTTP/1.1.  It is generally assumed
   that implementations advertising only HTTP/1.0 support will not
   understand how to process a transfer-encoded payload.  A client MUST
   NOT send a request containing Transfer-Encoding unless it knows the 

   server will handle HTTP/1.1 (or later) requests; such knowledge might
   be in the form of specific user configuration or by remembering the
   version of a prior received response.  A server MUST NOT send a
   response containing Transfer-Encoding unless the corresponding
   request indicates HTTP/1.1 (or later).

   A server that receives a request message with a transfer coding it
   does not understand SHOULD respond with 501 (Not Implemented).</source>
          <target state="translated">В поле заголовка Transfer-Encoding перечислены имена кодов передачи, соответствующие последовательности кодировок передачи, которые были (или будут) применены к телу полезной нагрузки для формирования тела сообщения. Кодирование передачи определено в &lt;a href=&quot;#section-4&quot;&gt;Разделе 4&lt;/a&gt; . Transfer-Encoding = 1 # transfer-coding Transfer-Encoding аналогичен полю Content-Transfer-Encoding MIME, которое было разработано для обеспечения безопасной транспортировки двоичных данных через 7-битную транспортную службу ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045], раздел 6&lt;/a&gt;). Однако безопасный транспорт имеет другую направленность для протокола передачи с 8-битной чистой передачей. В случае HTTP Transfer-Encoding в первую очередь предназначена для точного разграничения динамически генерируемой полезной нагрузки и различения кодировок полезной нагрузки, которые применяются только для эффективности или безопасности транспорта, от тех, которые являются характеристиками выбранного ресурса. Получатель ДОЛЖЕН иметь возможность анализировать кодировку фрагментированной передачи ( &lt;a href=&quot;#section-4.1&quot;&gt;раздел 4.1.&lt;/a&gt;), потому что он играет решающую роль в формировании сообщений, когда размер тела полезной нагрузки неизвестен заранее. Отправитель НЕ ДОЛЖЕН применять фрагменты более одного раза к телу сообщения (т. Е. Фрагменты уже разбитого сообщения не разрешены). Если к телу полезной нагрузки запроса применяется какое-либо кодирование передачи, отличное от фрагментированного, отправитель ДОЛЖЕН применять фрагментированное кодирование в качестве окончательного кодирования передачи, чтобы гарантировать, что сообщение правильно сформировано. Если к телу полезной нагрузки ответа применяется какое-либо кодирование передачи, отличное от фрагментированного, отправитель ДОЛЖЕН либо применить фрагментированное кодирование в качестве окончательного кодирования передачи, либо завершить сообщение, закрыв соединение. Например, Transfer-Encoding: gzip, chunked указывает, что тело полезной нагрузки было сжато с использованием кодирования gzip, а затем разделено на фрагменты с использованием кодирования по фрагментам при формировании тела сообщения.В отличие от Content-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;Раздел 3.1.2.1 [RFC7231]&lt;/a&gt; ), Transfer-Encoding - это свойство сообщения, а не его представления, и любой получатель в цепочке запроса / ответа МОЖЕТ декодировать полученный код (ы) передачи или применять дополнительное кодирование (s) передачи ) в тело сообщения, предполагая, что соответствующие изменения внесены в значение поля Transfer-Encoding. Дополнительная информация о параметрах кодирования может быть предоставлена ​​другими полями заголовка, не определенными в данной спецификации. Transfer-Encoding МОЖЕТ быть отправлено в ответ на запрос HEAD или в ответе 304 (не изменено) ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;раздел 4.1 [RFC7232]&lt;/a&gt;) к запросу GET, ни один из которых не включает тело сообщения, чтобы указать, что исходный сервер применил бы кодирование передачи к телу сообщения, если бы запрос был безусловным GET. Однако это указание не требуется, поскольку любой получатель в цепочке ответов (включая исходный сервер) может удалить кодировки передачи, когда они не нужны. Сервер НЕ ДОЛЖЕН отправлять поле заголовка Transfer-Encoding в любом ответе с кодом состояния 1xx (информационный) или 204 (без содержимого). Сервер НЕ ДОЛЖЕН отправлять поле заголовка Transfer-Encoding в любом ответе 2xx (Успешно) на запрос CONNECT ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;раздел 4.3.6 [RFC7231])&lt;/a&gt;). Кодирование передачи было добавлено в HTTP / 1.1. Обычно предполагается, что реализации, рекламирующие только поддержку HTTP / 1.0, не поймут, как обрабатывать данные, закодированные при передаче. Клиент НЕ ДОЛЖЕН отправлять запрос, содержащий Transfer-Encoding, если он не знает, что сервер будет обрабатывать запросы HTTP / 1.1 (или более поздней версии); такие знания могут быть в форме конкретной пользовательской конфигурации или путем запоминания версии ранее полученного ответа. Сервер НЕ ДОЛЖЕН отправлять ответ, содержащий Transfer-Encoding, если в соответствующем запросе не указано HTTP / 1.1 (или более поздняя версия). Серверу, который получает сообщение запроса с непонятной ему кодировкой передачи, СЛЕДУЕТ ответить 501 (не реализовано).</target>
        </trans-unit>
        <trans-unit id="1c8b20b0d07b7680a3c0f95ac8ec3b25b3de332b" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.2</source>
          <target state="translated">Протокол безопасности транспортного уровня (TLS)Версия 1.2</target>
        </trans-unit>
        <trans-unit id="12fd383ebe402c54f473646772c58d3e6163c837" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.3</source>
          <target state="translated">Протокол безопасности транспортного уровня (TLS)версия 1.3</target>
        </trans-unit>
        <trans-unit id="8a56da9b77b531c4fafce5d057fc066caa86cf4f" translate="yes" xml:space="preserve">
          <source>The UA string of Firefox itself is broken down into four components:</source>
          <target state="translated">Строка UA самого Firefox разбита на четыре компонента:</target>
        </trans-unit>
        <trans-unit id="f72374d140af175240e14a12a7f961729a13b2d2" translate="yes" xml:space="preserve">
          <source>The UNLOCK method removes the lock identified by the lock token in
   the Lock-Token request header.  The Request-URI MUST identify a
   resource within the scope of the lock.

   Note that use of the Lock-Token header to provide the lock token is
   not consistent with other state-changing methods, which all require
   an If header with the lock token.  Thus, the If header is not needed
   to provide the lock token.  Naturally, when the If header is present,
   it has its normal meaning as a conditional header.

   For a successful response to this method, the server MUST delete the
   lock entirely.

   If all resources that have been locked under the submitted lock token
   cannot be unlocked, then the UNLOCK request MUST fail.

   A successful response to an UNLOCK method does not mean that the
   resource is necessarily unlocked.  It means that the specific lock
   corresponding to the specified token no longer exists.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the UNLOCK method.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">Метод UNLOCK снимает блокировку, идентифицированную токеном блокировки в заголовке запроса Lock-Token. Request-URI ДОЛЖЕН идентифицировать ресурс в рамках блокировки. Обратите внимание, что использование заголовка Lock-Token для предоставления токена блокировки несовместимо с другими методами изменения состояния, которые все требуют заголовка If с токеном блокировки. Таким образом, заголовок If не нужен для предоставления токена блокировки. Естественно, когда присутствует заголовок If, он имеет свое обычное значение как условный заголовок. Для успешного ответа на этот метод сервер ДОЛЖЕН полностью удалить блокировку. Если все ресурсы, которые были заблокированы поданным токеном блокировки, не могут быть разблокированы, то запрос UNLOCK ДОЛЖЕН завершиться неудачей. Успешный ответ на метод UNLOCK не означает, что ресурс обязательно разблокирован.Это означает, что конкретной блокировки, соответствующей указанному токену, больше не существует. Любой DAV-совместимый ресурс, поддерживающий метод LOCK, ДОЛЖЕН поддерживать метод UNLOCK. Этот метод идемпотентен, но небезопасен (см.&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Раздел 9.1 [RFC2616]&lt;/a&gt; ). Ответы на этот метод НЕ ДОЛЖНЫ кэшироваться.</target>
        </trans-unit>
        <trans-unit id="7dc195e95f3f78e1ec1e89ef97a6a85b571c15d4" translate="yes" xml:space="preserve">
          <source>The URI of the document in which the violation occurred.</source>
          <target state="translated">URI документа,в котором произошло нарушение.</target>
        </trans-unit>
        <trans-unit id="ceb66755626c081ee38ccbccf8e082e6464687a3" translate="yes" xml:space="preserve">
          <source>The URI of the resource that was blocked from loading by the Content Security Policy. If the blocked URI is from a different origin than the document-uri, then the blocked URI is truncated to contain just the scheme, host, and port.</source>
          <target state="translated">URI ресурса,который был заблокирован для загрузки политикой безопасности контента.Если заблокированный URI имеет иное происхождение,чем document-uri,то заблокированный URI усекается,чтобы содержать только схему,хост и порт.</target>
        </trans-unit>
        <trans-unit id="ab6860a88c4f5fa569a9d2df89c6b4183b5b6406" translate="yes" xml:space="preserve">
          <source>The URI requested by the client is longer than the server is willing to interpret.</source>
          <target state="translated">URI,запрашиваемый клиентом,длиннее,чем сервер готов к интерпретации.</target>
        </trans-unit>
        <trans-unit id="2631108f4b94ab9a2cb00980acaf8c1f780ff904" translate="yes" xml:space="preserve">
          <source>The URL &lt;code&gt;http://example.com/&lt;/code&gt; will be redirected to &lt;code&gt;http://www.example.com/&lt;/code&gt;, as will any files or directories under it (&lt;code&gt;http://example.com/index.html&lt;/code&gt; will be redirected to &lt;code&gt;http://www.example.com/index.html&lt;/code&gt;)</source>
          <target state="translated">URL &lt;code&gt;http://example.com/&lt;/code&gt; будет перенаправлен на &lt;code&gt;http://www.example.com/&lt;/code&gt; , как и любые файлы или каталоги под ним ( &lt;code&gt;http://example.com/index.html&lt;/code&gt; будут перенаправлены на &lt;code&gt;http://www.example.com/index.html&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="328f9c5a6f56c9b38378bbbf4afce0ee4c1c87e1" translate="yes" xml:space="preserve">
          <source>The URL being accessed. The path and query components of &lt;code&gt;https://&lt;/code&gt; URLs are stripped. In Chrome, you can disable this by setting &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, in Firefox the preference is &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt;.</source>
          <target state="translated">URL-адрес, к которому осуществляется доступ. Компоненты пути и запроса URL &lt;code&gt;https://&lt;/code&gt; удаляются. В Chrome вы можете отключить это, установив для &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; значение &lt;code&gt;false&lt;/code&gt; , в Firefox предпочтение - &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0186dd865b14f3a2fc2d2ec7512e14fe948697fc" translate="yes" xml:space="preserve">
          <source>The Upgrade general-header allows the client to specify what
   additional communication protocols it supports and would like to use
   if the server finds it appropriate to switch protocols. The server
   MUST use the Upgrade header field within a 101 (Switching Protocols)
   response to indicate which protocol(s) are being switched.

       Upgrade        = &quot;Upgrade&quot; &quot;:&quot; 1#product

   For example,

       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11

   The Upgrade header field is intended to provide a simple mechanism
   for transition from HTTP/1.1 to some other, incompatible protocol. It
   does so by allowing the client to advertise its desire to use another
   protocol, such as a later version of HTTP with a higher major version
   number, even though the current request has been made using HTTP/1.1.
   This eases the difficult transition between incompatible protocols by
   allowing the client to initiate a request in the more commonly
   supported protocol while indicating to the server that it would like
   to use a &quot;better&quot; protocol if available (where &quot;better&quot; is determined
   by the server, possibly according to the nature of the method and/or
   resource being requested).

   The Upgrade header field only applies to switching application-layer
   protocols upon the existing transport-layer connection. Upgrade
   cannot be used to insist on a protocol change; its acceptance and use
   by the server is optional. The capabilities and nature of the
   application-layer communication after the protocol change is entirely
   dependent upon the new protocol chosen, although the first action
   after changing the protocol MUST be a response to the initial HTTP
   request containing the Upgrade header field.

   The Upgrade header field only applies to the immediate connection.
   Therefore, the upgrade keyword MUST be supplied within a Connection
   header field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) whenever Upgrade is present in an
   HTTP/1.1 message. 

   The Upgrade header field cannot be used to indicate a switch to a
   protocol on a different connection. For that purpose, it is more
   appropriate to use a 301, 302, 303, or 305 redirection response.

   This specification only defines the protocol name &quot;HTTP&quot; for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of &lt;a href=&quot;#section-3.1&quot;&gt;section 3.1&lt;/a&gt; and future updates to this
   specification. Any token can be used as a protocol name; however, it
   will only be useful if both the client and server associate the name
   with the same protocol.</source>
          <target state="translated">Общий заголовок Upgrade позволяет клиенту указать, какие дополнительные протоколы связи он поддерживает и хотел бы использовать, если сервер сочтет целесообразным переключить протоколы. Сервер ДОЛЖЕН использовать поле заголовка Upgrade в ответе 101 (Switching Protocols), чтобы указать, какой протокол (ы) переключается. Upgrade = &quot;Upgrade&quot; &quot;:&quot; 1 # product Например, Upgrade: HTTP / 2.0, SHTTP / 1.3, IRC / 6.9, RTA / x11 Поле заголовка Upgrade предназначено для обеспечения простого механизма перехода с HTTP / 1.1 на некоторые другой, несовместимый протокол. Он делает это, позволяя клиенту заявить о своем желании использовать другой протокол, например, более позднюю версию HTTP с более высоким номером основной версии, даже если текущий запрос был сделан с использованием HTTP / 1.1.Это упрощает сложный переход между несовместимыми протоколами, позволяя клиенту инициировать запрос в более широко поддерживаемом протоколе, указывая серверу, что он хотел бы использовать &amp;laquo;лучший&amp;raquo; протокол, если он доступен (где &amp;laquo;лучший&amp;raquo; определяется сервером. , возможно, в зависимости от характера запрашиваемого метода и / или ресурса). Поле заголовка Upgrade применяется только к переключению протоколов прикладного уровня при существующем соединении транспортного уровня. Обновление нельзя использовать для настаивания на изменении протокола; его принятие и использование сервером необязательно. Возможности и характер связи на уровне приложений после изменения протокола полностью зависят от выбранного нового протокола.хотя первое действие после изменения протокола ДОЛЖНО быть ответом на начальный HTTP-запрос, содержащий поле заголовка Upgrade. Поле заголовка Upgrade применяется только к непосредственному соединению. Следовательно, ключевое слово обновления ДОЛЖНО быть указано в поле заголовка соединения (&lt;a href=&quot;#section-14.10&quot;&gt;раздел 14.10&lt;/a&gt; ) всякий раз, когда обновление присутствует в сообщении HTTP / 1.1. Поле заголовка Upgrade нельзя использовать для обозначения переключения на протокол в другом соединении. Для этой цели более целесообразно использовать ответ перенаправления 301, 302, 303 или 305. Эта спецификация определяет только имя протокола &amp;laquo;HTTP&amp;raquo; для использования семейством протоколов передачи гипертекста, как определено правилами версии HTTP &lt;a href=&quot;#section-3.1&quot;&gt;раздела 3.1&lt;/a&gt; и будущими обновлениями этой спецификации. В качестве имени протокола можно использовать любой токен; однако это будет полезно только в том случае, если и клиент, и сервер связывают имя с одним и тем же протоколом.</target>
        </trans-unit>
        <trans-unit id="956c514c873571fd13c43a02eba30c85c739c04b" translate="yes" xml:space="preserve">
          <source>The User-Agent (&lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;), Via (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;Section&amp;nbsp;5.7.1 of [RFC7230]&lt;/a&gt;), and
   Server (&lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;) header fields often reveal information about
   the respective sender's software systems.  In theory, this can make
   it easier for an attacker to exploit known security holes; in
   practice, attackers tend to try all potential holes regardless of the
   apparent software versions being used.

   Proxies that serve as a portal through a network firewall ought to
   take special precautions regarding the transfer of header information
   that might identify hosts behind the firewall.  The Via header field
   allows intermediaries to replace sensitive machine names with
   pseudonyms.</source>
          <target state="translated">Поля заголовка User-Agent ( &lt;a href=&quot;#section-5.5.3&quot;&gt;раздел 5.5.3&lt;/a&gt; ), Via ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;раздел 5.7.1 [RFC7230]&lt;/a&gt; ) и Server ( &lt;a href=&quot;#section-7.4.2&quot;&gt;раздел 7.4.2&lt;/a&gt; ) часто содержат информацию о программных системах соответствующего отправителя. Теоретически это может облегчить злоумышленнику использование известных дыр в безопасности; на практике злоумышленники стремятся попробовать все потенциальные дыры независимо от видимых версий используемого программного обеспечения. Прокси-серверы, которые служат порталом через сетевой брандмауэр, должны принимать особые меры предосторожности в отношении передачи информации заголовка, которая может идентифицировать хосты за брандмауэром. Поле заголовка Via позволяет посредникам заменять конфиденциальные имена компьютеров псевдонимами.</target>
        </trans-unit>
        <trans-unit id="37ab671dc85571491b078190122b8c7014630aae" translate="yes" xml:space="preserve">
          <source>The User-Agent request-header field contains information about the
   user agent originating the request. This is for statistical purposes,
   the tracing of protocol violations, and automated recognition of user
   agents for the sake of tailoring responses to avoid particular user
   agent limitations. User agents SHOULD include this field with
   requests. The field can contain multiple product tokens (&lt;a href=&quot;#section-3.8&quot;&gt;section 3.8&lt;/a&gt;)
   and comments identifying the agent and any subproducts which form a
   significant part of the user agent. By convention, the product tokens
   are listed in order of their significance for identifying the
   application.

       User-Agent     = &quot;User-Agent&quot; &quot;:&quot; 1*( product | comment )

   Example:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3</source>
          <target state="translated">Поле заголовка запроса User-Agent содержит информацию о пользовательском агенте, создавшем запрос. Это делается для статистических целей, отслеживания нарушений протокола и автоматического распознавания пользовательских агентов с целью адаптации ответов, чтобы избежать конкретных ограничений пользовательских агентов. Пользовательские агенты ДОЛЖНЫ включать это поле в запросы. Поле может содержать несколько токенов продукта ( &lt;a href=&quot;#section-3.8&quot;&gt;раздел 3.8&lt;/a&gt; ) и комментарии, идентифицирующие агента и любые субпродукты, которые составляют значительную часть пользовательского агента. По соглашению, маркеры продуктов перечислены в порядке их значимости для идентификации приложения. User-Agent = &quot;User-Agent&quot; &quot;:&quot; 1 * (product | comment) Пример: User-Agent: CERN-LineMode / 2.15 libwww / 2.17b3</target>
        </trans-unit>
        <trans-unit id="0145d328878d74d7d6f76ae8e632bd27f666b2da" translate="yes" xml:space="preserve">
          <source>The Vary field value indicates the set of request-header fields that
   fully determines, while the response is fresh, whether a cache is
   permitted to use the response to reply to a subsequent request
   without revalidation. For uncacheable or stale responses, the Vary
   field value advises the user agent about the criteria that were used
   to select the representation. A Vary field value of &quot;*&quot; implies that
   a cache cannot determine from the request headers of a subsequent
   request whether this response is the appropriate representation. See
   &lt;a href=&quot;#section-13.6&quot;&gt;section 13.6&lt;/a&gt; for use of the Vary header field by caches.

       Vary  = &quot;Vary&quot; &quot;:&quot; ( &quot;*&quot; | 1#field-name )

   An HTTP/1.1 server SHOULD include a Vary header field with any
   cacheable response that is subject to server-driven negotiation.
   Doing so allows a cache to properly interpret future requests on that
   resource and informs the user agent about the presence of negotiation 

   on that resource. A server MAY include a Vary header field with a
   non-cacheable response that is subject to server-driven negotiation,
   since this might provide the user agent with useful information about
   the dimensions over which the response varies at the time of the
   response.

   A Vary field value consisting of a list of field-names signals that
   the representation selected for the response is based on a selection
   algorithm which considers ONLY the listed request-header field values
   in selecting the most appropriate representation. A cache MAY assume
   that the same selection will be made for future requests with the
   same values for the listed field names, for the duration of time for
   which the response is fresh.

   The field-names given are not limited to the set of standard
   request-header fields defined by this specification. Field names are
   case-insensitive.

   A Vary field value of &quot;*&quot; signals that unspecified parameters not
   limited to the request-headers (e.g., the network address of the
   client), play a role in the selection of the response representation.
   The &quot;*&quot; value MUST NOT be generated by a proxy server; it may only be
   generated by an origin server.</source>
          <target state="translated">Значение поля Vary указывает набор полей заголовка запроса, который полностью определяет, пока ответ является свежим, разрешено ли кэшу использовать ответ для ответа на последующий запрос без повторной проверки. Для некэшируемых или устаревших ответов значение поля Vary сообщает пользовательскому агенту о критериях, которые использовались для выбора представления. Значение поля Vary &amp;laquo;*&amp;raquo; означает, что кэш не может определить из заголовков запроса последующего запроса, является ли этот ответ подходящим представлением. См. &lt;a href=&quot;#section-13.6&quot;&gt;Раздел 13.6.&lt;/a&gt;для использования кешами поля заголовка Vary. Vary = &quot;Vary&quot; &quot;:&quot; (&quot;*&quot; | 1 # field-name) Сервер HTTP / 1.1 ДОЛЖЕН включать поле заголовка Vary с любым кешируемым ответом, который является предметом согласования, управляемого сервером. Это позволяет кэшу правильно интерпретировать будущие запросы к этому ресурсу и информирует пользовательский агент о наличии согласования по этому ресурсу. Сервер МОЖЕТ включать поле заголовка Vary с некэшируемым ответом, который является предметом согласования, управляемого сервером, поскольку это может предоставить пользовательскому агенту полезную информацию об измерениях, по которым ответ изменяется во время ответа.Значение поля Vary, состоящее из списка имен полей, сигнализирует о том, что представление, выбранное для ответа, основано на алгоритме выбора, который учитывает ТОЛЬКО перечисленные значения полей заголовка запроса при выборе наиболее подходящего представления. Кэш МОЖЕТ предполагать, что такой же выбор будет сделан для будущих запросов с теми же значениями для перечисленных имен полей в течение времени, в течение которого ответ остается свежим. Указанные имена полей не ограничиваются набором стандартных полей заголовка запроса, определенных в этой спецификации. Имена полей не чувствительны к регистру. Значение поля Vary &amp;laquo;*&amp;raquo; сигнализирует, что неуказанные параметры, не ограниченные заголовками запроса (например, сетевой адрес клиента), играют роль в выборе представления ответа. &quot;* &quot;значение НЕ ДОЛЖНО генерироваться прокси-сервером; оно может быть создано только исходным сервером.</target>
        </trans-unit>
        <trans-unit id="46218eb322ca25f8d1c7432adb208448ace419bd" translate="yes" xml:space="preserve">
          <source>The Via general-header field MUST be used by gateways and proxies to
   indicate the intermediate protocols and recipients between the user
   agent and the server on requests, and between the origin server and
   the client on responses. It is analogous to the &quot;Received&quot; field of
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] and is intended to be used for tracking message forwards,
   avoiding request loops, and identifying the protocol capabilities of
   all senders along the request/response chain.

      Via =  &quot;Via&quot; &quot;:&quot; 1#( received-protocol received-by [ comment ] )
      received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
      protocol-name     = token
      protocol-version  = token
      received-by       = ( host [ &quot;:&quot; port ] ) | pseudonym
      pseudonym         = token

   The received-protocol indicates the protocol version of the message
   received by the server or client along each segment of the
   request/response chain. The received-protocol version is appended to
   the Via field value when the message is forwarded so that information
   about the protocol capabilities of upstream applications remains
   visible to all recipients. 

   The protocol-name is optional if and only if it would be &quot;HTTP&quot;. The
   received-by field is normally the host and optional port number of a
   recipient server or client that subsequently forwarded the message.
   However, if the real host is considered to be sensitive information,
   it MAY be replaced by a pseudonym. If the port is not given, it MAY
   be assumed to be the default port of the received-protocol.

   Multiple Via field values represents each proxy or gateway that has
   forwarded the message. Each recipient MUST append its information
   such that the end result is ordered according to the sequence of
   forwarding applications.

   Comments MAY be used in the Via header field to identify the software
   of the recipient proxy or gateway, analogous to the User-Agent and
   Server header fields. However, all comments in the Via field are
   optional and MAY be removed by any recipient prior to forwarding the
   message.

   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named &quot;fred&quot;, which uses HTTP/1.1 to
   forward the request to a public proxy at nowhere.com, which completes
   the request by forwarding it to the origin server at www.ics.uci.edu.
   The request received by www.ics.uci.edu would then have the following
   Via header field:

       Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)

   Proxies and gateways used as a portal through a network firewall
   SHOULD NOT, by default, forward the names and ports of hosts within
   the firewall region. This information SHOULD only be propagated if
   explicitly enabled. If not enabled, the received-by host of any host
   behind the firewall SHOULD be replaced by an appropriate pseudonym
   for that host.

   For organizations that have strong privacy requirements for hiding
   internal structures, a proxy MAY combine an ordered subsequence of
   Via header field entries with identical received-protocol values into
   a single such entry. For example,

       Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

        could be collapsed to

       Via: 1.0 ricky, 1.1 mertz, 1.0 lucy 

   Applications SHOULD NOT combine multiple entries unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms. Applications MUST NOT combine entries which
   have different received-protocol values.</source>
          <target state="translated">Поле общего заголовка Via ДОЛЖНО использоваться шлюзами и прокси для указания промежуточных протоколов и получателей между пользовательским агентом и сервером при запросах и между исходным сервером и клиентом при ответах. Это аналог поля &amp;laquo;Получено&amp;raquo; в &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] и предназначен для использования для отслеживания пересылки сообщений, предотвращения зацикливания запросов и определения возможностей протокола всех отправителей в цепочке запросов / ответов. Via = &quot;Через&quot; &quot;:&quot; 1 # (полученный-протокол получен [комментарий]) полученный-протокол = [имя-протокола &quot;/&quot;] версия-протокола имя-протокола = токен версия-протокола = полученный-полученный-токен (хост [&quot;:&quot; порт]) | псевдоним pseudonym = token Полученный протокол указывает версию протокола сообщения, полученного сервером или клиентом в каждом сегменте цепочки запросов / ответов.Версия принятого протокола добавляется к значению поля Via при пересылке сообщения, так что информация о возможностях протокола восходящих приложений остается видимой для всех получателей. Имя-протокола является необязательным, если и только если это будет &amp;laquo;HTTP&amp;raquo;. Поле полученного обычно представляет собой хост и необязательный номер порта сервера-получателя или клиента, который впоследствии переадресовал сообщение. Однако, если реальный хост считается конфиденциальной информацией, он МОЖЕТ быть заменен псевдонимом. Если порт не указан, он МОЖЕТ быть принят как порт по умолчанию для принятого протокола. Несколько значений поля Via представляют каждый прокси или шлюз, который переадресовал сообщение.Каждый получатель ДОЛЖЕН добавить свою информацию так, чтобы конечный результат был упорядочен в соответствии с последовательностью приложений пересылки. Комментарии МОГУТ использоваться в поле заголовка Via для идентификации программного обеспечения прокси-сервера или шлюза получателя, аналогично полям заголовка User-Agent и Server. Однако все комментарии в поле Via являются необязательными и МОГУТ быть удалены любым получателем до пересылки сообщения. Например, сообщение запроса может быть отправлено от пользовательского агента HTTP / 1.0 на внутренний прокси-сервер с кодовым именем &amp;laquo;fred&amp;raquo;, который использует HTTP / 1.1 для пересылки запроса общедоступному прокси-серверу nowhere.com, который завершает запрос пересылка на исходный сервер на www.ics.uci.edu. Запрос, полученный сайтом www.ics.uci.edu, будет иметь следующее поле заголовка Via: Via: 1.0 fred, 1.1 nowhere.com (Apache / 1.1) Прокси-серверы и шлюзы, используемые в качестве портала через сетевой брандмауэр, НЕ ДОЛЖНЫ по умолчанию пересылать имена и порты хостов в регионе брандмауэра. Эту информацию СЛЕДУЕТ распространять, только если явно разрешено. Если этот параметр не включен, принимаемый хост любого хоста за брандмауэром ДОЛЖЕН быть заменен соответствующим псевдонимом для этого хоста. Для организаций, которые предъявляют строгие требования к конфиденциальности для сокрытия внутренних структур, прокси МОЖЕТ объединить упорядоченную подпоследовательность записей поля заголовка Via с идентичными значениями принятого протокола в одну такую ​​запись. Например, Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy можно свернуть на Via: 1.0 ricky, 1.1 mertz, 1.0 lucy Приложения НЕ ДОЛЖНЫ объединять несколько записей, если все они не находятся под одним и тем же организационным контролем и хосты уже заменены псевдонимами. Приложения НЕ ДОЛЖНЫ объединять записи, которые имеют разные значения протокола приема.</target>
        </trans-unit>
        <trans-unit id="0176fdb6175026d4c263772f8859cf082f15cf8e" translate="yes" xml:space="preserve">
          <source>The WWW-Authenticate response-header field MUST be included in 401
   (Unauthorized) response messages. The field value consists of at
   least one challenge that indicates the authentication scheme(s) and
   parameters applicable to the Request-URI.

       WWW-Authenticate  = &quot;WWW-Authenticate&quot; &quot;:&quot; 1#challenge

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. User
   agents are advised to take special care in parsing the WWW-
   Authenticate field value as it might contain more than one challenge,
   or if more than one WWW-Authenticate header field is provided, the
   contents of a challenge itself can contain a comma-separated list of
   authentication parameters.</source>
          <target state="translated">Поле заголовка ответа WWW-Authenticate ДОЛЖНО быть включено в ответное сообщение 401 (Unauthorized). Значение поля состоит как минимум из одного запроса, который указывает схему (ы) аутентификации и параметры, применимые к Request-URI. WWW-Authenticate = &quot;WWW-Authenticate&quot; &quot;:&quot; 1 # вызов Процесс аутентификации доступа HTTP описан в разделе &quot;Аутентификация HTTP: базовая и дайджест-аутентификация доступа&quot; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]. Пользовательским агентам рекомендуется проявлять особую осторожность при синтаксическом анализе значения поля WWW-Authenticate, поскольку оно может содержать более одного запроса, или, если предоставлено более одного поля заголовка WWW-Authenticate, содержимое самого запроса может содержать разделенные запятыми список параметров аутентификации.</target>
        </trans-unit>
        <trans-unit id="7a35f374a20f06c6368a7744257833df18d21fb6" translate="yes" xml:space="preserve">
          <source>The Warning general-header field is used to carry additional
   information about the status or transformation of a message which
   might not be reflected in the message. This information is typically
   used to warn about a possible lack of semantic transparency from
   caching operations or transformations applied to the entity body of
   the message.

   Warning headers are sent with responses using:

       Warning    = &quot;Warning&quot; &quot;:&quot; 1#warning-value

       warning-value = warn-code SP warn-agent SP warn-text
                                             [SP warn-date]

       warn-code  = 3DIGIT
       warn-agent = ( host [ &quot;:&quot; port ] ) | pseudonym
                       ; the name or pseudonym of the server adding
                       ; the Warning header, for use in debugging
       warn-text  = quoted-string
       warn-date  = &amp;lt;&quot;&amp;gt; HTTP-date &amp;lt;&quot;&amp;gt;

   A response MAY carry more than one Warning header.

   The warn-text SHOULD be in a natural language and character set that
   is most likely to be intelligible to the human user receiving the
   response. This decision MAY be based on any available knowledge, such
   as the location of the cache or user, the Accept-Language field in a
   request, the Content-Language field in a response, etc. The default
   language is English and the default character set is ISO-8859-1.

   If a character set other than ISO-8859-1 is used, it MUST be encoded
   in the warn-text using the method described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [&lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;].

   Warning headers can in general be applied to any message, however
   some specific warn-codes are specific to caches and can only be
   applied to response messages. New Warning headers SHOULD be added
   after any existing Warning headers. A cache MUST NOT delete any
   Warning header that it received with a message. However, if a cache
   successfully validates a cache entry, it SHOULD remove any Warning
   headers previously attached to that entry except as specified for 

   specific Warning codes. It MUST then add any Warning headers received
   in the validating response. In other words, Warning headers are those
   that would be attached to the most recent relevant response.

   When multiple Warning headers are attached to a response, the user
   agent ought to inform the user of as many of them as possible, in the
   order that they appear in the response. If it is not possible to
   inform the user of all of the warnings, the user agent SHOULD follow
   these heuristics:

      - Warnings that appear early in the response take priority over
        those appearing later in the response.

      - Warnings in the user's preferred character set take priority
        over warnings in other character sets but with identical warn-
        codes and warn-agents.

   Systems that generate multiple Warning headers SHOULD order them with
   this user agent behavior in mind.

   Requirements for the behavior of caches with respect to Warnings are
   stated in &lt;a href=&quot;#section-13.1.2&quot;&gt;section 13.1.2&lt;/a&gt;.

   This is a list of the currently-defined warn-codes, each with a
   recommended warn-text in English, and a description of its meaning.

   110 Response is stale
     MUST be included whenever the returned response is stale.

   111 Revalidation failed
     MUST be included if a cache returns a stale response because an
     attempt to revalidate the response failed, due to an inability to
     reach the server.

   112 Disconnected operation
     SHOULD be included if the cache is intentionally disconnected from
     the rest of the network for a period of time.

   113 Heuristic expiration
     MUST be included if the cache heuristically chose a freshness
     lifetime greater than 24 hours and the response's age is greater
     than 24 hours.

   199 Miscellaneous warning
     The warning text MAY include arbitrary information to be presented
     to a human user, or logged. A system receiving this warning MUST
     NOT take any automated action, besides presenting the warning to
     the user. 

   214 Transformation applied
     MUST be added by an intermediate cache or proxy if it applies any
     transformation changing the content-coding (as specified in the
     Content-Encoding header) or media-type (as specified in the
     Content-Type header) of the response, or the entity-body of the
     response, unless this Warning code already appears in the response.

   299 Miscellaneous persistent warning
     The warning text MAY include arbitrary information to be presented
     to a human user, or logged. A system receiving this warning MUST
     NOT take any automated action.

   If an implementation sends a message with one or more Warning headers
   whose version is HTTP/1.0 or lower, then the sender MUST include in
   each warning-value a warn-date that matches the date in the response.

   If an implementation receives a message with a warning-value that
   includes a warn-date, and that warn-date is different from the Date
   value in the response, then that warning-value MUST be deleted from
   the message before storing, forwarding, or using it. (This prevents
   bad consequences of naive caching of Warning header fields.) If all
   of the warning-values are deleted for this reason, the Warning header
   MUST be deleted as well.</source>
          <target state="translated">Поле общего заголовка предупреждения используется для передачи дополнительной информации о состоянии или преобразовании сообщения, которая может не отражаться в сообщении. Эта информация обычно используется для предупреждения о возможном отсутствии семантической прозрачности из-за операций кэширования или преобразований, применяемых к телу объекта сообщения. Заголовки предупреждений отправляются с ответами с использованием: Warning = &quot;Warning&quot; &quot;:&quot; 1 # значение-предупреждения значение-предупреждения = код-предупреждения SP-предупреждения-агента SP-предупреждения-текст [Дата-предупреждения-SP] код-предупреждения = 3DIGIT-агент-предупреждения = (хост [&quot;:&quot; порт]) | псевдоним; имя или псевдоним добавляемого сервера; заголовок предупреждения,для использования при отладке warn-text = quoted-string warn-date = &amp;lt;&quot;&amp;gt; HTTP-date &amp;lt;&quot;&amp;gt; Ответ МОЖЕТ содержать более одного заголовка предупреждения. Текст предупреждения ДОЛЖЕН быть на естественном языке и с набором символов, который, скорее всего, будет понятен человеку-пользователю, получающему ответ. Это решение МОЖЕТ основываться на любых доступных знаниях, таких как расположение кеша или пользователя, поле Accept-Language в запросе, поле Content-Language в ответе и т. Д. Язык по умолчанию - английский, а набор символов по умолчанию это ISO-8859-1. Если используется набор символов, отличный от ISO-8859-1, он ДОЛЖЕН быть закодирован в тексте предупреждения с использованием метода, описанного вТекст предупреждения ДОЛЖЕН быть на естественном языке и с набором символов, который, скорее всего, будет понятен человеку-пользователю, получающему ответ. Это решение МОЖЕТ основываться на любых доступных знаниях, таких как расположение кеша или пользователя, поле Accept-Language в запросе, поле Content-Language в ответе и т. Д. Язык по умолчанию - английский, а набор символов по умолчанию это ISO-8859-1. Если используется набор символов, отличный от ISO-8859-1, он ДОЛЖЕН быть закодирован в тексте предупреждения с использованием метода, описанного вТекст предупреждения ДОЛЖЕН быть на естественном языке и с набором символов, который, скорее всего, будет понятен человеку-пользователю, получающему ответ. Это решение МОЖЕТ основываться на любых доступных знаниях, таких как расположение кеша или пользователя, поле Accept-Language в запросе, поле Content-Language в ответе и т. Д. Язык по умолчанию - английский, а набор символов по умолчанию это ISO-8859-1. Если используется набор символов, отличный от ISO-8859-1, он ДОЛЖЕН быть закодирован в тексте предупреждения с использованием метода, описанного вполе Content-Language в ответе и т. д. Язык по умолчанию - английский, а набор символов по умолчанию - ISO-8859-1. Если используется набор символов, отличный от ISO-8859-1, он ДОЛЖЕН быть закодирован в тексте предупреждения с использованием метода, описанного вполе Content-Language в ответе и т. д. Язык по умолчанию - английский, а набор символов по умолчанию - ISO-8859-1. Если используется набор символов, отличный от ISO-8859-1, он ДОЛЖЕН быть закодирован в тексте предупреждения с использованием метода, описанного в&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [ &lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;]. Заголовки предупреждений, как правило, могут применяться к любому сообщению, однако некоторые конкретные коды предупреждений относятся к кэшам и могут применяться только к ответным сообщениям. Новые заголовки предупреждений ДОЛЖНЫ быть добавлены после любых существующих заголовков предупреждений. Кэш НЕ ДОЛЖЕН удалять любой заголовок предупреждения, полученный с сообщением. Однако, если кэш успешно проверяет запись кэша, он ДОЛЖЕН удалить все заголовки предупреждений, ранее прикрепленные к этой записи, за исключением случаев, указанных для конкретных кодов предупреждений. Затем он ДОЛЖЕН добавить любые заголовки предупреждений, полученные в проверяющем ответе. Другими словами, заголовки предупреждений - это заголовки, которые будут прикреплены к самому последнему актуальному ответу. Когда к ответу прикреплено несколько заголовков Warning, пользовательский агент должен проинформировать пользователя о как можно большем количестве из них,в том порядке, в котором они появляются в ответе. Если невозможно проинформировать пользователя обо всех предупреждениях, пользовательский агент ДОЛЖЕН следовать этой эвристике: - Предупреждения, которые появляются в начале ответа, имеют приоритет над теми, которые появляются позже в ответе. - Предупреждения в предпочтительном наборе символов пользователя имеют приоритет над предупреждениями в других наборах символов, но с идентичными кодами предупреждений и агентами предупреждений. Системы, которые генерируют несколько заголовков предупреждений, ДОЛЖНЫ упорядочивать их с учетом этого поведения пользовательского агента. Требования к поведению кешей в отношении предупреждений изложены в- Предупреждения, которые появляются в начале ответа, имеют приоритет над теми, которые появляются позже в ответе. - Предупреждения в предпочтительном наборе символов пользователя имеют приоритет над предупреждениями в других наборах символов, но с идентичными кодами предупреждений и агентами предупреждений. Системы, которые генерируют несколько заголовков предупреждений, ДОЛЖНЫ упорядочивать их с учетом этого поведения пользовательского агента. Требования к поведению кешей в отношении предупреждений изложены в- Предупреждения, которые появляются в начале ответа, имеют приоритет над теми, которые появляются позже в ответе. - Предупреждения в предпочтительном наборе символов пользователя имеют приоритет над предупреждениями в других наборах символов, но с идентичными кодами предупреждений и агентами предупреждений. Системы, которые генерируют несколько заголовков предупреждений, ДОЛЖНЫ упорядочивать их с учетом этого поведения пользовательского агента. Требования к поведению кешей в отношении предупреждений изложены вТребования к поведению кешей в отношении предупреждений изложены вТребования к поведению кешей в отношении предупреждений изложены в&lt;a href=&quot;#section-13.1.2&quot;&gt;раздел 13.1.2&lt;/a&gt;, Это список определенных в настоящее время кодов предупреждений, каждый с рекомендуемым текстом предупреждения на английском языке и описанием его значения. 110 Ответ устаревший ДОЛЖЕН быть включен всякий раз, когда возвращенный ответ является устаревшим. 111 Ошибка повторной проверки ДОЛЖНА быть включена, если кэш возвращает устаревший ответ из-за неудачной попытки повторной проверки ответа из-за невозможности доступа к серверу. 112 Операция отключения ДОЛЖНА быть включена, если кэш намеренно отключен от остальной сети на определенный период времени. 113 Эвристическое истечение ДОЛЖНО быть включено, если кэш эвристически выбрал срок действия обновления более 24 часов, а возраст ответа превышает 24 часа.199 Прочие предупреждения Текст предупреждения МОЖЕТ включать произвольную информацию, которая будет представлена ​​пользователю-человеку или записана в журнал. Система, получающая это предупреждение, НЕ ДОЛЖНА предпринимать какие-либо автоматические действия, кроме представления предупреждения пользователю. 214 Применяемое преобразование ДОЛЖНО быть добавлено промежуточным кешем или прокси-сервером, если он применяет любое преобразование, изменяющее кодирование содержимого (как указано в заголовке Content-Encoding) или медиа-тип (как указано в заголовке Content-Type) ответа, или тело объекта ответа, если этот код предупреждения уже не появляется в ответе. 299 Разное постоянное предупреждение Текст предупреждения МОЖЕТ включать произвольную информацию, которая будет представлена ​​пользователю-человеку или записана в журнал. Система, получающая это предупреждение, НЕ ДОЛЖНА предпринимать никаких автоматических действий.Если реализация отправляет сообщение с одним или несколькими заголовками предупреждений, версия которых - HTTP / 1.0 или ниже, то отправитель ДОЛЖЕН включать в каждое значение предупреждения дату предупреждения, которая соответствует дате в ответе. Если реализация получает сообщение со значением-предупреждением, которое включает дату-предупреждения, и эта дата-предупреждения отличается от значения даты в ответе, то это значение-предупреждения ДОЛЖНО быть удалено из сообщения перед сохранением, пересылкой или используй это. (Это предотвращает плохие последствия наивного кэширования полей заголовка предупреждения.) Если все значения предупреждения удалены по этой причине, заголовок предупреждения также ДОЛЖЕН быть удален.тогда отправитель ДОЛЖЕН включать в каждое значение предупреждения дату предупреждения, которая соответствует дате в ответе. Если реализация получает сообщение со значением-предупреждением, которое включает дату-предупреждения, и эта дата-предупреждения отличается от значения даты в ответе, то это значение-предупреждения ДОЛЖНО быть удалено из сообщения перед сохранением, пересылкой или используй это. (Это предотвращает плохие последствия наивного кэширования полей заголовка предупреждения.) Если все значения предупреждения удалены по этой причине, заголовок предупреждения также ДОЛЖЕН быть удален.тогда отправитель ДОЛЖЕН включать в каждое значение предупреждения дату предупреждения, которая соответствует дате в ответе. Если реализация получает сообщение со значением-предупреждением, которое включает дату-предупреждения, и эта дата-предупреждения отличается от значения даты в ответе, то это значение-предупреждения ДОЛЖНО быть удалено из сообщения перед сохранением, пересылкой или используй это. (Это предотвращает плохие последствия наивного кэширования полей заголовка предупреждения.) Если все значения предупреждения удалены по этой причине, заголовок предупреждения также ДОЛЖЕН быть удален.(Это предотвращает плохие последствия наивного кэширования полей заголовка предупреждения.) Если все значения предупреждения удалены по этой причине, заголовок предупреждения также ДОЛЖЕН быть удален.(Это предотвращает плохие последствия наивного кэширования полей заголовка предупреждения.) Если все значения предупреждения удалены по этой причине, заголовок предупреждения также ДОЛЖЕН быть удален.</target>
        </trans-unit>
        <trans-unit id="650ee0647a2c1fdd4db296e88e9d7457a6d4e9da" translate="yes" xml:space="preserve">
          <source>The Web APIs have native methods to encode or decode to base64: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;Base64 encoding and decoding&lt;/a&gt;.</source>
          <target state="translated">У веб-API есть собственные методы для кодирования или декодирования в base64: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;кодирование и декодирование Base64&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="56faf444060ee49993107fee26b7ba0d66f5e281" translate="yes" xml:space="preserve">
          <source>The Web Origin Concept</source>
          <target state="translated">Концепция веб-происхождения</target>
        </trans-unit>
        <trans-unit id="215d6bd38f0870c1defdd62eb60f6f1375d1790f" translate="yes" xml:space="preserve">
          <source>The Web Runtime uses the same user agent string as desktop Firefox.</source>
          <target state="translated">В Web Runtime используется та же самая строка агента пользователя,что и в desktop Firefox.</target>
        </trans-unit>
        <trans-unit id="941232b2ff4433cb0bd6270438632894b53fb59c" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don't update their links.</source>
          <target state="translated">Веб-страница временно недоступна по непредвиденным причинам.Таким образом,поисковые системы не обновляют свои ссылки.</target>
        </trans-unit>
        <trans-unit id="55fa8ca3dd54f0ec3aab1401af4719063aeb4a24" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don't update their links. Better than &lt;code&gt;302&lt;/code&gt; when non-GET links/operations are available on the site.</source>
          <target state="translated">Веб-страница временно недоступна по непредвиденным причинам. Таким образом, поисковые системы не обновляют свои ссылки. Лучше, чем &lt;code&gt;302&lt;/code&gt; , когда на сайте доступны не-GET ссылки / операции.</target>
        </trans-unit>
        <trans-unit id="ad5e46a03efafad9853b734ee0d593694b072117" translate="yes" xml:space="preserve">
          <source>The Web server</source>
          <target state="translated">Веб-сервер</target>
        </trans-unit>
        <trans-unit id="95924074d7e37faf6b144a7b43119f38c76fd2f0" translate="yes" xml:space="preserve">
          <source>The WebSocket Protocol</source>
          <target state="translated">Протокол WebSocket</target>
        </trans-unit>
        <trans-unit id="09ee06d1ee05107c094545645447a824d3d94f1b" translate="yes" xml:space="preserve">
          <source>The WebSocket protocol version the client wishes to use when communicating with the server. This number should be the most recent version possible listed in the &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#version-number&quot;&gt;IANA WebSocket Version Number Registry&lt;/a&gt;. The most recent final version of the WebSocket protocol is version 13.</source>
          <target state="translated">Версия протокола WebSocket, которую клиент желает использовать при взаимодействии с сервером. Этот номер должен быть самой последней возможной версией, указанной в &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#version-number&quot;&gt;реестре номеров версий IANA WebSocket&lt;/a&gt; . Самая последняя финальная версия протокола WebSocket - это версия 13.</target>
        </trans-unit>
        <trans-unit id="e242f211ed018b0f56d726778881102bd4b4068c" translate="yes" xml:space="preserve">
          <source>The XML namespace extension ([&lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;]) is used in this
   specification in order to allow for new XML elements to be added
   without fear of colliding with other element names.  Although WebDAV
   request and response bodies can be extended by arbitrary XML
   elements, which can be ignored by the message recipient, an XML
   element in the &quot;DAV:&quot; namespace SHOULD NOT be used in the request or
   response body unless that XML element is explicitly defined in an
   IETF RFC reviewed by a WebDAV working group.

   For WebDAV to be both extensible and backwards-compatible, both
   clients and servers need to know how to behave when unexpected or
   unrecognized command extensions are received.  For XML processing,
   this means that clients and servers MUST process received XML
   documents as if unexpected elements and attributes (and all children
   of unrecognized elements) were not there.  An unexpected element or
   attribute includes one that may be used in another context but is not
   expected here.  Ignoring such items for purposes of processing can of
   course be consistent with logging all information or presenting for
   debugging.

   This restriction also applies to the processing, by clients, of DAV
   property values where unexpected XML elements SHOULD be ignored
   unless the property's schema declares otherwise.

   This restriction does not apply to setting dead DAV properties on the
   server where the server MUST record all XML elements. 

   Additionally, this restriction does not apply to the use of XML where
   XML happens to be the content type of the entity body, for example,
   when used as the body of a PUT.

   Processing instructions in XML SHOULD be ignored by recipients.
   Thus, specifications extending WebDAV SHOULD NOT use processing
   instructions to define normative behavior.

   XML DTD fragments are included for all the XML elements defined in
   this specification.  However, correct XML will not be valid according
   to any DTD due to namespace usage and extension rules.  In
   particular:

   o  Elements (from this specification) are in the &quot;DAV:&quot; namespace,

   o  Element ordering is irrelevant unless otherwise stated,

   o  Extension attributes MAY be added,

   o  For element type definitions of &quot;ANY&quot;, the normative text
      definition for that element defines what can be in it and what
      that means.

   o  For element type definitions of &quot;#PCDATA&quot;, extension elements MUST
      NOT be added.

   o  For other element type definitions, including &quot;EMPTY&quot;, extension
      elements MAY be added.

   Note that this means that elements containing elements cannot be
   extended to contain text, and vice versa.

   With DTD validation relaxed by the rules above, the constraints
   described by the DTD fragments are normative (see for example
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;).  A recipient of a WebDAV message with an XML body MUST
   NOT validate the XML document according to any hard-coded or
   dynamically-declared DTD.

   Note that this section describes backwards-compatible extensibility
   rules.  There might also be times when an extension is designed not
   to be backwards-compatible, for example, defining an extension that
   reuses an XML element defined in this document but omitting one of
   the child elements required by the DTDs in this specification.</source>
          <target state="translated">Расширение пространства имен XML ([ &lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;]) используется в этой спецификации, чтобы позволить добавлять новые элементы XML, не опасаясь столкновения с другими именами элементов. Хотя тела запросов и ответов WebDAV могут быть расширены произвольными элементами XML, которые могут игнорироваться получателем сообщения, элемент XML в пространстве имен &amp;laquo;DAV:&amp;raquo; НЕ ДОЛЖЕН использоваться в теле запроса или ответа, если этот элемент XML не определен явно. в RFC IETF, рассмотренном рабочей группой WebDAV. Чтобы WebDAV был расширяемым и обратно совместимым, и клиенты, и серверы должны знать, как вести себя при получении неожиданных или нераспознанных расширений команд. Для обработки XML,это означает, что клиенты и серверы ДОЛЖНЫ обрабатывать полученные XML-документы, как если бы неожиданных элементов и атрибутов (и всех дочерних элементов нераспознанных элементов) не было. Неожиданный элемент или атрибут включает тот, который может использоваться в другом контексте, но здесь не ожидается. Игнорирование таких элементов в целях обработки, конечно, может соответствовать регистрации всей информации или ее представлению для отладки. Это ограничение также применяется к обработке клиентами значений свойств DAV, в которых СЛЕДУЕТ игнорировать неожиданные элементы XML, если в схеме свойства не указано иное. Это ограничение не применяется к установке неработающих свойств DAV на сервере, где сервер ДОЛЖЕН записывать все элементы XML. Дополнительно,это ограничение не применяется к использованию XML, где XML является типом содержимого тела объекта, например, при использовании в качестве тела PUT. Получатели СЛЕДУЕТ игнорировать инструкции обработки в XML. Таким образом, спецификации, расширяющие WebDAV, НЕ ДОЛЖНЫ использовать инструкции обработки для определения нормативного поведения. Фрагменты XML DTD включены во все элементы XML, определенные в этой спецификации. Однако правильный XML не будет действительным в соответствии с каким-либо DTD из-за использования пространства имен и правил расширения. В частности: o Элементы (из этой спецификации) находятся в пространстве имен &amp;laquo;DAV:&amp;raquo;, o Порядок элементов не имеет значения, если не указано иное, o Могут быть добавлены атрибуты расширения, o Для определений типа элемента &amp;laquo;ЛЮБОЙ&amp;raquo;,нормативное текстовое определение этого элемента определяет, что в нем может содержаться и что это означает. o Для определений типа элементов &quot;#PCDATA&quot; элементы расширения НЕ ДОЛЖНЫ добавляться. o Для других определений типов элементов, включая &quot;EMPTY&quot;, МОГУТ быть добавлены элементы расширения. Обратите внимание, что это означает, что элементы, содержащие элементы, не могут быть расширены, чтобы содержать текст, и наоборот. С проверкой DTD, ослабленной указанными выше правилами, ограничения, описанные фрагментами DTD, являются нормативными (см., Например,Обратите внимание, что это означает, что элементы, содержащие элементы, не могут быть расширены, чтобы содержать текст, и наоборот. С проверкой DTD, ослабленной указанными выше правилами, ограничения, описанные фрагментами DTD, являются нормативными (см., Например,Обратите внимание, что это означает, что элементы, содержащие элементы, не могут быть расширены, чтобы содержать текст, и наоборот. С проверкой DTD, ослабленной указанными выше правилами, ограничения, описанные фрагментами DTD, являются нормативными (см., Например, &lt;a href=&quot;#appendix-A&quot;&gt;Приложение А&lt;/a&gt; ). Получатель сообщения WebDAV с телом XML НЕ ДОЛЖЕН проверять документ XML в соответствии с каким-либо жестко запрограммированным или динамически объявленным DTD. Обратите внимание, что в этом разделе описаны правила расширяемости с обратной совместимостью. Также могут быть случаи, когда расширение спроектировано так, чтобы быть обратно совместимым, например, определение расширения, которое повторно использует элемент XML, определенный в этом документе, но опускает один из дочерних элементов, требуемых DTD в этой спецификации.</target>
        </trans-unit>
        <trans-unit id="b298dd5e10b677f7b1f3b1962b7f374d92022229" translate="yes" xml:space="preserve">
          <source>The ability to lock a resource provides a mechanism for serializing
   access to that resource.  Using a lock, an authoring client can
   provide a reasonable guarantee that another principal will not modify
   a resource while it is being edited.  In this way, a client can
   prevent the &quot;lost update&quot; problem.

   This specification allows locks to vary over two client-specified
   parameters, the number of principals involved (exclusive vs. shared)
   and the type of access to be granted.  This document defines locking
   for only one access type, write.  However, the syntax is extensible,
   and permits the eventual specification of locking for other access
   types.</source>
          <target state="translated">Возможность блокировки ресурса обеспечивает механизм сериализации доступа к этому ресурсу.Используя блокировку,клиент-авторизатор может предоставить разумную гарантию того,что другой директор не будет изменять ресурс во время его редактирования.Таким образом,клиент может предотвратить проблему &quot;потерянного обновления&quot;.Данная спецификация позволяет изменять блокировки более чем на два указанных клиентом параметра,количество задействованных принципалов (эксклюзивный против общего)и тип предоставляемого доступа.Данный документ определяет блокировку только для одного типа доступа,запись.Однако синтаксис является расширяемым и позволяет в конечном итоге специфицировать блокировку для других типов доступа.</target>
        </trans-unit>
        <trans-unit id="3b06c2527b7380abe2e2e286d29197b000c1f987" translate="yes" xml:space="preserve">
          <source>The above Content Security Policy will allow inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements</source>
          <target state="translated">Вышеупомянутая политика безопасности содержимого разрешает встроенные элементы &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38b5b1c5b09838d3f34e6ad848719f979f8adbe4" translate="yes" xml:space="preserve">
          <source>The above Content Security Policy will allow inline styles like the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element, and the &lt;code&gt;style&lt;/code&gt; attribute on any element:</source>
          <target state="translated">Вышеупомянутая политика безопасности содержимого разрешает встроенные стили, такие как элемент &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; , и атрибут &lt;code&gt;style&lt;/code&gt; для любого элемента:</target>
        </trans-unit>
        <trans-unit id="fccee75b555f59c4fe0c1b6040c213d2c31d26f2" translate="yes" xml:space="preserve">
          <source>The above checks to see if the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header sent by the browser (obtained through $_SERVER['HTTP_ORIGIN']) matches '&lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;'. If yes, it returns &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt;. This example can be &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;seen running here&lt;/a&gt;.</source>
          <target state="translated">Вышеупомянутое проверяет, соответствует ли заголовок &lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; ,&lt;/a&gt; отправленный браузером (полученный через $ _SERVER ['HTTP_ORIGIN']), ' &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt; '. Если да, он возвращает &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt; . Этот пример можно &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;увидеть здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bde7701a5c7f870f1548d1541023a9c35cec39e4" translate="yes" xml:space="preserve">
          <source>The above example will use the proxy for everything except local hosts in the mozilla.org domain, with the further exception that hosts www.mozilla.org and merchant.mozilla.org will go through the proxy.</source>
          <target state="translated">В приведенном выше примере прокси будет использоваться для всего,кроме локальных хостов в домене mozilla.org,за исключением того,что хосты www.mozilla.org и merchant.mozilla.org будут проходить через прокси.</target>
        </trans-unit>
        <trans-unit id="517f24a05885574e21ddf60556499b7755bb7037" translate="yes" xml:space="preserve">
          <source>The above requires consulting the DNS every time; it can be grouped intelligently with other rules so that DNS is consulted only if other rules do not yield a result:</source>
          <target state="translated">Вышеизложенное требует консультации с DNS каждый раз;она может быть разумно сгруппирована с другими правилами,так что с DNS можно консультироваться только в том случае,если другие правила не дают результата:</target>
        </trans-unit>
        <trans-unit id="5a1d7213c66cb3708576c9dee4e5fbc7b85eeee8" translate="yes" xml:space="preserve">
          <source>The added security is only provided if the user accessing the document is using a browser supporting &lt;code&gt;X-Frame-Options&lt;/code&gt;.</source>
          <target state="translated">Дополнительная безопасность предоставляется только в том случае, если пользователь, обращающийся к документу, использует браузер, поддерживающий &lt;code&gt;X-Frame-Options&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc4cf5be0bdff2d41464e3aec79f3206f5e9a290" translate="yes" xml:space="preserve">
          <source>The address of the previous web page from which a link to the currently requested page was followed.</source>
          <target state="translated">Адрес предыдущей веб-страницы,с которой следовала ссылка на запрашиваемую в настоящее время страницу.</target>
        </trans-unit>
        <trans-unit id="3a13999e890799ba528c66f4b10225cdce017aa2" translate="yes" xml:space="preserve">
          <source>The allowlist is a list of origins that takes one of the following values:</source>
          <target state="translated">Разрешительный список-это список происхождения,который принимает одно из следующих значений:</target>
        </trans-unit>
        <trans-unit id="393e3579b1c31fc17a2e5e0bd2a662711c3a5e42" translate="yes" xml:space="preserve">
          <source>The alternative and de-facto standard versions of this header are the &lt;a href=&quot;x-forwarded-for&quot;&gt;&lt;code&gt;X-Forwarded-For&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;x-forwarded-host&quot;&gt;&lt;code&gt;X-Forwarded-Host&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;x-forwarded-proto&quot;&gt;&lt;code&gt;X-Forwarded-Proto&lt;/code&gt;&lt;/a&gt; headers.</source>
          <target state="translated">Альтернативными и фактически стандартными версиями этого заголовка являются заголовки &lt;a href=&quot;x-forwarded-for&quot;&gt; &lt;code&gt;X-Forwarded-For&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;x-forwarded-host&quot;&gt; &lt;code&gt;X-Forwarded-Host&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;x-forwarded-proto&quot;&gt; &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55a9a290f76d786d7b3d83d441f76e13bf0f3dcc" translate="yes" xml:space="preserve">
          <source>The app:categories element can contain a &quot;fixed&quot; attribute, with a
   value of either &quot;yes&quot; or &quot;no&quot;, indicating whether the list of
   categories is a fixed or an open set.  The absence of the &quot;fixed&quot;
   attribute is equivalent to the presence of a &quot;fixed&quot; attribute with a
   value of &quot;no&quot;.

   Alternatively, the app:categories element MAY contain an &quot;href&quot;
   attribute, whose value MUST be an IRI reference identifying a
   Category Document.  If the &quot;href&quot; attribute is provided, the app:
   categories element MUST be empty and MUST NOT have the &quot;fixed&quot; or
   &quot;scheme&quot; attributes.</source>
          <target state="translated">Элемент app:categories может содержать &quot;фиксированный&quot; атрибут,со значением &quot;да&quot; или &quot;нет&quot;,указывающим,является ли список категорий фиксированным или открытым набором.Отсутствие атрибута &quot;фиксированный&quot; эквивалентно наличию атрибута &quot;фиксированный&quot; со значением &quot;нет&quot;.В качестве альтернативы,элемент app:categories MAY содержит атрибут &quot;href&quot;,значение которого ДОЛЖНО быть ссылкой IRI,идентифицирующей документ категории.Если предусмотрен атрибут &quot;href&quot;,то элемент app:categories ДОЛЖЕН быть пустым и НЕ ДОЛЖЕН иметь атрибуты &quot;fixed&quot; или &quot;scheme&quot;.</target>
        </trans-unit>
        <trans-unit id="41b7617765ea8bb8c7b2ba0dc382b82fa950ce4a" translate="yes" xml:space="preserve">
          <source>The app:collection element MAY appear as a child of an atom:feed or
   atom:source element in an Atom Feed Document.  Its content identifies
   a Collection by which new Entries can be added to appear in the feed.
   When it appears in an atom:feed or atom:source element, the app:
   collection element is considered foreign markup as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;6 of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">Элемент app: collection МОЖЕТ отображаться как дочерний элемент элемента atom: feed или atom: source в документе Atom Feed. Его содержимое определяет коллекцию, с помощью которой можно добавлять новые записи для отображения в ленте. Когда он появляется в элементе atom: feed или atom: source, элемент app: collection считается внешней разметкой, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;разделе &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;6 [RFC4287]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="784a9192f7175993193ec2889d2de31d1902f984" translate="yes" xml:space="preserve">
          <source>The app:collection element MUST contain an &quot;href&quot; attribute, whose
   value gives the IRI of the Collection.</source>
          <target state="translated">Элемент app:collection ДОЛЖЕН содержать атрибут &quot;href&quot;,значение которого дает IRI Коллекции.</target>
        </trans-unit>
        <trans-unit id="7a08eb3336f8f673ed58387417f07a2fa35ffa86" translate="yes" xml:space="preserve">
          <source>The app:workspace element MUST contain one &quot;atom:title&quot; element (as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;]), giving a human-readable title for the
   Workspace.</source>
          <target state="translated">Элемент app: workspace ДОЛЖЕН содержать один элемент &amp;laquo;atom: title&amp;raquo; (как определено в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]), дающий удобочитаемый заголовок для Workspace.</target>
        </trans-unit>
        <trans-unit id="31dd4c2d31d8ecfa729e47a41ac595124e30799a" translate="yes" xml:space="preserve">
          <source>The application/http type can be used to enclose a pipeline of one or
   more HTTP request or response messages (not intermixed).

   Type name:  application

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype

      version:  The HTTP-version number of the enclosed messages (e.g.,
         &quot;1.1&quot;).  If not present, the version can be determined from the
         first line of the body. 

      msgtype:  The message type -- &quot;request&quot; or &quot;response&quot;.  If not
         present, the type can be determined from the first line of the
         body.

   Encoding considerations:  HTTP messages enclosed by this type are in
      &quot;binary&quot; format; use of an appropriate Content-Transfer-Encoding
      is required when transmitted via email.

   Security considerations:  see &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#section-8.3.2&quot;&gt;Section 8.3.2&lt;/a&gt;).

   Applications that use this media type:  N/A

   Fragment identifier considerations:  N/A

   Additional information:

      Deprecated alias names for this type:  N/A

      Magic number(s):  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:
      See Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">Тип application / http может использоваться для включения конвейера из одного или нескольких HTTP-запросов или сообщений ответа (не смешанных). Имя типа: application Имя подтипа: http Обязательные параметры: Н / Д Необязательные параметры: версия, msgtype версия: номер HTTP-версии вложенных сообщений (например, &amp;laquo;1.1&amp;raquo;). Если нет, версию можно определить по первой строке тела. msgtype: Тип сообщения - &amp;laquo;запрос&amp;raquo; или &amp;laquo;ответ&amp;raquo;. Если нет, тип можно определить по первой строке тела. Замечания по кодированию: сообщения HTTP, заключенные в этот тип, имеют &amp;laquo;двоичный&amp;raquo; формат; при передаче по электронной почте требуется использование соответствующего Content-Transfer-Encoding. Соображения безопасности:см. &lt;a href=&quot;#section-9&quot;&gt;раздел 9&lt;/a&gt; Соображения по совместимости: Нет Опубликованная спецификация: Эта спецификация (см. &lt;a href=&quot;#section-8.3.2&quot;&gt;Раздел 8.3.2&lt;/a&gt; ). Приложения, использующие этот тип носителя: Н / Д. Рекомендации по идентификатору фрагмента: Н / Д Дополнительная информация: Устаревшие псевдонимы для этого типа: Н / Д Магические числа: Н / Д Расширение (я) файла: Н / Д Файл Macintosh Введите код (ы): N / A Человек и адрес электронной почты, с которыми можно связаться для получения дополнительной информации: См. раздел Адреса авторов. Предполагаемое использование: ОБЩИЕ Ограничения использования: Н / Д Автор: См. Раздел Адреса авторов. Сменить контроллер: IESG</target>
        </trans-unit>
        <trans-unit id="79aee5e9b1bd229aa07d406e676deb28b27cc227" translate="yes" xml:space="preserve">
          <source>The article &lt;a href=&quot;cors&quot;&gt;covering the HTTP headers used by both clients and servers is here&lt;/a&gt;, and should be considered prerequisite reading.</source>
          <target state="translated">Статья, &lt;a href=&quot;cors&quot;&gt;посвященная заголовкам HTTP, используемым как клиентами, так и серверами, находится здесь&lt;/a&gt; , и ее следует считать обязательным к прочтению.</target>
        </trans-unit>
        <trans-unit id="06b805071003db0b0483630bf1631444f9c65f63" translate="yes" xml:space="preserve">
          <source>The asterisk is a special value representing any resource.</source>
          <target state="translated">Звездочка-это специальное значение,представляющее любой ресурс.</target>
        </trans-unit>
        <trans-unit id="74a66c2c405c525c313119a786fdc5a7536e3be4" translate="yes" xml:space="preserve">
          <source>The asterisk is a special value representing any resource. They are only useful when uploading a resource, usually with &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, to check if another resource with the identity has already been uploaded before.</source>
          <target state="translated">Звездочка - это специальное значение, представляющее любой ресурс. Они полезны только при загрузке ресурса, обычно с &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; , чтобы проверить, был ли ранее загружен другой ресурс с идентификатором.</target>
        </trans-unit>
        <trans-unit id="dc0975dcc835c772deb36f7878cb50959eba5345" translate="yes" xml:space="preserve">
          <source>The asterisk-form of request-target is only used for a server-wide
   OPTIONS request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.7&quot;&gt;Section&amp;nbsp;4.3.7 of [RFC7231]&lt;/a&gt;).

     asterisk-form  = &quot;*&quot;

   When a client wishes to request OPTIONS for the server as a whole, as
   opposed to a specific named resource of that server, the client MUST
   send only &quot;*&quot; (%x2A) as the request-target.  For example,

     OPTIONS * HTTP/1.1

   If a proxy receives an OPTIONS request with an absolute-form of
   request-target in which the URI has an empty path and no query
   component, then the last proxy on the request chain MUST send a
   request-target of &quot;*&quot; when it forwards the request to the indicated
   origin server.

   For example, the request

     OPTIONS &lt;a href=&quot;http://www.example.org:8001&quot;&gt;http://www.example.org:8001&lt;/a&gt; HTTP/1.1

   would be forwarded by the final proxy as

     OPTIONS * HTTP/1.1
     Host: www.example.org:8001

   after connecting to port 8001 of host &quot;www.example.org&quot;.</source>
          <target state="translated">Форма звездочки для целевого запроса используется только для &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.7&quot;&gt;общесерверного&lt;/a&gt; запроса OPTIONS ( раздел 4.3.7 [RFC7231] ). asterisk-form = &quot;*&quot; Когда клиент желает запросить ОПЦИИ для сервера в целом, в отличие от конкретного именованного ресурса этого сервера, клиент ДОЛЖЕН отправить только &quot;*&quot; (% x2A) в качестве цели запроса. Например, OPTIONS * HTTP / 1.1. Если прокси-сервер получает запрос OPTIONS с абсолютной формой цели запроса, в которой URI имеет пустой путь и не содержит компонентов запроса, то последний прокси в цепочке запросов ДОЛЖЕН отправить запрос: target со знаком &amp;laquo;*&amp;raquo;, когда он пересылает запрос на указанный исходный сервер. Например, запрос OPTIONS &lt;a href=&quot;http://www.example.org:8001&quot;&gt;http://www.example.org:8001&lt;/a&gt; HTTP / 1.1 будет перенаправлен последним прокси как OPTIONS * HTTP / 1.1 Host: www.example.org:8001 после подключения к порту 8001 хоста &amp;laquo;www.example.org&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7c769400bb18a5cd534dd7b8c9bf26657988f6ef" translate="yes" xml:space="preserve">
          <source>The authority component of a URL, consisting of the domain name and optionally the port (prefixed by a &lt;code&gt;':'&lt;/code&gt;), is called the &lt;em&gt;authority form&lt;/em&gt;. It is only used with &lt;code&gt;CONNECT&lt;/code&gt; when setting up an HTTP tunnel.</source>
          <target state="translated">Компонент полномочий URL, состоящий из имени домена и, возможно, порта (с префиксом &lt;code&gt;':'&lt;/code&gt; ), называется &lt;em&gt;формой полномочий&lt;/em&gt; . Он используется только с &lt;code&gt;CONNECT&lt;/code&gt; при настройке HTTP-туннеля.</target>
        </trans-unit>
        <trans-unit id="7687b27068a2ba93c3867498f2559aee586b78c2" translate="yes" xml:space="preserve">
          <source>The authority-form of request-target is only used for CONNECT
   requests (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of [RFC7231]&lt;/a&gt;).

     authority-form = authority

   When making a CONNECT request to establish a tunnel through one or
   more proxies, a client MUST send only the target URI's authority
   component (excluding any userinfo and its &quot;@&quot; delimiter) as the
   request-target.  For example,

     CONNECT www.example.com:80 HTTP/1.1</source>
          <target state="translated">Форма полномочий объекта-запроса используется только для запросов CONNECT ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;раздел 4.3.6 [RFC7231]&lt;/a&gt; ). авторитет-форма = авторитет При выполнении запроса CONNECT для установления туннеля через один или несколько прокси-серверов клиент ДОЛЖЕН отправить только компонент полномочий целевого URI (за исключением информации о пользователе и его разделителя &amp;laquo;@&amp;raquo;) в качестве цели запроса. Например, CONNECT www.example.com:80 HTTP / 1.1.</target>
        </trans-unit>
        <trans-unit id="eb218e220bee49a462071f93357caea4eef78a66" translate="yes" xml:space="preserve">
          <source>The auto-config file should be saved to a file with a .pac filename extension:</source>
          <target state="translated">Файл автоматической настройки должен быть сохранен в файл с расширением .pac:</target>
        </trans-unit>
        <trans-unit id="b1a30935583f6c8ca798d1fb82e164294a1797dd" translate="yes" xml:space="preserve">
          <source>The auto-config file should be saved to a file with a &lt;code&gt;.pac&lt;/code&gt; filename extension:</source>
          <target state="translated">Файл автоконфигурации следует сохранить в файл с &lt;code&gt;.pac&lt;/code&gt; файла .pac :</target>
        </trans-unit>
        <trans-unit id="885be6e78dcfaa04b9ed4e903a1be4fd5a6bb5be" translate="yes" xml:space="preserve">
          <source>The autoconfig file can be output by a CGI script. This is useful, for example, when making the autoconfig file act differently based on the client IP address (the REMOTE_ADDR environment variable in CGI).</source>
          <target state="translated">Файл автоконфигурации может быть выдан с помощью CGI-скрипта.Это полезно,например,когда файл автоконфигурации действует по-другому в зависимости от IP-адреса клиента (переменная окружения REMOTE_ADDR в CGI).</target>
        </trans-unit>
        <trans-unit id="654dd208a7e3408c3ffc11bf5374d37d8901160c" translate="yes" xml:space="preserve">
          <source>The basic cache mechanisms in HTTP/1.1 (server-specified expiration
   times and validators) are implicit directives to caches. In some
   cases, a server or client might need to provide explicit directives
   to the HTTP caches. We use the Cache-Control header for this purpose.

   The Cache-Control header allows a client or server to transmit a
   variety of directives in either requests or responses. These
   directives typically override the default caching algorithms. As a
   general rule, if there is any apparent conflict between header
   values, the most restrictive interpretation is applied (that is, the
   one that is most likely to preserve semantic transparency). However, 

   in some cases, cache-control directives are explicitly specified as
   weakening the approximation of semantic transparency (for example,
   &quot;max-stale&quot; or &quot;public&quot;).

   The cache-control directives are described in detail in &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;.</source>
          <target state="translated">Основные механизмы кеширования в HTTP / 1.1 (время истечения срока действия и валидаторы, определяемые сервером) - это неявные директивы для кешей. В некоторых случаях серверу или клиенту может потребоваться предоставить явные директивы кешам HTTP. Для этого мы используем заголовок Cache-Control. Заголовок Cache-Control позволяет клиенту или серверу передавать различные директивы в запросах или ответах. Эти директивы обычно переопределяют алгоритмы кэширования по умолчанию. Как правило, если есть какой-либо очевидный конфликт между значениями заголовка, применяется наиболее ограничительная интерпретация (то есть та, которая с наибольшей вероятностью сохранит семантическую прозрачность). Однако в некоторых случаях директивы управления кешем явно указываются как ослабляющие приближение семантической прозрачности (например, &amp;laquo;max-stale&amp;raquo;или &amp;laquo;публичный&amp;raquo;). Директивы управления кешем подробно описаны в&lt;a href=&quot;#section-14.9&quot;&gt;раздел 14.9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="205356eaedd8e0ecc02522f44b70d14ec801fc5f" translate="yes" xml:space="preserve">
          <source>The basic features of the client-server protocol: what it can do and its intended uses.</source>
          <target state="translated">Основные особенности протокола клиент-сервер:что он может делать и для чего предназначен.</target>
        </trans-unit>
        <trans-unit id="e7083aadda2c31d227df92dd2fa84ac3833dcfbc" translate="yes" xml:space="preserve">
          <source>The browser is &lt;strong&gt;always&lt;/strong&gt; the entity initiating the request. It is never the server (though some mechanisms have been added over the years to simulate server-initiated messages).</source>
          <target state="translated">Браузер &lt;strong&gt;всегда&lt;/strong&gt; является инициатором запроса. Это никогда не бывает сервером (хотя с годами были добавлены некоторые механизмы для имитации инициируемых сервером сообщений).</target>
        </trans-unit>
        <trans-unit id="2cbd8e5718ca567c96ddc915f16935aae94c67e0" translate="yes" xml:space="preserve">
          <source>The browser version is often, but not always, put in the value part of the &lt;em&gt;BrowserName/VersionNumber&lt;/em&gt; token in the User Agent String. This is of course not the case for Internet Explorer (which puts the version number right after the MSIE token), and for Opera after version 10, which has added a Version/&lt;em&gt;VersionNumber&lt;/em&gt; token.</source>
          <target state="translated">Версия браузера часто, но не всегда, помещается в часть &lt;em&gt;значения&lt;/em&gt; токена &lt;em&gt;BrowserName / VersionNumber&lt;/em&gt; в &lt;em&gt;строке&lt;/em&gt; пользовательского агента. Это, конечно, не относится к Internet Explorer (который помещает номер версии сразу после токена MSIE) и к Opera после версии 10, в которой добавлен токен Version / &lt;em&gt;VersionNumber&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5bdbde6838426248696c94b45cfec9d0fc5ec1db" translate="yes" xml:space="preserve">
          <source>The browser will automatically retry a previously unresponsive proxy after 30 minutes. Additional attempts will continue beginning at one hour, always adding 30 minutes to the elapsed time between attempts.</source>
          <target state="translated">По истечении 30 минут браузер автоматически повторит попытку использования ранее не отвечавшего прокси-сервера.Дополнительные попытки будут продолжаться,начиная с одного часа,всегда добавляя 30 минут к истекшему времени между попытками.</target>
        </trans-unit>
        <trans-unit id="887b852d02845ba1a99a4a0744f4797dc2bf5823" translate="yes" xml:space="preserve">
          <source>The cache is disconnected from the rest of the network.</source>
          <target state="translated">Кэш отключен от остальной сети.</target>
        </trans-unit>
        <trans-unit id="2f21d9d6b26c4e6bea5e52cb792172b8c9de3d95" translate="yes" xml:space="preserve">
          <source>The cache must verify the status of the stale resources before using it and expired ones should not be used.</source>
          <target state="translated">Кэш должен проверять состояние неработающих ресурсов перед их использованием,а просроченные ресурсы не должны использоваться.</target>
        </trans-unit>
        <trans-unit id="daeefaacace04c4b349d31a7092c605e7392d449" translate="yes" xml:space="preserve">
          <source>The cache should not store anything about the client request or server response.</source>
          <target state="translated">В кэше не должно храниться ничего о запросе клиента или ответе сервера.</target>
        </trans-unit>
        <trans-unit id="6c578830e2a2b4f9372dff694a83a347a725c406" translate="yes" xml:space="preserve">
          <source>The cache should not store anything about the client request or server response. A request is sent to the server and a full response is downloaded each and every time.</source>
          <target state="translated">В кэше не должно храниться ничего о запросе клиента или ответе сервера.Запрос посылается на сервер и каждый раз загружается полный ответ.</target>
        </trans-unit>
        <trans-unit id="0f42630e59bac670b1a39303ea428afbe6e77a0e" translate="yes" xml:space="preserve">
          <source>The character encoding standard.</source>
          <target state="translated">Стандарт кодирования символов.</target>
        </trans-unit>
        <trans-unit id="fd7f690c409848b22dbd45c29cbfb870b4b15ecf" translate="yes" xml:space="preserve">
          <source>The chunked encoding allows each chunk to include zero or more chunk
   extensions, immediately following the chunk-size, for the sake of
   supplying per-chunk metadata (such as a signature or hash),
   mid-message control information, or randomization of message body
   size.

     chunk-ext      = *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )

     chunk-ext-name = token
     chunk-ext-val  = token / quoted-string

   The chunked encoding is specific to each connection and is likely to
   be removed or recoded by each recipient (including intermediaries)
   before any higher-level application would have a chance to inspect
   the extensions.  Hence, use of chunk extensions is generally limited 

   to specialized HTTP services such as &quot;long polling&quot; (where client and
   server can have shared expectations regarding the use of chunk
   extensions) or for padding within an end-to-end secured connection.

   A recipient MUST ignore unrecognized chunk extensions.  A server
   ought to limit the total length of chunk extensions received in a
   request to an amount reasonable for the services provided, in the
   same way that it applies length limitations and timeouts for other
   parts of a message, and generate an appropriate 4xx (Client Error)
   response if that amount is exceeded.</source>
          <target state="translated">Кодовая кодировка позволяет каждому блоку включать нулевые или более расширений,сразу после размера блока,для поставки метаданных на каждый блок (таких как подпись или хэш),контрольной информации в середине сообщения,или рандомизации размера тела сообщения.chunk-ext=*(&quot;;&quot; chunk-ext-name[&quot;=&quot; chunk-ext-val])chunk-ext-name=token chunk-ext-val=token /цитируемая строка Кодировка chunk-ext-val=token /цитируемая строка Кодировка chunked специфична для каждого соединения и,вероятно,будет удалена или перекодирована каждым получателем (включая посредников),прежде чем у любого приложения более высокого уровня появится возможность проверить расширения.Следовательно,использование chunk-расширений обычно ограничивается специализированными сервисами HTTP,такими как &quot;длинный опрос&quot; (когда клиент и сервер могут иметь общие ожидания относительно использования chunk-расширений)или для заполнения внутри сквозного защищенного соединения.Получатель ДОЛЖЕН игнорировать нераспознанные chunk-расширения.Сервер должен ограничивать общую длину чанковых расширений,полученных в запросе,до разумной для предоставляемых услуг суммы,точно так же,как он применяет ограничения по длине и таймауты для других частей сообщения,и генерировать соответствующий 4xx (Client Error)ответ,если эта сумма превышена.</target>
        </trans-unit>
        <trans-unit id="48e4a91f8067d7ebfdee16e201dcdb0c016dab57" translate="yes" xml:space="preserve">
          <source>The chunked encoding modifies the body of a message in order to
   transfer it as a series of chunks, each with its own size indicator,
   followed by an OPTIONAL trailer containing entity-header fields. This
   allows dynamically produced content to be transferred along with the
   information necessary for the recipient to verify that it has
   received the full message.

       Chunked-Body   = *chunk
                        last-chunk
                        trailer
                        CRLF

       chunk          = chunk-size [ chunk-extension ] CRLF
                        chunk-data CRLF
       chunk-size     = 1*HEX
       last-chunk     = 1*(&quot;0&quot;) [ chunk-extension ] CRLF

       chunk-extension= *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )
       chunk-ext-name = token
       chunk-ext-val  = token | quoted-string
       chunk-data     = chunk-size(OCTET)
       trailer        = *(entity-header CRLF)

   The chunk-size field is a string of hex digits indicating the size of
   the chunk. The chunked encoding is ended by any chunk whose size is
   zero, followed by the trailer, which is terminated by an empty line.

   The trailer allows the sender to include additional HTTP header
   fields at the end of the message. The Trailer header field can be
   used to indicate which header fields are included in a trailer (see
   &lt;a href=&quot;#section-14.40&quot;&gt;section 14.40&lt;/a&gt;). 

   A server using chunked transfer-coding in a response MUST NOT use the
   trailer for any header fields unless at least one of the following is
   true:

   a)the request included a TE header field that indicates &quot;trailers&quot; is
     acceptable in the transfer-coding of the  response, as described in
     &lt;a href=&quot;#section-14.39&quot;&gt;section 14.39&lt;/a&gt;; or,

   b)the server is the origin server for the response, the trailer
     fields consist entirely of optional metadata, and the recipient
     could use the message (in a manner acceptable to the origin server)
     without receiving this metadata.  In other words, the origin server
     is willing to accept the possibility that the trailer fields might
     be silently discarded along the path to the client.

   This requirement prevents an interoperability failure when the
   message is being received by an HTTP/1.1 (or later) proxy and
   forwarded to an HTTP/1.0 recipient. It avoids a situation where
   compliance with the protocol would have necessitated a possibly
   infinite buffer on the proxy.

   An example process for decoding a Chunked-Body is presented in
   appendix 19.4.6.

   All HTTP/1.1 applications MUST be able to receive and decode the
   &quot;chunked&quot; transfer-coding, and MUST ignore chunk-extension extensions
   they do not understand.</source>
          <target state="translated">Кодирование по частям модифицирует тело сообщения, чтобы передать его в виде серии фрагментов, каждый со своим индикатором размера, за которым следует ДОПОЛНИТЕЛЬНЫЙ трейлер, содержащий поля заголовка объекта. Это позволяет передавать динамически создаваемый контент вместе с информацией, необходимой получателю для проверки того, что он получил полное сообщение. Chunked-Body = * конец последнего фрагмента фрагмента CRLF фрагмент = размер фрагмента [расширение фрагмента] CRLF данные фрагмента CRLF размер фрагмента = 1 * последний фрагмент HEX = 1 * (&quot;0&quot;) [расширение фрагмента] CRLF chunk-extension = * (&quot;;&quot; chunk-ext-name [&quot;=&quot;chunk-ext-val]) chunk-ext-name = токен chunk-ext-val = токен | строка в кавычках chunk-data = размер фрагмента (OCTET) трейлер = * (заголовок объекта CRLF) Поле размера фрагмента представляет собой строку шестнадцатеричных цифр, указывающую размер фрагмента. Кодирование по фрагментам заканчивается любым фрагментом, размер которого равен нулю, за которым следует трейлер, который завершается пустой строкой. Трейлер позволяет отправителю включать дополнительные поля заголовка HTTP в конце сообщения. Поле заголовка трейлера можно использовать, чтобы указать, какие поля заголовка включены в трейлер (см.Кодирование по фрагментам заканчивается любым фрагментом, размер которого равен нулю, за которым следует трейлер, который завершается пустой строкой. Трейлер позволяет отправителю включать дополнительные поля заголовка HTTP в конце сообщения. Поле заголовка трейлера можно использовать, чтобы указать, какие поля заголовка включены в трейлер (см.Кодирование по фрагментам заканчивается любым фрагментом, размер которого равен нулю, за которым следует трейлер, который завершается пустой строкой. Трейлер позволяет отправителю включать дополнительные поля заголовка HTTP в конце сообщения. Поле заголовка трейлера можно использовать, чтобы указать, какие поля заголовка включены в трейлер (см. &lt;a href=&quot;#section-14.40&quot;&gt;раздел 14.40&lt;/a&gt; ). Сервер, использующий фрагментированное кодирование передачи в ответе, НЕ ДОЛЖЕН использовать трейлер для каких-либо полей заголовка, если не выполняется хотя бы одно из следующих условий: a) запрос включал поле заголовка TE, которое указывает, что &quot;трейлеры&quot; приемлемы в кодировании передачи ответа, как описано в &lt;a href=&quot;#section-14.39&quot;&gt;разделе 14.39&lt;/a&gt;; или b) сервер является исходным сервером для ответа, поля концевого звена полностью состоят из необязательных метаданных, и получатель может использовать сообщение (способом, приемлемым для исходного сервера) без получения этих метаданных. Другими словами, исходный сервер готов принять возможность того, что поля трейлера могут быть незаметно отброшены на пути к клиенту. Это требование предотвращает сбой взаимодействия, когда сообщение принимается прокси-сервером HTTP / 1.1 (или более поздней версии) и пересылается получателю HTTP / 1.0. Это позволяет избежать ситуации, когда соответствие протоколу потребовало бы, возможно, бесконечного буфера на прокси-сервере. Пример процесса декодирования Chunked-Body представлен в приложении 19.4.6. Все HTTP / 1.1 приложения ДОЛЖНЫ иметь возможность принимать и декодировать &quot;фрагментированное&quot; кодирование передачи и ДОЛЖНЫ игнорировать расширения фрагментов, которые они не понимают.</target>
        </trans-unit>
        <trans-unit id="a7d9ecd82450ec8dc1ad7713aebafcc7e0d70fa4" translate="yes" xml:space="preserve">
          <source>The chunked transfer coding wraps the payload body in order to
   transfer it as a series of chunks, each with its own size indicator,
   followed by an OPTIONAL trailer containing header fields.  Chunked
   enables content streams of unknown size to be transferred as a
   sequence of length-delimited buffers, which enables the sender to
   retain connection persistence and the recipient to know when it has
   received the entire message.

     chunked-body   = *chunk
                      last-chunk
                      trailer-part
                      CRLF

     chunk          = chunk-size [ chunk-ext ] CRLF
                      chunk-data CRLF
     chunk-size     = 1*HEXDIG
     last-chunk     = 1*(&quot;0&quot;) [ chunk-ext ] CRLF

     chunk-data     = 1*OCTET ; a sequence of chunk-size octets

   The chunk-size field is a string of hex digits indicating the size of
   the chunk-data in octets.  The chunked transfer coding is complete
   when a chunk with a chunk-size of zero is received, possibly followed
   by a trailer, and finally terminated by an empty line.

   A recipient MUST be able to parse and decode the chunked transfer
   coding.</source>
          <target state="translated">Кодировка переноса с кусочками обертывает кузов грузоподъемности,чтобы перевести его как серию кусочков,каждый из которых имеет свой индикатор размера,за которым следует ФАКУЛЬТАТИВНЫЙ прицеп с полями заголовка.Функция chunked позволяет передавать потоки содержимого неизвестного размера в виде последовательности буферов,разделенных по длине,что позволяет отправителю сохранять постоянство соединения,а получателю-знать,когда он получил сообщение целиком.chunked-body=*chunk last-chunk trailer-part CRLF chunk=размер чанка[chunk-ext]CRLF chunk-data CRLF chunk-size=1*HEXDIG last-chunk=1*(&quot;0&quot;)[chunk-ext]CRLF chunk-data=1*OCTET;последовательность октетов размера чанка Поле размера чанка представляет собой строку гекс-цифр,указывающую размер чанка-данных в октетах.Кодировка передачи в кусках завершена,когда получена кусок с размером куска нуля,возможно,за ним следует трейлер,и в конце концов пустая строка.Получатель ДОЛЖЕН уметь разобрать и декодировать кодировку передачи в кусках.</target>
        </trans-unit>
        <trans-unit id="415a4bc5f36b8b74ac665b81439b0f17201eff1f" translate="yes" xml:space="preserve">
          <source>The client IP address</source>
          <target state="translated">IP-адрес клиента</target>
        </trans-unit>
        <trans-unit id="f4f8621b5597ea11953d56253188393201c5390d" translate="yes" xml:space="preserve">
          <source>The client SHOULD continue with its request. This interim response is
   used to inform the client that the initial part of the request has
   been received and has not yet been rejected by the server. The client
   SHOULD continue by sending the remainder of the request or, if the
   request has already been completed, ignore this response. The server
   MUST send a final response after the request has been completed. See
   &lt;a href=&quot;#section-8.2.3&quot;&gt;section 8.2.3&lt;/a&gt; for detailed discussion of the use and handling of this
   status code.</source>
          <target state="translated">Клиент ДОЛЖЕН продолжить выполнение своего запроса. Этот промежуточный ответ используется для информирования клиента о том, что начальная часть запроса получена и еще не отклонена сервером. Клиенту СЛЕДУЕТ продолжить, отправив оставшуюся часть запроса, или, если запрос уже выполнен, игнорировать этот ответ. Сервер ДОЛЖЕН отправить окончательный ответ после того, как запрос был завершен. См. &lt;a href=&quot;#section-8.2.3&quot;&gt;Раздел 8.2.3&lt;/a&gt; для подробного обсуждения использования и обработки этого кода состояния.</target>
        </trans-unit>
        <trans-unit id="1cdfa1347854a07ac313ca6b4125f4dd9a9af51d" translate="yes" xml:space="preserve">
          <source>The client did not produce a request within the time that the server
   was prepared to wait. The client MAY repeat the request without
   modifications at any later time.</source>
          <target state="translated">Клиент не выдал запрос в то время,когда сервер был готов ждать.Клиент МОЖЕТ повторить запрос без изменений в любое последующее время.</target>
        </trans-unit>
        <trans-unit id="7266b1abf9d7b15153ddaf61096e777051f04c74" translate="yes" xml:space="preserve">
          <source>The client does not have access rights to the content, i.e. they are unauthorized, so server is rejecting to give proper response. Unlike 401, the client's identity is known to the server.</source>
          <target state="translated">Клиент не имеет прав доступа к контенту,т.е.он является неавторизованным,поэтому сервер отказывается дать правильный ответ.В отличие от 401,личность клиента известна серверу.</target>
        </trans-unit>
        <trans-unit id="e8a06a1a055ac600eef86c86487e70e03abac976" translate="yes" xml:space="preserve">
          <source>The client establishes a TCP connection (or the appropriate connection if the transport layer is not TCP).</source>
          <target state="translated">Клиент устанавливает TCP соединение (или соответствующее соединение,если транспортный уровень не является TCP).</target>
        </trans-unit>
        <trans-unit id="bc64fec6ee0e97b2601f305debb944c7297d99f9" translate="yes" xml:space="preserve">
          <source>The client has indicated preconditions in its headers which the server does not meet.</source>
          <target state="translated">Клиент указал в своих заголовках предварительные условия,которым сервер не соответствует.</target>
        </trans-unit>
        <trans-unit id="bfa31c734d07698a1162e761b391639dea1a2247" translate="yes" xml:space="preserve">
          <source>The client issues a request to the canonical domain: &lt;code&gt;http://example.org/whatddup&lt;/code&gt;</source>
          <target state="translated">Клиент отправляет запрос к каноническому домену: &lt;code&gt;http://example.org/whatddup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="517d78c7c821635a0b4548cee1bab26d988c7745" translate="yes" xml:space="preserve">
          <source>The client sends its request, and waits for the answer.</source>
          <target state="translated">Клиент отправляет свой запрос и ждет ответа.</target>
        </trans-unit>
        <trans-unit id="ee32a252064fce95d78b27deb30677a6f5f9861f" translate="yes" xml:space="preserve">
          <source>The client should not repeat this request without modification.</source>
          <target state="translated">Клиент не должен повторять этот запрос без изменений.</target>
        </trans-unit>
        <trans-unit id="6ecda58cff7b06f0ebd744bad8fc92cd64e7b568" translate="yes" xml:space="preserve">
          <source>The client that initiated the request and subsequent proxies in a chain of proxies.</source>
          <target state="translated">Клиент,инициировавший запрос,и последующие прокси в цепочке прокси.</target>
        </trans-unit>
        <trans-unit id="72cded756bfa543235b2ef68f253845e7563a14d" translate="yes" xml:space="preserve">
          <source>The codings defined below can be used to compress the payload of a
   message.</source>
          <target state="translated">Определенные ниже коды могут быть использованы для сжатия полезной нагрузки сообщения.</target>
        </trans-unit>
        <trans-unit id="9677ba4a41043c80dd7875428097d17f3b102726" translate="yes" xml:space="preserve">
          <source>The common use case is to return &lt;code&gt;204&lt;/code&gt; as a result of a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; request, updating a resource, without changing the current content of the page displayed to the user. If the resource is created, &lt;a href=&quot;201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; is returned instead. If the page should be changed to the newly updated page, the &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">Обычный вариант использования - вернуть &lt;code&gt;204&lt;/code&gt; в результате запроса &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; , обновляя ресурс, без изменения текущего содержимого страницы, отображаемой пользователю. Если ресурс создан, вместо него возвращается &lt;a href=&quot;201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Created&lt;/code&gt; . Если страница должна быть изменена на недавно обновленную страницу, вместо &lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; следует использовать 200 .</target>
        </trans-unit>
        <trans-unit id="e652d732604ca7329e0833f245786713768ed8e7" translate="yes" xml:space="preserve">
          <source>The common use case of this status code is as the result of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request.</source>
          <target state="translated">Типичный вариант использования этого кода состояния - результат запроса &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c04133abc831323a63813210792503c0061624d7" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;strong comparison algorithm&lt;/em&gt;, meaning two files are considered identical byte to byte only. This is weakened when the &lt;code&gt;W/&lt;/code&gt; prefix is used in front of the &lt;code&gt;ETag&lt;/code&gt;.</source>
          <target state="translated">При сравнении с сохраненным &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; используется &lt;em&gt;строгий алгоритм сравнения&lt;/em&gt; , то есть два файла считаются идентичными только байтами. Это ослабляется, когда префикс &lt;code&gt;W/&lt;/code&gt; используется перед &lt;code&gt;ETag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7a2fbb792f71c73497799f887f4d3819b0abaf6" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;weak comparison algorithm&lt;/em&gt;, meaning two files are considered identical not only if they are identical byte to byte, but if the content is equivalent. For example, two pages that would differ only by the date of generation in the footer would be considered as identical.</source>
          <target state="translated">При сравнении с сохраненным &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; используется &lt;em&gt;слабый алгоритм сравнения&lt;/em&gt; , то есть два файла считаются идентичными не только в том случае, если они идентичны байтам, но и если их содержимое эквивалентно. Например, две страницы, которые будут отличаться только датой создания в нижнем колонтитуле, будут считаться идентичными.</target>
        </trans-unit>
        <trans-unit id="a0905c4e80c334babf93aeba4446459e7079b76c" translate="yes" xml:space="preserve">
          <source>The compatibility table in this page is generated from structured data. If you'd like to contribute to the data, please check out &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt; and send us a pull request.</source>
          <target state="translated">Таблица совместимости на этой странице создана на основе структурированных данных. Если вы хотите внести свой вклад в данные, посетите &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt; и отправьте нам запрос на перенос.</target>
        </trans-unit>
        <trans-unit id="a05c38dc87a4c3ad5288313d314048589646b4f9" translate="yes" xml:space="preserve">
          <source>The concrete steps necessary to deliver the HPKP header depend on the web server you use.</source>
          <target state="translated">Конкретные шаги,необходимые для доставки заголовка HPKP,зависят от используемого вами веб-сервера.</target>
        </trans-unit>
        <trans-unit id="f5aee79466e47707e7aaaf37d00efa279a7d1756" translate="yes" xml:space="preserve">
          <source>The content and concepts within are a product of the Atom community
   and the Atompub Working Group.</source>
          <target state="translated">Содержание и концепции,входящие в него,являются продуктом сообщества Atom и Рабочей группы Atompub.</target>
        </trans-unit>
        <trans-unit id="5e832a9cde14ca1e931972542042bbb8f1f01671" translate="yes" xml:space="preserve">
          <source>The content of an &quot;app:accept&quot; element value is a media range as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  The media range specifies a type of
   representation that can be POSTed to a Collection.

   The app:accept element is similar to the HTTP Accept request-header
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  Media type parameters are allowed within app:accept, but
   app:accept has no notion of preference -- &quot;accept-params&quot; or &quot;q&quot;
   arguments, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.1&quot;&gt;Section&amp;nbsp;14.1 of [RFC2616]&lt;/a&gt; are not
   significant.

   White space (as defined in [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;]) around the app:accept element's
   media range is insignificant and MUST be ignored.

   A value of &quot;application/atom+xml;type=entry&quot; MAY appear in any app:
   accept list of media ranges and indicates that Atom Entry Documents
   can be POSTed to the Collection.  If no app:accept element is
   present, clients SHOULD treat this as equivalent to an app:accept
   element with the content &quot;application/atom+xml;type=entry&quot;.

   If one app:accept element exists and is empty, clients SHOULD assume
   that the Collection does not support the creation of new Entries.

   appAccept =
      element app:accept {
            appCommonAttributes,
            ( text? )
      }</source>
          <target state="translated">Содержимое значения элемента &amp;laquo;app: accept&amp;raquo; представляет собой диапазон мультимедиа, как определено в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]. Диапазон мультимедиа определяет тип представления, которое может быть отправлено в коллекцию POST. Элемент app: accept аналогичен заголовку запроса HTTP Accept [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]. Параметры типа мультимедиа разрешены в app: accept, но app: accept не имеет понятия предпочтения - аргументы accept-params или q, как указано в &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.1&quot;&gt;разделе 14.1 [RFC2616]&lt;/a&gt; , не имеют значения. Пробел (как определено в [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;]) вокруг приложения: диапазон мультимедиа элемента accept не имеет значения и ДОЛЖЕН игнорироваться. Значение &amp;laquo;application / atom + xml; type = entry&amp;raquo; МОЖЕТ появиться в любом списке диапазонов мультимедиа app: accept и указывает, что документы Atom Entry могут быть отправлены в коллекцию. Если элемент app: accept отсутствует, клиентам СЛЕДУЕТ рассматривать его как эквивалент элемента app: accept с содержимым &amp;laquo;application / atom + xml; type = entry&amp;raquo;. Если один элемент app: accept существует и пуст, клиентам СЛЕДУЕТ предполагать, что Коллекция не поддерживает создание новых записей. appAccept = element app: accept {appCommonAttributes, (text?)}</target>
        </trans-unit>
        <trans-unit id="539a35b3718ee8a5aee196d79e2ab252e1794cb2" translate="yes" xml:space="preserve">
          <source>The content security policy</source>
          <target state="translated">Политика безопасности контента</target>
        </trans-unit>
        <trans-unit id="a99f7db56a8fc0d621fb9f438536232235171cde" translate="yes" xml:space="preserve">
          <source>The cookie created above is a &lt;em&gt;session cookie&lt;/em&gt;: it is deleted when the client shuts down, because it didn't specify an &lt;code&gt;Expires&lt;/code&gt; or &lt;code&gt;Max-Age&lt;/code&gt; directive. However, web browsers may use &lt;strong&gt;session restoring&lt;/strong&gt;, which makes most session cookies permanent, as if the browser was never closed.</source>
          <target state="translated">Созданный выше файл cookie является &lt;em&gt;файлом cookie сеанса&lt;/em&gt; : он удаляется при завершении работы клиента, поскольку в нем не &lt;code&gt;Expires&lt;/code&gt; директива Expires или &lt;code&gt;Max-Age&lt;/code&gt; . Однако веб-браузеры могут использовать &lt;strong&gt;восстановление сеанса&lt;/strong&gt; , что делает большинство файлов cookie сеанса постоянными, как если бы браузер никогда не закрывался.</target>
        </trans-unit>
        <trans-unit id="d3ea80f5dbbb07b298e7e569c7ef43ac598c80e1" translate="yes" xml:space="preserve">
          <source>The creator of a lock has special privileges to use the lock to
   modify the resource.  When a locked resource is modified, a server
   MUST check that the authenticated principal matches the lock creator
   (in addition to checking for valid lock token submission).

   The server MAY allow privileged users other than the lock creator to
   destroy a lock (for example, the resource owner or an administrator).
   The 'unlock' privilege in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;] was defined to provide that
   permission.

   There is no requirement for servers to accept LOCK requests from all
   users or from anonymous users.

   Note that having a lock does not confer full privilege to modify the
   locked resource.  Write access and other privileges MUST be enforced
   through normal privilege or authentication mechanisms, not based on
   the possible obscurity of lock token values.</source>
          <target state="translated">Создатель блокировки имеет особые привилегии использовать блокировку для изменения ресурса. Когда заблокированный ресурс изменяется, сервер ДОЛЖЕН проверить, соответствует ли аутентифицированный принципал создателю блокировки (в дополнение к проверке правильности отправки токена блокировки). Сервер МОЖЕТ разрешить привилегированным пользователям, кроме создателя блокировки, снять блокировку (например, владельцу ресурса или администратору). Право &amp;laquo;разблокировать&amp;raquo; в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;] был определен для предоставления такого разрешения. Серверы не обязаны принимать запросы LOCK от всех пользователей или от анонимных пользователей. Обратите внимание, что наличие блокировки не дает полных привилегий на изменение заблокированного ресурса. Доступ для записи и другие привилегии ДОЛЖНЫ быть реализованы с помощью обычных механизмов привилегий или аутентификации, а не на основе возможной скрытности значений токенов блокировки.</target>
        </trans-unit>
        <trans-unit id="ed6930808b04a49db2a6e882d398fb403c175d9d" translate="yes" xml:space="preserve">
          <source>The credentials are constructed like this:</source>
          <target state="translated">Удостоверения построены вот так:</target>
        </trans-unit>
        <trans-unit id="7b8947dfbd554435efd90ececbfae32fbeaafdf7" translate="yes" xml:space="preserve">
          <source>The current set of policy-controlled features fall into two broad categories:</source>
          <target state="translated">Нынешний набор функций,контролируемых политикой,подразделяется на две широкие категории:</target>
        </trans-unit>
        <trans-unit id="a8e69d68f3b1fc3a7df5c137fb99fc1e2d0cfdfa" translate="yes" xml:space="preserve">
          <source>The data URL will use the encoded data after the initial header line.</source>
          <target state="translated">URL-адрес данных будет использовать закодированные данные после строки начального заголовка.</target>
        </trans-unit>
        <trans-unit id="230d58d4d34777b830d4af9d56c4ae6916e8d111" translate="yes" xml:space="preserve">
          <source>The data portion of a data URL is opaque, so an attempt to use a query string (page-specific parameters, with the syntax &lt;code&gt;&amp;lt;url&amp;gt;?parameter-data&lt;/code&gt;) with a data URL will just include the query string in the data the URL represents.</source>
          <target state="translated">Часть данных URL-адреса данных непрозрачна, поэтому попытка использовать строку запроса (параметры страницы, с синтаксисом &lt;code&gt;&amp;lt;url&amp;gt;?parameter-data&lt;/code&gt; ) с URL-адресом данных просто включит строку запроса в данные URL-адреса. представляет.</target>
        </trans-unit>
        <trans-unit id="a838733e8354e6c49d346e5cb2fb10c66ede3853" translate="yes" xml:space="preserve">
          <source>The data to be sent is already compressed and a second compression won't lead to smaller data to be transmitted. This may be the case with some image formats;</source>
          <target state="translated">Отправляемые данные уже сжаты,и второе сжатие не приведет к передаче меньших объемов данных.Это может произойти в некоторых форматах изображений;</target>
        </trans-unit>
        <trans-unit id="7f9129a63093295fb84eccd3b4f61f829c9ef91c" translate="yes" xml:space="preserve">
          <source>The date/time after which the response is considered stale.</source>
          <target state="translated">Дата/время,после которого ответ считается просроченным.</target>
        </trans-unit>
        <trans-unit id="cd1d97e38222ff903f1be33758664532039e0043" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;'self'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce8a92d4fc085eba2fc0033588db51c48988c071" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bebd0e8a85754c8108d63895e7f002620ba7cd6c" translate="yes" xml:space="preserve">
          <source>The definition of collection state has been fixed so it doesn't vary
   anymore depending on the Request-URI (see &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

   The DAV:source property introduced in &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-4.6&quot;&gt;Section&amp;nbsp;4.6 of [RFC2518]&lt;/a&gt; was
   removed due to lack of implementation experience.

   The DAV header now allows non-IETF extensions through URIs in
   addition to compliance class tokens.  It also can now be used in
   requests, although this specification does not define any associated
   semantics for the compliance classes defined in here (see
   &lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;).

   In &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;, the definition of the Depth header (&lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;)
   required that, by default, request headers would be applied to each
   resource in scope.  Based on implementation experience, the default
   has now been reversed (see &lt;a href=&quot;#section-10.2&quot;&gt;Section 10.2&lt;/a&gt;).

   The definitions of HTTP status code 102 (&lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-10.1&quot;&gt;[RFC2518], Section&amp;nbsp;10.1&lt;/a&gt;) and
   the Status-URI response header (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;) have been removed due to
   lack of implementation.

   The TimeType format used in the Timeout request header and the
   &quot;timeout&quot; XML element used to be extensible.  Now, only the two
   formats defined by this specification are allowed (see &lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;).

Author's Address

   Lisa Dusseault (editor)
   CommerceNet
   2064 Edgewood Dr.
   Palo Alto, CA  94303
   US

   EMail: ldusseault@commerce.net 

Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   &quot;AS IS&quot; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.


Dusseault                   Standards Track                   [Page 127]</source>
          <target state="translated">Определение состояния коллекции было исправлено, поэтому оно больше не зависит от Request-URI (см. &lt;a href=&quot;#section-5.2&quot;&gt;Раздел 5.2&lt;/a&gt; ). Свойство DAV: source, представленное в &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-4.6&quot;&gt;разделе 4.6 [RFC2518],&lt;/a&gt; было удалено из-за отсутствия опыта реализации. Заголовок DAV теперь позволяет использовать расширения, отличные от IETF, через URI в дополнение к токенам классов соответствия. Теперь его также можно использовать в запросах, хотя эта спецификация не определяет какую-либо связанную семантику для классов соответствия, определенных здесь (см. &lt;a href=&quot;#section-10.1&quot;&gt;Раздел 10.1&lt;/a&gt; ). В &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; определение заголовка глубины ( &lt;a href=&quot;#section-9.2&quot;&gt;раздел 9.2&lt;/a&gt;) требовал, чтобы по умолчанию заголовки запроса применялись к каждому ресурсу в области видимости. Основываясь на опыте реализации, значение по умолчанию было отменено (см. &lt;a href=&quot;#section-10.2&quot;&gt;Раздел 10.2&lt;/a&gt; ). Определения кода состояния HTTP 102 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-10.1&quot;&gt;[RFC2518], раздел 10.1&lt;/a&gt; ) и заголовка ответа Status-URI ( &lt;a href=&quot;#section-9.7&quot;&gt;раздел 9.7&lt;/a&gt; ) были удалены из-за отсутствия реализации. Формат TimeType, используемый в заголовке запроса Timeout и XML-элементе timeout, раньше был расширяемым. Теперь разрешены только два формата, определенные в этой спецификации (см. &lt;a href=&quot;#section-10.7&quot;&gt;Раздел 10.7.&lt;/a&gt;). Адрес автора Лиза Дюссо (редактор) CommerceNet 2064 Edgewood Доктор Пало-Альто, CA 94303, США Электронная почта: ldusseault@commerce.net Полное заявление об авторских правах Авторское право (C) IETF Trust (2007). На этот документ распространяются права, лицензии и ограничения, содержащиеся в &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78.&lt;/a&gt;, и, за исключением случаев, указанных в настоящем документе, авторы сохраняют за собой все свои права. Этот документ и содержащаяся в нем информация предоставляются на условиях &amp;laquo;КАК ЕСТЬ&amp;raquo;, и СОСТАВНИК, ОРГАНИЗАЦИЯ, ПРЕДСТАВЛЯЕМЫЕ ОН / ОНА ИЛИ СПОНСИРУЕМЫЕ (ЕСЛИ ЕСТЬ), ИНТЕРНЕТ-ОБЩЕСТВО, IETF TRUST И ИНТЕРНЕТ-ИНЖЕНЕРНАЯ ЦЕНА ОТКАЗЫВАЕТСЯ ОТ ВСЕХ ГАРАНТИИ, ЯВНЫЕ ИЛИ ПОДРАЗУМЕВАЕМЫЕ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ​​НИКАКИМИ ГАРАНТИЯМИ, ЧТО ИСПОЛЬЗОВАНИЕ ДАННЫХ ЗДЕСЬ НЕ НАРУШАЕТ НИКАКИХ ПРАВ ИЛИ КАКИХ-ЛИБО ПОДРАЗУМЕВАЕМЫХ ГАРАНТИЙ КОММЕРЧЕСКОЙ ЦЕННОСТИ ИЛИ ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННОЙ ЦЕЛИ.Интеллектуальная собственность IETF не занимает никакой позиции в отношении действительности или объема каких-либо прав интеллектуальной собственности или других прав, которые могут быть заявлены как относящиеся к реализации или использованию технологии, описанной в этом документе, или степени, в которой любая лицензия на такие права может или может быть недоступен; он также не означает, что он предпринял какие-либо независимые усилия для определения каких-либо таких прав. Информацию о процедурах в отношении прав в документах RFC можно найти в&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;ПП 78&lt;/a&gt; и &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;ПП 79&lt;/a&gt; . Могут быть получены копии раскрытых прав интеллектуальной собственности в секретариат IETF и любые гарантии предоставления лицензий либо в результате попытки получить генеральную лицензию или разрешение на использование таких прав собственности разработчиками или пользователями данной спецификации. из он-лайн репозитория IPR IETF по адресу &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;, IETF предлагает любой заинтересованной стороне довести до ее сведения любые авторские права, патенты или заявки на патенты, а также другие права собственности, которые могут касаться технологий, которые могут потребоваться для реализации этого стандарта. Пожалуйста, направьте информацию в IETF по адресу ietf-ipr@ietf.org. Благодарности Финансирование функции редактора RFC в настоящее время предоставляется Internet Society. Дорожка стандартов Дюссо [стр. 127]</target>
        </trans-unit>
        <trans-unit id="846eb07b1348486cd629ae2d294bdd353ad9d018" translate="yes" xml:space="preserve">
          <source>The definition of validator weakness has been expanded and clarified.
   (&lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;)

   Weak entity-tags are now allowed in all requests except range
   requests.  (Sections &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; and &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;)

   The ETag header field ABNF has been changed to not use quoted-string,
   thus avoiding escaping issues.  (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;)

   ETag is defined to provide an entity tag for the selected
   representation, thereby clarifying what it applies to in various
   situations (such as a PUT response).  (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;)

   The precedence for evaluation of conditional requests has been
   defined.  (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;)</source>
          <target state="translated">Расширено и уточнено определение слабости валидатора. ( &lt;a href=&quot;#section-2.1&quot;&gt;Раздел 2.1&lt;/a&gt; ) Слабые теги сущностей теперь разрешены во всех запросах, кроме запросов диапазона. (Разделы &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; и &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; ) Поле заголовка ETag ABNF было изменено, чтобы не использовать строку в кавычках, что позволяет избежать проблем с экранированием. ( &lt;a href=&quot;#section-2.3&quot;&gt;Раздел 2.3&lt;/a&gt; ) ETag определен для предоставления тега объекта для выбранного представления, тем самым разъясняя, к чему он применяется в различных ситуациях (например, в ответе PUT). ( &lt;a href=&quot;#section-2.3&quot;&gt;Раздел 2.3&lt;/a&gt; ) Определен приоритет для оценки условных запросов. ( &lt;a href=&quot;#section-6&quot;&gt;Раздел 6&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e5328b76256fad750a1749c068a42a24ebf54b5b" translate="yes" xml:space="preserve">
          <source>The delta-seconds rule specifies a non-negative integer, representing
   time in seconds.

     delta-seconds  = 1*DIGIT

   A recipient parsing a delta-seconds value and converting it to binary
   form ought to use an arithmetic type of at least 31 bits of
   non-negative integer range.  If a cache receives a delta-seconds
   value greater than the greatest integer it can represent, or if any
   of its subsequent calculations overflows, the cache MUST consider the
   value to be either 2147483648 (2^31) or the greatest positive integer
   it can conveniently represent.

      Note: The value 2147483648 is here for historical reasons,
      effectively represents infinity (over 68 years), and does not need
      to be stored in binary form; an implementation could produce it as
      a canned string if any overflow occurs, even if the calculations
      are performed with an arithmetic type incapable of directly
      representing that number.  What matters here is that an overflow
      be detected and not treated as a negative value in later
      calculations.</source>
          <target state="translated">Правило дельта-секунд определяет неотрицательное целое число,представляющее собой время в секундах.Дельта-секунды=1*DIGIT Получатель,разбирающий значение дельта-секунд и преобразующий его в двоичную форму,должен использовать арифметический тип,состоящий не менее чем из 31 бита неотрицательного целочисленного диапазона.Если кэш получает значение дельта-секунд больше,чем наибольшее целое число,которое он может представить,или если какое-либо из его последующих вычислений переполнится,то кэш ДОЛЖЕН считать значение либо 2147483648 (2^31),либо наибольшее положительное целое число,которое он может удобно представить.Примечание:значение 2147483648 здесь по историческим причинам,фактически представляет собой бесконечность (более 68 лет),и его не нужно хранить в двоичном виде;реализация может выдать его в виде консервированной строки,если произойдет какое-либо переполнение,даже если вычисления выполняются с арифметическим типом,неспособным напрямую представить это число.Здесь важно,чтобы переполнение было обнаружено и не рассматривалось как отрицательное значение в последующих вычислениях.</target>
        </trans-unit>
        <trans-unit id="462deec90237c01c88236d382d44851e9cb76a0d" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive instructs the user agent to report attempts to violate the Content Security Policy. These violation reports consist of JSON documents sent via an HTTP POST request to the specified URI.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;strong&gt;report-uri&lt;/strong&gt; предписывает пользовательскому агенту сообщать о попытках нарушения политики безопасности содержимого. Эти отчеты о нарушениях состоят из документов JSON, отправленных через HTTP-запрос POST на указанный URI.</target>
        </trans-unit>
        <trans-unit id="d2fba7a8d872d32f2df3792a939bb1791a1db637" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">&lt;code&gt;child-src&lt;/code&gt; директива HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) child-src определяет допустимые источники для &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;веб-воркеров&lt;/a&gt; и вложенных контекстов просмотра, загружаемых с использованием таких элементов, как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; . Для работников несоответствующие запросы обрабатываются пользовательским агентом как фатальные сетевые ошибки.</target>
        </trans-unit>
        <trans-unit id="e51c9503c283d705f7c21009451fd7fc25c1eae1" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive instructs the user agent to report attempts to violate the Content Security Policy. These violation reports consist of JSON documents sent via an HTTP POST request to the specified URI.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;strong&gt;report-uri&lt;/strong&gt; предписывает пользовательскому агенту сообщать о попытках нарушения политики безопасности содержимого. Эти отчеты о нарушениях состоят из документов JSON, отправленных через HTTP-запрос POST на указанный URI.</target>
        </trans-unit>
        <trans-unit id="fb07dc5196edc576bb2b0f9aa70d416b3225ffb6" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">&lt;code&gt;child-src&lt;/code&gt; директива HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) child-src определяет допустимые источники для &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;веб-воркеров&lt;/a&gt; и вложенных контекстов просмотра, загружаемых с использованием таких элементов, как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; . Для работников несоответствующие запросы обрабатываются пользовательским агентом как фатальные сетевые ошибки.</target>
        </trans-unit>
        <trans-unit id="546d3635c32a2c56e35d6d2aa60b3503528021d5" translate="yes" xml:space="preserve">
          <source>The determination of the best suited representation is made through one of two mechanisms:</source>
          <target state="translated">Определение наиболее подходящего представительства осуществляется с помощью одного из двух механизмов:</target>
        </trans-unit>
        <trans-unit id="1a6be54e0040e3b26e0677bc1c6c4c457e76e04c" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;PUT&lt;/code&gt; and &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;PUT&lt;/code&gt; is idempotent: calling it once or several times successively has the same effect (that is no &lt;em&gt;side&lt;/em&gt; effect), where successive identical &lt;code&gt;POST&lt;/code&gt; may have additional effects, like passing an order several times.</source>
          <target state="translated">Разница между &lt;code&gt;PUT&lt;/code&gt; и &lt;a href=&quot;post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; заключается в том, что &lt;code&gt;PUT&lt;/code&gt; является идемпотентным: вызов его один или несколько раз подряд дает тот же эффект (то есть не является &lt;em&gt;побочным&lt;/em&gt; эффектом), где последовательные идентичные &lt;code&gt;POST&lt;/code&gt; могут иметь дополнительные эффекты, такие как передача заказа несколько раз.</target>
        </trans-unit>
        <trans-unit id="b97e83ad793fdb57539f72e47bc2da06f9dd1d1b" translate="yes" xml:space="preserve">
          <source>The different behaviors are defined by the method of the request used, and by the set of headers used for a precondition:</source>
          <target state="translated">Различное поведение определяется используемым методом запроса,а также набором заголовков,используемых для предусловия:</target>
        </trans-unit>
        <trans-unit id="80097a5c7491102e72da844144491c63c53e8bbd" translate="yes" xml:space="preserve">
          <source>The different operations that can be done with HTTP: &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, and also less common requests like &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methods/trace&quot;&gt;&lt;code&gt;TRACE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Различные операции, которые можно выполнять с помощью HTTP: &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; , а также менее распространенные запросы, такие как &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;methods/trace&quot;&gt; &lt;code&gt;TRACE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e04de4891d47a19965395d893dcab0798dc6bd5e" translate="yes" xml:space="preserve">
          <source>The directive has no effect in and of itself, but only gains meaning in combination with other directives.</source>
          <target state="translated">Директива сама по себе не имеет никакого эффекта,а только приобретает смысл в сочетании с другими директивами.</target>
        </trans-unit>
        <trans-unit id="ff5b92c5b8f032668f44bf6f84a3cf1d8c8d5495" translate="yes" xml:space="preserve">
          <source>The directive whose enforcement caused the violation.</source>
          <target state="translated">Директива,исполнение которой стало причиной нарушения.</target>
        </trans-unit>
        <trans-unit id="1e1a37c4f62f3222f090827450cdf97da20610e6" translate="yes" xml:space="preserve">
          <source>The directive whose inforcement caused the violation.</source>
          <target state="translated">Директива,информация о которой стала причиной нарушения.</target>
        </trans-unit>
        <trans-unit id="9d6fbbcf7c6fc507f3bb84ba69ad161ef0423583" translate="yes" xml:space="preserve">
          <source>The directives are case-insensitive and have an optional argument, that can use both token and quoted-string syntax. Multiple directives are comma-separated.</source>
          <target state="translated">Директивы не чувствительны к регистру и имеют необязательный аргумент,который может использовать как синтаксис маркеров,так и синтаксис кавычек.Несколько директив разделены запятыми.</target>
        </trans-unit>
        <trans-unit id="a323859b4a71cd1636fe58a5af5f7f00fc33a635" translate="yes" xml:space="preserve">
          <source>The directives of the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header can also be applied to &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;.</source>
          <target state="translated">Директивы заголовка &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; также могут применяться к &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95c774d8f9b5eed24a795ffcdff60addf8cc635d" translate="yes" xml:space="preserve">
          <source>The document &lt;code&gt;https://example.com/page.html&lt;/code&gt; will send the referrer &lt;code&gt;https://example.com/&lt;/code&gt;.</source>
          <target state="translated">Документ &lt;code&gt;https://example.com/page.html&lt;/code&gt; отправит рефереру &lt;code&gt;https://example.com/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d8ec917bef56223b37a5c1500b0656c3dce3b2f" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation header&lt;/code&gt; has opened another window with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; or other similar methods without &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; or the &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; feature being set. This is for the same reason as above, namely that they can communicate and thus we cannot allow them to switch processes.</source>
          <target state="translated">Документ с &lt;code&gt;Large-Allocation header&lt;/code&gt; открыл другое окно с помощью &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; или других аналогичных методов без установленной функции &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; или &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; . Это происходит по той же причине, что и выше, а именно потому, что они могут общаться, и поэтому мы не можем позволить им переключать процессы.</target>
        </trans-unit>
        <trans-unit id="4a86ff11f18e76ef15af55380e0e783a222b5261" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation&lt;/code&gt; header was loaded in a window which was opened by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; or other similar methods without &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; or the &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; feature being set. These windows must remain in the same process as their opener, as they can communicate, meaning that we cannot allow them to switch processes.</source>
          <target state="translated">Документ с заголовком &lt;code&gt;Large-Allocation&lt;/code&gt; был загружен в окно, которое было открыто с помощью &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; или других аналогичных методов без установленной функции &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; или &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; . Эти окна должны оставаться в том же процессе, что и их открыватель, поскольку они могут взаимодействовать, а это означает, что мы не можем позволить им переключать процессы.</target>
        </trans-unit>
        <trans-unit id="99747b44d362c4206f7c42047a6a2ac0e7e63002" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation&lt;/code&gt; header was loaded in an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. Firefox cannot move an iframe into a new process currently, so the document must load in the current process.</source>
          <target state="translated">Документ с заголовком &lt;code&gt;Large-Allocation&lt;/code&gt; был загружен в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; . Firefox не может переместить iframe в новый процесс в настоящее время, поэтому документ должен загружаться в текущем процессе.</target>
        </trans-unit>
        <trans-unit id="a6f2c4f6f26722715e92610972343c812a59e653" translate="yes" xml:space="preserve">
          <source>The domain name of the forwarded server.</source>
          <target state="translated">Доменное имя переадресованного сервера.</target>
        </trans-unit>
        <trans-unit id="063cfa7dcd340bc61f1b1e374717469ae3ca0edf" translate="yes" xml:space="preserve">
          <source>The domain name of the server (for virtual hosting) or the IP.</source>
          <target state="translated">Доменное имя сервера (для виртуального хостинга)или IP.</target>
        </trans-unit>
        <trans-unit id="29fdd0cbf82278b018fbbaf65a8801167da2e6c8" translate="yes" xml:space="preserve">
          <source>The effect of certain methods performed on a resource at the origin
   server might cause one or more existing cache entries to become non-
   transparently invalid. That is, although they might continue to be
   &quot;fresh,&quot; they do not accurately reflect what the origin server would
   return for a new request on that resource. 

   There is no way for the HTTP protocol to guarantee that all such
   cache entries are marked invalid. For example, the request that
   caused the change at the origin server might not have gone through
   the proxy where a cache entry is stored. However, several rules help
   reduce the likelihood of erroneous behavior.

   In this section, the phrase &quot;invalidate an entity&quot; means that the
   cache will either remove all instances of that entity from its
   storage, or will mark these as &quot;invalid&quot; and in need of a mandatory
   revalidation before they can be returned in response to a subsequent
   request.

   Some HTTP methods MUST cause a cache to invalidate an entity. This is
   either the entity referred to by the Request-URI, or by the Location
   or Content-Location headers (if present). These methods are:

      - PUT

      - DELETE

      - POST

   In order to prevent denial of service attacks, an invalidation based
   on the URI in a Location or Content-Location header MUST only be
   performed if the host part is the same as in the Request-URI.

   A cache that passes through requests for methods it does not
   understand SHOULD invalidate any entities referred to by the
   Request-URI.</source>
          <target state="translated">Влияние определенных методов,выполняемых на ресурс на исходном сервере,может привести к тому,что одна или несколько существующих записей в кэше станут непрозрачно недействительными.То есть,хотя они могут продолжать быть &quot;свежими&quot;,они не точно отражают то,что сервер происхождения будет возвращаться для нового запроса на этот ресурс.Протокол HTTP не может гарантировать,что все такие записи в кэше будут помечены как недействительные.Например,запрос,который вызвал изменение на исходном сервере,возможно,не прошел через прокси-сервер,где хранится запись в кэше.Однако,несколько правил помогают уменьшить вероятность ошибочного поведения.В этом разделе фраза &quot;invalidate a entity&quot; означает,что кэш либо удалит все экземпляры этой сущности из своего хранилища,либо пометит их как &quot;invalid&quot; и нуждается в обязательной повторной проверке перед тем,как они могут быть возвращены в ответ на последующий запрос.Некоторые методы HTTP ДОЛЖНЫ приводить к тому,что кэш делает сущность недействительной.Это либо объект,на который ссылается Request-URI,либо заголовки Location или Content-Location (если есть).Этими методами являются:-PUT-DELETE-POST Для предотвращения атак типа &quot;отказ в обслуживании&quot;,аннулирование на основе URI в заголовке Location или Content-Location ДОЛЖНО выполняться только в том случае,если хост-узел совпадает с заголовком Request-URI.Кэш,который проходит через запросы методов,не понимает,ДОЛЖЕН аннулировать все сущности,на которые ссылается Request-URI.</target>
        </trans-unit>
        <trans-unit id="96733518a6ff2858b2648088ac99a8575b177584" translate="yes" xml:space="preserve">
          <source>The entity-body (if any) sent with an HTTP request or response is in
   a format and encoding defined by the entity-header fields.

       entity-body    = *OCTET

   An entity-body is only present in a message when a message-body is
   present, as described in &lt;a href=&quot;#section-4.3&quot;&gt;section 4.3&lt;/a&gt;. The entity-body is obtained
   from the message-body by decoding any Transfer-Encoding that might
   have been applied to ensure safe and proper transfer of the message.</source>
          <target state="translated">Тело объекта (если есть), отправленное с HTTP-запросом или ответом, имеет формат и кодировку, определяемые полями заголовка объекта. entity-body = * OCTET Тело объекта присутствует в сообщении, только когда присутствует тело сообщения, как описано в &lt;a href=&quot;#section-4.3&quot;&gt;разделе 4.3&lt;/a&gt; . Тело объекта получается из тела сообщения путем декодирования любого кодирования передачи, которое могло быть применено для обеспечения безопасной и правильной передачи сообщения.</target>
        </trans-unit>
        <trans-unit id="446ffc851c64954297de6b7856c3aaf1d655d3fb" translate="yes" xml:space="preserve">
          <source>The entity-length of a message is the length of the message-body
   before any transfer-codings have been applied. &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; defines
   how the transfer-length of a message-body is determined.</source>
          <target state="translated">Длина объекта сообщения - это длина тела сообщения до применения каких-либо кодировок передачи. &lt;a href=&quot;#section-4.4&quot;&gt;Раздел 4.4&lt;/a&gt; определяет, как определяется длина передачи тела сообщения.</target>
        </trans-unit>
        <trans-unit id="430808f49439af4bf0997780d867503fb8ae80aa" translate="yes" xml:space="preserve">
          <source>The equivalent &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; response would have included the headers &lt;a href=&quot;../headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/content-location&quot;&gt;&lt;code&gt;Content-Location&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эквивалентный ответ &lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; должен включать заголовки &lt;a href=&quot;../headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../headers/content-location&quot;&gt; &lt;code&gt;Content-Location&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../headers/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc6274c604e308e30d74c2f35a4f5fe3102aafe5" translate="yes" xml:space="preserve">
          <source>The exact resource identified by an Internet request is determined by
   examining both the Request-URI and the Host header field.

   An origin server that does not allow resources to differ by the
   requested host MAY ignore the Host header field value when
   determining the resource identified by an HTTP/1.1 request. (But see
   &lt;a href=&quot;#section-19.6.1.1&quot;&gt;section 19.6.1.1&lt;/a&gt; for other requirements on Host support in HTTP/1.1.)

   An origin server that does differentiate resources based on the host
   requested (sometimes referred to as virtual hosts or vanity host
   names) MUST use the following rules for determining the requested
   resource on an HTTP/1.1 request:

   1. If Request-URI is an absoluteURI, the host is part of the
     Request-URI. Any Host header field value in the request MUST be
     ignored.

   2. If the Request-URI is not an absoluteURI, and the request includes
     a Host header field, the host is determined by the Host header
     field value.

   3. If the host as determined by rule 1 or 2 is not a valid host on
     the server, the response MUST be a 400 (Bad Request) error message.

   Recipients of an HTTP/1.0 request that lacks a Host header field MAY
   attempt to use heuristics (e.g., examination of the URI path for
   something unique to a particular host) in order to determine what
   exact resource is being requested.</source>
          <target state="translated">Точный ресурс, идентифицированный Интернет-запросом, определяется путем проверки как Request-URI, так и поля заголовка Host. Исходный сервер, который не позволяет ресурсам отличаться запрошенным хостом, МОЖЕТ игнорировать значение поля заголовка Host при определении ресурса, идентифицированного запросом HTTP / 1.1. (Но см. &lt;a href=&quot;#section-19.6.1.1&quot;&gt;Раздел 19.6.1.1&lt;/a&gt;для других требований к поддержке хоста в HTTP / 1.1.) Исходный сервер, который дифференцирует ресурсы на основе запрошенного хоста (иногда называемый виртуальными хостами или частными именами хостов), ДОЛЖЕН использовать следующие правила для определения запрошенного ресурса в HTTP / 1.1 запрос: 1. Если Request-URI является absoluteURI, хост является частью Request-URI. Любое значение поля заголовка Host в запросе ДОЛЖНО игнорироваться. 2. Если Request-URI не является absoluteURI и запрос включает в себя поле заголовка Host, узел определяется значением поля заголовка Host. 3. Если хост, определенный правилом 1 или 2, не является допустимым хостом на сервере, ответ ДОЛЖЕН быть сообщением об ошибке 400 (неверный запрос). Получатели запроса HTTP / 1.0, в котором отсутствует поле заголовка Host, МОГУТ попытаться использовать эвристику (например,исследование пути URI для чего-то уникального для конкретного хоста), чтобы определить, какой именно ресурс запрашивается.</target>
        </trans-unit>
        <trans-unit id="9d41666eafa2d743345a256aece9bd1b22af0421" translate="yes" xml:space="preserve">
          <source>The examples at the end of this document are complete. There is no additional syntax needed to save it into a file and use it. (Of course, the JavaScripts must be edited to reflect your site's domain name and/or subnets.)</source>
          <target state="translated">Примеры,приведенные в конце этого документа,являются полными.Нет необходимости в дополнительном синтаксисе,чтобы сохранить его в файл и использовать.(Конечно,JavaScripts необходимо отредактировать,чтобы отразить доменное имя и/или подсети вашего сайта).</target>
        </trans-unit>
        <trans-unit id="4044137ba9e4a5b42152e40cc16d223426864ffc" translate="yes" xml:space="preserve">
          <source>The exception to this is if the worker script's origin is a globally unique identifier (for example, if its URL has a scheme of data or blob). In this case, the worker does inherit the content security policy of the document or worker that created it.</source>
          <target state="translated">Исключение составляют случаи,когда происхождение рабочего скрипта является глобально уникальным идентификатором (например,если его URL имеет схему данных или блоба).В этом случае рабочий наследует политику безопасности содержимого документа или рабочего,который его создал.</target>
        </trans-unit>
        <trans-unit id="25060abe4601e57cbdab7b0fcd2e4d780cee3888" translate="yes" xml:space="preserve">
          <source>The expectation given in an Expect request-header field (see &lt;a href=&quot;#section-14.20&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;) could not be met by this server, or, if the server is a proxy,
   the server has unambiguous evidence that the request could not be met
   by the next-hop server.</source>
          <target state="translated">Ожидание, указанное в поле заголовка запроса Expect (см. &lt;a href=&quot;#section-14.20&quot;&gt;Раздел &lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt; ), не может быть выполнено этим сервером, или, если сервер является прокси, сервер имеет недвусмысленное свидетельство того, что запрос не может быть выполнен сервером следующего перехода. ,</target>
        </trans-unit>
        <trans-unit id="e89474435ba5cceae8038928368d478ddd9d1651" translate="yes" xml:space="preserve">
          <source>The expected size of the allocation to be performed, in megabytes.</source>
          <target state="translated">Ожидаемый размер ассигнований,которые должны быть выполнены,в мегабайтах.</target>
        </trans-unit>
        <trans-unit id="7187b470d2aaa46b6160031b6302821aeaad40ea" translate="yes" xml:space="preserve">
          <source>The experimental &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; lists configuration data that can be used by the server to select an appropriate response. Valid values are:</source>
          <target state="translated">Экспериментальный &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH&quot;&gt; &lt;code&gt;Accept-CH&lt;/code&gt; &lt;/a&gt; перечисляет данные конфигурации, которые могут использоваться сервером для выбора соответствующего ответа. Допустимые значения:</target>
        </trans-unit>
        <trans-unit id="4c1f313837ffc811f5a2970246c6c36e4cf61462" translate="yes" xml:space="preserve">
          <source>The expiration time is computed as follows:</source>
          <target state="translated">Срок годности рассчитывается следующим образом:</target>
        </trans-unit>
        <trans-unit id="85e3770a3188fd2db74ea558b54fe9b64ff2f7c6" translate="yes" xml:space="preserve">
          <source>The expiration time of an entity MAY be specified by the origin
   server using the Expires header (see &lt;a href=&quot;#section-14.21&quot;&gt;section 14.21&lt;/a&gt;). Alternatively,
   it MAY be specified using the max-age directive in a response. When
   the max-age cache-control directive is present in a cached response,
   the response is stale if its current age is greater than the age
   value given (in seconds) at the time of a new request for that
   resource. The max-age directive on a response implies that the
   response is cacheable (i.e., &quot;public&quot;) unless some other, more
   restrictive cache directive is also present.

   If a response includes both an Expires header and a max-age
   directive, the max-age directive overrides the Expires header, even
   if the Expires header is more restrictive. This rule allows an origin
   server to provide, for a given response, a longer expiration time to
   an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be
   useful if certain HTTP/1.0 caches improperly calculate ages or
   expiration times, perhaps due to desynchronized clocks.

   Many HTTP/1.0 cache implementations will treat an Expires value that
   is less than or equal to the response Date value as being equivalent
   to the Cache-Control response directive &quot;no-cache&quot;. If an HTTP/1.1
   cache receives such a response, and the response does not include a
   Cache-Control header field, it SHOULD consider the response to be
   non-cacheable in order to retain compatibility with HTTP/1.0 servers.

       Note: An origin server might wish to use a relatively new HTTP
       cache control feature, such as the &quot;private&quot; directive, on a
       network including older caches that do not understand that
       feature. The origin server will need to combine the new feature
       with an Expires field whose value is less than or equal to the
       Date value. This will prevent older caches from improperly
       caching the response. 

   s-maxage
       If a response includes an s-maxage directive, then for a shared
       cache (but not for a private cache), the maximum age specified by
       this directive overrides the maximum age specified by either the
       max-age directive or the Expires header. The s-maxage directive
       also implies the semantics of the proxy-revalidate directive (see
       &lt;a href=&quot;#section-14.9.4&quot;&gt;section 14.9.4&lt;/a&gt;), i.e., that the shared cache must not use the
       entry after it becomes stale to respond to a subsequent request
       without first revalidating it with the origin server. The s-
       maxage directive is always ignored by a private cache.

   Note that most older caches, not compliant with this specification,
   do not implement any cache-control directives. An origin server
   wishing to use a cache-control directive that restricts, but does not
   prevent, caching by an HTTP/1.1-compliant cache MAY exploit the
   requirement that the max-age directive overrides the Expires header,
   and the fact that pre-HTTP/1.1-compliant caches do not observe the
   max-age directive.

   Other directives allow a user agent to modify the basic expiration
   mechanism. These directives MAY be specified on a request:

   max-age
      Indicates that the client is willing to accept a response whose
      age is no greater than the specified time in seconds. Unless max-
      stale directive is also included, the client is not willing to
      accept a stale response.

   min-fresh
      Indicates that the client is willing to accept a response whose
      freshness lifetime is no less than its current age plus the
      specified time in seconds. That is, the client wants a response
      that will still be fresh for at least the specified number of
      seconds.

   max-stale
      Indicates that the client is willing to accept a response that has
      exceeded its expiration time. If max-stale is assigned a value,
      then the client is willing to accept a response that has exceeded
      its expiration time by no more than the specified number of
      seconds. If no value is assigned to max-stale, then the client is
      willing to accept a stale response of any age.

   If a cache returns a stale response, either because of a max-stale
   directive on a request, or because the cache is configured to
   override the expiration time of a response, the cache MUST attach a
   Warning header to the stale response, using Warning 110 (Response is
   stale). 

   A cache MAY be configured to return stale responses without
   validation, but only if this does not conflict with any &quot;MUST&quot;-level
   requirements concerning cache validation (e.g., a &quot;must-revalidate&quot;
   cache-control directive).

   If both the new request and the cached entry include &quot;max-age&quot;
   directives, then the lesser of the two values is used for determining
   the freshness of the cached entry for that request.</source>
          <target state="translated">Время истечения срока действия объекта МОЖЕТ быть указано исходным сервером с помощью заголовка Expires (см. &lt;a href=&quot;#section-14.21&quot;&gt;Раздел 14.21.&lt;/a&gt;). В качестве альтернативы это МОЖЕТ быть указано с помощью директивы max-age в ответе. Когда в кэшированном ответе присутствует директива max-age cache-control, ответ считается устаревшим, если его текущий возраст больше, чем значение возраста, указанное (в секундах) во время нового запроса для этого ресурса. Директива max-age в ответе подразумевает, что ответ является кэшируемым (т. Е. &amp;laquo;Общедоступным&amp;raquo;), если также не присутствует какая-либо другая, более ограничительная директива кеширования. Если ответ включает и заголовок Expires, и директиву max-age, директива max-age переопределяет заголовок Expires, даже если заголовок Expires более строгий. Это правило позволяет исходному серверу предоставлять для данного ответа более длительное время истечения срока действия для кеша HTTP / 1.1 (или более позднего), чем для кеша HTTP / 1.0.Это может быть полезно, если некоторые кеши HTTP / 1.0 неправильно вычисляют возраст или время истечения срока действия, возможно, из-за десинхронизации часов. Многие реализации кеширования HTTP / 1.0 будут рассматривать значение Expires, которое меньше или равно значению даты ответа, как эквивалент директиве ответа Cache-Control &amp;laquo;no-cache&amp;raquo;. Если кэш HTTP / 1.1 получает такой ответ, и ответ не включает поле заголовка Cache-Control, он ДОЛЖЕН считать ответ некэшируемым, чтобы сохранить совместимость с серверами HTTP / 1.0. Примечание. Исходный сервер может пожелать использовать относительно новую функцию управления кешем HTTP, такую ​​как директива &amp;laquo;private&amp;raquo;, в сети, включая старые кеши, которые не поддерживают эту функцию.Исходный сервер должен будет объединить новую функцию с полем Expires, значение которого меньше или равно значению Date. Это предотвратит неправильное кэширование ответа в старых кэшах. s-maxage Если ответ включает директиву s-maxage, то для общего кеша (но не для частного кеша) максимальный возраст, указанный в этой директиве, переопределяет максимальный возраст, указанный либо в директиве max-age, либо в заголовке Expires. , Директива s-maxage также подразумевает семантику директивы proxy-revalidate (см.тогда для общего кеша (но не для частного кеша) максимальный возраст, указанный в этой директиве, переопределяет максимальный возраст, указанный либо в директиве max-age, либо в заголовке Expires. Директива s-maxage также подразумевает семантику директивы proxy-revalidate (см.тогда для общего кеша (но не для частного кеша) максимальный возраст, указанный в этой директиве, переопределяет максимальный возраст, указанный либо в директиве max-age, либо в заголовке Expires. Директива s-maxage также подразумевает семантику директивы proxy-revalidate (см. &lt;a href=&quot;#section-14.9.4&quot;&gt;раздел 14.9.4&lt;/a&gt;), т. е. общий кеш не должен использовать запись после того, как она устареет, для ответа на последующий запрос без предварительной повторной проверки ее на исходном сервере. Директива s-maxage всегда игнорируется частным кешем. Обратите внимание, что большинство старых кешей, не соответствующих этой спецификации, не реализуют никаких директив управления кешем. Исходный сервер, желающий использовать директиву управления кешем, которая ограничивает, но не предотвращает, кэширование с помощью кеша, совместимого с HTTP / 1.1, МОЖЕТ использовать требование, чтобы директива max-age переопределяла заголовок Expires, и тот факт, что до HTTP /1.1- совместимые кеши не соблюдают директиву max-age. Другие директивы позволяют пользовательскому агенту изменять основной механизм истечения срока действия. Эти директивы МОГУТ быть указаны по запросу:max-age Указывает, что клиент готов принять ответ, возраст которого не превышает указанное время в секундах. Если не включена также директива maxstale, клиент не желает принимать устаревший ответ. min-fresh Указывает, что клиент готов принять ответ, время жизни которого не меньше, чем его текущий возраст плюс указанное время в секундах. То есть клиент хочет, чтобы ответ был свежим в течение как минимум указанного количества секунд. max-stale Указывает, что клиент готов принять ответ, срок действия которого истек. Если max-stale присвоено значение,тогда клиент желает принять ответ, срок действия которого истек не более чем на указанное количество секунд. Если max-stale не присвоено никакого значения, то клиент готов принять устаревший ответ любого возраста. Если кэш возвращает устаревший ответ, либо из-за директивы max-stale в запросе, либо из-за того, что кеш настроен на переопределение времени истечения срока ответа, кеш ДОЛЖЕН присоединить заголовок предупреждения к устаревшему ответу, используя предупреждение 110 (Ответ устарел). Кэш МОЖЕТ быть сконфигурирован так, чтобы возвращать устаревшие ответы без проверки, но только если это не противоречит каким-либо требованиям уровня &amp;laquo;ОБЯЗАТЕЛЬНО&amp;raquo;, касающимся проверки кеша (например, директива &amp;laquo;обязательна повторная проверка&amp;raquo; управления кешем).Если и новый запрос, и кэшированная запись включают директивы &amp;laquo;max-age&amp;raquo;, то меньшее из двух значений используется для определения актуальности кэшированной записи для этого запроса.</target>
        </trans-unit>
        <trans-unit id="3993f15811c93a67d3ec5d0d92f253093020cabe" translate="yes" xml:space="preserve">
          <source>The features include:</source>
          <target state="translated">Особенности включают в себя:</target>
        </trans-unit>
        <trans-unit id="c73ddc20bc1d282151f4ec68084bc6164972b4dc" translate="yes" xml:space="preserve">
          <source>The file consists of a function called &lt;code&gt;FindProxyForURL&lt;/code&gt;. The example below will work in an environment where the internal DNS server is set up so that it can only resolve internal host names, and the goal is to use a proxy only for hosts that aren't resolvable:</source>
          <target state="translated">Файл состоит из функции &lt;code&gt;FindProxyForURL&lt;/code&gt; . Пример ниже будет работать в среде, где внутренний DNS-сервер настроен так, что он может разрешать только внутренние имена хостов, а цель состоит в том, чтобы использовать прокси только для хостов, которые не разрешаются:</target>
        </trans-unit>
        <trans-unit id="ce8df497bc37efd316beaa79c7a58e65942dbc0b" translate="yes" xml:space="preserve">
          <source>The file firefox.js passes preference names and values to the pref() function. For example:</source>
          <target state="translated">Файл firefox.js передает в функцию pref()имена и значения предпочтений.Например:</target>
        </trans-unit>
        <trans-unit id="5b3cb207abfe237d7efa942f6a8fef274b6ca29a" translate="yes" xml:space="preserve">
          <source>The final block is a data block, which contains the optional data.</source>
          <target state="translated">Последний блок-это блок данных,который содержит необязательные данные.</target>
        </trans-unit>
        <trans-unit id="82d496b5f7760cf0c1c546e8d1a28c4fc534cf8d" translate="yes" xml:space="preserve">
          <source>The final block is an optional data block, which may contain further data mainly used by the POST method.</source>
          <target state="translated">Последний блок-это необязательный блок данных,который может содержать дополнительные данные,используемые в основном в методе POST.</target>
        </trans-unit>
        <trans-unit id="477b8ca70c884ab091243f614c5d70eeeab51fd8" translate="yes" xml:space="preserve">
          <source>The final part of the request is its body. Not all requests have one: requests fetching resources, like &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;, DELETE, or OPTIONS, usually don't need one. Some requests send data to the server in order to update it: as often the case with &lt;code&gt;POST&lt;/code&gt; requests (containing HTML form data).</source>
          <target state="translated">Заключительная часть запроса - это его тело. Не все запросы имеют один: запросы на выборку ресурсов, таких как &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;HEAD&lt;/code&gt; , DELETE или OPTIONS, обычно в них не нуждаются. Некоторые запросы отправляют данные на сервер для их обновления: как это часто бывает с запросами &lt;code&gt;POST&lt;/code&gt; (содержащими данные HTML-формы).</target>
        </trans-unit>
        <trans-unit id="a7bd7db1836bd8959bc7e0d7e27321e685761ca2" translate="yes" xml:space="preserve">
          <source>The final recipient of the request should reflect the message received, excluding some fields described below, back to the client as the message body of a 200 (OK) response with a &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;message/http&lt;/code&gt;. The final recipient is either the origin server or the first server to receive a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt;&lt;code&gt;Max-Forwards&lt;/code&gt;&lt;/a&gt; value of 0 in the request.</source>
          <target state="translated">Конечный получатель запроса должен отражать полученное сообщение, за исключением некоторых полей , описанных ниже, обратно клиенту как тело сообщения 200 (OK) ответ с &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; в &lt;code&gt;message/http&lt;/code&gt; . Конечным получателем является либо исходный сервер, либо первый сервер, получивший в запросе значение &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt; &lt;code&gt;Max-Forwards&lt;/code&gt; ,&lt;/a&gt; равное 0.</target>
        </trans-unit>
        <trans-unit id="ec16b4ce596bd77bc971178dc4e6a8899896e2cb" translate="yes" xml:space="preserve">
          <source>The first 40 characters of the inline script, event handler, or style that caused the violation.</source>
          <target state="translated">Первые 40 символов встроенного скрипта,обработчика событий или стиля,которые вызвали нарушение.</target>
        </trans-unit>
        <trans-unit id="30b3cc93d61693c25216e29c69eecc3a87dde174" translate="yes" xml:space="preserve">
          <source>The first line contains a request method followed by its parameters:</source>
          <target state="translated">В первой строке содержится метод запроса,за которым следуют его параметры:</target>
        </trans-unit>
        <trans-unit id="0ce913e069990d2088bde8127d92db28b9c6593c" translate="yes" xml:space="preserve">
          <source>The first line of a Response message is the Status-Line, consisting
   of the protocol version followed by a numeric status code and its
   associated textual phrase, with each element separated by SP
   characters. No CR or LF is allowed except in the final CRLF sequence.

       Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</source>
          <target state="translated">Первая строка Ответного сообщения-это строка состояния,состоящая из версии протокола,за которой следует цифровой код состояния и связанная с ним текстовая фраза,каждый элемент которой разделены символами SP.Никакие CR или LF не допускаются,кроме как в конечной последовательности CRLF.Status-Line=HTTP-Version SP Статус-код SP Причина-фраза CRLF</target>
        </trans-unit>
        <trans-unit id="34ccf4b003a3910dffb0926766714dc4dd11b6eb" translate="yes" xml:space="preserve">
          <source>The first line of a response message is the status-line, consisting
   of the protocol version, a space (SP), the status code, another
   space, a possibly empty textual phrase describing the status code,
   and ending with CRLF.

     status-line = HTTP-version SP status-code SP reason-phrase CRLF

   The status-code element is a 3-digit integer code describing the
   result of the server's attempt to understand and satisfy the client's
   corresponding request.  The rest of the response message is to be
   interpreted in light of the semantics defined for that status code.
   See &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7231]&lt;/a&gt; for information about the semantics of
   status codes, including the classes of status code (indicated by the
   first digit), the status codes defined by this specification,
   considerations for the definition of new status codes, and the IANA
   registry.

     status-code    = 3DIGIT

   The reason-phrase element exists for the sole purpose of providing a
   textual description associated with the numeric status code, mostly
   out of deference to earlier Internet application protocols that were
   more frequently used with interactive text clients.  A client SHOULD
   ignore the reason-phrase content.

     reason-phrase  = *( HTAB / SP / VCHAR / obs-text )</source>
          <target state="translated">Первая строка ответного сообщения - это строка состояния, состоящая из версии протокола, пробела (SP), кода состояния, еще одного пробела, возможно, пустой текстовой фразы, описывающей код состояния, и заканчивающейся CRLF. status-line = HTTP-версия SP status-code SP-причина-фраза CRLF Элемент status-code - это трехзначный целочисленный код, описывающий результат попытки сервера понять и удовлетворить соответствующий запрос клиента. Остальная часть ответного сообщения должна интерпретироваться в свете семантики, определенной для этого кода состояния. См. &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;Раздел 6 [RFC7231]&lt;/a&gt;для получения информации о семантике кодов состояния, включая классы кодов состояния (обозначенных первой цифрой), коды состояния, определенные в этой спецификации, рекомендации по определению новых кодов состояния и реестр IANA. status-code = 3DIGIT Элемент &amp;laquo;причина-фраза&amp;raquo; существует с единственной целью - предоставить текстовое описание, связанное с числовым кодом статуса, в основном из уважения к более ранним протоколам Интернет-приложений, которые чаще использовались с интерактивными текстовыми клиентами. Клиенту СЛЕДУЕТ игнорировать содержание фразы-причины. причина-фраза = * (HTAB / SP / VCHAR / obs-text)</target>
        </trans-unit>
        <trans-unit id="83e62459a880f4c5afe20430a0ef17081dbab746" translate="yes" xml:space="preserve">
          <source>The first line, the &lt;em&gt;status line&lt;/em&gt;, consists of an acknowledgment of the HTTP version used, followed by a status request (and its brief meaning in human-readable text).</source>
          <target state="translated">Первая строка, строка &lt;em&gt;состояния&lt;/em&gt; , состоит из подтверждения используемой версии HTTP, за которым следует запрос состояния (и его краткое значение в удобочитаемом тексте).</target>
        </trans-unit>
        <trans-unit id="5ae099fefbfad76e3dc77d1838fdc9c03df6ff4f" translate="yes" xml:space="preserve">
          <source>The first parameter in the HTTP context is always &lt;code&gt;form-data&lt;/code&gt;. Additional parameters are case-insensitive and have arguments that use quoted-string syntax after the &lt;code&gt;'='&lt;/code&gt; sign. Multiple parameters are separated by a semi-colon (&lt;code&gt;';'&lt;/code&gt;).</source>
          <target state="translated">Первым параметром в контексте HTTP всегда &lt;code&gt;form-data&lt;/code&gt; . Дополнительные параметры нечувствительны к регистру и имеют аргументы, использующие синтаксис строки в кавычках после знака &lt;code&gt;'='&lt;/code&gt; . Несколько параметров разделяются точкой с запятой ( &lt;code&gt;';'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1fe827f01fdf9c514ffb2a7b42770124ec3e2359" translate="yes" xml:space="preserve">
          <source>The first parameter in the HTTP context is either &lt;code&gt;inline&lt;/code&gt; (default value, indicating it can be displayed inside the Web page, or as the Web page) or &lt;code&gt;attachment&lt;/code&gt; (indicating it should be downloaded; most browsers presenting a 'Save as' dialog, prefilled with the value of the &lt;code&gt;filename&lt;/code&gt; parameters if present).</source>
          <target state="translated">Первый параметр в контексте HTTP является либо &lt;code&gt;inline&lt;/code&gt; (значение по умолчанию, указывающим, что он может отображаться внутри веб-страницы или как веб-страница), либо &lt;code&gt;attachment&lt;/code&gt; (указывающим, что он должен быть загружен; большинство браузеров представляют диалоговое окно &amp;laquo;Сохранить как&amp;raquo;, предварительно заполненное со значением параметров &lt;code&gt;filename&lt;/code&gt; если они есть).</target>
        </trans-unit>
        <trans-unit id="ce28a16fac0b2bc02f8a3ca48fc7babba03c0403" translate="yes" xml:space="preserve">
          <source>The first time your site is accessed using HTTPS and it returns the &lt;code&gt;Strict-Transport-Security&lt;/code&gt; header, the browser records this information, so that future attempts to load the site using HTTP will automatically use HTTPS instead.</source>
          <target state="translated">При первом доступе к вашему сайту по протоколу HTTPS, который возвращает заголовок &lt;code&gt;Strict-Transport-Security&lt;/code&gt; , браузер записывает эту информацию, так что при последующих попытках загрузить сайт с использованием HTTP вместо этого будет автоматически использоваться HTTPS.</target>
        </trans-unit>
        <trans-unit id="36a8e92e02612d193d4f4ea4835f02c068455028" translate="yes" xml:space="preserve">
          <source>The first upload of a resource is an edge case of the previous. Like any update of a resource, it is subject to a race condition if two clients try to perform at the similar times. To prevent this, conditional requests can be used: by adding &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; with the special value of &lt;code&gt;'*'&lt;/code&gt;, representing any etag. The request will succeed, only if the resource didn't exist before:</source>
          <target state="translated">Первая загрузка ресурса - это крайний случай предыдущей. Как и любое обновление ресурса, оно подвергается гонке, если два клиента пытаются работать в одно и то же время. Чтобы предотвратить это, можно использовать условные запросы: путем добавления &lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; со специальным значением &lt;code&gt;'*'&lt;/code&gt; , представляющим любой etag. Запрос будет успешным, только если ресурс не существовал ранее:</target>
        </trans-unit>
        <trans-unit id="e91a68110a72942d37f1a34f4d6ec060c7f1376a" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">Следующий &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; заблокирован и не загружается:</target>
        </trans-unit>
        <trans-unit id="485ecd6f231e048f16edaf6c17d5ccf5b1cb2429" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">Следующий &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; заблокирован и не загружается:</target>
        </trans-unit>
        <trans-unit id="63f869c917c180bee24835b4bf30ef56f30bb133" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">Следующая &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; заблокирована и не загружается:</target>
        </trans-unit>
        <trans-unit id="2bd3ab38162171d160acbfdeffc4df3e7c14c331" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="translated">Следующие элементы &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; заблокированы и не загружаются:</target>
        </trans-unit>
        <trans-unit id="af33c524092efa46a9bc5e3da17591ca7a2dfed3" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="translated">Следующие элементы &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt; &lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt; &lt;/a&gt; заблокированы и не загружаются:</target>
        </trans-unit>
        <trans-unit id="613e74e65709c0a5a289fb76a70fe4d72cdf7122" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Следующий &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fc90632d3761290b941626aad0314e6c02769a1e" translate="yes" xml:space="preserve">
          <source>The following Java code sets CORS response headers. Notice how the code sets the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value to the same value as the &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">Следующий код Java устанавливает заголовки ответов CORS. Обратите внимание, как код устанавливает значение &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; на то же значение, что и заголовок запроса &lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94255118119d25126914c95e1d87df4cff5fadb0" translate="yes" xml:space="preserve">
          <source>The following are all valid JavaScript MIME types according to the &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME Sniffing Standard&lt;/a&gt;.</source>
          <target state="translated">Ниже приведены все допустимые типы MIME JavaScript в соответствии со &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;стандартом сниффинга MIME&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81369c9bb8b849666e492d12305470dc3ab76aac" translate="yes" xml:space="preserve">
          <source>The following command will extract the Base64 encoded information for a website.</source>
          <target state="translated">Следующая команда извлечет для сайта информацию в кодировке Base64.</target>
        </trans-unit>
        <trans-unit id="386280384a9e1e846fc762abee1b45fa8528a42c" translate="yes" xml:space="preserve">
          <source>The following commands will help you extract the Base64 encoded information from a key file, a certificate signing request, or a certificate.</source>
          <target state="translated">Следующие команды помогут вам извлечь закодированную в Base64 информацию из ключевого файла,запроса на подписание сертификата или сертификата.</target>
        </trans-unit>
        <trans-unit id="509ad4a6b5b143b75559c314a8f0880abef072e8" translate="yes" xml:space="preserve">
          <source>The following connections are blocked and won't load:</source>
          <target state="translated">Следующие соединения заблокированы и не загружаются:</target>
        </trans-unit>
        <trans-unit id="41623b548495875f7a172266a4ccbfc78a26525c" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF
   (line feed), OCTET (any 8-bit sequence of data), SP (space), and
   VCHAR (any visible US-ASCII character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     BWS           = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     RWS           = &amp;lt;RWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     absolute-URI  = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     comment       = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     field-name    = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     partial-URI   = &amp;lt;partial-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt; 

     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;</source>
          <target state="translated">Следующие основные правила включены по ссылке, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Приложении B.1 [RFC5234]&lt;/a&gt; : ALPHA (буквы), CR (возврат каретки), CRLF (CR LF), CTL (элементы управления), DIGIT (десятичные 0-9) , DQUOTE (двойные кавычки), HEXDIG (шестнадцатеричные 0-9 / AF / af), HTAB (горизонтальная табуляция), LF (перевод строки), OCTET (любая 8-битная последовательность данных), SP (пробел) и VCHAR ( любой видимый символ US-ASCII). Следующие правила определены в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]: BWS = &amp;lt;BWS, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], раздел 3.2.3&lt;/a&gt; &amp;gt; OWS = &amp;lt;OWS, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], раздел 3.2.3&lt;/a&gt; &amp;gt; RWS = &amp;lt;RWS, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Раздел 3.2.3&lt;/a&gt; &amp;gt; URI-ссылка = &amp;lt;URI-ссылка, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], раздел 2.7&lt;/a&gt;&amp;gt; absolute-URI = &amp;lt;absolute-URI, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], раздел 2.7&lt;/a&gt; &amp;gt; comment = &amp;lt;comment, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], раздел 3.2.6&lt;/a&gt; &amp;gt; field-name = &amp;lt;comment, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], раздел 3.2&lt;/a&gt; &amp;gt; partial- URI = &amp;lt;частичный-URI, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], раздел 2.7&lt;/a&gt; &amp;gt; quoted-string = &amp;lt;quoted-string, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], раздел 3.2.6&lt;/a&gt; &amp;gt; token = &amp;lt;токен, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], раздел 3.2.6&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="9c0942541cf8ef1d402170eff33c293ebc3cc0b4" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   Note that all rules derived from token are to be compared
   case-insensitively, like range-unit and acceptable-ranges.

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS        = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     token      = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date  = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;
     entity-tag = &amp;lt;entity-tag, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232], Section&amp;nbsp;2.3&lt;/a&gt;&amp;gt;</source>
          <target state="translated">Следующие основные правила включены по ссылке, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Приложении B.1 [RFC5234]&lt;/a&gt; : ALPHA (буквы), CR (возврат каретки), CRLF (CR LF), CTL (элементы управления), DIGIT (десятичные 0-9) , DQUOTE (двойные кавычки), HEXDIG (шестнадцатеричные 0-9 / AF / af), LF (перевод строки), OCTET (любая 8-битная последовательность данных), SP (пробел) и VCHAR (любой видимый символ US-ASCII ). Обратите внимание, что все правила, производные от токена, должны сравниваться без учета регистра, например диапазон-единица и допустимые-диапазоны. Приведенные ниже правила определены в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]: OWS = &amp;lt;OWS, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], раздел 3.2.3&lt;/a&gt; &amp;gt; token = &amp;lt;token, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], раздел 3.2.6&lt;/a&gt; &amp;gt; Приведенные ниже правила определены в других частях: HTTP -date = &amp;lt;HTTP-дата, см.&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], раздел 7.1.1.1&lt;/a&gt; &amp;gt; entity-tag = &amp;lt;entity-tag, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232], раздел 2.3&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="cb819c2dfc07123960d680297955265860aae754" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     BWS           = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;</source>
          <target state="translated">Следующие основные правила включены по ссылке, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Приложении B.1 [RFC5234]&lt;/a&gt; : ALPHA (буквы), CR (возврат каретки), CRLF (CR LF), CTL (элементы управления), DIGIT (десятичные 0-9) , DQUOTE (двойные кавычки), HEXDIG (шестнадцатеричные 0-9 / AF / af), LF (перевод строки), OCTET (любая 8-битная последовательность данных), SP (пробел) и VCHAR (любой видимый символ US-ASCII ). Следующие ниже правила определены в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]: BWS = &amp;lt;BWS, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], раздел 3.2.3&lt;/a&gt; &amp;gt; OWS = &amp;lt;OWS, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], раздел 3.2.3&lt;/a&gt; &amp;gt; quoted-string = &amp;lt;quoted-string, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], раздел 3.2.6&lt;/a&gt; &amp;gt; token = &amp;lt;token, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], раздел 3.2.6&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="af8790fbb4ed65c1be1cf1a4b4f340c4491c4f9d" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     field-name    = &amp;lt;field-name, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

     port          = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     pseudonym     = &amp;lt;pseudonym, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230], Section&amp;nbsp;5.7.1&lt;/a&gt;&amp;gt;
     uri-host      = &amp;lt;uri-host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date     = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;</source>
          <target state="translated">Следующие основные правила включены по ссылке, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Приложении B.1 [RFC5234]&lt;/a&gt; : ALPHA (буквы), CR (возврат каретки), CRLF (CR LF), CTL (элементы управления), DIGIT (десятичные 0-9) , DQUOTE (двойные кавычки), HEXDIG (шестнадцатеричные 0-9 / AF / af), LF (перевод строки), OCTET (любая 8-битная последовательность данных), SP (пробел) и VCHAR (любой видимый символ US-ASCII ). Следующие правила определены в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]: OWS = &amp;lt;OWS, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], раздел 3.2.3&lt;/a&gt; &amp;gt; field-name = &amp;lt;field-name, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], раздел 3.2&lt;/a&gt; &amp;gt; quoted-string = &amp;lt;quoted-string , см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], раздел 3.2.6&lt;/a&gt; &amp;gt; token = &amp;lt;token, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], раздел 3.2.6&lt;/a&gt; &amp;gt; port = &amp;lt;порт,видеть&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], раздел 2.7&lt;/a&gt; &amp;gt; псевдоним = &amp;lt;псевдоним, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230], раздел 5.7.1&lt;/a&gt; &amp;gt; uri-host = &amp;lt;uri-host, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], раздел 2.7&lt;/a&gt; &amp;gt; Приведенные ниже правила определены в других частях: HTTP- date = &amp;lt;HTTP-date, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], раздел 7.1.1.1&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="bde3f83ba4fdea6e1247cb746890cdb2c25a10cd" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     obs-text      = &amp;lt;obs-text, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date     = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;</source>
          <target state="translated">Следующие основные правила включены по ссылке, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Приложении B.1 [RFC5234]&lt;/a&gt; : ALPHA (буквы), CR (возврат каретки), CRLF (CR LF), CTL (элементы управления), DIGIT (десятичные 0-9) , DQUOTE (двойные кавычки), HEXDIG (шестнадцатеричные 0-9 / AF / af), LF (перевод строки), OCTET (любая 8-битная последовательность данных), SP (пробел) и VCHAR (любой видимый символ US-ASCII ). Следующие ниже правила определены в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]: OWS = &amp;lt;OWS, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], раздел 3.2.3&lt;/a&gt; &amp;gt; obs-text = &amp;lt;obs-text, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], раздел 3.2.6&lt;/a&gt; &amp;gt; Правила ниже определены в другие части: HTTP-date = &amp;lt;HTTP-date, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], раздел 7.1.1.1&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="8084bb34a7c23d1e9e812c435cfc66928e96c80b" translate="yes" xml:space="preserve">
          <source>The following example shows the same copy operation being performed,
   but with the Overwrite header set to &quot;F.&quot; A response of 412
   (Precondition Failed) is returned because the destination URL is
   already mapped to a resource.

   &amp;gt;&amp;gt;Request

     COPY /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example.com/users/f/fielding/index.html
     Overwrite: F 

   &amp;gt;&amp;gt;Response

     HTTP/1.1 412 Precondition Failed</source>
          <target state="translated">В следующем примере показано выполнение той же операции копирования, но с заголовком Overwrite, установленным на &amp;laquo;F.&amp;raquo; Возвращается ответ 412 (Ошибка предварительного условия), поскольку целевой URL уже сопоставлен с ресурсом. &amp;gt;&amp;gt; Запросить КОПИРОВАНИЕ /~fielding/index.html HTTP / 1.1 Хост: www.example.com Назначение: http://www.example.com/users/f/fielding/index.html Перезапись: F &amp;gt;&amp;gt; Ответ HTTP / 1.1 412 Ошибка предварительного условия</target>
        </trans-unit>
        <trans-unit id="7acf3453f8031411e0b71e19213cb90990e8cb3a" translate="yes" xml:space="preserve">
          <source>The following example specifies enforcement of Certificate Transparency for 24 hours and reports violations to foo.example.</source>
          <target state="translated">Следующий пример указывает на обеспечение прозрачности сертификатов в течение 24 часов и сообщает о нарушениях на личном примере.</target>
        </trans-unit>
        <trans-unit id="94b32d3de424f684aa74d5609ddab84fb75dd925" translate="yes" xml:space="preserve">
          <source>The following font resource loading is blocked and won't load:</source>
          <target state="translated">Загрузка следующего ресурса шрифтов заблокирована и не загружается:</target>
        </trans-unit>
        <trans-unit id="354531c678665d3125c2ef3c1112692d5b4fe889" translate="yes" xml:space="preserve">
          <source>The following headers are involved in the WebSocket upgrade process. Other than the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers, the rest are generally optional or handled for you by the browser and server when they're talking to each other.</source>
          <target state="translated">Следующие заголовки участвуют в процессе обновления WebSocket. За исключением заголовков &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; , остальные, как правило, необязательны или обрабатываются для вас браузером и сервером, когда они общаются друг с другом.</target>
        </trans-unit>
        <trans-unit id="bb8db65f4711517dd753e17a8cd07fb37a9810cb" translate="yes" xml:space="preserve">
          <source>The following is an example of a request that will be preflighted.</source>
          <target state="translated">Ниже приведен пример запроса,который будет выполнен до вылета.</target>
        </trans-unit>
        <trans-unit id="6166015c4ad889984ba227b210f2740bda4740b4" translate="yes" xml:space="preserve">
          <source>The following line with your relevant key information (pin-sha256=&quot;...&quot; fields) will enable HPKP on lighttpd.</source>
          <target state="translated">Следующая строка с вашей соответствующей ключевой информацией (pin-sha256=&quot;...&quot; поля)включит HPKP в lightttpd.</target>
        </trans-unit>
        <trans-unit id="2ae960e358cb5178ea4e99046d9b426fbe630cc9" translate="yes" xml:space="preserve">
          <source>The following list summarizes HTTP headers by their usage category. For an alphabetical list, see the navigation on the left side.</source>
          <target state="translated">Следующий список обобщает заголовки HTTP по категориям их использования.Алфавитный список см.в навигации слева.</target>
        </trans-unit>
        <trans-unit id="eb997113b54cfb7ed6ae28493a5cfaf71d6f764b" translate="yes" xml:space="preserve">
          <source>The following request body for a PROPFIND method is illegal.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;&amp;gt;
       &amp;lt;D:allprop/&amp;gt;
       &amp;lt;D:propname/&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   The definition of the propfind element only allows for the allprop or
   the propname element, not both.  Thus, the above is an error and must
   be responded to with a 400 (Bad Request).

   Imagine, however, that a server wanted to be &quot;kind&quot; and decided to
   pick the allprop element as the true element and respond to it.  A
   client running over a bandwidth limited line who intended to execute
   a propname would be in for a big surprise if the server treated the
   command as an allprop.

   Additionally, if a server were lenient and decided to reply to this
   request, the results would vary randomly from server to server, with
   some servers executing the allprop directive, and others executing
   the propname directive.  This reduces interoperability rather than
   increasing it.</source>
          <target state="translated">Следующее тело запроса для метода PROPFIND является недопустимым. &amp;lt;? xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D: propfind xmlns: D = &quot;DAV:&quot;&amp;gt; &amp;lt;D: allprop /&amp;gt; &amp;lt;D: propname /&amp;gt; &amp;lt;/ D: propfind&amp;gt; Определение элемента propfind допускает только элемент allprop или propname, но не оба. Таким образом, указанное выше является ошибкой, и на нее следует ответить 400 (неверный запрос). Однако представьте, что сервер хотел быть &amp;laquo;добрым&amp;raquo; и решил выбрать элемент allprop в качестве истинного элемента и ответить на него. Клиент, работающий по линии с ограниченной пропускной способностью и намеревавшийся выполнить имя пропуска, будет большим сюрпризом, если сервер обработает команду как allprop. Кроме того, если сервер проявил снисходительность и решил ответить на этот запрос,результаты будут варьироваться случайным образом от сервера к серверу, при этом некоторые серверы будут выполнять директиву allprop, а другие - директиву propname. Это снижает функциональную совместимость, а не увеличивает ее.</target>
        </trans-unit>
        <trans-unit id="afe5b5f9e1c6d81603d280407ff45a5bd4095d77" translate="yes" xml:space="preserve">
          <source>The following request header fields are sent by a user agent to
   engage in proactive negotiation of the response content, as defined
   in &lt;a href=&quot;#section-3.4.1&quot;&gt;Section 3.4.1&lt;/a&gt;.  The preferences sent in these fields apply to any
   content in the response, including representations of the target
   resource, representations of error or processing status, and
   potentially even the miscellaneous text strings that might appear
   within the protocol.

   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | Accept            | &lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt; |
   | Accept-Charset    | &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt; |
   | Accept-Encoding   | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt; |
   | Accept-Language   | &lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt; |
   +-------------------+---------------+</source>
          <target state="translated">Следующие поля заголовка запроса отправляются пользовательским агентом для упреждающего согласования содержимого ответа, как определено в &lt;a href=&quot;#section-3.4.1&quot;&gt;разделе 3.4.1&lt;/a&gt; . Предпочтения, отправленные в этих полях, применяются к любому содержимому в ответе, включая представления целевого ресурса, представления ошибок или состояния обработки и, возможно, даже разные текстовые строки, которые могут появиться в протоколе. + ------------------- + --------------- + | Имя поля заголовка | Определено в ... | + ------------------- + --------------- + | Принять | &lt;a href=&quot;#section-5.3.2&quot;&gt;Раздел 5.3.2&lt;/a&gt; | | Accept-Charset | &lt;a href=&quot;#section-5.3.3&quot;&gt;Раздел 5.3.3&lt;/a&gt; | | Принять-кодирование | &lt;a href=&quot;#section-5.3.4&quot;&gt;Раздел 5.3.4&lt;/a&gt; | | Accept-Language | &lt;a href=&quot;#section-5.3.5&quot;&gt;Раздел 5.3.5&lt;/a&gt;| + ------------------- + --------------- +</target>
        </trans-unit>
        <trans-unit id="b87d45a3e8d029bf68f7eb8d73ed362bd6af38eb" translate="yes" xml:space="preserve">
          <source>The following request header fields provide additional information
   about the request context, including information about the user, user
   agent, and resource behind the request.

   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | From              | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt; |
   | Referer           | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; |
   | User-Agent        | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt; |
   +-------------------+---------------+</source>
          <target state="translated">Следующие поля заголовка запроса предоставляют дополнительную информацию о контексте запроса, включая информацию о пользователе, пользовательском агенте и ресурсе, стоящем за запросом. + ------------------- + --------------- + | Имя поля заголовка | Определено в ... | + ------------------- + --------------- + | От | &lt;a href=&quot;#section-5.5.1&quot;&gt;Раздел 5.5.1&lt;/a&gt; | | Referer | &lt;a href=&quot;#section-5.5.2&quot;&gt;Раздел 5.5.2&lt;/a&gt; | | User-Agent | &lt;a href=&quot;#section-5.5.3&quot;&gt;Раздел 5.5.3&lt;/a&gt; | + ------------------- + --------------- +</target>
        </trans-unit>
        <trans-unit id="0c838a2a126c25c04d28baea5afb318e21afbddd" translate="yes" xml:space="preserve">
          <source>The following rules are used throughout this specification to
   describe basic parsing constructs. The US-ASCII coded character set
   is defined by ANSI X3.4-1986 [&lt;a href=&quot;#ref-21&quot;&gt;21&lt;/a&gt;]. 

       OCTET          = &amp;lt;any 8-bit sequence of data&amp;gt;
       CHAR           = &amp;lt;any US-ASCII character (octets 0 - 127)&amp;gt;
       UPALPHA        = &amp;lt;any US-ASCII uppercase letter &quot;A&quot;..&quot;Z&quot;&amp;gt;
       LOALPHA        = &amp;lt;any US-ASCII lowercase letter &quot;a&quot;..&quot;z&quot;&amp;gt;
       ALPHA          = UPALPHA | LOALPHA
       DIGIT          = &amp;lt;any US-ASCII digit &quot;0&quot;..&quot;9&quot;&amp;gt;
       CTL            = &amp;lt;any US-ASCII control character
                        (octets 0 - 31) and DEL (127)&amp;gt;
       CR             = &amp;lt;US-ASCII CR, carriage return (13)&amp;gt;
       LF             = &amp;lt;US-ASCII LF, linefeed (10)&amp;gt;
       SP             = &amp;lt;US-ASCII SP, space (32)&amp;gt;
       HT             = &amp;lt;US-ASCII HT, horizontal-tab (9)&amp;gt;
       &amp;lt;&quot;&amp;gt;            = &amp;lt;US-ASCII double-quote mark (34)&amp;gt;

   HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all
   protocol elements except the entity-body (see appendix 19.3 for
   tolerant applications). The end-of-line marker within an entity-body
   is defined by its associated media type, as described in &lt;a href=&quot;#section-3.7&quot;&gt;section 3.7&lt;/a&gt;.

       CRLF           = CR LF

   HTTP/1.1 header field values can be folded onto multiple lines if the
   continuation line begins with a space or horizontal tab. All linear
   white space, including folding, has the same semantics as SP. A
   recipient MAY replace any linear white space with a single SP before
   interpreting the field value or forwarding the message downstream.

       LWS            = [CRLF] 1*( SP | HT )

   The TEXT rule is only used for descriptive field contents and values
   that are not intended to be interpreted by the message parser. Words
   of *TEXT MAY contain characters from character sets other than ISO-
   8859-1 [&lt;a href=&quot;#ref-22&quot;&gt;22&lt;/a&gt;] only when encoded according to the rules of &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;
   [&lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;].

       TEXT           = &amp;lt;any OCTET except CTLs,
                        but including LWS&amp;gt;

   A CRLF is allowed in the definition of TEXT only as part of a header
   field continuation. It is expected that the folding LWS will be
   replaced with a single SP before interpretation of the TEXT value.

   Hexadecimal numeric characters are used in several protocol elements.

       HEX            = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot;
                      | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | DIGIT 

   Many HTTP/1.1 header field values consist of words separated by LWS
   or special characters. These special characters MUST be in a quoted
   string to be used within a parameter value (as defined in &lt;a href=&quot;#section-3.6&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt;).

       token          = 1*&amp;lt;any CHAR except CTLs or separators&amp;gt;
       separators     = &quot;(&quot; | &quot;)&quot; | &quot;&amp;lt;&quot; | &quot;&amp;gt;&quot; | &quot;@&quot;
                      | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &amp;lt;&quot;&amp;gt;
                      | &quot;/&quot; | &quot;[&quot; | &quot;]&quot; | &quot;?&quot; | &quot;=&quot;
                      | &quot;{&quot; | &quot;}&quot; | SP | HT

   Comments can be included in some HTTP header fields by surrounding
   the comment text with parentheses. Comments are only allowed in
   fields containing &quot;comment&quot; as part of their field value definition.
   In all other fields, parentheses are considered part of the field
   value.

       comment        = &quot;(&quot; *( ctext | quoted-pair | comment ) &quot;)&quot;
       ctext          = &amp;lt;any TEXT excluding &quot;(&quot; and &quot;)&quot;&amp;gt;

   A string of text is parsed as a single word if it is quoted using
   double-quote marks.

       quoted-string  = ( &amp;lt;&quot;&amp;gt; *(qdtext | quoted-pair ) &amp;lt;&quot;&amp;gt; )
       qdtext         = &amp;lt;any TEXT except &amp;lt;&quot;&amp;gt;&amp;gt;

   The backslash character (&quot;\&quot;) MAY be used as a single-character
   quoting mechanism only within quoted-string and comment constructs.

       quoted-pair    = &quot;\&quot; CHAR</source>
          <target state="translated">Следующие правила используются в этой спецификации для описания основных конструкций синтаксического анализа. Набор символов US-ASCII определяется ANSI X3.4-1986 [ &lt;a href=&quot;#ref-21&quot;&gt;21&lt;/a&gt;]. OCTET = &amp;lt;любая 8-битная последовательность данных&amp;gt; CHAR = &amp;lt;любой символ US-ASCII (октеты 0&amp;ndash;127)&amp;gt; UPALPHA = &amp;lt;любая заглавная буква US-ASCII &amp;laquo;A&amp;raquo; .. &amp;laquo;Z&amp;raquo;&amp;gt; LOALPHA = &amp;lt;любой US- Строчная буква ASCII &quot;a&quot; .. &quot;z&quot;&amp;gt; ALPHA = UPALPHA | LOALPHA DIGIT = &amp;lt;любая цифра US-ASCII &quot;0&quot; .. &quot;9&quot;&amp;gt; CTL = &amp;lt;любой управляющий символ US-ASCII (октеты 0&amp;ndash;31) и DEL (127)&amp;gt; CR = &amp;lt;US-ASCII CR, возврат каретки ( 13)&amp;gt; LF = &amp;lt;US-ASCII LF, перевод строки (10)&amp;gt; SP = &amp;lt;US-ASCII SP, пробел (32)&amp;gt; HT = &amp;lt;US-ASCII HT, горизонтальная табуляция (9)&amp;gt; &amp;lt;&quot;&amp;gt; = &amp;lt;Знак двойной кавычки US-ASCII (34)&amp;gt; HTTP / 1.1 определяет последовательность CR LF как маркер конца строки для всех элементов протокола, кроме тела объекта (см. Приложение 19.3 для терпимых приложений). Маркер конца строки в теле объекта определяется связанным с ним типом носителя, как описано в&lt;a href=&quot;#section-3.7&quot;&gt;раздел 3.7&lt;/a&gt; . CRLF = CR LF Значения поля заголовка HTTP / 1.1 могут быть разделены на несколько строк, если строка продолжения начинается с пробела или горизонтальной табуляции. Все линейные пробелы, включая сворачивание, имеют ту же семантику, что и SP. Получатель МОЖЕТ заменить любой линейный пробел одним SP перед интерпретацией значения поля или пересылкой сообщения в нисходящем направлении. LWS = [CRLF] 1 * (SP | HT) Правило TEXT используется только для описательного содержимого полей и значений, которые не предназначены для интерпретации анализатором сообщений. Слова * TEXT МОГУТ содержать символы из наборов символов, отличных от ISO-8859-1 [ &lt;a href=&quot;#ref-22&quot;&gt;22&lt;/a&gt; ], только при кодировании в соответствии с правилами &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [ &lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;]. ТЕКСТ = &amp;lt;любой октет, кроме CTL, но включая LWS&amp;gt; CRLF разрешен в определении ТЕКСТА только как часть продолжения поля заголовка. Ожидается, что сворачивающийся LWS будет заменен одним SP перед интерпретацией значения TEXT. Шестнадцатеричные цифровые символы используются в нескольких элементах протокола. HEX = &quot;A&quot; | &amp;laquo;Б&amp;raquo; | &quot;C&quot; | &amp;laquo;Д&amp;raquo; | &quot;E&quot; | &quot;F&quot; | &quot;а&quot; | &quot;б&quot; | &quot;с&quot; | &quot;д&quot; | &quot;е&quot; | &quot;е&quot; | ЦИФРА Многие значения полей заголовка HTTP / 1.1 состоят из слов, разделенных LWS или специальными символами.Эти специальные символы ДОЛЖНЫ быть в строке в кавычках для использования в значении параметра (как определено в &lt;a href=&quot;#section-3.6&quot;&gt;разделе &lt;/a&gt;&lt;a href=&quot;#section-3.6&quot;&gt;3.6.&lt;/a&gt;). token = 1 * &amp;lt;любой СИМВОЛ, кроме CTL или разделителей&amp;gt; separators = &quot;(&quot; | &quot;)&quot; | &quot;&amp;lt;&quot; | &quot;&amp;gt;&quot; | &quot;@&quot; | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &amp;lt;&quot;&amp;gt; |&quot; / &quot;|&quot; [&quot;|&quot;] &quot;|&quot;? &quot;|&quot; = &quot;|&quot; {&quot;|&quot;} &quot;| SP | HT Комментарии могут быть включены в некоторые поля заголовка HTTP, заключив текст комментария в круглые скобки. Комментарии разрешены только в полях, содержащих &quot;комментарий&quot; как часть определения значения поля. Во всех других полях круглые скобки считаются частью значения поля. comment = &quot;(&quot; * (ctext | quoted-pair | comment) &quot; )&amp;raquo;ctext = &amp;lt;любой ТЕКСТ за исключением &quot;(&quot; и &quot;)&quot;&amp;gt; Строка текста анализируется как одно слово, если она заключена в двойные кавычки. quoted-string = (&amp;lt;&quot;&amp;gt; * (qdtext | quoted-pair) &amp;lt;&quot;&amp;gt;) qdtext = &amp;lt;любой ТЕКСТ, кроме &amp;lt;&quot;&amp;gt;&amp;gt; Символ обратной косой черты (&quot; \ &quot;) МОЖЕТ использоваться как односимвольный механизм цитирования только внутри конструкции строки в кавычках и комментариев. quoted-pair = &quot;\&quot; CHAR) МОЖЕТ использоваться как односимвольный механизм цитирования только в конструкциях строки в кавычках и комментариев. quoted-pair = &quot;\&quot; СИМВОЛ) МОЖЕТ использоваться как односимвольный механизм цитирования только в конструкциях строки в кавычках и комментариев. quoted-pair = &quot;\&quot; СИМВОЛ</target>
        </trans-unit>
        <trans-unit id="94fbcc64e65bdd0aa51395bd7a796209855490ba" translate="yes" xml:space="preserve">
          <source>The following sections describe the LOCK method, which is used to
   take out a lock of any access type and to refresh an existing lock.
   These sections on the LOCK method describe only those semantics that
   are specific to the LOCK method and are independent of the access
   type of the lock being requested.

   Any resource that supports the LOCK method MUST, at minimum, support
   the XML request and response formats defined herein.

   This method is neither idempotent nor safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">В следующих разделах описывается метод LOCK, который используется для снятия блокировки любого типа доступа и обновления существующей блокировки. Эти разделы о методе LOCK описывают только ту семантику, которая специфична для метода LOCK и не зависит от типа доступа запрошенной блокировки. Любой ресурс, поддерживающий метод LOCK, ДОЛЖЕН, как минимум, поддерживать форматы запроса и ответа XML, определенные здесь. Этот метод не является ни идемпотентным, ни безопасным (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Раздел 9.1 [RFC2616]&lt;/a&gt; ). Ответы на этот метод НЕ ДОЛЖНЫ кэшироваться.</target>
        </trans-unit>
        <trans-unit id="abeecd90959a6815a68add2040eb84d9caaab598" translate="yes" xml:space="preserve">
          <source>The following status codes are added to those defined in HTTP/1.1
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].</source>
          <target state="translated">Следующие коды состояния добавлены к кодам, определенным в HTTP / 1.1 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="9b6537480c704b017f88ab825b88e92592b9fb1e" translate="yes" xml:space="preserve">
          <source>The following table summarizes the way major browser vendors indicate that their browsers are running on a mobile device:</source>
          <target state="translated">В следующей таблице приведена сводная информация о том,как основные производители браузеров указывают,что их браузеры работают на мобильном устройстве:</target>
        </trans-unit>
        <trans-unit id="84d447214f0a07951f17fa8b161dc87650490e95" translate="yes" xml:space="preserve">
          <source>The format for &lt;code&gt;data&lt;/code&gt; URLs is very simple, but it's easy to forget to put a comma before the &quot;data&quot; segment, or to incorrectly encode the data into base64 format.</source>
          <target state="translated">Формат URL-адресов &lt;code&gt;data&lt;/code&gt; очень прост, но легко забыть поставить запятую перед сегментом &amp;laquo;данные&amp;raquo; или неправильно закодировать данные в формате base64.</target>
        </trans-unit>
        <trans-unit id="d7ba8c7d265a4018beb38838d1f5b22bd2735b93" translate="yes" xml:space="preserve">
          <source>The format problem might be due to the request's indicated &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;, or as a result of inspecting the data directly.</source>
          <target state="translated">Проблема с форматированием может быть связана с указанным в запросе &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../headers/content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt; , или в результате непосредственной проверки данных.</target>
        </trans-unit>
        <trans-unit id="dd102c31666a18bf73247dbe968b9437a20ca82e" translate="yes" xml:space="preserve">
          <source>The forwarded protocol (http or https).</source>
          <target state="translated">Передаваемый протокол (http или https).</target>
        </trans-unit>
        <trans-unit id="5ad0214c4fd4e5e15f5b8411cc3e3ac722291550" translate="yes" xml:space="preserve">
          <source>The framework for HTTP Authentication is now defined by this
   document, rather than &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.

   The &quot;realm&quot; parameter is no longer always required on challenges;
   consequently, the ABNF allows challenges without any auth parameters.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   The &quot;token68&quot; alternative to auth-param lists has been added for
   consistency with legacy authentication schemes such as &quot;Basic&quot;.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   This specification introduces the Authentication Scheme Registry,
   along with considerations for new authentication schemes.
   (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;)</source>
          <target state="translated">Структура HTTP-аутентификации теперь определяется этим документом, а не &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt; . Параметр &amp;laquo;realm&amp;raquo; больше не всегда требуется для вызовов; следовательно, ABNF разрешает вызовы без каких-либо параметров аутентификации. ( &lt;a href=&quot;#section-2&quot;&gt;Раздел 2&lt;/a&gt; ) Альтернатива &amp;laquo;token68&amp;raquo; спискам auth-param была добавлена ​​для согласованности с устаревшими схемами аутентификации, такими как &amp;laquo;Базовая&amp;raquo;. ( &lt;a href=&quot;#section-2&quot;&gt;Раздел 2&lt;/a&gt; ) Эта спецификация представляет реестр схемы аутентификации, а также рекомендации по новым схемам аутентификации. ( &lt;a href=&quot;#section-5.1&quot;&gt;Раздел 5.1&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e81a90a6f49982e97eba3c1cef4effa451cb6b9f" translate="yes" xml:space="preserve">
          <source>The freshness lifetime is calculated based on several headers. If a &quot;&lt;code&gt;Cache-control: max-age=N&lt;/code&gt;&quot; header is specified, then the freshness lifetime is equal to N. If this header is not present, which is very often the case, it is checked if an &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header is present. If an &lt;code&gt;Expires&lt;/code&gt; header exists, then its value minus the value of the &lt;a href=&quot;headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; header determines the freshness lifetime. Finally, if neither header is present, look for a &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; header. If this header is present, then the cache's freshness lifetime is equal to the value of the &lt;code&gt;Date&lt;/code&gt; header minus the value of the &lt;code&gt;Last-modified&lt;/code&gt; header divided by 10.</source>
          <target state="translated">Срок действия свежести рассчитывается на основе нескольких заголовков. Если указан заголовок &amp;laquo; &lt;code&gt;Cache-control: max-age=N&lt;/code&gt; &amp;raquo;, то время жизни свежести равно N. Если этот заголовок отсутствует, что очень часто случается, проверяется наличие заголовка &lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt; . Если заголовок &lt;code&gt;Expires&lt;/code&gt; существует, то его значение за вычетом значения заголовка &lt;a href=&quot;headers/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; определяет срок действия. Наконец, если ни один заголовок отсутствует, ищите заголовок &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; . Если этот заголовок присутствует, то время жизни кеша равно значению заголовка &lt;code&gt;Date&lt;/code&gt; минус значение заголовка &lt;code&gt;Last-modified&lt;/code&gt; , деленное на 10.</target>
        </trans-unit>
        <trans-unit id="512b0319b59cba71ca1e2c65af451cb82702e739" translate="yes" xml:space="preserve">
          <source>The general HTTP authentication framework</source>
          <target state="translated">Общий фреймворк HTTP-аутентификации</target>
        </trans-unit>
        <trans-unit id="2a68383800c3c6e98cc63558c863f3f6c90c1d56" translate="yes" xml:space="preserve">
          <source>The general HTTP authentication framework is used by several authentication schemes. Schemes can differ in security strength and in their availability in client or server software.</source>
          <target state="translated">Общий фреймворк HTTP-аутентификации используется несколькими схемами аутентификации.Схемы могут различаться по степени защищенности и доступности в клиентском или серверном программном обеспечении.</target>
        </trans-unit>
        <trans-unit id="047e5f84cba0657a76fe5fac248fc74bc7cb3a90" translate="yes" xml:space="preserve">
          <source>The general principle is that there should be an intuitive or non-breaking way for web developers to detect or handle the case when the feature is disabled. Newly introduced features may have an explicit API to signal the state. Existing features that later integrate with Feature Policy will typically use existing mechanisms. Some approaches include:</source>
          <target state="translated">Общий принцип заключается в том,что веб-разработчики должны иметь интуитивный или неразрушающий способ обнаружить или обработать случай,когда функция отключена.Вновь введенные функции могут иметь явный API для сигнализации состояния.Существующие функции,которые позже интегрируются с Feature Policy,обычно используют существующие механизмы.Некоторые подходы включают в себя:</target>
        </trans-unit>
        <trans-unit id="4082c3c3add497840e14f2e91b541fe68c6e3568" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;lang&lt;/a&gt;&lt;/code&gt; attribute is used on HTML elements to indicate the language of an entire &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt; document or parts of it.</source>
          <target state="translated">Атрибут global &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;lang&lt;/a&gt;&lt;/code&gt; используется в элементах HTML, чтобы указать язык всего документа &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt; или его частей.</target>
        </trans-unit>
        <trans-unit id="57f2be6c87684acab7e795f4366c55ff9f31e0e7" translate="yes" xml:space="preserve">
          <source>The hostname extracted from the URL. This is only for convenience; it is the same string as between :// and the first : or / after that. The port number is not included in this parameter. It can be extracted from the URL when necessary.</source>
          <target state="translated">Имя хоста,извлеченное из URL.Это только для удобства;это та же самая строка,что и между ://и первым:или/после этого.Номер порта не включен в этот параметр.Он может быть извлечен из URL при необходимости.</target>
        </trans-unit>
        <trans-unit id="d6b2c30b24be1ada27dc38a1f58fce4304459396" translate="yes" xml:space="preserve">
          <source>The hostname from the URL (excluding port number).</source>
          <target state="translated">Имя хоста с URL (за исключением номера порта).</target>
        </trans-unit>
        <trans-unit id="e2ca20155497fac3b42eb54e6e58c4e5f8398358" translate="yes" xml:space="preserve">
          <source>The hostname from the URL.</source>
          <target state="translated">Имя хоста из URL.</target>
        </trans-unit>
        <trans-unit id="7bcc834a08945d7f53b90ecdf02df16cd4cbc61a" translate="yes" xml:space="preserve">
          <source>The identity and the location of resources on the Web are mostly given by a single URL (Uniform Resource Locator, a kind of URI). There are sometimes reasons identity and location are not given by the same URI: HTTP uses a specific HTTP header, &lt;a href=&quot;../headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; when the resource requested wants the client to access it at another location.</source>
          <target state="translated">Идентификационные данные и расположение ресурсов в Интернете в большинстве случаев задаются одним URL-адресом (унифицированный указатель ресурсов, своего рода URI). Иногда есть причины, по которым идентичность и местоположение не задаются одним и тем же URI: HTTP использует определенный HTTP-заголовок, &lt;a href=&quot;../headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; ,&lt;/a&gt; когда запрашиваемый ресурс хочет, чтобы клиент получил доступ к нему в другом месте.</target>
        </trans-unit>
        <trans-unit id="c1e67e8b2786357d4a6663a2bc15f636eb756e8f" translate="yes" xml:space="preserve">
          <source>The iframe allow attribute</source>
          <target state="translated">Атрибут iframe allow</target>
        </trans-unit>
        <trans-unit id="651815c795a02ba38593f0882335db6d832e2b91" translate="yes" xml:space="preserve">
          <source>The implementation of this prefetching in some browsers allows domain name resolution to occur in parallel with (instead of in serial with) the fetching of actual page content. By doing this, the high-latency domain name resolution process doesn't cause any delay while fetching content.</source>
          <target state="translated">Реализация такой предварительной выборки в некоторых браузерах позволяет осуществлять выборку доменного имени параллельно с (а не последовательно с)выборкой фактического содержимого страницы.Благодаря этому процесс разрешения доменных имен с высокой задержкой не вызывает задержек при получении контента.</target>
        </trans-unit>
        <trans-unit id="37f7cdd7fd1331a83928f974ca15680ae3b0af4f" translate="yes" xml:space="preserve">
          <source>The inclusion of the &quot;app:draft&quot; element represents a request by the
   client to control the visibility of a Member Resource.  The app:draft
   element MAY be ignored by the server.

   The number of app:draft elements in app:control MUST be zero or one.
   The content of an app:draft element MUST be one of &quot;yes&quot; or &quot;no&quot;.  If
   the element contains &quot;no&quot;, this indicates a client request that the
   Member Resource be made publicly visible.  If the app:draft element
   is not present, then servers that support the extension MUST behave
   as though an app:draft element containing &quot;no&quot; was sent.</source>
          <target state="translated">Включение элемента &quot;app:draft&quot; представляет собой просьбу клиента контролировать наглядность ресурса члена.Элемент app:draft МОЖЕТ быть проигнорирован сервером.Количество элементов app:draft в приложении:control ДОЛЖНО быть равным нулю или единице.Содержимое элемента app:draft ДОЛЖНО быть одним из &quot;да&quot; или &quot;нет&quot;.Если элемент содержит &quot;нет&quot;,то это указывает на запрос клиента о том,чтобы Ресурс-участник стал общедоступным.Если элемент app:draft отсутствует,то серверы,поддерживающие расширение,ДОЛЖНЫ вести себя так,как будто был отправлен элемент app:draft,содержащий &quot;нет&quot;.</target>
        </trans-unit>
        <trans-unit id="ff9cab94e579758912dbc34c45bff0d14c466bcf" translate="yes" xml:space="preserve">
          <source>The information below has been pulled from MDN's GitHub (&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;).</source>
          <target state="translated">Приведенная ниже информация была взята из GitHub MDN ( &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="89f19b58853606bc26aa103de926f33f0228de47" translate="yes" xml:space="preserve">
          <source>The information by the client is quite verbose (HTTP/2 header compression mitigates this problem) and a privacy risk (HTTP fingerprinting)</source>
          <target state="translated">Информация,предоставляемая клиентом,довольно многословна (сжатие заголовков HTTP/2 смягчает эту проблему)и представляет собой риск для конфиденциальности (отпечатки пальцев HTTP).</target>
        </trans-unit>
        <trans-unit id="88371e0de52c1ea4ce93bd3a2050533f57795785" translate="yes" xml:space="preserve">
          <source>The information shown below has been pulled from MDN's GitHub (&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;).</source>
          <target state="translated">Информация, показанная ниже, была взята из MDN GitHub ( &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3cf93a0d825024937b080186cbf88ae3afde9002" translate="yes" xml:space="preserve">
          <source>The initial range unit registry contains the registrations below:

   +-------------+---------------------------------------+-------------+
   | Range Unit  | Description                           | Reference   |
   | Name        |                                       |             |
   +-------------+---------------------------------------+-------------+
   | bytes       | a range of octets                     | &lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt; |
   | none        | reserved as keyword, indicating no    | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   |             | ranges are supported                  |             |
   +-------------+---------------------------------------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">Реестр единиц начального диапазона содержит следующие регистрации: + ------------- + ------------------------- -------------- + ------------- + | Единица измерения | Описание | Справка | | Имя | | | + ------------- + ----------------------------------- ---- + ------------- + | байты | диапазон октетов | &lt;a href=&quot;#section-2.1&quot;&gt;Раздел 2.1&lt;/a&gt; | | нет | зарезервировано как ключевое слово, указывающее нет | &lt;a href=&quot;#section-2.3&quot;&gt;Раздел 2.3&lt;/a&gt; | | | поддерживаются диапазоны | | + ------------- + ----------------------------------- ---- + ------------- + Контроллер изменений: &amp;laquo;IETF (iesg@ietf.org) - Инженерная группа Интернета&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ebd17564840526ee148efdaf203fca839e5379a4" translate="yes" xml:space="preserve">
          <source>The initial version of HTTP had no version number; it has been later called 0.9 to differentiate it from the later versions. HTTP/0.9 is extremely simple: requests consist of a single line and start with the only possible method &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; followed by the path to the resource (not the URL as both the protocol, server, and port are unnecessary once connected to the server).</source>
          <target state="translated">Первоначальная версия HTTP не имела номера версии; Позже он был назван 0.9, чтобы отличить его от более поздних версий. HTTP / 0.9 чрезвычайно прост: запросы состоят из одной строки и начинаются с единственного возможного метода &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; ,&lt;/a&gt; за которым следует путь к ресурсу (не URL-адрес, поскольку и протокол, и сервер, и порт не нужны после подключения к серверу).</target>
        </trans-unit>
        <trans-unit id="aa546185419767d20a05e2cb4df36ea1b19d66d3" translate="yes" xml:space="preserve">
          <source>The interface where the request came in to the proxy server.</source>
          <target state="translated">Интерфейс,через который запрос поступал на прокси-сервер.</target>
        </trans-unit>
        <trans-unit id="7c3952a320aa0697f4c57ed16e077bfea2eed9ae" translate="yes" xml:space="preserve">
          <source>The introduction of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Client-Hints&quot;&gt;&lt;code&gt;Client-Hints&lt;/code&gt;&lt;/a&gt; allows the browser, or client, to proactively communicate information about its requirements, or hardware constraints, to the server.</source>
          <target state="translated">Внедрение &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Client-Hints&quot;&gt; &lt;code&gt;Client-Hints&lt;/code&gt; &lt;/a&gt; позволяет браузеру или клиенту заранее сообщать серверу информацию о своих требованиях или аппаратных ограничениях.</target>
        </trans-unit>
        <trans-unit id="b38d9075a389a16460fcd684d2635f8653d50eed" translate="yes" xml:space="preserve">
          <source>The introduction of security-related prefixes in the &lt;a href=&quot;../headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header, now helps guarantee a secure cookie has not been altered.</source>
          <target state="translated">Введение префиксов , связанных с безопасностью в &lt;a href=&quot;../headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; заголовка, теперь помогает гарантировать безопасное печенье не было изменено.</target>
        </trans-unit>
        <trans-unit id="5e730b1eec3af5f9a050a8a9662df02e4c7599c2" translate="yes" xml:space="preserve">
          <source>The issued request looks like this:</source>
          <target state="translated">Выданный запрос выглядит так:</target>
        </trans-unit>
        <trans-unit id="c84804fc4afa331bf0f09b76ea2770dfd6b62155" translate="yes" xml:space="preserve">
          <source>The key for this request to upgrade. The client adds this if it wishes to do so, and the server will include in the response a key of its own, which the client will validate before delivering the upgrade response to you.</source>
          <target state="translated">Ключ к этому запросу на обновление.Клиент добавляет его,если он этого пожелает,и сервер включит в ответ свой ключ,который клиент проверит перед тем,как доставить вам ответ об апгрейде.</target>
        </trans-unit>
        <trans-unit id="9a15e6847a0ff9b62775caf043875cd4c43edfc3" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [&lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt;].

   An implementation is not compliant if it fails to satisfy one or more
   of the MUST or REQUIRED level requirements for the protocols it
   implements. An implementation that satisfies all the MUST or REQUIRED
   level and all the SHOULD level requirements for its protocols is said
   to be &quot;unconditionally compliant&quot;; one that satisfies all the MUST
   level requirements but not all the SHOULD level requirements for its
   protocols is said to be &quot;conditionally compliant.&quot;</source>
          <target state="translated">Ключевые слова &amp;laquo;ДОЛЖЕН&amp;raquo;, &amp;laquo;НЕ ДОЛЖЕН&amp;raquo;, &amp;laquo;ОБЯЗАТЕЛЬНО&amp;raquo;, &amp;laquo;ДОЛЖЕН&amp;raquo;, &amp;laquo;НЕ ДОЛЖЕН&amp;raquo;, &amp;laquo;ДОЛЖЕН&amp;raquo;, &amp;laquo;НЕ ДОЛЖЕН&amp;raquo;, &amp;laquo;РЕКОМЕНДУЕТСЯ&amp;raquo;, &amp;laquo;МОЖЕТ&amp;raquo; и &amp;laquo;ДОПОЛНИТЕЛЬНО&amp;raquo; в этом документе являются следует интерпретировать, как описано в &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [ &lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt; ]. Реализация не соответствует требованиям, если она не удовлетворяет одному или нескольким требованиям уровня ОБЯЗАТЕЛЬНО или ТРЕБУЕТСЯ для протоколов, которые она реализует. Реализация, которая удовлетворяет всем ОБЯЗАТЕЛЬНЫМ или ТРЕБУЕМЫМ уровням и всем требованиям ДОЛЖНО к уровню своих протоколов, называется &quot;безусловно соответствующей&quot;; тот, который удовлетворяет всем требованиям уровня ДОЛЖЕН, но не всем требованиям уровня ДОЛЖЕН для его протоколов, называется &quot;условно совместимым&quot;.</target>
        </trans-unit>
        <trans-unit id="9a4a2293d2f84b8a5fd8f2e4def5c748288282ce" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].</source>
          <target state="translated">Ключевые слова &amp;laquo;ДОЛЖЕН&amp;raquo;, &amp;laquo;НЕ ДОЛЖЕН&amp;raquo;, &amp;laquo;ОБЯЗАТЕЛЬНО&amp;raquo;, &amp;laquo;ДОЛЖЕН&amp;raquo;, &amp;laquo;НЕ ДОЛЖЕН&amp;raquo;, &amp;laquo;ДОЛЖЕН&amp;raquo;, &amp;laquo;НЕ ДОЛЖЕН&amp;raquo;, &amp;laquo;РЕКОМЕНДУЕТСЯ&amp;raquo;, &amp;laquo;МОЖЕТ&amp;raquo; и &amp;laquo;ДОПОЛНИТЕЛЬНО&amp;raquo; в этом документе являются следует интерпретировать, как описано в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="f9eac2de940bf2c082a5aa542b14155a2665a0ba" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   Conformance criteria and considerations regarding error handling are
   defined in &lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;.</source>
          <target state="translated">Ключевые слова &amp;laquo;ДОЛЖЕН&amp;raquo;, &amp;laquo;НЕ ДОЛЖЕН&amp;raquo;, &amp;laquo;ОБЯЗАТЕЛЬНО&amp;raquo;, &amp;laquo;ДОЛЖЕН&amp;raquo;, &amp;laquo;НЕ ДОЛЖЕН&amp;raquo;, &amp;laquo;ДОЛЖЕН&amp;raquo;, &amp;laquo;НЕ ДОЛЖЕН&amp;raquo;, &amp;laquo;РЕКОМЕНДУЕТСЯ&amp;raquo;, &amp;laquo;МОЖЕТ&amp;raquo; и &amp;laquo;ДОПОЛНИТЕЛЬНО&amp;raquo; в этом документе являются следует интерпретировать, как описано в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt; ]. Критерии соответствия и соображения относительно обработки ошибок определены в &lt;a href=&quot;#section-2.5&quot;&gt;разделе 2.5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a63eeb5f4d9a57b187d7fb929309ed70bf0dbac" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   Conformance criteria and considerations regarding error handling are
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.5&quot;&gt;Section&amp;nbsp;2.5 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">Ключевые слова &amp;laquo;ДОЛЖЕН&amp;raquo;, &amp;laquo;НЕ ДОЛЖЕН&amp;raquo;, &amp;laquo;ОБЯЗАТЕЛЬНО&amp;raquo;, &amp;laquo;ДОЛЖЕН&amp;raquo;, &amp;laquo;НЕ ДОЛЖЕН&amp;raquo;, &amp;laquo;ДОЛЖЕН&amp;raquo;, &amp;laquo;НЕ ДОЛЖЕН&amp;raquo;, &amp;laquo;РЕКОМЕНДУЕТСЯ&amp;raquo;, &amp;laquo;МОЖЕТ&amp;raquo; и &amp;laquo;ДОПОЛНИТЕЛЬНО&amp;raquo; в этом документе являются следует интерпретировать, как описано в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt; ]. Критерии соответствия и соображения относительно обработки ошибок определены в &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.5&quot;&gt;разделе 2.5 [RFC7230]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb75c6ee1cca0ad36d986b0e355cb0e843e6e2f2" translate="yes" xml:space="preserve">
          <source>The kind of validation is independent of the validator used. Both &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; allow both types of validation, though the complexity to implement it on the server side may vary. HTTP uses strong validation by default, and it specifies when weak validation can be used.</source>
          <target state="translated">Тип проверки не зависит от используемого валидатора. И &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; ,&lt;/a&gt; и &lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; допускают оба типа проверки, хотя сложность ее реализации на стороне сервера может различаться. HTTP по умолчанию использует строгую проверку и указывает, когда можно использовать слабую проверку.</target>
        </trans-unit>
        <trans-unit id="d08a92729e395511c2581a4dfc33791c98b63230" translate="yes" xml:space="preserve">
          <source>The largest change that happened to HTTP was done as early as end of 1994. Instead of sending HTTP over a basic TCP/IP stack, Netscape Communication created an additional encrypted transmission layer on top of it: SSL. SSL 1.0 was never released outside the companies, but SSL 2.0 and its successors SSL 3.0 and SSL 3.1 allowed for the creation of e-commerce Web sites by encrypting and guaranteeing the authenticity of the messages exchanged between the server and client. SSL was put on the standards track and eventually became TLS, with version 1.0, 1.1, and 1.2 appearing successfully to close vulnerabilities. TLS 1.3 is currently in the making.</source>
          <target state="translated">Самое большое изменение,которое произошло с HTTP,было сделано еще в конце 1994 года.Вместо отправки HTTP через базовый стек TCP/IP,Netscape Communication создала поверх него дополнительный зашифрованный уровень передачи:SSL.SSL 1.0 никогда не выпускался за пределами компаний,но SSL 2.0 и его преемники SSL 3.0 и SSL 3.1 позволяли создавать веб-сайты электронной коммерции путем шифрования и гарантирования подлинности сообщений,которыми обменивались сервер и клиент.SSL был поставлен на стандартный путь и со временем стал TLS,с версиями 1.0,1.1 и 1.2,успешно закрывающими уязвимости.В настоящее время TLS 1.3 находится в разработке.</target>
        </trans-unit>
        <trans-unit id="d01d212bb5fa98e344dced612706d97e4c48d614" translate="yes" xml:space="preserve">
          <source>The last part of a response is the body. Not all responses have one: responses with a status code, like &lt;a href=&quot;status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;, usually don't.</source>
          <target state="translated">Последняя часть ответа - это тело. Не во всех ответах он есть: ответы с кодом состояния, например &lt;a href=&quot;status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt; , обычно его нет.</target>
        </trans-unit>
        <trans-unit id="13fd2da68ff6f625ec41f864542e44b06721f081" translate="yes" xml:space="preserve">
          <source>The length in decimal number of octets.</source>
          <target state="translated">Длина в десятичном числе октетов.</target>
        </trans-unit>
        <trans-unit id="fc5fa9bc684bf265ecd239fcfb6b1be61af94a10" translate="yes" xml:space="preserve">
          <source>The length of a message body is determined by one of the following
   (in order of precedence):

   1.  Any response to a HEAD request and any response with a 1xx
       (Informational), 204 (No Content), or 304 (Not Modified) status
       code is always terminated by the first empty line after the
       header fields, regardless of the header fields present in the
       message, and thus cannot contain a message body.

   2.  Any 2xx (Successful) response to a CONNECT request implies that
       the connection will become a tunnel immediately after the empty
       line that concludes the header fields.  A client MUST ignore any
       Content-Length or Transfer-Encoding header fields received in
       such a message.

   3.  If a Transfer-Encoding header field is present and the chunked
       transfer coding (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) is the final encoding, the message
       body length is determined by reading and decoding the chunked
       data until the transfer coding indicates the data is complete.

       If a Transfer-Encoding header field is present in a response and
       the chunked transfer coding is not the final encoding, the
       message body length is determined by reading the connection until
       it is closed by the server.  If a Transfer-Encoding header field
       is present in a request and the chunked transfer coding is not
       the final encoding, the message body length cannot be determined
       reliably; the server MUST respond with the 400 (Bad Request)
       status code and then close the connection.

       If a message is received with both a Transfer-Encoding and a
       Content-Length header field, the Transfer-Encoding overrides the
       Content-Length.  Such a message might indicate an attempt to
       perform request smuggling (&lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;) or response splitting
       (&lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt;) and ought to be handled as an error.  A sender MUST
       remove the received Content-Length field prior to forwarding such
       a message downstream.

   4.  If a message is received without Transfer-Encoding and with
       either multiple Content-Length header fields having differing
       field-values or a single Content-Length header field having an
       invalid value, then the message framing is invalid and the
       recipient MUST treat it as an unrecoverable error.  If this is a
       request message, the server MUST respond with a 400 (Bad Request)
       status code and then close the connection.  If this is a response
       message received by a proxy, the proxy MUST close the connection
       to the server, discard the received response, and send a 502 (Bad 

       Gateway) response to the client.  If this is a response message
       received by a user agent, the user agent MUST close the
       connection to the server and discard the received response.

   5.  If a valid Content-Length header field is present without
       Transfer-Encoding, its decimal value defines the expected message
       body length in octets.  If the sender closes the connection or
       the recipient times out before the indicated number of octets are
       received, the recipient MUST consider the message to be
       incomplete and close the connection.

   6.  If this is a request message and none of the above are true, then
       the message body length is zero (no message body is present).

   7.  Otherwise, this is a response message without a declared message
       body length, so the message body length is determined by the
       number of octets received prior to the server closing the
       connection.

   Since there is no way to distinguish a successfully completed,
   close-delimited message from a partially received message interrupted
   by network failure, a server SHOULD generate encoding or
   length-delimited messages whenever possible.  The close-delimiting
   feature exists primarily for backwards compatibility with HTTP/1.0.

   A server MAY reject a request that contains a message body but not a
   Content-Length by responding with 411 (Length Required).

   Unless a transfer coding other than chunked has been applied, a
   client that sends a request containing a message body SHOULD use a
   valid Content-Length header field if the message body length is known
   in advance, rather than the chunked transfer coding, since some
   existing services respond to chunked with a 411 (Length Required)
   status code even though they understand the chunked transfer coding.
   This is typically because such services are implemented via a gateway
   that requires a content-length in advance of being called and the
   server is unable or unwilling to buffer the entire request before
   processing.

   A user agent that sends a request containing a message body MUST send
   a valid Content-Length header field if it does not know the server
   will handle HTTP/1.1 (or later) requests; such knowledge can be in
   the form of specific user configuration or by remembering the version
   of a prior received response.

   If the final response to the last request on a connection has been
   completely received and there remains additional data to read, a user
   agent MAY discard the remaining data or attempt to determine if that 

   data belongs as part of the prior response body, which might be the
   case if the prior message's Content-Length value is incorrect.  A
   client MUST NOT process, cache, or forward such extra data as a
   separate response, since such behavior would be vulnerable to cache
   poisoning.</source>
          <target state="translated">Длина тела сообщения определяется одним из следующих факторов (в порядке приоритета): 1. Любой ответ на запрос HEAD и любой ответ с 1xx (информационный), 204 (без содержимого) или 304 (без изменений) код состояния всегда заканчивается первой пустой строкой после полей заголовка, независимо от полей заголовка, присутствующих в сообщении, и поэтому не может содержать тело сообщения. 2. Любой ответ 2xx (Успешный) на запрос CONNECT означает, что соединение станет туннелем сразу после пустой строки, завершающей поля заголовка. Клиент ДОЛЖЕН игнорировать любые поля заголовка Content-Length или Transfer-Encoding, полученные в таком сообщении. 3. Если поле заголовка Transfer-Encoding присутствует и фрагментированное кодирование передачи (&lt;a href=&quot;#section-4.1&quot;&gt;Раздел 4.1&lt;/a&gt;) является окончательным кодированием, длина тела сообщения определяется путем чтения и декодирования фрагментированных данных до тех пор, пока кодирование передачи не покажет, что данные завершены. Если в ответе присутствует поле заголовка Transfer-Encoding, а кодирование передачи по частям не является окончательной кодировкой, длина тела сообщения определяется путем чтения соединения до тех пор, пока оно не будет закрыто сервером. Если в запросе присутствует поле заголовка Transfer-Encoding, а фрагментированное кодирование передачи не является окончательным кодированием, длина тела сообщения не может быть надежно определена; сервер ДОЛЖЕН ответить кодом состояния 400 (неверный запрос) и затем закрыть соединение. Если сообщение получено с полями заголовка Transfer-Encoding и Content-Length,Transfer-Encoding имеет приоритет над Content-Length. Такое сообщение может указывать на попытку выполнить контрабанду запроса (&lt;a href=&quot;#section-9.5&quot;&gt;Раздел 9.5&lt;/a&gt; ) или разделение ответа ( &lt;a href=&quot;#section-9.4&quot;&gt;раздел 9.4&lt;/a&gt;) и ее следует обрабатывать как ошибку. Отправитель ДОЛЖЕН удалить полученное поле Content-Length перед пересылкой такого сообщения в нисходящем направлении. 4. Если сообщение получено без Transfer-Encoding и либо с несколькими полями заголовка Content-Length, имеющими разные значения полей, либо с одним полем заголовка Content-Length, имеющим недопустимое значение, то кадрирование сообщения недействительно, и получатель ДОЛЖЕН обработать его. как неисправимую ошибку. Если это сообщение с запросом, сервер ДОЛЖЕН ответить кодом состояния 400 (неверный запрос), а затем закрыть соединение. Если это ответное сообщение, полученное прокси-сервером, прокси-сервер ДОЛЖЕН закрыть соединение с сервером, отбросить полученный ответ и отправить клиенту ответ 502 (Плохой шлюз).Если это ответное сообщение, полученное пользовательским агентом, пользовательский агент ДОЛЖЕН закрыть соединение с сервером и отклонить полученный ответ. 5. Если допустимое поле заголовка Content-Length присутствует без Transfer-Encoding, его десятичное значение определяет ожидаемую длину тела сообщения в октетах. Если отправитель закрывает соединение или время ожидания получателя истекает до того, как будет получено указанное количество октетов, получатель ДОЛЖЕН считать сообщение неполным и закрыть соединение. 6. Если это сообщение с запросом, и ни одно из вышеперечисленных не соответствует действительности, длина тела сообщения равна нулю (тело сообщения отсутствует). 7. В противном случае это ответное сообщение без объявленной длины тела сообщения,поэтому длина тела сообщения определяется количеством октетов, полученных до того, как сервер закрыл соединение. Поскольку нет способа отличить успешно завершенное сообщение с короткими разделителями от частично полученного сообщения, прерванного сетевым отказом, серверу СЛЕДУЕТ генерировать сообщения с кодировкой или с разделителями по длине, когда это возможно. Функция закрытых разделителей существует прежде всего для обратной совместимости с HTTP / 1.0. Сервер МОЖЕТ отклонить запрос, который содержит тело сообщения, но не Content-Length, ответив 411 (требуется длина). Если не было применено кодирование передачи, отличное от фрагментированного, клиент, который отправляет запрос, содержащий тело сообщения, ДОЛЖЕН использовать допустимое поле заголовка Content-Length, если длина тела сообщения известна заранее,а не кодирование передачи по частям, поскольку некоторые существующие службы отвечают на фрагменты кодом состояния 411 (требуется длина), даже если они понимают кодирование передачи по фрагментам. Обычно это происходит из-за того, что такие службы реализуются через шлюз, который требует длины содержимого перед вызовом, и сервер не может или не хочет буферизовать весь запрос перед обработкой. Пользовательский агент, который отправляет запрос, содержащий тело сообщения, ДОЛЖЕН отправить допустимое поле заголовка Content-Length, если он не знает, что сервер будет обрабатывать запросы HTTP / 1.1 (или более поздние); такие знания могут быть в форме конкретной пользовательской конфигурации или путем запоминания версии ранее полученного ответа.Если окончательный ответ на последний запрос о соединении был полностью получен и остались дополнительные данные для чтения, пользовательский агент МОЖЕТ отбросить оставшиеся данные или попытаться определить, принадлежат ли эти данные как часть тела предыдущего ответа, что может быть случай, если значение Content-Length в предыдущем сообщении неверно. Клиент НЕ ДОЛЖЕН обрабатывать, кэшировать или пересылать такие дополнительные данные в качестве отдельного ответа, поскольку такое поведение может быть уязвимо для заражения кеша.так как такое поведение будет уязвимо для заражения кеша.так как такое поведение будет уязвимо для заражения кеша.</target>
        </trans-unit>
        <trans-unit id="de35152ee3c77722bc9537cad929955d73dab593" translate="yes" xml:space="preserve">
          <source>The list of allowed &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;.</source>
          <target state="translated">Список разрешенных &lt;a href=&quot;../methods&quot;&gt;методов HTTP-запроса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15263fb5ed512784dbb85f5e27d3d988105feb1f" translate="yes" xml:space="preserve">
          <source>The maximum lifetime of the cookie as an HTTP-date timestamp. See &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; for the detailed format. If not specified, the cookie will have the lifetime of a &lt;strong&gt;session cookie. &lt;/strong&gt;A session is finished when the client is shut down meaning that session cookies will get removed at that point. However, many web browsers have a feature called session restore that will save all your tabs and have them come back next time you use the browser. Cookies will also be present and it's like you had never actually closed the browser.</source>
          <target state="translated">Максимальное время жизни файла cookie в виде метки времени HTTP-даты. См. Подробный формат в &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; . Если не указан, cookie будет иметь время жизни &lt;strong&gt;cookie сеанса. &lt;/strong&gt;Сеанс завершается, когда клиент завершает работу, что означает, что файлы cookie сеанса будут удалены в этот момент. Однако во многих веб-браузерах есть функция восстановления сеанса, которая сохранит все ваши вкладки и заставит их вернуться в следующий раз, когда вы будете использовать браузер. Файлы cookie также будут присутствовать, и это будет похоже на то, что вы никогда не закрывали браузер.</target>
        </trans-unit>
        <trans-unit id="e63c2c824f245057f299d57750e6b8789678a89a" translate="yes" xml:space="preserve">
          <source>The maximum size supported is 32kB</source>
          <target state="translated">Максимальный поддерживаемый размер-32 кБ</target>
        </trans-unit>
        <trans-unit id="c27432dd9f890b43b972ceef8be06ebeb078000d" translate="yes" xml:space="preserve">
          <source>The maximum size supported is 4GB</source>
          <target state="translated">Максимальный поддерживаемый размер-4 ГБ</target>
        </trans-unit>
        <trans-unit id="6711070acb52353698f99e67ae8f7a23d80cf676" translate="yes" xml:space="preserve">
          <source>The meaning of a success depends on the HTTP request method:</source>
          <target state="translated">Смысл успеха зависит от метода HTTP-запроса:</target>
        </trans-unit>
        <trans-unit id="ed1aebd9e25e31bb79bed64a7c6d90aa83890cf3" translate="yes" xml:space="preserve">
          <source>The media format of the requested data is not supported by the server, so the server is rejecting the request.</source>
          <target state="translated">Формат носителя запрашиваемых данных не поддерживается сервером,поэтому сервер отклоняет запрос.</target>
        </trans-unit>
        <trans-unit id="6d8af46d85f95f2c6776a4511c1248db0db1fa9e" translate="yes" xml:space="preserve">
          <source>The message body (if any) of an HTTP message is used to carry the
   payload body of that request or response.  The message body is
   identical to the payload body unless a transfer coding has been
   applied, as described in &lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;.

     message-body = *OCTET

   The rules for when a message body is allowed in a message differ for
   requests and responses.

   The presence of a message body in a request is signaled by a
   Content-Length or Transfer-Encoding header field.  Request message
   framing is independent of method semantics, even if the method does
   not define any use for a message body.

   The presence of a message body in a response depends on both the
   request method to which it is responding and the response status code
   (&lt;a href=&quot;#section-3.1.2&quot;&gt;Section 3.1.2&lt;/a&gt;).  Responses to the HEAD request method (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2
   of [RFC7231]&lt;/a&gt;) never include a message body because the associated
   response header fields (e.g., Transfer-Encoding, Content-Length,
   etc.), if present, indicate only what their values would have been if
   the request method had been GET (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;Section&amp;nbsp;4.3.1 of [RFC7231]&lt;/a&gt;). 2xx
   (Successful) responses to a CONNECT request method (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;) switch to tunnel mode instead of having a message body.
   All 1xx (Informational), 204 (No Content), and 304 (Not Modified)
   responses do not include a message body.  All other responses do
   include a message body, although the body might be of zero length.</source>
          <target state="translated">Тело сообщения (если есть) HTTP-сообщения используется для передачи тела полезной нагрузки этого запроса или ответа. Тело сообщения идентично телу полезной нагрузки, если не было применено кодирование передачи, как описано в &lt;a href=&quot;#section-3.3.1&quot;&gt;разделе 3.3.1&lt;/a&gt; . message-body = * OCTET Правила, когда в сообщении допускается тело сообщения, различаются для запросов и ответов. Присутствие тела сообщения в запросе сигнализируется полем заголовка Content-Length или Transfer-Encoding. Формирование сообщения запроса не зависит от семантики метода, даже если метод не определяет использование тела сообщения. Наличие тела сообщения в ответе зависит как от метода запроса, на который оно отвечает, так и от кода состояния ответа ( &lt;a href=&quot;#section-3.1.2&quot;&gt;раздел 3.1.2.&lt;/a&gt;). Ответы на метод запроса HEAD ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;раздел 4.3.2 [RFC7231]&lt;/a&gt; ) никогда не включают тело сообщения, потому что связанные поля заголовка ответа (например, Transfer-Encoding, Content-Length и т. Д.), Если присутствуют, указывают только то, что их значения было бы, если бы методом запроса был GET ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;раздел 4.3.1 [RFC7231]&lt;/a&gt; ). 2xx (Успешные) ответы на метод запроса CONNECT ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;раздел 4.3.6 [RFC7231]&lt;/a&gt; ) переключаются в туннельный режим вместо того, чтобы иметь тело сообщения. Все ответы 1xx (информационные), 204 (без содержимого) и 304 (без изменений) не содержат тела сообщения. Все остальные ответы включают тело сообщения, хотя тело может иметь нулевую длину.</target>
        </trans-unit>
        <trans-unit id="4e8aaa241374a41dac239673c7a83e9b31912343" translate="yes" xml:space="preserve">
          <source>The message header fields below should be added to the permanent
   registry (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt;]).</source>
          <target state="translated">Поля заголовка сообщения ниже должны быть добавлены в постоянный реестр (см. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt; ]).</target>
        </trans-unit>
        <trans-unit id="5e0a346350c18fe7ecba53dc40c76384937c220e" translate="yes" xml:space="preserve">
          <source>The message-body (if any) of an HTTP message is used to carry the
   entity-body associated with the request or response. The message-body
   differs from the entity-body only when a transfer-coding has been
   applied, as indicated by the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;).

       message-body = entity-body
                    | &amp;lt;entity-body encoded as per Transfer-Encoding&amp;gt;

   Transfer-Encoding MUST be used to indicate any transfer-codings
   applied by an application to ensure safe and proper transfer of the
   message. Transfer-Encoding is a property of the message, not of the 

   entity, and thus MAY be added or removed by any application along the
   request/response chain. (However, &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt; places restrictions on
   when certain transfer-codings may be used.)

   The rules for when a message-body is allowed in a message differ for
   requests and responses.

   The presence of a message-body in a request is signaled by the
   inclusion of a Content-Length or Transfer-Encoding header field in
   the request's message-headers. A message-body MUST NOT be included in
   a request if the specification of the request method (&lt;a href=&quot;#section-5.1.1&quot;&gt;section 5.1.1&lt;/a&gt;)
   does not allow sending an entity-body in requests. A server SHOULD
   read and forward a message-body on any request; if the request method
   does not include defined semantics for an entity-body, then the
   message-body SHOULD be ignored when handling the request.

   For response messages, whether or not a message-body is included with
   a message is dependent on both the request method and the response
   status code (&lt;a href=&quot;#section-6.1.1&quot;&gt;section 6.1.1&lt;/a&gt;). All responses to the HEAD request method
   MUST NOT include a message-body, even though the presence of entity-
   header fields might lead one to believe they do. All 1xx
   (informational), 204 (no content), and 304 (not modified) responses
   MUST NOT include a message-body. All other responses do include a
   message-body, although it MAY be of zero length.</source>
          <target state="translated">Тело сообщения (если есть) HTTP-сообщения используется для переноса тела объекта, связанного с запросом или ответом. Тело сообщения отличается от тела объекта только тогда, когда было применено кодирование передачи, как указано в поле заголовка Transfer-Encoding ( &lt;a href=&quot;#section-14.41&quot;&gt;раздел &lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt; ). тело сообщения = тело объекта | &amp;lt;entity-body, закодированный согласно Transfer-Encoding&amp;gt; Transfer-Encoding ДОЛЖЕН использоваться для указания любых кодировок передачи, применяемых приложением для обеспечения безопасной и правильной передачи сообщения. Кодирование передачи - это свойство сообщения, а не объекта, и поэтому МОЖЕТ быть добавлено или удалено любым приложением в цепочке запросов / ответов. (Однако &lt;a href=&quot;#section-3.6&quot;&gt;раздел 3.6&lt;/a&gt;накладывает ограничения на то, когда могут использоваться определенные коды передачи.) Правила, когда в сообщении разрешается тело сообщения, различаются для запросов и ответов. Присутствие тела сообщения в запросе сигнализируется включением поля заголовка Content-Length или Transfer-Encoding в заголовки сообщения запроса. Тело сообщения НЕ ДОЛЖНО включаться в запрос, если спецификация метода запроса ( &lt;a href=&quot;#section-5.1.1&quot;&gt;раздел 5.1.1&lt;/a&gt;) не позволяет отправлять тело объекта в запросах. Серверу СЛЕДУЕТ читать и пересылать тело сообщения по любому запросу; если метод запроса не включает определенную семантику для тела объекта, то тело сообщения СЛЕДУЕТ игнорировать при обработке запроса. Для ответных сообщений, включено ли в сообщение тело сообщения, зависит как от метода запроса, так и от кода состояния ответа ( &lt;a href=&quot;#section-6.1.1&quot;&gt;раздел 6.1.1&lt;/a&gt; ). Все ответы на метод запроса HEAD НЕ ДОЛЖНЫ включать тело сообщения, даже если наличие полей заголовка объекта может заставить человека поверить в то, что они есть. Все ответы 1xx (информационный), 204 (без содержимого) и 304 (без изменений) НЕ ДОЛЖНЫ включать тело сообщения. Все остальные ответы включают тело сообщения, хотя оно МОЖЕТ иметь нулевую длину.</target>
        </trans-unit>
        <trans-unit id="a40c2c2dfbf9c25f98c934df39c7f7ed182fe5cf" translate="yes" xml:space="preserve">
          <source>The message/http type can be used to enclose a single HTTP request or
   response message, provided that it obeys the MIME restrictions for
   all &quot;message&quot; types regarding line length and encodings.

   Type name:  message

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype

      version:  The HTTP-version number of the enclosed message (e.g.,
         &quot;1.1&quot;).  If not present, the version can be determined from the
         first line of the body.

      msgtype:  The message type -- &quot;request&quot; or &quot;response&quot;.  If not
         present, the type can be determined from the first line of the
         body.

   Encoding considerations:  only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
      permitted 

   Security considerations:  see &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#section-8.3.1&quot;&gt;Section 8.3.1&lt;/a&gt;).

   Applications that use this media type:  N/A

   Fragment identifier considerations:  N/A

   Additional information:

      Magic number(s):  N/A

      Deprecated alias names for this type:  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:
      See Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">Тип message / http может использоваться для включения одного HTTP-запроса или ответного сообщения при условии, что он подчиняется ограничениям MIME для всех типов &amp;laquo;сообщений&amp;raquo; относительно длины строки и кодировок. Имя типа: сообщение Имя подтипа: http Обязательные параметры: Н / Д Дополнительные параметры: версия, тип сообщения версия: Номер HTTP-версии вложенного сообщения (например, &amp;laquo;1.1&amp;raquo;). Если нет, версию можно определить по первой строке тела. msgtype: Тип сообщения - &amp;laquo;запрос&amp;raquo; или &amp;laquo;ответ&amp;raquo;. Если нет, тип можно определить по первой строке тела. Рекомендации по кодированию: разрешены только &amp;laquo;7-битные&amp;raquo;, &amp;laquo;8-битные&amp;raquo; или &amp;laquo;двоичные&amp;raquo;. Соображения безопасности:см. &lt;a href=&quot;#section-9&quot;&gt;раздел 9&lt;/a&gt; Соображения по совместимости: Нет Опубликованная спецификация: Эта спецификация (см. &lt;a href=&quot;#section-8.3.1&quot;&gt;Раздел 8.3.1&lt;/a&gt; ). Приложения, использующие этот тип носителя: Н / Д. Рекомендации по идентификатору фрагмента: Н / Д Дополнительная информация: Магический номер (а): Н / Д Устаревшие псевдонимы для этого типа: Н / Д Расширение (я) файла: Н / Д Файл Macintosh Введите код (ы): N / A Человек и адрес электронной почты, с которыми можно связаться для получения дополнительной информации: См. раздел Адреса авторов. Предполагаемое использование: ОБЩИЕ Ограничения использования: Н / Д Автор: См. Раздел Адреса авторов. Сменить контроллер: IESG</target>
        </trans-unit>
        <trans-unit id="0249133f37d2157bb5d5d75cceeb4bf6c3634006" translate="yes" xml:space="preserve">
          <source>The method and the body of the original request are reused to perform the redirected request. In the cases where you want the method used to be changed to &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, use &lt;a href=&quot;303&quot;&gt;&lt;code&gt;303 See Other&lt;/code&gt;&lt;/a&gt; instead. This is useful when you want to give an answer to a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method that is not the uploaded resources, but a confirmation message (like &quot;You successfully uploaded XYZ&quot;).</source>
          <target state="translated">Метод и тело исходного запроса повторно используются для выполнения перенаправленного запроса. В случаях, когда вы хотите, чтобы используемый метод был изменен на &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , используйте вместо этого &lt;a href=&quot;303&quot;&gt; &lt;code&gt;303 See Other&lt;/code&gt; &lt;/a&gt; . Это полезно, если вы хотите дать ответ методу &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; ,&lt;/a&gt; который не является загруженными ресурсами, а является подтверждающим сообщением (например, &amp;laquo;Вы успешно загрузили XYZ&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="bcb5ff63a9c845a973320d106a4e7a8f6258bc0a" translate="yes" xml:space="preserve">
          <source>The method specified in the Request-Line is not allowed for the
   resource identified by the Request-URI. The response MUST include an
   Allow header containing a list of valid methods for the requested
   resource.</source>
          <target state="translated">Метод,указанный в строке отзывов,не допускается для ресурса,обозначенного в строке отзывов.Ответ ДОЛЖЕН содержать заголовок Allow,содержащий список допустимых методов для запрашиваемого ресурса.</target>
        </trans-unit>
        <trans-unit id="c61cd0e1f1485b50b5d1e9ad93568afa1f7867e5" translate="yes" xml:space="preserve">
          <source>The misunderstood X-XSS-Protection &amp;ndash; blog.innerht.ml</source>
          <target state="translated">Неправильно понятый X-XSS-Protection - blog.innerht.ml</target>
        </trans-unit>
        <trans-unit id="6aa0132e5f88b4993af9157a3eacfea873d280a5" translate="yes" xml:space="preserve">
          <source>The more we use cached resources, the better the responsiveness and the performance of a Web site will be. To optimize this, good practices recommend to set expiration times as far in the future as possible. This is possible on resources that are regularly updated, or often, but is problematic for resources that are rarely and infrequently updated. They are the resources that would benefit the most from caching resources, yet this makes them very difficult to update. This is typical of the technical resources included and linked from each Web pages: JavaScript and CSS files change infrequently, but when they change you want them to be updated quickly.</source>
          <target state="translated">Чем больше мы используем кэшированные ресурсы,тем лучше будет отзывчивость и производительность веб-сайта.Чтобы оптимизировать это,хорошая практика рекомендует устанавливать сроки истечения срока действия как можно дальше в будущем.Это возможно на ресурсах,которые регулярно обновляются,или часто,но проблематично для ресурсов,которые редко и редко обновляются.Это те ресурсы,которые больше всего выигрывают от кэширования ресурсов,но это очень затрудняет их обновление.Это типично для технических ресурсов,включенных и связанных с каждой Web-страницей:JavaScript и CSS файлы меняются редко,но когда они меняются,вы хотите,чтобы они быстро обновлялись.</target>
        </trans-unit>
        <trans-unit id="900a5182069f7643f5a96c3714605f7b28cd3d50" translate="yes" xml:space="preserve">
          <source>The most basic form of lock is an exclusive lock.  Exclusive locks
   avoid having to deal with content change conflicts, without requiring
   any coordination other than the methods described in this
   specification.

   However, there are times when the goal of a lock is not to exclude
   others from exercising an access right but rather to provide a
   mechanism for principals to indicate that they intend to exercise
   their access rights.  Shared locks are provided for this case.  A
   shared lock allows multiple principals to receive a lock.  Hence any
   principal that has both access privileges and a valid lock can use
   the locked resource.

   With shared locks, there are two trust sets that affect a resource.
   The first trust set is created by access permissions.  Principals who
   are trusted, for example, may have permission to write to the
   resource.  Among those who have access permission to write to the
   resource, the set of principals who have taken out a shared lock also
   must trust each other, creating a (typically) smaller trust set
   within the access permission write set.

   Starting with every possible principal on the Internet, in most
   situations the vast majority of these principals will not have write
   access to a given resource.  Of the small number who do have write
   access, some principals may decide to guarantee their edits are free
   from overwrite conflicts by using exclusive write locks.  Others may
   decide they trust their collaborators will not overwrite their work
   (the potential set of collaborators being the set of principals who
   have write permission) and use a shared lock, which informs their
   collaborators that a principal may be working on the resource.

   The WebDAV extensions to HTTP do not need to provide all of the
   communications paths necessary for principals to coordinate their
   activities.  When using shared locks, principals may use any out-of-
   band communication channel to coordinate their work (e.g., face-to-
   face interaction, written notes, post-it notes on the screen,
   telephone conversation, email, etc.)  The intent of a shared lock is
   to let collaborators know who else may be working on a resource.

   Shared locks are included because experience from Web-distributed
   authoring systems has indicated that exclusive locks are often too
   rigid.  An exclusive lock is used to enforce a particular editing
   process: take out an exclusive lock, read the resource, perform
   edits, write the resource, release the lock.  This editing process
   has the problem that locks are not always properly released, for
   example, when a program crashes or when a lock creator leaves without 

   unlocking a resource.  While both timeouts (&lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;) and
   administrative action can be used to remove an offending lock,
   neither mechanism may be available when needed; the timeout may be
   long or the administrator may not be available.

   A successful request for a new shared lock MUST result in the
   generation of a unique lock associated with the requesting principal.
   Thus, if five principals have taken out shared write locks on the
   same resource, there will be five locks and five lock tokens, one for
   each principal.</source>
          <target state="translated">Самая простая форма замка - эксклюзивный замок. Эксклюзивные блокировки позволяют избежать конфликтов изменения содержимого, не требуя какой-либо координации, кроме методов, описанных в этой спецификации. Однако бывают случаи, когда цель блокировки заключается не в том, чтобы исключить других пользователей из реализации права доступа, а в том, чтобы предоставить принципалам механизм, указывающий, что они намерены реализовать свои права доступа. Для этого случая предусмотрены общие замки. Общая блокировка позволяет нескольким участникам получить блокировку. Следовательно, любой принципал, который имеет как привилегии доступа, так и действительную блокировку, может использовать заблокированный ресурс. При общих блокировках есть два набора доверия, которые влияют на ресурс. Первый набор доверия создается разрешениями на доступ. Директора, которым доверяют, например,может иметь разрешение на запись в ресурс. Среди тех, у кого есть разрешение на запись в ресурс, набор участников, которые сняли общую блокировку, также должны доверять друг другу, создавая (обычно) меньший набор доверия в наборе разрешений на запись. Начиная с каждого возможного принципала в Интернете, в большинстве ситуаций подавляющее большинство этих принципалов не будет иметь доступа на запись к данному ресурсу. Из небольшого числа людей, у которых есть доступ на запись, некоторые руководители могут решить гарантировать отсутствие конфликтов перезаписи при их редактировании с помощью исключительных блокировок записи. Другие могут решить, что доверяют тому, что их соавторы не будут перезаписывать их работу (потенциальный набор соавторов - это набор принципалов, имеющих разрешение на запись) и использовать общую блокировку,который сообщает своим сотрудникам, что над ресурсом может работать принципал. Расширения WebDAV для HTTP не должны предоставлять все пути связи, необходимые принципалам для координации их действий. При использовании общих блокировок руководители могут использовать любой канал внеполосной связи для координации своей работы (например, личное общение, письменные заметки, заметки на экране, телефонный разговор, электронная почта и т. Д.). Цель общей блокировки - сообщить соавторам, кто еще может работать над ресурсом. Общие блокировки включены, потому что опыт систем разработки, распределенных по сети, показал, что эксклюзивные блокировки часто бывают слишком жесткими. Исключительная блокировка используется для принудительного выполнения определенного процесса редактирования: снять исключительную блокировку, прочитать ресурс, выполнить редактирование,напишите ресурс, снимите блокировку. Этот процесс редактирования имеет проблему, заключающуюся в том, что блокировки не всегда снимаются должным образом, например, когда происходит сбой программы или когда создатель блокировки выходит, не разблокировав ресурс. Пока оба таймаута (&lt;a href=&quot;#section-6.6&quot;&gt;Раздел 6.6&lt;/a&gt; ) и административные действия могут быть использованы для снятия блокировки, нарушающей правила, при необходимости ни один из механизмов может быть недоступен; таймаут может быть длинным или администратор может быть недоступен. Успешный запрос новой совместной блокировки ДОЛЖЕН привести к созданию уникальной блокировки, связанной с запрашивающим принципалом. Таким образом, если пять принципалов сняли общие блокировки записи на одном и том же ресурсе, будет пять блокировок и пять токенов блокировки, по одному для каждого принципала.</target>
        </trans-unit>
        <trans-unit id="a156ff3c58c5769ef6c6729d1da6678b0896af60" translate="yes" xml:space="preserve">
          <source>The most common authentication scheme is the &quot;Basic&quot; authentication scheme which is introduced in more details below. IANA maintains a &lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;list of authentication schemes&lt;/a&gt;, but there are other schemes offered by host services, such as Amazon AWS. Common authentication schemes include:</source>
          <target state="translated">Наиболее распространенной схемой аутентификации является &quot;Базовая&quot; схема аутентификации, которая более подробно представлена ​​ниже. IANA ведет &lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;список схем аутентификации&lt;/a&gt; , но есть и другие схемы, предлагаемые хост-сервисами, например Amazon AWS. Общие схемы аутентификации включают:</target>
        </trans-unit>
        <trans-unit id="c3c5a495d4e0bf178a13835396e7d4610c8dd302" translate="yes" xml:space="preserve">
          <source>The most common form of URI is the Uniform Resource Locator (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;), which is known as the &lt;em&gt;web address&lt;/em&gt;.</source>
          <target state="translated">Наиболее распространенной формой URI является унифицированный указатель ресурса ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt; ), который известен как &lt;em&gt;веб-адрес&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="441408fdebb55a519d6ec56cfba9f8cfcf41c9d1" translate="yes" xml:space="preserve">
          <source>The most common form of request-target is the origin-form.

     origin-form    = absolute-path [ &quot;?&quot; query ]

   When making a request directly to an origin server, other than a
   CONNECT or server-wide OPTIONS request (as detailed below), a client
   MUST send only the absolute path and query components of the target
   URI as the request-target.  If the target URI's path component is
   empty, the client MUST send &quot;/&quot; as the path within the origin-form of
   request-target.  A Host header field is also sent, as defined in
   &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;.

   For example, a client wishing to retrieve a representation of the
   resource identified as

     http://www.example.org/where?q=now

   directly from the origin server would open (or reuse) a TCP
   connection to port 80 of the host &quot;www.example.org&quot; and send the
   lines:

     GET /where?q=now HTTP/1.1
     Host: www.example.org

   followed by the remainder of the request message.</source>
          <target state="translated">Самая распространенная форма цели-запроса - это форма-источника. origin-form = absolute-path [&quot;?&quot; query] При выполнении запроса непосредственно к исходному серверу, кроме запроса CONNECT или общесерверного запроса OPTIONS (как подробно описано ниже), клиент ДОЛЖЕН отправлять только абсолютный путь и компоненты запроса целевого URI в качестве цели запроса. Если компонент пути целевого URI пуст, клиент ДОЛЖЕН отправить &amp;laquo;/&amp;raquo; в качестве пути в исходной форме цели-запроса. Также отправляется поле заголовка Host, как определено в &lt;a href=&quot;#section-5.4&quot;&gt;разделе 5.4.&lt;/a&gt;, Например, клиент, желающий получить представление ресурса, идентифицированного как http://www.example.org/where?q=now, непосредственно с исходного сервера, откроет (или повторно использует) TCP-соединение с портом 80 хоста. &amp;laquo;www.example.org&amp;raquo; и отправьте строки: GET / where? q = now HTTP / 1.1 Host: www.example.org, а затем оставшуюся часть сообщения запроса.</target>
        </trans-unit>
        <trans-unit id="46ee34a68e260d2ac9a208c1c10ecca4cdb7c99d" translate="yes" xml:space="preserve">
          <source>The most common reason to perform user agent sniffing is to determine which type of device the browser runs on. The goal is to serve different HTML to different device types.</source>
          <target state="translated">Наиболее распространенной причиной для выполнения прослушивания пользовательских агентов является определение типа устройства,на котором работает браузер.Цель состоит в том,чтобы обслуживать различные HTML для различных типов устройств.</target>
        </trans-unit>
        <trans-unit id="61e4993d071956d95f174a16357fd080a1122e7b" translate="yes" xml:space="preserve">
          <source>The most common use case for conditional requests is updating a cache. With an empty cache, or without a cache, the requested resource is sent back with a status of &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">Наиболее распространенный вариант использования условных запросов - это обновление кеша. С пустым кешем или без кеша запрошенный ресурс отправляется обратно со статусом &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63916efe76674061fe4628e66838f4f65d786f1d" translate="yes" xml:space="preserve">
          <source>The most common use case is to resume a download, to guarantee that the stored resource has not been modified since the last fragment has been received.</source>
          <target state="translated">Наиболее распространенный вариант использования-возобновить загрузку,чтобы гарантировать,что сохраненный ресурс не был изменен с момента получения последнего фрагмента.</target>
        </trans-unit>
        <trans-unit id="a9d5d6bfeb55ebb232d3c55e050956f34dcf4435" translate="yes" xml:space="preserve">
          <source>The most common use case is to update a cached entity that has no associated &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Наиболее распространенный вариант использования - обновить кэшированный объект, не связанный с &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="69e5095bac19f7e957fc81b9fc8a8c4dfee3e4ef" translate="yes" xml:space="preserve">
          <source>The most commonly used API based on top of HTTP is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, which can be used to exchange data between a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; and a server.</source>
          <target state="translated">Наиболее часто используемый API, основанный на HTTP, - это &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; API, который может использоваться для обмена данными между &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;пользовательским агентом&lt;/a&gt; и сервером.</target>
        </trans-unit>
        <trans-unit id="e318c21bd25e3fadc6435097a45df0a0fc7f22d3" translate="yes" xml:space="preserve">
          <source>The most important directive here is &quot;&lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt;&quot; which is the maximum amount of time a resource will be considered fresh. Contrary to &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt;, this directive is relative to the time of the request. For the files in the application that will not change, you can usually add aggressive caching. This includes static files such as images, CSS files and JavaScript files, for example.</source>
          <target state="translated">Самая важная директива здесь - &lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt; , которая определяет максимальное количество времени, в течение которого ресурс будет считаться свежим. В отличие от &lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt; , эта директива относится ко времени запроса. Для файлов в приложении, которые не изменятся, обычно можно добавить агрессивное кеширование. Сюда входят, например, статические файлы, такие как изображения, файлы CSS и файлы JavaScript.</target>
        </trans-unit>
        <trans-unit id="2de54066611634f9bbfbe66c8f61f170f030f4d4" translate="yes" xml:space="preserve">
          <source>The most interesting capability exposed by both &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; and CORS is the ability to make &quot;credentialed&quot; requests that are aware of &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt; and HTTP Authentication information. By default, in cross-site &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; invocations, browsers will &lt;strong&gt;not&lt;/strong&gt; send credentials. A specific flag has to be set on the &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; object or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; constructor when it is invoked.</source>
          <target state="translated">Наиболее интересная возможность, предоставляемая как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; ,так&lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; и CORS, - это возможность делать &amp;laquo;учетные&amp;raquo; запросы, которые знают о &lt;a href=&quot;cookies&quot;&gt;HTTP-файлах cookie&lt;/a&gt; и информации HTTP-аутентификации. По умолчанию при вызовах межсайтового &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&quot;&lt;/a&gt; браузеры &lt;strong&gt;не&lt;/strong&gt; отправляют учетные данные. При его вызове для объекта &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; или конструктора &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; должен быть установлен конкретный флаг .</target>
        </trans-unit>
        <trans-unit id="3a1c1a63ba9f8dd30771846a530a5374e05d9e6e" translate="yes" xml:space="preserve">
          <source>The name of a supported request header. The header may list any number of headers, separated by commas.</source>
          <target state="translated">Название заголовка поддерживаемого запроса.В заголовке может быть указано любое количество заголовков,разделенных запятыми.</target>
        </trans-unit>
        <trans-unit id="0efb14ebcb5f0fce2ff3b286a2ffd2165a867e1e" translate="yes" xml:space="preserve">
          <source>The name of the policy section that was violated.</source>
          <target state="translated">Название раздела политики,который был нарушен.</target>
        </trans-unit>
        <trans-unit id="844cb327de813003d80319f4e20e97ec08ef266e" translate="yes" xml:space="preserve">
          <source>The name of the software or (sub) product that handles the requests.</source>
          <target state="translated">Название программного обеспечения или (суб)продукта,который обрабатывает запросы.</target>
        </trans-unit>
        <trans-unit id="cbecb7545401e92e7f01c19b30802601bc05d85b" translate="yes" xml:space="preserve">
          <source>The name or pseudonym of the server or software adding the &lt;code&gt;Warning&lt;/code&gt; header (might be &quot;-&quot; when the agent is unknown).</source>
          <target state="translated">Имя или псевдоним сервера или программного обеспечения, добавляющего заголовок &lt;code&gt;Warning&lt;/code&gt; (может быть &amp;laquo;-&amp;raquo;, если агент неизвестен).</target>
        </trans-unit>
        <trans-unit id="0040305cef3180d6d7255c0c077b8782a6cc726f" translate="yes" xml:space="preserve">
          <source>The next major version of HTTP, HTTP/3, will use QUIC instead TCP/TLS for the transport layer portion.</source>
          <target state="translated">Следующая основная версия HTTP,HTTP/3,будет использовать QUIC вместо TCP/TLS для части транспортного уровня.</target>
        </trans-unit>
        <trans-unit id="8a49012952b5d13c3bc899a210b34a7392e5f266" translate="yes" xml:space="preserve">
          <source>The non-standard &lt;code&gt;Large-Allocation&lt;/code&gt; response header tells the browser that the page being loaded is going to want to perform a large allocation. It is currently only implemented in Firefox, but is harmless to send to every browser.</source>
          <target state="translated">Нестандартный заголовок ответа &lt;code&gt;Large-Allocation&lt;/code&gt; сообщает браузеру, что загружаемая страница захочет выполнить большое распределение. В настоящее время он реализован только в Firefox, но безвреден для отправки в любой браузер.</target>
        </trans-unit>
        <trans-unit id="ba5026e86262d6245f07b3191a146bd8bb62bfc9" translate="yes" xml:space="preserve">
          <source>The notion of HTTP headers has been introduced, both for the requests and the responses, allowing metadata to be transmitted and making the protocol extremely flexible and extensible.</source>
          <target state="translated">Было введено понятие заголовков HTTP,как для запросов,так и для ответов,что позволяет передавать метаданные и делает протокол чрезвычайно гибким и расширяемым.</target>
        </trans-unit>
        <trans-unit id="cebe7f3b1e1476fa1411cff9686fdc49ff3da815" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;content-security-policy/referrer&quot;&gt;&lt;code&gt;referrer&lt;/code&gt;&lt;/a&gt;  directive.</source>
          <target state="translated">Устаревшая директива &lt;a href=&quot;content-security-policy/referrer&quot;&gt; &lt;code&gt;referrer&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ee97cde545a5282f8eb8711464102b13b2f6dec" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;code&gt;Cookie2&lt;/code&gt; HTTP request header used to advise the server that the user agent understands &quot;new-style&quot; cookies, but nowadays user agents will use the &lt;a href=&quot;cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header instead, not this one.</source>
          <target state="translated">Устаревший заголовок HTTP-запроса &lt;code&gt;Cookie2&lt;/code&gt; , используемый для информирования сервера о том, что пользовательский агент понимает файлы cookie &amp;laquo;нового стиля&amp;raquo;, но в настоящее время пользовательские агенты будут использовать вместо этого заголовок &lt;a href=&quot;cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; ,&lt;/a&gt; а не этот.</target>
        </trans-unit>
        <trans-unit id="33c769b0c666a82869a02203951c2b8b5edec421" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;code&gt;Set-Cookie2&lt;/code&gt; HTTP response header used to send cookies from the server to the user agent, but has been deprecated by the specification. Use &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Устаревший заголовок HTTP-ответа &lt;code&gt;Set-Cookie2&lt;/code&gt; , используемый для отправки файлов cookie с сервера пользовательскому агенту, но не рекомендуется спецификацией. Вместо этого используйте &lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd9be51f044c110f50b29c3226b55ae882be5f1e" translate="yes" xml:space="preserve">
          <source>The only allowed methods are:</source>
          <target state="translated">Единственные разрешенные методы:</target>
        </trans-unit>
        <trans-unit id="cc061ae17eb93f938e35cb15516a270a95c70f3c" translate="yes" xml:space="preserve">
          <source>The only allowed values for the &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header are:</source>
          <target state="translated">Единственные допустимые значения для заголовка &lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="12f64d0b6bf68050154b5d92dd4e2be1345a3197" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;307&lt;/code&gt; and &lt;a href=&quot;302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;307&lt;/code&gt; guarantees that the method and the body will not be changed when the redirected request is made. With &lt;code&gt;302&lt;/code&gt;, some old clients were incorrectly changing the method to &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;: the behavior with non-&lt;code&gt;GET&lt;/code&gt; methods and &lt;code&gt;302&lt;/code&gt; is then unpredictable on the Web, whereas the behavior with &lt;code&gt;307&lt;/code&gt; is predictable. For &lt;code&gt;GET&lt;/code&gt; requests, their behavior is identical.</source>
          <target state="translated">Единственная разница между &lt;code&gt;307&lt;/code&gt; и &lt;a href=&quot;302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt; заключается в том, что &lt;code&gt;307&lt;/code&gt; гарантирует, что метод и тело не будут изменены при выполнении перенаправленного запроса. С &lt;code&gt;302&lt;/code&gt; некоторые старые клиенты неправильно меняли метод на &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; : поведение с методами, отличными от &lt;code&gt;GET&lt;/code&gt; и &lt;code&gt;302&lt;/code&gt; , тогда непредсказуемо в Интернете, тогда как поведение с &lt;code&gt;307&lt;/code&gt; предсказуемо. Для запросов &lt;code&gt;GET&lt;/code&gt; их поведение идентично.</target>
        </trans-unit>
        <trans-unit id="d4019eec51fe05092ad2db95b5b089e76d4b1742" translate="yes" xml:space="preserve">
          <source>The only expectation defined in the specification is &lt;code&gt;Expect: 100-continue&lt;/code&gt;, to which the server shall respond with:</source>
          <target state="translated">Единственное ожидание, определенное в спецификации, - &lt;code&gt;Expect: 100-continue&lt;/code&gt; , на которое сервер должен ответить:</target>
        </trans-unit>
        <trans-unit id="8582b84a04fd3c0703aeb779483786b9e1fec4ab" translate="yes" xml:space="preserve">
          <source>The only valid value for this header is &lt;code&gt;true&lt;/code&gt; (case-sensitive). If you don't need credentials, omit this header entirely (rather than setting its value to &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">Единственное допустимое значение для этого заголовка - &lt;code&gt;true&lt;/code&gt; (с учетом регистра). Если вам не нужны учетные данные, полностью опустите этот заголовок (вместо того, чтобы устанавливать для него значение &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="57e0edd3cec8916417007e47f389d457d3b92156" translate="yes" xml:space="preserve">
          <source>The order in which header fields with differing field names are
   received is not significant.  However, it is good practice to send
   header fields that contain control data first, such as Host on
   requests and Date on responses, so that implementations can decide
   when not to handle a message as early as possible.  A server MUST NOT
   apply a request to the target resource until the entire request 

   header section is received, since later header fields might include
   conditionals, authentication credentials, or deliberately misleading
   duplicate header fields that would impact request processing.

   A sender MUST NOT generate multiple header fields with the same field
   name in a message unless either the entire field value for that
   header field is defined as a comma-separated list [i.e., #(values)]
   or the header field is a well-known exception (as noted below).

   A recipient MAY combine multiple header fields with the same field
   name into one &quot;field-name: field-value&quot; pair, without changing the
   semantics of the message, by appending each subsequent field value to
   the combined field value in order, separated by a comma.  The order
   in which header fields with the same field name are received is
   therefore significant to the interpretation of the combined field
   value; a proxy MUST NOT change the order of these field values when
   forwarding a message.

      Note: In practice, the &quot;Set-Cookie&quot; header field ([&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;]) often
      appears multiple times in a response message and does not use the
      list syntax, violating the above requirements on multiple header
      fields with the same name.  Since it cannot be combined into a
      single field-value, recipients ought to handle &quot;Set-Cookie&quot; as a
      special case while processing header fields.  (See &lt;a href=&quot;#appendix-A.2.3&quot;&gt;Appendix A.2.3&lt;/a&gt;
      of [&lt;a href=&quot;#ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt;] for details.)</source>
          <target state="translated">Порядок получения полей заголовков с разными именами полей не имеет значения. Однако рекомендуется сначала отправлять поля заголовка, содержащие управляющие данные, такие как Хост при запросах и Дата в ответах, чтобы реализации могли решить, когда не обрабатывать сообщение как можно раньше. Сервер НЕ ДОЛЖЕН применять запрос к целевому ресурсу до тех пор, пока не будет получен весь раздел заголовка запроса, поскольку более поздние поля заголовка могут включать в себя условные выражения, учетные данные аутентификации или намеренно вводящие в заблуждение повторяющиеся поля заголовка, которые могут повлиять на обработку запроса. Отправитель НЕ ДОЛЖЕН создавать в сообщении несколько полей заголовка с одним и тем же именем, если только полное значение этого поля заголовка не определено как список, разделенный запятыми [т. Е.# (значения)] или поле заголовка - хорошо известное исключение (как указано ниже). Получатель МОЖЕТ объединить несколько полей заголовка с одинаковым именем поля в одну пару &amp;laquo;имя-поля: значение-поле&amp;raquo; без изменения семантики сообщения, добавляя каждое последующее значение поля к объединенному значению поля по порядку, разделенное знаком запятая. Следовательно, порядок, в котором принимаются поля заголовка с одинаковым именем поля, важен для интерпретации значения комбинированного поля; прокси-сервер НЕ ДОЛЖЕН изменять порядок значений этих полей при пересылке сообщения. Примечание. На практике поле заголовка &quot;Set-Cookie&quot; ([без изменения семантики сообщения, добавляя каждое последующее значение поля к объединенному значению поля по порядку, разделенное запятой. Следовательно, порядок, в котором принимаются поля заголовка с одинаковым именем поля, важен для интерпретации значения комбинированного поля; прокси-сервер НЕ ДОЛЖЕН изменять порядок значений этих полей при пересылке сообщения. Примечание. На практике поле заголовка &quot;Set-Cookie&quot; ([без изменения семантики сообщения, добавляя каждое последующее значение поля к объединенному значению поля по порядку, разделенное запятой. Таким образом, порядок, в котором принимаются поля заголовка с одинаковым именем поля, важен для интерпретации значения комбинированного поля; прокси-сервер НЕ ДОЛЖЕН изменять порядок значений этих полей при пересылке сообщения. Примечание. На практике поле заголовка &quot;Set-Cookie&quot; ([На практике поле заголовка &quot;Set-Cookie&quot; ([На практике поле заголовка &quot;Set-Cookie&quot; ([&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ]) часто появляется несколько раз в ответном сообщении и не использует синтаксис списка, нарушая приведенные выше требования к нескольким полям заголовка с одинаковым именем. Так как он не может быть объединен в одно значение поля, получатели должны обрабатывать &quot;Set-Cookie&quot; как особый случай при обработке полей заголовка. (Подробности см. В &lt;a href=&quot;#appendix-A.2.3&quot;&gt;Приложении &lt;/a&gt;&lt;a href=&quot;#ref-Kri2001&quot;&gt;A.2.3&lt;/a&gt; [ Kri2001 ].)</target>
        </trans-unit>
        <trans-unit id="18149c10ff86aae91ec06cd0aef8f5de4440363f" translate="yes" xml:space="preserve">
          <source>The origin is a URI indicating the server from which the request initiated. It does not include any path information, but only the server name.</source>
          <target state="translated">Источником является URI,указывающий на сервер,с которого был инициирован запрос.Он не содержит никакой информации о пути,а только имя сервера.</target>
        </trans-unit>
        <trans-unit id="26e7668fe582d80ecc70504dac9a50d81f54d606" translate="yes" xml:space="preserve">
          <source>The origin server requires the request to be conditional. Intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.</source>
          <target state="translated">Исходный сервер требует,чтобы запрос был условным.Предназначен для предотвращения проблемы &quot;потерянных обновлений&quot;,когда клиент GETs изменяет состояние ресурса и PUTs его обратно на сервер,когда тем временем третья сторона изменила состояние на сервере,что приводит к конфликту.</target>
        </trans-unit>
        <trans-unit id="c28b7e0ef7daf83cb81a618727021028721dfa63" translate="yes" xml:space="preserve">
          <source>The original WebDAV model for locking unmapped URLs created &quot;lock-
   null resources&quot;.  This model was over-complicated and some
   interoperability and implementation problems were discovered.  The
   new WebDAV model for locking unmapped URLs (see &lt;a href=&quot;#section-7.3&quot;&gt;Section 7.3&lt;/a&gt;) creates
   &quot;locked empty resources&quot;.  Lock-null resources are deprecated.  This
   section discusses the original model briefly because clients MUST be
   able to handle either model.

   In the original &quot;lock-null resource&quot; model, which is no longer
   recommended for implementation:

   o  A lock-null resource sometimes appeared as &quot;Not Found&quot;.  The
      server responds with a 404 or 405 to any method except for PUT,
      MKCOL, OPTIONS, PROPFIND, LOCK, UNLOCK.

   o  A lock-null resource does however show up as a member of its
      parent collection.

   o  The server removes the lock-null resource entirely (its URI
      becomes unmapped) if its lock goes away before it is converted to
      a regular resource.  Recall that locks go away not only when they
      expire or are unlocked, but are also removed if a resource is
      renamed or moved, or if any parent collection is renamed or moved. 

   o  The server converts the lock-null resource into a regular resource
      if a PUT request to the URL is successful.

   o  The server converts the lock-null resource into a collection if a
      MKCOL request to the URL is successful (though interoperability
      experience showed that not all servers followed this requirement).

   o  Property values were defined for DAV:lockdiscovery and DAV:
      supportedlock properties but not necessarily for other properties
      like DAV:getcontenttype.

   Clients can easily interoperate both with servers that support the
   old model &quot;lock-null resources&quot; and the recommended model of &quot;locked
   empty resources&quot; by only attempting PUT after a LOCK to an unmapped
   URL, not MKCOL or GET.</source>
          <target state="translated">Исходная модель WebDAV для блокировки несопоставленных URL-адресов создавала &amp;laquo;ресурсы без блокировки&amp;raquo;. Эта модель была чрезмерно сложной, и были обнаружены некоторые проблемы взаимодействия и реализации. Новая модель WebDAV для блокировки несопоставленных URL-адресов (см. &lt;a href=&quot;#section-7.3&quot;&gt;Раздел 7.3&lt;/a&gt;) создает &amp;laquo;заблокированные пустые ресурсы&amp;raquo;. Ресурсы Lock-null устарели. В этом разделе кратко обсуждается исходная модель, потому что клиенты ДОЛЖНЫ иметь возможность обрабатывать любую модель. В исходной модели &amp;laquo;ресурс с нулевой блокировкой&amp;raquo;, которая больше не рекомендуется для реализации: o Ресурс с нулевой блокировкой иногда отображается как &amp;laquo;Не найден&amp;raquo;. Сервер отвечает 404 или 405 на любой метод, кроме PUT, MKCOL, OPTIONS, PROPFIND, LOCK, UNLOCK. o Ресурс lock-null действительно отображается как член своей родительской коллекции. o Сервер полностью удаляет ресурс lock-null (его URI становится несопоставленным), если его блокировка снимается до того, как он будет преобразован в обычный ресурс. Напомним, что блокировки исчезают не только по истечении срока их действия или когда они разблокированы,но также удаляются, если ресурс переименован или перемещен, или если какая-либо родительская коллекция переименована или перемещена. o Сервер преобразует ресурс lock-null в обычный ресурс, если запрос PUT к URL-адресу успешен. o Сервер преобразует ресурс lock-null в коллекцию, если запрос MKCOL к URL-адресу успешен (хотя опыт взаимодействия показал, что не все серверы следовали этому требованию). o Значения свойств были определены для свойств DAV: lockdiscovery и DAV: supportedlock, но не обязательно для других свойств, таких как DAV: getcontenttype. Клиенты могут легко взаимодействовать как с серверами, которые поддерживают старую модель &amp;laquo;заблокированных пустых ресурсов&amp;raquo;, так и рекомендованную модель &amp;laquo;заблокированных пустых ресурсов&amp;raquo;.путем только попытки PUT после LOCK для несопоставленного URL-адреса, а не MKCOL или GET.</target>
        </trans-unit>
        <trans-unit id="351291dcc2c8f40b6fda3d0b9fb11a63f52c019f" translate="yes" xml:space="preserve">
          <source>The original model of HTTP, and the default one in HTTP/1.0, is &lt;em&gt;short-lived connections&lt;/em&gt;. Each HTTP request is completed on its own connection; this means a TCP handshake happens before each HTTP request, and these are serialized.</source>
          <target state="translated">Исходная модель HTTP и модель HTTP / 1.0 по умолчанию - это &lt;em&gt;краткосрочные соединения&lt;/em&gt; . Каждый HTTP-запрос выполняется в отдельном соединении; это означает, что рукопожатие TCP происходит перед каждым HTTP-запросом, и они сериализуются.</target>
        </trans-unit>
        <trans-unit id="79e460eb743f85621e4024af0b7bff004e6c3d39" translate="yes" xml:space="preserve">
          <source>The original policy as specified by the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; HTTP header.</source>
          <target state="translated">Исходная политика, указанная в HTTP-заголовке &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4893fed57017b899f622f28734ae6d2fe80b3b77" translate="yes" xml:space="preserve">
          <source>The original policy as specified by the &lt;code&gt;Content-Security-Policy&lt;/code&gt; HTTP header.</source>
          <target state="translated">Исходная политика, указанная в HTTP-заголовке &lt;code&gt;Content-Security-Policy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65440960b2a3f39f3e1fd7555605568089a8d96a" translate="yes" xml:space="preserve">
          <source>The original vision of Tim Berners-Lee for the Web wasn't a read-only medium. He envisioned a Web where people can add and move documents remotely, a kind of distributed file system. Around 1996, HTTP has been extended to allow authoring, and a standard called WebDAV was created. It has been further extended for specific applications like CardDAV to handle address book entries and CalDAV to deal with calendars. But all these *DAV extensions had a flaw: they had to be implemented by the servers to be used, which was quite complex. Their use on Web realms stayed confidential.</source>
          <target state="translated">Оригинальное видение Тима Бернерса-Ли для Сети не было носителем информации только для чтения.Он представлял себе Сеть,где люди могут добавлять и перемещать документы удаленно,своего рода распределенную файловую систему.Примерно в 1996 году был расширен протокол HTTP,позволяющий писать документы,и был создан стандарт под названием WebDAV.Он был далее расширен для специфических приложений,таких как CardDAV для работы с записями адресной книги и CalDAV для работы с календарями.Но у всех этих *DAV расширений был недостаток:они должны были быть реализованы серверами для использования,что было довольно сложно.Их использование в Web-среде оставалось конфиденциальным.</target>
        </trans-unit>
        <trans-unit id="ec62cbdca93d2ad4ec39377f99d81883dfe1d146" translate="yes" xml:space="preserve">
          <source>The output will look something like this:</source>
          <target state="translated">Выход будет выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="aa47362e2b58ce7c1d4859c59d1d577c32eab05a" translate="yes" xml:space="preserve">
          <source>The page can only be displayed in a frame on the same origin as the page itself. The spec leaves it up to browser vendors to decide whether this option applies to the top level, the parent, or the whole chain, although it is argued that the option is not very useful unless all ancestors are also in the same origin (see &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=725490&quot;&gt;bug 725490&lt;/a&gt;). Also see &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility&lt;/a&gt; for support details.</source>
          <target state="translated">Страница может отображаться только во фрейме в том же источнике, что и сама страница. В спецификации оставляет на производитель браузеров , чтобы решить , относится ли этот вариант на уровень верхнего, родитель или всю цепь, хотя он утверждал , что вариант не очень полезно , если все предки также в том же происхождении (см &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=725490&quot;&gt;ошибки 725490&lt;/a&gt; ). Также см. &lt;a href=&quot;#Browser_compatibility&quot;&gt;Совместимость браузера&lt;/a&gt; для получения дополнительной информации о поддержке.</target>
        </trans-unit>
        <trans-unit id="87ed0031ffdd1f701402da552456ef09ffc21cb3" translate="yes" xml:space="preserve">
          <source>The page can only be displayed in a frame on the specified origin. Note that in Firefox this still suffers from the same problem as &lt;code&gt;sameorigin&lt;/code&gt; did &amp;mdash; it doesn't check the frame ancestors to see if they are in the same origin.</source>
          <target state="translated">Страница может отображаться только во фрейме в указанном источнике. Обратите внимание, что в Firefox это по-прежнему страдает той же проблемой, что и &lt;code&gt;sameorigin&lt;/code&gt; - он не проверяет предков фреймов, чтобы узнать, находятся ли они в том же источнике.</target>
        </trans-unit>
        <trans-unit id="6fd708bba3250a928bde72e278816558269ceee3" translate="yes" xml:space="preserve">
          <source>The page cannot be displayed in a frame, regardless of the site attempting to do so.</source>
          <target state="translated">Страница не может быть отображена во фрейме,независимо от того,какой сайт пытается это сделать.</target>
        </trans-unit>
        <trans-unit id="7e65beef9355c724f3b8565f6ab1fad05b9ee018" translate="yes" xml:space="preserve">
          <source>The parameters &quot;filename&quot; and &quot;filename*&quot; differ only in that &quot;filename*&quot; uses the encoding defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt;. When both &quot;filename&quot; and &quot;filename*&quot; are present in a single header field value, &quot;filename*&quot; is preferred over &quot;filename&quot; when both are understood.</source>
          <target state="translated">Параметры &amp;laquo;имя файла&amp;raquo; и &amp;laquo;имя файла *&amp;raquo; отличаются только тем, что &amp;laquo;имя файла *&amp;raquo; использует кодировку, определенную в &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt; . Когда и &amp;laquo;имя файла&amp;raquo;, и &amp;laquo;имя файла *&amp;raquo; присутствуют в одном значении поля заголовка, &amp;laquo;имя файла *&amp;raquo; предпочтительнее, чем &amp;laquo;имя файла&amp;raquo;, когда оба понятны.</target>
        </trans-unit>
        <trans-unit id="f73b0f673ad4f6ff6cd78d437d63486d3077a18d" translate="yes" xml:space="preserve">
          <source>The path of the resource to fetch; the URL of the resource stripped from elements that are obvious from the context, for example without the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;protocol&lt;/a&gt; (&lt;code&gt;http://&lt;/code&gt;), the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;domain&lt;/a&gt; (here &lt;code&gt;developer.mozilla.org&lt;/code&gt;), or the TCP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;port&lt;/a&gt; (here &lt;code&gt;80&lt;/code&gt;).</source>
          <target state="translated">Путь к извлекаемому ресурсу; URL-адрес ресурса, очищенный от очевидных из контекста элементов, например без &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;протокола&lt;/a&gt; ( &lt;code&gt;http://&lt;/code&gt; ), &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;домена&lt;/a&gt; (здесь &lt;code&gt;developer.mozilla.org&lt;/code&gt; ) или TCP- &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;порта&lt;/a&gt; (здесь &lt;code&gt;80&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="21d24dd0cdd0a56d270ae234ba2ae51b6e5cb97c" translate="yes" xml:space="preserve">
          <source>The performance of web sites and applications can be significantly improved by reusing previously fetched resources. Web caches reduce latency and network traffic and thus lessen the time needed to display a representation of a resource. By making use of HTTP caching, Web sites become more responsive.</source>
          <target state="translated">Производительность веб-сайтов и приложений может быть значительно повышена за счет повторного использования ранее собранных ресурсов.Веб-кэш снижает задержки и сетевой трафик и,таким образом,уменьшает время,необходимое для отображения представления ресурса.Благодаря использованию HTTP-кэширования веб-сайты становятся более отзывчивыми.</target>
        </trans-unit>
        <trans-unit id="4ef7dc4ef4177a90ccc5fba5f3743824b87bfd8e" translate="yes" xml:space="preserve">
          <source>The policy is a string containing the policy directives describing your Content Security Policy.</source>
          <target state="translated">Политика представляет собой строку,содержащую директивы политики,описывающие вашу политику безопасности контента.</target>
        </trans-unit>
        <trans-unit id="1cde3605fdc2afc6de4d0a52e9aa9896f47fafaf" translate="yes" xml:space="preserve">
          <source>The policy:</source>
          <target state="translated">Политика:</target>
        </trans-unit>
        <trans-unit id="776afe838427d09cf840d7fc30aa63d4eaa2c3d9" translate="yes" xml:space="preserve">
          <source>The precondition given in one or more of the request-header fields
   evaluated to false when it was tested on the server. This response
   code allows the client to place preconditions on the current resource
   metainformation (header field data) and thus prevent the requested
   method from being applied to a resource other than the one intended.</source>
          <target state="translated">Предусловие,заданное в одном или нескольких полях заголовка запроса,при тестировании на сервере оценивалось как ложное.Этот код ответа позволяет клиенту поставить предусловия на текущую метаинформацию ресурса (данные полей заголовков)и тем самым предотвратить применение запрошенного метода к ресурсу,отличному от того,на который он был назначен.</target>
        </trans-unit>
        <trans-unit id="82d265543b246e66360f0830a564b27c84119c7f" translate="yes" xml:space="preserve">
          <source>The preferred way to target content to a device form factor is to use CSS Media Queries. However, if you use UA sniffing to target content to a device form factor, please look for &lt;strong&gt;Mobi&lt;/strong&gt; (to include Opera Mobile, which uses &quot;Mobi&quot;) for the phone form factor and do &lt;strong&gt;not&lt;/strong&gt; assume any correlation between &quot;Android&quot; and the device form factor. This way, your code will work if/when Firefox ships on other phone/tablet operating systems or Android is used for laptops. Also, please use touch detection to find touch devices rather than looking for &quot;Mobi&quot; or &quot;Tablet&quot;, since there may be touch devices which are not tablets.</source>
          <target state="translated">Предпочтительный способ нацелить контент на форм-фактор устройства - использовать CSS Media Queries. Однако, если вы используете сниффинг UA для нацеливания контента на форм-фактор устройства, ищите &lt;strong&gt;Mobi&lt;/strong&gt; (включая Opera Mobile, которая использует Mobi) для форм-фактора телефона и &lt;strong&gt;не&lt;/strong&gt; предполагайте какой-либо корреляции между &amp;laquo;Android&amp;raquo; и устройством. фактор формы. Таким образом, ваш код будет работать, если / когда Firefox поставляется на других операционных системах телефона / планшета или Android используется для ноутбуков. Кроме того, используйте обнаружение касания для поиска сенсорных устройств, а не ищите &quot;Mobi&quot; или &quot;Tablet&quot;, поскольку могут быть сенсорные устройства, которые не являются планшетами.</target>
        </trans-unit>
        <trans-unit id="336e39ad55330caf3f7eb800fefcd2e0dc7dd455" translate="yes" xml:space="preserve">
          <source>The preflight request simply suffered any kind of networking error that might ordinarily occur.</source>
          <target state="translated">Предполетный запрос просто страдал от любого рода сетевых ошибок,которые обычно могут возникать.</target>
        </trans-unit>
        <trans-unit id="debdc150f8d10727246ce79b174d0a3a9962d2c4" translate="yes" xml:space="preserve">
          <source>The previous example was illegal because it contained two elements
   that were explicitly banned from appearing together in the propfind
   element.  However, XML is an extensible language, so one can imagine
   new elements being defined for use with propfind.  Below is the
   request body of a PROPFIND and, like the previous example, must be
   rejected with a 400 (Bad Request) by a server that does not
   understand the expired-props element.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
      xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
       &amp;lt;E:expired-props/&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   To understand why a 400 (Bad Request) is returned, let us look at the
   request body as the server unfamiliar with expired-props sees it.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
                  xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   As the server does not understand the 'expired-props' element,
   according to the WebDAV-specific XML processing rules specified in
   &lt;a href=&quot;#section-17&quot;&gt;Section 17&lt;/a&gt;, it must process the request as if the element were not
   there.  Thus, the server sees an empty propfind, which by the
   definition of the propfind element is illegal.

   Please note that had the extension been additive, it would not
   necessarily have resulted in a 400 (Bad Request).  For example,
   imagine the following request body for a PROPFIND:


      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
                  xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
       &amp;lt;D:propname/&amp;gt;
       &amp;lt;E:leave-out&amp;gt;*boss*&amp;lt;/E:leave-out&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   The previous example contains the fictitious element leave-out.  Its
   purpose is to prevent the return of any property whose name matches
   the submitted pattern.  If the previous example were submitted to a
   server unfamiliar with 'leave-out', the only result would be that the
   'leave-out' element would be ignored and a propname would be
   executed.</source>
          <target state="translated">Предыдущий пример был недопустимым, потому что он содержал два элемента, которым явно запрещено появляться вместе в элементе propfind. Однако XML - это расширяемый язык, поэтому можно представить новые элементы, определяемые для использования с propfind. Ниже приведено тело запроса PROPFIND, и, как и в предыдущем примере, он должен быть отклонен с помощью 400 (неверный запрос) сервером, который не понимает элемент expired-props. &amp;lt;? xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D: propfind xmlns: D = &quot;DAV:&quot; xmlns: E = &quot;http://www.example.com/standards/props/&quot;&amp;gt; &amp;lt;E: expired-props /&amp;gt; &amp;lt;/ D: propfind&amp;gt; Чтобы понять, почему возвращается 400 (неверный запрос), давайте посмотрим на тело запроса, как его видит сервер, незнакомый с expired-props. &amp;lt;? xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D: propfind xmlns: D = &quot;DAV:&quot; xmlns: E = &quot;http://www.example.com/standards/props/&quot;&amp;gt; &amp;lt; / D: propfind&amp;gt; Поскольку сервер не понимает элемент 'expired-props', в соответствии с правилами обработки XML, специфичными для WebDAV, указанными в &lt;a href=&quot;#section-17&quot;&gt;Раздел 17.&lt;/a&gt;, он должен обработать запрос, как если бы элемента там не было. Таким образом, сервер видит пустой propfind, что по определению элемента propfind является недопустимым. Обратите внимание, что если бы расширение было аддитивным, это не обязательно привело бы к 400 (неверный запрос). Например, представьте себе следующее тело запроса для PROPFIND: &amp;lt;? Xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D: propfind xmlns: D = &quot;DAV:&quot; xmlns: E = &quot;http: // www.example.com/standards/props / &quot;&amp;gt; &amp;lt;D: propname /&amp;gt; &amp;lt;E: leave-out&amp;gt; * boss * &amp;lt;/ E: leave-out&amp;gt; &amp;lt;/ D: propfind&amp;gt; Предыдущий пример содержит фиктивный элемент leave -вне. Его цель - предотвратить возврат любого свойства, имя которого соответствует представленному шаблону.Если бы предыдущий пример был отправлен на сервер, незнакомый с &quot;исключением&quot;, единственным результатом было бы то, что элемент &quot;исключения&quot; был бы проигнорирован, и было бы выполнено имя свойства.</target>
        </trans-unit>
        <trans-unit id="1ae30a0f00a7837d72ecd861dd4a6d9fd65f4447" translate="yes" xml:space="preserve">
          <source>The primary changes in this revision have been editorial in nature:
   extracting the messaging syntax and partitioning HTTP semantics into
   separate documents for the core features, conditional requests,
   partial requests, caching, and authentication.  The conformance
   language has been revised to clearly target requirements and the
   terminology has been improved to distinguish payload from
   representations and representations from resources.

   A new requirement has been added that semantics embedded in a URI be
   disabled when those semantics are inconsistent with the request
   method, since this is a common cause of interoperability failure.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   An algorithm has been added for determining if a payload is
   associated with a specific identifier.  (&lt;a href=&quot;#section-3.1.4.1&quot;&gt;Section 3.1.4.1&lt;/a&gt;)

   The default charset of ISO-8859-1 for text media types has been
   removed; the default is now whatever the media type definition says.
   Likewise, special treatment of ISO-8859-1 has been removed from the
   Accept-Charset header field.  (&lt;a href=&quot;#section-3.1.1.3&quot;&gt;Section 3.1.1.3&lt;/a&gt; and &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;)

   The definition of Content-Location has been changed to no longer
   affect the base URI for resolving relative URI references, due to
   poor implementation support and the undesirable effect of potentially
   breaking relative links in content-negotiated resources.
   (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;)

   To be consistent with the method-neutral parsing algorithm of
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;], the definition of GET has been relaxed so that requests
   can have a body, even though a body has no meaning for GET.
   (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;)

   Servers are no longer required to handle all Content-* header fields
   and use of Content-Range has been explicitly banned in PUT requests.
   (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;)

   Definition of the CONNECT method has been moved from [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;] to
   this specification.  (&lt;a href=&quot;#section-4.3.6&quot;&gt;Section 4.3.6&lt;/a&gt;)

   The OPTIONS and TRACE request methods have been defined as being
   safe.  (&lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt; and &lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt;) 

   The Expect header field's extension mechanism has been removed due to
   widely-deployed broken implementations.  (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;)

   The Max-Forwards header field has been restricted to the OPTIONS and
   TRACE methods; previously, extension methods could have used it as
   well.  (&lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;)

   The &quot;about:blank&quot; URI has been suggested as a value for the Referer
   header field when no referring URI is applicable, which distinguishes
   that case from others where the Referer field is not sent or has been
   removed.  (&lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt;)

   The following status codes are now cacheable (that is, they can be
   stored and reused by a cache without explicit freshness information
   present): 204, 404, 405, 414, 501.  (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;)

   The 201 (Created) status description has been changed to allow for
   the possibility that more than one resource has been created.
   (&lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;)

   The definition of 203 (Non-Authoritative Information) has been
   broadened to include cases of payload transformations as well.
   (&lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;)

   The set of request methods that are safe to automatically redirect is
   no longer closed; user agents are able to make that determination
   based upon the request method semantics.  The redirect status codes
   301, 302, and 307 no longer have normative requirements on response
   payloads and user interaction.  (&lt;a href=&quot;#section-6.4&quot;&gt;Section 6.4&lt;/a&gt;)

   The status codes 301 and 302 have been changed to allow user agents
   to rewrite the method from POST to GET.  (Sections &lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt; and &lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt;)

   The description of the 303 (See Other) status code has been changed
   to allow it to be cached if explicit freshness information is given,
   and a specific definition has been added for a 303 response to GET.
   (&lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;)

   The 305 (Use Proxy) status code has been deprecated due to security
   concerns regarding in-band configuration of a proxy.  (&lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;)

   The 400 (Bad Request) status code has been relaxed so that it isn't
   limited to syntax errors.  (&lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;)

   The 426 (Upgrade Required) status code has been incorporated from
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;].  (&lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt;) 

   The target of requirements on HTTP-date and the Date header field
   have been reduced to those systems generating the date, rather than
   all systems sending a date.  (&lt;a href=&quot;#section-7.1.1&quot;&gt;Section 7.1.1&lt;/a&gt;)

   The syntax of the Location header field has been changed to allow all
   URI references, including relative references and fragments, along
   with some clarifications as to when use of fragments would not be
   appropriate.  (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;)

   Allow has been reclassified as a response header field, removing the
   option to specify it in a PUT request.  Requirements relating to the
   content of Allow have been relaxed; correspondingly, clients are not
   required to always trust its value.  (&lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;)

   A Method Registry has been defined.  (&lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;)

   The Status Code Registry has been redefined by this specification;
   previously, it was defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC2817]&lt;/a&gt;.
   (&lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt;)

   Registration of content codings has been changed to require IETF
   Review.  (&lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;)

   The Content-Disposition header field has been removed since it is now
   defined by [&lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC6266&lt;/a&gt;].

   The Content-MD5 header field has been removed because it was
   inconsistently implemented with respect to partial responses.</source>
          <target state="translated">Основные изменения в этой версии носили редакционный характер: извлечение синтаксиса обмена сообщениями и разделение семантики HTTP на отдельные документы для основных функций, условных запросов, частичных запросов, кэширования и аутентификации. Язык соответствия был изменен для четкого определения требований, а терминология была улучшена, чтобы отличать полезную нагрузку от представлений и представления от ресурсов. Было добавлено новое требование, согласно которому семантика, встроенная в URI, должна быть отключена, когда эта семантика несовместима с методом запроса, поскольку это частая причина сбоя взаимодействия. ( &lt;a href=&quot;#section-2&quot;&gt;Раздел 2&lt;/a&gt; ) Добавлен алгоритм для определения того, связана ли полезная нагрузка с конкретным идентификатором. ( &lt;a href=&quot;#section-3.1.4.1&quot;&gt;Раздел 3.1.4.1&lt;/a&gt;) Кодировка по умолчанию ISO-8859-1 для типов текстовых носителей удалена; теперь по умолчанию используется то, что указано в определении типа носителя. Точно так же специальная обработка ISO-8859-1 была удалена из поля заголовка Accept-Charset. ( &lt;a href=&quot;#section-3.1.1.3&quot;&gt;Раздел 3.1.1.3&lt;/a&gt; и &lt;a href=&quot;#section-5.3.3&quot;&gt;Раздел 5.3.3&lt;/a&gt; ) Определение Content-Location было изменено, чтобы больше не влиять на базовый URI для разрешения относительных ссылок URI из-за плохой поддержки реализации и нежелательного эффекта потенциального разрыва относительных ссылок в контенте. согласованные ресурсы. ( &lt;a href=&quot;#section-3.1.4.2&quot;&gt;Раздел 3.1.4.2&lt;/a&gt; ) В соответствии с алгоритмом анализа, не &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;зависящим&lt;/a&gt; от метода [ RFC7230] определение GET смягчено, поэтому запросы могут иметь тело, даже если тело не имеет значения для GET. ( &lt;a href=&quot;#section-4.3.1&quot;&gt;Раздел 4.3.1&lt;/a&gt; ) От серверов больше не требуется обрабатывать все поля заголовка Content- *, а использование Content-Range явно запрещено в запросах PUT. ( &lt;a href=&quot;#section-4.3.4&quot;&gt;Раздел 4.3.4&lt;/a&gt; ) Определение метода CONNECT перемещено из [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ] в эту спецификацию. ( &lt;a href=&quot;#section-4.3.6&quot;&gt;Раздел 4.3.6&lt;/a&gt; ) Методы запроса OPTIONS и TRACE определены как безопасные. ( &lt;a href=&quot;#section-4.3.7&quot;&gt;Раздел 4.3.7&lt;/a&gt; и &lt;a href=&quot;#section-4.3.8&quot;&gt;Раздел 4.3.8&lt;/a&gt; ) Механизм расширения поля заголовка Expect был удален из-за широко распространенных неработающих реализаций. ( &lt;a href=&quot;#section-5.1.1&quot;&gt;Раздел 5.1.1&lt;/a&gt;) Поле заголовка Max-Forwards ограничено методами OPTIONS и TRACE; ранее его также могли использовать методы расширения. ( &lt;a href=&quot;#section-5.1.2&quot;&gt;Раздел 5.1.2&lt;/a&gt; ) URI &amp;laquo;about: blank&amp;raquo; был предложен в качестве значения для поля заголовка Referer, когда не применим ссылающийся URI, что отличает этот случай от других случаев, когда поле Referer не отправляется или было удалено. ( &lt;a href=&quot;#section-5.5.2&quot;&gt;Раздел 5.5.2&lt;/a&gt; ) Следующие коды состояния теперь могут кэшироваться (то есть они могут быть сохранены и повторно использованы в кеше без явной информации о свежести): 204, 404, 405, 414, 501. ( &lt;a href=&quot;#section-6&quot;&gt;Раздел 6&lt;/a&gt; ) 201 ( Создано) описание статуса было изменено, чтобы учесть возможность создания более одного ресурса. (&lt;a href=&quot;#section-6.3.2&quot;&gt;Раздел 6.3.2&lt;/a&gt; ). Определение 203 (Неавторизованная информация) было расширено и теперь включает случаи преобразования полезной нагрузки. ( &lt;a href=&quot;#section-6.3.4&quot;&gt;Раздел 6.3.4&lt;/a&gt; ) Набор методов запроса, безопасных для автоматического перенаправления, больше не закрыт; пользовательские агенты могут делать это определение на основе семантики метода запроса. Коды состояния переадресации 301, 302 и 307 больше не имеют нормативных требований к ответной нагрузке и взаимодействию с пользователем. ( &lt;a href=&quot;#section-6.4&quot;&gt;Раздел 6.4&lt;/a&gt; ) Коды состояния 301 и 302 были изменены, чтобы пользовательские агенты могли переписывать метод с POST на GET. (Разделы &lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt; и &lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt;) Описание кода состояния 303 (см. Другое) было изменено, чтобы можно было кэшировать его, если дана явная информация о свежести, и было добавлено конкретное определение для ответа 303 на GET. ( &lt;a href=&quot;#section-6.4.4&quot;&gt;Раздел 6.4.4&lt;/a&gt; ) Код состояния 305 (Use Proxy) устарел из-за проблем с безопасностью, связанных с внутренней конфигурацией прокси. ( &lt;a href=&quot;#section-6.4.5&quot;&gt;Раздел 6.4.5&lt;/a&gt; ) Код состояния 400 (неверный запрос) был ослаблен, чтобы он не ограничивался синтаксическими ошибками. ( &lt;a href=&quot;#section-6.5.1&quot;&gt;Раздел 6.5.1&lt;/a&gt; ) Код состояния 426 (требуется обновление) был включен из [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ]. ( &lt;a href=&quot;#section-6.5.15&quot;&gt;Раздел 6.5.15&lt;/a&gt;) Целевые требования к HTTP-дате и полю заголовка Date были сокращены до тех систем, которые генерируют дату, а не всех систем, отправляющих дату. ( &lt;a href=&quot;#section-7.1.1&quot;&gt;Раздел 7.1.1&lt;/a&gt; ) Синтаксис поля заголовка Location был изменен, чтобы разрешить все ссылки URI, включая относительные ссылки и фрагменты, вместе с некоторыми пояснениями относительно того, когда использование фрагментов нецелесообразно. ( &lt;a href=&quot;#section-7.1.2&quot;&gt;Раздел 7.1.2&lt;/a&gt; ) Allow было реклассифицировано как поле заголовка ответа, удалена возможность указывать его в запросе PUT. Требования к содержанию Allow были смягчены; соответственно, клиенты не обязаны всегда доверять его ценности. ( &lt;a href=&quot;#section-7.4.1&quot;&gt;Раздел 7.4.1&lt;/a&gt; ) Определен реестр методов. (&lt;a href=&quot;#section-8.1&quot;&gt;Раздел 8.1&lt;/a&gt; ) Реестр кодов состояния был переопределен этой спецификацией; ранее он был определен в &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;разделе 7.1 [RFC2817]&lt;/a&gt; . ( &lt;a href=&quot;#section-8.2&quot;&gt;Раздел 8.2&lt;/a&gt; ) Регистрация кодирования контента изменена и требует проверки IETF. ( &lt;a href=&quot;#section-8.4&quot;&gt;Раздел 8.4&lt;/a&gt; ) Поле заголовка Content-Disposition было удалено, так как теперь оно определено в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC6266&lt;/a&gt; ]. Поле заголовка Content-MD5 было удалено, поскольку оно было непоследовательно реализовано в отношении частичных ответов.</target>
        </trans-unit>
        <trans-unit id="e12309a2843027455af9add0576f0892e2a69fde" translate="yes" xml:space="preserve">
          <source>The primary difference between the HTTP header and the &lt;code&gt;allow&lt;/code&gt; attribute is that the allow attribute only controls features within an iframe. The header controls features in the response and any embedded content within the page.</source>
          <target state="translated">Основное различие между HTTP-заголовком и атрибутом &lt;code&gt;allow&lt;/code&gt; заключается в том, что атрибут allow управляет только функциями внутри iframe. Заголовок управляет функциями ответа и любым встроенным содержимым на странице.</target>
        </trans-unit>
        <trans-unit id="b50ebcbe3e89d6447760b75f1e616af6abba5bb8" translate="yes" xml:space="preserve">
          <source>The principle behind entity tags is that only the service author
   knows the semantics of a resource well enough to select an
   appropriate cache validation mechanism, and the specification of any
   validator comparison function more complex than byte-equality would
   open up a can of worms. Thus, comparisons of any other headers
   (except Last-Modified, for compatibility with HTTP/1.0) are never
   used for purposes of validating a cache entry.</source>
          <target state="translated">Принцип,лежащий в основе сущностных тегов,заключается в том,что только автор сервиса знает семантику ресурса достаточно хорошо,чтобы выбрать подходящий механизм проверки кэша,а спецификация любой функции сравнения валидаторов более сложная,чем байтовое качество,откроет банку с червями.Таким образом,сравнения любых других заголовков (кроме Last-Modified,для совместимости с HTTP/1.0)никогда не используются для проверки записи в кэше.</target>
        </trans-unit>
        <trans-unit id="e894f8457ed794b88882865f6c9931e22354537d" translate="yes" xml:space="preserve">
          <source>The principle behind entity-tags is that only the service author
   knows the implementation of a resource well enough to select the most
   accurate and efficient validation mechanism for that resource, and
   that any such mechanism can be mapped to a simple sequence of octets
   for easy comparison.  Since the value is opaque, there is no need for
   the client to be aware of how each entity-tag is constructed.

   For example, a resource that has implementation-specific versioning
   applied to all changes might use an internal revision number, perhaps
   combined with a variance identifier for content negotiation, to
   accurately differentiate between representations.  Other
   implementations might use a collision-resistant hash of
   representation content, a combination of various file attributes, or
   a modification timestamp that has sub-second resolution.

   An origin server SHOULD send an ETag for any selected representation
   for which detection of changes can be reasonably and consistently
   determined, since the entity-tag's use in conditional requests and
   evaluating cache freshness ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]) can result in a substantial
   reduction of HTTP network traffic and can be a significant factor in
   improving service scalability and reliability.</source>
          <target state="translated">Принцип, лежащий в основе тегов сущностей, заключается в том, что только автор сервиса знает реализацию ресурса достаточно хорошо, чтобы выбрать наиболее точный и эффективный механизм проверки для этого ресурса, и что любой такой механизм может быть сопоставлен с простой последовательностью октетов для легкого сравнения. , Поскольку значение непрозрачно, клиенту не нужно знать, как создается каждый объект-тег. Например, ресурс, в котором ко всем изменениям применяется управление версиями, зависящее от реализации, может использовать внутренний номер редакции, возможно, в сочетании с идентификатором отклонения для согласования содержимого, чтобы точно различать представления. В других реализациях может использоваться устойчивый к коллизиям хэш содержимого представления, комбинация различных атрибутов файла,или отметка времени модификации с разрешением менее секунды. Исходному серверу СЛЕДУЕТ отправлять ETag для любого выбранного представления, для которого можно разумно и последовательно определять обнаружение изменений, поскольку использование тега объекта в условных запросах и оценке актуальности кеша ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ]) может привести к существенному сокращению сетевого трафика HTTP и может стать важным фактором повышения масштабируемости и надежности услуг.</target>
        </trans-unit>
        <trans-unit id="c1875060cbf6a72a618b42c5d094d85aee6d41e8" translate="yes" xml:space="preserve">
          <source>The principle is simple, but there is one potential problem: if the downloaded resource has been modified between both downloads, the obtained ranges will correspond to two different versions of the resource, and the final document will be corrupted.</source>
          <target state="translated">Принцип прост,но есть одна потенциальная проблема:если скачанный ресурс был изменен между обеими загрузками,то полученные диапазоны будут соответствовать двум разным версиям ресурса,а итоговый документ будет поврежден.</target>
        </trans-unit>
        <trans-unit id="2f036bd357e0e56c778c2d79ff8ac18d032812cb" translate="yes" xml:space="preserve">
          <source>The protocol that is used. Usually it is the HTTP protocol or its secured version, HTTPS.</source>
          <target state="translated">Используемый протокол.Обычно это протокол HTTP или его защищенная версия,HTTPS.</target>
        </trans-unit>
        <trans-unit id="2ec525dcadd68d3467f5291ea2396006096b487a" translate="yes" xml:space="preserve">
          <source>The purpose of an HTTP cache is to store information received in
   response to requests for use in responding to future requests. In
   many cases, a cache simply returns the appropriate parts of a
   response to the requester. However, if the cache holds a cache entry
   based on a previous response, it might have to combine parts of a new
   response with what is held in the cache entry.</source>
          <target state="translated">Целью HTTP-кэша является хранение информации,полученной в ответ на запросы для использования в ответ на будущие запросы.Во многих случаях кэш просто возвращает соответствующие части ответа на запрос.Однако,если в кэше хранится запись в кэше,основанная на предыдущем ответе,возможно,придется объединить части нового ответа с тем,что содержится в записи в кэше.</target>
        </trans-unit>
        <trans-unit id="6728c1b09c31f5d826dfb315c8231a9800e8a7de" translate="yes" xml:space="preserve">
          <source>The purpose of the 100 (Continue) status (see &lt;a href=&quot;#section-10.1.1&quot;&gt;section 10.1.1&lt;/a&gt;) is to
   allow a client that is sending a request message with a request body
   to determine if the origin server is willing to accept the request
   (based on the request headers) before the client sends the request
   body. In some cases, it might either be inappropriate or highly
   inefficient for the client to send the body if the server will reject
   the message without looking at the body.

   Requirements for HTTP/1.1 clients:

      - If a client will wait for a 100 (Continue) response before
        sending the request body, it MUST send an Expect request-header
        field (&lt;a href=&quot;#section-14.20&quot;&gt;section 14.20&lt;/a&gt;) with the &quot;100-continue&quot; expectation.

      - A client MUST NOT send an Expect request-header field (&lt;a href=&quot;#section-14.20&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;) with the &quot;100-continue&quot; expectation if it does not intend
        to send a request body.

   Because of the presence of older implementations, the protocol allows
   ambiguous situations in which a client may send &quot;Expect: 100-
   continue&quot; without receiving either a 417 (Expectation Failed) status
   or a 100 (Continue) status. Therefore, when a client sends this
   header field to an origin server (possibly via a proxy) from which it
   has never seen a 100 (Continue) status, the client SHOULD NOT wait
   for an indefinite period before sending the request body.

   Requirements for HTTP/1.1 origin servers:

      - Upon receiving a request which includes an Expect request-header
        field with the &quot;100-continue&quot; expectation, an origin server MUST
        either respond with 100 (Continue) status and continue to read
        from the input stream, or respond with a final status code. The
        origin server MUST NOT wait for the request body before sending
        the 100 (Continue) response. If it responds with a final status
        code, it MAY close the transport connection or it MAY continue 

        to read and discard the rest of the request.  It MUST NOT
        perform the requested method if it returns a final status code.

      - An origin server SHOULD NOT send a 100 (Continue) response if
        the request message does not include an Expect request-header
        field with the &quot;100-continue&quot; expectation, and MUST NOT send a
        100 (Continue) response if such a request comes from an HTTP/1.0
        (or earlier) client. There is an exception to this rule: for
        compatibility with &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, a server MAY send a 100 (Continue)
        status in response to an HTTP/1.1 PUT or POST request that does
        not include an Expect request-header field with the &quot;100-
        continue&quot; expectation. This exception, the purpose of which is
        to minimize any client processing delays associated with an
        undeclared wait for 100 (Continue) status, applies only to
        HTTP/1.1 requests, and not to requests with any other HTTP-
        version value.

      - An origin server MAY omit a 100 (Continue) response if it has
        already received some or all of the request body for the
        corresponding request.

      - An origin server that sends a 100 (Continue) response MUST
        ultimately send a final status code, once the request body is
        received and processed, unless it terminates the transport
        connection prematurely.

      - If an origin server receives a request that does not include an
        Expect request-header field with the &quot;100-continue&quot; expectation,
        the request includes a request body, and the server responds
        with a final status code before reading the entire request body
        from the transport connection, then the server SHOULD NOT close
        the transport connection until it has read the entire request,
        or until the client closes the connection. Otherwise, the client
        might not reliably receive the response message. However, this
        requirement is not be construed as preventing a server from
        defending itself against denial-of-service attacks, or from
        badly broken client implementations.

   Requirements for HTTP/1.1 proxies:

      - If a proxy receives a request that includes an Expect request-
        header field with the &quot;100-continue&quot; expectation, and the proxy
        either knows that the next-hop server complies with HTTP/1.1 or
        higher, or does not know the HTTP version of the next-hop
        server, it MUST forward the request, including the Expect header
        field. 

      - If the proxy knows that the version of the next-hop server is
        HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST
        respond with a 417 (Expectation Failed) status.

      - Proxies SHOULD maintain a cache recording the HTTP version
        numbers received from recently-referenced next-hop servers.

      - A proxy MUST NOT forward a 100 (Continue) response if the
        request message was received from an HTTP/1.0 (or earlier)
        client and did not include an Expect request-header field with
        the &quot;100-continue&quot; expectation. This requirement overrides the
        general rule for forwarding of 1xx responses (see &lt;a href=&quot;#section-10.1&quot;&gt;section 10.1&lt;/a&gt;).</source>
          <target state="translated">Назначение статуса 100 (Продолжить) (см. &lt;a href=&quot;#section-10.1.1&quot;&gt;Раздел 10.1.1&lt;/a&gt; ) - позволить клиенту, который отправляет сообщение запроса с телом запроса, определить, готов ли исходный сервер принять запрос (на основе заголовков запроса). до того, как клиент отправит тело запроса. В некоторых случаях для клиента может быть неприемлемо или крайне неэффективно отправлять тело, если сервер отклонит сообщение, не глядя на тело. Требования для клиентов HTTP / 1.1: - Если клиент будет ждать ответа 100 (продолжить) перед отправкой тела запроса, он ДОЛЖЕН отправить поле заголовка запроса Expect ( &lt;a href=&quot;#section-14.20&quot;&gt;раздел 14.20&lt;/a&gt; ) с ожиданием &amp;laquo;100-continue&amp;raquo;. - Клиент НЕ ДОЛЖЕН отправлять поле заголовка запроса Expect ( &lt;a href=&quot;#section-14.20&quot;&gt;раздел&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14,20&lt;/a&gt;) с ожиданием &amp;laquo;100-continue&amp;raquo;, если он не намерен отправлять тело запроса. Из-за наличия более старых реализаций протокол допускает неоднозначные ситуации, в которых клиент может послать &amp;laquo;Expect: 100-continue&amp;raquo;, не получив ни статуса 417 (Expectation Failed), ни статуса 100 (Continue). Следовательно, когда клиент отправляет это поле заголовка на исходный сервер (возможно, через прокси), от которого он никогда не видел статус 100 (Продолжить), клиенту НЕ СЛЕДУЕТ ждать неопределенное время перед отправкой тела запроса. Требования к исходным серверам HTTP / 1.1: - После получения запроса, который включает поле заголовка запроса Expect с ожиданием &amp;laquo;100-continue&amp;raquo;,исходный сервер ДОЛЖЕН либо ответить статусом 100 (Продолжить) и продолжить чтение из входного потока, либо ответить кодом окончательного статуса. Исходный сервер НЕ ДОЛЖЕН ждать тела запроса перед отправкой ответа 100 (Продолжить). Если он отвечает окончательным кодом состояния, он МОЖЕТ закрыть транспортное соединение или МОЖЕТ продолжить чтение и отклонить остальную часть запроса. Он НЕ ДОЛЖЕН выполнять запрошенный метод, если он возвращает окончательный код состояния. - Исходному серверу НЕ СЛЕДУЕТ отправлять ответ 100 (продолжить), если сообщение запроса не включает поле заголовка запроса Expect с ожиданием &quot;100-continue&quot;, и НЕ ДОЛЖЕН отправлять ответ 100 (продолжить), если такой запрос приходит. от клиента HTTP / 1.0 (или более ранней версии).Есть исключение из этого правила: для совместимости с&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, сервер МОЖЕТ отправить статус 100 (Продолжить) в ответ на запрос HTTP / 1.1 PUT или POST, который не включает поле заголовка запроса Expect с ожиданием &amp;laquo;100-continue&amp;raquo;. Это исключение, целью которого является минимизация любых задержек обработки клиентов, связанных с необъявленным ожиданием состояния 100 (Продолжить), применяется только к запросам HTTP / 1.1, а не к запросам с любым другим значением версии HTTP. - Исходный сервер МОЖЕТ пропустить ответ 100 (продолжить), если он уже получил часть или все тело запроса для соответствующего запроса. - Исходный сервер, который отправляет ответ 100 (Продолжить), ДОЛЖЕН в конечном итоге отправить окончательный код состояния после получения и обработки тела запроса,если только он преждевременно не разорвет транспортное соединение. - Если исходный сервер получает запрос, который не включает поле заголовка запроса Expect с ожиданием &amp;laquo;100-continue&amp;raquo;, запрос включает тело запроса, и сервер отвечает окончательным кодом состояния перед чтением всего тела запроса из транспортного соединения, то серверу НЕ СЛЕДУЕТ закрывать транспортное соединение, пока он не прочитает весь запрос или пока клиент не закроет соединение. В противном случае клиент может не получить надежное ответное сообщение. Однако это требование не должно толковаться как предотвращение защиты сервера от атак типа &amp;laquo;отказ в обслуживании&amp;raquo; или от плохо выполненных клиентских реализаций.Требования для прокси HTTP / 1.1: - Если прокси-сервер получает запрос, который включает поле заголовка запроса Expect с ожиданием &amp;laquo;100-continue&amp;raquo;, и прокси-сервер либо знает, что сервер следующего перехода соответствует HTTP / 1.1 или выше, или не знает HTTP-версию сервера следующего перехода, он ДОЛЖЕН переслать запрос, включая поле заголовка Expect. - Если прокси-сервер знает, что версия сервера следующего перехода - HTTP / 1.0 или ниже, он НЕ ДОЛЖЕН пересылать запрос и ДОЛЖЕН ответить статусом 417 (ожидание не выполнено). - Прокси-серверы ДОЛЖНЫ поддерживать кэш, в котором записываются номера версий HTTP, полученные от недавно использованных серверов следующего перехода.- Прокси-сервер НЕ ДОЛЖЕН пересылать ответ 100 (продолжить), если сообщение запроса было получено от клиента HTTP / 1.0 (или более ранней версии) и не включало поле заголовка запроса Expect с ожиданием &amp;laquo;100-continue&amp;raquo;. Это требование отменяет общее правило пересылки ответов 1xx (см.&lt;a href=&quot;#section-10.1&quot;&gt;раздел 10.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0b61f958141b9100243d1bc18970ced7c1dcafec" translate="yes" xml:space="preserve">
          <source>The quoted string is the Base64 encoded &lt;em&gt;Subject Public Key Information&lt;/em&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;) fingerprint. It is possible to specify multiple pins for different public keys. Some browsers might allow other hashing algorithms than SHA-256 in the future. See below on how to extract this information out of a certificate or key file.</source>
          <target state="translated">Строка в кавычках является кодировкой Base64 &lt;em&gt;Subject Public Key Information&lt;/em&gt; ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt; ) отпечатков пальцев. Можно указать несколько контактов для разных открытых ключей. В некоторых браузерах в будущем могут быть разрешены другие алгоритмы хеширования, кроме SHA-256. См. Ниже, как извлечь эту информацию из файла сертификата или ключа.</target>
        </trans-unit>
        <trans-unit id="caac15f88bc560faaa8d23301f149cd934db87b9" translate="yes" xml:space="preserve">
          <source>The quoted string is the Base64 encoded Subject Public Key Information (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;) fingerprint. It is possible to specify multiple pins for different public keys. Some browsers might allow other hashing algorithms than SHA-256 in the future.</source>
          <target state="translated">Строка в кавычках представляет собой отпечаток &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt; в кодировке Base64 . Можно указать несколько контактов для разных открытых ключей. В некоторых браузерах в будущем могут быть разрешены другие алгоритмы хеширования, кроме SHA-256.</target>
        </trans-unit>
        <trans-unit id="048868ca8bba5de4473c03e4f113e14a03b3840f" translate="yes" xml:space="preserve">
          <source>The range specified by the &lt;code&gt;Range&lt;/code&gt; header field in the request can't be fulfilled; it's possible that the range is outside the size of the target URI's data.</source>
          <target state="translated">Диапазон, указанный в поле заголовка &lt;code&gt;Range&lt;/code&gt; в запросе, не может быть выполнен; возможно, что диапазон выходит за пределы размера данных целевого URI.</target>
        </trans-unit>
        <trans-unit id="1d2b5330a14328ad92bbc96c72d50b3c95138424" translate="yes" xml:space="preserve">
          <source>The recommendation is to compress data as much as possible and therefore to use this field, but some types of resources, such as jpeg images, are already compressed. Sometimes, using additional compression doesn't reduce payload size and can even make the payload longer.</source>
          <target state="translated">Рекомендуется сжимать данные как можно больше и,следовательно,использовать это поле,но некоторые виды ресурсов,такие как jpeg изображения,уже сжаты.Иногда использование дополнительного сжатия не уменьшает размер полезной нагрузки и даже может сделать ее длиннее.</target>
        </trans-unit>
        <trans-unit id="b4310de37bf5d5b890a2b93359f92ce5fd4a2747" translate="yes" xml:space="preserve">
          <source>The recommended way of sniffing for Gecko-based browsers (if you &lt;em&gt;have to&lt;/em&gt; sniff for the browser engine instead of using feature detection) is by the presence of the &quot;&lt;code&gt;Gecko&lt;/code&gt;&quot; and &quot;&lt;code&gt;rv:&lt;/code&gt;&quot; strings, since some other browsers include a &quot;&lt;code&gt;like Gecko&lt;/code&gt;&quot; token.</source>
          <target state="translated">Рекомендуемый способ сниффинга для браузеров на основе Gecko (если вам &lt;em&gt;нужно&lt;/em&gt; сниффать движок браузера вместо использования функции обнаружения) - это наличие строк &amp;laquo; &lt;code&gt;Gecko&lt;/code&gt; &amp;raquo; и &amp;laquo; &lt;code&gt;rv:&lt;/code&gt; &amp;raquo;, поскольку некоторые другие браузеры включают в себя строку &amp;laquo; &lt;code&gt;like Gecko&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="835a33da74dbfed0d3a5afc284d8d5f7eeac4750" translate="yes" xml:space="preserve">
          <source>The referrer of the document in which the violation occurred.</source>
          <target state="translated">Ссылка на документ,в котором произошло нарушение.</target>
        </trans-unit>
        <trans-unit id="457d2e04c3cca60af5bcc1e43cb940e66612e208" translate="yes" xml:space="preserve">
          <source>The registry has been populated with the registrations below:

   +-----------+----------------------------------+---------------+
   | Warn Code | Short Description                | Reference     |
   +-----------+----------------------------------+---------------+
   | 110       | Response is Stale                | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt; |
   | 111       | Revalidation Failed              | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; |
   | 112       | Disconnected Operation           | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt; |
   | 113       | Heuristic Expiration             | &lt;a href=&quot;#section-5.5.4&quot;&gt;Section 5.5.4&lt;/a&gt; |
   | 199       | Miscellaneous Warning            | &lt;a href=&quot;#section-5.5.5&quot;&gt;Section 5.5.5&lt;/a&gt; |
   | 214       | Transformation Applied           | &lt;a href=&quot;#section-5.5.6&quot;&gt;Section 5.5.6&lt;/a&gt; |
   | 299       | Miscellaneous Persistent Warning | &lt;a href=&quot;#section-5.5.7&quot;&gt;Section 5.5.7&lt;/a&gt; |
   +-----------+----------------------------------+---------------+</source>
          <target state="translated">В реестр внесены следующие регистрации: + ----------- + --------------------------- ------- + --------------- + | Код предупреждения | Краткое описание | Справка | + ----------- + ---------------------------------- + - ------------- + | 110 | Ответ устарел | &lt;a href=&quot;#section-5.5.1&quot;&gt;Раздел 5.5.1&lt;/a&gt; | | 111 | Ошибка повторной проверки | &lt;a href=&quot;#section-5.5.2&quot;&gt;Раздел 5.5.2&lt;/a&gt; | | 112 | Отключенная операция | &lt;a href=&quot;#section-5.5.3&quot;&gt;Раздел 5.5.3&lt;/a&gt; | | 113 | Эвристическое истечение срока | &lt;a href=&quot;#section-5.5.4&quot;&gt;Раздел 5.5.4&lt;/a&gt; | | 199 | Разное предупреждение | &lt;a href=&quot;#section-5.5.5&quot;&gt;Раздел 5.5.5&lt;/a&gt; | | 214 | Прикладная трансформация | &lt;a href=&quot;#section-5.5.6&quot;&gt;Раздел 5.5.6&lt;/a&gt;| | 299 | Разное постоянное предупреждение | &lt;a href=&quot;#section-5.5.7&quot;&gt;Раздел 5.5.7&lt;/a&gt; | + ----------- + ---------------------------------- + - ------------- +</target>
        </trans-unit>
        <trans-unit id="6bfb04acf1092d994bf84da7df6bb36e8f3a785e" translate="yes" xml:space="preserve">
          <source>The registry has been populated with the registrations below:

   +------------------------+----------------------------------+
   | Cache Directive        | Reference                        |
   +------------------------+----------------------------------+
   | max-age                | &lt;a href=&quot;#section-5.2.1.1&quot;&gt;Section 5.2.1.1&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt; |
   | max-stale              | &lt;a href=&quot;#section-5.2.1.2&quot;&gt;Section 5.2.1.2&lt;/a&gt;                  |
   | min-fresh              | &lt;a href=&quot;#section-5.2.1.3&quot;&gt;Section 5.2.1.3&lt;/a&gt;                  |
   | must-revalidate        | &lt;a href=&quot;#section-5.2.2.1&quot;&gt;Section 5.2.2.1&lt;/a&gt;                  |
   | no-cache               | &lt;a href=&quot;#section-5.2.1.4&quot;&gt;Section 5.2.1.4&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.2&quot;&gt;Section 5.2.2.2&lt;/a&gt; |
   | no-store               | &lt;a href=&quot;#section-5.2.1.5&quot;&gt;Section 5.2.1.5&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.3&quot;&gt;Section 5.2.2.3&lt;/a&gt; |
   | no-transform           | &lt;a href=&quot;#section-5.2.1.6&quot;&gt;Section 5.2.1.6&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.4&quot;&gt;Section 5.2.2.4&lt;/a&gt; |
   | only-if-cached         | &lt;a href=&quot;#section-5.2.1.7&quot;&gt;Section 5.2.1.7&lt;/a&gt;                  |
   | private                | &lt;a href=&quot;#section-5.2.2.6&quot;&gt;Section 5.2.2.6&lt;/a&gt;                  |
   | proxy-revalidate       | &lt;a href=&quot;#section-5.2.2.7&quot;&gt;Section 5.2.2.7&lt;/a&gt;                  |
   | public                 | &lt;a href=&quot;#section-5.2.2.5&quot;&gt;Section 5.2.2.5&lt;/a&gt;                  |
   | s-maxage               | &lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;                  |
   | stale-if-error         | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-4&quot;&gt;[RFC5861], Section&amp;nbsp;4&lt;/a&gt;             |
   | stale-while-revalidate | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-3&quot;&gt;[RFC5861], Section&amp;nbsp;3&lt;/a&gt;             |
   +------------------------+----------------------------------+</source>
          <target state="translated">В реестр внесены следующие регистрации: + ------------------------ + -------------- -------------------- + | Директива кеширования | Справка | + ------------------------ + ------------------------ ---------- + | макс-возраст | &lt;a href=&quot;#section-5.2.1.1&quot;&gt;Раздел 5.2.1.1&lt;/a&gt; , &lt;a href=&quot;#section-5.2.2.8&quot;&gt;Раздел 5.2.2.8&lt;/a&gt; | | макс несвежий | &lt;a href=&quot;#section-5.2.1.2&quot;&gt;Раздел 5.2.1.2&lt;/a&gt; | | мин-фреш | &lt;a href=&quot;#section-5.2.1.3&quot;&gt;Раздел 5.2.1.3&lt;/a&gt; | | необходимо перевалидировать | &lt;a href=&quot;#section-5.2.2.1&quot;&gt;Раздел 5.2.2.1&lt;/a&gt; | | без кеша | &lt;a href=&quot;#section-5.2.1.4&quot;&gt;Раздел 5.2.1.4&lt;/a&gt; , &lt;a href=&quot;#section-5.2.2.2&quot;&gt;Раздел 5.2.2.2&lt;/a&gt; | | нет магазина | &lt;a href=&quot;#section-5.2.1.5&quot;&gt;Раздел 5.2.1.5&lt;/a&gt; ,&lt;a href=&quot;#section-5.2.2.3&quot;&gt;Раздел 5.2.2.3&lt;/a&gt; | | без преобразования | &lt;a href=&quot;#section-5.2.1.6&quot;&gt;Раздел 5.2.1.6&lt;/a&gt; , &lt;a href=&quot;#section-5.2.2.4&quot;&gt;Раздел 5.2.2.4&lt;/a&gt; | | только если кэшируется | &lt;a href=&quot;#section-5.2.1.7&quot;&gt;Раздел 5.2.1.7&lt;/a&gt; | | частный | &lt;a href=&quot;#section-5.2.2.6&quot;&gt;Раздел 5.2.2.6&lt;/a&gt; | | прокси-ревалидат | &lt;a href=&quot;#section-5.2.2.7&quot;&gt;Раздел 5.2.2.7&lt;/a&gt; | | общественный | &lt;a href=&quot;#section-5.2.2.5&quot;&gt;Раздел 5.2.2.5&lt;/a&gt; | | s-maxage | &lt;a href=&quot;#section-5.2.2.9&quot;&gt;Раздел 5.2.2.9&lt;/a&gt; | | устаревшая-если-ошибка | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-4&quot;&gt;[RFC5861], раздел 4&lt;/a&gt; | | просроченный во время повторной валидации | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-3&quot;&gt;[RFC5861], раздел 3&lt;/a&gt; | + ------------------------ + ------------------------ ---------- +</target>
        </trans-unit>
        <trans-unit id="6c3e9e6ad9f0e3368fa4d44e9aa2e2c33c90d7a5" translate="yes" xml:space="preserve">
          <source>The relevant RFC document for the &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Upgrade header field is RFC 7230, section 6.7&lt;/a&gt;. The standard establishes rules for upgrading or changing to a different protocol on the current client, server, transport protocol connection. For example, this header standard allows a client to change from HTTP 1.1 to HTTP 2.0, assuming the server decides to acknowledge and implement the Upgrade header field. Neither party is required to accept the terms specified in the Upgrade header field. It can be used in both client and server headers. If the Upgrade header field is specified, then the sender MUST also send the Connection header field with the upgrade option specified. For details on the Connection header field &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;please see section 6.1 of the aforementioned RFC&lt;/a&gt;.</source>
          <target state="translated">Соответствующий документ RFC для &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;поля заголовка обновления - RFC 7230, раздел 6.7&lt;/a&gt; . Стандарт устанавливает правила для обновления или перехода на другой протокол для текущего клиента, сервера, транспортного протокола соединения. Например, этот стандарт заголовка позволяет клиенту перейти с HTTP 1.1 на HTTP 2.0, предполагая, что сервер решит подтвердить и реализовать поле заголовка Upgrade. Ни одна из сторон не обязана принимать условия, указанные в поле заголовка &amp;laquo;Обновление&amp;raquo;. Его можно использовать как в заголовках клиента, так и сервера. Если указано поле заголовка обновления, то отправитель ДОЛЖЕН также отправить поле заголовка соединения с указанной опцией обновления. Подробнее о поле заголовка соединения &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;см. Раздел 6.1 вышеупомянутого RFC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9681bfccce6746b808712df87789877aff1a0a08" translate="yes" xml:space="preserve">
          <source>The remaining response header fields provide more information about
   the target resource for potential use in later requests.

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Accept-Ranges     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7233]&lt;/a&gt; |
   | Allow             | &lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;            |
   | Server            | &lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;            |
   +-------------------+--------------------------+</source>
          <target state="translated">Остальные поля заголовка ответа предоставляют дополнительную информацию о целевом ресурсе для потенциального использования в последующих запросах. + ------------------- + -------------------------- + | Имя поля заголовка | Определено в ... | + ------------------- + -------------------------- + | Принять-диапазоны | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-2.3&quot;&gt;Раздел 2.3 [RFC7233]&lt;/a&gt; | | Разрешить | &lt;a href=&quot;#section-7.4.1&quot;&gt;Раздел 7.4.1&lt;/a&gt; | | Сервер | &lt;a href=&quot;#section-7.4.2&quot;&gt;Раздел 7.4.2&lt;/a&gt; | + ------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="4af6457a5675ed1ed5b26a3a3626f6948e42d207" translate="yes" xml:space="preserve">
          <source>The report JSON object contains the following data:</source>
          <target state="translated">Отчет JSON объекта содержит следующие данные:</target>
        </trans-unit>
        <trans-unit id="5baf54425251a0af52438742ec528ea5d7cad288" translate="yes" xml:space="preserve">
          <source>The representation data associated with an HTTP message is either
   provided as the payload body of the message or referred to by the
   message semantics and the effective request URI.  The representation
   data is in a format and encoding defined by the representation
   metadata header fields.

   The data type of the representation data is determined via the header
   fields Content-Type and Content-Encoding.  These define a two-layer,
   ordered encoding model:

     representation-data := Content-Encoding( Content-Type( bits ) )</source>
          <target state="translated">Данные представления,связанные с сообщением HTTP,либо предоставляются в качестве тела полезной нагрузки сообщения,либо на них ссылаются семантика сообщения и действующий URI запроса.Данные представления представлены в формате и кодировке,определяемых полями заголовка метаданных представления.Тип данных представления определяется полями заголовков Content-Type и Content-Encoding.Они определяют двухуровневую,упорядоченную модель кодирования:representation-data :=Content-Encoding(Content-Type(bit))</target>
        </trans-unit>
        <trans-unit id="57fb990a7173c920416af3c97b46113340011437" translate="yes" xml:space="preserve">
          <source>The request could not be completed due to a conflict with the current
   state of the resource. This code is only allowed in situations where
   it is expected that the user might be able to resolve the conflict
   and resubmit the request. The response body SHOULD include enough 

   information for the user to recognize the source of the conflict.
   Ideally, the response entity would include enough information for the
   user or user agent to fix the problem; however, that might not be
   possible and is not required.

   Conflicts are most likely to occur in response to a PUT request. For
   example, if versioning were being used and the entity being PUT
   included changes to a resource which conflict with those made by an
   earlier (third-party) request, the server might use the 409 response
   to indicate that it can't complete the request. In this case, the
   response entity would likely contain a list of the differences
   between the two versions in a format defined by the response
   Content-Type.</source>
          <target state="translated">Запрос не мог быть выполнен из-за конфликта с текущим состоянием ресурса.Данный код разрешен только в ситуациях,когда ожидается,что пользователь сможет разрешить конфликт и повторно отправить запрос.Орган ответа ДОЛЖЕН содержать достаточно информации для того,чтобы пользователь мог распознать источник конфликта.В идеале,орган ответа должен содержать достаточно информации для того,чтобы пользователь или пользовательский агент мог решить проблему;однако,это может быть невозможно и не требуется.Конфликты чаще всего возникают в ответ на запрос PUT.Например,если используется версионирование и в сущность PUT включены изменения ресурса,которые конфликтуют с теми,которые были сделаны более ранним (сторонним)запросом,сервер может использовать ответ 409,чтобы указать,что он не может завершить запрос.В этом случае сущность ответа,скорее всего,будет содержать список различий между двумя версиями в формате,определяемом типом ответа Content-Type.</target>
        </trans-unit>
        <trans-unit id="62943efc1c331624006dfa87f2880914c04923b3" translate="yes" xml:space="preserve">
          <source>The request could not be understood by the server due to malformed
   syntax. The client SHOULD NOT repeat the request without
   modifications.</source>
          <target state="translated">Запрос не мог быть понят сервером из-за некорректного синтаксиса.Клиент НЕ ДОЛЖЕН повторять запрос без изменений.</target>
        </trans-unit>
        <trans-unit id="a5f388607fcf883d14ee29792afda2dc8c83b32d" translate="yes" xml:space="preserve">
          <source>The request failed due to failure of a previous request.</source>
          <target state="translated">Запрос не удался в связи с неудачей предыдущего запроса.</target>
        </trans-unit>
        <trans-unit id="80b2b18dab161f54208331e259eefdc84181c453" translate="yes" xml:space="preserve">
          <source>The request has been accepted for processing, but the processing has
   not been completed.  The request might or might not eventually be
   acted upon, as it might be disallowed when processing actually takes
   place. There is no facility for re-sending a status code from an
   asynchronous operation such as this.

   The 202 response is intentionally non-committal. Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed. The entity returned with this
   response SHOULD include an indication of the request's current status
   and either a pointer to a status monitor or some estimate of when the
   user can expect the request to be fulfilled.</source>
          <target state="translated">Запрос был принят на обработку,но обработка не была завершена.В конце концов,запрос может быть обработан,а может и не быть,так как он может быть отклонен,когда обработка действительно происходит.Нет возможности повторно отправить код статуса от такой асинхронной операции.Ответ 202 намеренно не является обязательным.Его цель-позволить серверу принять запрос на какой-то другой процесс (возможно,пакетно-ориентированный процесс,который запускается только один раз в день),не требуя,чтобы соединение пользовательского агента с сервером сохранялось до завершения процесса.Сущность,возвращаемая с этим ответом SHOULD,включает в себя указание текущего состояния запроса и либо указатель на монитор состояния,либо некоторую оценку того,когда пользователь может ожидать,что запрос будет выполнен.</target>
        </trans-unit>
        <trans-unit id="3496a6a34429a71d096b5d661e42c1a9bb755e60" translate="yes" xml:space="preserve">
          <source>The request has been fulfilled and resulted in a new resource being
   created. The newly created resource can be referenced by the URI(s)
   returned in the entity of the response, with the most specific URI
   for the resource given by a Location header field. The response
   SHOULD include an entity containing a list of resource
   characteristics and location(s) from which the user or user agent can
   choose the one most appropriate. The entity format is specified by
   the media type given in the Content-Type header field. The origin
   server MUST create the resource before returning the 201 status code.
   If the action cannot be carried out immediately, the server SHOULD
   respond with 202 (Accepted) response instead.

   A 201 response MAY contain an ETag response header field indicating
   the current value of the entity tag for the requested variant just
   created, see &lt;a href=&quot;#section-14.19&quot;&gt;section 14.19&lt;/a&gt;.</source>
          <target state="translated">Запрос был выполнен, и в результате был создан новый ресурс. На вновь созданный ресурс можно ссылаться с помощью URI, возвращаемого в сущности ответа, с наиболее конкретным URI для ресурса, заданным полем заголовка Location. Ответ ДОЛЖЕН включать объект, содержащий список характеристик ресурса и местоположения, из которых пользователь или пользовательский агент может выбрать наиболее подходящий. Формат объекта определяется типом носителя, указанным в поле заголовка Content-Type. Исходный сервер ДОЛЖЕН создать ресурс перед возвратом кода состояния 201. Если действие не может быть выполнено немедленно, сервер ДОЛЖЕН ответить ответом 202 (Принято).Ответ 201 МОЖЕТ содержать поле заголовка ответа ETag, указывающее текущее значение тега объекта для только что созданного запрошенного варианта, см.&lt;a href=&quot;#section-14.19&quot;&gt;Раздел 14.19&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7d84e18807de0c6356f2f62e25c75fb03b74e11" translate="yes" xml:space="preserve">
          <source>The request has been received but not yet acted upon. It is non-committal, meaning that there is no way in HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">Просьба была получена,но по ней еще не принято никаких мер.Он не является обязательным,а это означает,что нет способа в HTTP,чтобы позже отправить асинхронный ответ,указывающий на результат обработки запроса.Он предназначен для случаев,когда другой процесс или сервер обрабатывает запрос,или для пакетной обработки.</target>
        </trans-unit>
        <trans-unit id="563c97ec35447bf615f29b9828050c09a712103e" translate="yes" xml:space="preserve">
          <source>The request has more than one possible response. The user-agent or user should choose one of them. There is no standardized way of choosing one of the responses.</source>
          <target state="translated">Запрос имеет более чем один возможный ответ.Пользователь-агент или пользователь должен выбрать один из них.Стандартизированного способа выбора одного из ответов не существует.</target>
        </trans-unit>
        <trans-unit id="5487d137616e521aa017175b35b13aa2e3f74d3d" translate="yes" xml:space="preserve">
          <source>The request has succeeded and a new resource has been created as a result of it. This is typically the response sent after a POST request, or after some PUT requests.</source>
          <target state="translated">Запрос удался,в результате чего был создан новый ресурс.Обычно это ответ,отправленный после POST запроса,или после некоторых PUT запросов.</target>
        </trans-unit>
        <trans-unit id="d8ecc9cc6596038de67ec68a577d983da6a673ef" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The information returned with the response
   is dependent on the method used in the request, for example:

   GET    an entity corresponding to the requested resource is sent in
          the response;

   HEAD   the entity-header fields corresponding to the requested
          resource are sent in the response without any message-body;

   POST   an entity describing or containing the result of the action; 

   TRACE  an entity containing the request message as received by the
          end server.</source>
          <target state="translated">Запрос удался.Информация,возвращаемая с ответом,зависит,например,от метода,использованного в запросе:GET в ответе посылается сущность,соответствующая запрашиваемому ресурсу;HEAD поля заголовка сущности,соответствующие запрашиваемому ресурсу,посылаются в ответе без тел сообщения;POST сущность,описывающая или содержащая результат действия;TRACE сущность,содержащая запросное сообщение в том виде,в котором оно было получено конечным сервером.</target>
        </trans-unit>
        <trans-unit id="f565b6003126123248442292df2bf9baaa5e391b" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The meaning of a success varies depending on the HTTP method:</source>
          <target state="translated">Запрос удался.Смысл успеха варьируется в зависимости от метода HTTP:</target>
        </trans-unit>
        <trans-unit id="d11383f57aada516934509a2d3957090ac4763bc" translate="yes" xml:space="preserve">
          <source>The request looks something like this (less interesting headers are omitted here):</source>
          <target state="translated">Запрос выглядит примерно так (здесь опущены менее интересные заголовки):</target>
        </trans-unit>
        <trans-unit id="0c671ed51daf22d159e04d7c4fd432023c8f3806" translate="yes" xml:space="preserve">
          <source>The request method and the body will not be altered, whereas &lt;a href=&quot;301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; may incorrectly sometimes be changed to a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Метод запроса и тело не будут изменены, тогда как &lt;a href=&quot;301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt; иногда может быть неправильно изменен на метод &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e391f1f093da1eaf3c8079eb9f1cb969d2137823" translate="yes" xml:space="preserve">
          <source>The request method is known by the server but has been disabled and cannot be used. For example, an API may forbid DELETE-ing a resource. The two mandatory methods, &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt;, must never be disabled and should not return this error code.</source>
          <target state="translated">Метод запроса известен серверу, но он отключен и не может быть использован. Например, API может запретить УДАЛЕНИЕ ресурса. Два обязательных метода, &lt;code&gt;GET&lt;/code&gt; и &lt;code&gt;HEAD&lt;/code&gt; , никогда не должны отключаться и не должны возвращать этот код ошибки.</target>
        </trans-unit>
        <trans-unit id="3868804eb59e6799895608f9d8fc1f4241a46d74" translate="yes" xml:space="preserve">
          <source>The request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">Метод запроса не поддерживается сервером и не может быть обработан. Единственные методы, которые серверы должны поддерживать (и, следовательно, не должны возвращать этот код), - это &lt;code&gt;GET&lt;/code&gt; и &lt;code&gt;HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cacbb0963918be12f6522f203c0731acc095523b" translate="yes" xml:space="preserve">
          <source>The request method token is the primary source of request semantics;
   it indicates the purpose for which the client has made this request
   and what is expected by the client as a successful result.

   The request method's semantics might be further specialized by the
   semantics of some header fields when present in a request (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;)
   if those additional semantics do not conflict with the method.  For
   example, a client can send conditional request header fields
   (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;) to make the requested action conditional on the current
   state of the target resource ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]).

     method = token

   HTTP was originally designed to be usable as an interface to
   distributed object systems.  The request method was envisioned as
   applying semantics to a target resource in much the same way as
   invoking a defined method on an identified object would apply
   semantics.  The method token is case-sensitive because it might be
   used as a gateway to object-based systems with case-sensitive method
   names.

   Unlike distributed objects, the standardized request methods in HTTP
   are not resource-specific, since uniform interfaces provide for
   better visibility and reuse in network-based systems [&lt;a href=&quot;#ref-REST&quot;&gt;REST&lt;/a&gt;].  Once
   defined, a standardized method ought to have the same semantics when
   applied to any resource, though each resource determines for itself
   whether those semantics are implemented or allowed.

   This specification defines a number of standardized methods that are
   commonly used in HTTP, as outlined by the following table.  By
   convention, standardized methods are defined in all-uppercase
   US-ASCII letters. 

   +---------+-------------------------------------------------+-------+
   | Method  | Description                                     | Sec.  |
   +---------+-------------------------------------------------+-------+
   | GET     | Transfer a current representation of the target | 4.3.1 |
   |         | resource.                                       |       |
   | HEAD    | Same as GET, but only transfer the status line  | 4.3.2 |
   |         | and header section.                             |       |
   | POST    | Perform resource-specific processing on the     | 4.3.3 |
   |         | request payload.                                |       |
   | PUT     | Replace all current representations of the      | 4.3.4 |
   |         | target resource with the request payload.       |       |
   | DELETE  | Remove all current representations of the       | 4.3.5 |
   |         | target resource.                                |       |
   | CONNECT | Establish a tunnel to the server identified by  | 4.3.6 |
   |         | the target resource.                            |       |
   | OPTIONS | Describe the communication options for the      | 4.3.7 |
   |         | target resource.                                |       |
   | TRACE   | Perform a message loop-back test along the path | 4.3.8 |
   |         | to the target resource.                         |       |
   +---------+-------------------------------------------------+-------+

   All general-purpose servers MUST support the methods GET and HEAD.
   All other methods are OPTIONAL.

   Additional methods, outside the scope of this specification, have
   been standardized for use in HTTP.  All such methods ought to be
   registered within the &quot;Hypertext Transfer Protocol (HTTP) Method
   Registry&quot; maintained by IANA, as defined in &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.

   The set of methods allowed by a target resource can be listed in an
   Allow header field (&lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;).  However, the set of allowed
   methods can change dynamically.  When a request method is received
   that is unrecognized or not implemented by an origin server, the
   origin server SHOULD respond with the 501 (Not Implemented) status
   code.  When a request method is received that is known by an origin
   server but not allowed for the target resource, the origin server
   SHOULD respond with the 405 (Method Not Allowed) status code.</source>
          <target state="translated">Маркер метода запроса является основным источником семантики запроса; он указывает цель, для которой клиент сделал этот запрос, и ожидаемый клиентом успешный результат. Семантика метода запроса может быть дополнительно специализирована семантикой некоторых полей заголовка, когда они присутствуют в запросе ( &lt;a href=&quot;#section-5&quot;&gt;раздел 5&lt;/a&gt; ), если эта дополнительная семантика не конфликтует с методом. Например, клиент может отправить условные поля заголовка запроса ( &lt;a href=&quot;#section-5.2&quot;&gt;раздел 5.2&lt;/a&gt; ), чтобы сделать запрошенное действие обусловленным текущим состоянием целевого ресурса ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]). method = token HTTP был изначально разработан для использования в качестве интерфейса для распределенных объектных систем. Предполагалось, что метод запроса применяет семантику к целевому ресурсу почти так же, как вызов определенного метода для идентифицированного объекта применяет семантику. Маркер метода чувствителен к регистру, поскольку он может использоваться в качестве шлюза к объектным системам с чувствительными к регистру именами методов. В отличие от распределенных объектов, стандартизированные методы запросов в HTTP не привязаны к конкретным ресурсам, поскольку унифицированные интерфейсы обеспечивают лучшую видимость и повторное использование в сетевых системах [ &lt;a href=&quot;#ref-REST&quot;&gt;REST&lt;/a&gt;]. После определения стандартизованный метод должен иметь одинаковую семантику при применении к любому ресурсу, хотя каждый ресурс сам определяет, реализована или разрешена эта семантика. Эта спецификация определяет ряд стандартизированных методов, которые обычно используются в HTTP, как показано в следующей таблице. По соглашению, стандартизованные методы определяются заглавными буквами US-ASCII. + --------- + --------------------------------------- ---------- + ------- + | Метод | Описание | Sec. | + --------- + --------------------------------------- ---------- + ------- + | ПОЛУЧИТЬ | Перенести текущее представление цели | 4.3.1 | | | ресурс. | | | ГОЛОВА | То же, что GET,но переносить только строку состояния | 4.3.2 | | | и раздел заголовка. | | | ПОЧТА | Выполнение обработки для конкретного ресурса на | 4.3.3 | | | запросить полезную нагрузку. | | | PUT | Заменить все текущие представления | 4.3.4 | | | целевой ресурс с полезной нагрузкой запроса. | | | УДАЛИТЬ | Удалите все текущие представления | 4.3.5 | | | целевой ресурс. | | | ПОДКЛЮЧИТЬ | Установите туннель к серверу, указанному | 4.3.6 | | | целевой ресурс. | | | ОПЦИИ | Опишите варианты коммуникации для | 4.3.7 | | | целевой ресурс.| | | TRACE | Выполните тест обратной связи сообщений по пути | 4.3.8 | | | к целевому ресурсу. | | + --------- + --------------------------------------- ---------- + ------- + Все серверы общего назначения ДОЛЖНЫ поддерживать методы GET и HEAD. Все остальные методы НЕОБЯЗАТЕЛЬНЫ. Дополнительные методы, выходящие за рамки данной спецификации, стандартизированы для использования в HTTP. Все такие методы должны быть зарегистрированы в &amp;laquo;Реестре методов протокола передачи гипертекста (HTTP)&amp;raquo;, поддерживаемом IANA, как определено в| | + --------- + --------------------------------------- ---------- + ------- + Все серверы общего назначения ДОЛЖНЫ поддерживать методы GET и HEAD. Все остальные методы НЕОБЯЗАТЕЛЬНЫ. Дополнительные методы, выходящие за рамки данной спецификации, стандартизированы для использования в HTTP. Все такие методы должны быть зарегистрированы в &amp;laquo;Реестре методов протокола передачи гипертекста (HTTP)&amp;raquo;, поддерживаемом IANA, как определено в| | + --------- + --------------------------------------- ---------- + ------- + Все серверы общего назначения ДОЛЖНЫ поддерживать методы GET и HEAD. Все остальные методы НЕОБЯЗАТЕЛЬНЫ. Дополнительные методы, выходящие за рамки данной спецификации, стандартизированы для использования в HTTP. Все такие методы должны быть зарегистрированы в &amp;laquo;Реестре методов протокола передачи гипертекста (HTTP)&amp;raquo;, поддерживаемом IANA, как определено в&lt;a href=&quot;#section-8.1&quot;&gt;Раздел 8.1&lt;/a&gt; . Набор методов, разрешенных целевым ресурсом, может быть указан в поле заголовка Allow ( &lt;a href=&quot;#section-7.4.1&quot;&gt;раздел 7.4.1&lt;/a&gt; ). Однако набор разрешенных методов может меняться динамически. Когда получен метод запроса, который не распознан или не реализован исходным сервером, исходный сервер ДОЛЖЕН ответить кодом состояния 501 (не реализован). Когда получен метод запроса, который известен исходному серверу, но не разрешен для целевого ресурса, исходный сервер ДОЛЖЕН ответить кодом состояния 405 (метод не разрешен).</target>
        </trans-unit>
        <trans-unit id="ea4723439e12f3374a0c44c124fcfaaf67f0d247" translate="yes" xml:space="preserve">
          <source>The request requires user authentication. The response MUST include a
   WWW-Authenticate header field (&lt;a href=&quot;#section-14.47&quot;&gt;section 14.47&lt;/a&gt;) containing a challenge
   applicable to the requested resource. The client MAY repeat the
   request with a suitable Authorization header field (&lt;a href=&quot;#section-14.8&quot;&gt;section 14.8&lt;/a&gt;). If
   the request already included Authorization credentials, then the 401
   response indicates that authorization has been refused for those
   credentials. If the 401 response contains the same challenge as the
   prior response, and the user agent has already attempted
   authentication at least once, then the user SHOULD be presented the
   entity that was given in the response, since that entity might
   include relevant diagnostic information. HTTP access authentication
   is explained in &quot;HTTP Authentication: Basic and Digest Access
   Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;].</source>
          <target state="translated">Запрос требует аутентификации пользователя. Ответ ДОЛЖЕН включать поле заголовка WWW-Authenticate ( &lt;a href=&quot;#section-14.47&quot;&gt;раздел 14.47&lt;/a&gt; ), содержащее запрос, применимый к запрошенному ресурсу. Клиент МОЖЕТ повторить запрос с подходящим полем заголовка авторизации ( &lt;a href=&quot;#section-14.8&quot;&gt;раздел 14.8&lt;/a&gt;). Если запрос уже включал учетные данные авторизации, то ответ 401 указывает, что в авторизации для этих учетных данных отказано. Если ответ 401 содержит тот же вызов, что и предыдущий ответ, и пользовательский агент уже попытался аутентифицироваться хотя бы один раз, то пользователю СЛЕДУЕТ представить объект, который был указан в ответе, поскольку этот объект может включать в себя релевантную диагностическую информацию. Аутентификация доступа HTTP объясняется в разделе &amp;laquo;Аутентификация HTTP: базовая и дайджест-аутентификация доступа&amp;raquo; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="536c30469835dbdbadd49c3051aea9ea66357e5b" translate="yes" xml:space="preserve">
          <source>The request to TLS can be made either optionally or mandatorily.</source>
          <target state="translated">Запрос на TLS может быть сделан как опционально,так и в обязательном порядке.</target>
        </trans-unit>
        <trans-unit id="ab19f93fa18ca65854665f21139e776133cce6e1" translate="yes" xml:space="preserve">
          <source>The request was directed at a server that is not able to produce a response. This can be sent by a server that is not configured to produce responses for the combination of scheme and authority that are included in the request URI.</source>
          <target state="translated">Запрос был направлен на сервер,который не в состоянии дать ответ.Это может быть отправлено сервером,который не настроен на получение ответов для комбинации схемы и полномочий,которые включены в URI запроса.</target>
        </trans-unit>
        <trans-unit id="e88680dcf3022af1b9dae0ac257cac1136f1dced" translate="yes" xml:space="preserve">
          <source>The request was redirected to 'https://example.com/foo', which is disallowed for cross-origin requests that require preflight</source>
          <target state="translated">Запрос был перенаправлен на сайт 'https://example.com/foo',который запрещен для запросов с перекрестным происхождением,требующих совершения предполетного полета.</target>
        </trans-unit>
        <trans-unit id="f7233ccb2f021155bf357e2393734dc2cb1fd475" translate="yes" xml:space="preserve">
          <source>The request was well-formed but was unable to be followed due to semantic errors.</source>
          <target state="translated">Запрос был хорошо сформулирован,но не смог быть выполнен из-за семантических ошибок.</target>
        </trans-unit>
        <trans-unit id="c92c57474b6ca0ed55b1d1a0fed53a9265911a89" translate="yes" xml:space="preserve">
          <source>The request-header fields allow the client to pass additional
   information about the request, and about the client itself, to the
   server. These fields act as request modifiers, with semantics
   equivalent to the parameters on a programming language method
   invocation.

       request-header = Accept                   ; &lt;a href=&quot;#section-14.1&quot;&gt;Section 14.1&lt;/a&gt;
                      | Accept-Charset           ; &lt;a href=&quot;#section-14.2&quot;&gt;Section 14.2&lt;/a&gt;
                      | Accept-Encoding          ; &lt;a href=&quot;#section-14.3&quot;&gt;Section 14.3&lt;/a&gt;
                      | Accept-Language          ; &lt;a href=&quot;#section-14.4&quot;&gt;Section 14.4&lt;/a&gt;
                      | Authorization            ; &lt;a href=&quot;#section-14.8&quot;&gt;Section 14.8&lt;/a&gt;
                      | Expect                   ; &lt;a href=&quot;#section-14.20&quot;&gt;Section 14.20&lt;/a&gt;
                      | From                     ; &lt;a href=&quot;#section-14.22&quot;&gt;Section 14.22&lt;/a&gt;
                      | Host                     ; &lt;a href=&quot;#section-14.23&quot;&gt;Section 14.23&lt;/a&gt;
                      | If-Match                 ; &lt;a href=&quot;#section-14.24&quot;&gt;Section 14.24&lt;/a&gt; 

                      | If-Modified-Since        ; &lt;a href=&quot;#section-14.25&quot;&gt;Section 14.25&lt;/a&gt;
                      | If-None-Match            ; &lt;a href=&quot;#section-14.26&quot;&gt;Section 14.26&lt;/a&gt;
                      | If-Range                 ; &lt;a href=&quot;#section-14.27&quot;&gt;Section 14.27&lt;/a&gt;
                      | If-Unmodified-Since      ; &lt;a href=&quot;#section-14.28&quot;&gt;Section 14.28&lt;/a&gt;
                      | Max-Forwards             ; &lt;a href=&quot;#section-14.31&quot;&gt;Section 14.31&lt;/a&gt;
                      | Proxy-Authorization      ; &lt;a href=&quot;#section-14.34&quot;&gt;Section 14.34&lt;/a&gt;
                      | Range                    ; &lt;a href=&quot;#section-14.35&quot;&gt;Section 14.35&lt;/a&gt;
                      | Referer                  ; &lt;a href=&quot;#section-14.36&quot;&gt;Section 14.36&lt;/a&gt;
                      | TE                       ; &lt;a href=&quot;#section-14.39&quot;&gt;Section 14.39&lt;/a&gt;
                      | User-Agent               ; &lt;a href=&quot;#section-14.43&quot;&gt;Section 14.43&lt;/a&gt;

   Request-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields MAY be given the semantics of request-
   header fields if all parties in the communication recognize them to
   be request-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">Поля заголовка запроса позволяют клиенту передавать на сервер дополнительную информацию о запросе и о самом клиенте. Эти поля действуют как модификаторы запроса с семантикой, эквивалентной параметрам при вызове метода языка программирования. заголовок запроса = Принять; &lt;a href=&quot;#section-14.1&quot;&gt;Раздел 14.1&lt;/a&gt; | Accept-Charset; &lt;a href=&quot;#section-14.2&quot;&gt;Раздел 14.2&lt;/a&gt; | Принять-кодирование; &lt;a href=&quot;#section-14.3&quot;&gt;Раздел 14.3&lt;/a&gt; | Accept-Language; &lt;a href=&quot;#section-14.4&quot;&gt;Раздел 14.4&lt;/a&gt; | Авторизация; &lt;a href=&quot;#section-14.8&quot;&gt;Раздел 14.8&lt;/a&gt; | Ожидайте; &lt;a href=&quot;#section-14.20&quot;&gt;Раздел 14.20&lt;/a&gt; | Из ; &lt;a href=&quot;#section-14.22&quot;&gt;Раздел 14.22&lt;/a&gt; | Хост; &lt;a href=&quot;#section-14.23&quot;&gt;Раздел 14.23&lt;/a&gt; | If-Match; &lt;a href=&quot;#section-14.24&quot;&gt;Раздел 14.24&lt;/a&gt; | If-Modified-Since; &lt;a href=&quot;#section-14.25&quot;&gt;Раздел 14.25&lt;/a&gt; | If-None-Match; &lt;a href=&quot;#section-14.26&quot;&gt;Раздел 14.26&lt;/a&gt; | Если-диапазон; &lt;a href=&quot;#section-14.27&quot;&gt;Раздел 14.27&lt;/a&gt; | Если-без изменений-с; &lt;a href=&quot;#section-14.28&quot;&gt;Раздел 14.28&lt;/a&gt; | Макс-нападающие; &lt;a href=&quot;#section-14.31&quot;&gt;Раздел 14.31&lt;/a&gt; | Прокси-авторизация; &lt;a href=&quot;#section-14.34&quot;&gt;Раздел 14.34&lt;/a&gt; | Ассортимент ; &lt;a href=&quot;#section-14.35&quot;&gt;Раздел 14.35&lt;/a&gt; | Referer; &lt;a href=&quot;#section-14.36&quot;&gt;Раздел 14.36&lt;/a&gt; | TE; &lt;a href=&quot;#section-14.39&quot;&gt;Раздел 14.39&lt;/a&gt; | Пользователь-агент; &lt;a href=&quot;#section-14.43&quot;&gt;Раздел 14.43.&lt;/a&gt; Имена полей заголовка запроса могут быть надежно расширены только в сочетании с изменением версии протокола. Однако новым или экспериментальным полям заголовка МОЖНО придать семантику полей заголовка запроса, если все стороны в сообщении распознают их как поля заголовка запроса. Нераспознанные поля заголовка обрабатываются как поля заголовка объекта.</target>
        </trans-unit>
        <trans-unit id="00ee3240d5b62db652acaaec1c517dfc4187762e" translate="yes" xml:space="preserve">
          <source>The requested resource MUST be accessed through the proxy given by
   the Location field. The Location field gives the URI of the proxy.
   The recipient is expected to repeat this single request via the
   proxy. 305 responses MUST only be generated by origin servers.

      Note: &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; was not clear that 305 was intended to redirect a
      single request, and to be generated by origin servers only.  Not
      observing these limitations has significant security consequences.</source>
          <target state="translated">Доступ к запрошенному ресурсу ДОЛЖЕН быть доступен через прокси-сервер, указанный в поле Location. В поле Location указан URI прокси. Ожидается, что получатель повторит этот единственный запрос через прокси. 305 ответов ДОЛЖНЫ создаваться только серверами-источниками. Примечание. В &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; не было ясно, что 305 предназначен для перенаправления одного запроса и должен быть сгенерирован только исходными серверами. Несоблюдение этих ограничений имеет серьезные последствия для безопасности.</target>
        </trans-unit>
        <trans-unit id="d984d2d7ff09514806eb927c4043ee9bc91f6a1d" translate="yes" xml:space="preserve">
          <source>The requested resource corresponds to any one of a set of
   representations, each with its own specific location, and agent-
   driven negotiation information (&lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;) is being provided so that
   the user (or user agent) can select a preferred representation and
   redirect its request to that location.

   Unless it was a HEAD request, the response SHOULD include an entity
   containing a list of resource characteristics and location(s) from
   which the user or user agent can choose the one most appropriate. The
   entity format is specified by the media type given in the Content-
   Type header field. Depending upon the format and the capabilities of 

   the user agent, selection of the most appropriate choice MAY be
   performed automatically. However, this specification does not define
   any standard for such automatic selection.

   If the server has a preferred choice of representation, it SHOULD
   include the specific URI for that representation in the Location
   field; user agents MAY use the Location field value for automatic
   redirection. This response is cacheable unless indicated otherwise.</source>
          <target state="translated">Запрошенный ресурс соответствует любому из набора представлений, каждое со своим конкретным местоположением и управляемой агентом информацией о переговорах ( &lt;a href=&quot;#section-12&quot;&gt;раздел 12&lt;/a&gt;) предоставляется, чтобы пользователь (или пользовательский агент) мог выбрать предпочтительное представление и перенаправить свой запрос в это место. Если это не запрос HEAD, ответ ДОЛЖЕН включать объект, содержащий список характеристик ресурсов и местоположения (а), из которых пользователь или пользовательский агент может выбрать наиболее подходящий. Формат объекта определяется типом носителя, указанным в поле заголовка Content-Type. В зависимости от формата и возможностей пользовательского агента выбор наиболее подходящего варианта МОЖЕТ быть выполнен автоматически. Однако эта спецификация не определяет никаких стандартов для такого автоматического выбора. Если у сервера есть предпочтительный выбор представления, он ДОЛЖЕН включить конкретный URI для этого представления в поле Location;пользовательские агенты МОГУТ использовать значение поля Location для автоматического перенаправления. Этот ответ кэшируется, если не указано иное.</target>
        </trans-unit>
        <trans-unit id="e7c77b9895c801f0e66c9d13d10555d8495d972e" translate="yes" xml:space="preserve">
          <source>The requested resource has been assigned a new permanent URI and any
   future references to this resource SHOULD use one of the returned
   URIs.  Clients with link editing capabilities ought to automatically
   re-link references to the Request-URI to one or more of the new
   references returned by the server, where possible. This response is
   cacheable unless indicated otherwise.

   The new permanent URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s).

   If the 301 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.

      Note: When automatically redirecting a POST request after
      receiving a 301 status code, some existing HTTP/1.0 user agents
      will erroneously change it into a GET request.</source>
          <target state="translated">Запрашиваемому ресурсу был присвоен новый постоянный URI,и любые будущие ссылки на этот ресурс ДОЛЖНЫ использовать один из возвращаемых URI.Клиенты с возможностями редактирования ссылок должны автоматически переустанавливать ссылки на Request-URI к одной или нескольким новым ссылкам,возвращаемым сервером,где это возможно.Этот ответ является кэшируемым,если не указано иное.Новый постоянный URI ДОЛЖЕН указываться полем Location в ответе.Если только метод запроса не был HEAD,сущность ответа SHOULD содержит короткую гипертекстовую заметку с гиперссылкой на новый URI(ы).Если код статуса 301 получен в ответ на запрос,отличный от GET или HEAD,пользовательский агент НЕ ДОЛЖЕН автоматически перенаправлять запрос,если он не может быть подтвержден пользователем,поскольку это может изменить условия,при которых запрос был выдан.Примечание:При автоматическом перенаправлении POST-запроса после получения кода статуса 301 некоторые существующие HTTP/1.0 пользовательские агенты ошибочно преобразуют его в GET-запрос.</target>
        </trans-unit>
        <trans-unit id="84c9980aa16b04f88efc81ddd498027c5e617c08" translate="yes" xml:space="preserve">
          <source>The requested resource is no longer available at the server and no
   forwarding address is known. This condition is expected to be
   considered permanent. Clients with link editing capabilities SHOULD
   delete references to the Request-URI after user approval. If the
   server does not know, or has no facility to determine, whether or not
   the condition is permanent, the status code 404 (Not Found) SHOULD be
   used instead. This response is cacheable unless indicated otherwise.

   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed. Such an event is common for
   limited-time, promotional services and for resources belonging to
   individuals no longer working at the server's site. It is not
   necessary to mark all permanently unavailable resources as &quot;gone&quot; or
   to keep the mark for any length of time -- that is left to the
   discretion of the server owner.</source>
          <target state="translated">Запрашиваемый ресурс больше не доступен на сервере и адрес переадресации не известен.Ожидается,что это условие будет считаться постоянным.Клиенты с возможностями редактирования ссылок ДОЛЖНЫ удалять ссылки на Request-URI после одобрения пользователем.Если сервер не знает или не имеет возможности определить,является ли условие постоянным,вместо него используется код статуса 404 (Не найдено)SHOULD.Этот ответ является кэшируемым,если не указано иное.Ответ 410 предназначен,в первую очередь,для облегчения задачи веб-обслуживания,уведомляя получателя о том,что ресурс намеренно недоступен и что владельцы сервера желают,чтобы удаленные ссылки на этот ресурс были удалены.Такое событие характерно для ограниченных по времени,рекламных услуг и для ресурсов,принадлежащих физическим лицам,больше не работающим на сайте сервера.Необязательно отмечать все постоянно недоступные ресурсы как &quot;ушедшие&quot; или сохранять эту отметку в течение любого времени-это оставляется на усмотрение владельца сервера.</target>
        </trans-unit>
        <trans-unit id="3a016e600e3bce12c26484b50fa5be354243d903" translate="yes" xml:space="preserve">
          <source>The requested resource resides temporarily under a different URI.
   Since the redirection MAY be altered on occasion, the client SHOULD
   continue to use the Request-URI for future requests.  This response
   is only cacheable if indicated by a Cache-Control or Expires header
   field.

   The temporary URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s) , since many pre-HTTP/1.1 user agents do not
   understand the 307 status. Therefore, the note SHOULD contain the
   information necessary for a user to repeat the original request on
   the new URI.

   If the 307 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.</source>
          <target state="translated">Запрашиваемый ресурс временно находится под другим УРИ.Так как переадресация ДОЛЖНА быть изменена в некоторых случаях,клиент ДОЛЖЕН продолжать использовать Request-URI для будущих запросов.Этот ответ кэшируется только в том случае,если он указан в поле заголовка Cache-Control или Expires.Временный URI Показывается полем Location в ответе.Если только метод запроса не был HEAD,сущность ответа SHOULD содержит короткую гипертекстовую заметку с гиперссылкой на новый URI(ы),так как многие пользовательские агенты до HTTP/1.1 не понимают статуса 307.Поэтому примечание SHOULD содержит информацию,необходимую пользователю для повторения первоначального запроса по новому URI.Если код статуса 307 получен в ответ на запрос,отличный от GET или HEAD,пользовательский агент НЕ ДОЛЖЕН автоматически перенаправлять запрос,если он не может быть подтвержден пользователем,так как это может изменить условия,при которых запрос был выдан.</target>
        </trans-unit>
        <trans-unit id="a9d909310ffffdfd39320376da2640abfbc56135" translate="yes" xml:space="preserve">
          <source>The requested resource resides temporarily under a different URI.
   Since the redirection might be altered on occasion, the client SHOULD
   continue to use the Request-URI for future requests.  This response
   is only cacheable if indicated by a Cache-Control or Expires header
   field.

   The temporary URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s). 

   If the 302 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.

      Note: &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; specify that the client is not allowed
      to change the method on the redirected request.  However, most
      existing user agent implementations treat 302 as if it were a 303
      response, performing a GET on the Location field-value regardless
      of the original request method. The status codes 303 and 307 have
      been added for servers that wish to make unambiguously clear which
      kind of reaction is expected of the client.</source>
          <target state="translated">Запрошенный ресурс временно находится под другим URI. Поскольку перенаправление может быть изменено при случае, клиент ДОЛЖЕН продолжать использовать Request-URI для будущих запросов. Этот ответ кэшируется только в том случае, если он указан полем заголовка Cache-Control или Expires. Временный URI СЛЕДУЕТ указывать в поле Location в ответе. Если метод запроса не был HEAD, объект ответа ДОЛЖЕН содержать короткую гипертекстовую заметку с гиперссылкой на новый URI. Если код состояния 302 получен в ответ на запрос, отличный от GET или HEAD, пользовательский агент НЕ ДОЛЖЕН автоматически перенаправлять запрос, если он не может быть подтвержден пользователем, поскольку это может изменить условия, при которых запрос был выпущен. Примечание: &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; и&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; указывает, что клиенту не разрешено изменять метод перенаправленного запроса. Однако большинство существующих реализаций пользовательского агента обрабатывают 302, как если бы это был ответ 303, выполняя GET для значения поля Location независимо от исходного метода запроса. Коды состояния 303 и 307 были добавлены для серверов, которые хотят однозначно указать, какой тип реакции ожидается от клиента.</target>
        </trans-unit>
        <trans-unit id="24d06f0884418e17262e5806d51e7313670997da" translate="yes" xml:space="preserve">
          <source>The requirements that clients and servers support the Host header
   field (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;), report an error if it is missing from an
   HTTP/1.1 request, and accept absolute URIs (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) are among
   the most important changes defined by HTTP/1.1. 

   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed.  The Host header field was
   introduced during the development of HTTP/1.1 and, though it was
   quickly implemented by most HTTP/1.0 browsers, additional
   requirements were placed on all HTTP/1.1 requests in order to ensure
   complete adoption.  At the time of this writing, most HTTP-based
   services are dependent upon the Host header field for targeting
   requests.</source>
          <target state="translated">Требования, чтобы клиенты и серверы поддерживали поле заголовка Host ( &lt;a href=&quot;#section-5.4&quot;&gt;раздел 5.4&lt;/a&gt; ), сообщали об ошибке, если оно отсутствует в запросе HTTP / 1.1, и принимали абсолютные URI ( &lt;a href=&quot;#section-5.3&quot;&gt;раздел 5.3&lt;/a&gt;) являются одними из самых важных изменений, определенных HTTP / 1.1. Старые клиенты HTTP / 1.0 предполагали однозначную взаимосвязь IP-адресов и серверов; не было другого установленного механизма для различения предполагаемого сервера запроса, кроме IP-адреса, на который этот запрос был направлен. Поле заголовка Host было введено во время разработки HTTP / 1.1, и, хотя оно было быстро реализовано в большинстве браузеров HTTP / 1.0, для всех запросов HTTP / 1.1 были наложены дополнительные требования, чтобы обеспечить полное внедрение. На момент написания этой статьи большинство служб на основе HTTP зависело от поля заголовка Host для адресных запросов.</target>
        </trans-unit>
        <trans-unit id="554d1e6bd5194783475ebafadd7bbf4b3ceb10ad" translate="yes" xml:space="preserve">
          <source>The requirements that clients and servers support the Host request-
   header, report an error if the Host request-header (&lt;a href=&quot;#section-14.23&quot;&gt;section 14.23&lt;/a&gt;) is
   missing from an HTTP/1.1 request, and accept absolute URIs (&lt;a href=&quot;#section-5.1.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;) are among the most important changes defined by this
   specification.

   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed. The changes outlined above will
   allow the Internet, once older HTTP clients are no longer common, to
   support multiple Web sites from a single IP address, greatly
   simplifying large operational Web servers, where allocation of many
   IP addresses to a single host has created serious problems. The
   Internet will also be able to recover the IP addresses that have been
   allocated for the sole purpose of allowing special-purpose domain
   names to be used in root-level HTTP URLs. Given the rate of growth of
   the Web, and the number of servers already deployed, it is extremely 

   important that all implementations of HTTP (including updates to
   existing HTTP/1.0 applications) correctly implement these
   requirements:

      - Both clients and servers MUST support the Host request-header.

      - A client that sends an HTTP/1.1 request MUST send a Host header.

      - Servers MUST report a 400 (Bad Request) error if an HTTP/1.1
        request does not include a Host request-header.

      - Servers MUST accept absolute URIs.</source>
          <target state="translated">Требования, чтобы клиенты и серверы поддерживали заголовок запроса Host, сообщали об ошибке, если заголовок запроса Host ( &lt;a href=&quot;#section-14.23&quot;&gt;раздел 14.23&lt;/a&gt; ) отсутствует в запросе HTTP / 1.1, и принимали абсолютные URI ( &lt;a href=&quot;#section-5.1.2&quot;&gt;раздел &lt;/a&gt;&lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2).&lt;/a&gt;) являются одними из наиболее важных изменений, определенных данной спецификацией. Старые клиенты HTTP / 1.0 предполагали однозначную взаимосвязь IP-адресов и серверов; не было другого установленного механизма для различения предполагаемого сервера запроса, кроме IP-адреса, на который этот запрос был направлен. Описанные выше изменения позволят Интернету, когда старые HTTP-клиенты перестанут быть распространенными, поддерживать несколько веб-сайтов с одного IP-адреса, что значительно упростит большие рабочие веб-серверы, где выделение множества IP-адресов одному хосту создает серьезные проблемы. , Интернет также сможет восстанавливать IP-адреса, которые были выделены с единственной целью разрешить использование доменных имен специального назначения в URL-адресах HTTP корневого уровня. Учитывая скорость роста Интернета,и количество уже развернутых серверов, чрезвычайно важно, чтобы все реализации HTTP (включая обновления существующих приложений HTTP / 1.0) правильно выполняли следующие требования: - И клиенты, и серверы ДОЛЖНЫ поддерживать заголовок запроса Host. - Клиент, который отправляет запрос HTTP / 1.1, ДОЛЖЕН отправить заголовок Host. - Серверы ДОЛЖНЫ сообщать об ошибке 400 (неверный запрос), если запрос HTTP / 1.1 не включает заголовок запроса хоста. - Серверы ДОЛЖНЫ принимать абсолютные URI.1 запрос ДОЛЖЕН отправлять заголовок Host. - Серверы ДОЛЖНЫ сообщать об ошибке 400 (неверный запрос), если запрос HTTP / 1.1 не включает заголовок запроса хоста. - Серверы ДОЛЖНЫ принимать абсолютные URI.1 запрос ДОЛЖЕН отправлять заголовок Host. - Серверы ДОЛЖНЫ сообщать об ошибке 400 (неверный запрос), если запрос HTTP / 1.1 не включает заголовок запроса хоста. - Серверы ДОЛЖНЫ принимать абсолютные URI.</target>
        </trans-unit>
        <trans-unit id="b85098c9f819adbf87cde9578f01517d8065c6c2" translate="yes" xml:space="preserve">
          <source>The resource identified by the request is only capable of generating
   response entities which have content characteristics not acceptable
   according to the accept headers sent in the request.

   Unless it was a HEAD request, the response SHOULD include an entity
   containing a list of available entity characteristics and location(s)
   from which the user or user agent can choose the one most
   appropriate. The entity format is specified by the media type given
   in the Content-Type header field. Depending upon the format and the
   capabilities of the user agent, selection of the most appropriate
   choice MAY be performed automatically. However, this specification
   does not define any standard for such automatic selection.

      Note: HTTP/1.1 servers are allowed to return responses which are
      not acceptable according to the accept headers sent in the
      request. In some cases, this may even be preferable to sending a
      406 response. User agents are encouraged to inspect the headers of
      an incoming response to determine if it is acceptable.

   If the response could be unacceptable, a user agent SHOULD
   temporarily stop receipt of more data and query the user for a
   decision on further actions.</source>
          <target state="translated">Ресурс,идентифицируемый по запросу,способен генерировать только те сущности ответа,которые имеют контентные характеристики,не приемлемые по заголовкам акцепта,отправленным в запросе.Если это не был запрос HEAD,то ответ ДОЛЖЕН включать сущность,содержащую список доступных характеристик сущности и местоположения(ов),из которых пользователь или агент пользователя может выбрать наиболее подходящую.Формат сущности задается типом носителя,указанным в поле заголовка Content-Type.В зависимости от формата и возможностей пользовательского агента выбор наиболее подходящего будет произведен автоматически.Однако данная спецификация не определяет каких-либо стандартов такого автоматического выбора.Примечание:серверам HTTP/1.1 разрешено возвращать ответы,которые не приемлемы в соответствии с заголовками accept,отправленными в запросе.В некоторых случаях это может быть даже предпочтительнее,чем посылать 406 ответов.Пользовательским агентам рекомендуется проверять заголовки входящего ответа,чтобы определить,является ли он приемлемым.Если ответ может оказаться неприемлемым,пользовательский агент ДОЛЖЕН временно остановить получение дополнительных данных и запросить у пользователя решение о дальнейших действиях.</target>
        </trans-unit>
        <trans-unit id="7d38c9e9eed37f8ebb054ffe20689cb741c8e1bf" translate="yes" xml:space="preserve">
          <source>The resource that is being accessed is locked.</source>
          <target state="translated">Доступ к ресурсу заблокирован.</target>
        </trans-unit>
        <trans-unit id="2e6d65ce6753d6adca24d41c2f2aab6cad178c87" translate="yes" xml:space="preserve">
          <source>The response from the server may include these.</source>
          <target state="translated">Ответ от сервера может включать в себя эти данные.</target>
        </trans-unit>
        <trans-unit id="0596f7bd46252bc01ceca1b37ff3abcdb40b4bc7" translate="yes" xml:space="preserve">
          <source>The response header fields allow the server to pass additional
   information about the response beyond what is placed in the
   status-line.  These header fields give information about the server,
   about further access to the target resource, or about related
   resources.

   Although each response header field has a defined meaning, in
   general, the precise semantics might be further refined by the
   semantics of the request method and/or response status code.</source>
          <target state="translated">Поля заголовка ответа позволяют серверу передавать дополнительную информацию о ответе за пределы того,что размещено в строке состояния.Эти поля заголовка дают информацию о сервере,о дальнейшем доступе к целевому ресурсу или о связанных с ним ресурсах.Хотя каждое поле заголовка ответа имеет определенное значение,в целом,точная семантика может быть дополнительно уточнена семантикой метода запроса и/или кодом статуса ответа.</target>
        </trans-unit>
        <trans-unit id="ff7a362ee27a0f1762005f0ec6ebc5bb964259ee" translate="yes" xml:space="preserve">
          <source>The response is extremely simple too: it only consisted of the file itself.</source>
          <target state="translated">Ответ тоже чрезвычайно прост:он состоял только из самого файла.</target>
        </trans-unit>
        <trans-unit id="513c2898705ac68cc3e3ee06f80d9c90116f1922" translate="yes" xml:space="preserve">
          <source>The response then contains an &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; header with the allowed methods:</source>
          <target state="translated">Затем ответ содержит заголовок &lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt; с разрешенными методами:</target>
        </trans-unit>
        <trans-unit id="18088efa80d68a5ff78b12db71323e5708eee380" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request is missing the required &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header, which is used to determine whether or not the resource can be accessed by content operating within the current origin.</source>
          <target state="translated">В ответе на запрос &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; отсутствует требуемый заголовок &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; , который используется для определения того, доступен ли ресурс для контента, работающего в текущем источнике.</target>
        </trans-unit>
        <trans-unit id="bacd2f05b83c3c39f0e7214a569bb88e96978d01" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request that was sent by the server includes an &lt;a href=&quot;../../headers/access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; header which includes at least one invalid header name.</source>
          <target state="translated">Ответ на запрос &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS,&lt;/a&gt; который был отправлен сервером, включает заголовок &lt;a href=&quot;../../headers/access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; ,&lt;/a&gt; который включает как минимум одно недопустимое имя заголовка.</target>
        </trans-unit>
        <trans-unit id="15a529998feb2d569f6cffb35b10491d075a60be" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request that was sent by the server includes an &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header which includes at least one invalid method name.</source>
          <target state="translated">Ответ на запрос &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; , отправленный сервером, включает заголовок &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; ,&lt;/a&gt; который включает по крайней мере одно недопустимое имя метода.</target>
        </trans-unit>
        <trans-unit id="2ae0be16c13fe096b642ef89520ae9e65e43a5c6" translate="yes" xml:space="preserve">
          <source>The response to the request can be found under a different URI and
   SHOULD be retrieved using a GET method on that resource. This method
   exists primarily to allow the output of a POST-activated script to
   redirect the user agent to a selected resource. The new URI is not a
   substitute reference for the originally requested resource. The 303
   response MUST NOT be cached, but the response to the second
   (redirected) request might be cacheable.

   The different URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s).

      Note: Many pre-HTTP/1.1 user agents do not understand the 303
      status. When interoperability with such clients is a concern, the
      302 status code may be used instead, since most user agents react
      to a 302 response as described here for 303.</source>
          <target state="translated">Ответ на запрос может быть найден в другом URI,и его можно получить с помощью GET-метода на этом ресурсе.Этот метод существует в первую очередь для того,чтобы разрешить вывод POST-активированного скрипта для перенаправления пользовательского агента на выбранный ресурс.Новый URI не является заменой ссылки на изначально запрошенный ресурс.Ответ 303 НЕ ДОЛЖЕН быть кэширован,но ответ на второй (перенаправленный)запрос может быть кэшируемым.Различный URI ДОЛЖЕН быть задан полем Location в ответе.Если только метод запроса не был HEAD,сущность ответа ДОЛЖНА содержать короткую гипертекстовую заметку с гиперссылкой на новый URI(ы).Примечание:Многие пользовательские агенты до HTTP/1.1 не понимают статуса 303.Когда речь идет о функциональной совместимости с такими клиентами,вместо них может использоваться код статуса 302,поскольку большинство пользовательских агентов реагируют на ответ 302,как описано здесь для ответа 303.</target>
        </trans-unit>
        <trans-unit id="12506b704a003858abdf13381ee9b21f91a7f1af" translate="yes" xml:space="preserve">
          <source>The response-header fields allow the server to pass additional
   information about the response which cannot be placed in the Status-
   Line. These header fields give information about the server and about
   further access to the resource identified by the Request-URI.

       response-header = Accept-Ranges           ; &lt;a href=&quot;#section-14.5&quot;&gt;Section 14.5&lt;/a&gt;
                       | Age                     ; &lt;a href=&quot;#section-14.6&quot;&gt;Section 14.6&lt;/a&gt;
                       | ETag                    ; &lt;a href=&quot;#section-14.19&quot;&gt;Section 14.19&lt;/a&gt;
                       | Location                ; &lt;a href=&quot;#section-14.30&quot;&gt;Section 14.30&lt;/a&gt;
                       | Proxy-Authenticate      ; &lt;a href=&quot;#section-14.33&quot;&gt;Section 14.33&lt;/a&gt; 

                       | Retry-After             ; &lt;a href=&quot;#section-14.37&quot;&gt;Section 14.37&lt;/a&gt;
                       | Server                  ; &lt;a href=&quot;#section-14.38&quot;&gt;Section 14.38&lt;/a&gt;
                       | Vary                    ; &lt;a href=&quot;#section-14.44&quot;&gt;Section 14.44&lt;/a&gt;
                       | WWW-Authenticate        ; &lt;a href=&quot;#section-14.47&quot;&gt;Section 14.47&lt;/a&gt;

   Response-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields MAY be given the semantics of response-
   header fields if all parties in the communication recognize them to
   be response-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">Поля заголовка ответа позволяют серверу передавать дополнительную информацию об ответе, которую нельзя поместить в строку состояния. Эти поля заголовка предоставляют информацию о сервере и о дальнейшем доступе к ресурсу, идентифицированному Request-URI. заголовок ответа = диапазоны принятия; &lt;a href=&quot;#section-14.5&quot;&gt;Раздел 14.5&lt;/a&gt; | Возраст; &lt;a href=&quot;#section-14.6&quot;&gt;Раздел 14.6&lt;/a&gt; | ETag; &lt;a href=&quot;#section-14.19&quot;&gt;Раздел 14.19&lt;/a&gt; | Расположение ; &lt;a href=&quot;#section-14.30&quot;&gt;Раздел 14.30&lt;/a&gt; | Прокси-аутентификация; &lt;a href=&quot;#section-14.33&quot;&gt;Раздел 14.33&lt;/a&gt; | Retry-After; &lt;a href=&quot;#section-14.37&quot;&gt;Раздел 14.37&lt;/a&gt; | Сервер; &lt;a href=&quot;#section-14.38&quot;&gt;Раздел 14.38&lt;/a&gt; | Варьировать; &lt;a href=&quot;#section-14.44&quot;&gt;Раздел 14.44&lt;/a&gt; | WWW-аутентификация; &lt;a href=&quot;#section-14.47&quot;&gt;Раздел 14.47.&lt;/a&gt; Имена полей заголовка ответа могут быть надежно расширены только в сочетании с изменением версии протокола. Однако новым или экспериментальным полям заголовка МОЖНО придать семантику полей заголовка ответа, если все стороны в сообщении распознают их как поля заголовка ответа. Нераспознанные поля заголовка обрабатываются как поля заголовка объекта.</target>
        </trans-unit>
        <trans-unit id="e9dacdcee08be9c8b87ede18aa52688f460db02e" translate="yes" xml:space="preserve">
          <source>The resulting string is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded (&lt;code&gt;YWxhZGRpbjpvcGVuc2VzYW1l&lt;/code&gt;).</source>
          <target state="translated">Результирующая строка закодирована в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; ( &lt;code&gt;YWxhZGRpbjpvcGVuc2VzYW1l&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fe3f7b6dc9ffc173061b38ba8ad0c8201cfdcbaa" translate="yes" xml:space="preserve">
          <source>The returned metainformation in the entity-header is not the
   definitive set as available from the origin server, but is gathered
   from a local or a third-party copy. The set presented MAY be a subset
   or superset of the original version. For example, including local
   annotation information about the resource might result in a superset
   of the metainformation known by the origin server. Use of this
   response code is not required and is only appropriate when the
   response would otherwise be 200 (OK).</source>
          <target state="translated">Возвращаемая метаинформация в заголовке субъекта не является окончательным набором,доступным с исходного сервера,а собирается из локальной копии или копии стороннего производителя.Представленный MAY набор является подмножеством или подмножеством оригинальной версии.Например,включение локальной аннотационной информации о ресурсе может привести к вытеснению мета-информации,известной серверу-источнику.Использование этого кода ответа не является обязательным и уместно только тогда,когда ответ в противном случае был бы 200 (OK).</target>
        </trans-unit>
        <trans-unit id="18a95000f2ca8553876b3106954ec5daa00d8eec" translate="yes" xml:space="preserve">
          <source>The revision version added to revved resources doesn't need to be a classical revision string like 1.1.3, or even a monotonously growing suite of number. It can be anything that prevent collisions, like a hash or a date.</source>
          <target state="translated">Версия ревизии,добавленная в ревизионные ресурсы,не обязательно должна быть классической строкой ревизии,как 1.1.3,или даже монотонно растущим набором номеров.Это может быть всё,что предотвращает столкновения,например,хэш или дата.</target>
        </trans-unit>
        <trans-unit id="b125ccbfa7a0e3bda312abb6c814a3f729297ece" translate="yes" xml:space="preserve">
          <source>The root of a Category Document is the &quot;app:categories&quot; element.  An
   app:categories element can contain zero or more atom:category
   elements from the Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] namespace
   (&quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;).

   An atom:category child element that has no &quot;scheme&quot; attribute
   inherits the attribute from its app:categories parent.  An atom:
   category child element with an existing &quot;scheme&quot; attribute does not
   inherit the &quot;scheme&quot; value of its app:categories parent element. 

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       }

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           undefinedContent
       }

   appCategories = appInlineCategories | appOutOfLineCategories</source>
          <target state="translated">Корнем документа категории является элемент &amp;laquo;приложение: категории&amp;raquo;. Элемент app: &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;Categories&lt;/a&gt; может содержать ноль или более элементов atom: category из пространства имен Atom Syndication Format [ RFC4287 ] ( &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;). Дочерний элемент atom: category без атрибута&quot; scheme &quot;наследует атрибут от своего родительского элемента app: category. Дочерний элемент atom: category с существующим атрибутом&quot; scheme &quot;не наследует значение&quot; scheme &quot;своего приложения. : родительский элемент категорий. atomCategory = элемент atom: категория {atomCommonAttributes, термин атрибута {текст}, схема атрибута {atomURI}?, метка атрибута {текст} ?, undefinedContent} appInlineCategories = элемент app: категории {атрибут фиксированный {&quot;да&quot; | &quot;no&quot;} ?, схема атрибута {atomURI} ?, (atomCategory *, undefinedContent)} appOutOfLineCategories = element app:категории {attribute href {atomURI}, undefinedContent} appCategories = appInlineCategories | appOutOfLineCategories</target>
        </trans-unit>
        <trans-unit id="dac1669f4b5c683593043fc93e45f9e39b9b3183" translate="yes" xml:space="preserve">
          <source>The root of a Service Document is the &quot;app:service&quot; element.

   The app:service element is the container for service information
   associated with one or more Workspaces.  An app:service element MUST
   contain one or more app:workspace elements.

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   start = appService

   appService =
      element app:service {
         appCommonAttributes,
         ( appWorkspace+
           &amp;amp; extensionElement* )
      }</source>
          <target state="translated">Корнем документа службы является элемент &amp;laquo;приложение: служба&amp;raquo;. Элемент app: service - это контейнер для служебной информации, связанной с одной или несколькими рабочими областями. Элемент app: service ДОЛЖЕН содержать один или несколько элементов app: workspace. namespace app = &quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &quot; start = appService appService = element app: service {appCommonAttributes, (appWorkspace + &amp;amp; extensionElement *)}</target>
        </trans-unit>
        <trans-unit id="32ded409a46c9e2ba7534a99504667ab5ee8ab0f" translate="yes" xml:space="preserve">
          <source>The same challenge and response mechanism can be used for &lt;em&gt;proxy authentication&lt;/em&gt;. In this case, it is an intermediate proxy that requires authentication. As both resource authentication and proxy authentication can coexist, a different set of headers and status codes is needed. In the case of proxies, the challenging status code is &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt; (Proxy Authentication Required), the &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response header contains at least one challenge applicable to the proxy, and the &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request header is used for providing the credentials to the proxy server.</source>
          <target state="translated">Тот же механизм запроса и ответа может использоваться для &lt;em&gt;аутентификации прокси&lt;/em&gt; . В данном случае это промежуточный прокси, требующий аутентификации. Поскольку аутентификация ресурсов и аутентификация прокси могут сосуществовать, необходим другой набор заголовков и кодов состояния. В случае прокси-серверов, вызывающий код состояния - &lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; (требуется проверка подлинности прокси), заголовок ответа &lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; содержит по крайней мере один запрос, применимый к прокси, а заголовок запроса &lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; используется для предоставления учетных данных прокси. сервер.</target>
        </trans-unit>
        <trans-unit id="0fb319a198a96a066c14d3602f889f224011cec2" translate="yes" xml:space="preserve">
          <source>The same-site attribute can have one of two values:</source>
          <target state="translated">Атрибут одного сайта может иметь одно из двух значений:</target>
        </trans-unit>
        <trans-unit id="a4b6e8afc97244358680d329fe8d9b651eecefb1" translate="yes" xml:space="preserve">
          <source>The second way to use Feature Policy is for controlling content within an iframe. Use the &lt;code&gt;allow&lt;/code&gt; attribute to specify a policy list for embedded content.</source>
          <target state="translated">Второй способ использования Feature Policy - это управление контентом внутри iframe. Используйте атрибут &lt;code&gt;allow&lt;/code&gt; , чтобы указать список политик для встроенного содержимого.</target>
        </trans-unit>
        <trans-unit id="fe3498e5bef07e6ed03f63dc1e56c45eca481341" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;Preflighted Access Control Requests&lt;/a&gt; shows a header exchange between client and server. A server resource responding to a preflight requests needs to be able to make the following determinations:</source>
          <target state="translated">В разделе &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;Предварительно настроенные запросы управления доступом&lt;/a&gt; показан обмен заголовками между клиентом и сервером. Ресурс сервера, отвечающий на предполетные запросы, должен иметь возможность выполнять следующие определения:</target>
        </trans-unit>
        <trans-unit id="90f4ec1e7f4c071f00d99bb58a633629eba8d99f" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;cors#Simple_requests&quot;&gt;Simple Access Control Requests&lt;/a&gt; shows you the header exchanges between client and server. Here is a PHP code segment that handles a Simple Request:</source>
          <target state="translated">В разделе &amp;laquo; &lt;a href=&quot;cors#Simple_requests&quot;&gt;Простые запросы управления доступом&amp;raquo;&lt;/a&gt; показан обмен заголовками между клиентом и сервером. Вот сегмент кода PHP, который обрабатывает простой запрос:</target>
        </trans-unit>
        <trans-unit id="fa4d350781530c820391fd6c19e201ae2a7686b3" translate="yes" xml:space="preserve">
          <source>The semantics of GET are unchanged when applied to a collection,
   since GET is defined as, &quot;retrieve whatever information (in the form
   of an entity) is identified by the Request-URI&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  GET, when
   applied to a collection, may return the contents of an &quot;index.html&quot;
   resource, a human-readable view of the contents of the collection, or
   something else altogether.  Hence, it is possible that the result of
   a GET on a collection will bear no correlation to the membership of
   the collection.

   Similarly, since the definition of HEAD is a GET without a response
   message body, the semantics of HEAD are unmodified when applied to
   collection resources.</source>
          <target state="translated">Семантика GET не изменяется при применении к коллекции, поскольку GET определяется как &amp;laquo;получить любую информацию (в форме объекта), идентифицированную Request-URI&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]. GET, применяемый к коллекции, может возвращать содержимое ресурса index.html, удобочитаемое представление содержимого коллекции или что-то еще. Следовательно, возможно, что результат GET для коллекции не будет иметь корреляции с членством в коллекции. Точно так же, поскольку определение HEAD - это GET без тела сообщения ответа, семантика HEAD не изменяется при применении к ресурсам коллекции.</target>
        </trans-unit>
        <trans-unit id="00fa260f74b6e3042ef94427143bf9ccc1a0c47d" translate="yes" xml:space="preserve">
          <source>The server MUST generate an &lt;code&gt;Allow&lt;/code&gt; header field in a 405 response containing a list of the target resource's currently supported methods.</source>
          <target state="translated">Сервер ДОЛЖЕН генерировать поле заголовка &lt;code&gt;Allow&lt;/code&gt; в ответе 405, содержащем список поддерживаемых в настоящее время методов целевого ресурса.</target>
        </trans-unit>
        <trans-unit id="0562c768d353635c49184c6fe08601647efdac48" translate="yes" xml:space="preserve">
          <source>The server also sends &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; with a value of &quot;&lt;code&gt;X-PINGOTHER, Content-Type&lt;/code&gt;&quot;, confirming that these are permitted headers to be used with the actual request. Like &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;, &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; is a comma separated list of acceptable headers.</source>
          <target state="translated">Сервер также отправляет &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; со значением &amp;laquo; &lt;code&gt;X-PINGOTHER, Content-Type&lt;/code&gt; &amp;raquo;, подтверждая, что эти заголовки разрешены для использования с фактическим запросом. Как и &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; , &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; представляет собой список допустимых заголовков, разделенных запятыми.</target>
        </trans-unit>
        <trans-unit id="583376e0dba516f5c2825a92214abd5ad5c19f01" translate="yes" xml:space="preserve">
          <source>The server answers with a code &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; with the header &lt;code&gt;&lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt;: http://example.org/whaddup&lt;/code&gt;.</source>
          <target state="translated">Сервер отвечает кодом &lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt; с заголовком &lt;code&gt;&lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt;: http://example.org/whaddup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51013a828db296ccfd288d288af04cf909401777" translate="yes" xml:space="preserve">
          <source>The server can not find requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 to hide the existence of a resource from an unauthorized client. This response code is probably the most famous one due to its frequent occurence on the web.</source>
          <target state="translated">Сервер не может найти запрашиваемый ресурс.В браузере это означает,что URL-адрес не распознан.В API это также может означать,что конечная точка действительна,но сам ресурс не существует.Серверы могут также послать этот ответ вместо 403,чтобы скрыть существование ресурса от неавторизованного клиента.Этот код ответа является,пожалуй,самым известным в связи с его частым появлением в сети.</target>
        </trans-unit>
        <trans-unit id="79671e2c7c02bbc1b0253a58c7f5460d4f719ccf" translate="yes" xml:space="preserve">
          <source>The server can now redirect to a secure version of the site. A &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header can be used so that the site isn't served by caches to clients that don&amp;rsquo;t support the upgrade mechanism.</source>
          <target state="translated">Теперь сервер может перенаправить на безопасную версию сайта. &lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; заголовок может быть использован так , что сайт не обслуживается кэшем для клиентов , которые не поддерживают механизм обновления.</target>
        </trans-unit>
        <trans-unit id="c5445db0622182456257f92e9ecf6bebf5eeb4a0" translate="yes" xml:space="preserve">
          <source>The server compares the client's &lt;code&gt;ETag&lt;/code&gt; (sent with &lt;code&gt;If-None-Match&lt;/code&gt;) with the &lt;code&gt;ETag&lt;/code&gt; for its current version of the resource and if both values match (that is, the resource has not changed), the server send back a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Not Modified&lt;/code&gt; status, without any body, which tells the client that the cached version of the response is still good to use (&lt;em&gt;fresh&lt;/em&gt;).</source>
          <target state="translated">Сервер сравнивает клиент &lt;code&gt;ETag&lt;/code&gt; (посланный с &lt;code&gt;If-None-Match&lt;/code&gt; ) с &lt;code&gt;ETag&lt;/code&gt; для его текущей версии ресурса , и если оба значения совпадают (то есть, ресурс не изменился), сервер посылает обратно &lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Not Modified&lt;/code&gt; статуса , без тела, которое сообщает клиенту, что кешированная версия ответа все еще пригодна для использования ( &lt;em&gt;свежая&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="61c7564335ef677861a44bea5af3ab893bbca1c3" translate="yes" xml:space="preserve">
          <source>The server could also consider other &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; headers, such as &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Сервер также может учитывать другие заголовки &lt;a href=&quot;../content_negotiation&quot;&gt;согласования содержимого&lt;/a&gt; , такие как &lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96160ecd7ee13608af383e3bb73b0b35b5d6fb42" translate="yes" xml:space="preserve">
          <source>The server detected an infinite loop while processing the request.</source>
          <target state="translated">При обработке запроса сервер обнаружил бесконечный цикл.</target>
        </trans-unit>
        <trans-unit id="fedec016c5b57cc11eff3c532c6a93596d64f0f6" translate="yes" xml:space="preserve">
          <source>The server does not support the functionality required to fulfill the
   request. This is the appropriate response when the server does not
   recognize the request method and is not capable of supporting it for
   any resource.</source>
          <target state="translated">Сервер не поддерживает функциональность,необходимую для выполнения запроса.Это соответствующий ответ,когда сервер не распознает способ запроса и не способен его поддерживать для любого ресурса.</target>
        </trans-unit>
        <trans-unit id="b05cf7bf3fff0832cc499297170da1dced108414" translate="yes" xml:space="preserve">
          <source>The server does not support, or refuses to support, the HTTP protocol
   version that was used in the request message. The server is
   indicating that it is unable or unwilling to complete the request
   using the same major version as the client, as described in &lt;a href=&quot;#section-3.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;, other than with this error message. The response SHOULD contain
   an entity describing why that version is not supported and what other
   protocols are supported by that server.</source>
          <target state="translated">Сервер не поддерживает или отказывается поддерживать версию протокола HTTP, которая использовалась в сообщении запроса. Сервер указывает, что он не может или не хочет выполнить запрос, используя ту же основную версию, что и клиент, как описано в &lt;a href=&quot;#section-3.1&quot;&gt;разделе &lt;/a&gt;&lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; , за исключением этого сообщения об ошибке. Ответ ДОЛЖЕН содержать объект, описывающий, почему эта версия не поддерживается, и какие другие протоколы поддерживаются этим сервером.</target>
        </trans-unit>
        <trans-unit id="c06e31cc29dd99d9a9450fd0a50b146873ff8448" translate="yes" xml:space="preserve">
          <source>The server doesn't have total knowledge of the browser. Even with the Client Hints extension, it has not a complete knowledge of the capabilities of the browser. Unlike reactive content negotiation where the client makes the choice, the server choice is always somewhat arbitrary.</source>
          <target state="translated">Сервер не имеет полного представления о браузере.Даже с расширением Client Hints он не обладает полным знанием возможностей браузера.В отличие от реактивного согласования содержания,когда клиент делает выбор,выбор сервера всегда несколько произволен.</target>
        </trans-unit>
        <trans-unit id="59d4cf28c9831ade812e9ba3919040baedea9266" translate="yes" xml:space="preserve">
          <source>The server encountered an unexpected condition which prevented it
   from fulfilling the request.</source>
          <target state="translated">Сервер столкнулся с неожиданным состоянием,которое не позволило ему выполнить запрос.</target>
        </trans-unit>
        <trans-unit id="10710baff0a022ad3a742df8fef3c65957eb66a8" translate="yes" xml:space="preserve">
          <source>The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.</source>
          <target state="translated">Сервер имеет внутреннюю ошибку конфигурации:выбранный ресурс варианта настроен на ведение прозрачного согласования содержимого сам по себе,и поэтому не является подходящей конечной точкой в процессе согласования.</target>
        </trans-unit>
        <trans-unit id="706ed34301bbcc058a72a5142e2a23a25bb1303a" translate="yes" xml:space="preserve">
          <source>The server has an internal configuration error: transparent content negotiation for the request results in a circular reference.</source>
          <target state="translated">Сервер имеет внутреннюю ошибку конфигурации:прозрачное согласование содержания для запроса приводит к круговой ссылке.</target>
        </trans-unit>
        <trans-unit id="d758b127d939bbbe9c83eda748c2d96b939c4dc5" translate="yes" xml:space="preserve">
          <source>The server has encountered a situation it doesn't know how to handle.</source>
          <target state="translated">Сервер столкнулся с ситуацией,с которой не знает,как справиться.</target>
        </trans-unit>
        <trans-unit id="b30dd73b04a13c811e1dbf9b2319193169edb03c" translate="yes" xml:space="preserve">
          <source>The server has fulfilled a GET request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.</source>
          <target state="translated">Сервер выполнил GET-запрос на ресурс,а ответ представляет собой представление результата одной или нескольких манипуляций с экземпляром,примененных к текущему экземпляру.</target>
        </trans-unit>
        <trans-unit id="e118a9d32f4f8ee5d1a291b20a7b4b379a234f47" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the partial GET request for the resource.
   The request MUST have included a Range header field (&lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt;)
   indicating the desired range, and MAY have included an If-Range
   header field (&lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) to make the request conditional.

   The response MUST include the following header fields:

      - Either a Content-Range header field (&lt;a href=&quot;#section-14.16&quot;&gt;section 14.16&lt;/a&gt;) indicating
        the range included with this response, or a multipart/byteranges
        Content-Type including Content-Range fields for each part. If a
        Content-Length header field is present in the response, its
        value MUST match the actual number of OCTETs transmitted in the
        message-body.

      - Date

      - ETag and/or Content-Location, if the header would have been sent
        in a 200 response to the same request 

      - Expires, Cache-Control, and/or Vary, if the field-value might
        differ from that sent in any previous response for the same
        variant

   If the 206 response is the result of an If-Range request that used a
   strong cache validator (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;), the response SHOULD NOT
   include other entity-headers. If the response is the result of an
   If-Range request that used a weak validator, the response MUST NOT
   include other entity-headers; this prevents inconsistencies between
   cached entity-bodies and updated headers. Otherwise, the response
   MUST include all of the entity-headers that would have been returned
   with a 200 (OK) response to the same request.

   A cache MUST NOT combine a 206 response with other previously cached
   content if the ETag or Last-Modified headers do not match exactly,
   see 13.5.4.

   A cache that does not support the Range and Content-Range headers
   MUST NOT cache 206 (Partial) responses.</source>
          <target state="translated">Сервер выполнил частичный запрос GET для ресурса. Запрос ДОЛЖЕН включать поле заголовка Range ( &lt;a href=&quot;#section-14.35&quot;&gt;раздел 14.35&lt;/a&gt; ), указывающее желаемый диапазон, и МОЖЕТ включать поле заголовка If-Range ( &lt;a href=&quot;#section-14.27&quot;&gt;раздел 14.27&lt;/a&gt; ), чтобы сделать запрос условным. Ответ ДОЛЖЕН включать следующие поля заголовка: - Либо поле заголовка Content-Range ( &lt;a href=&quot;#section-14.16&quot;&gt;раздел 14.16).&lt;/a&gt;), указывающий диапазон, включенный в этот ответ, или Content-Type multipart / byteranges, включая поля Content-Range для каждой части. Если в ответе присутствует поле заголовка Content-Length, его значение ДОЛЖНО соответствовать фактическому количеству OCTET, переданных в теле сообщения. - Дата - ETag и / или Content-Location, если заголовок был бы отправлен в ответе 200 на тот же запрос - Expires, Cache-Control и / или Vary, если значение поля может отличаться от отправленного в любом предыдущий ответ для того же варианта. Если ответ 206 является результатом запроса If-Range, который использовал надежный валидатор кеша (см. &lt;a href=&quot;#section-13.3.3&quot;&gt;раздел 13.3.3)&lt;/a&gt;), ответ НЕ ДОЛЖЕН включать другие заголовки объектов. Если ответ является результатом запроса If-Range, который использовал слабый валидатор, ответ НЕ ДОЛЖЕН включать другие заголовки объектов; это предотвращает несоответствия между кэшированными телами объектов и обновленными заголовками. В противном случае ответ ДОЛЖЕН включать все заголовки объектов, которые были бы возвращены с ответом 200 (OK) на тот же запрос. Кэш НЕ ДОЛЖЕН объединять ответ 206 с другим ранее кэшированным содержимым, если заголовки ETag или Last-Modified не совпадают в точности, см. 13.5.4. Кэш, который не поддерживает заголовки Range и Content-Range, НЕ ДОЛЖЕН кэшировать 206 (частичных) ответов.</target>
        </trans-unit>
        <trans-unit id="9154c7f74bf47c2abcfe8e8637f31d473b4ccf8a" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the request and the user agent SHOULD reset
   the document view which caused the request to be sent. This response
   is primarily intended to allow input for actions to take place via
   user input, followed by a clearing of the form in which the input is
   given so that the user can easily initiate another input action. The
   response MUST NOT include an entity.</source>
          <target state="translated">Сервер выполнил запрос,а агент пользователя SHOULD сбросил представление документа,вызвавшее отправку запроса.Этот ответ предназначен,прежде всего,для того,чтобы пользователь мог вводить данные для выполнения действий через пользовательский ввод,с последующим сбросом формы,в которой вводится данные,с тем,чтобы пользователь мог легко инициировать другое входное действие.Ответ НЕ ДОЛЖЕН включать в себя сущность.</target>
        </trans-unit>
        <trans-unit id="0ee5c3ee094642bb5d46e9cb3d051a90abd31149" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the request but does not need to return an
   entity-body, and might want to return updated metainformation. The
   response MAY include new or updated metainformation in the form of
   entity-headers, which if present SHOULD be associated with the
   requested variant.

   If the client is a user agent, it SHOULD NOT change its document view
   from that which caused the request to be sent. This response is
   primarily intended to allow input for actions to take place without
   causing a change to the user agent's active document view, although
   any new or updated metainformation SHOULD be applied to the document
   currently in the user agent's active view.

   The 204 response MUST NOT include a message-body, and thus is always
   terminated by the first empty line after the header fields.</source>
          <target state="translated">Сервер выполнил запрос,но не нуждается в возврате сущности-тела,и может захотеть вернуть обновленную метаинформацию.Ответ MAY включает в себя новую или обновленную метаинформацию в виде заголовков структур,которые при наличии таковой ДОЛЖНЫ быть связаны с запрошенным вариантом.Если клиент является агентом пользователя,то он НЕ ДОЛЖЕН изменить вид своего документа с того,который вызвал отправку запроса.Этот ответ в первую очередь предназначен для того,чтобы обеспечить возможность ввода действий без изменения активного представления документа агентом пользователя,хотя любая новая или обновленная метаинформация ДОЛЖНА быть применена к документу,находящемуся в настоящее время в активном представлении агента пользователя.Ответ 204 НЕ ДОЛЖЕН включать тело сообщения,и поэтому всегда завершается первой пустой строкой после полей заголовка.</target>
        </trans-unit>
        <trans-unit id="8c2ef715f1697c767e016f66e48a9c5ad3088fc4" translate="yes" xml:space="preserve">
          <source>The server has not found anything matching the Request-URI. No
   indication is given of whether the condition is temporary or
   permanent. The 410 (Gone) status code SHOULD be used if the server
   knows, through some internally configurable mechanism, that an old
   resource is permanently unavailable and has no forwarding address.
   This status code is commonly used when the server does not wish to
   reveal exactly why the request has been refused, or when no other
   response is applicable.</source>
          <target state="translated">Сервер не нашел ничего,подходящего для Request-URI.Не указано,является ли это условие временным или постоянным.Код статуса 410 (Gone)SHOULD используется,если сервер знает,через какой-то внутренне конфигурируемый механизм,что старый ресурс постоянно недоступен и не имеет адреса переадресации.Этот код статуса обычно используется,когда сервер не хочет точно выяснить,почему запрос был отклонен,или когда другой ответ неприменим.</target>
        </trans-unit>
        <trans-unit id="76d2c9e44a151f75cad87b75d25351ab5902d469" translate="yes" xml:space="preserve">
          <source>The server includes in this response an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; response header to indicate the protocol it switched to. The process is described in detail in the article &lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;Protocol upgrade mechanism&lt;/a&gt;.</source>
          <target state="translated">Сервер включает в этот ответ заголовок ответа &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; ,&lt;/a&gt; чтобы указать протокол, на который он переключился. Подробно процесс описан в статье &lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;Механизм обновления протокола&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be80728dab68882cff956fbc4def7165d17d07e6" translate="yes" xml:space="preserve">
          <source>The server is currently unable to handle the request due to a
   temporary overloading or maintenance of the server. The implication
   is that this is a temporary condition which will be alleviated after
   some delay. If known, the length of the delay MAY be indicated in a
   Retry-After header. If no Retry-After is given, the client SHOULD
   handle the response as it would for a 500 response.

      Note: The existence of the 503 status code does not imply that a
      server must use it when becoming overloaded. Some servers may wish
      to simply refuse the connection.</source>
          <target state="translated">В настоящее время сервер не может обработать запрос из-за временной перегрузки или обслуживания сервера.Подразумевается,что это временное состояние,которое будет устранено после некоторой задержки.Если известно,то длительность задержки MAY указывается в заголовке Retry-After.Если не задан параметр Retry-After,клиент ДОЛЖЕН обрабатывать ответ так,как это было бы для ответа 500.Примечание:Наличие кода состояния 503 не означает,что сервер должен использовать его при перегрузке.Некоторые серверы могут просто отказаться от соединения.</target>
        </trans-unit>
        <trans-unit id="baf2d9062e2499753136835fe0c821934d565f38" translate="yes" xml:space="preserve">
          <source>The server is not ready to handle the request. Common causes are a server that is down for maintenance or that is overloaded. Note that together with this response, a user-friendly page explaining the problem should be sent. This responses should be used for temporary conditions and the &lt;code&gt;Retry-After:&lt;/code&gt; HTTP header should, if possible, contain the estimated time before the recovery of the service. The webmaster must also take care about the caching-related headers that are sent along with this response, as these temporary condition responses should usually not be cached.</source>
          <target state="translated">Сервер не готов обработать запрос. Типичные причины - это сервер, который не работает на техническое обслуживание или перегружен. Обратите внимание, что вместе с этим ответом должна быть отправлена ​​удобная страница с объяснением проблемы. Эти ответы следует использовать для временных условий, а HTTP-заголовок &lt;code&gt;Retry-After:&lt;/code&gt; по возможности должен содержать расчетное время до восстановления службы. Веб-мастер также должен позаботиться о заголовках, связанных с кешированием, которые отправляются вместе с этим ответом, поскольку эти временные ответы условий обычно не должны кэшироваться.</target>
        </trans-unit>
        <trans-unit id="30401629d5451d683706de07ce99fc1a19648e2c" translate="yes" xml:space="preserve">
          <source>The server is overloaded and cannot afford the computational overhead induced by the compression requirement. Typically, Microsoft recommends not to compress if a server uses more than 80% of its computational power.</source>
          <target state="translated">Сервер перегружен и не может позволить себе накладные расходы,вызванные требованием сжатия.Обычно Microsoft рекомендует не сжимать,если сервер использует более 80% своей вычислительной мощности.</target>
        </trans-unit>
        <trans-unit id="91058d54183ce48b758a3923ca1dd0add318d618" translate="yes" xml:space="preserve">
          <source>The server is refusing to process a request because the request
   entity is larger than the server is willing or able to process. The
   server MAY close the connection to prevent the client from continuing
   the request.

   If the condition is temporary, the server SHOULD include a Retry-
   After header field to indicate that it is temporary and after what
   time the client MAY try again.</source>
          <target state="translated">Сервер отказывается обрабатывать запрос,потому что сущность запроса больше,чем сервер хочет или может обрабатывать.Сервер MAY закрывает соединение,чтобы предотвратить продолжение запроса клиентом.Если условие является временным,сервер ДОЛЖЕН включить поле заголовка Retry-After (Повтор-после),чтобы указать,что оно является временным и после какого времени клиент MAY пытается снова.</target>
        </trans-unit>
        <trans-unit id="555c0a61bfb0c95cce342015880bc471fe52028d" translate="yes" xml:space="preserve">
          <source>The server is refusing to service the request because the Request-URI
   is longer than the server is willing to interpret. This rare
   condition is only likely to occur when a client has improperly
   converted a POST request to a GET request with long query
   information, when the client has descended into a URI &quot;black hole&quot; of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself), or when the server is under attack by a client attempting to
   exploit security holes present in some servers using fixed-length
   buffers for reading or manipulating the Request-URI.</source>
          <target state="translated">Сервер отказывается обслуживать запрос,потому что Request-URI длиннее,чем сервер хочет интерпретировать.Это редкое условие может возникнуть только в том случае,если клиент неправильно преобразовал POST-запрос в GET-запрос с длинной информацией о запросе,когда клиент спустился в &quot;черную дыру&quot; URI перенаправления (например,префикс перенаправленного URI,указывающий на суффикс самого себя),или когда сервер подвергается атаке со стороны клиента,пытающегося использовать дыры в безопасности,присутствующие в некоторых серверах,используя буферы фиксированной длины для чтения или манипулируя Request-URI.</target>
        </trans-unit>
        <trans-unit id="b7583fbc3987a772449c07846db7b69d3aab25c3" translate="yes" xml:space="preserve">
          <source>The server is refusing to service the request because the entity of
   the request is in a format not supported by the requested resource
   for the requested method.</source>
          <target state="translated">Сервер отказывается обслуживать запрос,так как сущность запроса находится в формате,не поддерживаемом запрашиваемым ресурсом для запрашиваемого метода.</target>
        </trans-unit>
        <trans-unit id="9e40f61b278945136b6bf8c69ccb6441c6101dc0" translate="yes" xml:space="preserve">
          <source>The server is unwilling to process the request because its header fields are too large. The request MAY be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">Сервер не хочет обрабатывать запрос,так как его поля заголовка слишком велики.Запрос MAY должен быть отправлен повторно после уменьшения размера полей заголовка запроса.</target>
        </trans-unit>
        <trans-unit id="6b402009d984cfa7b4aa7445fadf6432930d62bf" translate="yes" xml:space="preserve">
          <source>The server may either refuse the upgrade &amp;mdash; in this case it merely ignores the &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; header and sends back a regular response (&lt;code&gt;&quot;200 OK&quot;&lt;/code&gt; if it can serve the requested resource, a &lt;code&gt;30x&lt;/code&gt; status code if it wants to perform a redirect, a &lt;code&gt;40x&lt;/code&gt; or &lt;code&gt;50x&lt;/code&gt; one if it can't serve the requested resource) &amp;mdash; or accept the upgrade. In this case, it sends back a &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; with an Upgrade header that specifies the protocol chosen.</source>
          <target state="translated">Сервер может либо отказаться от обновления - в этом случае он просто игнорирует заголовок &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; и отправляет обратно обычный ответ ( &lt;code&gt;&quot;200 OK&quot;&lt;/code&gt; если он может обслуживать запрошенный ресурс, &lt;code&gt;30x&lt;/code&gt; код состояния, если он хочет выполнить перенаправление, &lt;code&gt;40x&lt;/code&gt; или &lt;code&gt;50x&lt;/code&gt; один , если он не может служить запрошенный ресурс) - или принимать обновления. В этом случае он отправляет обратно &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; с заголовком Upgrade, в котором указывается выбранный протокол.</target>
        </trans-unit>
        <trans-unit id="2eb9ea8eac80a46172e3c3d063d37cbb8a09735e" translate="yes" xml:space="preserve">
          <source>The server may specify &quot;*&quot; as a wildcard, thereby allowing any origin to see timing resources.</source>
          <target state="translated">Сервер может указать &quot;*&quot; в качестве подстановочного знака,тем самым позволяя любому источнику видеть временные ресурсы.</target>
        </trans-unit>
        <trans-unit id="0103c094e5add7857b8d5242900bc764e81c4d56" translate="yes" xml:space="preserve">
          <source>The server now checks the request headers and may respond with a &lt;a href=&quot;../status/100&quot;&gt;&lt;code&gt;100&lt;/code&gt;&lt;/a&gt; (Continue) response to instruct the client to go ahead and send the message body, or it will send a &lt;a href=&quot;../status/417&quot;&gt;&lt;code&gt;417&lt;/code&gt;&lt;/a&gt; (Expectation Failed) status if any of the expectations cannot be met.</source>
          <target state="translated">Теперь сервер проверяет заголовки запроса и может ответить ответом &lt;a href=&quot;../status/100&quot;&gt; &lt;code&gt;100&lt;/code&gt; &lt;/a&gt; (Продолжить), чтобы дать клиенту указание продолжить и отправить тело сообщения, или он отправит статус &lt;a href=&quot;../status/417&quot;&gt; &lt;code&gt;417&lt;/code&gt; &lt;/a&gt; (Ожидание не выполнено), если какое-либо из ожиданий не может быть выполнено.</target>
        </trans-unit>
        <trans-unit id="e1283857d0934fd62a1b18ee296b4ffd28fea393" translate="yes" xml:space="preserve">
          <source>The server only permits access to documents being loaded specifically over HTTPS through the single origin onlinebanking.jumbobank.com.</source>
          <target state="translated">Сервер разрешает доступ только к документам,загружаемым специально по HTTPS через единственный источник на onlinebanking.jumbobank.com.</target>
        </trans-unit>
        <trans-unit id="19c7fec239224320ece1ddcef09fb8d8afe6a922" translate="yes" xml:space="preserve">
          <source>The server processes the request, sending back its answer, providing a status code and appropriate data.</source>
          <target state="translated">Сервер обрабатывает запрос,отправляя ответ,предоставляя код состояния и соответствующие данные.</target>
        </trans-unit>
        <trans-unit id="4a76d046fb30a4094df60f730aa186a8214f36f9" translate="yes" xml:space="preserve">
          <source>The server refuses the attempt to brew coffee with a teapot.</source>
          <target state="translated">Сервер отказывается от попытки заваривать кофе с чайником.</target>
        </trans-unit>
        <trans-unit id="0521746f768ead6cf341a3de72d80f86946a50aa" translate="yes" xml:space="preserve">
          <source>The server refuses to accept the request without a defined Content-
   Length. The client MAY repeat the request if it adds a valid
   Content-Length header field containing the length of the message-body
   in the request message.</source>
          <target state="translated">Сервер отказывается принять запрос без определенного Content-Length.Клиент MAY повторяет запрос,если добавляет поле заголовка Content-Length,содержащее длину тела сообщения в запросном сообщении.</target>
        </trans-unit>
        <trans-unit id="098d1595780b213e964cc55bccf5bbf26c81cacc" translate="yes" xml:space="preserve">
          <source>The server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol. The server sends an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header in a 426 response to indicate the required protocol(s).</source>
          <target state="translated">Сервер отказывается выполнять запрос с использованием текущего протокола, но может пожелать сделать это после того, как клиент перейдет на другой протокол. Сервер отправляет заголовок &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; в ответе 426, чтобы указать требуемый протокол (ы).</target>
        </trans-unit>
        <trans-unit id="d96c620c10c72c2facba569247c0abd76880b504" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; and says that &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, and &lt;code&gt;OPTIONS&lt;/code&gt; are viable methods to query the resource in question. This header is similar to the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of CORS.</source>
          <target state="translated">Сервер отвечает &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; и сообщает, что &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;GET&lt;/code&gt; и &lt;code&gt;OPTIONS&lt;/code&gt; являются жизнеспособными методами для запроса соответствующего ресурса. Этот заголовок аналогичен заголовку ответа &lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt; , но используется строго в контексте CORS.</target>
        </trans-unit>
        <trans-unit id="0adba182e0838c8ba807f3caebecfe1ff5519a80" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; and says that &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; are viable methods to query the resource in question. Note that this header is similar to the &lt;a href=&quot;headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of access control.</source>
          <target state="translated">Сервер отвечает &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; и сообщает, что &lt;code&gt;POST&lt;/code&gt; и &lt;code&gt;GET&lt;/code&gt; являются жизнеспособными методами для запроса соответствующего ресурса. Обратите внимание, что этот заголовок аналогичен заголовку ответа &lt;a href=&quot;headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt; , но используется строго в контексте управления доступом.</target>
        </trans-unit>
        <trans-unit id="5d7efc45419f666af1044e66769f805e285297d7" translate="yes" xml:space="preserve">
          <source>The server responds with the scheme used, indicated by the &lt;code&gt;Content-Encoding&lt;/code&gt; response header.</source>
          <target state="translated">Сервер отвечает используемой схемой, указанной в заголовке ответа &lt;code&gt;Content-Encoding&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adb6ebfb2d7ba636e549327e9964bd8e4a9aa87e" translate="yes" xml:space="preserve">
          <source>The server responses with the &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; status and a &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: multipart/byteranges; boundary=3d6b6a416f9b5&lt;/code&gt; header, indicating that a multipart byterange follows. Each part contains its own &lt;code&gt;Content-Type&lt;/code&gt; and &lt;code&gt;Content-Range&lt;/code&gt; fields and the required boundary parameter specifies the boundary string used to separate each body-part.</source>
          <target state="translated">Сервер отвечает со статусом &lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; и &lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: multipart/byteranges; boundary=3d6b6a416f9b5&lt;/code&gt; заголовок, указывающий, что следует составной диапазон байтов . Каждая часть содержит свои собственные поля &lt;code&gt;Content-Type&lt;/code&gt; и &lt;code&gt;Content-Range&lt;/code&gt; , а обязательный параметр границы указывает граничную строку, используемую для разделения каждой части тела.</target>
        </trans-unit>
        <trans-unit id="d9701baf78124c3a98a96cf4e906d3722ade4288" translate="yes" xml:space="preserve">
          <source>The server responses with the &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; status:</source>
          <target state="translated">Сервер отвечает со статусом &lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="60a245e6b24fad30a550d86662bff1af7454a2ee" translate="yes" xml:space="preserve">
          <source>The server sends an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header with this response to indicate the required protocol(s).</source>
          <target state="translated">Сервер отправляет заголовок &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; с этим ответом, чтобы указать требуемый протокол (ы).</target>
        </trans-unit>
        <trans-unit id="9542fcfca4223129b519747385fa48be52ecf048" translate="yes" xml:space="preserve">
          <source>The server sends this response to direct the client to get the requested resource at another URI with same method that was used in the prior request. This has the same semantics as the &lt;code&gt;302 Found&lt;/code&gt; HTTP response code, with the exception that the user agent &lt;em&gt;must not&lt;/em&gt; change the HTTP method used: If a &lt;code&gt;POST&lt;/code&gt; was used in the first request, a &lt;code&gt;POST&lt;/code&gt; must be used in the second request.</source>
          <target state="translated">Сервер отправляет этот ответ, чтобы указать клиенту получить запрошенный ресурс по другому URI с тем же методом, который использовался в предыдущем запросе. Он имеет ту же семантику, что и код ответа HTTP &lt;code&gt;302 Found&lt;/code&gt; , за исключением того, что пользовательский агент &lt;em&gt;не должен&lt;/em&gt; изменять используемый метод HTTP: если &lt;code&gt;POST&lt;/code&gt; использовался в первом запросе, &lt;code&gt;POST&lt;/code&gt; должен использоваться во втором запросе.</target>
        </trans-unit>
        <trans-unit id="5c7306d33878ab5bc99fecabc06252df15d1029f" translate="yes" xml:space="preserve">
          <source>The server sent this response to direct the client to get the requested resource at another URI with a GET request.</source>
          <target state="translated">Сервер отправил этот ответ,чтобы направить клиента на получение запрашиваемого ресурса по другому URI с GET-запросом.</target>
        </trans-unit>
        <trans-unit id="8cf25e98d428f5cff29ccef9eba702a25e100fa8" translate="yes" xml:space="preserve">
          <source>The server understands and is willing to comply with the client's
   request, via the Upgrade message header field (&lt;a href=&quot;#section-14.42&quot;&gt;section 14.42&lt;/a&gt;), for a
   change in the application protocol being used on this connection. The
   server will switch protocols to those defined by the response's
   Upgrade header field immediately after the empty line which
   terminates the 101 response.

   The protocol SHOULD be switched only when it is advantageous to do
   so. For example, switching to a newer version of HTTP is advantageous
   over older versions, and switching to a real-time, synchronous
   protocol might be advantageous when delivering resources that use
   such features.</source>
          <target state="translated">Сервер понимает и готов выполнить запрос клиента через поле заголовка сообщения Upgrade ( &lt;a href=&quot;#section-14.42&quot;&gt;раздел 14.42&lt;/a&gt; ) об изменении протокола приложения, используемого в этом соединении. Сервер переключит протоколы на те, которые определены в поле заголовка Upgrade ответа сразу после пустой строки, завершающей ответ 101. Протокол СЛЕДУЕТ переключать только тогда, когда это выгодно. Например, переключение на более новую версию HTTP выгодно по сравнению со старыми версиями, а переключение на синхронный протокол реального времени может быть выгодным при доставке ресурсов, использующих такие функции.</target>
        </trans-unit>
        <trans-unit id="1d1ec0c651dbab18735a86dfc8ae8c14372b5e8a" translate="yes" xml:space="preserve">
          <source>The server understood the request, but is refusing to fulfill it.
   Authorization will not help and the request SHOULD NOT be repeated.
   If the request method was not HEAD and the server wishes to make
   public why the request has not been fulfilled, it SHOULD describe the
   reason for the refusal in the entity.  If the server does not wish to
   make this information available to the client, the status code 404
   (Not Found) can be used instead.</source>
          <target state="translated">Сервер понял запрос,но отказывается его выполнять.Авторизация не поможет и запрос НЕ ДОЛЖЕН повториться.Если метод запроса не был HEAD и сервер хочет обнародовать причину,по которой запрос не был выполнен,то он ДОЛЖЕН описать причину отказа в сущности.Если сервер не хочет делать эту информацию доступной для клиента,вместо него можно использовать код статуса 404 (Not Found).</target>
        </trans-unit>
        <trans-unit id="94809fc6f53d174f5374acd4dfb1f7acb678c149" translate="yes" xml:space="preserve">
          <source>The server's response's &lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt; header will have a value computed based upon the specified &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Заголовок &lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt; ответа сервера будет иметь значение, вычисленное на основе указанного &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3ef1a39a25ddc08d8e0d5a5bb5464d92b09bc2a" translate="yes" xml:space="preserve">
          <source>The server, while acting as a gateway or proxy, did not receive a
   timely response from the upstream server specified by the URI (e.g.
   HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed
   to access in attempting to complete the request.

      Note: Note to implementors: some deployed proxies are known to
      return 400 or 500 when DNS lookups time out.</source>
          <target state="translated">Сервер,действуя в качестве шлюза или прокси-сервера,не получил своевременного ответа от сервера,указанного URI (например,HTTP,FTP,LDAP)или от какого-то другого вспомогательного сервера (например,DNS),к которому он должен был получить доступ при попытке завершения запроса.Примечание:Примечание для исполнителей:некоторые развернутые прокси-серверы,как известно,возвращают 400 или 500,когда время поиска DNS заканчивается.</target>
        </trans-unit>
        <trans-unit id="46e47cc0b16529d905f0b1b3af210872557d572b" translate="yes" xml:space="preserve">
          <source>The server, while acting as a gateway or proxy, received an invalid
   response from the upstream server it accessed in attempting to
   fulfill the request.</source>
          <target state="translated">Сервер,действуя в качестве шлюза или прокси-сервера,получил недействительный ответ от сервера,к которому он обращался при попытке выполнить запрос.</target>
        </trans-unit>
        <trans-unit id="cad9f838a72a1881211f8a63fadbd9aa2da06441" translate="yes" xml:space="preserve">
          <source>The set of common methods for HTTP/1.1 is defined below. Although
   this set can be expanded, additional methods cannot be assumed to
   share the same semantics for separately extended clients and servers.

   The Host request-header field (&lt;a href=&quot;#section-14.23&quot;&gt;section 14.23&lt;/a&gt;) MUST accompany all
   HTTP/1.1 requests.</source>
          <target state="translated">Набор общих методов для HTTP / 1.1 определен ниже. Хотя этот набор может быть расширен, нельзя предполагать, что дополнительные методы используют одну и ту же семантику для отдельно расширенных клиентов и серверов. Поле заголовка запроса хоста ( &lt;a href=&quot;#section-14.23&quot;&gt;раздел 14.23&lt;/a&gt; ) ДОЛЖНО сопровождать все запросы HTTP / 1.1.</target>
        </trans-unit>
        <trans-unit id="57fc403f1552de7486f1009e75d3e485460c6c32" translate="yes" xml:space="preserve">
          <source>The site returns a generic success message confirming the post was published. The server specifies &lt;em&gt;where&lt;/em&gt; the new post is with &lt;code&gt;Content-Location&lt;/code&gt;:</source>
          <target state="translated">Сайт возвращает типовое сообщение об успешной публикации, подтверждающее публикацию сообщения. Сервер указывает, &lt;em&gt;где&lt;/em&gt; находится новый пост, с помощью &lt;code&gt;Content-Location&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="40812bee8a9705438af783eaa9ebe956256664d2" translate="yes" xml:space="preserve">
          <source>The special value of '&lt;code&gt;*&lt;/code&gt;' means that the server-driven content negotiation also uses information not conveyed in a header to choose the appropriate content.</source>
          <target state="translated">Специальное значение &amp;laquo; &lt;code&gt;*&lt;/code&gt; &amp;raquo; означает, что управляемое сервером согласование контента также использует информацию, не переданную в заголовке, для выбора подходящего контента.</target>
        </trans-unit>
        <trans-unit id="8f79a17c3099080cc2dd18760e1e6dd5db53ca77" translate="yes" xml:space="preserve">
          <source>The specification advices that names and descriptions should be kept as short as possible (use abbreviations and omit optional values where possible) to minimize the HTTP overhead.</source>
          <target state="translated">Спецификация советует,чтобы названия и описания были как можно короче (используйте аббревиатуры и пропустите необязательные значения,где это возможно),чтобы минимизировать накладные расходы HTTP.</target>
        </trans-unit>
        <trans-unit id="6830140aefcebc442d186cdf8f55cdcc404c9a85" translate="yes" xml:space="preserve">
          <source>The specification has been substantially rewritten for clarity.

   The conditions under which an authenticated response can be cached
   have been clarified.  (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;)

   New status codes can now define that caches are allowed to use
   heuristic freshness with them.  Caches are now allowed to calculate
   heuristic freshness for URIs with query components.  (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   The algorithm for calculating age is now less conservative.  Caches
   are now required to handle dates with time zones as if they're
   invalid, because it's not possible to accurately guess.
   (&lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;)

   The Content-Location response header field is no longer used to
   determine the appropriate response to use when validating.
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;)

   The algorithm for selecting a cached negotiated response to use has
   been clarified in several ways.  In particular, it now explicitly
   allows header-specific canonicalization when processing selecting
   header fields.  (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   Requirements regarding denial-of-service attack avoidance when
   performing invalidation have been clarified.  (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;)

   Cache invalidation only occurs when a successful response is
   received.  (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;)

   Cache directives are explicitly defined to be case-insensitive.
   Handling of multiple instances of cache directives when only one is
   expected is now defined.  (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;)

   The &quot;no-store&quot; request directive doesn't apply to responses; i.e., a
   cache can satisfy a request with no-store on it and does not
   invalidate it.  (&lt;a href=&quot;#section-5.2.1.5&quot;&gt;Section 5.2.1.5&lt;/a&gt;)

   The qualified forms of the private and no-cache cache directives are
   noted to not be widely implemented; for example, &quot;private=foo&quot; is
   interpreted by many caches as simply &quot;private&quot;.  Additionally, the
   meaning of the qualified form of no-cache has been clarified.
   (&lt;a href=&quot;#section-5.2.2&quot;&gt;Section 5.2.2&lt;/a&gt;)

   The &quot;no-cache&quot; response directive's meaning has been clarified.
   (&lt;a href=&quot;#section-5.2.2.2&quot;&gt;Section 5.2.2.2&lt;/a&gt;) 

   The one-year limit on Expires header field values has been removed;
   instead, the reasoning for using a sensible value is given.
   (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;)

   The Pragma header field is now only defined for backwards
   compatibility; future pragmas are deprecated.  (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;)

   Some requirements regarding production and processing of the Warning
   header fields have been relaxed, as it is not widely implemented.
   Furthermore, the Warning header field no longer uses &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;
   encoding, nor does it allow multiple languages, as these aspects were
   not implemented.  (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;)

   This specification introduces the Cache Directive and Warn Code
   Registries, and defines considerations for new cache directives.
   (&lt;a href=&quot;#section-7.1&quot;&gt;Section 7.1&lt;/a&gt; and &lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;)</source>
          <target state="translated">Для ясности спецификация была существенно переписана. Уточнены условия, при которых аутентифицированный ответ может быть кэширован. ( &lt;a href=&quot;#section-3.2&quot;&gt;Раздел 3.2&lt;/a&gt; ) Новые коды состояния теперь могут определять, что кэшам разрешено использовать с ними эвристическую актуальность. Кэшам теперь разрешено вычислять эвристическую актуальность для URI с компонентами запроса. ( &lt;a href=&quot;#section-4.2.2&quot;&gt;Раздел 4.2.2&lt;/a&gt; ) Алгоритм расчета возраста стал менее консервативным. Кеши теперь требуются для обработки дат с часовыми поясами, как если бы они недействительны, потому что невозможно точно угадать. ( &lt;a href=&quot;#section-4.2.3&quot;&gt;Раздел 4.2.3&lt;/a&gt; ) Поле заголовка ответа Content-Location больше не используется для определения соответствующего ответа, который будет использоваться при проверке. ( &lt;a href=&quot;#section-4.3&quot;&gt;Раздел 4.3&lt;/a&gt;Алгоритм выбора кэшированного согласованного ответа для использования был разъяснен несколькими способами. В частности, теперь он явно разрешает канонизацию для конкретного заголовка при обработке выбора полей заголовка. ( &lt;a href=&quot;#section-4.1&quot;&gt;Раздел 4.1&lt;/a&gt; ) Уточнены требования по предотвращению атак типа &amp;laquo;отказ в обслуживании&amp;raquo; при выполнении аннулирования. ( &lt;a href=&quot;#section-4.4&quot;&gt;Раздел 4.4&lt;/a&gt; ) Аннулирование кеша происходит только при получении успешного ответа. ( &lt;a href=&quot;#section-4.4&quot;&gt;Раздел 4.4&lt;/a&gt; ) Директивы кэша явно определены как нечувствительные к регистру. Теперь определена обработка нескольких экземпляров директив кеша, когда ожидается только одна. ( &lt;a href=&quot;#section-5.2&quot;&gt;Раздел 5.2&lt;/a&gt;) Директива запроса &quot;no-store&quot; не применяется к ответам; т.е. кэш может удовлетворить запрос без сохранения в нем и не делает его недействительным. ( &lt;a href=&quot;#section-5.2.1.5&quot;&gt;Раздел 5.2.1.5&lt;/a&gt; ) Отмечено, что определенные формы директив private и no-cache не получили широкого распространения; например, &quot;private = foo&quot; интерпретируется многими кешами как просто &quot;частный&quot;. Кроме того, было разъяснено значение квалифицированной формы отсутствия кеширования. ( &lt;a href=&quot;#section-5.2.2&quot;&gt;Раздел 5.2.2&lt;/a&gt; ) Уточнено значение директивы ответа &amp;laquo;no-cache&amp;raquo;. ( &lt;a href=&quot;#section-5.2.2.2&quot;&gt;Раздел 5.2.2.2&lt;/a&gt; ) Ограничение в один год для значений поля заголовка Expires было удалено; вместо этого приводится обоснование использования разумного значения. ( &lt;a href=&quot;#section-5.3&quot;&gt;Раздел 5.3&lt;/a&gt;) Поле заголовка Pragma теперь определяется только для обратной совместимости; будущие прагмы устарели. ( &lt;a href=&quot;#section-5.4&quot;&gt;Раздел 5.4&lt;/a&gt; ) Некоторые требования, касающиеся создания и обработки полей заголовка &amp;laquo;Предупреждение&amp;raquo;, были ослаблены, так как это широко не применяется. Кроме того, поле заголовка &amp;laquo;Предупреждение&amp;raquo; больше не использует кодировку &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; и не поддерживает использование нескольких языков, поскольку эти аспекты не были реализованы. ( &lt;a href=&quot;#section-5.5&quot;&gt;Раздел 5.5&lt;/a&gt; ) Эта спецификация вводит реестры директив кэширования и кода предупреждений, а также определяет особенности новых директив кеширования. ( &lt;a href=&quot;#section-7.1&quot;&gt;Раздел 7.1&lt;/a&gt; и &lt;a href=&quot;#section-7.2&quot;&gt;Раздел 7.2&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="69f7236ac3c099aef6887071703596241bc5ffd5" translate="yes" xml:space="preserve">
          <source>The specified HTTPS proxy should be used</source>
          <target state="translated">Необходимо использовать указанный HTTPS прокси</target>
        </trans-unit>
        <trans-unit id="53a5be96dd5bb71c6d16a8d35e8c39cbe4374a0d" translate="yes" xml:space="preserve">
          <source>The specified SOCKS server (with the specified SOCK version) should be used</source>
          <target state="translated">Следует использовать указанный SOCKS-сервер (с указанной версией SOCK)</target>
        </trans-unit>
        <trans-unit id="303a58e78e8f8eb268fe6f62c8b7f193b6bc1142" translate="yes" xml:space="preserve">
          <source>The specified SOCKS server should be used</source>
          <target state="translated">Должен использоваться указанный сервер SOCKS</target>
        </trans-unit>
        <trans-unit id="68cc27ab7cd860287da7fdc9be46fedaaa277c72" translate="yes" xml:space="preserve">
          <source>The specified proxy should be used</source>
          <target state="translated">Необходимо использовать указанный прокси-сервер</target>
        </trans-unit>
        <trans-unit id="6b8ade5bf013491609fa2a91c4e3f35610d584fc" translate="yes" xml:space="preserve">
          <source>The standardized header:</source>
          <target state="translated">Стандартный заголовок:</target>
        </trans-unit>
        <trans-unit id="f7bf0204749a2c35928a6f9840f70eb32df13567" translate="yes" xml:space="preserve">
          <source>The start line of an HTTP response, called the &lt;em&gt;status line&lt;/em&gt;, contains the following information:</source>
          <target state="translated">Начальная строка HTTP-ответа, называемая &lt;em&gt;строкой состояния&lt;/em&gt; , содержит следующую информацию:</target>
        </trans-unit>
        <trans-unit id="f31c6de41f53a39d348494f7a67a1dcc8252643d" translate="yes" xml:space="preserve">
          <source>The start-line and HTTP headers of the HTTP message are collectively known as the &lt;em&gt;head&lt;/em&gt; of the requests, whereas its payload is known as the &lt;em&gt;body&lt;/em&gt;.</source>
          <target state="translated">Начало строки и HTTP - заголовки сообщения HTTP все вместе известны как &lt;em&gt;головки&lt;/em&gt; из запросов, тогда как его полезной нагрузки известна как &lt;em&gt;тело&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3f72d9e6a8a95e3d9c5ddb845c0490a8f4e705e6" translate="yes" xml:space="preserve">
          <source>The status code registry has been updated with the registrations
   below: 

   +-------+-------------------------------+----------------+
   | Value | Description                   | Reference      |
   +-------+-------------------------------+----------------+
   | 100   | Continue                      | &lt;a href=&quot;#section-6.2.1&quot;&gt;Section 6.2.1&lt;/a&gt;  |
   | 101   | Switching Protocols           | &lt;a href=&quot;#section-6.2.2&quot;&gt;Section 6.2.2&lt;/a&gt;  |
   | 200   | OK                            | &lt;a href=&quot;#section-6.3.1&quot;&gt;Section 6.3.1&lt;/a&gt;  |
   | 201   | Created                       | &lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;  |
   | 202   | Accepted                      | &lt;a href=&quot;#section-6.3.3&quot;&gt;Section 6.3.3&lt;/a&gt;  |
   | 203   | Non-Authoritative Information | &lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;  |
   | 204   | No Content                    | &lt;a href=&quot;#section-6.3.5&quot;&gt;Section 6.3.5&lt;/a&gt;  |
   | 205   | Reset Content                 | &lt;a href=&quot;#section-6.3.6&quot;&gt;Section 6.3.6&lt;/a&gt;  |
   | 300   | Multiple Choices              | &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;  |
   | 301   | Moved Permanently             | &lt;a href=&quot;#section-6.4.2&quot;&gt;Section 6.4.2&lt;/a&gt;  |
   | 302   | Found                         | &lt;a href=&quot;#section-6.4.3&quot;&gt;Section 6.4.3&lt;/a&gt;  |
   | 303   | See Other                     | &lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;  |
   | 305   | Use Proxy                     | &lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;  |
   | 306   | (Unused)                      | &lt;a href=&quot;#section-6.4.6&quot;&gt;Section 6.4.6&lt;/a&gt;  |
   | 307   | Temporary Redirect            | &lt;a href=&quot;#section-6.4.7&quot;&gt;Section 6.4.7&lt;/a&gt;  |
   | 400   | Bad Request                   | &lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;  |
   | 402   | Payment Required              | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;  |
   | 403   | Forbidden                     | &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt;  |
   | 404   | Not Found                     | &lt;a href=&quot;#section-6.5.4&quot;&gt;Section 6.5.4&lt;/a&gt;  |
   | 405   | Method Not Allowed            | &lt;a href=&quot;#section-6.5.5&quot;&gt;Section 6.5.5&lt;/a&gt;  |
   | 406   | Not Acceptable                | &lt;a href=&quot;#section-6.5.6&quot;&gt;Section 6.5.6&lt;/a&gt;  |
   | 408   | Request Timeout               | &lt;a href=&quot;#section-6.5.7&quot;&gt;Section 6.5.7&lt;/a&gt;  |
   | 409   | Conflict                      | &lt;a href=&quot;#section-6.5.8&quot;&gt;Section 6.5.8&lt;/a&gt;  |
   | 410   | Gone                          | &lt;a href=&quot;#section-6.5.9&quot;&gt;Section 6.5.9&lt;/a&gt;  |
   | 411   | Length Required               | &lt;a href=&quot;#section-6.5.10&quot;&gt;Section 6.5.10&lt;/a&gt; |
   | 413   | Payload Too Large             | &lt;a href=&quot;#section-6.5.11&quot;&gt;Section 6.5.11&lt;/a&gt; |
   | 414   | URI Too Long                  | &lt;a href=&quot;#section-6.5.12&quot;&gt;Section 6.5.12&lt;/a&gt; |
   | 415   | Unsupported Media Type        | &lt;a href=&quot;#section-6.5.13&quot;&gt;Section 6.5.13&lt;/a&gt; |
   | 417   | Expectation Failed            | &lt;a href=&quot;#section-6.5.14&quot;&gt;Section 6.5.14&lt;/a&gt; |
   | 426   | Upgrade Required              | &lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt; |
   | 500   | Internal Server Error         | &lt;a href=&quot;#section-6.6.1&quot;&gt;Section 6.6.1&lt;/a&gt;  |
   | 501   | Not Implemented               | &lt;a href=&quot;#section-6.6.2&quot;&gt;Section 6.6.2&lt;/a&gt;  |
   | 502   | Bad Gateway                   | &lt;a href=&quot;#section-6.6.3&quot;&gt;Section 6.6.3&lt;/a&gt;  |
   | 503   | Service Unavailable           | &lt;a href=&quot;#section-6.6.4&quot;&gt;Section 6.6.4&lt;/a&gt;  |
   | 504   | Gateway Timeout               | &lt;a href=&quot;#section-6.6.5&quot;&gt;Section 6.6.5&lt;/a&gt;  |
   | 505   | HTTP Version Not Supported    | &lt;a href=&quot;#section-6.6.6&quot;&gt;Section 6.6.6&lt;/a&gt;  |
   +-------+-------------------------------+----------------+</source>
          <target state="translated">Реестр кодов состояния был обновлен регистрациями ниже: + ------- + ----------------------------- - + ---------------- + | Значение | Описание | Справка | + ------- + ------------------------------- + --------- ------- + | 100 | Продолжить | &lt;a href=&quot;#section-6.2.1&quot;&gt;Раздел 6.2.1&lt;/a&gt; | | 101 | Протоколы переключения | &lt;a href=&quot;#section-6.2.2&quot;&gt;Раздел 6.2.2&lt;/a&gt; | | 200 | ОК | &lt;a href=&quot;#section-6.3.1&quot;&gt;Раздел 6.3.1&lt;/a&gt; | | 201 | Создано | &lt;a href=&quot;#section-6.3.2&quot;&gt;Раздел 6.3.2&lt;/a&gt; | | 202 | Принято | &lt;a href=&quot;#section-6.3.3&quot;&gt;Раздел 6.3.3&lt;/a&gt; | | 203 | Неавторитетная информация | &lt;a href=&quot;#section-6.3.4&quot;&gt;Раздел 6.3.4&lt;/a&gt; | | 204 | Нет содержимого |&lt;a href=&quot;#section-6.3.5&quot;&gt;Раздел 6.3.5&lt;/a&gt; | | 205 | Сбросить содержимое | &lt;a href=&quot;#section-6.3.6&quot;&gt;Раздел 6.3.6&lt;/a&gt; | | 300 | Множественный выбор | &lt;a href=&quot;#section-6.4.1&quot;&gt;Раздел 6.4.1&lt;/a&gt; | | 301 | Переехал навсегда | &lt;a href=&quot;#section-6.4.2&quot;&gt;Раздел 6.4.2&lt;/a&gt; | | 302 | Найдено | &lt;a href=&quot;#section-6.4.3&quot;&gt;Раздел 6.4.3&lt;/a&gt; | | 303 | См. Другое | &lt;a href=&quot;#section-6.4.4&quot;&gt;Раздел 6.4.4&lt;/a&gt; | | 305 | Использовать прокси | &lt;a href=&quot;#section-6.4.5&quot;&gt;Раздел 6.4.5&lt;/a&gt; | | 306 | (Не используется) | &lt;a href=&quot;#section-6.4.6&quot;&gt;Раздел 6.4.6&lt;/a&gt; | | 307 | Временное перенаправление | &lt;a href=&quot;#section-6.4.7&quot;&gt;Раздел 6.4.7&lt;/a&gt; | | 400 | Плохой запрос | &lt;a href=&quot;#section-6.5.1&quot;&gt;Раздел 6.5.1&lt;/a&gt; | | 402 | Требуется оплата | &lt;a href=&quot;#section-6.5.2&quot;&gt;Раздел 6.5.2&lt;/a&gt; | | 403 | Запрещено | &lt;a href=&quot;#section-6.5.3&quot;&gt;Раздел 6.5.3&lt;/a&gt; | | 404 | Не найдено | &lt;a href=&quot;#section-6.5.4&quot;&gt;Раздел 6.5.4&lt;/a&gt; | | 405 | Метод не разрешен | &lt;a href=&quot;#section-6.5.5&quot;&gt;Раздел 6.5.5&lt;/a&gt; | | 406 | Неприемлемо | &lt;a href=&quot;#section-6.5.6&quot;&gt;Раздел 6.5.6&lt;/a&gt; | | 408 | Тайм-аут запроса | &lt;a href=&quot;#section-6.5.7&quot;&gt;Раздел 6.5.7&lt;/a&gt; | | 409 | Конфликт | &lt;a href=&quot;#section-6.5.8&quot;&gt;Раздел 6.5.8&lt;/a&gt; | | 410 | Ушел | &lt;a href=&quot;#section-6.5.9&quot;&gt;Раздел 6.5.9&lt;/a&gt; | | 411 | Требуемая длина | &lt;a href=&quot;#section-6.5.10&quot;&gt;Раздел 6.5.10&lt;/a&gt; | | 413 | Слишком большая полезная нагрузка |&lt;a href=&quot;#section-6.5.11&quot;&gt;Раздел 6.5.11&lt;/a&gt; | | 414 | URI слишком длинный | &lt;a href=&quot;#section-6.5.12&quot;&gt;Раздел 6.5.12&lt;/a&gt; | | 415 | Неподдерживаемый тип носителя | &lt;a href=&quot;#section-6.5.13&quot;&gt;Раздел 6.5.13&lt;/a&gt; | | 417 | Ожидания не оправдались | &lt;a href=&quot;#section-6.5.14&quot;&gt;Раздел 6.5.14&lt;/a&gt; | | 426 | Требуется обновление | &lt;a href=&quot;#section-6.5.15&quot;&gt;Раздел 6.5.15&lt;/a&gt; | | 500 | Внутренняя ошибка сервера | &lt;a href=&quot;#section-6.6.1&quot;&gt;Раздел 6.6.1&lt;/a&gt; | | 501 | Не реализовано | &lt;a href=&quot;#section-6.6.2&quot;&gt;Раздел 6.6.2&lt;/a&gt; | | 502 | Плохой шлюз | &lt;a href=&quot;#section-6.6.3&quot;&gt;Раздел 6.6.3&lt;/a&gt; | | 503 | Служба недоступна | &lt;a href=&quot;#section-6.6.4&quot;&gt;Раздел 6.6.4&lt;/a&gt; | | 504 | Тайм-аут шлюза | &lt;a href=&quot;#section-6.6.5&quot;&gt;Раздел 6.6.5&lt;/a&gt; | | 505 | Версия HTTP не поддерживается | &lt;a href=&quot;#section-6.6.6&quot;&gt;Раздел 6.6.6&lt;/a&gt; | + ------- + ------------------------------- + --------- ------- +</target>
        </trans-unit>
        <trans-unit id="ed1c1d835f4a51029a15ccecbb039e7a11e9bd7a" translate="yes" xml:space="preserve">
          <source>The status codes listed below are defined in this specification,
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7232]&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7233]&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3&quot;&gt;Section&amp;nbsp;3 of
   [RFC7235]&lt;/a&gt;.  The reason phrases listed here are only recommendations
   -- they can be replaced by local equivalents without affecting the
   protocol.

   Responses with status codes that are defined as cacheable by default
   (e.g., 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501 in
   this specification) can be reused by a cache with heuristic
   expiration unless otherwise indicated by the method definition or
   explicit cache controls [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]; all other status codes are not
   cacheable by default. 

   +------+-------------------------------+--------------------------+
   | Code | Reason-Phrase                 | Defined in...            |
   +------+-------------------------------+--------------------------+
   | 100  | Continue                      | &lt;a href=&quot;#section-6.2.1&quot;&gt;Section 6.2.1&lt;/a&gt;            |
   | 101  | Switching Protocols           | &lt;a href=&quot;#section-6.2.2&quot;&gt;Section 6.2.2&lt;/a&gt;            |
   | 200  | OK                            | &lt;a href=&quot;#section-6.3.1&quot;&gt;Section 6.3.1&lt;/a&gt;            |
   | 201  | Created                       | &lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;            |
   | 202  | Accepted                      | &lt;a href=&quot;#section-6.3.3&quot;&gt;Section 6.3.3&lt;/a&gt;            |
   | 203  | Non-Authoritative Information | &lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;            |
   | 204  | No Content                    | &lt;a href=&quot;#section-6.3.5&quot;&gt;Section 6.3.5&lt;/a&gt;            |
   | 205  | Reset Content                 | &lt;a href=&quot;#section-6.3.6&quot;&gt;Section 6.3.6&lt;/a&gt;            |
   | 206  | Partial Content               | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7233]&lt;/a&gt; |
   | 300  | Multiple Choices              | &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;            |
   | 301  | Moved Permanently             | &lt;a href=&quot;#section-6.4.2&quot;&gt;Section 6.4.2&lt;/a&gt;            |
   | 302  | Found                         | &lt;a href=&quot;#section-6.4.3&quot;&gt;Section 6.4.3&lt;/a&gt;            |
   | 303  | See Other                     | &lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;            |
   | 304  | Not Modified                  | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7232]&lt;/a&gt; |
   | 305  | Use Proxy                     | &lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;            |
   | 307  | Temporary Redirect            | &lt;a href=&quot;#section-6.4.7&quot;&gt;Section 6.4.7&lt;/a&gt;            |
   | 400  | Bad Request                   | &lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;            |
   | 401  | Unauthorized                  | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC7235]&lt;/a&gt; |
   | 402  | Payment Required              | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;            |
   | 403  | Forbidden                     | &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt;            |
   | 404  | Not Found                     | &lt;a href=&quot;#section-6.5.4&quot;&gt;Section 6.5.4&lt;/a&gt;            |
   | 405  | Method Not Allowed            | &lt;a href=&quot;#section-6.5.5&quot;&gt;Section 6.5.5&lt;/a&gt;            |
   | 406  | Not Acceptable                | &lt;a href=&quot;#section-6.5.6&quot;&gt;Section 6.5.6&lt;/a&gt;            |
   | 407  | Proxy Authentication Required | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7235]&lt;/a&gt; |
   | 408  | Request Timeout               | &lt;a href=&quot;#section-6.5.7&quot;&gt;Section 6.5.7&lt;/a&gt;            |
   | 409  | Conflict                      | &lt;a href=&quot;#section-6.5.8&quot;&gt;Section 6.5.8&lt;/a&gt;            |
   | 410  | Gone                          | &lt;a href=&quot;#section-6.5.9&quot;&gt;Section 6.5.9&lt;/a&gt;            |
   | 411  | Length Required               | &lt;a href=&quot;#section-6.5.10&quot;&gt;Section 6.5.10&lt;/a&gt;           |
   | 412  | Precondition Failed           | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7232]&lt;/a&gt; |
   | 413  | Payload Too Large             | &lt;a href=&quot;#section-6.5.11&quot;&gt;Section 6.5.11&lt;/a&gt;           |
   | 414  | URI Too Long                  | &lt;a href=&quot;#section-6.5.12&quot;&gt;Section 6.5.12&lt;/a&gt;           |
   | 415  | Unsupported Media Type        | &lt;a href=&quot;#section-6.5.13&quot;&gt;Section 6.5.13&lt;/a&gt;           |
   | 416  | Range Not Satisfiable         | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7233]&lt;/a&gt; |
   | 417  | Expectation Failed            | &lt;a href=&quot;#section-6.5.14&quot;&gt;Section 6.5.14&lt;/a&gt;           |
   | 426  | Upgrade Required              | &lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt;           |
   | 500  | Internal Server Error         | &lt;a href=&quot;#section-6.6.1&quot;&gt;Section 6.6.1&lt;/a&gt;            |
   | 501  | Not Implemented               | &lt;a href=&quot;#section-6.6.2&quot;&gt;Section 6.6.2&lt;/a&gt;            |
   | 502  | Bad Gateway                   | &lt;a href=&quot;#section-6.6.3&quot;&gt;Section 6.6.3&lt;/a&gt;            |
   | 503  | Service Unavailable           | &lt;a href=&quot;#section-6.6.4&quot;&gt;Section 6.6.4&lt;/a&gt;            |
   | 504  | Gateway Timeout               | &lt;a href=&quot;#section-6.6.5&quot;&gt;Section 6.6.5&lt;/a&gt;            |
   | 505  | HTTP Version Not Supported    | &lt;a href=&quot;#section-6.6.6&quot;&gt;Section 6.6.6&lt;/a&gt;            |
   +------+-------------------------------+--------------------------+ 

   Note that this list is not exhaustive -- it does not include
   extension status codes defined in other specifications.  The complete
   list of status codes is maintained by IANA.  See &lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt; for
   details.</source>
          <target state="translated">Перечисленные ниже коды состояния определены в этой спецификации, в &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4&quot;&gt;разделе 4 [RFC7232]&lt;/a&gt; , в &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4&quot;&gt;разделе 4 [RFC7233]&lt;/a&gt; и в &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3&quot;&gt;разделе 3 [RFC7235]&lt;/a&gt; . Приведенные здесь фразы причин являются только рекомендациями - их можно заменить местными эквивалентами, не влияя на протокол. Ответы с кодами состояния, которые определены как кэшируемые по умолчанию (например, 200, 203, 204, 206, 300, 301, 404, 405, 410, 414 и 501 в этой спецификации) могут быть повторно использованы кешем с эвристическим истечением срока действия, если только иначе указывается в определении метода или явных элементах управления кешем [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]; все остальные коды состояния по умолчанию не кэшируются. + ------ + ------------------------------- + ---------- ---------------- + | Код | Причина-фраза | Определено в ... | + ------ + ------------------------------- + ---------- ---------------- + | 100 | Продолжить | &lt;a href=&quot;#section-6.2.1&quot;&gt;Раздел 6.2.1&lt;/a&gt; | | 101 | Протоколы переключения | &lt;a href=&quot;#section-6.2.2&quot;&gt;Раздел 6.2.2&lt;/a&gt; | | 200 | ОК | &lt;a href=&quot;#section-6.3.1&quot;&gt;Раздел 6.3.1&lt;/a&gt; | | 201 | Создано | &lt;a href=&quot;#section-6.3.2&quot;&gt;Раздел 6.3.2&lt;/a&gt; | | 202 | Принято | &lt;a href=&quot;#section-6.3.3&quot;&gt;Раздел 6.3.3&lt;/a&gt; | | 203 | Неавторитетная информация | &lt;a href=&quot;#section-6.3.4&quot;&gt;Раздел 6.3.4&lt;/a&gt; | | 204 | Нет содержимого | &lt;a href=&quot;#section-6.3.5&quot;&gt;Раздел 6.3.5&lt;/a&gt; | | 205 | Сбросить содержимое | &lt;a href=&quot;#section-6.3.6&quot;&gt;Раздел 6.3.6&lt;/a&gt; | | 206 | Частичное содержание | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.1&quot;&gt;Раздел 4.1 [RFC7233]&lt;/a&gt; | | 300 | Множественный выбор | &lt;a href=&quot;#section-6.4.1&quot;&gt;Раздел 6.4.1&lt;/a&gt; | | 301 | Переехал навсегда | &lt;a href=&quot;#section-6.4.2&quot;&gt;Раздел 6.4.2&lt;/a&gt; | | 302 | Найдено | &lt;a href=&quot;#section-6.4.3&quot;&gt;Раздел 6.4.3&lt;/a&gt; | | 303 | См. Другое | &lt;a href=&quot;#section-6.4.4&quot;&gt;Раздел 6.4.4&lt;/a&gt; | | 304 | Не изменено | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Раздел 4.1 [RFC7232]&lt;/a&gt; | | 305 | Использовать прокси |&lt;a href=&quot;#section-6.4.5&quot;&gt;Раздел 6.4.5&lt;/a&gt; | | 307 | Временное перенаправление | &lt;a href=&quot;#section-6.4.7&quot;&gt;Раздел 6.4.7&lt;/a&gt; | | 400 | Плохой запрос | &lt;a href=&quot;#section-6.5.1&quot;&gt;Раздел 6.5.1&lt;/a&gt; | | 401 | Несанкционированный | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.1&quot;&gt;Раздел 3.1 [RFC7235]&lt;/a&gt; | | 402 | Требуется оплата | &lt;a href=&quot;#section-6.5.2&quot;&gt;Раздел 6.5.2&lt;/a&gt; | | 403 | Запрещено | &lt;a href=&quot;#section-6.5.3&quot;&gt;Раздел 6.5.3&lt;/a&gt; | | 404 | Не найдено | &lt;a href=&quot;#section-6.5.4&quot;&gt;Раздел 6.5.4&lt;/a&gt; | | 405 | Метод не разрешен | &lt;a href=&quot;#section-6.5.5&quot;&gt;Раздел 6.5.5&lt;/a&gt; | | 406 | Неприемлемо | &lt;a href=&quot;#section-6.5.6&quot;&gt;Раздел 6.5.6&lt;/a&gt; | | 407 | Требуется проверка подлинности прокси | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.2&quot;&gt;Раздел 3.2 [RFC7235]&lt;/a&gt; | | 408 | Тайм-аут запроса | &lt;a href=&quot;#section-6.5.7&quot;&gt;Раздел 6.5.7&lt;/a&gt; | | 409 | Конфликт | &lt;a href=&quot;#section-6.5.8&quot;&gt;Раздел 6.5.8&lt;/a&gt; | | 410 | Ушел | &lt;a href=&quot;#section-6.5.9&quot;&gt;Раздел 6.5.9&lt;/a&gt; | | 411 | Требуемая длина | &lt;a href=&quot;#section-6.5.10&quot;&gt;Раздел 6.5.10&lt;/a&gt; | | 412 | Предварительное условие не выполнено | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.2&quot;&gt;Раздел 4.2 [RFC7232]&lt;/a&gt; | | 413 | Слишком большая полезная нагрузка | &lt;a href=&quot;#section-6.5.11&quot;&gt;Раздел 6.5.11&lt;/a&gt; | | 414 | URI слишком длинный | &lt;a href=&quot;#section-6.5.12&quot;&gt;Раздел 6.5.12&lt;/a&gt; | | 415 | Неподдерживаемый тип носителя |&lt;a href=&quot;#section-6.5.13&quot;&gt;Раздел 6.5.13&lt;/a&gt; | | 416 | Неудовлетворительный диапазон | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.4&quot;&gt;Раздел 4.4 [RFC7233]&lt;/a&gt; | | 417 | Ожидания не оправдались | &lt;a href=&quot;#section-6.5.14&quot;&gt;Раздел 6.5.14&lt;/a&gt; | | 426 | Требуется обновление | &lt;a href=&quot;#section-6.5.15&quot;&gt;Раздел 6.5.15&lt;/a&gt; | | 500 | Внутренняя ошибка сервера | &lt;a href=&quot;#section-6.6.1&quot;&gt;Раздел 6.6.1&lt;/a&gt; | | 501 | Не реализовано | &lt;a href=&quot;#section-6.6.2&quot;&gt;Раздел 6.6.2&lt;/a&gt; | | 502 | Плохой шлюз | &lt;a href=&quot;#section-6.6.3&quot;&gt;Раздел 6.6.3&lt;/a&gt; | | 503 | Служба недоступна | &lt;a href=&quot;#section-6.6.4&quot;&gt;Раздел 6.6.4&lt;/a&gt; | | 504 | Тайм-аут шлюза | &lt;a href=&quot;#section-6.6.5&quot;&gt;Раздел 6.6.5&lt;/a&gt; | | 505 | Версия HTTP не поддерживается | &lt;a href=&quot;#section-6.6.6&quot;&gt;Раздел 6.6.6&lt;/a&gt; | + ------ + ------------------------------- + ---------- ---------------- + Обратите внимание, что этот список не является исчерпывающим - он не включает коды состояния добавочных номеров, определенные в других спецификациях. Полный список кодов состояния поддерживается IANA. См &lt;a href=&quot;#section-8.2&quot;&gt;раздел 8.2&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="abe4655086702c287f500adc1ea133906ee1151a" translate="yes" xml:space="preserve">
          <source>The status-code element is a three-digit integer code giving the
   result of the attempt to understand and satisfy the request.

   HTTP status codes are extensible.  HTTP clients are not required to
   understand the meaning of all registered status codes, though such
   understanding is obviously desirable.  However, a client MUST
   understand the class of any status code, as indicated by the first
   digit, and treat an unrecognized status code as being equivalent to
   the x00 status code of that class, with the exception that a
   recipient MUST NOT cache a response with an unrecognized status code.

   For example, if an unrecognized status code of 471 is received by a
   client, the client can assume that there was something wrong with its
   request and treat the response as if it had received a 400 (Bad
   Request) status code.  The response message will usually contain a
   representation that explains the status.

   The first digit of the status-code defines the class of response.
   The last two digits do not have any categorization role.  There are
   five values for the first digit:

   o  1xx (Informational): The request was received, continuing process

   o  2xx (Successful): The request was successfully received,
      understood, and accepted

   o  3xx (Redirection): Further action needs to be taken in order to
      complete the request

   o  4xx (Client Error): The request contains bad syntax or cannot be
      fulfilled 

   o  5xx (Server Error): The server failed to fulfill an apparently
      valid request</source>
          <target state="translated">Элемент status-code представляет собой трехзначный целочисленный код,дающий результат попытки понять и удовлетворить запрос.Коды статуса HTTP являются расширяемыми.HTTP-клиенты не обязаны понимать смысл всех зарегистрированных кодов статуса,хотя такое понимание очевидно желательно.Тем не менее,клиент ДОЛЖЕН понимать класс любого кода статуса,как указано первой цифрой,и относиться к непризнанному коду статуса как к эквиваленту кода статуса x00 этого класса,за исключением того,что получатель ДОЛЖЕН НЕ кэшировать ответ с непризнанным кодом статуса.Например,если непризнанный код статуса 471 получен клиентом,клиент может предположить,что с его запросом что-то не так,и рассматривать ответ,как если бы он получил код статуса 400 (Плохой запрос).Ответное сообщение обычно будет содержать представление,объясняющее статус.Первая цифра кода статуса определяет класс ответа.Последние две цифры не имеют никакой роли категоризации.Первая цифра имеет пять значений:o 1xx (Информационное):Запрос получен,продолжающийся процесс o 2xx (Успешный):Запрос был успешно получен,понят и принят o 3xx (Переадресация):Для завершения запроса необходимо предпринять дальнейшие действия o 4xx (Ошибка клиента):Запрос содержит неверный синтаксис или не может быть выполнен o 5xx (Ошибка сервера):Запрос содержит неверный синтаксис или не может быть выполнен o 5xx (Ошибка сервера):Запрос был успешно получен,понят и принят o 3xx (Переадресация):Необходимо предпринять дальнейшие действия,чтобы завершить запрос o 4xx (Ошибка клиента):Запрос содержит неверный синтаксис или не может быть выполнен o 5xx (Ошибка сервера):Запрос содержит неверный синтаксис или не может быть выполнен o 5xx (Ошибка сервера):Запрос должен быть выполнен o 4xx (Ошибка клиента):Запрос содержит неверный синтаксис или не может быть выполнен o 5xx (Ошибка сервера):Запрос должен быть выполнен:Сервер не смог выполнить явно действительный запрос</target>
        </trans-unit>
        <trans-unit id="ea09a27e31ad55afff5e7a2614ea2f6ce9a594b2" translate="yes" xml:space="preserve">
          <source>The string can contain any number of the following building blocks, separated by a semicolon:</source>
          <target state="translated">Строка может содержать любое количество следующих строительных блоков,разделенных точкой с запятой:</target>
        </trans-unit>
        <trans-unit id="ad6aeb189468d6962df260c9530bf2336ac50aef" translate="yes" xml:space="preserve">
          <source>The successful result of a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; is often not a &lt;code&gt;200&lt;/code&gt;&lt;code&gt;OK&lt;/code&gt; but a &lt;a href=&quot;204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;&lt;code&gt;No Content&lt;/code&gt; (or a &lt;a href=&quot;201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; when the resource is uploaded for the first time).</source>
          <target state="translated">Успешным результатом &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; часто является не &lt;code&gt;200&lt;/code&gt; &lt;code&gt;OK&lt;/code&gt; , а &lt;a href=&quot;204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt; &lt;code&gt;No Content&lt;/code&gt; (или &lt;a href=&quot;201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Created&lt;/code&gt; , когда ресурс загружается в первый раз).</target>
        </trans-unit>
        <trans-unit id="b7a73c4b6342735091b4f2e7334e43ba0cdd039a" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;Server-Timing&lt;/code&gt; header allows you to communicate metrics in different ways: server metric name only, metric with value, metric with value and description, and metric with description.</source>
          <target state="translated">Синтаксис заголовка &lt;code&gt;Server-Timing&lt;/code&gt; позволяет передавать метрики по-разному: только имя метрики сервера, метрика со значением, метрика со значением и описанием и метрика с описанием.</target>
        </trans-unit>
        <trans-unit id="9d244dc96c1e69e051bc4e338a9553169a494af1" translate="yes" xml:space="preserve">
          <source>The syntax of the Slug header is defined using the augmented BNF
   syntax defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC2616]&lt;/a&gt;:

       LWS      = &amp;lt;defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;Section&amp;nbsp;2.2 of [RFC2616]&lt;/a&gt;&amp;gt;
       slugtext = %x20-7E | LWS
       Slug     = &quot;Slug&quot; &quot;:&quot; *slugtext

   The field value is the percent-encoded value of the UTF-8 encoding of
   the character sequence to be included (see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC3986]&lt;/a&gt;
   for the definition of percent encoding, and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt;] for the
   definition of the UTF-8 encoding).

   Implementation note: to produce the field value from a character
   sequence, first encode it using the UTF-8 encoding, then encode all
   octets outside the ranges %20-24 and %26-7E using percent encoding
   (%25 is the ASCII encoding of &quot;%&quot;, thus it needs to be escaped).  To
   consume the field value, first reverse the percent encoding, then run
   the resulting octet sequence through a UTF-8 decoding process.</source>
          <target state="translated">Синтаксис заголовка Slug определяется с использованием расширенного синтаксиса BNF, определенного в &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;разделе 2.1 [RFC2616]&lt;/a&gt; : LWS = &amp;lt;определенный в &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;разделе 2.2 [&lt;/a&gt; RFC2616 ] &amp;gt; slugtext =% x20-7E | LWS Slug = &quot;Slug&quot; &quot;:&quot; * slugtext Значение поля представляет собой закодированное в процентах значение кодировки UTF-8 для включаемой последовательности символов ( определение процентного кодирования см. В &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.1&quot;&gt;разделе 2.1 [RFC3986]&lt;/a&gt; , а также [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt;] для определения кодировки UTF-8). Примечание по реализации: чтобы получить значение поля из последовательности символов, сначала закодируйте его, используя кодировку UTF-8, затем закодируйте все октеты за пределами диапазонов% 20-24 и% 26-7E, используя процентное кодирование (% 25 - это кодировка ASCII для &quot;%&quot;, поэтому его нужно экранировать). Чтобы использовать значение поля, сначала измените процентное кодирование, а затем запустите полученную последовательность октетов в процессе декодирования UTF-8.</target>
        </trans-unit>
        <trans-unit id="ea12de6efa63fc587d1f14a9b9c6eb9b2ffc6913" translate="yes" xml:space="preserve">
          <source>The table below describes the behavior that occurs when a lock
   request is made on a resource.

     +--------------------------+----------------+-------------------+
     | Current State            | Shared Lock OK | Exclusive Lock OK |
     +--------------------------+----------------+-------------------+
     | None                     | True           | True              |
     | Shared Lock              | True           | False             |
     | Exclusive Lock           | False          | False*            |
     +--------------------------+----------------+-------------------+

   Legend: True = lock may be granted.  False = lock MUST NOT be
   granted. *=It is illegal for a principal to request the same lock
   twice.

   The current lock state of a resource is given in the leftmost column,
   and lock requests are listed in the first row.  The intersection of a
   row and column gives the result of a lock request.  For example, if a
   shared lock is held on a resource, and an exclusive lock is
   requested, the table entry is &quot;false&quot;, indicating that the lock must
   not be granted.</source>
          <target state="translated">В таблице ниже описано поведение,которое происходит при запросе блокировки на ресурсе.+-----------------------------------------------------------------+| Текущее состояние | Общий замок OK | Эксклюзивный замок OK | +---------------------------------------------------------------------------+| Нет | Правда | Правда | | Общий замок | Правда | Ложь | | Эксклюзивный замок | Ложь | Ложь*| +--------------------------------------------------------------------------------------------------------------------------------------------------------------Легенда:True=замок может быть предоставлен.Фальшивка=блокировка НЕ ДОЛЖНА быть предоставлена.*=Незаконно,чтобы директор дважды запросил один и тот же замок.Текущее состояние блокировки ресурса указано в самом левом столбце,а запросы блокировки перечислены в первой строке.Пересечение строки и столбца дает результат запроса на блокировку.Например,если общий замок удерживается на ресурсе,и запрашивается исключительный замок,запись в таблице является &quot;ложной&quot;,что указывает на то,что замок не должен быть разрешен.</target>
        </trans-unit>
        <trans-unit id="b94957031bbb851c3915a1e070dc41a5bc6b1c5f" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;, which nature isn't defined further; it can be a document, a photo, or anything else. Each resource is identified by a Uniform Resource Identifier (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;) used throughout HTTP for identifying resources.</source>
          <target state="translated">Цель HTTP-запроса называется &amp;laquo;ресурсом&amp;raquo;, природа которого далее не определяется; это может быть документ, фотография или что-нибудь еще. Каждый ресурс идентифицируется унифицированным идентификатором &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;ресурса&lt;/a&gt; ( URI ), используемым в HTTP для идентификации ресурсов.</target>
        </trans-unit>
        <trans-unit id="0027de0398e06b3c16ab5881af95789a5ccae8db" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;.  HTTP does not
   limit the nature of a resource; it merely defines an interface that
   might be used to interact with resources.  Each resource is
   identified by a Uniform Resource Identifier (URI), as described in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;Section&amp;nbsp;2.7 of [RFC7230]&lt;/a&gt;.

   When a client constructs an HTTP/1.1 request message, it sends the
   target URI in one of various forms, as defined in (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of
   [RFC7230]&lt;/a&gt;).  When a request is received, the server reconstructs an
   effective request URI for the target resource (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of
   [RFC7230]&lt;/a&gt;).

   One design goal of HTTP is to separate resource identification from
   request semantics, which is made possible by vesting the request
   semantics in the request method (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) and a few
   request-modifying header fields (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  If there is a conflict
   between the method semantics and any semantic implied by the URI
   itself, as described in &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;, the method semantics take
   precedence.</source>
          <target state="translated">Цель HTTP-запроса называется &amp;laquo;ресурсом&amp;raquo;. HTTP не ограничивает природу ресурса; он просто определяет интерфейс, который может использоваться для взаимодействия с ресурсами. Каждый ресурс идентифицируется унифицированным идентификатором ресурса (URI), как описано в &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;разделе 2.7 [RFC7230]&lt;/a&gt; . Когда клиент создает сообщение запроса HTTP / 1.1, он отправляет целевой URI в одной из различных форм, как определено в ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Раздел 5.3 [RFC7230]&lt;/a&gt; ). Когда запрос получен, сервер восстанавливает действующий URI запроса для целевого ресурса ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;раздел 5.5 [RFC7230]&lt;/a&gt; ). Одна из целей разработки HTTP - отделить идентификацию ресурса от семантики запроса, что стало возможным благодаря вложению семантики запроса в метод запроса (&lt;a href=&quot;#section-4&quot;&gt;Раздел 4&lt;/a&gt; ) и несколько полей заголовка, изменяющих запрос ( &lt;a href=&quot;#section-5&quot;&gt;Раздел 5&lt;/a&gt; ). Если существует конфликт между семантикой метода и любой семантикой, подразумеваемой самим URI, как описано в &lt;a href=&quot;#section-4.2.1&quot;&gt;Разделе 4.2.1&lt;/a&gt; , семантика метода имеет приоритет.</target>
        </trans-unit>
        <trans-unit id="9418d48752326ff0dff5f0989dac32b59078dac8" translate="yes" xml:space="preserve">
          <source>The text of the error message will be something similar to the following:</source>
          <target state="translated">Текст сообщения об ошибке будет похож на следующий:</target>
        </trans-unit>
        <trans-unit id="19c4cdcadd110283f71f254a20c3b6bdf9d892cf" translate="yes" xml:space="preserve">
          <source>The time in seconds the object has been in a proxy cache.</source>
          <target state="translated">Время в секундах,в течение которого объект находился в прокси-кэше.</target>
        </trans-unit>
        <trans-unit id="b56b41274f5f4a39f688c4966d1da21de98a88bd" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the browser should remember that a site is only to be accessed using HTTPS.</source>
          <target state="translated">Время в секундах,которое браузер должен помнить,что доступ к сайту возможен только через HTTPS.</target>
        </trans-unit>
        <trans-unit id="1ab5a5f12646b8f33cf1a6e834273c9a7926c03d" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the browser should remember that this site is only to be accessed using one of the defined keys.</source>
          <target state="translated">Время в секундах,что браузер должен помнить,что к этому сайту можно получить доступ только с помощью одного из определенных ключей.</target>
        </trans-unit>
        <trans-unit id="42e4cd11bd5edf3670dcbf4e3f786a4428a217a9" translate="yes" xml:space="preserve">
          <source>The total size of the document (or &lt;code&gt;'*'&lt;/code&gt; if unknown).</source>
          <target state="translated">Общий размер документа (или &lt;code&gt;'*'&lt;/code&gt; если неизвестно).</target>
        </trans-unit>
        <trans-unit id="f6969607248ffc4491cc44dae24cf7138a7b4be2" translate="yes" xml:space="preserve">
          <source>The transfer-length of a message is the length of the message-body as
   it appears in the message; that is, after any transfer-codings have
   been applied. When a message-body is included with a message, the
   transfer-length of that body is determined by one of the following
   (in order of precedence):

   1.Any response message which &quot;MUST NOT&quot; include a message-body (such
     as the 1xx, 204, and 304 responses and any response to a HEAD
     request) is always terminated by the first empty line after the
     header fields, regardless of the entity-header fields present in
     the message.

   2.If a Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section 14.41&lt;/a&gt;) is present and
     has any value other than &quot;identity&quot;, then the transfer-length is
     defined by use of the &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;),
     unless the message is terminated by closing the connection.

   3.If a Content-Length header field (&lt;a href=&quot;#section-14.13&quot;&gt;section 14.13&lt;/a&gt;) is present, its
     decimal value in OCTETs represents both the entity-length and the
     transfer-length. The Content-Length header field MUST NOT be sent
     if these two lengths are different (i.e., if a Transfer-Encoding 

     header field is present). If a message is received with both a
     Transfer-Encoding header field and a Content-Length header field,
     the latter MUST be ignored.

   4.If the message uses the media type &quot;multipart/byteranges&quot;, and the
     ransfer-length is not otherwise specified, then this self-
     elimiting media type defines the transfer-length. This media type
     UST NOT be used unless the sender knows that the recipient can arse
     it; the presence in a request of a Range header with ultiple byte-
     range specifiers from a 1.1 client implies that the lient can parse
     multipart/byteranges responses.

       A range header might be forwarded by a 1.0 proxy that does not
       understand multipart/byteranges; in this case the server MUST
       delimit the message using methods defined in items 1,3 or 5 of
       this section.

   5.By the server closing the connection. (Closing the connection
     cannot be used to indicate the end of a request body, since that
     would leave no possibility for the server to send back a response.)

   For compatibility with HTTP/1.0 applications, HTTP/1.1 requests
   containing a message-body MUST include a valid Content-Length header
   field unless the server is known to be HTTP/1.1 compliant. If a
   request contains a message-body and a Content-Length is not given,
   the server SHOULD respond with 400 (bad request) if it cannot
   determine the length of the message, or with 411 (length required) if
   it wishes to insist on receiving a valid Content-Length.

   All HTTP/1.1 applications that receive entities MUST accept the
   &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;), thus allowing this mechanism
   to be used for messages when the message length cannot be determined
   in advance.

   Messages MUST NOT include both a Content-Length header field and a
   non-identity transfer-coding. If the message does include a non-
   identity transfer-coding, the Content-Length MUST be ignored.

   When a Content-Length is given in a message where a message-body is
   allowed, its field value MUST exactly match the number of OCTETs in
   the message-body. HTTP/1.1 user agents MUST notify the user when an
   invalid length is received and detected.</source>
          <target state="translated">Длина передачи сообщения - это длина тела сообщения в том виде, в котором оно отображается в сообщении; то есть после применения любых кодировок передачи. Когда тело сообщения включается в сообщение, длина передачи этого тела определяется одним из следующих (в порядке приоритета): 1. Любое ответное сообщение, которое &amp;laquo;НЕ ДОЛЖНО&amp;raquo; включать тело сообщения (например, ответы 1xx, 204 и 304 и любой ответ на запрос HEAD) всегда заканчиваются первой пустой строкой после полей заголовка, независимо от полей заголовка объекта, присутствующих в сообщении. 2. Если поле заголовка Transfer-Encoding ( &lt;a href=&quot;#section-14.41&quot;&gt;раздел 14.41&lt;/a&gt; ) присутствует и имеет любое значение, отличное от &amp;laquo;identity&amp;raquo;, то длина передачи определяется с использованием &amp;laquo;chunked&amp;raquo;трансфер-кодирование (&lt;a href=&quot;#section-3.6&quot;&gt;раздел 3.6&lt;/a&gt; ), если сообщение не прерывается закрытием соединения. 3.Если поле заголовка Content-Length ( &lt;a href=&quot;#section-14.13&quot;&gt;раздел 14.13&lt;/a&gt;) присутствует, его десятичное значение в OCTET представляет как длину объекта, так и длину передачи. Поле заголовка Content-Length НЕ ДОЛЖНО отправляться, если эти две длины различаются (т. Е. Если присутствует поле заголовка Transfer-Encoding). Если сообщение получено как с полем заголовка Transfer-Encoding, так и с полем заголовка Content-Length, последнее ДОЛЖНО игнорироваться. 4. Если в сообщении используется тип мультимедиа &amp;laquo;multipart / byteranges&amp;raquo;, а длина передачи не указана иначе, то этот самоограничивающийся тип мультимедиа определяет длину передачи. Этот тип носителя UST НЕ может использоваться, если отправитель не знает, что получатель может это принять; наличие в запросе заголовка Range со спецификаторами диапазона байтов от 1.1 клиент подразумевает, что клиент может анализировать ответы multipart / byteranges. Заголовок диапазона может быть перенаправлен прокси 1.0, который не понимает multipart / byteranges; в этом случае сервер ДОЛЖЕН разграничить сообщение, используя методы, определенные в пунктах 1,3 или 5 этого раздела. 5. При закрытии соединения сервером. (Закрытие соединения не может использоваться для указания конца тела запроса, поскольку это не оставит возможности для сервера отправить ответ.) Для совместимости с приложениями HTTP / 1.0 запросы HTTP / 1.1, содержащие тело сообщения, ДОЛЖНЫ включить допустимое поле заголовка Content-Length, если сервер не соответствует требованиям HTTP / 1.1. Если запрос содержит тело сообщения, а Content-Length не указан,серверу СЛЕДУЕТ ответить 400 (неверный запрос), если он не может определить длину сообщения, или 411 (требуется длина), если он хочет настоять на получении допустимой Content-Length. Все приложения HTTP / 1.1, которые получают объекты, ДОЛЖНЫ принимать &quot;фрагментированное&quot; кодирование передачи (&lt;a href=&quot;#section-3.6&quot;&gt;раздел 3.6&lt;/a&gt; ), что позволяет использовать этот механизм для сообщений, когда длину сообщения невозможно определить заранее. Сообщения НЕ ДОЛЖНЫ включать в себя как поле заголовка Content-Length, так и неидентификационное кодирование передачи. Если сообщение действительно включает неидентификационное кодирование передачи, Content-Length ДОЛЖНО игнорироваться. Когда Content-Length задается в сообщении, где разрешено тело сообщения, значение его поля ДОЛЖНО точно соответствовать количеству OCTET в теле сообщения. Пользовательские агенты HTTP / 1.1 ДОЛЖНЫ уведомлять пользователя при получении и обнаружении недопустимой длины.</target>
        </trans-unit>
        <trans-unit id="38523484ffd68ebb6eb7a5214e3ed27961920f11" translate="yes" xml:space="preserve">
          <source>The two URNs correspond to</source>
          <target state="translated">Два URN соответствуют</target>
        </trans-unit>
        <trans-unit id="ff2f97e2406493e9f79fccc71e1be4f7abf32463" translate="yes" xml:space="preserve">
          <source>The unit for ranges are bytes.</source>
          <target state="translated">Единица измерения диапазонов-байты.</target>
        </trans-unit>
        <trans-unit id="b6b0d4dfd9983f94ad3e71c861ccec5e604be4be" translate="yes" xml:space="preserve">
          <source>The unit in which ranges are specified. This is usually &lt;code&gt;bytes&lt;/code&gt;.</source>
          <target state="translated">Единица измерения, в которой указаны диапазоны. Обычно это &lt;code&gt;bytes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="924b5ee64285daafc6521cbe0d29ade1c8958494" translate="yes" xml:space="preserve">
          <source>The user has sent too many requests in a given amount of time (&quot;rate limiting&quot;).</source>
          <target state="translated">За заданное время пользователь отправил слишком много запросов (&quot;ограничение скорости&quot;).</target>
        </trans-unit>
        <trans-unit id="9ffdd05f199fbe940ba584fa8cdea1148a035d9b" translate="yes" xml:space="preserve">
          <source>The user prefers not to be tracked on the target site.</source>
          <target state="translated">Пользователь предпочитает,чтобы его не отслеживали на целевом сайте.</target>
        </trans-unit>
        <trans-unit id="d71574f65fb3da08e3baf6b4a99a03c89f5a3b91" translate="yes" xml:space="preserve">
          <source>The user prefers to allow tracking on the target site.</source>
          <target state="translated">Пользователь предпочитает разрешить отслеживание на целевом сайте.</target>
        </trans-unit>
        <trans-unit id="91276b37149e1af5a39e9acf956fda9d8e55baac" translate="yes" xml:space="preserve">
          <source>The user requests an illegal resource, such as a web page censored by a government.</source>
          <target state="translated">Пользователь запрашивает незаконный ресурс,такой как веб-страница,цензурируемая правительством.</target>
        </trans-unit>
        <trans-unit id="9b9325341a547bb5d13f713ae99d4c608b9f2504" translate="yes" xml:space="preserve">
          <source>The user's DNT preference can also be read from JavaScript using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/doNotTrack&quot;&gt;&lt;code&gt;Navigator.doNotTrack&lt;/code&gt;&lt;/a&gt; property:</source>
          <target state="translated">Предпочтения пользователя DNT также можно прочитать из JavaScript с помощью свойства &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/doNotTrack&quot;&gt; &lt;code&gt;Navigator.doNotTrack&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2e6eca9e7b97463080612be2b9d7493bcb1e1c94" translate="yes" xml:space="preserve">
          <source>The username and the password are combined with a colon (&lt;code&gt;aladdin:opensesame&lt;/code&gt;).</source>
          <target state="translated">Имя пользователя и пароль объединяются двоеточием ( &lt;code&gt;aladdin:opensesame&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e7e7dde22649be5d5f9982b5b058ad7e12b419de" translate="yes" xml:space="preserve">
          <source>The value of a property is always a (well-formed) XML fragment.

   XML has been chosen because it is a flexible, self-describing,
   structured data format that supports rich schema definitions, and
   because of its support for multiple character sets.  XML's self-
   describing nature allows any property's value to be extended by
   adding elements.  Clients will not break when they encounter
   extensions because they will still have the data specified in the
   original schema and MUST ignore elements they do not understand. 

   XML's support for multiple character sets allows any human-readable
   property to be encoded and read in a character set familiar to the
   user.  XML's support for multiple human languages, using the &quot;xml:
   lang&quot; attribute, handles cases where the same character set is
   employed by multiple human languages.  Note that xml:lang scope is
   recursive, so an xml:lang attribute on any element containing a
   property name element applies to the property value unless it has
   been overridden by a more locally scoped attribute.  Note that a
   property only has one value, in one language (or language MAY be left
   undefined); a property does not have multiple values in different
   languages or a single value in multiple languages.

   A property is always represented with an XML element consisting of
   the property name, called the &quot;property name element&quot;.  The simplest
   example is an empty property, which is different from a property that
   does not exist:

      &amp;lt;R:title xmlns:R=&quot;http://www.example.com/ns/&quot;&amp;gt;&amp;lt;/R:title&amp;gt;

   The value of the property appears inside the property name element.
   The value may be any kind of well-formed XML content, including both
   text-only and mixed content.  Servers MUST preserve the following XML
   Information Items (using the terminology from [&lt;a href=&quot;#ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt;]) in
   storage and transmission of dead properties:

   For the property name Element Information Item itself:

      [namespace name]

      [local name]

      [&lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;attributes&lt;/a&gt;] named &quot;xml:lang&quot; or any such attribute in scope

      [&lt;a id=&quot;ref-children&quot; name=&quot;ref-children&quot;&gt;children&lt;/a&gt;] of type element or character

   On all Element Information Items in the property value:

      [namespace name]

      [local name]

      [&lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;attributes&lt;/a&gt;]

      [&lt;a href=&quot;#ref-children&quot;&gt;children&lt;/a&gt;] of type element or character 

   On Attribute Information Items in the property value:

      [namespace name]

      [local name]

      [normalized value]

   On Character Information Items in the property value:

      [character code]

   Since prefixes are used in some XML vocabularies (XPath and XML
   Schema, for example), servers SHOULD preserve, for any Information
   Item in the value:

      [&lt;a id=&quot;ref-prefix&quot; name=&quot;ref-prefix&quot;&gt;prefix&lt;/a&gt;]

   XML Infoset attributes not listed above MAY be preserved by the
   server, but clients MUST NOT rely on them being preserved.  The above
   rules would also apply by default to live properties, unless defined
   otherwise.

   Servers MUST ignore the XML attribute xml:space if present and never
   use it to change whitespace handling.  Whitespace in property values
   is significant.</source>
          <target state="translated">Значение свойства всегда является (правильно сформированным) фрагментом XML. XML был выбран потому, что это гибкий, самоописывающийся, структурированный формат данных, который поддерживает расширенные определения схем, а также из-за его поддержки множественных наборов символов. Самоописывающая природа XML позволяет расширять значение любого свойства путем добавления элементов. Клиенты не сломаются, когда встретят расширения, потому что они все еще будут иметь данные, указанные в исходной схеме, и ДОЛЖНЫ игнорировать элементы, которые они не понимают. Поддержка XML для нескольких наборов символов позволяет кодировать и читать любое удобочитаемое свойство в наборе символов, знакомом пользователю. Поддержка XML для нескольких человеческих языков с использованием атрибута &quot;xml: lang&quot;,обрабатывает случаи, когда один и тот же набор символов используется в нескольких человеческих языках. Обратите внимание, что область видимости xml: lang является рекурсивной, поэтому атрибут xml: lang любого элемента, содержащего элемент имени свойства, применяется к значению свойства, если только он не был переопределен атрибутом с более локальной областью действия. Обратите внимание, что свойство имеет только одно значение на одном языке (или язык МОЖЕТ быть оставлен неопределенным); свойство не может иметь несколько значений на разных языках или одно значение на нескольких языках. Свойство всегда представлено элементом XML, состоящим из имени свойства, который называется &amp;laquo;элементом имени свойства&amp;raquo;. Самый простой пример - пустое свойство, которое отличается от несуществующего свойства: &amp;lt;R: title xmlns: R = &quot;http://www.example.com/ns/&quot;&amp;gt; &amp;lt;/ R: title&amp;gt;Значение свойства отображается внутри элемента имени свойства. Значение может быть любым правильно сформированным содержимым XML, включая как текстовое, так и смешанное содержимое. Серверы ДОЛЖНЫ сохранять следующие информационные элементы XML (используя терминологию из [&lt;a href=&quot;#ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt; ]) при хранении и передаче мертвых свойств: для имени свойства. Элемент информации. Сам элемент: [имя пространства имен] [локальное имя] [ &lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;атрибуты&lt;/a&gt; ] с именем &amp;laquo;xml: lang&amp;raquo; или любой такой атрибут в области [ &lt;a id=&quot;ref-children&quot; name=&quot;ref-children&quot;&gt;дочерние&lt;/a&gt; элементы ] типа элемент или символ Во всех информационных элементах элемента в значении свойства: [имя пространства имен] [локальное имя] [ &lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;атрибуты&lt;/a&gt; ] [ &lt;a href=&quot;#ref-children&quot;&gt;дочерние&lt;/a&gt; элементы] элемента типа или символа. Элементы информации об атрибуте в значении свойства: [имя пространства имен] [локальное имя] [нормализованное значение] Элементы информации о символах в значении свойства: [код символа] Поскольку префиксы используются в некоторых словарях XML (XPath и XML-схему, например), серверы ДОЛЖНЫ сохранять для любого информационного элемента в значении: [ &lt;a id=&quot;ref-prefix&quot; name=&quot;ref-prefix&quot;&gt;префикс&lt;/a&gt; ] атрибуты информационного набора XML, не перечисленные выше, МОГУТ быть сохранены сервером, но клиенты НЕ ДОЛЖНЫ полагаться на их сохранение. Вышеупомянутые правила также будут применяться по умолчанию к действующим свойствам, если не указано иное. Серверы ДОЛЖНЫ игнорировать атрибут XML xml: space, если он присутствует, и никогда не использовать его для изменения обработки пробелов. Пробелы в значениях свойств значительны.</target>
        </trans-unit>
        <trans-unit id="fb3e4816a344b23838df3c23c4b5bab0b9342359" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;*&lt;/code&gt; (enable for all origins) or &lt;code&gt;'none'&lt;/code&gt; (disable for all origins) may only be used alone, while &lt;code&gt;'self'&lt;/code&gt; and &lt;code&gt;'src'&lt;/code&gt; may be used with one or more origins.</source>
          <target state="translated">Значения &lt;code&gt;*&lt;/code&gt; (включить для всех источников) или &lt;code&gt;'none'&lt;/code&gt; (отключить для всех источников) можно использовать только по отдельности, в то время как &lt;code&gt;'self'&lt;/code&gt; и &lt;code&gt;'src'&lt;/code&gt; могут использоваться с одним или несколькими источниками.</target>
        </trans-unit>
        <trans-unit id="f91edc1b64b95c9c888baf6cb011efedf5d401fa" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;*&lt;/code&gt; (enable for all origins) or &lt;code&gt;'none'&lt;/code&gt; (disable for all origins) may only be used alone, while &lt;code&gt;'self'&lt;/code&gt; may be used with one or more origins.</source>
          <target state="translated">Значения &lt;code&gt;*&lt;/code&gt; (включить для всех источников) или &lt;code&gt;'none'&lt;/code&gt; (отключить для всех источников) можно использовать только по отдельности, в то время как &lt;code&gt;'self'&lt;/code&gt; можно использовать с одним или несколькими источниками.</target>
        </trans-unit>
        <trans-unit id="dcb79e8e805e8e88b9627449d36415ee11787dcd" translate="yes" xml:space="preserve">
          <source>The version numbers are not relevant. Avoid inferring materials based on these.</source>
          <target state="translated">Номера версий не имеют отношения к делу.Не делайте на их основе выводов.</target>
        </trans-unit>
        <trans-unit id="c896f8683d1b38332492f9add5b7e8036c2af733" translate="yes" xml:space="preserve">
          <source>The version of the HTTP protocol they follow.</source>
          <target state="translated">Версия протокола HTTP,которой они следуют.</target>
        </trans-unit>
        <trans-unit id="af0975667c912879263ed1a3127961e483e13536" translate="yes" xml:space="preserve">
          <source>The version of the HTTP protocol.</source>
          <target state="translated">Версия протокола HTTP.</target>
        </trans-unit>
        <trans-unit id="18e8cb1bbc1cc055f8280b649b640d1c2817543a" translate="yes" xml:space="preserve">
          <source>The version of the protocol used, such as &quot;1.1&quot;.</source>
          <target state="translated">Использованная версия протокола,например &quot;1.1&quot;.</target>
        </trans-unit>
        <trans-unit id="8a2eeda1fd5d692f44f72233f1d8f895ceec9038" translate="yes" xml:space="preserve">
          <source>The warning text can include arbitrary information to be presented to
   a human user or logged.  A system receiving this warning MUST NOT
   take any automated action, besides presenting the warning to the
   user.</source>
          <target state="translated">Текст предупреждения может содержать произвольную информацию,которая должна быть представлена пользователю или зарегистрирована в журнале.Система,получающая это предупреждение,НЕ ДОЛЖНА предпринимать никаких автоматических действий,кроме представления предупреждения пользователю.</target>
        </trans-unit>
        <trans-unit id="15cc2f59f7cbc4d7458f6cc67c3db06644c699c3" translate="yes" xml:space="preserve">
          <source>The warning text can include arbitrary information to be presented to
   a human user or logged.  A system receiving this warning MUST NOT
   take any automated action.</source>
          <target state="translated">Текст предупреждения может содержать произвольную информацию,которая должна быть представлена пользователю или зарегистрирована в журнале.Система,получающая это предупреждение,НЕ ДОЛЖНА предпринимать никаких автоматических действий.</target>
        </trans-unit>
        <trans-unit id="5141799507b06d7b06feb80a1395a0473365c760" translate="yes" xml:space="preserve">
          <source>The web provides functionality and APIs that may have privacy or security risks if abused. In some cases, you may wish to strictly limit how such functionality is used on a website. There are policy-controlled features to allow functionality to be enabled/disabled for specific origins or frames within a website. Where available, the feature integrates with the Permissions API, or feature-specific mechanisms to check if the feature is available.</source>
          <target state="translated">Веб предоставляет функциональные возможности и API,которые в случае злоупотребления ими могут представлять угрозу для конфиденциальности или безопасности.В некоторых случаях вы можете захотеть строго ограничить использование такой функциональности на веб-сайте.Существуют функции,контролируемые политикой,которые позволяют включать/отключать функциональность для определенного происхождения или фреймов внутри веб сайта.Там,где это возможно,функция интегрируется с Permissions API,или специальными механизмами для проверки доступности функции.</target>
        </trans-unit>
        <trans-unit id="7dfe76bf0e6f8f40957fd161579016ac421163fe" translate="yes" xml:space="preserve">
          <source>The wildcard value (*) that is mentioned in the latest specification, is not yet implemented in browsers:</source>
          <target state="translated">Значение подстановочного знака (*),упомянутое в последней спецификации,еще не реализовано в браузерах:</target>
        </trans-unit>
        <trans-unit id="1efbe0911ef1776423c120227469a104642f0bff" translate="yes" xml:space="preserve">
          <source>The&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate&quot;&gt; HTML5 boilerplate project&lt;/a&gt; has an example on &lt;a href=&quot;https://github.com/h5bp/html5-boilerplate/blob/7a22a33d4041c479d0962499e853501073811887/.htaccess#L219-L258&quot;&gt;how to configure an Apache server to redirect one domain to the other&lt;/a&gt;.</source>
          <target state="translated">В &lt;a href=&quot;https://github.com/h5bp/html5-boilerplate&quot;&gt;стандартном проекте HTML5&lt;/a&gt; есть пример &lt;a href=&quot;https://github.com/h5bp/html5-boilerplate/blob/7a22a33d4041c479d0962499e853501073811887/.htaccess#L219-L258&quot;&gt;того, как настроить сервер Apache для перенаправления одного домена на другой&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d8f25ce63c5964fb8abf78f765646524df92d04" translate="yes" xml:space="preserve">
          <source>Then include an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt; attribute on the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">Затем &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;включите&lt;/a&gt; атрибут allow в элемент &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3a105d13d54e1c2eb5dcd554ae6b632346f6c862" translate="yes" xml:space="preserve">
          <source>Then the client could remember that the JSON version is available at that particular URL, skipping content negotation the next time it requests that document.</source>
          <target state="translated">Тогда клиент мог вспомнить,что версия JSON доступна по этому конкретному URL,пропустив отрицание содержимого при следующем запросе этого документа.</target>
        </trans-unit>
        <trans-unit id="c166069763014ce7a3cf04a150e6d98bc4aa9d06" translate="yes" xml:space="preserve">
          <source>Then you need to set up your server to receive the reports; it can store or process them in whatever manner you feel is appropriate.</source>
          <target state="translated">Затем вам нужно настроить ваш сервер на получение отчетов;он может хранить или обрабатывать их любым удобным для вас способом.</target>
        </trans-unit>
        <trans-unit id="19356494f1c284767cfe46395570ff7af7ec9025" translate="yes" xml:space="preserve">
          <source>There are a few header fields which have general applicability for
   both request and response messages, but which do not apply to the
   entity being transferred. These header fields apply only to the 

   message being transmitted.

       general-header = Cache-Control            ; &lt;a href=&quot;#section-14.9&quot;&gt;Section 14.9&lt;/a&gt;
                      | Connection               ; &lt;a href=&quot;#section-14.10&quot;&gt;Section 14.10&lt;/a&gt;
                      | Date                     ; &lt;a href=&quot;#section-14.18&quot;&gt;Section 14.18&lt;/a&gt;
                      | Pragma                   ; &lt;a href=&quot;#section-14.32&quot;&gt;Section 14.32&lt;/a&gt;
                      | Trailer                  ; &lt;a href=&quot;#section-14.40&quot;&gt;Section 14.40&lt;/a&gt;
                      | Transfer-Encoding        ; &lt;a href=&quot;#section-14.41&quot;&gt;Section 14.41&lt;/a&gt;
                      | Upgrade                  ; &lt;a href=&quot;#section-14.42&quot;&gt;Section 14.42&lt;/a&gt;
                      | Via                      ; &lt;a href=&quot;#section-14.45&quot;&gt;Section 14.45&lt;/a&gt;
                      | Warning                  ; &lt;a href=&quot;#section-14.46&quot;&gt;Section 14.46&lt;/a&gt;

   General-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields may be given the semantics of general
   header fields if all parties in the communication recognize them to
   be general-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">Есть несколько полей заголовков, которые в целом применимы как для сообщений запроса, так и для сообщений ответа, но не применяются к передаваемому объекту. Эти поля заголовка применяются только к передаваемому сообщению. общий заголовок = Кэш-контроль; &lt;a href=&quot;#section-14.9&quot;&gt;Раздел 14.9&lt;/a&gt; | Подключение; &lt;a href=&quot;#section-14.10&quot;&gt;Раздел 14.10&lt;/a&gt; | Дата ; &lt;a href=&quot;#section-14.18&quot;&gt;Раздел 14.18&lt;/a&gt; | Прагма; &lt;a href=&quot;#section-14.32&quot;&gt;Раздел 14.32&lt;/a&gt; | Прицеп; &lt;a href=&quot;#section-14.40&quot;&gt;Раздел 14.40&lt;/a&gt; | Передача-кодирование; &lt;a href=&quot;#section-14.41&quot;&gt;Раздел 14.41&lt;/a&gt; | Обновить ;&lt;a href=&quot;#section-14.42&quot;&gt;Раздел 14.42&lt;/a&gt; | Через ; &lt;a href=&quot;#section-14.45&quot;&gt;Раздел 14.45&lt;/a&gt; | Предупреждение; &lt;a href=&quot;#section-14.46&quot;&gt;Раздел 14.46.&lt;/a&gt; Имена полей общего заголовка могут быть надежно расширены только в сочетании с изменением версии протокола. Однако новым или экспериментальным полям заголовка может быть придана семантика полей общего заголовка, если все стороны в сообщении распознают их как поля общего заголовка. Нераспознанные поля заголовка обрабатываются как поля заголовка объекта.</target>
        </trans-unit>
        <trans-unit id="3cd54b5762f67dada954e548e046b34d36650e6c" translate="yes" xml:space="preserve">
          <source>There are a few rare conditions when this might occur:</source>
          <target state="translated">Есть несколько редких случаев,когда это может произойти:</target>
        </trans-unit>
        <trans-unit id="d68958166491fcc8ea9c6532f3f7c7286929a632" translate="yes" xml:space="preserve">
          <source>There are certain aspects of the HTTP Authentication Framework that
   put constraints on how new authentication schemes can work:

   o  HTTP authentication is presumed to be stateless: all of the
      information necessary to authenticate a request MUST be provided
      in the request, rather than be dependent on the server remembering
      prior requests.  Authentication based on, or bound to, the
      underlying connection is outside the scope of this specification
      and inherently flawed unless steps are taken to ensure that the
      connection cannot be used by any party other than the
      authenticated user (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7230]&lt;/a&gt;).

   o  The authentication parameter &quot;realm&quot; is reserved for defining
      protection spaces as described in &lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;.  New schemes MUST
      NOT use it in a way incompatible with that definition.

   o  The &quot;token68&quot; notation was introduced for compatibility with
      existing authentication schemes and can only be used once per
      challenge or credential.  Thus, new schemes ought to use the
      auth-param syntax instead, because otherwise future extensions
      will be impossible.

   o  The parsing of challenges and credentials is defined by this
      specification and cannot be modified by new authentication
      schemes.  When the auth-param syntax is used, all parameters ought
      to support both token and quoted-string syntax, and syntactical
      constraints ought to be defined on the field value after parsing
      (i.e., quoted-string processing).  This is necessary so that
      recipients can use a generic parser that applies to all
      authentication schemes.

      Note: The fact that the value syntax for the &quot;realm&quot; parameter is
      restricted to quoted-string was a bad design choice not to be
      repeated for new parameters.

   o  Definitions of new schemes ought to define the treatment of
      unknown extension parameters.  In general, a &quot;must-ignore&quot; rule is
      preferable to a &quot;must-understand&quot; rule, because otherwise it will
      be hard to introduce new parameters in the presence of legacy
      recipients.  Furthermore, it's good to describe the policy for
      defining new parameters (such as &quot;update the specification&quot; or
      &quot;use this registry&quot;).

   o  Authentication schemes need to document whether they are usable in
      origin-server authentication (i.e., using WWW-Authenticate),
      and/or proxy authentication (i.e., using Proxy-Authenticate). 

   o  The credentials carried in an Authorization header field are
      specific to the user agent and, therefore, have the same effect on
      HTTP caches as the &quot;private&quot; Cache-Control response directive
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.2.6&quot;&gt;Section&amp;nbsp;5.2.2.6 of [RFC7234]&lt;/a&gt;), within the scope of the request in
      which they appear.

      Therefore, new authentication schemes that choose not to carry
      credentials in the Authorization header field (e.g., using a newly
      defined header field) will need to explicitly disallow caching, by
      mandating the use of either Cache-Control request directives
      (e.g., &quot;no-store&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.1.5&quot;&gt;Section&amp;nbsp;5.2.1.5 of [RFC7234]&lt;/a&gt;) or response
      directives (e.g., &quot;private&quot;).</source>
          <target state="translated">Существуют определенные аспекты структуры HTTP-аутентификации, которые накладывают ограничения на то, как могут работать новые схемы аутентификации: o Предполагается, что HTTP-аутентификация не имеет состояния: вся информация, необходимая для аутентификации запроса, ДОЛЖНА быть предоставлена ​​в запросе, а не зависеть от сервер запоминает предыдущие запросы. Аутентификация, основанная на базовом соединении или связанная с ним, выходит за рамки данной спецификации и по своей сути ошибочна, если не предприняты шаги, гарантирующие, что соединение не может использоваться какой-либо стороной, кроме аутентифицированного пользователя (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.3&quot;&gt;Раздел 2.3 [RFC7230]&lt;/a&gt; ) , o Параметр аутентификации &quot;область&quot; зарезервирован для определения пространств защиты, как описано в &lt;a href=&quot;#section-2.2&quot;&gt;разделе 2.2.&lt;/a&gt;, Новые схемы НЕ ДОЛЖНЫ использовать его таким образом, который несовместим с этим определением. o Обозначение &amp;laquo;token68&amp;raquo; было введено для совместимости с существующими схемами аутентификации и может использоваться только один раз для запроса или учетных данных. Таким образом, новые схемы должны вместо этого использовать синтаксис auth-param, потому что в противном случае будущие расширения будут невозможны. o Анализ запросов и учетных данных определяется этой спецификацией и не может быть изменен новыми схемами аутентификации. Когда используется синтаксис auth-param, все параметры должны поддерживать синтаксис как токена, так и строки в кавычках, а синтаксические ограничения должны быть определены для значения поля после синтаксического анализа (т. Е. Обработки строки в кавычках).Это необходимо для того, чтобы получатели могли использовать общий синтаксический анализатор, который применяется ко всем схемам аутентификации. Примечание. Тот факт, что синтаксис значения для параметра &amp;laquo;область&amp;raquo; ограничен строкой в ​​кавычках, был плохим выбором дизайна, чтобы не повторяться для новых параметров. o Определения новых схем должны определять обработку неизвестных параметров расширения. В общем, правило &amp;laquo;обязательно игнорировать&amp;raquo; предпочтительнее, чем правило &amp;laquo;обязательно понимать&amp;raquo;, потому что в противном случае будет сложно ввести новые параметры в присутствии старых получателей. Кроме того, полезно описать политику для определения новых параметров (таких как &amp;laquo;обновить спецификацию&amp;raquo; или &amp;laquo;использовать этот реестр&amp;raquo;).o Схемы аутентификации должны задокументировать, можно ли их использовать при аутентификации исходного сервера (т. е. с использованием WWW-аутентификации) и / или аутентификации прокси (т. е. с использованием аутентификации прокси). o Учетные данные, содержащиеся в поле заголовка авторизации, специфичны для пользовательского агента и, следовательно, оказывают такое же влияние на кеши HTTP, как и директива ответа &quot;private&quot; Cache-Control (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.2.6&quot;&gt;Раздел 5.2.2.6 [RFC7234]&lt;/a&gt; ), в рамках запроса, в котором они появляются. Следовательно, новые схемы аутентификации, которые предпочитают не переносить учетные данные в поле заголовка авторизации (например, с использованием вновь определенного поля заголовка), должны будут явно запрещать кэширование, требуя использования любой директивы запроса Cache-Control (например, &amp;laquo;no- store &amp;raquo;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.1.5&quot;&gt;раздел 5.2.1.5 [RFC7234]&lt;/a&gt; ) или директивы ответа (например,&amp;laquo; private &amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="47def022b2952624e6b7c50d68fc89498c6bcbc8" translate="yes" xml:space="preserve">
          <source>There are different ways to choose which website is &lt;em&gt;canonical&lt;/em&gt;.</source>
          <target state="translated">Есть разные способы выбрать, какой веб-сайт является &lt;em&gt;каноническим&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fb9fab7f67432c45ef3a01bc4e6955ba9af7ef46" translate="yes" xml:space="preserve">
          <source>There are five major rendering engines: Trident, Gecko, Presto, Blink, and WebKit. As sniffing the rendering engines names is common, a lot of user agents added other rendering names to trigger detection. It is therefore important to pay attention not to trigger false-positives when detecting the rendering engine.</source>
          <target state="translated">Есть пять основных двигателей рендеринга:Trident,Gecko,Presto,Blink и WebKit.Так как прослушивание имен рендер-движков является обычным делом,многие пользовательские агенты добавили другие имена рендер-движков для срабатывания детектора.Поэтому при обнаружении рендер-движка важно обращать внимание на то,чтобы не спровоцировать срабатывание ложных срабатываний.</target>
        </trans-unit>
        <trans-unit id="ec7265e037a89a08f26052ad3aa1abd61eeef50e" translate="yes" xml:space="preserve">
          <source>There are no legal or technological requirements for its use, but the &lt;a href=&quot;headers/dnt&quot;&gt;&lt;code&gt;DNT&lt;/code&gt;&lt;/a&gt; header can be used to signal that a web application should disable either its tracking or cross-site user tracking of an individual user. See the &lt;a href=&quot;headers/dnt&quot;&gt;&lt;code&gt;DNT&lt;/code&gt;&lt;/a&gt; header for more information.</source>
          <target state="translated">Нет никаких юридических или технологических требований для его использования, но заголовок &lt;a href=&quot;headers/dnt&quot;&gt; &lt;code&gt;DNT&lt;/code&gt; &lt;/a&gt; может использоваться, чтобы сигнализировать о том, что веб-приложение должно отключить отслеживание или межсайтовое отслеживание отдельного пользователя. См. Заголовок &lt;a href=&quot;headers/dnt&quot;&gt; &lt;code&gt;DNT&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="8341be3003600a3499c2c6008b5ac1ba78954829" translate="yes" xml:space="preserve">
          <source>There are numerous request headers available. They can be divided in several groups:</source>
          <target state="translated">Имеются многочисленные заголовки запросов.Они могут быть разделены на несколько групп:</target>
        </trans-unit>
        <trans-unit id="6e686045e6ac4c90ab4cd236500952ba40ae62b2" translate="yes" xml:space="preserve">
          <source>There are numerous response headers available. These can be divided into several groups:</source>
          <target state="translated">Имеются многочисленные заголовки ответов.Их можно разделить на несколько групп:</target>
        </trans-unit>
        <trans-unit id="9222fd28dc57a16808d7c19d6bf6f9df7c972ab4" translate="yes" xml:space="preserve">
          <source>There are numerous use cases for redirects, but as performance is impacted with every redirect, their use should be kept to a minimum.</source>
          <target state="translated">Существует множество случаев использования перенаправления,но так как на производительность влияет каждое перенаправление,их использование должно быть сведено к минимуму.</target>
        </trans-unit>
        <trans-unit id="13f9ecbdd18ed16f602f0ce2e3e411623b20ecea" translate="yes" xml:space="preserve">
          <source>There are several kinds of caches: these can be grouped into two main categories: private or shared caches. A &lt;em&gt;shared cache&lt;/em&gt; is a cache that stores responses for reuse by more than one user. A &lt;em&gt;private cache&lt;/em&gt; is dedicated to a single user. This page will mostly talk about browser and proxy caches, but there are also gateway caches, CDN, reverse proxy caches and load balancers that are deployed on web servers for better reliability, performance and scaling of web sites and web applications.</source>
          <target state="translated">Есть несколько видов кешей: их можно сгруппировать в две основные категории: частные или общие кеши. &lt;em&gt;Общий кэш&lt;/em&gt; является кэш , который хранит ответы для повторного использования более чем одного пользователя. &lt;em&gt;Собственный кэш&lt;/em&gt; предназначен для одного пользователя. На этой странице в основном рассказывается о кэшах браузера и прокси, но есть также кеши шлюза, CDN, кеши обратных прокси и балансировщики нагрузки, которые развернуты на веб-серверах для повышения надежности, производительности и масштабирования веб-сайтов и веб-приложений.</target>
        </trans-unit>
        <trans-unit id="cb582dbfa4a7b1600d7a27acf7bcaf2e2220c793" translate="yes" xml:space="preserve">
          <source>There are several policy-controlled features designed to represent functionality that can negatively impact the user experience. These features include:</source>
          <target state="translated">Существует несколько функций,контролируемых политиками и предназначенных для представления функциональности,которая может негативно влиять на работу пользователей.Эти функции включают в себя:</target>
        </trans-unit>
        <trans-unit id="5b36e7ddb912239041ca7ab0dc533b4f7149cde8" translate="yes" xml:space="preserve">
          <source>There are several policy-controlled features to help enforce best practices for providing good performance and user experiences.</source>
          <target state="translated">Существует несколько функций,контролируемых политикой,которые помогают внедрять передовую практику для обеспечения хорошей производительности и удобства работы пользователей.</target>
        </trans-unit>
        <trans-unit id="4c3b7153e2634e73590a4cce2b8c456ab59f6363" translate="yes" xml:space="preserve">
          <source>There are several types of redirects and they fall into three categories: permanent, temporary and special redirections.</source>
          <target state="translated">Существует несколько типов перенаправлений,которые делятся на три категории:постоянные,временные и специальные.</target>
        </trans-unit>
        <trans-unit id="c7f58fdbcbba9bec3b86fd66d8bc7fa26b8fe6f5" translate="yes" xml:space="preserve">
          <source>There are three possible directives for &lt;code&gt;X-Frame-Options&lt;/code&gt;:</source>
          <target state="translated">Для &lt;code&gt;X-Frame-Options&lt;/code&gt; есть три возможных директивы :</target>
        </trans-unit>
        <trans-unit id="617a6e0c426a32391566dd90c1be40e2204860a0" translate="yes" xml:space="preserve">
          <source>There are three relevant statuses, when working with range requests:</source>
          <target state="translated">При работе с запросами диапазона есть три соответствующих статуса:</target>
        </trans-unit>
        <trans-unit id="8ae719b0ddb46afe501f7c4d04161647540a420e" translate="yes" xml:space="preserve">
          <source>There are two common use cases:</source>
          <target state="translated">Есть два случая общего пользования:</target>
        </trans-unit>
        <trans-unit id="4d8949bb550cb1be029d6340065449416ee39fb0" translate="yes" xml:space="preserve">
          <source>There are two entity-tag comparison functions, depending on whether
   or not the comparison context allows the use of weak validators:

   o  Strong comparison: two entity-tags are equivalent if both are not
      weak and their opaque-tags match character-by-character.

   o  Weak comparison: two entity-tags are equivalent if their
      opaque-tags match character-by-character, regardless of either or
      both being tagged as &quot;weak&quot;. 

   The example below shows the results for a set of entity-tag pairs and
   both the weak and strong comparison function results:

   +--------+--------+-------------------+-----------------+
   | ETag 1 | ETag 2 | Strong Comparison | Weak Comparison |
   +--------+--------+-------------------+-----------------+
   | W/&quot;1&quot;  | W/&quot;1&quot;  | no match          | match           |
   | W/&quot;1&quot;  | W/&quot;2&quot;  | no match          | no match        |
   | W/&quot;1&quot;  | &quot;1&quot;    | no match          | match           |
   | &quot;1&quot;    | &quot;1&quot;    | match             | match           |
   +--------+--------+-------------------+-----------------+</source>
          <target state="translated">o Слабое сравнение:два тега эквивалентны,если оба тега не являются слабыми,а их непрозрачные теги соответствуют посимвольно.o Слабое сравнение:два тега эквивалентны,если их непрозрачные теги соответствуют посимвольно,независимо от того,оба или оба тега помечены как &quot;слабые&quot;.В примере ниже показаны результаты для набора пар меток,а также слабые и сильные результаты функции сравнения:+----------+--------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------+----------------------------------------------------------------------------------------------------------+| &quot;1&quot; W/&quot;1&quot; | &quot;1&quot; W/&quot;1&quot; | no match | match | | W/&quot;1&quot; | W/&quot;2&quot; | no match | no match | | W/&quot;1&quot; | &quot;1&quot; | no match | | &quot;1&quot; | &quot;1&quot; | &quot;1&quot; | &quot;1&quot; match | | +------------+---------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</target>
        </trans-unit>
        <trans-unit id="db65cf9eb555812887e466f13f1dfba01665198b" translate="yes" xml:space="preserve">
          <source>There are two kinds of collection write locks.  A depth-0 write lock
   on a collection protects the collection properties plus the internal
   member URLs of that one collection, while not protecting the content
   or properties of member resources (if the collection itself has any
   entity bodies, those are also protected).  A depth-infinity write
   lock on a collection provides the same protection on that collection
   and also provides write lock protection on every member resource.

   Expressed otherwise, a write lock of either kind protects any request
   that would create a new resource in a write locked collection, any
   request that would remove an internal member URL of a write locked
   collection, and any request that would change the segment name of any
   internal member.

   Thus, a collection write lock protects all the following actions:

   o  DELETE a collection's direct internal member, 

   o  MOVE an internal member out of the collection,

   o  MOVE an internal member into the collection,

   o  MOVE to rename an internal member within a collection,

   o  COPY an internal member into a collection, and

   o  PUT or MKCOL request that would create a new internal member.

   The collection's lock token is required in addition to the lock token
   on the internal member itself, if it is locked separately.

   In addition, a depth-infinity lock affects all write operations to
   all members of the locked collection.  With a depth-infinity lock,
   the resource identified by the root of the lock is directly locked,
   and all its members are indirectly locked.

   o  Any new resource added as a descendant of a depth-infinity locked
      collection becomes indirectly locked.

   o  Any indirectly locked resource moved out of the locked collection
      into an unlocked collection is thereafter unlocked.

   o  Any indirectly locked resource moved out of a locked source
      collection into a depth-infinity locked target collection remains
      indirectly locked but is now protected by the lock on the target
      collection (the target collection's lock token will thereafter be
      required to make further changes).

   If a depth-infinity write LOCK request is issued to a collection
   containing member URLs identifying resources that are currently
   locked in a manner that conflicts with the new lock (see &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;,
   point 3), the request MUST fail with a 423 (Locked) status code, and
   the response SHOULD contain the 'no-conflicting-lock' precondition.

   If a lock request causes the URL of a resource to be added as an
   internal member URL of a depth-infinity locked collection, then the
   new resource MUST be automatically protected by the lock.  For
   example, if the collection /a/b/ is write locked and the resource /c
   is moved to /a/b/c, then resource /a/b/c will be added to the write
   lock.</source>
          <target state="translated">Есть два вида блокировок записи для сбора. Блокировка записи с глубиной 0 для коллекции защищает свойства коллекции и внутренние URL-адреса членов этой коллекции, не защищая при этом содержимое или свойства ресурсов-членов (если сама коллекция имеет какие-либо тела сущностей, они также защищены). Бесконечная блокировка записи для коллекции обеспечивает такую ​​же защиту для этой коллекции, а также обеспечивает защиту блокировки записи для каждого ресурса-члена. Иначе говоря, блокировка записи любого типа защищает любой запрос, который создаст новый ресурс в коллекции с блокировкой записи, любой запрос, который удалит внутренний URL-адрес члена коллекции с блокировкой записи, а также любой запрос, который изменит имя сегмента любого внутренний член. Таким образом,блокировка записи в коллекцию защищает все следующие действия: o УДАЛИТЬ прямого внутреннего члена коллекции, o ПЕРЕМЕСТИТЬ внутренний член из коллекции, o ПЕРЕМЕСТИТЬ внутренний член в коллекцию, o ПЕРЕМЕСТИТЬ, чтобы переименовать внутренний член в коллекции, o КОПИРОВАТЬ внутренний член в коллекцию и o запрос PUT или MKCOL, который создаст новый внутренний член. Токен блокировки коллекции требуется в дополнение к токену блокировки на самом внутреннем элементе, если он заблокирован отдельно. Кроме того, блокировка бесконечности глубины влияет на все операции записи для всех членов заблокированной коллекции. При блокировке бесконечности глубины ресурс, определяемый корнем блокировки, блокируется напрямую, а все его элементы блокируются косвенно.o Любой новый ресурс, добавленный как потомок коллекции, заблокированной на бесконечную глубину, становится косвенно заблокированным. o Любой косвенно заблокированный ресурс, перемещенный из заблокированной коллекции в разблокированную коллекцию, впоследствии разблокируется. o Любой косвенно заблокированный ресурс, перемещенный из заблокированной исходной коллекции в целевую коллекцию с заблокированной бесконечностью глубины, остается косвенно заблокированным, но теперь защищен блокировкой целевой коллекции (после этого потребуется токен блокировки целевой коллекции для внесения дальнейших изменений). Если запрос LOCK на запись с бесконечной глубиной выдается коллекции, содержащей URL-адреса участников, идентифицирующие ресурсы, которые в настоящее время заблокированы способом, который конфликтует с новой блокировкой (см.o Любой косвенно заблокированный ресурс, перемещенный из заблокированной коллекции в разблокированную коллекцию, впоследствии разблокируется. o Любой косвенно заблокированный ресурс, перемещенный из заблокированной исходной коллекции в целевую коллекцию с заблокированной бесконечностью глубины, остается косвенно заблокированным, но теперь защищен блокировкой целевой коллекции (после этого потребуется токен блокировки целевой коллекции для внесения дальнейших изменений). Если запрос LOCK на запись с бесконечной глубиной выдается коллекции, содержащей URL-адреса членов, идентифицирующих ресурсы, которые в настоящее время заблокированы способом, который конфликтует с новой блокировкой (см.o Любой косвенно заблокированный ресурс, перемещенный из заблокированной коллекции в разблокированную коллекцию, впоследствии разблокируется. o Любой косвенно заблокированный ресурс, перемещенный из заблокированной исходной коллекции в целевую коллекцию с заблокированной бесконечностью глубины, остается косвенно заблокированным, но теперь защищен блокировкой целевой коллекции (после этого потребуется токен блокировки целевой коллекции для внесения дальнейших изменений). Если запрос LOCK на запись с бесконечной глубиной выдается коллекции, содержащей URL-адреса членов, идентифицирующих ресурсы, которые в настоящее время заблокированы способом, который конфликтует с новой блокировкой (см.o Любой косвенно заблокированный ресурс, перемещенный из заблокированной исходной коллекции в целевую коллекцию с заблокированной бесконечностью глубины, остается косвенно заблокированным, но теперь защищен блокировкой целевой коллекции (после этого потребуется токен блокировки целевой коллекции для внесения дальнейших изменений). Если запрос LOCK на запись с бесконечной глубиной выдается коллекции, содержащей URL-адреса членов, идентифицирующих ресурсы, которые в настоящее время заблокированы способом, который конфликтует с новой блокировкой (см.o Любой косвенно заблокированный ресурс, перемещенный из заблокированной исходной коллекции в целевую коллекцию с заблокированной бесконечностью глубины, остается косвенно заблокированным, но теперь защищен блокировкой целевой коллекции (после этого потребуется токен блокировки целевой коллекции для внесения дальнейших изменений). Если запрос LOCK на запись с бесконечной глубиной выдается коллекции, содержащей URL-адреса членов, идентифицирующих ресурсы, которые в настоящее время заблокированы способом, который конфликтует с новой блокировкой (см.Если запрос LOCK на запись с бесконечной глубиной выдается коллекции, содержащей URL-адреса членов, идентифицирующих ресурсы, которые в настоящее время заблокированы способом, который конфликтует с новой блокировкой (см.Если запрос LOCK на запись с бесконечной глубиной выдается коллекции, содержащей URL-адреса членов, идентифицирующих ресурсы, которые в настоящее время заблокированы способом, который конфликтует с новой блокировкой (см.&lt;a href=&quot;#section-6.1&quot;&gt;Раздел 6.1&lt;/a&gt; , пункт 3), запрос ДОЛЖЕН завершиться ошибкой с кодом состояния 423 (заблокирован), а ответ ДОЛЖЕН содержать предварительное условие &amp;laquo;no-конфликтующей блокировки&amp;raquo;. Если запрос блокировки вызывает добавление URL-адреса ресурса в качестве внутреннего URL-адреса члена коллекции, заблокированной на бесконечность глубины, то новый ресурс ДОЛЖЕН быть автоматически защищен блокировкой. Например, если коллекция / a / b / заблокирована от записи, а ресурс / c перемещен в / a / b / c, то ресурс / a / b / c будет добавлен к блокировке записи.</target>
        </trans-unit>
        <trans-unit id="ea804f8e0e63528d1dd87bc0e827f009664d28b8" translate="yes" xml:space="preserve">
          <source>There are two types of HTTP messages, requests and responses, each with its own format.</source>
          <target state="translated">Существует два типа HTTP-сообщений,запросов и ответов,каждый из которых имеет свой формат.</target>
        </trans-unit>
        <trans-unit id="fe2bb96492312ef6374bb657cdd41b390e796741" translate="yes" xml:space="preserve">
          <source>There are two types of proxies: &lt;strong&gt;forward proxies&lt;/strong&gt; (or tunnel, or gateway) and&lt;strong&gt; reverse proxies&lt;/strong&gt; (used to control and protect access to a server for load-balancing, authentication, decryption or caching).</source>
          <target state="translated">Существует два типа прокси: &lt;strong&gt;прокси-&lt;/strong&gt; серверы &lt;strong&gt;прямого&lt;/strong&gt; доступа (или туннель, или шлюз) и &lt;strong&gt;обратные прокси-серверы&lt;/strong&gt; (используемые для управления и защиты доступа к серверу для балансировки нагрузки, аутентификации, дешифрования или кэширования).</target>
        </trans-unit>
        <trans-unit id="d24023e8db6a2be9a6f15c3bd48794df9fdd2114" translate="yes" xml:space="preserve">
          <source>There is a discussion to add WebP (&lt;code&gt;image/webp&lt;/code&gt;) to this list, but browser vendors are cautious in accepting it.</source>
          <target state="translated">Существует дискуссия о добавлении WebP ( &lt;code&gt;image/webp&lt;/code&gt; ) в этот список, но производители браузеров осторожно соглашаются с этим.</target>
        </trans-unit>
        <trans-unit id="357745e961c49e7808944a7f96ad3fca2b616dd4" translate="yes" xml:space="preserve">
          <source>There is no content to send for this request, but the headers may be useful. The user-agent may update its cached headers for this resource with the new ones.</source>
          <target state="translated">Нет содержимого для отправки этого запроса,но заголовки могут быть полезны.Пользователь-агент может обновлять свои кэшированные заголовки для этого ресурса новыми.</target>
        </trans-unit>
        <trans-unit id="2f5a6e5a3d7f30adf4bc4c7e14047c3ad52fec62" translate="yes" xml:space="preserve">
          <source>There is no way to deal with this problem without annoying one of the two clients. However, lost updates and race conditions are to be avoided. We want predictable results, and expect that the clients are notified when their changes are rejected.</source>
          <target state="translated">Нет способа решить эту проблему,не раздражая одного из двух клиентов.Тем не менее,потерянных обновлений и гоночных условий следует избегать.Мы хотим предсказуемых результатов и ожидаем,что клиенты будут уведомлены,когда их изменения будут отклонены.</target>
        </trans-unit>
        <trans-unit id="5746b1d21828f38918b30138869ef276f2228158" translate="yes" xml:space="preserve">
          <source>There is one associative array already defined (because a JavaScript currently cannot define them on its own):</source>
          <target state="translated">Уже определен один ассоциативный массив (поскольку JavaScript в настоящее время не может определить их самостоятельно):</target>
        </trans-unit>
        <trans-unit id="d277b5fa967b80dbc6939e7b654fcee1641c47de" translate="yes" xml:space="preserve">
          <source>There may be cases where a client wishes to submit state tokens, but
   doesn't want the request to fail just because the state token isn't
   current anymore.  One simple way to do this is to include a Condition
   that is known to always evaluate to true, such as in:

     If: (&amp;lt;urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;)
       (Not &amp;lt;DAV:no-lock&amp;gt;)

   &quot;DAV:no-lock&quot; is known to never represent a current lock token.  Lock
   tokens are assigned by the server, following the uniqueness
   requirements described in &lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;, therefore cannot use the
   &quot;DAV:&quot; scheme.  Thus, by applying &quot;Not&quot; to a state token that is 

   known not to be current, the Condition always evaluates to true.
   Consequently, the whole If header will always evaluate to true, and
   the lock token urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2 will be
   submitted in any case.</source>
          <target state="translated">Могут быть случаи, когда клиент желает отправить токены состояния, но не хочет, чтобы запрос завершился ошибкой только потому, что токен состояния больше не актуален. Один простой способ сделать это - включить условие, которое, как известно, всегда оценивается как истинное, например, в: If: (&amp;lt;urn: uuid: 181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;) (Not &amp;lt;DAV: no- lock&amp;gt;) Известно, что &amp;laquo;DAV: no-lock&amp;raquo; никогда не представляет текущий токен блокировки. Жетоны блокировки назначаются сервером в соответствии с требованиями уникальности, описанными в &lt;a href=&quot;#section-6.5&quot;&gt;разделе 6.5.&lt;/a&gt;, поэтому нельзя использовать схему &amp;laquo;DAV:&amp;raquo;. Таким образом, применяя &amp;laquo;Not&amp;raquo; к токену состояния, о котором известно, что он не является текущим, Condition всегда оценивается как истинное. Следовательно, весь заголовок If всегда будет оцениваться как истинный, и урна токена блокировки: uuid: 181d4fae-7d8c-11d0-a765-00a0c91e6bf2 будет отправлена ​​в любом случае.</target>
        </trans-unit>
        <trans-unit id="2490d9396fd52fc708c5e36b206a6d2e488dee63" translate="yes" xml:space="preserve">
          <source>There should always be a confirmation required for any sensitive action.</source>
          <target state="translated">Для любых деликатных действий всегда должно быть подтверждение.</target>
        </trans-unit>
        <trans-unit id="9a8936e6969eea24b3ea42fd8769c85fdddd316b" translate="yes" xml:space="preserve">
          <source>These HTTP codes are not redefined, but their use is somewhat
   extended by WebDAV methods and requirements.  In general, many HTTP
   status codes can be used in response to any request, not just in
   cases described in this document.  Note also that WebDAV servers are
   known to use 300-level redirect responses (and early interoperability
   tests found clients unprepared to see those responses).  A 300-level
   response MUST NOT be used when the server has created a new resource
   in response to the request.</source>
          <target state="translated">Эти HTTP коды не переопределены,но их использование несколько расширено методами и требованиями WebDAV.В целом,многие коды статуса HTTP могут быть использованы в ответ на любой запрос,а не только в случаях,описанных в этом документе.Отметим также,что серверы WebDAV,как известно,используют 300-уровневые редиректные ответы (и ранние тесты функциональной совместимости обнаружили клиентов неподготовленными к просмотру этих ответов).300-уровневый ответ НЕ ДОЛЖЕН использоваться,когда сервер создал новый ресурс в ответ на запрос.</target>
        </trans-unit>
        <trans-unit id="d2011ed2f18ef5bdd96144452aa6435ca84d3624" translate="yes" xml:space="preserve">
          <source>These URLs are examples &amp;mdash; the site could serve the different filetypes with any URL patterns it wishes, such as a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search&quot;&gt;query string parameter&lt;/a&gt;: &lt;code&gt;/documents/foo?format=json&lt;/code&gt;, &lt;code&gt;/documents/foo?format=xml&lt;/code&gt;, and so on.</source>
          <target state="translated">Эти URL-адреса являются примерами - сайт может обслуживать файлы разных типов с любыми шаблонами URL-адресов, которые он пожелает, такими как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search&quot;&gt;параметр строки запроса&lt;/a&gt; : &lt;code&gt;/documents/foo?format=json&lt;/code&gt; , &lt;code&gt;/documents/foo?format=xml&lt;/code&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="19ac2e7adff1466c1a8f79fcbd5235600c8aac56" translate="yes" xml:space="preserve">
          <source>These URLs will be rewritten before the request is made, meaning that no insecure requests will hit the network. Note that, if the requested resource is not actually available via HTTPS, the request will fail without any fallback to HTTP.</source>
          <target state="translated">Эти URL будут перезаписаны до того,как запрос будет сделан,что означает,что незащищенные запросы не будут попадать в сеть.Обратите внимание,что если запрашиваемый ресурс на самом деле не доступен через HTTPS,то запрос будет выполнен без отказов на HTTP.</target>
        </trans-unit>
        <trans-unit id="14aea1eca27b905f4bb97521d425369003cb4f07" translate="yes" xml:space="preserve">
          <source>These are some sample UA strings from other Gecko-based browsers on various platforms. Note that many of these have not yet been released on Gecko 2.0!</source>
          <target state="translated">Это некоторые примеры строк UA из других браузеров на базе Gecko на различных платформах.Обратите внимание,что многие из них еще не были выпущены на Gecko 2.0!</target>
        </trans-unit>
        <trans-unit id="f6caceedce573b19f722b4be7d0ac77739c262ca" translate="yes" xml:space="preserve">
          <source>These are the values sent when the context doesn't give better information. Note that all browsers add the &lt;code&gt;*/*&lt;/code&gt; MIME Type to cover all cases. This is typically used for requests initiated via the address bar of a browser, or via an HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">Это значения, отправляемые, когда контекст не дает более точной информации. Обратите внимание, что все браузеры добавляют тип MIME &lt;code&gt;*/*&lt;/code&gt; , чтобы охватить все случаи. Обычно это используется для запросов, инициируемых через адресную строку браузера или через элемент HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63ded4498d8ac164d315a41831a90dda911d2194" translate="yes" xml:space="preserve">
          <source>These four building blocks were completed by the end of 1990, and the first servers were already running outside of CERN by early 1991. On August 6&lt;sup&gt;th&lt;/sup&gt; 1991, Tim Berners-Lee's &lt;a href=&quot;https://groups.google.com/forum/#!msg/alt.hypertext/eCTkkOoWTAY/urNMgHnS2gYJ&quot;&gt;post&lt;/a&gt; on the public &lt;em&gt;alt.hypertext&lt;/em&gt; newsgroup is now considered as the official start of the World Wide Web as a public project.</source>
          <target state="translated">Эти четыре здания блоков были завершены к концу 1990 года, а первые сервера уже работают за пределами ЦЕРНА в начале 1991 года 6 августа - &lt;sup&gt;го&lt;/sup&gt; 1991 года Тим Бернерс-Ли &lt;a href=&quot;https://groups.google.com/forum/#!msg/alt.hypertext/eCTkkOoWTAY/urNMgHnS2gYJ&quot;&gt;пост&lt;/a&gt; на общественном &lt;em&gt;alt.hypertext&lt;/em&gt; телеконференции в настоящее время считаются официальным запуск всемирной паутины как публичного проекта.</target>
        </trans-unit>
        <trans-unit id="fe283302753b3d4f0050a7e568fff6e5641e1e65" translate="yes" xml:space="preserve">
          <source>These functions can be used in building the PAC file:</source>
          <target state="translated">Эти функции могут быть использованы при создании файла PAC:</target>
        </trans-unit>
        <trans-unit id="adec7a72aca0f353da15e6ce23d6fb621cfcba41" translate="yes" xml:space="preserve">
          <source>These headers are meaningful only for a single transport-level connection and must not be retransmitted by proxies or cached. Such headers are: &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt;. Note that only hop-by-hop headers may be set using the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; general header.</source>
          <target state="translated">Эти заголовки имеют смысл только для одного соединения транспортного уровня и не должны повторно передаваться прокси-серверами или кэшироваться. Такими заголовками являются: &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; . Обратите внимание, что с помощью общего заголовка &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; могут быть установлены только заголовки &quot;шаг за шагом&quot; .</target>
        </trans-unit>
        <trans-unit id="ed24fa2e76be943bae964dfeca098c8b6b9d0285" translate="yes" xml:space="preserve">
          <source>These headers must be transmitted to the final recipient of the message; that is, the server for a request or the client for a response. Intermediate proxies must retransmit end-to-end headers unmodified and caches must store them.</source>
          <target state="translated">Эти заголовки должны быть переданы конечному получателю сообщения,т.е.серверу для запроса или клиенту для ответа.Промежуточные прокси-серверы должны ретранслировать сквозные заголовки в неизмененном виде,а кэш должен хранить их.</target>
        </trans-unit>
        <trans-unit id="49c4698bda080192aa7cae79c66f0082e395ce72" translate="yes" xml:space="preserve">
          <source>These novelties have not been introduced as concerted effort, but as a try-and-see approach over the 1991-1995 period: a server and a browser added one feature and it saw if it get traction. A lot of interoperability problems were common. In November 1996, in order to solve these annoyances, an informational document describing the common practices has been published, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;. This is the definition of HTTP/1.0 and it is notable that, in the narrow sense of the term, it isn't an official standard.</source>
          <target state="translated">Эти новинки вводились не как согласованные усилия, а как пробный подход в период 1991-1995 годов: сервер и браузер добавили одну функцию и посмотрели, наберется ли она обороты. Было много проблем с совместимостью. В ноябре 1996 года для решения этих проблем был опубликован информационный документ с описанием общепринятой практики - &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; . Это определение HTTP / 1.0, и примечательно, что в узком смысле этого слова он не является официальным стандартом.</target>
        </trans-unit>
        <trans-unit id="c006f1681899103b8b2e153338a77be2fac29883" translate="yes" xml:space="preserve">
          <source>These redirections are meant to last forever. They imply that the original URL should not be used anymore and that the new one is preferred. Search engine robots trigger an update of the associated URL for the resource in their indexes.</source>
          <target state="translated">Эти перенаправления должны длиться вечно.Они подразумевают,что исходный URL-адрес больше не должен использоваться,а новый предпочтительнее.Поисковые роботы запускают обновление ассоциированного URL ресурса в своих индексах.</target>
        </trans-unit>
        <trans-unit id="a3faadcdd29a9a6bfd08a2c7df57422c7e3b140f" translate="yes" xml:space="preserve">
          <source>These types of manipulations can be prevented by disallowing Javascript via the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; CSP directive.</source>
          <target state="translated">Эти типы манипуляций можно предотвратить, запретив Javascript с помощью директивы CSP &lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b94cf424727db244876c5a0b8a36ae1be82af513" translate="yes" xml:space="preserve">
          <source>They exist. They are hard to defend against. Research continues.
   Beware.</source>
          <target state="translated">Они существуют.От них трудно защищаться.Исследования продолжаются.Берегись.</target>
        </trans-unit>
        <trans-unit id="2b2bbfc5127ae16613bef18603ec77b3984aa83a" translate="yes" xml:space="preserve">
          <source>They should always provide a way to overcome the server-chosen language, e.g., by providing a language menu on the site. Most user-agents provide a default value for the &lt;code&gt;Accept-Language&lt;/code&gt; header, adapted to the user interface language and end users often do not modify it, either by not knowing how, or by not being able to do it, as in an Internet caf&amp;eacute; for instance.</source>
          <target state="translated">Они всегда должны обеспечивать способ преодоления языка, выбранного сервером, например, путем предоставления языкового меню на сайте. Большинство пользовательских агентов предоставляют значение по умолчанию для заголовка &lt;code&gt;Accept-Language&lt;/code&gt; , адаптированное к языку пользовательского интерфейса, и конечные пользователи часто не изменяют его, либо не зная, как, либо не имея возможности сделать это, как в интернет-кафе. например.</target>
        </trans-unit>
        <trans-unit id="d3bab67bcd21378560c58ae4bc5a035031a2e0e6" translate="yes" xml:space="preserve">
          <source>Third-party cookies</source>
          <target state="translated">сторонние куки-файлы</target>
        </trans-unit>
        <trans-unit id="78174180aec78d0cf1800defae73ef9440efe127" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; and worker are blocked and won't load:</source>
          <target state="translated">Этот &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; и рабочий заблокированы и не загружаются:</target>
        </trans-unit>
        <trans-unit id="dd32e06ea9f72392b7e2d0f29fca1199727c26bb" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;cross-origin sharing standard&lt;/a&gt; is used to enable cross-site HTTP requests for:</source>
          <target state="translated">Этот стандарт &lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;межсайтового обмена&lt;/a&gt; используется для включения межсайтовых HTTP-запросов для:</target>
        </trans-unit>
        <trans-unit id="451546fb091c1c1b7ec24fc3cf824086880d3078" translate="yes" xml:space="preserve">
          <source>This Warning code MUST be added by a proxy if it applies any
   transformation to the representation, such as changing the
   content-coding, media-type, or modifying the representation data,
   unless this Warning code already appears in the response.</source>
          <target state="translated">Этот код предупреждения ДОЛЖЕН добавляться прокси-сервером,если он применяет к представлению какие-либо преобразования,такие как изменение кодирования контента,типа носителя или изменение данных представления,если только этот код предупреждения уже не появляется в ответе.</target>
        </trans-unit>
        <trans-unit id="18ecbc255cf2ecd1c85dbf2f6ac85289ceb68820" translate="yes" xml:space="preserve">
          <source>This allows the &lt;code&gt;X-My-Custom-Header&lt;/code&gt; and &lt;code&gt;X-Another-Custom-Header&lt;/code&gt; headers to be exposed to the browser.</source>
          <target state="translated">Это позволяет отображать заголовки &lt;code&gt;X-My-Custom-Header&lt;/code&gt; и &lt;code&gt;X-Another-Custom-Header&lt;/code&gt; для браузера.</target>
        </trans-unit>
        <trans-unit id="d793e4bdbd751c7b733ab0e15d263a1a9069b84e" translate="yes" xml:space="preserve">
          <source>This appendix is informative.

   The Relax NG schema explicitly excludes elements in the Atom Protocol
   namespace that are not defined in this revision of the specification.
   Requirements for Atom Protocol processors encountering such markup
   are given in Sections &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; and &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].

   The Schema for Service Documents:

   # -*- rnc -*- # RELAX NG Compact Syntax Grammar for the Atom Protocol

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   namespace atom = &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;
   namespace xsd = &quot;&lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;
   namespace xhtml = &quot;&lt;a href=&quot;http://www.w3.org/1999/xhtml&quot;&gt;http://www.w3.org/1999/xhtml&lt;/a&gt;&quot;
   namespace local = &quot;&quot;

   start = appService

   # common:attrs

   atomURI = text

   appCommonAttributes =
      attribute xml:base { atomURI }?,
      attribute xml:lang { atomLanguageTag  }?,
      attribute xml:space {&quot;default&quot;|&quot;preserved&quot;}?,
      undefinedAttribute*

   atomCommonAttributes = appCommonAttributes

   undefinedAttribute = attribute * - (xml:base | xml:space  | xml:lang
     | local:*) { text }

   atomLanguageTag = xsd:string {
      pattern = &quot;([A-Za-z]{1,8}(-[A-Za-z0-9]{1,8})*)?&quot;
   } 

   atomDateConstruct =
       appCommonAttributes,
       xsd:dateTime

   # app:service
   appService =
      element app:service {
         appCommonAttributes,
         ( appWorkspace+
           &amp;amp; extensionElement* )
      }

   # app:workspace

   appWorkspace =
      element app:workspace {
         appCommonAttributes,
         ( atomTitle
           &amp;amp; appCollection*
           &amp;amp; extensionSansTitleElement* )
      }

   atomTitle = element atom:title { atomTextConstruct }

   # app:collection

   appCollection =
      element app:collection {
         appCommonAttributes,
         attribute href { atomURI  },
         ( atomTitle
           &amp;amp; appAccept*
           &amp;amp; appCategories*
           &amp;amp; extensionSansTitleElement* )
      }

   # app:categories

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       } 

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           undefinedContent
       }

   appCategories = appInlineCategories | appOutOfLineCategories

   # app:accept

   appAccept =
      element app:accept {
            appCommonAttributes,
            ( text? )
      }

   # Simple Extension

   simpleSansTitleExtensionElement =
      element * - (app:*|atom:title) {
         text
      }

   simpleExtensionElement =
      element * - (app:*) {
         text
      }

   # Structured Extension

   structuredSansTitleExtensionElement =
      element * - (app:*|atom:title) {
         (attribute * { text }+,
            (text|anyElement)*)
       | (attribute * { text }*,
          (text?, anyElement+, (text|anyElement)*))
      } 

   structuredExtensionElement =
      element * - (app:*) {
         (attribute * { text }+,
            (text|anyElement)*)
       | (attribute * { text }*,
          (text?, anyElement+, (text|anyElement)*))
      }

   # Other Extensibility

   extensionSansTitleElement =
    simpleSansTitleExtensionElement|structuredSansTitleExtensionElement

   extensionElement = simpleExtensionElement |
      structuredExtensionElement

   undefinedContent = (text|anyForeignElement)*

   # Extensions

   anyElement =
      element * {
         (attribute * { text }
          | text
          | anyElement)*
      }

   anyForeignElement =
       element * - app:* {
          (attribute * { text }
           | text
           | anyElement)*
       }

   atomPlainTextConstruct =
       atomCommonAttributes,
       attribute type { &quot;text&quot; | &quot;html&quot; }?,
       text

   atomXHTMLTextConstruct =
       atomCommonAttributes,
       attribute type { &quot;xhtml&quot; },
       xhtmlDiv

   atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct 

   anyXHTML = element xhtml:* {
       (attribute * { text }
        | text
        | anyXHTML)*
   }

   xhtmlDiv = element xhtml:div {
     (attribute * { text }
      | text
      | anyXHTML)*
   }

   # EOF

   The Schema for Category Documents:

   # -*- rnc -*- # RELAX NG Compact Syntax Grammar for the Atom Protocol

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   namespace atom = &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;
   namespace xsd = &quot;&lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;
   namespace local = &quot;&quot;

   start = appCategories

   atomCommonAttributes =
      attribute xml:base { atomURI }?,
      attribute xml:lang { atomLanguageTag }?,
      undefinedAttribute*

   undefinedAttribute = attribute * - (xml:base | xml:lang | local:*) {
     text }

   atomURI = text

   atomLanguageTag = xsd:string {
      pattern = &quot;([A-Za-z]{1,8}(-[A-Za-z0-9]{1,8})*)?&quot;
   }

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       } 

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           (empty)
       }

   appCategories = appInlineCategories | appOutOfLineCategories

   # Extensibility

   undefinedContent = (text|anyForeignElement)*

   anyElement =
      element * {
         (attribute * { text }
          | text
          | anyElement)*
      }

   anyForeignElement =
       element * - atom:* {
          (attribute * { text }
           | text
           | anyElement)*
       }

   # EOF 

Authors' Addresses

   Joe Gregorio (editor)
   Google

   EMail: joe@bitworking.org
   URI:   &lt;a href=&quot;http://bitworking.org/&quot;&gt;http://bitworking.org/&lt;/a&gt;


   Bill de hOra (editor)
   NewBay Software

   EMail: bill@dehora.net
   URI:   &lt;a href=&quot;http://dehora.net/&quot;&gt;http://dehora.net/&lt;/a&gt; 

Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   &quot;AS IS&quot; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Gregorio &amp;amp; de hOra          Standards Track                    [Page 53]</source>
          <target state="translated">Это приложение является информативным. Схема Relax NG явно исключает элементы в пространстве имен протокола Atom, которые не определены в этой версии спецификации. Требования к процессорам протокола Atom, сталкивающимся с такой разметкой, приведены в разделах &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; и &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]. Схема для служебных документов: # - * - rnc - * - # RELAX NG Compact Syntax Grammar для пространства имен протокола Atom app = &quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &quot; namespace atom = &quot; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http: // www.w3.org/2005/Atom&lt;/a&gt; &quot;пространство имен xsd =&quot; &lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt; &quot;пространство имен xhtml =&quot; &lt;a href=&quot;http://www.w3.org/1999/xhtml&quot;&gt;http://www.w3.org/1999/xhtml&lt;/a&gt;&quot;namespace local =&quot; &quot;start = appService # common: attrs atomURI = text appCommonAttributes = attribute xml: base {atomURI} ?, атрибут xml: lang {atomLanguageTag} ?, атрибут xml: space {&quot; default &quot;|&quot; saved &quot;}? , undefinedAttribute * atomCommonAttributes = appCommonAttributes undefinedAttribute = attribute * - (xml: base | xml: space | xml: lang | local: *) {text} atomLanguageTag = xsd: string {pattern = &quot;([A-Za-z] {1 , 8} (- [A-Za-z0-9] {1,8}) *)? &quot;} AtomDateConstruct = appCommonAttributes, xsd: dateTime # app: service appService = element app: service {appCommonAttributes, (appWorkspace + &amp;amp; extensionElement * )} # app: workspace appWorkspace = element app:рабочая область {appCommonAttributes, (atomTitle &amp;amp; appCollection * &amp;amp; extensionSansTitleElement *)} atomTitle = element atom: title {atomTextConstruct} # app: collection appCollection = element app: collection {appCommonAttributes, attribute href {atomURI}, (atomTitle &amp;amp; appAcategories * &amp;amp; appAcategories * &amp;amp; extensionSansTitleElement *)} # app: Categories atomCategory = element atom: category {atomCommonAttributes, термин атрибута {текст}, схема атрибута {atomURI}?, метка атрибута {text} ?, undefinedContent} appInlineCategories = element app: category {attribute fixed { &amp;laquo;да&amp;raquo; | &quot;нет&quot;} ?,схема атрибутов {atomURI} ?, (atomCategory *, undefinedContent)} appOutOfLineCategories = элемент приложение: категории {атрибут href {atomURI}, undefinedContent} appCategories = appInlineCategories | appOutOfLineCategories # app: accept appAccept = element app: accept {appCommonAttributes, (text?)} # Простое расширение simpleSansTitleExtensionElement = element * - (app: * | atom: title) {text} simpleExtensionElement = element * - (app: *) { text} # Структурированное расширение structuredSansTitleExtensionElement = element * - (app: * | atom: title) {(attribute * {text} +, (text | anyElement) *) | (атрибут * {текст} *, (текст ?,anyElement +, (text | anyElement) *))} structuredExtensionElement = element * - (app: *) {(атрибут * {text} +, (text | anyElement) *) | (attribute * {text} *, (text ?, anyElement +, (text | anyElement) *))} # Другое расширение extensionSansTitleElement = simpleSansTitleExtensionElement | structuredSansTitleExtensionElement extensionElement = simpleExtensionElement | structuredExtensionElement undefinedContent = (text | anyForeignElement) * # Расширения anyElement = element * {(attribute * {text} | text | anyElement) *} anyForeignElement = element * - app: * {(attribute * {text} | text | anyElement) * } atomPlainTextConstruct = atomCommonAttributes,тип атрибута {&quot;текст&quot; | &quot;html&quot;} ?, текст atomXHTMLTextConstruct = atomCommonAttributes, тип атрибута {&quot;xhtml&quot;}, xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML = element xhtml: * {(attribute * {text} | text | anyXHTML) *} xhtmlDiv = element xhtml: div {(attribute * {text} | text | anyXHTML) *} # EOF Схема для документов категории: # - * - rnc - * - # RELAX NG Compact Syntax Grammar для пространства имен протокола Atom app = &quot;xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML = element xhtml: * {(attribute * {text} | text | anyXHTML) *} xhtmlDiv = element xhtml: div {(attribute * {text} | text | anyXHTML) *} # EOF Схема для документов категории: # - * - rnc - * - # RELAX NG Compact Syntax Grammar для пространства имен протокола Atom app = &quot;xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML = element xhtml: * {(attribute * {text} | text | anyXHTML) *} xhtmlDiv = element xhtml: div {(attribute * {text} | text | anyXHTML) *} # EOF Схема для документов категории: # - * - rnc - * - # RELAX NG Compact Syntax Grammar для пространства имен протокола Atom app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &quot;namespace atom =&quot; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; &quot;namespace xsd =&quot; &lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;namespace local =&quot; &quot;start = appCategories atomCommonAttributes = attribute xml: base {atomURI} ?, attribute xml: lang {atomLanguageTag} ?, undefinedAttribute * undefinedAttribute = attribute * - (xml: base | xml: lang | local: *) { text} atomURI = text atomLanguageTag = xsd: string {pattern = &quot;([A-Za-z] {1,8} (- [A-Za-z0-9] {1,8}) *)?&quot;} atomCategory = атом элемента: категория {atomCommonAttributes, термин атрибута {текст}, схема атрибута {atomURI} ?, метка атрибута {текст} ?, undefinedContent} appInlineCategories = элемент приложение: категории {атрибут фиксированный {&quot;да&quot; | &quot;нет&quot;} ?, схема атрибутов {atomURI} ?, (atomCategory *,undefinedContent)} appOutOfLineCategories = элемент приложение: категории {атрибут href {atomURI}, (пусто)} appCategories = appInlineCategories | appOutOfLineCategories # Extensibility undefinedContent = (text | anyForeignElement) * anyElement = element * {(attribute * {text} | text | anyElement) *} anyForeignElement = element * - atom: * {(attribute * {text} | text | anyElement) * } # Адреса авторов EOF Джо Грегорио (редактор) Электронная почта Google: joe@bitworking.org URI:(пусто)} appCategories = appInlineCategories | appOutOfLineCategories # Extensibility undefinedContent = (text | anyForeignElement) * anyElement = element * {(attribute * {text} | text | anyElement) *} anyForeignElement = element * - atom: * {(attribute * {text} | text | anyElement) * } # Адреса авторов EOF Джо Грегорио (редактор) Электронная почта Google: joe@bitworking.org URI:(пусто)} appCategories = appInlineCategories | appOutOfLineCategories # Extensibility undefinedContent = (text | anyForeignElement) * anyElement = element * {(attribute * {text} | text | anyElement) *} anyForeignElement = element * - atom: * {(attribute * {text} | text | anyElement) * } # Адреса авторов EOF Джо Грегорио (редактор) Электронная почта Google: joe@bitworking.org URI:* {(attribute * {text} | text | anyElement) *} # EOF Адреса авторов Джо Грегорио (редактор) Электронная почта Google: joe@bitworking.org URI:* {(attribute * {text} | text | anyElement) *} # EOF Адреса авторов Джо Грегорио (редактор) Электронная почта Google: joe@bitworking.org URI: &lt;a href=&quot;http://bitworking.org/&quot;&gt;http://bitworking.org/&lt;/a&gt; Билл де Хора (редактор) NewBay Software EMail: bill@dehora.net URI: &lt;a href=&quot;http://dehora.net/&quot;&gt;http://dehora.net/&lt;/a&gt; Полное заявление об авторских правах Copyright (C) The IETF Trust (2007). На этот документ распространяются права, лицензии и ограничения, содержащиеся в &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78.&lt;/a&gt;, и, за исключением случаев, указанных в настоящем документе, авторы сохраняют за собой все свои права. Этот документ и содержащаяся в нем информация предоставляются на условиях &amp;laquo;КАК ЕСТЬ&amp;raquo;, и СОСТАВНИК, ОРГАНИЗАЦИЯ, ПРЕДСТАВЛЯЕМЫЕ ОН / ОНА ИЛИ СПОНСИРУЕМЫЕ (ЕСЛИ ЕСТЬ), ИНТЕРНЕТ-ОБЩЕСТВО, IETF TRUST И ИНТЕРНЕТ-ИНЖЕНЕРНАЯ ЦЕНА ОТКАЗЫВАЕТСЯ ОТ ВСЕХ ГАРАНТИИ, ЯВНЫЕ ИЛИ ПОДРАЗУМЕВАЕМЫЕ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ​​НИКАКИМИ ГАРАНТИЯМИ, ЧТО ИСПОЛЬЗОВАНИЕ ДАННЫХ ЗДЕСЬ НЕ НАРУШАЕТ НИКАКИХ ПРАВ ИЛИ КАКИХ-ЛИБО ПОДРАЗУМЕВАЕМЫХ ГАРАНТИЙ КОММЕРЧЕСКОЙ ЦЕННОСТИ ИЛИ ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННОЙ ЦЕЛИ.Интеллектуальная собственность IETF не занимает никакой позиции в отношении действительности или объема каких-либо прав интеллектуальной собственности или других прав, которые могут быть заявлены как относящиеся к реализации или использованию технологии, описанной в этом документе, или степени, в которой любая лицензия на такие права может или может быть недоступен; он также не означает, что он предпринял какие-либо независимые усилия для определения каких-либо таких прав. Информацию о процедурах в отношении прав в документах RFC можно найти в&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;ПП 78&lt;/a&gt; и &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;ПП 79&lt;/a&gt; . Копии раскрытия прав интеллектуальной собственности, переданные в секретариат IETF, и любые гарантии предоставления лицензий, или результат попытки получить генеральную лицензию или разрешение на использование таких прав собственности разработчиками или пользователями данной спецификации могут быть получены из он-лайн репозитория IPR IETF по адресу &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt; . IETF предлагает любой заинтересованной стороне довести до ее сведения любые авторские права, патенты или заявки на патенты или другие права собственности, которые могут касаться технологий, которые могут потребоваться для реализации этого стандарта. Пожалуйста, направьте информацию в IETF по адресу ietf-ipr@ietf.org. Gregorio &amp;amp; de hOra Standards Track [Страница 53]</target>
        </trans-unit>
        <trans-unit id="2da261bce7b3f1d3df96b4c74a292834af8e4041" translate="yes" xml:space="preserve">
          <source>This article documents the default values for the HTTP &lt;code&gt;&lt;a href=&quot;../headers/accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; header for specific inputs and browser versions.</source>
          <target state="translated">В этой статье описаны значения по умолчанию для заголовка HTTP &lt;code&gt;&lt;a href=&quot;../headers/accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; для определенных входных данных и версий браузера.</target>
        </trans-unit>
        <trans-unit id="76ccc899841c5ef0fd03f785dbd8994ed74b0227" translate="yes" xml:space="preserve">
          <source>This article is a general discussion of Cross-Origin Resource Sharing and includes a discussion of the necessary HTTP headers.</source>
          <target state="translated">Эта статья представляет собой общее обсуждение совместного использования ресурсов Cross-Origin и включает в себя обсуждение необходимых HTTP заголовков.</target>
        </trans-unit>
        <trans-unit id="41ec7728272d28393919275489b46845b2a0bf81" translate="yes" xml:space="preserve">
          <source>This can be done easily using the command-line &lt;code&gt;uuencode&lt;/code&gt; utility on Linux and Mac OS X systems:</source>
          <target state="translated">Это можно легко сделать с помощью утилиты командной строки &lt;code&gt;uuencode&lt;/code&gt; в системах Linux и Mac OS X:</target>
        </trans-unit>
        <trans-unit id="11f06821ff38b68a8a006d81f07fe9d41afdd57e" translate="yes" xml:space="preserve">
          <source>This can be useful for serving content dynamically, for example. When using the &lt;code&gt;Vary: User-Agent&lt;/code&gt; header, caching servers should consider the user agent when deciding whether to serve the page from cache. If you are serving different content to mobile users, it can help you to avoid that a cache may mistakenly serve a desktop version of your site to your mobile users. In addition, it can help Google and other search engines to discover the mobile version of a page, and might also tell them that no &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;Cloaking&lt;/a&gt; is intended.</source>
          <target state="translated">Это может быть полезно, например, для динамического обслуживания контента. При использовании заголовка &lt;code&gt;Vary: User-Agent&lt;/code&gt; серверы кеширования должны учитывать пользовательский агент при принятии решения о том, следует ли обслуживать страницу из кеша. Если вы предоставляете мобильным пользователям различный контент, это может помочь вам избежать того, что кеш может ошибочно обслуживать настольную версию вашего сайта для мобильных пользователей. Кроме того, он может помочь Google и другим поисковым системам обнаружить мобильную версию страницы, а также сообщить им, что &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;маскировка&lt;/a&gt; не предназначена.</target>
        </trans-unit>
        <trans-unit id="18b253862e749024a5a8be5438a282e1f0a396b5" translate="yes" xml:space="preserve">
          <source>This can happen if the JavaScript code is running with enhanced privileges allowing it access to multiple domains' content, for example.</source>
          <target state="translated">Это может произойти,если JavaScript-код запущен с расширенными привилегиями,позволяющими,например,получить доступ к содержимому нескольких доменов.</target>
        </trans-unit>
        <trans-unit id="d58af569eba5200f4747d5689b8ff7e7d1d52941" translate="yes" xml:space="preserve">
          <source>This class of status code indicates a provisional response,
   consisting only of the Status-Line and optional headers, and is
   terminated by an empty line. There are no required headers for this
   class of status code. Since HTTP/1.0 did not define any 1xx status
   codes, servers MUST NOT send a 1xx response to an HTTP/1.0 client
   except under experimental conditions.

   A client MUST be prepared to accept one or more 1xx status responses
   prior to a regular response, even if the client does not expect a 100
   (Continue) status message. Unexpected 1xx status responses MAY be
   ignored by a user agent.

   Proxies MUST forward 1xx responses, unless the connection between the
   proxy and its client has been closed, or unless the proxy itself
   requested the generation of the 1xx response. (For example, if a 

   proxy adds a &quot;Expect: 100-continue&quot; field when it forwards a request,
   then it need not forward the corresponding 100 (Continue)
   response(s).)</source>
          <target state="translated">Этот класс кода статуса указывает на предварительную реакцию,состоящую только из строки статуса и необязательных заголовков,и завершается пустой строкой.Для данного класса кода статуса заголовков не требуется.Так как HTTP/1.0 не определял никаких кодов статуса 1xx,серверы НЕ ДОЛЖНЫ посылать 1xx ответ клиенту HTTP/1.0,кроме как в экспериментальных условиях.Клиент ДОЛЖЕН быть готовым принять один или более 1xx-ответов о статусе перед регулярным ответом,даже если клиент не ожидает сообщение о статусе 100 (Продолжить).Неожиданные 1xx ответные сообщения о статусе МОГУТ быть проигнорированы агентом пользователя.Прокси ДОЛЖЕН пересылать 1xx ответы,если только соединение между прокси и его клиентом не было закрыто,или если сам прокси не запросил 1xx ответа.(Например,если при переадресации запроса прокси добавляет поле &quot;Ожидать:100-continue&quot;,то ему не нужно переадресовывать соответствующие 100 (Continue)ответов).</target>
        </trans-unit>
        <trans-unit id="6b9a408e9c3b7b54fbf759cb196264221abed170" translate="yes" xml:space="preserve">
          <source>This class of status code indicates that further action needs to be
   taken by the user agent in order to fulfill the request.  The action
   required MAY be carried out by the user agent without interaction
   with the user if and only if the method used in the second request is
   GET or HEAD. A client SHOULD detect infinite redirection loops, since
   such loops generate network traffic for each redirection.

      Note: previous versions of this specification recommended a
      maximum of five redirections. Content developers should be aware
      that there might be clients that implement such a fixed
      limitation.</source>
          <target state="translated">Данный класс кода статуса указывает на то,что для выполнения запроса необходимо дальнейшее действие агента пользователя.Действие,требующееся MAY,должно быть выполнено агентом пользователя без взаимодействия с пользователем,если и только если метод,используемый во втором запросе-GET или HEAD.Клиент ДОЛЖЕН обнаруживать бесконечные циклы перенаправления,так как такие циклы генерируют сетевой трафик для каждого перенаправления.Замечание:в предыдущих версиях этой спецификации было рекомендовано не более пяти перенаправлений.Разработчики содержимого должны знать,что могут быть клиенты,которые реализуют такое фиксированное ограничение.</target>
        </trans-unit>
        <trans-unit id="dbcc4967400bddc90f0377f2e1ba98fce661236c" translate="yes" xml:space="preserve">
          <source>This class of status code indicates that the client's request was
   successfully received, understood, and accepted.</source>
          <target state="translated">Данный класс кода статуса указывает на то,что запрос клиента был успешно принят,понят и принят.</target>
        </trans-unit>
        <trans-unit id="aa0eac6f65fb6440a25f249695197fc412fc43a4" translate="yes" xml:space="preserve">
          <source>This code indicates that the server has received and is processing the request, but no response is available yet.</source>
          <target state="translated">Этот код указывает на то,что сервер получил и обрабатывает запрос,но ответа пока нет.</target>
        </trans-unit>
        <trans-unit id="3a6a8f72886b84a7449d24f613f3e53c70e794a8" translate="yes" xml:space="preserve">
          <source>This code is reserved for future use.</source>
          <target state="translated">Этот код зарезервирован для дальнейшего использования.</target>
        </trans-unit>
        <trans-unit id="ffadfb15e2eb2fc2bbccd496410791acc5ffa9e9" translate="yes" xml:space="preserve">
          <source>This code is sent in response to an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header by the client, and indicates the protocol the server is switching to.</source>
          <target state="translated">Этот код отправляется клиентом в ответ на заголовок запроса на &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; и указывает протокол, на который переключается сервер.</target>
        </trans-unit>
        <trans-unit id="b0827e7feb1318caf938fa97aff681eecc88f25e" translate="yes" xml:space="preserve">
          <source>This code is similar to 401 (Unauthorized), but indicates that the
   client must first authenticate itself with the proxy. The proxy MUST
   return a Proxy-Authenticate header field (&lt;a href=&quot;#section-14.33&quot;&gt;section 14.33&lt;/a&gt;) containing a
   challenge applicable to the proxy for the requested resource. The
   client MAY repeat the request with a suitable Proxy-Authorization
   header field (&lt;a href=&quot;#section-14.34&quot;&gt;section 14.34&lt;/a&gt;). HTTP access authentication is explained
   in &quot;HTTP Authentication: Basic and Digest Access Authentication&quot;
   [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;].</source>
          <target state="translated">Этот код похож на 401 (Неавторизованный), но указывает, что клиент должен сначала аутентифицироваться с помощью прокси. Прокси-сервер ДОЛЖЕН вернуть поле заголовка Proxy-Authenticate ( &lt;a href=&quot;#section-14.33&quot;&gt;раздел 14.33&lt;/a&gt; ), содержащее запрос, применимый к прокси для запрошенного ресурса. Клиент МОЖЕТ повторить запрос с подходящим полем заголовка Proxy-Authorization ( &lt;a href=&quot;#section-14.34&quot;&gt;раздел 14.34&lt;/a&gt; ). Аутентификация доступа HTTP объясняется в разделе &amp;laquo;Аутентификация HTTP: базовая и дайджест-аутентификация доступа&amp;raquo; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="a79aa67f6b67e62ec228c4830d6fa231aff1cf84" translate="yes" xml:space="preserve">
          <source>This design technique involves developing your Web site in 'layers', using a bottom-up approach, starting with a simpler layer and improving the capabilities of the site in successive layers, each using more features.</source>
          <target state="translated">Этот метод проектирования включает в себя разработку вашего веб сайта в &quot;слоях&quot;,используя подход &quot;снизу вверх&quot;,начиная с более простого слоя и улучшая возможности сайта в последовательных слоях,каждый из которых использует больше возможностей.</target>
        </trans-unit>
        <trans-unit id="c4f2bfc459cbc9d47da09ed899ca07996d8c748f" translate="yes" xml:space="preserve">
          <source>This directive is meaningless for the Public-Key-Pins-Report-Only header, it will be ignored by user agents and the header will not be cached.</source>
          <target state="translated">Эта директива бессмысленна для заголовка Public-Key-Pins-Report-Only,она будет игнорироваться пользовательскими агентами и заголовок не будет кэшироваться.</target>
        </trans-unit>
        <trans-unit id="f32511f74b3172e453c0eb1a2d75c8552c9a2edb" translate="yes" xml:space="preserve">
          <source>This directive is not supported in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element or by the &lt;a href=&quot;../content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-policy-Report-Only&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">Эта директива не поддерживается в элементе &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; или в поле заголовка &lt;a href=&quot;../content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-policy-Report-Only&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d0590723290af17baff140ec8796150f9341847" translate="yes" xml:space="preserve">
          <source>This directive is not supported in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">Эта директива не поддерживается в элементе &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b819d9b6f80f6df35168312b4868b28bd76e9d1" translate="yes" xml:space="preserve">
          <source>This document describes an extension to the HTTP/1.1 protocol that
   allows clients to perform remote Web content authoring operations.
   This extension provides a coherent set of methods, headers, request
   entity body formats, and response entity body formats that provide
   operations for:

   Properties: The ability to create, remove, and query information
   about Web pages, such as their authors, creation dates, etc.

   Collections: The ability to create sets of documents and to retrieve
   a hierarchical membership listing (like a directory listing in a file
   system).

   Locking: The ability to keep more than one person from working on a
   document at the same time.  This prevents the &quot;lost update problem&quot;,
   in which modifications are lost as first one author, then another,
   writes changes without merging the other author's changes.

   Namespace Operations: The ability to instruct the server to copy and
   move Web resources, operations that change the mapping from URLs to
   resources.

   Requirements and rationale for these operations are described in a
   companion document, &quot;Requirements for a Distributed Authoring and
   Versioning Protocol for the World Wide Web&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt;].

   This document does not specify the versioning operations suggested by
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt;].  That work was done in a separate document, &quot;Versioning
   Extensions to WebDAV&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;].

   The sections below provide a detailed introduction to various WebDAV
   abstractions: resource properties (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), collections of
   resources (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;), locks (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;) in general, and write locks
   (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) specifically.

   These abstractions are manipulated by the WebDAV-specific HTTP
   methods (&lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;) and the extra HTTP headers (&lt;a href=&quot;#section-10&quot;&gt;Section 10&lt;/a&gt;) used with
   WebDAV methods.  General considerations for handling HTTP requests
   and responses in WebDAV are found in &lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;.

   While the status codes provided by HTTP/1.1 are sufficient to
   describe most error conditions encountered by WebDAV methods, there
   are some errors that do not fall neatly into the existing categories.
   This specification defines extra status codes developed for WebDAV
   methods (&lt;a href=&quot;#section-11&quot;&gt;Section 11&lt;/a&gt;) and describes existing HTTP status codes
   (&lt;a href=&quot;#section-12&quot;&gt;Section 12&lt;/a&gt;) as used in WebDAV.  Since some WebDAV methods may 

   operate over many resources, the Multi-Status response (&lt;a href=&quot;#section-13&quot;&gt;Section 13&lt;/a&gt;)
   has been introduced to return status information for multiple
   resources.  Finally, this version of WebDAV introduces precondition
   and postcondition (&lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;) XML elements in error response bodies.

   WebDAV uses XML ([&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]) for property names and some values, and
   also uses XML to marshal complicated requests and responses.  This
   specification contains DTD and text definitions of all properties
   (&lt;a href=&quot;#section-15&quot;&gt;Section 15&lt;/a&gt;) and all other XML elements (&lt;a href=&quot;#section-14&quot;&gt;Section 14&lt;/a&gt;) used in
   marshalling.  WebDAV includes a few special rules on extending WebDAV
   XML marshalling in backwards-compatible ways (&lt;a href=&quot;#section-17&quot;&gt;Section 17&lt;/a&gt;).

   Finishing off the specification are sections on what it means for a
   resource to be compliant with this specification (&lt;a href=&quot;#section-18&quot;&gt;Section 18&lt;/a&gt;), on
   internationalization support (&lt;a href=&quot;#section-19&quot;&gt;Section 19&lt;/a&gt;), and on security
   (&lt;a href=&quot;#section-20&quot;&gt;Section 20&lt;/a&gt;).</source>
          <target state="translated">В этом документе описывается расширение протокола HTTP / 1.1, которое позволяет клиентам выполнять удаленные операции создания веб-контента. Это расширение предоставляет согласованный набор методов, заголовков, форматов тела объекта запроса и форматов тела объекта ответа, которые обеспечивают операции для: Свойства: возможность создавать, удалять и запрашивать информацию о веб-страницах, такую ​​как их авторы, даты создания, Коллекции: возможность создавать наборы документов и получать иерархический список членства (например, список каталогов в файловой системе). Блокировка: возможность запретить нескольким людям работать над документом одновременно. Это предотвращает &amp;laquo;проблему потери обновлений&amp;raquo;, при которой изменения теряются сначала одним автором, затем другим,записывает изменения без объединения изменений других авторов. Операции пространства имен: возможность указать серверу копировать и перемещать веб-ресурсы, операции, которые изменяют отображение URL-адресов на ресурсы. Требования и обоснование этих операций описаны в сопутствующем документе &amp;laquo;Требования к протоколу распределенной разработки и управления версиями для World Wide Web&amp;raquo; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt; ]. В этом документе не указаны операции управления версиями, предлагаемые [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt; ]. Эта работа была выполнена в отдельном документе &amp;laquo;Расширения управления версиями для WebDAV&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ]. В следующих разделах представлено подробное введение в различные абстракции WebDAV: свойства ресурсов ( &lt;a href=&quot;#section-4&quot;&gt;раздел 4&lt;/a&gt; ), коллекции ресурсов ( &lt;a href=&quot;#section-5&quot;&gt;раздел 5&lt;/a&gt; ), блокировки ( &lt;a href=&quot;#section-6&quot;&gt;раздел 6&lt;/a&gt; ) в целом и блокировки записи ( &lt;a href=&quot;#section-7&quot;&gt;раздел 7&lt;/a&gt; ) в частности. Эти абстракции управляются специфичными для WebDAV HTTP-методами ( &lt;a href=&quot;#section-9&quot;&gt;раздел 9&lt;/a&gt; ) и дополнительными заголовками HTTP ( &lt;a href=&quot;#section-10&quot;&gt;раздел 10&lt;/a&gt;), используемый с методами WebDAV. Общие рекомендации по обработке HTTP-запросов и ответов в WebDAV можно найти в &lt;a href=&quot;#section-8&quot;&gt;Разделе 8&lt;/a&gt; . Хотя кодов состояния, предоставляемых HTTP / 1.1, достаточно для описания большинства условий ошибок, с которыми сталкиваются методы WebDAV, есть некоторые ошибки, которые не попадают в существующие категории. Эта спецификация определяет дополнительные коды состояния, разработанные для методов WebDAV ( &lt;a href=&quot;#section-11&quot;&gt;раздел 11&lt;/a&gt; ), и описывает существующие коды состояния HTTP ( &lt;a href=&quot;#section-12&quot;&gt;раздел 12&lt;/a&gt; ), используемые в WebDAV. Поскольку некоторые методы WebDAV могут работать с множеством ресурсов, ответ Multi-Status ( &lt;a href=&quot;#section-13&quot;&gt;раздел 13&lt;/a&gt;) был введен для возврата информации о состоянии для нескольких ресурсов. Наконец, эта версия WebDAV вводит элементы XML предусловия и постусловия ( &lt;a href=&quot;#section-16&quot;&gt;раздел 16&lt;/a&gt; ) в телах ответов об ошибках. WebDAV использует XML ([ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ]) для имен свойств и некоторых значений, а также использует XML для упорядочивания сложных запросов и ответов. Эта спецификация содержит DTD и текстовые определения всех свойств ( &lt;a href=&quot;#section-15&quot;&gt;раздел 15&lt;/a&gt; ) и всех других элементов XML ( &lt;a href=&quot;#section-14&quot;&gt;раздел 14&lt;/a&gt; ), используемых при маршалинге. WebDAV включает несколько специальных правил по расширению маршаллинга WebDAV XML обратно совместимыми способами ( &lt;a href=&quot;#section-17&quot;&gt;Раздел 17&lt;/a&gt;). Завершают спецификацию разделы о том, что означает соответствие ресурса этой спецификации ( &lt;a href=&quot;#section-18&quot;&gt;раздел 18&lt;/a&gt; ), о поддержке интернационализации ( &lt;a href=&quot;#section-19&quot;&gt;раздел 19&lt;/a&gt; ) и безопасности ( &lt;a href=&quot;#section-20&quot;&gt;раздел 20&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d12cc0f3aacd5b3de7f5ba6d1f64c9e830a68a99" translate="yes" xml:space="preserve">
          <source>This document describes the user agent string used in Firefox 4 and later and applications based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 and later. For a breakdown of changes to the string in Gecko 2.0, see &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Final User Agent string for Firefox 4&lt;/a&gt; (blog post). See also this document on &lt;a href=&quot;../../browser_detection_using_the_user_agent&quot;&gt;user agent sniffing&lt;/a&gt; and this &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks blog post&lt;/a&gt;.</source>
          <target state="translated">В этом документе описывается строка пользовательского агента, используемая в Firefox 4 и новее, а также в приложениях, основанных на &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 и новее. Подробную информацию об изменениях строки в Gecko 2.0 см. В разделе &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Окончательная строка агента пользователя для Firefox 4&lt;/a&gt; (сообщение в блоге). См. Также этот документ о &lt;a href=&quot;../../browser_detection_using_the_user_agent&quot;&gt;сниффинге пользовательских агентов&lt;/a&gt; и этот &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;пост в блоге Hacks&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="77d126757eafa5a2c1ec7b146581b7a094dfa302" translate="yes" xml:space="preserve">
          <source>This document describes the user agent string used in Firefox 4 and later and applications based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 and later. For a breakdown of changes to the string in Gecko 2.0, see &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Final User Agent string for Firefox 4&lt;/a&gt; (blog post). See also this document on &lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;user agent sniffing&lt;/a&gt; and this &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks blog post&lt;/a&gt;.</source>
          <target state="translated">В этом документе описывается строка пользовательского агента, используемая в Firefox 4 и новее, а также в приложениях, основанных на &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 и новее. Подробную информацию об изменениях строки в Gecko 2.0 см. В разделе &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Окончательная строка агента пользователя для Firefox 4&lt;/a&gt; (сообщение в блоге). См. Также этот документ о &lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;сниффинге пользовательских агентов&lt;/a&gt; и этот &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;пост в блоге Hacks&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e83d25b1239accfb20c5eb5ac032a6055e8ac00e" translate="yes" xml:space="preserve">
          <source>This edition of HTTP/1.1 builds on the many contributions that went
   into &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, including
   substantial contributions made by the previous authors, editors, and
   Working Group Chairs: Tim Berners-Lee, Ari Luotonen, Roy T. Fielding,
   Henrik Frystyk Nielsen, Jim Gettys, Jeffrey C. Mogul, Larry Masinter,
   and Paul J. Leach.  Mark Nottingham oversaw this effort as Working
   Group Chair.

   Since 1999, the following contributors have helped improve the HTTP
   specification by reporting bugs, asking smart questions, drafting or
   reviewing text, and evaluating open issues:

   Adam Barth, Adam Roach, Addison Phillips, Adrian Chadd, Adrian Cole,
   Adrien W. de Croy, Alan Ford, Alan Ruttenberg, Albert Lunde, Alek
   Storm, Alex Rousskov, Alexandre Morgaut, Alexey Melnikov, Alisha
   Smith, Amichai Rothman, Amit Klein, Amos Jeffries, Andreas Maier,
   Andreas Petersson, Andrei Popov, Anil Sharma, Anne van Kesteren,
   Anthony Bryan, Asbjorn Ulsberg, Ashok Kumar, Balachander
   Krishnamurthy, Barry Leiba, Ben Laurie, Benjamin Carlyle, Benjamin
   Niven-Jenkins, Benoit Claise, Bil Corry, Bill Burke, Bjoern
   Hoehrmann, Bob Scheifler, Boris Zbarsky, Brett Slatkin, Brian Kell,
   Brian McBarron, Brian Pane, Brian Raymor, Brian Smith, Bruce Perens,
   Bryce Nesbitt, Cameron Heavon-Jones, Carl Kugler, Carsten Bormann,
   Charles Fry, Chris Burdess, Chris Newman, Christian Huitema, Cyrus
   Daboo, Dale Robert Anderson, Dan Wing, Dan Winship, Daniel Stenberg,
   Darrel Miller, Dave Cridland, Dave Crocker, Dave Kristol, Dave
   Thaler, David Booth, David Singer, David W. Morris, Diwakar Shetty,
   Dmitry Kurochkin, Drummond Reed, Duane Wessels, Edward Lee, Eitan
   Adler, Eliot Lear, Emile Stephan, Eran Hammer-Lahav, Eric D.
   Williams, Eric J. Bowman, Eric Lawrence, Eric Rescorla, Erik
   Aronesty, EungJun Yi, Evan Prodromou, Felix Geisendoerfer, Florian
   Weimer, Frank Ellermann, Fred Akalin, Fred Bohle, Frederic Kayser,
   Gabor Molnar, Gabriel Montenegro, Geoffrey Sneddon, Gervase Markham,
   Gili Tzabari, Grahame Grieve, Greg Slepak, Greg Wilkins, Grzegorz
   Calkowski, Harald Tveit Alvestrand, Harry Halpin, Helge Hess, Henrik
   Nordstrom, Henry S. Thompson, Henry Story, Herbert van de Sompel,
   Herve Ruellan, Howard Melman, Hugo Haas, Ian Fette, Ian Hickson, Ido
   Safruti, Ilari Liusvaara, Ilya Grigorik, Ingo Struck, J. Ross Nicoll,
   James Cloos, James H. Manger, James Lacey, James M. Snell, Jamie 

   Lokier, Jan Algermissen, Jari Arkko, Jeff Hodges (who came up with
   the term 'effective Request-URI'), Jeff Pinner, Jeff Walden, Jim
   Luther, Jitu Padhye, Joe D. Williams, Joe Gregorio, Joe Orton, Joel
   Jaeggli, John C. Klensin, John C. Mallery, John Cowan, John Kemp,
   John Panzer, John Schneider, John Stracke, John Sullivan, Jonas
   Sicking, Jonathan A. Rees, Jonathan Billington, Jonathan Moore,
   Jonathan Silvera, Jordi Ros, Joris Dobbelsteen, Josh Cohen, Julien
   Pierre, Jungshik Shin, Justin Chapweske, Justin Erenkrantz, Justin
   James, Kalvinder Singh, Karl Dubost, Kathleen Moriarty, Keith
   Hoffman, Keith Moore, Ken Murchison, Koen Holtman, Konstantin
   Voronkov, Kris Zyp, Leif Hedstrom, Lionel Morand, Lisa Dusseault,
   Maciej Stachowiak, Manu Sporny, Marc Schneider, Marc Slemko, Mark
   Baker, Mark Pauley, Mark Watson, Markus Isomaki, Markus Lanthaler,
   Martin J. Duerst, Martin Musatov, Martin Nilsson, Martin Thomson,
   Matt Lynch, Matthew Cox, Matthew Kerwin, Max Clark, Menachem Dodge,
   Meral Shirazipour, Michael Burrows, Michael Hausenblas, Michael
   Scharf, Michael Sweet, Michael Tuexen, Michael Welzl, Mike Amundsen,
   Mike Belshe, Mike Bishop, Mike Kelly, Mike Schinkel, Miles Sabin,
   Murray S. Kucherawy, Mykyta Yevstifeyev, Nathan Rixham, Nicholas
   Shanks, Nico Williams, Nicolas Alvarez, Nicolas Mailhot, Noah Slater,
   Osama Mazahir, Pablo Castro, Pat Hayes, Patrick R. McManus, Paul E.
   Jones, Paul Hoffman, Paul Marquess, Pete Resnick, Peter Lepeska,
   Peter Occil, Peter Saint-Andre, Peter Watkins, Phil Archer, Phil
   Hunt, Philippe Mougin, Phillip Hallam-Baker, Piotr Dobrogost, Poul-
   Henning Kamp, Preethi Natarajan, Rajeev Bector, Ray Polk, Reto
   Bachmann-Gmuer, Richard Barnes, Richard Cyganiak, Rob Trace, Robby
   Simpson, Robert Brewer, Robert Collins, Robert Mattson, Robert
   O'Callahan, Robert Olofsson, Robert Sayre, Robert Siemer, Robert de
   Wilde, Roberto Javier Godoy, Roberto Peon, Roland Zink, Ronny
   Widjaja, Ryan Hamilton, S. Mike Dierken, Salvatore Loreto, Sam
   Johnston, Sam Pullara, Sam Ruby, Saurabh Kulkarni, Scott Lawrence
   (who maintained the original issues list), Sean B. Palmer, Sean
   Turner, Sebastien Barnoud, Shane McCarron, Shigeki Ohtsu, Simon
   Yarde, Stefan Eissing, Stefan Tilkov, Stefanos Harhalakis, Stephane
   Bortzmeyer, Stephen Farrell, Stephen Kent, Stephen Ludin, Stuart
   Williams, Subbu Allamaraju, Subramanian Moonesamy, Susan Hares,
   Sylvain Hellegouarch, Tapan Divekar, Tatsuhiro Tsujikawa, Tatsuya
   Hayashi, Ted Hardie, Ted Lemon, Thomas Broyer, Thomas Fossati, Thomas
   Maslen, Thomas Nadeau, Thomas Nordin, Thomas Roessler, Tim Bray, Tim
   Morgan, Tim Olsen, Tom Zhou, Travis Snoozy, Tyler Close, Vincent
   Murphy, Wenbo Zhu, Werner Baumann, Wilbur Streett, Wilfredo Sanchez
   Vega, William A. Rowe Jr., William Chan, Willy Tarreau, Xiaoshu Wang,
   Yaron Goland, Yngve Nysaeter Pettersen, Yoav Nir, Yogesh Bang,
   Yuchung Cheng, Yutaka Oiwa, Yves Lafon (long-time member of the
   editor team), Zed A. Shaw, and Zhong Yu.

   See &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-16&quot;&gt;Section&amp;nbsp;16 of [RFC2616]&lt;/a&gt; for additional acknowledgements from
   prior revisions.</source>
          <target state="translated">Эта редакция HTTP / 1.1 основана на многих материалах, внесенных в &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; и &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616.&lt;/a&gt;, включая существенный вклад предыдущих авторов, редакторов и председателей рабочих групп: Тима Бернерса-Ли, Ари Луотонена, Роя Т. Филдинга, Хенрика Фристика Нильсена, Джима Геттиса, Джеффри С. Могула, Ларри Масинтера и Пола Дж. Лича. , Марк Ноттингем курировал эту работу как председатель Рабочей группы. С 1999 года следующие участники помогли улучшить спецификацию HTTP, сообщая об ошибках, задавая умные вопросы, составляя или просматривая текст и оценивая открытые проблемы: Адам Барт, Адам Роуч, Аддисон Филлипс, Адриан Чадд, Адриан Коул, Адриен В. де Крой. , Алан Форд, Алан Руттенберг, Альберт Лунде, Алек Сторм, Алекс Руссков, Александр Морго, Алексей Мельников, Алиша Смит, Амихай Ротман, Амит Кляйн, Амос Джеффрис, Андреас Майер, Андреас Петерссон, Андрей Попов, Анил Шарма, Энн ван Кестерен,Энтони Брайан, Асбьерн Ульсберг, Ашок Кумар, Балачандер Кришнамурти, Барри Лейба, Бен Лори, Бенджамин Карлайл, Бенджамин Нивен-Дженкинс, Бенуа Клез, Бил Корри, Билл Берк, Бьорн Хёрманн, Боб Шайфлер, Борис Затбарс, Боб Шайфлер, Борис Затбарс, Брайан МакБаррон, Брайан Пейн, Брайан Реймор, Брайан Смит, Брюс Перенс, Брайс Несбитт, Кэмерон Хивон-Джонс, Карл Куглер, Карстен Борман, Чарльз Фрай, Крис Бердесс, Крис Ньюман, Кристиан Хайтема, Сайрус Дабу, Дейл Роберт Андерсон, Дэн Винг , Дэн Уиншип, Дэниел Стенберг, Даррел Миллер, Дэйв Кридленд, Дэйв Крокер, Дэйв Кристол, Дэйв Талер, Дэвид Бут, Дэвид Сингер, Дэвид В. Моррис, Дивакар Шетти, Дмитрий Курочкин, Драммонд Рид, Дуэйн Весселс, Эдвард Ли, Эйтан Адлер , Элиот Лир, Эмиль Стефан, Эран Хаммер-Лахав, Эрик Д. Уильямс, Эрик Дж. Боуман,Эрик Лоуренс, Эрик Рескорла, Эрик Аронести, Юнг Джун Йи, Эван Продрому, Феликс Гайзендорфер, Флориан Веймер, Фрэнк Эллерманн, Фред Акалин, Фред Боле, Фредерик Кайзер, Габор Молнар, Габриэль Монтенегро, Джеффри Снеддон, Грэливас Гайзендерфер, Гиливас Маркамари, , Грег Слепак, Грег Уилкинс, Гжегож Кальковски, Харальд Твейт Альвестранд, Гарри Халпин, Хельге Хесс, Хенрик Нордстром, Генри С. Томпсон, Генри Стори, Герберт ван де Сомпель, Эрве Руллан, Говард Мелман, Хьюго Хаас, Ян Фетте, Ян Хиксон , Идо Сафрути, Илари Лиусваара, Илья Григорик, Инго Страк, Дж. Росс Николл, Джеймс Клоос, Джеймс Х. Мангер, Джеймс Лейси, Джеймс М. Снелл, Джейми Локьер, Ян Алджермиссен, Яри Аркко, Джефф Ходжес (кто придумал термин &amp;laquo;эффективный запрос-URI&amp;raquo;), Джефф Пиннер, Джефф Уолден, Джим Лютер, Джиту Падхай, Джо Д. Уильямс,Джо Грегорио, Джо Ортон, Джоэл Джеггли, Джон К. Кленсин, Джон К. Маллери, Джон Коуэн, Джон Кемп, Джон Пэнзер, Джон Шнайдер, Джон Стрэк, Джон Салливан, Джонас Сикинг, Джонатан А. Рис, Джонатан Биллингтон, Джонатан Мур , Джонатан Сильвера, Хорди Рос, Джорис Доббелстин, Джош Коэн, Жюльен Пьер, Юнгшик Шин, Джастин Чапвеске, Джастин Эренкранц, Джастин Джеймс, Кальвиндер Сингх, Карл Дубост, Кэтлин Мориарти, Кейт Хоффман, Кейт Мур, Кен Мерчисон, Констант Холт Воронков, Крис Зип, Лейф Хедстром, Лайонел Моран, Лиза Дюссо, Мацей Стаховяк, Ману Спорни, Марк Шнайдер, Марк Слемко, Марк Бейкер, Марк Поли, Марк Уотсон, Маркус Исомаки, Маркус Ланталер, Мартин Дж. Дюрст, Мартин Мусатов, Мартин Нильссон, Мартин Томсон, Мэтт Линч, Мэттью Кокс, Мэттью Кервин, Макс Кларк, Менахем Додж,Мерал Ширазипур, Майкл Берроуз, Майкл Хаузенблас, Майкл Шарф, Майкл Свит, Майкл Туэксен, Майкл Велцль, Майк Амундсен, Майк Белше, Майк Бишоп, Майк Келли, Майк Шинкель, Майлз Сабин, Мюррей С. Кучерави, Микита Евстифефеев, Натан Рикшифамев Николас Шэнкс, Нико Уильямс, Николас Альварес, Николас Мэйлхот, Ноа Слейтер, Осама Мазахир, Пабло Кастро, Пэт Хейс, Патрик Р. Макманус, Пол Э. Джонс, Пол Хоффман, Пол Маркиз, Пит Резник, Питер Лепеска, Питер Окцил, Питер Сен-Андре, Питер Уоткинс, Фил Арчер, Фил Хант, Филипп Мужен, Филипп Халлам-Бейкер, Петр Доброгост, Пол-Хеннинг Камп, Прити Натараджан, Раджив Бектор, Рэй Полк, Рето Бахманн-Гмуер, Ричард Барнс, Ричард Циганиак, Роб Трэйс, Робби Симпсон, Роберт Брюэр, Роберт Коллинз, Роберт Мэтсон, Роберт О'Каллахан,Роберт Олофссон, Роберт Сэйр, Роберт Симер, Роберт де Вильде, Роберто Хавьер Годой, Роберто Пеон, Роланд Зинк, Ронни Виджаджа, Райан Гамильтон, С. Майк Диркен, Сальваторе Лорето, Сэм Джонстон, Сэм Пуллара, Сэм Руби, Саураб Кулкарни, Скотт Лоуренс (который поддерживал исходный список проблем), Шон Б. Палмер, Шон Тернер, Себастьян Барноуд, Шейн Маккаррон, Шигеки Оцу, Саймон Ярде, Стефан Эйссинг, Стефан Тилков, Стефанос Хархалакис, Стефан Борцмайер, Стивен Фаррелл, Стивен Кент, Стивен , Стюарт Уильямс, Суббу Алламараджу, Субраманиан Мунсами, Сьюзан Харес, Сильвен Хеллегуарх, Тапан Дивекар, Тацухиро Цуджикава, Тацуя Хаяси, Тед Харди, Тед Лемон, Томас Бройер, Томас Фоссати, Томас Маслен, Томас Надо, Томас Нордин, Томас Рёсслер Брей, Тим Морган, Тим Олсен, Том Чжоу, Трэвис Снузи,Тайлер Клоуз, Винсент Мерфи, Венбо Чжу, Вернер Бауман, Уилбур Стрит, Уилфредо Санчес Вега, Уильям А. Роу-младший, Уильям Чан, Вилли Тарро, Сяошу Ван, Ярон Голанд, Ингве Нисетер Петтерсен, Йоав Нир, Йогеш Ченг Банг, Ючунг , Ютака Оива, Ив Лафон (давний член редакционной группы), Зед А. Шоу и Чжун Ю. Видеть&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-16&quot;&gt;Раздел 16 [RFC2616] содержит&lt;/a&gt; дополнительную информацию о предыдущих изменениях.</target>
        </trans-unit>
        <trans-unit id="ee24423cc6a36dea3e2a80b1cc45bcc1e29b0c7b" translate="yes" xml:space="preserve">
          <source>This error can also occur if the response includes more than one &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header.</source>
          <target state="translated">Эта ошибка также может возникнуть, если ответ включает более одного заголовка &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e1d7d044ce568115a051e7914a52c456d823802" translate="yes" xml:space="preserve">
          <source>This error means that the document was not loaded at the top level of an user-opened or noopener-opened tab or window. It can occur in these situations:</source>
          <target state="translated">Данная ошибка означает,что документ не был загружен на верхнем уровне открытой пользователем или не открывшейся вкладки или окна.Это может произойти в таких ситуациях:</target>
        </trans-unit>
        <trans-unit id="1884120a66eaf56447e8f0aecbc8de6969d27e9d" translate="yes" xml:space="preserve">
          <source>This error response is a generic &quot;catch-all&quot; response. Sometimes, server administrators log error responses like the 500 status code with more details about the request to prevent the error from happening again in the future.</source>
          <target state="translated">Эта реакция на ошибку является общей реакцией &quot;catch-all&quot;.Иногда администраторы сервера записывают в журнал ответы на ошибки,такие как код состояния 500 с более подробной информацией о запросе,чтобы предотвратить повторение ошибки в будущем.</target>
        </trans-unit>
        <trans-unit id="9439e46ba591022a7d8217b7752ce9ccbf400eb2" translate="yes" xml:space="preserve">
          <source>This error response is given when the server is acting as a gateway and cannot get a response in time.</source>
          <target state="translated">Этот ответ об ошибке дается,когда сервер действует как шлюз и не может получить ответ вовремя.</target>
        </trans-unit>
        <trans-unit id="eab61895b7f6d33786618e886763053a4551a6b6" translate="yes" xml:space="preserve">
          <source>This error response means that the server, while working as a gateway to get a response needed to handle the request, got an invalid response.</source>
          <target state="translated">Этот ответ об ошибке означает,что сервер,работая в качестве шлюза для получения ответа,необходимого для обработки запроса,получил ошибочный ответ.</target>
        </trans-unit>
        <trans-unit id="f68650d4dca44929b9f30e96e89144cfc0f2f700" translate="yes" xml:space="preserve">
          <source>This error shouldn't happen on well-tested production systems, but can be found more often while testing a new system.</source>
          <target state="translated">Такая ошибка не должна возникать на хорошо протестированных производственных системах,но чаще встречается при тестировании новой системы.</target>
        </trans-unit>
        <trans-unit id="483909e9171e2699ed78d6021cf1843f1935c891" translate="yes" xml:space="preserve">
          <source>This evolution of HTTP proves its extensibility and simplicity, liberating creation of many applications and compelling the adoption of the protocol. The environment in which HTTP is used today is quite different from that seen in the early 1990s. HTTP's original design proved to be a masterpiece, allowing the Web to evolve over a quarter of a century, without the need of a mutiny. By healing flaws, yet retaining the flexibility and extensibility which made HTTP such a success, the adoption of HTTP/2 hints at a bright future for the protocol.</source>
          <target state="translated">Эта эволюция HTTP доказывает свою расширяемость и простоту,освобождая создание многих приложений и заставляя принять протокол.Среда,в которой сегодня используется HTTP,сильно отличается от той,что была в начале 1990-х годов.Оригинальный дизайн HTTP оказался шедевром,позволившим Вебу развиваться более четверти века без необходимости мятежа.Исцеляя недостатки,сохраняя при этом гибкость и расширяемость,которые сделали HTTP таким успешным,принятие HTTP/2 намекает на светлое будущее протокола.</target>
        </trans-unit>
        <trans-unit id="781912733ac5a2c031d25e3e8b5988cba0dcdce0" translate="yes" xml:space="preserve">
          <source>This example allows &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; content on a particular origin to access the user's location:</source>
          <target state="translated">Этот пример позволяет контенту &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; из определенного источника получить доступ к местоположению пользователя:</target>
        </trans-unit>
        <trans-unit id="ca8e2b99c120ccf6c9a6bffe95a381cde5380542" translate="yes" xml:space="preserve">
          <source>This example creates a collection called /webdisc/xfiles/ on the
   server www.example.com. 

   &amp;gt;&amp;gt;Request

     MKCOL /webdisc/xfiles/ HTTP/1.1
     Host: www.example.com


   &amp;gt;&amp;gt;Response

     HTTP/1.1 201 Created</source>
          <target state="translated">В этом примере создается коллекция с именем / webdisc / xfiles / на сервере www.example.com. &amp;gt;&amp;gt; Запрос MKCOL / webdisc / xfiles / HTTP / 1.1 Хост: www.example.com &amp;gt;&amp;gt; Ответ HTTP / 1.1 201 Создан</target>
        </trans-unit>
        <trans-unit id="6c2ce892d1c3a6298b72aa271eaca87af850694a" translate="yes" xml:space="preserve">
          <source>This example is more sophisticated. There are four (4) proxy servers; one of them is a hot stand-by for all of the other ones, so if any of the remaining three goes down the fourth one will take over. Furthermore, the three remaining proxy servers share the load based on URL patterns, which makes their caching more effective (there is only one copy of any document on the three servers -- as opposed to one copy on each of them). The load is distributed like this:</source>
          <target state="translated">Этот пример более сложный.Существует четыре (4)прокси-сервера;один из них находится в горячем резерве для всех остальных,так что если любой из оставшихся трех прокси-серверов пойдет вниз,то четвертый возьмет на себя ответственность.Более того,три оставшихся прокси-сервера делят нагрузку на основе шаблонов URL,что делает их кэширование более эффективным (на трех серверах есть только одна копия любого документа-в отличие от одной копии на каждом из них).Нагрузка распределяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="f8d7c446d07bc06ec9ae31c4aecccef522ea44ec" translate="yes" xml:space="preserve">
          <source>This example response is taken from the IETF RFC (see below) and contains a reference to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monty_Python's_Life_of_Brian&quot;&gt;Monty Python's Life of Brian&lt;/a&gt;.</source>
          <target state="translated">Этот пример ответа взят из IETF RFC (см. Ниже) и содержит ссылку на &lt;a href=&quot;https://en.wikipedia.org/wiki/Monty_Python's_Life_of_Brian&quot;&gt;книгу Монти Пайтон &amp;laquo;Жизнь Брайана&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="999b4d428320409a219f5dc5012ceca8d2b38d22" translate="yes" xml:space="preserve">
          <source>This example shows &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; when it specifies support for multiple headers.</source>
          <target state="translated">Этот пример показывает &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; , когда он указывает поддержку нескольких заголовков.</target>
        </trans-unit>
        <trans-unit id="0b1f58893a7cb8a1c12815693f3befaeab5b7414" translate="yes" xml:space="preserve">
          <source>This example shows resource
   http://www.example.com/~fielding/index.html being copied to the
   location http://www.example.com/users/f/fielding/index.html.  The 204
   (No Content) status code indicates that the existing resource at the
   destination was overwritten.

   &amp;gt;&amp;gt;Request

     COPY /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example.com/users/f/fielding/index.html

   &amp;gt;&amp;gt;Response

     HTTP/1.1 204 No Content</source>
          <target state="translated">В этом примере показано, как ресурс http://www.example.com/~fielding/index.html копируется в расположение http://www.example.com/users/f/fielding/index.html. Код состояния 204 (Нет содержимого) указывает, что существующий ресурс в месте назначения был перезаписан. &amp;gt;&amp;gt; Request COPY /~fielding/index.html HTTP / 1.1 Host: www.example.com Назначение: http://www.example.com/users/f/fielding/index.html &amp;gt;&amp;gt; Response HTTP / 1.1 204 Нет содержание</target>
        </trans-unit>
        <trans-unit id="fa023a88dd9876a6752395fc5752087af07a81f6" translate="yes" xml:space="preserve">
          <source>This example shows resource
   http://www.example.com/~fielding/index.html being moved to the
   location http://www.example.com/users/f/fielding/index.html.  The
   contents of the destination resource would have been overwritten if
   the destination URL was already mapped to a resource.  In this case,
   since there was nothing at the destination resource, the response
   code is 201 (Created).

   &amp;gt;&amp;gt;Request

     MOVE /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example/users/f/fielding/index.html

   &amp;gt;&amp;gt;Response

     HTTP/1.1 201 Created
     Location: http://www.example.com/users/f/fielding/index.html</source>
          <target state="translated">В этом примере показано, как ресурс http://www.example.com/~fielding/index.html перемещается в расположение http://www.example.com/users/f/fielding/index.html. Содержимое целевого ресурса было бы перезаписано, если бы целевой URL-адрес уже был сопоставлен с ресурсом. В этом случае, поскольку на целевом ресурсе ничего не было, код ответа - 201 (Создан). &amp;gt;&amp;gt; Запрос MOVE /~fielding/index.html HTTP / 1.1 Хост: www.example.com Назначение: http: //www.example/users/f/fielding/index.html &amp;gt;&amp;gt; Response HTTP / 1.1 201 Место создания: http://www.example.com/users/f/fielding/index.html</target>
        </trans-unit>
        <trans-unit id="e00417a4554c87f42e03a721ef55ecfe0950a2cf" translate="yes" xml:space="preserve">
          <source>This example will work in an environment where the internal DNS server is set up so that it can only resolve internal host names, and the goal is to use a proxy only for hosts that aren't resolvable:</source>
          <target state="translated">Этот пример будет работать в среде,где внутренний DNS сервер настроен так,что он может разрешать только имена внутренних хостов,а целью является использование прокси только для тех хостов,которые не разрешаются:</target>
        </trans-unit>
        <trans-unit id="a76e357a372c477fb919b2dd879c8bc24b00a2e5" translate="yes" xml:space="preserve">
          <source>This extensible nature of HTTP has, over time, allowed for more control and functionality of the Web. Cache or authentication methods were functions handled early in HTTP history. The ability to relax the &lt;em&gt;origin constraint&lt;/em&gt;, by contrast, has only been added in the 2010s.</source>
          <target state="translated">Эта расширяемая природа HTTP со временем позволила расширить контроль и функциональность Интернета. Кэширование или методы аутентификации были функциями, которые обрабатывались на ранних этапах истории HTTP. Возможность ослабить &lt;em&gt;ограничение происхождения&lt;/em&gt; , напротив, была добавлена ​​только в 2010-х годах.</target>
        </trans-unit>
        <trans-unit id="60964c2acb63a5e80056aab53d36efc81e0dae97" translate="yes" xml:space="preserve">
          <source>This feature has been removed from the Web standards. Though some browsers may still support it, it is in the process of being dropped. Avoid using it and update existing code if possible; see the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.</source>
          <target state="translated">Эта функция была удалена из веб-стандартов. Хотя некоторые браузеры все еще могут поддерживать его, он находится в процессе удаления. Избегайте его использования и обновляйте существующий код, если это возможно; см. &lt;a href=&quot;#Browser_compatibility&quot;&gt;таблицу совместимости&lt;/a&gt; внизу этой страницы, чтобы принять решение. Имейте в виду, что эта функция может перестать работать в любое время.</target>
        </trans-unit>
        <trans-unit id="ad63cac1625affd2a84d66756a720def351fb2b3" translate="yes" xml:space="preserve">
          <source>This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.</source>
          <target state="translated">Эта функция является нестандартной и не находится на стандартной дорожке.Не используйте ее на производственных сайтах,обращенных к Сети:она будет работать не для каждого пользователя.Также могут быть большие несовместимости между реализациями и поведение может измениться в будущем.</target>
        </trans-unit>
        <trans-unit id="59314e7aec66910164f6914bdc2ab1c6bad7e1f6" translate="yes" xml:space="preserve">
          <source>This feature is obsolete. Although it may still work in some browsers, its use is discouraged since it could be removed at any time. Try to avoid using it.</source>
          <target state="translated">Эта функция устарела.Хотя она все еще может работать в некоторых браузерах,ее использование не рекомендуется,так как она может быть удалена в любой момент.Постарайтесь не использовать ее.</target>
        </trans-unit>
        <trans-unit id="bc17d0049c62a76188340a479b6da749df640b09" translate="yes" xml:space="preserve">
          <source>This fundamental article describes a typical HTTP session: what happens under the hood when you click on a link in your browser&amp;hellip;</source>
          <target state="translated">В этой фундаментальной статье описывается типичный сеанс HTTP: что происходит под капотом, когда вы нажимаете ссылку в своем браузере ...</target>
        </trans-unit>
        <trans-unit id="9f93380bea42618419d88a1e2ec92eb06b4070a2" translate="yes" xml:space="preserve">
          <source>This header can be used either with a &lt;a href=&quot;last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; validator, or with an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but not with both.</source>
          <target state="translated">Этот заголовок может использоваться либо с валидатором &lt;a href=&quot;last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; , либо с &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; , но не с обоими.</target>
        </trans-unit>
        <trans-unit id="e2108a313bc4bb54663d17af6f772b5774776cf7" translate="yes" xml:space="preserve">
          <source>This header from the server tells the client to store a cookie.</source>
          <target state="translated">Этот заголовок с сервера говорит клиенту хранить файл cookie.</target>
        </trans-unit>
        <trans-unit id="9f3041471fef5fbbbbc5c294aaefd72cf8e4b8e6" translate="yes" xml:space="preserve">
          <source>This header is a hint to be used when the server has no way of determining the language via another way, like a specific URL, that is controlled by an explicit user decision. It is recommended that the server never overrides an explicit decision. The content of the &lt;code&gt;Accept-Language&lt;/code&gt; is often out of the control of the user (like when traveling and using an Internet Cafe in a different country); the user may also want to visit a page in another language than the locale of their user interface.</source>
          <target state="translated">Этот заголовок является подсказкой, которую следует использовать, когда сервер не имеет возможности определить язык другим способом, например, с помощью определенного URL-адреса, который контролируется явным решением пользователя. Рекомендуется, чтобы сервер никогда не отменял явное решение. Содержание &lt;code&gt;Accept-Language&lt;/code&gt; часто находится вне контроля пользователя (например, когда вы путешествуете и используете интернет-кафе в другой стране); пользователь также может захотеть посетить страницу на другом языке, отличном от локали его пользовательского интерфейса.</target>
        </trans-unit>
        <trans-unit id="0e9bd72b00debb383ca11d6751998799ac99152f" translate="yes" xml:space="preserve">
          <source>This header is automatically added by clients that choose to use it; it cannot be added using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader&quot;&gt;&lt;code&gt;XMLHttpRequest.setRequestHeader()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Этот заголовок автоматически добавляется клиентами, которые решают его использовать; его нельзя добавить с помощью метода &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader&quot;&gt; &lt;code&gt;XMLHttpRequest.setRequestHeader()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4737f0640e2626ce2c86bf3453432d3e8fdff2b5" translate="yes" xml:space="preserve">
          <source>This header is not supported inside a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">Этот заголовок не поддерживается внутри элемента &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ac57abc80887b57bdf2fcf4f45fa8fc42191101" translate="yes" xml:space="preserve">
          <source>This header is required if the request has an &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Этот заголовок требуется, если запрос имеет заголовок &lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dae9e9e16dbee7cb2e940a19073f03abae67dabc" translate="yes" xml:space="preserve">
          <source>This header is used for debugging, statistics, and generating location-dependent content and by design it exposes privacy sensitive information, such as the IP address of the client. Therefore the user's privacy must be kept in mind when deploying this header.</source>
          <target state="translated">Этот заголовок используется для отладки,статистики и генерации контента,зависящего от местоположения,и по своей конструкции он раскрывает конфиденциальную информацию,такую как IP-адрес клиента.Поэтому при установке этого заголовка необходимо учитывать конфиденциальность пользователя.</target>
        </trans-unit>
        <trans-unit id="e339b1a060076bad3fa562c3df51670b4975b5b9" translate="yes" xml:space="preserve">
          <source>This header must be sent if the server responds with a &lt;a href=&quot;../status/405&quot;&gt;&lt;code&gt;405&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Method Not Allowed&lt;/code&gt; status code to indicate which request methods can be used. An empty &lt;code&gt;Allow&lt;/code&gt; header indicates that the resource allows no request methods, which might occur temporarily for a given resource, for example.</source>
          <target state="translated">Этот заголовок должен быть отправлен, если сервер отвечает кодом состояния &lt;a href=&quot;../status/405&quot;&gt; &lt;code&gt;405&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Method Not Allowed&lt;/code&gt; , чтобы указать, какие методы запроса можно использовать. Пустой заголовок &lt;code&gt;Allow&lt;/code&gt; указывает на то, что ресурс не разрешает использование методов запроса, которые могут временно применяться, например, для данного ресурса.</target>
        </trans-unit>
        <trans-unit id="65cd8f4bdbc85c57584352cda936cbf16cec5740" translate="yes" xml:space="preserve">
          <source>This header reports violations that would have occurred. You can use this to iteratively work on your content security policy. You observe how your site behaves, watching for violation reports, then choose the desired policy enforced by the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Этот заголовок сообщает о нарушениях, которые могли бы произойти. Вы можете использовать это для итеративной работы над политикой безопасности контента. Вы наблюдаете, как ведет себя ваш сайт, отслеживая сообщения о нарушениях, затем выбираете желаемую политику, применяемую заголовком &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6406ecfb1884f34413b4947c4224d8b102734485" translate="yes" xml:space="preserve">
          <source>This header was introduced by Microsoft in IE 8 as a way for webmasters to block content sniffing that was happening and could transform non-executable MIME types into executable MIME types. Since then, other browsers have introduced it, even if their MIME sniffing algorithms were less aggressive.</source>
          <target state="translated">Этот заголовок был представлен компанией Microsoft в IE 8 в качестве способа для вебмастеров блокировать прослушивание содержимого,которое происходило и могло преобразовывать не исполняемые MIME типы в исполняемые MIME типы.С тех пор его внедрили другие браузеры,даже если их алгоритмы прослушивания MIME были менее агрессивными.</target>
        </trans-unit>
        <trans-unit id="c77a8aadedd58ca97eb678dcd40675e7891feafc" translate="yes" xml:space="preserve">
          <source>This interim response indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.</source>
          <target state="translated">Этот промежуточный ответ указывает,что пока все в порядке и что клиент должен продолжить запрос или проигнорировать его,если он уже закончен.</target>
        </trans-unit>
        <trans-unit id="97f1b290f6e916924cd7cb715ba859fdd697edc8" translate="yes" xml:space="preserve">
          <source>This is a problem that most likely can only be fixed on the server side, by modifying the server's configuration to no longer send the invalid or unknown header name with the &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header. It may also be worth checking to ensure that the user agent or HTTP library you're using on the client is up-to-date.</source>
          <target state="translated">Это проблема, которая, скорее всего, может быть решена только на стороне сервера, изменив конфигурацию сервера, чтобы больше не отправлять недопустимое или неизвестное имя заголовка с заголовком &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; . Также, возможно, стоит проверить, обновлен ли пользовательский агент или HTTP-библиотека, которую вы используете на клиенте.</target>
        </trans-unit>
        <trans-unit id="5ca266f84de58335a9fa22c96177ea4b42712957" translate="yes" xml:space="preserve">
          <source>This is a problem that most likely can only be fixed on the server side, by modifying the server's configuration to no longer send the invalid or unknown method name with the &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; header. It may also be worth checking to ensure that the user agent or HTTP library you're using on the client is up-to-date.</source>
          <target state="translated">Это проблема, которая, скорее всего, может быть решена только на стороне сервера, изменив конфигурацию сервера, чтобы больше не отправлять недопустимое или неизвестное имя метода с заголовком &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; . Также, возможно, стоит проверить, обновлен ли пользовательский агент или HTTP-библиотека, которую вы используете на клиенте.</target>
        </trans-unit>
        <trans-unit id="68654c9820232d31d9835d660a42416043e4d6e6" translate="yes" xml:space="preserve">
          <source>This is a top-down approach in which you build the best possible site using all the features you want, then tweak it to make it work on older browsers. This can be harder to do, and less effective, than progressive enhancement, but may be useful in some cases.</source>
          <target state="translated">Это подход сверху вниз,в котором вы строите лучший сайт,используя все функции,которые вы хотите,а затем настроить его,чтобы заставить его работать на старых браузерах.Это может быть сложнее и менее эффективно,чем постепенное улучшение,но может быть полезно в некоторых случаях.</target>
        </trans-unit>
        <trans-unit id="ddb9ae3d96d8b78e1be6c37fe9e53f2fec150502" translate="yes" xml:space="preserve">
          <source>This is a very subjective topic it could be considered a &lt;a href=&quot;http://bikeshed.com/&quot;&gt;bikeshedding&lt;/a&gt; issue. If you wish to read deeper, please see some of the &lt;a href=&quot;http://www.themezilla.com/should-you-use-www-in-your-url-or-not/&quot;&gt;many&lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;articles&lt;/a&gt; on the subject.</source>
          <target state="translated">Это очень субъективная тема, ее можно рассматривать как проблему с &lt;a href=&quot;http://bikeshed.com/&quot;&gt;прокатом велосипедов&lt;/a&gt; . Если вы хотите читать глубже, ознакомьтесь с некоторыми из &lt;a href=&quot;http://www.themezilla.com/should-you-use-www-in-your-url-or-not/&quot;&gt;многих &lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;статей&lt;/a&gt; по этой теме.</target>
        </trans-unit>
        <trans-unit id="80608a6f9119cc7c4582aee9309cf18792c53923" translate="yes" xml:space="preserve">
          <source>This is an improvement over earlier &lt;code&gt;Accept&lt;/code&gt; headers as it no longer ranks &lt;code&gt;image/png&lt;/code&gt; above &lt;code&gt;text/html&lt;/code&gt;</source>
          <target state="translated">Это улучшение по сравнению с предыдущими заголовками &lt;code&gt;Accept&lt;/code&gt; , поскольку они больше не ставят &lt;code&gt;image/png&lt;/code&gt; выше &lt;code&gt;text/html&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">Это эквивалентно:</target>
        </trans-unit>
        <trans-unit id="f3c017ea67402b333e111c91d0d8c835c18ed46a" translate="yes" xml:space="preserve">
          <source>This is implemented using the &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; headers. If the etag doesn't match the original file, or if the file has been modified since it has been obtained, the change is simply rejected with a &lt;a href=&quot;status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error. It is then up to the client to deal with the error: either by notifying the user to start again (this time on the newest version), or by showing the user a &lt;em&gt;diff &lt;/em&gt;of both versions, helping them decide which changes they wish to keep.</source>
          <target state="translated">Это реализовано с использованием заголовков &lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; . Если etag не соответствует исходному файлу или если файл был изменен с момента его получения, изменение просто отклоняется с ошибкой &lt;a href=&quot;status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Precondition Failed&lt;/code&gt; . Затем клиент должен устранить ошибку: либо путем уведомления пользователя о необходимости начать заново (на этот раз с самой новой версией), либо путем показа пользователю &lt;em&gt;различий&lt;/em&gt; обеих версий, помогая им решить, какие изменения они хотят сохранить. ,</target>
        </trans-unit>
        <trans-unit id="124f23444ec9f501d1f80c6afe1cad1494209a7a" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints &lt;/em&gt; and is only available in Chrome 61 or later.</source>
          <target state="translated">Это часть &lt;strong&gt;экспериментальной&lt;/strong&gt; технологии под названием &lt;em&gt;Client Hints,&lt;/em&gt; которая доступна только в Chrome 61 или новее.</target>
        </trans-unit>
        <trans-unit id="d2cd90cf410e959cd661c8e83d47ed919723c7b5" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints&lt;/em&gt;. Initial support is in Chrome 46 or later. The Device-Memory value is in Chrome 61 or later.</source>
          <target state="translated">Это часть &lt;strong&gt;экспериментальной&lt;/strong&gt; технологии под названием &lt;em&gt;Client Hints&lt;/em&gt; . Первоначальная поддержка находится в Chrome 46 или новее. Значение Device-Memory указано в Chrome 61 или новее.</target>
        </trans-unit>
        <trans-unit id="2c9b9f265a030439ad0eded89740990c1cd0e705" translate="yes" xml:space="preserve">
          <source>This is similar to 401 but authentication is needed to be done by a proxy.</source>
          <target state="translated">Это похоже на 401,но аутентификация должна выполняться через прокси-сервер.</target>
        </trans-unit>
        <trans-unit id="8f1bfe2beacf7098474167acd9a0dc8c20186348" translate="yes" xml:space="preserve">
          <source>This is the default for binary files. As it means &lt;em&gt;unknown binary &lt;/em&gt; file, browsers usually don't execute it, or even ask if it should be executed. They treat it as if the &lt;a href=&quot;../headers/content-disposition&quot;&gt;&lt;code&gt;Content-Disposition&lt;/code&gt;&lt;/a&gt; header was set to &lt;code&gt;attachment&lt;/code&gt;, and propose a &quot;Save As&quot; dialog.</source>
          <target state="translated">Это значение по умолчанию для двоичных файлов. Поскольку это означает &lt;em&gt;неизвестный двоичный&lt;/em&gt; файл, браузеры обычно не запускают его и даже не спрашивают, нужно ли его запускать. Они рассматривают его так, как если бы заголовок &lt;a href=&quot;../headers/content-disposition&quot;&gt; &lt;code&gt;Content-Disposition&lt;/code&gt; &lt;/a&gt; был установлен как &lt;code&gt;attachment&lt;/code&gt; , и предлагают диалог &amp;laquo;Сохранить как&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9273da9e8fd5fcf9c3bde1b24ef99c570ddd6fd7" translate="yes" xml:space="preserve">
          <source>This is the default for textual files. Even if it really means &lt;em&gt;unknown textual&lt;/em&gt; file, browsers assume they can display it.</source>
          <target state="translated">Это значение по умолчанию для текстовых файлов. Даже если это действительно означает &lt;em&gt;неизвестный текстовый&lt;/em&gt; файл, браузеры предполагают, что они могут его отобразить.</target>
        </trans-unit>
        <trans-unit id="e89b69639ed3c3449649e0ef238ba09b307791ec" translate="yes" xml:space="preserve">
          <source>This is the user agent's default behavior if no policy is specified. The URL is sent as a referrer when the protocol security level stays the same (HTTP&amp;rarr;HTTP, HTTPS&amp;rarr;HTTPS), but isn't sent to a less secure destination (HTTPS&amp;rarr;HTTP).</source>
          <target state="translated">Это поведение пользовательского агента по умолчанию, если политика не указана. URL-адрес отправляется как реферер, когда уровень безопасности протокола остается неизменным (HTTP &amp;rarr; HTTP, HTTPS &amp;rarr; HTTPS), но не отправляется в менее безопасное место назначения (HTTPS &amp;rarr; HTTP).</target>
        </trans-unit>
        <trans-unit id="aec6ea7897565c6f7f8de375d3405f1846b40c5a" translate="yes" xml:space="preserve">
          <source>This is the user agent's default behavior if no policy is specified. The origin is sent as referrer to a-priori as-much-secure destination (HTTPS-&amp;gt;HTTPS), but isn't sent to a less secure destination (HTTPS-&amp;gt;HTTP).</source>
          <target state="translated">Это поведение пользовательского агента по умолчанию, если политика не указана. Источник отправляется как реферер в априори максимально безопасный пункт назначения (HTTPS-&amp;gt; HTTPS), но не отправляется в менее безопасный пункт назначения (HTTPS-&amp;gt; HTTP).</target>
        </trans-unit>
        <trans-unit id="176fe26e859db9d8a79b1329a0c4c540c8bdb602" translate="yes" xml:space="preserve">
          <source>This is used for caching purposes. It tells the client that the response has not been modified, so the client can continue to use the same cached version of the response.</source>
          <target state="translated">Это используется в целях кэширования.Она говорит клиенту,что ответ не был изменен,поэтому клиент может продолжать использовать ту же самую кэшированную версию ответа.</target>
        </trans-unit>
        <trans-unit id="db5ca9d8b582bb760db634b162cc4217b98dc46c" translate="yes" xml:space="preserve">
          <source>This is usually a bad practice, but there are some cases in which this is necessary. In these cases, you should first analyze your situation to be sure it's really necessary. Can you prevent it by adding some non-semantic &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt;&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;&lt;/a&gt; elements? The difficulty of successfully using user agent detection is worth a few disruptions to the purity of your HTML. Also, rethink your design: can you use progressive enhancement or fluid layouts to help remove the need to do this?</source>
          <target state="translated">Обычно это плохая практика, но в некоторых случаях это необходимо. В этих случаях вам следует сначала проанализировать свою ситуацию, чтобы убедиться, что это действительно необходимо. Можете ли вы предотвратить это, добавив некоторые &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt; &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; &lt;/a&gt; элементы &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; &lt;/a&gt; или &amp;lt;span&amp;gt; ? Сложность успешного использования обнаружения пользовательского агента стоит нескольких нарушений чистоты вашего HTML. Кроме того, переосмыслите свой дизайн: можете ли вы использовать прогрессивные улучшения или плавные макеты, чтобы избавиться от необходимости делать это?</target>
        </trans-unit>
        <trans-unit id="17702de3201465eb14c00b1b36262a93968df79b" translate="yes" xml:space="preserve">
          <source>This means that the resource is now permanently located at another URI, specified by the &lt;code&gt;Location:&lt;/code&gt; HTTP Response header. This has the same semantics as the &lt;code&gt;301 Moved Permanently&lt;/code&gt; HTTP response code, with the exception that the user agent &lt;em&gt;must not&lt;/em&gt; change the HTTP method used: If a &lt;code&gt;POST&lt;/code&gt; was used in the first request, a &lt;code&gt;POST&lt;/code&gt; must be used in the second request.</source>
          <target state="translated">Это означает, что ресурс теперь постоянно находится по другому URI, указанному в заголовке &lt;code&gt;Location:&lt;/code&gt; HTTP Response. Он имеет ту же семантику, что и код ответа HTTP &lt;code&gt;301 Moved Permanently&lt;/code&gt; , за исключением того, что пользовательский агент &lt;em&gt;не должен&lt;/em&gt; изменять используемый метод HTTP: если &lt;code&gt;POST&lt;/code&gt; использовался в первом запросе, &lt;code&gt;POST&lt;/code&gt; должен использоваться во втором запросе.</target>
        </trans-unit>
        <trans-unit id="37f8e68ab017e83ab3d110757c8a5ccd4bf55d28" translate="yes" xml:space="preserve">
          <source>This mechanism is always client initiated (with one exception: it's possible for the server to &lt;a href=&quot;#Server-initiated_upgrade_to_TLS&quot;&gt;require an upgrade to TLS&lt;/a&gt;), and the server may accept or refuse the switch to the new protocol. This makes it possible to start a connection using a commonly-used protocol, such as HTTP/1.1, then request that the connection switch to HTTP/2 or even to WebSockets.</source>
          <target state="translated">Этот механизм всегда инициируется клиентом (за одним исключением: сервер может &lt;a href=&quot;#Server-initiated_upgrade_to_TLS&quot;&gt;потребовать обновления до TLS&lt;/a&gt; ), и сервер может принять или отклонить переход на новый протокол. Это позволяет запускать соединение с использованием обычно используемого протокола, такого как HTTP / 1.1, а затем запрашивать переключение соединения на HTTP / 2 или даже на WebSockets.</target>
        </trans-unit>
        <trans-unit id="930c017a0341cb94a246a09014c32e54c099c6b0" translate="yes" xml:space="preserve">
          <source>This message means that the browser saw the &lt;code&gt;Large-Allocation&lt;/code&gt; header, and was able to reload the page into a new process which should have more available contiguous memory.</source>
          <target state="translated">Это сообщение означает, что браузер увидел заголовок &lt;code&gt;Large-Allocation&lt;/code&gt; и смог перезагрузить страницу в новый процесс, который должен иметь больше доступной непрерывной памяти.</target>
        </trans-unit>
        <trans-unit id="7884c1f5aebded20cacbf12f85bb3629712f95c4" translate="yes" xml:space="preserve">
          <source>This model is the default model used in HTTP/1.0 (if there is no &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header, or if its value is set to &lt;code&gt;close&lt;/code&gt;). In HTTP/1.1, this model is only used when the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header is sent with a value of &lt;code&gt;close&lt;/code&gt;.</source>
          <target state="translated">Эта модель является моделью по умолчанию, используемой в HTTP / 1.0 (если нет заголовка &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; или если для него установлено значение &lt;code&gt;close&lt;/code&gt; ). В HTTP / 1.1 эта модель используется только тогда, когда заголовок &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; отправляется со значением &lt;code&gt;close&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f8dd381093e02d3c56d8bf2d6a1a2b6d6c9bc23" translate="yes" xml:space="preserve">
          <source>This page is not complete.</source>
          <target state="translated">Эта страница не является полной.</target>
        </trans-unit>
        <trans-unit id="2700ae9496ac92696a2d7d32affc7822518ebd17" translate="yes" xml:space="preserve">
          <source>This page was loaded in a new process due to a &lt;code&gt;Large-Allocation&lt;/code&gt; header.</source>
          <target state="translated">Эта страница была загружена в новом процессе из &lt;code&gt;Large-Allocation&lt;/code&gt; заголовка Large-Allocation .</target>
        </trans-unit>
        <trans-unit id="0cac347b43837064b316648d4989da0372112872" translate="yes" xml:space="preserve">
          <source>This page would be loaded in a new process due to a &lt;code&gt;Large-Allocation&lt;/code&gt; header, however &lt;code&gt;Large-Allocation&lt;/code&gt; process creation is disabled on non-Win32 platforms.</source>
          <target state="translated">Эта страница будет загружена в новом процессе из &lt;code&gt;Large-Allocation&lt;/code&gt; заголовка Large-Allocation , однако создание процесса &lt;code&gt;Large-Allocation&lt;/code&gt; отключено на платформах, отличных от Win32.</target>
        </trans-unit>
        <trans-unit id="012dc0221186c93aa5f93e94a45c4ed8bd7f1e8a" translate="yes" xml:space="preserve">
          <source>This policy will leak origins and paths from TLS-protected resources to insecure origins. Carefully consider the impact of this setting.</source>
          <target state="translated">Эта политика приведет к утечке данных о происхождении и пути от TLS-защищенных ресурсов к небезопасным источникам.Внимательно рассмотрите влияние этой установки.</target>
        </trans-unit>
        <trans-unit id="777df6e36502c801cccff6604d845d23f1626c6e" translate="yes" xml:space="preserve">
          <source>This prefetching is performed in the background, so that the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DNS&quot;&gt;DNS&lt;/a&gt; is likely to have been resolved by the time the referenced items are needed. This reduces latency when the user clicks a link.</source>
          <target state="translated">Эта предварительная выборка выполняется в фоновом режиме, так что &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DNS&quot;&gt;DNS&lt;/a&gt; , вероятно, будет разрешен к тому времени, когда требуются элементы, на которые есть ссылка. Это уменьшает задержку, когда пользователь щелкает ссылку.</target>
        </trans-unit>
        <trans-unit id="322ff44ffffc8c1929757a32b5dd54ce49618142" translate="yes" xml:space="preserve">
          <source>This rapid adoption rate was likely as HTTP/2 does not require adaptation of Web sites and applications: using HTTP/1.1 or HTTP/2 is transparent for them. Having an up-to-date server communicating with a recent browser is enough to enable its use: only a limited set of groups were needed to trigger adoption, and as legacy browser and server versions are renewed, usage has naturally increased, without further Web developer efforts.</source>
          <target state="translated">Скорее всего,такие быстрые темпы внедрения были обусловлены тем,что HTTP/2 не требует адаптации веб-сайтов и приложений:использование HTTP/1.1 или HTTP/2 для них является прозрачным.Для его использования достаточно иметь современный сервер,общающийся с недавним браузером:для запуска внедрения требовалось лишь ограниченное количество групп,а по мере обновления старых версий браузера и сервера,использование естественно возросло,без дальнейших усилий со стороны веб-разработчиков.</target>
        </trans-unit>
        <trans-unit id="9bd4e192aba5cf8728bcb7d85247e143a7a701f5" translate="yes" xml:space="preserve">
          <source>This represents an HTML resource whose contents are:</source>
          <target state="translated">Это представляет собой HTML ресурс,содержимое которого:</target>
        </trans-unit>
        <trans-unit id="9e1a08d4ddad6242047c3f07fe630aad370f9ebd" translate="yes" xml:space="preserve">
          <source>This response code is no longer used, it is just reserved currently. It was used in a previous version of the HTTP 1.1 specification.</source>
          <target state="translated">Этот код ответа больше не используется,он просто зарезервирован на данный момент.Он использовался в предыдущей версии спецификации HTTP 1.1.</target>
        </trans-unit>
        <trans-unit id="196c5e3984dee3a01e3d4870bc32fe1976f373ee" translate="yes" xml:space="preserve">
          <source>This response code is reserved for future use. Initial aim for creating this code was using it for digital payment systems however this is not used currently.</source>
          <target state="translated">Этот код ответа зарезервирован для дальнейшего использования.Изначально целью создания этого кода было использование его для цифровых платежных систем,однако в настоящее время он не используется.</target>
        </trans-unit>
        <trans-unit id="17caf511cbbea70b5e359bd60edd742730612bb2" translate="yes" xml:space="preserve">
          <source>This response code is sent after accomplishing request to tell user agent reset document view which sent this request.</source>
          <target state="translated">Этот код ответа отправляется после выполнения запроса,чтобы сообщить агенту сброса документа,который отправил этот запрос.</target>
        </trans-unit>
        <trans-unit id="a6e3073e4af982c8216898b651b8900b118d9707" translate="yes" xml:space="preserve">
          <source>This response code is used because of range header sent by the client to separate download into multiple streams.</source>
          <target state="translated">Этот код ответа используется из-за заголовка диапазона,посылаемого клиентом для разделения загрузки на несколько потоков.</target>
        </trans-unit>
        <trans-unit id="54001a8a74f4230a78d081c9dd427598feb0b64e" translate="yes" xml:space="preserve">
          <source>This response code means returned meta-information set is not exact set as available from the origin server, but collected from a local or a third party copy. Except this condition, 200 OK response should be preferred instead of this response.</source>
          <target state="translated">Этот код ответа означает,что возвращаемый мета-информационный набор не является точным набором,доступным с исходного сервера,а собирается с локальной или сторонней копии.За исключением этого условия,предпочтительным должен быть ответ 200 ОК,а не этот ответ.</target>
        </trans-unit>
        <trans-unit id="a48afdbe246b4285c52a497fa58e9555d4417761" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of requested resource has been changed &lt;em&gt;temporarily&lt;/em&gt;. New changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.</source>
          <target state="translated">Этот код ответа означает, что URI запрошенного ресурса был &lt;em&gt;временно&lt;/em&gt; изменен . В будущем могут быть внесены новые изменения в URI. Следовательно, этот же URI должен использоваться клиентом в будущих запросах.</target>
        </trans-unit>
        <trans-unit id="796776b8f699ee7445564de16ff0f1e7a6734445" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of the requested resource has been changed. Probably, the new URI would be given in the response.</source>
          <target state="translated">Этот код ответа означает,что URI запрашиваемого ресурса был изменен.Вероятно,в ответе будет приведен новый URI.</target>
        </trans-unit>
        <trans-unit id="d31becaff4260704a27003cc76245a28d6fbfe6e" translate="yes" xml:space="preserve">
          <source>This response code means the expectation indicated by the &lt;code&gt;Expect&lt;/code&gt; request header field can't be met by the server.</source>
          <target state="translated">Этот код ответа означает, что ожидание, указанное в поле заголовка запроса &lt;code&gt;Expect&lt;/code&gt; , не может быть выполнено сервером.</target>
        </trans-unit>
        <trans-unit id="276e87f04788008ea8cf8cd65690a3af4d8541d7" translate="yes" xml:space="preserve">
          <source>This response is sent on an idle connection by some servers, even without any previous request by the client. It means that the server would like to shut down this unused connection. This response is used much more since some browsers, like Chrome, Firefox 27+, or IE9, use HTTP pre-connection mechanisms to speed up surfing. Also note that some servers merely shut down the connection without sending this message.</source>
          <target state="translated">Этот ответ посылается по простаивающему соединению некоторыми серверами,даже без предварительного запроса со стороны клиента.Это означает,что сервер хотел бы отключить это неиспользованное соединение.Этот ответ используется гораздо больше,так как некоторые браузеры,такие как Chrome,Firefox 27+или IE9,используют механизмы предварительного подключения HTTP для ускорения серфинга.Также обратите внимание,что некоторые серверы просто отключают соединение,не посылая это сообщение.</target>
        </trans-unit>
        <trans-unit id="2c19fa8f26e55768b081e1362d43a2a5e678955c" translate="yes" xml:space="preserve">
          <source>This response is sent when a request conflicts with the current state of the server.</source>
          <target state="translated">Этот ответ посылается,когда запрос конфликтует с текущим состоянием сервера.</target>
        </trans-unit>
        <trans-unit id="6c23f72de698fc46f7f3192934a03283e62349b8" translate="yes" xml:space="preserve">
          <source>This response is sent when the web server, after performing &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;server-driven content negotiation&lt;/a&gt;, doesn't find any content following the criteria given by the user agent.</source>
          <target state="translated">Этот ответ отправляется, когда веб-сервер после выполнения &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;согласования содержимого, управляемого сервером&lt;/a&gt; , не находит никакого содержимого, соответствующего критериям, заданным пользовательским агентом.</target>
        </trans-unit>
        <trans-unit id="20edf11481196ba8cc7fb946fd061c712997616b" translate="yes" xml:space="preserve">
          <source>This response is used much more since some browsers, like Chrome, Firefox 27+, and IE9, use HTTP pre-connection mechanisms to speed up surfing.</source>
          <target state="translated">Этот ответ используется гораздо больше,так как некоторые браузеры,такие как Chrome,Firefox 27+и IE9,используют механизмы предварительного подключения HTTP для ускорения серфинга.</target>
        </trans-unit>
        <trans-unit id="efe292862f7c79acb9c2cf06d20c3228017f8092" translate="yes" xml:space="preserve">
          <source>This response means that server could not understand the request due to invalid syntax.</source>
          <target state="translated">Этот ответ означает,что сервер не смог понять запрос из-за неправильного синтаксиса.</target>
        </trans-unit>
        <trans-unit id="b752e6a7b8c6d84ac6a300b6dfb2535f1b47b8ae" translate="yes" xml:space="preserve">
          <source>This response would be sent when the requested content has been permanently deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for &quot;limited-time, promotional services&quot;. APIs should not feel compelled to indicate resources that have been deleted with this status code.</source>
          <target state="translated">Этот ответ будет отправлен,когда запрашиваемое содержимое будет навсегда удалено с сервера,без адреса пересылки.Предполагается,что клиенты будут удалять свой кэш и ссылки на ресурс.Спецификация HTTP предполагает,что этот код статуса будет использоваться для &quot;ограниченных по времени,рекламных услуг&quot;.API не должны чувствовать себя вынужденными указывать ресурсы,которые были удалены с этим кодом статуса.</target>
        </trans-unit>
        <trans-unit id="eb0cde7eef9a19e7d58639cfa5c60f6f2574ad52" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of HTTP/1.1 header
   fields for applying preconditions on requests.  &lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt; defines
   when the preconditions are applied.  &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt; defines the order of
   evaluation when more than one precondition is present.</source>
          <target state="translated">В этом разделе определяется синтаксис и семантика полей заголовка HTTP / 1.1 для применения предварительных условий к запросам. &lt;a href=&quot;#section-5&quot;&gt;Раздел 5&lt;/a&gt; определяет, когда применяются предварительные условия. &lt;a href=&quot;#section-6&quot;&gt;Раздел 6&lt;/a&gt; определяет порядок оценки, когда присутствует более одного предусловия.</target>
        </trans-unit>
        <trans-unit id="84857579e8f4c4b00cf5ec7e227da62c2cbe3299" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of HTTP/1.1 header
   fields related to caching.</source>
          <target state="translated">Этот раздел определяет синтаксис и семантику полей заголовков HTTP/1.1,связанных с кэшированием.</target>
        </trans-unit>
        <trans-unit id="0e8dc398bfb18bf438574e9ca86e1a588f2447e3" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of all standard
   HTTP/1.1 header fields. For entity-header fields, both sender and
   recipient refer to either the client or the server, depending on who
   sends and who receives the entity.</source>
          <target state="translated">Этот раздел определяет синтаксис и семантику всех стандартных полей заголовков HTTP/1.1.Для полей заголовка сущности,как отправитель,так и получатель относятся либо к клиенту,либо к серверу,в зависимости от того,кто посылает и кто получает сущность.</target>
        </trans-unit>
        <trans-unit id="96ccae596f81c60b228fa76095eeb49aec1c38ba" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of header fields
   related to the HTTP authentication framework.</source>
          <target state="translated">Этот раздел определяет синтаксис и семантику полей заголовков,связанных с фреймворком HTTP-аутентификации.</target>
        </trans-unit>
        <trans-unit id="b059e4393c3ed5f02e30040602db1e13b843ebfb" translate="yes" xml:space="preserve">
          <source>This section describes problems that commonly occur when creating and using &lt;code&gt;data&lt;/code&gt; URLs.</source>
          <target state="translated">В этом разделе описаны проблемы, которые обычно возникают при создании и использовании URL-адресов &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="509645587a49cf601fb027d0d0b3f365b9c1a570" translate="yes" xml:space="preserve">
          <source>This section describes the semantics specific to the write lock type.
   The write lock is a specific instance of a lock type, and is the only
   lock type described in this specification.

   An exclusive write lock protects a resource: it prevents changes by
   any principal other than the lock creator and in any case where the
   lock token is not submitted (e.g., by a client process other than the
   one holding the lock).

   Clients MUST submit a lock-token they are authorized to use in any
   request that modifies a write-locked resource.  The list of
   modifications covered by a write-lock include:

   1.  A change to any of the following aspects of any write-locked
       resource:

       *  any variant,

       *  any dead property,

       *  any live property that is lockable (a live property is
          lockable unless otherwise defined.)

   2.  For collections, any modification of an internal member URI.  An
       internal member URI of a collection is considered to be modified
       if it is added, removed, or identifies a different resource.
       More discussion on write locks and collections is found in
       &lt;a href=&quot;#section-7.4&quot;&gt;Section 7.4&lt;/a&gt;.

   3.  A modification of the mapping of the root of the write lock,
       either to another resource or to no resource (e.g., DELETE).

   Of the methods defined in HTTP and WebDAV, PUT, POST, PROPPATCH,
   LOCK, UNLOCK, MOVE, COPY (for the destination resource), DELETE, and
   MKCOL are affected by write locks.  All other HTTP/WebDAV methods
   defined so far -- GET in particular -- function independently of a
   write lock.

   The next few sections describe in more specific terms how write locks
   interact with various operations.</source>
          <target state="translated">В этом разделе описывается семантика, специфичная для типа блокировки записи. Блокировка записи - это особый экземпляр типа блокировки и единственный тип блокировки, описанный в этой спецификации. Исключительная блокировка записи защищает ресурс: она предотвращает изменения любым принципалом, кроме создателя блокировки, и в любом случае, когда маркер блокировки не отправлен (например, клиентским процессом, отличным от того, который удерживает блокировку). Клиенты ДОЛЖНЫ предоставить маркер блокировки, который им разрешено использовать в любом запросе, который изменяет ресурс с блокировкой записи. Список модификаций, на которые распространяется блокировка записи, включает: 1. Изменение любого из следующих аспектов любого ресурса с блокировкой записи: * любой вариант, * любое мертвое свойство,* любое живое свойство, которое блокируется (живое свойство блокируется, если не определено иное). 2. Для коллекций - любая модификация URI внутреннего члена. URI внутреннего члена коллекции считается измененным, если он добавлен, удален или идентифицирует другой ресурс. Дополнительное обсуждение блокировок записи и коллекций можно найти в &lt;a href=&quot;#section-7.4&quot;&gt;Раздел 7.4&lt;/a&gt; . 3. Модификация отображения корня блокировки записи либо на другой ресурс, либо на отсутствие ресурса (например, DELETE). Из методов, определенных в HTTP и WebDAV, блокировки записи влияют на PUT, POST, PROPPATCH, LOCK, UNLOCK, MOVE, COPY (для целевого ресурса), DELETE и MKCOL. Все остальные методы HTTP / WebDAV, определенные до сих пор, в частности GET, работают независимо от блокировки записи. В следующих нескольких разделах более конкретно описывается, как блокировки записи взаимодействуют с различными операциями.</target>
        </trans-unit>
        <trans-unit id="1b8caae975a03a8390b52fa0ed5d2957f9b87b19" translate="yes" xml:space="preserve">
          <source>This section is meant to inform application developers, information
   providers, and users of the security limitations in HTTP/1.1 as
   described by this document. The discussion does not include
   definitive solutions to the problems revealed, though it does make
   some suggestions for reducing security risks.</source>
          <target state="translated">Данный раздел предназначен для информирования разработчиков приложений,поставщиков информации и пользователей об ограничениях безопасности в HTTP/1.1,описанных в данном документе.Обсуждение не включает в себя окончательное решение выявленных проблем,хотя и содержит некоторые предложения по снижению рисков безопасности.</target>
        </trans-unit>
        <trans-unit id="e14dd174357a0e5e555989561acf1df199436583" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns relevant to HTTP semantics and
   its use for transferring information over the Internet.
   Considerations related to message syntax, parsing, and routing are
   discussed in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-9&quot;&gt;Section&amp;nbsp;9 of [RFC7230]&lt;/a&gt;.

   The list of considerations below is not exhaustive.  Most security
   concerns related to HTTP semantics are about securing server-side
   applications (code behind the HTTP interface), securing user agent 

   processing of payloads received via HTTP, or secure use of the
   Internet in general, rather than security of the protocol.  Various
   organizations maintain topical information and links to current
   research on Web application security (e.g., [&lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]).</source>
          <target state="translated">Этот раздел предназначен для информирования разработчиков, поставщиков информации и пользователей об известных проблемах безопасности, связанных с семантикой HTTP и ее использованием для передачи информации через Интернет. Соображения, связанные с синтаксисом сообщений, синтаксическим &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-9&quot;&gt;анализом&lt;/a&gt; и маршрутизацией, обсуждаются в разделе 9 [RFC7230] . Приведенный ниже список соображений не является исчерпывающим. Большинство проблем безопасности, связанных с семантикой HTTP, касаются защиты приложений на стороне сервера (кода, стоящего за интерфейсом HTTP), защиты обработки пользовательским агентом полезных данных, полученных через HTTP, или безопасного использования Интернета в целом, а не безопасности протокола. Различные организации поддерживают актуальную информацию и ссылки на текущие исследования по безопасности веб-приложений (например, [ &lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt; ]).</target>
        </trans-unit>
        <trans-unit id="cc5ec5ca15ce6b7e4d99013caa23973be65f1836" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to HTTP authentication.
   More general security considerations are addressed in HTTP messaging
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].

   Everything about the topic of HTTP authentication is a security
   consideration, so the list of considerations below is not exhaustive.
   Furthermore, it is limited to security considerations regarding the
   authentication framework, in general, rather than discussing all of
   the potential considerations for specific authentication schemes
   (which ought to be documented in the specifications that define those
   schemes).  Various organizations maintain topical information and
   links to current research on Web application security (e.g.,
   [&lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]), including common pitfalls for implementing and using the
   authentication schemes found in practice.</source>
          <target state="translated">Этот раздел предназначен для информирования разработчиков, поставщиков информации и пользователей об известных проблемах безопасности, связанных с аутентификацией HTTP. Более общие вопросы безопасности рассматриваются в HTTP-сообщениях [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] и семантике [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]. Все, что касается аутентификации HTTP, является соображением безопасности, поэтому приведенный ниже список соображений не является исчерпывающим. Кроме того, он ограничен соображениями безопасности относительно структуры аутентификации в целом, а не обсуждением всех потенциальных соображений для конкретных схем аутентификации (которые должны быть задокументированы в спецификациях, определяющих эти схемы). Различные организации хранят актуальную информацию и ссылки на текущие исследования по безопасности веб-приложений (например, [ &lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt; ]), включая распространенные ошибки при реализации и использовании схем аутентификации, встречающиеся на практике.</target>
        </trans-unit>
        <trans-unit id="d7b61cbd1c222657e3948d017b4f1b45bdc23901" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to HTTP caching.  More
   general security considerations are addressed in HTTP messaging
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].

   Caches expose additional potential vulnerabilities, since the
   contents of the cache represent an attractive target for malicious
   exploitation.  Because cache contents persist after an HTTP request
   is complete, an attack on the cache can reveal information long after
   a user believes that the information has been removed from the
   network.  Therefore, cache contents need to be protected as sensitive
   information.

   In particular, various attacks might be amplified by being stored in
   a shared cache; such &quot;cache poisoning&quot; attacks use the cache to
   distribute a malicious payload to many clients, and are especially
   effective when an attacker can use implementation flaws, elevated
   privileges, or other techniques to insert such a response into a
   cache.  One common attack vector for cache poisoning is to exploit
   differences in message parsing on proxies and in user agents; see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.3&quot;&gt;Section&amp;nbsp;3.3.3 of [RFC7230]&lt;/a&gt; for the relevant requirements.

   Likewise, implementation flaws (as well as misunderstanding of cache
   operation) might lead to caching of sensitive information (e.g.,
   authentication credentials) that is thought to be private, exposing
   it to unauthorized parties. 

   Furthermore, the very use of a cache can bring about privacy
   concerns.  For example, if two users share a cache, and the first one
   browses to a site, the second may be able to detect that the other
   has been to that site, because the resources from it load more
   quickly, thanks to the cache.

   Note that the Set-Cookie response header field [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] does not
   inhibit caching; a cacheable response with a Set-Cookie header field
   can be (and often is) used to satisfy subsequent requests to caches.
   Servers who wish to control caching of these responses are encouraged
   to emit appropriate Cache-Control response header fields.</source>
          <target state="translated">Этот раздел предназначен для информирования разработчиков, поставщиков информации и пользователей об известных проблемах безопасности, связанных с кэшированием HTTP. Более общие вопросы безопасности рассматриваются в HTTP-сообщениях [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] и семантике [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]. Кеши открывают дополнительные потенциальные уязвимости, так как их содержимое представляет собой привлекательную цель для злонамеренного использования. Поскольку содержимое кеша сохраняется после завершения HTTP-запроса, атака на кеш может раскрыть информацию еще долгое время после того, как пользователь считает, что информация была удалена из сети. Следовательно, содержимое кэша необходимо защищать как конфиденциальную информацию. В частности, различные атаки могут быть усилены хранением в общем кэше; такие атаки &amp;laquo;отравления кеша&amp;raquo; используют кеш для распространения вредоносных полезных данных среди множества клиентов и особенно эффективны, когда злоумышленник может использовать недостатки реализации, повышенные привилегии или другие методы для вставки такого ответа в кэш.Один из распространенных векторов атаки отравления кеша - использование различий в парсинге сообщений на прокси-серверах и в пользовательских агентах; видеть &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.3&quot;&gt;Раздел 3.3.3 [RFC7230]&lt;/a&gt; для соответствующих требований. Точно так же недостатки реализации (а также неправильное понимание работы кеша) могут привести к кэшированию конфиденциальной информации (например, учетных данных для аутентификации), которая считается частной, и раскрывает ее неавторизованным сторонам. Кроме того, само использование кеша может вызвать проблемы с конфиденциальностью. Например, если два пользователя совместно используют кеш, а первый просматривает сайт, второй может обнаружить, что другой был на этом сайте, потому что ресурсы с него загружаются быстрее благодаря кешу. Обратите внимание, что поле заголовка ответа Set-Cookie [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] не запрещает кеширование; кэшируемый ответ с полем заголовка Set-Cookie может использоваться (и часто используется) для удовлетворения последующих запросов к кешам. Серверам, которые хотят контролировать кеширование этих ответов, рекомендуется создавать соответствующие поля заголовка ответа Cache-Control.</target>
        </trans-unit>
        <trans-unit id="0e335c0656016c7e9ffd0c440c556a3faf33fe1d" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to the HTTP conditional
   request mechanisms.  More general security considerations are
   addressed in HTTP &quot;Message Syntax and Routing&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and
   &quot;Semantics and Content&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]. 

   The validators defined by this specification are not intended to
   ensure the validity of a representation, guard against malicious
   changes, or detect man-in-the-middle attacks.  At best, they enable
   more efficient cache updates and optimistic concurrent writes when
   all participants are behaving nicely.  At worst, the conditions will
   fail and the client will receive a response that is no more harmful
   than an HTTP exchange without conditional requests.

   An entity-tag can be abused in ways that create privacy risks.  For
   example, a site might deliberately construct a semantically invalid
   entity-tag that is unique to the user or user agent, send it in a
   cacheable response with a long freshness time, and then read that
   entity-tag in later conditional requests as a means of re-identifying
   that user or user agent.  Such an identifying tag would become a
   persistent identifier for as long as the user agent retained the
   original cache entry.  User agents that cache representations ought
   to ensure that the cache is cleared or replaced whenever the user
   performs privacy-maintaining actions, such as clearing stored cookies
   or changing to a private browsing mode.</source>
          <target state="translated">Этот раздел предназначен для информирования разработчиков, поставщиков информации и пользователей об известных проблемах безопасности, связанных с механизмами условных запросов HTTP. Более общие вопросы безопасности рассматриваются в HTTP &amp;laquo;Синтаксис и маршрутизация сообщений&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] и &amp;laquo;Семантика и контент&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]. Валидаторы, определенные в этой спецификации, не предназначены для обеспечения достоверности представления, защиты от вредоносных изменений или обнаружения атак типа &amp;laquo;злоумышленник в середине&amp;raquo;. В лучшем случае они обеспечивают более эффективное обновление кеша и оптимистичную одновременную запись, когда все участники ведут себя хорошо. В худшем случае условия не будут выполнены, и клиент получит ответ, который не более опасен, чем обмен HTTP без условных запросов. Использование тега объекта может привести к нарушению конфиденциальности. Например, сайт может намеренно создать семантически недопустимый тег объекта, который является уникальным для пользователя или пользовательского агента, отправить его в кэшируемом ответе с длительным временем актуальности,а затем прочитать этот тег объекта в последующих условных запросах как средство повторной идентификации этого пользователя или пользовательского агента. Такой идентифицирующий тег стал бы постоянным идентификатором до тех пор, пока пользовательский агент сохранял исходную запись кэша. Пользовательские агенты, которые кэшируют представления, должны обеспечивать очистку или замену кеша всякий раз, когда пользователь выполняет действия по поддержанию конфиденциальности, такие как очистка сохраненных файлов cookie или переход в режим приватного просмотра.</target>
        </trans-unit>
        <trans-unit id="a8b6ada4af46edbc538acb5ee5cd9d1e819c9d08" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to the HTTP range
   request mechanisms.  More general security considerations are
   addressed in HTTP messaging [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].</source>
          <target state="translated">Этот раздел предназначен для информирования разработчиков, поставщиков информации и пользователей об известных проблемах безопасности, связанных с механизмами запроса диапазона HTTP. Более общие вопросы безопасности рассматриваются в HTTP-сообщениях [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] и семантике [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="20f34b6144b38a6c6e8c314d3b99c718e19c16cf" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security considerations relevant to HTTP message
   syntax, parsing, and routing.  Security considerations about HTTP
   semantics and payloads are addressed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].</source>
          <target state="translated">Этот раздел предназначен для информирования разработчиков, поставщиков информации и пользователей об известных аспектах безопасности, связанных с синтаксисом, синтаксическим анализом и маршрутизацией сообщений HTTP. &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;Вопросы&lt;/a&gt; безопасности, касающиеся семантики HTTP и полезных данных, рассматриваются в [ RFC7231 ].</target>
        </trans-unit>
        <trans-unit id="6807589d15db566935fa0b36f3c986f0dcb8f1e1" translate="yes" xml:space="preserve">
          <source>This section is provided to detail issues concerning security
   implications of which WebDAV applications need to be aware.

   All of the security considerations of HTTP/1.1 (discussed in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]) and XML (discussed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;]) also apply to WebDAV.  In
   addition, the security risks inherent in remote authoring require
   stronger authentication technology, introduce several new privacy
   concerns, and may increase the hazards from poor server design.
   These issues are detailed below.</source>
          <target state="translated">В этом разделе подробно описаны проблемы, связанные с последствиями для безопасности, о которых приложениям WebDAV необходимо знать. Все соображения безопасности HTTP / 1.1 (обсуждаются в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]) и XML (обсуждаются в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt; ]) также применимы к WebDAV. Кроме того, риски безопасности, присущие удаленному авторингу, требуют более надежной технологии аутентификации, вносят несколько новых проблем с конфиденциальностью и могут увеличивать опасность из-за плохой конструкции сервера. Эти проблемы подробно описаны ниже.</target>
        </trans-unit>
        <trans-unit id="b6f1686ad83954bc21d87d0b2feab0950aa7dc14" translate="yes" xml:space="preserve">
          <source>This section lists headers that clients may use when issuing HTTP requests in order to make use of the cross-origin sharing feature. Note that these headers are set for you when making invocations to servers. Developers using cross-site &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; capability do not have to set any cross-origin sharing request headers programmatically.</source>
          <target state="translated">В этом разделе перечислены заголовки, которые клиенты могут использовать при отправке HTTP-запросов, чтобы использовать функцию общего доступа между источниками. Обратите внимание, что эти заголовки устанавливаются для вас при обращении к серверам. Разработчикам, использующим возможность межсайтового &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; , не нужно программно устанавливать заголовки запросов на совместное использование между источниками.</target>
        </trans-unit>
        <trans-unit id="2596221fd857bbcaea04d0cd1a4ea6fd1d357430" translate="yes" xml:space="preserve">
          <source>This section lists major changes between this document and &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;,
   starting with those that are likely to result in implementation
   changes.  Servers will advertise support for all changes in this
   specification by returning the compliance class &quot;3&quot; in the DAV
   response header (see Sections &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; and &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;).</source>
          <target state="translated">В этом разделе перечислены основные изменения между этим документом и &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; , начиная с тех, которые могут привести к изменениям в реализации. Серверы будут анонсировать поддержку всех изменений в этой спецификации, возвращая класс соответствия &amp;laquo;3&amp;raquo; в заголовке ответа DAV (см. Разделы &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; и &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fd619925c99ba3f120ebdc079103c35edf44f771" translate="yes" xml:space="preserve">
          <source>This section lists the HTTP response headers that servers send back for access control requests as defined by the Cross-Origin Resource Sharing specification. The previous section gives an overview of these in action.</source>
          <target state="translated">В этом разделе перечислены заголовки HTTP-ответов,которые серверы посылают обратно для запросов управления доступом,как определено в Cross-Origin Resource Sharing спецификации.В предыдущем разделе дается их обзор в действии.</target>
        </trans-unit>
        <trans-unit id="256b3572a114f6830fdfb27c4527ad2a42aa41b3" translate="yes" xml:space="preserve">
          <source>This section provides a concise model for how locking behaves.  Later
   sections will provide more detail on some of the concepts and refer
   back to these model statements.  Normative statements related to LOCK
   and UNLOCK method handling can be found in the sections on those
   methods, whereas normative statements that cover any method are
   gathered here.

   1.  A lock either directly or indirectly locks a resource.

   2.  A resource becomes directly locked when a LOCK request to a URL
       of that resource creates a new lock.  The &quot;lock-root&quot; of the new
       lock is that URL.  If at the time of the request, the URL is not
       mapped to a resource, a new empty resource is created and
       directly locked.

   3.  An exclusive lock (&lt;a href=&quot;#section-6.2&quot;&gt;Section 6.2&lt;/a&gt;) conflicts with any other kind of
       lock on the same resource, whether either lock is direct or
       indirect.  A server MUST NOT create conflicting locks on a
       resource.

   4.  For a collection that is locked with a depth-infinity lock L, all
       member resources are indirectly locked.  Changes in membership of
       such a collection affect the set of indirectly locked resources:

       *  If a member resource is added to the collection, the new
          member resource MUST NOT already have a conflicting lock,
          because the new resource MUST become indirectly locked by L.

       *  If a member resource stops being a member of the collection,
          then the resource MUST no longer be indirectly locked by L.

   5.  Each lock is identified by a single globally unique lock token
       (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;).

   6.  An UNLOCK request deletes the lock with the specified lock token.
       After a lock is deleted, no resource is locked by that lock.

   7.  A lock token is &quot;submitted&quot; in a request when it appears in an
       &quot;If&quot; header (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;, &quot;Write Lock&quot;, discusses when token
       submission is required for write locks).

   8.  If a request causes the lock-root of any lock to become an
       unmapped URL, then the lock MUST also be deleted by that request.</source>
          <target state="translated">В этом разделе представлена ​​краткая модель того, как ведет себя блокировка. В последующих разделах будут представлены более подробные сведения о некоторых концепциях и ссылки на эти утверждения модели. Нормативные утверждения, связанные с обработкой методов LOCK и UNLOCK, можно найти в разделах, посвященных этим методам, тогда как нормативные утверждения, относящиеся к любому методу, собраны здесь. 1. Блокировка прямо или косвенно блокирует ресурс. 2. Ресурс становится напрямую заблокированным, когда запрос LOCK на URL-адрес этого ресурса создает новую блокировку. Этот URL-адрес является &quot;корнем блокировки&quot; новой блокировки. Если во время запроса URL-адрес не сопоставлен с ресурсом, создается новый пустой ресурс, который напрямую блокируется. 3. Эксклюзивная блокировка ( &lt;a href=&quot;#section-6.2&quot;&gt;Раздел 6.2&lt;/a&gt;) конфликтует с любым другим видом блокировки того же ресурса, будь то блокировка прямой или косвенной. Сервер НЕ ДОЛЖЕН создавать конфликтующие блокировки ресурса. 4. Для коллекции, которая заблокирована блокировкой бесконечности глубины L, все ресурсы-члены блокируются косвенно. Изменения в членстве в такой коллекции влияют на набор косвенно заблокированных ресурсов: * Если ресурс-член добавлен в коллекцию, новый ресурс-член НЕ ДОЛЖЕН уже иметь конфликтующую блокировку, потому что новый ресурс ДОЛЖЕН быть косвенно заблокирован L. * Если ресурс-член перестает быть членом коллекции, то ресурс ДОЛЖЕН больше не быть косвенно заблокирован L. 5. Каждая блокировка идентифицируется одним глобально уникальным токеном блокировки (&lt;a href=&quot;#section-6.5&quot;&gt;Раздел 6.5&lt;/a&gt; ). 6. Запрос UNLOCK удаляет блокировку с указанным токеном блокировки. После удаления блокировки ни один ресурс не блокируется этой блокировкой. 7. Маркер блокировки &amp;laquo;отправляется&amp;raquo; в запрос, когда он появляется в заголовке &amp;laquo;Если&amp;raquo; ( &lt;a href=&quot;#section-7&quot;&gt;Раздел 7&lt;/a&gt; , &amp;laquo;Блокировка записи&amp;raquo;, обсуждает, когда отправка маркера требуется для блокировок записи). 8. Если запрос приводит к тому, что корень блокировки любой блокировки становится неотображенным URL-адресом, то блокировка также ДОЛЖНА быть удалена этим запросом.</target>
        </trans-unit>
        <trans-unit id="b4b255e71c5acf2b758f6ac1313183b4a6e6c569" translate="yes" xml:space="preserve">
          <source>This section provides a description of a type of Web resource, the
   collection, and discusses its interactions with the HTTP URL
   namespace and with HTTP methods.  The purpose of a collection
   resource is to model collection-like objects (e.g., file system
   directories) within a server's namespace. 

   All DAV-compliant resources MUST support the HTTP URL namespace model
   specified herein.</source>
          <target state="translated">В этом разделе приводится описание типа веб-ресурса,коллекции,а также обсуждается его взаимодействие с пространством имён HTTP URL и с HTTP-методами.Назначение ресурса коллекции состоит в моделировании объектов,похожих на коллекции (например,каталогов файловой системы)в пространстве имён сервера.Все DAV-совместимые ресурсы ДОЛЖНЫ поддерживать указанную здесь модель пространства имён HTTP URL.</target>
        </trans-unit>
        <trans-unit id="41f24be581ad6f64eda1b3a4bd3c9c3eed891392" translate="yes" xml:space="preserve">
          <source>This section provides examples of some common security policy scenarios.</source>
          <target state="translated">В этом разделе приведены примеры некоторых общих сценариев политики безопасности.</target>
        </trans-unit>
        <trans-unit id="ffdc290f371b09817d92044b4802c7dcaa78a48b" translate="yes" xml:space="preserve">
          <source>This section summarizes major differences between versions HTTP/1.0
   and HTTP/1.1.</source>
          <target state="translated">В данном разделе обобщены основные различия между версиями HTTP/1.0 и HTTP/1.1.</target>
        </trans-unit>
        <trans-unit id="ff966b2d60be3de0767cef83a4ad73d50f777ddf" translate="yes" xml:space="preserve">
          <source>This section, as with similar sections for other methods, provides
   some guidance on error codes and preconditions or postconditions
   (defined in &lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;) that might be particularly useful with
   PROPFIND.

   403 Forbidden - A server MAY reject PROPFIND requests on collections
   with depth header of &quot;Infinity&quot;, in which case it SHOULD use this
   error with the precondition code 'propfind-finite-depth' inside the
   error body.</source>
          <target state="translated">Этот раздел, как и аналогичные разделы для других методов, предоставляет некоторые рекомендации по кодам ошибок и предварительным условиям или постусловиям (определенным в &lt;a href=&quot;#section-16&quot;&gt;Разделе 16&lt;/a&gt; ), которые могут быть особенно полезны с PROPFIND. 403 Запрещено - сервер МОЖЕТ отклонять запросы PROPFIND к коллекциям с заголовком глубины &amp;laquo;Infinity&amp;raquo;, и в этом случае он ДОЛЖЕН использовать эту ошибку с кодом предварительного условия &amp;laquo;propfind-Finder-depth&amp;raquo; внутри тела ошибки.</target>
        </trans-unit>
        <trans-unit id="639667e8ad5d2c48599430916aed509755cbbadd" translate="yes" xml:space="preserve">
          <source>This simple HTML file will be saved as a regular download rather than displayed in the browser. Most browsers will propose to save it under the &lt;code&gt;cool.html&lt;/code&gt; filename (by default).</source>
          <target state="translated">Этот простой HTML-файл будет сохранен как обычная загрузка, а не отображаться в браузере. Большинство браузеров предлагают сохранить его под &lt;code&gt;cool.html&lt;/code&gt; файла cool.html (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="1c7309d7bb5ffc950761c7540724deee943ec907" translate="yes" xml:space="preserve">
          <source>This simple model held an innate limitation on performance: opening each TCP connection is a resource-consuming operation. Several messages must be exchanged between the client and the server. Network latency and bandwidth affect performance when a request needs sending. Modern Web pages require many requests (a dozen or more) to serve the amount of information needed, proving this earlier model inefficient.</source>
          <target state="translated">Эта простая модель имела врожденное ограничение производительности:открытие каждого TCP-соединения является ресурсоемкой операцией.Между клиентом и сервером необходимо обмениваться несколькими сообщениями.Задержки сети и пропускная способность влияют на производительность,когда запрос нуждается в отправке.Современные веб-страницы требуют много запросов (дюжина и более),чтобы обслуживать количество необходимой информации,доказывая,что эта более ранняя модель неэффективна.</target>
        </trans-unit>
        <trans-unit id="484f69d86199a4745f12e506b1b55024069115fc" translate="yes" xml:space="preserve">
          <source>This solution is more efficient, but slightly less flexible, as only one etag can be used in the condition. Rarely is such additional flexibility needed.</source>
          <target state="translated">Это решение является более эффективным,но немного менее гибким,так как в состоянии может быть использован только один метка.Редко требуется такая дополнительная гибкость.</target>
        </trans-unit>
        <trans-unit id="01774d0c8108df34d3eb470ca203ddd51442235b" translate="yes" xml:space="preserve">
          <source>This specification adds the value &quot;edit&quot; to the Atom Registry of Link
   Relations (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC4287]&lt;/a&gt;).  The value of &quot;edit&quot;
   specifies that the value of the href attribute is the IRI of an
   editable Member Entry.  When appearing within an atom:entry, the href
   IRI can be used to retrieve, update, and delete the Resource
   represented by that Entry.  An atom:entry MUST NOT contain more than
   one &quot;edit&quot; link relation.</source>
          <target state="translated">Эта спецификация добавляет значение &amp;laquo;edit&amp;raquo; в реестр отношений ссылок Atom (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;Раздел 7.1 [RFC4287]&lt;/a&gt; ). Значение &amp;laquo;edit&amp;raquo; указывает, что значением атрибута href является IRI редактируемой записи члена. При появлении в записи atom: href IRI можно использовать для извлечения, обновления и удаления ресурса, представленного этой записью. Элемент atom: entry НЕ ДОЛЖЕН содержать более одного отношения ссылки &quot;редактировать&quot;.</target>
        </trans-unit>
        <trans-unit id="87fe0975464508a17f30a33c7f745b43a75fae60" translate="yes" xml:space="preserve">
          <source>This specification adds the value &quot;edit-media&quot; to the Atom Registry
   of Link Relations (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC4287]&lt;/a&gt;).  When appearing
   within an atom:entry, the value of the href attribute is an IRI that
   can be used to modify a Media Resource associated with that Entry.

   An atom:entry element MAY contain zero or more &quot;edit-media&quot; link
   relations.  An atom:entry MUST NOT contain more than one atom:link
   element with a &quot;rel&quot; attribute value of &quot;edit-media&quot; that has the
   same &quot;type&quot; and &quot;hreflang&quot; attribute values.  All &quot;edit-media&quot; link
   relations in the same Entry reference the same Resource.  If a client
   encounters multiple &quot;edit-media&quot; link relations in an Entry then it
   SHOULD choose a link based on the client preferences for &quot;type&quot; and
   &quot;hreflang&quot;.  If a client encounters multiple &quot;edit-media&quot; link
   relations in an Entry and has no preference based on the &quot;type&quot; and
   &quot;hreflang&quot; attributes then the client SHOULD pick the first &quot;edit-
   media&quot; link relation in document order.</source>
          <target state="translated">Эта спецификация добавляет значение &quot;edit-media&quot; в реестр отношений ссылок Atom (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;Раздел 7.1 [RFC4287]&lt;/a&gt;). При появлении в записи atom: значение атрибута href представляет собой IRI, который можно использовать для изменения медиаресурса, связанного с этой записью. Элемент atom: entry МОЖЕТ содержать ноль или более связей &quot;редактирование-медиа&quot;. Элемент atom: entry НЕ ДОЛЖЕН содержать более одного элемента atom: link со значением атрибута rel &quot;edit-media&quot;, имеющим одинаковые значения атрибутов &quot;type&quot; и &quot;hreflang&quot;. Все связи &amp;laquo;редактирование-медиа&amp;raquo; в одной и той же записи ссылаются на один и тот же ресурс. Если клиент встречает несколько связей &amp;laquo;редактирование-медиа&amp;raquo; в записи, то он ДОЛЖЕН выбрать ссылку на основе предпочтений клиента для &amp;laquo;типа&amp;raquo; и &amp;laquo;hreflang&amp;raquo;. Если клиент сталкивается с несколькими &quot;редакторами медиа&quot;отношения ссылки в записи и не имеет предпочтений на основе атрибутов &amp;laquo;type&amp;raquo; и &amp;laquo;hreflang&amp;raquo;, тогда клиент ДОЛЖЕН выбрать первое отношение ссылки &amp;laquo;edit-media&amp;raquo; в порядке документа.</target>
        </trans-unit>
        <trans-unit id="b2a53f987b042cdfef40437d4b21f1000736b54d" translate="yes" xml:space="preserve">
          <source>This specification defines a new &quot;type&quot; parameter for use with the
   &quot;application/atom+xml&quot; media type.  The &quot;type&quot; parameter has a value
   of &quot;entry&quot; or &quot;feed&quot;.

   Neither the parameter name nor its value are case sensitive. 

   The value &quot;entry&quot; indicates that the media type identifies an Atom
   Entry Document.  The root element of the document MUST be atom:entry.

   The value &quot;feed&quot; indicates that the media type identifies an Atom
   Feed Document.  The root element of the document MUST be atom:feed.

   If not specified, the type is assumed to be unspecified, requiring
   Atom processors to examine the root element to determine the type of
   Atom document.</source>
          <target state="translated">Данная спецификация определяет новый параметр &quot;type&quot; для использования с типом носителя &quot;application/atom+xml&quot;.Параметр &quot;type&quot; имеет значение &quot;entry&quot; или &quot;feed&quot;.Ни имя параметра,ни его значение не чувствительны к регистру.Значение &quot;entry&quot; указывает на то,что тип носителя информации идентифицирует документ Atom Entry.Корневой элемент документа ДОЛЖЕН быть atom:entry.Значение &quot;feed&quot; (подача)указывает на то,что тип носителя идентифицирует Atom Feed Document (Атомный подающий документ).Корневым элементом документа ДОЛЖЕН быть atom:feed.Если тип не указан,то считается,что он не указан,что требует от Atom-процессоров исследовать корневой элемент для определения типа документа Atom.</target>
        </trans-unit>
        <trans-unit id="978449461dd375d2f22dc902ad77e42eee391e36" translate="yes" xml:space="preserve">
          <source>This specification defines an Atom Format Structured Extension, as
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC4287]&lt;/a&gt;, for publishing control within the
   &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot; namespace.</source>
          <target state="translated">Эта спецификация определяет структурированное расширение формата Atom, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;разделе 6 [RFC4287]&lt;/a&gt; , для управления публикацией в пространстве имен &amp;laquo; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="91a1e7bdc7ea038fc4979f4ad8ada34b2e46af01" translate="yes" xml:space="preserve">
          <source>This specification defines the HTTP status codes

   o  207 Multi-Status (&lt;a href=&quot;#section-11.1&quot;&gt;Section 11.1&lt;/a&gt;)

   o  422 Unprocessable Entity (&lt;a href=&quot;#section-11.2&quot;&gt;Section 11.2&lt;/a&gt;),

   o  423 Locked (&lt;a href=&quot;#section-11.3&quot;&gt;Section 11.3&lt;/a&gt;),

   o  424 Failed Dependency (&lt;a href=&quot;#section-11.4&quot;&gt;Section 11.4&lt;/a&gt;) and

   o  507 Insufficient Storage (&lt;a href=&quot;#section-11.5&quot;&gt;Section 11.5&lt;/a&gt;),

   to be updated in the registry at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt;.

   Note: the HTTP status code 102 (Processing) has been removed in this
   specification; its IANA registration should continue to reference &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518&lt;/a&gt;.</source>
          <target state="translated">Эта спецификация определяет коды состояния HTTP o 207 Multi-Status ( &lt;a href=&quot;#section-11.1&quot;&gt;Раздел 11.1&lt;/a&gt; ) o 422 Unprocessable Entity ( &lt;a href=&quot;#section-11.2&quot;&gt;Раздел 11.2&lt;/a&gt; ), o 423 Locked ( &lt;a href=&quot;#section-11.3&quot;&gt;Раздел 11.3&lt;/a&gt; ), o 424 Failed Dependency ( &lt;a href=&quot;#section-11.4&quot;&gt;Раздел 11.4&lt;/a&gt; ) и o 507 Недостаточное хранилище ( &lt;a href=&quot;#section-11.5&quot;&gt;Раздел 11.5&lt;/a&gt; ) , который будет обновлен в реестре на &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;. Примечание: код состояния HTTP 102 (Обработка) был удален в этой спецификации; его регистрация IANA должна по-прежнему ссылаться на &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e1fe7c5f8c6eb66628d934996aa12f9c804ee43" translate="yes" xml:space="preserve">
          <source>This specification defines two URI schemes:

   1.  the &quot;opaquelocktoken&quot; scheme defined in &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;, and

   2.  the &quot;DAV&quot; URI scheme, which historically was used in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] to
       disambiguate WebDAV property and XML element names and which
       continues to be used for that purpose in this specification and
       others extending WebDAV.  Creation of identifiers in the &quot;DAV:&quot;
       namespace is controlled by the IETF.

   Note that defining new URI schemes for XML namespaces is now
   discouraged.  &quot;DAV:&quot; was defined before standard best practices
   emerged.</source>
          <target state="translated">Эта спецификация определяет две схемы URI: 1. схему &amp;laquo;непрозрачный токен&amp;raquo;, определенную в &lt;a href=&quot;#appendix-C&quot;&gt;Приложении C&lt;/a&gt; , и 2. схему URI &amp;laquo;DAV&amp;raquo;, которая исторически использовалась в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ] для устранения неоднозначности свойств WebDAV и имен элементов XML и которая продолжает оставаться используется для этой цели в этой спецификации и других расширениях WebDAV. Создание идентификаторов в пространстве имен &amp;laquo;DAV:&amp;raquo; контролируется IETF. Обратите внимание, что определение новых схем URI для пространств имен XML теперь не рекомендуется. &amp;laquo;DAV:&amp;raquo; был определен до появления стандартных передовых практик.</target>
        </trans-unit>
        <trans-unit id="21623dc11b6c2f043255281513da10df5c7cbec3" translate="yes" xml:space="preserve">
          <source>This specification defines two forms of metadata that are commonly
   used to observe resource state and test for preconditions:
   modification dates (&lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;) and opaque entity tags
   (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;).  Additional metadata that reflects resource state has
   been defined by various extensions of HTTP, such as Web Distributed
   Authoring and Versioning (WebDAV, [&lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC4918&lt;/a&gt;]), that are beyond the
   scope of this specification.  A resource metadata value is referred
   to as a &quot;validator&quot; when it is used within a precondition.</source>
          <target state="translated">Эта спецификация определяет две формы метаданных, которые обычно используются для наблюдения за состоянием ресурса и проверки предварительных условий: даты модификации ( &lt;a href=&quot;#section-2.2&quot;&gt;раздел 2.2&lt;/a&gt; ) и непрозрачные теги сущностей ( &lt;a href=&quot;#section-2.3&quot;&gt;раздел 2.3&lt;/a&gt; ). Дополнительные метаданные, отражающие состояние ресурса, были определены различными расширениями HTTP, такими как Web Distributed Authoring и Versioning (WebDAV, [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC4918&lt;/a&gt; ]), которые выходят за рамки данной спецификации. Значение метаданных ресурса называется &amp;laquo;валидатором&amp;raquo;, когда оно используется в предварительном условии.</target>
        </trans-unit>
        <trans-unit id="187fe63d0c83c4fa38b37175ce98332747f01af0" translate="yes" xml:space="preserve">
          <source>This specification defines two kinds of documents -- Category
   Documents and Service Documents.

   A Category Document (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) contains lists of categories
   specified using the &quot;atom:category&quot; element from the Atom Syndication
   Format (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC4287]&lt;/a&gt;).

   A Service Document (&lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;) groups available Collections into
   Workspaces.

   The namespace name [&lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;] for either kind of document is:

       &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;

   Atom Publishing Protocol XML Documents MUST be &quot;namespace-well-
   formed&quot; as specified in Section 7 of [&lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;].

   This specification uses the prefix &quot;app:&quot; for the namespace name.
   The prefix &quot;atom:&quot; is used for &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;, the
   namespace name of the Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].  These
   namespace prefixes are not semantically significant.

   This specification does not define any DTDs for Atom Protocol
   formats, and hence does not require them to be &quot;valid&quot; in the sense
   used by [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].</source>
          <target state="translated">Эта спецификация определяет два типа документов - документы категории и служебные документы. Документ категории ( &lt;a href=&quot;#section-7&quot;&gt;раздел 7&lt;/a&gt; ) содержит списки категорий, определенных с помощью элемента &quot;atom: category&quot; из формата синдикации Atom (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-4.2.2&quot;&gt;Раздел 4.2.2 [RFC4287]&lt;/a&gt; ). Сервисный документ ( &lt;a href=&quot;#section-8&quot;&gt;раздел 8&lt;/a&gt; ) группирует доступные коллекции в рабочие области. Имя пространства имен [ &lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt; ] для любого типа документа: &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; XML-документы протокола публикации Atom ДОЛЖНЫ быть &amp;laquo;правильно сформированными пространством имен&amp;raquo;, как указано в Разделе 7 [ &lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;]. В этой спецификации для имени пространства имен используется префикс &amp;laquo;app:&amp;raquo;. Префикс &amp;laquo;атом:&amp;raquo; используется для &amp;laquo; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; &amp;raquo;, имени пространства имен формата синдикации Atom [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]. Эти префиксы пространства имен не имеют семантического значения. Эта спецификация не определяет никаких DTD для форматов протокола Atom и, следовательно, не требует, чтобы они были &amp;laquo;действительными&amp;raquo; в смысле, используемом [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="6f49469a7f998d6aa7fb1c171080afd01320be81" translate="yes" xml:space="preserve">
          <source>This specification does not define the behavior of the PUT method for
   existing collections.  A PUT request to an existing collection MAY be
   treated as an error (405 Method Not Allowed).

   The MKCOL method is defined to create collections.</source>
          <target state="translated">Эта спецификация не определяет поведение PUT-метода для существующих коллекций.PUT-запрос к существующей коллекции МОЖЕТ быть обработан как ошибка (405 Метод не разрешен).Метод MKCOL определен для создания коллекций.</target>
        </trans-unit>
        <trans-unit id="d7d3f4f1fc7a5db64d2f982f26f4448b11b753a7" translate="yes" xml:space="preserve">
          <source>This specification encourages the use of &quot;A Universally Unique
   Identifier (UUID) URN Namespace&quot; ([&lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt;]) for lock tokens
   (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;), in order to guarantee their uniqueness across space
   and time.  Version 1 UUIDs (defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) MAY contain a
   &quot;node&quot; field that &quot;consists of an IEEE 802 MAC address, usually the
   host address.  For systems with multiple IEEE addresses, any
   available one can be used&quot;.  Since a WebDAV server will issue many
   locks over its lifetime, the implication is that it may also be
   publicly exposing its IEEE 802 address.

   There are several risks associated with exposure of IEEE 802
   addresses.  Using the IEEE 802 address:

   o  It is possible to track the movement of hardware from subnet to
      subnet.

   o  It may be possible to identify the manufacturer of the hardware
      running a WebDAV server.

   o  It may be possible to determine the number of each type of
      computer running WebDAV.

   This risk only applies to host-address-based UUID versions.  &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;4 of [RFC4122]&lt;/a&gt; describes several other mechanisms for generating
   UUIDs that do not involve the host address and therefore do not
   suffer from this risk.</source>
          <target state="translated">Эта спецификация поощряет использование &amp;laquo;пространства имен URN с универсальным уникальным идентификатором (UUID)&amp;raquo; ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt; ]) для токенов блокировки ( &lt;a href=&quot;#section-6.5&quot;&gt;раздел 6.5&lt;/a&gt; ), чтобы гарантировать их уникальность в пространстве и времени. UUID версии 1 (определены в &lt;a href=&quot;#section-4&quot;&gt;разделе 4&lt;/a&gt;) МОЖЕТ содержать поле &amp;laquo;узел&amp;raquo;, которое &amp;laquo;состоит из MAC-адреса IEEE 802, обычно адреса хоста. Для систем с несколькими адресами IEEE может использоваться любой доступный&amp;raquo;. Поскольку сервер WebDAV за время своего существования будет выдавать множество блокировок, это может означать, что он также может публично раскрывать свой адрес IEEE 802. Есть несколько рисков, связанных с раскрытием адресов IEEE 802. Использование адреса IEEE 802: o Можно отслеживать перемещение оборудования из подсети в подсеть. o Возможно, удастся определить производителя оборудования, на котором запущен сервер WebDAV. o Можно определить количество компьютеров каждого типа, на которых работает WebDAV. Этот риск распространяется только на версии UUID на основе адресов хоста. &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;Раздел &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;4 [RFC4122]&lt;/a&gt;описывает несколько других механизмов для генерации UUID, которые не связаны с адресом хоста и, следовательно, не подвержены этому риску.</target>
        </trans-unit>
        <trans-unit id="37eee64d4bf2bb8f0591eb5fc58512e72f0c0858" translate="yes" xml:space="preserve">
          <source>This specification has been carefully audited to correct and
   disambiguate key word usage; &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; had many problems in respect to
   the conventions laid out in &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [&lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt;].

   Clarified which error code should be used for inbound server failures
   (e.g. DNS failures). (&lt;a href=&quot;#section-10.5.5&quot;&gt;Section 10.5.5&lt;/a&gt;). 

   CREATE had a race that required an Etag be sent when a resource is
   first created. (&lt;a href=&quot;#section-10.2.2&quot;&gt;Section 10.2.2&lt;/a&gt;).

   Content-Base was deleted from the specification: it was not
   implemented widely, and there is no simple, safe way to introduce it
   without a robust extension mechanism. In addition, it is used in a
   similar, but not identical fashion in MHTML [&lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;].

   Transfer-coding and message lengths all interact in ways that
   required fixing exactly when chunked encoding is used (to allow for
   transfer encoding that may not be self delimiting); it was important
   to straighten out exactly how message lengths are computed. (Sections
   3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16)

   A content-coding of &quot;identity&quot; was introduced, to solve problems
   discovered in caching. (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;)

   Quality Values of zero should indicate that &quot;I don't want something&quot;
   to allow clients to refuse a representation. (&lt;a href=&quot;#section-3.9&quot;&gt;Section 3.9&lt;/a&gt;)

   The use and interpretation of HTTP version numbers has been clarified
   by &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;. Require proxies to upgrade requests to highest protocol
   version they support to deal with problems discovered in HTTP/1.0
   implementations (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;)

   Charset wildcarding is introduced to avoid explosion of character set
   names in accept headers. (&lt;a href=&quot;#section-14.2&quot;&gt;Section 14.2&lt;/a&gt;)

   A case was missed in the Cache-Control model of HTTP/1.1; s-maxage
   was introduced to add this missing case. (Sections &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt;, &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;, &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;,
   14.9.3)

   The Cache-Control: max-age directive was not properly defined for
   responses. (&lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;)

   There are situations where a server (especially a proxy) does not
   know the full length of a response but is capable of serving a
   byterange request. We therefore need a mechanism to allow byteranges
   with a content-range not indicating the full length of the message.
   (&lt;a href=&quot;#section-14.16&quot;&gt;Section 14.16&lt;/a&gt;)

   Range request responses would become very verbose if all meta-data
   were always returned; by allowing the server to only send needed
   headers in a 206 response, this problem can be avoided. (&lt;a href=&quot;#section-10.2.7&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;, 13.5.3, and 14.27) 

   Fix problem with unsatisfiable range requests; there are two cases:
   syntactic problems, and range doesn't exist in the document. The 416
   status code was needed to resolve this ambiguity needed to indicate
   an error for a byte range request that falls outside of the actual
   contents of a document. (&lt;a href=&quot;#section-10.4.17&quot;&gt;Section 10.4.17&lt;/a&gt;, 14.16)

   Rewrite of message transmission requirements to make it much harder
   for implementors to get it wrong, as the consequences of errors here
   can have significant impact on the Internet, and to deal with the
   following problems:

      1. Changing &quot;HTTP/1.1 or later&quot; to &quot;HTTP/1.1&quot;, in contexts where
         this was incorrectly placing a requirement on the behavior of
         an implementation of a future version of HTTP/1.x

      2. Made it clear that user-agents should retry requests, not
         &quot;clients&quot; in general.

      3. Converted requirements for clients to ignore unexpected 100
         (Continue) responses, and for proxies to forward 100 responses,
         into a general requirement for 1xx responses.

      4. Modified some TCP-specific language, to make it clearer that
         non-TCP transports are possible for HTTP.

      5. Require that the origin server MUST NOT wait for the request
         body before it sends a required 100 (Continue) response.

      6. Allow, rather than require, a server to omit 100 (Continue) if
         it has already seen some of the request body.

      7. Allow servers to defend against denial-of-service attacks and
         broken clients.

   This change adds the Expect header and 417 status code. The message
   transmission requirements fixes are in sections &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;, &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt;,
   8.1.2.2, 13.11, and 14.20.

   Proxies should be able to add Content-Length when appropriate.
   (&lt;a href=&quot;#section-13.5.2&quot;&gt;Section 13.5.2&lt;/a&gt;)

   Clean up confusion between 403 and 404 responses. (&lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;,
   10.4.5, and 10.4.11)

   Warnings could be cached incorrectly, or not updated appropriately.
   (&lt;a href=&quot;#section-13.1.2&quot;&gt;Section 13.1.2&lt;/a&gt;, 13.2.4, 13.5.2, 13.5.3, 14.9.3, and 14.46) Warning
   also needed to be a general header, as PUT or other methods may have
   need for it in requests. 

   Transfer-coding had significant problems, particularly with
   interactions with chunked encoding. The solution is that transfer-
   codings become as full fledged as content-codings. This involves
   adding an IANA registry for transfer-codings (separate from content
   codings), a new header field (TE) and enabling trailer headers in the
   future. Transfer encoding is a major performance benefit, so it was
   worth fixing [&lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt;]. TE also solves another, obscure, downward
   interoperability problem that could have occurred due to interactions
   between authentication trailers, chunked encoding and HTTP/1.0
   clients.(&lt;a href=&quot;#section-3.6&quot;&gt;Section 3.6&lt;/a&gt;, 3.6.1, and 14.39)

   The PATCH, LINK, UNLINK methods were defined but not commonly
   implemented in previous versions of this specification. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;
   [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;].

   The Alternates, Content-Version, Derived-From, Link, URI, Public and
   Content-Base header fields were defined in previous versions of this
   specification, but not commonly implemented. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;].</source>
          <target state="translated">Эта спецификация была тщательно проверена, чтобы исправить и устранить неоднозначность использования ключевых слов; &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; имел много проблем в отношении соглашений, изложенных в &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [ &lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt; ]. Уточнено, какой код ошибки следует использовать при сбоях входящего сервера (например, сбоях DNS). ( &lt;a href=&quot;#section-10.5.5&quot;&gt;Раздел 10.5.5&lt;/a&gt; ). В CREATE была гонка, которая требовала отправки Etag при первом создании ресурса. ( &lt;a href=&quot;#section-10.2.2&quot;&gt;Раздел 10.2.2&lt;/a&gt; ). Content-Base был удален из спецификации: он не получил широкого распространения, и нет простого и безопасного способа внедрить его без надежного механизма расширения. Кроме того, он используется аналогичным, но не идентичным образом в MHTML [ &lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;]. Кодирование передачи и длина сообщений взаимодействуют между собой способами, которые требуют исправления именно тогда, когда используется кодирование по фрагментам (чтобы разрешить кодирование передачи, которое может не быть саморазграничивающимся); Было важно уточнить, как именно рассчитывается длина сообщений. (Разделы 3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16) Для решения проблем, обнаруженных при кэшировании, было введено кодирование содержимого &amp;laquo;идентичности&amp;raquo;. ( &lt;a href=&quot;#section-3.5&quot;&gt;раздел 3.5&lt;/a&gt; ) Нулевые значения качества должны указывать на то, что &amp;laquo;я чего-то не хочу&amp;raquo;, чтобы клиенты могли отказаться от представления. ( &lt;a href=&quot;#section-3.9&quot;&gt;Раздел 3.9&lt;/a&gt; ) Использование и интерпретация номеров версий HTTP разъяснены в &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145.&lt;/a&gt;, Требовать от прокси-серверов обновлять запросы до самой высокой версии протокола, которую они поддерживают, для решения проблем, обнаруженных в реализациях HTTP / 1.0 ( &lt;a href=&quot;#section-3.1&quot;&gt;раздел 3.1&lt;/a&gt; ). Введены подстановочные знаки набора символов, чтобы избежать взрыва имен наборов символов в заголовках принятия. ( &lt;a href=&quot;#section-14.2&quot;&gt;Раздел 14.2&lt;/a&gt; ) В модели Cache-Control HTTP / 1.1 упущен случай; s-maxage был введен, чтобы добавить этот отсутствующий случай. (Разделы &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt; , &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt; , &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt; , 14.9.3) Директива Cache-Control: max-age не была правильно определена для ответов. ( &lt;a href=&quot;#section-14.9.3&quot;&gt;Раздел 14.9.3&lt;/a&gt;) Бывают ситуации, когда сервер (особенно прокси) не знает полной длины ответа, но может обслуживать запрос байтового диапазона. Поэтому нам нужен механизм, разрешающий байтовые взаимодействия с диапазоном содержимого, не указывающим полную длину сообщения. ( &lt;a href=&quot;#section-14.16&quot;&gt;Раздел 14.16&lt;/a&gt; ) Ответы на запросы диапазона стали бы очень подробными, если бы все метаданные всегда возвращались; разрешив серверу отправлять только необходимые заголовки в ответе 206, можно избежать этой проблемы. ( &lt;a href=&quot;#section-10.2.7&quot;&gt;Раздел &lt;/a&gt;&lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;, 13.5.3 и 14.27) Исправить проблему с невыполнимыми запросами диапазона; есть два случая: синтаксические проблемы и диапазон не существует в документе. Код состояния 416 был необходим для устранения этой неоднозначности, необходимой для указания ошибки для запроса диапазона байтов, выходящего за рамки фактического содержимого документа. ( &lt;a href=&quot;#section-10.4.17&quot;&gt;Раздел 10.4.17&lt;/a&gt;, 14.16) Перепишите требования к передаче сообщений, чтобы разработчикам было намного сложнее ошибиться, поскольку последствия ошибок здесь могут иметь существенное влияние на Интернет, и решить следующие проблемы: 1. Изменение &amp;laquo;HTTP / 1.1 или позже &amp;laquo;на&amp;laquo; HTTP / 1.1 &amp;raquo;, в контекстах, где это неправильно ставило требование к поведению реализации будущей версии HTTP / 1.x 2. Стало ясно, что пользовательские агенты должны повторять запросы, а не&amp;laquo; клиенты &amp;raquo; &quot; В основном. 3. Преобразованы требования для клиентов игнорировать неожиданные 100 (Продолжить) ответов и для прокси-серверов на пересылку 100 ответов в общее требование для ответов 1xx. 4. Изменен некоторый язык, специфичный для TCP,чтобы было понятнее, что для HTTP возможны не-TCP-транспорты. 5. Требовать, чтобы исходный сервер НЕ ДОЛЖЕН ждать тела запроса, прежде чем он отправит требуемый ответ 100 (Продолжить). 6. Разрешить, а не требовать, чтобы сервер пропускал 100 (Продолжить), если он уже видел часть тела запроса. 7. Разрешить серверам защищаться от атак типа &amp;laquo;отказ в обслуживании&amp;raquo; и сломанных клиентов. Это изменение добавляет заголовок Expect и код состояния 417. Исправления требований к передаче сообщений находятся в разделахсервер должен пропустить 100 (Продолжить), если он уже видел часть тела запроса. 7. Разрешить серверам защищаться от атак типа &amp;laquo;отказ в обслуживании&amp;raquo; и сломанных клиентов. Это изменение добавляет заголовок Expect и код состояния 417. Исправления требований к передаче сообщений находятся в разделахсервер должен пропустить 100 (Продолжить), если он уже видел часть тела запроса. 7. Разрешить серверам защищаться от атак типа &amp;laquo;отказ в обслуживании&amp;raquo; и сломанных клиентов. Это изменение добавляет заголовок Expect и код состояния 417. Исправления требований к передаче сообщений находятся в разделах&lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; , &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt; , 8.1.2.2, 13.11 и 14.20. Прокси-серверы должны иметь возможность добавлять Content-Length, когда это необходимо. ( &lt;a href=&quot;#section-13.5.2&quot;&gt;Раздел 13.5.2&lt;/a&gt; ) Устраните путаницу между ответами 403 и 404. ( &lt;a href=&quot;#section-10.4.4&quot;&gt;Разделы 10.4.4&lt;/a&gt; , 10.4.5 и 10.4.11) Предупреждения могли быть неправильно кэшированы или обновлены неправильно. ( &lt;a href=&quot;#section-13.1.2&quot;&gt;Раздел 13.1.2&lt;/a&gt;, 13.2.4, 13.5.2, 13.5.3, 14.9.3 и 14.46) Предупреждение также должно быть общим заголовком, так как PUT или другие методы могут нуждаться в нем в запросах. Передаточное кодирование имело серьезные проблемы, особенно при взаимодействии с фрагментированным кодированием. Решение состоит в том, что кодирование передачи становится таким же полноценным, как и кодирование содержимого. Это включает добавление реестра IANA для кодирования передачи (отдельно от кодирования контента), нового поля заголовка (TE) и включения заголовков трейлеров в будущем. Кодирование передачи - главное преимущество в производительности, поэтому его стоило исправить [ &lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt; ]. TE также решает другую, неясную проблему нисходящей совместимости, которая могла возникнуть из-за взаимодействия между трейлерами аутентификации, фрагментированным кодированием и клиентами HTTP / 1.0 ( &lt;a href=&quot;#section-3.6&quot;&gt;раздел 3.6.&lt;/a&gt;, 3.6.1 и 14.39) Методы PATCH, LINK, UNLINK были определены, но обычно не реализовывались в предыдущих версиях этой спецификации. См. &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]. Поля заголовков Alternates, Content-Version, Derived-From, Link, URI, Public и Content-Base были определены в предыдущих версиях этой спецификации, но обычно не применяются. См. &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="5c3aed10c6ed1ff4c98e713111fede52cc2146bd" translate="yes" xml:space="preserve">
          <source>This specification makes heavy use of the augmented BNF and generic
   constructs defined by David H. Crocker for &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Similarly, it
   reuses many of the definitions provided by Nathaniel Borenstein and
   Ned Freed for MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]. We hope that their inclusion in this
   specification will help reduce past confusion over the relationship
   between HTTP and Internet mail message formats.

   The HTTP protocol has evolved considerably over the years. It has
   benefited from a large and active developer community--the many
   people who have participated on the www-talk mailing list--and it is
   that community which has been most responsible for the success of
   HTTP and of the World-Wide Web in general. Marc Andreessen, Robert
   Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois
   Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob
   McCool, Lou Montulli, Dave Raggett, Tony Sanders, and Marc
   VanHeyningen deserve special recognition for their efforts in
   defining early aspects of the protocol.

   This document has benefited greatly from the comments of all those
   participating in the HTTP-WG. In addition to those already mentioned,
   the following individuals have contributed to this specification: 

       Gary Adams                  Ross Patterson
       Harald Tveit Alvestrand     Albert Lunde
       Keith Ball                  John C. Mallery
       Brian Behlendorf            Jean-Philippe Martin-Flatin
       Paul Burchard               Mitra
       Maurizio Codogno            David Morris
       Mike Cowlishaw              Gavin Nicol
       Roman Czyborra              Bill Perry
       Michael A. Dolan            Jeffrey Perry
       David J. Fiander            Scott Powers
       Alan Freier                 Owen Rees
       Marc Hedlund                Luigi Rizzo
       Greg Herlihy                David Robinson
       Koen Holtman                Marc Salomon
       Alex Hopmann                Rich Salz
       Bob Jernigan                Allan M. Schiffman
       Shel Kaphan                 Jim Seidman
       Rohit Khare                 Chuck Shotton
       John Klensin                Eric W. Sink
       Martijn Koster              Simon E. Spero
       Alexei Kosut                Richard N. Taylor
       David M. Kristol            Robert S. Thau
       Daniel LaLiberte            Bill (BearHeart) Weinman
       Ben Laurie                  Francois Yergeau
       Paul J. Leach               Mary Ellen Zurko
       Daniel DuBois               Josh Cohen


   Much of the content and presentation of the caching design is due to
   suggestions and comments from individuals including: Shel Kaphan,
   Paul Leach, Koen Holtman, David Morris, and Larry Masinter.

   Most of the specification of ranges is based on work originally done
   by Ari Luotonen and John Franks, with additional input from Steve
   Zilles.

   Thanks to the &quot;cave men&quot; of Palo Alto. You know who you are.

   Jim Gettys (the current editor of this document) wishes particularly
   to thank Roy Fielding, the previous editor of this document, along
   with John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen
   Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence, and
   Larry Masinter for their help. And thanks go particularly to Jeff
   Mogul and Scott Lawrence for performing the &quot;MUST/MAY/SHOULD&quot; audit. 

   The Apache Group, Anselm Baird-Smith, author of Jigsaw, and Henrik
   Frystyk implemented &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; early, and we wish to thank them for the
   discovery of many of the problems that this document attempts to
   rectify.</source>
          <target state="translated">Эта спецификация интенсивно использует расширенный BNF и общие конструкции, определенные Дэвидом Х. Крокером для &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]. Точно так же он повторно использует многие определения, данные Натаниэлем Боренштейном и Недом Фридом для MIME [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]. Мы надеемся, что их включение в эту спецификацию поможет избежать путаницы в прошлом по поводу взаимосвязи между форматами сообщений электронной почты HTTP и Интернета. Протокол HTTP значительно эволюционировал за эти годы. Он получил пользу от большого и активного сообщества разработчиков - многих людей, участвовавших в списке рассылки www-talk - и именно это сообщество внесло наибольшую ответственность за успех HTTP и всемирной паутины в мире. Общее. Марк Андриссен, Роберт Кайо, Дэниел В. Коннолли, Боб Денни, Джон Фрэнкс, Жан-Франсуа Грофф, Филипп М. Халлам-Бейкер, Хакон В. Ли, Ари Луотонен, Роб МакКул, Лу Монтулли, Дэйв Рэггетт, Тони Сандерс и Марк ВанХейнинген заслуживает особого признания за их усилия по определению ранних аспектов протокола.В этом документе были учтены комментарии всех участников HTTP-WG. В дополнение к уже упомянутым, следующие люди внесли свой вклад в эту спецификацию: Гэри Адамс Росс Паттерсон Харальд Твейт Альвестранд Альберт Лунде Кейт Болл Джон К. Маллери Брайан Белендорф Жан-Филипп Мартин-Флатен Пол Бурчард Митра Маурицио Кодоньо Дэвид Моррис Майк Коулишоу Гэвин Никол Роман Чиборра Билл Перри Майкл А. Долан Джеффри Перри Дэвид Дж.Фиандер Скотт Пауэрс Алан Фрейер Оуэн Риз Марк Хедлунд Луиджи Риццо Грег Херлихи Дэвид Робинсон Коен Холтман Марк Саломон Алекс Хопманн Рич Зальц Боб Джерниган Аллан М. Шиффман Шел Капхан Джим Зейдман Рохит Харе Чак Шоттон Джон Кленсин У. Синк Мартиджн Костер Косут Ричард Н. Тейлор Дэвид М. Кристол Роберт С. Тау Даниэль Лалиберте Билл (BearHeart) Вайнман Бен Лори Франсуа Йерго Пол Дж.Лич Мэри Эллен Зурко Даниэль Дюбуа Джош Коэн Большая часть содержания и представления дизайна кэширования обусловлена ​​предложениями и комментариями отдельных лиц, включая: Шел Капхан, Пол Лич, Коэн Холтман, Дэвид Моррис и Ларри Масинтер. Большая часть спецификации диапазонов основана на работе, первоначально выполненной Ари Луотоненом и Джоном Фрэнксом, с дополнительным вкладом Стива Зиллеса. Спасибо &amp;laquo;пещерным людям&amp;raquo; Пало-Альто. Ты знаешь кто ты есть. Джим Геттис (нынешний редактор этого документа) хотел бы особенно поблагодарить Роя Филдинга, предыдущего редактора этого документа, а также Джона Кленсина, Джеффа Могула, Пола Лича, Дэйва Кристола, Коэна Холтмана, Джона Фрэнкса, Джоша Коэна, Алекса Хопмана, Скотту Лоуренсу и Ларри Масинтеру за их помощь.И особенно спасибо Джеффу Могулу и Скотту Лоуренсу за выполнение аудита &amp;laquo;ДОЛЖЕН / МОЖЕТ / ДОЛЖЕН&amp;raquo;. Группа Apache, Ансельм Бэрд-Смит, автор Jigsaw, и Хенрик Фристик реализовали&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; раньше, и мы хотим поблагодарить их за обнаружение многих проблем, которые этот документ пытается исправить.</target>
        </trans-unit>
        <trans-unit id="3fad4602c9c700895f3ed6117008bdc18c9fc181" translate="yes" xml:space="preserve">
          <source>This specification reserves the method name CONNECT for use with a
   proxy that can dynamically switch to being a tunnel (e.g. SSL
   tunneling [&lt;a href=&quot;#ref-44&quot;&gt;44&lt;/a&gt;]).</source>
          <target state="translated">Эта спецификация резервирует имя метода CONNECT для использования с прокси, который может динамически переключаться на туннель (например, туннелирование SSL [ &lt;a href=&quot;#ref-44&quot;&gt;44&lt;/a&gt; ]).</target>
        </trans-unit>
        <trans-unit id="672729314726c61a4c205fd539620a1ce076c9fe" translate="yes" xml:space="preserve">
          <source>This specification takes over the definition of the HTTP
   Authentication Framework, previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.  We thank
   John Franks, Phillip M. Hallam-Baker, Jeffery L. Hostetler, Scott D.
   Lawrence, Paul J. Leach, Ari Luotonen, and Lawrence C. Stewart for
   their work on that specification.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc2617#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC2617]&lt;/a&gt; for
   further acknowledgements.

   See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;Section&amp;nbsp;10 of [RFC7230]&lt;/a&gt; for the Acknowledgments related to this
   document revision.</source>
          <target state="translated">Эта спецификация берет на себя определение структуры HTTP-аутентификации, ранее определенное в &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt; . Мы благодарим Джона Фрэнкса, Филиппа М. Халлам-Бейкера, Джеффри Л. Хостетлера, Скотта Д. Лоуренса, Пола Дж. Лича, Ари Луотонена и Лоуренса С. Стюарта за их работу над этой спецификацией. См. &lt;a href=&quot;https://tools.ietf.org/html/rfc2617#section-6&quot;&gt;Раздел 6 [RFC2617]&lt;/a&gt; для получения дополнительной информации. См. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;Раздел 10 [RFC7230], где указаны&lt;/a&gt; Благодарности, относящиеся к этой редакции документа.</target>
        </trans-unit>
        <trans-unit id="199a33e3a0bbdd6ce39373b856043ea2c7f5f848" translate="yes" xml:space="preserve">
          <source>This specification targets conformance criteria according to the role
   of a participant in HTTP communication.  Hence, HTTP requirements are
   placed on senders, recipients, clients, servers, user agents,
   intermediaries, origin servers, proxies, gateways, or caches,
   depending on what behavior is being constrained by the requirement.
   Additional (social) requirements are placed on implementations,
   resource owners, and protocol element registrations when they apply
   beyond the scope of a single communication.

   The verb &quot;generate&quot; is used instead of &quot;send&quot; where a requirement
   differentiates between creating a protocol element and merely
   forwarding a received element downstream.

   An implementation is considered conformant if it complies with all of
   the requirements associated with the roles it partakes in HTTP.

   Conformance includes both the syntax and semantics of protocol
   elements.  A sender MUST NOT generate protocol elements that convey a
   meaning that is known by that sender to be false.  A sender MUST NOT
   generate protocol elements that do not match the grammar defined by
   the corresponding ABNF rules.  Within a given message, a sender MUST
   NOT generate protocol elements or syntax alternatives that are only
   allowed to be generated by participants in other roles (i.e., a role
   that the sender does not have for that message).

   When a received protocol element is parsed, the recipient MUST be
   able to parse any value of reasonable length that is applicable to
   the recipient's role and that matches the grammar defined by the
   corresponding ABNF rules.  Note, however, that some received protocol
   elements might not be parsed.  For example, an intermediary 

   forwarding a message might parse a header-field into generic
   field-name and field-value components, but then forward the header
   field without further parsing inside the field-value.

   HTTP does not have specific length limitations for many of its
   protocol elements because the lengths that might be appropriate will
   vary widely, depending on the deployment context and purpose of the
   implementation.  Hence, interoperability between senders and
   recipients depends on shared expectations regarding what is a
   reasonable length for each protocol element.  Furthermore, what is
   commonly understood to be a reasonable length for some protocol
   elements has changed over the course of the past two decades of HTTP
   use and is expected to continue changing in the future.

   At a minimum, a recipient MUST be able to parse and process protocol
   element lengths that are at least as long as the values that it
   generates for those same protocol elements in other messages.  For
   example, an origin server that publishes very long URI references to
   its own resources needs to be able to parse and process those same
   references when received as a request target.

   A recipient MUST interpret a received protocol element according to
   the semantics defined for it by this specification, including
   extensions to this specification, unless the recipient has determined
   (through experience or configuration) that the sender incorrectly
   implements what is implied by those semantics.  For example, an
   origin server might disregard the contents of a received
   Accept-Encoding header field if inspection of the User-Agent header
   field indicates a specific implementation version that is known to
   fail on receipt of certain content codings.

   Unless noted otherwise, a recipient MAY attempt to recover a usable
   protocol element from an invalid construct.  HTTP does not define
   specific error handling mechanisms except when they have a direct
   impact on security, since different applications of the protocol
   require different error handling strategies.  For example, a Web
   browser might wish to transparently recover from a response where the
   Location header field doesn't parse according to the ABNF, whereas a
   systems control client might consider any form of error recovery to
   be dangerous.</source>
          <target state="translated">Данная спецификация устанавливает критерии соответствия в соответствии с ролью участника в коммуникации HTTP.Таким образом,требования HTTP предъявляются к отправителям,получателям,клиентам,серверам,агентам пользователей,посредникам,исходным серверам,прокси-серверам,шлюзам или кэшам,в зависимости от того,какое поведение ограничивается требованием.Дополнительные (социальные)требования предъявляются к реализации,владельцам ресурсов и регистрации протокольного элемента,когда они применяются вне рамок одного взаимодействия.Глагол &quot;генерировать&quot; используется вместо &quot;посылать&quot;,когда требование различает создание элемента протокола и простую пересылку полученного элемента вниз по потоку.Реализация считается соответствующей,если она соответствует всем требованиям,связанным с ролями,которые она разделяет в HTTP.Соответствие включает в себя как синтаксис,так и семантику элементов протокола.Отправитель НЕ ДОЛЖЕН генерировать элементы протокола,которые передают значение,известное этому отправителю как ложное.Отправитель НЕ ДОЛЖЕН генерировать элементы протокола,которые не соответствуют грамматике,определенной соответствующими правилами ABNF.Внутри данного сообщения отправитель НЕ ДОЛЖЕН генерировать элементы протокола или альтернативы синтаксиса,которые могут быть сгенерированы только участниками других ролей (т.е.роль,которую отправитель не имеет для данного сообщения).При разборе элемента принятого протокола получатель ДОЛЖЕН уметь разобрать любое значение разумной длины,которое применимо к роли получателя и соответствует грамматике,определенной соответствующими правилами ABNF.Обратите внимание,однако,что некоторые элементы принятого протокола могут не быть разобраны.Например,посредник,пересылающий сообщение,может разобрать поле заголовка на общие компоненты имени поля и значения поля,но затем пересылать поле заголовка без дальнейшего разбора внутри значения поля.HTTP не имеет конкретных ограничений по длине для многих своих элементов протокола,потому что длины,которые могут быть подходящими,будут сильно варьироваться в зависимости от контекста развертывания и цели реализации.Следовательно,функциональная совместимость между отправителями и получателями зависит от общих ожиданий относительно того,какая длина будет приемлемой для каждого элемента протокола.Более того,то,что обычно понимается как разумная длина для некоторых элементов протокола,изменилось за последние два десятилетия использования HTTP и,как ожидается,будет продолжать меняться в будущем.Как минимум,получатель ДОЛЖЕН уметь разобрать и обработать длины элементов протокола,которые как минимум равны значениям,которые он генерирует для тех же элементов протокола в других сообщениях.Например,сервер происхождения,который публикует очень длинные ссылки URI на свои собственные ресурсы,должен иметь возможность разобрать и обработать те же самые ссылки,когда они поступают в качестве цели запроса.Получатель ДОЛЖЕН интерпретировать элемент полученного протокола в соответствии с семантикой,определенной для него этой спецификацией,включая расширения этой спецификации,если только получатель не определил (через опыт или конфигурацию),что отправитель неправильно реализует то,что подразумевается этой семантикой.Например,сервер отправителя может не обращать внимания на содержимое полученного поля заголовка Accept-Encoding,если проверка поля заголовка User-Agent указывает на конкретную версию реализации,которая,как известно,не работает при получении определенных кодов содержимого.Если не указано иное,получатель MAY пытается восстановить используемый элемент протокола из недействительной конструкции.HTTP не определяет конкретные механизмы обработки ошибок,за исключением тех случаев,когда они непосредственно влияют на безопасность,поскольку различные приложения протокола требуют различных стратегий обработки ошибок.Например,веб-браузер может захотеть прозрачно восстанавливаться из ответа,в котором поле заголовка Location не разобрано в соответствии с ABNF,в то время как клиент,контролирующий систему,может посчитать любую форму восстановления ошибок опасной.</target>
        </trans-unit>
        <trans-unit id="facba0308af11f7848962366e11eb270544c791e" translate="yes" xml:space="preserve">
          <source>This specification uses a number of terms to refer to the roles
   played by participants in, and objects of, the HTTP communication.

   connection
      A transport layer virtual circuit established between two programs
      for the purpose of communication.

   message
      The basic unit of HTTP communication, consisting of a structured
      sequence of octets matching the syntax defined in &lt;a href=&quot;#section-4&quot;&gt;section 4&lt;/a&gt; and
      transmitted via the connection.

   request
      An HTTP request message, as defined in &lt;a href=&quot;#section-5&quot;&gt;section 5&lt;/a&gt;.

   response
      An HTTP response message, as defined in &lt;a href=&quot;#section-6&quot;&gt;section 6&lt;/a&gt;. 

   resource
      A network data object or service that can be identified by a URI,
      as defined in &lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;. Resources may be available in multiple
      representations (e.g. multiple languages, data formats, size, and
      resolutions) or vary in other ways.

   entity
      The information transferred as the payload of a request or
      response. An entity consists of metainformation in the form of
      entity-header fields and content in the form of an entity-body, as
      described in &lt;a href=&quot;#section-7&quot;&gt;section 7&lt;/a&gt;.

   representation
      An entity included with a response that is subject to content
      negotiation, as described in &lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;. There may exist multiple
      representations associated with a particular response status.

   content negotiation
      The mechanism for selecting the appropriate representation when
      servicing a request, as described in &lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;. The
      representation of entities in any response can be negotiated
      (including error responses).

   variant
      A resource may have one, or more than one, representation(s)
      associated with it at any given instant. Each of these
      representations is termed a `varriant'.  Use of the term `variant'
      does not necessarily imply that the resource is subject to content
      negotiation.

   client
      A program that establishes connections for the purpose of sending
      requests.

   user agent
      The client which initiates a request. These are often browsers,
      editors, spiders (web-traversing robots), or other end user tools.

   server
      An application program that accepts connections in order to
      service requests by sending back responses. Any given program may
      be capable of being both a client and a server; our use of these
      terms refers only to the role being performed by the program for a
      particular connection, rather than to the program's capabilities
      in general. Likewise, any server may act as an origin server,
      proxy, gateway, or tunnel, switching behavior based on the nature
      of each request. 

   origin server
      The server on which a given resource resides or is to be created.

   proxy
      An intermediary program which acts as both a server and a client
      for the purpose of making requests on behalf of other clients.
      Requests are serviced internally or by passing them on, with
      possible translation, to other servers. A proxy MUST implement
      both the client and server requirements of this specification. A
      &quot;transparent proxy&quot; is a proxy that does not modify the request or
      response beyond what is required for proxy authentication and
      identification. A &quot;non-transparent proxy&quot; is a proxy that modifies
      the request or response in order to provide some added service to
      the user agent, such as group annotation services, media type
      transformation, protocol reduction, or anonymity filtering. Except
      where either transparent or non-transparent behavior is explicitly
      stated, the HTTP proxy requirements apply to both types of
      proxies.

   gateway
      A server which acts as an intermediary for some other server.
      Unlike a proxy, a gateway receives requests as if it were the
      origin server for the requested resource; the requesting client
      may not be aware that it is communicating with a gateway.

   tunnel
      An intermediary program which is acting as a blind relay between
      two connections. Once active, a tunnel is not considered a party
      to the HTTP communication, though the tunnel may have been
      initiated by an HTTP request. The tunnel ceases to exist when both
      ends of the relayed connections are closed.

   cache
      A program's local store of response messages and the subsystem
      that controls its message storage, retrieval, and deletion. A
      cache stores cacheable responses in order to reduce the response
      time and network bandwidth consumption on future, equivalent
      requests. Any client or server may include a cache, though a cache
      cannot be used by a server that is acting as a tunnel.

   cacheable
      A response is cacheable if a cache is allowed to store a copy of
      the response message for use in answering subsequent requests. The
      rules for determining the cacheability of HTTP responses are
      defined in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;. Even if a resource is cacheable, there may
      be additional constraints on whether a cache can use the cached
      copy for a particular request. 

   first-hand
      A response is first-hand if it comes directly and without
      unnecessary delay from the origin server, perhaps via one or more
      proxies. A response is also first-hand if its validity has just
      been checked directly with the origin server.

   explicit expiration time
      The time at which the origin server intends that an entity should
      no longer be returned by a cache without further validation.

   heuristic expiration time
      An expiration time assigned by a cache when no explicit expiration
      time is available.

   age
      The age of a response is the time since it was sent by, or
      successfully validated with, the origin server.

   freshness lifetime
      The length of time between the generation of a response and its
      expiration time.

   fresh
      A response is fresh if its age has not yet exceeded its freshness
      lifetime.

   stale
      A response is stale if its age has passed its freshness lifetime.

   semantically transparent
      A cache behaves in a &quot;semantically transparent&quot; manner, with
      respect to a particular response, when its use affects neither the
      requesting client nor the origin server, except to improve
      performance. When a cache is semantically transparent, the client
      receives exactly the same response (except for hop-by-hop headers)
      that it would have received had its request been handled directly
      by the origin server.

   validator
      A protocol element (e.g., an entity tag or a Last-Modified time)
      that is used to find out whether a cache entry is an equivalent
      copy of an entity.

   upstream/downstream
      Upstream and downstream describe the flow of a message: all
      messages flow from upstream to downstream. 

   inbound/outbound
      Inbound and outbound refer to the request and response paths for
      messages: &quot;inbound&quot; means &quot;traveling toward the origin server&quot;,
      and &quot;outbound&quot; means &quot;traveling toward the user agent&quot;</source>
          <target state="translated">В этой спецификации используется ряд терминов для обозначения ролей, выполняемых участниками и объектами HTTP-коммуникации. соединение Виртуальный канал транспортного уровня, устанавливаемый между двумя программами с целью связи. message Базовая единица связи HTTP, состоящая из структурированной последовательности октетов, соответствующих синтаксису, определенному в &lt;a href=&quot;#section-4&quot;&gt;разделе 4,&lt;/a&gt; и передаваемых через соединение. request Сообщение HTTP-запроса, как определено в &lt;a href=&quot;#section-5&quot;&gt;разделе 5&lt;/a&gt; . response Сообщение HTTP-ответа, как определено в &lt;a href=&quot;#section-6&quot;&gt;разделе 6&lt;/a&gt; . ресурс Сетевой объект данных или сервис, который может быть идентифицирован с помощью URI, как определено в &lt;a href=&quot;#section-3.2&quot;&gt;разделе 3.2.&lt;/a&gt;, Ресурсы могут быть доступны в нескольких представлениях (например, на нескольких языках, форматах данных, размере и разрешении) или различаться другими способами. entity Информация, передаваемая как полезная нагрузка запроса или ответа. Сущность состоит из метаинформации в виде полей заголовка сущности и содержимого в форме тела сущности, как описано в &lt;a href=&quot;#section-7&quot;&gt;разделе 7&lt;/a&gt; . представление Сущность, включенная в ответ, который подлежит согласованию содержимого, как описано в &lt;a href=&quot;#section-12&quot;&gt;разделе 12&lt;/a&gt; . Может существовать несколько представлений, связанных с определенным статусом ответа. согласование содержимого. Механизм выбора подходящего представления при обслуживании запроса, как описано в &lt;a href=&quot;#section-12&quot;&gt;разделе 12.&lt;/a&gt;, О представлении сущностей в любом ответе можно договориться (включая ответы об ошибках). вариант Ресурс может иметь одно или несколько представлений, связанных с ним в любой данный момент. Каждое из этих представлений называется &quot;вариантом&quot;. Использование термина &quot;вариант&quot; не обязательно означает, что ресурс является предметом согласования содержания. клиент. Программа, которая устанавливает соединения для отправки запросов. агент пользователя Клиент, который инициирует запрос. Часто это браузеры, редакторы, пауки (роботы, перемещающиеся по сети) или другие инструменты для конечных пользователей. server Прикладная программа, которая принимает соединения для обслуживания запросов путем отправки ответов.Любая данная программа может быть как клиентом, так и сервером; наше использование этих терминов относится только к роли, выполняемой программой для конкретного соединения, а не к возможностям программы в целом. Точно так же любой сервер может действовать как исходный сервер, прокси, шлюз или туннель, переключаясь в зависимости от характера каждого запроса. исходный сервер Сервер, на котором данный ресурс находится или должен быть создан. прокси. Программа-посредник, которая действует и как сервер, и как клиент с целью выполнения запросов от имени других клиентов. Запросы обслуживаются внутри компании или путем их передачи с возможным переводом на другие серверы. Прокси-сервер ДОЛЖЕН соответствовать требованиям данной спецификации как к клиенту, так и к серверу.&amp;laquo;Прозрачный прокси&amp;raquo; - это прокси, который не изменяет запрос или ответ сверх того, что требуется для аутентификации и идентификации прокси. &amp;laquo;Непрозрачный прокси&amp;raquo; - это прокси-сервер, который изменяет запрос или ответ, чтобы предоставить некоторую дополнительную услугу пользовательскому агенту, например, услуги аннотации групп, преобразование типа мультимедиа, сокращение протокола или фильтрацию анонимности. За исключением случаев, когда явно указано прозрачное или непрозрачное поведение, требования HTTP-прокси применяются к обоим типам прокси. шлюз. Сервер, который действует как посредник для другого сервера. В отличие от прокси, шлюз принимает запросы, как если бы он был исходным сервером для запрошенного ресурса;запрашивающий клиент может не знать, что он обменивается данными со шлюзом. туннель. Промежуточная программа, которая действует как слепой ретранслятор между двумя соединениями. Будучи активным, туннель не считается стороной HTTP-соединения, хотя туннель мог быть инициирован HTTP-запросом. Туннель перестает существовать, когда закрываются оба конца ретранслируемых соединений. cache Локальное хранилище ответных сообщений программы и подсистема, которая управляет хранением, извлечением и удалением сообщений. В кэше хранятся кэшируемые ответы, чтобы сократить время отклика и потребление пропускной способности сети на будущие эквивалентные запросы. Любой клиент или сервер может включать в себя кеш, хотя кеш не может использоваться сервером, который действует как туннель.cacheable Ответ является кешируемым, если кешу разрешено хранить копию ответного сообщения для использования при ответах на последующие запросы. Правила определения кэшируемости HTTP-ответов определены в&lt;a href=&quot;#section-13&quot;&gt;Раздел 13&lt;/a&gt;, Даже если ресурс кэшируемый, могут быть дополнительные ограничения на то, может ли кэш использовать кэшированную копию для конкретного запроса. из первых рук Ответ приходит из первых рук, если он приходит напрямую и без ненужной задержки от исходного сервера, возможно, через один или несколько прокси. Ответ также предоставляется из первых рук, если его достоверность только что была проверена непосредственно с исходным сервером. явное время истечения срока действия Время, в которое исходный сервер предполагает, что объект больше не должен возвращаться кешем без дальнейшей проверки. эвристическое время истечения Срок действия, назначаемый кешем, когда явное время истечения недоступно. age Возраст ответа - это время с момента его отправки или успешной проверки исходным сервером.время жизни свежести Промежуток времени между генерацией ответа и временем его истечения. fresh Ответ считается свежим, если его возраст еще не превысил срок его свежести. устаревший Ответ считается устаревшим, если его возраст уже истек. семантически прозрачный Кэш ведет себя &amp;laquo;семантически прозрачным&amp;raquo; образом по отношению к конкретному ответу, когда его использование не влияет ни на запрашивающего клиента, ни на исходный сервер, за исключением повышения производительности. Когда кеш семантически прозрачен, клиент получает точно такой же ответ (за исключением пошаговых заголовков), который он получил бы, если бы его запрос был обработан непосредственно исходным сервером. валидатор Элемент протокола (например,тег объекта или время последнего изменения), который используется, чтобы узнать, является ли запись кэша эквивалентной копией объекта. upstream / downstream Upstream и downstream описывают поток сообщения: все сообщения идут от восходящего к нисходящему. входящие / исходящие входящие и исходящие относятся к путям запроса и ответа для сообщений: &amp;laquo;входящее&amp;raquo; означает &amp;laquo;движение к исходному серверу&amp;raquo;, а &amp;laquo;исходящее&amp;raquo; означает &amp;laquo;движение к пользовательскому агенту&amp;raquo;входящие / исходящие входящие и исходящие относятся к путям запроса и ответа для сообщений: &amp;laquo;входящее&amp;raquo; означает &amp;laquo;движение к исходному серверу&amp;raquo;, а &amp;laquo;исходящее&amp;raquo; означает &amp;laquo;движение к пользовательскому агенту&amp;raquo;входящие / исходящие входящие и исходящие относятся к путям запроса и ответа для сообщений: &amp;laquo;входящее&amp;raquo; означает &amp;laquo;движение к исходному серверу&amp;raquo;, а &amp;laquo;исходящее&amp;raquo; означает &amp;laquo;движение к пользовательскому агенту&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="5366fbe830e07db7f7079781b54e53bea8e2feb6" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;,
   that allows for compact definition of comma-separated lists using a
   '#' operator (similar to how the '*' operator indicates repetition).
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt; shows the collected grammar with all list operators
   expanded to standard ABNF notation.

   The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234], Appendix&amp;nbsp;B.1&lt;/a&gt;: ALPHA (letters), CR (carriage return), CRLF
   (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote),
   HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line
   feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any
   visible [&lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt;] character).

   As a convention, ABNF rule names prefixed with &quot;obs-&quot; denote
   &quot;obsolete&quot; grammar rules that appear for historical reasons.</source>
          <target state="translated">В этой спецификации используется нотация расширенной формы Бэкуса-Наура (ABNF) из [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] с расширением списка, определенным в &lt;a href=&quot;#section-7&quot;&gt;разделе 7&lt;/a&gt; , что позволяет компактно определять списки, разделенные запятыми, с помощью оператора '#' (аналогично тому, как '* 'означает повторение). &lt;a href=&quot;#appendix-B&quot;&gt;Приложение B&lt;/a&gt; показывает собранную грамматику со всеми операторами списка, расширенными до стандартной нотации ABNF. Следующие основные правила включены посредством ссылки, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234], Приложение B.1.&lt;/a&gt;: ALPHA (буквы), CR (возврат каретки), CRLF (CR LF), CTL (элементы управления), DIGIT (десятичные 0-9), DQUOTE (двойные кавычки), HEXDIG (шестнадцатеричные 0-9 / AF / af), HTAB (горизонтальная табуляция), LF (перевод строки), OCTET (любая 8-битная последовательность данных), SP (пробел) и VCHAR (любой видимый &lt;a href=&quot;#ref-USASCII&quot;&gt;символ&lt;/a&gt; [ USASCII ]). По соглашению, имена правил ABNF с префиксом &amp;laquo;obs-&amp;raquo; обозначают &amp;laquo;устаревшие&amp;raquo; грамматические правила, которые появляются по историческим причинам.</target>
        </trans-unit>
        <trans-unit id="3f746953f3428a5eccba921f06abcdb82aa34c60" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation.</source>
          <target state="translated">В этой спецификации используется нотация расширенной формы Бэкуса-Наура (ABNF) из [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] с расширением списка, определенным в &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;разделе 7 [RFC7230]&lt;/a&gt; , что позволяет компактно определять списки, разделенные запятыми, с помощью оператора '#' (аналогично как оператор '*' указывает на повторение). &lt;a href=&quot;#appendix-B&quot;&gt;Приложение B&lt;/a&gt; описывает правила, импортированные из других документов. &lt;a href=&quot;#appendix-C&quot;&gt;Приложение C&lt;/a&gt; показывает собранную грамматику со всеми операторами списка, расширенными до стандартной нотации ABNF.</target>
        </trans-unit>
        <trans-unit id="faf3c32d78c2b6483745156433268b97ba91a18a" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation.</source>
          <target state="translated">В этой спецификации используется нотация расширенной формы Бэкуса-Наура (ABNF) из [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] с расширением списка, определенным в &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;разделе 7 [RFC7230]&lt;/a&gt; , что позволяет компактно определять списки, разделенные запятыми, с помощью оператора '#' (аналогично как оператор '*' указывает на повторение). &lt;a href=&quot;#appendix-C&quot;&gt;Приложение C&lt;/a&gt; описывает правила, импортированные из других документов. &lt;a href=&quot;#appendix-D&quot;&gt;Приложение D&lt;/a&gt; показывает собранную грамматику со всеми операторами списков, расширенными до стандартной нотации ABNF.</target>
        </trans-unit>
        <trans-unit id="ee23ef0e85f4f9cd9d0acebbd9b86ac08e046506" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation. 

   This specification uses the terms &quot;character&quot;, &quot;character encoding
   scheme&quot;, &quot;charset&quot;, and &quot;protocol element&quot; as they are defined in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt;].</source>
          <target state="translated">В этой спецификации используется нотация расширенной формы Бэкуса-Наура (ABNF) из [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] с расширением списка, определенным в &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;разделе 7 [RFC7230]&lt;/a&gt; , что позволяет компактно определять списки, разделенные запятыми, с помощью оператора '#' (аналогично как оператор '*' указывает на повторение). &lt;a href=&quot;#appendix-C&quot;&gt;Приложение C&lt;/a&gt; описывает правила, импортированные из других документов. &lt;a href=&quot;#appendix-D&quot;&gt;Приложение D&lt;/a&gt; показывает собранную грамматику со всеми операторами списков, расширенными до стандартной нотации ABNF. В этой спецификации используются термины &amp;laquo;символ&amp;raquo;, &amp;laquo;схема кодировки символов&amp;raquo;, &amp;laquo; &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;набор&lt;/a&gt; символов&amp;raquo; и &amp;laquo;элемент протокола&amp;raquo;, как они определены в [ RFC6365 ].</target>
        </trans-unit>
        <trans-unit id="98343664a6355afcb4ca38df251b44b6714d8a1e" translate="yes" xml:space="preserve">
          <source>This specification uses three rules to denote the use of linear
   whitespace: OWS (optional whitespace), RWS (required whitespace), and
   BWS (&quot;bad&quot; whitespace).

   The OWS rule is used where zero or more linear whitespace octets
   might appear.  For protocol elements where optional whitespace is
   preferred to improve readability, a sender SHOULD generate the
   optional whitespace as a single SP; otherwise, a sender SHOULD NOT
   generate optional whitespace except as needed to white out invalid or
   unwanted protocol elements during in-place message filtering.

   The RWS rule is used when at least one linear whitespace octet is
   required to separate field tokens.  A sender SHOULD generate RWS as a
   single SP.

   The BWS rule is used where the grammar allows optional whitespace
   only for historical reasons.  A sender MUST NOT generate BWS in
   messages.  A recipient MUST parse for such bad whitespace and remove
   it before interpreting the protocol element. 

     OWS            = *( SP / HTAB )
                    ; optional whitespace
     RWS            = 1*( SP / HTAB )
                    ; required whitespace
     BWS            = OWS
                    ; &quot;bad&quot; whitespace</source>
          <target state="translated">Эта спецификация использует три правила для обозначения использования линейных пробельных символов:OWS (необязательные пробельные символы),RWS (обязательные пробельные символы)и BWS (&quot;плохие&quot; пробельные символы).Правило OWS используется там,где могут появиться нулевые или более линейные октеты пробела.Для элементов протокола,где необязательные пробельные символы предпочтительны для улучшения читабельности,отправитель SHOULD генерирует необязательные пробельные символы в виде одного ПВ;в противном случае,отправитель SHOULD НЕ генерирует необязательные пробельные символы,за исключением случаев,когда это необходимо для отсеивания недействительных или нежелательных элементов протокола во время фильтрации сообщений на месте.Правило RWS используется,когда для разделения маркеров полей требуется по крайней мере один линейный октет пробела.Отправитель SHOULD генерирует RWS в виде одного ПВ.Правило BWS используется,когда грамматика допускает необязательные пробельные символы только по историческим причинам.Отправитель НЕ ДОЛЖЕН генерировать BWS в сообщениях.Получатель ДОЛЖЕН разбирать такие плохие пробелы и удалять их перед интерпретацией элемента протокола.OWS=*(SP/HTAB);необязательный пробельный RWS=1*(SP/HTAB);требуемый пробельный BWS=OWS;&quot;плохой&quot; пробельный</target>
        </trans-unit>
        <trans-unit id="aff04232d95d6c1171cd6ab1415e3e08026d9557" translate="yes" xml:space="preserve">
          <source>This specification uses two new media types that conform to the
   registry mechanism described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC4288&lt;/a&gt;], a new message header that
   conforms to the registry mechanism described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt;], and two
   new link relations that conform to the registry mechanism described
   in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].</source>
          <target state="translated">В этой спецификации используются два новых типа носителей, которые соответствуют механизму реестра, описанному в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC4288&lt;/a&gt; ], новый заголовок сообщения, который соответствует механизму реестра, описанному в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt; ], и два новых отношения ссылок, которые соответствуют механизму реестра, описанному в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287]&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="168a50454b53ca416e50a221ecab212a73004d2b" translate="yes" xml:space="preserve">
          <source>This status code is used in HTTP 1.1 only for Request-URIs, not URIs
   in other locations.</source>
          <target state="translated">Этот код статуса используется в HTTP 1.1 только для Request-URIs,но не для URI в других местах.</target>
        </trans-unit>
        <trans-unit id="e6542819db91e2214f7b4c25edf572e8a36dacaa" translate="yes" xml:space="preserve">
          <source>This status is not generated by origin servers, but by intercepting proxies that control access to the network.</source>
          <target state="translated">Этот статус генерируется не исходными серверами,а перехватывающими прокси-серверами,которые контролируют доступ к сети.</target>
        </trans-unit>
        <trans-unit id="372dd7c8c17bd1505f433437b7bcad8e716c04b8" translate="yes" xml:space="preserve">
          <source>This status is sent with a &lt;a href=&quot;../headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; header that contains information on how to authorize correctly.</source>
          <target state="translated">Этот статус отправляется с заголовком &lt;a href=&quot;../headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; ,&lt;/a&gt; который содержит информацию о том, как правильно авторизоваться.</target>
        </trans-unit>
        <trans-unit id="a3cd34d9e9d7109fa13e3c0395c58eb46cc7b8a7" translate="yes" xml:space="preserve">
          <source>This status is sent with a &lt;a href=&quot;../headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header that contains information on how to authorize correctly.</source>
          <target state="translated">Этот статус отправляется с заголовком &lt;a href=&quot;../headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; ,&lt;/a&gt; который содержит информацию о том, как правильно авторизоваться.</target>
        </trans-unit>
        <trans-unit id="8a9d71b9023a06f11edab66435c308dc6a0ee383" translate="yes" xml:space="preserve">
          <source>This status is similar to &lt;a href=&quot;401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;, but in this case, re-authenticating will make no difference. The access is permanently forbidden and tied to the application logic, such as insufficient rights to a resource.</source>
          <target state="translated">Этот статус аналогичен &lt;a href=&quot;401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; , но в этом случае повторная аутентификация не будет иметь никакого значения. Доступ запрещен навсегда и привязан к логике приложения, например, недостаточные права на ресурс.</target>
        </trans-unit>
        <trans-unit id="a37c225e3a7cdee05e8c812d332fa6e17571a6c3" translate="yes" xml:space="preserve">
          <source>This status is similar to &lt;a href=&quot;403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;, but in this case, authentication is possible.</source>
          <target state="translated">Этот статус аналогичен &lt;a href=&quot;403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt; , но в этом случае возможна аутентификация.</target>
        </trans-unit>
        <trans-unit id="be28e288a13627a68b1784eb600b0e65cfd5a0de" translate="yes" xml:space="preserve">
          <source>This technique has an additional benefit: updating two cached resources at the same time will not lead to the situation where the out-dated version of one resource is used in combination with the new version of the other one. This is very important when web sites have CSS stylesheets or JS scripts that have mutual dependencies, i.e., they depend on each other because they refer to the same HTML elements.</source>
          <target state="translated">Эта техника имеет дополнительное преимущество:обновление двух кэшированных ресурсов одновременно не приведет к ситуации,когда устаревшая версия одного ресурса будет использоваться в сочетании с новой версией другого.Это очень важно,когда веб-сайты имеют таблицы стилей CSS или JS-скрипты,которые имеют взаимные зависимости,т.е.они зависят друг от друга,потому что ссылаются на одни и те же HTML-элементы.</target>
        </trans-unit>
        <trans-unit id="3aeab72cfc99a5f7f9ea4900285e4bd674414a02" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;a href=&quot;http://kb.mozillazine.org/Network.http.accept.default&quot;&gt;&lt;code&gt;network.http.accept.default&lt;/code&gt;&lt;/a&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l1750&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">Это значение можно изменить с помощью параметра &lt;a href=&quot;http://kb.mozillazine.org/Network.http.accept.default&quot;&gt; &lt;code&gt;network.http.accept.default&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l1750&quot;&gt;источник&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee7de26255283cc9167d1e4ab5cca6cdf380b11c" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;code&gt;image.http.accept&lt;/code&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l4735&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">Это значение можно изменить с &lt;code&gt;image.http.accept&lt;/code&gt; параметра image.http.accept . &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l4735&quot;&gt;источник&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b50b2cc5848103a486b6389534eb105140db6ea" translate="yes" xml:space="preserve">
          <source>This will lead to a simple exchange between the client and the server, using CORS headers to handle the privileges:</source>
          <target state="translated">Это приведет к простому обмену между клиентом и сервером,используя заголовки CORS для обработки привилегий:</target>
        </trans-unit>
        <trans-unit id="81a97739f75df445cadaa8f98d4fa5c5bdf3f859" translate="yes" xml:space="preserve">
          <source>This works roughly the same way as a client-initiated upgrade; an optional upgrade is requested by adding the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header to any message. A mandatory upgrade, though, works slightly differently, in that it requests the upgrade by replying to a message it receives with the &lt;a href=&quot;status/426&quot;&gt;&lt;code&gt;426&lt;/code&gt;&lt;/a&gt; status code, like this:</source>
          <target state="translated">Это работает примерно так же, как и обновление по инициативе клиента; необязательное обновление запрашивается путем добавления заголовка &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; к любому сообщению. Однако обязательное обновление работает несколько иначе, поскольку оно запрашивает обновление, отвечая на полученное сообщение с кодом состояния &lt;a href=&quot;status/426&quot;&gt; &lt;code&gt;426&lt;/code&gt; &lt;/a&gt; , например:</target>
        </trans-unit>
        <trans-unit id="fa3701a77f1cf83ff8e3fe524326c23f848bc1ab" translate="yes" xml:space="preserve">
          <source>This would allow CORS requests from Mozilla, Google, Microsoft, and Apple's domains.</source>
          <target state="translated">Это позволит выполнять CORS-запросы из доменов Mozilla,Google,Microsoft и Apple.</target>
        </trans-unit>
        <trans-unit id="a59129b8ca208dcde27e54fb7891ca5c8b965bb9" translate="yes" xml:space="preserve">
          <source>Though Feature Policy provides control of multiple features using a consistent syntax, the behavior of policy controlled features varies and depends on several factors.</source>
          <target state="translated">Хотя Feature Policy обеспечивает управление несколькими функциями с помощью последовательного синтаксиса,поведение функций,контролируемых политикой,варьируется и зависит от нескольких факторов.</target>
        </trans-unit>
        <trans-unit id="35b0c32c11633fd5293f1721594a37c0441531d3" translate="yes" xml:space="preserve">
          <source>Though HTTP/2 adds some complexity, by embedding HTTP messages in frames to improve performance, the basic structure of messages has stayed the same since HTTP/1.0. Session flow remains simple, allowing it to be investigated, and debugged with a simple &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;HTTP message monitor&lt;/a&gt;.</source>
          <target state="translated">Хотя HTTP / 2 добавляет некоторую сложность, за счет встраивания HTTP-сообщений во фреймы для повышения производительности базовая структура сообщений осталась неизменной с HTTP / 1.0. Поток сеанса остается простым, что позволяет исследовать и отлаживать его с помощью простого &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;монитора сообщений HTTP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b6645a896cbe79649d39568f2032a9ab20c38bc" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Хотя директива &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; предназначена для замены устаревшей директивы &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; , &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; еще не поддерживается в большинстве браузеров. Таким образом, для совместимости с текущими браузерами, а также для добавления прямой совместимости, когда браузеры получают поддержку &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; , вы можете указать как &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; ,так и &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2d2996b4c0f8fba5d4ab332690b5f78e0e30f92d" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Хотя директива &lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; предназначена для замены устаревшей директивы &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; , &lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; еще не поддерживается в большинстве браузеров. Таким образом, для совместимости с текущими браузерами, а также для добавления прямой совместимости, когда браузеры получают поддержку &lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; , вы можете указать как &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; ,так и &lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0c3769f4cf6b7264f228cc766b7de9065e61137e" translate="yes" xml:space="preserve">
          <source>Though there are legitimate uses of this header for selecting content, &lt;a href=&quot;browser_detection_using_the_user_agent&quot;&gt;it is considered bad practice&lt;/a&gt; to rely on it to define what features are supported by the user agent.</source>
          <target state="translated">Хотя есть законные способы использования этого заголовка для выбора содержимого, полагаться на него при определении того, какие функции поддерживает пользовательский агент, &lt;a href=&quot;browser_detection_using_the_user_agent&quot;&gt;считается плохой практикой&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b228606ae426f931604823fecbe96f6aa2850ab0" translate="yes" xml:space="preserve">
          <source>Threats</source>
          <target state="translated">Threats</target>
        </trans-unit>
        <trans-unit id="02283ca03b246291fac06381aab094d267592b90" translate="yes" xml:space="preserve">
          <source>Tighter Control Over Your Referrers &amp;ndash; Mozilla Security Blog</source>
          <target state="translated">Более строгий контроль над вашими рефералами - блог Mozilla Security</target>
        </trans-unit>
        <trans-unit id="7197d879754a435ef6abdac823a28530b7748197" translate="yes" xml:space="preserve">
          <source>Time based conditions</source>
          <target state="translated">Временные условия</target>
        </trans-unit>
        <trans-unit id="d21434199b502487596cffe0f83fce73f8fae46d" translate="yes" xml:space="preserve">
          <source>TimeOut = &quot;Timeout&quot; &quot;:&quot; 1#TimeType
      TimeType = (&quot;Second-&quot; DAVTimeOutVal | &quot;Infinite&quot;)
                 ; No LWS allowed within TimeType
      DAVTimeOutVal = 1*DIGIT

   Clients MAY include Timeout request headers in their LOCK requests.
   However, the server is not required to honor or even consider these
   requests.  Clients MUST NOT submit a Timeout request header with any
   method other than a LOCK method.

   The &quot;Second&quot; TimeType specifies the number of seconds that will
   elapse between granting of the lock at the server, and the automatic
   removal of the lock.  The timeout value for TimeType &quot;Second&quot; MUST
   NOT be greater than 2^32-1.

   See &lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt; for a description of lock timeout behavior.</source>
          <target state="translated">TimeOut = &quot;Timeout&quot; &quot;:&quot; 1 # TimeType TimeType = (&quot;Second-&quot; DAVTimeOutVal | &quot;Бесконечный&quot;); LWS не допускается в пределах TimeType. DAVTimeOutVal = 1 * DIGIT. Клиенты МОГУТ включать заголовки запроса Timeout в свои запросы LOCK. Однако сервер не обязан выполнять или даже рассматривать эти запросы. Клиенты НЕ ДОЛЖНЫ отправлять заголовок запроса тайм-аута с помощью любого другого метода, кроме LOCK. &amp;laquo;Второй&amp;raquo; TimeType указывает количество секунд, которое пройдет между предоставлением блокировки на сервере и автоматическим снятием блокировки. Значение тайм-аута для TimeType &quot;Second&quot; НЕ ДОЛЖНО быть больше 2 ^ 32-1. См. &lt;a href=&quot;#section-6.6&quot;&gt;Раздел 6.6&lt;/a&gt; для описания поведения тайм-аута блокировки.</target>
        </trans-unit>
        <trans-unit id="7bbd92323b129c3217bf6942ecefc96c45003532" translate="yes" xml:space="preserve">
          <source>Timing-Allow-Origin</source>
          <target state="translated">Timing-Allow-Origin</target>
        </trans-unit>
        <trans-unit id="768e0c1c69573fb588f61f1308a015c11468e05f" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Title</target>
        </trans-unit>
        <trans-unit id="eb5cc0f84fc345c602dd1accf23180e03ce108cd" translate="yes" xml:space="preserve">
          <source>Tk</source>
          <target state="translated">Tk</target>
        </trans-unit>
        <trans-unit id="6916244a87f04cf740dd467f9478fda4624dfa30" translate="yes" xml:space="preserve">
          <source>To add members to a Collection, clients send POST requests to the URI
   of the Collection.

   Successful member creation is indicated with a 201 (&quot;Created&quot;)
   response code.  When the Collection responds with a status code of
   201, it SHOULD also return a response body, which MUST be an Atom
   Entry Document representing the newly created Resource.  Since the
   server is free to alter the POSTed Entry, for example, by changing
   the content of the atom:id element, returning the Entry can be useful
   to the client, enabling it to correlate the client and server views
   of the new Entry.

   When a Member Resource is created, its Member Entry URI MUST be
   returned in a Location header in the Collection's response. 

   If the creation request contained an Atom Entry Document, and the
   subsequent response from the server contains a Content-Location
   header that matches the Location header character-for-character, then
   the client is authorized to interpret the response entity as being a
   complete representation of the newly created Entry.  Without a
   matching Content-Location header, the client MUST NOT assume the
   returned entity is a complete representation of the created Resource.

   The request body sent with the POST need not be an Atom Entry.  For
   example, it might be a picture or a movie.  Collections MAY return a
   response with a status code of 415 (&quot;Unsupported Media Type&quot;) to
   indicate that the media type of the POSTed entity is not allowed or
   supported by the Collection.  For a discussion of the issues in
   creating such content, see &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;.</source>
          <target state="translated">Чтобы добавить членов в коллекцию, клиенты отправляют запросы POST на URI коллекции. Успешное создание члена обозначается кодом ответа 201 (&amp;laquo;Создан&amp;raquo;). Когда Коллекция отвечает кодом состояния 201, она ДОЛЖНА также возвращать тело ответа, которое ДОЛЖНО быть Документом ввода Atom, представляющим вновь созданный ресурс. Поскольку сервер может изменять POSTed Entry, например, изменяя содержимое элемента atom: id, возврат Entry может быть полезен для клиента, позволяя ему соотносить клиентские и серверные представления новой Entry. При создании ресурса-члена его URI-элемент записи ДОЛЖЕН быть возвращен в заголовке Location в ответе Collection. Если запрос на создание содержал входной документ Atom,и последующий ответ от сервера содержит заголовок Content-Location, который соответствует символу заголовка Location, тогда клиент авторизуется интерпретировать объект ответа как полное представление вновь созданной записи. Без соответствующего заголовка Content-Location клиент НЕ ДОЛЖЕН предполагать, что возвращаемый объект является полным представлением созданного ресурса. Тело запроса, отправленное с POST, не обязательно должно быть записью Atom. Например, это может быть картинка или фильм. Коллекции МОГУТ возвращать ответ с кодом состояния 415 (&amp;laquo;Неподдерживаемый тип носителя&amp;raquo;), чтобы указать, что тип носителя объекта POSTed не разрешен или не поддерживается Коллекцией. Для обсуждения вопросов создания такого контента см.видетьвидетьтогда клиент авторизуется интерпретировать объект ответа как полное представление вновь созданной записи. Без соответствующего заголовка Content-Location клиент НЕ ДОЛЖЕН предполагать, что возвращаемый объект является полным представлением созданного ресурса. Тело запроса, отправленное с POST, не обязательно должно быть записью Atom. Например, это может быть картинка или фильм. Коллекции МОГУТ возвращать ответ с кодом состояния 415 (&amp;laquo;Неподдерживаемый тип носителя&amp;raquo;), чтобы указать, что тип носителя объекта POSTed не разрешен или не поддерживается Коллекцией. Для обсуждения вопросов создания такого контента см.тогда клиент авторизуется интерпретировать объект ответа как полное представление вновь созданной записи. Без соответствующего заголовка Content-Location клиент НЕ ДОЛЖЕН предполагать, что возвращаемый объект является полным представлением созданного ресурса. Тело запроса, отправленное с POST, не обязательно должно быть записью Atom. Например, это может быть картинка или фильм. Коллекции МОГУТ возвращать ответ с кодом состояния 415 (&amp;laquo;Неподдерживаемый тип носителя&amp;raquo;), чтобы указать, что тип носителя объекта POSTed не разрешен или не поддерживается Коллекцией. Для обсуждения вопросов создания такого контента см.клиент НЕ ДОЛЖЕН предполагать, что возвращаемый объект является полным представлением созданного ресурса. Тело запроса, отправленное с POST, не обязательно должно быть записью Atom. Например, это может быть картинка или фильм. Коллекции МОГУТ возвращать ответ с кодом состояния 415 (&amp;laquo;Неподдерживаемый тип носителя&amp;raquo;), чтобы указать, что тип носителя объекта POSTed не разрешен или не поддерживается Коллекцией. Для обсуждения вопросов создания такого контента см.клиент НЕ ДОЛЖЕН предполагать, что возвращаемый объект является полным представлением созданного ресурса. Тело запроса, отправленное с POST, не обязательно должно быть записью Atom. Например, это может быть картинка или фильм. Коллекции МОГУТ возвращать ответ с кодом состояния 415 (&amp;laquo;Неподдерживаемый тип носителя&amp;raquo;), чтобы указать, что тип носителя объекта POSTed не разрешен или не поддерживается Коллекцией. Для обсуждения вопросов создания такого контента см.), чтобы указать, что тип мультимедиа объекта POSTed не разрешен или не поддерживается Коллекцией. Для обсуждения вопросов создания такого контента см.), чтобы указать, что тип мультимедиа объекта POSTed не разрешен или не поддерживается Коллекцией. Для обсуждения вопросов создания такого контента см.&lt;a href=&quot;#section-9.6&quot;&gt;Раздел 9.6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="386b4890041dd717ecf8b7b91609bc0b0530ef7e" translate="yes" xml:space="preserve">
          <source>To additionally expose a custom header, like &lt;code&gt;X-Kuma-Revision&lt;/code&gt;, you can specify multiple headers separated by a comma:</source>
          <target state="translated">Чтобы дополнительно предоставить настраиваемый заголовок, такой как &lt;code&gt;X-Kuma-Revision&lt;/code&gt; , вы можете указать несколько заголовков, разделенных запятыми:</target>
        </trans-unit>
        <trans-unit id="a180bdbe7008f814531ba52754a31bdde24cb15f" translate="yes" xml:space="preserve">
          <source>To allow &lt;code&gt;https://developer.mozilla.org&lt;/code&gt; to see timing resources, you can specify:</source>
          <target state="translated">Чтобы разрешить &lt;code&gt;https://developer.mozilla.org&lt;/code&gt; видеть ресурсы синхронизации, вы можете указать:</target>
        </trans-unit>
        <trans-unit id="ac82a05a9215546227ac811284787b043b688757" translate="yes" xml:space="preserve">
          <source>To allow any resource to see timing resources:</source>
          <target state="translated">Чтобы любой ресурс мог видеть временные ресурсы:</target>
        </trans-unit>
        <trans-unit id="ed12e1286c2fe40563eb11b075acdb101da5456e" translate="yes" xml:space="preserve">
          <source>To allow inline scripts and inline event handlers, &lt;code&gt;'unsafe-inline'&lt;/code&gt;, a nonce-source or a hash-source that matches the inline block can be specified.</source>
          <target state="translated">Чтобы разрешить встроенные сценарии и встроенные обработчики событий, можно указать &lt;code&gt;'unsafe-inline'&lt;/code&gt; , nonce-source или hash-source, который соответствует встроенному блоку.</target>
        </trans-unit>
        <trans-unit id="f0269ea1c1b256b968def48a5f2f52309ec5262a" translate="yes" xml:space="preserve">
          <source>To allow inline styles, &lt;code&gt;'unsafe-inline'&lt;/code&gt;, a nonce-source or a hash-source that matches the inline block can be specified.</source>
          <target state="translated">Чтобы разрешить встроенные стили, можно указать &lt;code&gt;'unsafe-inline'&lt;/code&gt; , nonce-source или hash-source, который соответствует встроенному блоку.</target>
        </trans-unit>
        <trans-unit id="baf2613fc6493f70145cca53cbfd72435e9e8e80" translate="yes" xml:space="preserve">
          <source>To apply a redirect to a folder or a subset of the pages only, use the &lt;code&gt;rewrite&lt;/code&gt; directive:</source>
          <target state="translated">Чтобы применить перенаправление только к папке или подмножеству страниц, используйте директиву &lt;code&gt;rewrite&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bb7179c9bb0b7e4c55288f5bc188620cf66f5d11" translate="yes" xml:space="preserve">
          <source>To avoid breaking existing web content, the default for such policy-controlled features is to allow the functionality to be used by all origins. That is, the default allowlist is &lt;code&gt;'*'&lt;/code&gt; for each feature. Preventing the use of the sub-optimal functionality requires explicitly specifying a policy that disables the features.</source>
          <target state="translated">Чтобы избежать нарушения существующего веб-контента, по умолчанию для таких функций, управляемых политикой, разрешено использование этих функций из всех источников. То есть список разрешений по умолчанию - &lt;code&gt;'*'&lt;/code&gt; для каждой функции. Чтобы предотвратить использование неоптимальных функций, необходимо явно указать политику, отключающую эти функции.</target>
        </trans-unit>
        <trans-unit id="9aa4823e36d63b17b94087b674887608e0551a24" translate="yes" xml:space="preserve">
          <source>To configure Apache to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header for all pages, add this to your site's configuration:</source>
          <target state="translated">Чтобы настроить Apache для отправки заголовка &lt;code&gt;X-Frame-Options&lt;/code&gt; для всех страниц, добавьте это в конфигурацию вашего сайта:</target>
        </trans-unit>
        <trans-unit id="e80d381b0c7feec0a158d29c3338a640577b5bd0" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; deny , add this to your site's configuration:</source>
          <target state="translated">Чтобы настроить Apache для установки запрета &lt;code&gt;X-Frame-Options&lt;/code&gt; , добавьте это в конфигурацию вашего сайта:</target>
        </trans-unit>
        <trans-unit id="b534ad3f3a442c64de937628acf24797af926fef" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; to &lt;code&gt;allow-from&lt;/code&gt; a specific Host , add this to your site's configuration:</source>
          <target state="translated">Чтобы настроить Apache для установки параметров &lt;code&gt;X-Frame-Options&lt;/code&gt; для &lt;code&gt;allow-from&lt;/code&gt; определенного хоста, добавьте это в конфигурацию вашего сайта:</target>
        </trans-unit>
        <trans-unit id="845c7d45d2e5670380ce094b42f8d93ca377f4d0" translate="yes" xml:space="preserve">
          <source>To configure HAProxy to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this to your front-end, listen, or backend configuration:</source>
          <target state="translated">Чтобы настроить HAProxy для отправки заголовка &lt;code&gt;X-Frame-Options&lt;/code&gt; , добавьте его в конфигурацию внешнего интерфейса, прослушивания или внутреннего интерфейса:</target>
        </trans-unit>
        <trans-unit id="d8ead758c64a8732b962f9c079ccbcb8977cec05" translate="yes" xml:space="preserve">
          <source>To configure IIS to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this to your site's &lt;code&gt;Web.config&lt;/code&gt; file:</source>
          <target state="translated">Чтобы настроить IIS для отправки заголовка &lt;code&gt;X-Frame-Options&lt;/code&gt; , добавьте это в файл &lt;code&gt;Web.config&lt;/code&gt; своего сайта :</target>
        </trans-unit>
        <trans-unit id="40d91183fa2ac507cab6f74e7d193a9cc7597506" translate="yes" xml:space="preserve">
          <source>To configure nginx to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this either to your http, server or location configuration:</source>
          <target state="translated">Чтобы настроить nginx для отправки заголовка &lt;code&gt;X-Frame-Options&lt;/code&gt; , добавьте его в конфигурацию http, сервера или местоположения:</target>
        </trans-unit>
        <trans-unit id="f87ea35dcc44f41e60725e0641384c547d99d798" translate="yes" xml:space="preserve">
          <source>To correct this problem on the client side, simply ensure that the credentials flag's value is &lt;code&gt;false&lt;/code&gt; when issuing your CORS request.</source>
          <target state="translated">Чтобы исправить эту проблему на стороне клиента, просто убедитесь, что значение флага учетных данных &lt;code&gt;false&lt;/code&gt; при выдаче запроса CORS.</target>
        </trans-unit>
        <trans-unit id="d348d55722c44b500e4b7059e9ff9d2fa1dddb00" translate="yes" xml:space="preserve">
          <source>To delete a Member Resource, a client sends a DELETE request to its
   Member URI, as specified in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  The deletion of a Media Link
   Entry SHOULD result in the deletion of the corresponding Media
   Resource.</source>
          <target state="translated">Чтобы удалить ресурс-член, клиент отправляет запрос DELETE своему URI-члену, как указано в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]. Удаление записи медиа-ссылки ДОЛЖНО привести к удалению соответствующего медиаресурса.</target>
        </trans-unit>
        <trans-unit id="04d139058a76ad3d2cff70e2b313580511ed4b4b" translate="yes" xml:space="preserve">
          <source>To disallow all plugins, the &lt;a href=&quot;object-src&quot;&gt;&lt;code&gt;object-src&lt;/code&gt;&lt;/a&gt; directive should be set to &lt;code&gt;'none'&lt;/code&gt; which will disallow plugins. The &lt;code&gt;plugin-types&lt;/code&gt; directive is only used if you are allowing plugins with &lt;code&gt;object-src&lt;/code&gt; at all.</source>
          <target state="translated">Чтобы запретить все плагины, для директивы &lt;a href=&quot;object-src&quot;&gt; &lt;code&gt;object-src&lt;/code&gt; &lt;/a&gt; должно быть установлено значение &lt;code&gt;'none'&lt;/code&gt; что запретит плагины. &lt;code&gt;plugin-types&lt;/code&gt; директива используется только тогда , когда вы позволяете плагинов с &lt;code&gt;object-src&lt;/code&gt; на всех.</target>
        </trans-unit>
        <trans-unit id="92b682f994622384b1029f2cc2b8c3099145173c" translate="yes" xml:space="preserve">
          <source>To disallow http assets on a more granular level, you can also set individual directives to &quot;https:&quot;. For example, to disallow insecure http images:</source>
          <target state="translated">Чтобы запретить http-активы на более гранулированном уровне,можно также установить индивидуальные директивы на &quot;https:&quot;.Например,чтобы запретить небезопасные http-изображения:</target>
        </trans-unit>
        <trans-unit id="76414f91106f2a76e27289d53511ec4aff7ac9a8" translate="yes" xml:space="preserve">
          <source>To do this, HTTP uses a mechanism similar to the content negotiation for end-to-end compression: the node transmitting the request advertizes its will using the &lt;a href=&quot;headers/te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; header and the other node chooses the adequate method, applies it, and indicates its choice with the &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Для этого HTTP использует механизм, аналогичный согласованию содержимого для сквозного сжатия: узел, передающий запрос, объявляет о своей воле, используя заголовок &lt;a href=&quot;headers/te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; ,&lt;/a&gt; а другой узел выбирает подходящий метод, применяет его и указывает свой выбор с помощью &lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; заголовок.</target>
        </trans-unit>
        <trans-unit id="2695ec4a2bbfc44084d656ae8935110af8816675" translate="yes" xml:space="preserve">
          <source>To ease deployment, CSP can be deployed in report-only mode. The policy is not enforced, but any violations are reported to a provided URI. Additionally, a report-only header can be used to test a future revision to a policy without actually deploying it.</source>
          <target state="translated">Чтобы упростить развертывание,CSP можно развернуть в режиме только для отчетов.Политика не соблюдается,но о любых нарушениях сообщается в предоставленном URI.Кроме того,заголовок,доступный только для отчета,может быть использован для тестирования будущей ревизии политики без ее фактического развертывания.</target>
        </trans-unit>
        <trans-unit id="75b596875abd418e26e2741605ac5a556d421f5c" translate="yes" xml:space="preserve">
          <source>To edit a Member Resource, a client sends a PUT request to its Member
   URI, as specified in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   To avoid unintentional loss of data when editing Member Entries or
   Media Link Entries, an Atom Protocol client SHOULD preserve all
   metadata that has not been intentionally modified, including unknown
   foreign markup as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">Чтобы изменить ресурс-член, клиент отправляет запрос PUT на свой URI-адрес члена, как указано в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]. Чтобы избежать непреднамеренной потери данных при редактировании записей участников или медиа-ссылок, клиент протокола Atom ДОЛЖЕН сохранять все метаданные, которые не были намеренно изменены, включая неизвестную внешнюю разметку, как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;разделе 6 [RFC4287]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65a702b04aa6a54fd3c8430997ab1bc38d37ad8c" translate="yes" xml:space="preserve">
          <source>To eliminate this error by changing the server's configuration, adjust the server's configuration to set the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header's value to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Чтобы устранить эту ошибку, изменив конфигурацию сервера, настройте конфигурацию сервера так, чтобы в заголовке &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; было установлено значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfa8844d0259c7d70df5b60e696f31e2bbcd03c1" translate="yes" xml:space="preserve">
          <source>To enable CSP, you need to configure your web server to return the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header (sometimes you will see mentions of the &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; header, but that's an older version and you don't need to specify it anymore).</source>
          <target state="translated">Чтобы включить CSP, вам необходимо настроить свой веб-сервер так, чтобы он возвращал HTTP-заголовок &lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (иногда вы увидите упоминания заголовка &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; , но это более старая версия, и вам не нужно уточняйте больше).</target>
        </trans-unit>
        <trans-unit id="e9df87dcc5fcb972c46f913809c87fec6f3d341b" translate="yes" xml:space="preserve">
          <source>To enable this feature for your site, you need to return the &lt;a href=&quot;headers/public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; HTTP header when your site is accessed over HTTPS:</source>
          <target state="translated">Чтобы включить эту функцию для вашего сайта, вам необходимо вернуть HTTP-заголовок &lt;a href=&quot;headers/public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; ,&lt;/a&gt; когда ваш сайт доступен по HTTPS:</target>
        </trans-unit>
        <trans-unit id="d7620e1e33a6d347685e1ebb3aa8b33714970a09" translate="yes" xml:space="preserve">
          <source>To ensure the authenticity of a server's public key used in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; sessions, this public key is wrapped into a X.509 certificate which is usually signed by a certificate authority (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CA&quot;&gt;CA&lt;/a&gt;). Web clients such as browsers trust a lot of these CAs, which can all create certificates for arbitrary domain names. If an attacker is able to compromise a single CA, they can perform MITM attacks on various TLS connections. HPKP can circumvent this threat for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; protocol by telling the client which public key belongs to a certain web server.</source>
          <target state="translated">Чтобы гарантировать подлинность открытого ключа сервера, используемого в сеансах &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; , этот открытый ключ заключен в сертификат X.509, который обычно подписывается центром сертификации ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CA&quot;&gt;CA&lt;/a&gt; ). Веб-клиенты, такие как браузеры, доверяют многим из этих центров сертификации, которые могут создавать сертификаты для произвольных доменных имен. Если злоумышленник может взломать один ЦС, он может выполнять атаки MITM на различные соединения TLS. HPKP может обойти эту угрозу для протокола &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; , сообщив клиенту, какой открытый ключ принадлежит определенному веб-серверу.</target>
        </trans-unit>
        <trans-unit id="ee9c68887239fed95f26110a7e627ff78bd12cc1" translate="yes" xml:space="preserve">
          <source>To expose a non-simple response header, you can specify:</source>
          <target state="translated">Для отображения непростого заголовка ответа можно указать:</target>
        </trans-unit>
        <trans-unit id="0114a346ce11f11d1f933758ffbbdf2f5442cd43" translate="yes" xml:space="preserve">
          <source>To find out whether a server supports &lt;code&gt;PATCH&lt;/code&gt;, a server can advertise its support by adding it to the list in the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; (for CORS) response headers.</source>
          <target state="translated">Чтобы узнать, поддерживает ли сервер &lt;code&gt;PATCH&lt;/code&gt; , сервер может объявить о своей поддержке, добавив ее в список в заголовках ответа &lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; (для CORS).</target>
        </trans-unit>
        <trans-unit id="f3e43c65e3e2914cd34ba18edec78bc17058b478" translate="yes" xml:space="preserve">
          <source>To find out which request methods a server supports, one can use curl and issue an OPTIONS request:</source>
          <target state="translated">Чтобы узнать,какие методы запроса поддерживает сервер,можно использовать curl и выдать запрос OPTIONS:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
