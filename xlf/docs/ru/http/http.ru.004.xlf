<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="translated">Значения по умолчанию</target>
        </trans-unit>
        <trans-unit id="a5c2516af3446d0b014a66cd8335c651bab61880" translate="yes" xml:space="preserve">
          <source>Define the lifetime of a cookie</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dead4f5e7150393c68c21004bedb55c7c195d60" translate="yes" xml:space="preserve">
          <source>Define where cookies are sent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="245c3e85d7084e6fe802cca877477e7792e1d78f" translate="yes" xml:space="preserve">
          <source>Defined in a previous version of the HTTP specification to indicate that a requested response must be accessed by a proxy. It has been deprecated due to security concerns regarding in-band configuration of a proxy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab39d71630263cb06de73047fe986abf13013e75" translate="yes" xml:space="preserve">
          <source>Defines &lt;code&gt;connect-src&lt;/code&gt;, &lt;code&gt;default-src&lt;/code&gt;, &lt;code&gt;font-src&lt;/code&gt;, &lt;code&gt;frame-src&lt;/code&gt;, &lt;code&gt;img-src&lt;/code&gt;, &lt;code&gt;media-src&lt;/code&gt;, &lt;code&gt;object-src&lt;/code&gt;, report-uri, &lt;code&gt;sandbox&lt;/code&gt;, &lt;code&gt;script-src,&lt;/code&gt; and &lt;code&gt;style-src&lt;/code&gt;.</source>
          <target state="translated">Определяет &lt;code&gt;connect-src&lt;/code&gt; , &lt;code&gt;default-src&lt;/code&gt; , &lt;code&gt;font-src&lt;/code&gt; , &lt;code&gt;frame-src&lt;/code&gt; , &lt;code&gt;img-src&lt;/code&gt; , &lt;code&gt;media-src&lt;/code&gt; , &lt;code&gt;object-src&lt;/code&gt; , report-uri, &lt;code&gt;sandbox&lt;/code&gt; , &lt;code&gt;script-src,&lt;/code&gt; и &lt;code&gt;style-src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40978ed9d38521abaff2d2262f9c89c7cd595480" translate="yes" xml:space="preserve">
          <source>Defines a mechanism that enables developers to declare a network error reporting policy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eacb52986e3e740e8c70b75c3e7482999a612bff" translate="yes" xml:space="preserve">
          <source>Defines the &lt;code&gt;fullscreen&lt;/code&gt; policy.</source>
          <target state="translated">Определяет &lt;code&gt;fullscreen&lt;/code&gt; политику.</target>
        </trans-unit>
        <trans-unit id="d951108d1c6ab12879dc6ad6f06e33639209ba4b" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to access a resource behind a proxy server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ebc06a403db3f222282cbfb2aa8be80e23aefc" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to access a resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b169a4830ca101a24b3e67607bce56b1c91720" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to gain access to a resource behind a Proxy server.</source>
          <target state="translated">Определяет метод аутентификации,который должен использоваться для получения доступа к ресурсу за прокси-сервером.</target>
        </trans-unit>
        <trans-unit id="6543a340c8cdd818ac73a63a94d4fd7de57aba8d" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to gain access to a resource.</source>
          <target state="translated">Определяет метод аутентификации,который должен использоваться для получения доступа к ресурсу.</target>
        </trans-unit>
        <trans-unit id="7826d05e84456b5b15119edee382be8851b9547e" translate="yes" xml:space="preserve">
          <source>Defines the range unit the server supports. Though &lt;code&gt;bytes&lt;/code&gt; is the only range unit formally defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, additional range units may be registered in the&lt;a href=&quot;https://www.iana.org/assignments/http-parameters/http-parameters.xhtml#range-units&quot;&gt; HTTP Range Unit Registry&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8dcc75b63979f2db11f899a91470adab4ff1cb6" translate="yes" xml:space="preserve">
          <source>Defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Определяет допустимые источники для &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;веб-рабочих&lt;/a&gt; и вложенных контекстов просмотра, загружаемых с использованием таких элементов, как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b64b866be84f841a370d95030a45025c6a3e04e9" translate="yes" xml:space="preserve">
          <source>Denial-of-service attacks are of special concern to WebDAV servers.
   WebDAV plus HTTP enables denial-of-service attacks on every part of a
   system's resources.

   o  The underlying storage can be attacked by PUTting extremely large
      files.

   o  Asking for recursive operations on large collections can attack
      processing time.

   o  Making multiple pipelined requests on multiple connections can
      attack network connections.

   WebDAV servers need to be aware of the possibility of a denial-of-
   service attack at all levels.  The proper response to such an attack
   MAY be to simply drop the connection.  Or, if the server is able to
   make a response, the server MAY use a 400-level status request such
   as 400 (Bad Request) and indicate why the request was refused (a 500-
   level status response would indicate that the problem is with the
   server, whereas unintentional DoS attacks are something the client is
   capable of remedying).</source>
          <target state="translated">Атаки типа &quot;отказ в обслуживании&quot; имеют особое значение для WebDAV серверов.WebDAV плюс HTTP позволяет атаковать отказ в обслуживании на каждую часть системных ресурсов.o Основанное на этом хранилище может быть атаковано PUTting очень большими файлами.o Запрос на рекурсивные операции с большими коллекциями может атаковать время обработки.o Создание множественных потоковых запросов на множественных соединениях может атаковать сетевые соединения.WebDAV-серверы должны быть осведомлены о возможности атаки типа &quot;отказ в обслуживании&quot; на всех уровнях.Правильным ответом на такую атаку МОЖЕТ быть простое обрыв соединения.Или,если сервер способен дать ответ,сервер MAY использует 400-уровневый запрос о статусе,например 400 (Bad Request)и указывает,почему запрос был отклонен (500-уровневый ответ о статусе будет указывать на то,что проблема в сервере,в то время как непреднамеренные DoS-атаки-это то,что клиент способен исправить).</target>
        </trans-unit>
        <trans-unit id="89de95bda785091ad4670c2c51c5dd042349d3eb" translate="yes" xml:space="preserve">
          <source>Deprecate modification of 'secure' cookies from non-secure origins</source>
          <target state="translated">Удалить изменение &quot;безопасных&quot; куки-файлов из небезопасных источников.</target>
        </trans-unit>
        <trans-unit id="efb41926689d64456523d9abd88a8e204ff7906a" translate="yes" xml:space="preserve">
          <source>Deprecates &lt;code&gt;frame-src&lt;/code&gt;.</source>
          <target state="translated">Устарела &lt;code&gt;frame-src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4f0c7b98ab40a4d967b59248a69752d5ae464d4" translate="yes" xml:space="preserve">
          <source>Depth = &quot;Depth&quot; &quot;:&quot; (&quot;0&quot; | &quot;1&quot; | &quot;infinity&quot;)

   The Depth request header is used with methods executed on resources
   that could potentially have internal members to indicate whether the
   method is to be applied only to the resource (&quot;Depth: 0&quot;), to the
   resource and its internal members only (&quot;Depth: 1&quot;), or the resource
   and all its members (&quot;Depth: infinity&quot;).

   The Depth header is only supported if a method's definition
   explicitly provides for such support.

   The following rules are the default behavior for any method that
   supports the Depth header.  A method may override these defaults by
   defining different behavior in its definition. 

   Methods that support the Depth header may choose not to support all
   of the header's values and may define, on a case-by-case basis, the
   behavior of the method if a Depth header is not present.  For
   example, the MOVE method only supports &quot;Depth: infinity&quot;, and if a
   Depth header is not present, it will act as if a &quot;Depth: infinity&quot;
   header had been applied.

   Clients MUST NOT rely upon methods executing on members of their
   hierarchies in any particular order or on the execution being atomic
   unless the particular method explicitly provides such guarantees.

   Upon execution, a method with a Depth header will perform as much of
   its assigned task as possible and then return a response specifying
   what it was able to accomplish and what it failed to do.

   So, for example, an attempt to COPY a hierarchy may result in some of
   the members being copied and some not.

   By default, the Depth header does not interact with other headers.
   That is, each header on a request with a Depth header MUST be applied
   only to the Request-URI if it applies to any resource, unless
   specific Depth behavior is defined for that header.

   If a source or destination resource within the scope of the Depth
   header is locked in such a way as to prevent the successful execution
   of the method, then the lock token for that resource MUST be
   submitted with the request in the If request header.

   The Depth header only specifies the behavior of the method with
   regards to internal members.  If a resource does not have internal
   members, then the Depth header MUST be ignored.</source>
          <target state="translated">Depth=&quot;Depth&quot; &quot;:&quot; (&quot;0&quot; | &quot;1&quot; | &quot;бесконечность&quot;)Заголовок запроса Depth используется с методами,выполняемыми на ресурсах,которые потенциально могут иметь внутренних членов,чтобы указать,будет ли этот метод применяться только к ресурсу (&quot;Depth:0&quot;),только к ресурсу и его внутренним членам (&quot;Depth:1&quot;),или же к ресурсу и всем его членам (&quot;Depth:бесконечность&quot;).Заголовок Depth поддерживается только в том случае,если определение метода явно предусматривает такую поддержку.Следующие правила являются поведением по умолчанию для любого метода,поддерживающего Depth заголовок.Метод может переопределить эти значения по умолчанию,определив в своем определении различное поведение.Методы,поддерживающие заголовок Depth,могут выбрать не поддержку всех значений заголовка и могут определить в каждом конкретном случае поведение метода,если заголовок Depth отсутствует.Например,метод MOVE поддерживает только &quot;Depth:бесконечность&quot;,и если заголовок Depth отсутствует,то он будет действовать так,как если бы был применен заголовок &quot;Depth:бесконечность&quot;.Клиенты НЕ ДОЛЖНЫ полагаться на методы,выполняющиеся на членов их иерархии в определенном порядке или на атомарное исполнение,если только конкретный метод явно не предоставляет таких гарантий.После выполнения метод с заголовком &quot;Depth:бесконечность&quot; выполнит как можно большую часть поставленной задачи,а затем вернет ответ с указанием того,что он смог выполнить,а что нет.Так,например,попытка применения иерархии COPY может привести к тому,что некоторые члены метода будут скопированы,а некоторые-нет.По умолчанию заголовок Depth не взаимодействует с другими заголовками.То есть,каждый заголовок запроса с заголовком Depth ДОЛЖЕН применяться только к Request-URI,если он не применяется к любому ресурсу,если только для этого заголовка не определено специфическое поведение Depth.Если ресурс-источник или ресурс-получатель в области действия заголовка Depth заблокирован таким образом,что это препятствует успешному выполнению метода,то блокирующий маркер для этого ресурса ДОЛЖЕН быть представлен вместе с запросом в заголовке If запроса.Заголовок Depth определяет только поведение метода по отношению к внутренним членам.Если ресурс не имеет внутренних членов,то заголовок Depth ДОЛЖЕН быть проигнорирован.</target>
        </trans-unit>
        <trans-unit id="c3f35f2651dfb57ad3dbd2465104d1927bb97b16" translate="yes" xml:space="preserve">
          <source>Describes how Web resources are referenced and how to locate them.</source>
          <target state="translated">Описывает,как на веб-ресурсы ссылаются и как их найти.</target>
        </trans-unit>
        <trans-unit id="13eefb880344c770ed016914712964de5ecee92a" translate="yes" xml:space="preserve">
          <source>Describes how web resources are referenced and how to locate them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932bd93206e0c74c22f35c1fa3ed7a4be6439b83" translate="yes" xml:space="preserve">
          <source>Describes the human language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70c9f2b9944695efcc3168d72ca8c97f9659ed15" translate="yes" xml:space="preserve">
          <source>Describes the language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">Описывает язык(ы),предназначенный(ые)для аудитории,таким образом,чтобы позволить пользователю дифференцировать его в соответствии с собственным предпочитаемым языком.</target>
        </trans-unit>
        <trans-unit id="d5ca427b8a632e16915ddd1ca200bfe11ba09ba7" translate="yes" xml:space="preserve">
          <source>Describes the three connection management models available in HTTP/1.x, their strengths, and their weaknesses.</source>
          <target state="translated">Описывает три модели управления соединениями,доступные в HTTP/1.x,их сильные и слабые стороны.</target>
        </trans-unit>
        <trans-unit id="a9a26ce3467081341f2f33fd2f385b9b4b5a76b7" translate="yes" xml:space="preserve">
          <source>Describes the type and structure of the different kind of messages of HTTP/1.x and HTTP/2.</source>
          <target state="translated">Описывает тип и структуру различных типов сообщений HTTP/1.x и HTTP/2.</target>
        </trans-unit>
        <trans-unit id="045b1f4c38aa570756046a04e9ca60247fc160b5" translate="yes" xml:space="preserve">
          <source>Describes what HTTP is and its role in the Web architecture, its position in the protocol stack.</source>
          <target state="translated">Описывает,что такое HTTP и его роль в веб-архитектуре,его место в стеке протоколов.</target>
        </trans-unit>
        <trans-unit id="724e541fe26287b5d45feca3f617b30de64a8464" translate="yes" xml:space="preserve">
          <source>Describes what HTTP is and its role in web architecture, including its position in the protocol stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="6011dbf6cfab599fb1f5bc7fc964691bbd1b3180" translate="yes" xml:space="preserve">
          <source>Designed in the early 1990s, HTTP is an extensible protocol which has evolved over time. It is an application layer protocol that is sent over &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TCP&quot;&gt;TCP&lt;/a&gt;, or over a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt;-encrypted TCP connection, though any reliable transport protocol could theoretically be used. Due to its extensibility, it is used to not only fetch hypertext documents, but also images and videos or to post content to servers, like with HTML form results. HTTP can also be used to fetch parts of documents to update Web pages on demand.</source>
          <target state="translated">HTTP, разработанный в начале 1990-х, представляет собой расширяемый протокол, который со временем развивался. Это протокол прикладного уровня, который пересылается через &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TCP&quot;&gt;TCP&lt;/a&gt; или TCP-соединение с шифрованием &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; , хотя теоретически можно использовать любой надежный транспортный протокол. Благодаря своей расширяемости он используется не только для получения гипертекстовых документов, но также изображений и видео или для публикации содержимого на серверах, например, с результатами HTML-форм. HTTP также можно использовать для получения частей документов для обновления веб-страниц по запросу.</target>
        </trans-unit>
        <trans-unit id="532c67fe1b5afae15d2d08fba7a78de0f63cc4b5" translate="yes" xml:space="preserve">
          <source>Desktop</source>
          <target state="translated">Desktop</target>
        </trans-unit>
        <trans-unit id="dfd0263c11d50bfbcd6f11a03ba9f3544f34bf13" translate="yes" xml:space="preserve">
          <source>Despite &lt;code&gt;image/vnd.microsoft.icon&lt;/code&gt; being &lt;a href=&quot;https://www.iana.org/assignments/media-types/image/vnd.microsoft.icon&quot;&gt;registered with IANA&lt;/a&gt;, it is largely unsupported, and &lt;code&gt;image/x-icon&lt;/code&gt; is being used instead.</source>
          <target state="translated">Несмотря на &lt;code&gt;image/vnd.microsoft.icon&lt;/code&gt; быть &lt;a href=&quot;https://www.iana.org/assignments/media-types/image/vnd.microsoft.icon&quot;&gt;зарегистрирован в IANA&lt;/a&gt; , это в значительной степени не поддерживается, и &lt;code&gt;image/x-icon&lt;/code&gt; используется вместо этого.</target>
        </trans-unit>
        <trans-unit id="2c9a54d2465a44e3b40b84b59d11de3a6c0cadc8" translate="yes" xml:space="preserve">
          <source>Determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</source>
          <target state="translated">Определяет,как сопоставить заголовки будущих запросов,чтобы решить,можно ли использовать кэшированный ответ,а не запрашивать свежий с исходного сервера.</target>
        </trans-unit>
        <trans-unit id="6d8108385e143b7a138219a9ade7a2c3c2bf95f5" translate="yes" xml:space="preserve">
          <source>Determines how to match request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e965db93ca2d2ed880afa222771550e11edd88c" translate="yes" xml:space="preserve">
          <source>Device-specific</source>
          <target state="translated">Device-specific</target>
        </trans-unit>
        <trans-unit id="504f16935ab18165c15c8ac0d71a7134e267a656" translate="yes" xml:space="preserve">
          <source>Device-specific user agent strings</source>
          <target state="translated">Строки агентов для конкретного устройства</target>
        </trans-unit>
        <trans-unit id="ceb4688658b58abe9c95bf427c98e66f4be1e7a3" translate="yes" xml:space="preserve">
          <source>Different kinds of caches</source>
          <target state="translated">Различные виды кэшей</target>
        </trans-unit>
        <trans-unit id="1ca0ed6389159c54076291dfd79987d9f92fb6b6" translate="yes" xml:space="preserve">
          <source>Directive type</source>
          <target state="translated">Тип директивы</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="691c26c4ce33366b87dae4f9e53ebeaaa6a4d716" translate="yes" xml:space="preserve">
          <source>Directives for caching mechanisms in both requests and responses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d32a74ca0f336eef375d6cd3af907aa1d40f0be6" translate="yes" xml:space="preserve">
          <source>Directives that define whether a response/request can be cached, where it may be cached, and whether it must be validated with the origin server before caching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f4473df8cb59f0a369aebee3d1509adc0151c6" translate="yes" xml:space="preserve">
          <source>Disabled</source>
          <target state="translated">Disabled</target>
        </trans-unit>
        <trans-unit id="787d14cbc3437c5c1be6e012c1af87a9cce09ce1" translate="yes" xml:space="preserve">
          <source>Disabled From version 35 until version 37 (exclusive): this feature is behind the &lt;code&gt;network.http.altsvc.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;) and the &lt;code&gt;altsvc.oe&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f484ad36a1ee3a334bfeaabcdd32d70515f88ee" translate="yes" xml:space="preserve">
          <source>Disabled From version 47: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b112b210a8f4589c98ad826e6212c056804fde" translate="yes" xml:space="preserve">
          <source>Disabled From version 48: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89947c297946cdea762cd2db19147fd97a643839" translate="yes" xml:space="preserve">
          <source>Disabled From version 49 until version 68 (exclusive): this feature is behind the &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23e78cd51ef4c7696b73e65f06fc0fba687013d" translate="yes" xml:space="preserve">
          <source>Disabled From version 49: this feature is behind the &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">Отключено Начиная с версии 49: эта функция находится за предпочтением &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; (должно быть установлено значение &lt;code&gt;true&lt;/code&gt; ). Чтобы изменить настройки в Firefox, посетите about: config.</target>
        </trans-unit>
        <trans-unit id="acf361a5483e12203a0c0598d3d3f3664a139585" translate="yes" xml:space="preserve">
          <source>Disabled From version 50: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7790dccb9f3d88c21e6418f32f87789fb463366" translate="yes" xml:space="preserve">
          <source>Disabled From version 52: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">Отключено Начиная с версии 52: эта функция находится за параметром &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; (необходимо установить значение &lt;code&gt;Enabled&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ad350d06e4ae5e37d57c0405b7c8e1fbfca3f705" translate="yes" xml:space="preserve">
          <source>Disabled From version 53: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">Отключено Начиная с версии 53: эта функция находится за параметром &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; (необходимо установить значение &lt;code&gt;Enabled&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="01d0cf4c918a77e56e449b4d149616907d38849e" translate="yes" xml:space="preserve">
          <source>Disabled From version 55: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">Отключено Начиная с версии 55: эта функция находится за параметром &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; (необходимо установить значение &lt;code&gt;Enabled&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="02423b2163f75291aa5854698bba6b1f6a5052f1" translate="yes" xml:space="preserve">
          <source>Disabled From version 56: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">Отключено Начиная с версии 56: эта функция скрывается за предпочтением &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; (необходимо установить значение &lt;code&gt;Enabled&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4b34d34dcaec154df6181d68e5bec4643debe21c" translate="yes" xml:space="preserve">
          <source>Disabled From version 59: this feature is behind the &lt;code&gt;network.http.sendOriginHeader&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">Отключено Начиная с версии 59: эта функция находится за предпочтением &lt;code&gt;network.http.sendOriginHeader&lt;/code&gt; (должно быть установлено значение &lt;code&gt;true&lt;/code&gt; ). Чтобы изменить настройки в Firefox, посетите about: config.</target>
        </trans-unit>
        <trans-unit id="40734bba86a26fa4c0ddd48daccbe4d758349227" translate="yes" xml:space="preserve">
          <source>Disabled From version 60: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73719b598079cc354ff255d41acbbe0b420ae879" translate="yes" xml:space="preserve">
          <source>Disabled From version 62: this feature is behind the &lt;code&gt;dom.clearSiteData.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">Отключено Начиная с версии 62: эта функция находится за предпочтением &lt;code&gt;dom.clearSiteData.enabled&lt;/code&gt; (должно быть установлено значение &lt;code&gt;true&lt;/code&gt; ). Чтобы изменить настройки в Firefox, посетите about: config.</target>
        </trans-unit>
        <trans-unit id="7847ec1580ce5ad83ab59a78912ccb3ab21e102b" translate="yes" xml:space="preserve">
          <source>Disabled From version 65: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">Отключено Начиная с версии 65: эта функция находится за параметром &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; (необходимо установить значение &lt;code&gt;Enabled&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5a54bae2672ba58fd0d7d8cd35ca056cf1ce8f92" translate="yes" xml:space="preserve">
          <source>Disabled From version 65: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">Отключено Начиная с версии 65: эта функция находится за параметром &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; (необходимо установить значение &lt;code&gt;Enabled&lt;/code&gt; ). Чтобы изменить настройки в Chrome, посетите chrome: // flags.</target>
        </trans-unit>
        <trans-unit id="6aac50e494a4685cfa01b409c7700b3851e9f9e7" translate="yes" xml:space="preserve">
          <source>Disabled From version 65: this feature is behind the &lt;code&gt;dom.security.featurePolicy.header.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="726ec65869fe460716d9db41541949cae8c24c4e" translate="yes" xml:space="preserve">
          <source>Disabled From version 66: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">Отключено Начиная с версии 66: эта функция находится за параметром &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; (необходимо установить на &lt;code&gt;Enabled&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aebc6632a71f5502b11ed22ad8c5755ec1c88bfe" translate="yes" xml:space="preserve">
          <source>Disabled From version 66: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">Отключено Начиная с версии 66: эта функция находится за параметром &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; (необходимо установить на &lt;code&gt;Enabled&lt;/code&gt; ). Чтобы изменить настройки в Chrome, посетите chrome: // flags.</target>
        </trans-unit>
        <trans-unit id="366e50a33639dd16e2b224c5a3ee5b82578e4e0e" translate="yes" xml:space="preserve">
          <source>Disabled From version 67: this feature is behind the &lt;code&gt;dom.security.featurePolicy.header.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56705b66ed39339d0a4b894306b2ecabb3efd7c6" translate="yes" xml:space="preserve">
          <source>Disabled From version 68: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">Отключено Начиная с версии 68: эта функция находится за параметром &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; (необходимо установить значение &lt;code&gt;Enabled&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2dcbb985ceab20f02611932df74cc051d6062ad2" translate="yes" xml:space="preserve">
          <source>Disabled From version 68: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">Отключено Начиная с версии 68: эта функция находится за параметром &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; (необходимо установить значение &lt;code&gt;Enabled&lt;/code&gt; ). Чтобы изменить настройки в Chrome, посетите chrome: // flags.</target>
        </trans-unit>
        <trans-unit id="d28e2d242fc0c32d88a4828425be70d8d4e9386c" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">Отключено Начиная с версии 69: эта функция скрывается за предпочтением &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; (необходимо установить значение &lt;code&gt;Enabled&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dc43adf822f8071bf38b741b4c8b4ff8caa87dd2" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">Отключено Начиная с версии 69: эта функция скрывается за предпочтением &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; (необходимо установить значение &lt;code&gt;Enabled&lt;/code&gt; ). Чтобы изменить настройки в Chrome, посетите chrome: // flags.</target>
        </trans-unit>
        <trans-unit id="e63694ea8ef64e459c00d7c0d93772ca98cd8c0d" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;network.cookie.sameSite.laxByDefault&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e6c448fbfef096f82b450df55d6a46e80c7144a" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;network.cookie.sameSite.noneRequiresSecure&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2696e5d2f6597ff6db717b5917fe7ef78b21f49" translate="yes" xml:space="preserve">
          <source>Disabled From version 72: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932bbade750d61ada15f0c29ceb15ac8767a08c2" translate="yes" xml:space="preserve">
          <source>Disabled From version 72: this feature is behind the &lt;code&gt;security.cert_pinning.hpkp.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78775da32cd4aa8691fe3765af5c89229860835" translate="yes" xml:space="preserve">
          <source>Disabled From version 73 until version 76 (exclusive): this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49a2f2138558d7e247fc15cdf0f8f8e80da02a9" translate="yes" xml:space="preserve">
          <source>Disabled From version 79: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efbf731d4f27dd707439b02e0fcf767655467961" translate="yes" xml:space="preserve">
          <source>Disables DNS prefetching. This is useful if you don't control the link on the pages, or know that you don't want to leak information to these domains.</source>
          <target state="translated">Отключает предварительную настройку DNS.Это полезно,если вы не контролируете ссылку на страницах или знаете,что не хотите утечки информации в эти домены.</target>
        </trans-unit>
        <trans-unit id="58f5f4ebc16939ddad056d1835f255075e38be52" translate="yes" xml:space="preserve">
          <source>Disables MIME sniffing and forces browser to use the type given in &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Отключает сниффинг MIME и заставляет браузер использовать тип, указанный в &lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c27076a7d462b5b7f6f1b44922f1242a3e46ba5" translate="yes" xml:space="preserve">
          <source>Disables XSS filtering.</source>
          <target state="translated">Отключает фильтрацию XSS.</target>
        </trans-unit>
        <trans-unit id="57822983bbd8b7a6c9f3de16f7fe5eab989d06a5" translate="yes" xml:space="preserve">
          <source>Disabling a feature in a policy is a one-way toggle. If a feature has been disabled for a child frame by its parent frame, the child cannot re-enable it, and neither can any of the child's descendants.</source>
          <target state="translated">Отключение функции в политике-это одностороннее переключение.Если функция была отключена для дочернего фрейма родительским фреймом,дочерний фрейм не может повторно включить ее,и ни один из потомков дочернего фрейма не может.</target>
        </trans-unit>
        <trans-unit id="b95dd3eb6900d93a418238bf7a5a3a1a746e7c86" translate="yes" xml:space="preserve">
          <source>Disallowing plugins</source>
          <target state="translated">Отключающие плагины</target>
        </trans-unit>
        <trans-unit id="93902c2eda1c4f4fa6e24f3a214f7642478627b6" translate="yes" xml:space="preserve">
          <source>Disconnected Operation</source>
          <target state="translated">Отключено Эксплуатация</target>
        </trans-unit>
        <trans-unit id="c5bdaaa9046da0ea03b3b9660b87425b983b09dd" translate="yes" xml:space="preserve">
          <source>Discrete types</source>
          <target state="translated">Дискретные типы</target>
        </trans-unit>
        <trans-unit id="d69e4d6aad6c625810f7014dfc3dfbd01898d5b3" translate="yes" xml:space="preserve">
          <source>Discussion of HTTP headers</source>
          <target state="translated">Обсуждение заголовков HTTP</target>
        </trans-unit>
        <trans-unit id="e7414bd7b2a8ae1b4152a32e27208f6ea5703ede" translate="yes" xml:space="preserve">
          <source>Display security and privacy policies In Firefox Developer Tools</source>
          <target state="translated">Политики безопасности и конфиденциальности отображения В Firefox Developer Tools</target>
        </trans-unit>
        <trans-unit id="d78de940f6bf90261043cb8bd08624772df60547" translate="yes" xml:space="preserve">
          <source>Disregarding DNT. The origin server is unable or unwilling to respect a tracking preference received from the requesting user agent.</source>
          <target state="translated">Без учета ДНТ.Исходный сервер не может или не желает уважать предпочтения по отслеживанию,полученные от запрашивающего агента пользователя.</target>
        </trans-unit>
        <trans-unit id="4a1de6fc43e38e089c17a80c82ba419f8f473962" translate="yes" xml:space="preserve">
          <source>Do &lt;strong&gt;not&lt;/strong&gt; use this meta element like this for stating a document language:</source>
          <target state="translated">Вы &lt;strong&gt;не&lt;/strong&gt; использовать этот мета элемент , как это для констатирую язык документа:</target>
        </trans-unit>
        <trans-unit id="2c25376cd1e5d495d8c85d1b29c113dcd4496160" translate="yes" xml:space="preserve">
          <source>Do Not Track</source>
          <target state="translated">Не отслеживать</target>
        </trans-unit>
        <trans-unit id="70f963907a2dc441e4078146477cb1ac975253ce" translate="yes" xml:space="preserve">
          <source>Do Not Track on Wikipedia</source>
          <target state="translated">Не отслеживать в Википедии</target>
        </trans-unit>
        <trans-unit id="5de6d660ffd0c31bb077df9301609dfb8cf69667" translate="yes" xml:space="preserve">
          <source>Do you want to provide different HTML depending on which browser is being used?</source>
          <target state="translated">Вы хотите предоставить различные HTML в зависимости от того,какой браузер используется?</target>
        </trans-unit>
        <trans-unit id="96d09f4b8e17c5718c2731ce7ab9928e287257a4" translate="yes" xml:space="preserve">
          <source>Do-Not-Track</source>
          <target state="translated">Do-Not-Track</target>
        </trans-unit>
        <trans-unit id="e214b8a29923056887b7edf6635d90dcbb2abe88" translate="yes" xml:space="preserve">
          <source>Document</source>
          <target state="translated">Document</target>
        </trans-unit>
        <trans-unit id="54500ed3527305b0f92d5cf278622f552f491a43" translate="yes" xml:space="preserve">
          <source>Document directive</source>
          <target state="translated">директивный документ</target>
        </trans-unit>
        <trans-unit id="f2213ce4b36d0f4e6e226bd21f16b5d5bf80dcba" translate="yes" xml:space="preserve">
          <source>Document directives</source>
          <target state="translated">руководящий документ</target>
        </trans-unit>
        <trans-unit id="ec6b0754c2e6157428f7e2691227c09de666ec35" translate="yes" xml:space="preserve">
          <source>Document directives govern the properties of a document or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;worker&lt;/a&gt; environment to which a policy applies.</source>
          <target state="translated">Директивы документа управляют свойствами документа или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;рабочей&lt;/a&gt; среды, к которой применяется политика.</target>
        </trans-unit>
        <trans-unit id="48b3bb8b0a579c9e6fbd40516291d94dca86d1ba" translate="yes" xml:space="preserve">
          <source>Does not work below Windows 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6dfa8179f4637130555f525186dd9377736169" translate="yes" xml:space="preserve">
          <source>Does not work on Windows 7 and Windows 8.1.</source>
          <target state="translated">Не работает на Windows 7 и Windows 8.1.</target>
        </trans-unit>
        <trans-unit id="ea664539e7e07c3b3cb2d4e3bb71cc99d18e5b5b" translate="yes" xml:space="preserve">
          <source>Domain aliasing</source>
          <target state="translated">Наименование домена</target>
        </trans-unit>
        <trans-unit id="3b549bffd9a85f8fa78b065a75e77e845bc42471" translate="yes" xml:space="preserve">
          <source>Domain aliasing can be done for several reasons:</source>
          <target state="translated">Наложение доменных имен может быть сделано по нескольким причинам:</target>
        </trans-unit>
        <trans-unit id="66a72f8713e4b8fdfa4a8582d2a117d6b82dbadd" translate="yes" xml:space="preserve">
          <source>Domain attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690d7332b26bc38eab02d6b1abf316a940401914" translate="yes" xml:space="preserve">
          <source>Domain sharding</source>
          <target state="translated">Ограждение домена</target>
        </trans-unit>
        <trans-unit id="3c61580d55d642952fbec533e8d3f2630a7d8e94" translate="yes" xml:space="preserve">
          <source>Domain=&amp;lt;domain-value&amp;gt; Optional</source>
          <target state="translated">Домен = &amp;lt;domain-value&amp;gt; Необязательно</target>
        </trans-unit>
        <trans-unit id="dc4653bff510cf1118951874eb552343ce4eeea4" translate="yes" xml:space="preserve">
          <source>Download resumption in Internet Explorer</source>
          <target state="translated">Скачать возобновление в Internet Explorer</target>
        </trans-unit>
        <trans-unit id="a862c2b21b5e1337de2b76d5e43ae1375117d34d" translate="yes" xml:space="preserve">
          <source>Downloads</source>
          <target state="translated">Downloads</target>
        </trans-unit>
        <trans-unit id="23d33e22acfcb9ecddb4a85f10607dc4ff49e23c" translate="yes" xml:space="preserve">
          <source>Draft</source>
          <target state="translated">Draft</target>
        </trans-unit>
        <trans-unit id="13ae8e0a7cb29b1ff62023de94998bfc639787c9" translate="yes" xml:space="preserve">
          <source>Draft document</source>
          <target state="translated">Проект документа</target>
        </trans-unit>
        <trans-unit id="ddc6d4101d699284c4ee49346220f3fb8a444994" translate="yes" xml:space="preserve">
          <source>Draft spec</source>
          <target state="translated">Проект спецификации</target>
        </trans-unit>
        <trans-unit id="8a8aba5130fcc62311d7ddc3b7380514a11ed8fe" translate="yes" xml:space="preserve">
          <source>Due to the &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;configuration-based entropy&lt;/a&gt; increase, a modified value can be used to fingerprint the user, it is not recommended to change it and a Web site cannot trust this value to reflect the actual wish of the user. Site designers must not be over-zealous by using language detection via this header as it can lead to a poor user experience:</source>
          <target state="translated">Из-за увеличения &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;энтропии на основе конфигурации&lt;/a&gt; , измененное значение может использоваться для отпечатка пальца пользователя, его не рекомендуется изменять, и веб-сайт не может доверять этому значению, чтобы оно отражало фактическое желание пользователя. Разработчики сайтов не должны переусердствовать, используя определение языка с помощью этого заголовка, так как это может ухудшить работу пользователей:</target>
        </trans-unit>
        <trans-unit id="408eba332fcca84c3bed5ec905d05209bce63d2e" translate="yes" xml:space="preserve">
          <source>Due to their emphasis on authoring, WebDAV servers need to use
   authentication technology to protect not just access to a network
   resource, but the integrity of the resource as well.  Furthermore,
   the introduction of locking functionality requires support for
   authentication.

   A password sent in the clear over an insecure channel is an
   inadequate means for protecting the accessibility and integrity of a
   resource as the password may be intercepted.  Since Basic
   authentication for HTTP/1.1 performs essentially clear text
   transmission of a password, Basic authentication MUST NOT be used to
   authenticate a WebDAV client to a server unless the connection is
   secure.  Furthermore, a WebDAV server MUST NOT send a Basic
   authentication challenge in a WWW-Authenticate header unless the
   connection is secure.  An example of a secure connection would be a
   Transport Layer Security (TLS) connection employing a strong cipher
   suite and server authentication. 

   WebDAV applications MUST support the Digest authentication scheme
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;].  Since Digest authentication verifies that both parties to
   a communication know a shared secret, a password, without having to
   send that secret in the clear, Digest authentication avoids the
   security problems inherent in Basic authentication while providing a
   level of authentication that is useful in a wide range of scenarios.</source>
          <target state="translated">Из-за того, что серверы WebDAV делают упор на авторскую разработку, они должны использовать технологию аутентификации для защиты не только доступа к сетевому ресурсу, но и целостности ресурса. Кроме того, введение функции блокировки требует поддержки аутентификации. Пароль, посланный в открытом виде по незащищенному каналу, является неадекватным средством защиты доступности и целостности ресурса, поскольку пароль может быть перехвачен. Поскольку обычная проверка подлинности для HTTP / 1.1 выполняет по существу передачу пароля в виде открытого текста, обычная проверка подлинности НЕ ДОЛЖНА использоваться для проверки подлинности клиента WebDAV на сервере, если соединение не является безопасным. Кроме того, сервер WebDAV НЕ ДОЛЖЕН отправлять запрос базовой аутентификации в заголовке WWW-Authenticate, если соединение не является безопасным.Примером безопасного соединения может служить соединение TLS, использующее надежный набор шифров и аутентификацию сервера. Приложения WebDAV ДОЛЖНЫ поддерживать схему аутентификации Digest [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ]. Поскольку дайджест-аутентификация проверяет, знают ли обе стороны связи общий секрет, пароль, без необходимости отправлять этот секрет в открытом виде, дайджест-аутентификация позволяет избежать проблем безопасности, присущих базовой аутентификации, обеспечивая при этом уровень аутентификации, который полезен в широком диапазоне. ряд сценариев.</target>
        </trans-unit>
        <trans-unit id="997743d612e18993ff8dc7080968428d093101a4" translate="yes" xml:space="preserve">
          <source>During the same time, the need for an encrypted transport layer raised: the Web left the relative trustiness of a mostly academic network, to a jungle where advertisers, random individuals or criminals compete to get as much private information about people, try to impersonate them or even to replace data transmitted by altered ones. As the applications built over HTTP became more and more powerful, having access to more and more private information like address books, e-mail, or the geographic position of the user, the need to have TLS became ubiquitous even outside the e-commerce use case.</source>
          <target state="translated">В то же время возникла необходимость в зашифрованном транспортном уровне:Сеть оставила относительное доверие в основном академической сети,в джунглях,где рекламодатели,случайные люди или преступники соревнуются за то,чтобы получить как можно больше частной информации о людях,попытаться выдать себя за них или даже заменить данные,передаваемые измененными.По мере того,как приложения,построенные по HTTP,становились все более мощными,имея доступ к все большему количеству частной информации,такой как адресные книги,электронная почта,или географическое положение пользователя,необходимость в TLS стала повсеместной даже вне рамок использования электронной коммерции.</target>
        </trans-unit>
        <trans-unit id="95b3251ec6e19bc2e780b0b452fffbe79113def2" translate="yes" xml:space="preserve">
          <source>Dynamic serving</source>
          <target state="translated">Динамичная подача</target>
        </trans-unit>
        <trans-unit id="57313c5dd0c9956db75ecb6a66db1c8dbb3f5fdf" translate="yes" xml:space="preserve">
          <source>Dynamic. The origin server needs more information to determine tracking status.</source>
          <target state="translated">Динамический.Серверу-источнику требуется больше информации для определения статуса отслеживания.</target>
        </trans-unit>
        <trans-unit id="705ecd20fdc7a1a80cbce38adda833a8e258328f" translate="yes" xml:space="preserve">
          <source>ECMAScript (&lt;a href=&quot;https://www.iana.org/assignments/media-types/application/ecmascript&quot;&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt; Specification&lt;/em&gt;&lt;/a&gt;) (&lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329 Section 8.2&lt;/a&gt;)</source>
          <target state="translated">ECMAScript ( &lt;a href=&quot;https://www.iana.org/assignments/media-types/application/ecmascript&quot;&gt;&lt;em&gt;спецификация &lt;/em&gt;&lt;/a&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt;&lt;/em&gt; ) ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329, раздел 8.2&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="11d00f6ed181afbae6281cf892e585dcee85b274" translate="yes" xml:space="preserve">
          <source>ETag</source>
          <target state="translated">ETag</target>
        </trans-unit>
        <trans-unit id="a9cf203d9639d2de24fc7e1aabf9a3f1d1b216fd" translate="yes" xml:space="preserve">
          <source>ETag (RFC 2616)</source>
          <target state="translated">ETag (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="c3c187693ac73afbe58b0355bda0f434ddd57b14" translate="yes" xml:space="preserve">
          <source>ETag (RFC 7232)</source>
          <target state="translated">ETag (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="2586de7225abd1a31095cd8e2595f05492c55926" translate="yes" xml:space="preserve">
          <source>ETags</source>
          <target state="translated">ETags</target>
        </trans-unit>
        <trans-unit id="91b64bf36619dc548bb6dc82aa7a3172dcb0fa4a" translate="yes" xml:space="preserve">
          <source>EU cookie directive</source>
          <target state="translated">директива ЕС о куки-файлах</target>
        </trans-unit>
        <trans-unit id="aacf5c8fecb249d308c1a10d329efa9aa9c43e95" translate="yes" xml:space="preserve">
          <source>Each Hypertext Transfer Protocol (HTTP) message is either a request
   or a response.  A server listens on a connection for a request,
   parses each message received, interprets the message semantics in
   relation to the identified request target, and responds to that
   request with one or more response messages.  A client constructs
   request messages to communicate specific intentions, examines
   received responses to see if the intentions were carried out, and
   determines how to interpret the results.  This document defines
   HTTP/1.1 request and response semantics in terms of the architecture
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;].

   HTTP provides a uniform interface for interacting with a resource
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;), regardless of its type, nature, or implementation, via
   the manipulation and transfer of representations (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;).

   HTTP semantics include the intentions defined by each request method
   (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), extensions to those semantics that might be described in
   request header fields (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;), the meaning of status codes to
   indicate a machine-readable response (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;), and the meaning of
   other control data and resource metadata that might be given in
   response header fields (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).

   This document also defines representation metadata that describe how
   a payload is intended to be interpreted by a recipient, the request
   header fields that might influence content selection, and the various
   selection algorithms that are collectively referred to as &quot;content
   negotiation&quot; (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;).</source>
          <target state="translated">Каждое сообщение протокола передачи гипертекста (HTTP) является либо запросом, либо ответом. Сервер прослушивает соединение для запроса, анализирует каждое полученное сообщение, интерпретирует семантику сообщения относительно идентифицированной цели запроса и отвечает на этот запрос одним или несколькими ответными сообщениями. Клиент создает сообщения запроса, чтобы сообщить о конкретных намерениях, проверяет полученные ответы, чтобы убедиться, что намерения были выполнены, и определяет, как интерпретировать результаты. Этот документ определяет семантику запросов и ответов HTTP / 1.1 в терминах архитектуры, определенной в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]. HTTP предоставляет единый интерфейс для взаимодействия с ресурсом ( &lt;a href=&quot;#section-2&quot;&gt;раздел 2&lt;/a&gt;), независимо от его типа, природы или реализации, посредством манипулирования и передачи представлений ( &lt;a href=&quot;#section-3&quot;&gt;раздел 3&lt;/a&gt; ). Семантика HTTP включает намерения, определенные каждым методом запроса ( &lt;a href=&quot;#section-4&quot;&gt;раздел 4&lt;/a&gt; ), расширения той семантики, которая может быть описана в полях заголовка запроса ( &lt;a href=&quot;#section-5&quot;&gt;раздел 5&lt;/a&gt; ), значение кодов состояния для указания машиночитаемого ответа ( &lt;a href=&quot;#section-6&quot;&gt;раздел 6&lt;/a&gt; ) и значение других управляющих данных и метаданных ресурсов, которые могут быть указаны в полях заголовка ответа ( &lt;a href=&quot;#section-7&quot;&gt;Раздел 7&lt;/a&gt;). Этот документ также определяет метаданные представления, которые описывают, как полезная нагрузка предназначена для интерпретации получателем, поля заголовка запроса, которые могут влиять на выбор контента, и различные алгоритмы выбора, которые в совокупности называются &amp;laquo;согласованием контента&amp;raquo; ( &lt;a href=&quot;#section-3.4&quot;&gt;раздел 3.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="057e4721fb960e50e6bc2f172224db4e1bf70d8b" translate="yes" xml:space="preserve">
          <source>Each Status-Code is described below, including a description of which
   method(s) it can follow and any metainformation required in the
   response.</source>
          <target state="translated">Каждый статус-код описан ниже,включая описание того,какому методу (методам)он может следовать,и любую метаинформацию,требуемую в ответе.</target>
        </trans-unit>
        <trans-unit id="0bafccf37828f0cf81554847666fb3201e53972e" translate="yes" xml:space="preserve">
          <source>Each browser performs MIME sniffing differently and under different circumstances. (For example, Safari will look at the file extension in the URL if the sent MIME type is unsuitable.) There are security concerns as some MIME types represent executable content. Servers can prevent MIME sniffing by sending the &lt;a href=&quot;../headers/x-content-type-options&quot;&gt;&lt;code&gt;X-Content-Type-Options&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Каждый браузер выполняет анализ MIME по-своему и при разных обстоятельствах. (Например, Safari будет проверять расширение файла в URL-адресе, если отправленный тип MIME не подходит.) Существуют проблемы безопасности, поскольку некоторые типы MIME представляют исполняемое содержимое. Серверы могут предотвратить прослушивание MIME, отправив заголовок &lt;a href=&quot;../headers/x-content-type-options&quot;&gt; &lt;code&gt;X-Content-Type-Options&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82fa8700dcf214b80fbd4de6e7bf762e538223a6" translate="yes" xml:space="preserve">
          <source>Each client in the request chain may have its own cache, so it is
   common for a cache at an intermediary to receive conditional requests
   from other (outbound) caches.  Likewise, some user agents make use of
   conditional requests to limit data transfers to recently modified
   representations or to complete the transfer of a partially retrieved
   representation.

   If a cache receives a request that can be satisfied by reusing one of
   its stored 200 (OK) or 206 (Partial Content) responses, the cache
   SHOULD evaluate any applicable conditional header field preconditions
   received in that request with respect to the corresponding validators
   contained within the selected response.  A cache MUST NOT evaluate 

   conditional header fields that are only applicable to an origin
   server, found in a request with semantics that cannot be satisfied
   with a cached response, or applied to a target resource for which it
   has no stored responses; such preconditions are likely intended for
   some other (inbound) server.

   The proper evaluation of conditional requests by a cache depends on
   the received precondition header fields and their precedence, as
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7232]&lt;/a&gt;.  The If-Match and
   If-Unmodified-Since conditional header fields are not applicable to a
   cache.

   A request containing an If-None-Match header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of
   [RFC7232]&lt;/a&gt;) indicates that the client wants to validate one or more of
   its own stored responses in comparison to whichever stored response
   is selected by the cache.  If the field-value is &quot;*&quot;, or if the
   field-value is a list of entity-tags and at least one of them matches
   the entity-tag of the selected stored response, a cache recipient
   SHOULD generate a 304 (Not Modified) response (using the metadata of
   the selected stored response) instead of sending that stored
   response.

   When a cache decides to revalidate its own stored responses for a
   request that contains an If-None-Match list of entity-tags, the cache
   MAY combine the received list with a list of entity-tags from its own
   stored set of responses (fresh or stale) and send the union of the
   two lists as a replacement If-None-Match header field value in the
   forwarded request.  If a stored response contains only partial
   content, the cache MUST NOT include its entity-tag in the union
   unless the request is for a range that would be fully satisfied by
   that partial stored response.  If the response to the forwarded
   request is 304 (Not Modified) and has an ETag header field value with
   an entity-tag that is not in the client's list, the cache MUST
   generate a 200 (OK) response for the client by reusing its
   corresponding stored response, as updated by the 304 response
   metadata (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;).

   If an If-None-Match header field is not present, a request containing
   an If-Modified-Since header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7232]&lt;/a&gt;)
   indicates that the client wants to validate one or more of its own
   stored responses by modification date.  A cache recipient SHOULD
   generate a 304 (Not Modified) response (using the metadata of the
   selected stored response) if one of the following cases is true: 1)
   the selected stored response has a Last-Modified field-value that is
   earlier than or equal to the conditional timestamp; 2) no
   Last-Modified field is present in the selected stored response, but
   it has a Date field-value that is earlier than or equal to the
   conditional timestamp; or, 3) neither Last-Modified nor Date is 

   present in the selected stored response, but the cache recorded it as
   having been received at a time earlier than or equal to the
   conditional timestamp.

   A cache that implements partial responses to range requests, as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;], also needs to evaluate a received If-Range
   header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt;) with respect to its selected
   stored response.</source>
          <target state="translated">Каждый клиент в цепочке запросов может иметь свой собственный кеш, поэтому для кеша на посреднике обычным делом является получение условных запросов из других (исходящих) кешей. Аналогичным образом, некоторые пользовательские агенты используют условные запросы для ограничения передачи данных недавно измененными представлениями или для завершения передачи частично извлеченного представления. Если кэш получает запрос, который может быть удовлетворен путем повторного использования одного из сохраненных ответов 200 (ОК) или 206 (частичное содержимое), кеш ДОЛЖЕН оценить любые применимые предварительные условия поля условного заголовка, полученные в этом запросе, относительно соответствующих валидаторов, содержащихся в выбранный ответ. Кэш НЕ ДОЛЖЕН оценивать поля условного заголовка, которые применимы только к исходному серверу,обнаружен в запросе с семантикой, которая не может быть удовлетворена кэшированным ответом, или применена к целевому ресурсу, для которого у него нет сохраненных ответов; такие предварительные условия, вероятно, предназначены для какого-либо другого (входящего) сервера. Правильная оценка условных запросов кэшем зависит от полученных полей заголовка предварительного условия и их приоритета, как определено в&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-6&quot;&gt;Раздел 6 [RFC7232]&lt;/a&gt; . Поля условного заголовка If-Match и If-Unmodified-Since не применимы к кешу. Запрос, содержащий поле заголовка If-None-Match ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;раздел 3.2 [RFC7232]&lt;/a&gt;) указывает, что клиент хочет проверить один или несколько собственных сохраненных ответов по сравнению с любым сохраненным ответом, выбранным кешем. Если значение поля равно &amp;laquo;*&amp;raquo;, или если значение поля представляет собой список тегов объекта, и хотя бы один из них соответствует тегу объекта выбранного сохраненного ответа, получатель кеша ДОЛЖЕН сгенерировать сообщение 304 (Не изменено ) ответ (с использованием метаданных выбранного сохраненного ответа) вместо отправки этого сохраненного ответа. Когда кеш решает повторно проверить свои собственные сохраненные ответы для запроса, который содержит список тегов сущностей If-None-Match,кэш МОЖЕТ объединить полученный список со списком тегов объектов из своего собственного сохраненного набора ответов (свежих или устаревших) и отправить объединение двух списков в качестве заменяющего значения поля заголовка If-None-Match в перенаправленном запросе. Если сохраненный ответ содержит только частичное содержимое, кэш НЕ ДОЛЖЕН включать свой тег объекта в объединение, если только запрос не относится к диапазону, который полностью удовлетворяется этим частичным сохраненным ответом. Если ответ на перенаправленный запрос равен 304 (не изменен) и имеет значение поля заголовка ETag с тегом объекта, которого нет в списке клиента, кэш ДОЛЖЕН сгенерировать ответ 200 (OK) для клиента, повторно используя его соответствующий сохраненный ответ, обновленный метаданными ответа 304 (кэш НЕ ДОЛЖЕН включать свой тег объекта в объединение, если только запрос не относится к диапазону, который будет полностью удовлетворен этим частичным сохраненным ответом. Если ответ на перенаправленный запрос равен 304 (не изменен) и имеет значение поля заголовка ETag с тегом объекта, которого нет в списке клиента, кэш ДОЛЖЕН сгенерировать ответ 200 (OK) для клиента, повторно используя его соответствующий сохраненный ответ, обновленный метаданными ответа 304 (кэш НЕ ДОЛЖЕН включать свой тег объекта в объединение, если только запрос не относится к диапазону, который будет полностью удовлетворен этим частичным сохраненным ответом. Если ответ на перенаправленный запрос равен 304 (не изменен) и имеет значение поля заголовка ETag с тегом объекта, которого нет в списке клиента, кэш ДОЛЖЕН сгенерировать ответ 200 (OK) для клиента, повторно используя его соответствующий сохраненный ответ, обновленный метаданными ответа 304 (кэш ДОЛЖЕН генерировать ответ 200 (OK) для клиента, повторно используя его соответствующий сохраненный ответ, обновленный метаданными ответа 304 (кэш ДОЛЖЕН генерировать ответ 200 (OK) для клиента, повторно используя его соответствующий сохраненный ответ, обновленный метаданными ответа 304 (&lt;a href=&quot;#section-4.3.4&quot;&gt;Раздел 4.3.4&lt;/a&gt; ). Если поле заголовка If-None-Match отсутствует, запрос, содержащий поле заголовка If-Modified-Since ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;раздел 3.3 [RFC7232])&lt;/a&gt;) указывает, что клиент хочет проверить один или несколько собственных сохраненных ответов по дате изменения. Получателю кэша СЛЕДУЕТ сгенерировать ответ 304 (Not Modified) (используя метаданные выбранного сохраненного ответа), если выполняется один из следующих случаев: 1) выбранный сохраненный ответ имеет значение поля Last-Modified, которое раньше или равно условной отметке времени; 2) в выбранном сохраненном ответе нет поля Last-Modified, но у него есть значение поля Date, которое раньше или равно условной отметке времени; или 3) ни Last-Modified, ни Date не присутствуют в выбранном сохраненном ответе, но кэш записал его как полученный в момент времени, предшествующий условной временной метке или равный ему. Кэш, реализующий частичные ответы на запросы диапазона,как определено в [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ], также необходимо оценить полученное поле заголовка If-Range ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;раздел 3.2 [RFC7233]&lt;/a&gt; ) относительно его выбранного сохраненного ответа.</target>
        </trans-unit>
        <trans-unit id="cdfff658f8638be3f51c025575b0ddaed39961ef" translate="yes" xml:space="preserve">
          <source>Each data type has some redundancy, that is &lt;em&gt;wasted space&lt;/em&gt;, in it. If text can typically have as much as 60% redundancy, this rate can be much higher for some other media like audio and video. Unlike text, these other media types are taking a lot of space to store and the need to regain this wasted space appeared very early. Engineers designed the optimized compression algorithm used by file formats designed for this specific purpose. Compression algorithms used for files can be grouped into two broad categories:</source>
          <target state="translated">Каждый тип данных имеет некоторую избыточность, то есть &lt;em&gt;потерянное пространство&lt;/em&gt; . Если текст обычно может иметь до 60% избыточности, этот показатель может быть намного выше для некоторых других носителей, таких как аудио и видео. В отличие от текста, эти другие типы носителей занимают много места для хранения, и необходимость вернуть это потраченное впустую пространство возникла очень рано. Инженеры разработали оптимизированный алгоритм сжатия, используемый форматами файлов, предназначенными для этой конкретной цели. Алгоритмы сжатия, используемые для файлов, можно разделить на две большие категории:</target>
        </trans-unit>
        <trans-unit id="ae7498ae0f7b36b2dcd84d942c2be51971574fec" translate="yes" xml:space="preserve">
          <source>Each data type has some redundancy, that is &lt;em&gt;wasted space&lt;/em&gt;, in it. If text can typically have as much as 60% redundancy, this rate can be much higher for some other media like audio and video. Unlike text, these other media types use lot of space to store their data and the need to optimize storage and regain space was apparent very early. Engineers designed the optimized compression algorithm used by file formats designed for this specific purpose. Compression algorithms used for files can be grouped into two broad categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c418e981dde2783c397a4ab8566b1987e0ddccd" translate="yes" xml:space="preserve">
          <source>Each header field consists of a case-insensitive field name followed
   by a colon (&quot;:&quot;), optional leading whitespace, the field value, and
   optional trailing whitespace. 

     header-field   = field-name &quot;:&quot; OWS field-value OWS

     field-name     = token
     field-value    = *( field-content / obs-fold )
     field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
     field-vchar    = VCHAR / obs-text

     obs-fold       = CRLF 1*( SP / HTAB )
                    ; obsolete line folding
                    ; see &lt;a href=&quot;#section-3.2.4&quot;&gt;Section 3.2.4&lt;/a&gt;

   The field-name token labels the corresponding field-value as having
   the semantics defined by that header field.  For example, the Date
   header field is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Section&amp;nbsp;7.1.1.2 of [RFC7231]&lt;/a&gt; as containing
   the origination timestamp for the message in which it appears.</source>
          <target state="translated">Каждое поле заголовка состоит из имени поля без учета регистра, за которым следует двоеточие (&quot;:&quot;), необязательного начального пробела, значения поля и необязательного конечного пробела. header-field = field-name &quot;:&quot; OWS field-value OWS field-name = token field-value = * (field-content / obs-fold) field-content = field-vchar [1 * (SP / HTAB) field -vchar] field-vchar = VCHAR / obs-text obs-fold = CRLF 1 * (SP / HTAB); устаревший перенос строк; см. &lt;a href=&quot;#section-3.2.4&quot;&gt;раздел 3.2.4&lt;/a&gt; . Маркер имени поля помечает соответствующее значение поля как имеющее семантику, определенную этим полем заголовка. Например, поле заголовка Date определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;разделе 7.1.1.2 [RFC7231].&lt;/a&gt; как содержащий отметку времени отправления сообщения, в котором оно появляется.</target>
        </trans-unit>
        <trans-unit id="9565e409b5a13cd6eeebcf793281c0c14e6920fb" translate="yes" xml:space="preserve">
          <source>Each individual request is sent to a server, which handles it and provides an answer, called the &lt;em&gt;response&lt;/em&gt;. Between the client and the server there are numerous entities, collectively called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxies&lt;/a&gt;, which perform different operations and act as gateways or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;caches&lt;/a&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa9777361801f65cdbd5d095a27001848c440f6" translate="yes" xml:space="preserve">
          <source>Each individual request is sent to a server, which will handle it and provide an answer, called the &lt;em&gt;response&lt;/em&gt;. Between this request and response there are numerous entities, collectively designated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxies&lt;/a&gt;, which perform different operations and act as gateways or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;caches&lt;/a&gt;, for example.</source>
          <target state="translated">Каждый отдельный запрос отправляется на сервер, который обрабатывает его и предоставляет ответ, называемый &lt;em&gt;ответом&lt;/em&gt; . Между этим запросом и ответом есть множество объектов, которые вместе обозначаются как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;прокси&lt;/a&gt; , которые выполняют различные операции и действуют, например, как шлюзы или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;кеши&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d47e568ac317d800ba83293a6e6b145c10f0e3f" translate="yes" xml:space="preserve">
          <source>Each registered protocol name is associated with contact information
   and an optional set of specifications that details how the connection
   will be processed after it has been upgraded.

   Registrations happen on a &quot;First Come First Served&quot; basis (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC5226]&lt;/a&gt;) and are subject to the following rules:

   1.  A protocol-name token, once registered, stays registered forever.

   2.  The registration MUST name a responsible party for the
       registration.

   3.  The registration MUST name a point of contact.

   4.  The registration MAY name a set of specifications associated with
       that token.  Such specifications need not be publicly available.

   5.  The registration SHOULD name a set of expected &quot;protocol-version&quot;
       tokens associated with that token at the time of registration. 

   6.  The responsible party MAY change the registration at any time.
       The IANA will keep a record of all such changes, and make them
       available upon request.

   7.  The IESG MAY reassign responsibility for a protocol token.  This
       will normally only be used in the case when a responsible party
       cannot be contacted.

   This registration procedure for HTTP Upgrade Tokens replaces that
   previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;Section&amp;nbsp;7.2 of [RFC2817]&lt;/a&gt;.</source>
          <target state="translated">Каждое зарегистрированное имя протокола связано с контактной информацией и дополнительным набором спецификаций, в которых подробно описывается, как соединение будет обрабатываться после его обновления. Регистрация происходит по принципу &amp;laquo;первым пришел - первым &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;обслужен&lt;/a&gt; &amp;raquo; (см. Раздел 4.1 [RFC5226].) и подчиняются следующим правилам: 1. После регистрации токен имени протокола остается зарегистрированным навсегда. 2. При регистрации ДОЛЖНА быть указана ответственная за регистрацию сторона. 3. При регистрации ДОЛЖНО быть указано контактное лицо. 4. Регистрация МОЖЕТ назвать набор спецификаций, связанных с этим токеном. Такие спецификации не обязательно должны быть общедоступными. 5. Регистрации СЛЕДУЕТ назвать набор ожидаемых токенов &amp;laquo;версии протокола&amp;raquo;, связанных с этим токеном во время регистрации. 6. Ответственная сторона МОЖЕТ изменить регистрацию в любое время. IANA будет вести учет всех таких изменений и предоставлять их по запросу. 7. IESG МОЖЕТ передать ответственность за токен протокола.Обычно это используется только в том случае, если невозможно связаться с ответственным лицом. Эта процедура регистрации для токенов обновления HTTP заменяет ранее определенную в&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;Раздел 7.2 [RFC2817]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f681ccf67162d9cff0a908b916182711ed9cc29e" translate="yes" xml:space="preserve">
          <source>Each request for a URL is supposed to be treated as a unique and uncacheable request. A better way to indicate this is to use &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;: &lt;code&gt;no-store&lt;/code&gt;, which is clearer to read and also signals that the object shouldn't be stored ever.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb1874585ee277130e7dcc804818855ef02a2e2" translate="yes" xml:space="preserve">
          <source>Each request for a URL is supposed to be treated as a unique and uncacheable request. A better way to indicate this is to use &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: private&lt;/code&gt;, which is clearer to read and also signals that the object shouldn't be stored ever.</source>
          <target state="translated">Предполагается, что каждый запрос URL-адреса должен рассматриваться как уникальный и некэшируемый запрос. Лучший способ указать на это - использовать &lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: private&lt;/code&gt; , который более понятен для чтения, а также сигнализирует, что объект никогда не должен храниться.</target>
        </trans-unit>
        <trans-unit id="06c0d14065b0e4f4c93db5d7ec072d4c7ca36aee" translate="yes" xml:space="preserve">
          <source>Each type has its own set of possible subtypes, and a MIME type always has both a type and a subtype, never just one or the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="083351d889941c99f11bdb7f8dc5b5a5a90e3651" translate="yes" xml:space="preserve">
          <source>Early-Data</source>
          <target state="translated">Early-Data</target>
        </trans-unit>
        <trans-unit id="8440b9eb7d03917b2509b5baeab2a299ce257eb0" translate="yes" xml:space="preserve">
          <source>Edge</source>
          <target state="translated">Edge</target>
        </trans-unit>
        <trans-unit id="aa5e3465605004afca0f330dee1d92d60e4608d6" translate="yes" xml:space="preserve">
          <source>Edge 17 skips the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive (&lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/17415478/&quot;&gt;bug&lt;/a&gt;).</source>
          <target state="translated">Edge 17 пропускает директиву &lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/17415478/&quot;&gt;ошибка&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="40943d342558e930e5fd4552c5671ad9d18db865" translate="yes" xml:space="preserve">
          <source>Edge Mobile</source>
          <target state="translated">Edge Mobile</target>
        </trans-unit>
        <trans-unit id="8186c1b8199a285af780f2cff07d80dbd60cd881" translate="yes" xml:space="preserve">
          <source>Edge has &lt;a href=&quot;https://blogs.windows.com/windowsexperience/2018/07/25/announcing-windows-10-insider-preview-build-17723-and-build-18204/&quot;&gt;retired their XSS filter&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1594fb58d4be36a563bbf83f00f527da6feeed9b" translate="yes" xml:space="preserve">
          <source>Edge on Windows 10 Mobile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ed0aee9b31cc8d3563818529b7abccaaaad432" translate="yes" xml:space="preserve">
          <source>Edge/xyz</source>
          <target state="translated">Edge/xyz</target>
        </trans-unit>
        <trans-unit id="d5fbe14f72118336fc25fa625850b0c5c3be431a" translate="yes" xml:space="preserve">
          <source>EdgeHTML</source>
          <target state="translated">EdgeHTML</target>
        </trans-unit>
        <trans-unit id="add94fac827b3ed02fee4c1b72173331645c25b8" translate="yes" xml:space="preserve">
          <source>Edit this page on MDN</source>
          <target state="translated">Редактируйте эту страницу на MDN</target>
        </trans-unit>
        <trans-unit id="a769fc9fd1bf50a69b3839fd2f92626878d5b626" translate="yes" xml:space="preserve">
          <source>Editor's Draft</source>
          <target state="translated">Редакторский черновик</target>
        </trans-unit>
        <trans-unit id="f0aaf1ff183fe38a130caadf7977863f8e2a59f3" translate="yes" xml:space="preserve">
          <source>Editor's draft</source>
          <target state="translated">Черновик редактора</target>
        </trans-unit>
        <trans-unit id="90b56ed596b137c9da80b986161d0bd1c8d62cba" translate="yes" xml:space="preserve">
          <source>Editor's draft / Candidate recommendation</source>
          <target state="translated">Черновик редактора/Рекомендация кандидата</target>
        </trans-unit>
        <trans-unit id="1c3d5530a42ab230eeb2ce3fa0fa80758453dd56" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;report&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; header is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb29b12af265782c792c3f30babdfaf626f24932" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;report&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fcd0c7316a8c31f4e9ceb1db446cf33c197f076" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; header is used.</source>
          <target state="translated">Либо &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; либо &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; зависимости от того, используется ли заголовок &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8d9968b1d7df53b6e4cf681453c3df54edc30bf" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header is used.</source>
          <target state="translated">Либо &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; либо &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; зависимости от того, используется ли заголовок &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; или заголовок &lt;code&gt;Content-Security-Policy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa29e4650b1639a98c0c8f55d262398a02155fba" translate="yes" xml:space="preserve">
          <source>Either the string &quot;GMT&quot; for GMT timezone, or not specified, for local timezone.</source>
          <target state="translated">Либо строка &quot;GMT&quot; для GMT часового пояса,либо не указана для локального часового пояса.</target>
        </trans-unit>
        <trans-unit id="eec5a0a958a1fbddcf0daab821af65ae5b6cc34b" translate="yes" xml:space="preserve">
          <source>Electronic mail address</source>
          <target state="translated">Электронный почтовый адрес</target>
        </trans-unit>
        <trans-unit id="f98f953a2a328bdea00e564fed7dfd322a69cd6d" translate="yes" xml:space="preserve">
          <source>Electronic publication (EPUB)</source>
          <target state="translated">Электронное издание (EPUB)</target>
        </trans-unit>
        <trans-unit id="5a67bc2ccc5173b788a5682e69fed1656994a358" translate="yes" xml:space="preserve">
          <source>Elements controlled by &lt;code&gt;object-src&lt;/code&gt; are perhaps coincidentally considered legacy HTML elements and are not receiving new standardized features (such as the security attributes &lt;code&gt;sandbox&lt;/code&gt; or &lt;code&gt;allow&lt;/code&gt; for &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;). Therefore it is &lt;strong&gt;recommended&lt;/strong&gt; to restrict this fetch-directive (e.g., explicitly set &lt;code&gt;object-src 'none'&lt;/code&gt; if possible).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3465998ffce5d1b11571e20db3e058cd0d4176c" translate="yes" xml:space="preserve">
          <source>Elements controlled by &lt;code&gt;object-src&lt;/code&gt; are perhaps coincidentally considered legacy HTML elements and aren't receiving new standardized features (such as the security attributes &lt;code&gt;sandbox&lt;/code&gt; or &lt;code&gt;allow&lt;/code&gt; for &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;). Therefore it is &lt;a href=&quot;https://csp.withgoogle.com/docs/strict-csp.html&quot;&gt;recommended&lt;/a&gt; to restrict this fetch-directive (e.g. explicitly set &lt;code&gt;object-src 'none'&lt;/code&gt; if possible).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70620ad9a50dbab17deb7f1669beeb98b33e7dd5" translate="yes" xml:space="preserve">
          <source>Enable CORS: I want to add CORS support to my server</source>
          <target state="translated">Включить CORS:Я хочу добавить поддержку CORS на мой сервер.</target>
        </trans-unit>
        <trans-unit id="7060cb09d904d309fcf66579b0dfa0ec89ffc7ea" translate="yes" xml:space="preserve">
          <source>Enables Cross-Origin Read Blocking (CORB) protection for the MIME-types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a23cd75e8cc48555a5cc4d39dc5d353f54219c1" translate="yes" xml:space="preserve">
          <source>Enables DNS prefetching. This is what browsers do, if they support the feature, when this header is not present</source>
          <target state="translated">Включает предварительную настройку DNS.Это то,что делают браузеры,если они поддерживают эту функцию,когда этот заголовок отсутствует.</target>
        </trans-unit>
        <trans-unit id="15f6f232156085ea4d4637fb11cb65dea424795d" translate="yes" xml:space="preserve">
          <source>Enables XSS filtering (usually default in browsers). If a cross-site scripting attack is detected, the browser will sanitize the page (remove the unsafe parts).</source>
          <target state="translated">Включает XSS-фильтрацию (обычно по умолчанию в браузерах).При обнаружении межсайтовой скриптовой атаки браузер обезопасит страницу (удалит небезопасные части).</target>
        </trans-unit>
        <trans-unit id="2afff7cdf670cfcd98e1bf3804e6db1cd9978584" translate="yes" xml:space="preserve">
          <source>Enables XSS filtering. If a cross-site scripting attack is detected, the browser will sanitize the page and report the violation. This uses the functionality of the CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive to send a report.</source>
          <target state="translated">Включает фильтрацию XSS. Если обнаружена атака с использованием межсайтовых сценариев, браузер очистит страницу и сообщит о нарушении. Это использует функциональные возможности директивы CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; для отправки отчета.</target>
        </trans-unit>
        <trans-unit id="04c90c3404283e6479b83c3594ac6645fd7a76cf" translate="yes" xml:space="preserve">
          <source>Enables XSS filtering. Rather than sanitizing the page, the browser will prevent rendering of the page if an attack is detected.</source>
          <target state="translated">Включает фильтрацию XSS.Вместо того,чтобы дезинфицировать страницу,браузер будет препятствовать отрисовке страницы в случае обнаружения атаки.</target>
        </trans-unit>
        <trans-unit id="22ebba1e22e214dfdd20ecfca28bb3fc46c19982" translate="yes" xml:space="preserve">
          <source>Enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">Включает песочницу для запрошенного ресурса, аналогичную атрибуту &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9c536a9d2dc890eb3a315dacecf7bf8af2ea7a0" translate="yes" xml:space="preserve">
          <source>Enables cross-site scripting filtering.</source>
          <target state="translated">Включает межсайтовую скриптовую фильтрацию.</target>
        </trans-unit>
        <trans-unit id="22f217de833d7c0f4da332bd436a93307529d3b5" translate="yes" xml:space="preserve">
          <source>Enabling HPKP</source>
          <target state="translated">Включение HPKP</target>
        </trans-unit>
        <trans-unit id="bd97d929640fde2abf473682141dfee61b906111" translate="yes" xml:space="preserve">
          <source>Enabling reporting</source>
          <target state="translated">Способствующая отчетность</target>
        </trans-unit>
        <trans-unit id="d51a5760383324ea2ced3708f0c4f21b3b6433db" translate="yes" xml:space="preserve">
          <source>Encoding data into base64 format</source>
          <target state="translated">Кодирование данных в формат base64</target>
        </trans-unit>
        <trans-unit id="5a526ce1054f67846c014806870479f982067006" translate="yes" xml:space="preserve">
          <source>Encoding in Javascript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1b3d87041d9d3f6d49d001407d5e51e783220a" translate="yes" xml:space="preserve">
          <source>Encoding on Microsoft Windows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a85145b06e5a569eeab2640e8113603e4dec581" translate="yes" xml:space="preserve">
          <source>Encoding on Windows can be done through powershell or some dedicated tool. It can even be done via bash &lt;code&gt;base64&lt;/code&gt; utility (see section Encoding on a Unix system) if &lt;a href=&quot;https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux&quot;&gt;WSL&lt;/a&gt; is activated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9723a9fa3539530df973d9238398c2287f9fc64" translate="yes" xml:space="preserve">
          <source>Encoding on a Unix system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635fc00ea52427c14323d1d4ec9234a0c136c15e" translate="yes" xml:space="preserve">
          <source>Encrypted Media Extensions&lt;br/&gt;&lt;small&gt;The definition of 'Feature Policy integration' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b844634b78bbf66c2386fb7400b4efd46ba2fc" translate="yes" xml:space="preserve">
          <source>Encrypted media</source>
          <target state="translated">Зашифрованные носители</target>
        </trans-unit>
        <trans-unit id="bb7917263fb0376ecaaebc6aea8b04a067f36021" translate="yes" xml:space="preserve">
          <source>End-to-end compression</source>
          <target state="translated">Комплексное сжатие</target>
        </trans-unit>
        <trans-unit id="a93b3f3b09d62b69cd48fa61fb8317033f43c87d" translate="yes" xml:space="preserve">
          <source>End-to-end headers</source>
          <target state="translated">Встраиваемые заголовки</target>
        </trans-unit>
        <trans-unit id="c1f86bbe0ad1ce921865c4c1081ca46c634279dd" translate="yes" xml:space="preserve">
          <source>Enforces &lt;a href=&quot;https://w3c.github.io/webappsec-trusted-types/dist/spec/&quot;&gt;Trusted Types&lt;/a&gt; at the DOM XSS injection sinks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a78c23ebe3e022d382e262e5bb0fac3b0c04eb" translate="yes" xml:space="preserve">
          <source>Enforcing best practices for good user experiences</source>
          <target state="translated">Внедрение передового опыта для обеспечения хорошего опыта пользователей</target>
        </trans-unit>
        <trans-unit id="434a202c7ecffe7d7bd9b742b730a5afd1676889" translate="yes" xml:space="preserve">
          <source>Enforcing best practices for good user experiences.</source>
          <target state="translated">Внедрение передового опыта для обеспечения хорошего опыта пользователей.</target>
        </trans-unit>
        <trans-unit id="ffa0f5134bbe5f9da939c45f920a197f4634fba1" translate="yes" xml:space="preserve">
          <source>Ensure images are sized properly and are not too big for the viewport.</source>
          <target state="translated">Убедитесь,что изображения имеют правильный размер и не слишком велики для видового экрана.</target>
        </trans-unit>
        <trans-unit id="2a6cc6b1ec9b8b2e989114255b4da3ce2b2f166e" translate="yes" xml:space="preserve">
          <source>Ensures a resource will disown its opener when navigated to.</source>
          <target state="translated">Гарантирует,что ресурс отключит свой нож при переходе к нему.</target>
        </trans-unit>
        <trans-unit id="2f61151d2512a5c88d23bfe8d6fbd9a0947b4f37" translate="yes" xml:space="preserve">
          <source>Entity (RFC 2616)</source>
          <target state="translated">Субъект (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="234e8581d4bf52bbea04d4ae883867b5f00f2402" translate="yes" xml:space="preserve">
          <source>Entity header</source>
          <target state="translated">Заголовок сущности</target>
        </trans-unit>
        <trans-unit id="83a31c55ad20bb3cf7572f62e10bce1fa2085786" translate="yes" xml:space="preserve">
          <source>Entity tag uniquely representing the requested resource. They are a string of ASCII characters placed between double quotes, like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;. The method by which &lt;code&gt;ETag&lt;/code&gt; values are generated is not specified. Often, a hash of the content, a hash of the last modification timestamp, or just a revision number is used. For example, MDN uses a hexadecimal hash of the wiki article content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9024c46dde9f89740b2171b9280d89a9caba4424" translate="yes" xml:space="preserve">
          <source>Entity tags are used for comparing two or more entities from the same
   requested resource. HTTP/1.1 uses entity tags in the ETag (&lt;a href=&quot;#section-14.19&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;), If-Match (&lt;a href=&quot;#section-14.24&quot;&gt;section 14.24&lt;/a&gt;), If-None-Match (&lt;a href=&quot;#section-14.26&quot;&gt;section 14.26&lt;/a&gt;), and
   If-Range (&lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) header fields. The definition of how they
   are used and compared as cache validators is in &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;. An
   entity tag consists of an opaque quoted string, possibly prefixed by
   a weakness indicator.

      entity-tag = [ weak ] opaque-tag
      weak       = &quot;W/&quot;
      opaque-tag = quoted-string

   A &quot;strong entity tag&quot; MAY be shared by two entities of a resource
   only if they are equivalent by octet equality.

   A &quot;weak entity tag,&quot; indicated by the &quot;W/&quot; prefix, MAY be shared by
   two entities of a resource only if the entities are equivalent and
   could be substituted for each other with no significant change in
   semantics. A weak entity tag can only be used for weak comparison.

   An entity tag MUST be unique across all versions of all entities
   associated with a particular resource. A given entity tag value MAY
   be used for entities obtained by requests on different URIs. The use
   of the same entity tag value in conjunction with entities obtained by
   requests on different URIs does not imply the equivalence of those
   entities.</source>
          <target state="translated">Теги сущностей используются для сравнения двух или более сущностей из одного и того же запрошенного ресурса. HTTP / 1.1 использует теги сущностей в полях заголовка ETag ( &lt;a href=&quot;#section-14.19&quot;&gt;раздел &lt;/a&gt;&lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; ), If-Match ( &lt;a href=&quot;#section-14.24&quot;&gt;раздел 14.24&lt;/a&gt; ), If-None-Match ( &lt;a href=&quot;#section-14.26&quot;&gt;раздел 14.26&lt;/a&gt; ) и If-Range ( &lt;a href=&quot;#section-14.27&quot;&gt;раздел 14.27&lt;/a&gt; ). Определение того, как они используются и сравниваются в качестве валидаторов кеша, находится в &lt;a href=&quot;#section-13.3.3&quot;&gt;разделе 13.3.3.&lt;/a&gt;, Тег объекта состоит из непрозрачной строки в кавычках, возможно с префиксом индикатора слабости. entity-tag = [weak] opaque-tag weak = &quot;W /&quot; opaque-tag = quoted-string &quot;сильный тег объекта&quot; МОЖЕТ использоваться совместно двумя объектами ресурса, только если они эквивалентны по октетному равенству. &amp;laquo;Слабый тег объекта&amp;raquo;, обозначенный префиксом &amp;laquo;W /&amp;raquo;, МОЖЕТ совместно использоваться двумя объектами ресурса только в том случае, если объекты эквивалентны и могут быть заменены друг на друга без значительного изменения семантики. Тег слабого объекта можно использовать только для слабого сравнения. Тег объекта ДОЛЖЕН быть уникальным для всех версий всех объектов, связанных с конкретным ресурсом. Данное значение тега объекта МОЖЕТ использоваться для объектов, полученных запросами по разным URI.Использование одного и того же значения тега объекта в сочетании с объектами, полученными запросами по разным URI, не означает эквивалентности этих объектов.</target>
        </trans-unit>
        <trans-unit id="843ca4f28f9ce3aa7d78cfc1dd5d180a8db20d61" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;) and may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that the weak comparison algorithm should be used (This is useless with &lt;code&gt;If-None-Match&lt;/code&gt; as it only uses that algorithm).</source>
          <target state="translated">Теги объектов, однозначно представляющие запрошенные ресурсы. Они представляют собой строку символов ASCII, помещенных в двойные кавычки (например, &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; ), и могут иметь префикс &lt;code&gt;W/&lt;/code&gt; чтобы указать, что следует использовать алгоритм слабого сравнения (это бесполезно с &lt;code&gt;If-None-Match&lt;/code&gt; , поскольку он использует только этот алгоритм).</target>
        </trans-unit>
        <trans-unit id="cb4831ed8a07834c227f88278424a465acad3a5a" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;) and may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that the weak comparison algorithm should be used.</source>
          <target state="translated">Теги объектов, однозначно представляющие запрошенные ресурсы. Они представляют собой строку символов ASCII, помещенных в двойные кавычки (например, &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; ) и могут иметь префикс &lt;code&gt;W/&lt;/code&gt; чтобы указать, что следует использовать алгоритм слабого сравнения.</target>
        </trans-unit>
        <trans-unit id="f511403ebe3ad82f8791c9cc50f7078c288954a3" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;). The method by which &lt;code&gt;ETag&lt;/code&gt; values are generated is not specified. Oftentimes, a hash of the content, a hash of the last modification timestamp, or just a revision number is used. For example, MDN uses a hash of hexadecimal digits of the wiki content.</source>
          <target state="translated">Теги объектов, однозначно представляющие запрошенные ресурсы. Они представляют собой строку символов ASCII, заключенных в двойные кавычки (например, &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; ). Метод &lt;code&gt;ETag&lt;/code&gt; значений ETag не указан. Часто используется хеш содержимого, хеш отметки времени последней модификации или просто номер редакции. Например, MDN использует хеш из шестнадцатеричных цифр содержимого вики.</target>
        </trans-unit>
        <trans-unit id="3b0aa4ab650e7127575b944e7c4f357507fe1bf6" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;). They may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that they are &quot;weak&quot;, i.e. that they represent the resource semantically, but not byte-for-byte. However, in an &lt;code&gt;If-Match&lt;/code&gt; header, weak entity tags will never match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d3b3c670a7def682fbdd286ebd5fcf01de31d4" translate="yes" xml:space="preserve">
          <source>Entity-header fields define metainformation about the entity-body or,
   if no body is present, about the resource identified by the request.
   Some of this metainformation is OPTIONAL; some might be REQUIRED by
   portions of this specification.

       entity-header  = Allow                    ; &lt;a href=&quot;#section-14.7&quot;&gt;Section 14.7&lt;/a&gt;
                      | Content-Encoding         ; &lt;a href=&quot;#section-14.11&quot;&gt;Section 14.11&lt;/a&gt;
                      | Content-Language         ; &lt;a href=&quot;#section-14.12&quot;&gt;Section 14.12&lt;/a&gt;
                      | Content-Length           ; &lt;a href=&quot;#section-14.13&quot;&gt;Section 14.13&lt;/a&gt;
                      | Content-Location         ; &lt;a href=&quot;#section-14.14&quot;&gt;Section 14.14&lt;/a&gt;
                      | Content-MD5              ; &lt;a href=&quot;#section-14.15&quot;&gt;Section 14.15&lt;/a&gt;
                      | Content-Range            ; &lt;a href=&quot;#section-14.16&quot;&gt;Section 14.16&lt;/a&gt;
                      | Content-Type             ; &lt;a href=&quot;#section-14.17&quot;&gt;Section 14.17&lt;/a&gt;
                      | Expires                  ; &lt;a href=&quot;#section-14.21&quot;&gt;Section 14.21&lt;/a&gt;
                      | Last-Modified            ; &lt;a href=&quot;#section-14.29&quot;&gt;Section 14.29&lt;/a&gt;
                      | extension-header

       extension-header = message-header

   The extension-header mechanism allows additional entity-header fields
   to be defined without changing the protocol, but these fields cannot
   be assumed to be recognizable by the recipient. Unrecognized header
   fields SHOULD be ignored by the recipient and MUST be forwarded by
   transparent proxies.</source>
          <target state="translated">Поля заголовка объекта определяют метаинформацию о теле объекта или, если тело отсутствует, о ресурсе, идентифицированном запросом. Часть этой метаинформации НЕОБЯЗАТЕЛЬНА; некоторые могут быть ТРЕБОВАННЫМИ частями этой спецификации. entity-header = Разрешить; &lt;a href=&quot;#section-14.7&quot;&gt;Раздел 14.7&lt;/a&gt; | Content-Encoding; &lt;a href=&quot;#section-14.11&quot;&gt;Раздел 14.11&lt;/a&gt; | Content-Language; &lt;a href=&quot;#section-14.12&quot;&gt;Раздел 14.12&lt;/a&gt; | Content-Length; &lt;a href=&quot;#section-14.13&quot;&gt;Раздел 14.13&lt;/a&gt; | Контент-Местоположение; &lt;a href=&quot;#section-14.14&quot;&gt;Раздел 14.14&lt;/a&gt; | Content-MD5; &lt;a href=&quot;#section-14.15&quot;&gt;Раздел 14.15&lt;/a&gt; | Content-Range;&lt;a href=&quot;#section-14.16&quot;&gt;Раздел 14.16&lt;/a&gt; | Тип содержимого ; &lt;a href=&quot;#section-14.17&quot;&gt;Раздел 14.17&lt;/a&gt; | Истекает; &lt;a href=&quot;#section-14.21&quot;&gt;Раздел 14.21&lt;/a&gt; | Последнее изменение ; &lt;a href=&quot;#section-14.29&quot;&gt;Раздел 14.29&lt;/a&gt; | extension-header extension-header = message-header Механизм extension-header позволяет определять дополнительные поля заголовка объекта без изменения протокола, но нельзя предполагать, что эти поля распознаются получателем. Нераспознанные поля заголовка ДОЛЖНЫ игнорироваться получателем и ДОЛЖНЫ пересылаться прозрачными прокси.</target>
        </trans-unit>
        <trans-unit id="dc77c92755cf792527e0b3edc88e46b61f8087b7" translate="yes" xml:space="preserve">
          <source>Error responses: a &lt;a href=&quot;status/404&quot;&gt;&lt;code&gt;404&lt;/code&gt;&lt;/a&gt; (Not Found) result page.</source>
          <target state="translated">Ответы об ошибках: страница с результатами &lt;a href=&quot;status/404&quot;&gt; &lt;code&gt;404&lt;/code&gt; &lt;/a&gt; (не найдено).</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="ec4322ae064b7f4e2416acd40d4d58f17e5f8f12" translate="yes" xml:space="preserve">
          <source>Errors: CORSAllowOriginNotMatchingOrigin</source>
          <target state="translated">Ошибки:CORSAllowOriginNotMatchingOrigin .</target>
        </trans-unit>
        <trans-unit id="4087c6aa16b5abf1735ae9f8137528c87023309b" translate="yes" xml:space="preserve">
          <source>Errors: CORSDidNotSucceed</source>
          <target state="translated">Ошибки:CORSDidNotSucceed .</target>
        </trans-unit>
        <trans-unit id="1110c379846585f2593a508b8c164b5bd8320b76" translate="yes" xml:space="preserve">
          <source>Errors: CORSDisabled</source>
          <target state="translated">Ошибки:CORSD-совместимый</target>
        </trans-unit>
        <trans-unit id="dac4e756c8a76cbef1b33dca607cb3bc5b771e95" translate="yes" xml:space="preserve">
          <source>Errors: CORSExternalRedirectNotAllowed</source>
          <target state="translated">Ошибки:CORSExternalRedirectNotAllowed</target>
        </trans-unit>
        <trans-unit id="ce973b3c74a1ebbfbbd6d7dec66c6bb20ce1f763" translate="yes" xml:space="preserve">
          <source>Errors: CORSInvalidAllowHeader</source>
          <target state="translated">Ошибки:CORSInvalidAllowHeader</target>
        </trans-unit>
        <trans-unit id="a282fd28c28a400d13afa18351e51568b54396d2" translate="yes" xml:space="preserve">
          <source>Errors: CORSInvalidAllowMethod</source>
          <target state="translated">Ошибки:CORSInvalidAllowMethod</target>
        </trans-unit>
        <trans-unit id="b8d43e50964c1cfd887f4afc94b47bcdd5d69570" translate="yes" xml:space="preserve">
          <source>Errors: CORSMIssingAllowCredentials</source>
          <target state="translated">Ошибки:CORSMIssingAllowCredentials .</target>
        </trans-unit>
        <trans-unit id="710e0ccb5287b4319b0c5fdee5593e1d13fa6e37" translate="yes" xml:space="preserve">
          <source>Errors: CORSMethodNotFound</source>
          <target state="translated">Ошибки:CORSMethodNotFound</target>
        </trans-unit>
        <trans-unit id="a307f601e16873b1a5a1472fa793e47e1b28b743" translate="yes" xml:space="preserve">
          <source>Errors: CORSMissingAllowHeaderFromPreflight</source>
          <target state="translated">Ошибки:CORSMissingAllowHeaderFromPreight .</target>
        </trans-unit>
        <trans-unit id="3d47284892dc16fb82eea87c1c413d4b5c528c8b" translate="yes" xml:space="preserve">
          <source>Errors: CORSMissingAllowOrigin</source>
          <target state="translated">Ошибки:CORSMissingAllowOrigin</target>
        </trans-unit>
        <trans-unit id="59e949130b0899712b1a17c6d46a1f58dc1ad38e" translate="yes" xml:space="preserve">
          <source>Errors: CORSMultipleAllowOriginNotAllowed</source>
          <target state="translated">Ошибки:CORSMultipleAllowOriginNotAllowed .</target>
        </trans-unit>
        <trans-unit id="fe11294cab619d12140db3bf906980249f0d9b51" translate="yes" xml:space="preserve">
          <source>Errors: CORSNotSupportingCredentials</source>
          <target state="translated">Ошибки:CORSNotSupportingCredentials .</target>
        </trans-unit>
        <trans-unit id="9d941c8ccc9202a89b0022d5ed88c86d19e065a4" translate="yes" xml:space="preserve">
          <source>Errors: CORSOriginHeaderNotAdded</source>
          <target state="translated">Ошибки:CORSOriginHeaderNotAdded</target>
        </trans-unit>
        <trans-unit id="4b2583c03a065a201e0c7af7eb778cf128afcc99" translate="yes" xml:space="preserve">
          <source>Errors: CORSPreflightDidNotSucceed</source>
          <target state="translated">Ошибки:CORSPreflightDidNotSucceed</target>
        </trans-unit>
        <trans-unit id="a43f3bb8e46c7f4d0e112510dc95499734debf0d" translate="yes" xml:space="preserve">
          <source>Errors: CORSRequestNotHttp</source>
          <target state="translated">Ошибки:CORSRequestNotHttp .</target>
        </trans-unit>
        <trans-unit id="76e3d52572cfb5f282f24af08ceb3c93515e0c23" translate="yes" xml:space="preserve">
          <source>Establishing a connection</source>
          <target state="translated">Установление связи</target>
        </trans-unit>
        <trans-unit id="d9c2c223b0f7d2f2a1d0a4ab149a50dae5eaf1dd" translate="yes" xml:space="preserve">
          <source>Evaluation (RFC 7232)</source>
          <target state="translated">Оценка (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="016549bb81a6b73cbdac91b27317bed690bbaf39" translate="yes" xml:space="preserve">
          <source>Even if both the client and the server supports the same compression algorithms, the server may choose not to compress the body of a response, if the identity value is also acceptable. Two common cases lead to this:</source>
          <target state="translated">Даже если и клиент,и сервер поддерживают одинаковые алгоритмы сжатия,сервер может решить не сжимать тело ответа,если идентификационное значение также приемлемо.Два распространенных случая приводят к этому:</target>
        </trans-unit>
        <trans-unit id="39e1dc57ed79bde6d7d9296899ff80637127740c" translate="yes" xml:space="preserve">
          <source>Even if identity and location are both described using a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;, they are two different concepts and it is useful sometimes to distinguished between them. This article introduces the &lt;a href=&quot;headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Даже если идентичность и местоположение описываются с помощью &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL-адреса&lt;/a&gt; , это две разные концепции, и иногда полезно различать их. В этой статье представлен заголовок &lt;a href=&quot;headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d11701203cf55bb28a83c78028e1b759782a7ab9" translate="yes" xml:space="preserve">
          <source>Even if server-driven content negotiation is the most common way to agree on a specific representation of a resource, it has several drawbacks:</source>
          <target state="translated">Даже если серверные переговоры по содержанию являются наиболее распространенным способом согласования конкретного представления ресурса,у них есть несколько недостатков:</target>
        </trans-unit>
        <trans-unit id="d8b58599d2ecd8aca415a34fd71768d962e8e310" translate="yes" xml:space="preserve">
          <source>Even if the specification requires the method (and the body) not to be altered when the redirection is performed, not all user-agents align with it - you can still find this type of bugged software out there. It is therefore recommended to use the &lt;code&gt;301&lt;/code&gt; code only as a response for &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods and to use the &lt;a href=&quot;308&quot;&gt;&lt;code&gt;308 Permanent Redirect&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; methods instead, as the method change is explicitly prohibited with this status.</source>
          <target state="translated">Даже если спецификация требует, чтобы метод (и тело) не изменялся при выполнении перенаправления, не все пользовательские агенты согласуются с ним - вы все равно можете найти этот тип программного обеспечения с ошибками. Поэтому рекомендуется использовать код &lt;code&gt;301&lt;/code&gt; только в качестве ответа для методов &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; и вместо этого использовать &lt;a href=&quot;308&quot;&gt; &lt;code&gt;308 Permanent Redirect&lt;/code&gt; &lt;/a&gt; для методов &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; , поскольку изменение метода явно запрещено с этим статусом.</target>
        </trans-unit>
        <trans-unit id="60e9e00953556ca6c857baf9a61ba9002b374a14" translate="yes" xml:space="preserve">
          <source>Even if the specification requires the method (and the body) not to be altered when the redirection is performed, not all user-agents conform here - you can still find this type of bugged software out there. It is therefore recommended to set the &lt;code&gt;302&lt;/code&gt; code only as a response for &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods and to use &lt;a href=&quot;307&quot;&gt;&lt;code&gt;307 Temporary Redirect&lt;/code&gt;&lt;/a&gt; instead, as the method change is explicitly prohibited in that case.</source>
          <target state="translated">Даже если спецификация требует, чтобы метод (и тело) не изменялся при выполнении перенаправления, не все пользовательские агенты соответствуют здесь - вы все равно можете найти этот тип программного обеспечения с ошибками. Поэтому рекомендуется устанавливать код &lt;code&gt;302&lt;/code&gt; только в качестве ответа для методов &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; и вместо этого использовать &lt;a href=&quot;307&quot;&gt; &lt;code&gt;307 Temporary Redirect&lt;/code&gt; &lt;/a&gt; , поскольку в этом случае изменение метода явно запрещено.</target>
        </trans-unit>
        <trans-unit id="41dab3c71327a38803685ef6e3cebc869962fcfb" translate="yes" xml:space="preserve">
          <source>Even if this method works, it adds an extra response/request exchange when the document has been changed. This impairs performance, and HTTP has a specific header to avoid this scenario: &lt;a href=&quot;headers/if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Даже если этот метод работает, он добавляет дополнительный обмен ответом / запросом при изменении документа. Это снижает производительность, и HTTP имеет специальный заголовок, чтобы избежать этого сценария: &lt;a href=&quot;headers/if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b284eb5d595f914af47d2a8c3a9cef82f913efb4" translate="yes" xml:space="preserve">
          <source>Even if this technique also works for internal links, you should try to avoid having internal redirects. A redirect has a significant performance cost (as an extra HTTP request is done) and if you can avoid it by correcting internal links, you should fix these links.</source>
          <target state="translated">Даже если эта техника работает и для внутренних ссылок,следует стараться избегать внутренних переадресаций.Редирект имеет значительные затраты на производительность (как дополнительный HTTP-запрос),и если вы можете избежать этого,исправив внутренние ссылки,вы должны исправить эти ссылки.</target>
        </trans-unit>
        <trans-unit id="58665e4007bca0cad4410abfb11d1a4668903330" translate="yes" xml:space="preserve">
          <source>Even with more complexity, introduced in HTTP/2 by encapsulating HTTP messages into frames, HTTP is generally designed to be simple and human readable. HTTP messages can be read and understood by humans, providing easier developer testing, and reduced complexity for new-comers.</source>
          <target state="translated">Даже с большей сложностью,введенной в HTTP/2 путем инкапсуляции HTTP-сообщений во фреймы,HTTP,как правило,спроектирован так,чтобы быть простым и удобочитаемым человеком.Сообщения HTTP могут быть прочитаны и поняты человеком,что облегчает тестирование разработчиков,а также снижает сложность для новичков.</target>
        </trans-unit>
        <trans-unit id="8b42fb3b1821d636c208455d3a9009fab5579ed3" translate="yes" xml:space="preserve">
          <source>Evercookie by Samy Kamkar</source>
          <target state="translated">Эверкуки от Сами Камкара</target>
        </trans-unit>
        <trans-unit id="f7b5a8683f9a1cf2ee2d67f073ba064ecc576032" translate="yes" xml:space="preserve">
          <source>Everyone, really.</source>
          <target state="translated">Все,правда.</target>
        </trans-unit>
        <trans-unit id="f49a3e37d7614909e74abaad869cfa8d5952bf40" translate="yes" xml:space="preserve">
          <source>Evolution of HTTP</source>
          <target state="translated">Эволюция HTTP</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">Пример 1</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">Пример 2</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="translated">Пример 3</target>
        </trans-unit>
        <trans-unit id="f4cd3ef194759e6a1bf205a2958b720d8edb10da" translate="yes" xml:space="preserve">
          <source>Example 4</source>
          <target state="translated">Пример 4</target>
        </trans-unit>
        <trans-unit id="dcb2a7f833e9a3ee29881cf3f00069ceeab20571" translate="yes" xml:space="preserve">
          <source>Example 5</source>
          <target state="translated">Пример 5</target>
        </trans-unit>
        <trans-unit id="69126e599801a8577cf34e537a3e5b119797d966" translate="yes" xml:space="preserve">
          <source>Example 6</source>
          <target state="translated">Пример 6</target>
        </trans-unit>
        <trans-unit id="fad75d0ce8eb620d0eb8c90ad36bb1d3ba100630" translate="yes" xml:space="preserve">
          <source>Example HPKP Header</source>
          <target state="translated">Пример заголовка HPKP</target>
        </trans-unit>
        <trans-unit id="6f262b0de6886f68de9a7f3020d9645e1a46ad07" translate="yes" xml:space="preserve">
          <source>Example of typical subtypes</source>
          <target state="translated">Пример типичных подтипов</target>
        </trans-unit>
        <trans-unit id="987339acda1c7e11edad694279b3ef232cafa98c" translate="yes" xml:space="preserve">
          <source>Example preflight request</source>
          <target state="translated">Пример запроса на предполетный рейс</target>
        </trans-unit>
        <trans-unit id="1937f18faac9b560d6b0ad0c27d8e5021d3c2ec8" translate="yes" xml:space="preserve">
          <source>Example requests</source>
          <target state="translated">Примеры запросов</target>
        </trans-unit>
        <trans-unit id="101e766cdf474de8672fa38603435f2c2f88941b" translate="yes" xml:space="preserve">
          <source>Example response</source>
          <target state="translated">Пример ответа</target>
        </trans-unit>
        <trans-unit id="9e9047fddfc8910797ad5dcc2be127acbfe08b7f" translate="yes" xml:space="preserve">
          <source>Example responses</source>
          <target state="translated">Примеры ответов</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="1391352a916b067bd98f31a68d100a8e123a5170" translate="yes" xml:space="preserve">
          <source>Example: Disable unsafe inline/eval, only allow loading of resources (images, fonts, scripts, etc.) over https:</source>
          <target state="translated">Пример:Отключить небезопасные inline/eval,разрешить загрузку только ресурсов (изображений,шрифтов,скриптов и т.д.)по https:</target>
        </trans-unit>
        <trans-unit id="c7fd2423984ee2e46f44f28ab3c25a81d90c3fd1" translate="yes" xml:space="preserve">
          <source>Example: Do not implement the above policy yet; instead just report violations that would have occurred:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179aebe7be456d632b5d789d99331eede78b73e3" translate="yes" xml:space="preserve">
          <source>Example: Don't implement the above policy yet; instead just report violations that would have occurred:</source>
          <target state="translated">Пример:Не осуществляйте пока вышеуказанную политику;вместо этого просто сообщите о нарушениях,которые могли бы произойти:</target>
        </trans-unit>
        <trans-unit id="6a1a9b351cb6e527d7405905cebedc49fbc528bb" translate="yes" xml:space="preserve">
          <source>Example: Pre-existing site that uses too much inline code to fix but wants to ensure resources are loaded only over HTTPS and to disable plugins:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e17700dcd76dcab4611e46cba8a84a5260c2c790" translate="yes" xml:space="preserve">
          <source>Example: Pre-existing site that uses too much inline code to fix but wants to ensure resources are loaded only over https and disable plugins:</source>
          <target state="translated">Пример:Предварительно существующий сайт,который использует слишком много встроенного кода для исправления,но хочет обеспечить загрузку ресурсов только через https и отключить плагины:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="cd077131fc10d919fcb4af0bc52b5d5dc3bff60d" translate="yes" xml:space="preserve">
          <source>Examples of Access Control in Action</source>
          <target state="translated">Примеры контроля доступа в действии</target>
        </trans-unit>
        <trans-unit id="42b05d16ad1706c69b98dcd1d0beab7d996df8be" translate="yes" xml:space="preserve">
          <source>Examples of access control scenarios</source>
          <target state="translated">Примеры сценариев контроля доступа</target>
        </trans-unit>
        <trans-unit id="8b6959ab8197d951dfd31c9bfb60d608f8853eea" translate="yes" xml:space="preserve">
          <source>Examples of this usage can be &lt;a href=&quot;#Preflighted_requests&quot;&gt;found above.&lt;/a&gt;</source>
          <target state="translated">Примеры такого использования можно &lt;a href=&quot;#Preflighted_requests&quot;&gt;найти выше.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65a7ed9127c8003c7810083e7bbc1569d8b66810" translate="yes" xml:space="preserve">
          <source>Examples of this usage can be &lt;a href=&quot;#Preflighted_requests&quot;&gt;found above&lt;/a&gt;.</source>
          <target state="translated">Примеры такого использования можно &lt;a href=&quot;#Preflighted_requests&quot;&gt;найти выше&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47abb8e5ca6a2e13e7aa85756a29b3a05a3d8d7b" translate="yes" xml:space="preserve">
          <source>Examples of what you can do with Feature Policy:</source>
          <target state="translated">Примеры того,что можно сделать с помощью Feature Policy:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="57e9b7197782a4e7584bbc9820ab7355aa88a3d3" translate="yes" xml:space="preserve">
          <source>Examples: Common use cases</source>
          <target state="translated">Примеры:Случаи общего пользования</target>
        </trans-unit>
        <trans-unit id="997886ce9b39820b9d7574fbb168082bb6c4cfb9" translate="yes" xml:space="preserve">
          <source>Except for the standard hop-by-hop headers (&lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt;), any hop-by-hop headers used by the message must be listed in the &lt;code&gt;Connection&lt;/code&gt; header, so that the first proxy knows it has to consume them and not forward them further. Standard hop-by-hop headers can be listed too (it is often the case of &lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, but this is not mandatory).</source>
          <target state="translated">За исключением стандартных пошаговых заголовков ( &lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; ), должны быть перечислены все пошаговые заголовки, используемые сообщением. в заголовке &lt;code&gt;Connection&lt;/code&gt; , чтобы первый прокси знал, что он должен их использовать, а не пересылать дальше. Также могут быть перечислены стандартные пошаговые заголовки (это часто бывает с &lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt; , но это не обязательно).</target>
        </trans-unit>
        <trans-unit id="7233a11fc2426584ed01a173a4d930d34926020b" translate="yes" xml:space="preserve">
          <source>Except when excluded below, a recipient cache or origin server MUST
   evaluate received request preconditions after it has successfully
   performed its normal request checks and just before it would perform
   the action associated with the request method.  A server MUST ignore
   all received preconditions if its response to the same request
   without those conditions would have been a status code other than a
   2xx (Successful) or 412 (Precondition Failed).  In other words,
   redirects and failures take precedence over the evaluation of
   preconditions in conditional requests. 

   A server that is not the origin server for the target resource and
   cannot act as a cache for requests on the target resource MUST NOT
   evaluate the conditional request header fields defined by this
   specification, and it MUST forward them if the request is forwarded,
   since the generating client intends that they be evaluated by a
   server that can provide a current representation.  Likewise, a server
   MUST ignore the conditional request header fields defined by this
   specification when received with a request method that does not
   involve the selection or modification of a selected representation,
   such as CONNECT, OPTIONS, or TRACE.

   Conditional request header fields that are defined by extensions to
   HTTP might place conditions on all recipients, on the state of the
   target resource in general, or on a group of resources.  For
   instance, the &quot;If&quot; header field in WebDAV can make a request
   conditional on various aspects of multiple resources, such as locks,
   if the recipient understands and implements that field (&lt;a href=&quot;https://tools.ietf.org/html/rfc4918#section-10.4&quot;&gt;[RFC4918],
   Section&amp;nbsp;10.4&lt;/a&gt;).

   Although conditional request header fields are defined as being
   usable with the HEAD method (to keep HEAD's semantics consistent with
   those of GET), there is no point in sending a conditional HEAD
   because a successful response is around the same size as a 304 (Not
   Modified) response and more useful than a 412 (Precondition Failed)
   response.</source>
          <target state="translated">За исключением случаев, исключенных ниже, кэш получателя или исходный сервер ДОЛЖЕН оценивать предварительные условия полученного запроса после того, как он успешно выполнил свои обычные проверки запроса и непосредственно перед выполнением действия, связанного с методом запроса. Сервер ДОЛЖЕН игнорировать все полученные предварительные условия, если его ответ на тот же запрос без этих условий был бы кодом состояния, отличным от 2xx (успешно) или 412 (предварительное условие не выполнено). Другими словами, перенаправления и сбои имеют приоритет над оценкой предварительных условий в условных запросах. Сервер, который не является исходным сервером для целевого ресурса и не может действовать как кеш для запросов к целевому ресурсу, НЕ ДОЛЖЕН оценивать поля заголовка условного запроса, определенные в этой спецификации,и он ДОЛЖЕН пересылать их, если запрос пересылается, поскольку генерирующий клиент предполагает, что они будут оценены сервером, который может предоставить текущее представление. Точно так же сервер ДОЛЖЕН игнорировать поля заголовка условного запроса, определенные этой спецификацией, когда он получен с помощью метода запроса, который не включает выбор или изменение выбранного представления, например CONNECT, OPTIONS или TRACE. Поля заголовка условного запроса, определяемые расширениями HTTP, могут накладывать условия на всех получателей, на состояние целевого ресурса в целом или на группу ресурсов. Например, поле заголовка &amp;laquo;Если&amp;raquo; в WebDAV может обусловливать запрос различных аспектов нескольких ресурсов, таких как блокировки, если получатель понимает и реализует это поле (если получатель понимает и реализует это поле (&lt;a href=&quot;https://tools.ietf.org/html/rfc4918#section-10.4&quot;&gt;[RFC4918], раздел 10.4&lt;/a&gt; ). Хотя поля заголовка условного запроса определены как пригодные для использования с методом HEAD (чтобы семантика HEAD соответствовала семантике GET), нет смысла отправлять условный заголовок HEAD, потому что успешный ответ имеет примерно тот же размер, что и 304 (не изменено ) и более полезен, чем ответ 412 (ошибка предварительного условия).</target>
        </trans-unit>
        <trans-unit id="25c9949f0e8e682737f53bb3d3d209c13c6e1d5b" translate="yes" xml:space="preserve">
          <source>Executable script is only allowed from userscripts.example.com.</source>
          <target state="translated">Исполняемый скрипт разрешен только с userscripts.example.com.</target>
        </trans-unit>
        <trans-unit id="2d47895b1210b1ebd4fa933059d36aed26cda284" translate="yes" xml:space="preserve">
          <source>Existing HTTP clients and user agents typically retain authentication
   information indefinitely.  HTTP does not provide a mechanism for the
   origin server to direct clients to discard these cached credentials,
   since the protocol has no awareness of how credentials are obtained 

   or managed by the user agent.  The mechanisms for expiring or
   revoking credentials can be specified as part of an authentication
   scheme definition.

   Circumstances under which credential caching can interfere with the
   application's security model include but are not limited to:

   o  Clients that have been idle for an extended period, following
      which the server might wish to cause the client to re-prompt the
      user for credentials.

   o  Applications that include a session termination indication (such
      as a &quot;logout&quot; or &quot;commit&quot; button on a page) after which the server
      side of the application &quot;knows&quot; that there is no further reason
      for the client to retain the credentials.

   User agents that cache credentials are encouraged to provide a
   readily accessible mechanism for discarding cached credentials under
   user control.</source>
          <target state="translated">Существующие HTTP-клиенты и пользовательские агенты,как правило,хранят информацию об аутентификации бессрочно.HTTP не предоставляет механизма,позволяющего серверу-источнику направлять клиентов на отбрасывание этих кэшированных учетных данных,поскольку протокол не знает,как учетные данные получаются или управляются агентом пользователя.Механизмы истечения срока действия или отзыва учетных данных могут быть определены как часть определения схемы аутентификации.Обстоятельства,при которых кэширование учетных данных может вмешиваться в модель безопасности приложения,включают,но не ограничиваются следующими обстоятельствами:o Клиенты,которые не работали в течение длительного периода времени,после чего сервер может заставить клиента повторно запросить у пользователя учетные данные.o Приложения,которые включают указание о завершении сеанса (такие как кнопка &quot;logout&quot; или &quot;commit&quot; на странице),после чего серверная сторона приложения &quot;знает&quot;,что у клиента нет никаких дополнительных причин для сохранения учетных данных.Пользовательским агентам,которые кэшируют учетные данные,рекомендуется предоставить легко доступный механизм для отбрасывания кэшированных учетных данных под контролем пользователя.</target>
        </trans-unit>
        <trans-unit id="6ccac52b5d4274914636579bf1636b1d5fa966cc" translate="yes" xml:space="preserve">
          <source>Existing HTTP clients and user agents typically retain authentication
   information indefinitely. HTTP/1.1. does not provide a method for a
   server to direct clients to discard these cached credentials. This is
   a significant defect that requires further extensions to HTTP.
   Circumstances under which credential caching can interfere with the
   application's security model include but are not limited to:

      - Clients which have been idle for an extended period following
        which the server might wish to cause the client to reprompt the
        user for credentials.

      - Applications which include a session termination indication
        (such as a `logout' or `commit' button on a page) after which
        the server side of the application `knows' that there is no
        further reason for the client to retain the credentials.

   This is currently under separate study. There are a number of work-
   arounds to parts of this problem, and we encourage the use of
   password protection in screen savers, idle time-outs, and other
   methods which mitigate the security problems inherent in this
   problem. In particular, user agents which cache credentials are
   encouraged to provide a readily accessible mechanism for discarding
   cached credentials under user control.</source>
          <target state="translated">Существующие HTTP-клиенты и пользовательские агенты,как правило,хранят информацию об аутентификации бессрочно.HTTP/1.1.не предоставляет серверу способ направить клиентов на отбрасывание этих кэшированных учетных данных.Это значительный дефект,требующий дополнительных расширений HTTP.Обстоятельства,при которых кэширование учетных данных может повлиять на модель безопасности приложения,включают в себя,но не ограничиваются ими:-Клиенты,которые простаивали в течение длительного периода времени,после чего сервер может захотеть заставить клиента выдать пользователю повторный запрос на учетные данные.-Приложения,которые включают указание о завершении сеанса (например,кнопка `выхода'' или `комментарий' на странице),после чего серверная сторона приложения `знает`,что у клиента нет больше причин для сохранения учетных данных.В настоящее время это рассматривается отдельно.Существует ряд способов решения этой проблемы,и мы рекомендуем использовать защиту паролем в заставках,тайм-аутах и других методах,которые смягчают проблемы безопасности,связанные с этой проблемой.В частности,пользовательские агенты,которые кэшируют учетные данные,поощряются для обеспечения легкодоступного механизма отбрасывания кэшированных учетных данных под контролем пользователя.</target>
        </trans-unit>
        <trans-unit id="a57a461722611e40b9d47ce41e5966ee9c0e2bfc" translate="yes" xml:space="preserve">
          <source>Expanding the reach of your site</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a76f4ceddd2c24dfba52fcd6415b4a5d7627655" translate="yes" xml:space="preserve">
          <source>Expanding the reach of your site. A common case is when your site resides under the &lt;code&gt;www.example.com&lt;/code&gt; domain and accessing your pages from &lt;code&gt;example.com&lt;/code&gt; should be possible, too. Redirections for &lt;code&gt;example.com&lt;/code&gt; pages to &lt;code&gt;www.example.com&lt;/code&gt; are set up in this case. You might also provide commonly used synonym names or frequent typos of your domain names.</source>
          <target state="translated">Расширение охвата вашего сайта. Часто бывает, что ваш сайт находится в домене &lt;code&gt;www.example.com&lt;/code&gt; , и доступ к вашим страницам с &lt;code&gt;example.com&lt;/code&gt; также должен быть возможен. В этом случае настраиваются перенаправления для страниц &lt;code&gt;example.com&lt;/code&gt; на &lt;code&gt;www.example.com&lt;/code&gt; . Вы также можете указать часто используемые синонимы или частые опечатки в ваших доменных именах.</target>
        </trans-unit>
        <trans-unit id="58fc1be971a32518b08bb4967f47c3e29fc379b9" translate="yes" xml:space="preserve">
          <source>Expect</source>
          <target state="translated">Expect</target>
        </trans-unit>
        <trans-unit id="994027919b14e63b028676f8e18f24f8c3412b5f" translate="yes" xml:space="preserve">
          <source>Expect (RFC 2616)</source>
          <target state="translated">Ожидайте (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="53f1bb33df8415879d9607269fadc4b08f7884fc" translate="yes" xml:space="preserve">
          <source>Expect (RFC 7231)</source>
          <target state="translated">Ожидайте (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="dac7eb9f8e739ef71916b8aa6eabe504d21db9ae" translate="yes" xml:space="preserve">
          <source>Expect-CT</source>
          <target state="translated">Expect-CT</target>
        </trans-unit>
        <trans-unit id="1782a86fff7281c9294c0d3eefa4ab6846695cc2" translate="yes" xml:space="preserve">
          <source>Expect-CT Extension for HTTP</source>
          <target state="translated">Расширение Expect-CT для HTTP</target>
        </trans-unit>
        <trans-unit id="79322ef6edc1926ecbca88fd7e24b3ff46c3ac45" translate="yes" xml:space="preserve">
          <source>Experimental spec</source>
          <target state="translated">Экспериментальная спецификация</target>
        </trans-unit>
        <trans-unit id="549fb9eb005687c11bca9c3462372257a7683df5" translate="yes" xml:space="preserve">
          <source>Experiments are in progress to design a better transport protocol more suited to HTTP. For example, Google is experimenting with &lt;a href=&quot;https://en.wikipedia.org/wiki/QUIC&quot;&gt;QUIC&lt;/a&gt; which builds on UDP to provide a more reliable and efficient transport protocol.</source>
          <target state="translated">В настоящее время ведутся эксперименты по разработке лучшего транспортного протокола, более подходящего для HTTP. Например, Google экспериментирует с &lt;a href=&quot;https://en.wikipedia.org/wiki/QUIC&quot;&gt;QUIC,&lt;/a&gt; который основан на UDP, чтобы обеспечить более надежный и эффективный транспортный протокол.</target>
        </trans-unit>
        <trans-unit id="1c82119c31678afc6233c719096414eef0fb22b6" translate="yes" xml:space="preserve">
          <source>Expiration</source>
          <target state="translated">Expiration</target>
        </trans-unit>
        <trans-unit id="a99be3da0c9da2f3c64500b5ef8a8e48f503d127" translate="yes" xml:space="preserve">
          <source>Expires</source>
          <target state="translated">Expires</target>
        </trans-unit>
        <trans-unit id="cc75acb2b0ea3b677a15b0b6b818f64332802b2f" translate="yes" xml:space="preserve">
          <source>Expires (RFC 2616)</source>
          <target state="translated">Истекает (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="668c321a385a7ec5effd27dc4959016e1b54db8c" translate="yes" xml:space="preserve">
          <source>Expires (RFC 7234)</source>
          <target state="translated">Истекает (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="798d2fe08024167fc3592a3e1fdd8f0482db3150" translate="yes" xml:space="preserve">
          <source>Expires=&amp;lt;date&amp;gt; Optional</source>
          <target state="translated">Expires = &amp;lt;date&amp;gt; Необязательно</target>
        </trans-unit>
        <trans-unit id="440f936591556c4ab22d4ca93b07905600bf80fc" translate="yes" xml:space="preserve">
          <source>Explains how a client and a server can negotiate a specific HTTP version and eventually upgrade the protocol version used.</source>
          <target state="translated">Объясняет,как клиент и сервер могут договариваться о конкретной HTTP-версии и,в конечном счете,обновлять используемую версию протокола.</target>
        </trans-unit>
        <trans-unit id="4c04fa2d870e27906bb18e89eabbb66f7bf88805" translate="yes" xml:space="preserve">
          <source>Expresses the user's tracking preference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a639e6f336caa1c98ebcd19c35befb40a19c9aca" translate="yes" xml:space="preserve">
          <source>Extending a database through an append operation.</source>
          <target state="translated">Расширение базы данных с помощью операции приложения.</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="a5be9d96e47f86f30faca0b0c0d8cd92b6b591df" translate="yes" xml:space="preserve">
          <source>Extension &lt;code&gt;Cache-Control&lt;/code&gt; directives</source>
          <target state="translated">Директивы Extension &lt;code&gt;Cache-Control&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fef92b354ef2777bc846bf834005b52b7dd4a00e" translate="yes" xml:space="preserve">
          <source>Extension &lt;code&gt;Cache-Control&lt;/code&gt; directives are not part of the core HTTP caching standards document. Be sure to check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; for their support.</source>
          <target state="translated">Директивы Extension &lt;code&gt;Cache-Control&lt;/code&gt; не являются частью основного документа стандартов кеширования HTTP. Обязательно проверьте &lt;a href=&quot;#Browser_compatibility&quot;&gt;таблицу совместимости&lt;/a&gt; для их поддержки.</target>
        </trans-unit>
        <trans-unit id="790215898ba9547c6ca3b5fc75be3806f3e82b33" translate="yes" xml:space="preserve">
          <source>Extension &lt;code&gt;Cache-Control&lt;/code&gt; directives are not part of the core HTTP caching standards document. Check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; for their support; user-agents that don't recognize them should ignore them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b9d10d572cffd131c6e10d79fd13870c1b14e9" translate="yes" xml:space="preserve">
          <source>Extension Cache-Control directives</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9618205d36acb2ec9a802339b387cf754ed53de" translate="yes" xml:space="preserve">
          <source>External CSS stylesheets use the default policy (&lt;code&gt;no-referrer-when-downgrade&lt;/code&gt;) unless it's overwritten via an HTTP header that is set for a CSS stylesheet specifically.</source>
          <target state="translated">Внешние таблицы стилей CSS используют политику по умолчанию ( &lt;code&gt;no-referrer-when-downgrade&lt;/code&gt; ), если она не перезаписывается через HTTP-заголовок, специально установленный для таблицы стилей CSS.</target>
        </trans-unit>
        <trans-unit id="1f757e53076199141ccd603fa5607cc746399b36" translate="yes" xml:space="preserve">
          <source>External CSS stylesheets use the default policy (&lt;code&gt;no-referrer-when-downgrade&lt;/code&gt;), unless it's overwritten via a &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header on the CSS stylesheet&amp;rsquo;s response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b4519004830e628fefbfc612f64b245ab37406" translate="yes" xml:space="preserve">
          <source>Extracting the Base64 encoded public key information</source>
          <target state="translated">Извлечение информации открытого ключа в кодировке Base64</target>
        </trans-unit>
        <trans-unit id="82ca99fbea5a5ea4d775520c3099a29adbd2bbf4" translate="yes" xml:space="preserve">
          <source>F.1.  Changes for Both Client and Server Implementations</source>
          <target state="translated">F.1.Изменения для клиентской и серверной имплементации</target>
        </trans-unit>
        <trans-unit id="e3444e81a7c395eacc8d894f9505a6b6ec9ed898" translate="yes" xml:space="preserve">
          <source>F.2.  Changes for Server Implementations</source>
          <target state="translated">F.2 Изменения для серверных имплементаций</target>
        </trans-unit>
        <trans-unit id="8d6a58de84dd929ed244644a2cc93d7d20768fb2" translate="yes" xml:space="preserve">
          <source>F.3.  Other Changes</source>
          <target state="translated">F.3.Другие изменения</target>
        </trans-unit>
        <trans-unit id="22da6d41863afa4c87a7a2a96539883a5b235c05" translate="yes" xml:space="preserve">
          <source>FTP is still acceptable at the top level (such as typed directly into the browser's URL bar, or the target of a link), although some browsers may delegate loading FTP content to another application.</source>
          <target state="translated">FTP все еще приемлем на верхнем уровне (например,вводится непосредственно в URL-адрес браузера или в адресную строку ссылки),хотя некоторые браузеры могут делегировать загрузку FTP-контента другому приложению.</target>
        </trans-unit>
        <trans-unit id="92fe61c3f61162d432bcc18c5c3c2721f89c4867" translate="yes" xml:space="preserve">
          <source>Faced with this error, browsers usually either abort the operation (for example, a download will be considered as non-resumable) or ask for the whole document again.</source>
          <target state="translated">Столкнувшись с этой ошибкой,браузеры обычно либо прерывают операцию (например,загрузка будет считаться невозвратной),либо снова запрашивают весь документ.</target>
        </trans-unit>
        <trans-unit id="b4a100ebc4c1820c605bd96d9dd279ff888640e2" translate="yes" xml:space="preserve">
          <source>Fallback</source>
          <target state="translated">Fallback</target>
        </trans-unit>
        <trans-unit id="eba72e67a897b4f1538c1c559bf91bf79d26f8df" translate="yes" xml:space="preserve">
          <source>FastCorp Inc. wants to disable &lt;code&gt;fullscreen&lt;/code&gt; for all cross-origin child frames, except for a specific &amp;lt;iframe&amp;gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">FastCorp Inc. хочет отключить &lt;code&gt;fullscreen&lt;/code&gt; режим для всех дочерних фреймов с перекрестным происхождением, за исключением конкретного &amp;lt;iframe&amp;gt;. Это можно сделать, доставив следующий заголовок HTTP-ответа для определения политики функций:</target>
        </trans-unit>
        <trans-unit id="30c4b13be3aa4b1468bedb0d443187e381399c80" translate="yes" xml:space="preserve">
          <source>FastCorp Inc. wants to disable &lt;code&gt;geolocation&lt;/code&gt; for all cross-origin child frames, except for a specific &amp;lt;iframe&amp;gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">FastCorp Inc. хочет отключить &lt;code&gt;geolocation&lt;/code&gt; для всех дочерних фреймов с перекрестным источником, за исключением определенного &amp;lt;iframe&amp;gt;. Это можно сделать, доставив следующий заголовок HTTP-ответа для определения политики функций:</target>
        </trans-unit>
        <trans-unit id="2b02ecda0275dbc6a16322d0aa2715bb1b0c7f16" translate="yes" xml:space="preserve">
          <source>Feature Policy</source>
          <target state="translated">Особая политика</target>
        </trans-unit>
        <trans-unit id="116ce4ea97fc76a7402a5b9f210f36fadfbb4c2b" translate="yes" xml:space="preserve">
          <source>Feature Policy allows web developers to selectively enable, disable, and modify the behavior of certain features and APIs in the browser. It is similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;Content Security Policy&lt;/a&gt; but controls features instead of security behavior.</source>
          <target state="translated">Политика функций позволяет веб-разработчикам выборочно включать, отключать и изменять поведение определенных функций и API в браузере. Она похожа на &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;политику безопасности контента,&lt;/a&gt; но контролирует функции, а не поведение безопасности.</target>
        </trans-unit>
        <trans-unit id="c53bb4cebead9ce42d5d5eff5bdc667fd91758b5" translate="yes" xml:space="preserve">
          <source>Feature Policy allows you to control which origins can use which features, both in the top-level page and in embedded frames. Essentially, you write a policy, which is an allowed list of origins for each feature. For every feature controlled by Feature Policy, the feature is only enabled in the current document or frame if its origin matches the allowed list of origins.</source>
          <target state="translated">Функциональная политика позволяет вам контролировать,какие оригиналы могут использовать какие функции,как на странице верхнего уровня,так и во встроенных кадрах.По сути,вы пишете политику,которая представляет собой список разрешенных исходных данных для каждой функции.Для каждой функции,управляемой Feature Policy,эта функция включена в текущем документе или фрейме только в том случае,если ее происхождение совпадает с разрешенным списком происхождения.</target>
        </trans-unit>
        <trans-unit id="23cd7a78a2dc77e19ba57e025deceab5b480ee5d" translate="yes" xml:space="preserve">
          <source>Feature Policy provides a mechanism to explicitly declare what functionality is used (or not used), throughout your website. This allows you to lock in best practices, even as the codebase evolves over time &amp;mdash; as well as to more safely compose third-party content &amp;mdash; by limiting which features are available.</source>
          <target state="translated">Политика функций предоставляет механизм для явного объявления того, какие функции используются (или не используются) на вашем веб-сайте. Это позволяет закрепить передовой опыт, даже если кодовая база со временем развивается, а также более безопасно составлять сторонний контент, ограничивая доступные функции.</target>
        </trans-unit>
        <trans-unit id="92799190c0f4fe5ecaee2952ecf286aa6cce9ac3" translate="yes" xml:space="preserve">
          <source>Feature Policy provides two ways to specify policies to control features:</source>
          <target state="translated">Функциональная политика предоставляет два способа указания политик для управления функциями:</target>
        </trans-unit>
        <trans-unit id="0847c40e72979da8866a8e8b3f1f0cc411a2dad3" translate="yes" xml:space="preserve">
          <source>Feature Policy: Using Feature Policy</source>
          <target state="translated">Особая политика:Политика использования объектов</target>
        </trans-unit>
        <trans-unit id="fcae4ecf5da500dd00bf9572a09b7e678697d109" translate="yes" xml:space="preserve">
          <source>Feature Policy&lt;br/&gt;&lt;small&gt;The definition of 'Feature-Policy' in that specification.&lt;/small&gt;</source>
          <target state="translated">Политика функций &lt;br/&gt;&lt;small&gt;Определение &amp;laquo;политики функций&amp;raquo; в этой спецификации.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="294d4d9a4eaac5449bf61242940545b797efd4f7" translate="yes" xml:space="preserve">
          <source>Feature detection</source>
          <target state="translated">Обнаружение признаков</target>
        </trans-unit>
        <trans-unit id="6680a4d48c2812c07a01fb3632993e80d45a2200" translate="yes" xml:space="preserve">
          <source>Feature detection is where you don't try to figure out which browser is rendering your page, but instead, you check to see if the specific feature you need is available. If it's not, you use a fallback. In those rare cases where behavior differs between browsers, instead of checking the user agent string, you should instead implement a test to detect how the browser implements the API and determine how to use it from that. An example of feature detection is as follows. In 2017, Chrome &lt;a href=&quot;https://www.chromestatus.com/feature/5668726032564224&quot;&gt;unflagged experimental lookbehind support in regular expressions&lt;/a&gt;, but no other browser supported it. So, you might have thought to do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cfcbb2b685a05f07291909f36952c99a4e2fe7b" translate="yes" xml:space="preserve">
          <source>Feature detection is where you don't try to figure out which browser is rendering your page, but instead, you check to see if the specific feature you need is available. If it's not, you use a fallback. There are never any rare cases where you should use the user agent string, such as to detect a browser which implements the behavior of an API differently. Rather, in such rare cases, you should implement a test to detect how the browser implements the API and then determine when and how to use it instead. A good current example of feature detection is as follows. Recently, Chrome has added experimental look behind support to regular expressions, but no other browser currently supports this. So, you might incorrectly assume you should do this:</source>
          <target state="translated">Обнаружение функции-это то место,где вы не пытаетесь выяснить,какой браузер визуализирует вашу страницу,а вместо этого проверяете,доступна ли нужная функция.Если нет,вы используете запасной вариант.Никогда не бывает редких случаев,когда вы должны использовать строку агента пользователя,например,для обнаружения браузера,который реализует поведение API по-другому.Скорее,в таких редких случаях вы должны реализовать тест,чтобы определить,как браузер реализует API,а затем определить,когда и как его использовать.Хорошим текущим примером обнаружения возможностей является следующий.Недавно Chrome добавил экспериментальный взгляд за поддержкой регулярных выражений,но на данный момент ни один другой браузер не поддерживает это.Таким образом,вы можете ошибочно полагать,что это нужно делать:</target>
        </trans-unit>
        <trans-unit id="95c726252d0d002492bfb760d3686808998bb8df" translate="yes" xml:space="preserve">
          <source>Feature policies on www.chromestatus.com</source>
          <target state="translated">Правила размещения информации на сайте www.chromestatus.com.</target>
        </trans-unit>
        <trans-unit id="d7fb77650eb9c4f73d9377f06679ca2cd28df471" translate="yes" xml:space="preserve">
          <source>Feature-Policy</source>
          <target state="translated">Feature-Policy</target>
        </trans-unit>
        <trans-unit id="6731078bdcb61e26085f7dc9985790c18e8a240e" translate="yes" xml:space="preserve">
          <source>Feature-Policy Tester (Chrome Developer Tools extension)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ee4ffa583da7bdf223c2ffed9d85ab239371e0" translate="yes" xml:space="preserve">
          <source>Feature-Policy: autoplay</source>
          <target state="translated">Характеристика-Политика:автоигра</target>
        </trans-unit>
        <trans-unit id="31f9ca897eb5c9f44de8842f2516fb02a54faa2e" translate="yes" xml:space="preserve">
          <source>Feature-Policy: camera</source>
          <target state="translated">Функция-Политика:камера</target>
        </trans-unit>
        <trans-unit id="bf16c6ee691c8e9ca8e2dbe87a3f347fcb570cc7" translate="yes" xml:space="preserve">
          <source>Feature-Policy: document-domain</source>
          <target state="translated">Характеристика-Политика:документ-домен</target>
        </trans-unit>
        <trans-unit id="fe796e681d5c63dcc531be776ac43685da71889f" translate="yes" xml:space="preserve">
          <source>Feature-Policy: encrypted-media</source>
          <target state="translated">Характеристика-Политика:зашифрованные средства массовой информации</target>
        </trans-unit>
        <trans-unit id="37767aecde5e9787909f7866d3735071b1ccad3d" translate="yes" xml:space="preserve">
          <source>Feature-Policy: fullscreen</source>
          <target state="translated">Характеристика-Политика:в полноэкранном режиме</target>
        </trans-unit>
        <trans-unit id="9488de5430b2b3fc9fd436b5e2d0c394e296837e" translate="yes" xml:space="preserve">
          <source>Feature-Policy: geolocation</source>
          <target state="translated">Характеристика-Политика:геолокация</target>
        </trans-unit>
        <trans-unit id="2c61ebc183f28f44ab1b2b148b5d57942442df26" translate="yes" xml:space="preserve">
          <source>Feature-Policy: microphone</source>
          <target state="translated">Характеристика-Политика:микрофон</target>
        </trans-unit>
        <trans-unit id="596057da4c0cdcb20ea8b614fd43950671e7a493" translate="yes" xml:space="preserve">
          <source>Feature-Policy: midi</source>
          <target state="translated">Feature-Policy:midi</target>
        </trans-unit>
        <trans-unit id="6ae2a5e94ce91f2de51637745788fb01a6ad53dc" translate="yes" xml:space="preserve">
          <source>Feature-Policy: payment</source>
          <target state="translated">Характеристика-Политика:оплата</target>
        </trans-unit>
        <trans-unit id="6392e975cf7e0435d78f4e6d61f8527537c58cfd" translate="yes" xml:space="preserve">
          <source>Feature-Policy: vr</source>
          <target state="translated">Характеристика-Политика:vr</target>
        </trans-unit>
        <trans-unit id="088204f1105dd468d38881f2fd12a0b4aa4c7aab" translate="yes" xml:space="preserve">
          <source>Feature-Policy:fullscreen</source>
          <target state="translated">Feature-Policy:fullscreen</target>
        </trans-unit>
        <trans-unit id="d710338755da08a83c18e218bac6cbaa1e2a4fd1" translate="yes" xml:space="preserve">
          <source>Feature-Policy:geolocation</source>
          <target state="translated">Feature-Policy:geolocation</target>
        </trans-unit>
        <trans-unit id="9d7e13756d87f97651352edd83fe4becad54f376" translate="yes" xml:space="preserve">
          <source>Feature-Policy:microphone</source>
          <target state="translated">Feature-Policy:microphone</target>
        </trans-unit>
        <trans-unit id="e7e6e3dcff550300eec2d95910564a70e893cba4" translate="yes" xml:space="preserve">
          <source>Features are each defined to have a default allowlist, which is one of:</source>
          <target state="translated">Каждая из функций определена,чтобы иметь список разрешенных по умолчанию,который является одним из них:</target>
        </trans-unit>
        <trans-unit id="73987c80f34346a88ab75127eefbe27a82362092" translate="yes" xml:space="preserve">
          <source>Features restricted to secure contexts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e28fef517be6e0fc21d5716c7662e4801ad299" translate="yes" xml:space="preserve">
          <source>Fetch API</source>
          <target state="translated">Получить API</target>
        </trans-unit>
        <trans-unit id="0c16479e5749d322208146b5b5f7624d72ebd140" translate="yes" xml:space="preserve">
          <source>Fetch directive</source>
          <target state="translated">Директива Fetch</target>
        </trans-unit>
        <trans-unit id="e53b45c9af742d503a22c70314dddb7873195091" translate="yes" xml:space="preserve">
          <source>Fetch directives</source>
          <target state="translated">Директивы Fetch</target>
        </trans-unit>
        <trans-unit id="7a5dfae050f11fd6283650bfb92f289b86d2ac98" translate="yes" xml:space="preserve">
          <source>Fetch directives control locations from which certain resource types may be loaded.</source>
          <target state="translated">Fetch директивы контролируют места,из которых могут быть загружены определенные типы ресурсов.</target>
        </trans-unit>
        <trans-unit id="6117c09509a0de56a9b4f6836fda41153fe625f3" translate="yes" xml:space="preserve">
          <source>Fetch directives control the locations from which certain resource types may be loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afdd60e438b0416f34aeb50bf03aae713ddb1bda" translate="yes" xml:space="preserve">
          <source>Fetch metadata request headers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916f35ff813a6743346055125d97c6cbba1aaedc" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Credentials' in that specification.&lt;/small&gt;</source>
          <target state="translated">Получение &lt;br/&gt;&lt;small&gt;Определение &amp;laquo;Access-Control-Allow-Credentials&amp;raquo; в этой спецификации.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="0678866e50722f12e36a5dc2fec0748a692fe2ca" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Headers' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;Определение &amp;laquo;Access-Control-Allow-Headers&amp;raquo; в этой спецификации.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2cf87afd008c8c6a087d3cc6f98ba0277b9043b7" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Methods' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;Определение &amp;laquo;Access-Control-Allow-Methods&amp;raquo; в этой спецификации.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e4f7ed2d1134249b47bfd1f0ca53f80515e1563f" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Origin' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;Определение &amp;laquo;Access-Control-Allow-Origin&amp;raquo; в этой спецификации.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b6d65973f43b54eb3f3ef47447a2bae6cff6fe97" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Expose-Headers' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;Определение &amp;laquo;Access-Control-Expose-Headers&amp;raquo; в этой спецификации.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8089c31c9e26d8f2db19edbf9e44a130bc5eddd3" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Max-Age' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;Определение &amp;laquo;Access-Control-Max-Age&amp;raquo; в этой спецификации.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9397823a091bbc18047f30f651f6476462ab4fa8" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Request-Headers' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;Определение заголовков Access-Control-Request-Headers в этой спецификации.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="82f6f83e1801614fce5a5524369fe1de50f85da5" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Request-Method' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;Определение метода запроса-контроля доступа в этой спецификации.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7e1eb076c3812c097fec7c1be9899bd085c5fbf1" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'CORS' in that specification.&lt;/small&gt;</source>
          <target state="translated">Получить &lt;br/&gt;&lt;small&gt;Определение CORS в этой спецификации.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="fe63ee35db7f3102d616e69a27e101cdcc18b63a" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Origin header' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;Определение &amp;laquo;заголовка источника&amp;raquo; в этой спецификации.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1446331a1b71bc30148510fc4d99d0e0ec91086f" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'X-Content-Type-Options definition' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;Определение &amp;laquo;определения X-Content-Type-Options&amp;raquo; в этой спецификации.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="918815e8513a9d78892a5b82f5db40dddb1a7f3b" translate="yes" xml:space="preserve">
          <source>Fetching the root page of developer.mozilla.org, i.e. &lt;a href=&quot;https://developer.mozilla.org/&quot;&gt;http://developer.mozilla.org/&lt;/a&gt;, and telling the server that the user-agent would prefer the page in French, if possible:</source>
          <target state="translated">Получение корневой страницы developer.mozilla.org, то есть &lt;a href=&quot;https://developer.mozilla.org/&quot;&gt;http://developer.mozilla.org/&lt;/a&gt; , и сообщение серверу, что пользовательский агент предпочел бы страницу на французском языке, если это возможно:</target>
        </trans-unit>
        <trans-unit id="3253d0b90d63fd1a7b31fd3494e21aaa52e7e42e" translate="yes" xml:space="preserve">
          <source>File Transfer Protocol</source>
          <target state="translated">Протокол передачи файлов</target>
        </trans-unit>
        <trans-unit id="5d438ceeae874a432c5e55fd5791a60c59eb0d8f" translate="yes" xml:space="preserve">
          <source>File extension(s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361a82465491c9161713f597566a3f42e5734e1b" translate="yes" xml:space="preserve">
          <source>File format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7b57a8f84d5b2b2d5abb274bb773348457c9ea" translate="yes" xml:space="preserve">
          <source>File format compression</source>
          <target state="translated">Сжатие формата файла</target>
        </trans-unit>
        <trans-unit id="57fa91ed93807da407d7147d7099ef87d3eef96c" translate="yes" xml:space="preserve">
          <source>Filename suffixes are sometimes used, especially on Microsoft Windows. Not all operating systems consider these suffixes meaningful (such as Linux and MacOS), and there is no guarantee they are correct.</source>
          <target state="translated">Иногда используются суффиксы имен файлов,особенно в Microsoft Windows.Не все операционные системы считают эти суффиксы значимыми (например,Linux и MacOS),и нет никакой гарантии,что они корректны.</target>
        </trans-unit>
        <trans-unit id="b8a4a48235c2528b57fabea0f16e59922544df82" translate="yes" xml:space="preserve">
          <source>Files whose MIME type is &lt;code&gt;image&lt;/code&gt; contain image data. The subtype specifies which specific image file format the data represents. Only a few image types are used commonly enough to be considered safe for use on web pages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1888d033ef09f73993a1ae6180b384a516770e4" translate="yes" xml:space="preserve">
          <source>Filtration based on &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;, if any at all.</source>
          <target state="translated">Фильтрация по &lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; , если вообще есть.</target>
        </trans-unit>
        <trans-unit id="02b7b1f402f1dad5cba5d5c6f4047891c00d3834" translate="yes" xml:space="preserve">
          <source>Finally, &lt;a href=&quot;headers/access-control-max-age&quot;&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;&lt;/a&gt; gives the value in seconds for how long the response to the preflight request can be cached for without sending another preflight request. In this case, 86400 seconds is 24 hours. Note that each browser has a &lt;a href=&quot;headers/access-control-max-age&quot;&gt;maximum internal value&lt;/a&gt; that takes precedence when the &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; is greater.</source>
          <target state="translated">Наконец, &lt;a href=&quot;headers/access-control-max-age&quot;&gt; &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; &lt;/a&gt; дает значение в секундах, в течение которого можно кэшировать ответ на предварительный запрос без отправки другого предварительного запроса. В этом случае 86400 секунд - это 24 часа. Обратите внимание, что каждый браузер имеет &lt;a href=&quot;headers/access-control-max-age&quot;&gt;максимальное внутреннее значение,&lt;/a&gt; которое имеет приоритет, когда &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; больше.</target>
        </trans-unit>
        <trans-unit id="9c162123e6b08c6245b8c567094309cf3046a7d6" translate="yes" xml:space="preserve">
          <source>Finding insecure requests</source>
          <target state="translated">Поиск небезопасных запросов</target>
        </trans-unit>
        <trans-unit id="b4ee6522335b033249255b4cc1d572993282aafb" translate="yes" xml:space="preserve">
          <source>Firefox</source>
          <target state="translated">Firefox</target>
        </trans-unit>
        <trans-unit id="3d69145991747b3ff98ca2ac235bf9a2b6c0b22b" translate="yes" xml:space="preserve">
          <source>Firefox 3.6 and later</source>
          <target state="translated">Firefox 3.6 и более поздние версии</target>
        </trans-unit>
        <trans-unit id="9a053be79e5c0ac7481cbdffd78827759a3ed9f5" translate="yes" xml:space="preserve">
          <source>Firefox 4</source>
          <target state="translated">Firefox 4</target>
        </trans-unit>
        <trans-unit id="e75eacacb146d953aa91455b2699bff5088fb836" translate="yes" xml:space="preserve">
          <source>Firefox 5 handles the &lt;code&gt;Content-Disposition&lt;/code&gt; HTTP response header more effectively if both the &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;filename*&lt;/code&gt; parameters are provided; it looks through all provided names, using the &lt;code&gt;filename*&lt;/code&gt; parameter if one is available, even if a &lt;code&gt;filename&lt;/code&gt; parameter is included first. Previously, the first matching parameter would be used, thereby preventing a more appropriate name from being used. See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=588781&quot;&gt;bug 588781&lt;/a&gt;.</source>
          <target state="translated">Firefox 5 более эффективно обрабатывает заголовок HTTP-ответа &lt;code&gt;Content-Disposition&lt;/code&gt; , если указаны параметры &lt;code&gt;filename&lt;/code&gt; и &lt;code&gt;filename*&lt;/code&gt; ; он просматривает все предоставленные имена, используя параметр &lt;code&gt;filename*&lt;/code&gt; если он доступен, даже если параметр &lt;code&gt;filename&lt;/code&gt; включен первым. Раньше использовался первый совпадающий параметр, что предотвращало использование более подходящего имени. Смотрите &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=588781&quot;&gt;ошибку 588781&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4443afafb8462a4928ffbe0151cd70875fd784c9" translate="yes" xml:space="preserve">
          <source>Firefox 72 enables &lt;code&gt;X-Content-Type-Options: nosniff&lt;/code&gt; for top-level documents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98488d27ab42c5d6a59371f548c195bffbe9d824" translate="yes" xml:space="preserve">
          <source>Firefox 82 (and later) and Chrome prioritize the HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&amp;lt;a&amp;gt; element's&lt;/a&gt;&lt;code&gt;download&lt;/code&gt; attribute over the &lt;code&gt;Content-Disposition&lt;/code&gt;&lt;code&gt;inline&lt;/code&gt; parameter (for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin URLs&lt;/a&gt;). Earlier Firefox versions prioritize the header and will display the content inline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389872f22235d2e890d3e24f0e0fb6d81e0c8a59" translate="yes" xml:space="preserve">
          <source>Firefox &lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;caps this at 24 hours&lt;/a&gt; (86400 seconds) and Chromium at &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=36&amp;amp;rcl=52002151773d8cd9ffc5f557cd7cc880fddcae3e&quot;&gt;10 minutes&lt;/a&gt; (600 seconds). Chromium also specifies a default value of 5 seconds.</source>
          <target state="translated">Firefox &lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;ограничивает это 24 часами&lt;/a&gt; (86400 секунд), а Chromium - &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=36&amp;amp;rcl=52002151773d8cd9ffc5f557cd7cc880fddcae3e&quot;&gt;10 минутами&lt;/a&gt; (600 секунд). Chromium также указывает значение по умолчанию 5 секунд.</target>
        </trans-unit>
        <trans-unit id="90fb1b1a36a9c036151eeced597d613144d0f291" translate="yes" xml:space="preserve">
          <source>Firefox &lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;caps this at 24 hours&lt;/a&gt; (86400 seconds).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1444ac74d1094f6f34b49da3ee9966b7b93f1731" translate="yes" xml:space="preserve">
          <source>Firefox Developer Tools</source>
          <target state="translated">Инструменты для разработчиков Firefox</target>
        </trans-unit>
        <trans-unit id="f300fd41a795a419c45aee9c6cb726e738e71b7e" translate="yes" xml:space="preserve">
          <source>Firefox Developer Tools: using a source map</source>
          <target state="translated">Инструменты для разработчиков Firefox:использование исходной карты</target>
        </trans-unit>
        <trans-unit id="e4b319de38dd3b5708092c79d821e3e2547bbfeb" translate="yes" xml:space="preserve">
          <source>Firefox OS</source>
          <target state="translated">ОС Firefox</target>
        </trans-unit>
        <trans-unit id="08b98a32baa6ee15d09f718291f659a3f7d5a387" translate="yes" xml:space="preserve">
          <source>Firefox OS devices identify themselves without any operating system indication; for example: &quot;Mozilla/5.0 (Mobile; rv:15.0) Gecko/15.0 Firefox/15.0&quot;. The web is the platform.</source>
          <target state="translated">Например,устройства с ОС Firefox идентифицируют себя без указания операционной системы:&quot;Mozilla/5.0 (Mobile;rv:15.0)Gecko/15.0 Firefox/15.0&quot;.Веб-это платформа.</target>
        </trans-unit>
        <trans-unit id="096d24033e6a963360da3b94208e68f8d97b00a8" translate="yes" xml:space="preserve">
          <source>Firefox OS has a four-digit version number:</source>
          <target state="translated">Операционная система Firefox имеет четырехзначный номер версии:</target>
        </trans-unit>
        <trans-unit id="ee0b8d61fb018abae298ec4b7eb6bf2ea815cea8" translate="yes" xml:space="preserve">
          <source>Firefox OS version number</source>
          <target state="translated">Номер версии ОС Firefox</target>
        </trans-unit>
        <trans-unit id="0b43f7fedde8c737f31357ef6642b9b7dec844af" translate="yes" xml:space="preserve">
          <source>Firefox UA string</source>
          <target state="translated">строка Firefox UA</target>
        </trans-unit>
        <trans-unit id="cd5ecb0a55376afe3b1ad82fbe8b4cecc9e76924" translate="yes" xml:space="preserve">
          <source>Firefox Web Runtime</source>
          <target state="translated">Firefox Web Runtime</target>
        </trans-unit>
        <trans-unit id="0c516be8bc16e485b9c5dea3cac5637b2be7f8c3" translate="yes" xml:space="preserve">
          <source>Firefox and Chrome&lt;strong&gt; disable pin validation&lt;/strong&gt; for pinned hosts whose validated certificate chain terminates at a &lt;strong&gt;user-defined trust anchor&lt;/strong&gt; (rather than a built-in trust anchor). This means that for users who imported custom root certificates all pinning violations are ignored.</source>
          <target state="translated">Firefox и Chrome &lt;strong&gt;отключают проверку пин-кода&lt;/strong&gt; для закрепленных хостов, чья подтвержденная цепочка сертификатов заканчивается на определяемом &lt;strong&gt;пользователем якоре доверия&lt;/strong&gt; (а не на встроенном якоре доверия). Это означает, что для пользователей, импортировавших пользовательские корневые сертификаты, все нарушения закрепления игнорируются.</target>
        </trans-unit>
        <trans-unit id="f46b1448185527825780f84cfe778a2558ec052f" translate="yes" xml:space="preserve">
          <source>Firefox currently only supports the &lt;code&gt;Large-Allocation&lt;/code&gt; header in our 32-bit Windows builds, as memory fragmentation is not an issue in 64-bit builds. If you are running a non-win32 version of Firefox, this error will appear. This check can be disabled with the &quot;dom.largeAllocation.</source>
          <target state="translated">В настоящее время Firefox поддерживает только заголовок &lt;code&gt;Large-Allocation&lt;/code&gt; в наших 32-разрядных сборках Windows, поскольку фрагментация памяти не является проблемой в 64-разрядных сборках. Если вы используете версию Firefox, отличную от Win32, эта ошибка появится. Эту проверку можно отключить с помощью параметра dom.largeAllocation.</target>
        </trans-unit>
        <trans-unit id="fd814d6c03ca30a65e6eae11a110b64dbd4091ec" translate="yes" xml:space="preserve">
          <source>Firefox earlier than 3.6</source>
          <target state="translated">Firefox ранее 3,6</target>
        </trans-unit>
        <trans-unit id="35e08ebaf6a034e084ac621e4a8de400a08ba9e7" translate="yes" xml:space="preserve">
          <source>Firefox for Android</source>
          <target state="translated">Firefox для Android</target>
        </trans-unit>
        <trans-unit id="6b3b609703588318cf5eddb907cb036af5b8fa9f" translate="yes" xml:space="preserve">
          <source>Firefox for Echo Show</source>
          <target state="translated">Firefox для Эхо Шоу</target>
        </trans-unit>
        <trans-unit id="70bde33b11b3ebf831139347906ee55c0954e773" translate="yes" xml:space="preserve">
          <source>Firefox for Fire TV</source>
          <target state="translated">Firefox для Fire TV</target>
        </trans-unit>
        <trans-unit id="aa1b6f07af81be5e73ca90848517f82656d9b533" translate="yes" xml:space="preserve">
          <source>Firefox for Maemo (Nokia N900)</source>
          <target state="translated">Firefox для Maemo (Nokia N900)</target>
        </trans-unit>
        <trans-unit id="d796cd118178bed42189a33b56788596ce709a40" translate="yes" xml:space="preserve">
          <source>Firefox for iOS</source>
          <target state="translated">Firefox для iOS</target>
        </trans-unit>
        <trans-unit id="4a1947cf48de07acf77d4542c741b3b264b1d589" translate="yes" xml:space="preserve">
          <source>Firefox for iOS user agent string</source>
          <target state="translated">Строка агента Firefox для пользователя iOS</target>
        </trans-unit>
        <trans-unit id="520f59d4c4564c36ce2dffd8248ed3f436481f50" translate="yes" xml:space="preserve">
          <source>Firefox for iOS uses the default Mobile Safari UA string, with an additional &lt;strong&gt;FxiOS/&amp;lt;version&amp;gt;&lt;/strong&gt; token, similar to how &lt;a href=&quot;https://developer.chrome.com/multidevice/user-agent#chrome_for_ios_user_agent&quot;&gt;Chrome for iOS identifies itself&lt;/a&gt;.</source>
          <target state="translated">Firefox для iOS использует строку UA Mobile Safari по умолчанию с дополнительным &lt;strong&gt;токеном FxiOS / &amp;lt;version&amp;gt;&lt;/strong&gt; , аналогично тому, как &lt;a href=&quot;https://developer.chrome.com/multidevice/user-agent#chrome_for_ios_user_agent&quot;&gt;Chrome для iOS идентифицирует себя&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57d4690e6cf1e25d65d0fd2cf1024daa1be89df4" translate="yes" xml:space="preserve">
          <source>Firefox has detected that the server is redirecting the request for this address in a way that will never complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97d9b72ae732fc5ec0d2b8c7b9205f083804989f" translate="yes" xml:space="preserve">
          <source>Firefox has moved to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiprocess_Firefox&quot;&gt;multiprocess architecture&lt;/a&gt;, and this architecture is required in order to support the &lt;code&gt;Large-Allocation&lt;/code&gt; header. Some &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/SDK&quot;&gt;legacy Addons&lt;/a&gt; can prevent Firefox from using this new, faster, multiprocess architecture. If you have one of these Addons installed, then we will continue to use the old single process architecuture for compatibility, and cannot handle the &lt;code&gt;Large-Allocation&lt;/code&gt; header.</source>
          <target state="translated">Firefox перешел на &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiprocess_Firefox&quot;&gt;многопроцессорную архитектуру&lt;/a&gt; , и эта архитектура требуется для поддержки заголовка &lt;code&gt;Large-Allocation&lt;/code&gt; . Некоторые &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/SDK&quot;&gt;устаревшие надстройки&lt;/a&gt; могут помешать Firefox использовать эту новую, более быструю, многопроцессорную архитектуру. Если у вас установлен один из этих дополнений, мы продолжим использовать старую архитектуру одного процесса для совместимости и не сможем обрабатывать заголовок &lt;code&gt;Large-Allocation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cea7ce89d775de0cacc4bf3ee3434d91b180561e" translate="yes" xml:space="preserve">
          <source>Firefox has not, and &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=528661&quot;&gt;will not implement &lt;code&gt;X-XSS-Protection&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce4010ab4d918ae6e0eb7de27062f406a172591" translate="yes" xml:space="preserve">
          <source>Firefox once used &lt;code&gt;ISO-8859-1&lt;/code&gt;, but changed to &lt;code&gt;utf-8&lt;/code&gt; for parity with other browsers and to avoid potential problems as described in &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1419658&quot;&gt;bug 1419658&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fa353bc27c77608b28b6a494fb71634a8d1229" translate="yes" xml:space="preserve">
          <source>Firefox user agent string reference</source>
          <target state="translated">Ссылка на строку агента пользователя Firefox</target>
        </trans-unit>
        <trans-unit id="824138edb7e10e6cc870e036060b42fe43828628" translate="yes" xml:space="preserve">
          <source>Firefox's console displays messages in its console when requests fail due to CORS. Part of the error text is a &quot;reason&quot; message that provides added insight into what went wrong. The reason messages are listed below; click the message to open an article explaining the error in more detail and offering possible solutions.</source>
          <target state="translated">Консоль Firefox отображает сообщения в своей консоли,когда запросы не удовлетворяются из-за CORS.Часть текста ошибки-это сообщение &quot;причина&quot;,которое дает дополнительное представление о том,что пошло не так.Сообщения о причине перечислены ниже;щелкните по сообщению,чтобы открыть статью,объясняющую ошибку более подробно и предлагающую возможные решения.</target>
        </trans-unit>
        <trans-unit id="7d1c6e60d05a2c5211575867279c806da9425465" translate="yes" xml:space="preserve">
          <source>Firefox, Chrome and Safari do not support multiple origins in the Access-Control-Allow-Origin header.</source>
          <target state="translated">Firefox,Chrome и Safari не поддерживают несколько источников в заголовке Access-Control-Alloww-Origin.</target>
        </trans-unit>
        <trans-unit id="be168c2fee1a2d9fa42cc62fef4298c4cbcefbf2" translate="yes" xml:space="preserve">
          <source>Firefox/xyz</source>
          <target state="translated">Firefox/xyz</target>
        </trans-unit>
        <trans-unit id="f614dfafdbd42e06d5c689e2cc52f2820578b824" translate="yes" xml:space="preserve">
          <source>Firefox: &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1309358&quot;&gt;bug 1309358&lt;/a&gt;</source>
          <target state="translated">Firefox: &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1309358&quot;&gt;ошибка 1309358&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a0200dffc7bdc64d4a349f323b1653382469567" translate="yes" xml:space="preserve">
          <source>Fires a &lt;code&gt;SecurityPolicyViolationEvent&lt;/code&gt;.</source>
          <target state="translated">Запускает событие &lt;code&gt;SecurityPolicyViolationEvent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b748324a443374f003fb0c40ffc43547df0d368f" translate="yes" xml:space="preserve">
          <source>First you need to extract the public key information from your certificate or key file and encode them using Base64.</source>
          <target state="translated">Сначала вам нужно извлечь информацию об открытом ключе из сертификата или файла ключа и закодировать их,используя Base64.</target>
        </trans-unit>
        <trans-unit id="72a34e1cd654a785a78eeb2f1af6246aef47a923" translate="yes" xml:space="preserve">
          <source>First, the request. The preflight request is an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request that includes some combination of the three preflight request headers: &lt;a href=&quot;access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56777de18c704b8472efc7f29607549036e406b" translate="yes" xml:space="preserve">
          <source>First, the request. The preflight request is an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request which includes some combination of the three preflight request headers: &lt;a href=&quot;access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;, such as:</source>
          <target state="translated">Во-первых, просьба. Предварительный запрос - это запрос &lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; ,&lt;/a&gt; который включает некоторую комбинацию трех заголовков предварительного запроса: &lt;a href=&quot;access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; , например:</target>
        </trans-unit>
        <trans-unit id="1856a70ba04296bbf62c2e423de0fbdcfb0f5adf" translate="yes" xml:space="preserve">
          <source>Flow of an HTTP session</source>
          <target state="translated">Поток сессии HTTP</target>
        </trans-unit>
        <trans-unit id="bcbad51a46a03dbd80a644d3f941e3c1172162b3" translate="yes" xml:space="preserve">
          <source>Focus Version (Rendering Engine)</source>
          <target state="translated">Версия фокуса (двигатель-рендер)</target>
        </trans-unit>
        <trans-unit id="56c6a4ca5cb7ee3279f46162d43efe44a37848d9" translate="yes" xml:space="preserve">
          <source>Focus for Android</source>
          <target state="translated">Фокус для Android</target>
        </trans-unit>
        <trans-unit id="9c96a14d8cf5e47753d46702539d3958d06bb67a" translate="yes" xml:space="preserve">
          <source>Focus for iOS</source>
          <target state="translated">Фокус для iOS</target>
        </trans-unit>
        <trans-unit id="aa5bdfcda9154f616d3599ff8019fe359c3f4231" translate="yes" xml:space="preserve">
          <source>Followed by a second connection and request to fetch the image (followed by a response to that request):</source>
          <target state="translated">Далее следует второе соединение и запрос на получение изображения (с последующим ответом на этот запрос):</target>
        </trans-unit>
        <trans-unit id="453b3d513097bbb5dad0b729903f4324d053ad1f" translate="yes" xml:space="preserve">
          <source>Font/typeface data. Common examples include &lt;code&gt;font/woff&lt;/code&gt;, &lt;code&gt;font/ttf&lt;/code&gt;, and &lt;code&gt;font/otf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1d332ceb92dcde1fcd283f80c52096a5c624f8" translate="yes" xml:space="preserve">
          <source>Footnote 1</source>
          <target state="translated">Сноска 1</target>
        </trans-unit>
        <trans-unit id="a2e8427dcb2cd9ff2779aa2b38c7e477133f780c" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, to update a cached entity that has an associated &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для методов &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; , чтобы обновить кэшированный объект, имеющий связанный &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a4b7f7de1f1cba719e4bebb16b0fc5cf663d900" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, used in combination with a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header, it can guarantee that the new ranges requested comes from the same resource than the previous one. If it doesn't match, then a &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt; (Range Not Satisfiable) response is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523ad4bead51d0b08a4fff5dbbe8221c7a8666b5" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, used in combination with an &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header, it can guarantee that the new ranges requested comes from the same resource than the previous one. If it doesn't match, then a &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;(Range Not Satisfiable) response is returned.</source>
          <target state="translated">Для методов &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; , используемых в сочетании с заголовком &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; , это может гарантировать, что новые запрошенные диапазоны поступают из того же ресурса, что и предыдущий. Если он не совпадает, возвращается ответ &lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; (диапазон не удовлетворяется).</target>
        </trans-unit>
        <trans-unit id="01925d81b53df8220be1ab3b85de00880bc40ace" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt; attributes&lt;/a&gt;, the owner document's referrer policy is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a5e026c5b9f4e6d8669a37e565175368c88cdf" translate="yes" xml:space="preserve">
          <source>For DAV properties, the name of the property is also the same as the
   name of the XML element that contains its value.  In the section
   below, the final line of each section gives the element type
   declaration using the format defined in [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;].  The &quot;Value&quot;
   field, where present, specifies further restrictions on the allowable
   contents of the XML element using BNF (i.e., to further restrict the
   values of a PCDATA element).

   A protected property is one that cannot be changed with a PROPPATCH
   request.  There may be other requests that would result in a change
   to a protected property (as when a LOCK request affects the value of
   DAV:lockdiscovery).  Note that a given property could be protected on
   one type of resource, but not protected on another type of resource.

   A computed property is one with a value defined in terms of a
   computation (based on the content and other properties of that
   resource, or even of some other resource).  A computed property is
   always a protected property.

   COPY and MOVE behavior refers to local COPY and MOVE operations.

   For properties defined based on HTTP GET response headers (DAV:get*),
   the header value could include LWS as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], &lt;a href=&quot;#section-4.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;.  Server implementors SHOULD strip LWS from these values before
   using as WebDAV property values.</source>
          <target state="translated">Для свойств DAV имя свойства также совпадает с именем элемента XML, который содержит его значение. В следующем разделе последняя строка каждого раздела дает объявление типа элемента с использованием формата, определенного в [ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]. Поле &amp;laquo;Значение&amp;raquo;, если оно присутствует, определяет дополнительные ограничения на допустимое содержимое элемента XML с использованием BNF (т. Е. Для дальнейшего ограничения значений элемента PCDATA). Защищенное свойство - это свойство, которое нельзя изменить с помощью запроса PROPPATCH. Могут быть и другие запросы, которые могут привести к изменению защищенного свойства (например, когда запрос LOCK влияет на значение DAV: lockdiscovery). Обратите внимание, что данное свойство может быть защищено на одном типе ресурса, но не защищено на другом типе ресурса. Вычисляемое свойство - это свойство, значение которого определяется в терминах вычисления (на основе содержимого и других свойств этого ресурса или даже какого-либо другого ресурса). Вычисляемое свойство всегда является защищенным свойством.Поведение COPY и MOVE относится к локальным операциям COPY и MOVE. Для свойств, определенных на основе заголовков ответа HTTP GET (DAV: get *), значение заголовка может включать LWS, как определено в [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ], &lt;a href=&quot;#section-4.2&quot;&gt;раздел &lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . Разработчикам сервера СЛЕДУЕТ удалить LWS из этих значений перед использованием в качестве значений свойств WebDAV.</target>
        </trans-unit>
        <trans-unit id="7578507963f5f6a92a4ce0b4b4477e8db695266c" translate="yes" xml:space="preserve">
          <source>For Nginx, the command to set up this header is:</source>
          <target state="translated">Для Nginx это команда установки этого заголовка:</target>
        </trans-unit>
        <trans-unit id="1714ef110b1269230d283611695b8af7bcd041c3" translate="yes" xml:space="preserve">
          <source>For an example of a custom 404 page, see &lt;a href=&quot;https://developer.mozilla.org/en-US/404&quot;&gt;MDN's 404 page&lt;/a&gt;.</source>
          <target state="translated">Пример настраиваемой страницы 404 см. &lt;a href=&quot;https://developer.mozilla.org/en-US/404&quot;&gt;На странице 404 MDN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1da755a1735ea720fcbdf190446a592e95aff7a8" translate="yes" xml:space="preserve">
          <source>For authoring to commence, a client needs to discover the
   capabilities and locations of the available Collections.  Service
   Documents are designed to support this discovery process.

   How Service Documents are discovered is not defined in this
   specification. 

   Service Documents are identified with the &quot;application/atomsvc+xml&quot;
   media type (see &lt;a href=&quot;#section-16.2&quot;&gt;Section 16.2&lt;/a&gt;).</source>
          <target state="translated">Чтобы начать создание, клиенту необходимо узнать о возможностях и расположении доступных коллекций. Сервисные документы предназначены для поддержки этого процесса обнаружения. Как обнаруживаются сервисные документы, в данной спецификации не определено. Сервисные документы идентифицируются с типом носителя &amp;laquo;application / atomvc + xml&amp;raquo; (см. &lt;a href=&quot;#section-16.2&quot;&gt;Раздел 16.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="074190f3eb43757a18a5c3d3ad9b48a9217873dc" translate="yes" xml:space="preserve">
          <source>For clients that don't implement cookie prefixes, you cannot count on these additional assurances, and prefixed cookies will always be accepted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dc6e3c719ad40719899f3731172d36e94077ff2" translate="yes" xml:space="preserve">
          <source>For compression, end-to-end compression is where the largest performance improvements of Web sites reside. End-to-end compression refers to a compression of the body of a message that is done by the server and will last unchanged until it reaches the client. Whatever the intermediate nodes are, they leave the body untouched.</source>
          <target state="translated">Для сжатия,сквозное сжатие-это то место,где находятся наибольшие улучшения производительности веб-сайтов.Сжатие из конца в конец относится к сжатию тела сообщения,которое выполняется сервером и будет оставаться неизменным до тех пор,пока оно не достигнет клиента.Какими бы ни были промежуточные узлы,они оставляют тело нетронутым.</target>
        </trans-unit>
        <trans-unit id="f0f988728409b019db831b62218300a55ac3d394" translate="yes" xml:space="preserve">
          <source>For convenience, this protocol can be referred to as the &quot;Atom
   Protocol&quot; or &quot;AtomPub&quot;.  The following terminology is used by this
   specification:

   o  URI - A Uniform Resource Identifier as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;].  In
      this specification, the phrase &quot;the URI of a document&quot; is
      shorthand for &quot;a URI which, when dereferenced, is expected to
      produce that document as a representation&quot;.

   o  IRI - An Internationalized Resource Identifier as defined in
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt;].  Before an IRI found in a document is used by HTTP, the
      IRI is first converted to a URI.  See &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;.

   o  Resource - A network-accessible data object or service identified
      by an IRI, as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  See [&lt;a href=&quot;#ref-REC-webarch&quot;&gt;REC-webarch&lt;/a&gt;] for further
      discussion on Resources.

   o  relation (or &quot;relation of&quot;) - Refers to the &quot;rel&quot; attribute value
      of an atom:link element.

   o  Representation - An entity included with a request or response as
      defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   o  Collection - A Resource that contains a set of Member Resources.
      Collections are represented as Atom Feeds.  See &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;. 

   o  Member (or Member Resource) - A Resource whose IRI is listed in a
      Collection by an atom:link element with a relation of &quot;edit&quot; or
      &quot;edit-media&quot;.  See &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt;.  The protocol defines two kinds of
      Members:

      *  Entry Resource - Members of a Collection that are represented
         as Atom Entry Documents, as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].

      *  Media Resource - Members of a Collection that have
         representations other than Atom Entry Documents.

   o  Media Link Entry - An Entry Resource that contains metadata about
      a Media Resource.  See &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;.

   o  Workspace - A named group of Collections.  See &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.

   o  Service Document - A document that describes the location and
      capabilities of one or more Collections, grouped into Workspaces.
      See &lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;.

   o  Category Document - A document that describes the categories
      allowed in a Collection.  See &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;.</source>
          <target state="translated">Для удобства этот протокол может называться &amp;laquo;Протокол Atom&amp;raquo; или &amp;laquo;AtomPub&amp;raquo;. В данной спецификации используется следующая терминология: o URI - унифицированный идентификатор ресурса, как определено в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]. В этой спецификации фраза &amp;laquo;URI документа&amp;raquo; является сокращением для &amp;laquo;URI, при разыменовании которого ожидается создание этого документа как представления&amp;raquo;. o IRI - международный идентификатор ресурса, как определено в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt; ]. Прежде чем IRI, обнаруженный в документе, будет использоваться HTTP, IRI сначала преобразуется в URI. См. &lt;a href=&quot;#section-4.1&quot;&gt;Раздел 4.1&lt;/a&gt; . o Ресурс - доступный по сети объект данных или сервис, идентифицированный IRI, как определено в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ].Видеть [&lt;a href=&quot;#ref-REC-webarch&quot;&gt;REC-webarch&lt;/a&gt; ] для дальнейшего обсуждения ресурсов. o отношение (или &quot;отношение&quot;) - относится к значению атрибута &quot;rel&quot; элемента atom: link. o Представление - объект, включенный в запрос или ответ, как определено в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]. o Коллекция - Ресурс, содержащий набор Членских Ресурсов. Коллекции представлены в виде фидов Atom. См. &lt;a href=&quot;#section-9&quot;&gt;Раздел 9&lt;/a&gt; . o Участник (или ресурс участника) - ресурс, чей IRI указан в коллекции с помощью элемента atom: link с отношением &amp;laquo;edit&amp;raquo; или &amp;laquo;edit-media&amp;raquo;. См. &lt;a href=&quot;#section-9.1&quot;&gt;Раздел 9.1&lt;/a&gt; . Протокол определяет два типа членов: * Входной ресурс - элементы коллекции, представленные как входные документы Atom,как определено в [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]. * Медиа-ресурс - члены коллекции, у которых есть представления, отличные от входных документов Atom. o Запись медиа-ссылки - входной ресурс, содержащий метаданные о медиаресурсе. См. &lt;a href=&quot;#section-9.6&quot;&gt;Раздел 9.6&lt;/a&gt; . o Рабочая область - именованная группа коллекций. См. &lt;a href=&quot;#section-8.1&quot;&gt;Раздел 8.1&lt;/a&gt; . o Сервисный документ - документ, описывающий расположение и возможности одной или нескольких коллекций, сгруппированных в рабочие области. См. &lt;a href=&quot;#section-8&quot;&gt;Раздел 8&lt;/a&gt; . o Документ категории - документ, описывающий категории, разрешенные в Коллекции. См. &lt;a href=&quot;#section-7&quot;&gt;Раздел 7&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eef31d3a1350a01572c86bb4dfa3d00e0c975e26" translate="yes" xml:space="preserve">
          <source>For each policy-controlled feature, the browser maintains a list of origins for which the feature is enabled, known as an allowlist. If you do not specify a policy for a feature, then a default allowlist will be used. The default allowlist is specific to each feature.</source>
          <target state="translated">Для каждой функции,контролируемой политикой,браузер ведет список источников,для которых эта функция включена,известный как список разрешений.Если вы не укажете политику для функции,то будет использоваться список разрешений по умолчанию.Разрешительный список по умолчанию специфичен для каждой функции.</target>
        </trans-unit>
        <trans-unit id="bbfd900d40adcb99301092c21f8010e24f933f46" translate="yes" xml:space="preserve">
          <source>For example when editing MDN, the current wiki content is hashed and put into an &lt;code&gt;Etag&lt;/code&gt; in the response:</source>
          <target state="translated">Например, при редактировании MDN текущий контент вики хешируется и помещается в &lt;code&gt;Etag&lt;/code&gt; в ответе:</target>
        </trans-unit>
        <trans-unit id="9445e49e152cffd5d9a04a8f80bbd49732b55bc8" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://www.browserleaks.com/firefox&quot;&gt;a script on Browserleaks&lt;/a&gt; highlights what Firefox reveals when queried by a simple script running on the site (you can find the code in &lt;a href=&quot;https://browserleaks.com/firefox#more&quot;&gt;https://browserleaks.com/firefox#more&lt;/a&gt;).</source>
          <target state="translated">Например, &lt;a href=&quot;https://www.browserleaks.com/firefox&quot;&gt;сценарий Browserleaks&lt;/a&gt; выделяет то, что открывает Firefox при запросе простого сценария, запущенного на сайте (вы можете найти код в &lt;a href=&quot;https://browserleaks.com/firefox#more&quot;&gt;https://browserleaks.com/firefox#more&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8282891590c0b08790018d81b4f472f2cf7db144" translate="yes" xml:space="preserve">
          <source>For example, a document at &lt;code&gt;https://example.com/page.html&lt;/code&gt; will send the referrer &lt;code&gt;https://example.com/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b899bc979c38aad573a87de3d6fa69123c484f" translate="yes" xml:space="preserve">
          <source>For example, allow all browsing contexts within this iframe to use fullscreen:</source>
          <target state="translated">Например,позвольте всем контекстам просмотра в этом ифраме использовать полноэкранный режим:</target>
        </trans-unit>
        <trans-unit id="eac94e3ce15d79355451ea902d576dd478ad2b17" translate="yes" xml:space="preserve">
          <source>For example, by default all of the following result in a separate request to the origin and a separate cache entry: &lt;code&gt;Accept-Encoding: gzip,deflate,sdch&lt;/code&gt;, &lt;code&gt;Accept-Encoding: gzip,deflate&lt;/code&gt;, &lt;code&gt;Accept-Encoding: gzip&lt;/code&gt;. This is true even though the origin server will probably respond with &amp;mdash; and store &amp;mdash; the same resource for all requests (a gzip)!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5100e86095301001726a9dd07582fc20d58ee08d" translate="yes" xml:space="preserve">
          <source>For example, for any MIME type whose main type is &lt;code&gt;text&lt;/code&gt;, the optional &lt;code&gt;charset&lt;/code&gt; parameter can be used to specify the character set used for the characters in the data. If no &lt;code&gt;charset&lt;/code&gt; is specified, the default is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ASCII&quot;&gt;ASCII&lt;/a&gt; (&lt;code&gt;US-ASCII&lt;/code&gt;) unless overridden by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent's&lt;/a&gt; settings. To specify a UTF-8 text file, the MIME type &lt;code&gt;text/plain;charset=UTF-8&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b715bba658a875ffba997c7f848a3f6b1c1f7c" translate="yes" xml:space="preserve">
          <source>For example, if &quot;&lt;code&gt;Content-Language: de-DE&lt;/code&gt;&quot; is set, it says that the document is intended for German language speakers (however, it doesn't indicate the document is written in German. For example, it might be written in English as part of a language course for German speakers).</source>
          <target state="translated">Например, если установлено &amp;laquo; &lt;code&gt;Content-Language: de-DE&lt;/code&gt; &amp;raquo;, это говорит о том, что документ предназначен для говорящих на немецком языке (однако это не означает, что документ написан на немецком языке. Например, он может быть написан на Английский как часть языкового курса для говорящих по-немецки).</target>
        </trans-unit>
        <trans-unit id="7c8d24654bcc03695c4c0562fb4fd4f65c41f354" translate="yes" xml:space="preserve">
          <source>For example, if &quot;&lt;code&gt;Content-Language: de-DE&lt;/code&gt;&quot; is set, it says that the document is intended for German language speakers (however, it doesn't indicate the document is written in German. For example, it might be written in English as part of a language course for German speakers. If you want to indicate which language the document is written in, use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;&lt;code&gt;lang&lt;/code&gt; attribute&lt;/a&gt; instead).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931c15cbf1cb0d096c2f7f3977e96a703c6efded" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Domain=mozilla.org&lt;/code&gt; is set, then cookies are available on subdomains like &lt;code&gt;developer.mozilla.org&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6412826a466b2db302aa194f4e3daf55e5d61efd" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Domain=mozilla.org&lt;/code&gt; is set, then cookies are included on subdomains like &lt;code&gt;developer.mozilla.org&lt;/code&gt;.</source>
          <target state="translated">Например, если задано значение &lt;code&gt;Domain=mozilla.org&lt;/code&gt; , файлы cookie включаются в такие поддомены, как &lt;code&gt;developer.mozilla.org&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f88d60c9d2f02ed6a1a1bf95ce9b557bca2dbed6" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Path=/docs&lt;/code&gt; is set, these paths match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0625b9fc57344582bbde2ab4696157ad3f42eb" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Path=/docs&lt;/code&gt; is set, these paths will match:</source>
          <target state="translated">Например, если задано значение &lt;code&gt;Path=/docs&lt;/code&gt; , эти пути будут соответствовать:</target>
        </trans-unit>
        <trans-unit id="fa9700b85e0e01538fcca2eb77f677f69026288f" translate="yes" xml:space="preserve">
          <source>For example, if the page &lt;code&gt;https://service.tld/fetchdata&lt;/code&gt; were requested, and the HTTP response is &quot;301 Moved Permanently&quot;, &quot;307 Temporary Redirect&quot;, or &quot;308 Permanent Redirect&quot; with a &lt;code&gt;Location&lt;/code&gt; of &lt;code&gt;https://anotherservice.net/getdata&lt;/code&gt;, the CORS request will fail in this manner.</source>
          <target state="translated">Например, если страница &lt;code&gt;https://service.tld/fetchdata&lt;/code&gt; было предложено, и ответ HTTP является &quot;301 Moved постоянно&quot;, &quot;307 Temporary Redirect&quot;, или &quot;308 Permanent Redirect&quot; с &lt;code&gt;Location&lt;/code&gt; по &lt;code&gt;https://anotherservice.net/getdata&lt;/code&gt; , запрос CORS не удастся таким образом.</target>
        </trans-unit>
        <trans-unit id="7b87738a4c88c7a7b6a1a09e51a26bf1a734d5d4" translate="yes" xml:space="preserve">
          <source>For example, if the response includes:</source>
          <target state="translated">Например,если ответ включает в себя:</target>
        </trans-unit>
        <trans-unit id="66e0a70fb691c18fbdd0bd050b60e272a1fe413f" translate="yes" xml:space="preserve">
          <source>For example, in Apache, add a line such as the following to the server's configuration (within the appropriate &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; section). The configuration is typically found in a &lt;code&gt;.conf&lt;/code&gt; file (&lt;code&gt;httpd.conf&lt;/code&gt; and &lt;code&gt;apache.conf&lt;/code&gt; are common names for these), or in an &lt;code&gt;.htaccess&lt;/code&gt; file.</source>
          <target state="translated">Например, в Apache добавьте следующую строку в конфигурацию сервера (в соответствующем разделе &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; ). Конфигурация обычно находится в файле &lt;code&gt;.conf&lt;/code&gt; ( их общие имена &lt;code&gt;httpd.conf&lt;/code&gt; и &lt;code&gt;apache.conf&lt;/code&gt; ) или в файле &lt;code&gt;.htaccess&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="619f3c064cc0ce3bc00c710809c1ce33e001a212" translate="yes" xml:space="preserve">
          <source>For example, sending the result of a form:</source>
          <target state="translated">Например,отправка результата формы:</target>
        </trans-unit>
        <trans-unit id="142fdc15f7a89b9c24c2befb228055d091883a52" translate="yes" xml:space="preserve">
          <source>For example, suppose web content at &lt;code&gt;https://foo.example&lt;/code&gt; wishes to invoke content on domain &lt;code&gt;https://bar.other&lt;/code&gt;. Code of this sort might be used in JavaScript deployed on &lt;code&gt;foo.example&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b184b5ed58eb6819039876c32250bc43b4bad555" translate="yes" xml:space="preserve">
          <source>For example, suppose web content on domain &lt;code&gt;http://foo.example&lt;/code&gt; wishes to invoke content on domain &lt;code&gt;http://bar.other&lt;/code&gt;. Code of this sort might be used within JavaScript deployed on foo.example:</source>
          <target state="translated">Например, предположим, что веб-контент в домене &lt;code&gt;http://foo.example&lt;/code&gt; хочет вызвать контент в домене &lt;code&gt;http://bar.other&lt;/code&gt; . Код такого рода может использоваться в JavaScript, развернутом в foo.example:</target>
        </trans-unit>
        <trans-unit id="ac8d0edbbe6f6a992074ea6f9eb0145ef93102b7" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;CONNECT&lt;/code&gt; method can be used to access websites that use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;). The client asks an HTTP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;Proxy server&lt;/a&gt; to tunnel the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Transmission_Control_Protocol_(TCP)&quot;&gt;TCP&lt;/a&gt; connection to the desired destination. The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;Proxy server&lt;/a&gt; continues to proxy the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Transmission_Control_Protocol_(TCP)&quot;&gt;TCP&lt;/a&gt; stream to and from the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d20e4a9531f0f953723ad2bce29ba67c92820b20" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;CONNECT&lt;/code&gt; method can be used to access websites that use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;). The client asks an HTTP Proxy server to tunnel the TCP connection to the desired destination. The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server, the Proxy server continues to proxy the TCP stream to and from the client.</source>
          <target state="translated">Например, метод &lt;code&gt;CONNECT&lt;/code&gt; можно использовать для доступа к веб-сайтам, использующим &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt; ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; ). Клиент просит прокси-сервер HTTP туннелировать TCP-соединение в желаемое место назначения. Затем сервер устанавливает соединение от имени клиента. После того, как соединение было установлено сервером, прокси-сервер продолжает проксировать поток TCP к клиенту и от него.</target>
        </trans-unit>
        <trans-unit id="71916a917e381d9f4baa72eb7d0f481b27298684" translate="yes" xml:space="preserve">
          <source>For example, the following are equivalent:</source>
          <target state="translated">Например,следующее эквивалентно:</target>
        </trans-unit>
        <trans-unit id="0a5e19a07f0f940d54dbc5e573ed269580925a99" translate="yes" xml:space="preserve">
          <source>For example, the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e32905633351c047f12f27629c2b7dbcbd3258eb" translate="yes" xml:space="preserve">
          <source>For example, the server may reject a request if its &lt;a href=&quot;content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; is too large.</source>
          <target state="translated">Например, сервер может отклонить запрос, если его &lt;a href=&quot;content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; слишком велико.</target>
        </trans-unit>
        <trans-unit id="d63752de4fee204887b96a1631e06acc76c5193f" translate="yes" xml:space="preserve">
          <source>For example, this blocks the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; from using the camera and microphone:</source>
          <target state="translated">Например, это блокирует &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; от использования камеры и микрофона:</target>
        </trans-unit>
        <trans-unit id="667503768ab9f00b3c857611676b705bf222dc50" translate="yes" xml:space="preserve">
          <source>For example, to allow a site at https://amazing.site to access the resource using CORS, the header should be:</source>
          <target state="translated">Например,чтобы сайт по адресу https://amazing.site мог получить доступ к ресурсу с помощью CORS,заголовок должен быть:</target>
        </trans-unit>
        <trans-unit id="dc1f722176891e42941f464101332b2ba20f6189" translate="yes" xml:space="preserve">
          <source>For example, to allow code from the origin &lt;code&gt;http://mozilla.org&lt;/code&gt; to access the resource, you can specify:</source>
          <target state="translated">Например, чтобы разрешить коду из источника &lt;code&gt;http://mozilla.org&lt;/code&gt; доступ к ресурсу, вы можете указать:</target>
        </trans-unit>
        <trans-unit id="74f296365850776cc0a36afe6f2ae5336b6c5ffa" translate="yes" xml:space="preserve">
          <source>For example, to allow code from the origin &lt;code&gt;https://mozilla.org&lt;/code&gt; to access the resource, you can specify:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8dcd604f2bec51e5cc439af7d8b146ce60c0ce" translate="yes" xml:space="preserve">
          <source>For example, to block all content from using the Geolocation API across your site:</source>
          <target state="translated">Например,заблокировать весь контент от использования Geolocation API на вашем сайте:</target>
        </trans-unit>
        <trans-unit id="b10aebfe3ed1f1d241d8fb042922d4cfda18c68c" translate="yes" xml:space="preserve">
          <source>For example, when editing MDN, the current wiki content is hashed and put into an &lt;code&gt;Etag&lt;/code&gt; in the response:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2c26aca152b85331257eaf1e9e80e1fb0d82dc" translate="yes" xml:space="preserve">
          <source>For example, your company was renamed, but you want existing links or bookmarks to still find you under the new name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="de2cc7afb113653239fadefd58531368ab6e0fde" translate="yes" xml:space="preserve">
          <source>For historical reasons, the &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME Sniffing Standard&lt;/a&gt; (the definition of how browsers should interpret media types and figure out what to do with content that doesn't have a valid one) allows JavaScript to be served using any MIME type that essentially matches any of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc7ca2973a124b54e9384bba7dd4138b39eb2ca" translate="yes" xml:space="preserve">
          <source>For images, &lt;code&gt;gif&lt;/code&gt; or &lt;code&gt;png&lt;/code&gt; are using loss-less compression.</source>
          <target state="translated">Для изображений в &lt;code&gt;gif&lt;/code&gt; или &lt;code&gt;png&lt;/code&gt; используется сжатие без потерь.</target>
        </trans-unit>
        <trans-unit id="f96d0e055aab7967e098e229f35a70f7d0cf4499" translate="yes" xml:space="preserve">
          <source>For inline styles or styles created from APIs like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;HTMLElement.style&lt;/code&gt;&lt;/a&gt;, the owner document's referrer policy is used.</source>
          <target state="translated">Для встроенных стилей или стилей, созданных из API, таких как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;HTMLElement.style&lt;/code&gt; &lt;/a&gt; , используется политика реферера документа владельца.</target>
        </trans-unit>
        <trans-unit id="84bf50840f620c842f8d504aeebea80f2ae78a0a" translate="yes" xml:space="preserve">
          <source>For locking mechanisms, it is the opposite: Web developers need to issue a request with the proper headers, while webmasters can mostly rely on the application to carry out the checks for them.</source>
          <target state="translated">Для запирающих механизмов все наоборот:Веб-разработчикам необходимо выдавать запрос с соответствующими заголовками,в то время как веб-мастера могут в основном полагаться на приложение для проведения проверок.</target>
        </trans-unit>
        <trans-unit id="05bc2f18a1040cbebb023b0b22da7d3057050814" translate="yes" xml:space="preserve">
          <source>For more details on Firefox and Gecko based user agent strings, see the &lt;a href=&quot;user-agent/firefox&quot;&gt;Firefox user agent string reference&lt;/a&gt;. The UA string of Firefox itself is broken down into four components:</source>
          <target state="translated">Дополнительные сведения о строках пользовательских агентов на основе Firefox и Gecko см. В &lt;a href=&quot;user-agent/firefox&quot;&gt;справочнике по&lt;/a&gt; строкам пользовательских агентов Firefox . Строка UA самого Firefox разбита на четыре компонента:</target>
        </trans-unit>
        <trans-unit id="1512d2a0f3572c16865118ba125042228226dfbe" translate="yes" xml:space="preserve">
          <source>For more details on autoplay and autoplay blocking, see the article &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide&quot;&gt;Autoplay guide for media and Web Audio APIs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d24847af6c0b28f664c1b1ecd25eca36f5dc16" translate="yes" xml:space="preserve">
          <source>For more details see &lt;a href=&quot;feature_policy/using_feature_policy&quot;&gt;Using Feature Policy&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительных сведений см. &lt;a href=&quot;feature_policy/using_feature_policy&quot;&gt;Использование политики функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f2fd29856862ed0ab79e6861cc4858f4155a7dc" translate="yes" xml:space="preserve">
          <source>For more details, see also the &lt;a href=&quot;#Freshness&quot;&gt;Freshness&lt;/a&gt; section below.</source>
          <target state="translated">Для получения дополнительных сведений см. Также раздел &amp;laquo; &lt;a href=&quot;#Freshness&quot;&gt;Свежесть&lt;/a&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="5761c54fb5552b444dde1792f6afdb1a5c918baa" translate="yes" xml:space="preserve">
          <source>For more information about cookie prefixes and the current state of browser support, see the &lt;a href=&quot;headers/set-cookie#Cookie_prefixes&quot;&gt;Prefixes section of the Set-Cookie reference article&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a6b38e5e421526b3d5933f3b867e718bd90436" translate="yes" xml:space="preserve">
          <source>For more information, see also this article on &lt;a href=&quot;../csp&quot;&gt;Content Security Policy (CSP)&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. Также эту статью о &lt;a href=&quot;../csp&quot;&gt;политике безопасности контента (CSP)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07a2c7640b2fa8de34fac3055d8b39541b74752f" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;../cookies&quot;&gt;guide on HTTP cookies&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3aa6b680bc6518edc5c36b2eb482864b073f5d2" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP Public Key Pinning&lt;/a&gt; article.</source>
          <target state="translated">Дополнительные сведения см. В статье &amp;laquo; &lt;a href=&quot;../public_key_pinning&quot;&gt;Закрепление открытого ключа HTTP&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6388d0122d4c6699e1cf73b26f4fab54e1e4ece" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; header reference page and the &lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP Public Key Pinning&lt;/a&gt; article.</source>
          <target state="translated">Для получения дополнительной информации см. Справочную страницу заголовка &lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt; и статью &lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP Public Key Pinning&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16d858e940de2d5add12c93eacce99796fbd8dc3" translate="yes" xml:space="preserve">
          <source>For more information, see the guide on &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения см. В руководстве по &lt;a href=&quot;../cookies&quot;&gt;файлам cookie HTTP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6025b5f65ce2bedee9e205665e9c4e24e2e5b2f7" translate="yes" xml:space="preserve">
          <source>For more information, see the introductory article on &lt;a href=&quot;../csp&quot;&gt;Content Security Policy (CSP)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf003bb7d49f08a37fe6d4505f868da1702a5d5" translate="yes" xml:space="preserve">
          <source>For more information, see the main &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTTP/Feature_Policy&quot;&gt;Feature Policy&lt;/a&gt; article.</source>
          <target state="translated">Дополнительные сведения см. В основной статье о &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTTP/Feature_Policy&quot;&gt;политике функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e6566bd07adb3ff65425532a199412494bb4520" translate="yes" xml:space="preserve">
          <source>For more on Firefox- and Gecko-based user agent strings, see the &lt;a href=&quot;user-agent/firefox&quot;&gt;Firefox user agent string reference&lt;/a&gt;. The UA string of Firefox is broken down into 4 components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c13a01882beedd60ef040f694851d73933cf613" translate="yes" xml:space="preserve">
          <source>For more prevention tips, see the &lt;a href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet&quot;&gt;OWASP CSRF prevention cheat sheet&lt;/a&gt;.</source>
          <target state="translated">Дополнительные советы по предотвращению см. В &lt;a href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet&quot;&gt;памятке по предотвращению ошибок OWASP CSRF&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b991665d6c852df1848b14e1c2237629d3e471a4" translate="yes" xml:space="preserve">
          <source>For more, see &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_cookie#EU_cookie_directive&quot;&gt;this Wikipedia section&lt;/a&gt; and consult state laws for the latest and most accurate information.</source>
          <target state="translated">Дополнительную информацию можно найти в &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_cookie#EU_cookie_directive&quot;&gt;этом разделе Википедии&lt;/a&gt; и в законах штата, чтобы получить самую свежую и точную информацию.</target>
        </trans-unit>
        <trans-unit id="16bc316a5e9428e01ce42d164953682ad4eeadaf" translate="yes" xml:space="preserve">
          <source>For multipart entities the &lt;code&gt;boundary&lt;/code&gt; directive is required, which consists of 1 to 70 characters from a set of characters known to be very robust through email gateways, and not ending with white space. It is used to encapsulate the boundaries of the multiple parts of the message. Often the header boundary is prepended by two dashes in the body and the final boundary also have a two dashes appended to it.</source>
          <target state="translated">Для составных объектов требуется &lt;code&gt;boundary&lt;/code&gt; директива, которая состоит из от 1 до 70 символов из набора символов, которые, как известно, очень надежны для шлюзов электронной почты, и не заканчиваются пробелами. Он используется для инкапсуляции границ нескольких частей сообщения. Часто к границе заголовка добавляются два тире в теле, а к последней границе добавляются два тире.</target>
        </trans-unit>
        <trans-unit id="7c3aed89e6dab97831be498c22ad6502ef3a5cd6" translate="yes" xml:space="preserve">
          <source>For multipart entities the &lt;code&gt;boundary&lt;/code&gt; directive is required, which consists of 1 to 70 characters from a set of characters known to be very robust through email gateways, and not ending with white space. It is used to encapsulate the boundaries of the multiple parts of the message. Often, the header boundary is prepended with two dashes and the final boundary has two dashes appended at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="093b1094cde6e7f4f4d8f8b971af7a8990963019" translate="yes" xml:space="preserve">
          <source>For new content, you can start developing with a policy that disables all the features. This approach ensures that none of the functionality is introduced. When applying a policy to existing content, testing is likely required to verify it continues to work as expected. This is especially important for embedded or third-party content that you do not control.</source>
          <target state="translated">Для нового контента вы можете начать разработку с политики,которая отключает все функции.Такой подход гарантирует,что ни одна из функций не будет введена.При применении политики к существующему контенту,скорее всего,потребуется тестирование,чтобы убедиться в том,что он продолжает работать,как и ожидалось.Это особенно важно для встроенного контента или контента сторонних производителей,который вы не контролируете.</target>
        </trans-unit>
        <trans-unit id="2f39ad9de038e309432fa2abc7e02992cadbd96a" translate="yes" xml:space="preserve">
          <source>For nginx, you will need to specify a location that you are going to protect and the &lt;code&gt;auth_basic&lt;/code&gt; directive that provides the name to the password-protected area. The &lt;code&gt;auth_basic_user_file&lt;/code&gt; directive then points to a .htpasswd file containing the encrypted user credentials, just like in the Apache example above.</source>
          <target state="translated">Для nginx вам нужно будет указать местоположение, которое вы собираетесь защищать, и директиву &lt;code&gt;auth_basic&lt;/code&gt; , которая предоставляет имя защищенной паролем области. &lt;code&gt;auth_basic_user_file&lt;/code&gt; директива затем указывает на .htpasswd файл , содержащий зашифрованные учетные данные пользователя, так же , как в примере Apache выше.</target>
        </trans-unit>
        <trans-unit id="b60310977b1322aae7188c84f1d2bec064596b5e" translate="yes" xml:space="preserve">
          <source>For nginx, you will need to specify a location that you are going to protect and the &lt;code&gt;auth_basic&lt;/code&gt; directive that provides the name to the password-protected area. The &lt;code&gt;auth_basic_user_file&lt;/code&gt; directive then points to a &lt;code&gt;.htpasswd&lt;/code&gt; file containing the encrypted user credentials, just like in the Apache example above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70553b80e8be103814c1eb5f51fa3a904090e239" translate="yes" xml:space="preserve">
          <source>For other methods, and in particular for &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-Match&lt;/code&gt; can be used to prevent the &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;lost update problem&lt;/a&gt;. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) response is returned.</source>
          <target state="translated">Для других методов, и в частности для &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;If-Match&lt;/code&gt; может использоваться для предотвращения &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;проблемы потери обновления&lt;/a&gt; . Он может проверить, не отменит ли изменение ресурса, который пользователь хочет загрузить, другое изменение, которое было выполнено с момента получения исходного ресурса. Если запрос не может быть выполнен, возвращается ответ &lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; (ошибка предварительного условия).</target>
        </trans-unit>
        <trans-unit id="538225086d2d3b055913158dd5b4c3b9bfc1f097" translate="yes" xml:space="preserve">
          <source>For other methods, and in particular for &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-None-Match&lt;/code&gt; used with the &lt;code&gt;*&lt;/code&gt; value can be used to save a file not known to exist, guaranteeing that another upload didn't happen before, losing the data of the previous put; this problem is a variation of the &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;lost update problem&lt;/a&gt;.</source>
          <target state="translated">Для других методов, и, в частности, для &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;If-None-Match&lt;/code&gt; , используемое со значением &lt;code&gt;*&lt;/code&gt; , может использоваться для сохранения файла, о существовании которого не известно, гарантируя, что другая загрузка не произошла раньше, теряя данные предыдущего помещения; эта проблема является разновидностью &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;проблемы&lt;/a&gt; с утерянным обновлением .</target>
        </trans-unit>
        <trans-unit id="89936fcb3c720f2a1e2c92027641b334e9357ffd" translate="yes" xml:space="preserve">
          <source>For other products based on Gecko, the string can take one of two forms, where the tokens have the same meaning except those noted below:</source>
          <target state="translated">Для других продуктов,основанных на Gecko,строка может принимать одну из двух форм,где токены имеют одинаковое значение,за исключением отмеченных ниже:</target>
        </trans-unit>
        <trans-unit id="907135173500e7b45556d497127edb70bd3fb716" translate="yes" xml:space="preserve">
          <source>For reasons of security and privacy, it is necessary to make a
   distinction between &quot;shared&quot; and &quot;non-shared&quot; caches. A non-shared
   cache is one that is accessible only to a single user. Accessibility
   in this case SHOULD be enforced by appropriate security mechanisms.
   All other caches are considered to be &quot;shared.&quot; Other sections of 

   this specification place certain constraints on the operation of
   shared caches in order to prevent loss of privacy or failure of
   access controls.</source>
          <target state="translated">По соображениям безопасности и конфиденциальности необходимо проводить различие между &quot;общим&quot; и &quot;несовместным&quot; кэшами.Необщий кэш-это кэш,доступный только одному пользователю.Доступность в этом случае ДОЛЖНА быть обеспечена соответствующими механизмами безопасности.Все остальные кэши считаются &quot;общими&quot;.Другие разделы данной спецификации накладывают определенные ограничения на работу с общими кэшами,чтобы предотвратить потерю приватности или сбой в управлении доступом.</target>
        </trans-unit>
        <trans-unit id="257548a557c142ce44b1aa876c1f52d0b2cfeb6c" translate="yes" xml:space="preserve">
          <source>For requests &lt;em&gt;without credentials&lt;/em&gt;, the literal value &quot;*&quot; can be specified, as a wildcard; the value tells browsers to allow requesting code from any origin to access the resource. Attempting to use the wildcard with credentials &lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;will result in an error&lt;/a&gt;.</source>
          <target state="translated">Для запросов &lt;em&gt;без учетных данных&lt;/em&gt; можно указать буквальное значение &amp;laquo;*&amp;raquo; в качестве подстановочного знака; значение указывает браузерам разрешить запрос кода из любого источника для доступа к ресурсу. Попытка использовать подстановочный знак с учетными данными &lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;приведет к ошибке&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c5ca72995d97f0458eaf84378300b9b55e7ea55" translate="yes" xml:space="preserve">
          <source>For requests &lt;em&gt;without credentials&lt;/em&gt;, the literal value &quot;&lt;code&gt;*&lt;/code&gt;&quot; can be specified, as a wildcard; the value tells browsers to allow requesting code from any origin to access the resource. Attempting to use the wildcard with credentials &lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;will result in an error&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a1bfce12feb1fb720a7fe1100883e79f123be1" translate="yes" xml:space="preserve">
          <source>For security reasons, browsers restrict cross-origin HTTP requests initiated from scripts. For example, &lt;code&gt;XMLHttpRequest&lt;/code&gt; and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; follow the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. This means that a web application using those APIs can only request resources from the same origin the application was loaded from unless the response from other origins includes the right CORS headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351e6c404b20eecdc808fd67608ccc7928ea6386" translate="yes" xml:space="preserve">
          <source>For security reasons, browsers restrict cross-origin HTTP requests initiated from within scripts. For example, &lt;code&gt;XMLHttpRequest&lt;/code&gt; and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; follow the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. This means that a web application using those APIs can only request HTTP resources from the same origin the application was loaded from, unless the response from the other origin includes the right CORS headers.</source>
          <target state="translated">По соображениям безопасности браузеры ограничивают HTTP-запросы из разных источников, инициируемые из скриптов. Например, &lt;code&gt;XMLHttpRequest&lt;/code&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; следуют &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;политике одного источника&lt;/a&gt; . Это означает, что веб-приложение, использующее эти API, может запрашивать ресурсы HTTP только из того же источника, из которого было загружено приложение, если только ответ из другого источника не включает правильные заголовки CORS.</target>
        </trans-unit>
        <trans-unit id="ee3a9635da3f4811be8395ffd6f2c7c100ed7868" translate="yes" xml:space="preserve">
          <source>For text documents without a specific subtype, &lt;code&gt;text/plain&lt;/code&gt; should be used.</source>
          <target state="translated">Для текстовых документов без определенного подтипа следует использовать &lt;code&gt;text/plain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cb9d98048f241ce3bdc766680c13b98ba44670c" translate="yes" xml:space="preserve">
          <source>For text documents without a specific subtype, &lt;code&gt;text/plain&lt;/code&gt; should be used. Similarly, for binary documents without a specific or known subtype, &lt;code&gt;application/octet-stream&lt;/code&gt; should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01fd2dd2707385a8305b768f33bb65eb7bcb3f6d" translate="yes" xml:space="preserve">
          <source>For the files in the application that will not change, you can usually add aggressive caching by sending the response header below. This includes static files that are served by the application such as images, CSS files and JavaScript files, for example. In addition, see also the &lt;code&gt;Expires&lt;/code&gt; header.</source>
          <target state="translated">Для файлов в приложении, которые не будут меняться, обычно можно добавить агрессивное кеширование, отправив заголовок ответа ниже. Сюда входят статические файлы, которые обслуживаются приложением, например изображения, файлы CSS и файлы JavaScript. Кроме того, см. Также заголовок &lt;code&gt;Expires&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47f9208ec82cf7fb7519a3acacb255f0ed8d2472" translate="yes" xml:space="preserve">
          <source>For the purpose of defining the behavior of caches and non-caching
   proxies, we divide HTTP headers into two categories:

      - End-to-end headers, which are  transmitted to the ultimate
        recipient of a request or response. End-to-end headers in
        responses MUST be stored as part of a cache entry and MUST be
        transmitted in any response formed from a cache entry.

      - Hop-by-hop headers, which are meaningful only for a single
        transport-level connection, and are not stored by caches or
        forwarded by proxies.

   The following HTTP/1.1 headers are hop-by-hop headers:

      - Connection
      - Keep-Alive
      - Proxy-Authenticate
      - Proxy-Authorization
      - TE
      - Trailers
      - Transfer-Encoding
      - Upgrade

   All other headers defined by HTTP/1.1 are end-to-end headers.

   Other hop-by-hop headers MUST be listed in a Connection header,
   (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) to be introduced into HTTP/1.1 (or later).</source>
          <target state="translated">С целью определения поведения кешей и некэширующих прокси-серверов мы делим HTTP-заголовки на две категории: - Сквозные заголовки, которые передаются конечному получателю запроса или ответа. Сквозные заголовки в ответах ДОЛЖНЫ храниться как часть записи кэша и ДОЛЖНЫ передаваться в любом ответе, сформированном из записи кэша. - Поэтапные заголовки, которые имеют смысл только для одного соединения транспортного уровня, не хранятся в кэшах и не пересылаются прокси-серверами. Следующие заголовки HTTP / 1.1 являются пошаговыми заголовками: - Connection - Keep-Alive - Proxy-Authenticate - Proxy-Authorization - TE - Trailers - Transfer-Encoding - Upgrade Все остальные заголовки, определенные HTTP / 1.1, являются сквозными. -end заголовки.Другие пошаговые заголовки ДОЛЖНЫ быть перечислены в заголовке соединения, (&lt;a href=&quot;#section-14.10&quot;&gt;раздел 14.10&lt;/a&gt; ) для включения в HTTP / 1.1 (или новее).</target>
        </trans-unit>
        <trans-unit id="21bafa062922688ae091d5ac581f85b2253ab9b7" translate="yes" xml:space="preserve">
          <source>For these reasons, pipelining has been superseded by a better algorithm, &lt;em&gt;multiplexing&lt;/em&gt;, that is used by HTTP/2.</source>
          <target state="translated">По этим причинам конвейерная обработка была заменена более совершенным алгоритмом &lt;em&gt;мультиплексирования&lt;/em&gt; , который используется в HTTP / 2.</target>
        </trans-unit>
        <trans-unit id="e0fe7bfcb91231799d489fc2723d6dd4bbc0c043" translate="yes" xml:space="preserve">
          <source>Forbidden header name</source>
          <target state="translated">Запрещенное имя заголовка</target>
        </trans-unit>
        <trans-unit id="f09e76e0b403d1bc7b01b5a7432c7aadcdb4a81e" translate="yes" xml:space="preserve">
          <source>Forbidden response-header name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecdbc655eb3ebf83109410af71e822cca4455369" translate="yes" xml:space="preserve">
          <source>Forbids JavaScript from accessing the cookie, for example, through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; property. Note that a cookie that has been created with HttpOnly will still be sent with JavaScript-initiated requests, e.g. when calling &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send&quot;&gt;&lt;code&gt;XMLHttpRequest.send()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch&quot;&gt;&lt;code&gt;fetch()&lt;/code&gt;&lt;/a&gt;. This mitigates attacks against cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b412bc69411dace0d04398d6ef301aa1c667a968" translate="yes" xml:space="preserve">
          <source>Force communication using HTTPS instead of HTTP.</source>
          <target state="translated">Принудительная коммуникация с использованием HTTPS вместо HTTP.</target>
        </trans-unit>
        <trans-unit id="eef9c57759e4f6a908b3d969fe32e4b1fa5c2a10" translate="yes" xml:space="preserve">
          <source>Forced prefetching of hostnames might be useful, for example, on the homepage of a site to force pre-resolution of domain names that are referenced frequently throughout the site even though they are not used on the home page itself. This will improve the overall performance of site even though the performance of the home page may not be affected.</source>
          <target state="translated">Принудительная предварительная выборка имен хостов может быть полезна,например,на главной странице сайта для принуждения к предварительному разрешению доменных имен,на которые часто ссылаются по всему сайту,даже если они не используются на самой главной странице.Это улучшит общую работоспособность сайта,даже если на работоспособность главной страницы это не повлияет.</target>
        </trans-unit>
        <trans-unit id="07c90eda5719a0767b7585d1fae63b890d2df734" translate="yes" xml:space="preserve">
          <source>Forces caches to submit the request to the origin server for validation before releasing a cached copy.</source>
          <target state="translated">Заставляет кэш отправить запрос на исходный сервер для проверки перед выпуском кэшированной копии.</target>
        </trans-unit>
        <trans-unit id="5e4ea8df1ce37991d82f8682bf378d09968f9b0d" translate="yes" xml:space="preserve">
          <source>Forcing &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/https&quot;&gt;HTTPS&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4634694667d40eda0bbe0a5024383a25099b93b8" translate="yes" xml:space="preserve">
          <source>Forcing HTTPS. Requests to the HTTP version of your site will be redirected to the HTTPS version of your site.</source>
          <target state="translated">Форсирование HTTPS.Запросы на HTTP-версию вашего сайта будут перенаправлены на HTTPS-версию вашего сайта.</target>
        </trans-unit>
        <trans-unit id="e65113ef7489ad2e3e6bcd61586a5a6e130fc3a1" translate="yes" xml:space="preserve">
          <source>Forcing lookup of specific hostnames</source>
          <target state="translated">Принудительный поиск конкретных имен хостов</target>
        </trans-unit>
        <trans-unit id="ab88e44a21e56a74ea52f9806dd114accfebc6fd" translate="yes" xml:space="preserve">
          <source>Form factor</source>
          <target state="translated">Форм-фактор</target>
        </trans-unit>
        <trans-unit id="d4287342eaedf156edc375518b5469130015c5b1" translate="yes" xml:space="preserve">
          <source>Formatting in HTML</source>
          <target state="translated">Форматирование в HTML</target>
        </trans-unit>
        <trans-unit id="72574aaae0c03841c4924b83ccaa181535815a29" translate="yes" xml:space="preserve">
          <source>Fortunately, as long as you have access to the server's configuration, fixing this is easy. The &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header supports multiple origins, separated by commas, like this:</source>
          <target state="translated">К счастью, если у вас есть доступ к конфигурации сервера, это легко исправить. &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; заголовка поддерживает несколько генеза, разделенных запятыми, например:</target>
        </trans-unit>
        <trans-unit id="88300ac449331e8942e45db76cb6c950d0433ba5" translate="yes" xml:space="preserve">
          <source>Forward proxies</source>
          <target state="translated">Форвардные прокси</target>
        </trans-unit>
        <trans-unit id="f39bbf5e0d44588e0ee44ca9d11dbdff07723664" translate="yes" xml:space="preserve">
          <source>Forward proxies can also be anonymous proxies and allow users to hide their IP address while browsing the Web or using other Internet services. &lt;a href=&quot;https://www.torproject.org/&quot;&gt;TOR&lt;/a&gt; (The Onion Router), routes internet traffic through multiple proxies for anonymity.</source>
          <target state="translated">Прямые прокси-серверы также могут быть анонимными прокси-серверами и позволяют пользователям скрывать свой IP-адрес при просмотре веб-страниц или использовании других интернет-служб. &lt;a href=&quot;https://www.torproject.org/&quot;&gt;TOR&lt;/a&gt; (луковый маршрутизатор) направляет интернет-трафик через несколько прокси-серверов для анонимности.</target>
        </trans-unit>
        <trans-unit id="5e96e7529d107df0e1753fe21bd01b67d79778d3" translate="yes" xml:space="preserve">
          <source>Forwarded</source>
          <target state="translated">Forwarded</target>
        </trans-unit>
        <trans-unit id="879b7cb814cbc842f6566b4b5009e2ae4c5e4256" translate="yes" xml:space="preserve">
          <source>Forwarded HTTP Extension</source>
          <target state="translated">Переадресованное расширение HTTP</target>
        </trans-unit>
        <trans-unit id="a751a7c6f5ebc769cdda2c0d60519a9100785f00" translate="yes" xml:space="preserve">
          <source>Forwarding client information through proxies</source>
          <target state="translated">Пересылка информации о клиенте через прокси-серверы</target>
        </trans-unit>
        <trans-unit id="3f19d616ab1973eab54443edad1f469f67e51a95" translate="yes" xml:space="preserve">
          <source>Fragment</source>
          <target state="translated">Fragment</target>
        </trans-unit>
        <trans-unit id="7bf6780ba1203e0c37a2bbe6f2b29b2481023856" translate="yes" xml:space="preserve">
          <source>Frame and message structure in HTTP/2</source>
          <target state="translated">Фрейм и структура сообщения в HTTP/2</target>
        </trans-unit>
        <trans-unit id="5b968bd2c47b3621328bcde661b5d00bbb234e51" translate="yes" xml:space="preserve">
          <source>Freshness</source>
          <target state="translated">Freshness</target>
        </trans-unit>
        <trans-unit id="71fec796b8ce84752a371f57c6e5fa7e23101e6f" translate="yes" xml:space="preserve">
          <source>Freshness (RFC 7234)</source>
          <target state="translated">Свежесть (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="061140cd8957c1a20500ec4735145a4823d87854" translate="yes" xml:space="preserve">
          <source>From (RFC 2616)</source>
          <target state="translated">Из (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="ab25ccd00949ff6aec782bce24f64f443ae8183b" translate="yes" xml:space="preserve">
          <source>From (RFC 7231)</source>
          <target state="translated">Из (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="fc8df84d4beeac0f9b5f8d6d828c77f7b287a76a" translate="yes" xml:space="preserve">
          <source>From the beginnings of HTTP, the protocol allowed another negotiation type: &lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;. In this negotiation, when facing an ambiguous request, the server sends back a page containing links to the available alternative resources. The user is presented the resources and choose the one to use.</source>
          <target state="translated">С самого начала HTTP протокол допускал другой тип согласования: &lt;em&gt;согласование, управляемое агентом,&lt;/em&gt; или &lt;em&gt;реактивное согласование&lt;/em&gt; . В этом согласовании, когда встречается неоднозначный запрос, сервер отправляет обратно страницу, содержащую ссылки на доступные альтернативные ресурсы. Пользователь получает ресурсы и выбирает тот, который использовать.</target>
        </trans-unit>
        <trans-unit id="2a0830997625a669017113736869c02cdf00c6fb" translate="yes" xml:space="preserve">
          <source>From version 1, Focus is powered by Android WebView and uses the following user agent string format:</source>
          <target state="translated">Начиная с версии 1,Focus работает на Android WebView и использует следующий формат строк агента пользователя:</target>
        </trans-unit>
        <trans-unit id="bf2dddbd41ffb807d3f91b7c00d45658b62cbe7d" translate="yes" xml:space="preserve">
          <source>From version 1.1, Firefox for Echo Show uses a user agent string with the following format:</source>
          <target state="translated">Начиная с версии 1.1,Firefox for Echo Show использует строку агента пользователя со следующим форматом:</target>
        </trans-unit>
        <trans-unit id="b65dd0e7d73eba5ec8f68b41e102211c26e17c9c" translate="yes" xml:space="preserve">
          <source>From version 53 onwards, Gecko has a pref available in &lt;code&gt;about:config&lt;/code&gt; to allow users to set their default &lt;code&gt;Referrer-Policy&lt;/code&gt; &amp;mdash; &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="634b1e47168d224b18cc5d200468a1a666ff4f5b" translate="yes" xml:space="preserve">
          <source>From version 53 onwards, Gecko has a pref available in &lt;code&gt;about:config&lt;/code&gt; to allow users to set their default &lt;code&gt;Referrer-Policy&lt;/code&gt;&amp;mdash; &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt;.</source>
          <target state="translated">Начиная с версии 53, у Gecko в &lt;code&gt;about:config&lt;/code&gt; есть настройка, позволяющая пользователям устанавливать свою &lt;code&gt;Referrer-Policy&lt;/code&gt; &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt; умолчанию - network.http.referer.userControlPolicy .</target>
        </trans-unit>
        <trans-unit id="f46e7fd368eae55073e0a8f47aee34fcd932ec29" translate="yes" xml:space="preserve">
          <source>From version 59 onwards (See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=587523&quot;&gt;#587523&lt;/a&gt;), this has been replaced by &lt;code&gt;network.http.referer.defaultPolicy&lt;/code&gt; and &lt;code&gt;network.http.referer.defaultPolicy.pbmode&lt;/code&gt;.</source>
          <target state="translated">Начиная с версии 59 (см. &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=587523&quot;&gt;# 587523&lt;/a&gt; ), он был заменен на &lt;code&gt;network.http.referer.defaultPolicy&lt;/code&gt; и &lt;code&gt;network.http.referer.defaultPolicy.pbmode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d0bf1cf951361338f44d3f633af3e9f659dd546" translate="yes" xml:space="preserve">
          <source>From version 82, if an &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; element's &lt;code&gt;download&lt;/code&gt; attribute is set (for a same-origin URL) then the &lt;code&gt;inline&lt;/code&gt; directive is ignored. Earlier versions did not match the specification and respected the header directive over the attribute. See &lt;a href=&quot;https://bugzil.la/1658877&quot;&gt;bug 1658877&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb08d10b00a6114f53ac03b662cd5c0fa2fadf2c" translate="yes" xml:space="preserve">
          <source>Fullscreen</source>
          <target state="translated">Fullscreen</target>
        </trans-unit>
        <trans-unit id="d1c21c81f5e9278875fd7faba9e8ce5fee900412" translate="yes" xml:space="preserve">
          <source>Fullscreen API&lt;br/&gt;&lt;small&gt;The definition of 'Fullscreen' in that specification.&lt;/small&gt;</source>
          <target state="translated">Полноэкранный API &lt;br/&gt;&lt;small&gt;Определение &amp;laquo;полноэкранного режима&amp;raquo; в этой спецификации.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9cf4076ad8ca1d493e56ac7306efcb34aa07f0cd" translate="yes" xml:space="preserve">
          <source>Fully qualified hostname to match against.</source>
          <target state="translated">Полностью квалифицированный хозяин матча против.</target>
        </trans-unit>
        <trans-unit id="70e18d39d91b0bb23213a714597ec6ac0a18898d" translate="yes" xml:space="preserve">
          <source>Functional overview</source>
          <target state="translated">Обзор функций</target>
        </trans-unit>
        <trans-unit id="d121b74dc433c61707ecf2145f14c0087235e9c1" translate="yes" xml:space="preserve">
          <source>Further extensions to the request are required for the server to fulfil it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859debff3eb6a95e21550e12eaa3e9501db63349" translate="yes" xml:space="preserve">
          <source>Further extensions to the request are required for the server to fulfill it.</source>
          <target state="translated">Для его выполнения серверу необходимо дополнительное расширение запроса.</target>
        </trans-unit>
        <trans-unit id="c09cf39e0efd384b99059d76f22ce0c68ab74478" translate="yes" xml:space="preserve">
          <source>Furthermore, some default values of preferences differ between build configurations, such as platform and locale, which means web sites could identify individual users using this information.</source>
          <target state="translated">Кроме того,некоторые значения предпочтений по умолчанию различаются между конфигурациями сборки,такими как платформа и локаль,что означает,что веб-сайты могут идентифицировать отдельных пользователей,используя эту информацию.</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="828d617ffbd78d6822f9aa5a1a25e2e9a6f4041d" translate="yes" xml:space="preserve">
          <source>GET (RFC 7231)</source>
          <target state="translated">GET (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="889241fb06a8d7a9634f3ef3d8c354487e92626b" translate="yes" xml:space="preserve">
          <source>GET: The resource has been fetched and is transmitted in the message body.</source>
          <target state="translated">GET:Ресурс получен и передан в теле сообщения.</target>
        </trans-unit>
        <trans-unit id="758f6c9347b91091c38ad698a8eba6aeac47b9c4" translate="yes" xml:space="preserve">
          <source>GIF</source>
          <target state="translated">GIF</target>
        </trans-unit>
        <trans-unit id="ad6e940d0a1449c3f043c3a92ac96eacb89d1691" translate="yes" xml:space="preserve">
          <source>GIF images (lossless compression, superseded by PNG)</source>
          <target state="translated">GIF-изображения (сжатие без потерь,заменено PNG)</target>
        </trans-unit>
        <trans-unit id="d84234ce9f95c2df9a9cb91648dc0629d7b55a78" translate="yes" xml:space="preserve">
          <source>GMT</source>
          <target state="translated">GMT</target>
        </trans-unit>
        <trans-unit id="352e09ef4c24f106ac21c027ee173d9c89b53400" translate="yes" xml:space="preserve">
          <source>GZip Compressed Archive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b0db79f60240a0079907f498493dc26899f285" translate="yes" xml:space="preserve">
          <source>Gateway or multiple parties. The server is acting as a gateway to an exchange involving multiple parties.</source>
          <target state="translated">Шлюз или несколько вечеринок.Сервер действует в качестве шлюза для обмена с участием нескольких сторон.</target>
        </trans-unit>
        <trans-unit id="75402c80a4e4ffb05b2e1744866544933eef7e16" translate="yes" xml:space="preserve">
          <source>Gecko</source>
          <target state="translated">Gecko</target>
        </trans-unit>
        <trans-unit id="d377c8358e2e4b422fb5f7dadb1f64fb8c95cca2" translate="yes" xml:space="preserve">
          <source>Gecko user agent string</source>
          <target state="translated">строка агента пользователя Gecko</target>
        </trans-unit>
        <trans-unit id="64f2d81db08b8b5b6d065aef938e7abd5e149546" translate="yes" xml:space="preserve">
          <source>Gecko version number</source>
          <target state="translated">номер версии Gecko</target>
        </trans-unit>
        <trans-unit id="ab051d4c4633073d92cf5eecdf9929aa43fd1d4b" translate="yes" xml:space="preserve">
          <source>Gecko/xyz</source>
          <target state="translated">Gecko/xyz</target>
        </trans-unit>
        <trans-unit id="40fe0205052be8e7ff127e8675aa5f542d969bde" translate="yes" xml:space="preserve">
          <source>General example</source>
          <target state="translated">Общий пример</target>
        </trans-unit>
        <trans-unit id="8fccc069576bf17f5e7e17b4b3c176d69ed30562" translate="yes" xml:space="preserve">
          <source>General form</source>
          <target state="translated">Общая форма</target>
        </trans-unit>
        <trans-unit id="c1e2a5611d6d492bfc81f68a60efadd4f6151c4e" translate="yes" xml:space="preserve">
          <source>General header</source>
          <target state="translated">Главный заголовок</target>
        </trans-unit>
        <trans-unit id="ce7515fe427724c3a8ec1e689f1513ade3494a01" translate="yes" xml:space="preserve">
          <source>General structure</source>
          <target state="translated">Общая структура</target>
        </trans-unit>
        <trans-unit id="5739e547142aa8443b5825e26cdfefcbe00318e3" translate="yes" xml:space="preserve">
          <source>General warning information about possible problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee8f734456eeec6f1528c29e7b9dd676c82ba5c" translate="yes" xml:space="preserve">
          <source>Geolocation</source>
          <target state="translated">Geolocation</target>
        </trans-unit>
        <trans-unit id="85b8d61e7354b7736b7ec8ca91e1105f85435b65" translate="yes" xml:space="preserve">
          <source>Given this CSP header:</source>
          <target state="translated">Учитывая этот заголовок CSP:</target>
        </trans-unit>
        <trans-unit id="4e8b70f78453a41b0760bb603aa5281fa0436163" translate="yes" xml:space="preserve">
          <source>Glossary: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;</source>
          <target state="translated">Глоссарий: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f179b6f36465b5aac2f67605586252775def9c70" translate="yes" xml:space="preserve">
          <source>Good:</source>
          <target state="translated">Good:</target>
        </trans-unit>
        <trans-unit id="bad9e9df904c73f497b664b045343bef194565df" translate="yes" xml:space="preserve">
          <source>Google Chrome handles DNS prefetching control</source>
          <target state="translated">Google Chrome обрабатывает управление предварительной настройкой DNS</target>
        </trans-unit>
        <trans-unit id="4d6910e3810a19ca345b6c8578f0e4ba472ba3b8" translate="yes" xml:space="preserve">
          <source>Google Docs CORB explainer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e389ee93fcba3ef467be442186c13f4427744a6" translate="yes" xml:space="preserve">
          <source>Google Webmaster blog: How to deal with planned site downtime</source>
          <target state="translated">Блог Google Webmaster:Как справиться с запланированным временем простоя сайта</target>
        </trans-unit>
        <trans-unit id="ea0c0aed6cf9a0c5b577d1e3a89cbf79500b4710" translate="yes" xml:space="preserve">
          <source>Google maintains &lt;a href=&quot;https://hstspreload.appspot.com/&quot;&gt;an HSTS preload service&lt;/a&gt;. By following the guidelines and successfully submitting your domain, browsers will never connect to your domain using an insecure connection. While the service is hosted by Google, all browsers have stated an intent to use (or actually started using) the preload list. However, it is not part of the HSTS specification and should not be treated as official.</source>
          <target state="translated">Google поддерживает &lt;a href=&quot;https://hstspreload.appspot.com/&quot;&gt;службу предварительной загрузки HSTS&lt;/a&gt; . Следуя инструкциям и успешно отправив свой домен, браузеры никогда не будут подключаться к вашему домену через небезопасное соединение. Хотя сервис размещен в Google, все браузеры заявили о намерении использовать (или фактически начали использовать) список предварительной загрузки. Однако он не является частью спецификации HSTS и не должен рассматриваться как официальный.</target>
        </trans-unit>
        <trans-unit id="60827ebdcf1686e9d01ea4b0e1ab1925903a2c9b" translate="yes" xml:space="preserve">
          <source>Google maintains &lt;a href=&quot;https://hstspreload.org/&quot;&gt;an HSTS preload service&lt;/a&gt;. By following the guidelines and successfully submitting your domain, browsers will never connect to your domain using an insecure connection. While the service is hosted by Google, all browsers have stated an intent to use (or actually started using) the preload list. However, it is not part of the HSTS specification and should not be treated as official.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef239b0e9b523a211062dd9a992489254f2934aa" translate="yes" xml:space="preserve">
          <source>Governs which referrer information sent in the &lt;a href=&quot;headers/referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header should be included with requests made.</source>
          <target state="translated">Управляет тем, какая информация о &lt;a href=&quot;headers/referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; отправляемая в заголовок Referer, должна включаться в сделанные запросы.</target>
        </trans-unit>
        <trans-unit id="360bdb2acc65ada59d8a23e434964675641d9c45" translate="yes" xml:space="preserve">
          <source>Graceful degradation</source>
          <target state="translated">Грациозная деградация</target>
        </trans-unit>
        <trans-unit id="14d1e14f4035027adcdfb20a1541aae1745796ae" translate="yes" xml:space="preserve">
          <source>Granular control over certain features</source>
          <target state="translated">зернистый контроль над некоторыми особенностями</target>
        </trans-unit>
        <trans-unit id="acdb09fe43197ccedd1630af2f50c572c32d3061" translate="yes" xml:space="preserve">
          <source>Graphics Interchange Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94265c1a4efc21014ed0c288b4d4deab23d58e6c" translate="yes" xml:space="preserve">
          <source>Graphics Interchange Format (GIF)</source>
          <target state="translated">Формат обмена графикой (GIF)</target>
        </trans-unit>
        <trans-unit id="07dad8754dab2f22b2c67d2717531b2161e04c97" translate="yes" xml:space="preserve">
          <source>Greenwich Mean Time. HTTP dates are always expressed in GMT, never in local time.</source>
          <target state="translated">Время по Гринвичу.Даты HTTP всегда выражаются по Гринвичу,никогда по местному времени.</target>
        </trans-unit>
        <trans-unit id="fac27197d986ea2b588d07c83185f5503eea7d94" translate="yes" xml:space="preserve">
          <source>Guide to media types used on the web</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63172a5d2ab37e128a6f6cf25b0335129725a21c" translate="yes" xml:space="preserve">
          <source>Guide: &lt;em&gt;&lt;a href=&quot;https://csswizardry.com/2019/03/cache-control-for-civilians&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt; for civilians&lt;/a&gt;&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="82ee9a2ace2ff133591d7f8cb5b72ca9b839fcd4" translate="yes" xml:space="preserve">
          <source>Guides: Basics</source>
          <target state="translated">Путеводители:Основы</target>
        </trans-unit>
        <trans-unit id="6e029883c1d4de187688b7e7b2376708429e4061" translate="yes" xml:space="preserve">
          <source>Gyroscope</source>
          <target state="translated">Gyroscope</target>
        </trans-unit>
        <trans-unit id="7138a51661947b19b5088da5a2bfede2876f49b9" translate="yes" xml:space="preserve">
          <source>HEAD</source>
          <target state="translated">HEAD</target>
        </trans-unit>
        <trans-unit id="780c90e89bccb7fed5c8548e6fe499017ad97ffb" translate="yes" xml:space="preserve">
          <source>HEAD (RFC 7231)</source>
          <target state="translated">ГОЛОВКА (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="562b472b05f04a6dd479541dc3fcef670a17fed9" translate="yes" xml:space="preserve">
          <source>HEAD: The entity headers are in the message body.</source>
          <target state="translated">Заголовки сущностей находятся в теле сообщения.</target>
        </trans-unit>
        <trans-unit id="c194c3625b9314d21fe00e2a5b33960d2235d75a" translate="yes" xml:space="preserve">
          <source>HPACK: Header Compression for HTTP/2</source>
          <target state="translated">HPACK:Сжатие заголовков для HTTP/2</target>
        </trans-unit>
        <trans-unit id="f4ce8cef0273faa8edf023797bff38c190bc758e" translate="yes" xml:space="preserve">
          <source>HPKP has the potential to lock out users for a long time if used incorrectly! The use of backup certificates and/or pinning the CA certificate is recommend.</source>
          <target state="translated">HPKP может заблокировать пользователей на длительное время,если используется неправильно! Рекомендуется использовать резервные сертификаты и/или пиннинговать сертификат CA.</target>
        </trans-unit>
        <trans-unit id="fc0a0d888f6e163542c2141a305027befded2018" translate="yes" xml:space="preserve">
          <source>HPKP has the potential to lock out users for a long time if used incorrectly! The use of backup certificates and/or pinning the CA certificate is recommended.</source>
          <target state="translated">HPKP может заблокировать пользователей на длительное время,если используется неправильно! Рекомендуется использовать резервные сертификаты и/или пиннинговать сертификат CA.</target>
        </trans-unit>
        <trans-unit id="f7a71b290916b9c6df149f326df62ff64346f837" translate="yes" xml:space="preserve">
          <source>HPKP is a &lt;em&gt;Trust on First Use&lt;/em&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TOFU&quot;&gt;TOFU&lt;/a&gt;) technique. The first time a web server tells a client via a special HTTP header which public keys belong to it, the client stores this information for a given period of time. When the client visits the server again, it expects at least one certificate in the certificate chain to contain a public key whose fingerprint is already known via HPKP. If the server delivers an unknown public key, the client should present a warning to the user.</source>
          <target state="translated">HPKP - это метод, основанный на &lt;em&gt;доверии при первом использовании&lt;/em&gt; ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TOFU&quot;&gt;TOFU&lt;/a&gt; ). Когда веб-сервер впервые сообщает клиенту через специальный HTTP-заголовок, какие открытые ключи ему принадлежат, клиент сохраняет эту информацию в течение определенного периода времени. Когда клиент снова посещает сервер, он ожидает, что по крайней мере один сертификат в цепочке сертификатов будет содержать открытый ключ, отпечаток которого уже известен через HPKP. Если сервер предоставляет неизвестный открытый ключ, клиент должен представить пользователю предупреждение.</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="f23df8f2db7fa54c086120949c75120681957c68" translate="yes" xml:space="preserve">
          <source>HTML &lt;code&gt;lang&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b74ec0b3fb709ed009e59e071a8ce0a9039c38" translate="yes" xml:space="preserve">
          <source>HTML Forms</source>
          <target state="translated">формы HTML</target>
        </trans-unit>
        <trans-unit id="2abbe4c282803f8a491f6e980e7fc519bd5a7483" translate="yes" xml:space="preserve">
          <source>HTML Living Standard</source>
          <target state="translated">уровень жизни HTML</target>
        </trans-unit>
        <trans-unit id="b7098c07bc2151e34df998ef11bad7237b20c9ba" translate="yes" xml:space="preserve">
          <source>HTML Living Standard&lt;br/&gt;&lt;small&gt;The definition of 'document-domain' in that specification.&lt;/small&gt;</source>
          <target state="translated">HTML Living Standard &lt;br/&gt;&lt;small&gt;Определение &amp;laquo;домена документа&amp;raquo; в этой спецификации.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="18d5d7015a5c0d8f94531cdc381221d904d7cbf2" translate="yes" xml:space="preserve">
          <source>HTML files</source>
          <target state="translated">файлы HTML</target>
        </trans-unit>
        <trans-unit id="6390be00d32679564fc38130d4ea8471a4d82c91" translate="yes" xml:space="preserve">
          <source>HTML redirections</source>
          <target state="translated">перенаправления HTML</target>
        </trans-unit>
        <trans-unit id="f66adf007a33a0423e5b7102cdbe9c27c03d133c" translate="yes" xml:space="preserve">
          <source>HTML redirections with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7508e59dac25653bfafc78c94cdfff1f91c75f89" translate="yes" xml:space="preserve">
          <source>HTML redirects (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt;) are executed if there weren't any HTTP redirects.</source>
          <target state="translated">Перенаправления HTML ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; ) выполняются, если не было перенаправлений HTTP.</target>
        </trans-unit>
        <trans-unit id="8486d6ebac41d1efb6780b5d1b64cf90fff3aae8" translate="yes" xml:space="preserve">
          <source>HTML redirects (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt;) execute if there weren't any HTTP redirects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="83ef326d5040783a2304cd9c3d4b2741d50432d8" translate="yes" xml:space="preserve">
          <source>HTTP 1.1 recommends the use of ETags rather than modification dates,
   for cache control, and there are even stronger reasons to prefer
   ETags for authoring.  Correct use of ETags is even more important in
   a distributed authoring environment, because ETags are necessary
   along with locks to avoid the lost-update problem.  A client might
   fail to renew a lock, for example, when the lock times out and the
   client is accidentally offline or in the middle of a long upload.
   When a client fails to renew the lock, it's quite possible the
   resource can still be relocked and the user can go on editing, as
   long as no changes were made in the meantime.  ETags are required for
   the client to be able to distinguish this case.  Otherwise, the 

   client is forced to ask the user whether to overwrite the resource on
   the server without even being able to tell the user if it has
   changed.  Timestamps do not solve this problem nearly as well as
   ETags.

   Strong ETags are much more useful for authoring use cases than weak
   ETags (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;Section&amp;nbsp;13.3.3 of [RFC2616]&lt;/a&gt;).  Semantic equivalence can be
   a useful concept but that depends on the document type and the
   application type, and interoperability might require some agreement
   or standard outside the scope of this specification and HTTP.  Note
   also that weak ETags have certain restrictions in HTTP, e.g., these
   cannot be used in If-Match headers.

   Note that the meaning of an ETag in a PUT response is not clearly
   defined either in this document or in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; (i.e., whether the
   ETag means that the resource is octet-for-octet equivalent to the
   body of the PUT request, or whether the server could have made minor
   changes in the formatting or content of the document upon storage).
   This is an HTTP issue, not purely a WebDAV issue.

   Because clients may be forced to prompt users or throw away changed
   content if the ETag changes, a WebDAV server SHOULD NOT change the
   ETag (or the Last-Modified time) for a resource that has an unchanged
   body and location.  The ETag represents the state of the body or
   contents of the resource.  There is no similar way to tell if
   properties have changed.</source>
          <target state="translated">HTTP 1.1 рекомендует использовать ETags вместо дат модификации для управления кешем, и есть еще более веские причины предпочесть ETags для разработки. Правильное использование ETags еще более важно в распределенной среде разработки, потому что ETags необходимы наряду с блокировками, чтобы избежать проблемы потери обновлений. Клиент может не возобновить блокировку, например, когда время блокировки истекло и клиент случайно отключился или находится в процессе длительной загрузки. Когда клиенту не удается возобновить блокировку, вполне возможно, что ресурс все еще может быть повторно заблокирован, и пользователь может продолжить редактирование, если за это время не было внесено никаких изменений. ETag необходимы для того, чтобы клиент мог различить этот случай. В противном случае,клиент вынужден спрашивать пользователя, перезаписывать ли ресурс на сервере, даже не имея возможности сообщить пользователю, изменился ли он. Отметки времени не решают эту проблему так же хорошо, как ETags. Сильные ETag гораздо более полезны для создания сценариев использования, чем слабые ETags (см.&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;Раздел 13.3.3 [RFC2616]&lt;/a&gt; ). Семантическая эквивалентность может быть полезной концепцией, но это зависит от типа документа и типа приложения, а для взаимодействия может потребоваться какое-то соглашение или стандарт, выходящий за рамки данной спецификации и HTTP. Также обратите внимание, что слабые ETag имеют определенные ограничения в HTTP, например, их нельзя использовать в заголовках If-Match. Обратите внимание, что значение ETag в ответе PUT четко не определено ни в этом документе, ни в &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616.&lt;/a&gt;(то есть, означает ли ETag, что ресурс октет за октетом эквивалентен телу запроса PUT, или сервер мог внести незначительные изменения в форматирование или содержимое документа при сохранении). Это проблема HTTP, а не только WebDAV. Поскольку клиенты могут быть вынуждены запрашивать пользователей или выбрасывать измененный контент, если ETag изменяется, серверу WebDAV НЕ СЛЕДУЕТ изменять ETag (или время последнего изменения) для ресурса, который имеет неизмененное тело и местоположение. ETag представляет состояние тела или содержимого ресурса. Нет аналогичного способа узнать, изменились ли свойства.</target>
        </trans-unit>
        <trans-unit id="056cc5e9a537351fb174e8ebbb3ca2b1700c2d47" translate="yes" xml:space="preserve">
          <source>HTTP &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;</source>
          <target state="translated">Согласование &lt;a href=&quot;../content_negotiation&quot;&gt;содержимого&lt;/a&gt; HTTP</target>
        </trans-unit>
        <trans-unit id="392079fd3fa793eb6c0e1335885b8cddafea9ef8" translate="yes" xml:space="preserve">
          <source>HTTP &lt;a href=&quot;headers&quot;&gt;headers&lt;/a&gt;, like those for requests.</source>
          <target state="translated">&lt;a href=&quot;headers&quot;&gt;Заголовки&lt;/a&gt; HTTP , например, для запросов.</target>
        </trans-unit>
        <trans-unit id="c6a6635bbee752fe5fb0f3784e33cdf15bd75ab6" translate="yes" xml:space="preserve">
          <source>HTTP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client hints&lt;/a&gt; are a work in progress. Actual documentation can be found on the &lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html&quot;&gt;website of the HTTP working group&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2ed3fe8a3093e057602abdf74477e83473a214" translate="yes" xml:space="preserve">
          <source>HTTP &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">HTTP- &lt;em&gt;хост: порт&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae47637ce45f4b16c54404dff4cb129bfbe68800" translate="yes" xml:space="preserve">
          <source>HTTP Access Control covering the HTTP headers</source>
          <target state="translated">HTTP Access Control,охватывающий заголовки HTTP</target>
        </trans-unit>
        <trans-unit id="d601b5bb2c1cad46bb9aa46a3ee39b64315236e7" translate="yes" xml:space="preserve">
          <source>HTTP Alternative Services</source>
          <target state="translated">альтернативные сервисы HTTP</target>
        </trans-unit>
        <trans-unit id="965e2184c8e7927a43f2bee90d3f5ececba434b6" translate="yes" xml:space="preserve">
          <source>HTTP Cache</source>
          <target state="translated">HTTP-кэш</target>
        </trans-unit>
        <trans-unit id="f54d56b271b9875e48fe27b600b0dc067a9f284e" translate="yes" xml:space="preserve">
          <source>HTTP Cache-Control Extensions for Stale Content</source>
          <target state="translated">Расширения для управления кэш-памятью HTTP для несвоевременного содержимого</target>
        </trans-unit>
        <trans-unit id="6c1e735662c0178e6f3fe960f4930ffeabb6f7fe" translate="yes" xml:space="preserve">
          <source>HTTP Caching FAQ</source>
          <target state="translated">часто задаваемые вопросы по кэшированию HTTP</target>
        </trans-unit>
        <trans-unit id="0b0260299fa380d7d3a7ccc7edbf8a208c829f61" translate="yes" xml:space="preserve">
          <source>HTTP Client Hints</source>
          <target state="translated">HTTP-клиентские хинты</target>
        </trans-unit>
        <trans-unit id="17e0afd9e45a02ae60f6b6aed60a68bef13f3af0" translate="yes" xml:space="preserve">
          <source>HTTP Conditional Requests</source>
          <target state="translated">Условные запросы HTTP</target>
        </trans-unit>
        <trans-unit id="186213537e6fba63d1dd994c6c9b358b6f840caf" translate="yes" xml:space="preserve">
          <source>HTTP Cookies</source>
          <target state="translated">HTTP-куки</target>
        </trans-unit>
        <trans-unit id="ae2fa3648597031d5a833b5724263dbfd920c241" translate="yes" xml:space="preserve">
          <source>HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)</source>
          <target state="translated">Расширения HTTP для Web распределенной авторизации и версионирования (WebDAV)</target>
        </trans-unit>
        <trans-unit id="6cee8a3bc57d158b257c68ed73852449cb27b716" translate="yes" xml:space="preserve">
          <source>HTTP Header Field X-Frame-Options</source>
          <target state="translated">HTTP Поле заголовка X-кадров-настройки</target>
        </trans-unit>
        <trans-unit id="f88eb2164f3dbd137bca83f451898992e6e6b039" translate="yes" xml:space="preserve">
          <source>HTTP Header Field X-Frame-Options - RFC 7034</source>
          <target state="translated">Поле заголовка HTTP X-кадровые опции-RFC 7034</target>
        </trans-unit>
        <trans-unit id="cc46670cd995848df63f3703c3400f81060dd482" translate="yes" xml:space="preserve">
          <source>HTTP Headers</source>
          <target state="translated">заголовки HTTP</target>
        </trans-unit>
        <trans-unit id="d5d09479cf8d4e2b8c35798b4a19c06e1f5461b3" translate="yes" xml:space="preserve">
          <source>HTTP Immutable Responses</source>
          <target state="translated">Непрерывные HTTP-ответы</target>
        </trans-unit>
        <trans-unit id="d1d0c4dbc1b360b38cb5161612b50b3934e501fa" translate="yes" xml:space="preserve">
          <source>HTTP Keep-Alive Header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc68b45ed9f862b4a9cd7aa0be2cfbc7e016a6ef" translate="yes" xml:space="preserve">
          <source>HTTP Message (RFC 2616)</source>
          <target state="translated">HTTP-сообщение (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="645acbbc29e90c2c68542670b051cdcea02987bc" translate="yes" xml:space="preserve">
          <source>HTTP Messages</source>
          <target state="translated">HTTP-сообщения</target>
        </trans-unit>
        <trans-unit id="3ccf0b57b902eafdb8fbf2b560f880d3eb800cc2" translate="yes" xml:space="preserve">
          <source>HTTP Messages transmitted during requests or responses have a very clear structure. This introductory article describes this structure, its purpose, and its possibilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="583d9f510824dc860b8faad49ebe7579ffd29c0b" translate="yes" xml:space="preserve">
          <source>HTTP Messages transmitted during requests or responses have a very clear structure; this introductory article describes this structure, its purpose and its possibilities.</source>
          <target state="translated">HTTP-сообщения,передаваемые во время запросов или ответов,имеют очень четкую структуру;эта вводная статья описывает эту структуру,ее назначение и возможности.</target>
        </trans-unit>
        <trans-unit id="1b57e4650aa38c4a92f3b3fc02ea7dab930ee663" translate="yes" xml:space="preserve">
          <source>HTTP Public Key Pinning (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HPKP&quot;&gt;HPKP&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34a93534eb1b632f2a799adfc1786464f6439f8" translate="yes" xml:space="preserve">
          <source>HTTP Public Key Pinning has been deprecated and removed in favor of Certificate Transparency and &lt;a href=&quot;headers/expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fdc3e6f5c751d82295ac7ade9d715a4814c0d4" translate="yes" xml:space="preserve">
          <source>HTTP Request Methods</source>
          <target state="translated">методы HTTP-запроса</target>
        </trans-unit>
        <trans-unit id="147cce8975179e5500fc1bb079891e026beac7f0" translate="yes" xml:space="preserve">
          <source>HTTP Requests</source>
          <target state="translated">HTTP-запросы</target>
        </trans-unit>
        <trans-unit id="7402660b7ec42f5008e637f7d416a9463ae2ce2f" translate="yes" xml:space="preserve">
          <source>HTTP Responses</source>
          <target state="translated">HTTP-ответы</target>
        </trans-unit>
        <trans-unit id="1e3c49a8c708be92f5037401d92246426a46dc11" translate="yes" xml:space="preserve">
          <source>HTTP State Management Mechanism</source>
          <target state="translated">Государственный механизм управления HTTP</target>
        </trans-unit>
        <trans-unit id="a5fc269de1ce9034a5e3e1936288b84520462ea3" translate="yes" xml:space="preserve">
          <source>HTTP Status Response Codes</source>
          <target state="translated">Коды ответа на статус HTTP</target>
        </trans-unit>
        <trans-unit id="92b092172a89d9cb7710c23a35bcf58905e6ddfd" translate="yes" xml:space="preserve">
          <source>HTTP Strict Transport Security (HSTS)</source>
          <target state="translated">HTTP Строгая транспортная безопасность (HSTS)</target>
        </trans-unit>
        <trans-unit id="30491b8aa76d328aca84cd3704d383ab97b03407" translate="yes" xml:space="preserve">
          <source>HTTP Working Group</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc09a66647a44074ee04da1ac1771e8479c9d8b" translate="yes" xml:space="preserve">
          <source>HTTP allows a browser, or another &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;, to a communicate with different &lt;em&gt;resources&lt;/em&gt; on Internet: to do this the browser needs both the &lt;em&gt;identity&lt;/em&gt; and the &lt;em&gt;location&lt;/em&gt; of the resources. These two bits of information are described by a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;.</source>
          <target state="translated">HTTP позволяет браузеру или другому &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;пользовательскому агенту&lt;/a&gt; связываться с различными &lt;em&gt;ресурсами&lt;/em&gt; в Интернете: для этого браузеру необходимы как &lt;em&gt;идентификация, так&lt;/em&gt; и &lt;em&gt;расположение&lt;/em&gt; ресурсов. Эти два бита информации описываются &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1cc8c4caf634d96aa87067b5477aecd5ac3e698e" translate="yes" xml:space="preserve">
          <source>HTTP allows a browser, or another &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;, to communicate with different &lt;em&gt;resources&lt;/em&gt; on the Internet: to do this the browser needs both the &lt;em&gt;identity&lt;/em&gt; and the &lt;em&gt;location&lt;/em&gt; of the resources. These two bits of information are described by a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d82f24e44e689920296a131052df78d102bbaff" translate="yes" xml:space="preserve">
          <source>HTTP and WebDAV did not use the bodies of most error responses for
   machine-parsable information until the specification for Versioning
   Extensions to WebDAV introduced a mechanism to include more specific
   information in the body of an error response (&lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-1.6&quot;&gt;Section&amp;nbsp;1.6 of
   [RFC3253]&lt;/a&gt;).  The error body mechanism is appropriate to use with any
   error response that may take a body but does not already have a body
   defined.  The mechanism is particularly appropriate when a status
   code can mean many things (for example, 400 Bad Request can mean
   required headers are missing, headers are incorrectly formatted, or
   much more).  This error body mechanism is covered in &lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;.</source>
          <target state="translated">HTTP и WebDAV не использовали тела большинства ответов об ошибках для машинного анализа информации, пока спецификация расширений управления версиями для WebDAV не представила механизм для включения более конкретной информации в тело ответа об ошибке ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-1.6&quot;&gt;раздел 1.6 [RFC3253]&lt;/a&gt; ). Механизм тела ошибки подходит для использования с любым ответом на ошибку, который может принимать тело, но еще не определено. Этот механизм особенно подходит, когда код состояния может означать много вещей (например, 400 Bad Request может означать, что требуемые заголовки отсутствуют, заголовки неправильно отформатированы или многое другое). Этот механизм тела ошибки описан в &lt;a href=&quot;#section-16&quot;&gt;разделе 16&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="170502bb0d853c3d72e45f0eef9c00311f2253c6" translate="yes" xml:space="preserve">
          <source>HTTP and connections</source>
          <target state="translated">HTTP и соединения</target>
        </trans-unit>
        <trans-unit id="70e2789624d7913484672252eb44130b859ad66a" translate="yes" xml:space="preserve">
          <source>HTTP applications have historically allowed three different formats
   for the representation of date/time stamps:

      Sun, 06 Nov 1994 08:49:37 GMT  ; &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;, updated by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt;
      Sunday, 06-Nov-94 08:49:37 GMT ; &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt;, obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;RFC 1036&lt;/a&gt;
      Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format

   The first format is preferred as an Internet standard and represents
   a fixed-length subset of that defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;] (an update to
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]). The second format is in common use, but is based on the
   obsolete &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt; [&lt;a href=&quot;#ref-12&quot;&gt;12&lt;/a&gt;] date format and lacks a four-digit year.
   HTTP/1.1 clients and servers that parse the date value MUST accept
   all three formats (for compatibility with HTTP/1.0), though they MUST
   only generate the &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; format for representing HTTP-date values
   in header fields. See &lt;a href=&quot;#section-19.3&quot;&gt;section 19.3&lt;/a&gt; for further information.

      Note: Recipients of date values are encouraged to be robust in
      accepting date values that may have been sent by non-HTTP
      applications, as is sometimes the case when retrieving or posting
      messages via proxies/gateways to SMTP or NNTP. 

   All HTTP date/time stamps MUST be represented in Greenwich Mean Time
   (GMT), without exception. For the purposes of HTTP, GMT is exactly
   equal to UTC (Coordinated Universal Time). This is indicated in the
   first two formats by the inclusion of &quot;GMT&quot; as the three-letter
   abbreviation for time zone, and MUST be assumed when reading the
   asctime format. HTTP-date is case sensitive and MUST NOT include
   additional LWS beyond that specifically included as SP in the
   grammar.

       HTTP-date    = &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date | &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date | asctime-date
       &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date = wkday &quot;,&quot; SP date1 SP time SP &quot;GMT&quot;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date  = weekday &quot;,&quot; SP date2 SP time SP &quot;GMT&quot;
       asctime-date = wkday SP date3 SP time SP 4DIGIT
       date1        = 2DIGIT SP month SP 4DIGIT
                      ; day month year (e.g., 02 Jun 1982)
       date2        = 2DIGIT &quot;-&quot; month &quot;-&quot; 2DIGIT
                      ; day-month-year (e.g., 02-Jun-82)
       date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))
                      ; month day (e.g., Jun  2)
       time         = 2DIGIT &quot;:&quot; 2DIGIT &quot;:&quot; 2DIGIT
                      ; 00:00:00 - 23:59:59
       wkday        = &quot;Mon&quot; | &quot;Tue&quot; | &quot;Wed&quot;
                    | &quot;Thu&quot; | &quot;Fri&quot; | &quot;Sat&quot; | &quot;Sun&quot;
       weekday      = &quot;Monday&quot; | &quot;Tuesday&quot; | &quot;Wednesday&quot;
                    | &quot;Thursday&quot; | &quot;Friday&quot; | &quot;Saturday&quot; | &quot;Sunday&quot;
       month        = &quot;Jan&quot; | &quot;Feb&quot; | &quot;Mar&quot; | &quot;Apr&quot;
                    | &quot;May&quot; | &quot;Jun&quot; | &quot;Jul&quot; | &quot;Aug&quot;
                    | &quot;Sep&quot; | &quot;Oct&quot; | &quot;Nov&quot; | &quot;Dec&quot;

      Note: HTTP requirements for the date/time stamp format apply only
      to their usage within the protocol stream. Clients and servers are
      not required to use these formats for user presentation, request
      logging, etc.</source>
          <target state="translated">Приложения HTTP исторически допускали три различных формата для представления меток даты и времени: вс, 06 ноября 1994 г., 08:49:37 GMT; &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; , обновленный &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123,&lt;/a&gt; воскресенье, 6 ноября 1994 г., 8:49:37 по Гринвичу; &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt; , устарело &lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;RFC 1036&lt;/a&gt; Вс, 6 ноября, 08:49:37 1994; Формат asctime () ANSI C Первый формат является предпочтительным в качестве стандарта Интернета и представляет собой подмножество фиксированной длины, определенное в &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt; ] (обновление &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]). Второй формат широко используется, но основан на устаревшем &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt; [ &lt;a href=&quot;#ref-12&quot;&gt;12&lt;/a&gt;] формат даты и не имеет года из четырех цифр. Клиенты и серверы HTTP / 1.1, которые анализируют значение даты, ДОЛЖНЫ принимать все три формата (для совместимости с HTTP / 1.0), хотя они ДОЛЖНЫ генерировать только формат &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; для представления значений даты HTTP в полях заголовка. См. &lt;a href=&quot;#section-19.3&quot;&gt;Раздел 19.3&lt;/a&gt;для дополнительной информации. Примечание. Получателям значений даты рекомендуется быть надежными в принятии значений даты, которые могли быть отправлены не-HTTP-приложениями, как это иногда бывает при получении или отправке сообщений через прокси / шлюзы на SMTP или NNTP. Все метки даты и времени HTTP ДОЛЖНЫ быть представлены в среднем времени по Гринвичу (GMT) без исключения. Для целей HTTP GMT точно равно UTC (всемирное координированное время). Это указывается в первых двух форматах включением &amp;laquo;GMT&amp;raquo; в качестве трехбуквенного сокращения для часового пояса и ДОЛЖНО приниматься при чтении формата asctime. HTTP-date чувствительна к регистру и НЕ ДОЛЖНА включать дополнительные LWS, помимо того, что специально включено в грамматику как SP.HTTP-date = &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt; -date |&lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt; -date | asctime-date &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt; -date = wkday &quot;,&quot; SP date1 SP time SP &quot;GMT&quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date = день недели &quot;,&quot; SP date2 SP time SP &quot;GMT&quot; asctime-date = wkday SP date3 SP time SP 4DIGIT date1 = 2DIGIT SP месяц SP 4DIGIT; день месяц год (например, 02 июня 1982 г.) date2 = 2DIGIT &quot;-&quot; месяц &quot;-&quot; 2DIGIT; день-месяц-год (например, 02-июн-82) date3 = месяц SP (2DIGIT | (SP 1DIGIT)); число месяца (например, 2 июня) time = 2DIGIT &quot;:&quot; 2DIGIT &quot;:&quot; 2DIGIT; 00:00:00 - 23:59:59 wkday = &quot;Пн&quot; | &amp;laquo;Вт&amp;raquo; | &amp;laquo;Ср&amp;raquo; | &amp;laquo;Чт&amp;raquo; | &amp;laquo;Пт&amp;raquo; | &amp;laquo;Сб&amp;raquo; | &quot;Вс&quot; будний день = &quot;понедельник&quot; | &amp;laquo;Вторник&amp;raquo; | &amp;laquo;Среда&amp;raquo; | &quot;Четверг &amp;raquo;|&amp;laquo; Пятница &amp;raquo;|&amp;laquo; Суббота &amp;raquo;|&amp;laquo; Воскресенье &amp;raquo;month =&amp;laquo; Янв &amp;raquo;|&amp;laquo; Фев &amp;raquo;|&amp;laquo; Мар &amp;raquo;|&amp;laquo; Апр &amp;raquo;|&amp;laquo; Май &amp;raquo;|&amp;laquo; Июнь &amp;raquo;|&amp;laquo; Июл &amp;raquo;|&amp;laquo; Авг &amp;raquo;|&amp;laquo; Сен &quot;|&quot; Oct &quot;|&quot; Nov &quot;|&quot; Dec &quot;Примечание: требования HTTP к формату отметки даты / времени применяются только к их использованию в потоке протокола. Клиентам и серверам не требуется использовать эти форматы для представления пользователей, регистрации запросов , и т.д.| &amp;laquo;Сен&amp;raquo; | &amp;laquo;Октябрь&amp;raquo; | &quot;Ноябрь&quot; | &amp;laquo;Dec&amp;raquo; Примечание: требования HTTP для формата отметки даты / времени применяются только к их использованию в потоке протокола. Клиенты и серверы не обязаны использовать эти форматы для представления пользователей, ведения журнала запросов и т. Д.| &amp;laquo;Сен&amp;raquo; | &amp;laquo;Октябрь&amp;raquo; | &quot;Ноябрь&quot; | &amp;laquo;Dec&amp;raquo; Примечание: требования HTTP для формата отметки даты / времени применяются только к их использованию в потоке протокола. Клиенты и серверы не обязаны использовать эти форматы для представления пользователей, ведения журнала запросов и т. Д.</target>
        </trans-unit>
        <trans-unit id="3cd45603fb781257153f9081597101ece177c7d0" translate="yes" xml:space="preserve">
          <source>HTTP authentication</source>
          <target state="translated">HTTP-аутентификация</target>
        </trans-unit>
        <trans-unit id="ab4ed2ef5f3094275f004bff5889feddcf0ad10a" translate="yes" xml:space="preserve">
          <source>HTTP caching &amp;ndash; Ilya Grigorik</source>
          <target state="translated">HTTP-кеширование - Илья Григорик</target>
        </trans-unit>
        <trans-unit id="d4978c013ac3d81e858ff3f4bb1b87778fc8087f" translate="yes" xml:space="preserve">
          <source>HTTP caching is optional but usually desirable. HTTP caches are typically limited to caching responses to &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;; they may decline other methods. The primary cache key consists of the request method and target URI (often only the URI is used &amp;mdash; this is because only &lt;code&gt;GET&lt;/code&gt; requests are caching targets).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0f4dfb9b0a4bec403f49cd2c2239e560902813" translate="yes" xml:space="preserve">
          <source>HTTP caching is optional, but reusing a cached resource is usually desirable. However, common HTTP caches are typically limited to caching responses to &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and may decline other methods. The primary cache key consists of the request method and target URI (oftentimes only the URI is used as only GET requests are caching targets). Common forms of caching entries are:</source>
          <target state="translated">Кэширование HTTP не является обязательным, но обычно желательно повторно использовать кэшированный ресурс. Однако обычные HTTP-кеши обычно ограничиваются кэшированием ответов на &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; и могут отклонять другие методы. Первичный ключ кеша состоит из метода запроса и целевого URI (часто используется только URI, поскольку только GET-запросы являются целями кэширования). Распространенными формами кэширования записей являются:</target>
        </trans-unit>
        <trans-unit id="64f23433ac676ea06e9a1900351a7ac4a13f68a1" translate="yes" xml:space="preserve">
          <source>HTTP caching works best when caches can entirely avoid making
   requests to the origin server. The primary mechanism for avoiding
   requests is for an origin server to provide an explicit expiration
   time in the future, indicating that a response MAY be used to satisfy
   subsequent requests. In other words, a cache can return a fresh
   response without first contacting the server.

   Our expectation is that servers will assign future explicit
   expiration times to responses in the belief that the entity is not
   likely to change, in a semantically significant way, before the
   expiration time is reached. This normally preserves semantic
   transparency, as long as the server's expiration times are carefully
   chosen. 

   The expiration mechanism applies only to responses taken from a cache
   and not to first-hand responses forwarded immediately to the
   requesting client.

   If an origin server wishes to force a semantically transparent cache
   to validate every request, it MAY assign an explicit expiration time
   in the past. This means that the response is always stale, and so the
   cache SHOULD validate it before using it for subsequent requests. See
   &lt;a href=&quot;#section-14.9.4&quot;&gt;section 14.9.4&lt;/a&gt; for a more restrictive way to force revalidation.

   If an origin server wishes to force any HTTP/1.1 cache, no matter how
   it is configured, to validate every request, it SHOULD use the &quot;must-
   revalidate&quot; cache-control directive (see &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).

   Servers specify explicit expiration times using either the Expires
   header, or the max-age directive of the Cache-Control header.

   An expiration time cannot be used to force a user agent to refresh
   its display or reload a resource; its semantics apply only to caching
   mechanisms, and such mechanisms need only check a resource's
   expiration status when a new request for that resource is initiated.
   See &lt;a href=&quot;#section-13.13&quot;&gt;section 13.13&lt;/a&gt; for an explanation of the difference between caches
   and history mechanisms.</source>
          <target state="translated">Кэширование HTTP работает лучше всего, когда кеши могут полностью избежать запросов к исходному серверу. Первичный механизм избежания запросов заключается в том, что исходный сервер предоставляет явное время истечения срока действия в будущем, указывая, что ответ МОЖЕТ использоваться для удовлетворения последующих запросов. Другими словами, кеш может вернуть свежий ответ без предварительного обращения к серверу. Мы ожидаем, что серверы будут назначать будущее явное время истечения для ответов, полагая, что сущность вряд ли изменится семантически значимым образом до того, как истечет время истечения срока. Обычно это сохраняет семантическую прозрачность, если время истечения срока действия сервера тщательно выбирается.Механизм истечения срока действия применяется только к ответам, взятым из кэша, а не к ответам из первых рук, которые немедленно пересылаются запрашивающему клиенту. Если исходный сервер желает заставить семантически прозрачный кеш проверять каждый запрос, он МОЖЕТ назначить явное время истечения срока в прошлом. Это означает, что ответ всегда устарел, и поэтому кеш ДОЛЖЕН проверить его, прежде чем использовать для последующих запросов. Видеть &lt;a href=&quot;#section-14.9.4&quot;&gt;раздел 14.9.4&lt;/a&gt; для более строгого способа принудительной повторной валидации. Если исходный сервер желает заставить любой кэш HTTP / 1.1, независимо от того, как он настроен, проверять каждый запрос, он ДОЛЖЕН использовать директиву управления кешем &quot;must-revalidate&quot; (см. &lt;a href=&quot;#section-14.9&quot;&gt;Раздел 14.9&lt;/a&gt; ). Серверы указывают явное время истечения срока действия, используя либо заголовок Expires, либо директиву max-age заголовка Cache-Control. Время истечения срока действия не может использоваться, чтобы заставить пользовательский агент обновить свое отображение или перезагрузить ресурс; его семантика применяется только к механизмам кэширования, и таким механизмам необходимо проверять состояние истечения срока действия ресурса только при инициировании нового запроса для этого ресурса. См. &lt;a href=&quot;#section-13.13&quot;&gt;Раздел 13.13.&lt;/a&gt; для объяснения разницы между кешами и механизмами истории.</target>
        </trans-unit>
        <trans-unit id="7f76c971673910b6c1b10deaca8522002aada40e" translate="yes" xml:space="preserve">
          <source>HTTP clients are often privy to large amounts of personal information
   (e.g. the user's name, location, mail address, passwords, encryption
   keys, etc.), and SHOULD be very careful to prevent unintentional
   leakage of this information via the HTTP protocol to other sources.
   We very strongly recommend that a convenient interface be provided
   for the user to control dissemination of such information, and that
   designers and implementors be particularly careful in this area.
   History shows that errors in this area often create serious security
   and/or privacy problems and generate highly adverse publicity for the
   implementor's company.</source>
          <target state="translated">HTTP-клиенты часто имеют доступ к большому количеству личной информации (например,имя пользователя,местоположение,почтовый адрес,пароли,ключи шифрования и т.д.),и ДОЛЖНЫ быть очень внимательными,чтобы предотвратить непреднамеренную утечку этой информации по протоколу HTTP в другие источники.Мы очень настоятельно рекомендуем предоставить пользователю удобный интерфейс для контроля над распространением такой информации,а разработчикам и реализаторам быть особенно внимательными в этой области.История показывает,что ошибки в этой области часто создают серьезные проблемы с безопасностью и/или конфиденциальностью и порождают крайне неблагоприятную рекламу для компании исполнителя.</target>
        </trans-unit>
        <trans-unit id="0593fb953516cec3cb50e486b7c0cd80aa7ff135" translate="yes" xml:space="preserve">
          <source>HTTP conditional requests</source>
          <target state="translated">условные HTTP-запросы</target>
        </trans-unit>
        <trans-unit id="a24d61eed6303644578268bb7ece0c747329e619" translate="yes" xml:space="preserve">
          <source>HTTP conditional requests are requests that are executed differently, depending on the value of specific headers. These headers define a precondition, and the result of the request will be different if the precondition is matched or not.</source>
          <target state="translated">Условные запросы HTTP-это запросы,которые выполняются по-разному,в зависимости от значения конкретных заголовков.Эти заголовки определяют предусловие,и результат запроса будет разным,если предусловие совпадает или нет.</target>
        </trans-unit>
        <trans-unit id="7cb9523b16d3c9a97f6ddd095333da9f953ccd3f" translate="yes" xml:space="preserve">
          <source>HTTP content negotiation (&lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;) uses short &quot;floating point&quot;
   numbers to indicate the relative importance (&quot;weight&quot;) of various
   negotiable parameters.  A weight is normalized to a real number in
   the range 0 through 1, where 0 is the minimum and 1 the maximum
   value. If a parameter has a quality value of 0, then content with
   this parameter is `not acceptable' for the client. HTTP/1.1
   applications MUST NOT generate more than three digits after the
   decimal point. User configuration of these values SHOULD also be
   limited in this fashion.

       qvalue         = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
                      | ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )

   &quot;Quality values&quot; is a misnomer, since these values merely represent
   relative degradation in desired quality.</source>
          <target state="translated">При согласовании содержимого HTTP ( &lt;a href=&quot;#section-12&quot;&gt;раздел 12&lt;/a&gt; ) используются короткие числа с плавающей запятой, чтобы указать относительную важность (&amp;laquo;вес&amp;raquo;) различных согласованных параметров. Вес нормализуется до действительного числа в диапазоне от 0 до 1, где 0 - минимальное, а 1 - максимальное значение. Если параметр имеет значение качества 0, то содержимое с этим параметром &quot;неприемлемо&quot; для клиента. Приложения HTTP / 1.1 НЕ ДОЛЖНЫ генерировать более трех цифр после десятичной точки. Таким же образом СЛЕДУЕТ ограничивать пользовательскую конфигурацию этих значений. qvalue = (&quot;0&quot; [&quot;.&quot; 0 * 3DIGIT]) | (&quot;1&quot; [&quot;.&quot; 0 * 3 (&quot;0&quot;)]) &quot;Значения качества&quot; - неправильное употребление,поскольку эти значения просто представляют собой относительное ухудшение желаемого качества.</target>
        </trans-unit>
        <trans-unit id="7b89b9e50093443d13f8d95c6b289f93dce89159" translate="yes" xml:space="preserve">
          <source>HTTP cookie</source>
          <target state="translated">HTTP-куки</target>
        </trans-unit>
        <trans-unit id="49bceea2f43dd4ce87f70babc4ac786f9373fb9b" translate="yes" xml:space="preserve">
          <source>HTTP cookie on Wikipedia</source>
          <target state="translated">HTTP-куки в Википедии</target>
        </trans-unit>
        <trans-unit id="d913ef28f4b5c9d1334d825b1c91fdfabe426299" translate="yes" xml:space="preserve">
          <source>HTTP cookies</source>
          <target state="translated">HTTP-куки</target>
        </trans-unit>
        <trans-unit id="d449bb5c3598a5a64c8ae94493892b59bad9bafe" translate="yes" xml:space="preserve">
          <source>HTTP defines a set of &lt;a href=&quot;methods&quot;&gt;request methods&lt;/a&gt; indicating the desired action to be performed upon a resource. Although they can also be nouns, these requests methods are sometimes referred as HTTP verbs. The most common requests are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt;:</source>
          <target state="translated">HTTP определяет набор &lt;a href=&quot;methods&quot;&gt;методов запроса,&lt;/a&gt; указывающих желаемое действие, которое должно быть выполнено над ресурсом. Хотя они также могут быть существительными, эти методы запросов иногда называют HTTP-глаголами. Наиболее частые запросы - &lt;code&gt;GET&lt;/code&gt; и &lt;code&gt;POST&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="30ad447e6db12c17885856bdde1f5bd54513584a" translate="yes" xml:space="preserve">
          <source>HTTP defines a set of &lt;strong&gt;request methods&lt;/strong&gt; to indicate the desired action to be performed for a given resource. Although they can also be nouns, these request methods are sometimes referred as &lt;em&gt;HTTP verbs&lt;/em&gt;. Each of them implements a different semantic, but some common features are shared by a group of them: e.g. a request method can be &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;idempotent&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;cacheable&lt;/a&gt;.</source>
          <target state="translated">HTTP определяет набор &lt;strong&gt;методов запроса,&lt;/strong&gt; чтобы указать желаемое действие, которое должно быть выполнено для данного ресурса. Хотя они также могут быть существительными, эти методы запроса иногда называют &lt;em&gt;HTTP-глаголами&lt;/em&gt; . Каждый из них реализует различную семантику, но некоторые общие функции являются общими для группы из них: например, метод запроса может быть &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;безопасным&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;идемпотентным&lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;кешируемым&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98d83c5b67ede465177980174dae53107f9fcd36" translate="yes" xml:space="preserve">
          <source>HTTP defines a set of &lt;strong&gt;request methods&lt;/strong&gt; to indicate the desired action to be performed for a given resource. Although they can also be nouns, these request methods are sometimes referred to as &lt;em&gt;HTTP verbs&lt;/em&gt;. Each of them implements a different semantic, but some common features are shared by a group of them: e.g. a request method can be &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;idempotent&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;cacheable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3823907860c4fbcb228c6adf9d8a7633b5e997" translate="yes" xml:space="preserve">
          <source>HTTP defines many headers that can be used in WebDAV requests and
   responses.  Not all of these are appropriate in all situations and
   some interactions may be undefined.  Note that HTTP 1.1 requires the
   Date header in all responses if possible (see &lt;a href=&quot;#section-14.18&quot;&gt;Section 14.18&lt;/a&gt;,
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]).

   The server MUST do authorization checks before checking any HTTP
   conditional header.</source>
          <target state="translated">HTTP определяет множество заголовков, которые можно использовать в запросах и ответах WebDAV. Не все из них подходят для всех ситуаций, и некоторые взаимодействия могут быть неопределенными. Обратите внимание, что HTTP 1.1 требует заголовка Date во всех ответах, если это возможно (см. &lt;a href=&quot;#section-14.18&quot;&gt;Раздел 14.18&lt;/a&gt; , [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]). Сервер ДОЛЖЕН выполнять проверки авторизации перед проверкой любого условного заголовка HTTP.</target>
        </trans-unit>
        <trans-unit id="8a133de8128e059a1d8a37cda84e730f09f27e2d" translate="yes" xml:space="preserve">
          <source>HTTP defines the Location header to indicate a preferred URL for the
   resource that was addressed in the Request-URI (e.g., in response to
   successful PUT requests or in redirect responses).  However, use of
   this header creates ambiguity when there are URLs in the body of the
   response, as with Multi-Status.  Thus, use of the Location header
   with the Multi-Status response is intentionally undefined.</source>
          <target state="translated">HTTP определяет заголовок Location для указания предпочтительного URL для ресурса,который был адресован в Request-URI (например,в ответ на успешные PUT-запросы или в редиректных ответах).Однако,использование этого заголовка создает двусмысленность при наличии URL в теле ответа,как в случае с Multi-Status.Таким образом,использование заголовка Location с ответом Multi-Status намеренно не определено.</target>
        </trans-unit>
        <trans-unit id="3a87bd3891b7e9c3d201f6e5eb6fa13e129baa69" translate="yes" xml:space="preserve">
          <source>HTTP didn't stop evolving upon the release of HTTP/2. Like with HTTP/1.x previously, HTTP's extensibility is still being used to add new features. Notably, we can cite new extensions of the HTTP protocol appearing in 2016:</source>
          <target state="translated">HTTP не прекратил развиваться после выхода HTTP/2.Как и в случае с HTTP/1.x,расширяемость HTTP все еще используется для добавления новых возможностей.Примечательно,что мы можем привести новые расширения протокола HTTP,появившиеся в 2016 году:</target>
        </trans-unit>
        <trans-unit id="b88a5eff6f325b12d08c43e0aa22f6a60e181d3d" translate="yes" xml:space="preserve">
          <source>HTTP does not define a specific mechanism for ensuring message
   integrity, instead relying on the error-detection ability of
   underlying transport protocols and the use of length or
   chunk-delimited framing to detect completeness.  Additional integrity
   mechanisms, such as hash functions or digital signatures applied to
   the content, can be selectively added to messages via extensible 

   metadata header fields.  Historically, the lack of a single integrity
   mechanism has been justified by the informal nature of most HTTP
   communication.  However, the prevalence of HTTP as an information
   access mechanism has resulted in its increasing use within
   environments where verification of message integrity is crucial.

   User agents are encouraged to implement configurable means for
   detecting and reporting failures of message integrity such that those
   means can be enabled within environments for which integrity is
   necessary.  For example, a browser being used to view medical history
   or drug interaction information needs to indicate to the user when
   such information is detected by the protocol to be incomplete,
   expired, or corrupted during transfer.  Such mechanisms might be
   selectively enabled via user agent extensions or the presence of
   message integrity metadata in a response.  At a minimum, user agents
   ought to provide some indication that allows a user to distinguish
   between a complete and incomplete response message (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;) when
   such verification is desired.</source>
          <target state="translated">HTTP не определяет конкретный механизм для обеспечения целостности сообщений, вместо этого полагаясь на способность обнаружения ошибок нижележащих транспортных протоколов и использование длины или кадрирования с разделителями-фрагментами для определения полноты. Дополнительные механизмы целостности, такие как хэш-функции или цифровые подписи, применяемые к контенту, могут быть выборочно добавлены к сообщениям через расширяемые поля заголовка метаданных. Исторически отсутствие единого механизма целостности оправдывалось неформальным характером большинства HTTP-коммуникаций. Однако преобладание HTTP в качестве механизма доступа к информации привело к его все более широкому использованию в средах, где проверка целостности сообщения имеет решающее значение.Пользовательским агентам рекомендуется реализовывать настраиваемые средства для обнаружения и сообщения о сбоях целостности сообщений, чтобы эти средства можно было использовать в средах, для которых необходима целостность. Например, браузер, используемый для просмотра истории болезни или информации о взаимодействии с лекарствами, должен указывать пользователю, когда такая информация обнаруживается протоколом как неполная, истекшая или поврежденная во время передачи. Такие механизмы могут выборочно включаться через расширения пользовательского агента или наличие метаданных целостности сообщения в ответе. Как минимум, пользовательские агенты должны предоставлять некоторую индикацию, которая позволяет пользователю различать полное и неполное ответное сообщение (Например, браузер, используемый для просмотра истории болезни или информации о взаимодействии с лекарствами, должен указывать пользователю, когда такая информация обнаруживается протоколом как неполная, истекшая или поврежденная во время передачи. Такие механизмы могут быть выборочно включены через расширения пользовательского агента или наличие метаданных целостности сообщения в ответе. Как минимум, пользовательские агенты должны предоставлять некоторую индикацию, которая позволяет пользователю различать полное и неполное ответное сообщение (Например, браузер, используемый для просмотра истории болезни или информации о взаимодействии с лекарствами, должен указывать пользователю, когда такая информация обнаруживается протоколом как неполная, истекшая или поврежденная во время передачи. Такие механизмы могут быть выборочно включены через расширения пользовательского агента или наличие метаданных целостности сообщения в ответе. Как минимум, пользовательские агенты должны предоставлять некоторую индикацию, которая позволяет пользователю различать полное и неполное ответное сообщение (Такие механизмы могут быть выборочно включены через расширения пользовательского агента или наличие метаданных целостности сообщения в ответе. Как минимум, пользовательские агенты должны предоставлять некоторую индикацию, которая позволяет пользователю различать полное и неполное ответное сообщение (Такие механизмы могут быть выборочно включены через расширения пользовательского агента или наличие метаданных целостности сообщения в ответе. Как минимум, пользовательские агенты должны предоставлять некоторую индикацию, которая позволяет пользователю различать полное и неполное ответное сообщение (&lt;a href=&quot;#section-3.4&quot;&gt;Раздел 3.4&lt;/a&gt; ), когда требуется такая проверка.</target>
        </trans-unit>
        <trans-unit id="87d2894d742e24a75af2f1ab57c0987684b7ec4b" translate="yes" xml:space="preserve">
          <source>HTTP does not include a request identifier for associating a given
   request message with its corresponding one or more response messages.
   Hence, it relies on the order of response arrival to correspond
   exactly to the order in which requests are made on the same
   connection.  More than one response message per request only occurs
   when one or more informational responses (1xx, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.2&quot;&gt;Section&amp;nbsp;6.2 of
   [RFC7231]&lt;/a&gt;) precede a final response to the same request. 

   A client that has more than one outstanding request on a connection
   MUST maintain a list of outstanding requests in the order sent and
   MUST associate each received response message on that connection to
   the highest ordered request that has not yet received a final
   (non-1xx) response.</source>
          <target state="translated">HTTP не включает идентификатор запроса для связывания данного сообщения запроса с соответствующим ему одним или несколькими ответными сообщениями. Следовательно, он полагается на то, что порядок получения ответа точно соответствует порядку, в котором запросы выполняются в том же соединении. Более одного ответного сообщения на запрос возникает только тогда, когда один или несколько информационных ответов (1xx, см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.2&quot;&gt;Раздел 6.2 [RFC7231]&lt;/a&gt; ) предшествуют окончательному ответу на тот же запрос. Клиент, который имеет более одного невыполненного запроса в соединении, ДОЛЖЕН поддерживать список невыполненных запросов в порядке отправки и ДОЛЖЕН связывать каждое полученное ответное сообщение в этом соединении с запросом наивысшего порядка, который еще не получил окончательный (не 1xx) ответ.</target>
        </trans-unit>
        <trans-unit id="125fe50c360004e5dcd111f8af56cce35d120574" translate="yes" xml:space="preserve">
          <source>HTTP does not place a predefined limit on the length of each header
   field or on the length of the header section as a whole, as described
   in &lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;.  Various ad hoc limitations on individual header
   field length are found in practice, often depending on the specific
   field semantics.

   A server that receives a request header field, or set of fields,
   larger than it wishes to process MUST respond with an appropriate 4xx
   (Client Error) status code.  Ignoring such header fields would
   increase the server's vulnerability to request smuggling attacks
   (&lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;).

   A client MAY discard or truncate received header fields that are
   larger than the client wishes to process if the field semantics are
   such that the dropped value(s) can be safely ignored without changing
   the message framing or response semantics.</source>
          <target state="translated">HTTP не устанавливает предопределенных ограничений на длину каждого поля заголовка или на длину раздела заголовка в целом, как описано в &lt;a href=&quot;#section-2.5&quot;&gt;Разделе 2.5&lt;/a&gt; . На практике встречаются различные специальные ограничения на длину отдельного поля заголовка, часто в зависимости от семантики конкретного поля. Сервер, который получает поле заголовка запроса или набор полей, размер которых больше, чем он хочет обработать, ДОЛЖЕН ответить соответствующим кодом состояния 4xx (ошибка клиента). Игнорирование таких полей заголовков повысит уязвимость сервера для атак контрабанды ( &lt;a href=&quot;#section-9.5&quot;&gt;Раздел 9.5).&lt;/a&gt;). Клиент МОЖЕТ отбросить или обрезать полученные поля заголовка, размер которых превышает размер, который клиент желает обработать, если семантика поля такова, что отброшенные значения могут быть безопасно проигнорированы без изменения кадрирования сообщения или семантики ответа.</target>
        </trans-unit>
        <trans-unit id="7af78e2e7197dc15cd8324e0e4f1f29b3b33d7e4" translate="yes" xml:space="preserve">
          <source>HTTP does not use the Content-Transfer-Encoding (CTE) field of &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;. Proxies and gateways from MIME-compliant protocols to HTTP MUST
   remove any non-identity CTE (&quot;quoted-printable&quot; or &quot;base64&quot;) encoding
   prior to delivering the response message to an HTTP client.

   Proxies and gateways from HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encoding for safe transport on that protocol, where &quot;safe 

   transport&quot; is defined by the limitations of the protocol being used.
   Such a proxy or gateway SHOULD label the data with an appropriate
   Content-Transfer-Encoding if doing so will improve the likelihood of
   safe transport over the destination protocol.</source>
          <target state="translated">HTTP не использует поле Content-Transfer-Encoding (CTE) &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt; . Прокси-серверы и шлюзы из MIME-совместимых протоколов в HTTP ДОЛЖНЫ удалить любую неидентификационную кодировку CTE (&amp;laquo;quoted-printable&amp;raquo; или &amp;laquo;base64&amp;raquo;) перед доставкой ответного сообщения клиенту HTTP. Прокси-серверы и шлюзы от HTTP к протоколам, совместимым с MIME, несут ответственность за обеспечение того, чтобы сообщение было в правильном формате и кодировке для безопасной транспортировки по этому протоколу, где &amp;laquo;безопасный транспорт&amp;raquo; определяется ограничениями используемого протокола. Такой прокси-сервер или шлюз ДОЛЖЕН пометить данные соответствующим Content-Transfer-Encoding, если это повысит вероятность безопасной передачи по протоколу назначения.</target>
        </trans-unit>
        <trans-unit id="983fa6dde64a744fecec4d6eaeb6ead62114677a" translate="yes" xml:space="preserve">
          <source>HTTP does not use the Content-Transfer-Encoding field of MIME.
   Proxies and gateways from MIME-compliant protocols to HTTP need to
   remove any Content-Transfer-Encoding prior to delivering the response
   message to an HTTP client.

   Proxies and gateways from HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encoding for safe transport on that protocol, where &quot;safe
   transport&quot; is defined by the limitations of the protocol being used.
   Such a proxy or gateway ought to transform and label the data with an
   appropriate Content-Transfer-Encoding if doing so will improve the
   likelihood of safe transport over the destination protocol.</source>
          <target state="translated">HTTP не использует поле Content-Transfer-Encoding в MIME.Прокси и шлюзы от MIME-совместимых протоколов к HTTP должны удалять любое поле Content-Transfer-Encoding перед доставкой ответного сообщения клиенту HTTP.Прокси и шлюзы от HTTP до MIME-совместимых протоколов отвечают за то,чтобы сообщение было в правильном формате и кодировке для безопасной транспортировки по этому протоколу,где &quot;безопасная транспортировка&quot; определяется ограничениями используемого протокола.Такой прокси-сервер или шлюз должен преобразовывать и маркировать данные соответствующим Content-Transfer-Encoding,если это повысит вероятность безопасной транспортировки по протоколу назначения.</target>
        </trans-unit>
        <trans-unit id="b9046bf180bf7e78db825b7e37fce06636dac2f9" translate="yes" xml:space="preserve">
          <source>HTTP enables the use of intermediaries to satisfy requests through a
   chain of connections.  There are three common forms of HTTP
   intermediary: proxy, gateway, and tunnel.  In some cases, a single
   intermediary might act as an origin server, proxy, gateway, or
   tunnel, switching behavior based on the nature of each request.

            &amp;gt;             &amp;gt;             &amp;gt;             &amp;gt;
       UA =========== A =========== B =========== C =========== O
                  &amp;lt;             &amp;lt;             &amp;lt;             &amp;lt;

   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server.  A request or response message that
   travels the whole chain will pass through four separate connections.
   Some HTTP communication options might apply only to the connection
   with the nearest, non-tunnel neighbor, only to the endpoints of the
   chain, or to all connections along the chain.  Although the diagram
   is linear, each participant might be engaged in multiple,
   simultaneous communications.  For example, B might be receiving
   requests from many clients other than A, and/or forwarding requests
   to servers other than C, at the same time that it is handling A's 

   request.  Likewise, later requests might be sent through a different
   path of connections, often based on dynamic configuration for load
   balancing.

   The terms &quot;upstream&quot; and &quot;downstream&quot; are used to describe
   directional requirements in relation to the message flow: all
   messages flow from upstream to downstream.  The terms &quot;inbound&quot; and
   &quot;outbound&quot; are used to describe directional requirements in relation
   to the request route: &quot;inbound&quot; means toward the origin server and
   &quot;outbound&quot; means toward the user agent.

   A &quot;proxy&quot; is a message-forwarding agent that is selected by the
   client, usually via local configuration rules, to receive requests
   for some type(s) of absolute URI and attempt to satisfy those
   requests via translation through the HTTP interface.  Some
   translations are minimal, such as for proxy requests for &quot;http&quot; URIs,
   whereas other requests might require translation to and from entirely
   different application-level protocols.  Proxies are often used to
   group an organization's HTTP requests through a common intermediary
   for the sake of security, annotation services, or shared caching.
   Some proxies are designed to apply transformations to selected
   messages or payloads while they are being forwarded, as described in
   &lt;a href=&quot;#section-5.7.2&quot;&gt;Section 5.7.2&lt;/a&gt;.

   A &quot;gateway&quot; (a.k.a. &quot;reverse proxy&quot;) is an intermediary that acts as
   an origin server for the outbound connection but translates received
   requests and forwards them inbound to another server or servers.
   Gateways are often used to encapsulate legacy or untrusted
   information services, to improve server performance through
   &quot;accelerator&quot; caching, and to enable partitioning or load balancing
   of HTTP services across multiple machines.

   All HTTP requirements applicable to an origin server also apply to
   the outbound communication of a gateway.  A gateway communicates with
   inbound servers using any protocol that it desires, including private
   extensions to HTTP that are outside the scope of this specification.
   However, an HTTP-to-HTTP gateway that wishes to interoperate with
   third-party HTTP servers ought to conform to user agent requirements
   on the gateway's inbound connection.

   A &quot;tunnel&quot; acts as a blind relay between two connections without
   changing the messages.  Once active, a tunnel is not considered a
   party to the HTTP communication, though the tunnel might have been
   initiated by an HTTP request.  A tunnel ceases to exist when both
   ends of the relayed connection are closed.  Tunnels are used to
   extend a virtual connection through an intermediary, such as when
   Transport Layer Security (TLS, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]) is used to establish
   confidential communication through a shared firewall proxy. 

   The above categories for intermediary only consider those acting as
   participants in the HTTP communication.  There are also
   intermediaries that can act on lower layers of the network protocol
   stack, filtering or redirecting HTTP traffic without the knowledge or
   permission of message senders.  Network intermediaries are
   indistinguishable (at a protocol level) from a man-in-the-middle
   attack, often introducing security flaws or interoperability problems
   due to mistakenly violating HTTP semantics.

   For example, an &quot;interception proxy&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt;] (also commonly known
   as a &quot;transparent proxy&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC1919&lt;/a&gt;] or &quot;captive portal&quot;) differs from
   an HTTP proxy because it is not selected by the client.  Instead, an
   interception proxy filters or redirects outgoing TCP port 80 packets
   (and occasionally other common port traffic).  Interception proxies
   are commonly found on public network access points, as a means of
   enforcing account subscription prior to allowing use of non-local
   Internet services, and within corporate firewalls to enforce network
   usage policies.

   HTTP is defined as a stateless protocol, meaning that each request
   message can be understood in isolation.  Many implementations depend
   on HTTP's stateless design in order to reuse proxied connections or
   dynamically load balance requests across multiple servers.  Hence, a
   server MUST NOT assume that two requests on the same connection are
   from the same user agent unless the connection is secured and
   specific to that agent.  Some non-standard HTTP extensions (e.g.,
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;RFC4559&lt;/a&gt;]) have been known to violate this requirement, resulting in
   security and interoperability problems.</source>
          <target state="translated">HTTP позволяет использовать посредников для удовлетворения запросов через цепочку соединений. Существует три распространенных формы посредника HTTP: прокси, шлюз и туннель. В некоторых случаях один посредник может действовать как исходный сервер, прокси, шлюз или туннель, переключая поведение в зависимости от характера каждого запроса. &amp;gt;&amp;gt;&amp;gt;&amp;gt; UA =========== A =========== B =========== C ========= == O &amp;lt;&amp;lt;&amp;lt;&amp;lt;На рисунке выше показаны три посредника (A, B и C) между пользовательским агентом и исходным сервером. Сообщение запроса или ответа, которое проходит по всей цепочке, проходит через четыре отдельных соединения. Некоторые параметры связи HTTP могут применяться только к соединению с ближайшим,не-туннельный сосед, только к конечным точкам цепочки или ко всем соединениям в цепочке. Хотя диаграмма линейна, каждый участник может участвовать в нескольких одновременных коммуникациях. Например, B может получать запросы от многих клиентов, отличных от A, и / или перенаправлять запросы на серверы, отличные от C, в то же время, когда он обрабатывает запрос A. Точно так же последующие запросы могут быть отправлены через другой путь соединений, часто основанный на динамической конфигурации для балансировки нагрузки. Термины &amp;laquo;восходящий&amp;raquo; и &amp;laquo;нисходящий&amp;raquo; используются для описания требований к направлению потока сообщений: все сообщения проходят от восходящего к нисходящему. Термины &quot;входящий&quot; и &quot;исходящий&quot;используются для описания требований к направлению относительно маршрута запроса: &amp;laquo;входящий&amp;raquo; означает к исходному серверу и &amp;laquo;исходящий&amp;raquo; означает к пользовательскому агенту. &amp;laquo;Прокси-сервер&amp;raquo; - это агент пересылки сообщений, который выбирается клиентом, обычно с помощью правил локальной конфигурации, для получения запросов на некоторые типы абсолютных URI и попытки удовлетворить эти запросы посредством трансляции через интерфейс HTTP. Некоторые переводы минимальны, например, для прокси-запросов для http URI, тогда как для других запросов может потребоваться перевод в и из совершенно других протоколов уровня приложения. Прокси-серверы часто используются для группировки HTTP-запросов организации через общего посредника в целях безопасности, служб аннотации или общего кэширования.Некоторые прокси-серверы предназначены для применения преобразований к выбранным сообщениям или полезным нагрузкам во время их пересылки, как описано в &lt;a href=&quot;#section-5.7.2&quot;&gt;Раздел 5.7.2&lt;/a&gt;, &amp;laquo;Шлюз&amp;raquo; (он же &amp;laquo;обратный прокси&amp;raquo;) - это посредник, который действует как исходный сервер для исходящего соединения, но транслирует полученные запросы и перенаправляет их входящие на другой сервер или серверы. Шлюзы часто используются для инкапсуляции устаревших или ненадежных информационных служб, для повышения производительности сервера за счет &amp;laquo;ускорительного&amp;raquo; кэширования, а также для обеспечения разделения или балансировки нагрузки HTTP-сервисов на нескольких машинах. Все требования HTTP, применимые к исходному серверу, также применяются к исходящей связи шлюза. Шлюз взаимодействует с серверами входящей почты, используя любой протокол, который он желает, включая частные расширения HTTP, которые выходят за рамки данной спецификации. Тем не мение,шлюз HTTP-HTTP, который желает взаимодействовать со сторонними HTTP-серверами, должен соответствовать требованиям пользовательского агента к входящему соединению шлюза. &amp;laquo;Туннель&amp;raquo; действует как слепой ретранслятор между двумя соединениями без изменения сообщений. Будучи активным, туннель не считается стороной HTTP-соединения, хотя туннель мог быть инициирован HTTP-запросом. Туннель перестает существовать, когда закрываются оба конца ретранслируемого соединения. Туннели используются для расширения виртуального соединения через посредника, например, когда безопасность транспортного уровня (TLS, [туннель не считается стороной HTTP-соединения, хотя туннель мог быть инициирован HTTP-запросом. Туннель перестает существовать, когда закрываются оба конца ретранслируемого соединения. Туннели используются для расширения виртуального соединения через посредника, например, когда безопасность транспортного уровня (TLS, [туннель не считается стороной HTTP-соединения, хотя туннель мог быть инициирован HTTP-запросом. Туннель перестает существовать, когда закрываются оба конца ретранслируемого соединения. Туннели используются для расширения виртуального соединения через посредника, например, когда безопасность транспортного уровня (TLS, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt; ]) используется для установления конфиденциальной связи через общий прокси-сервер межсетевого экрана. Вышеупомянутые категории для посредников рассматривают только тех, кто действует как участники HTTP-коммуникации. Существуют также посредники, которые могут действовать на нижних уровнях стека сетевых протоколов, фильтруя или перенаправляя HTTP-трафик без ведома или разрешения отправителей сообщений. Сетевые посредники неотличимы (на уровне протокола) от атаки типа &amp;laquo;злоумышленник в середине&amp;raquo;, часто вызывая недостатки безопасности или проблемы взаимодействия из-за ошибочного нарушения семантики HTTP. Например, &amp;laquo;прокси-сервер перехвата&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt; ] (также известный как &amp;laquo;прозрачный прокси-сервер&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC1919&lt;/a&gt;] или &amp;laquo;Captive Portal&amp;raquo;) отличается от прокси-сервера HTTP, поскольку он не выбирается клиентом. Вместо этого прокси-сервер перехвата фильтрует или перенаправляет исходящие пакеты TCP-порта 80 (а иногда и другой общий трафик порта). Прокси-серверы перехвата обычно используются в точках доступа к общедоступной сети в качестве средства обеспечения подписки на учетную запись до разрешения использования нелокальных Интернет-сервисов, а также в корпоративных брандмауэрах для обеспечения соблюдения политик использования сети. HTTP определяется как протокол без сохранения состояния, что означает, что каждое сообщение запроса можно понимать изолированно. Многие реализации зависят от структуры HTTP без сохранения состояния, чтобы повторно использовать прокси-соединения или динамически балансировать нагрузку запросов на нескольких серверах. Следовательно,сервер НЕ ДОЛЖЕН предполагать, что два запроса в одном и том же соединении исходят от одного и того же пользовательского агента, если соединение не является защищенным и специфичным для этого агента. Некоторые нестандартные расширения HTTP (например, [&lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;RFC4559&lt;/a&gt; ]) нарушают это требование, что приводит к проблемам с безопасностью и совместимостью.</target>
        </trans-unit>
        <trans-unit id="8db8a2b5c25cf2c27eaf8a47b284cc3768fbc846" translate="yes" xml:space="preserve">
          <source>HTTP flow</source>
          <target state="translated">поток HTTP</target>
        </trans-unit>
        <trans-unit id="ef8491af63ac960b4c3bb2e915780d4330bd99fe" translate="yes" xml:space="preserve">
          <source>HTTP frames are now transparent to Web developers. This is an additional step in HTTP/2, between HTTP/1.1 messages and the underlying transport protocol. No changes are needed in the APIs used by Web developers to utilize HTTP frames; when available in both the browser and the server, HTTP/2 is switched on and used.</source>
          <target state="translated">HTTP-фреймы теперь прозрачны для веб-разработчиков.Это дополнительный шаг в HTTP/2,между сообщениями HTTP/1.1 и базовым транспортным протоколом.Никаких изменений не требуется в API,используемых веб-разработчиками для использования HTTP-фреймов;когда HTTP/2 доступен как в браузере,так и на сервере,он включается и используется.</target>
        </trans-unit>
        <trans-unit id="c4d23b3cd8874c5cafac5c54211af2245465e64f" translate="yes" xml:space="preserve">
          <source>HTTP has a concept of &lt;em&gt;conditional requests&lt;/em&gt;, where the result, and even the success of a request, can be changed by comparing the affected resources with the value of a &lt;em&gt;validator&lt;/em&gt;. Such requests can be useful to validate the content of a cache, and sparing a useless control, to verify the integrity of a document, like when resuming a download, or when preventing to lose updates when uploading or modifying a document on the server.</source>
          <target state="translated">HTTP имеет концепцию &lt;em&gt;условных запросов&lt;/em&gt; , где результат и даже успех запроса могут быть изменены путем сравнения затронутых ресурсов со значением &lt;em&gt;валидатора&lt;/em&gt; . Такие запросы могут быть полезны для проверки содержимого кеша и сохранения бесполезного элемента управления, для проверки целостности документа, например, при возобновлении загрузки или для предотвращения потери обновлений при загрузке или изменении документа на сервере.</target>
        </trans-unit>
        <trans-unit id="d453645149af5aacd6ac81b6f3d3ee73f00f71ff" translate="yes" xml:space="preserve">
          <source>HTTP has been in use since 1990.  The first version, later referred
   to as HTTP/0.9, was a simple protocol for hypertext data transfer
   across the Internet, using only a single request method (GET) and no
   metadata.  HTTP/1.0, as defined by [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;], added a range of
   request methods and MIME-like messaging, allowing for metadata to be
   transferred and modifiers placed on the request/response semantics.
   However, HTTP/1.0 did not sufficiently take into consideration the
   effects of hierarchical proxies, caching, the need for persistent
   connections, or name-based virtual hosts.  The proliferation of
   incompletely implemented applications calling themselves &quot;HTTP/1.0&quot;
   further necessitated a protocol version change in order for two
   communicating applications to determine each other's true
   capabilities.

   HTTP/1.1 remains compatible with HTTP/1.0 by including more stringent
   requirements that enable reliable implementations, adding only those
   features that can either be safely ignored by an HTTP/1.0 recipient
   or only be sent when communicating with a party advertising
   conformance with HTTP/1.1.

   HTTP/1.1 has been designed to make supporting previous versions easy.
   A general-purpose HTTP/1.1 server ought to be able to understand any
   valid request in the format of HTTP/1.0, responding appropriately
   with an HTTP/1.1 message that only uses features understood (or
   safely ignored) by HTTP/1.0 clients.  Likewise, an HTTP/1.1 client
   can be expected to understand any valid HTTP/1.0 response.

   Since HTTP/0.9 did not support header fields in a request, there is
   no mechanism for it to support name-based virtual hosts (selection of
   resource by inspection of the Host header field).  Any server that
   implements name-based virtual hosts ought to disable support for
   HTTP/0.9.  Most requests that appear to be HTTP/0.9 are, in fact,
   badly constructed HTTP/1.x requests caused by a client failing to
   properly encode the request-target.</source>
          <target state="translated">HTTP используется с 1990 года. Первая версия, позже названная HTTP / 0.9, была простым протоколом для передачи гипертекстовых данных через Интернет, использующим только один метод запроса (GET) и не использовавший метаданные. HTTP / 1.0, как определено в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;], добавлен ряд методов запроса и обмена сообщениями в стиле MIME, что позволяет передавать метаданные и помещать модификаторы в семантику запроса / ответа. Однако в HTTP / 1.0 недостаточно учитывались эффекты иерархических прокси, кэширования, необходимость постоянных соединений или виртуальных хостов на основе имен. Распространение не полностью реализованных приложений, называющих себя &amp;laquo;HTTP / 1.0&amp;raquo;, в дальнейшем потребовало изменения версии протокола, чтобы два взаимодействующих приложения могли определять истинные возможности друг друга. HTTP / 1.1 остается совместимым с HTTP / 1.0 за счет включения более строгих требований, обеспечивающих надежную реализацию, добавляя только те функции, которые можно безопасно игнорировать с помощью HTTP / 1.0 или отправляться только при общении с сторонней рекламой в соответствии с HTTP / 1.1. HTTP / 1.1 был разработан, чтобы упростить поддержку предыдущих версий. Сервер HTTP / 1.1 общего назначения должен уметь понимать любой действительный запрос в формате HTTP / 1.0, отвечая соответствующим образом сообщением HTTP / 1.1, которое использует только функции, понятные (или безопасно игнорируемые) клиентами HTTP / 1.0. Точно так же можно ожидать, что клиент HTTP / 1.1 поймет любой действительный ответ HTTP / 1.0. Поскольку HTTP / 0.9 не поддерживает поля заголовка в запросе, для него нет механизма поддержки виртуальных хостов на основе имен (выбор ресурса путем проверки поля заголовка Host). Любой сервер, реализующий виртуальные хосты на основе имен, должен отключить поддержку HTTP / 0.9. Большинство запросов выглядят как HTTP / 0.9, по сути, являются плохо построенными запросами HTTP / 1.x, вызванными тем, что клиент не смог правильно кодировать цель запроса.</target>
        </trans-unit>
        <trans-unit id="d9e77166a8c6244ca9fbbd6e6d1edc2dc7a40b2e" translate="yes" xml:space="preserve">
          <source>HTTP has the ability to host programs that are executed on client
   machines.  These programs can take many forms including Web scripts,
   executables, plug-in modules, and macros in documents.  WebDAV does
   not change any of the security concerns around these programs, yet
   often WebDAV is used in contexts where a wide range of users can
   publish documents on a server.  The server might not have a close 

   trust relationship with the author that is publishing the document.
   Servers that allow clients to publish arbitrary content can usefully
   implement precautions to check that content published to the server
   is not harmful to other clients.  Servers could do this by techniques
   such as restricting the types of content that is allowed to be
   published and running virus and malware detection software on
   published content.  Servers can also mitigate the risk by having
   appropriate access restriction and authentication of users that are
   allowed to publish content to the server.</source>
          <target state="translated">HTTP имеет возможность размещать программы,которые выполняются на клиентских машинах.Эти программы могут принимать различные формы,включая веб-скрипты,исполняемые файлы,подключаемые модули и макросы в документах.WebDAV не изменяет ни одного из аспектов безопасности этих программ,но часто WebDAV используется в контекстах,где широкий круг пользователей может публиковать документы на сервере.Сервер может не иметь тесных доверительных отношений с автором,который публикует документ.Серверы,позволяющие клиентам публиковать произвольное содержимое,могут с пользой применять меры предосторожности для проверки того,что содержимое,публикуемое на сервере,не вредит другим клиентам.Серверы могут делать это с помощью таких методов,как ограничение типов содержимого,которое разрешено публиковать,и запуск программного обеспечения для обнаружения вирусов и вредоносного ПО на опубликованном содержимом.Серверы также могут снизить риск путем соответствующего ограничения доступа и проверки подлинности пользователей,которым разрешено публиковать содержимое на сервере.</target>
        </trans-unit>
        <trans-unit id="d67c4ad19745067f8e2d7649769ed21fc1c5ca16" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry located at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers&quot;&gt;http://www.iana.org/assignments/message-headers&lt;/a&gt;&amp;gt;, as defined by
   [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;].</source>
          <target state="translated">Поля заголовка HTTP регистрируются в реестре &amp;laquo;Заголовки сообщений&amp;raquo;, расположенном по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers&quot;&gt;http://www.iana.org/assignments/message-headers&lt;/a&gt; &amp;gt;, как определено в [ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="1d6d97f7196be4dd0bf90ee5372fccc2a746c5ee" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +-------------------+----------+----------+---------------+
   | Header Field Name | Protocol | Status   | Reference     |
   +-------------------+----------+----------+---------------+
   | Connection        | http     | standard | &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;   |
   | Content-Length    | http     | standard | &lt;a href=&quot;#section-3.3.2&quot;&gt;Section 3.3.2&lt;/a&gt; |
   | Host              | http     | standard | &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;   |
   | TE                | http     | standard | &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;   |
   | Trailer           | http     | standard | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;   |
   | Transfer-Encoding | http     | standard | &lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt; |
   | Upgrade           | http     | standard | &lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;   |
   | Via               | http     | standard | &lt;a href=&quot;#section-5.7.1&quot;&gt;Section 5.7.1&lt;/a&gt; |
   +-------------------+----------+----------+---------------+

   Furthermore, the header field-name &quot;Close&quot; has been registered as
   &quot;reserved&quot;, since using that name as an HTTP header field might
   conflict with the &quot;close&quot; connection option of the Connection header
   field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Close             | http     | reserved | &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">Поля заголовка HTTP регистрируются в реестре &amp;laquo;Заголовки сообщений&amp;raquo;, который ведется по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt;. В этом документе определены следующие поля заголовка HTTP, поэтому реестр &amp;laquo;Имена полей постоянного заголовка сообщения&amp;raquo; был соответствующим образом обновлен (см. [ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]). + ------------------- + ---------- + ---------- + ------- -------- + | Имя поля заголовка | Протокол | Статус | Справка | + ------------------- + ---------- + ---------- + ------- -------- + | Подключение | http | стандарт | &lt;a href=&quot;#section-6.1&quot;&gt;Раздел 6.1&lt;/a&gt; | | Content-Length | http | стандарт | &lt;a href=&quot;#section-3.3.2&quot;&gt;Раздел 3.3.2&lt;/a&gt; | | Хост | http | стандарт | &lt;a href=&quot;#section-5.4&quot;&gt;Раздел 5.4&lt;/a&gt; | | TE | http | стандарт | &lt;a href=&quot;#section-4.3&quot;&gt;Раздел 4.3&lt;/a&gt; | | Трейлер | http | стандарт | &lt;a href=&quot;#section-4.4&quot;&gt;Раздел 4.4&lt;/a&gt; | | Передача-кодирование | http | стандарт | &lt;a href=&quot;#section-3.3.1&quot;&gt;Раздел 3.3.1&lt;/a&gt; | | Обновление | http | стандарт | &lt;a href=&quot;#section-6.7&quot;&gt;Раздел 6.7&lt;/a&gt; | | Через | http | стандарт | &lt;a href=&quot;#section-5.7.1&quot;&gt;Раздел 5.7.1&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- -------- + Кроме того, имя поля заголовка &amp;laquo;Close&amp;raquo; было зарегистрировано как &amp;laquo;зарезервировано&amp;raquo;, поскольку использование этого имени в качестве поля заголовка HTTP может конфликтовать с опцией подключения &amp;laquo;close&amp;raquo; в поле заголовка соединения ( &lt;a href=&quot;#section-6.1&quot;&gt;Раздел 6.1&lt;/a&gt;). + ------------------- + ---------- + ---------- + ------- ------ + | Имя поля заголовка | Протокол | Статус | Справка | + ------------------- + ---------- + ---------- + ------- ------ + | Закрыть | http | зарезервировано | &lt;a href=&quot;#section-8.1&quot;&gt;Раздел 8.1&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ + Контроллер изменений: &amp;laquo;IETF (iesg@ietf.org) - Инженерная группа Интернета&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="66ddb22b9ea74c6c2384f567cca6126c75a248f7" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +---------------------+----------+----------+-------------+
   | Header Field Name   | Protocol | Status   | Reference   |
   +---------------------+----------+----------+-------------+
   | Authorization       | http     | standard | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   | Proxy-Authenticate  | http     | standard | &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt; |
   | Proxy-Authorization | http     | standard | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; |
   | WWW-Authenticate    | http     | standard | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   +---------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">Поля заголовка HTTP регистрируются в реестре &amp;laquo;Заголовки сообщений&amp;raquo;, который ведется по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt;. В этом документе определены следующие поля заголовка HTTP, поэтому реестр &amp;laquo;Имена полей постоянного заголовка сообщения&amp;raquo; был соответствующим образом обновлен (см. [ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]). + --------------------- + ---------- + ---------- + ----- -------- + | Имя поля заголовка | Протокол | Статус | Справка | + --------------------- + ---------- + ---------- + ----- -------- + | Авторизация | http | стандарт | &lt;a href=&quot;#section-4.2&quot;&gt;Раздел 4.2&lt;/a&gt; | | Прокси-аутентификация | http | стандарт | &lt;a href=&quot;#section-4.3&quot;&gt;Раздел 4.3&lt;/a&gt; | | Прокси-авторизация | http | стандарт | &lt;a href=&quot;#section-4.4&quot;&gt;Раздел 4.4&lt;/a&gt;| | WWW-аутентификация | http | стандарт | &lt;a href=&quot;#section-4.1&quot;&gt;Раздел 4.1&lt;/a&gt; | + --------------------- + ---------- + ---------- + ----- -------- + Контроллер изменений: &amp;laquo;IETF (iesg@ietf.org) - Инженерная группа Интернета&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="20431a45dc8eadae77ecc94ccdfbb95f3cbd8c6e" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the
   permanent registrations below (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]):

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Accept-Ranges     | http     | standard | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   | Content-Range     | http     | standard | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   | If-Range          | http     | standard | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   | Range             | http     | standard | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">Поля заголовка HTTP регистрируются в реестре &amp;laquo;Заголовки сообщений&amp;raquo;, который ведется по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt;. В этом документе определены следующие поля заголовка HTTP, поэтому связанные с ними записи реестра были обновлены в соответствии с указанными ниже постоянными регистрациями (см. [ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]): + ------------------- + ---------- + ---------- + ------------- + | Имя поля заголовка | Протокол | Статус | Справка | + ------------------- + ---------- + ---------- + ------- ------ + | Принять-диапазоны | http | стандарт | &lt;a href=&quot;#section-2.3&quot;&gt;Раздел 2.3&lt;/a&gt; | | Content-Range | http | стандарт | &lt;a href=&quot;#section-4.2&quot;&gt;Раздел 4.2&lt;/a&gt; | | Если-диапазон | http | стандарт | &lt;a href=&quot;#section-3.2&quot;&gt;Раздел 3.2&lt;/a&gt;| | Диапазон | http | стандарт | &lt;a href=&quot;#section-3.1&quot;&gt;Раздел 3.1&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ + Контроллер изменений: &amp;laquo;IETF (iesg@ietf.org) - Инженерная группа Интернета&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="abd476ef3b0f23a2fb0e1c507e9aa66688224abd" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the
   permanent registrations below (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]):

   +---------------------+----------+----------+-------------+
   | Header Field Name   | Protocol | Status   | Reference   |
   +---------------------+----------+----------+-------------+
   | ETag                | http     | standard | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   | If-Match            | http     | standard | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   | If-Modified-Since   | http     | standard | &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt; |
   | If-None-Match       | http     | standard | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   | If-Unmodified-Since | http     | standard | &lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt; |
   | Last-Modified       | http     | standard | &lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt; |
   +---------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">Поля заголовка HTTP регистрируются в реестре &amp;laquo;Заголовки сообщений&amp;raquo;, который ведется по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt;. В этом документе определены следующие поля заголовка HTTP, поэтому связанные с ними записи реестра были обновлены в соответствии с указанными ниже постоянными регистрациями (см. [ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]): + ------------------- - + ---------- + ---------- + ------------- + | Имя поля заголовка | Протокол | Статус | Справка | + --------------------- + ---------- + ---------- + ----- -------- + | ETag | http | стандарт | &lt;a href=&quot;#section-2.3&quot;&gt;Раздел 2.3&lt;/a&gt; | | If-Match | http | стандарт | &lt;a href=&quot;#section-3.1&quot;&gt;Раздел 3.1&lt;/a&gt; | | If-Modified-Since | http | стандарт | &lt;a href=&quot;#section-3.3&quot;&gt;Раздел 3.3&lt;/a&gt;| | Если-None-Match | http | стандарт | &lt;a href=&quot;#section-3.2&quot;&gt;Раздел 3.2&lt;/a&gt; | | If-Unmodified-Since | http | стандарт | &lt;a href=&quot;#section-3.4&quot;&gt;Раздел 3.4&lt;/a&gt; | | Последнее изменение | http | стандарт | &lt;a href=&quot;#section-2.2&quot;&gt;Раздел 2.2&lt;/a&gt; | + --------------------- + ---------- + ---------- + ----- -------- + Контроллер изменений: &amp;laquo;IETF (iesg@ietf.org) - Инженерная группа Интернета&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ab0fef364114802e59e987c48134f247b0ff269b" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;. 

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Age               | http     | standard | &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; |
   | Cache-Control     | http     | standard | &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt; |
   | Expires           | http     | standard | &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt; |
   | Pragma            | http     | standard | &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt; |
   | Warning           | http     | standard | &lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">Поля заголовка HTTP регистрируются в реестре &amp;laquo;Заголовки сообщений&amp;raquo;, который ведется по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt;. В этом документе определены следующие поля заголовка HTTP, поэтому реестр &amp;laquo;Имена полей постоянного заголовка сообщения&amp;raquo; был соответствующим образом обновлен (см. [ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]). + ------------------- + ---------- + ---------- + ------- ------ + | Имя поля заголовка | Протокол | Статус | Справка | + ------------------- + ---------- + ---------- + ------- ------ + | Возраст | http | стандарт | &lt;a href=&quot;#section-5.1&quot;&gt;Раздел 5.1&lt;/a&gt; | | Cache-Control | http | стандарт | &lt;a href=&quot;#section-5.2&quot;&gt;Раздел 5.2&lt;/a&gt; | | Истекает | http | стандарт | &lt;a href=&quot;#section-5.3&quot;&gt;Раздел 5.3&lt;/a&gt;| | Прагма | http | стандарт | &lt;a href=&quot;#section-5.4&quot;&gt;Раздел 5.4&lt;/a&gt; | | Предупреждение | http | стандарт | &lt;a href=&quot;#section-5.5&quot;&gt;Раздел 5.5&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ + Контроллер изменений: &amp;laquo;IETF (iesg@ietf.org) - Инженерная группа Интернета&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e44fb4fb2547d4ca031836cab9543ab18adb9840" translate="yes" xml:space="preserve">
          <source>HTTP header fields which will be present in the trailer part of chunked messages. These header fields are &lt;strong&gt;disallowed&lt;/strong&gt;:</source>
          <target state="translated">Поля HTTP-заголовка, которые будут присутствовать в конце фрагментированных сообщений. Эти поля заголовка &lt;strong&gt;запрещены&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c4df20b3f27418d9364765f0fd87a2e34f853b85" translate="yes" xml:space="preserve">
          <source>HTTP header fields, which include general-header (&lt;a href=&quot;#section-4.5&quot;&gt;section 4.5&lt;/a&gt;),
   request-header (&lt;a href=&quot;#section-5.3&quot;&gt;section 5.3&lt;/a&gt;), response-header (&lt;a href=&quot;#section-6.2&quot;&gt;section 6.2&lt;/a&gt;), and
   entity-header (&lt;a href=&quot;#section-7.1&quot;&gt;section 7.1&lt;/a&gt;) fields, follow the same generic format as
   that given in &lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Each header field consists
   of a name followed by a colon (&quot;:&quot;) and the field value. Field names
   are case-insensitive. The field value MAY be preceded by any amount
   of LWS, though a single SP is preferred. Header fields can be
   extended over multiple lines by preceding each extra line with at
   least one SP or HT. Applications ought to follow &quot;common form&quot;, where
   one is known or indicated, when generating HTTP constructs, since
   there might exist some implementations that fail to accept anything 

   beyond the common forms.

       message-header = field-name &quot;:&quot; [ field-value ]
       field-name     = token
       field-value    = *( field-content | LWS )
       field-content  = &amp;lt;the OCTETs making up the field-value
                        and consisting of either *TEXT or combinations
                        of token, separators, and quoted-string&amp;gt;

   The field-content does not include any leading or trailing LWS:
   linear white space occurring before the first non-whitespace
   character of the field-value or after the last non-whitespace
   character of the field-value. Such leading or trailing LWS MAY be
   removed without changing the semantics of the field value. Any LWS
   that occurs between field-content MAY be replaced with a single SP
   before interpreting the field value or forwarding the message
   downstream.

   The order in which header fields with differing field names are
   received is not significant. However, it is &quot;good practice&quot; to send
   general-header fields first, followed by request-header or response-
   header fields, and ending with the entity-header fields.

   Multiple message-header fields with the same field-name MAY be
   present in a message if and only if the entire field-value for that
   header field is defined as a comma-separated list [i.e., #(values)].
   It MUST be possible to combine the multiple header fields into one
   &quot;field-name: field-value&quot; pair, without changing the semantics of the
   message, by appending each subsequent field-value to the first, each
   separated by a comma. The order in which header fields with the same
   field-name are received is therefore significant to the
   interpretation of the combined field value, and thus a proxy MUST NOT
   change the order of these field values when a message is forwarded.</source>
          <target state="translated">Поля HTTP-заголовка, которые включают в себя поля общего заголовка ( &lt;a href=&quot;#section-4.5&quot;&gt;раздел 4.5&lt;/a&gt; ), заголовка запроса ( &lt;a href=&quot;#section-5.3&quot;&gt;раздел 5.3&lt;/a&gt; ), заголовка ответа ( &lt;a href=&quot;#section-6.2&quot;&gt;раздел 6.2&lt;/a&gt; ) и заголовка объекта ( &lt;a href=&quot;#section-7.1&quot;&gt;раздел 7.1&lt;/a&gt; ), имеют тот же общий формат, что и приведенный в &lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-3.1&quot;&gt;разделе 3.1 RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Каждое поле заголовка состоит из имени, за которым следует двоеточие (&quot;:&quot;) и значения поля. Имена полей не чувствительны к регистру. Значению поля МОЖЕТ предшествовать любое количество LWS, хотя предпочтительнее использовать один SP. Поля заголовка могут быть расширены на несколько строк, если перед каждой дополнительной строкой стоит хотя бы один SP или HT. Приложения должны следовать &amp;laquo;общей форме&amp;raquo;, если она известна или указана, при создании конструкций HTTP, поскольку могут существовать некоторые реализации, которые не могут принимать что-либо, кроме общих форм. заголовок-сообщения = имя-поля &quot;:&quot; [значение-поля] имя-поля = токен значение-поля = * (содержимое-поля | LWS) содержимое-поля = &amp;lt;OCTET, составляющие значение поля и состоящие либо из * TEXT, либо из комбинаций токена, разделителей и строки в кавычках&amp;gt; Содержимое поля не включает никаких начальных или конечных LWS: линейные пробелы перед первым непробельным символом значения поля или после последнего непробельного символа значения поля. Такой начальный или конечный LWS МОЖЕТ быть удален без изменения семантики значения поля. Любой LWS, который возникает между содержимым поля, МОЖЕТ быть заменен одним SP перед интерпретацией значения поля или пересылкой сообщения в нисходящем направлении. Порядок получения полей заголовков с разными именами полей не имеет значения. Однако рекомендуется сначала отправлять поля общего заголовка,за которыми следуют поля заголовка запроса или ответа и заканчиваются полями заголовка объекта. Несколько полей заголовка сообщения с одинаковым именем поля МОГУТ присутствовать в сообщении тогда и только тогда, когда все значение поля для этого поля заголовка определено как список, разделенный запятыми [т.е. # (значения)]. ДОЛЖНА быть возможна объединение нескольких полей заголовка в одну пару &amp;laquo;имя-поля: значение-поля&amp;raquo; без изменения семантики сообщения, путем добавления каждого последующего значения поля к первому, каждое из которых разделено запятой. Таким образом, порядок, в котором принимаются поля заголовка с одинаковым именем поля, важен для интерпретации значения комбинированного поля, и, таким образом, прокси-сервер НЕ ДОЛЖЕН изменять порядок значений этих полей при пересылке сообщения.и заканчивая полями заголовка объекта. Несколько полей заголовка сообщения с одинаковым именем поля МОГУТ присутствовать в сообщении тогда и только тогда, когда все значение поля для этого поля заголовка определено как список, разделенный запятыми [то есть # (значения)]. ДОЛЖНА быть возможна объединение нескольких полей заголовка в одну пару &amp;laquo;имя-поля: значение-поля&amp;raquo; без изменения семантики сообщения, путем добавления каждого последующего значения поля к первому, каждое из которых разделено запятой. Порядок, в котором принимаются поля заголовка с одинаковым именем поля, поэтому важен для интерпретации значения объединенного поля, и, таким образом, прокси-сервер НЕ ДОЛЖЕН изменять порядок значений этих полей при пересылке сообщения.и заканчивая полями заголовка объекта. Несколько полей заголовка сообщения с одинаковым именем поля МОГУТ присутствовать в сообщении тогда и только тогда, когда все значение поля для этого поля заголовка определено как список, разделенный запятыми [то есть # (значения)]. ДОЛЖНА быть возможна объединение нескольких полей заголовка в одну пару &amp;laquo;имя-поля: значение-поля&amp;raquo; без изменения семантики сообщения путем добавления каждого последующего значения поля к первому, каждое из которых разделено запятой. Таким образом, порядок, в котором принимаются поля заголовка с одинаковым именем поля, важен для интерпретации значения комбинированного поля, и, таким образом, прокси-сервер НЕ ДОЛЖЕН изменять порядок значений этих полей при пересылке сообщения.Несколько полей заголовка сообщения с одинаковым именем поля МОГУТ присутствовать в сообщении тогда и только тогда, когда все значение поля для этого поля заголовка определено как список, разделенный запятыми [то есть # (значения)]. ДОЛЖНА быть возможна объединение нескольких полей заголовка в одну пару &amp;laquo;имя-поля: значение-поля&amp;raquo; без изменения семантики сообщения, путем добавления каждого последующего значения поля к первому, каждое из которых разделено запятой. Таким образом, порядок, в котором принимаются поля заголовка с одинаковым именем поля, важен для интерпретации значения комбинированного поля, и, таким образом, прокси-сервер НЕ ДОЛЖЕН изменять порядок значений этих полей при пересылке сообщения.Несколько полей заголовка сообщения с одинаковым именем поля МОГУТ присутствовать в сообщении тогда и только тогда, когда все значение поля для этого поля заголовка определено как список, разделенный запятыми [то есть # (значения)]. ДОЛЖНА быть возможна объединение нескольких полей заголовка в одну пару &amp;laquo;имя-поля: значение-поля&amp;raquo; без изменения семантики сообщения, путем добавления каждого последующего значения поля к первому, каждое из которых разделено запятой. Порядок, в котором принимаются поля заголовка с одинаковым именем поля, поэтому важен для интерпретации значения объединенного поля, и, таким образом, прокси-сервер НЕ ДОЛЖЕН изменять порядок значений этих полей при пересылке сообщения.ДОЛЖНА быть возможна объединение нескольких полей заголовка в одну пару &amp;laquo;имя-поля: значение-поля&amp;raquo; без изменения семантики сообщения, путем добавления каждого последующего значения поля к первому, каждое из которых разделено запятой. Таким образом, порядок, в котором принимаются поля заголовка с одинаковым именем поля, важен для интерпретации значения комбинированного поля, и, таким образом, прокси-сервер НЕ ДОЛЖЕН изменять порядок значений этих полей при пересылке сообщения.ДОЛЖНА быть возможна объединение нескольких полей заголовка в одну пару &amp;laquo;имя-поля: значение-поля&amp;raquo; без изменения семантики сообщения, путем добавления каждого последующего значения поля к первому, каждое из которых разделено запятой. Порядок, в котором принимаются поля заголовка с одинаковым именем поля, поэтому важен для интерпретации значения объединенного поля, и, таким образом, прокси-сервер НЕ ДОЛЖЕН изменять порядок значений этих полей при пересылке сообщения.Таким образом, порядок, в котором принимаются поля заголовка с одинаковым именем поля, важен для интерпретации значения комбинированного поля, и, таким образом, прокси-сервер НЕ ДОЛЖЕН изменять порядок значений этих полей при пересылке сообщения.Таким образом, порядок, в котором принимаются поля заголовка с одинаковым именем поля, важен для интерпретации значения комбинированного поля, и, таким образом, прокси-сервер НЕ ДОЛЖЕН изменять порядок значений этих полей при пересылке сообщения.</target>
        </trans-unit>
        <trans-unit id="2ee53c95b1d46b2119a03c49e611077033b4d0b3" translate="yes" xml:space="preserve">
          <source>HTTP headers</source>
          <target state="translated">заголовки HTTP</target>
        </trans-unit>
        <trans-unit id="48536d1a36cdc18529d34d2b1499b1bddb33777a" translate="yes" xml:space="preserve">
          <source>HTTP headers allow the client and the server to pass additional information with the request or the response. An HTTP header consists of its case-insensitive name followed by a colon '&lt;code&gt;:&lt;/code&gt;', then by its value (without line breaks). Leading white space before the value is ignored.</source>
          <target state="translated">Заголовки HTTP позволяют клиенту и серверу передавать дополнительную информацию с запросом или ответом. Заголовок HTTP состоит из его имени без учета регистра, за которым следует двоеточие ' &lt;code&gt;:&lt;/code&gt; ', а затем его значение (без разрывов строк). Начальный пробел перед значением игнорируется.</target>
        </trans-unit>
        <trans-unit id="8e56498c371e01a01014a24b174120a52a7628f8" translate="yes" xml:space="preserve">
          <source>HTTP headers, meta elements and language information</source>
          <target state="translated">HTTP заголовки,мета-элементы и языковая информация</target>
        </trans-unit>
        <trans-unit id="63565f85024865ce35e9904d8dab88b231490429" translate="yes" xml:space="preserve">
          <source>HTTP implementations that share code with MHTML [&lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC2557&lt;/a&gt;]
   implementations need to be aware of MIME line length limitations.
   Since HTTP does not have this limitation, HTTP does not fold long
   lines.  MHTML messages being transported by HTTP follow all
   conventions of MHTML, including line length limitations and folding,
   canonicalization, etc., since HTTP transfers message-bodies as 

   payload and, aside from the &quot;multipart/byteranges&quot; type (Appendix A
   of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]), does not interpret the content or any MIME header
   lines that might be contained therein.</source>
          <target state="translated">Реализации HTTP, которые используют общий код с реализациями MHTML [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC2557&lt;/a&gt; ], должны знать об ограничениях длины строки MIME. Поскольку HTTP не имеет этого ограничения, HTTP не складывает длинные строки. Сообщения MHTML, транспортируемые по HTTP, следуют всем соглашениям MHTML, включая ограничения длины строки и сворачивание, канонизацию и т. Д., Поскольку HTTP передает тела сообщения в качестве полезной нагрузки и, кроме типа &amp;laquo;multipart / byteranges&amp;raquo; (Приложение A к [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ] ), не интерпретирует содержимое или какие-либо строки заголовка MIME, которые могут в нем содержаться.</target>
        </trans-unit>
        <trans-unit id="de5402f673a6f75205a2fa61021e4a87fd38eaf7" translate="yes" xml:space="preserve">
          <source>HTTP implementations which share code with MHTML [&lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;] implementations
   need to be aware of MIME line length limitations. Since HTTP does not
   have this limitation, HTTP does not fold long lines. MHTML messages
   being transported by HTTP follow all conventions of MHTML, including
   line length limitations and folding, canonicalization, etc., since
   HTTP transports all message-bodies as payload (see &lt;a href=&quot;#section-3.7.2&quot;&gt;section 3.7.2&lt;/a&gt;) and
   does not interpret the content or any MIME header lines that might be
   contained therein.</source>
          <target state="translated">Реализации HTTP, которые используют общий код с реализациями MHTML [ &lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt; ], должны знать об ограничениях длины строки MIME. Поскольку HTTP не имеет этого ограничения, HTTP не складывает длинные строки. Сообщения MHTML, транспортируемые по HTTP, следуют всем соглашениям MHTML, включая ограничения длины строки и сворачивание, канонизацию и т. Д., Поскольку HTTP транспортирует все тела сообщения как полезную нагрузку (см. &lt;a href=&quot;#section-3.7.2&quot;&gt;Раздел 3.7.2&lt;/a&gt; ) и не интерпретирует содержимое или какой-либо заголовок MIME. строки, которые могут там содержаться.</target>
        </trans-unit>
        <trans-unit id="4924be195f30ae39945dc7a126df600856cfafd8" translate="yes" xml:space="preserve">
          <source>HTTP introduces a set of headers, starting with &lt;code&gt;&lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; as a way for a browser to announce the format, language, or encoding it prefers. This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710a819ac327fdfc49afc67cb5bdfc03f98d8ddc" translate="yes" xml:space="preserve">
          <source>HTTP introduces a set of headers, starting with &lt;code&gt;Accept-&lt;/code&gt; as a way for a browser to announce the format, language, or encoding it prefers. This article explains how this advertisement happens, how the server is expected to react and how it will choose the most adequate response.</source>
          <target state="translated">HTTP представляет собой набор заголовков, начиная с &lt;code&gt;Accept-&lt;/code&gt; , чтобы браузер мог объявить предпочитаемый формат, язык или кодировку. В этой статье объясняется, как происходит это объявление, как ожидается реакция сервера и как он выберет наиболее адекватный ответ.</target>
        </trans-unit>
        <trans-unit id="7bce7c5f422974cc46aee17e50fec032a864e5fe" translate="yes" xml:space="preserve">
          <source>HTTP is a client-server protocol: requests are sent by one entity, the user-agent (or a proxy on behalf of it). Most of the time the user-agent is a Web browser, but it can be anything, for example a robot that crawls the Web to populate and maintain a search engine index.</source>
          <target state="translated">HTTP является протоколом клиент-сервер:запросы посылает одна сущность,пользователь-агент (или прокси от его имени).В большинстве случаев пользователь-агент является веб-браузером,но это может быть что угодно,например,робот,который ползает по Сети,чтобы заполнить и поддерживать индекс поисковой системы.</target>
        </trans-unit>
        <trans-unit id="b485125423c17b1efeda78b6422f6043dbfdd69f" translate="yes" xml:space="preserve">
          <source>HTTP is a pretty extensible protocol. It relies on a few basic concepts like the notion of resources and URIs, a simple structure of messages, and a client-server structure for the communication flow. On top of these basic concepts, numerous extensions have appeared over the years, adding new functionality and new semantics by creating new HTTP methods or headers.</source>
          <target state="translated">HTTP-это довольно расширяемый протокол.Он опирается на несколько базовых концепций,таких как понятие ресурсов и URI,простая структура сообщений и структура клиент-сервер для коммуникационного потока.Помимо этих базовых концепций,с годами появилось множество расширений,добавляющих новую функциональность и новую семантику путем создания новых методов HTTP или заголовков.</target>
        </trans-unit>
        <trans-unit id="1e62200cdd839db28dbcb3a764ce93c997d72428" translate="yes" xml:space="preserve">
          <source>HTTP is a stateless request/response protocol that operates by
   exchanging messages (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) across a reliable transport- or
   session-layer &quot;connection&quot; (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).  An HTTP &quot;client&quot; is a
   program that establishes a connection to a server for the purpose of
   sending one or more HTTP requests.  An HTTP &quot;server&quot; is a program
   that accepts connections in order to service HTTP requests by sending
   HTTP responses.

   The terms &quot;client&quot; and &quot;server&quot; refer only to the roles that these
   programs perform for a particular connection.  The same program might
   act as a client on some connections and a server on others.  The term
   &quot;user agent&quot; refers to any of the various client programs that
   initiate a request, including (but not limited to) browsers, spiders
   (web-based robots), command-line tools, custom applications, and
   mobile apps.  The term &quot;origin server&quot; refers to the program that can
   originate authoritative responses for a given target resource.  The
   terms &quot;sender&quot; and &quot;recipient&quot; refer to any implementation that sends
   or receives a given message, respectively.

   HTTP relies upon the Uniform Resource Identifier (URI) standard
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;] to indicate the target resource (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;) and
   relationships between resources.  Messages are passed in a format
   similar to that used by Internet mail [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;] and the Multipurpose
   Internet Mail Extensions (MIME) [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;] (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#appendix-A&quot;&gt;Appendix&amp;nbsp;A of
   [RFC7231]&lt;/a&gt; for the differences between HTTP and MIME messages).

   Most HTTP communication consists of a retrieval request (GET) for a
   representation of some resource identified by a URI.  In the simplest
   case, this might be accomplished via a single bidirectional
   connection (===) between the user agent (UA) and the origin
   server (O).

            request   &amp;gt;
       UA ======================================= O
                                   &amp;lt;   response

   A client sends an HTTP request to a server in the form of a request
   message, beginning with a request-line that includes a method, URI,
   and protocol version (&lt;a href=&quot;#section-3.1.1&quot;&gt;Section 3.1.1&lt;/a&gt;), followed by header fields
   containing request modifiers, client information, and representation
   metadata (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;), an empty line to indicate the end of the
   header section, and finally a message body containing the payload
   body (if any, &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;). 

   A server responds to a client's request by sending one or more HTTP
   response messages, each beginning with a status line that includes
   the protocol version, a success or error code, and textual reason
   phrase (&lt;a href=&quot;#section-3.1.2&quot;&gt;Section 3.1.2&lt;/a&gt;), possibly followed by header fields containing
   server information, resource metadata, and representation metadata
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;), an empty line to indicate the end of the header
   section, and finally a message body containing the payload body (if
   any, &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;).

   A connection might be used for multiple request/response exchanges,
   as defined in &lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;.

   The following example illustrates a typical message exchange for a
   GET request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;Section&amp;nbsp;4.3.1 of [RFC7231]&lt;/a&gt;) on the URI
   &quot;http://www.example.com/hello.txt&quot;:

   Client request:

     GET /hello.txt HTTP/1.1
     User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
     Host: www.example.com
     Accept-Language: en, mi


   Server response:

     HTTP/1.1 200 OK
     Date: Mon, 27 Jul 2009 12:28:53 GMT
     Server: Apache
     Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
     ETag: &quot;34aa387-d-1568eb00&quot;
     Accept-Ranges: bytes
     Content-Length: 51
     Vary: Accept-Encoding
     Content-Type: text/plain

     Hello World! My payload includes a trailing CRLF.</source>
          <target state="translated">HTTP - это протокол запроса / ответа без сохранения состояния, который работает путем обмена сообщениями ( &lt;a href=&quot;#section-3&quot;&gt;раздел 3&lt;/a&gt; ) через надежное &amp;laquo;соединение&amp;raquo; транспортного или сеансового уровня ( &lt;a href=&quot;#section-6&quot;&gt;раздел 6&lt;/a&gt;). &amp;laquo;Клиент&amp;raquo; HTTP - это программа, которая устанавливает соединение с сервером с целью отправки одного или нескольких HTTP-запросов. HTTP-сервер - это программа, которая принимает соединения для обслуживания HTTP-запросов путем отправки HTTP-ответов. Термины &amp;laquo;клиент&amp;raquo; и &amp;laquo;сервер&amp;raquo; относятся только к тем ролям, которые эти программы выполняют для определенного соединения. Одна и та же программа может действовать как клиент для одних подключений и как сервер для других. Термин &amp;laquo;агент пользователя&amp;raquo; относится к любой из различных клиентских программ, инициирующих запрос, включая (но не ограничиваясь) браузеры, пауки (веб-роботы), инструменты командной строки, пользовательские приложения и мобильные приложения. Термин &quot;исходный сервер&quot;относится к программе, которая может создавать авторитетные ответы для данного целевого ресурса. Термины &amp;laquo;отправитель&amp;raquo; и &amp;laquo;получатель&amp;raquo; относятся к любой реализации, которая отправляет или принимает данное сообщение соответственно. HTTP полагается на стандарт универсального идентификатора ресурса (URI) [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ], чтобы указать целевой ресурс ( &lt;a href=&quot;#section-5.1&quot;&gt;раздел 5.1&lt;/a&gt; ) и отношения между ресурсами. Сообщения передаются в формате, аналогичном формату, используемому интернет-почтой [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ] и многоцелевыми расширениями интернет-почты (MIME) [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ] (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#appendix-A&quot;&gt;Приложение A к [RFC7231]&lt;/a&gt;о различиях между сообщениями HTTP и MIME). В большинстве случаев HTTP-связь состоит из поискового запроса (GET) для представления некоторого ресурса, идентифицированного URI. В простейшем случае это может быть выполнено через одно двунаправленное соединение (===) между пользовательским агентом (UA) и исходным сервером (O). request&amp;gt; UA ======================================= O &amp;lt;ответ Клиент отправляет HTTP запрос к серверу в форме сообщения запроса, начиная со строки запроса, которая включает метод, URI и версию протокола ( &lt;a href=&quot;#section-3.1.1&quot;&gt;раздел 3.1.1&lt;/a&gt; ), за которыми следуют поля заголовка, содержащие модификаторы запроса, информацию о клиенте и метаданные представления ( &lt;a href=&quot;#section-3.2&quot;&gt;Раздел 3.2&lt;/a&gt;), пустую строку для обозначения конца раздела заголовка и, наконец, тело сообщения, содержащее тело полезной нагрузки (если есть, &lt;a href=&quot;#section-3.3&quot;&gt;раздел 3.3&lt;/a&gt; ). Сервер отвечает на запрос клиента, отправляя одно или несколько сообщений ответа HTTP, каждое из которых начинается со строки состояния, которая включает версию протокола, код успеха или ошибки и текстовую фразу причины ( &lt;a href=&quot;#section-3.1.2&quot;&gt;раздел 3.1.2&lt;/a&gt; ), за которой, возможно, следуют поля заголовка содержащую информацию о сервере, метаданные ресурса и метаданные представления ( &lt;a href=&quot;#section-3.2&quot;&gt;раздел 3.2&lt;/a&gt; ), пустую строку для обозначения конца раздела заголовка и, наконец, тело сообщения, содержащее тело полезной нагрузки (если есть, &lt;a href=&quot;#section-3.3&quot;&gt;раздел 3.3&lt;/a&gt;). Соединение может использоваться для обмена множественными запросами / ответами, как определено в &lt;a href=&quot;#section-6.3&quot;&gt;разделе 6.3&lt;/a&gt; . В следующем примере показан типичный обмен сообщениями для запроса GET ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;раздел 4.3.1 [RFC7231]&lt;/a&gt; ) по URI &amp;laquo;http://www.example.com/hello.txt&amp;raquo;: Клиентский запрос: GET /hello.txt HTTP /1.1 User-Agent: curl / 7.16.3 libcurl / 7.16.3 OpenSSL / 0.9.7l zlib / 1.2.3 Хост: www.example.com Accept-Language: en, mi Ответ сервера: HTTP / 1.1 200 OK Дата: Пн, 27 июля 2009 г. 12:28:53 GMT Сервер: Apache Последнее изменение: среда, 22 июля 2009 г. 19:15:56 GMT ETag: &quot;34aa387-d-1568eb00&quot; Диапазон допустимых значений: байты Длина содержимого: 51 Варьируется: Accept-Encoding Content-Type: text / plain Hello World!Моя полезная нагрузка включает в себя завершающий CRLF.</target>
        </trans-unit>
        <trans-unit id="5cc2a6ae91625497aff3803fe93d9cda3d79e909" translate="yes" xml:space="preserve">
          <source>HTTP is an extensible protocol that is easy to use. The client-server structure, combined with the ability to simply add headers, allows HTTP to advance along with the extended capabilities of the Web.</source>
          <target state="translated">HTTP является расширяемым протоколом,который прост в использовании.Структура клиент-сервер в сочетании с возможностью простого добавления заголовков позволяет HTTP развиваться вместе с расширенными возможностями Web.</target>
        </trans-unit>
        <trans-unit id="bbcb125f3701fe50926501831f8f7ee161444b57" translate="yes" xml:space="preserve">
          <source>HTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), simple message structure, and client-server communication flow. On top of these basic concepts, numerous extensions have been developed over the years that add updated functionality and semantics with new HTTP methods or headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20fa14d437b5a88c718d590e0efda20242112a2" translate="yes" xml:space="preserve">
          <source>HTTP is extensible</source>
          <target state="translated">HTTP является расширяемым</target>
        </trans-unit>
        <trans-unit id="18ad92cc7b82eb0d0efdfdb9ee61c4c2a39d270e" translate="yes" xml:space="preserve">
          <source>HTTP is generally designed to be simple and human readable, even with the added complexity introduced in HTTP/2 by encapsulating HTTP messages into frames. HTTP messages can be read and understood by humans, providing easier testing for developers, and reduced complexity for newcomers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e492d2fcbffcb461a67019008cf2c966900353b" translate="yes" xml:space="preserve">
          <source>HTTP is independent of the security model of the Web, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. In fact, the current Web security model has been developed after the creation of HTTP! Over the years, it has proved useful to be able to be more lenient, by allowing under certain constraints to lift some of the restriction of this policy. How much and when such restrictions are lifted is transmitted by the server to the client using a new bunch of HTTP headers. These are defined in specifications like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;Cross-Origin Resource Sharing&lt;/a&gt; (CORS) or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;Content Security Policy&lt;/a&gt; (CSP).</source>
          <target state="translated">HTTP не зависит от модели безопасности Интернета, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;политики одного происхождения&lt;/a&gt; . Фактически, текущая модель веб-безопасности была разработана после создания HTTP! За прошедшие годы оказалось полезным быть более снисходительным, позволив при определенных ограничениях снять некоторые ограничения этой политики. Насколько и когда такие ограничения сняты, сервер передает клиенту с помощью новой группы заголовков HTTP. Они определены в таких спецификациях, как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;совместное использование ресурсов между источниками&lt;/a&gt; (CORS) или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;Политика безопасности контента&lt;/a&gt; (CSP).</target>
        </trans-unit>
        <trans-unit id="844e92e43f2d1fe1edd17a77bc8a5a11e990e4be" translate="yes" xml:space="preserve">
          <source>HTTP is not a MIME-compliant protocol.  However, messages can include
   a single MIME-Version header field to indicate what version of the
   MIME protocol was used to construct the message.  Use of the
   MIME-Version header field indicates that the message is in full
   conformance with the MIME protocol (as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;]).
   Senders are responsible for ensuring full conformance (where
   possible) when exporting HTTP messages to strict MIME environments.</source>
          <target state="translated">HTTP не является протоколом, совместимым с MIME. Однако сообщения могут включать в себя одно поле заголовка MIME-Version, чтобы указать, какая версия протокола MIME использовалась для создания сообщения. Использование поля заголовка MIME-Version указывает, что сообщение полностью соответствует протоколу MIME (как определено в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ]). Отправители несут ответственность за обеспечение полного соответствия (там, где это возможно) при экспорте сообщений HTTP в строгие среды MIME.</target>
        </trans-unit>
        <trans-unit id="e53f9322a91df40e55625dc45bd212cc6e3463d2" translate="yes" xml:space="preserve">
          <source>HTTP is not a MIME-compliant protocol. However, HTTP/1.1 messages MAY
   include a single MIME-Version general-header field to indicate what
   version of the MIME protocol was used to construct the message. Use
   of the MIME-Version header field indicates that the message is in
   full compliance with the MIME protocol (as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;[&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]).
   Proxies/gateways are responsible for ensuring full compliance (where
   possible) when exporting HTTP messages to strict MIME environments.

       MIME-Version   = &quot;MIME-Version&quot; &quot;:&quot; 1*DIGIT &quot;.&quot; 1*DIGIT

   MIME version &quot;1.0&quot; is the default for use in HTTP/1.1. However,
   HTTP/1.1 message parsing and semantics are defined by this document
   and not the MIME specification.</source>
          <target state="translated">HTTP не является протоколом, совместимым с MIME. Однако сообщения HTTP / 1.1 МОГУТ включать одно поле общего заголовка MIME-Version, чтобы указать, какая версия протокола MIME использовалась для создания сообщения. Использование поля заголовка MIME-Version указывает, что сообщение полностью соответствует протоколу MIME (как определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]). Прокси-серверы / шлюзы несут ответственность за обеспечение полного соответствия (где это возможно) при экспорте сообщений HTTP в строгие среды MIME. MIME-Version = &quot;MIME-Version&quot; &quot;:&quot; 1 * ЦИФРА &quot;.&quot; 1 * Версия DIGIT MIME &quot;1.0&quot; по умолчанию используется в HTTP / 1.1. Однако синтаксический анализ и семантика сообщений HTTP / 1.1 определяются в этом документе, а не в спецификации MIME.</target>
        </trans-unit>
        <trans-unit id="dca5ebedb205dfacf9266ff93c066cf81c69779d" translate="yes" xml:space="preserve">
          <source>HTTP is simple</source>
          <target state="translated">HTTP просто</target>
        </trans-unit>
        <trans-unit id="505159632976cbe17f2844bb8f7ce15822bb5f60" translate="yes" xml:space="preserve">
          <source>HTTP is stateless, but not sessionless</source>
          <target state="translated">HTTP является апатридом,но не без сессии</target>
        </trans-unit>
        <trans-unit id="809c123eeed8b2f5fd5ed3274c85be36e7f59d12" translate="yes" xml:space="preserve">
          <source>HTTP is stateless: there is no link between two requests being successively carried out on the same connection. This immediately has the prospect of being problematic for users attempting to interact with certain pages coherently, for example, using e-commerce shopping baskets. But while the core of HTTP itself is stateless, HTTP cookies allow the use of stateful sessions. Using header extensibility, HTTP Cookies are added to the workflow, allowing session creation on each HTTP request to share the same context, or the same state.</source>
          <target state="translated">HTTP является апатридом:нет связи между двумя запросами,последовательно выполняемыми по одному и тому же соединению.Это сразу же чревато проблемами для пользователей,пытающихся взаимодействовать с определенными страницами согласованно,например,используя корзины для покупок в электронной торговле.Но в то время как ядро HTTP само по себе является апатридом,HTTP-куки позволяют использовать сеансы с обратной связью.Используя расширяемость заголовков,HTTP-куки добавляются в рабочий процесс,позволяя создавать сеансы по каждому HTTP-запросу в одном и том же контексте,или в одном и том же состоянии.</target>
        </trans-unit>
        <trans-unit id="40096b223d68b1f8c1440bbea86dad29e675b9a1" translate="yes" xml:space="preserve">
          <source>HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches.  This
   document defines aspects of HTTP/1.1 related to caching and reusing
   response messages.

   An HTTP cache is a local store of response messages and the subsystem
   that controls storage, retrieval, and deletion of messages in it.  A
   cache stores cacheable responses in order to reduce the response time
   and network bandwidth consumption on future, equivalent requests.
   Any client or server MAY employ a cache, though a cache cannot be
   used by a server that is acting as a tunnel.

   A shared cache is a cache that stores responses to be reused by more
   than one user; shared caches are usually (but not always) deployed as
   a part of an intermediary.  A private cache, in contrast, is
   dedicated to a single user; often, they are deployed as a component
   of a user agent.

   The goal of caching in HTTP/1.1 is to significantly improve
   performance by reusing a prior response message to satisfy a current
   request.  A stored response is considered &quot;fresh&quot;, as defined in
   &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;, if the response can be reused without &quot;validation&quot;
   (checking with the origin server to see if the cached response
   remains valid for this request).  A fresh response can therefore
   reduce both latency and network overhead each time it is reused.
   When a cached response is not fresh, it might still be reusable if it
   can be freshened by validation (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) or if the origin is
   unavailable (&lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;).</source>
          <target state="translated">HTTP обычно используется для распределенных информационных систем, где производительность может быть улучшена за счет использования кэшей ответов. Этот документ определяет аспекты HTTP / 1.1, связанные с кэшированием и повторным использованием ответных сообщений. Кэш HTTP - это локальное хранилище ответных сообщений и подсистема, которая контролирует хранение, извлечение и удаление сообщений в нем. В кэше хранятся кэшируемые ответы, чтобы сократить время отклика и потребление пропускной способности сети на будущие эквивалентные запросы. Любой клиент или сервер МОЖЕТ использовать кеш, хотя кеш не может использоваться сервером, который действует как туннель. Общий кеш - это кеш, в котором хранятся ответы для повторного использования более чем одним пользователем; общие кэши обычно (но не всегда) развертываются как часть посредника. Частный кеш, напротив,предназначен для одного пользователя; часто они развертываются как компонент пользовательского агента. Целью кэширования в HTTP / 1.1 является значительное повышение производительности за счет повторного использования предыдущего ответного сообщения для удовлетворения текущего запроса. Сохраненный ответ считается &amp;laquo;свежим&amp;raquo;, как определено в &lt;a href=&quot;#section-4.2&quot;&gt;Раздел 4.2&lt;/a&gt; , если ответ может быть повторно использован без &amp;laquo;проверки&amp;raquo; (проверка с исходным сервером, чтобы увидеть, остается ли кешированный ответ действительным для этого запроса). Таким образом, свежий ответ может уменьшить как задержку, так и накладные расходы сети при каждом повторном использовании. Если кешированный ответ не является свежим, его можно использовать повторно, если его можно обновить с помощью проверки ( &lt;a href=&quot;#section-4.3&quot;&gt;раздел 4.3&lt;/a&gt; ) или если источник недоступен ( &lt;a href=&quot;#section-4.2.4&quot;&gt;раздел 4.2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bc0cee4ed0cc389fa445e5f9f96d84585ff6e837" translate="yes" xml:space="preserve">
          <source>HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches. The
   HTTP/1.1 protocol includes a number of elements intended to make
   caching work as well as possible. Because these elements are
   inextricable from other aspects of the protocol, and because they
   interact with each other, it is useful to describe the basic caching
   design of HTTP separately from the detailed descriptions of methods,
   headers, response codes, etc.

   Caching would be useless if it did not significantly improve
   performance. The goal of caching in HTTP/1.1 is to eliminate the need
   to send requests in many cases, and to eliminate the need to send
   full responses in many other cases. The former reduces the number of
   network round-trips required for many operations; we use an
   &quot;expiration&quot; mechanism for this purpose (see &lt;a href=&quot;#section-13.2&quot;&gt;section 13.2&lt;/a&gt;). The
   latter reduces network bandwidth requirements; we use a &quot;validation&quot;
   mechanism for this purpose (see &lt;a href=&quot;#section-13.3&quot;&gt;section 13.3&lt;/a&gt;).

   Requirements for performance, availability, and disconnected
   operation require us to be able to relax the goal of semantic
   transparency. The HTTP/1.1 protocol allows origin servers, caches, 

   and clients to explicitly reduce transparency when necessary.
   However, because non-transparent operation may confuse non-expert
   users, and might be incompatible with certain server applications
   (such as those for ordering merchandise), the protocol requires that
   transparency be relaxed

      - only by an explicit protocol-level request when relaxed by
        client or origin server

      - only with an explicit warning to the end user when relaxed by
        cache or client

   Therefore, the HTTP/1.1 protocol provides these important elements:

      1. Protocol features that provide full semantic transparency when
         this is required by all parties.

      2. Protocol features that allow an origin server or user agent to
         explicitly request and control non-transparent operation.

      3. Protocol features that allow a cache to attach warnings to
         responses that do not preserve the requested approximation of
         semantic transparency.

   A basic principle is that it must be possible for the clients to
   detect any potential relaxation of semantic transparency.

      Note: The server, cache, or client implementor might be faced with
      design decisions not explicitly discussed in this specification.
      If a decision might affect semantic transparency, the implementor
      ought to err on the side of maintaining transparency unless a
      careful and complete analysis shows significant benefits in
      breaking transparency.</source>
          <target state="translated">HTTP обычно используется для распределенных информационных систем, где производительность может быть улучшена за счет использования кэшей ответов. Протокол HTTP / 1.1 включает ряд элементов, предназначенных для максимально эффективной работы кэширования. Поскольку эти элементы неотделимы от других аспектов протокола и поскольку они взаимодействуют друг с другом, полезно описать базовую схему кэширования HTTP отдельно от подробных описаний методов, заголовков, кодов ответов и т. Д. Кэширование было бы бесполезным. если это не привело к значительному повышению производительности. Целью кэширования в HTTP / 1.1 является устранение необходимости отправлять запросы во многих случаях и устранение необходимости отправлять полные ответы во многих других случаях. Первый уменьшает количество сетевых циклов, необходимых для многих операций;мы используем для этого механизм &amp;laquo;истечения срока&amp;raquo; (см.&lt;a href=&quot;#section-13.2&quot;&gt;раздел 13.2&lt;/a&gt; ). Последнее снижает требования к пропускной способности сети; для этой цели мы используем механизм &amp;laquo;проверки&amp;raquo; (см. &lt;a href=&quot;#section-13.3&quot;&gt;раздел 13.3.&lt;/a&gt;). Требования к производительности, доступности и отключенной работе требуют от нас возможности ослабить цель семантической прозрачности. Протокол HTTP / 1.1 позволяет исходным серверам, кешам и клиентам явно снижать прозрачность при необходимости. Однако, поскольку непрозрачная операция может сбить с толку неспециализированных пользователей и может быть несовместима с некоторыми серверными приложениями (например, с приложениями для заказа товаров), протокол требует, чтобы прозрачность была ослаблена - только явным запросом на уровне протокола при ослаблении клиент или исходный сервер - только с явным предупреждением для конечного пользователя при отключении кэшем или клиентом Таким образом, протокол HTTP / 1.1 предоставляет следующие важные элементы: 1.Функции протокола, обеспечивающие полную семантическую прозрачность, когда этого требуют все стороны. 2. Функции протокола, которые позволяют исходному серверу или пользовательскому агенту явно запрашивать и контролировать непрозрачную операцию. 3. Функции протокола, которые позволяют кэшу прикреплять предупреждения к ответам, которые не сохраняют запрошенное приближение семантической прозрачности. Основной принцип заключается в том, что клиенты должны иметь возможность обнаруживать любое возможное ослабление семантической прозрачности. Примечание. Разработчик сервера, кэша или клиента может столкнуться с проектными решениями, которые явно не обсуждаются в этой спецификации. Если решение может повлиять на семантическую прозрачность,разработчик должен ошибиться в сторону сохранения прозрачности, если только тщательный и полный анализ не покажет значительных преимуществ нарушения прозрачности.</target>
        </trans-unit>
        <trans-unit id="ee5bd85f6de02476bff1ddc097b7f7447096c5a2" translate="yes" xml:space="preserve">
          <source>HTTP is used in a wide variety of applications, ranging from
   general-purpose computers to home appliances.  In some cases,
   communication options are hard-coded in a client's configuration.
   However, most HTTP clients rely on the same resource identification
   mechanism and configuration techniques as general-purpose Web
   browsers.

   HTTP communication is initiated by a user agent for some purpose.
   The purpose is a combination of request semantics, which are defined
   in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;], and a target resource upon which to apply those
   semantics.  A URI reference (&lt;a href=&quot;#section-2.7&quot;&gt;Section 2.7&lt;/a&gt;) is typically used as an 

   identifier for the &quot;target resource&quot;, which a user agent would
   resolve to its absolute form in order to obtain the &quot;target URI&quot;.
   The target URI excludes the reference's fragment component, if any,
   since fragment identifiers are reserved for client-side processing
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], Section&amp;nbsp;3.5&lt;/a&gt;).</source>
          <target state="translated">HTTP используется в самых разных приложениях, от компьютеров общего назначения до бытовой техники. В некоторых случаях параметры связи жестко запрограммированы в конфигурации клиента. Однако большинство HTTP-клиентов полагаются на тот же механизм идентификации ресурсов и методы настройки, что и веб-браузеры общего назначения. HTTP-связь инициируется пользовательским агентом для какой-то цели. Цель - комбинация семантики запроса, которая определена в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ], и целевого ресурса, к которому следует применить эту семантику. Ссылка на URI ( &lt;a href=&quot;#section-2.7&quot;&gt;раздел 2.7&lt;/a&gt;) обычно используется в качестве идентификатора для &amp;laquo;целевого ресурса&amp;raquo;, который пользовательский агент преобразовывает в его абсолютную форму, чтобы получить &amp;laquo;целевой URI&amp;raquo;. Целевой URI исключает компонент фрагмента ссылки, если таковой имеется, поскольку идентификаторы фрагментов зарезервированы для обработки на стороне клиента ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], раздел 3.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="14fc3ba32d80ac4a60cf241e5c4400241293ff7f" translate="yes" xml:space="preserve">
          <source>HTTP message headers are used to describe a resource, or the behavior of the server or the client. Custom proprietary headers can be added using the &lt;code&gt;X-&lt;/code&gt; prefix; others in an &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#perm-headers&quot;&gt;IANA registry&lt;/a&gt;, whose original content was defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4229&quot;&gt;RFC 4229&lt;/a&gt;. IANA also maintains a &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#prov-headers&quot;&gt;registry of proposed new HTTP message headers&lt;/a&gt;.</source>
          <target state="translated">Заголовки сообщения HTTP используются для описания ресурса или поведения сервера или клиента. Пользовательские собственные заголовки могут быть добавлены с помощью префикса &lt;code&gt;X-&lt;/code&gt; ; другие в &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#perm-headers&quot;&gt;реестре IANA&lt;/a&gt; , исходное содержание которого определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc4229&quot;&gt;RFC 4229&lt;/a&gt; . IANA также ведет &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#prov-headers&quot;&gt;реестр предлагаемых новых заголовков сообщений HTTP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2638b56fdde689e585c5bdfb740cd6d868d52464" translate="yes" xml:space="preserve">
          <source>HTTP messages are composed of textual information encoded in ASCII, and span over multiple lines. In HTTP/1.1, and earlier versions of the protocol, these messages were openly sent across the connection. In HTTP/2, the once human-readable message is now divided up into HTTP frames, providing optimization and performance improvements.</source>
          <target state="translated">Сообщения HTTP состоят из текстовой информации,закодированной в ASCII,и охватывают несколько строк.В HTTP/1.1,а также в более ранних версиях протокола,эти сообщения открыто отправлялись по всему соединению.В HTTP/2 некогда читаемое человеком сообщение теперь разбито на HTTP-фреймы,что обеспечивает оптимизацию и повышение производительности.</target>
        </trans-unit>
        <trans-unit id="118d6001c735751f3c84aa7e43184e1a5916e130" translate="yes" xml:space="preserve">
          <source>HTTP messages are how data is exchanged between a server and a client. There are two types of messages: &lt;em&gt;requests&lt;/em&gt; sent by the client to trigger an action on the server, and &lt;em&gt;responses&lt;/em&gt;, the answer from the server.</source>
          <target state="translated">Сообщения HTTP - это способ обмена данными между сервером и клиентом. Есть два типа сообщений: &lt;em&gt;запросы,&lt;/em&gt; отправленные клиентом для запуска действия на сервере, и &lt;em&gt;ответы&lt;/em&gt; , ответ от сервера.</target>
        </trans-unit>
        <trans-unit id="2f6109f653584ed6dc3dfe16c53952b62bfd3c70" translate="yes" xml:space="preserve">
          <source>HTTP messages are the key in using HTTP; their structure is simple and they are highly extensible. The HTTP/2 framing mechanism adds a new intermediate layer between the HTTP/1.x syntax and the underlying transport protocol, without fundamentally modifying it: building upon proven mechanisms.</source>
          <target state="translated">Сообщения HTTP являются ключом к использованию HTTP;их структура проста,и они очень расширяемы.Механизм формирования фреймов HTTP/2 добавляет новый промежуточный уровень между синтаксисом HTTP/1.x и базовым транспортным протоколом,не изменяя его в корне:основываясь на проверенных механизмах.</target>
        </trans-unit>
        <trans-unit id="891aa548a3155a7bc116f727c4c9e489c435ed0b" translate="yes" xml:space="preserve">
          <source>HTTP messages are the key in using HTTP; their structure is simple, and they are highly extensible. The HTTP/2 framing mechanism adds a new intermediate layer between the HTTP/1.x syntax and the underlying transport protocol, without fundamentally modifying it: building upon proven mechanisms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="167bf47970009cc8e263d7f95620e5a732a4503a" translate="yes" xml:space="preserve">
          <source>HTTP messages consist of requests from client to server and responses
   from server to client.

       HTTP-message   = Request | Response     ; HTTP/1.1 messages

   Request (&lt;a href=&quot;#section-5&quot;&gt;section 5&lt;/a&gt;) and Response (&lt;a href=&quot;#section-6&quot;&gt;section 6&lt;/a&gt;) messages use the generic
   message format of &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] for transferring entities (the payload
   of the message). Both types of message consist of a start-line, zero
   or more header fields (also known as &quot;headers&quot;), an empty line (i.e.,
   a line with nothing preceding the CRLF) indicating the end of the
   header fields, and possibly a message-body.

        generic-message = start-line
                          *(message-header CRLF)
                          CRLF
                          [ message-body ]
        start-line      = Request-Line | Status-Line

   In the interest of robustness, servers SHOULD ignore any empty
   line(s) received where a Request-Line is expected. In other words, if
   the server is reading the protocol stream at the beginning of a
   message and receives a CRLF first, it should ignore the CRLF.

   Certain buggy HTTP/1.0 client implementations generate extra CRLF's
   after a POST request. To restate what is explicitly forbidden by the
   BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an
   extra CRLF.</source>
          <target state="translated">Сообщения HTTP состоят из запросов от клиента к серверу и ответов от сервера к клиенту. HTTP-сообщение = Запрос | Отклик ; Сообщения HTTP / 1.1 Сообщения запросов ( &lt;a href=&quot;#section-5&quot;&gt;раздел 5&lt;/a&gt; ) и ответа ( &lt;a href=&quot;#section-6&quot;&gt;раздел 6&lt;/a&gt; ) используют общий формат сообщений &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] для передачи сущностей (полезная нагрузка сообщения). Оба типа сообщений состоят из начальной строки, нуля или нескольких полей заголовка (также известных как &amp;laquo;заголовки&amp;raquo;), пустой строки (т. Е. Строки, в которой ничего не предшествует CRLF), указывающей конец полей заголовка, и, возможно, тело сообщения. generic-message = start-line * (заголовок сообщения CRLF) CRLF [message-body] start-line = Request-Line | Строка состояния В интересах надежности серверы ДОЛЖНЫ игнорировать любые пустые строки, полученные там, где ожидается строка запроса. Другими словами, если сервер читает поток протокола в начале сообщения и сначала получает CRLF, он должен игнорировать CRLF. Некий глючный HTTP / 1.0 клиентские реализации генерируют дополнительные CRLF после запроса POST. Чтобы повторить то, что явно запрещено BNF, клиент HTTP / 1.1 НЕ ДОЛЖЕН предварять или следовать запросу с дополнительным CRLF.</target>
        </trans-unit>
        <trans-unit id="a514b96da0b4952018a9659e3ae2424d71abef2e" translate="yes" xml:space="preserve">
          <source>HTTP messages, as defined in HTTP/1.1 and earlier, are human-readable. In HTTP/2, these messages are embedded into a binary structure, a &lt;em&gt;frame&lt;/em&gt;, allowing optimizations like compression of headers and multiplexing. Even if only part of the original HTTP message is sent in this version of HTTP, the semantics of each message is unchanged and the client reconstitutes (virtually) the original HTTP/1.1 request. It is therefore useful to comprehend HTTP/2 messages in the HTTP/1.1 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e792736752047fb0b0f5fa09841f2859bfcdc55a" translate="yes" xml:space="preserve">
          <source>HTTP messaging is independent of the underlying transport- or
   session-layer connection protocol(s).  HTTP only presumes a reliable
   transport with in-order delivery of requests and the corresponding
   in-order delivery of responses.  The mapping of HTTP request and
   response structures onto the data units of an underlying transport
   protocol is outside the scope of this specification.

   As described in &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;, the specific connection protocols to be
   used for an HTTP interaction are determined by client configuration
   and the target URI.  For example, the &quot;http&quot; URI scheme
   (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;) indicates a default connection of TCP over IP, with a
   default TCP port of 80, but the client might be configured to use a
   proxy via some other connection, port, or protocol. 

   HTTP implementations are expected to engage in connection management,
   which includes maintaining the state of current connections,
   establishing a new connection or reusing an existing connection,
   processing messages received on a connection, detecting connection
   failures, and closing each connection.  Most clients maintain
   multiple connections in parallel, including more than one connection
   per server endpoint.  Most servers are designed to maintain thousands
   of concurrent connections, while controlling request queues to enable
   fair use and detect denial-of-service attacks.</source>
          <target state="translated">Обмен сообщениями HTTP не зависит от базовых протоколов соединения транспортного или сеансового уровня. HTTP предполагает только надежный транспорт с упорядоченной доставкой запросов и соответствующей упорядоченной доставкой ответов. Отображение структур HTTP-запроса и ответа на блоки данных нижележащего транспортного протокола выходит за рамки данной спецификации. Как описано в &lt;a href=&quot;#section-5.2&quot;&gt;разделе 5.2&lt;/a&gt; , конкретные протоколы подключения, которые будут использоваться для взаимодействия HTTP, определяются конфигурацией клиента и целевым URI. Например, схема URI &quot;http&quot; ( &lt;a href=&quot;#section-2.7.1&quot;&gt;раздел 2.7.1&lt;/a&gt;) указывает соединение TCP по IP по умолчанию с TCP-портом по умолчанию 80, но клиент может быть настроен на использование прокси через какое-либо другое соединение, порт или протокол. Ожидается, что реализации HTTP будут участвовать в управлении соединениями, которое включает в себя поддержание состояния текущих соединений, установление нового соединения или повторное использование существующего соединения, обработку сообщений, полученных при соединении, обнаружение сбоев соединения и закрытие каждого соединения. Большинство клиентов поддерживают несколько подключений параллельно, включая более одного подключения на конечную точку сервера. Большинство серверов предназначены для поддержки тысяч одновременных подключений при одновременном контроле очередей запросов для обеспечения добросовестного использования и обнаружения атак типа &amp;laquo;отказ в обслуживании&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a512b6978afa758b64c87ca8fb2b859560321f57" translate="yes" xml:space="preserve">
          <source>HTTP method registrations MUST include the following fields:

   o  Method Name (see &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;)

   o  Safe (&quot;yes&quot; or &quot;no&quot;, see &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;)

   o  Idempotent (&quot;yes&quot; or &quot;no&quot;, see &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   o  Pointer to specification text

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">Регистрация метода HTTP ДОЛЖНА включать следующие поля: o Имя метода (см. &lt;a href=&quot;#section-4&quot;&gt;Раздел 4&lt;/a&gt; ) o Безопасный (&amp;laquo;да&amp;raquo; или &amp;laquo;нет&amp;raquo;, см. &lt;a href=&quot;#section-4.2.1&quot;&gt;Раздел 4.2.1&lt;/a&gt; ) o Идемпотентный (&amp;laquo;да&amp;raquo; или &amp;laquo;нет&amp;raquo;, см. &lt;a href=&quot;#section-4.2.2&quot;&gt;Раздел 4.2.2.&lt;/a&gt; ) o Указатель на текст спецификации. Значения, добавляемые в это пространство имен, требуют &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;проверки&lt;/a&gt; IETF (см. [RFC5226], раздел 4.1 ).</target>
        </trans-unit>
        <trans-unit id="7962f2b4e2fb00149a92feb9ef354150c4b8364c" translate="yes" xml:space="preserve">
          <source>HTTP methods</source>
          <target state="translated">HTTP-методы</target>
        </trans-unit>
        <trans-unit id="16b2633fc11a6a9453f446495015f632c3dba72e" translate="yes" xml:space="preserve">
          <source>HTTP mostly relies on TCP for its transport protocol, providing a connection between the client and the server. In its infancy, HTTP used a single model to handle such connections. These connections were short-lived: a new one created each time a request needed sending, and closed once the answer had been received.</source>
          <target state="translated">HTTP в основном полагается на TCP для своего транспортного протокола,обеспечивая соединение между клиентом и сервером.В зачаточном состоянии HTTP использовал одну модель для обработки таких соединений.Эти соединения были недолговечными:новое создавалось каждый раз,когда требовалось отправить запрос,и закрывалось после получения ответа.</target>
        </trans-unit>
        <trans-unit id="e6523763c79c318a3d3099179709a1159fa699ff" translate="yes" xml:space="preserve">
          <source>HTTP pipelining</source>
          <target state="translated">HTTP-трубопровод</target>
        </trans-unit>
        <trans-unit id="c04bfd419ae2ca3a5245f7e1492aab6d7596ed0e" translate="yes" xml:space="preserve">
          <source>HTTP pipelining is not activated by default in modern browsers:</source>
          <target state="translated">В современных браузерах HTTP-трубопровод по умолчанию не активирован:</target>
        </trans-unit>
        <trans-unit id="0912d51b43dfca3b2cf9646a999e4cef417cee1d" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and
   authentication, via an extensible set of challenge-response
   authentication schemes, which can be used by a server to challenge a
   client request and by a client to provide authentication information.
   This document defines HTTP/1.1 authentication in terms of the
   architecture defined in &quot;Hypertext Transfer Protocol (HTTP/1.1):
   Message Syntax and Routing&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;], including the general
   framework previously described in &quot;HTTP Authentication: Basic and
   Digest Access Authentication&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] and the related fields and
   status codes previously defined in &quot;Hypertext Transfer Protocol --
   HTTP/1.1&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   The IANA Authentication Scheme Registry (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;) lists
   registered authentication schemes and their corresponding
   specifications, including the &quot;basic&quot; and &quot;digest&quot; authentication
   schemes previously defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.</source>
          <target state="translated">HTTP обеспечивает общую структуру для управления доступом и аутентификации с помощью расширяемого набора схем аутентификации запрос-ответ, которые могут использоваться сервером для оспаривания запроса клиента и клиентом для предоставления информации аутентификации. Этот документ определяет аутентификацию HTTP / 1.1 с точки зрения архитектуры, определенной в &amp;laquo;Протоколе передачи гипертекста (HTTP / 1.1): синтаксис сообщений и маршрутизация&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ], включая общую структуру, ранее описанную в &amp;laquo;Аутентификации HTTP: базовая и дайджест-аутентификация доступа&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ] и соответствующие поля и коды состояния, ранее определенные в &amp;laquo;Протоколе передачи гипертекста - HTTP / 1.1&amp;raquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ].Реестр схемы аутентификации IANA ( &lt;a href=&quot;#section-5.1&quot;&gt;раздел 5.1&lt;/a&gt;) перечисляет зарегистрированные схемы аутентификации и их соответствующие спецификации, включая схемы &quot;базовой&quot; и &quot;дайджест-аутентификации&quot;, ранее определенные в &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7885aa462dbdfaf51f0c394e3808399fbb15bff6" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and authentication. The most common HTTP authentication is based on the &quot;Basic&quot; schema. This page shows an introduction to the HTTP framework for authentication and shows how to restrict access to your server using the HTTP &quot;Basic&quot; schema.</source>
          <target state="translated">HTTP обеспечивает общую основу для контроля доступа и аутентификации.Наиболее распространенная HTTP-аутентификация основана на &quot;Базовой&quot; схеме.Эта страница показывает введение в фреймворк HTTP для аутентификации и показывает,как ограничить доступ к вашему серверу с помощью &quot;Базовой&quot; схемы HTTP.</target>
        </trans-unit>
        <trans-unit id="f0b556a167d090c37ed069f694278c1d0f8c8b55" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and authentication. This page is an introduction to the HTTP framework for authentication, and shows how to restrict access to your server using the HTTP &quot;Basic&quot; schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adbb32950149f0405fef2566ee545e5f42986bc6" translate="yes" xml:space="preserve">
          <source>HTTP provides a simple challenge-response authentication framework
   that can be used by a server to challenge a client request and by a
   client to provide authentication information.  It uses a case-
   insensitive token as a means to identify the authentication scheme,
   followed by additional information necessary for achieving 

   authentication via that scheme.  The latter can be either a comma-
   separated list of parameters or a single sequence of characters
   capable of holding base64-encoded information.

   Authentication parameters are name=value pairs, where the name token
   is matched case-insensitively, and each parameter name MUST only
   occur once per challenge.

     auth-scheme    = token

     auth-param     = token BWS &quot;=&quot; BWS ( token / quoted-string )

     token68        = 1*( ALPHA / DIGIT /
                          &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; / &quot;+&quot; / &quot;/&quot; ) *&quot;=&quot;

   The token68 syntax allows the 66 unreserved URI characters
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]), plus a few others, so that it can hold a base64,
   base64url (URL and filename safe alphabet), base32, or base16 (hex)
   encoding, with or without padding, but excluding whitespace
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC4648&lt;/a&gt;]).

   A 401 (Unauthorized) response message is used by an origin server to
   challenge the authorization of a user agent, including a
   WWW-Authenticate header field containing at least one challenge
   applicable to the requested resource.

   A 407 (Proxy Authentication Required) response message is used by a
   proxy to challenge the authorization of a client, including a
   Proxy-Authenticate header field containing at least one challenge
   applicable to the proxy for the requested resource.

     challenge   = auth-scheme [ 1*SP ( token68 / #auth-param ) ]

      Note: Many clients fail to parse a challenge that contains an
      unknown scheme.  A workaround for this problem is to list well-
      supported schemes (such as &quot;basic&quot;) first.

   A user agent that wishes to authenticate itself with an origin server
   -- usually, but not necessarily, after receiving a 401 (Unauthorized)
   -- can do so by including an Authorization header field with the
   request.

   A client that wishes to authenticate itself with a proxy -- usually,
   but not necessarily, after receiving a 407 (Proxy Authentication
   Required) -- can do so by including a Proxy-Authorization header
   field with the request. 

   Both the Authorization field value and the Proxy-Authorization field
   value contain the client's credentials for the realm of the resource
   being requested, based upon a challenge received in a response
   (possibly at some point in the past).  When creating their values,
   the user agent ought to do so by selecting the challenge with what it
   considers to be the most secure auth-scheme that it understands,
   obtaining credentials from the user as appropriate.  Transmission of
   credentials within header field values implies significant security
   considerations regarding the confidentiality of the underlying
   connection, as described in &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;.

     credentials = auth-scheme [ 1*SP ( token68 / #auth-param ) ]

   Upon receipt of a request for a protected resource that omits
   credentials, contains invalid credentials (e.g., a bad password) or
   partial credentials (e.g., when the authentication scheme requires
   more than one round trip), an origin server SHOULD send a 401
   (Unauthorized) response that contains a WWW-Authenticate header field
   with at least one (possibly new) challenge applicable to the
   requested resource.

   Likewise, upon receipt of a request that omits proxy credentials or
   contains invalid or partial proxy credentials, a proxy that requires
   authentication SHOULD generate a 407 (Proxy Authentication Required)
   response that contains a Proxy-Authenticate header field with at
   least one (possibly new) challenge applicable to the proxy.

   A server that receives valid credentials that are not adequate to
   gain access ought to respond with the 403 (Forbidden) status code
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.3&quot;&gt;Section&amp;nbsp;6.5.3 of [RFC7231]&lt;/a&gt;).

   HTTP does not restrict applications to this simple challenge-response
   framework for access authentication.  Additional mechanisms can be
   used, such as authentication at the transport level or via message
   encapsulation, and with additional header fields specifying
   authentication information.  However, such additional mechanisms are
   not defined by this specification.</source>
          <target state="translated">HTTP обеспечивает простую структуру аутентификации типа &quot;запрос-ответ&quot;, которая может использоваться сервером для оспаривания клиентского запроса и клиентом для предоставления информации аутентификации. Он использует нечувствительный к регистру токен в качестве средства идентификации схемы аутентификации, за которым следует дополнительная информация, необходимая для аутентификации по этой схеме. Последний может быть либо списком параметров, разделенных запятыми, либо одиночной последовательностью символов, способной хранить информацию в кодировке base64. Параметры аутентификации представляют собой пары имя = значение, где маркер имени сопоставляется без учета регистра, и каждое имя параметра ДОЛЖНО встречаться только один раз за запрос. auth-scheme = token auth-param = token BWS &quot;=&quot;BWS (token / quoted-string) token68 = 1 * (ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; / &quot;+&quot; / &quot;/&quot;) * &quot;=&quot; Синтаксис token68 позволяет 66 незарезервированных символов URI ([&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]), а также несколько других, так что он может содержать кодировку base64, base64url (безопасный алфавит для URL и имени файла), base32 или base16 (шестнадцатеричный), с заполнением или без него, но исключая пробелы ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC4648&lt;/a&gt;]). Ответное сообщение 401 (Unauthorized) используется исходным сервером для проверки авторизации пользовательского агента, включая поле заголовка WWW-Authenticate, содержащее по крайней мере один запрос, применимый к запрошенному ресурсу. Ответное сообщение 407 (Proxy Authentication Required) используется прокси-сервером для проверки авторизации клиента, включая поле заголовка Proxy-Authenticate, содержащее по крайней мере один запрос, применимый к прокси для запрошенного ресурса. Challenge = auth-scheme [1 * SP (token68 / # auth-param)] Примечание. Многие клиенты не могут проанализировать вызов, содержащий неизвестную схему. Обходной путь для этой проблемы - сначала перечислить хорошо поддерживаемые схемы (например, &amp;laquo;базовые&amp;raquo;). Пользовательский агент, который хочет аутентифицироваться на исходном сервере - обычноно не обязательно, после получения 401 (Unauthorized) - это можно сделать, включив в запрос поле заголовка авторизации. Клиент, который хочет аутентифицироваться с помощью прокси - обычно, но не обязательно, после получения 407 (требуется аутентификация прокси) - может сделать это, включив в запрос поле заголовка Proxy-Authorization. И значение поля Authorization, и значение поля Proxy-Authorization содержат учетные данные клиента для области запрашиваемого ресурса на основе запроса, полученного в ответе (возможно, в какой-то момент в прошлом). Создавая свои значения, пользовательский агент должен сделать это, выбрав задачу с тем, что он считает наиболее безопасной схемой аутентификации, которую он понимает, получая учетные данные от пользователя при необходимости.Передача учетных данных в значениях поля заголовка подразумевает серьезные соображения безопасности в отношении конфиденциальности базового соединения, как описано в&lt;a href=&quot;#section-6.1&quot;&gt;Раздел 6.1&lt;/a&gt;, credentials = auth-scheme [1 * SP (token68 / # auth-param)] При получении запроса на защищенный ресурс, который не содержит учетных данных, содержит недопустимые учетные данные (например, неверный пароль) или частичные учетные данные (например, при аутентификации схема требует более одного кругового обхода), исходный сервер ДОЛЖЕН отправить ответ 401 (неавторизованный), который содержит поле заголовка WWW-Authenticate с по крайней мере одним (возможно новым) запросом, применимым к запрошенному ресурсу. Аналогичным образом, при получении запроса, в котором отсутствуют учетные данные прокси или содержатся недопустимые или частичные учетные данные прокси, прокси, который требует аутентификации, ДОЛЖЕН генерировать ответ 407 (Proxy Authentication Required), который содержит поле заголовка Proxy-Authenticate по крайней мере с одним (возможно новым) проблема применима к прокси.Сервер, который получает действительные учетные данные, которых недостаточно для получения доступа, должен ответить кодом состояния 403 (Запрещено) (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.3&quot;&gt;Раздел 6.5.3 [RFC7231]&lt;/a&gt; ). HTTP не ограничивает приложения этой простой структурой запроса-ответа для аутентификации доступа. Могут использоваться дополнительные механизмы, такие как аутентификация на транспортном уровне или посредством инкапсуляции сообщений, а также с дополнительными полями заголовка, определяющими информацию аутентификации. Однако такие дополнительные механизмы не определены в данной спецификации.</target>
        </trans-unit>
        <trans-unit id="373942ad0bad321a26d1a83f0200afd58d5697de" translate="yes" xml:space="preserve">
          <source>HTTP provides several OPTIONAL challenge-response authentication
   mechanisms which can be used by a server to challenge a client
   request and by a client to provide authentication information. The
   general framework for access authentication, and the specification of
   &quot;basic&quot; and &quot;digest&quot; authentication, are specified in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. This
   specification adopts the definitions of &quot;challenge&quot; and &quot;credentials&quot;
   from that specification.</source>
          <target state="translated">HTTP предоставляет несколько ДОПОЛНИТЕЛЬНЫХ механизмов аутентификации типа &quot;запрос-ответ&quot;, которые могут использоваться сервером для оспаривания запроса клиента и клиентом для предоставления информации аутентификации. Общая структура для аутентификации доступа и спецификация &amp;laquo;базовой&amp;raquo; и &amp;laquo;дайджест-аутентификации&amp;raquo; указаны в &amp;laquo;HTTP-аутентификации: базовая и дайджест-аутентификация доступа&amp;raquo; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]. Эта спецификация принимает определения &amp;laquo;вызов&amp;raquo; и &amp;laquo;учетные данные&amp;raquo; из этой спецификации.</target>
        </trans-unit>
        <trans-unit id="a37a5613d3d5d4214d5abfa3246a8f2754483f2a" translate="yes" xml:space="preserve">
          <source>HTTP range requests allow to send only a portion of an HTTP message from a server to a client. Partial requests are useful for large media or downloading files with pause and resume functions, for example.</source>
          <target state="translated">Запросы диапазона HTTP позволяют отправить клиенту только часть HTTP-сообщения с сервера.Частичные запросы полезны,например,при работе с большими носителями или при загрузке файлов с функциями паузы и возобновления.</target>
        </trans-unit>
        <trans-unit id="f0381d73cd3211cb7f1d5c958b65d38f42cff6af" translate="yes" xml:space="preserve">
          <source>HTTP redirects always execute first &amp;mdash; they exist when there is not even a transmitted page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5389896e588834f2b24421a83cb0356215da18cf" translate="yes" xml:space="preserve">
          <source>HTTP redirects are always executed first when there is not even a page transmitted, and of course not even read.</source>
          <target state="translated">HTTP перенаправления всегда выполняются первыми,когда даже страница не передана,и,конечно,даже не прочитана.</target>
        </trans-unit>
        <trans-unit id="7fcfef93fd3c40ba7ae279fc8feebbaed226cca1" translate="yes" xml:space="preserve">
          <source>HTTP redirects are the best way to create redirections, but sometimes you don't have control over the server. In that case, try a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element with its &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;Refresh&lt;/code&gt; in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;&lt;/a&gt; of the page. When displaying the page, the browser will go to the indicated URL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b493de0ada593e9de6d698d017989888be7557a7" translate="yes" xml:space="preserve">
          <source>HTTP redirects are the preferred way to create redirections, but sometimes the Web developer doesn't have control over the server or cannot configure it. For these specific cases, the Web developers can craft an HTML page with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element and the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;refresh&lt;/code&gt; in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;&lt;/a&gt; of the page. When displaying the page, the browser will find this element and will go to the indicated page.</source>
          <target state="translated">Перенаправления HTTP являются предпочтительным способом создания перенаправлений, но иногда веб-разработчик не может контролировать сервер или не может его настроить. Для этих конкретных случаев веб-разработчики могут создать HTML-страницу с элементом &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; и атрибутом &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; установленным для &lt;code&gt;refresh&lt;/code&gt; в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt; &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; &lt;/a&gt; страницы. При отображении страницы браузер найдет этот элемент и перейдет на указанную страницу.</target>
        </trans-unit>
        <trans-unit id="40e98c57f45ddbbd1f7fd8fe0e605fd5413464d7" translate="yes" xml:space="preserve">
          <source>HTTP redirects aren't the only way to define redirections. There are two other methods: HTML redirections using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element, and JavaScript redirections using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;.</source>
          <target state="translated">Перенаправления HTTP - не единственный способ определения перенаправлений. Есть два других метода: перенаправление HTML с использованием элемента &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; и перенаправление JavaScript с использованием &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="862c8627d2b4f34ae450a4e001c8246586866cf8" translate="yes" xml:space="preserve">
          <source>HTTP redirects aren't the only way to define redirections. There are two others:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f59fe5f8bdc78024da5c64132db3a21db48277" translate="yes" xml:space="preserve">
          <source>HTTP referer on Wikipedia</source>
          <target state="translated">референт HTTP в Википедии</target>
        </trans-unit>
        <trans-unit id="7695bd9fd17d8eeddb124e64ff2e516e51ad7340" translate="yes" xml:space="preserve">
          <source>HTTP relies on the notion of an authoritative response: a response
   that has been determined by (or at the direction of) the authority
   identified within the target URI to be the most appropriate response
   for that request given the state of the target resource at the time
   of response message origination.  Providing a response from a
   non-authoritative source, such as a shared cache, is often useful to
   improve performance and availability, but only to the extent that the
   source can be trusted or the distrusted response can be safely used.

   Unfortunately, establishing authority can be difficult.  For example,
   phishing is an attack on the user's perception of authority, where
   that perception can be misled by presenting similar branding in 

   hypertext, possibly aided by userinfo obfuscating the authority
   component (see &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;).  User agents can reduce the impact of
   phishing attacks by enabling users to easily inspect a target URI
   prior to making an action, by prominently distinguishing (or
   rejecting) userinfo when present, and by not sending stored
   credentials and cookies when the referring document is from an
   unknown or untrusted source.

   When a registered name is used in the authority component, the &quot;http&quot;
   URI scheme (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;) relies on the user's local name resolution
   service to determine where it can find authoritative responses.  This
   means that any attack on a user's network host table, cached names,
   or name resolution libraries becomes an avenue for attack on
   establishing authority.  Likewise, the user's choice of server for
   Domain Name Service (DNS), and the hierarchy of servers from which it
   obtains resolution results, could impact the authenticity of address
   mappings; DNS Security Extensions (DNSSEC, [&lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC4033&lt;/a&gt;]) are one way to
   improve authenticity.

   Furthermore, after an IP address is obtained, establishing authority
   for an &quot;http&quot; URI is vulnerable to attacks on Internet Protocol
   routing.

   The &quot;https&quot; scheme (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;) is intended to prevent (or at
   least reveal) many of these potential attacks on establishing
   authority, provided that the negotiated TLS connection is secured and
   the client properly verifies that the communicating server's identity
   matches the target URI's authority component (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]).
   Correctly implementing such verification can be difficult (see
   [&lt;a href=&quot;#ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt;]).</source>
          <target state="translated">HTTP полагается на понятие авторитетного ответа: ответ, который был определен (или по указанию) органом, идентифицированным в целевом URI, как наиболее подходящий ответ для этого запроса с учетом состояния целевого ресурса в данный момент. отправления ответного сообщения. Предоставление ответа от неавторизованного источника, такого как общий кеш, часто полезно для повышения производительности и доступности, но только в той степени, в которой можно доверять источнику или можно безопасно использовать недоверенный ответ. К сожалению, установить власть бывает сложно. Например, фишинг - это атака на восприятие пользователем авторитета, при котором это восприятие можно ввести в заблуждение, представив аналогичный брендинг в гипертексте,возможно, при помощи userinfo, запутывающего компонент полномочий (см.&lt;a href=&quot;#section-2.7.1&quot;&gt;Раздел 2.7.1&lt;/a&gt; ). Пользовательские агенты могут снизить влияние фишинговых атак, позволяя пользователям легко проверять целевой URI до совершения действия, четко различая (или отклоняя) информацию о пользователе, если она присутствует, и не отправляя сохраненные учетные данные и файлы cookie, когда ссылающийся документ из неизвестный или ненадежный источник. Когда зарегистрированное имя используется в компоненте полномочий, схема URI &amp;laquo;http&amp;raquo; ( &lt;a href=&quot;#section-2.7.1&quot;&gt;раздел 2.7.1&lt;/a&gt;) полагается на локальную службу разрешения имен пользователя, чтобы определить, где он может найти авторитетные ответы. Это означает, что любая атака на сетевую таблицу хостов пользователя, кэшированные имена или библиотеки разрешения имен становится средством атаки на установление полномочий. Точно так же выбор пользователем сервера для службы доменных имен (DNS) и иерархия серверов, с которых он получает результаты разрешения, могут повлиять на подлинность сопоставлений адресов; Расширения безопасности DNS (DNSSEC, [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC4033&lt;/a&gt; ]) - это один из способов повышения аутентичности. Кроме того, после получения IP-адреса установление полномочий для URI &amp;laquo;http&amp;raquo; уязвимо для атак на маршрутизацию по Интернет-протоколу. Схема &quot;https&quot; ( &lt;a href=&quot;#section-2.7.2&quot;&gt;раздел 2.7.2.&lt;/a&gt;) предназначен для предотвращения (или, по крайней мере, выявления) многих из этих потенциальных атак на установление полномочий, при условии, что согласованное TLS-соединение защищено, и клиент должным образом проверяет, что идентификатор взаимодействующего сервера соответствует компоненту полномочий целевого URI (см. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt; ]) , Правильная реализация такой проверки может быть затруднена (см. [ &lt;a href=&quot;#ref-Georgiev&quot;&gt;Георгиев&lt;/a&gt; ]).</target>
        </trans-unit>
        <trans-unit id="9f50e4941b29dd7e65e26b2c2ee8f27fd3643197" translate="yes" xml:space="preserve">
          <source>HTTP relies on underlying transport protocols to provide message
   confidentiality when that is desired.  HTTP has been specifically
   designed to be independent of the transport protocol, such that it
   can be used over many different forms of encrypted connection, with
   the selection of such transports being identified by the choice of
   URI scheme or within user agent configuration.

   The &quot;https&quot; scheme can be used to identify resources that require a
   confidential connection, as described in &lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;.</source>
          <target state="translated">HTTP полагается на базовые транспортные протоколы, чтобы обеспечить конфиденциальность сообщений, когда это необходимо. HTTP был специально разработан, чтобы быть независимым от транспортного протокола, чтобы его можно было использовать во многих различных формах зашифрованного соединения, при этом выбор таких транспортов определяется выбором схемы URI или в конфигурации пользовательского агента. Схема &amp;laquo;https&amp;raquo; может использоваться для идентификации ресурсов, которым требуется конфиденциальное соединение, как описано в &lt;a href=&quot;#section-2.7.2&quot;&gt;Разделе 2.7.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cfd05af6cff4f10fa13fcdf1e53531e0f64c32a" translate="yes" xml:space="preserve">
          <source>HTTP request message routing is determined by each client based on
   the target resource, the client's proxy configuration, and
   establishment or reuse of an inbound connection.  The corresponding
   response routing follows the same connection chain back to the
   client.</source>
          <target state="translated">Маршрутизация сообщений HTTP-запросов определяется каждым клиентом на основе целевого ресурса,конфигурации клиентского прокси-сервера и установления или повторного использования входящего соединения.Соответствующая маршрутизация ответа следует той же цепочке соединений обратно к клиенту.</target>
        </trans-unit>
        <trans-unit id="2c8a5e9aaefc55ae6f8b58628a6a46daf09140bd" translate="yes" xml:space="preserve">
          <source>HTTP request methods</source>
          <target state="translated">методы HTTP-запроса</target>
        </trans-unit>
        <trans-unit id="13dd6cb8837a7e513f219955d516b3e87a62005c" translate="yes" xml:space="preserve">
          <source>HTTP requests are messages sent by the client to initiate an action on the server. Their &lt;em&gt;start-line&lt;/em&gt; contain three elements:</source>
          <target state="translated">HTTP-запросы - это сообщения, отправляемые клиентом для инициирования действия на сервере. Их &lt;em&gt;стартовая строка&lt;/em&gt; содержит три элемента:</target>
        </trans-unit>
        <trans-unit id="914464e25e17836661d23d43c1739c512c319a50" translate="yes" xml:space="preserve">
          <source>HTTP requests, and responses, share similar structure and are composed of:</source>
          <target state="translated">HTTP-запросы и ответы имеют схожую структуру и состоят из них:</target>
        </trans-unit>
        <trans-unit id="baed8872df40013bfa5b06f559f07e0a29344282" translate="yes" xml:space="preserve">
          <source>HTTP response codes indicate whether a specific HTTP request has been successfully completed. Responses are grouped in five classes: informational responses, successful responses, redirections, client errors, and servers errors.</source>
          <target state="translated">Коды ответа HTTP указывают,был ли конкретный запрос HTTP успешно завершен.Ответы сгруппированы в пять классов:информационные ответы,успешные ответы,перенаправления,ошибки клиентов и серверов.</target>
        </trans-unit>
        <trans-unit id="0e68989f0a2de628c6a35155870120ca03c2f18a" translate="yes" xml:space="preserve">
          <source>HTTP response header field instructs the user agent to store reporting endpoints for an origin.</source>
          <target state="translated">Поле заголовка ответа HTTP инструктирует пользовательского агента хранить отчетные конечные точки для источника.</target>
        </trans-unit>
        <trans-unit id="9bae5d05ad944fb1e294a99bcffd4e35229e257f" translate="yes" xml:space="preserve">
          <source>HTTP response status codes</source>
          <target state="translated">коды статуса ответа HTTP</target>
        </trans-unit>
        <trans-unit id="b57d1200b41d22a049735dbac8f54f4cf988cf0d" translate="yes" xml:space="preserve">
          <source>HTTP response status codes indicate whether a specific &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; request has been successfully completed. Responses are grouped in five classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c76e508f304e725a4ab9639fbe06b8e54f58b4d" translate="yes" xml:space="preserve">
          <source>HTTP response status codes indicate whether a specific &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; request has been successfully completed. Responses are grouped in five classes: informational responses, successful responses, redirects, client errors, and servers errors. Status codes are defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;section 10 of RFC 2616&lt;/a&gt;.</source>
          <target state="translated">Коды состояния HTTP-ответа указывают, был ли успешно выполнен конкретный &lt;a href=&quot;index&quot;&gt;HTTP-&lt;/a&gt; запрос. Ответы сгруппированы в пять классов: информационные ответы, успешные ответы, перенаправления, ошибки клиента и ошибки серверов. Коды состояния определены в &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;разделе 10 RFC 2616&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5a6f42d4f42646541a1cb9ef004b15fc1e9d233" translate="yes" xml:space="preserve">
          <source>HTTP retrieval requests using conditional or unconditional GET
   methods MAY request one or more sub-ranges of the entity, instead of
   the entire entity, using the Range request header, which applies to
   the entity returned as the result of the request:

      Range = &quot;Range&quot; &quot;:&quot; ranges-specifier 

   A server MAY ignore the Range header. However, HTTP/1.1 origin
   servers and intermediate caches ought to support byte ranges when
   possible, since Range supports efficient recovery from partially
   failed transfers, and supports efficient partial retrieval of large
   entities.

   If the server supports the Range header and the specified range or
   ranges are appropriate for the entity:

      - The presence of a Range header in an unconditional GET modifies
        what is returned if the GET is otherwise successful. In other
        words, the response carries a status code of 206 (Partial
        Content) instead of 200 (OK).

      - The presence of a Range header in a conditional GET (a request
        using one or both of If-Modified-Since and If-None-Match, or
        one or both of If-Unmodified-Since and If-Match) modifies what
        is returned if the GET is otherwise successful and the
        condition is true. It does not affect the 304 (Not Modified)
        response returned if the conditional is false.

   In some cases, it might be more appropriate to use the If-Range
   header (see &lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) in addition to the Range header.

   If a proxy that supports ranges receives a Range request, forwards
   the request to an inbound server, and receives an entire entity in
   reply, it SHOULD only return the requested range to its client. It
   SHOULD store the entire received response in its cache if that is
   consistent with its cache allocation policies.</source>
          <target state="translated">HTTP-запросы на извлечение с использованием условных или безусловных методов GET МОГУТ запрашивать один или несколько поддиапазонов объекта вместо всего объекта, используя заголовок запроса Range, который применяется к объекту, возвращенному в результате запроса: Range = &quot;Range &quot;&quot;: &quot;спецификатор диапазонов Сервер МОЖЕТ игнорировать заголовок диапазона. Однако исходные серверы HTTP / 1.1 и промежуточные кэши должны поддерживать байтовые диапазоны, когда это возможно, поскольку Range поддерживает эффективное восстановление после частично сбойных передач и поддерживает эффективное частичное извлечение больших объектов. Если сервер поддерживает заголовок Range и указанный диапазон или диапазоны подходят для объекта: - Наличие заголовка Range в безусловном GET изменяет то, что возвращается, если GET в противном случае успешно.Другими словами, ответ содержит код состояния 206 (частичное содержимое) вместо 200 (ОК). - Наличие заголовка Range в условном GET (запрос с использованием одного или обоих If-Modified-Since и If-None-Match, или одного или обоих If-Unmodified-Since и If-Match) изменяет то, что возвращается если в противном случае GET успешно и условие истинно. Это не влияет на ответ 304 (Not Modified), возвращаемый, если условие ложно. В некоторых случаях может быть более целесообразным использовать заголовок If-Range (см.или один или оба If-Unmodified-Since и If-Match) изменяют то, что возвращается, если GET в противном случае успешен и условие истинно. Это не влияет на ответ 304 (Not Modified), возвращаемый, если условие ложно. В некоторых случаях может быть более целесообразным использовать заголовок If-Range (см.или один или оба If-Unmodified-Since и If-Match) изменяют то, что возвращается, если GET в противном случае успешен и условие истинно. Это не влияет на ответ 304 (Not Modified), возвращаемый, если условие ложно. В некоторых случаях может быть более целесообразным использовать заголовок If-Range (см.&lt;a href=&quot;#section-14.27&quot;&gt;раздел 14.27&lt;/a&gt; ) в дополнение к заголовку Range. Если прокси-сервер, поддерживающий диапазоны, получает запрос диапазона, перенаправляет запрос на входящий сервер и получает в ответ весь объект, он ДОЛЖЕН возвращать только запрошенный диапазон своему клиенту. Ему СЛЕДУЕТ хранить весь полученный ответ в своем кэше, если это согласуется с его политиками выделения кеша.</target>
        </trans-unit>
        <trans-unit id="764bdb74b95275c85a8d7aa1fe3fe82d3d5e9d0f" translate="yes" xml:space="preserve">
          <source>HTTP status: &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/202&quot;&gt;&lt;code&gt;202&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Статус HTTP: &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/202&quot;&gt; &lt;code&gt;202&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96e2aaa2653ba0ee26b576dfaebf0854b040cb7a" translate="yes" xml:space="preserve">
          <source>HTTP tunneling</source>
          <target state="translated">HTTP-туннелирование</target>
        </trans-unit>
        <trans-unit id="269219e381ce4221eb783ce2498c82ac2c3eba0d" translate="yes" xml:space="preserve">
          <source>HTTP uses Internet Media Types [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;] in the Content-Type (&lt;a href=&quot;#section-14.17&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;) and Accept (&lt;a href=&quot;#section-14.1&quot;&gt;section 14.1&lt;/a&gt;) header fields in order to provide
   open and extensible data typing and type negotiation.

       media-type     = type &quot;/&quot; subtype *( &quot;;&quot; parameter )
       type           = token
       subtype        = token

   Parameters MAY follow the type/subtype in the form of attribute/value
   pairs (as defined in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;).

   The type, subtype, and parameter attribute names are case-
   insensitive. Parameter values might or might not be case-sensitive,
   depending on the semantics of the parameter name. Linear white space
   (LWS) MUST NOT be used between the type and subtype, nor between an
   attribute and its value. The presence or absence of a parameter might
   be significant to the processing of a media-type, depending on its
   definition within the media type registry. 

   Note that some older HTTP applications do not recognize media type
   parameters. When sending data to older HTTP applications,
   implementations SHOULD only use media type parameters when they are
   required by that type/subtype definition.

   Media-type values are registered with the Internet Assigned Number
   Authority (IANA [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;]). The media type registration process is
   outlined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;]. Use of non-registered media types is
   discouraged.</source>
          <target state="translated">HTTP использует Internet Media Types [ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt; ] в полях заголовка Content-Type ( &lt;a href=&quot;#section-14.17&quot;&gt;раздел &lt;/a&gt;&lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt; ) и Accept ( &lt;a href=&quot;#section-14.1&quot;&gt;раздел 14.1&lt;/a&gt; ) для обеспечения открытой и расширяемой типизации данных и согласования типов. media-type = type &quot;/&quot; subtype * (&quot;;&quot; параметр) type = token subtype = token Параметры МОГУТ следовать за типом / подтипом в форме пар атрибут / значение (как определено в &lt;a href=&quot;#section-3.6&quot;&gt;разделе 3.6.&lt;/a&gt;). В именах атрибутов типа, подтипа и параметра регистр не учитывается. Значения параметров могут или не могут быть чувствительны к регистру, в зависимости от семантики имени параметра. Линейные пробелы (LWS) НЕ ДОЛЖНЫ использоваться между типом и подтипом, а также между атрибутом и его значением. Наличие или отсутствие параметра может иметь значение для обработки типа носителя, в зависимости от его определения в реестре типов носителей. Обратите внимание, что некоторые старые приложения HTTP не распознают параметры типа мультимедиа. При отправке данных в более старые приложения HTTP реализации ДОЛЖНЫ использовать параметры типа носителя только тогда, когда они требуются определением этого типа / подтипа. Значения типа носителя регистрируются в Internet Assigned Number Authority (IANA [ &lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;]). Процесс регистрации типа носителя описан в &lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; [ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt; ]. Использование незарегистрированных типов носителей не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="b80bb07a4e60213a6bb04971b80d505cc84d5109" translate="yes" xml:space="preserve">
          <source>HTTP uses Internet media types [&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;] in the Content-Type
   (&lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt;) and Accept (&lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt;) header fields in order
   to provide open and extensible data typing and type negotiation.
   Media types define both a data format and various processing models:
   how to process that data in accordance with each context in which it
   is received.

     media-type = type &quot;/&quot; subtype *( OWS &quot;;&quot; OWS parameter )
     type       = token
     subtype    = token

   The type/subtype MAY be followed by parameters in the form of
   name=value pairs.

     parameter      = token &quot;=&quot; ( token / quoted-string ) 

   The type, subtype, and parameter name tokens are case-insensitive.
   Parameter values might or might not be case-sensitive, depending on
   the semantics of the parameter name.  The presence or absence of a
   parameter might be significant to the processing of a media-type,
   depending on its definition within the media type registry.

   A parameter value that matches the token production can be
   transmitted either as a token or within a quoted-string.  The quoted
   and unquoted values are equivalent.  For example, the following
   examples are all equivalent, but the first is preferred for
   consistency:

     text/html;charset=utf-8
     text/html;charset=UTF-8
     Text/HTML;Charset=&quot;utf-8&quot;
     text/html; charset=&quot;utf-8&quot;

   Internet media types ought to be registered with IANA according to
   the procedures defined in [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;].

      Note: Unlike some similar constructs in other header fields, media
      type parameters do not allow whitespace (even &quot;bad&quot; whitespace)
      around the &quot;=&quot; character.</source>
          <target state="translated">HTTP использует типы Интернет-носителей [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt; ] в Content-Type ( &lt;a href=&quot;#section-3.1.1.5&quot;&gt;раздел 3.1.1.5&lt;/a&gt; ) и Accept ( &lt;a href=&quot;#section-5.3.2&quot;&gt;раздел 5.3.2).&lt;/a&gt;) поля заголовка, чтобы обеспечить открытую и расширяемую типизацию данных и согласование типов. Типы медиа определяют как формат данных, так и различные модели обработки: как обрабатывать эти данные в соответствии с каждым контекстом, в котором они получены. media-type = type &quot;/&quot; subtype * (OWS &quot;;&quot; OWS parameter) type = token subtype = token За типом / подтипом могут следовать параметры в форме пар имя = значение. параметр = токен &quot;=&quot; (токен / строка в кавычках) В токенах типа, подтипа и имени параметра регистр не учитывается. Значения параметров могут или не могут быть чувствительны к регистру, в зависимости от семантики имени параметра. Наличие или отсутствие параметра может иметь значение для обработки медиа-типа,в зависимости от его определения в реестре типов носителей. Значение параметра, соответствующее производству токена, может быть передано либо как токен, либо в строке в кавычках. Цитированные и некотируемые значения эквивалентны. Например, все следующие примеры эквивалентны, но первый предпочтительнее для согласованности: text / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset = &quot;utf-8&quot; text / html ; charset = &quot;utf-8&quot; Типы Интернет-носителей должны быть зарегистрированы в IANA в соответствии с процедурами, определенными в [но для единообразия предпочтительнее первое: текст / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset = &quot;utf-8&quot; text / html; charset = &quot;utf-8&quot; Типы Интернет-носителей должны быть зарегистрированы в IANA в соответствии с процедурами, определенными в [но для единообразия предпочтительнее первое: текст / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset = &quot;utf-8&quot; text / html; charset = &quot;utf-8&quot; Типы Интернет-носителей должны быть зарегистрированы в IANA в соответствии с процедурами, определенными в [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ]. Примечание. В отличие от некоторых подобных конструкций в других полях заголовка, параметры типа мультимедиа не допускают пробелов (даже &amp;laquo;плохих&amp;raquo; пробелов) вокруг символа &amp;laquo;=&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="aa6f0f90fa306d4b1ed46d12bd83446d94bb910c" translate="yes" xml:space="preserve">
          <source>HTTP uses a &quot;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&quot; numbering scheme to indicate versions
   of the protocol.  This specification defines version &quot;1.1&quot;.  The
   protocol version as a whole indicates the sender's conformance with
   the set of requirements laid out in that version's corresponding
   specification of HTTP. 

   The version of an HTTP message is indicated by an HTTP-version field
   in the first line of the message.  HTTP-version is case-sensitive.

     HTTP-version  = HTTP-name &quot;/&quot; DIGIT &quot;.&quot; DIGIT
     HTTP-name     = %x48.54.54.50 ; &quot;HTTP&quot;, case-sensitive

   The HTTP version number consists of two decimal digits separated by a
   &quot;.&quot; (period or decimal point).  The first digit (&quot;major version&quot;)
   indicates the HTTP messaging syntax, whereas the second digit (&quot;minor
   version&quot;) indicates the highest minor version within that major
   version to which the sender is conformant and able to understand for
   future communication.  The minor version advertises the sender's
   communication capabilities even when the sender is only using a
   backwards-compatible subset of the protocol, thereby letting the
   recipient know that more advanced features can be used in response
   (by servers) or in future requests (by clients).

   When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;]
   or a recipient whose version is unknown, the HTTP/1.1 message is
   constructed such that it can be interpreted as a valid HTTP/1.0
   message if all of the newer features are ignored.  This specification
   places recipient-version requirements on some new features so that a
   conformant sender will only use compatible features until it has
   determined, through configuration or the receipt of a message, that
   the recipient supports HTTP/1.1.

   The interpretation of a header field does not change between minor
   versions of the same major HTTP version, though the default behavior
   of a recipient in the absence of such a field can change.  Unless
   specified otherwise, header fields defined in HTTP/1.1 are defined
   for all versions of HTTP/1.x.  In particular, the Host and Connection
   header fields ought to be implemented by all HTTP/1.x implementations
   whether or not they advertise conformance with HTTP/1.1.

   New header fields can be introduced without changing the protocol
   version if their defined semantics allow them to be safely ignored by
   recipients that do not recognize them.  Header field extensibility is
   discussed in &lt;a href=&quot;#section-3.2.1&quot;&gt;Section 3.2.1&lt;/a&gt;.

   Intermediaries that process HTTP messages (i.e., all intermediaries
   other than those acting as tunnels) MUST send their own HTTP-version
   in forwarded messages.  In other words, they are not allowed to
   blindly forward the first line of an HTTP message without ensuring
   that the protocol version in that message matches a version to which
   that intermediary is conformant for both the receiving and sending of
   messages.  Forwarding an HTTP message without rewriting the 

   HTTP-version might result in communication errors when downstream
   recipients use the message sender's version to determine what
   features are safe to use for later communication with that sender.

   A client SHOULD send a request version equal to the highest version
   to which the client is conformant and whose major version is no
   higher than the highest version supported by the server, if this is
   known.  A client MUST NOT send a version to which it is not
   conformant.

   A client MAY send a lower request version if it is known that the
   server incorrectly implements the HTTP specification, but only after
   the client has attempted at least one normal request and determined
   from the response status code or header fields (e.g., Server) that
   the server improperly handles higher request versions.

   A server SHOULD send a response version equal to the highest version
   to which the server is conformant that has a major version less than
   or equal to the one received in the request.  A server MUST NOT send
   a version to which it is not conformant.  A server can send a 505
   (HTTP Version Not Supported) response if it wishes, for any reason,
   to refuse service of the client's major protocol version.

   A server MAY send an HTTP/1.0 response to a request if it is known or
   suspected that the client incorrectly implements the HTTP
   specification and is incapable of correctly processing later version
   responses, such as when a client fails to parse the version number
   correctly or when an intermediary is known to blindly forward the
   HTTP-version even when it doesn't conform to the given minor version
   of the protocol.  Such protocol downgrades SHOULD NOT be performed
   unless triggered by specific client attributes, such as when one or
   more of the request header fields (e.g., User-Agent) uniquely match
   the values sent by a client known to be in error.

   The intention of HTTP's versioning design is that the major number
   will only be incremented if an incompatible message syntax is
   introduced, and that the minor number will only be incremented when
   changes made to the protocol have the effect of adding to the message
   semantics or implying additional capabilities of the sender.
   However, the minor version was not incremented for the changes
   introduced between [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], and this revision has
   specifically avoided any such changes to the protocol.

   When an HTTP message is received with a major version number that the
   recipient implements, but a higher minor version number than what the
   recipient implements, the recipient SHOULD process the message as if
   it were in the highest minor version within that major version to
   which the recipient is conformant.  A recipient can assume that a 

   message with a higher minor version, when sent to a recipient that
   has not yet indicated support for that higher version, is
   sufficiently backwards-compatible to be safely processed by any
   implementation of the same major version.</source>
          <target state="translated">HTTP использует схему нумерации &amp;laquo;&amp;lt;основной&amp;gt;. &amp;lt;Второстепенный&amp;gt;&amp;raquo; для обозначения версий протокола. Эта спецификация определяет версию &amp;laquo;1.1&amp;raquo;. Версия протокола в целом указывает на соответствие отправителя набору требований, изложенных в соответствующей спецификации HTTP для этой версии. Версия HTTP-сообщения указывается в поле HTTP-версия в первой строке сообщения. HTTP-версия чувствительна к регистру. HTTP-версия = HTTP-имя &quot;/&quot; ЦИФРА &quot;.&quot; ЦИФРОВОЕ HTTP-имя =% x48.54.54.50; &amp;laquo;HTTP&amp;raquo; с учетом регистра Номер версии HTTP состоит из двух десятичных цифр, разделенных знаком &amp;laquo;.&amp;raquo; (точка или десятичная точка). Первая цифра (&amp;laquo;основная версия&amp;raquo;) указывает синтаксис HTTP-сообщений,тогда как вторая цифра (&amp;laquo;дополнительная версия&amp;raquo;) указывает наивысшую дополнительную версию в этой основной версии, которой отправитель соответствует и способен понять для будущего общения. Младшая версия объявляет о коммуникационных возможностях отправителя, даже когда отправитель использует только обратно совместимое подмножество протокола, тем самым давая получателю знать, что более продвинутые функции могут использоваться в ответе (серверами) или в будущих запросах (клиентами). , Когда сообщение HTTP / 1.1 отправляется получателю HTTP / 1.0 [s возможности связи, даже когда отправитель использует только обратно совместимое подмножество протокола, тем самым давая получателю знать, что более продвинутые функции могут быть использованы в ответе (серверами) или в будущих запросах (клиентами). Когда сообщение HTTP / 1.1 отправляется получателю HTTP / 1.0 [s возможности связи, даже когда отправитель использует только обратно совместимое подмножество протокола, тем самым давая получателю знать, что более продвинутые функции могут быть использованы в ответе (серверами) или в будущих запросах (клиентами). Когда сообщение HTTP / 1.1 отправляется получателю HTTP / 1.0 [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;] или получателя, версия которого неизвестна, сообщение HTTP / 1.1 построено так, что его можно интерпретировать как действительное сообщение HTTP / 1.0, если все новые функции игнорируются. Эта спецификация устанавливает требования к версии получателя для некоторых новых функций, так что соответствующий отправитель будет использовать совместимые функции только до тех пор, пока он не определит посредством конфигурации или получения сообщения, что получатель поддерживает HTTP / 1.1. Интерпретация поля заголовка не меняется между дополнительными версиями одной и той же основной версии HTTP, хотя поведение получателя по умолчанию в отсутствие такого поля может измениться. Если не указано иное, поля заголовка, определенные в HTTP / 1.1, определены для всех версий HTTP / 1.x. В частности,поля заголовка Host и Connection должны быть реализованы всеми реализациями HTTP / 1.x, независимо от того, объявляют ли они соответствие с HTTP / 1.1. Новые поля заголовка могут быть введены без изменения версии протокола, если их определенная семантика позволяет безопасно игнорировать их получатели, которые их не распознают. Расширяемость поля заголовка обсуждается в&lt;a href=&quot;#section-3.2.1&quot;&gt;Раздел 3.2.1&lt;/a&gt;, Посредники, которые обрабатывают сообщения HTTP (т. Е. Все посредники, кроме тех, которые действуют как туннели), ДОЛЖНЫ отправлять свои собственные версии HTTP в пересылаемых сообщениях. Другими словами, им не разрешается вслепую пересылать первую строку HTTP-сообщения, не убедившись, что версия протокола в этом сообщении соответствует версии, которой этот посредник соответствует как для приема, так и для отправки сообщений. Пересылка HTTP-сообщения без перезаписи HTTP-версии может привести к ошибкам связи, когда нижестоящие получатели используют версию отправителя сообщения, чтобы определить, какие функции можно безопасно использовать для последующего обмена данными с этим отправителем.Клиенту СЛЕДУЕТ отправить версию запроса, равную наивысшей версии, которой соответствует клиент и чья основная версия не выше самой высокой версии, поддерживаемой сервером, если это известно. Клиент НЕ ДОЛЖЕН отправлять версию, которой он не соответствует. Клиент МОЖЕТ отправить более низкую версию запроса, если известно, что сервер неправильно реализует спецификацию HTTP, но только после того, как клиент попытался выполнить хотя бы один нормальный запрос и определил из кода состояния ответа или полей заголовка (например, Сервер), что сервер неправильно обрабатывает более высокие версии запросов. Серверу СЛЕДУЕТ отправлять версию ответа, равную наивысшей версии, которой соответствует сервер, которая имеет основную версию, меньшую или равную той, которая была получена в запросе.Сервер НЕ ДОЛЖЕН отправлять версию, которой он не соответствует. Сервер может отправить ответ 505 (версия HTTP не поддерживается), если он по какой-либо причине желает отказаться от обслуживания основной версии протокола клиента. Сервер МОЖЕТ отправить ответ HTTP / 1.0 на запрос, если известно или подозревается, что клиент неправильно реализует спецификацию HTTP и не может правильно обрабатывать ответы более поздних версий, например, когда клиенту не удается правильно проанализировать номер версии или когда известно, что посредник слепо пересылает HTTP-версию, даже если она не соответствует данной дополнительной версии протокола. Такое понижение версии протокола НЕ ДОЛЖНО выполняться, если только оно не инициировано конкретными атрибутами клиента, например, когда одно или несколько полей заголовка запроса (например,User-Agent) однозначно соответствуют значениям, отправленным клиентом, заведомо ошибочным. Цель дизайна управления версиями HTTP состоит в том, что старший номер будет увеличиваться только в том случае, если введен несовместимый синтаксис сообщения, а второстепенный номер будет увеличиваться только тогда, когда изменения, внесенные в протокол, повлияют на добавление к семантике сообщения или подразумевают дополнительные возможности отправителя. Однако дополнительная версия не была увеличена для изменений, внесенных между [и что младший номер будет увеличиваться только тогда, когда изменения, внесенные в протокол, повлекут за собой добавление к семантике сообщения или подразумевают дополнительные возможности отправителя. Однако дополнительная версия не была увеличена для изменений, внесенных между [и что младший номер будет увеличиваться только тогда, когда изменения, внесенные в протокол, повлекут за собой добавление к семантике сообщения или подразумевают дополнительные возможности отправителя. Однако дополнительная версия не была увеличена для изменений, внесенных между [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt; ] и [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ], и эта редакция специально избегает любых таких изменений в протоколе. Когда получено сообщение HTTP с основным номером версии, который реализует получатель, но с более высоким второстепенным номером версии, чем то, что реализует получатель, получатель ДОЛЖЕН обработать сообщение так, как если бы оно было с наивысшей дополнительной версией в той основной версии, для которой получатель соответствует. Получатель может предположить, что сообщение с более высокой дополнительной версией, отправленное получателю, который еще не указал на поддержку этой более высокой версии, является достаточно обратно совместимым, чтобы его можно было безопасно обработать любой реализацией той же основной версии.</target>
        </trans-unit>
        <trans-unit id="d3a5b43c3101b03cd5693da68dc42b80224e0a29" translate="yes" xml:space="preserve">
          <source>HTTP uses a &quot;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&quot; numbering scheme to indicate versions
   of the protocol. The protocol versioning policy is intended to allow
   the sender to indicate the format of a message and its capacity for
   understanding further HTTP communication, rather than the features
   obtained via that communication. No change is made to the version
   number for the addition of message components which do not affect
   communication behavior or which only add to extensible field values.
   The &amp;lt;minor&amp;gt; number is incremented when the changes made to the
   protocol add features which do not change the general message parsing
   algorithm, but which may add to the message semantics and imply
   additional capabilities of the sender. The &amp;lt;major&amp;gt; number is
   incremented when the format of a message within the protocol is
   changed. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [&lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;] for a fuller explanation. 

   The version of an HTTP message is indicated by an HTTP-Version field
   in the first line of the message.

       HTTP-Version   = &quot;HTTP&quot; &quot;/&quot; 1*DIGIT &quot;.&quot; 1*DIGIT

   Note that the major and minor numbers MUST be treated as separate
   integers and that each MAY be incremented higher than a single digit.
   Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is
   lower than HTTP/12.3. Leading zeros MUST be ignored by recipients and
   MUST NOT be sent.

   An application that sends a request or response message that includes
   HTTP-Version of &quot;HTTP/1.1&quot; MUST be at least conditionally compliant
   with this specification. Applications that are at least conditionally
   compliant with this specification SHOULD use an HTTP-Version of
   &quot;HTTP/1.1&quot; in their messages, and MUST do so for any message that is
   not compatible with HTTP/1.0. For more details on when to send
   specific HTTP-Version values, see &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [&lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;].

   The HTTP version of an application is the highest HTTP version for
   which the application is at least conditionally compliant.

   Proxy and gateway applications need to be careful when forwarding
   messages in protocol versions different from that of the application.
   Since the protocol version indicates the protocol capability of the
   sender, a proxy/gateway MUST NOT send a message with a version
   indicator which is greater than its actual version. If a higher
   version request is received, the proxy/gateway MUST either downgrade
   the request version, or respond with an error, or switch to tunnel
   behavior.

   Due to interoperability problems with HTTP/1.0 proxies discovered
   since the publication of &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;[&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;], caching proxies MUST, gateways
   MAY, and tunnels MUST NOT upgrade the request to the highest version
   they support. The proxy/gateway's response to that request MUST be in
   the same major version as the request.

      Note: Converting between versions of HTTP may involve modification
      of header fields required or forbidden by the versions involved.</source>
          <target state="translated">HTTP использует схему нумерации &amp;laquo;&amp;lt;основной&amp;gt;. &amp;lt;Второстепенный&amp;gt;&amp;raquo; для обозначения версий протокола. Политика управления версиями протокола предназначена для того, чтобы позволить отправителю указывать формат сообщения и его способность понимать дальнейшую связь HTTP, а не функции, полученные посредством этой связи. В номер версии не вносятся изменения для добавления компонентов сообщения, которые не влияют на поведение связи или которые только добавляют к расширяемым значениям полей. Число &amp;lt;minor&amp;gt; увеличивается, когда изменения, внесенные в протокол, добавляют функции, которые не изменяют общий алгоритм синтаксического анализа сообщения, но которые могут добавить к семантике сообщения и предполагать дополнительные возможности отправителя. &amp;lt;Майор&amp;gt;Число увеличивается при изменении формата сообщения в протоколе. Видеть&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [ &lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;] для более полного объяснения. Версия сообщения HTTP указывается в поле HTTP-Version в первой строке сообщения. HTTP-Version = &quot;HTTP&quot; &quot;/&quot; 1 * ЦИФРА &quot;.&quot; 1 * ЦИФРА Обратите внимание, что старший и младший числа ДОЛЖНЫ обрабатываться как отдельные целые числа и что каждое МОЖЕТ быть увеличено более чем на одну цифру. Таким образом, HTTP / 2.4 является более ранней версией, чем HTTP / 2.13, которая, в свою очередь, ниже, чем HTTP / 12.3. Начальные нули ДОЛЖНЫ игнорироваться получателями и НЕ ДОЛЖНЫ отправляться. Приложение, которое отправляет сообщение запроса или ответа, которое включает HTTP-версию &amp;laquo;HTTP / 1.1&amp;raquo;, ДОЛЖНО хотя бы условно соответствовать этой спецификации. Приложения, которые хотя бы условно соответствуют этой спецификации, ДОЛЖНЫ использовать HTTP-версию &amp;laquo;HTTP / 1.1&amp;raquo;.в своих сообщениях, и ДОЛЖЕН делать это для любого сообщения, несовместимого с HTTP / 1.0. Для получения дополнительной информации о том, когда отправлять определенные значения HTTP-версии, см.&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [ &lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt; ]. Версия HTTP приложения - это самая высокая версия HTTP, которой приложение соответствует хотя бы условно. Приложениям прокси и шлюза следует соблюдать осторожность при пересылке сообщений в версиях протокола, отличных от версии приложения. Поскольку версия протокола указывает возможности протокола отправителя, прокси-сервер / шлюз НЕ ДОЛЖЕН отправлять сообщение с индикатором версии, превышающим его фактическую версию. Если получен запрос более высокой версии, прокси / шлюз ДОЛЖЕН либо понизить версию запроса, либо ответить с ошибкой, либо переключиться на поведение туннеля. Из-за проблем взаимодействия с прокси HTTP / 1.0, обнаруженных после публикации &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;], кэширующие прокси ДОЛЖНЫ, шлюзы МОГУТ, а туннели НЕ ДОЛЖНЫ обновлять запрос до самой высокой версии, которую они поддерживают. Ответ прокси / шлюза на этот запрос ДОЛЖЕН быть той же основной версии, что и запрос. Примечание. Преобразование между версиями HTTP может включать изменение полей заголовков, требуемых или запрещенных соответствующими версиями.</target>
        </trans-unit>
        <trans-unit id="de9ea4b9303de1ca70c1a8e05822b3b34b2bc2c1" translate="yes" xml:space="preserve">
          <source>HTTP uses charset names to indicate or negotiate the character
   encoding scheme of a textual representation [&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt;].  A charset is
   identified by a case-insensitive token.

     charset = token

   Charset names ought to be registered in the IANA &quot;Character Sets&quot;
   registry (&amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt;&amp;gt;) according
   to the procedures defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt;].</source>
          <target state="translated">HTTP использует имена кодировок, чтобы указать или согласовать схему кодировки символов текстового представления [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt; ]. Кодировка идентифицируется токеном без учета регистра. charset = token Имена кодировок должны быть зарегистрированы в реестре &amp;laquo;Наборы символов&amp;raquo; IANA (&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt; &amp;gt;) в соответствии с процедурами, определенными в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="f64b344cb46f8dc4aefac27a98f9f8e7568e4d7b" translate="yes" xml:space="preserve">
          <source>HTTP uses the same definition of the term &quot;character set&quot; as that
   described for MIME: 

   The term &quot;character set&quot; is used in this document to refer to a
   method used with one or more tables to convert a sequence of octets
   into a sequence of characters. Note that unconditional conversion in
   the other direction is not required, in that not all characters may
   be available in a given character set and a character set may provide
   more than one sequence of octets to represent a particular character.
   This definition is intended to allow various kinds of character
   encoding, from simple single-table mappings such as US-ASCII to
   complex table switching methods such as those that use ISO-2022's
   techniques. However, the definition associated with a MIME character
   set name MUST fully specify the mapping to be performed from octets
   to characters. In particular, use of external profiling information
   to determine the exact mapping is not permitted.

      Note: This use of the term &quot;character set&quot; is more commonly
      referred to as a &quot;character encoding.&quot; However, since HTTP and
      MIME share the same registry, it is important that the terminology
      also be shared.

   HTTP character sets are identified by case-insensitive tokens. The
   complete set of tokens is defined by the IANA Character Set registry
   [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;].

       charset = token

   Although HTTP allows an arbitrary token to be used as a charset
   value, any token that has a predefined value within the IANA
   Character Set registry [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;] MUST represent the character set defined
   by that registry. Applications SHOULD limit their use of character
   sets to those defined by the IANA registry.

   Implementors should be aware of IETF character set requirements [&lt;a href=&quot;#ref-38&quot;&gt;38&lt;/a&gt;]
   [&lt;a href=&quot;#ref-41&quot;&gt;41&lt;/a&gt;].</source>
          <target state="translated">HTTP использует то же определение термина &amp;laquo;набор символов&amp;raquo;, что и для MIME: термин &amp;laquo;набор символов&amp;raquo; используется в этом документе для обозначения метода, используемого с одной или несколькими таблицами для преобразования последовательности октетов в последовательность персонажи. Обратите внимание, что безусловное преобразование в обратном направлении не требуется, поскольку не все символы могут быть доступны в данном наборе символов, а набор символов может обеспечивать более одной последовательности октетов для представления конкретного символа. Это определение предназначено для обеспечения различных видов кодировки символов, от простых отображений одной таблицы, таких как US-ASCII, до сложных методов переключения таблиц, таких как методы, использующие методы ISO-2022. Тем не мение,определение, связанное с именем набора символов MIME, ДОЛЖНО полностью определять отображение, которое должно выполняться от октетов к символам. В частности, использование информации внешнего профилирования для определения точного сопоставления не допускается. Примечание. Такое использование термина &amp;laquo;набор символов&amp;raquo; чаще называют &amp;laquo;кодировкой символов&amp;raquo;. Однако, поскольку HTTP и MIME используют один и тот же реестр, важно, чтобы терминология также была общей. Наборы символов HTTP идентифицируются токенами без учета регистра. Полный набор токенов определяется реестром набора символов IANA [чаще называют &amp;laquo;кодировкой символов&amp;raquo;. Однако, поскольку HTTP и MIME используют один и тот же реестр, важно, чтобы терминология также была общей. Наборы символов HTTP идентифицируются токенами без учета регистра. Полный набор токенов определяется реестром набора символов IANA [чаще называют &amp;laquo;кодировкой символов&amp;raquo;. Однако, поскольку HTTP и MIME используют один и тот же реестр, важно, чтобы терминология также была общей. Наборы символов HTTP идентифицируются токенами без учета регистра. Полный набор токенов определяется реестром набора символов IANA [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ]. charset = token Хотя HTTP позволяет использовать произвольный токен в качестве значения кодировки, любой токен, имеющий предопределенное значение в реестре набора символов IANA [ &lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ], ДОЛЖЕН представлять набор символов, определенный этим реестром. Приложениям СЛЕДУЕТ ограничивать использование наборов символов теми, которые определены в реестре IANA. Разработчики должны знать требования к набору символов IETF [ &lt;a href=&quot;#ref-38&quot;&gt;38&lt;/a&gt; ] [ &lt;a href=&quot;#ref-41&quot;&gt;41&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="4998cbc56519b60012d9ddef5a93ab40ac390988" translate="yes" xml:space="preserve">
          <source>HTTP was created for the World Wide Web (WWW) architecture and has
   evolved over time to support the scalability needs of a worldwide
   hypertext system.  Much of that architecture is reflected in the
   terminology and syntax productions used to define HTTP.</source>
          <target state="translated">HTTP был создан для архитектуры World Wide Web (WWW)и со временем развивался для поддержки потребностей в масштабируемости всемирной гипертекстовой системы.Большая часть этой архитектуры отражена в терминологии и синтаксисе,используемом для определения HTTP.</target>
        </trans-unit>
        <trans-unit id="40aed2983145eadb2c78a80757cda404bbec1b9e" translate="yes" xml:space="preserve">
          <source>HTTP was created in the early 1990s and has been extended several times. This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, and the modern HTTP/2 as well as minor novelties introduced over the years.</source>
          <target state="translated">HTTP был создан в начале 1990-х годов и неоднократно продлевался.Данная статья проходит через свою историю и описывает HTTP/0.9,HTTP/1.0,HTTP/1.1 и современный HTTP/2,а также небольшие новшества,появившиеся за эти годы.</target>
        </trans-unit>
        <trans-unit id="6691219872cf8222b135471124cba8cce6315df4" translate="yes" xml:space="preserve">
          <source>HTTP was created in the early 1990s and has been extended several times. This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, and the modern HTTP/2, as well as novelties introduced over the years.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8847a48bfa3a8070b11a550d8e6423fe9a938e29" translate="yes" xml:space="preserve">
          <source>HTTP was first specified in the early 1990s. Designed with extensibility in mind, it has seen numerous additions over the years; this lead to its specification being scattered through numerous specification documents (in the midst of experimental abandoned extensions). This page lists relevant resources about HTTP.</source>
          <target state="translated">Впервые HTTP был указан в начале 1990-х годов.Разработанный с учетом расширяемости,он видел многочисленные дополнения на протяжении многих лет;это привело к тому,что его спецификация была разбросана по многочисленным спецификационным документам (в разгар экспериментальных заброшенных расширений).На этой странице перечислены соответствующие ресурсы о HTTP.</target>
        </trans-unit>
        <trans-unit id="c36d6fae868bc13b893908c5f64cbe8e452543ec" translate="yes" xml:space="preserve">
          <source>HTTP's approach to error handling has been explained.  (&lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;)

   The HTTP-version ABNF production has been clarified to be case-
   sensitive.  Additionally, version numbers have been restricted to
   single digits, due to the fact that implementations are known to
   handle multi-digit version numbers incorrectly.  (&lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt;)

   Userinfo (i.e., username and password) are now disallowed in HTTP and
   HTTPS URIs, because of security issues related to their transmission
   on the wire.  (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;)

   The HTTPS URI scheme is now defined by this specification;
   previously, it was done in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-2.4&quot;&gt;Section&amp;nbsp;2.4 of [RFC2818]&lt;/a&gt;.  Furthermore, it
   implies end-to-end security.  (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;)

   HTTP messages can be (and often are) buffered by implementations;
   despite it sometimes being available as a stream, HTTP is
   fundamentally a message-oriented protocol.  Minimum supported sizes
   for various protocol elements have been suggested, to improve
   interoperability.  (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;)

   Invalid whitespace around field-names is now required to be rejected,
   because accepting it represents a security vulnerability.  The ABNF
   productions defining header fields now only list the field value.
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;)

   Rules about implicit linear whitespace between certain grammar
   productions have been removed; now whitespace is only allowed where
   specifically defined in the ABNF.  (&lt;a href=&quot;#section-3.2.3&quot;&gt;Section 3.2.3&lt;/a&gt;)

   Header fields that span multiple lines (&quot;line folding&quot;) are
   deprecated.  (&lt;a href=&quot;#section-3.2.4&quot;&gt;Section 3.2.4&lt;/a&gt;)

   The NUL octet is no longer allowed in comment and quoted-string text,
   and handling of backslash-escaping in them has been clarified.  The
   quoted-pair rule no longer allows escaping control characters other
   than HTAB.  Non-US-ASCII content in header fields and the reason
   phrase has been obsoleted and made opaque (the TEXT rule was
   removed).  (&lt;a href=&quot;#section-3.2.6&quot;&gt;Section 3.2.6&lt;/a&gt;)

   Bogus Content-Length header fields are now required to be handled as
   errors by recipients.  (&lt;a href=&quot;#section-3.3.2&quot;&gt;Section 3.3.2&lt;/a&gt;)

   The algorithm for determining the message body length has been
   clarified to indicate all of the special cases (e.g., driven by
   methods or status codes) that affect it, and that new protocol 

   elements cannot define such special cases.  CONNECT is a new, special
   case in determining message body length. &quot;multipart/byteranges&quot; is no
   longer a way of determining message body length detection.
   (&lt;a href=&quot;#section-3.3.3&quot;&gt;Section 3.3.3&lt;/a&gt;)

   The &quot;identity&quot; transfer coding token has been removed.  (Sections &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;
   and 4)

   Chunk length does not include the count of the octets in the chunk
   header and trailer.  Line folding in chunk extensions is disallowed.
   (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   The meaning of the &quot;deflate&quot; content coding has been clarified.
   (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   The segment + query components of &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; have been used to define
   the request-target, instead of abs_path from &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt;.  The
   asterisk-form of the request-target is only allowed with the OPTIONS
   method.  (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;)

   The term &quot;Effective Request URI&quot; has been introduced.  (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;)

   Gateways do not need to generate Via header fields anymore.
   (&lt;a href=&quot;#section-5.7.1&quot;&gt;Section 5.7.1&lt;/a&gt;)

   Exactly when &quot;close&quot; connection options have to be sent has been
   clarified.  Also, &quot;hop-by-hop&quot; header fields are required to appear
   in the Connection header field; just because they're defined as hop-
   by-hop in this specification doesn't exempt them.  (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;)

   The limit of two connections per server has been removed.  An
   idempotent sequence of requests is no longer required to be retried.
   The requirement to retry requests under certain circumstances when
   the server prematurely closes the connection has been removed.  Also,
   some extraneous requirements about when servers are allowed to close
   connections prematurely have been removed.  (&lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;)

   The semantics of the Upgrade header field is now defined in responses
   other than 101 (this was incorporated from [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;]).  Furthermore,
   the ordering in the field value is now significant.  (&lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;)

   Empty list elements in list productions (e.g., a list header field
   containing &quot;, ,&quot;) have been deprecated.  (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;)

   Registration of Transfer Codings now requires IETF Review
   (&lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;) 

   This specification now defines the Upgrade Token Registry, previously
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;Section&amp;nbsp;7.2 of [RFC2817]&lt;/a&gt;.  (&lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt;)

   The expectation to support HTTP/0.9 requests has been removed.
   (Appendix A)

   Issues with the Keep-Alive and Proxy-Connection header fields in
   requests are pointed out, with use of the latter being discouraged
   altogether.  (Appendix A.1.2)</source>
          <target state="translated">Был объяснен подход HTTP к обработке ошибок. ( &lt;a href=&quot;#section-2.5&quot;&gt;Раздел 2.5&lt;/a&gt; ) Уточнено, что производство ABNF в HTTP-версии учитывает регистр. Кроме того, номера версий были ограничены однозначными числами из-за того, что реализации, как известно, неправильно обрабатывают многозначные номера версий. ( &lt;a href=&quot;#section-2.6&quot;&gt;Раздел 2.6&lt;/a&gt; ) Userinfo (то есть имя пользователя и пароль) теперь запрещены в URI HTTP и HTTPS из-за проблем с безопасностью, связанных с их передачей по сети. ( &lt;a href=&quot;#section-2.7.1&quot;&gt;Раздел 2.7.1&lt;/a&gt; ) Схема HTTPS URI теперь определяется этой спецификацией; ранее это было сделано в &lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-2.4&quot;&gt;разделе 2.4 [RFC2818]&lt;/a&gt; . Кроме того, это подразумевает сквозную безопасность. ( &lt;a href=&quot;#section-2.7.2&quot;&gt;Раздел 2.7.2&lt;/a&gt;) Сообщения HTTP могут быть (и часто) буферизуются реализациями; Несмотря на то, что иногда он доступен в виде потока, HTTP по сути является протоколом, ориентированным на сообщения. Были предложены минимальные поддерживаемые размеры для различных элементов протокола, чтобы улучшить взаимодействие. ( &lt;a href=&quot;#section-3&quot;&gt;Раздел 3&lt;/a&gt; ) Недействительные пробелы вокруг имен полей теперь необходимо отклонять, поскольку их принятие представляет собой уязвимость системы безопасности. В продуктах ABNF, определяющих поля заголовка, теперь указывается только значение поля. ( &lt;a href=&quot;#section-3.2&quot;&gt;Раздел 3.2&lt;/a&gt; ) Были удалены правила о неявных линейных пробелах между некоторыми грамматическими произведениями; теперь пробелы разрешены только там, где это специально определено в ABNF. ( &lt;a href=&quot;#section-3.2.3&quot;&gt;Раздел 3.2.3&lt;/a&gt;) Поля заголовка, занимающие несколько строк (&amp;laquo;перенос строк&amp;raquo;), устарели. ( &lt;a href=&quot;#section-3.2.4&quot;&gt;Раздел 3.2.4&lt;/a&gt; ) Октет NUL больше не разрешен в комментариях и текстах в кавычках, и была уточнена обработка в них обратного слэша. Правило пары кавычек больше не позволяет экранировать управляющие символы, кроме HTAB. Содержимое не в формате US-ASCII в полях заголовка и фраза причины устарели и сделаны непрозрачными (правило TEXT было удалено). ( &lt;a href=&quot;#section-3.2.6&quot;&gt;Раздел 3.2.6&lt;/a&gt; ) Поля заголовка Bogus Content-Length теперь должны обрабатываться получателями как ошибки. ( &lt;a href=&quot;#section-3.3.2&quot;&gt;Раздел 3.3.2&lt;/a&gt;) Алгоритм определения длины тела сообщения был уточнен, чтобы указать все особые случаи (например, управляемые методами или кодами состояния), которые влияют на него, и что новые элементы протокола не могут определять такие особые случаи. CONNECT - это новый особый случай определения длины тела сообщения. &quot;multipart / byteranges&quot; больше не является способом определения длины тела сообщения. ( &lt;a href=&quot;#section-3.3.3&quot;&gt;Раздел 3.3.3&lt;/a&gt; ) Маркер кодирования передачи &quot;identity&quot; был удален. (Разделы &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; и 4) Длина блока не включает количество октетов в заголовке и конце блока. Сворачивание строк в расширениях фрагментов запрещено. ( &lt;a href=&quot;#section-4.1&quot;&gt;Раздел 4.1&lt;/a&gt; ) Уточнено значение кодирования содержимого &quot;deflate&quot;. (&lt;a href=&quot;#section-4.2.2&quot;&gt;Раздел 4.2.2&lt;/a&gt; ). Для определения цели запроса использовались компоненты сегмента + запроса из &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; вместо abs_path из &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt; . Форма звездочки для цели запроса разрешена только с методом OPTIONS. ( &lt;a href=&quot;#section-5.3&quot;&gt;Раздел 5.3&lt;/a&gt; ) Был введен термин &amp;laquo;действующий URI запроса&amp;raquo;. ( &lt;a href=&quot;#section-5.5&quot;&gt;Раздел 5.5&lt;/a&gt; ) Шлюзы больше не должны создавать поля заголовка Via. ( &lt;a href=&quot;#section-5.7.1&quot;&gt;Раздел 5.7.1&lt;/a&gt; ) Было уточнено, когда именно нужно отправлять параметры &amp;laquo;закрытия&amp;raquo;. Кроме того, в поле заголовка соединения должны отображаться поля заголовка &amp;laquo;шаг за шагом&amp;raquo;; то, что они определены в этой спецификации как поэтапные, не освобождает их.( &lt;a href=&quot;#section-6.1&quot;&gt;Раздел 6.1&lt;/a&gt;) Ограничение двух подключений на сервер было снято. Идемпотентная последовательность запросов больше не требуется повторять. Требование повторять запросы при определенных обстоятельствах, когда сервер преждевременно закрывает соединение, было удалено. Также были удалены некоторые посторонние требования о том, когда серверам разрешено преждевременно закрывать соединения. ( &lt;a href=&quot;#section-6.3&quot;&gt;Раздел 6.3&lt;/a&gt; ) Семантика поля заголовка Upgrade теперь определяется в ответах, отличных от 101 (это было включено из [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ]). Кроме того, теперь важен порядок значений поля. ( &lt;a href=&quot;#section-6.7&quot;&gt;Раздел 6.7&lt;/a&gt; ) Пустые элементы списка в продуктах списка (например, поле заголовка списка, содержащее &quot;,&quot;) устарели. (&lt;a href=&quot;#section-7&quot;&gt;Раздел 7&lt;/a&gt; ) Для регистрации кодов передачи теперь требуется проверка IETF ( &lt;a href=&quot;#section-8.4&quot;&gt;раздел 8.4&lt;/a&gt; ). Эта спецификация теперь определяет реестр токенов обновления, ранее определенный в &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;разделе 7.2 [RFC2817]&lt;/a&gt; . ( &lt;a href=&quot;#section-8.6&quot;&gt;Раздел 8.6&lt;/a&gt; ) Ожидание поддержки запросов HTTP / 0.9 было удалено. (Приложение A) Отмечены проблемы с полями заголовка Keep-Alive и Proxy-Connection в запросах, при этом использование последнего не рекомендуется. (Приложение A.1.2)</target>
        </trans-unit>
        <trans-unit id="e75786a71ce66c44187c7d3570685182eb4f5400" translate="yes" xml:space="preserve">
          <source>HTTP-only cookies aren't accessible via JavaScript through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; property, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; API to mitigate attacks against cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt; cookie только для HTTP недоступны через JavaScript через свойство Document.cookie , API &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; или API &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; для смягчения атак на межсайтовый скриптинг ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="645478239b71d9e2120cd5c5e2c81c2c7e39f857" translate="yes" xml:space="preserve">
          <source>HTTP/0.9 &amp;ndash; The one-line protocol</source>
          <target state="translated">HTTP / 0.9 - однострочный протокол</target>
        </trans-unit>
        <trans-unit id="44cba524f054d5d6640a40b11e1c3c0dd2b2e81c" translate="yes" xml:space="preserve">
          <source>HTTP/0.9 was very limited and both browsers and servers quickly extended it to be more versatile:</source>
          <target state="translated">HTTP/0.9 был очень ограничен,и браузеры и серверы быстро расширили его,чтобы он стал более универсальным:</target>
        </trans-unit>
        <trans-unit id="17104213d7caf462f808b5202b6b3bf53c6f9e5c" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 &amp;ndash; Building extensibility</source>
          <target state="translated">HTTP / 1.0 - создание расширяемости</target>
        </trans-unit>
        <trans-unit id="8cfcb01eada0b8cfd065017e118d423b8f745b23" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 connections are not persistent by default. Setting &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; to anything other than &lt;code&gt;close&lt;/code&gt;, usually &lt;code&gt;retry-after&lt;/code&gt;, will make them persistent.</source>
          <target state="translated">По умолчанию соединения HTTP / 1.0 не являются постоянными. Установка для &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; любого другого значения, кроме &lt;code&gt;close&lt;/code&gt; , обычно &lt;code&gt;retry-after&lt;/code&gt; , сделает их постоянными.</target>
        </trans-unit>
        <trans-unit id="c0e8fb29ae930b0d157a9f98acea4150c0686f37" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 opened a TCP connection for each request/response exchange, introducing two major flaws: opening a connection needs several round-trips of messages and therefore slow, but becomes more efficient when several messages are sent, and regularly sent: &lt;em&gt;warm&lt;/em&gt; connections are more efficient than &lt;em&gt;cold&lt;/em&gt; ones.</source>
          <target state="translated">HTTP / 1.0 открывал TCP-соединение для каждого обмена запросом / ответом, представляя два основных недостатка: для открытия соединения требуется несколько циклов передачи сообщений и, следовательно, медленное, но становится более эффективным, когда несколько сообщений отправляются и регулярно отправляются: &lt;em&gt;теплые&lt;/em&gt; соединения эффективнее &lt;em&gt;холодных&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0d0b58bbcdf0ad6dac8b90fb47db84cff63b6a65" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &amp;ndash; The standardized protocol</source>
          <target state="translated">HTTP / 1.1 - стандартизованный протокол</target>
        </trans-unit>
        <trans-unit id="b6ed95efc2e54e41776e64eab2beb02be978d4fe" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 allows a client to request that only part (a range of) the
   response entity be included within the response. HTTP/1.1 uses range
   units in the Range (&lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt;) and Content-Range (&lt;a href=&quot;#section-14.16&quot;&gt;section 14.16&lt;/a&gt;)
   header fields. An entity can be broken down into subranges according
   to various structural units.

      range-unit       = bytes-unit | other-range-unit
      bytes-unit       = &quot;bytes&quot;
      other-range-unit = token

   The only range unit defined by HTTP/1.1 is &quot;bytes&quot;. HTTP/1.1
   implementations MAY ignore ranges specified using other units. 

   HTTP/1.1 has been designed to allow implementations of applications
   that do not depend on knowledge of ranges.</source>
          <target state="translated">HTTP / 1.1 позволяет клиенту запрашивать, чтобы в ответ была включена только часть (диапазон) объекта ответа. HTTP / 1.1 использует единицы диапазона в полях заголовка Range ( &lt;a href=&quot;#section-14.35&quot;&gt;раздел 14.35&lt;/a&gt; ) и Content-Range ( &lt;a href=&quot;#section-14.16&quot;&gt;раздел 14.16&lt;/a&gt; ). Сущность может быть разбита на поддиапазоны согласно различным структурным единицам. диапазон-блок = байтовый-блок | other-range-unit bytes-unit = &quot;bytes&quot; other-range-unit = token Единственная единица диапазона, определяемая HTTP / 1.1, - это &quot;байты&quot;. Реализации HTTP / 1.1 МОГУТ игнорировать диапазоны, указанные с использованием других модулей. HTTP / 1.1 был разработан, чтобы позволить реализации приложений, которые не зависят от знания диапазонов.</target>
        </trans-unit>
        <trans-unit id="8cf11b6afbfe5a73402d4b60de58fb9f5e3c6400" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 and earlier HTTP messages are human-readable. In HTTP/2, these messages are embedded into a new binary structure, a frame, allowing optimizations like compression of headers and multiplexing. Even if only part of the original HTTP message is sent in this version of HTTP, the semantics of each message is unchanged and the client reconstitutes (virtually) the original HTTP/1.1 request. It is therefore useful to comprehend HTTP/2 messages in the HTTP/1.1 format.</source>
          <target state="translated">HTTP/1.1 и более ранние HTTP-сообщения читаются человеком.В HTTP/2 эти сообщения встроены в новую двоичную структуру-фрейм,позволяющий оптимизировать,например,сжатие заголовков и мультиплексирование.Даже если в этой версии HTTP отправляется только часть оригинального сообщения HTTP,семантика каждого сообщения остается неизменной,и клиент воссоздает (фактически)оригинальный запрос HTTP/1.1.Поэтому полезно понимать сообщения HTTP/2 в формате HTTP/1.1.</target>
        </trans-unit>
        <trans-unit id="340b2a6e6c85c293b668779af15231ac0ac5f995" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 clarified ambiguities and introduced numerous improvements:</source>
          <target state="translated">HTTP/1.1 уточнил неясности и внес многочисленные улучшения:</target>
        </trans-unit>
        <trans-unit id="aaede2afb4e2e830b4b4156c5fed71c83597729d" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 defaults to the use of &quot;persistent connections&quot;, allowing
   multiple requests and responses to be carried over a single
   connection.  The &quot;close&quot; connection option is used to signal that a
   connection will not persist after the current request/response.  HTTP
   implementations SHOULD support persistent connections. 

   A recipient determines whether a connection is persistent or not
   based on the most recently received message's protocol version and
   Connection header field (if any):

   o  If the &quot;close&quot; connection option is present, the connection will
      not persist after the current response; else,

   o  If the received protocol is HTTP/1.1 (or later), the connection
      will persist after the current response; else,

   o  If the received protocol is HTTP/1.0, the &quot;keep-alive&quot; connection
      option is present, the recipient is not a proxy, and the recipient
      wishes to honor the HTTP/1.0 &quot;keep-alive&quot; mechanism, the
      connection will persist after the current response; otherwise,

   o  The connection will close after the current response.

   A client MAY send additional requests on a persistent connection
   until it sends or receives a &quot;close&quot; connection option or receives an
   HTTP/1.0 response without a &quot;keep-alive&quot; connection option.

   In order to remain persistent, all messages on a connection need to
   have a self-defined message length (i.e., one not defined by closure
   of the connection), as described in &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;.  A server MUST read
   the entire request message body or close the connection after sending
   its response, since otherwise the remaining data on a persistent
   connection would be misinterpreted as the next request.  Likewise, a
   client MUST read the entire response message body if it intends to
   reuse the same connection for a subsequent request.

   A proxy server MUST NOT maintain a persistent connection with an
   HTTP/1.0 client (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;Section&amp;nbsp;19.7.1 of [RFC2068]&lt;/a&gt; for information and
   discussion of the problems with the Keep-Alive header field
   implemented by many HTTP/1.0 clients).

   See &lt;a href=&quot;#appendix-A.1.2&quot;&gt;Appendix A.1.2&lt;/a&gt; for more information on backwards compatibility
   with HTTP/1.0 clients.</source>
          <target state="translated">HTTP / 1.1 по умолчанию использует &amp;laquo;постоянные соединения&amp;raquo;, что позволяет передавать несколько запросов и ответов по одному соединению. Параметр &amp;laquo;закрыть&amp;raquo; соединение используется для обозначения того, что соединение не будет сохраняться после текущего запроса / ответа. Реализации HTTP ДОЛЖНЫ поддерживать постоянные соединения. Получатель определяет, является ли соединение постоянным или нет, на основе версии протокола самого последнего полученного сообщения и поля заголовка соединения (если есть): o Если присутствует опция &amp;laquo;закрыть&amp;raquo; соединение, соединение не будет сохраняться после текущего ответа; иначе: o Если получен протокол HTTP / 1.1 (или более поздний), соединение будет сохраняться после текущего ответа; иначе, o Если полученный протокол - HTTP / 1.0, &quot;присутствует опция соединения keep-alive &quot;, получатель не является прокси-сервером, и получатель желает соблюдать механизм HTTP / 1.0&quot; keep-alive &quot;, соединение будет сохраняться после текущего ответа; в противном случае соединение будет закрыто после текущий ответ. Клиент МОЖЕТ отправлять дополнительные запросы по постоянному соединению до тех пор, пока он не отправит или не получит параметр &quot;закрыть&quot; соединение или не получит ответ HTTP / 1.0 без параметра соединения &quot;keep-alive&quot;. Чтобы оставаться постоянным, все сообщения в соединении должна иметь самостоятельно определяемую длину сообщения (т. е. длину, не определяемую закрытием соединения), как описано вмеханизм, соединение будет сохраняться после текущего ответа; в противном случае o соединение будет закрыто после текущего ответа. Клиент МОЖЕТ отправлять дополнительные запросы по постоянному соединению до тех пор, пока он не отправит или не получит параметр соединения &amp;laquo;закрыть&amp;raquo; или не получит ответ HTTP / 1.0 без параметра соединения &amp;laquo;поддерживать активность&amp;raquo;. Чтобы оставаться постоянными, все сообщения в соединении должны иметь самостоятельно определяемую длину сообщения (т. Е. Длину, не определяемую закрытием соединения), как описано вмеханизм, соединение будет сохраняться после текущего ответа; в противном случае o соединение будет закрыто после текущего ответа. Клиент МОЖЕТ отправлять дополнительные запросы по постоянному соединению до тех пор, пока он не отправит или не получит параметр соединения &amp;laquo;закрыть&amp;raquo; или не получит ответ HTTP / 1.0 без параметра соединения &amp;laquo;поддерживать активность&amp;raquo;. Чтобы оставаться постоянными, все сообщения в соединении должны иметь самостоятельно определяемую длину сообщения (т. Е. Длину, не определяемую закрытием соединения), как описано в0 без опции подключения &quot;keep-alive&quot;. Чтобы оставаться постоянными, все сообщения в соединении должны иметь самостоятельно определяемую длину сообщения (то есть длину, не определяемую закрытием соединения), как описано в0 без опции подключения &quot;keep-alive&quot;. Чтобы оставаться постоянными, все сообщения в соединении должны иметь самостоятельно определяемую длину сообщения (то есть длину, не определяемую закрытием соединения), как описано в&lt;a href=&quot;#section-3.3&quot;&gt;Раздел 3.3&lt;/a&gt; . Сервер ДОЛЖЕН прочитать весь текст сообщения запроса или закрыть соединение после отправки своего ответа, так как в противном случае оставшиеся данные в постоянном соединении будут ошибочно интерпретированы как следующий запрос. Аналогичным образом, клиент ДОЛЖЕН прочитать весь текст ответного сообщения, если он намеревается повторно использовать то же соединение для последующего запроса. Прокси-сервер НЕ ДОЛЖЕН поддерживать постоянное соединение с клиентом HTTP / 1.0 (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;Раздел 19.7.1 [RFC2068]&lt;/a&gt; для информации и обсуждения проблем с полем заголовка Keep-Alive, реализуемого многими клиентами HTTP / 1.0). См. &lt;a href=&quot;#appendix-A.1.2&quot;&gt;Приложение A.1.2&lt;/a&gt; для получения дополнительной информации об обратной совместимости с клиентами HTTP / 1.0.</target>
        </trans-unit>
        <trans-unit id="b235442975ba302869396fe0ff4cdaebf53c2643" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 introduces the Transfer-Encoding header field
   (&lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;).  Transfer codings need to be decoded prior to
   forwarding an HTTP message over a MIME-compliant protocol.</source>
          <target state="translated">HTTP / 1.1 представляет поле заголовка Transfer-Encoding ( &lt;a href=&quot;#section-3.3.1&quot;&gt;раздел 3.3.1&lt;/a&gt; ). Перед отправкой сообщения HTTP по протоколу, совместимому с MIME, необходимо декодировать кодирование передачи.</target>
        </trans-unit>
        <trans-unit id="b7bc6b9e5b12ebbdf628d83f676eae2e25277f50" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 introduces the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;). Proxies/gateways MUST remove any transfer-coding prior to
   forwarding a message via a MIME-compliant protocol.

   A process for decoding the &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;)
   can be represented in pseudo-code as:

       length := 0
       read chunk-size, chunk-extension (if any) and CRLF
       while (chunk-size &amp;gt; 0) {
          read chunk-data and CRLF
          append chunk-data to entity-body
          length := length + chunk-size
          read chunk-size and CRLF
       }
       read entity-header
       while (entity-header not empty) {
          append entity-header to existing header fields
          read entity-header
       }
       Content-Length := length
       Remove &quot;chunked&quot; from Transfer-Encoding</source>
          <target state="translated">HTTP / 1.1 представляет поле заголовка Transfer-Encoding ( &lt;a href=&quot;#section-14.41&quot;&gt;раздел &lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt; ). Прокси-серверы / шлюзы ДОЛЖНЫ удалить любое кодирование передачи перед пересылкой сообщения по протоколу, совместимому с MIME. Процесс декодирования &quot;фрагментированного&quot; кодирования передачи ( &lt;a href=&quot;#section-3.6&quot;&gt;раздел 3.6.&lt;/a&gt;) может быть представлен в псевдокоде как: length: = 0 читать размер блока, расширение блока (если есть) и CRLF while (размер блока&amp;gt; 0) {читать данные блока и CRLF добавляет данные блока в объект- длина тела: = длина + размер блока читать размер блока и CRLF} читать заголовок объекта, в то время как (заголовок объекта не пустой) {добавить заголовок объекта к существующим полям заголовка читать заголовок объекта} Длина содержимого: = длина Удалить &quot; фрагментировано &quot;из Transfer-Encoding</target>
        </trans-unit>
        <trans-unit id="55f1d0e9c7b192d39b6bf47cece53fe18cddfa5c" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's
   flow control mechanisms to resolve temporary overloads, rather than
   terminating connections with the expectation that clients will retry.
   The latter technique can exacerbate network congestion.</source>
          <target state="translated">HTTP/1.1 серверы SHOULD поддерживают постоянные соединения и используют механизмы управления потоком TCP для разрешения временных перегрузок,а не для прерывания соединений с ожиданием повторных попыток клиентов.Последняя техника может усугубить перегрузку сети.</target>
        </trans-unit>
        <trans-unit id="5bde47938358e96d6b78dd50b25535a7c82c1d43" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses a restricted set of date formats (&lt;a href=&quot;#section-3.3.1&quot;&gt;section 3.3.1&lt;/a&gt;) to
   simplify the process of date comparison. Proxies and gateways from
   other protocols SHOULD ensure that any Date header field present in a
   message conforms to one of the HTTP/1.1 formats and rewrite the date
   if necessary.</source>
          <target state="translated">HTTP / 1.1 использует ограниченный набор форматов даты ( &lt;a href=&quot;#section-3.3.1&quot;&gt;раздел 3.3.1&lt;/a&gt; ), чтобы упростить процесс сравнения дат. Прокси-серверы и шлюзы из других протоколов ДОЛЖНЫ гарантировать, что любое поле заголовка Date, присутствующее в сообщении, соответствует одному из форматов HTTP / 1.1, и при необходимости переписать дату.</target>
        </trans-unit>
        <trans-unit id="f983729fa70af1e90d7ea6dbb4afb3d7c8f79cd6" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses a restricted set of date formats (&lt;a href=&quot;#section-7.1.1.1&quot;&gt;Section 7.1.1.1&lt;/a&gt;) to
   simplify the process of date comparison.  Proxies and gateways from
   other protocols ought to ensure that any Date header field present in
   a message conforms to one of the HTTP/1.1 formats and rewrite the
   date if necessary.</source>
          <target state="translated">HTTP / 1.1 использует ограниченный набор форматов даты ( &lt;a href=&quot;#section-7.1.1.1&quot;&gt;раздел 7.1.1.1&lt;/a&gt; ), чтобы упростить процесс сравнения дат. Прокси-серверы и шлюзы из других протоколов должны гарантировать, что любое поле заголовка Date, присутствующее в сообщении, соответствует одному из форматов HTTP / 1.1, и при необходимости перезаписывать дату.</target>
        </trans-unit>
        <trans-unit id="87f9910f16689f67ad3946ec5476c5e20370823d" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses many of the constructs defined for Internet Mail (&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]) and the Multipurpose Internet Mail Extensions (MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]) to
   allow entities to be transmitted in an open variety of
   representations and with extensible mechanisms. However, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;
   discusses mail, and HTTP has a few features that are different from
   those described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;. These differences were carefully chosen
   to optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.

   This appendix describes specific areas where HTTP differs from &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;. Proxies and gateways to strict MIME environments SHOULD be
   aware of these differences and provide the appropriate conversions
   where necessary. Proxies and gateways from MIME environments to HTTP
   also need to be aware of the differences because some conversions
   might be required.</source>
          <target state="translated">HTTP / 1.1 использует многие конструкции, определенные для Интернет-почты ( &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]) и многоцелевых расширений Интернет-почты (MIME [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]), чтобы позволить объектам передаваться в различных открытых представлениях и с расширяемыми механизмами. Однако в &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; обсуждается почта, а HTTP имеет несколько функций, которые отличаются от описанных в &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; . Эти различия были тщательно выбраны для оптимизации производительности по бинарным соединениям, чтобы предоставить большую свободу в использовании новых типов носителей, упростить сравнение дат и признать практику некоторых ранних HTTP-серверов и клиентов. В этом приложении описаны конкретные области, в которых HTTP отличается от&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt; . Прокси-серверы и шлюзы к средам со строгим MIME ДОЛЖНЫ быть в курсе этих различий и обеспечивать соответствующие преобразования там, где это необходимо. Прокси-серверы и шлюзы из сред MIME в HTTP также должны знать о различиях, потому что могут потребоваться некоторые преобразования.</target>
        </trans-unit>
        <trans-unit id="7ba038961de66fab4bc0d4ca5f738bb4971581c5" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses many of the constructs defined for the Internet Message
   Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;] and the Multipurpose Internet Mail Extensions (MIME)
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;] to allow a message body to be transmitted in an open
   variety of representations and with extensible header fields.
   However, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; is focused only on email; applications of HTTP have
   many characteristics that differ from email; hence, HTTP has features
   that differ from MIME.  These differences were carefully chosen to
   optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.

   This appendix describes specific areas where HTTP differs from MIME.
   Proxies and gateways to and from strict MIME environments need to be
   aware of these differences and provide the appropriate conversions
   where necessary.</source>
          <target state="translated">HTTP / 1.1 использует многие конструкции, определенные для формата Интернет-сообщений [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ] и многоцелевых расширений Интернет-почты (MIME) [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ], что позволяет передавать тело сообщения в различных открытых представлениях и с расширяемыми полями заголовка. Однако &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;ориентирован только на электронную почту; приложения HTTP имеют много характеристик, которые отличаются от электронной почты; следовательно, HTTP имеет функции, которые отличаются от MIME. Эти различия были тщательно выбраны для оптимизации производительности по бинарным соединениям, чтобы предоставить большую свободу в использовании новых типов носителей, упростить сравнение дат и признать практику некоторых ранних HTTP-серверов и клиентов. В этом приложении описаны конкретные области, в которых HTTP отличается от MIME. Прокси-серверы и шлюзы в строгие среды MIME и обратно должны знать об этих различиях и при необходимости обеспечивать соответствующие преобразования.</target>
        </trans-unit>
        <trans-unit id="26857a3eb014d1c446a022b99900a2e1fa1f388e" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was first published as &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; in January 1997.</source>
          <target state="translated">HTTP / 1.1 был впервые опубликован как &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; в январе 1997 года.</target>
        </trans-unit>
        <trans-unit id="d5072f3723c431d48c51e0f349be99684fbc90ba" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was the first version of HTTP to support persistent connection and pipelining. This article explains both concepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd63c4dcb6457bcb6fd3cf072cc949e847bb34c1" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was the first version of HTTP to support persistent connection and pipelining. This article explains these two concepts.</source>
          <target state="translated">HTTP/1.1 был первой версией HTTP для поддержки постоянных соединений и трубопроводов.В этой статье объясняются эти два понятия.</target>
        </trans-unit>
        <trans-unit id="1503342ea4d0a3a7deec2528731a5bc064211705" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Authentication</source>
          <target state="translated">HTTP/1.1:Аутентификация</target>
        </trans-unit>
        <trans-unit id="0c4a2c0ccd4801b8e3ca9529c7a252503dccdf00" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Semantics and Content</source>
          <target state="translated">HTTP/1.1:Семантика и содержание</target>
        </trans-unit>
        <trans-unit id="c0b298b6e63b8ce602677a51d4f1e6436079232f" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Status Code Definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21663f5aa54f6135626b598bc6ce1bf03ec7513b" translate="yes" xml:space="preserve">
          <source>HTTP/1.x messages have a few drawbacks for performance:</source>
          <target state="translated">Сообщения HTTP/1.x имеют несколько недостатков для производительности:</target>
        </trans-unit>
        <trans-unit id="682ec4f8ae7cf90f4fab0685ba322176bdd4f593" translate="yes" xml:space="preserve">
          <source>HTTP/2 &amp;ndash; A protocol for greater performance</source>
          <target state="translated">HTTP / 2 - протокол для большей производительности</target>
        </trans-unit>
        <trans-unit id="a9820b1d6f7a1eb33859fc438f4a30a55193154b" translate="yes" xml:space="preserve">
          <source>HTTP/2 Frames</source>
          <target state="translated">HTTP/2 фреймы</target>
        </trans-unit>
        <trans-unit id="b9a1cc9ca8b3b857841ac45f6cab101cd76b0608" translate="yes" xml:space="preserve">
          <source>HTTP/2 adds additional models for connection management.</source>
          <target state="translated">HTTP/2 добавляет дополнительные модели для управления соединениями.</target>
        </trans-unit>
        <trans-unit id="de5c597058c2601a65efadc88f948c586a1ffe49" translate="yes" xml:space="preserve">
          <source>HTTP/2 completely revisited how connections are created and maintained. This article explains how HTTP frames allow multiplexing and solve the 'head-of-line' blocking problem of former HTTP versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d84f8ae615e7ecf29c3c866e9ab8e4f31fe842" translate="yes" xml:space="preserve">
          <source>HTTP/2 completely revisited how connections are created and maintained: this article explains how HTTP frames allow multiplexing and solve the 'head-of-line' blocking problem of former HTTP versions.</source>
          <target state="translated">HTTP/2 полностью пересмотрел то,как создаются и поддерживаются соединения:эта статья объясняет,как HTTP фреймы позволяют мультиплексировать и решают проблему блокировки &quot;заголовков&quot; бывших версий HTTP.</target>
        </trans-unit>
        <trans-unit id="7f0a10f9ce0b6e8be8176a0d0cf459883c237676" translate="yes" xml:space="preserve">
          <source>HTTP/2 encapsulates and represents HTTP/1.x messages in a binary frame. This article explains the frame structure, its purpose and the way it is encoded.</source>
          <target state="translated">HTTP/2 инкапсулирует и представляет сообщения HTTP/1.x в двоичном фрейме.Эта статья объясняет структуру фрейма,его назначение и способ кодирования.</target>
        </trans-unit>
        <trans-unit id="8b89d94c6825e208193b0c3215145db1ad533fe7" translate="yes" xml:space="preserve">
          <source>HTTP/2 encapsulates and represents HTTP/1.x messages in a binary frame. This article explains the frame structure, its purpose, and the way it's encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6c2df4a46eb441a1cda15f98cf3c5243cca600" translate="yes" xml:space="preserve">
          <source>HTTP/2 introduces an extra step: it divides HTTP/1.x messages into frames which are embedded in a stream. Data and header frames are separated, this allows header compression. Several streams can be combined together, a process called &lt;em&gt;multiplexing&lt;/em&gt;, allowing more efficient underlying TCP connections.</source>
          <target state="translated">HTTP / 2 вводит дополнительный шаг: он разделяет сообщения HTTP / 1.x на фреймы, которые встраиваются в поток. Кадры данных и заголовки разделены, это позволяет сжать заголовок. Несколько потоков можно объединить вместе, этот процесс называется &lt;em&gt;мультиплексированием&lt;/em&gt; , что позволяет более эффективно использовать базовые TCP-соединения.</target>
        </trans-unit>
        <trans-unit id="a496c90d2f1f8118ed8e04e7a7acf8027e245b96" translate="yes" xml:space="preserve">
          <source>HTTP/3 - HTTP over QUIC</source>
          <target state="translated">HTTP/3-HTTP over QUIC</target>
        </trans-unit>
        <trans-unit id="2e6205295940162ec6f356951c335bcb251f4584" translate="yes" xml:space="preserve">
          <source>HTTPS &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Хост&lt;/em&gt; HTTPS &lt;em&gt;: порт&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b1b03288626a4932189c45619afd52b616640ff" translate="yes" xml:space="preserve">
          <source>Handling CORS on the server (Java example)</source>
          <target state="translated">Обработка CORS на сервере (пример Java)</target>
        </trans-unit>
        <trans-unit id="76ccff916d0696e0db6e0e63211aa5d404b177bb" translate="yes" xml:space="preserve">
          <source>Handshake</source>
          <target state="translated">Handshake</target>
        </trans-unit>
        <trans-unit id="ef63c9de46b2633531f80d09b249c8177fb13159" translate="yes" xml:space="preserve">
          <source>Header field name:  SLUG

   Applicable protocol:  http [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]

   Status:  standard.

   Author/Change controller:  IETF (iesg@ietf.org) Internet Engineering
      Task Force

   Specification document(s):  &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;.

   Related information:  None.</source>
          <target state="translated">Имя поля заголовка: SLUG Применимый протокол: http [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] Статус: стандартный. Автор / ответственный за изменения: IETF (iesg@ietf.org) Документ (ы) Спецификации Инженерной группы Интернета: &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt; . Связанная информация: Нет.</target>
        </trans-unit>
        <trans-unit id="16c88366423875ffcd832b0568164659af366f76" translate="yes" xml:space="preserve">
          <source>Header field name: DAV

   Applicable protocol: http

   Status: standard 

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;)</source>
          <target state="translated">Имя поля заголовка: DAV Применимый протокол: http Статус: стандартный Автор / Контроллер изменений: Документ спецификации IETF: эта спецификация ( &lt;a href=&quot;#section-10.1&quot;&gt;раздел 10.1&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="0a425ee275ccc8dc88e573145d9bc8f251db402b" translate="yes" xml:space="preserve">
          <source>Header field name: Depth

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.2&quot;&gt;Section 10.2&lt;/a&gt;)</source>
          <target state="translated">Имя поля заголовка: Глубина Применимый протокол: http Статус: стандартный Автор / Контроллер изменений: Документ спецификации IETF: эта спецификация ( &lt;a href=&quot;#section-10.2&quot;&gt;раздел 10.2&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="0b05ddbc40717bf61ebce12546f2a61a4a13a71f" translate="yes" xml:space="preserve">
          <source>Header field name: Destination

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.3&quot;&gt;Section 10.3&lt;/a&gt;)</source>
          <target state="translated">Имя поля заголовка: Назначение Применимый протокол: http Статус: стандартный Автор / Контроллер изменений: Документ спецификации IETF: эта спецификация ( &lt;a href=&quot;#section-10.3&quot;&gt;раздел 10.3&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="80f31a912be49327cab8cfb0f3ab988e1efad182" translate="yes" xml:space="preserve">
          <source>Header field name: If

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.4&quot;&gt;Section 10.4&lt;/a&gt;)</source>
          <target state="translated">Имя поля заголовка: Если Применимый протокол: http Статус: стандартный Автор / Контроллер изменений: Документ спецификации IETF: эта спецификация ( &lt;a href=&quot;#section-10.4&quot;&gt;раздел 10.4&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="405cc2ed9285599fe7b4ed659f2f3efef397c235" translate="yes" xml:space="preserve">
          <source>Header field name: Lock-Token

   Applicable protocol: http

   Status: standard 

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.5&quot;&gt;Section 10.5&lt;/a&gt;)</source>
          <target state="translated">Имя поля заголовка: Lock-Token Применимый протокол: http Статус: стандартный Автор / Контроллер изменений: Документ спецификации IETF: эта спецификация ( &lt;a href=&quot;#section-10.5&quot;&gt;раздел 10.5&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="0ef45169928c0bea57455212198061a9ab1aac96" translate="yes" xml:space="preserve">
          <source>Header field name: Overwrite

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.6&quot;&gt;Section 10.6&lt;/a&gt;)</source>
          <target state="translated">Имя поля заголовка: Перезаписать Применимый протокол: http Статус: стандартный Автор / Контроллер изменений: Документ спецификации IETF: эта спецификация ( &lt;a href=&quot;#section-10.6&quot;&gt;раздел 10.6&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="ebc42438bb349fc70f9ce54ef8a83a2205114a92" translate="yes" xml:space="preserve">
          <source>Header field name: Timeout

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;)</source>
          <target state="translated">Имя поля заголовка: Тайм-аут Применимый протокол: http Статус: стандартный Автор / Контроллер изменений: Документ спецификации IETF: эта спецификация ( &lt;a href=&quot;#section-10.7&quot;&gt;раздел 10.7&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="4ab8eed7600b67916da46088b86ba4f2a325716b" translate="yes" xml:space="preserve">
          <source>Header fields are fully extensible: there is no limit on the
   introduction of new field names, each presumably defining new
   semantics, nor on the number of header fields used in a given
   message.  Existing fields are defined in each part of this
   specification and in many other specifications outside this document
   set.

   New header fields can be defined such that, when they are understood
   by a recipient, they might override or enhance the interpretation of
   previously defined header fields, define preconditions on request
   evaluation, or refine the meaning of responses.

   A proxy MUST forward unrecognized header fields unless the field-name
   is listed in the Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) or the proxy
   is specifically configured to block, or otherwise transform, such
   fields.  Other recipients SHOULD ignore unrecognized header fields.
   These requirements allow HTTP's functionality to be enhanced without
   requiring prior update of deployed intermediaries.

   All defined header fields ought to be registered with IANA in the
   &quot;Message Headers&quot; registry, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.3&quot;&gt;Section&amp;nbsp;8.3 of [RFC7231]&lt;/a&gt;.</source>
          <target state="translated">Поля заголовка полностью расширяемы: нет ограничений на введение новых имен полей, каждое из которых предположительно определяет новую семантику, или на количество полей заголовков, используемых в данном сообщении. Существующие поля определены в каждой части этой спецификации и во многих других спецификациях за пределами этого набора документов. Новые поля заголовка могут быть определены таким образом, что, когда они будут понятны получателю, они могут переопределить или улучшить интерпретацию ранее определенных полей заголовка, определить предварительные условия при оценке запроса или уточнить смысл ответов. Прокси-сервер ДОЛЖЕН пересылать нераспознанные поля заголовка, если имя поля не указано в поле заголовка соединения ( &lt;a href=&quot;#section-6.1&quot;&gt;раздел 6.1.&lt;/a&gt;) или прокси-сервер специально настроен для блокировки или иного преобразования таких полей. Другим получателям СЛЕДУЕТ игнорировать нераспознанные поля заголовка. Эти требования позволяют расширять функциональность HTTP без предварительного обновления развернутых посредников. Все определенные поля заголовков должны быть зарегистрированы IANA в реестре &amp;laquo;Заголовки сообщений&amp;raquo;, как описано в &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.3&quot;&gt;разделе 8.3 [RFC7231]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a40e00de254d23c5e44ccdfe307162d5d4ecbef3" translate="yes" xml:space="preserve">
          <source>Header fields are key:value pairs that can be used to communicate
   data about the message, its payload, the target resource, or the
   connection (i.e., control data).  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt; for a
   general definition of header field syntax in HTTP messages.

   The requirements for header field names are defined in [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;].

   Authors of specifications defining new fields are advised to keep the
   name as short as practical and not to prefix the name with &quot;X-&quot;
   unless the header field will never be used on the Internet.  (The
   &quot;X-&quot; prefix idiom has been extensively misused in practice; it was
   intended to only be used as a mechanism for avoiding name collisions
   inside proprietary software or intranet processing, since the prefix
   would ensure that private names never collide with a newly registered
   Internet name; see [&lt;a href=&quot;#ref-BCP178&quot;&gt;BCP178&lt;/a&gt;] for further information).

   New header field values typically have their syntax defined using
   ABNF ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;]), using the extension defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt; as necessary, and are usually constrained to the range of
   US-ASCII characters.  Header fields needing a greater range of
   characters can use an encoding such as the one defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC5987&lt;/a&gt;].

   Leading and trailing whitespace in raw field values is removed upon
   field parsing (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.4&quot;&gt;Section&amp;nbsp;3.2.4 of [RFC7230]&lt;/a&gt;).  Field definitions where
   leading or trailing whitespace in values is significant will have to
   use a container syntax such as quoted-string (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;Section&amp;nbsp;3.2.6 of
   [RFC7230]&lt;/a&gt;).

   Because commas (&quot;,&quot;) are used as a generic delimiter between
   field-values, they need to be treated with care if they are allowed
   in the field-value.  Typically, components that might contain a comma
   are protected with double-quotes using the quoted-string ABNF
   production.

   For example, a textual date and a URI (either of which might contain
   a comma) could be safely carried in field-values like these:

     Example-URI-Field: &quot;http://example.com/a.html,foo&quot;,
                        &quot;http://without-a-comma.example.com/&quot;
     Example-Date-Field: &quot;Sat, 04 May 1996&quot;, &quot;Wed, 14 Sep 2005&quot;

   Note that double-quote delimiters almost always are used with the
   quoted-string production; using a different syntax inside
   double-quotes will likely cause unnecessary confusion. 

   Many header fields use a format including (case-insensitively) named
   parameters (for instance, Content-Type, defined in &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt;).
   Allowing both unquoted (token) and quoted (quoted-string) syntax for
   the parameter value enables recipients to use existing parser
   components.  When allowing both forms, the meaning of a parameter
   value ought to be independent of the syntax used for it (for an
   example, see the notes on parameter handling for media types in
   &lt;a href=&quot;#section-3.1.1.1&quot;&gt;Section 3.1.1.1&lt;/a&gt;).

   Authors of specifications defining new header fields are advised to
   consider documenting:

   o  Whether the field is a single value or whether it can be a list
      (delimited by commas; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;).

      If it does not use the list syntax, document how to treat messages
      where the field occurs multiple times (a sensible default would be
      to ignore the field, but this might not always be the right
      choice).

      Note that intermediaries and software libraries might combine
      multiple header field instances into a single one, despite the
      field's definition not allowing the list syntax.  A robust format
      enables recipients to discover these situations (good example:
      &quot;Content-Type&quot;, as the comma can only appear inside quoted
      strings; bad example: &quot;Location&quot;, as a comma can occur inside a
      URI).

   o  Under what conditions the header field can be used; e.g., only in
      responses or requests, in all messages, only on responses to a
      particular request method, etc.

   o  Whether the field should be stored by origin servers that
      understand it upon a PUT request.

   o  Whether the field semantics are further refined by the context,
      such as by existing request methods or status codes.

   o  Whether it is appropriate to list the field-name in the Connection
      header field (i.e., if the header field is to be hop-by-hop; see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC7230]&lt;/a&gt;).

   o  Under what conditions intermediaries are allowed to insert,
      delete, or modify the field's value. 

   o  Whether it is appropriate to list the field-name in a Vary
      response header field (e.g., when the request header field is used
      by an origin server's content selection algorithm; see
      &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;).

   o  Whether the header field is useful or allowable in trailers (see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7230]&lt;/a&gt;).

   o  Whether the header field ought to be preserved across redirects.

   o  Whether it introduces any additional security considerations, such
      as disclosure of privacy-related data.</source>
          <target state="translated">Поля заголовка - это пары ключ: значение, которые могут использоваться для передачи данных о сообщении, его полезной нагрузке, целевом ресурсе или соединении (т. Е. Управляющих данных). См. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Раздел 3.2 [RFC7230]&lt;/a&gt; для общего определения синтаксиса поля заголовка в сообщениях HTTP. Требования к именам полей заголовка определены в [ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]. Авторам спецификаций, определяющих новые поля, рекомендуется сохранять имя как можно более коротким и не ставить перед именем префикс &amp;laquo;X-&amp;raquo;, если только поле заголовка никогда не будет использоваться в Интернете. (Идиома префикса &amp;laquo;X-&amp;raquo; широко использовалась на практике; она была предназначена для использования только в качестве механизма для предотвращения конфликтов имен внутри проприетарного программного обеспечения или обработки в интрасети, поскольку префикс гарантировал, что частные имена никогда не будут конфликтовать с недавно зарегистрированными Интернет-имя; дополнительную информацию см. [ &lt;a href=&quot;#ref-BCP178&quot;&gt;BCP178&lt;/a&gt; ]). Синтаксис новых значений полей заголовка обычно определяется с помощью ABNF ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ]) с использованием расширения, определенного в &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;разделе 7 [RFC7230].&lt;/a&gt;по мере необходимости и обычно ограничиваются диапазоном символов US-ASCII. Поля заголовка, для которых требуется больший диапазон символов, могут использовать кодировку, такую ​​как определенная в [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC5987&lt;/a&gt; ]. Начальные и конечные пробелы в необработанных значениях поля удаляются при синтаксическом анализе поля ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.4&quot;&gt;раздел 3.2.4 [RFC7230]&lt;/a&gt; ). В определениях полей, в которых &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;важны начальные&lt;/a&gt; или конечные пробелы в значениях, необходимо использовать синтаксис контейнера, например строку в кавычках ( раздел 3.2.6 [RFC7230])). Поскольку запятые (&quot;,&quot;) используются в качестве общего разделителя между значениями поля, с ними нужно обращаться осторожно, если они разрешены в значении поля. Как правило, компоненты, которые могут содержать запятую, защищаются двойными кавычками с использованием строки в кавычках ABNF. Например, текстовая дата и URI (любой из которых может содержать запятую) могут безопасно переноситься в таких значениях полей: Example-URI-Field: &quot;http://example.com/a.html,foo&quot; , &quot;http://without-a-comma.example.com/&quot; Example-Date-Field: &quot;Sat, 04 May 1996&quot;, &quot;Wed, 14 Sep 2005&quot; Обратите внимание, что разделители двойных кавычек почти всегда используются с производство кавычек; использование другого синтаксиса в двойных кавычках может вызвать ненужную путаницу.Многие поля заголовка используют формат, включающий (без учета регистра) именованные параметры (например, Content-Type, определенный в&lt;a href=&quot;#section-3.1.1.5&quot;&gt;Раздел 3.1.1.5&lt;/a&gt; ). Разрешение синтаксиса в кавычках (токен) и в кавычках (строка в кавычках) для значения параметра позволяет получателям использовать существующие компоненты анализатора. Если разрешены обе формы, значение значения параметра не должно зависеть от синтаксиса, используемого для него (например, см. Примечания по обработке параметров для типов мультимедиа в &lt;a href=&quot;#section-3.1.1.1&quot;&gt;разделе 3.1.1.1&lt;/a&gt; ). Авторам спецификаций, определяющих новые поля заголовка, рекомендуется рассмотреть возможность документирования: o Является ли поле одним значением или может быть списком (разделенным запятыми; см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Раздел 3.2 [RFC7230]&lt;/a&gt;). Если он не использует синтаксис списка, задокументируйте, как обрабатывать сообщения, в которых поле встречается несколько раз (разумным по умолчанию было бы игнорировать поле, но это не всегда может быть правильным выбором). Обратите внимание, что посредники и программные библиотеки могут объединять несколько экземпляров поля заголовка в один, несмотря на то, что определение поля не разрешает синтаксис списка. Надежный формат позволяет получателям обнаруживать такие ситуации (хороший пример: &amp;laquo;Content-Type&amp;raquo;, поскольку запятая может появляться только внутри строк в кавычках; плохой пример: &amp;laquo;Location&amp;raquo;, поскольку запятая может встречаться внутри URI). o При каких условиях можно использовать поле заголовка; например, только в ответах или запросах, во всех сообщениях, только в ответах на определенный метод запроса и т. д.o Должно ли поле храниться исходными серверами, которые понимают его при запросе PUT. o уточняется ли семантика поля в дальнейшем контекстом, например, существующими методами запроса или кодами состояния. o Уместно ли указывать имя поля в поле заголовка соединения (т. е., если поле заголовка должно быть поэтапным; см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Раздел 6.1 [RFC7230]&lt;/a&gt; ). o При каких условиях посредникам разрешено вставлять, удалять или изменять значение поля. o Уместно ли указывать имя поля в поле заголовка ответа Vary (например, когда поле заголовка запроса используется алгоритмом выбора содержимого исходного сервера; см. &lt;a href=&quot;#section-7.1.4&quot;&gt;раздел 7.1.4&lt;/a&gt; ). o Является ли поле заголовка полезным или допустимым в трейлерах (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;раздел 4.1 [RFC7230]&lt;/a&gt; ). o Следует ли сохранять поле заголовка при переадресации. o вводит ли он какие-либо дополнительные соображения безопасности, такие как раскрытие данных, связанных с конфиденциальностью.</target>
        </trans-unit>
        <trans-unit id="73ce89b0c8df0a7ed4d98060b2c7c611ac330135" translate="yes" xml:space="preserve">
          <source>Header fields that regulate the use of trailers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; (requests) and &lt;a href=&quot;trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt; (responses).</source>
          <target state="translated">Поля заголовка, регулирующие использование трейлеров: &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; (запросы) и &lt;a href=&quot;trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt; (ответы).</target>
        </trans-unit>
        <trans-unit id="bf858dd7754f89623471d452d85365f43194c795" translate="yes" xml:space="preserve">
          <source>Header type</source>
          <target state="translated">Тип заголовка</target>
        </trans-unit>
        <trans-unit id="2e31dbd5f484d5c1a3e787a044871e878213d50e" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Заголовок с результатом согласования содержимого: &lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e46dedc85812b44c40eda61d963afafe6e17ec8" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Заголовок с результатом согласования содержимого: &lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="04db11046ac45baaf2858c147c0d0da0d83dfe2b" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Заголовок с результатом согласования содержимого: &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="d43cdd47172ebbec83d46dc0929904cbc0e5ba83" translate="yes" xml:space="preserve">
          <source>Headers are often very similar from one message to the next one, yet still repeated across connections.</source>
          <target state="translated">Заголовки часто очень похожи от одного сообщения к другому,но все равно повторяются через соединения.</target>
        </trans-unit>
        <trans-unit id="b9f5a636b75216c81304804a9a45004630234515" translate="yes" xml:space="preserve">
          <source>Headers can also be grouped according to how &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxies&lt;/a&gt; handle them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953e087d7da0e93f2114e33931a9fff08ea7dde9" translate="yes" xml:space="preserve">
          <source>Headers can also be grouped according to how proxies handle them:</source>
          <target state="translated">Заголовки также могут быть сгруппированы в соответствии с тем,как с ними работают прокси-серверы:</target>
        </trans-unit>
        <trans-unit id="7e731d99aaf73e73a84db12018da22acb10f8eaf" translate="yes" xml:space="preserve">
          <source>Headers can be grouped according to their contexts:</source>
          <target state="translated">Заголовки могут быть сгруппированы в соответствии с их контекстом:</target>
        </trans-unit>
        <trans-unit id="62484b23e54725c71a2263f18277c31549662db4" translate="yes" xml:space="preserve">
          <source>Headers, unlike bodies, are uncompressed.</source>
          <target state="translated">Заголовки,в отличие от тел,несжаты.</target>
        </trans-unit>
        <trans-unit id="5da9db7ae87281e3e1ab3c768b9be45ae8134d50" translate="yes" xml:space="preserve">
          <source>Helpful tools and resources for understanding and debugging HTTP.</source>
          <target state="translated">Полезные инструменты и ресурсы для понимания и отладки HTTP.</target>
        </trans-unit>
        <trans-unit id="2ed70bbb1a3a5c498b113f52c1548cee8ea9cc2d" translate="yes" xml:space="preserve">
          <source>Here again, be sure to take the right token for the browser you are looking for, as there is no guarantee that others will contain a valid number.</source>
          <target state="translated">Здесь опять же,не забудьте взять правильный токен для браузера,который Вы ищете,так как нет никакой гарантии,что другие будут содержать действительный номер.</target>
        </trans-unit>
        <trans-unit id="d5227ab359118de929fda02e4ed8472790aeba2d" translate="yes" xml:space="preserve">
          <source>Here is a JavaScript regular expression that will detect all mobile devices, including devices with a device id in their UA string:</source>
          <target state="translated">Вот JavaScript регулярное выражение,которое будет обнаруживать все мобильные устройства,включая устройства с идентификатором устройства в строке UA:</target>
        </trans-unit>
        <trans-unit id="4e3866c880875ee1ff8235362e89c76b5139a9ee" translate="yes" xml:space="preserve">
          <source>Here is a list of MIME types, associated by type of documents, ordered by their common extensions.</source>
          <target state="translated">Вот список MIME-типов,связанных по типам документов,упорядоченных по их общим расширениям.</target>
        </trans-unit>
        <trans-unit id="d20b00cd2016c9a232dbd3f29c2f2897e9fcffac" translate="yes" xml:space="preserve">
          <source>Here is a list of common features controllable with HTTP.</source>
          <target state="translated">Вот список общих функций,управляемых с помощью HTTP.</target>
        </trans-unit>
        <trans-unit id="5c9905f596ccef64e1269e49689d1a73c07dd5b6" translate="yes" xml:space="preserve">
          <source>Here is a sample exchange between client and server:</source>
          <target state="translated">Вот пример обмена между клиентом и сервером:</target>
        </trans-unit>
        <trans-unit id="9501e397bcbf8b4862fe537468cb6a0753bdae2b" translate="yes" xml:space="preserve">
          <source>Here is an example in PHP of handling a &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;preflighted request&lt;/a&gt;:</source>
          <target state="translated">Вот пример обработки предварительного &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;запроса&lt;/a&gt; на PHP :</target>
        </trans-unit>
        <trans-unit id="75207f8e8ffefa8d462dd3fb2a1a65ea217d704b" translate="yes" xml:space="preserve">
          <source>Here is an example of the Slug header that uses percent-encoding to
   represent the Unicode character U+00E8 (LATIN SMALL LETTER E WITH
   GRAVE):

       POST /myblog/entries HTTP/1.1
       Host: example.org
       Content-Type: image/png
       Slug: The Beach at S%C3%A8te
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   See &lt;a href=&quot;#section-9.2.1&quot;&gt;Section 9.2.1&lt;/a&gt; for an example of the Slug header applied to the
   creation of an Entry Resource.</source>
          <target state="translated">Вот пример заголовка Slug, который использует процентное кодирование для представления символа Юникода U + 00E8 (СТРОЧНАЯ ЛАТИНСКАЯ БУКВА E С ТЯЖЕЛЫМ): POST / myblog / entries HTTP / 1.1 Host: example.org Content-Type: image / png Слаг: Пляж в S% C3% A8te Авторизация: Базовая ZGFmZnk6c2VjZXJldA == Content-Length: nnn ... двоичные данные См. В &lt;a href=&quot;#section-9.2.1&quot;&gt;Разделе 9.2.1&lt;/a&gt; пример заголовка Slug, применяемого для создания ресурса входа.</target>
        </trans-unit>
        <trans-unit id="2797fafb9211cc2c051dcda055704a3e4e30b8b0" translate="yes" xml:space="preserve">
          <source>Here is an example of this process with a shared cache proxy:</source>
          <target state="translated">Вот пример этого процесса с прокси-сервером общего кэша:</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef5dd834bb2835bdbfb70e682c19ccc9767516af" translate="yes" xml:space="preserve">
          <source>Here is some PHP that handles credentialed requests:</source>
          <target state="translated">Вот некоторые PHP,которые работают с авторизованными запросами:</target>
        </trans-unit>
        <trans-unit id="8ef8c73e17b07ff09f65fb9ccc55b532e81935c5" translate="yes" xml:space="preserve">
          <source>Here we look at the most common use cases for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21888f07518ae7a0759573f20d4642440f36a52" translate="yes" xml:space="preserve">
          <source>Here we look at the most common use cases for the &lt;code&gt;Upgrade&lt;/code&gt; header.</source>
          <target state="translated">Здесь мы рассмотрим наиболее распространенные варианты использования заголовка &lt;code&gt;Upgrade&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ab6627dc7da6cad243b3faca054a977b46dce0f" translate="yes" xml:space="preserve">
          <source>Here's an example of what an &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header might look like. It indicates that a custom header named &lt;code&gt;X-Custom-Header&lt;/code&gt; is supported by CORS requests to the server (in addition to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header&quot;&gt;CORS-safelisted request headers&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f377abe687f3f604805ed4c41cf044b1a5eecca7" translate="yes" xml:space="preserve">
          <source>Here's an example of what an &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header might look like. It indicates that in addition to the &quot;simple&quot; headers, a custom header named &lt;code&gt;X-Custom-Header&lt;/code&gt; is supported by CORS requests to the server.</source>
          <target state="translated">Вот пример того, как может выглядеть заголовок &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; . Он указывает на то, что в дополнение к &amp;laquo;простым&amp;raquo; заголовкам, запросами CORS к серверу поддерживается настраиваемый заголовок с именем &lt;code&gt;X-Custom-Header&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29ece426131fe65594c0f74862a88481dffe1b6d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is the authentication scheme (&quot;Basic&quot; is the most common scheme and &lt;a href=&quot;authentication#Basic_authentication_scheme&quot;&gt;introduced below&lt;/a&gt;). The &lt;em&gt;realm&lt;/em&gt; is used to describe the protected area or to indicate the scope of protection. This could be a message like &quot;Access to the staging site&quot; or similar, so that the user knows to which space they are trying to get access to.</source>
          <target state="translated">Здесь &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; - это схема аутентификации (&amp;laquo;Базовая&amp;raquo; - наиболее распространенная схема, &lt;a href=&quot;authentication#Basic_authentication_scheme&quot;&gt;представленная ниже&lt;/a&gt; ). &lt;em&gt;Область&lt;/em&gt; используется для описания охраняемого района или указать сферу защиты. Это может быть сообщение типа &amp;laquo;Доступ к промежуточному сайту&amp;raquo; или подобное, чтобы пользователь знал, к какому пространству он пытается получить доступ.</target>
        </trans-unit>
        <trans-unit id="eb29f0c2d2f88776ddd04a11566426842fc746ff" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;base64EncodedSettings&lt;/code&gt; is an HTTP/2 &lt;code&gt;&quot;SETTINGS&quot;&lt;/code&gt; frame's payload which has been base64url encoded and all trailing &lt;code&gt;&quot;=&quot;&lt;/code&gt; (equals) characters removed in order to safely include it in this textual header format.</source>
          <target state="translated">Здесь &lt;code&gt;base64EncodedSettings&lt;/code&gt; - это полезная нагрузка кадра &lt;code&gt;&quot;SETTINGS&quot;&lt;/code&gt; HTTP / 2 , который был закодирован base64url, и все завершающие символы &lt;code&gt;&quot;=&quot;&lt;/code&gt; (равно) удалены, чтобы безопасно включить его в этот текстовый формат заголовка.</target>
        </trans-unit>
        <trans-unit id="a17f358e1ad5338444563c68bbadc2878e955302" translate="yes" xml:space="preserve">
          <source>Here, &lt;em&gt;x.y&lt;/em&gt; is the version of Mac OS X (for instance, Mac OS X 10.6).</source>
          <target state="translated">Здесь &lt;em&gt;xy&lt;/em&gt; - это версия Mac OS X (например, Mac OS X 10.6).</target>
        </trans-unit>
        <trans-unit id="ef77ad6909e7752d9aa6373842d49849209611c6" translate="yes" xml:space="preserve">
          <source>Here, by default, content is only permitted from the document's origin, with the following exceptions:</source>
          <target state="translated">Здесь,по умолчанию,содержимое разрешается только из источника документа,за следующими исключениями:</target>
        </trans-unit>
        <trans-unit id="fa2977eeb67774d5a0dd09ff4ec5ec0a36ef8155" translate="yes" xml:space="preserve">
          <source>Here, we present three scenarios that illustrate how Cross-Origin Resource Sharing works. All of these examples use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; object, which can be used to make cross-site invocations in any supporting browser.</source>
          <target state="translated">Здесь мы представляем три сценария, которые иллюстрируют, как работает совместное использование ресурсов между источниками. Во всех этих примерах используется объект &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; , который можно использовать для межсайтовых вызовов в любом поддерживающем браузере.</target>
        </trans-unit>
        <trans-unit id="b282bf1d7028f07f3c3e1a14dbfcb71697111c5d" translate="yes" xml:space="preserve">
          <source>Heroku's proxy library Vegur</source>
          <target state="translated">прокси-библиотека Героку Вегур</target>
        </trans-unit>
        <trans-unit id="ddf9efd09112f93ec00fa54e8c4c84c765c17139" translate="yes" xml:space="preserve">
          <source>Heuristic Expiration</source>
          <target state="translated">эвристическое истечение срока годности</target>
        </trans-unit>
        <trans-unit id="f2bddb211b435d77bdcd54be12a624bcbd764aed" translate="yes" xml:space="preserve">
          <source>Heuristic freshness checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1724e0bfe29683a06f3fb0d140956360664db86b" translate="yes" xml:space="preserve">
          <source>Historic specification of HTTP State Management Mechanism, obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;</source>
          <target state="translated">Историческая спецификация механизма управления состоянием HTTP, устарела &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d2fc15fa26334cc66ab95bf51b30e486fe93e127" translate="yes" xml:space="preserve">
          <source>History Lists (RFC 7234)</source>
          <target state="translated">Списки истории (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="2b89425faff6de6dc314db782d45b8bad9965067" translate="yes" xml:space="preserve">
          <source>History and implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8224b406bb9fcf1d12ea7ebecf7258a153c52d79" translate="yes" xml:space="preserve">
          <source>Hop-by-hop compression</source>
          <target state="translated">Хоп-хоп компрессия</target>
        </trans-unit>
        <trans-unit id="77f5c2d41f116e38295977a86465e5e9e801702a" translate="yes" xml:space="preserve">
          <source>Hop-by-hop compression, though similar to end-to-end compression, differs by one fundamental element: the compression doesn't happen on the resource in the server, creating a specific representation that is then transmitted, but on the body of the message between any two nodes on the path between the client and the server. Connections between successive intermediate nodes may apply a &lt;em&gt;different&lt;/em&gt; compression.</source>
          <target state="translated">Поэтапное сжатие, хотя и похоже на сквозное сжатие, отличается одним фундаментальным элементом: сжатие происходит не на ресурсе на сервере, создавая конкретное представление, которое затем передается, а на теле файла. сообщение между любыми двумя узлами на пути между клиентом и сервером. Соединения между последовательными промежуточными узлами могут применять &lt;em&gt;различное&lt;/em&gt; сжатие.</target>
        </trans-unit>
        <trans-unit id="78458c6f2f912b6d6875b5a660931222e51353f1" translate="yes" xml:space="preserve">
          <source>Hop-by-hop headers</source>
          <target state="translated">Заголовки хоп-хопа</target>
        </trans-unit>
        <trans-unit id="3960ec4ca5fb5e5d8cdb2cc1c5121c003e426517" translate="yes" xml:space="preserve">
          <source>Host</source>
          <target state="translated">Host</target>
        </trans-unit>
        <trans-unit id="f3680c389a985b1c29ff7e674003c4ba66aee02b" translate="yes" xml:space="preserve">
          <source>Host (RFC 2616)</source>
          <target state="translated">Хост (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="5406f06c65b376c58dac6bf71408ae1944750e32" translate="yes" xml:space="preserve">
          <source>Host names and ports of reverse proxies (load balancers, CDNs) may differ from the origin server handling the request, in that case the &lt;code&gt;X-Forwarded-Host&lt;/code&gt; header is useful to determine which Host was originally used.</source>
          <target state="translated">Имена хостов и порты обратных прокси-серверов (балансировщики нагрузки, CDN) могут отличаться от исходного сервера, обрабатывающего запрос, в этом случае заголовок &lt;code&gt;X-Forwarded-Host&lt;/code&gt; полезен для определения того, какой хост был первоначально использован.</target>
        </trans-unit>
        <trans-unit id="f4b4c2643126c467ddef65e6b67d5f8c8b5bdc1a" translate="yes" xml:space="preserve">
          <source>Host to which the cookie will be sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a6082579e4930c27da3887804287a2a53f1624" translate="yes" xml:space="preserve">
          <source>Host-specific file names</source>
          <target state="translated">Имена файлов,специфичных для конкретного хоста</target>
        </trans-unit>
        <trans-unit id="2ec76d41d987ae559f5e3a7f7fd514508f4dcf54" translate="yes" xml:space="preserve">
          <source>Hosted CSP reporting for HTTPS migrations</source>
          <target state="translated">Хостинговая отчетность CSP для миграции HTTPS</target>
        </trans-unit>
        <trans-unit id="1367a4331a65542cf39c8a9d5b8961997d49502b" translate="yes" xml:space="preserve">
          <source>Hostname based conditions</source>
          <target state="translated">Условия,основанные на имени хоста</target>
        </trans-unit>
        <trans-unit id="39e32117a3b52cca1d492b875f026756fb25597f" translate="yes" xml:space="preserve">
          <source>How Browsers Work</source>
          <target state="translated">Как работают браузеры</target>
        </trans-unit>
        <trans-unit id="4c91ae122f1612df59f2a23941f9e79f1d970ecc" translate="yes" xml:space="preserve">
          <source>How cookies work is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;. When serving an HTTP request, a server can send a &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP header with the response. The client then returns the cookie's value with every request to the same server in the form of a &lt;code&gt;Cookie&lt;/code&gt; request header. The cookie can also be set to expire on a certain date, or restricted to a specific domain and path.</source>
          <target state="translated">Как работают файлы cookie, определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt; . При обслуживании HTTP-запроса сервер может отправить HTTP-заголовок &lt;code&gt;Set-Cookie&lt;/code&gt; с ответом. Затем клиент возвращает значение файла cookie с каждым запросом к тому же серверу в форме заголовка запроса &lt;code&gt;Cookie&lt;/code&gt; . Срок действия файла cookie также может быть установлен на определенную дату или ограничен определенным доменом и путем.</target>
        </trans-unit>
        <trans-unit id="326d6840506a3e0e685440ecd35aff457aa45373" translate="yes" xml:space="preserve">
          <source>How documents are cached can be controlled by HTTP. The server can instruct proxies and clients, about what to cache and for how long. The client can instruct intermediate cache proxies to ignore the stored document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785a4091642b3107a87eb0510aa18c744ad3bd77" translate="yes" xml:space="preserve">
          <source>How documents are cached can be controlled by HTTP. The server can instruct proxies, and clients, what to cache and for how long. The client can instruct intermediate cache proxies to ignore the stored document.</source>
          <target state="translated">Как документы кэшируются,можно управлять с помощью HTTP.Сервер может инструктировать прокси-серверы и клиентов,что кэшировать и как долго.Клиент может инструктировать промежуточных прокси-серверов кэшировать,чтобы они игнорировали сохраненный документ.</target>
        </trans-unit>
        <trans-unit id="9a92fcc6dda054aa8ba041f16e995c47ecf3e087" translate="yes" xml:space="preserve">
          <source>How much detail to include is an interesting balance to strike; exposing the OS version is probably a bad idea, as mentioned in the earlier warning about overly-detailed values. However, exposed Apache versions helped browsers work around a bug those versions had with &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt; combined with &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a6840353bc46a78f9536e0c4ba600c96425f56" translate="yes" xml:space="preserve">
          <source>How the browser handles it</source>
          <target state="translated">Как браузер справляется с этим</target>
        </trans-unit>
        <trans-unit id="68bee7ceae58ef9dd68bebd7e8624e01362fe458" translate="yes" xml:space="preserve">
          <source>How to Fix 405 Method Not Allowed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bbcaa9a058613fa1a50456a0aabfa3b3df0140" translate="yes" xml:space="preserve">
          <source>How to avoid the CORS preflight</source>
          <target state="translated">Как избежать предполета CORS</target>
        </trans-unit>
        <trans-unit id="778498eaac84dd627c8fe8e2869a7fc961933c44" translate="yes" xml:space="preserve">
          <source>How to fix &lt;em&gt;&amp;ldquo;Access-Control-Allow-Origin header must not be the wildcard&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">Как исправить &lt;em&gt;&amp;laquo;Заголовок Access-Control-Allow-Origin не должен быть подстановочным знаком&amp;raquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc108c55cd0ff984c9ac45ce8cdb74f88f1a0654" translate="yes" xml:space="preserve">
          <source>How to fix CORS issue?</source>
          <target state="translated">Как исправить проблему CORS?</target>
        </trans-unit>
        <trans-unit id="c305fbaf8d1dd662dd884c22cf15416371345003" translate="yes" xml:space="preserve">
          <source>How to run Chrome browser without CORS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd427ecf132d3e2cc23ee42d32690dc605d28a0f" translate="yes" xml:space="preserve">
          <source>How to use a CORS proxy to get around &lt;em&gt;&amp;ldquo;No Access-Control-Allow-Origin header&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">Как использовать CORS-прокси для обхода &lt;em&gt;заголовка &amp;laquo;No Access-Control-Allow-Origin&amp;raquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f79e53c0a139eb96378c7ba89f9dd8fbfb330c0" translate="yes" xml:space="preserve">
          <source>However, if the request is one that triggers a preflight due to the presence of the &lt;code&gt;Authorization&lt;/code&gt; header in the request, you won&amp;rsquo;t be able to work around the limitation using the steps above. And you won&amp;rsquo;t be able to work around it at all unless you have control over the server the request is being made to.</source>
          <target state="translated">Однако, если запрос запускает предполетную проверку из-за наличия в запросе заголовка &lt;code&gt;Authorization&lt;/code&gt; , вы не сможете обойти ограничение, используя описанные выше действия. И вы вообще не сможете обойти это, если у вас нет контроля над сервером, к которому отправляется запрос.</target>
        </trans-unit>
        <trans-unit id="aa3bacea776742f9f4ee0b04c2738bf1f2acd22e" translate="yes" xml:space="preserve">
          <source>However, scripts without integrity won't load anymore:</source>
          <target state="translated">Однако,скрипты без целостности больше не будут загружаться:</target>
        </trans-unit>
        <trans-unit id="4784e9a56ee26ccc58e9b47e0384d44d80f5b536" translate="yes" xml:space="preserve">
          <source>However, styles properties that are set directly on the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt;&lt;/a&gt; property will not be blocked, allowing users to safely manipulate styles via JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6363c2d9cd37774dbf6ea52a71d3cc4b1d69edf1" translate="yes" xml:space="preserve">
          <source>However, styles properties that are set directly on the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt;&lt;/a&gt; property will not be blocked, allowing users to safely manipulate styles via Javascript:</source>
          <target state="translated">Однако свойства стилей, которые устанавливаются непосредственно в свойстве &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;style&lt;/code&gt; &lt;/a&gt; элемента, не будут заблокированы, что позволяет пользователям безопасно управлять стилями через Javascript:</target>
        </trans-unit>
        <trans-unit id="712efc901d5948d1ddc85420dd7828b2c028e889" translate="yes" xml:space="preserve">
          <source>However, the above code is absolutely terrible and ill-conceived. What if Chrome removes this look behind feature? What if another browser implements look behind regexps? What if another browser uses &lt;em&gt;Chrome &lt;/em&gt;in their user agent string? The list goes on and on of things that could go terribly wrong. Thus, you should instead use feature detection like the following.</source>
          <target state="translated">Однако приведенный выше код абсолютно ужасен и непродуман. Что, если Chrome уберет эту функцию просмотра назад? Что, если другой браузер реализует просмотр регулярных выражений? Что, если другой браузер использует &lt;em&gt;Chrome&lt;/em&gt; в строке своего пользовательского агента? Список вещей, которые могут пойти не так, можно продолжать и продолжать. Таким образом, вы должны вместо этого использовать обнаружение функций, как показано ниже.</target>
        </trans-unit>
        <trans-unit id="3e339ee7e7a8e7da017468304e92dc515e180b71" translate="yes" xml:space="preserve">
          <source>However, this won't wildcard the &lt;a href=&quot;authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; header, so if you need to expose that, you will need to list it explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872b5517c0f6559afa3677ba893bb97024b2ecc2" translate="yes" xml:space="preserve">
          <source>HttpOnly Optional</source>
          <target state="translated">HttpOnly опционально</target>
        </trans-unit>
        <trans-unit id="abd954b086bab88cb87ec4cda040e14953ecce8f" translate="yes" xml:space="preserve">
          <source>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)</source>
          <target state="translated">Протокол управления гипертекстовым кофейником (HTCPCP/1.0)</target>
        </trans-unit>
        <trans-unit id="9cb22c4629a969af0720c560a54790780d479542" translate="yes" xml:space="preserve">
          <source>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0): Semantics and Content</source>
          <target state="translated">Протокол управления гипертекстовым кофейником (HTCPCP/1.0):Семантика и содержание</target>
        </trans-unit>
        <trans-unit id="126116b4ff4ad54a45b5f2a945491694cc39450d" translate="yes" xml:space="preserve">
          <source>Hyper text transfer protocol (Secure)</source>
          <target state="translated">Гиперпротокол передачи текста (Безопасный)</target>
        </trans-unit>
        <trans-unit id="a40ca5dd3664e7e5fbc9868906e198fe122b47b2" translate="yes" xml:space="preserve">
          <source>HyperText Markup Language (HTML)</source>
          <target state="translated">Язык гипертекстовой разметки (HTML)</target>
        </trans-unit>
        <trans-unit id="3aabdc98f3e181618def85f1876081249a0e4138" translate="yes" xml:space="preserve">
          <source>HyperText Transport Protocol Keep-Alive Header</source>
          <target state="translated">Транспортный протокол HyperText Сохраняйте живым заголовок</target>
        </trans-unit>
        <trans-unit id="caec6dcaeb81aa6d4af95da6ddc9afca1f3451f8" translate="yes" xml:space="preserve">
          <source>Hypertext Preprocessor (&lt;strong&gt;Personal Home Page&lt;/strong&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8bf740d859a72ca5b146b5d3c7c57e9e44dbdab" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP) Keep-Alive Header</source>
          <target state="translated">Гипертекстовый протокол передачи данных (HTTP)Сохраняйте спокойствие заголовка</target>
        </trans-unit>
        <trans-unit id="18c750541be3062c47621490bab7ee6a43ed0176" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP) clients often encounter
   interrupted data transfers as a result of canceled requests or
   dropped connections.  When a client has stored a partial
   representation, it is desirable to request the remainder of that
   representation in a subsequent request rather than transfer the
   entire representation.  Likewise, devices with limited local storage
   might benefit from being able to request only a subset of a larger
   representation, such as a single page of a very large document, or
   the dimensions of an embedded image.

   This document defines HTTP/1.1 range requests, partial responses, and
   the multipart/byteranges media type.  Range requests are an OPTIONAL
   feature of HTTP, designed so that recipients not implementing this
   feature (or not supporting it for the target resource) can respond as
   if it is a normal GET request without impacting interoperability.
   Partial responses are indicated by a distinct status code to not be
   mistaken for full responses by caches that might not implement the
   feature.

   Although the range request mechanism is designed to allow for
   extensible range types, this specification only defines requests for
   byte ranges.</source>
          <target state="translated">Клиенты гипертекстового протокола передачи данных (HTTP)часто сталкиваются с прерванной передачей данных в результате отмененных запросов или прерванных соединений.Когда клиент хранит частичное представление,желательно запросить остаток этого представления в последующем запросе,а не передавать все представление.Аналогичным образом,устройства с ограниченным локальным хранилищем могут выиграть от возможности запросить только подмножество более крупного представления,например,одну страницу очень большого документа,или размеры встроенного изображения.Этот документ определяет запросы диапазона HTTP/1.1,частичные ответы и тип носителя,состоящего из нескольких частей/байтералей.Запросы диапазона являются ФАКУЛЬТАТИВНОЙ функцией HTTP,разработанной таким образом,чтобы получатели,не реализующие эту функцию (или не поддерживающие ее для целевого ресурса),могли отвечать так,как если бы это был обычный GET-запрос,не влияя на функциональную совместимость.Частичные ответы обозначаются отдельным кодом состояния,чтобы не быть ошибочно принятым за полные ответы кэшами,которые могут не реализовывать эту функцию.Хотя механизм запроса диапазона спроектирован так,что позволяет использовать расширяемые типы диапазонов,эта спецификация определяет запросы только для байтовых диапазонов.</target>
        </trans-unit>
        <trans-unit id="eaebf91177666f1aaca9207bce21f241c2d6aa1c" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Authentication</source>
          <target state="translated">Протокол передачи гипертекста (HTTP/1.1):Аутентификация</target>
        </trans-unit>
        <trans-unit id="cf04e8c69e3ace21820abada8b4f0bf8440a50a6" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Caching</source>
          <target state="translated">Протокол передачи гипертекста (HTTP/1.1):Кэширование</target>
        </trans-unit>
        <trans-unit id="565eb02fb9f4c2b506e298c3e3bd17146e8b9b29" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</source>
          <target state="translated">Протокол передачи гипертекста (HTTP/1.1):Условные запросы</target>
        </trans-unit>
        <trans-unit id="5ffac3f427873675e5fda46ed9caffb674838583" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</source>
          <target state="translated">Протокол передачи гипертекста (HTTP/1.1):синтаксис и маршрутизация сообщений</target>
        </trans-unit>
        <trans-unit id="067dc1d00ea2a2c2813ac9db731d6b354882d326" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</source>
          <target state="translated">Протокол передачи гипертекста (HTTP/1.1):Запросы диапазона</target>
        </trans-unit>
        <trans-unit id="67726549543e0d1b42d751ebf670ca915f452bde" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</source>
          <target state="translated">Протокол передачи гипертекста (HTTP/1.1):Семантика и содержание</target>
        </trans-unit>
        <trans-unit id="dadde9e82bc152463510002167edd8589458e39b" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Context</source>
          <target state="translated">Протокол передачи гипертекста (HTTP/1.1):Семантика и контекст</target>
        </trans-unit>
        <trans-unit id="0464d55671763178e4bb9bf689fd75c3b2bf90ee" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol -- HTTP/1.1</source>
          <target state="translated">Протокол передачи гипертекста --HTTP/1.1</target>
        </trans-unit>
        <trans-unit id="14001adc995acbe66bc7906c7030f074a23e21ec" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol Version 2 (HTTP/2)</source>
          <target state="translated">Протокол передачи гипертекста версия 2 (HTTP/2)</target>
        </trans-unit>
        <trans-unit id="e0899b85bb34ecad597f88ef93fbf5180bd78fc6" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7230)</source>
          <target state="translated">Соображения ИАНА (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="fb05bb988d2b3042dacb51c3209a976e89fd65b7" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7231)</source>
          <target state="translated">Соображения ИАНА (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="faddb1a82ba7e7645aff6b957bbe064fd752dd69" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7232)</source>
          <target state="translated">Соображения ИАНА (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="4cbf2a520cf53d1cedf62323be093a069cfdcece" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7233)</source>
          <target state="translated">Соображения ИАНА (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="2ce28868e82be3265aeb20b44d3fbb587c2a23ce" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7234)</source>
          <target state="translated">Соображения ИАНА (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="98a74c9cf29e82d02e581eb12c22dda292d5ee17" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7235)</source>
          <target state="translated">Соображения ИАНА (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="4bb8022eff5067ab10c4c96ad85499b49bef742d" translate="yes" xml:space="preserve">
          <source>IANA HTTP Range Unit Registry</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5904c4ee52524bdc80934ad4f9a7950c63e23ee8" translate="yes" xml:space="preserve">
          <source>IANA has added a reference to this specification in the
   'application/atom+xml' media type registration.</source>
          <target state="translated">IANA добавила ссылку на эту спецификацию при регистрации типа носителя 'application/atom+xml'.</target>
        </trans-unit>
        <trans-unit id="69ea11543f5de3dd2cb43742c8f141e34bd0847d" translate="yes" xml:space="preserve">
          <source>IANA is the official registry of MIME media types and maintains a &lt;a href=&quot;http://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;list of all the official MIME types&lt;/a&gt;. This table lists some important MIME types for the Web:</source>
          <target state="translated">IANA - это официальный реестр типов носителей MIME, который ведет &lt;a href=&quot;http://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;список всех официальных типов MIME&lt;/a&gt; . В этой таблице перечислены некоторые важные типы MIME для Интернета:</target>
        </trans-unit>
        <trans-unit id="89c07cdbd61e19ece57d06075ba79aecfe00c78b" translate="yes" xml:space="preserve">
          <source>IANA list of URI schemes</source>
          <target state="translated">список схем ИАНА</target>
        </trans-unit>
        <trans-unit id="78740b079f8a9346faaa07edbf050f52dc47fc13" translate="yes" xml:space="preserve">
          <source>IANA maintains the &quot;HTTP Content Coding Registry&quot; at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.

   The &quot;HTTP Content Coding Registry&quot; has been updated with the
   registrations below:

   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | compress   | UNIX &quot;compress&quot; data format [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;]  | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | deflate    | &quot;deflate&quot; compressed data            | &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt; |
   |            | ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;]) inside the &quot;zlib&quot; data   |               |
   |            | format ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;])                   |               |
   | gzip       | GZIP file format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;]           | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   | x-compress | Deprecated (alias for compress)      | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | x-gzip     | Deprecated (alias for gzip)          | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   +------------+--------------------------------------+---------------+</source>
          <target state="translated">IANA ведет &amp;laquo;Реестр кодирования содержимого HTTP&amp;raquo; по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;. В &amp;laquo;Реестр кодирования содержимого HTTP&amp;raquo; добавлены следующие регистрации: + ------------ + --------------------- ----------------- + --------------- + | Имя | Описание | Справка | + ------------ + ------------------------------------ - + --------------- + | сжать | UNIX &quot;сжимает&quot; формат данных [ &lt;a href=&quot;#ref-Welch&quot;&gt;Велч&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.1&quot;&gt;Раздел 4.2.1&lt;/a&gt; | | сдуть | &quot;сдуть&quot; сжатые данные | &lt;a href=&quot;#section-4.2.2&quot;&gt;Раздел 4.2.2&lt;/a&gt; | | | ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]) внутри данных &quot;zlib&quot; | | | | формат ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;]) | | | gzip | Формат файла GZIP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.3&quot;&gt;Раздел 4.2.3&lt;/a&gt; | | x-compress | Устарело (псевдоним для сжатия) | &lt;a href=&quot;#section-4.2.1&quot;&gt;Раздел 4.2.1&lt;/a&gt; | | x-gzip | Устарело (псевдоним для gzip) | &lt;a href=&quot;#section-4.2.3&quot;&gt;Раздел 4.2.3&lt;/a&gt; | + ------------ + ------------------------------------ - + --------------- +</target>
        </trans-unit>
        <trans-unit id="2f3aef98e61cefd59e70d51a0d54a7f7880c7e4d" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media
   types &quot;message/http&quot; and &quot;application/http&quot;.  The following has been
   registered with IANA.</source>
          <target state="translated">IANA ведет реестр типов Интернет-носителей [ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt;. Этот документ служит спецификацией для типов Интернет-носителей &amp;laquo;message / http&amp;raquo; и &amp;laquo;application / http&amp;raquo;. Следующее было зарегистрировано в IANA.</target>
        </trans-unit>
        <trans-unit id="57560e1f2062a0d9e41b59e9de0cd89dfc775402" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media type
   &quot;multipart/byteranges&quot;.  The following has been registered with IANA.</source>
          <target state="translated">IANA ведет реестр типов Интернет-носителей [ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt;. Этот документ служит спецификацией для типа Интернет-носителя &quot;multipart / byteranges&quot;. Следующее было зарегистрировано в IANA.</target>
        </trans-unit>
        <trans-unit id="2f25bf5a2ef40ce000fcbfb953c618138d7e6d92" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of URI Schemes [&lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt;&amp;gt;.

   This document defines the following URI schemes, so the &quot;Permanent
   URI Schemes&quot; registry has been updated accordingly.

   +------------+------------------------------------+---------------+
   | URI Scheme | Description                        | Reference     |
   +------------+------------------------------------+---------------+
   | http       | Hypertext Transfer Protocol        | &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt; |
   | https      | Hypertext Transfer Protocol Secure | &lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt; |
   +------------+------------------------------------+---------------+</source>
          <target state="translated">IANA ведет реестр схем URI [ &lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt; ] по адресу &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt; &amp;gt;. В этом документе определены следующие схемы URI, поэтому реестр &amp;laquo;Постоянных схем URI&amp;raquo; был обновлен соответствующим образом. + ------------ + ------------------------------------ + --------------- + | Схема URI | Описание | Справка | + ------------ + ------------------------------------ + --------------- + | http | Протокол передачи гипертекста | &lt;a href=&quot;#section-2.7.1&quot;&gt;Раздел 2.7.1&lt;/a&gt; | | https | Безопасный протокол передачи гипертекста | &lt;a href=&quot;#section-2.7.2&quot;&gt;Раздел 2.7.2&lt;/a&gt; | + ------------ + ------------------------------------ + --------------- +</target>
        </trans-unit>
        <trans-unit id="70d5ce962c5520d83534599071460204e3f79a4c" translate="yes" xml:space="preserve">
          <source>IANA official registry of HTTP status codes</source>
          <target state="translated">IANA официальный реестр кодов статуса HTTP</target>
        </trans-unit>
        <trans-unit id="052ea052e8c19248acaf0e57ba16070d89e5f3f2" translate="yes" xml:space="preserve">
          <source>IANA registry</source>
          <target state="translated">реестр IANA</target>
        </trans-unit>
        <trans-unit id="3ec2a8d54523fcf678717117536e9db1ddb9d0ec" translate="yes" xml:space="preserve">
          <source>IANA registry of Authentication schemes</source>
          <target state="translated">Реестр схем аутентификации IANA</target>
        </trans-unit>
        <trans-unit id="433dbaf6332943984d6516e68b5f7fa26960c972" translate="yes" xml:space="preserve">
          <source>ICO</source>
          <target state="translated">ICO</target>
        </trans-unit>
        <trans-unit id="1c424db78d6168d4e4112d7ef44078d6e5cc90ef" translate="yes" xml:space="preserve">
          <source>IETF Draft</source>
          <target state="translated">проект IETF</target>
        </trans-unit>
        <trans-unit id="8017c92650b8189e940d94d4098c59d4b86b1c4b" translate="yes" xml:space="preserve">
          <source>IETF RFC</source>
          <target state="translated">КСФМ IETF</target>
        </trans-unit>
        <trans-unit id="8571cc2c4258545210a5b00473280039ad4b84d4" translate="yes" xml:space="preserve">
          <source>IIS</source>
          <target state="translated">IIS</target>
        </trans-unit>
        <trans-unit id="863b6ddbf8a4aa095ca888b978a73ba1efc7811f" translate="yes" xml:space="preserve">
          <source>Icon format</source>
          <target state="translated">формат иконки</target>
        </trans-unit>
        <trans-unit id="ca9f65841299353702f59413c67b4d41e934a6e4" translate="yes" xml:space="preserve">
          <source>Ideally, there is one location, and therefore one URL, for each resource. But there are reasons for alternative names for a resource:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc4507a76928b989abe5a6100c9511b38bd00d7" translate="yes" xml:space="preserve">
          <source>Ideally, there is one location, and therefore one URL, for one resource. But there are reasons for wanting to have alternative names for a resource (several domains, like with and without the www prefix or shorter and easy to remember URLs, &amp;hellip;). In these cases, rather than duplicating the resource, it is useful to use a redirect to the one true (canonical) URL.</source>
          <target state="translated">В идеале для одного ресурса должно быть одно место и, следовательно, один URL. Но есть причины для желания иметь альтернативные имена для ресурса (несколько доменов, например, с префиксом www и без него или более короткие и легко запоминающиеся URL-адреса,&amp;hellip;). В этих случаях вместо дублирования ресурса полезно использовать перенаправление на один истинный (канонический) URL.</target>
        </trans-unit>
        <trans-unit id="f1df7d15a8112ad87203fcb0cb507f4b96b72bbd" translate="yes" xml:space="preserve">
          <source>Idempotent</source>
          <target state="translated">Idempotent</target>
        </trans-unit>
        <trans-unit id="b6a2413ad63489a62e13c1cef9ff703c77e3aa0f" translate="yes" xml:space="preserve">
          <source>Idempotent Methods (RFC 7231)</source>
          <target state="translated">Идемпотентные методы (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="526430255f19421715307947f2ff84df60c93896" translate="yes" xml:space="preserve">
          <source>Identifies the original host requested that a client used to connect to your proxy or load balancer.</source>
          <target state="translated">Определяет оригинальный хост,запрошенный клиентом для подключения к прокси-серверу или балансировщику нагрузки.</target>
        </trans-unit>
        <trans-unit id="b108c524c313085aeda694b0f180ecea370efb15" translate="yes" xml:space="preserve">
          <source>Identifies the originating IP addresses of a client connecting to a web server through an HTTP proxy or a load balancer.</source>
          <target state="translated">Определяет исходные IP-адреса клиента,подключающегося к веб-серверу через HTTP-прокси или балансировщик нагрузки.</target>
        </trans-unit>
        <trans-unit id="4728d359ae99afe818be6f9dc7667972f09461f4" translate="yes" xml:space="preserve">
          <source>Identifies the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b059dd235df4bbca4880938a5c1bb58a2acfaacc" translate="yes" xml:space="preserve">
          <source>Identifying allowed request methods</source>
          <target state="translated">Определение разрешенных методов запроса</target>
        </trans-unit>
        <trans-unit id="a11a4c57a7f8dccbb14cb41b82dc14540c9e4cbe" translate="yes" xml:space="preserve">
          <source>Identifying resources on the Web</source>
          <target state="translated">Идентификация ресурсов в Интернете</target>
        </trans-unit>
        <trans-unit id="2ddba376a063bd16e86e27e7bafe3713c58a5850" translate="yes" xml:space="preserve">
          <source>Identifying the issue</source>
          <target state="translated">Выявление проблемы</target>
        </trans-unit>
        <trans-unit id="5411f86a7d04f9bc55dfc770d7c059832dab58c1" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Also) responses always lead to the use of a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method, &lt;a href=&quot;../status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt; (Temporary Redirect) and &lt;a href=&quot;../status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt; (Permanent Redirect) don't change the method used in the original request;</source>
          <target state="translated">Если ответы &lt;a href=&quot;../status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt; (см. Также) всегда приводят к использованию метода &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/307&quot;&gt; &lt;code&gt;307&lt;/code&gt; &lt;/a&gt; (временное перенаправление) и &lt;a href=&quot;../status/308&quot;&gt; &lt;code&gt;308&lt;/code&gt; &lt;/a&gt; (постоянное перенаправление) не изменяют метод, использованный в исходном запросе;</target>
        </trans-unit>
        <trans-unit id="203f83a39c006e96b0372879695a48c384f5a98d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Viewport-Width&lt;/code&gt; occurs in a message more than once, the last value overrides all previous occurrences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e6f0a239dfb82509e36ca577925e74a83f28f9" translate="yes" xml:space="preserve">
          <source>If = &quot;If&quot; &quot;:&quot; ( 1*No-tag-list | 1*Tagged-list )

     No-tag-list = List
     Tagged-list = Resource-Tag 1*List

     List = &quot;(&quot; 1*Condition &quot;)&quot;
     Condition = [&quot;Not&quot;] (State-token | &quot;[&quot; entity-tag &quot;]&quot;)
     ; entity-tag: see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;Section&amp;nbsp;3.11 of [RFC2616]&lt;/a&gt;
     ; No LWS allowed between &quot;[&quot;, entity-tag and &quot;]&quot; 

     State-token = Coded-URL

     Resource-Tag = &quot;&amp;lt;&quot; Simple-ref &quot;&amp;gt;&quot;
     ; Simple-ref: see &lt;a href=&quot;#section-8.3&quot;&gt;Section 8.3&lt;/a&gt;
     ; No LWS allowed in Resource-Tag

   The syntax distinguishes between untagged lists (&quot;No-tag-list&quot;) and
   tagged lists (&quot;Tagged-list&quot;).  Untagged lists apply to the resource
   identified by the Request-URI, while tagged lists apply to the
   resource identified by the preceding Resource-Tag.

   A Resource-Tag applies to all subsequent Lists, up to the next
   Resource-Tag.

   Note that the two list types cannot be mixed within an If header.
   This is not a functional restriction because the No-tag-list syntax
   is just a shorthand notation for a Tagged-list production with a
   Resource-Tag referring to the Request-URI.

   Each List consists of one or more Conditions.  Each Condition is
   defined in terms of an entity-tag or state-token, potentially negated
   by the prefix &quot;Not&quot;.

   Note that the If header syntax does not allow multiple instances of
   If headers in a single request.  However, the HTTP header syntax
   allows extending single header values across multiple lines, by
   inserting a line break followed by whitespace (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], &lt;a href=&quot;#section-4.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;).</source>
          <target state="translated">If = &quot;If&quot; &quot;:&quot; (1 * Список-без тегов | 1 * Список-тегов) Список-без-тегов = Список-тегов = Тег-ресурса 1 * Список-список = &quot;(&quot; 1 * Условие &quot;) &quot;Condition = [&quot; Not &quot;] (State-token |&quot; [&quot;entity-tag&quot;] &quot;); entity-tag: см. &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;раздел 3.11 [RFC2616]&lt;/a&gt; ; Не допускается использование LWS между &quot;[&quot;, entity-tag и &quot;]&quot; State-token = Coded-URL Resource-Tag = &quot;&amp;lt;&quot; Simple-ref &quot;&amp;gt;&quot;; Simple-ref: см. &lt;a href=&quot;#section-8.3&quot;&gt;Раздел 8.3&lt;/a&gt; ; В теге ресурса не допускается использование LWS. Синтаксис различает списки без тегов (&quot;Список без тегов&quot;) и списки с тегами (&quot;Список с тегами&quot;). Списки без тегов применяются к ресурсу, указанному в Request-URI, а списки с тегами применяются к ресурсу, указанному предыдущим тегом ресурса. Тег ресурса применяется ко всем последующим спискам до следующего тега ресурса. Обратите внимание, что два типа списков нельзя смешивать в заголовке If. Это не функциональное ограничение, потому что синтаксис No-tag-list - это просто сокращенная запись для создания Tagged-list с Resource-Tag, относящимся к Request-URI. Каждый список состоит из одного или нескольких условий. Каждое Условие определяется с помощью тега объекта или токена состояния, потенциально отменяемого префиксом &amp;laquo;Не&amp;raquo;.Обратите внимание, что синтаксис заголовка If не позволяет использовать несколько экземпляров заголовков If в одном запросе. Однако синтаксис заголовка HTTP позволяет расширить значения одного заголовка на несколько строк, вставив разрыв строки, за которым следует пробел (см. [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ], &lt;a href=&quot;#section-4.2&quot;&gt;раздел &lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="00bde6a2609129ada06a88cb9a7d89333869670f" translate="yes" xml:space="preserve">
          <source>If HTTP pipelining is activated, several requests can be sent without waiting for the first response to be fully received. HTTP pipelining has proven difficult to implement in existing networks, where old pieces of software coexist with modern versions. HTTP pipelining has been superseded in HTTP/2 with more robust multiplexing requests within a frame.</source>
          <target state="translated">Если HTTP-трубопровод активирован,несколько запросов могут быть отправлены,не дожидаясь получения первого ответа в полном объеме.HTTP-трубопровод оказался труднореализуемым в существующих сетях,где старые части программного обеспечения сосуществуют с современными версиями.HTTP-трубопровод был заменен в HTTP/2 с более надежным мультиплексированием запросов в рамках.</target>
        </trans-unit>
        <trans-unit id="748bef436e961cb49a985af369e84e4c57fb5faa" translate="yes" xml:space="preserve">
          <source>If a (proxy) server receives valid credentials that are inadequate to access a given resource, the server should respond with the &lt;a href=&quot;status/403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Forbidden&lt;/code&gt; status code. Unlike &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; or &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;, authentication is impossible for this user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2712ef523f505fe38f908ee1d8ecd4882dfa22c9" translate="yes" xml:space="preserve">
          <source>If a (proxy) server receives valid credentials that are not adequate to gain access for a given resource, the server should respond with the &lt;a href=&quot;status/403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Forbidden&lt;/code&gt; status code. Unlike &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; or &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;, authentication is impossible for this user.</source>
          <target state="translated">Если (прокси) сервер получает действительные учетные данные, которых недостаточно для получения доступа к данному ресурсу, сервер должен ответить кодом состояния &lt;a href=&quot;status/403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Forbidden&lt;/code&gt; . В отличие от &lt;a href=&quot;status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; или &lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; , аутентификация для этого пользователя невозможна.</target>
        </trans-unit>
        <trans-unit id="9c01487d51a7abfed59147d7589b11bd17b56929" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-WebSocket-Key&quot;&gt;&lt;code&gt;Sec-WebSocket-Key&lt;/code&gt;&lt;/a&gt; header was provided, the value of this header is computed by taking the value of the key, concatenating the string &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to it, taking the &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; hash of that concatenated string, resulting in a 20-byte value. That value is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded to obtain the value of this property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326ac990ab0dffc2412d939867b01ccdcb920f4c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DELETE&lt;/code&gt; method is successfully applied, there are several response status codes possible:</source>
          <target state="translated">Если метод &lt;code&gt;DELETE&lt;/code&gt; успешно применен, возможны несколько кодов состояния ответа:</target>
        </trans-unit>
        <trans-unit id="e0abfc5dd0ca6cc561a0c1e9018bd30b2988a7b7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; header was provided, the value of this header is computed by taking the value of the key, concatenating the string &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to it, taking the &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; hash of that concatenated string, resulting in a 20-byte value. That value is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded to obtain the value of this property.</source>
          <target state="translated">Если был предоставлен заголовок &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; , значение этого заголовка вычисляется путем взятия значения ключа, присоединения к нему строки &amp;laquo;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&amp;raquo;, взяв хэш &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; эта объединенная строка, в результате чего получается 20-байтовое значение. Затем это значение кодируется в кодировке &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; для получения значения этого свойства.</target>
        </trans-unit>
        <trans-unit id="34536e055c95da8db601f072a295ac2e4e5c6957" translate="yes" xml:space="preserve">
          <source>If a COPY request has an Overwrite header with a value of &quot;F&quot;, and a
   resource exists at the Destination URL, the server MUST fail the
   request.

   When a server executes a COPY request and overwrites a destination
   resource, the exact behavior MAY depend on many factors, including
   WebDAV extension capabilities (see particularly [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;]).  For 

   example, when an ordinary resource is overwritten, the server could
   delete the target resource before doing the copy, or could do an in-
   place overwrite to preserve live properties.

   When a collection is overwritten, the membership of the destination
   collection after the successful COPY request MUST be the same
   membership as the source collection immediately before the COPY.
   Thus, merging the membership of the source and destination
   collections together in the destination is not a compliant behavior.

   In general, if clients require the state of the destination URL to be
   wiped out prior to a COPY (e.g., to force live properties to be
   reset), then the client could send a DELETE to the destination before
   the COPY request to ensure this reset.</source>
          <target state="translated">Если запрос COPY имеет заголовок Overwrite со значением &amp;laquo;F&amp;raquo; и ресурс существует в URL-адресе назначения, сервер ДОЛЖЕН отклонить запрос. Когда сервер выполняет запрос COPY и перезаписывает целевой ресурс, точное поведение МОЖЕТ зависеть от многих факторов, включая возможности расширения WebDAV (см., В частности, [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;]). Например, при перезаписи обычного ресурса сервер может удалить целевой ресурс перед копированием или выполнить перезапись на месте, чтобы сохранить текущие свойства. Когда коллекция перезаписывается, членство в целевой коллекции после успешного запроса COPY ДОЛЖНО быть таким же, как у исходной коллекции непосредственно перед COPY. Таким образом, объединение членства исходной и целевой коллекций в место назначения не является совместимым поведением. В общем, если клиенты требуют, чтобы состояние URL-адреса назначения было стерто до КОПИРОВАНИЯ (например, чтобы принудительно сбросить текущие свойства), то клиент может отправить УДАЛЕНИЕ в пункт назначения перед запросом КОПИРОВАТЬ, чтобы гарантировать этот сброс. ,</target>
        </trans-unit>
        <trans-unit id="0fb0c405e8ed86db97633eff664cd93d6b990ee4" translate="yes" xml:space="preserve">
          <source>If a cache receives a value greater than it can represent, or if any of its subsequent calculations overflows, the cache will consider the value to be either 2147483648 (2^31) or the greatest positive integer it can conveniently represent.</source>
          <target state="translated">Если кэш получит значение больше,чем может представлять,или если какое-либо из его последующих вычислений переполнится,то кэш будет считать значение либо 2147483648 (2^31),либо наибольшее положительное целое число,которое он может удобно представлять.</target>
        </trans-unit>
        <trans-unit id="f48cab758bf32db6fab20e2d919807414feba7e5" translate="yes" xml:space="preserve">
          <source>If a cache receives a value greater than it can represent, or if any of its subsequent calculations overflows, the cache will consider this value to be either 2,147,483,648 (2&lt;sup&gt;31&lt;/sup&gt;) or the greatest positive integer it can represent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f89453dd62bad0eede5073e7bfa49271c65312" translate="yes" xml:space="preserve">
          <source>If a client has a partial copy of a representation and wishes to have
   an up-to-date copy of the entire representation, it could use the
   Range header field with a conditional GET (using either or both of
   If-Unmodified-Since and If-Match.)  However, if the precondition
   fails because the representation has been modified, the client would
   then have to make a second request to obtain the entire current
   representation.

   The &quot;If-Range&quot; header field allows a client to &quot;short-circuit&quot; the
   second request.  Informally, its meaning is as follows: if the
   representation is unchanged, send me the part(s) that I am requesting
   in Range; otherwise, send me the entire representation.

     If-Range = entity-tag / HTTP-date

   A client MUST NOT generate an If-Range header field in a request that
   does not contain a Range header field.  A server MUST ignore an
   If-Range header field received in a request that does not contain a
   Range header field.  An origin server MUST ignore an If-Range header
   field received in a request for a target resource that does not
   support Range requests.

   A client MUST NOT generate an If-Range header field containing an
   entity-tag that is marked as weak.  A client MUST NOT generate an
   If-Range header field containing an HTTP-date unless the client has
   no entity-tag for the corresponding representation and the date is a
   strong validator in the sense defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;Section&amp;nbsp;2.2.2 of [RFC7232]&lt;/a&gt;.

   A server that evaluates an If-Range precondition MUST use the strong
   comparison function when comparing entity-tags (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3.2&quot;&gt;Section&amp;nbsp;2.3.2 of
   [RFC7232]&lt;/a&gt;) and MUST evaluate the condition as false if an HTTP-date 

   validator is provided that is not a strong validator in the sense
   defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;Section&amp;nbsp;2.2.2 of [RFC7232]&lt;/a&gt;.  A valid entity-tag can be
   distinguished from a valid HTTP-date by examining the first two
   characters for a DQUOTE.

   If the validator given in the If-Range header field matches the
   current validator for the selected representation of the target
   resource, then the server SHOULD process the Range header field as
   requested.  If the validator does not match, the server MUST ignore
   the Range header field.  Note that this comparison by exact match,
   including when the validator is an HTTP-date, differs from the
   &quot;earlier than or equal to&quot; comparison used when evaluating an
   If-Unmodified-Since conditional.</source>
          <target state="translated">Если у клиента есть частичная копия представления и он хочет иметь обновленную копию всего представления, он может использовать поле заголовка Range с условным GET (используя один или оба из If-Unmodified-Since и If -Match.) Однако, если предварительное условие не выполняется из-за изменения представления, клиент должен будет сделать второй запрос, чтобы получить все текущее представление. Поле заголовка &amp;laquo;If-Range&amp;raquo; позволяет клиенту &amp;laquo;замкнуть&amp;raquo; второй запрос. Неформально его значение таково: если представление не изменилось, пришлите мне запрошенные в Range части; в противном случае пришлите мне все представление.If-Range = entity-tag / HTTP-date. Клиент НЕ ДОЛЖЕН генерировать поле заголовка If-Range в запросе, не содержащем поля заголовка Range. Сервер ДОЛЖЕН игнорировать поле заголовка If-Range, полученное в запросе, не содержащем поля заголовка Range. Исходный сервер ДОЛЖЕН игнорировать поле заголовка If-Range, полученное в запросе целевого ресурса, который не поддерживает запросы Range. Клиент НЕ ДОЛЖЕН создавать поле заголовка If-Range, содержащее тег объекта, помеченный как слабый. Клиент НЕ ДОЛЖЕН генерировать поле заголовка If-Range, содержащее HTTP-дату, если только у клиента нет тега объекта для соответствующего представления и дата является сильным валидатором в смысле, определенномСервер ДОЛЖЕН игнорировать поле заголовка If-Range, полученное в запросе, не содержащем поля заголовка Range. Исходный сервер ДОЛЖЕН игнорировать поле заголовка If-Range, полученное в запросе целевого ресурса, который не поддерживает запросы Range. Клиент НЕ ДОЛЖЕН создавать поле заголовка If-Range, содержащее тег объекта, помеченный как слабый. Клиент НЕ ДОЛЖЕН генерировать поле заголовка If-Range, содержащее HTTP-дату, если только у клиента нет тега объекта для соответствующего представления и дата является сильным валидатором в смысле, определенномСервер ДОЛЖЕН игнорировать поле заголовка If-Range, полученное в запросе, не содержащем поля заголовка Range. Исходный сервер ДОЛЖЕН игнорировать поле заголовка If-Range, полученное в запросе целевого ресурса, который не поддерживает запросы Range. Клиент НЕ ДОЛЖЕН создавать поле заголовка If-Range, содержащее тег объекта, помеченный как слабый. Клиент НЕ ДОЛЖЕН генерировать поле заголовка If-Range, содержащее HTTP-дату, если только у клиента нет тега объекта для соответствующего представления и дата является сильным валидатором в смысле, определенномКлиент НЕ ДОЛЖЕН создавать поле заголовка If-Range, содержащее тег объекта, помеченный как слабый. Клиент НЕ ДОЛЖЕН генерировать поле заголовка If-Range, содержащее HTTP-дату, если только у клиента нет тега объекта для соответствующего представления и дата является сильным валидатором в смысле, определенномКлиент НЕ ДОЛЖЕН создавать поле заголовка If-Range, содержащее тег объекта, помеченный как слабый. Клиент НЕ ДОЛЖЕН генерировать поле заголовка If-Range, содержащее HTTP-дату, если только у клиента нет тега объекта для соответствующего представления и дата является сильным валидатором в смысле, определенном&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;Раздел 2.2.2 [RFC7232]&lt;/a&gt; . Сервер, который оценивает предварительное условие If-Range, ДОЛЖЕН использовать функцию &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3.2&quot;&gt;строгого&lt;/a&gt; сравнения при сравнении тегов объектов ( раздел 2.3.2 [RFC7232] ) и ДОЛЖЕН оценивать условие как ложное, если предоставлен валидатор даты HTTP, который не является строгим. валидатор в смысле, определенном в &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;разделе 2.2.2 [RFC7232]&lt;/a&gt;, Допустимый тег объекта можно отличить от действительной даты HTTP, проверив первые два символа DQUOTE. Если валидатор, указанный в поле заголовка If-Range, совпадает с текущим валидатором для выбранного представления целевого ресурса, то серверу СЛЕДУЕТ обработать поле заголовка Range по запросу. Если валидатор не соответствует, сервер ДОЛЖЕН игнорировать поле заголовка Range. Обратите внимание, что это сравнение по точному совпадению, в том числе когда валидатором является HTTP-дата, отличается от сравнения &amp;laquo;раньше или равно&amp;raquo;, используемого при оценке условного выражения If-Unmodified-Since.</target>
        </trans-unit>
        <trans-unit id="9d82e70ce9faffba2758cddebc66060093cca8ab" translate="yes" xml:space="preserve">
          <source>If a client has a partial copy of an entity in its cache, and wishes
   to have an up-to-date copy of the entire entity in its cache, it
   could use the Range request-header with a conditional GET (using
   either or both of If-Unmodified-Since and If-Match.) However, if the
   condition fails because the entity has been modified, the client
   would then have to make a second request to obtain the entire current
   entity-body.

   The If-Range header allows a client to &quot;short-circuit&quot; the second
   request. Informally, its meaning is `if the entity is unchanged, send
   me the part(s) that I am missing; otherwise, send me the entire new
   entity'.

        If-Range = &quot;If-Range&quot; &quot;:&quot; ( entity-tag | HTTP-date ) 

   If the client has no entity tag for an entity, but does have a Last-
   Modified date, it MAY use that date in an If-Range header. (The
   server can distinguish between a valid HTTP-date and any form of
   entity-tag by examining no more than two characters.) The If-Range
   header SHOULD only be used together with a Range header, and MUST be
   ignored if the request does not include a Range header, or if the
   server does not support the sub-range operation.

   If the entity tag given in the If-Range header matches the current
   entity tag for the entity, then the server SHOULD provide the
   specified sub-range of the entity using a 206 (Partial content)
   response. If the entity tag does not match, then the server SHOULD
   return the entire entity using a 200 (OK) response.</source>
          <target state="translated">Если клиент имеет частичную копию сущности в кэше и хочет иметь обновленную копию всей сущности в кэше,он может использовать заголовок запроса Range с условным GET (используя либо один,либо оба If-Unmodified-Since и If-Match).Однако,если условие не удаётся из-за того,что сущность была изменена,то клиенту придётся сделать второй запрос,чтобы получить всю текущую сущность-тело.Заголовок If-диапазона позволяет клиенту &quot;замыкать&quot; второй запрос.Информально,его смысл в том,что если сущность не изменилась,отправьте мне ту часть (части),которую я пропустил;в противном случае,отправьте мне всю новую сущность&quot;.If-диапазон=&quot;If-диапазон&quot; &quot;:&quot;(тег | HTTP-дата)Если у клиента нет тега сущности для сущности,но есть Last-Mодифицированная дата,он МОЖЕТ использовать эту дату в заголовке If-диапазона.(Сервер может отличить действительную HTTP-дату от любой формы тега сущности,рассмотрев не более двух символов).Заголовок If-диапазона ДОЛЖЕН использоваться только вместе с заголовком Range,и ДОЛЖЕН быть проигнорирован,если запрос не включает в себя заголовок Range,или если сервер не поддерживает операцию поддиапазона.Если тег сущности,указанный в заголовке If-диапазона,совпадает с текущим тегом сущности для данной сущности,то сервер SHOULD предоставляет указанный поддиапазон сущности,используя ответ 206 (Частичное содержимое).Если тег сущности не совпадает,то сервер SHOULD возвращает всю сущность,используя ответ 200 (OK).</target>
        </trans-unit>
        <trans-unit id="3088b6387af36bd48fbfec162964786d9f1bdf8a" translate="yes" xml:space="preserve">
          <source>If a cookie name has this prefix, it is accepted in a &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header only if it is also marked with the &lt;code&gt;Secure&lt;/code&gt; attribute, was sent from a secure origin, does &lt;em&gt;not&lt;/em&gt; include a &lt;code&gt;Domain&lt;/code&gt; attribute, and has the &lt;code&gt;Path&lt;/code&gt; attribute set to &lt;code&gt;/&lt;/code&gt;. In this way, these cookies can be seen as &quot;domain-locked&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c034021e921f0e666de945c6149637ed216dc323" translate="yes" xml:space="preserve">
          <source>If a cookie name has this prefix, it is accepted in a &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header only if it is marked with the &lt;code&gt;Secure&lt;/code&gt; attribute and was sent from a secure origin. This is weaker than the &lt;code&gt;__Host-&lt;/code&gt; prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c875512b44481b0aec708d6ca539f3bb79d246" translate="yes" xml:space="preserve">
          <source>If a new cacheable (see sections &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;, &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;, &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt; and &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt;)
   response is received from a resource while any existing responses for
   the same resource are cached, the cache SHOULD use the new response
   to reply to the current request. It MAY insert it into cache storage
   and MAY, if it meets all other requirements, use it to respond to any
   future requests that would previously have caused the old response to
   be returned. If it inserts the new response into cache storage  the
   rules in &lt;a href=&quot;#section-13.5.3&quot;&gt;section 13.5.3&lt;/a&gt; apply.

      Note: a new response that has an older Date header value than
      existing cached responses is not cacheable.</source>
          <target state="translated">Если новый кэшируемый ответ (см. Разделы &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt; , &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt; , &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt; и &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt; ) получен от ресурса, в то время как любые существующие ответы для того же ресурса кэшируются, кеш ДОЛЖЕН использовать новый ответ для ответа на текущий запрос. Он МОЖЕТ вставить его в кеш-хранилище и МОЖЕТ, если он отвечает всем другим требованиям, использовать его для ответа на любые будущие запросы, которые ранее вызвали возврат старого ответа. Если он вставляет новый ответ в кэш-память, применяются правила из &lt;a href=&quot;#section-13.5.3&quot;&gt;раздела 13.5.3&lt;/a&gt; . Примечание: новый ответ, имеющий более старое значение заголовка Date, чем существующие кэшированные ответы, не кэшируется.</target>
        </trans-unit>
        <trans-unit id="e58c73fa3ef27580bf7799dda53dd96a70453ff2" translate="yes" xml:space="preserve">
          <source>If a request goes through multiple proxies, the IP addresses of each successive proxy is listed. This means, the right-most IP address is the IP address of the most recent proxy and the left-most IP address is the IP address of the originating client.</source>
          <target state="translated">Если запрос проходит через несколько прокси-серверов,то IP-адреса каждого последовательного прокси-сервера перечисляются.Это означает,что самый правый IP-адрес-это IP-адрес последнего прокси,а самый левый IP-адрес-это IP-адрес клиента-инициатора.</target>
        </trans-unit>
        <trans-unit id="e2c3c58894ac3aaacdbb37189725a1f26ce869ef" translate="yes" xml:space="preserve">
          <source>If a resource exists at the destination and the Overwrite header is
   &quot;T&quot;, then prior to performing the move, the server MUST perform a
   DELETE with &quot;Depth: infinity&quot; on the destination resource.  If the
   Overwrite header is set to &quot;F&quot;, then the operation will fail.</source>
          <target state="translated">Если ресурс существует в месте назначения,а заголовок &quot;Overwrite&quot; имеет значение &quot;T&quot;,то перед выполнением перемещения сервер ДОЛЖЕН выполнить DELETE с &quot;Depth:бесконечность&quot; на ресурсе назначения.Если заголовок &quot;Overwrite header&quot; имеет значение &quot;F&quot;,то операция будет неудачной.</target>
        </trans-unit>
        <trans-unit id="22db687e87d90b4a5b61ae1c9f192564fbed5581" translate="yes" xml:space="preserve">
          <source>If a same-site cookie has this attribute, the browser will only send cookies if the request originated from the website that set the cookie. If the request originated from a different URL than the URL of the current location, none of the cookies tagged with the &lt;code&gt;strict&lt;/code&gt; attribute will be included.</source>
          <target state="translated">Если у файла cookie того же сайта есть этот атрибут, браузер будет отправлять файлы cookie только в том случае, если запрос исходит от веб-сайта, который установил файл cookie. Если запрос исходит от URL-адреса, отличного от URL-адреса текущего местоположения, ни один из файлов cookie, помеченных атрибутом &lt;code&gt;strict&lt;/code&gt; , не будет включен.</target>
        </trans-unit>
        <trans-unit id="a78f222e9151b20e3fa58d2b5922efdfbb1c1a0f" translate="yes" xml:space="preserve">
          <source>If a server returns such an error status, the body of the message should contain the list of the available representations of the resources, allowing the user to choose among them.</source>
          <target state="translated">Если сервер возвращает такой статус ошибки,то тело сообщения должно содержать список доступных представлений ресурсов,позволяющих пользователю выбирать из них.</target>
        </trans-unit>
        <trans-unit id="acb751d12ffe14eea97f1844541379bb1e82d026" translate="yes" xml:space="preserve">
          <source>If a single server supports multiple organizations that do not trust
   one another, then it MUST check the values of Location and Content-
   Location headers in responses that are generated under control of
   said organizations to make sure that they do not attempt to
   invalidate resources over which they have no authority.</source>
          <target state="translated">Если один сервер поддерживает несколько организаций,которые не доверяют друг другу,то он ДОЛЖЕН проверять значения заголовков Location и Content-Location в ответах,которые генерируются под контролем указанных организаций,чтобы убедиться,что они не пытаются сделать недействительными ресурсы,на которые у них нет полномочий.</target>
        </trans-unit>
        <trans-unit id="0034277126e29616d67034416858786a6bf01601" translate="yes" xml:space="preserve">
          <source>If a user signs out of your website or service, you might want to remove locally stored data. You can achieve that by adding the &lt;code&gt;Clear-Site-Data&lt;/code&gt; header to the response of https://example.com/logout:</source>
          <target state="translated">Если пользователь выходит из вашего веб-сайта или службы, вы можете удалить локально сохраненные данные. Вы можете добиться этого, добавив заголовок &lt;code&gt;Clear-Site-Data&lt;/code&gt; в ответ https://example.com/logout:</target>
        </trans-unit>
        <trans-unit id="28708bd5ed063a05bc0c1ffae01007cff1ddad84" translate="yes" xml:space="preserve">
          <source>If a user signs out of your website or service, you might want to remove locally stored data. You can achieve that by adding the &lt;code&gt;Clear-Site-Data&lt;/code&gt; header when sending the page confirming that logging out from the site has been accomplished successfully (https://example.com/logout, for example):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5c04bfd2a5924b2636ab2156504c08859b88e5" translate="yes" xml:space="preserve">
          <source>If a website accepts a connection through HTTP and redirects to HTTPS, visitors may initially communicate with the non-encrypted version of the site before being redirected, if, for example, the visitor types http://www.foo.com/ or even just foo.com. This creates an opportunity for a man-in-the-middle attack. The redirect could be exploited to direct visitors to a malicious site instead of the secure version of the original site.</source>
          <target state="translated">Если веб-сайт принимает соединение через HTTP и перенаправляет на HTTPS,посетители могут сначала связаться с незашифрованной версией сайта,прежде чем перенаправляться,если,например,посетитель набирает http://www.foo.com/или даже просто foo.com.Это создает возможность для атаки типа &quot;человек в середине&quot;.Редирект может быть использован для направления посетителей на вредоносный сайт вместо безопасной версии оригинального сайта.</target>
        </trans-unit>
        <trans-unit id="c5d743f58d38a06b0efb87624e4399a8e4fa3b88" translate="yes" xml:space="preserve">
          <source>If all proxies are down, and there was no DIRECT option specified, the browser will ask if proxies should be temporarily ignored, and direct connections attempted. After 20 minutes, the browser will ask if proxies should be retried, asking again after an additional 40 minutes. Queries will continue, always adding 20 minutes to the elapsed time between queries.</source>
          <target state="translated">Если все прокси не работают,и не указана опция DIRECT,браузер спросит,следует ли временно игнорировать прокси,а также делать попытки прямого подключения.Через 20 минут браузер спросит,следует ли перепробовать прокси,и спросит еще раз через 40 минут.Запросы будут продолжаться,всегда добавляя 20 минут к истекшему времени между запросами.</target>
        </trans-unit>
        <trans-unit id="24f0c3aae5a8cb6b90479558f98a655abee38832" translate="yes" xml:space="preserve">
          <source>If an HTTP/1.1 client sends a request which includes a request body,
   but which does not include an Expect request-header field with the
   &quot;100-continue&quot; expectation, and if the client is not directly
   connected to an HTTP/1.1 origin server, and if the client sees the
   connection close before receiving any status from the server, the
   client SHOULD retry the request.  If the client does retry this
   request, it MAY use the following &quot;binary exponential backoff&quot;
   algorithm to be assured of obtaining a reliable response:

      1. Initiate a new connection to the server

      2. Transmit the request-headers

      3. Initialize a variable R to the estimated round-trip time to the
         server (e.g., based on the time it took to establish the
         connection), or to a constant value of 5 seconds if the round-
         trip time is not available.

      4. Compute T = R * (2**N), where N is the number of previous
         retries of this request.

      5. Wait either for an error response from the server, or for T
         seconds (whichever comes first)

      6. If no error response is received, after T seconds transmit the
         body of the request.

      7. If client sees that the connection is closed prematurely,
         repeat from step 1 until the request is accepted, an error
         response is received, or the user becomes impatient and
         terminates the retry process. 

   If at any point an error status is received, the client

      - SHOULD NOT continue and

      - SHOULD close the connection if it has not completed sending the
        request message.</source>
          <target state="translated">Если клиент HTTP/1.1 посылает запрос,который включает в себя тело запроса,но не содержит поля Expect request-header с ожиданием &quot;100-continue&quot;,и если клиент не соединен напрямую с сервером-источником HTTP/1.1,и если клиент видит соединение закрытым до получения какого-либо статуса от сервера,то клиент ДОЛЖЕН повторить запрос.Если клиент все же повторит запрос,он МОЖЕТ использовать следующий алгоритм &quot;двоичной экспоненциальной обратной связи&quot;,чтобы быть уверенным в получении надежного ответа:1.Инициировать новое соединение с сервером 2.Передать заголовки запроса 3.Инициализировать переменную R на расчетное время обхода сервера (например,исходя из времени,затраченного на установление соединения),или на постоянное значение 5 секунд,если время обхода недоступно.4.Вычислить T=R*(2**N),где N-число предыдущих повторных попыток этого запроса.5.Дождаться либо ответа сервера на ошибку,либо T секунд (в зависимости от того,что наступит раньше)6.Если ответ об ошибке не получен,через T секунд передайте тело запроса.7.Если клиент видит,что соединение преждевременно закрыто,повторите с шага 1 до тех пор,пока запрос не будет принят,ответ об ошибке не будет получен,или пользователь станет нетерпеливым и прекратит процесс повторной попытки.Если в какой-то момент получен ошибочный статус,клиент-НЕ ДОЛЖЕН продолжать и-ПОКАЗАТЬ соединение,если он не завершил отправку сообщения с запросом.</target>
        </trans-unit>
        <trans-unit id="787c64d4a2d625599ff698430e64f8f08ddeb6a2" translate="yes" xml:space="preserve">
          <source>If an origin server does not explicitly specify freshness (e.g. using &lt;a href=&quot;headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header) then a heuristic approach may be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf50575579d857df6c5f0e97dcbebb456e6ad37f" translate="yes" xml:space="preserve">
          <source>If another principal locks a resource that a principal wishes to
   access, it is useful for the second principal to be able to find out
   who the first principal is.  For this purpose the DAV:lockdiscovery
   property is provided.  This property lists all outstanding locks,
   describes their type, and MAY even provide the lock tokens.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the DAV:lockdiscovery property.</source>
          <target state="translated">Если другой директор блокирует ресурс,к которому хочет получить доступ директор,полезно,чтобы второй директор смог узнать,кто первый директор.Для этой цели предоставляется свойство DAV:lock-discovery.Это свойство перечисляет все незавершенные блокировки,описывает их тип,и MAY даже предоставляет маркеры блокировки.Любой DAV-совместимый ресурс,поддерживающий метод блокировки,ДОЛЖЕН поддерживать свойство DAV:lockdiscovery.</target>
        </trans-unit>
        <trans-unit id="4e1966a722bf8f31efed779517aa3c6a04a51ec9" translate="yes" xml:space="preserve">
          <source>If both &lt;strong&gt;wd1 &lt;/strong&gt;and &lt;strong&gt;wd1 &lt;/strong&gt;are defined, the condition is true if the current weekday is in between those two &lt;em&gt;ordered &lt;/em&gt;weekdays. Bounds are inclusive, &lt;em&gt;but the bounds are ordered&lt;/em&gt;. If the &quot;GMT&quot; parameter is specified, times are taken to be in GMT. Otherwise, the local timezone is used.</source>
          <target state="translated">Если определены и &lt;strong&gt;wd1,&lt;/strong&gt; и &lt;strong&gt;wd1&lt;/strong&gt; , условие истинно, если текущий день недели находится между этими двумя &lt;em&gt;упорядоченными&lt;/em&gt; днями недели. Границы инклюзивные, &lt;em&gt;но упорядоченные&lt;/em&gt; . Если указан параметр &amp;laquo;GMT&amp;raquo;, время считается в GMT. В противном случае используется местный часовой пояс.</target>
        </trans-unit>
        <trans-unit id="9452662d9180b8ba3efe3a780c450ae27e07209e" translate="yes" xml:space="preserve">
          <source>If both a &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header are present in the same response, both policies are honored. The policy specified in &lt;code&gt;Content-Security-Policy&lt;/code&gt; headers is enforced while the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; policy generates reports but is not enforced.</source>
          <target state="translated">Если в одном ответе присутствуют как заголовок &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; ,так и&lt;/a&gt; заголовок &lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; , обе политики соблюдаются. Политика, указанная в заголовках &lt;code&gt;Content-Security-Policy&lt;/code&gt; , применяется, в то время как политика &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; генерирует отчеты, но не применяется.</target>
        </trans-unit>
        <trans-unit id="d126e6f1349def738aa84d3d7ade4189f1674e03" translate="yes" xml:space="preserve">
          <source>If both this directive (i.e. via the &lt;code&gt;allow&lt;/code&gt; attribute) and the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute are present on an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element, this directive takes precedence. There was a bug whereby the &lt;code&gt;fullscreen&lt;/code&gt; directive didn't work unless the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute was also present, but this has been fixed as of Firefox 80 (&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1608358&quot;&gt;bug 1608358&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7feb971c53a1e3363d82fc1ef6da1a87db0cb6b" translate="yes" xml:space="preserve">
          <source>If both this directive and the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute are present on an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element, this directive takes precedence.</source>
          <target state="translated">Если и эта директива, и атрибут &lt;code&gt;allowfullscreen&lt;/code&gt; присутствуют в элементе &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; , эта директива имеет приоритет.</target>
        </trans-unit>
        <trans-unit id="62b0316637ce393c10dfd9b58aa37bf2f0a42cdc" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;Content-Language&lt;/code&gt; is specified, the default is that the content is intended for all language audiences. Multiple language tags are also possible, as well as applying the &lt;code&gt;Content-Language&lt;/code&gt; header to various media types and not only to textual documents.</source>
          <target state="translated">Если &lt;code&gt;Content-Language&lt;/code&gt; не указан, по умолчанию контент предназначен для всех языковых аудиторий. Также возможны несколько языковых тегов, а также применение заголовка &lt;code&gt;Content-Language&lt;/code&gt; к различным типам мультимедиа, а не только к текстовым документам.</target>
        </trans-unit>
        <trans-unit id="5f0faef3900e1d15f4d91c1fcfcd5a68d9578e75" translate="yes" xml:space="preserve">
          <source>If no URL scheme is specified for a &lt;code&gt;host-source&lt;/code&gt; and the iframe is loaded from an &lt;code&gt;https&lt;/code&gt; URL, the URL for the page loading the iframe must also be &lt;code&gt;https&lt;/code&gt;, per the W3C spec on &lt;a href=&quot;https://w3c.github.io/webappsec-csp/2/#match-source-expression&quot;&gt;matching source expressions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2432969974e0bf99b152d397b2c719d44cd0439e" translate="yes" xml:space="preserve">
          <source>If no port is given, the default port for the service requested (e.g., &quot;80&quot; for an HTTP URL) is implied.</source>
          <target state="translated">Если порт не указан,подразумевается порт по умолчанию для запрашиваемой службы (например,&quot;80&quot; для HTTP URL).</target>
        </trans-unit>
        <trans-unit id="9619fd8159a262a6e7f8b156f3e9ea6322194094" translate="yes" xml:space="preserve">
          <source>If no port is included, the default port for the service requested (e.g., &lt;code&gt;443&lt;/code&gt; for an HTTPS URL, and &lt;code&gt;80&lt;/code&gt; for an HTTP URL) is implied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e478b06858c696e70a28213656753916abc92ba3" translate="yes" xml:space="preserve">
          <source>If omitted, defaults to the host of the current document URL, not including subdomains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219c745dfe181251ec5c580abc0c14da79c6b291" translate="yes" xml:space="preserve">
          <source>If only a single value is specified (from each category: day, month, year), the function returns a true value only on days that match that specification. If both values are specified, the result is true between those times, including bounds, &lt;em&gt;but the bounds are ordered&lt;/em&gt;.</source>
          <target state="translated">Если указано только одно значение (из каждой категории: день, месяц, год), функция возвращает истинное значение только в дни, соответствующие этой спецификации. Если указаны оба значения, результат будет истинным между этими временами, включая границы, &lt;em&gt;но границы упорядочены&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ebc918364962297bbe2d03e861cdada5a4d5d17c" translate="yes" xml:space="preserve">
          <source>If only a single value is specified (from each category: hour, minute, second), the function returns a true value only at times that match that specification. If both values are specified, the result is true between those times, including bounds, &lt;em&gt;but the bounds are ordered&lt;/em&gt;.</source>
          <target state="translated">Если указано только одно значение (из каждой категории: час, минута, секунда), функция возвращает истинное значение только в моменты времени, соответствующие этой спецификации. Если указаны оба значения, результат будет истинным между этими временами, включая границы, &lt;em&gt;но границы упорядочены&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7ad3b8639eddeee4168cd5b47edae6dcb2df2c3c" translate="yes" xml:space="preserve">
          <source>If only one parameter is present, the function returns a value of true on the weekday that the parameter represents. If the string &quot;GMT&quot; is specified as a second parameter, times are taken to be in GMT. Otherwise, they are assumed to be in the local timezone.</source>
          <target state="translated">Если присутствует только один параметр,функция возвращает значение true в день недели,который представляет параметр.Если в качестве второго параметра указана строка &quot;GMT&quot;,то время принимается равным GMT.В противном случае предполагается,что они находятся в локальном часовом поясе.</target>
        </trans-unit>
        <trans-unit id="b64b7edace3c1de8eea4e9f7cb502c7f66cbbfc3" translate="yes" xml:space="preserve">
          <source>If several ranges are sent back, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;multipart/byteranges&lt;/code&gt; and each fragment covers one range, with &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; describing it.</source>
          <target state="translated">Если несколько диапазонов отправляются обратно, &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; устанавливается на &lt;code&gt;multipart/byteranges&lt;/code&gt; , и каждый фрагмент охватывает один диапазон, с &lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; ,&lt;/a&gt; описывающими его.</target>
        </trans-unit>
        <trans-unit id="78a2139f59af3c201e14f90fe9cef770569b0d29" translate="yes" xml:space="preserve">
          <source>If sites omit the &lt;code&gt;Accept-Ranges&lt;/code&gt; header, they likely don't support for partial requests. Some sites also explicitly send &quot;&lt;code&gt;none&lt;/code&gt;&quot; as a value, indicating no support. In some apps, download managers disable their pause buttons in that case.</source>
          <target state="translated">Если на сайтах &lt;code&gt;Accept-Ranges&lt;/code&gt; заголовок Accept-Ranges , скорее всего, они не поддерживают частичные запросы. Некоторые сайты также явно отправляют &amp;laquo; &lt;code&gt;none&lt;/code&gt; &amp;raquo; в качестве значения, что указывает на отсутствие поддержки. В некоторых приложениях менеджеры загрузок в этом случае отключают свои кнопки паузы.</target>
        </trans-unit>
        <trans-unit id="c8a2e2bc49a74014d19dc3e20faf6d47f4b2c5fb" translate="yes" xml:space="preserve">
          <source>If sites omit the &lt;code&gt;Accept-Ranges&lt;/code&gt; header, they likely don't support partial requests. Some sites also explicitly send &quot;&lt;code&gt;none&lt;/code&gt;&quot; as a value, indicating no support. In some apps, download managers disable their pause buttons in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091a0218219abd0cdbbefc8a401d17bce706512c" translate="yes" xml:space="preserve">
          <source>If that's not possible, then another way is to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7832c9e8ca11a0dc4da645bd06786210e575896b" translate="yes" xml:space="preserve">
          <source>If the &quot;Basic&quot; authentication scheme is used, the credentials are constructed like this:</source>
          <target state="translated">Если используется &quot;Базовая&quot; схема аутентификации,то учетные данные строятся таким образом:</target>
        </trans-unit>
        <trans-unit id="f91174398d0cf4de63fc9e0993886a3f7ebd8264" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt; is present in HTTP responses (and its value isn't &quot;&lt;code&gt;none&lt;/code&gt;&quot;), the server supports range requests. You can check this by issuing a &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request and cURL, for example.</source>
          <target state="translated">Если &lt;a href=&quot;headers/accept-ranges&quot;&gt; &lt;code&gt;Accept-Ranges&lt;/code&gt; &lt;/a&gt; присутствует в HTTP-ответах (и его значение не &amp;laquo; &lt;code&gt;none&lt;/code&gt; &amp;raquo;), сервер поддерживает запросы диапазона. Вы можете проверить это , например, &lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; запрос HEAD и cURL.</target>
        </trans-unit>
        <trans-unit id="1e2bd82bb2d016fc76410dd12a3b0342a93316e7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt; is present in HTTP responses (and its value isn't &quot;&lt;code&gt;none&lt;/code&gt;&quot;), the server supports range requests. You can check this by issuing a &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request with cURL, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c9cc929b4bd0a174617d37fdb2ef2438aa90fc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; can't detect any value specified for this header&amp;mdash;even though the header is included in the response&amp;mdash;this error occurs.</source>
          <target state="translated">Если &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;пользовательский агент&lt;/a&gt; не может обнаружить какое-либо значение, указанное для этого заголовка, даже если заголовок включен в ответ, возникает эта ошибка.</target>
        </trans-unit>
        <trans-unit id="37fea5e541c03ceff1dd1b298e2c8a47aff43276" translate="yes" xml:space="preserve">
          <source>If the CORS configuration isn't setup correctly, the browser console will present an error like &lt;code&gt;&quot;Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite&quot;&lt;/code&gt; indicating that the request was blocked due to violating the CORS security rules. This might not necessarily be a set-up mistake, though. It's possible that the request is in fact intentionally being disallowed by the user's web application and remote external service. However, If the endpoint is meant to be available, some debugging is needed to succeed.</source>
          <target state="translated">Если конфигурация CORS настроена неправильно, в консоли браузера будет отображаться сообщение об ошибке типа &lt;code&gt;&quot;Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite&quot;&lt;/code&gt; что указывает на то, что запрос был заблокирован из-за нарушения безопасности CORS. правила. Однако это не обязательно может быть ошибкой настройки. Возможно, что запрос на самом деле намеренно запрещен веб-приложением пользователя и удаленной внешней службой. Однако, если конечная точка должна быть доступна, для успешного выполнения потребуется некоторая отладка.</target>
        </trans-unit>
        <trans-unit id="dc9c7b7249ed9c2cd26babda62bc7a605dd20286" translate="yes" xml:space="preserve">
          <source>If the CORS request indicated by the preflight request is authorized, the server will respond to the preflight request with a message that indicates the allowed origin, methods and headers. Below we see that &lt;a href=&quot;access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; includes the headers that were requested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ffab7457821dbf47b42281a4936c9c518bf014" translate="yes" xml:space="preserve">
          <source>If the attribute is set to lax, same-site cookies are withheld on cross-domain subrequests, such as calls to load images or frames, but will be sent when a user naviates to the URL from an external site, for example, by following a link.</source>
          <target state="translated">Если атрибут установлен в lax,то куки-файлы с одного и того же сайта удерживаются в междоменных подзапросах,таких как вызовы для загрузки изображений или фреймов,но будут отправлены,когда пользователь перейдет на URL с внешнего сайта,например,по ссылке.</target>
        </trans-unit>
        <trans-unit id="5d7a35532093cac38ce9488b4579d2ba232c9fa7" translate="yes" xml:space="preserve">
          <source>If the client has performed a conditional GET request and access is
   allowed, but the document has not been modified, the server SHOULD
   respond with this status code. The 304 response MUST NOT contain a
   message-body, and thus is always terminated by the first empty line
   after the header fields.

   The response MUST include the following header fields:

      - Date, unless its omission is required by &lt;a href=&quot;#section-14.18.1&quot;&gt;section 14.18.1&lt;/a&gt; 

   If a clockless origin server obeys these rules, and proxies and
   clients add their own Date to any response received without one (as
   already specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-14.19&quot;&gt;[RFC 2068], section&amp;nbsp;14.19&lt;/a&gt;), caches will operate
   correctly.

      - ETag and/or Content-Location, if the header would have been sent
        in a 200 response to the same request

      - Expires, Cache-Control, and/or Vary, if the field-value might
        differ from that sent in any previous response for the same
        variant

   If the conditional GET used a strong cache validator (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt;), the response SHOULD NOT include other entity-headers.
   Otherwise (i.e., the conditional GET used a weak validator), the
   response MUST NOT include other entity-headers; this prevents
   inconsistencies between cached entity-bodies and updated headers.

   If a 304 response indicates an entity not currently cached, then the
   cache MUST disregard the response and repeat the request without the
   conditional.

   If a cache uses a received 304 response to update a cache entry, the
   cache MUST update the entry to reflect any new field values given in
   the response.</source>
          <target state="translated">Если клиент выполнил условный запрос GET и доступ разрешен, но документ не был изменен, сервер ДОЛЖЕН ответить этим кодом состояния. Ответ 304 НЕ ДОЛЖЕН содержать тело сообщения и, следовательно, всегда заканчивается первой пустой строкой после полей заголовка. Ответ ДОЛЖЕН включать следующие поля заголовка: - Дата, если ее пропуск не требуется в соответствии с &lt;a href=&quot;#section-14.18.1&quot;&gt;разделом 14.18.1.&lt;/a&gt; Если исходный сервер без часов подчиняется этим правилам, а прокси-серверы и клиенты добавляют свою собственную дату к любому ответу, полученному без такового (как уже указано &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-14.19&quot;&gt;[RFC 2068], раздел 14.19&lt;/a&gt;) кеши будут работать правильно. - ETag и / или Content-Location, если заголовок был бы отправлен в ответе 200 на тот же запрос - Expires, Cache-Control и / или Vary, если значение поля может отличаться от отправленного в любом предыдущем ответе для того же варианта Если условный GET использовал сильный валидатор кеша (см. &lt;a href=&quot;#section-13.3.3&quot;&gt;раздел &lt;/a&gt;&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt;), ответ НЕ ДОЛЖЕН включать другие заголовки объектов. В противном случае (т. Е. Условный GET использовал слабый валидатор) ответ НЕ ДОЛЖЕН включать другие заголовки объектов; это предотвращает несоответствия между кэшированными телами объектов и обновленными заголовками. Если ответ 304 указывает на объект, который в настоящее время не кэширован, то кэш ДОЛЖЕН игнорировать ответ и повторять запрос без условного обозначения. Если кэш использует полученный ответ 304 для обновления записи кэша, кэш ДОЛЖЕН обновить запись, чтобы отразить любые новые значения полей, указанные в ответе.</target>
        </trans-unit>
        <trans-unit id="1b16cb43ac59e1398b6bbb6871dcb2c0b0c8621f" translate="yes" xml:space="preserve">
          <source>If the client receiving the &lt;code&gt;&quot;426 Upgrade Required&quot;&lt;/code&gt; response is willing and able to upgrade to TLS, it should then start the same process covered above under &lt;a href=&quot;#Client-initiated_upgrade_to_TLS&quot;&gt;Client-initiated upgrade to TLS&lt;/a&gt;.</source>
          <target state="translated">Если клиент, получивший ответ &lt;code&gt;&quot;426 Upgrade Required&quot;&lt;/code&gt; желает и может выполнить обновление до TLS, он должен затем запустить тот же процесс, описанный выше в разделе &amp;laquo; &lt;a href=&quot;#Client-initiated_upgrade_to_TLS&quot;&gt;Инициированное клиентом обновление до TLS&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="280f043319dde7fe251e1850244792cbea213b6e" translate="yes" xml:space="preserve">
          <source>If the data is textual, you can simply embed the text (using the appropriate entities or escapes based on the enclosing document's type). Otherwise, you can specify &lt;code&gt;base64&lt;/code&gt; to embed base64-encoded binary data.</source>
          <target state="translated">Если данные являются текстовыми, вы можете просто встроить текст (используя соответствующие сущности или экраны в зависимости от типа включающего документа). В противном случае вы можете указать &lt;code&gt;base64&lt;/code&gt; для внедрения двоичных данных в кодировке base64.</target>
        </trans-unit>
        <trans-unit id="32b1f46a0b7b90a86ae9e9f167e9ef7cf8038c9c" translate="yes" xml:space="preserve">
          <source>If the data is textual, you can simply embed the text (using the appropriate entities or escapes based on the enclosing document's type). Otherwise, you can specify &lt;code&gt;base64&lt;/code&gt; to embed base64-encoded binary data. You can find more info on MIME types &lt;a href=&quot;mime_types&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;mime_types/complete_list_of_mime_types&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8559d1d219606090271c33a621201ee02497f80" translate="yes" xml:space="preserve">
          <source>If the desired resource width is not known at the time of the request or the resource does not have a display width, the &lt;code&gt;Width&lt;/code&gt; header field can be omitted. If &lt;code&gt;Width&lt;/code&gt; occurs in a message more than once, the last value overrides all previous occurrences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18b5decb40c51cfed52abf66cbdc2d7b99ae4e9" translate="yes" xml:space="preserve">
          <source>If the device is large enough that it's not marked with &amp;ldquo;Mobi&amp;rdquo;, you should serve your desktop site (which, as a best practice, should support touch input anyway, as more desktop machines are appearing with touchscreens).</source>
          <target state="translated">Если устройство достаточно велико, чтобы на нем не было пометки &amp;laquo;Mobi&amp;raquo;, вам следует обслуживать свой настольный сайт (который, как правило, в любом случае должен поддерживать сенсорный ввод, так как все больше настольных компьютеров появляется с сенсорными экранами).</target>
        </trans-unit>
        <trans-unit id="0bbaf264d9f0d932c54c0e04e65ebace7f115760" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="translated">Если хэши не совпадают, это означает, что документ был отредактирован между ними, и &lt;code&gt; Precondition Failed&lt;/code&gt; ошибка &lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; Precondition Failed .</target>
        </trans-unit>
        <trans-unit id="277939955257bc43f4243fef87536e0654d15a25" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd651b3de41c4c0939b139c2bcd1ec691c3efd5" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bde6b2f02854c6b43c647e825f2d4a1429eb84b" translate="yes" xml:space="preserve">
          <source>If the request is being issued using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;, make sure you're not setting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;&lt;code&gt;withCredentials&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если запрос отправляется с использованием &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; , убедитесь, что вы не устанавливаете для параметра &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt; &lt;code&gt;withCredentials&lt;/code&gt; &lt;/a&gt; значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f1a69e15b2780621067297dd234a0594b2b2ffc" translate="yes" xml:space="preserve">
          <source>If the requested method isn't supported, the server will respond with an error.</source>
          <target state="translated">Если запрашиваемый метод не поддерживается,сервер ответит ошибкой.</target>
        </trans-unit>
        <trans-unit id="bd63754e6e7fd0ed5e66293b22c5760094fd4fcf" translate="yes" xml:space="preserve">
          <source>If the resource at a given URL changes, a new &lt;code&gt;Etag&lt;/code&gt; value &lt;em&gt;must&lt;/em&gt; be generated. A comparison of them can determine whether two representations of a resource are the same. Etags are therefore similar to fingerprints, and might also be used for tracking purposes by some servers. They might also be set to persist indefinitely by a tracking server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e618a8054c6dfe27daf59e1f19b56a3219ec450e" translate="yes" xml:space="preserve">
          <source>If the resource at a given URL changes, a new &lt;code&gt;Etag&lt;/code&gt; value must be generated. Etags are therefore similar to fingerprints and might also be used for tracking purposes by some servers. A comparison of them allows to quickly determine whether two representations of a resource are the same, but they might also be set to persist indefinitely by a tracking server.</source>
          <target state="translated">Если ресурс по данному URL-адресу изменяется, необходимо сгенерировать новое значение &lt;code&gt;Etag&lt;/code&gt; . Таким образом, Etags похожи на отпечатки пальцев и также могут использоваться для отслеживания некоторыми серверами. Их сравнение позволяет быстро определить, являются ли два представления ресурса одинаковыми, но они также могут быть настроены на неопределенное время с помощью сервера отслеживания.</target>
        </trans-unit>
        <trans-unit id="6df0a809ea7c0e16c3b4c1d61decdfe31ac868f4" translate="yes" xml:space="preserve">
          <source>If the resource has changed, the server just sends back a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt; OK&lt;/code&gt; response, with the new version of the resource, like if the request wasn't conditional and the client uses this new resource (and caches it).</source>
          <target state="translated">Если ресурс изменился, сервер просто отправляет ответ &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt; OK&lt;/code&gt; с новой версией ресурса, например, если запрос не был условным, и клиент использует этот новый ресурс (и кэширует его).</target>
        </trans-unit>
        <trans-unit id="28dabd823abd95eebd0c73b38250e390477657ad" translate="yes" xml:space="preserve">
          <source>If the resource has not changed, the server sends back a &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; response. This makes the cache fresh again, and the client uses the cached resource. Although there is a response/request round-trip that consumes some resources, this is more efficient than to transmit the whole resource over the wire again.</source>
          <target state="translated">Если ресурс не изменился, сервер отправляет ответ &lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; . Это делает кеш снова свежим, и клиент использует кэшированный ресурс. Хотя существует круговая передача ответа / запроса, которая потребляет некоторые ресурсы, это более эффективно, чем повторная передача всего ресурса по сети.</target>
        </trans-unit>
        <trans-unit id="96d3b1fd891c66341051bdd2445935c9e27b47b5" translate="yes" xml:space="preserve">
          <source>If the resource in question is meant to be widely accessed (just like any HTTP resource accessed by GET), then sending back the &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: *&lt;/code&gt; header will be sufficient, &lt;strong&gt;unless&lt;/strong&gt; the resource needs credentials such as &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and HTTP Authentication information.</source>
          <target state="translated">Если рассматриваемый ресурс предназначен для широкого доступа (как и любой HTTP-ресурс, к которому имеет доступ GET), тогда будет достаточно отправки заголовка &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: *&lt;/code&gt; , &lt;strong&gt;если только&lt;/strong&gt; этому ресурсу не требуются учетные данные, такие как &lt;a href=&quot;cookies&quot;&gt;файлы cookie&lt;/a&gt; и HTTP. Информация для аутентификации.</target>
        </trans-unit>
        <trans-unit id="5afbe977f3fe9a82606049c55808c60ca15cfb67" translate="yes" xml:space="preserve">
          <source>If the resource should be kept restricted based on requester domain, &lt;strong&gt;OR&lt;/strong&gt; if the resource needs to be accessed with credentials (or sets credentials), then filtering by the request's &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header may be necessary, or at least echoing back the requester's &lt;code&gt;Origin&lt;/code&gt; (e.g. &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt;). Additionally, the &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; header will have to be sent. This is discussed in a &lt;a href=&quot;#Credentialed_Requests&quot;&gt;subsequent section&lt;/a&gt;.</source>
          <target state="translated">Если ресурс должен быть ограничен на основе домена реквестере, &lt;strong&gt;или&lt;/strong&gt; если потребности в ресурсах , которые будут доступны с учетными данными (или наборы учетных данных), то фильтрация по запросу в &lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; заголовке может быть необходимым, или по крайней мере , вторя назад реквестера &lt;code&gt;Origin&lt;/code&gt; (например , &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt; ). Кроме того, необходимо будет отправить заголовок &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: true&lt;/code&gt; . Это обсуждается в &lt;a href=&quot;#Credentialed_Requests&quot;&gt;следующем разделе&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c8e2ffc70a619ab233773bc1539c19cb10a2bc1" translate="yes" xml:space="preserve">
          <source>If the response to a &lt;code&gt;HEAD&lt;/code&gt; request shows that a cached URL response is now outdated, the cached copy is invalidated even if no &lt;code&gt;GET&lt;/code&gt; request was made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a622ab8c535a47b0b491a95d39cc072896a324" translate="yes" xml:space="preserve">
          <source>If the result of a &lt;code&gt;HEAD&lt;/code&gt; request shows that a cached resource after a &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request is now outdated, the cache is invalidated, even if no &lt;code&gt;GET&lt;/code&gt; request has been made.</source>
          <target state="translated">Если результат запроса &lt;code&gt;HEAD&lt;/code&gt; показывает, что кэшированный ресурс после запроса &lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; теперь устарел, кеш становится недействительным, даже если запрос &lt;code&gt;GET&lt;/code&gt; не был сделан.</target>
        </trans-unit>
        <trans-unit id="8883378b1d0c73e1288f1ade4a8139bb08b162fd" translate="yes" xml:space="preserve">
          <source>If the selection of the best representation for a response is made by
   an algorithm located at the server, it is called server-driven
   negotiation. Selection is based on the available representations of
   the response (the dimensions over which it can vary; e.g. language,
   content-coding, etc.) and the contents of particular header fields in
   the request message or on other information pertaining to the request
   (such as the network address of the client).

   Server-driven negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to the user agent, or when the server desires to send its
   &quot;best guess&quot; to the client along with the first response (hoping to
   avoid the round-trip delay of a subsequent request if the &quot;best
   guess&quot; is good enough for the user). In order to improve the server's
   guess, the user agent MAY include request header fields (Accept,
   Accept-Language, Accept-Encoding, etc.) which describe its
   preferences for such a response.

   Server-driven negotiation has disadvantages:

      1. It is impossible for the server to accurately determine what
         might be &quot;best&quot; for any given user, since that would require
         complete knowledge of both the capabilities of the user agent
         and the intended use for the response (e.g., does the user want
         to view it on screen or print it on paper?).

      2. Having the user agent describe its capabilities in every
         request can be both very inefficient (given that only a small
         percentage of responses have multiple representations) and a
         potential violation of the user's privacy.

      3. It complicates the implementation of an origin server and the
         algorithms for generating responses to a request. 

      4. It may limit a public cache's ability to use the same response
         for multiple user's requests.

   HTTP/1.1 includes the following request-header fields for enabling
   server-driven negotiation through description of user agent
   capabilities and user preferences: Accept (&lt;a href=&quot;#section-14.1&quot;&gt;section 14.1&lt;/a&gt;), Accept-
   Charset (&lt;a href=&quot;#section-14.2&quot;&gt;section 14.2&lt;/a&gt;), Accept-Encoding (&lt;a href=&quot;#section-14.3&quot;&gt;section 14.3&lt;/a&gt;), Accept-
   Language (&lt;a href=&quot;#section-14.4&quot;&gt;section 14.4&lt;/a&gt;), and User-Agent (&lt;a href=&quot;#section-14.43&quot;&gt;section 14.43&lt;/a&gt;). However, an
   origin server is not limited to these dimensions and MAY vary the
   response based on any aspect of the request, including information
   outside the request-header fields or within extension header fields
   not defined by this specification.

   The Vary  header field can be used to express the parameters the
   server uses to select a representation that is subject to server-
   driven negotiation. See &lt;a href=&quot;#section-13.6&quot;&gt;section 13.6&lt;/a&gt; for use of the Vary header field
   by caches and &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt; for use of the Vary header field by
   servers.</source>
          <target state="translated">Если выбор наилучшего представления для ответа выполняется алгоритмом, расположенным на сервере, это называется согласованием, управляемым сервером. Выбор основан на доступных представлениях ответа (размеры, по которым он может варьироваться; например, язык, кодирование содержимого и т. Д.) И содержимом определенных полей заголовка в сообщении запроса или другой информации, относящейся к запросу (например, как сетевой адрес клиента). Управляемое сервером согласование выгодно, когда алгоритм выбора из доступных представлений трудно описать пользовательскому агенту, или когда сервер желает отправить клиенту свое &amp;laquo;лучшее предположение&amp;raquo; вместе с первым ответом (надеясь избежать двусторонняя задержка последующего запроса, если &quot;наилучшая догадка&quot;достаточно хорош для пользователя). Чтобы улучшить предположение сервера, пользовательский агент МОЖЕТ включать поля заголовка запроса (Accept, Accept-Language, Accept-Encoding и т. Д.), Которые описывают его предпочтения для такого ответа. Управляемое сервером согласование имеет недостатки: 1. Сервер не может точно определить, что может быть &quot;лучшим&quot; для любого данного пользователя, так как это потребует полного знания как возможностей пользовательского агента, так и предполагаемого использования ответа. (например, хочет ли пользователь просмотреть его на экране или распечатать на бумаге?). 2.Если пользовательский агент описывает свои возможности в каждом запросе, это может быть как очень неэффективным (учитывая, что только небольшой процент ответов имеет несколько представлений), так и потенциальным нарушением конфиденциальности пользователя. 3. Это усложняет реализацию исходного сервера и алгоритмов генерации ответов на запрос. 4. Это может ограничить возможность общедоступного кэша использовать один и тот же ответ для запросов нескольких пользователей. HTTP / 1.1 включает следующие поля заголовка запроса для включения согласования, управляемого сервером, посредством описания возможностей пользовательского агента и пользовательских предпочтений: Accept (4. Это может ограничить возможность общедоступного кэша использовать один и тот же ответ для запросов нескольких пользователей. HTTP / 1.1 включает следующие поля заголовка запроса для включения согласования, управляемого сервером, посредством описания возможностей пользовательского агента и пользовательских предпочтений: Accept (4. Это может ограничить возможность общедоступного кэша использовать один и тот же ответ для запросов нескольких пользователей. HTTP / 1.1 включает следующие поля заголовка запроса для включения согласования, управляемого сервером, посредством описания возможностей пользовательского агента и пользовательских предпочтений: Accept (&lt;a href=&quot;#section-14.1&quot;&gt;раздел 14.1&lt;/a&gt; ), Accept-Charset ( &lt;a href=&quot;#section-14.2&quot;&gt;раздел 14.2&lt;/a&gt; ), Accept-Encoding ( &lt;a href=&quot;#section-14.3&quot;&gt;раздел 14.3&lt;/a&gt; ), Accept-Language ( &lt;a href=&quot;#section-14.4&quot;&gt;раздел 14.4&lt;/a&gt; ) и User-Agent ( &lt;a href=&quot;#section-14.43&quot;&gt;раздел 14.43&lt;/a&gt; ). Однако исходный сервер не ограничен этими размерами и МОЖЕТ изменять ответ в зависимости от любого аспекта запроса, включая информацию за пределами полей заголовка запроса или внутри полей заголовка расширения, не определенных в этой спецификации. Поле заголовка Vary может использоваться для выражения параметров, которые сервер использует для выбора представления, которое является предметом согласования, управляемого сервером. См. &lt;a href=&quot;#section-13.6&quot;&gt;Раздел 13.6&lt;/a&gt; для использования поля заголовка Vary кешами и &lt;a href=&quot;#section-14.44&quot;&gt;раздел 14.44.&lt;/a&gt; для использования серверами поля заголовка Vary.</target>
        </trans-unit>
        <trans-unit id="a97009ed5a171d3f2d00627248f02de9b1bd4edb" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does not&lt;/em&gt; support TLS upgrade, or is unable to upgrade to TLS at the time, it responds with a standard HTTP/1.1 response, such as:</source>
          <target state="translated">Если сервер &lt;em&gt;не&lt;/em&gt; поддерживает обновление TLS или не может выполнить обновление до TLS в данный момент, он отвечает стандартным ответом HTTP / 1.1, например:</target>
        </trans-unit>
        <trans-unit id="2c4956e2baa89a364f68e36f2540d46e391032b0" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does&lt;/em&gt; recognize the method, but intentionally does not support it, the appropriate response is &lt;a href=&quot;405&quot;&gt;&lt;code&gt;405 Method Not Allowed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b4ec0bc4d37ddaf3aac7f70b029b83445ca56f2" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does&lt;/em&gt; support TLS upgrade and wishes to permit the upgrade, it responds with the &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; response code, like this:</source>
          <target state="translated">Если сервер &lt;em&gt;выполняет&lt;/em&gt; обновление поддержки TLS и желает , чтобы разрешить обновление, он отвечает с &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; код ответа, как это:</target>
        </trans-unit>
        <trans-unit id="a57f9acb3600d5372bf47b96b972a2c0b7a106b1" translate="yes" xml:space="preserve">
          <source>If the server allows CORS requests to use the &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; method, it responds with an &lt;a href=&quot;access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; response header, which lists &lt;code&gt;DELETE&lt;/code&gt; along with the other methods it supports:</source>
          <target state="translated">Если сервер разрешает запросам CORS использовать метод &lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; , он отвечает заголовком ответа &lt;a href=&quot;access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; , в котором перечисляется &lt;code&gt;DELETE&lt;/code&gt; вместе с другими поддерживаемыми им методами:</target>
        </trans-unit>
        <trans-unit id="be2369485a151abd59881e4ba1cc5463e20c789a" translate="yes" xml:space="preserve">
          <source>If the server can't communicate using the specified version of the WebSocket protocol, it will respond with an error (such as 426 Upgrade Required) that includes in its headers a &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; header with a comma-separated list of the supported protocol versions. If the server does support the requested protocol version, no &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; header is included in the response.</source>
          <target state="translated">Если сервер не может взаимодействовать с использованием указанной версии протокола WebSocket, он ответит ошибкой (например, 426 Upgrade Required), которая включает в свои заголовки заголовок &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; со списком поддерживаемых файлов, разделенных запятыми. версии протокола. Если сервер поддерживает запрошенную версию протокола, в ответ не включается заголовок &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bfc654fb667ab7a47e06dc70b7def2a7620c972" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any character encoding from this request header, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406 Not Acceptable&lt;/code&gt;&lt;/a&gt; error code. But for a better user experience, this is rarely done and the &lt;code&gt;Accept-Charset&lt;/code&gt; header is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae753ebfa7e739c1ebf4391f5ee391f4e94ee3ce" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any matching character set, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) error code. But, for a better user experience, this is rarely done and the more common way is to ignore the &lt;code&gt;Accept-Charset&lt;/code&gt; header in this case.</source>
          <target state="translated">Если сервер не может обслуживать какой-либо соответствующий набор символов, он теоретически может отправить обратно код ошибки &lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt; (неприемлемо). Но для лучшего взаимодействия с пользователем это делается редко, и в этом случае более распространенным способом является игнорирование заголовка &lt;code&gt;Accept-Charset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ca646db299a164f8eaec324da4187a3dc7c934" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any matching language, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) error code. But, for a better user experience, this is rarely done and more common way is to ignore the &lt;code&gt;Accept-Language&lt;/code&gt; header in this case.</source>
          <target state="translated">Если сервер не может обслуживать какой-либо соответствующий язык, он теоретически может отправить обратно код ошибки &lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt; (неприемлемо). Но для лучшего взаимодействия с пользователем это делается редко, и в этом случае более распространенным способом является игнорирование заголовка &lt;code&gt;Accept-Language&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5785d405909bd735e16eff8d00e42ade5e8499d9" translate="yes" xml:space="preserve">
          <source>If the server decides to upgrade the connection, it sends back a &lt;a href=&quot;status/101&quot;&gt;&lt;code&gt;101 Switching Protocols&lt;/code&gt;&lt;/a&gt; response status with an Upgrade header that specifies the protocol(s) being switched to. If it does not (or cannot) upgrade the connection, it ignores the &lt;code&gt;Upgrade&lt;/code&gt; header and sends back a regular response (for example, a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200 OK&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d3214eaff9a427b272921bccd27c1fd179422db" translate="yes" xml:space="preserve">
          <source>If the server has a preferred choice, it should generate a &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">Если у сервера есть предпочтительный выбор, он должен сгенерировать заголовок &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e05c84402fda441286aba0b966f3789dbf6191c3" translate="yes" xml:space="preserve">
          <source>If the server is unable to switch to HTTP/2 for any reason, it will reply with a standard HTTP/1 reply after handling the request as normal. So if the request was to fetch a web page which does in fact exist, you would get a standard &lt;code&gt;&quot;HTTP/1.1 200 OK&quot;&lt;/code&gt; response with the web page following the remainder of the header. If the server is able to switch to HTTP/2, a &quot;&lt;code&gt;HTTP/1.1 101 Switching Protocols&quot;&lt;/code&gt; response is sent, which will look like this:</source>
          <target state="translated">Если сервер не может переключиться на HTTP / 2 по какой-либо причине, он ответит стандартным ответом HTTP / 1 после обычной обработки запроса. Таким образом, если бы запрос был на получение веб-страницы, которая действительно существует, вы бы получили стандартный ответ &lt;code&gt;&quot;HTTP/1.1 200 OK&quot;&lt;/code&gt; с веб-страницей, следующей за оставшейся частью заголовка. Если сервер может переключиться на HTTP / 2, будет отправлен ответ &amp;laquo; &lt;code&gt;HTTP/1.1 101 Switching Protocols&quot;&lt;/code&gt; , который будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="b5c0cece345dde55b15ad1ad49b64cab5f6ed8d2" translate="yes" xml:space="preserve">
          <source>If the server is under your control, add the origin of the requesting site to the set of domains permitted access by adding it to the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header's value.</source>
          <target state="translated">Если сервер находится под вашим контролем, добавьте источник запрашивающего сайта в набор доменов, которым разрешен доступ, добавив его к значению заголовка &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62963ebedd2ff72d3bb4b415143d2ac0443881d2" translate="yes" xml:space="preserve">
          <source>If the server sends a response with an &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value that is an explicit origin (rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard), then the response should also include a &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header with the value &lt;code&gt;Origin&lt;/code&gt; &amp;mdash; to indicate to browsers that server responses can differ based on the value of the &lt;code&gt;Origin&lt;/code&gt; request header.</source>
          <target state="translated">Если сервер отправляет ответ со значением &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; , которое является явным источником (а не подстановочным знаком &amp;laquo; &lt;code&gt;*&lt;/code&gt; &amp;raquo;), то ответ также должен включать заголовок ответа &lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; со значением &lt;code&gt;Origin&lt;/code&gt; - для указания браузерам ответы сервера могут отличаться в зависимости от значения заголовка запроса &lt;code&gt;Origin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40ae9d31a1c63c02ebcd60debd2f8b97d5dd7ac9" translate="yes" xml:space="preserve">
          <source>If the server specifies a single origin (that may dynamically change based on the requesting origin as part of a white-list) rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, then the server should also include &lt;code&gt;Origin&lt;/code&gt; in the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header &amp;mdash; to indicate to clients that server responses will differ based on the value of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035b5ed82a9b1755b686239ae88f8e1ef4f77e51" translate="yes" xml:space="preserve">
          <source>If the server specifies a single origin rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, then the server should also include &lt;code&gt;Origin&lt;/code&gt; in the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header &amp;mdash; to indicate to clients that server responses will differ based on the value of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">Если сервер указывает одно происхождение, а не подстановочный знак &amp;laquo; &lt;code&gt;*&lt;/code&gt; &amp;raquo;, то сервер также должен включить &lt;code&gt;Origin&lt;/code&gt; в заголовок ответа &lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; - чтобы указать клиентам, что ответы сервера будут отличаться в зависимости от значения заголовка запроса &lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bdd4b87fdc6a81c461da6befd7c1928bb2e1a6e5" translate="yes" xml:space="preserve">
          <source>If the server supports range requests, you can issue such a request by using the &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header. It indicates the part(s) of a document that the server should return.</source>
          <target state="translated">Если сервер поддерживает запросы диапазона, вы можете отправить такой запрос с помощью заголовка &lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; . Он указывает части документа, которые сервер должен вернуть.</target>
        </trans-unit>
        <trans-unit id="6199750daad48ff639691648a086a49c0a3fd0a7" translate="yes" xml:space="preserve">
          <source>If the server wishes a faster Web site or application response, it is possible for the server to force the opening of more connections. For example, Instead of having all resources on the same domain, say &lt;code&gt;www.example.com&lt;/code&gt;, it could split over several domains, &lt;code&gt;www1.example.com&lt;/code&gt;, &lt;code&gt;www2.example.com&lt;/code&gt;, &lt;code&gt;www3.example.com&lt;/code&gt;. Each of these domains resolve to the &lt;em&gt;same&lt;/em&gt; server, and the Web browser will open 6 connections to each (in our example, boosting the connections to 18). This technique is called &lt;em&gt;domain sharding&lt;/em&gt;.</source>
          <target state="translated">Если серверу требуется более быстрый ответ веб-сайта или приложения, он может принудительно открыть больше соединений. Например, вместо того, чтобы &lt;code&gt;www1.example.com&lt;/code&gt; все ресурсы в одном домене, скажем &lt;code&gt;www.example.com&lt;/code&gt; , он может быть разделен на несколько доменов, www1.example.com , &lt;code&gt;www2.example.com&lt;/code&gt; , &lt;code&gt;www3.example.com&lt;/code&gt; . Каждый из этих доменов относится к &lt;em&gt;одному&lt;/em&gt; и тому &lt;em&gt;же&lt;/em&gt; серверу, и веб-браузер откроет 6 подключений к каждому (в нашем примере количество подключений увеличится до 18). Этот метод называется &lt;em&gt;сегментированием домена&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="633be8e65041e6f678ba0a69d47e73981a12258e" translate="yes" xml:space="preserve">
          <source>If the service your code is accessing using a CORS request is under your control, make sure that it's configured to include your origin in its &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header, and that only one such header is included in responses. The header itself accepts a comma-delineated list of origins, so adding a new origin is not difficult.</source>
          <target state="translated">Если служба, к которой ваш код обращается с помощью запроса CORS, находится под вашим контролем, убедитесь, что она настроена для включения вашего источника в свой заголовок &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; и что в ответы включен только один такой заголовок. Сам заголовок принимает список источников, разделенных запятыми, поэтому добавить новое происхождение не сложно.</target>
        </trans-unit>
        <trans-unit id="d5f87d2c5913a57c8787a092105a04dbd9842ee7" translate="yes" xml:space="preserve">
          <source>If the string is null, no proxies should be used</source>
          <target state="translated">Если строка нулевая,прокси-серверы не должны использоваться</target>
        </trans-unit>
        <trans-unit id="ee70fc1642248dcddd5b4e8e2c3aa5e1fa8b3482" translate="yes" xml:space="preserve">
          <source>If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server must send either a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) or a &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;No Content&lt;/code&gt;) response to indicate successful completion of the request.</source>
          <target state="translated">Если целевой ресурс действительно имеет текущее представление и это представление успешно модифицируется в соответствии с состоянием вложенного представления, то исходный сервер должен отправить ответ &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;OK&lt;/code&gt; ) или &lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;No Content&lt;/code&gt; ), чтобы указать на успешное завершение запрос.</target>
        </trans-unit>
        <trans-unit id="2e56a40e542286dd3f5f24ab9d9b357b4b9363fa" translate="yes" xml:space="preserve">
          <source>If the target resource does not have a current representation and the &lt;code&gt;PUT&lt;/code&gt; request successfully creates one, then the origin server must inform the user agent by sending a &lt;a href=&quot;../status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;Created&lt;/code&gt;) response.</source>
          <target state="translated">Если целевой ресурс не имеет текущего представления и запрос &lt;code&gt;PUT&lt;/code&gt; успешно создает его, то исходный сервер должен проинформировать пользовательский агент, отправив ответ &lt;a href=&quot;../status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;Created&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a21b80ceb96b8a7d43dede98629becf487c2e6a3" translate="yes" xml:space="preserve">
          <source>If the upgrade to TLS succeeds, the server will respond with &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; as described in the previous section. If the upgrade fails, the HTTP/1.1 connection will fail.</source>
          <target state="translated">Если обновление до TLS прошло успешно, сервер ответит &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; как описано в предыдущем разделе. Если обновление завершится неудачно, соединение HTTP / 1.1 не удастся.</target>
        </trans-unit>
        <trans-unit id="27db56e6fbfb8552acb661ab2ec13d5567a5150c" translate="yes" xml:space="preserve">
          <source>If there are hosts (such as the main Web server) that belong to the local domain but are outside the firewall and are only reachable through the proxy server, those exceptions can be handled using the &lt;code&gt;localHostOrDomainIs()&lt;/code&gt; function:</source>
          <target state="translated">Если есть хосты (например, главный веб-сервер), которые принадлежат локальному домену, но находятся за пределами брандмауэра и доступны только через прокси-сервер, эти исключения можно обрабатывать с помощью функции &lt;code&gt;localHostOrDomainIs()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d24ef4f84cb249bfa31f9902d7ae003a91952701" translate="yes" xml:space="preserve">
          <source>If there are multiple semicolon-separated settings, the left-most setting will be used, until Firefox fails to establish the connection to the proxy. In that case, the next value will be used, etc.</source>
          <target state="translated">Если есть несколько настроек с точкой с запятой,то будет использоваться крайняя левая настройка,пока Firefox не установит соединение с прокси-сервером.В этом случае будет использовано следующее значение и т.д.</target>
        </trans-unit>
        <trans-unit id="d35d9172db4121106bcca6f82d93219ec641178d" translate="yes" xml:space="preserve">
          <source>If there are other directives specified, &lt;code&gt;default-src&lt;/code&gt; does not influence them. The following header</source>
          <target state="translated">Если указаны другие директивы, &lt;code&gt;default-src&lt;/code&gt; на них не влияет. Следующий заголовок</target>
        </trans-unit>
        <trans-unit id="f3a3fb9e88e16c02dae3ebc873862c5294ca1f14" translate="yes" xml:space="preserve">
          <source>If there are other directives specified, &lt;code&gt;default-src&lt;/code&gt; does not influence them. The following header:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ef483d4374adee5323181a48fbe2db2ede05c8" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header with the &quot;max-age&quot; or &quot;s-maxage&quot; directive in the response, the &lt;code&gt;Expires&lt;/code&gt; header is ignored.</source>
          <target state="translated">Если в ответе есть заголовок &lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; с директивой &amp;laquo;max-age&amp;raquo; или &amp;laquo;s-maxage&amp;raquo;, заголовок &lt;code&gt;Expires&lt;/code&gt; игнорируется.</target>
        </trans-unit>
        <trans-unit id="3dc7a417b9985cacb686b59815968d89411858de" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header with the &lt;code&gt;max-age&lt;/code&gt; or &lt;code&gt;s-maxage&lt;/code&gt; directive in the response, the &lt;code&gt;Expires&lt;/code&gt; header is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872be7b4525857f39211419c11efc3edbf6a5a96" translate="yes" xml:space="preserve">
          <source>If there is only one range, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of the whole response is set to the type of the document, and a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; is provided.</source>
          <target state="translated">Если есть только один диапазон, &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; всего ответа устанавливается на тип документа, и предоставляется &lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b03947840333522631fcad82cab8f29beea0376" translate="yes" xml:space="preserve">
          <source>If this directive is absent, the user agent will first look for the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive, then the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive, then finally for the &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive, when governing worker execution.</source>
          <target state="translated">Если эта директива отсутствует, пользовательский агент сначала будет искать директиву &lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt; , затем директиву &lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt; , а затем, наконец, директиву &lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; , управляя выполнением worker.</target>
        </trans-unit>
        <trans-unit id="84255b47da2e8395f8cff0945ef69aa9944b73b4" translate="yes" xml:space="preserve">
          <source>If this directive is absent, the user agent will look for the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive (which falls back to the &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive).</source>
          <target state="translated">Если эта директива отсутствует, пользовательский агент будет искать директиву &lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt; (которая возвращается к директиве &lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="905e23650e04dd97cd87c8f1b4781aae080cf34e" translate="yes" xml:space="preserve">
          <source>If this header is delivered with the response at https://example.com/clear-cookies, all cookies on the same domain https://example.com and any subdomains (like https://stage.example.com, etc), will be cleared out.</source>
          <target state="translated">Если этот заголовок будет доставлен с ответом по адресу https://example.com/clear-cookies,то все куки-файлы на одном и том же домене https://example.com и на любых субдоменах (например,https://stage.example.com и т.д.)будут удалены.</target>
        </trans-unit>
        <trans-unit id="84639588f8530b0b81f649bf1306849d6885af93" translate="yes" xml:space="preserve">
          <source>If this optional parameter is specified, pin validation failures are reported to the given URL.</source>
          <target state="translated">Если этот необязательный параметр указан,то по заданному URL будут поступать сообщения о сбоях проверки выводов.</target>
        </trans-unit>
        <trans-unit id="cf9ff6207f9f440fe5c66b863c0c644f87236017" translate="yes" xml:space="preserve">
          <source>If this optional parameter is specified, this rule applies to all of the site's subdomains as well.</source>
          <target state="translated">Если этот необязательный параметр указан,то данное правило распространяется и на все поддомены сайта.</target>
        </trans-unit>
        <trans-unit id="bbeccd91304096ae1ada0d103a494be1d6ecd504" translate="yes" xml:space="preserve">
          <source>If unspecified, the cookie becomes a &lt;strong&gt;session cookie&lt;/strong&gt;. A session finishes when the client shuts down, and session cookies will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6baa688a2748366ccc3dde62ab07310d89508f6a" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;Server-sent events&lt;/a&gt;, make sure &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/withCredentials&quot;&gt;&lt;code&gt;EventSource.withCredentials&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;false&lt;/code&gt; (it's the default value).</source>
          <target state="translated">При использовании &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;событий&lt;/a&gt; , отправленных сервером , убедитесь, что &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/withCredentials&quot;&gt; &lt;code&gt;EventSource.withCredentials&lt;/code&gt; &lt;/a&gt; имеет значение &lt;code&gt;false&lt;/code&gt; (это значение по умолчанию).</target>
        </trans-unit>
        <trans-unit id="bb9e740256ba82627b9a0ee6fa47dc9b15df8b15" translate="yes" xml:space="preserve">
          <source>If using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;, make sure &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;&quot;omit&quot;&lt;/code&gt;.</source>
          <target state="translated">При использовании &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; убедитесь, что &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt; имеет значение &lt;code&gt;&quot;omit&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da0002cfebb5073d0fedbf25422e03f2884be38b" translate="yes" xml:space="preserve">
          <source>If you are not disclosing third-party cookies, consumer trust might get harmed if cookie use is discovered. A clear disclosure (such as in a privacy policy) tends to eliminate any negative effects of a cookie discovery. Some countries also have legislation about cookies. See for example Wikimedia Foundation's &lt;a href=&quot;https://wikimediafoundation.org/wiki/Cookie_statement&quot;&gt;cookie statement&lt;/a&gt;.</source>
          <target state="translated">Если вы не раскрываете сторонние файлы cookie, доверие потребителей может пострадать в случае обнаружения использования файлов cookie. Четкое раскрытие информации (например, в политике конфиденциальности) устраняет любые негативные последствия обнаружения файлов cookie. В некоторых странах также есть законы о файлах cookie. См., Например, &lt;a href=&quot;https://wikimediafoundation.org/wiki/Cookie_statement&quot;&gt;заявление&lt;/a&gt; о файлах cookie Фонда Викимедиа .</target>
        </trans-unit>
        <trans-unit id="bfae6e8214b89d3d41028b5ed5468c1096365497" translate="yes" xml:space="preserve">
          <source>If you are running a robotic user agent (e.g. a crawler), the &lt;code&gt;From&lt;/code&gt; header should be sent, so you can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests.</source>
          <target state="translated">Если вы запускаете роботизированный пользовательский агент (например, поисковый робот), должен быть отправлен заголовок &lt;code&gt;From&lt;/code&gt; , чтобы с вами можно было связаться в случае возникновения проблем на серверах, например, если робот отправляет чрезмерные, нежелательные или недопустимые запросы.</target>
        </trans-unit>
        <trans-unit id="9a96db39060f5e3f83ad7fb3b0569b07c25f59e0" translate="yes" xml:space="preserve">
          <source>If you don't know whether this condition is temporary or permanent, a &lt;a href=&quot;404&quot;&gt;&lt;code&gt;404&lt;/code&gt;&lt;/a&gt; status code should be used instead.</source>
          <target state="translated">Если вы не знаете, является ли это состояние временным или постоянным, вместо этого следует использовать код состояния &lt;a href=&quot;404&quot;&gt; &lt;code&gt;404&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b65a6981b33c89d11ed83bceadd2cf2695bfb77d" translate="yes" xml:space="preserve">
          <source>If you don't want a temporary redirect, an extra parameter (either the HTTP status code to use or the &lt;code&gt;permanent&lt;/code&gt; keyword) can be used to set up a different redirect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104043725295eb7cc9f3df2d7c830d6c1a7855ab" translate="yes" xml:space="preserve">
          <source>If you don't want to set up a temporary redirect, an extra parameter (either the HTTP status code to use or the &lt;code&gt;permanent&lt;/code&gt; keyword) can be used to set up a different redirect:</source>
          <target state="translated">Если вы не хотите настраивать временное перенаправление, можно использовать дополнительный параметр (либо используемый код состояния HTTP, либо &lt;code&gt;permanent&lt;/code&gt; ключевое слово) для настройки другого перенаправления:</target>
        </trans-unit>
        <trans-unit id="bbff3207b07c23fc192059f1baabdc3df63a21a1" translate="yes" xml:space="preserve">
          <source>If you have access to the server you can change your implementation to echo back an origin in the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header. You cannot send back a list of origins, because browsers only accept a value that is either a single origin or null</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e7b5fc4c6d4409c9fc727d5416d3a635b2f290" translate="yes" xml:space="preserve">
          <source>If you need to create a WebSocket connection from scratch, you'll have to handle the handshaking process yourself. After creating the initial HTTP/1.1 session, you need to request the upgrade by adding to a standard request the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers, as follows:</source>
          <target state="translated">Если вам нужно создать соединение WebSocket с нуля, вам придется самостоятельно обрабатывать процесс установления связи. После создания начального сеанса HTTP / 1.1 вам необходимо запросить обновление, добавив к стандартному запросу заголовки &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; , как показано ниже:</target>
        </trans-unit>
        <trans-unit id="95ee0117fd829b54190ed2ff0616a236aeb84cf5" translate="yes" xml:space="preserve">
          <source>If you receive a response that is not in this list, it is a non-standard response, possibly custom to the server's software.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e8f0fd26b3474ef31bc91624748a9e6528cbeb2" translate="yes" xml:space="preserve">
          <source>If you set your site to require SRI for script and styles using this directive:</source>
          <target state="translated">Если вы установили на вашем сайте требование SRI для скриптов и стилей,используя эту директиву:</target>
        </trans-unit>
        <trans-unit id="4990c5b1cf1cb465433d28094a3e92abdf6422d0" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;DENY&lt;/code&gt;, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site. On the other hand, if you specify &lt;code&gt;SAMEORIGIN&lt;/code&gt;, you can still use the page in a frame as long as the site including it in a frame is the same as the one serving the page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0907d966acc8c427e8ea343762038d9ac612b1e1" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;deny&lt;/code&gt;, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site. On the other hand, if you specify &lt;code&gt;sameorigin&lt;/code&gt;, you can still use the page in a frame as long as the site including it in a frame is the same as the one serving the page.</source>
          <target state="translated">Если вы укажете &lt;code&gt;deny&lt;/code&gt; , попытки загрузить страницу во фрейме будут не только неудачными при загрузке с других сайтов, но и попытки сделать это не удастся при загрузке с того же сайта. С другой стороны, если вы укажете &lt;code&gt;sameorigin&lt;/code&gt; , вы все равно можете использовать страницу во фрейме, если сайт, включающий ее во фрейм, совпадает с тем, который обслуживает страницу.</target>
        </trans-unit>
        <trans-unit id="76a40e879843d64bc7dc4946b5e5671cdab0ec07" translate="yes" xml:space="preserve">
          <source>If you still want to receive reporting, but also want to enforce a policy, use the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header with the &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">Если вы по-прежнему хотите получать отчеты, но также хотите применить политику, используйте заголовок &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; с директивой &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fa8f50d92b7325e18f060f06fa0a5d25f9ef058" translate="yes" xml:space="preserve">
          <source>If you want clients to be able to access other headers, you have to list them using the &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; header.</source>
          <target state="translated">Если вы хотите, чтобы клиенты имели доступ к другим заголовкам, вы должны перечислить их с помощью заголовка &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea06dd402f2e9e7e165d67b2c899ce9957d05866" translate="yes" xml:space="preserve">
          <source>If you want clients to be able to access other headers, you have to list them using the &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; header. &lt;a href=&quot;content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; was not part of the original set safelisted response headers [&lt;a href=&quot;https://github.com/whatwg/fetch/pull/626&quot;&gt;ref&lt;/a&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f7d5936f9e8e985a3e0dca82679038018eac65" translate="yes" xml:space="preserve">
          <source>If you want to avoid using user agent detection, you have options!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4dd6049dead6031953d458d3c0344045b4e4cbe" translate="yes" xml:space="preserve">
          <source>If you want to specify a fallback policy in any case the desired policy hasn't got wide enough browser support, use a comma-separated list with the desired policy specified last:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21412475687382be49c1ab666d1bf865da6de6a3" translate="yes" xml:space="preserve">
          <source>If you want to try to avoid using user agent detection, there are options in some cases!</source>
          <target state="translated">Если вы хотите попытаться избежать использования определения пользовательских агентов,в некоторых случаях есть варианты!</target>
        </trans-unit>
        <trans-unit id="0a038ab727911ca95eaa7cfa94eb4a630d6d412b" translate="yes" xml:space="preserve">
          <source>If your application, server, or proxy supports the standardized &lt;code&gt;Forwarded&lt;/code&gt; header, the &lt;a href=&quot;x-forwarded-for&quot;&gt;&lt;code&gt;X-Forwarded-For&lt;/code&gt;&lt;/a&gt; header can be replaced. Note that IPv6 address are quoted and enclosed in square brackets in &lt;code&gt;Forwarded&lt;/code&gt;.</source>
          <target state="translated">Если ваше приложение, сервер или прокси-сервер поддерживает стандартизованный заголовок &lt;code&gt;Forwarded&lt;/code&gt; -, заголовок &lt;a href=&quot;x-forwarded-for&quot;&gt; &lt;code&gt;X-Forwarded-For&lt;/code&gt; &lt;/a&gt; можно заменить. Обратите внимание, что IPv6-адреса заключены в кавычки и квадратные скобки в &lt;code&gt;Forwarded&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90a08b947a2957fe434f390c98a9142e831d9a0f" translate="yes" xml:space="preserve">
          <source>If your site authenticates users, it should regenerate and resend session cookies, even ones that already exist, whenever the user authenticates. This technique helps prevent &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Session_fixation&quot;&gt;session fixation attacks&lt;/a&gt;, where a third party can reuse a user's session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d1c453e83057e2df00a9ddb4d5028bf92c87b6" translate="yes" xml:space="preserve">
          <source>If, instead, you need to adjust the server's behavior, you'll need to change the value of &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; to grant access to the origin from which the client is loaded.</source>
          <target state="translated">Если вместо этого вам нужно настроить поведение сервера, вам нужно будет изменить значение &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; , чтобы предоставить доступ к источнику, из которого загружается клиент.</target>
        </trans-unit>
        <trans-unit id="c4eca4702bbd3334f2af696c9113056ad66a8d93" translate="yes" xml:space="preserve">
          <source>If-Match</source>
          <target state="translated">If-Match</target>
        </trans-unit>
        <trans-unit id="347825cb2f6b585363c705da713b0a01a89c0771" translate="yes" xml:space="preserve">
          <source>If-Match (RFC 2616)</source>
          <target state="translated">If-Match (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="258eadb23d36147c17ca65c583464f10d8beefd5" translate="yes" xml:space="preserve">
          <source>If-Match (RFC 7232)</source>
          <target state="translated">If-Match (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="de1338853da05e0b2ef334c6d2a1bd4efd32b464" translate="yes" xml:space="preserve">
          <source>If-Modified-Since</source>
          <target state="translated">If-Modified-Since</target>
        </trans-unit>
        <trans-unit id="434516b07ea046bbb5c4ac151f7538b608531da2" translate="yes" xml:space="preserve">
          <source>If-Modified-Since (RFC 2616)</source>
          <target state="translated">If-Modified-Since (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="33cf8486927b13aa3ae6d7b4b5c2ba9856f2354e" translate="yes" xml:space="preserve">
          <source>If-Modified-Since (RFC 7232)</source>
          <target state="translated">If-Modified-Since (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="2c743ca76b5ff26374732b33a172bc6386b3aab3" translate="yes" xml:space="preserve">
          <source>If-None-Match</source>
          <target state="translated">If-None-Match</target>
        </trans-unit>
        <trans-unit id="afb97058113ea8024c2b1e30396497276d9e7529" translate="yes" xml:space="preserve">
          <source>If-None-Match (RFC 2616)</source>
          <target state="translated">If-None-Match (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="9d29af1e2a7a4f8c799fff50073e73e2ee90bbe7" translate="yes" xml:space="preserve">
          <source>If-None-Match (RFC 7232)</source>
          <target state="translated">If-None-Match (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="3e610a822745a7648a28ddc376bb31e9d961b787" translate="yes" xml:space="preserve">
          <source>If-Range</source>
          <target state="translated">If-Range</target>
        </trans-unit>
        <trans-unit id="0db4229b3fe70c3cd52654ba3a313677c557a2f3" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 2616)</source>
          <target state="translated">If-диапазон (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="63c9a90407687da95ffa628c724bc3b45d1f6b45" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 7232)</source>
          <target state="translated">If-диапазон (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="d239314fe40c1036bb99b7c1a04ab1559ed5e25b" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 7233)</source>
          <target state="translated">If-диапазон (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="f07ea20e44175d8597a0629b88839dc18660c130" translate="yes" xml:space="preserve">
          <source>If-Unmodified-Since</source>
          <target state="translated">If-Unmodified-Since</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
