<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="735de8f8fe68c649804116d6060235191999625d" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital P</source>
          <target state="translated">Математический Сан-Сериф Капитал P</target>
        </trans-unit>
        <trans-unit id="29453f78bed0ac0167aec213fc953b4c62d1e2a6" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital Q</source>
          <target state="translated">Математический Сан-Сериф Капитал Q</target>
        </trans-unit>
        <trans-unit id="c995d2ad78de57f7575a3af3d18747803e4c1687" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital R</source>
          <target state="translated">Математический Сан-Сериф Капитал R</target>
        </trans-unit>
        <trans-unit id="86c063621a67ac4a769671757cce4a5d84df2027" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital S</source>
          <target state="translated">Математический Сан-Сериф Капитал S</target>
        </trans-unit>
        <trans-unit id="224ffdcfcf894add89408ae517c7ef3d12b95041" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital T</source>
          <target state="translated">Математический Сан-Сериф Капитал Т</target>
        </trans-unit>
        <trans-unit id="2c7b56ae20e1bd42a48cf6aa81701fccda860c69" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital U</source>
          <target state="translated">Математический Сан-Сериф Капитал U</target>
        </trans-unit>
        <trans-unit id="c6d343e7cdd6e8bf0911fa13d73dacf4f22dea79" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital V</source>
          <target state="translated">Математический Сан-Сериф Капитал V</target>
        </trans-unit>
        <trans-unit id="91306c6e45ac8e9e2acaa1fab80a425a1b33da1b" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital W</source>
          <target state="translated">Математический Сан-Сериф Капитал W</target>
        </trans-unit>
        <trans-unit id="ebce32b2d0821c45a9a7308830c29b7d37dcdb54" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital X</source>
          <target state="translated">Математический Сан-Сериф Капитал X</target>
        </trans-unit>
        <trans-unit id="d81dbe4e26a3ebaed62fd22eaa493ab748ec4680" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital Y</source>
          <target state="translated">Математический Сан-Сериф Капитал Y</target>
        </trans-unit>
        <trans-unit id="869c27fb10e3d3dcf153b7c7b1638af395cc7125" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital Z</source>
          <target state="translated">Математический Сан-Сериф Капитал Z</target>
        </trans-unit>
        <trans-unit id="34ccfc2848d139933a3055d1d8f58fb8e1472fec" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Eight</source>
          <target state="translated">Математическая безсерифная восьмерка</target>
        </trans-unit>
        <trans-unit id="8d2508a4068c3fdbdafe2af5b2aafcac618bf0d2" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Five</source>
          <target state="translated">Математический Сан-Сериф цифра пять</target>
        </trans-unit>
        <trans-unit id="3822e65c8f0db884820d647392f6dfa130edf9b1" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Four</source>
          <target state="translated">Математическая сансерическая цифра четыре</target>
        </trans-unit>
        <trans-unit id="badc61e0b60a16ada07cdac85324f16cbc727b53" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Nine</source>
          <target state="translated">Математический Сан-Сериф Девятая цифра</target>
        </trans-unit>
        <trans-unit id="10d87a7149332b0809b1214d8bcdcf6e29a19663" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit One</source>
          <target state="translated">Математический Сан-Сериф Цифра Один</target>
        </trans-unit>
        <trans-unit id="e89064d8fb47e8828be124e56792789b305d76a0" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Seven</source>
          <target state="translated">Математическая Сан-Сериф седьмая цифра</target>
        </trans-unit>
        <trans-unit id="99e28f68677ad323e0b98219df50f9510d3a871a" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Six</source>
          <target state="translated">Математическая сансерическая цифра Шесть</target>
        </trans-unit>
        <trans-unit id="744fd833f6eb766ce62a65a6c97df45a8887d1ed" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Three</source>
          <target state="translated">Математический Сан-Сериф цифра три</target>
        </trans-unit>
        <trans-unit id="b8a26ca79a1a69581e8cc61a81a8a3a79c07474f" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Two</source>
          <target state="translated">Математический Сан-Сериф цифра два</target>
        </trans-unit>
        <trans-unit id="3fae34a9a325d979b30cecaa17316be1866b376e" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Zero</source>
          <target state="translated">Математический Сан-Сериф Ноль Цифры</target>
        </trans-unit>
        <trans-unit id="5d660d000eb9c072b6e0094a3c9dace62de92506" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital A</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал A</target>
        </trans-unit>
        <trans-unit id="0bb1d80b74c20328966d83f84493c44227aa52fa" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital B</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал B</target>
        </trans-unit>
        <trans-unit id="19dd38c3c7119eec64e3d83f2618980e9128de2c" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital C</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал C</target>
        </trans-unit>
        <trans-unit id="edc2cb67c45511abe043b944d5d729ba54cb5bcd" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital D</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал D</target>
        </trans-unit>
        <trans-unit id="917b9c41912eac3d5303b4766db2887ce628c8a5" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital E</source>
          <target state="translated">Математический Сан-Сериф Курсивная Капитал E</target>
        </trans-unit>
        <trans-unit id="778bce7602ff2ccdc6ec50761e791acb740e0730" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital F</source>
          <target state="translated">Математический безсерифельный курсив F</target>
        </trans-unit>
        <trans-unit id="68b8893e17388cda1a0a7a39c7a88b3ae6182fda" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital G</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал G</target>
        </trans-unit>
        <trans-unit id="16bde5679f463c8a8b1b043235f38de648ecfe07" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital H</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал H</target>
        </trans-unit>
        <trans-unit id="a4f8befcaaaac58ae41d69c88ed6752253254e17" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital I</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал I</target>
        </trans-unit>
        <trans-unit id="aa6ad2f00fb3a45176516043a1b8c0fc652e1a7f" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital J</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал J</target>
        </trans-unit>
        <trans-unit id="553a6c8da6f75e3bb2ec4122a0ae3eaf2771cfee" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital K</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал K</target>
        </trans-unit>
        <trans-unit id="4431f70b6eb81b439344cc8a0d63a4bd03785114" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital L</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал L</target>
        </trans-unit>
        <trans-unit id="953c187d78d9c7c73c321255d0f71e989635456e" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital M</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал M</target>
        </trans-unit>
        <trans-unit id="a9521bb0f6d0426eeaa8913eb1ecdaf4654a2add" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital N</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал N</target>
        </trans-unit>
        <trans-unit id="b6fe7eca3981704dfeab71fd77906d954cd3293a" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital O</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал О</target>
        </trans-unit>
        <trans-unit id="afc81f59b7619e6d5ed1c1ef3d4d27fc46d07ef1" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital P</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал P</target>
        </trans-unit>
        <trans-unit id="2eb4837364a43a559e6a9ae01e2cbc8579635ff9" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital Q</source>
          <target state="translated">Математический Сан-Сериф Курсив Q</target>
        </trans-unit>
        <trans-unit id="f4170f808f4a58e651e1f30ec1b38142b5368ac3" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital R</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал R</target>
        </trans-unit>
        <trans-unit id="6ed1e2f57c2908845f6dae446da116d706104106" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital S</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал S</target>
        </trans-unit>
        <trans-unit id="53b834dee864f51c89a23bab556bf05fc17b8728" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital T</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал T</target>
        </trans-unit>
        <trans-unit id="5e7b06b361978376850cc80049273df0d0c888a6" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital U</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал U</target>
        </trans-unit>
        <trans-unit id="ab7105c21ff496b2a879408b719fd0ce05c60ae4" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital V</source>
          <target state="translated">Математический Сан-Сериф Курсивная Капитал V</target>
        </trans-unit>
        <trans-unit id="6d648302dff736caeade12457fe111ebc3ba2254" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital W</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал W</target>
        </trans-unit>
        <trans-unit id="738e60d25b20be185ad0950799ab230e188ffdb7" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital X</source>
          <target state="translated">Математический Сан-Сериф Курсивный Капитал X</target>
        </trans-unit>
        <trans-unit id="e05beb3bd17be0f678f5a1719d237847eee058b4" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital Y</source>
          <target state="translated">Математический Сан-Сериф курсив Y</target>
        </trans-unit>
        <trans-unit id="7955357da8dfd8893b4f5f39485063ede1be84fc" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital Z</source>
          <target state="translated">Математический Сан-Сериф курсив Z</target>
        </trans-unit>
        <trans-unit id="6a669f3f7096e1ffdb56e99437ebdbf11f88ef6a" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small A</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив A</target>
        </trans-unit>
        <trans-unit id="b109cd714b1c3c2dc450aa06407161da6a7f77f6" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small B</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив B</target>
        </trans-unit>
        <trans-unit id="ed75177f5c5301440bae8a62bb75961ccb78625d" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small C</source>
          <target state="translated">Математический Сан-Сериф Малый курсив C</target>
        </trans-unit>
        <trans-unit id="e94f02a8df0dd43a88623ac9f670b7fb9fbca152" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small D</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив D</target>
        </trans-unit>
        <trans-unit id="c313981bfe90ef3251ffc3cc688155b7a81a4eb4" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small E</source>
          <target state="translated">Математический Сан-Сериф Малый курсив E</target>
        </trans-unit>
        <trans-unit id="20e78fbfed5c894b98e25c125e313bc5cf447f2d" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small F</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив F</target>
        </trans-unit>
        <trans-unit id="3ffbb30da62564f9f06a970c553cc75516f84d64" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small G</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив G</target>
        </trans-unit>
        <trans-unit id="88d4569ec69a641f56e15c592b5420acb6756658" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small H</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив H</target>
        </trans-unit>
        <trans-unit id="527de882367bf730b743029d0e5fc34aef66d93a" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small I</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив I</target>
        </trans-unit>
        <trans-unit id="6413e31c10e5d328d5d85c5e9ca95a49c9e21ecf" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small J</source>
          <target state="translated">Математический Сан-Сериф Курсив Малый J</target>
        </trans-unit>
        <trans-unit id="a5db0df4c93acba75eed44c7743aac650ae6c34b" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small K</source>
          <target state="translated">Математический Сан-Сериф Курсив Малый K</target>
        </trans-unit>
        <trans-unit id="3585a33c469a7e9760e4b538bb3569524349f02f" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small L</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив L</target>
        </trans-unit>
        <trans-unit id="8fcffc00a78081012de345221981ed18a237268d" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small M</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив M</target>
        </trans-unit>
        <trans-unit id="b6871fdb2d163e57d612fcabde4992bc15dd003c" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small N</source>
          <target state="translated">Математический Сан-Сериф Курсив Малый N</target>
        </trans-unit>
        <trans-unit id="c937e27b7635715ec5cdbf76e0efa6b56929bc86" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small O</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив O</target>
        </trans-unit>
        <trans-unit id="358d27db8cbac6e138375174968cc6bda89cb8e6" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small P</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив P</target>
        </trans-unit>
        <trans-unit id="d649933b039af4cc6ccb198f879e87c5399cc89b" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small Q</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив Q</target>
        </trans-unit>
        <trans-unit id="6c401dff1e67d9840b91932bda1ef0136fefd859" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small R</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив R</target>
        </trans-unit>
        <trans-unit id="ed0d0e511fd42f8efa03aa03701e48d27d07ee1c" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small S</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив S</target>
        </trans-unit>
        <trans-unit id="665077d5b70b09d0da320a8ffa53c41d3f8524b7" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small T</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив T</target>
        </trans-unit>
        <trans-unit id="c6be34ab09505856e660411e974fd3a42221242a" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small U</source>
          <target state="translated">Математический Сан-Сериф Курсив Малый U</target>
        </trans-unit>
        <trans-unit id="61ee4fac986e65b9f9b38987e86c7d3086e71c29" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small V</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив V</target>
        </trans-unit>
        <trans-unit id="e8c99e3e0c38259d313acad69a434702e64037ac" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small W</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив W</target>
        </trans-unit>
        <trans-unit id="c3b2f3f86234974194e4e947f671cbd926553fcf" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small X</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив X</target>
        </trans-unit>
        <trans-unit id="e72addcb8fd9b49dbcb3722d324fca9afd248498" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small Y</source>
          <target state="translated">Математический Сан-Сериф Курсив Малый Y</target>
        </trans-unit>
        <trans-unit id="66fde99af41406a4cf856fc8adba34e31522e74a" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small Z</source>
          <target state="translated">Математический Сан-Сериф Малый Курсив Z</target>
        </trans-unit>
        <trans-unit id="77c328f6771fa8ddbab73684a774a7092a4b97e4" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small A</source>
          <target state="translated">Математический Сан-Сериф Малый А</target>
        </trans-unit>
        <trans-unit id="c01bd01b4a0fcfea0ba202d6062b1e54eeb2dd91" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small B</source>
          <target state="translated">Математический Сан-Сериф Малый B</target>
        </trans-unit>
        <trans-unit id="8a865bf2832e62512c96769afb09d8f387d805dc" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small C</source>
          <target state="translated">Математический Сан-Сериф Малый C</target>
        </trans-unit>
        <trans-unit id="a5e473505a5d5c7b0468b20d83e0fb0a984c9ccc" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small D</source>
          <target state="translated">Математический Сан-Сериф Малый D</target>
        </trans-unit>
        <trans-unit id="2dd2f6e391e11eb4e9d603594ea1956ef225f063" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small E</source>
          <target state="translated">Математический Сан-Сериф Малый E</target>
        </trans-unit>
        <trans-unit id="6044db6f6f77fb35e8dd548bf74f758c8396e600" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small F</source>
          <target state="translated">Математический Сан-Сериф Малый F</target>
        </trans-unit>
        <trans-unit id="b47402646c107a31f8ed4d8387b0b3d5cfaf96b5" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small G</source>
          <target state="translated">Математический Сан-Сериф Малый G</target>
        </trans-unit>
        <trans-unit id="f6f4b1a5e51ed52919fc443504c4948fbfa6a300" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small H</source>
          <target state="translated">Математический Сан-Сериф Малый H</target>
        </trans-unit>
        <trans-unit id="26f43312416d72451957125c8b8a223b8bdab17e" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small I</source>
          <target state="translated">Математический Сан-Сериф Малый I</target>
        </trans-unit>
        <trans-unit id="f8ad9b39197a0315952dbc6af33952d11c63742f" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small J</source>
          <target state="translated">Математический Сан-Сериф Малый J</target>
        </trans-unit>
        <trans-unit id="13035b445ebd649d777f895052d0296d22cb3b25" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small K</source>
          <target state="translated">Математический Сан-Сериф Малый K</target>
        </trans-unit>
        <trans-unit id="d07f8f7e568456c7898c9a51fabf220c7644359d" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small L</source>
          <target state="translated">Математический Сан-Сериф Малый L</target>
        </trans-unit>
        <trans-unit id="9bb94d1d8a58d7274d3dd8781047baff099aa5d9" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small M</source>
          <target state="translated">Математический Сан-Сериф Малая М</target>
        </trans-unit>
        <trans-unit id="fd8ec5dc12f206ba4aeda9b993990981407358d8" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small N</source>
          <target state="translated">Математический Сан-Сериф Малый N</target>
        </trans-unit>
        <trans-unit id="54b27a0c278909de47f1ee1d25ba4a08ab3413fd" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small O</source>
          <target state="translated">Математический Сан-Сериф Малый O</target>
        </trans-unit>
        <trans-unit id="afe9ac3ff58ec88dbffcb57e6865734fff20ab14" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small P</source>
          <target state="translated">Математический Сан-Сериф Малый P</target>
        </trans-unit>
        <trans-unit id="1d4448fc451d2375a3f1cff51cf083164a229d55" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small Q</source>
          <target state="translated">Математический Сан-Сериф Малый Q</target>
        </trans-unit>
        <trans-unit id="3f782d20e8c19ef7ea890ed9f09494590f2f271e" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small R</source>
          <target state="translated">Математический Сан-Сериф Малый R</target>
        </trans-unit>
        <trans-unit id="d75e3864e82bd62798c29ddf494890eeb20f8150" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small S</source>
          <target state="translated">Математический Сан-Сериф Малый S</target>
        </trans-unit>
        <trans-unit id="5375a5057566851c55c7b5106b2ea5c8174c20bd" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small T</source>
          <target state="translated">Математический Сан-Сериф Малый T</target>
        </trans-unit>
        <trans-unit id="d9191d78c85cd7c4e251a452f6e73569bf5f5777" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small U</source>
          <target state="translated">Математический Сан-Сериф Малый U</target>
        </trans-unit>
        <trans-unit id="ed40757c941d8a43afad6867391b120d2ecc00e9" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small V</source>
          <target state="translated">Математический Сан-Сериф Малый V</target>
        </trans-unit>
        <trans-unit id="7c0555c5968b11f230f8ecd85cf950dafa82a98a" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small W</source>
          <target state="translated">Математический Сан-Сериф Малый W</target>
        </trans-unit>
        <trans-unit id="c18f38cbbd42a240797d31dcafbd56e9e889bfb1" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small X</source>
          <target state="translated">Математический Сан-Сериф Малый X</target>
        </trans-unit>
        <trans-unit id="a0262cfe3582fc841b07ceabd801d3ad5563ecb3" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small Y</source>
          <target state="translated">Математический Сан-Сериф Малый Y</target>
        </trans-unit>
        <trans-unit id="9df2eb71500e01948b6ae94956e34c3050a6c2da" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small Z</source>
          <target state="translated">Математический Сан-Сериф Малый Z</target>
        </trans-unit>
        <trans-unit id="e781204cb8aa75c591f4f8c4e417898fc65c5578" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital A</source>
          <target state="translated">Математический сценарий заглавная буква А</target>
        </trans-unit>
        <trans-unit id="87a5b78d3cc66c44dc0f7e55dbe220c0492cd843" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital C</source>
          <target state="translated">Математический сценарий на заглавной букве C</target>
        </trans-unit>
        <trans-unit id="df68ec98e92ee5f88a61b2936d6f1393a59622fa" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital D</source>
          <target state="translated">Математический сценарий заглавная D</target>
        </trans-unit>
        <trans-unit id="5eaa653854dec24875818d1274419d0d1579b5ff" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital G</source>
          <target state="translated">Математический сценарий заглавная буква G</target>
        </trans-unit>
        <trans-unit id="0b129c86714dfa5b69f78e54ec29708531e991cc" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital J</source>
          <target state="translated">Математический сценарий заглавная буква J</target>
        </trans-unit>
        <trans-unit id="cceece1a02a7b18a7b2a25f72e451f18b78a0e9d" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital K</source>
          <target state="translated">Математический сценарий заглавная К</target>
        </trans-unit>
        <trans-unit id="2e190fcd0e74e49d79bf183058e429a33e67a14a" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital N</source>
          <target state="translated">Математический сценарий заглавная N</target>
        </trans-unit>
        <trans-unit id="a20c7fdd0045e55dd18385e4723cc7c9e9316662" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital O</source>
          <target state="translated">Математический сценарий заглавная O</target>
        </trans-unit>
        <trans-unit id="9330e7fcb0ae4cc996d6da34414a0459a8ee82aa" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital P</source>
          <target state="translated">Математический сценарий заглавная буква P</target>
        </trans-unit>
        <trans-unit id="af18cf1b8f17cee876055abf18963e4d7b6f4f6d" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital Q</source>
          <target state="translated">Математический скрипт заглавный Q</target>
        </trans-unit>
        <trans-unit id="4bb9f4b44eca35819890344af676b337253a7b02" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital S</source>
          <target state="translated">Математический сценарий заглавная буква S</target>
        </trans-unit>
        <trans-unit id="b3d047bb0bdcfa36a10f27a4ba225cb84d7ce8a6" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital T</source>
          <target state="translated">Математический сценарий заглавная Т</target>
        </trans-unit>
        <trans-unit id="6827599cd6e355eb8752adafbb8b32fb87dc337a" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital U</source>
          <target state="translated">Математический сценарий заглавная буква U</target>
        </trans-unit>
        <trans-unit id="c263a0559788ac9d3e77592e2829c6d114cc7d58" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital V</source>
          <target state="translated">Математический сценарий заглавная V</target>
        </trans-unit>
        <trans-unit id="4ba8e4151a26e2953a89d684d69818b9b3c0db84" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital W</source>
          <target state="translated">Математический сценарий Заглавная W</target>
        </trans-unit>
        <trans-unit id="409719dea8db475534ad2211a316bc8456ff4274" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital X</source>
          <target state="translated">Математический скрипт заглавный X</target>
        </trans-unit>
        <trans-unit id="3202429f1ca867375f3227d68c9bf684da8ac22c" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital Y</source>
          <target state="translated">Математический сценарий заглавная буква Y</target>
        </trans-unit>
        <trans-unit id="161d99918ad5b9b0229b3042834c7285d0ecfe64" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital Z</source>
          <target state="translated">Математический скрипт заглавная буква Z</target>
        </trans-unit>
        <trans-unit id="88e5c65d846248c4c565a65cfc2e474605647be5" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small A</source>
          <target state="translated">Математический сценарий Малый А</target>
        </trans-unit>
        <trans-unit id="8bfa40bbb4e6f1d8738ec741d9c445536b61501a" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small B</source>
          <target state="translated">Математический сценарий Малый B</target>
        </trans-unit>
        <trans-unit id="acff05dfba64829fd4b17f980e8d9bf5a7267376" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small C</source>
          <target state="translated">Математический сценарий Малый C</target>
        </trans-unit>
        <trans-unit id="48850c032f6a3a7d79a5286336903c473c781b4b" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small D</source>
          <target state="translated">Математический сценарий Малый D</target>
        </trans-unit>
        <trans-unit id="fa82d93fd22632aa5f4c510b6aaf7f7ad8f24fe9" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small F</source>
          <target state="translated">Математический сценарий Малый F</target>
        </trans-unit>
        <trans-unit id="c1c173a156db5908e1c9cf16d53184b85ad4179d" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small H</source>
          <target state="translated">Математический сценарий Малый H</target>
        </trans-unit>
        <trans-unit id="8d97b76d63cd562f090a430ab9522d2f1d4df9c6" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small I</source>
          <target state="translated">Математический сценарий Малый I</target>
        </trans-unit>
        <trans-unit id="60b7e29c76188f307d6c423da68fa2dc8f11d0e7" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small J</source>
          <target state="translated">Математический сценарий Малый J</target>
        </trans-unit>
        <trans-unit id="df5c1f55e99d3d61b3af1f8de891055be6401a72" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small K</source>
          <target state="translated">Математический сценарий Малый К</target>
        </trans-unit>
        <trans-unit id="1ccd7d2676d7ec8f9a260e02c77004b279c349b5" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small L</source>
          <target state="translated">Математический сценарий Малый L</target>
        </trans-unit>
        <trans-unit id="9529218e212048395f0a5af50f6e560c0b20b6ed" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small M</source>
          <target state="translated">Математический сценарий Малая М</target>
        </trans-unit>
        <trans-unit id="b6947301d6e7abb24efbdb6da1f711dce96aef10" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small N</source>
          <target state="translated">Математический сценарий Малый N</target>
        </trans-unit>
        <trans-unit id="2cd12fce07554f3f68f4fa72dc3c9b8a2288e06b" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small P</source>
          <target state="translated">Математический сценарий Малый P</target>
        </trans-unit>
        <trans-unit id="38c682085a9ff93fd9e8c5ac33f6cb7f2ce12cca" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small Q</source>
          <target state="translated">Математический сценарий Малый Q</target>
        </trans-unit>
        <trans-unit id="75801a5ec6e75edd468ad75e6f4ef52a8e5c801e" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small R</source>
          <target state="translated">Математический сценарий Малый R</target>
        </trans-unit>
        <trans-unit id="47e70e85a32518e50cff199a739e67c5d033b3df" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small S</source>
          <target state="translated">Математический сценарий Малый S</target>
        </trans-unit>
        <trans-unit id="d11168475256d528b51adff5486ce3944c51fbf7" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small T</source>
          <target state="translated">Математический сценарий Маленькая Т</target>
        </trans-unit>
        <trans-unit id="502226569b5eb35c99fd0b79be6ecc923e71df8e" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small U</source>
          <target state="translated">Математический сценарий Малый U</target>
        </trans-unit>
        <trans-unit id="0ac7a9a62e95370706905a88d8fc04443a48b2ba" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small V</source>
          <target state="translated">Математический сценарий Малый V</target>
        </trans-unit>
        <trans-unit id="3d3e2481ffa93292df3a1e3d9be65e95415fb4df" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small W</source>
          <target state="translated">Математический сценарий Малый W</target>
        </trans-unit>
        <trans-unit id="3179527cd0bf80d9e87fa6adb0b4f18e0ffb60ae" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small X</source>
          <target state="translated">Математический сценарий Малый X</target>
        </trans-unit>
        <trans-unit id="591a1c0d4440ce0ae720ca4545a1dc72fbe0fa31" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small Y</source>
          <target state="translated">Математический сценарий Малый Y</target>
        </trans-unit>
        <trans-unit id="ff010d413406b76a23e9dcc5046e4f6aa0d567d8" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small Z</source>
          <target state="translated">Математический сценарий Малый Z</target>
        </trans-unit>
        <trans-unit id="77e774bacbdb4d919d66d929940fc5bdbe59d534" translate="yes" xml:space="preserve">
          <source>Mathematics</source>
          <target state="translated">Mathematics</target>
        </trans-unit>
        <trans-unit id="58947ebc8ff43456c10a258659e8fb435561a3ff" translate="yes" xml:space="preserve">
          <source>Matrix</source>
          <target state="translated">Matrix</target>
        </trans-unit>
        <trans-unit id="5a4970506ff97e891dcbb638ac6c10d9beeb948e" translate="yes" xml:space="preserve">
          <source>Matrix determinant.</source>
          <target state="translated">Детерминант матрицы.</target>
        </trans-unit>
        <trans-unit id="763455038835785197036c60ba888ed8cd2abc12" translate="yes" xml:space="preserve">
          <source>Matrix division using a polyalgorithm. For input matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, the result &lt;code&gt;X&lt;/code&gt; is such that &lt;code&gt;A*X == B&lt;/code&gt; when &lt;code&gt;A&lt;/code&gt; is square. The solver that is used depends upon the structure of &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;A&lt;/code&gt; is upper or lower triangular (or diagonal), no factorization of &lt;code&gt;A&lt;/code&gt; is required and the system is solved with either forward or backward substitution. For non-triangular square matrices, an LU factorization is used.</source>
          <target state="translated">Деление матрицы с помощью полиалгоритма. Для входных матриц &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; результат &lt;code&gt;X&lt;/code&gt; таков, что &lt;code&gt;A*X == B&lt;/code&gt; когда &lt;code&gt;A&lt;/code&gt; квадратный. Решатель , который используется , зависит от структуры &lt;code&gt;A&lt;/code&gt; . Если &lt;code&gt;A&lt;/code&gt; является верхним или нижним треугольником (или диагональным), факторизация &lt;code&gt;A&lt;/code&gt; не требуется, и система решается с прямой или обратной заменой. Для нетреугольных квадратных матриц используется факторизация LU.</target>
        </trans-unit>
        <trans-unit id="3c5da95a5ae0b4da596632b3b7cc1f9110f46b42" translate="yes" xml:space="preserve">
          <source>Matrix exponential, equivalent to $\exp(\log(b)A)$.</source>
          <target state="translated">Матрица экспоненциальная,эквивалентная $\exp(\log(b)A)$.</target>
        </trans-unit>
        <trans-unit id="d5d345531891af4d5ff9cf449cb3b1e46b968471" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the &lt;code&gt;LDLt&lt;/code&gt; factorization of a real &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt;&lt;code&gt;SymTridiagonal&lt;/code&gt;&lt;/a&gt; matrix &lt;code&gt;S&lt;/code&gt; such that &lt;code&gt;S = L*Diagonal(d)*L'&lt;/code&gt;, where &lt;code&gt;L&lt;/code&gt; is a &lt;a href=&quot;#LinearAlgebra.UnitLowerTriangular&quot;&gt;&lt;code&gt;UnitLowerTriangular&lt;/code&gt;&lt;/a&gt; matrix and &lt;code&gt;d&lt;/code&gt; is a vector. The main use of an &lt;code&gt;LDLt&lt;/code&gt; factorization &lt;code&gt;F = ldlt(S)&lt;/code&gt; is to solve the linear system of equations &lt;code&gt;Sx = b&lt;/code&gt; with &lt;code&gt;F\b&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.ldlt&quot;&gt;&lt;code&gt;ldlt&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924fcf97406b11f89e1528156edeb0bfc0067c6c" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the &lt;code&gt;LQ&lt;/code&gt; factorization of a matrix &lt;code&gt;A&lt;/code&gt;. The &lt;code&gt;LQ&lt;/code&gt; decomposition is the &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt;&lt;code&gt;QR&lt;/code&gt;&lt;/a&gt; decomposition of &lt;code&gt;transpose(A)&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.lq&quot;&gt;&lt;code&gt;lq&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12aaced3881a71d1787cefcdb489f847f788675" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the &lt;code&gt;LU&lt;/code&gt; factorization of a square matrix &lt;code&gt;A&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt;&lt;code&gt;lu&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4a6e66ee7e3b3869496bc9841a6ad61c8628fc" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the Bunch-Kaufman factorization of a symmetric or Hermitian matrix &lt;code&gt;A&lt;/code&gt; as &lt;code&gt;P'UDU'P&lt;/code&gt; or &lt;code&gt;P'LDL'P&lt;/code&gt;, depending on whether the upper (the default) or the lower triangle is stored in &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;A&lt;/code&gt; is complex symmetric then &lt;code&gt;U'&lt;/code&gt; and &lt;code&gt;L'&lt;/code&gt; denote the unconjugated transposes, i.e. &lt;code&gt;transpose(U)&lt;/code&gt; and &lt;code&gt;transpose(L)&lt;/code&gt;, respectively. This is the return type of &lt;a href=&quot;#LinearAlgebra.bunchkaufman&quot;&gt;&lt;code&gt;bunchkaufman&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3574ad0c400da103651eecdd956e3b062cdc35b0" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the Cholesky factorization of a dense symmetric/Hermitian positive definite matrix &lt;code&gt;A&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20447ccdfaf58f9ab4d1e53629b88a4e0a41324" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the Schur factorization of a matrix &lt;code&gt;A&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur(_)&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5317626a88971c1522bbb978f1708a516baf677" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the eigenvalue/spectral decomposition of a square matrix &lt;code&gt;A&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1045ede9ec8762e91443cc3b20c1f1e3a81dab" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the generalized Schur factorization of two matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur(_, _)&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c855aa3fe59a37f74ffd7afa54a791b7ecba23" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the generalized eigenvalue/spectral decomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function, when called with two matrix arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0768172e7f95d1da41aa3f848b750d50d5ab6a85" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the generalized singular value decomposition (SVD) of two matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, such that &lt;code&gt;A = F.U*F.D1*F.R0*F.Q'&lt;/code&gt; and &lt;code&gt;B = F.V*F.D2*F.R0*F.Q'&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd(_, _)&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516873b3b274aab33fbfb7c63d4c6bc529f31889" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the pivoted Cholesky factorization of a dense symmetric/Hermitian positive semi-definite matrix &lt;code&gt;A&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky(_, Val(true))&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e534e67e08eb8c4983d753538af87a205b6c6282" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the singular value decomposition (SVD) of a matrix &lt;code&gt;A&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd(_)&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="363bb2b595e809cc54ad9681e48b4f445597455e" translate="yes" xml:space="preserve">
          <source>Matrix factorizations</source>
          <target state="translated">Матричные факторизации</target>
        </trans-unit>
        <trans-unit id="57db3d21b0671f1b99640ca19fb50219ae5719b1" translate="yes" xml:space="preserve">
          <source>Matrix inverse. Computes matrix &lt;code&gt;N&lt;/code&gt; such that &lt;code&gt;M * N = I&lt;/code&gt;, where &lt;code&gt;I&lt;/code&gt; is the identity matrix. Computed by solving the left-division &lt;code&gt;N = M \ I&lt;/code&gt;.</source>
          <target state="translated">Матрица инверсная. Вычисляет матрицу &lt;code&gt;N&lt;/code&gt; такую, что &lt;code&gt;M * N = I&lt;/code&gt; , где &lt;code&gt;I&lt;/code&gt; - единичная матрица. Вычисляется путем решения левого деления &lt;code&gt;N = M \ I&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e1606fb6bae143ac56fdb561605c843975256bf" translate="yes" xml:space="preserve">
          <source>Matrix multiplication.</source>
          <target state="translated">Матричное умножение.</target>
        </trans-unit>
        <trans-unit id="7d6ad85bd5e8146c0b359115e69f993f07f46178" translate="yes" xml:space="preserve">
          <source>Matrix power, equivalent to $\exp(p\log(A))$</source>
          <target state="translated">Матричная сила,эквивалентная $\exp(p\log(A))$</target>
        </trans-unit>
        <trans-unit id="9a15627babff19100b77ee14c6a2d191c015168f" translate="yes" xml:space="preserve">
          <source>Matrix trace. Sums the diagonal elements of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Матричный след. Сумм диагональные элементы &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47adefc07b1eaf2521a7bfa42bbff29f75e20cbc" translate="yes" xml:space="preserve">
          <source>Matrix type</source>
          <target state="translated">Тип матрицы</target>
        </trans-unit>
        <trans-unit id="3fe8138da6605a25163c96dc2d486b42f5cfa3be" translate="yes" xml:space="preserve">
          <source>Matrix type for storing sparse matrices in the &lt;a href=&quot;#man-csc&quot;&gt;Compressed Sparse Column&lt;/a&gt; format. The standard way of constructing SparseMatrixCSC is through the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function. See also &lt;a href=&quot;#SparseArrays.spzeros&quot;&gt;&lt;code&gt;spzeros&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#SparseArrays.spdiagm&quot;&gt;&lt;code&gt;spdiagm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#SparseArrays.sprand&quot;&gt;&lt;code&gt;sprand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab92b63667beffc21eb02656bf328d9fd6e9f0f" translate="yes" xml:space="preserve">
          <source>Matrix type for storing sparse matrices in the &lt;a href=&quot;#man-csc-1&quot;&gt;Compressed Sparse Column&lt;/a&gt; format. The standard way of constructing SparseMatrixCSC is through the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function. See also &lt;a href=&quot;#SparseArrays.spzeros&quot;&gt;&lt;code&gt;spzeros&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#SparseArrays.spdiagm&quot;&gt;&lt;code&gt;spdiagm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#SparseArrays.sprand&quot;&gt;&lt;code&gt;sprand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Тип матрицы для хранения разреженных матриц в формате &lt;a href=&quot;#man-csc-1&quot;&gt;сжатого разреженного столбца&lt;/a&gt; . Стандартный способ создания SparseMatrixCSC - через функцию &lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt; . См. Также &lt;a href=&quot;#SparseArrays.spzeros&quot;&gt; &lt;code&gt;spzeros&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#SparseArrays.spdiagm&quot;&gt; &lt;code&gt;spdiagm&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#SparseArrays.sprand&quot;&gt; &lt;code&gt;sprand&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cf1d39035482544215e965ec3f4bcf6e4f116f2" translate="yes" xml:space="preserve">
          <source>Matrix()</source>
          <target state="translated">Matrix()</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="d6c2803d69788d4452b8dc4ad969409843d18579" translate="yes" xml:space="preserve">
          <source>Measure performance with &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt;&lt;code&gt;@time&lt;/code&gt;&lt;/a&gt; and pay attention to memory allocation</source>
          <target state="translated">Измерьте производительность с помощью &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt; &lt;code&gt;@time&lt;/code&gt; &lt;/a&gt; и обратите внимание на выделение памяти</target>
        </trans-unit>
        <trans-unit id="a1ad84abe6b3edf4c9e138a700204927dc427eeb" translate="yes" xml:space="preserve">
          <source>Measured Angle</source>
          <target state="translated">Измеренный угол</target>
        </trans-unit>
        <trans-unit id="548d26034f0ec59e4ba571d389aad1e24d2ff182" translate="yes" xml:space="preserve">
          <source>Measured Angle Opening Left</source>
          <target state="translated">Измеренный угол открытия слева</target>
        </trans-unit>
        <trans-unit id="232225153f97b40ee5518de7eb39dc75d098d4dd" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Down And Left</source>
          <target state="translated">Измеренный угол с открытой рукой окончания в стрелку указывая вниз и налево</target>
        </trans-unit>
        <trans-unit id="da5a47ecf9d4ab9edb2b0388141f56d7f091db42" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Down And Right</source>
          <target state="translated">Измеренный угол с открытой рукой окончания в стрелку указывая вниз и вправо</target>
        </trans-unit>
        <trans-unit id="f1f55bcc346fe9ea1e99c22cb917cc6c7d8c99c1" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Left And Down</source>
          <target state="translated">Измеренный угол с открытой рукой окончания в стрелку,указывая налево и вниз</target>
        </trans-unit>
        <trans-unit id="e3db8a6b8e85a7c9e47e75c288f9e77c4d508a37" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Left And Up</source>
          <target state="translated">Измеренный угол с открытой рукой заканчивая в стрелку указывая налево и вверх</target>
        </trans-unit>
        <trans-unit id="d59cc58d5c45d17b6ec4add32eecf32d2a5aca3e" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Right And Down</source>
          <target state="translated">Измеренный угол с открытой рукой окончания в стрелку,указывающую направо и вниз</target>
        </trans-unit>
        <trans-unit id="ffb4558ac9229b540c5f26e65f51b285dc62320a" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Right And Up</source>
          <target state="translated">Измеренный угол с открытой рукой окончания в стрелку,указывающую направо и наверх</target>
        </trans-unit>
        <trans-unit id="90883044148da3d38ab4434d41e940637ea65bf1" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Up And Left</source>
          <target state="translated">Измеренный угол с открытой рукой заканчивая в стрелку указывая вверх и влево</target>
        </trans-unit>
        <trans-unit id="f35072267047ae73e8ae3d369f5f9330d4fa3f74" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Up And Right</source>
          <target state="translated">Измеренный угол с открытой рукой заканчивая в стрелку указывая вверх и вправо</target>
        </trans-unit>
        <trans-unit id="358d0fed23b749eaac11fb543b5a985d089a2cb3" translate="yes" xml:space="preserve">
          <source>Measured By</source>
          <target state="translated">Измерено</target>
        </trans-unit>
        <trans-unit id="c8cc86a5dd97c91227baa73199d6011f203981fb" translate="yes" xml:space="preserve">
          <source>Measured Right Angle With Dot</source>
          <target state="translated">Измеренный прямой угол с точкой</target>
        </trans-unit>
        <trans-unit id="8ed7f954e418ed1a12f72567b0854cca2382488e" translate="yes" xml:space="preserve">
          <source>Meat On Bone</source>
          <target state="translated">Мясо на кости</target>
        </trans-unit>
        <trans-unit id="b3d4ec4657cd52d15d0b2fa075de0da3c8fa5fb3" translate="yes" xml:space="preserve">
          <source>Medium Black Circle</source>
          <target state="translated">Средний черный круг</target>
        </trans-unit>
        <trans-unit id="80bc5f0c57c8c58b783aebf3f28eca1630bb79dc" translate="yes" xml:space="preserve">
          <source>Medium Shade</source>
          <target state="translated">Средний Оттенок</target>
        </trans-unit>
        <trans-unit id="ea37963b21d3852b8e65871e86083062b3635c36" translate="yes" xml:space="preserve">
          <source>Medium Small White Circle</source>
          <target state="translated">Средний Малый Белый Круг</target>
        </trans-unit>
        <trans-unit id="669a889ac35ac91706ca35863f49a2df1fe69828" translate="yes" xml:space="preserve">
          <source>Medium White Circle</source>
          <target state="translated">Средний белый круг</target>
        </trans-unit>
        <trans-unit id="26e65e893ae5535d32cd0105721177c58a22b962" translate="yes" xml:space="preserve">
          <source>Melon</source>
          <target state="translated">Melon</target>
        </trans-unit>
        <trans-unit id="1fd79b9555ddf59862d60aa0aa3bb74fb74aae78" translate="yes" xml:space="preserve">
          <source>Memo</source>
          <target state="translated">Memo</target>
        </trans-unit>
        <trans-unit id="89c8a2851d1755cf87365b4a7c55e5551cf878c6" translate="yes" xml:space="preserve">
          <source>Memory</source>
          <target state="translated">Memory</target>
        </trans-unit>
        <trans-unit id="e0efdce50032a40b3a3914e5fc8bfa6cd4288bb5" translate="yes" xml:space="preserve">
          <source>Memory Management</source>
          <target state="translated">Управление памятью</target>
        </trans-unit>
        <trans-unit id="80a13013c630f5f1ec3aaad3aff8839307d7bf31" translate="yes" xml:space="preserve">
          <source>Memory Ownership</source>
          <target state="translated">Право собственности на память</target>
        </trans-unit>
        <trans-unit id="9f595228ed09ac531780d97b13ac4686afb7555d" translate="yes" xml:space="preserve">
          <source>Memory allocation analysis</source>
          <target state="translated">Анализ распределения памяти</target>
        </trans-unit>
        <trans-unit id="3702db8927eec53d800914849f97d95c5310a2c2" translate="yes" xml:space="preserve">
          <source>Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. Do not try to free an object received from a C library with &lt;a href=&quot;../../base/libc/index#Base.Libc.free&quot;&gt;&lt;code&gt;Libc.free&lt;/code&gt;&lt;/a&gt; in Julia, as this may result in the &lt;code&gt;free&lt;/code&gt; function being called via the wrong &lt;code&gt;libc&lt;/code&gt; library and cause Julia to crash. The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid.</source>
          <target state="translated">Выделение и освобождение памяти таких объектов должно производиться вызовами соответствующих процедур очистки в используемых библиотеках, как и в любой программе C. Не пытайтесь освободить объект, полученный из библиотеки C с помощью &lt;a href=&quot;../../base/libc/index#Base.Libc.free&quot;&gt; &lt;code&gt;Libc.free&lt;/code&gt; &lt;/a&gt; в Julia, так как это может привести к вызову &lt;code&gt;free&lt;/code&gt; функции из неправильной библиотеки &lt;code&gt;libc&lt;/code&gt; и вызвать сбой Julia. Обратное (передача объекта, выделенного в Julia для освобождения внешней библиотекой) также недопустимо.</target>
        </trans-unit>
        <trans-unit id="ca752bf22b395d153a231703b547f8f6637b3cdb" translate="yes" xml:space="preserve">
          <source>Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. Do not try to free an object received from a C library with &lt;a href=&quot;../../base/libc/index#Base.Libc.free&quot;&gt;&lt;code&gt;Libc.free&lt;/code&gt;&lt;/a&gt; in Julia, as this may result in the &lt;code&gt;free&lt;/code&gt; function being called via the wrong library and cause the process to abort. The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1e92f6ba02c20d5f0755cdf90826342a6825b7" translate="yes" xml:space="preserve">
          <source>Memory allocation minimum alignment for instances of this type. Can be called on any &lt;code&gt;isconcretetype&lt;/code&gt;.</source>
          <target state="translated">Минимальное выравнивание выделения памяти для экземпляров этого типа. Может быть вызван на любом &lt;code&gt;isconcretetype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="475bc2651561a3c3ff5fe7691308be8b459d93e5" translate="yes" xml:space="preserve">
          <source>Memory layout</source>
          <target state="translated">Макет памяти</target>
        </trans-unit>
        <trans-unit id="6350b7336b67c776ed6dad88b8f36942529d682b" translate="yes" xml:space="preserve">
          <source>Memory-mapped I/O</source>
          <target state="translated">Ввод/вывод с отображением на карте памяти</target>
        </trans-unit>
        <trans-unit id="2794ee86f4e0460023fe30433be8584164633273" translate="yes" xml:space="preserve">
          <source>Mens Symbol</source>
          <target state="translated">мужской символ</target>
        </trans-unit>
        <trans-unit id="606cb109e24d78205b205b9b6b7b2ac8d0838a63" translate="yes" xml:space="preserve">
          <source>Mercury</source>
          <target state="translated">Mercury</target>
        </trans-unit>
        <trans-unit id="4c5719d7c4f2064eda838f77bfedad9f94b74089" translate="yes" xml:space="preserve">
          <source>Merge changes from the annotated commits (captured as &lt;a href=&quot;#LibGit2.GitAnnotated&quot;&gt;&lt;code&gt;GitAnnotated&lt;/code&gt;&lt;/a&gt; objects) &lt;code&gt;anns&lt;/code&gt; into the HEAD of the repository &lt;code&gt;repo&lt;/code&gt;. If &lt;code&gt;fastforward&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;em&gt;only&lt;/em&gt; a fastforward merge is allowed. In this case, if conflicts occur, the merge will fail. Otherwise, if &lt;code&gt;fastforward&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the merge may produce a conflict file which the user will need to resolve.</source>
          <target state="translated">Объединить изменения от аннотированных фиксаций (захваченных в качестве &lt;a href=&quot;#LibGit2.GitAnnotated&quot;&gt; &lt;code&gt;GitAnnotated&lt;/code&gt; &lt;/a&gt; объектов) &lt;code&gt;anns&lt;/code&gt; в голову хранилища &lt;code&gt;repo&lt;/code&gt; . Если &lt;code&gt;fastforward&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , &lt;em&gt;только&lt;/em&gt; FastForward слияние допускается. В этом случае, если возникнут конфликты, слияние не удастся. В противном случае, если &lt;code&gt;fastforward&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; , слияние может привести к возникновению файла конфликта, который пользователю необходимо будет разрешить.</target>
        </trans-unit>
        <trans-unit id="1d3cc5d3f4205143d0a97611bdaec4f401c0400d" translate="yes" xml:space="preserve">
          <source>Merge changes from the annotated commits (captured as &lt;a href=&quot;#LibGit2.GitAnnotated&quot;&gt;&lt;code&gt;GitAnnotated&lt;/code&gt;&lt;/a&gt; objects) &lt;code&gt;anns&lt;/code&gt; into the HEAD of the repository &lt;code&gt;repo&lt;/code&gt;. The keyword arguments are:</source>
          <target state="translated">Объединить изменения от аннотированных фиксаций (захваченных в качестве &lt;a href=&quot;#LibGit2.GitAnnotated&quot;&gt; &lt;code&gt;GitAnnotated&lt;/code&gt; &lt;/a&gt; объектов) &lt;code&gt;anns&lt;/code&gt; в голову хранилища &lt;code&gt;repo&lt;/code&gt; . Аргументы ключевого слова:</target>
        </trans-unit>
        <trans-unit id="a7ce51350f28e713c65619a1185c2251e4fffb1b" translate="yes" xml:space="preserve">
          <source>Merging 3 or more &lt;code&gt;NamedTuple&lt;/code&gt; requires at least Julia 1.1.</source>
          <target state="translated">Для &lt;code&gt;NamedTuple&lt;/code&gt; 3 или более NamedTuple требуется как минимум версия Julia 1.1.</target>
        </trans-unit>
        <trans-unit id="c65670ab4d7e518181387017cc3c5717a9a9ba92" translate="yes" xml:space="preserve">
          <source>Merging write calls:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23dc8e2c77e3a6452c8291f99396015eeb089f0" translate="yes" xml:space="preserve">
          <source>Message filtering can be influenced through the &lt;code&gt;JULIA_DEBUG&lt;/code&gt; environment variable, and serves as an easy way to enable debug logging for a file or module. For example, loading julia with &lt;code&gt;JULIA_DEBUG=loading&lt;/code&gt; will activate &lt;code&gt;@debug&lt;/code&gt; log messages in &lt;code&gt;loading.jl&lt;/code&gt;:</source>
          <target state="translated">На фильтрацию сообщений можно влиять с &lt;code&gt;JULIA_DEBUG&lt;/code&gt; переменной среды JULIA_DEBUG , и она служит простым способом включить ведение журнала отладки для файла или модуля. Например, загрузка джулия с &lt;code&gt;JULIA_DEBUG=loading&lt;/code&gt; активирует &lt;code&gt;@debug&lt;/code&gt; лог сообщений в &lt;code&gt;loading.jl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="22044cc3e10ac89fed15c158bcf4c9dd9df53872" translate="yes" xml:space="preserve">
          <source>Message formatting can be controlled by setting keyword arguments:</source>
          <target state="translated">Форматирование сообщений можно контролировать,задавая аргументы ключевых слов:</target>
        </trans-unit>
        <trans-unit id="8d546a6dea9ff90d517b51c25b35319931ae4e04" translate="yes" xml:space="preserve">
          <source>Meta</source>
          <target state="translated">Meta</target>
        </trans-unit>
        <trans-unit id="222fdf66495fc331b8da7129d7c651c611e92684" translate="yes" xml:space="preserve">
          <source>Meta.@dump</source>
          <target state="translated">Meta.@dump</target>
        </trans-unit>
        <trans-unit id="85a319e78e27958b8ef35a197ddde64ea5769730" translate="yes" xml:space="preserve">
          <source>Meta.@lower</source>
          <target state="translated">Meta.@lower</target>
        </trans-unit>
        <trans-unit id="91f37afbc9d42ff2c695ddd44a635578eac293a4" translate="yes" xml:space="preserve">
          <source>Meta.ParseError</source>
          <target state="translated">Meta.ParseError</target>
        </trans-unit>
        <trans-unit id="ad24faf50729a9f9fa55e867adf30c04801050e3" translate="yes" xml:space="preserve">
          <source>Meta.lower()</source>
          <target state="translated">Meta.lower()</target>
        </trans-unit>
        <trans-unit id="be14fac5e46b300563c5bdc2b385a68630aa88ae" translate="yes" xml:space="preserve">
          <source>Meta.parse()</source>
          <target state="translated">Meta.parse()</target>
        </trans-unit>
        <trans-unit id="28cab2863ff5f2561f57d8cf91121b0008285f3e" translate="yes" xml:space="preserve">
          <source>Metaprogramming</source>
          <target state="translated">Metaprogramming</target>
        </trans-unit>
        <trans-unit id="ce061c8f0bff6c0d69b4ff339bf3343d178939e9" translate="yes" xml:space="preserve">
          <source>Method 1:</source>
          <target state="translated">Метод 1:</target>
        </trans-unit>
        <trans-unit id="1a6137e84cd28d78515d93851515bfcb8ef41c78" translate="yes" xml:space="preserve">
          <source>Method 2:</source>
          <target state="translated">Метод 2:</target>
        </trans-unit>
        <trans-unit id="638b1272755d57118313a429e75cc6d4fb6194fb" translate="yes" xml:space="preserve">
          <source>Method &lt;code&gt;merge!(combine::Union{Function,Type}, args...)&lt;/code&gt; as an alias of &lt;code&gt;mergewith!(combine, args...)&lt;/code&gt; is still available for backward compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2751acf58f63b2b4f024bdf36f12f8f9082677db" translate="yes" xml:space="preserve">
          <source>Method &lt;code&gt;merge(combine::Union{Function,Type}, args...)&lt;/code&gt; as an alias of &lt;code&gt;mergewith(combine, args...)&lt;/code&gt; is still available for backward compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221fbe033b132ab714e88f3065acadd17c36ca4b" translate="yes" xml:space="preserve">
          <source>Method Ambiguities</source>
          <target state="translated">Окружающие факторы метода</target>
        </trans-unit>
        <trans-unit id="333406c36ea643634128264fa62782e940988274" translate="yes" xml:space="preserve">
          <source>Method definitions can optionally have type parameters qualifying the signature:</source>
          <target state="translated">Определения методов могут иметь параметры типа,квалифицирующие подпись:</target>
        </trans-unit>
        <trans-unit id="95ed8dfed2943ba3403b40ab7d40b3018af8b965" translate="yes" xml:space="preserve">
          <source>Method design and the avoidance of ambiguities</source>
          <target state="translated">Проектирование методов и избежание двусмысленности</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="7aed8ffa5a33f9bebcbfeed77cda3dcb44489be3" translate="yes" xml:space="preserve">
          <source>Methods &lt;code&gt;put!&lt;/code&gt;, &lt;code&gt;take!&lt;/code&gt;, &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;isready&lt;/code&gt; and &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; are proxied onto the backing store on the remote process.</source>
          <target state="translated">Методы &lt;code&gt;put!&lt;/code&gt; , &lt;code&gt;take!&lt;/code&gt; , &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;isready&lt;/code&gt; и &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; проксируются в резервное хранилище удаленного процесса.</target>
        </trans-unit>
        <trans-unit id="af99471f8043edf03013b29ba93261c8a6471c77" translate="yes" xml:space="preserve">
          <source>Methods are associated with types, so it is possible to make any arbitrary Julia object &quot;callable&quot; by adding methods to its type. (Such &quot;callable&quot; objects are sometimes called &quot;functors.&quot;)</source>
          <target state="translated">Методы ассоциируются с типами,поэтому можно сделать любой произвольный объект Julia &quot;вызываемым&quot;,добавив к его типу методы.(Такие &quot;вызываемые&quot; объекты иногда называют &quot;functors&quot;).</target>
        </trans-unit>
        <trans-unit id="db723548b522ffbcc5a940d493198540527fdeeb" translate="yes" xml:space="preserve">
          <source>Methods for complex arrays only. Rank-1 update of the Hermitian matrix &lt;code&gt;A&lt;/code&gt; with vector &lt;code&gt;x&lt;/code&gt; as &lt;code&gt;alpha*x*x' + A&lt;/code&gt;. &lt;a href=&quot;#stdlib-blas-uplo&quot;&gt;&lt;code&gt;uplo&lt;/code&gt;&lt;/a&gt; controls which triangle of &lt;code&gt;A&lt;/code&gt; is updated. Returns &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfcd7c3f933331c9493185e98f0d0d125e32c93f" translate="yes" xml:space="preserve">
          <source>Methods for complex arrays only. Rank-1 update of the Hermitian matrix &lt;code&gt;A&lt;/code&gt; with vector &lt;code&gt;x&lt;/code&gt; as &lt;code&gt;alpha*x*x' + A&lt;/code&gt;. &lt;a href=&quot;#stdlib-blas-uplo-1&quot;&gt;&lt;code&gt;uplo&lt;/code&gt;&lt;/a&gt; controls which triangle of &lt;code&gt;A&lt;/code&gt; is updated. Returns &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Только методы для сложных массивов. Ранг-1 обновление эрмитовых матрицы с вектор &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;alpha*x*x' + A&lt;/code&gt; . &lt;a href=&quot;#stdlib-blas-uplo-1&quot;&gt; &lt;code&gt;uplo&lt;/code&gt; &lt;/a&gt; управляет обновлением треугольника &lt;code&gt;A&lt;/code&gt; .Возвращает . &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="adcacb77db29c56837bcd83292ba9c039d0b4aec" translate="yes" xml:space="preserve">
          <source>Methods for complex arrays only. Rank-k update of the Hermitian matrix &lt;code&gt;C&lt;/code&gt; as &lt;code&gt;alpha*A*A' + beta*C&lt;/code&gt; or &lt;code&gt;alpha*A'*A + beta*C&lt;/code&gt; according to &lt;a href=&quot;#stdlib-blas-trans&quot;&gt;&lt;code&gt;trans&lt;/code&gt;&lt;/a&gt;. Only the &lt;a href=&quot;#stdlib-blas-uplo&quot;&gt;&lt;code&gt;uplo&lt;/code&gt;&lt;/a&gt; triangle of &lt;code&gt;C&lt;/code&gt; is updated. Returns &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4465dbd291638c2e6d39be89b1495ed836d260fd" translate="yes" xml:space="preserve">
          <source>Methods for complex arrays only. Rank-k update of the Hermitian matrix &lt;code&gt;C&lt;/code&gt; as &lt;code&gt;alpha*A*A' + beta*C&lt;/code&gt; or &lt;code&gt;alpha*A'*A + beta*C&lt;/code&gt; according to &lt;a href=&quot;#stdlib-blas-trans-1&quot;&gt;&lt;code&gt;trans&lt;/code&gt;&lt;/a&gt;. Only the &lt;a href=&quot;#stdlib-blas-uplo-1&quot;&gt;&lt;code&gt;uplo&lt;/code&gt;&lt;/a&gt; triangle of &lt;code&gt;C&lt;/code&gt; is updated. Returns &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">Только методы для сложных массивов. Обновление ранга k эрмитовой матрицы &lt;code&gt;C&lt;/code&gt; как &lt;code&gt;alpha*A*A' + beta*C&lt;/code&gt; или &lt;code&gt;alpha*A'*A + beta*C&lt;/code&gt; соответствии с &lt;a href=&quot;#stdlib-blas-trans-1&quot;&gt; &lt;code&gt;trans&lt;/code&gt; &lt;/a&gt; . Только &lt;a href=&quot;#stdlib-blas-uplo-1&quot;&gt; &lt;code&gt;uplo&lt;/code&gt; &lt;/a&gt; треугольник &lt;code&gt;C&lt;/code&gt; обновляется. Возвращает &lt;code&gt;C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddb20c7b85208cb61ca8f12e86f9eeabdbb2a780" translate="yes" xml:space="preserve">
          <source>Methods for complex arrays only. Returns the &lt;a href=&quot;#stdlib-blas-uplo&quot;&gt;&lt;code&gt;uplo&lt;/code&gt;&lt;/a&gt; triangle of &lt;code&gt;alpha*A*A'&lt;/code&gt; or &lt;code&gt;alpha*A'*A&lt;/code&gt;, according to &lt;a href=&quot;#stdlib-blas-trans&quot;&gt;&lt;code&gt;trans&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0acde9ce1bc4e0bce92e875e5b980c000ea8f3e" translate="yes" xml:space="preserve">
          <source>Methods for complex arrays only. Returns the &lt;a href=&quot;#stdlib-blas-uplo-1&quot;&gt;&lt;code&gt;uplo&lt;/code&gt;&lt;/a&gt; triangle of &lt;code&gt;alpha*A*A'&lt;/code&gt; or &lt;code&gt;alpha*A'*A&lt;/code&gt;, according to &lt;a href=&quot;#stdlib-blas-trans-1&quot;&gt;&lt;code&gt;trans&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Только методы для сложных массивов. Возвращает &lt;a href=&quot;#stdlib-blas-uplo-1&quot;&gt; &lt;code&gt;uplo&lt;/code&gt; &lt;/a&gt; треугольник &lt;code&gt;alpha*A*A'&lt;/code&gt; или &lt;code&gt;alpha*A'*A&lt;/code&gt; , согласно &lt;a href=&quot;#stdlib-blas-trans-1&quot;&gt; &lt;code&gt;trans&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31087378a8bbc77cc90dde57d0b24e402b04e866" translate="yes" xml:space="preserve">
          <source>Methods for working with Iterators.</source>
          <target state="translated">Методы работы с итераторами.</target>
        </trans-unit>
        <trans-unit id="b652fd8af9cd4414355894137d21ed352cdf7a08" translate="yes" xml:space="preserve">
          <source>Methods to implement</source>
          <target state="translated">Методы реализации</target>
        </trans-unit>
        <trans-unit id="c083bff944879d9f528cf185eba0f496bc10a47d" translate="yes" xml:space="preserve">
          <source>Metro</source>
          <target state="translated">Metro</target>
        </trans-unit>
        <trans-unit id="242805378404a310345cf70839197bf474f74005" translate="yes" xml:space="preserve">
          <source>Microphone</source>
          <target state="translated">Microphone</target>
        </trans-unit>
        <trans-unit id="c0e7f4f223c04978a94419263b9e43e5ed355d3a" translate="yes" xml:space="preserve">
          <source>Microscope</source>
          <target state="translated">Microscope</target>
        </trans-unit>
        <trans-unit id="9b1285dbfa3f301ee305a18122073774afa9fefa" translate="yes" xml:space="preserve">
          <source>Middle Dot</source>
          <target state="translated">средняя точка</target>
        </trans-unit>
        <trans-unit id="e408a463c8c8b04535936ec0388890fdb4eb6af4" translate="yes" xml:space="preserve">
          <source>Midline Horizontal Ellipsis</source>
          <target state="translated">Горизонтальный эллипсис средней линии</target>
        </trans-unit>
        <trans-unit id="fa3eb94a0a2b066b71bf209bbf87e72a3a0d9345" translate="yes" xml:space="preserve">
          <source>Milky Way</source>
          <target state="translated">Млечный Путь</target>
        </trans-unit>
        <trans-unit id="8fd89b05553b705a13699d7eda5f3995e28d70d1" translate="yes" xml:space="preserve">
          <source>Millisecond with a minimum width of 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5493525f70ed44ae88e23154562cfe8abb0989f" translate="yes" xml:space="preserve">
          <source>Minibus</source>
          <target state="translated">Minibus</target>
        </trans-unit>
        <trans-unit id="dec22368362321945374f59262ecb815c9ca058d" translate="yes" xml:space="preserve">
          <source>Minidisc</source>
          <target state="translated">Minidisc</target>
        </trans-unit>
        <trans-unit id="f63cdf5a9fb88ddc55332d0332e0e9c814eca99c" translate="yes" xml:space="preserve">
          <source>Minus Sign</source>
          <target state="translated">Знак минус</target>
        </trans-unit>
        <trans-unit id="aa58dd6ee65165aaa980990698cabc9c7f6af021" translate="yes" xml:space="preserve">
          <source>Minus Sign In Triangle</source>
          <target state="translated">Знак минус в треугольнике</target>
        </trans-unit>
        <trans-unit id="4ecfc39673921fa625e7c61530c0920fdc1d6211" translate="yes" xml:space="preserve">
          <source>Minus Sign With Comma Above</source>
          <target state="translated">Знак минус с запятой выше</target>
        </trans-unit>
        <trans-unit id="59ece43cec61f8aa8f09c373d63b6fda09eae8f1" translate="yes" xml:space="preserve">
          <source>Minus Sign With Dot Below</source>
          <target state="translated">Знак минус с точкой ниже</target>
        </trans-unit>
        <trans-unit id="aa51c42418d3ae6a07aefef69aa4b77d1056b220" translate="yes" xml:space="preserve">
          <source>Minus Sign With Falling Dots</source>
          <target state="translated">Сигнал минус с точками падения</target>
        </trans-unit>
        <trans-unit id="6783f03ccd844333eac42ccf91056e1122919617" translate="yes" xml:space="preserve">
          <source>Minus Sign With Rising Dots</source>
          <target state="translated">Знак &quot;минус&quot; с растущими точками</target>
        </trans-unit>
        <trans-unit id="86dc3e39a6aea834eb89a27cfa3557bba083ea09" translate="yes" xml:space="preserve">
          <source>Minus Tilde</source>
          <target state="translated">Минус Тильде</target>
        </trans-unit>
        <trans-unit id="d3cded1fdd470c6cff7ce15251a9d83764ce60c5" translate="yes" xml:space="preserve">
          <source>Minus Tilde + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Минус тильд+комбинация длинного наложения Solidus/непериодического наложения с длинным косым черенком</target>
        </trans-unit>
        <trans-unit id="64857cbc7d90e5ee4db91259927e9d694cb935aa" translate="yes" xml:space="preserve">
          <source>Minus-Or-Plus Sign</source>
          <target state="translated">Знак минус-ор-плюс</target>
        </trans-unit>
        <trans-unit id="8b5948646931ab1583c24f6ce3e01373cd06fe81" translate="yes" xml:space="preserve">
          <source>Minute with a minimum width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba3a82cd6d42814797e7ed3d7e9faa0082c5d899" translate="yes" xml:space="preserve">
          <source>Mirror callback function</source>
          <target state="translated">Функция обратного вызова зеркала</target>
        </trans-unit>
        <trans-unit id="92185dc52f71ef75dafedf866a3c86e592962f6d" translate="yes" xml:space="preserve">
          <source>Missing</source>
          <target state="translated">Missing</target>
        </trans-unit>
        <trans-unit id="c3453e940833c50faba05ca307352e54c2797a6f" translate="yes" xml:space="preserve">
          <source>Missing Values</source>
          <target state="translated">Пропавшие ценности</target>
        </trans-unit>
        <trans-unit id="eba901a61186cfbbb3bf7ee2deff1c264b66c04d" translate="yes" xml:space="preserve">
          <source>MissingException</source>
          <target state="translated">MissingException</target>
        </trans-unit>
        <trans-unit id="0eb7563cf925b3171d8413443294517880e52bf4" translate="yes" xml:space="preserve">
          <source>Mixed-type comparisons between signed integers, unsigned integers, and floats can be tricky. A great deal of care has been taken to ensure that Julia does them correctly.</source>
          <target state="translated">Сравнения смешанных типов между знаковыми целыми числами,беззнаковыми целыми числами и с плавающей точкой могут быть хитрыми.Большое внимание было уделено тому,чтобы убедиться,что Юлия делает их правильно.</target>
        </trans-unit>
        <trans-unit id="d2447ff507fee803f855bee558dbfc6d355b84f8" translate="yes" xml:space="preserve">
          <source>Mmap.Anonymous</source>
          <target state="translated">Mmap.Anonymous</target>
        </trans-unit>
        <trans-unit id="640194f4398e106565f53f62e3b4b08e399b4acd" translate="yes" xml:space="preserve">
          <source>Mmap.mmap()</source>
          <target state="translated">Mmap.mmap()</target>
        </trans-unit>
        <trans-unit id="9de550013f14e18d13217b11b5824a98b7e97a03" translate="yes" xml:space="preserve">
          <source>Mmap.sync!()</source>
          <target state="translated">Mmap.sync!()</target>
        </trans-unit>
        <trans-unit id="9d079c814c5c6e9525538ebe30bfd478a09629f6" translate="yes" xml:space="preserve">
          <source>Mobile Phone</source>
          <target state="translated">Мобильный телефон</target>
        </trans-unit>
        <trans-unit id="a64a4a32c023fbcae9315c83d229c56e147f1205" translate="yes" xml:space="preserve">
          <source>Mobile Phone Off</source>
          <target state="translated">Мобильный телефон выключен</target>
        </trans-unit>
        <trans-unit id="53d833926ab4deb21fef2ca63517a86d8d13288f" translate="yes" xml:space="preserve">
          <source>Mobile Phone With Rightwards Arrow At Left</source>
          <target state="translated">Мобильный телефон со стрелкой вправо налево</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="f3798f81c7b6fecad2cbfec741314f8a66c0eca3" translate="yes" xml:space="preserve">
          <source>Models</source>
          <target state="translated">Models</target>
        </trans-unit>
        <trans-unit id="378c6a346dad4490cef343a9bacc66eea52f2d4f" translate="yes" xml:space="preserve">
          <source>Modifier Letter Apostrophe</source>
          <target state="translated">Модификатор буквенный апостроф</target>
        </trans-unit>
        <trans-unit id="2f3a9bf639cb1a05417daaf9f821e730d1f2702f" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital A</source>
          <target state="translated">Письмо с заглавной буквы А</target>
        </trans-unit>
        <trans-unit id="f175b2d4ea0317119c9624b31973682c7c727deb" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital B</source>
          <target state="translated">Письмо с заглавной буквы B</target>
        </trans-unit>
        <trans-unit id="54dd7f09fef3cabc35ab4a6d249ebc1a38792897" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital D</source>
          <target state="translated">Письмо с заглавной буквы D</target>
        </trans-unit>
        <trans-unit id="2f393f158eede615c8f37ab6d03675f9222c0871" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital E</source>
          <target state="translated">Письмо с заглавной буквы E</target>
        </trans-unit>
        <trans-unit id="63eb7bc8a5531edaeecb5a5fcbca568ca4e4a2c7" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital G</source>
          <target state="translated">Письмо с заглавной буквы G</target>
        </trans-unit>
        <trans-unit id="6d7c9981939a9073e10475c6d0b8f61192d6c799" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital H</source>
          <target state="translated">Письмо с заглавной буквы H</target>
        </trans-unit>
        <trans-unit id="4413731a9bd52ab5447235f32b2b0de333c8ef4c" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital I</source>
          <target state="translated">Измените письмо с заглавной буквы I</target>
        </trans-unit>
        <trans-unit id="6c4ba7affffc374ec628373cf18e2899f5a87362" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital J</source>
          <target state="translated">Письмо с заглавной буквы J</target>
        </trans-unit>
        <trans-unit id="bd16cf51093e88927626338771cd09c92fdc329a" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital K</source>
          <target state="translated">Письмо с заглавной буквы K</target>
        </trans-unit>
        <trans-unit id="8f79c14762e8c7851d80fadde368877df85d6b23" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital L</source>
          <target state="translated">Изменить буквенное написание заглавной буквы L</target>
        </trans-unit>
        <trans-unit id="016c375485a48852c92c9754957d713deeefdf8d" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital M</source>
          <target state="translated">Письмо с заглавной буквы М</target>
        </trans-unit>
        <trans-unit id="10b6de66c6f3547ae2b2d7b053ff032b096b93de" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital N</source>
          <target state="translated">Изменить письмо с заглавной буквы N</target>
        </trans-unit>
        <trans-unit id="19807e73c0ff4a0127747353ad7be9d70d95a697" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital O</source>
          <target state="translated">Изменить письмо с заглавной буквы O</target>
        </trans-unit>
        <trans-unit id="3a9fa96695c83b6b5b6c060ec7b05141390f4803" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital P</source>
          <target state="translated">Изменить письмо с заглавной буквы P</target>
        </trans-unit>
        <trans-unit id="4378d0c864dc7449a10443763855ea4a59baa102" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital R</source>
          <target state="translated">Изменить письмо с заглавной буквы R</target>
        </trans-unit>
        <trans-unit id="a14533e9d3db66725bdefb9187de7134df849aa8" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital T</source>
          <target state="translated">Письмо с заглавной буквы T</target>
        </trans-unit>
        <trans-unit id="35ea6bcbac7185ab278072e6b19b25634e428e15" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital U</source>
          <target state="translated">Изменить письмо с заглавной буквы U</target>
        </trans-unit>
        <trans-unit id="67aa6839a8f6f282dad5b4931bd1883b098fbdcf" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital V</source>
          <target state="translated">Изменить букву заглавную V</target>
        </trans-unit>
        <trans-unit id="4ecfbd95ed7aef4b0c5960f7276af7528f3e1013" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital W</source>
          <target state="translated">Письмо с заглавной буквы W</target>
        </trans-unit>
        <trans-unit id="b949c25ddb1024b6b34775063c8ed4ff05dc6741" translate="yes" xml:space="preserve">
          <source>Modifier Letter Centred Left Half Ring / Modifier Letter Centered Left Half Ring</source>
          <target state="translated">Модификатор Буква отцентрированная левая половина кольца/Модификатор Буква отцентрированная левая половина кольца</target>
        </trans-unit>
        <trans-unit id="291ae0195a86f866993f9ce88979909a79117fd7" translate="yes" xml:space="preserve">
          <source>Modifier Letter Centred Right Half Ring / Modifier Letter Centered Right Half Ring</source>
          <target state="translated">Буква-модификатор Отцентрированное правое полукруглое кольцо/Буква-модификатор Отцентрированное правое полукруглое кольцо</target>
        </trans-unit>
        <trans-unit id="76e59ea12945ed8b3bae8d350d3c977ff6c9c661" translate="yes" xml:space="preserve">
          <source>Modifier Letter Down Tack</source>
          <target state="translated">Модификатор Буква вниз Tack</target>
        </trans-unit>
        <trans-unit id="34a5b4d80c8920b6836b60ae0b5dafe0f60ff41e" translate="yes" xml:space="preserve">
          <source>Modifier Letter Half Triangular Colon</source>
          <target state="translated">Буква-модификатор Половина треугольной колонки</target>
        </trans-unit>
        <trans-unit id="6fce62d6e4239964c4599dd5d2dced43471e2efa" translate="yes" xml:space="preserve">
          <source>Modifier Letter Low Vertical Line</source>
          <target state="translated">Буква-модификатор Низкая вертикальная линия</target>
        </trans-unit>
        <trans-unit id="b004982c20df1b8fbc334c55f8f0b60cd06099cf" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small A</source>
          <target state="translated">Буква-модификатор Маленькая A</target>
        </trans-unit>
        <trans-unit id="deb88425b7f46b631fd02a62bce97481cd4f4f0f" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Alpha</source>
          <target state="translated">Буква-модификатор Малый Альфа</target>
        </trans-unit>
        <trans-unit id="d2330a25644460fc348b0869a4f3ad148752432b" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small B</source>
          <target state="translated">Буква-модификатор Маленькая B</target>
        </trans-unit>
        <trans-unit id="8722138c1c68f848bb508699377ff45207b606f9" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Beta</source>
          <target state="translated">Буква-модификатор Маленькая бета</target>
        </trans-unit>
        <trans-unit id="e11743c39b0189ca08862d802023884f6ff509de" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small C</source>
          <target state="translated">Буква-модификатор Малый C</target>
        </trans-unit>
        <trans-unit id="ac514cd599f9a3a6730adac579cb5403479d24e7" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Chi</source>
          <target state="translated">Буква-модификатор Малый Ци</target>
        </trans-unit>
        <trans-unit id="25b12af6e54cc3a3e907f64218555b40070c42c1" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small D</source>
          <target state="translated">Буква-модификатор Малый D</target>
        </trans-unit>
        <trans-unit id="646926770eecb21814bebc00456d822dd902b2aa" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Delta</source>
          <target state="translated">Буква-модификатор Маленькая дельта</target>
        </trans-unit>
        <trans-unit id="b4ba7d679d1ff0f323efb3db18337cffb058215e" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small E</source>
          <target state="translated">Буква-модификатор Малый E</target>
        </trans-unit>
        <trans-unit id="23d05b8e8e47a8cc1fe82c0c873feb6eb937c1a0" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small F</source>
          <target state="translated">Буква-модификатор Малый F</target>
        </trans-unit>
        <trans-unit id="e8a3e647a87341c929cd000bd0eedbc0b417f747" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small G</source>
          <target state="translated">Буква-модификатор Малый G</target>
        </trans-unit>
        <trans-unit id="3685b9034b19a696b05b0209aff45ac1353acabb" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Greek Gamma</source>
          <target state="translated">Буква-модификатор Маленькая греческая гамма</target>
        </trans-unit>
        <trans-unit id="29c1c2e647f0e8f126ec82339b9456bd1ebf7261" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Greek Phi</source>
          <target state="translated">Буква-модификатор Маленький греческий Фи</target>
        </trans-unit>
        <trans-unit id="d9c30e3a448db04ac018a8bd5442daf3475c7ba8" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small H</source>
          <target state="translated">Буква-модификатор Маленькая H</target>
        </trans-unit>
        <trans-unit id="6e57ce9744f101dbce99ecdf29c1d13b26269999" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Iota</source>
          <target state="translated">Буква-модификатор Маленькая Iota</target>
        </trans-unit>
        <trans-unit id="9baf4c56dd431ef3ad26edec02f15427fb4f8e94" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small J</source>
          <target state="translated">Буква-модификатор Малый J</target>
        </trans-unit>
        <trans-unit id="fcbede69a2944bdb4d911b826974c6a32312043f" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small K</source>
          <target state="translated">Буква-модификатор Малый K</target>
        </trans-unit>
        <trans-unit id="5d854f258e61e6965bf6816999063efd5ac79b59" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small L</source>
          <target state="translated">Буква-модификатор Малый L</target>
        </trans-unit>
        <trans-unit id="cb37d7c92d1fb26c6ec47e0939092255ffd1ff93" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small M</source>
          <target state="translated">Буква-модификатор Маленькая M</target>
        </trans-unit>
        <trans-unit id="4940f12ed72f76097abffee48c6caf8597c15238" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small O</source>
          <target state="translated">Буква-модификатор Малый O</target>
        </trans-unit>
        <trans-unit id="044a808dd64acb0276529fec8c8eed4151b9e1b3" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Open E</source>
          <target state="translated">Буква-модификатор Маленькая открытая E</target>
        </trans-unit>
        <trans-unit id="c5e8864168c9f7bcc5eaee6e04534f6b0ec03fe6" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small P</source>
          <target state="translated">Буква-модификатор Малый P</target>
        </trans-unit>
        <trans-unit id="5f86982de25f53705d5112c5e339fc1c06461494" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Phi</source>
          <target state="translated">Буква-модификатор Маленький Фи</target>
        </trans-unit>
        <trans-unit id="31b385de66745576cfea4c510f4a9264de0c110c" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small R</source>
          <target state="translated">Буква-модификатор Малый R</target>
        </trans-unit>
        <trans-unit id="63d45af948e161b5baf4097ac61d4ca9bde5eaf9" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small S</source>
          <target state="translated">Буква-модификатор Small S</target>
        </trans-unit>
        <trans-unit id="a00cedabf28dd494f16962a61b3b84c2db750c59" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small T</source>
          <target state="translated">Буква-модификатор Малый T</target>
        </trans-unit>
        <trans-unit id="934e5e0569eba2ae29b6fd7b7f3048216d6ab5b1" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Theta</source>
          <target state="translated">Буква-модификатор Маленькая тета</target>
        </trans-unit>
        <trans-unit id="2be80d92c9166f9508dafa1c3c4a04d968778caf" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small U</source>
          <target state="translated">Буква-модификатор Малый U</target>
        </trans-unit>
        <trans-unit id="70d29e93c6cc783288013cdd5e61222df9f49c57" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small V</source>
          <target state="translated">Буква-модификатор Маленький V</target>
        </trans-unit>
        <trans-unit id="ae6c33276e50f036dcb88fa62fc9ac217fb18388" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small W</source>
          <target state="translated">Буква-модификатор Малый W</target>
        </trans-unit>
        <trans-unit id="30a372f7b079c66d667c70ed8f79a8629876ff27" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small X</source>
          <target state="translated">Буква-модификатор Малый X</target>
        </trans-unit>
        <trans-unit id="a69f6736779681fb0ed1056f1cad5cf275dd9d94" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Y</source>
          <target state="translated">Буква-модификатор Малый Y</target>
        </trans-unit>
        <trans-unit id="0b5f570214eea93dfb2923426c61433c7d0985f7" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Z</source>
          <target state="translated">Буква-модификатор Малый Z</target>
        </trans-unit>
        <trans-unit id="0a1e94c23d8acf4f254ffb7effdc13dfa9335d0c" translate="yes" xml:space="preserve">
          <source>Modifier Letter Triangular Colon</source>
          <target state="translated">Модификатор Буква Треугольная двоеточие</target>
        </trans-unit>
        <trans-unit id="fb2ae7750f3b68bfed15753e6ba40b4fd1614bc0" translate="yes" xml:space="preserve">
          <source>Modifier Letter Up Tack</source>
          <target state="translated">Modifier Letter Up Tack</target>
        </trans-unit>
        <trans-unit id="08c923edc7b9df3dd77fec300568421baabc1855" translate="yes" xml:space="preserve">
          <source>Modifier Letter Vertical Line</source>
          <target state="translated">Модификатор Буква Вертикальная линия</target>
        </trans-unit>
        <trans-unit id="b340178957b37d595f2386a2a7c9f3c1ea3e040d" translate="yes" xml:space="preserve">
          <source>Modifies &lt;code&gt;dict&lt;/code&gt; by transforming each value from &lt;code&gt;val&lt;/code&gt; to &lt;code&gt;f(val)&lt;/code&gt;. Note that the type of &lt;code&gt;dict&lt;/code&gt; cannot be changed: if &lt;code&gt;f(val)&lt;/code&gt; is not an instance of the key type of &lt;code&gt;dict&lt;/code&gt; then it will be converted to the key type if possible and otherwise raise an error.</source>
          <target state="translated">Изменяет &lt;code&gt;dict&lt;/code&gt; , преобразовывая каждое значение из &lt;code&gt;val&lt;/code&gt; в &lt;code&gt;f(val)&lt;/code&gt; . Обратите внимание, что тип &lt;code&gt;dict&lt;/code&gt; нельзя изменить: если &lt;code&gt;f(val)&lt;/code&gt; не является экземпляром ключевого типа &lt;code&gt;dict&lt;/code&gt; , тогда он будет преобразован в ключевой тип, если это возможно, и в противном случае вызовет ошибку.</target>
        </trans-unit>
        <trans-unit id="860fca59a229c6f65f6ba3d80bfe791d74f369e2" translate="yes" xml:space="preserve">
          <source>Modifies &lt;code&gt;dict&lt;/code&gt; by transforming each value from &lt;code&gt;val&lt;/code&gt; to &lt;code&gt;f(val)&lt;/code&gt;. Note that the type of &lt;code&gt;dict&lt;/code&gt; cannot be changed: if &lt;code&gt;f(val)&lt;/code&gt; is not an instance of the value type of &lt;code&gt;dict&lt;/code&gt; then it will be converted to the value type if possible and otherwise raise an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1db2af6a8e5de02c80ce0e770061ab316f1ee9" translate="yes" xml:space="preserve">
          <source>Modifies &lt;code&gt;dl&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;, and &lt;code&gt;du&lt;/code&gt; in-place and returns them and the second superdiagonal &lt;code&gt;du2&lt;/code&gt; and the pivoting vector &lt;code&gt;ipiv&lt;/code&gt;.</source>
          <target state="translated">Изменяет &lt;code&gt;dl&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; и &lt;code&gt;du&lt;/code&gt; на месте и возвращает их, а также вторую &lt;code&gt;du2&lt;/code&gt; и вектор поворота &lt;code&gt;ipiv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="572d43cf06548da1345ec6a3306e5d70ce13a433" translate="yes" xml:space="preserve">
          <source>Modifying OpenBLAS settings or compiling Julia with a different BLAS library, eg &lt;a href=&quot;https://software.intel.com/en-us/mkl&quot;&gt;Intel MKL&lt;/a&gt;, may provide performance improvements. You can use &lt;a href=&quot;https://github.com/JuliaComputing/MKL.jl&quot;&gt;MKL.jl&lt;/a&gt;, a package that makes Julia's linear algebra use Intel MKL BLAS and LAPACK instead of OpenBLAS, or search the discussion forum for suggestions on how to set this up manually. Note that Intel MKL cannot be bundled with Julia, as it is not open source.</source>
          <target state="translated">Изменение настроек OpenBLAS или компиляция Julia с другой библиотекой BLAS, например &lt;a href=&quot;https://software.intel.com/en-us/mkl&quot;&gt;Intel MKL&lt;/a&gt; , может улучшить производительность. Вы можете использовать &lt;a href=&quot;https://github.com/JuliaComputing/MKL.jl&quot;&gt;MKL.jl&lt;/a&gt; , пакет, который заставляет линейную алгебру Джулии использовать Intel MKL BLAS и LAPACK вместо OpenBLAS, или поискать в форуме обсуждения предложения о том, как настроить это вручную. Обратите внимание, что Intel MKL нельзя связать с Julia, так как это не открытый исходный код.</target>
        </trans-unit>
        <trans-unit id="e2d8cef0c43f0dd2eaf87acf03dd76365ee4a701" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;Distributed&lt;/code&gt; must be explicitly loaded on the master process before invoking &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt;. It is automatically made available on the worker processes.</source>
          <target state="translated">&lt;code&gt;Distributed&lt;/code&gt; модуль должен быть явно загружен в главный процесс перед &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt; . Он автоматически становится доступным для рабочих процессов.</target>
        </trans-unit>
        <trans-unit id="9a0d4c77db7f69422d17f4d02a74c2e9ca631637" translate="yes" xml:space="preserve">
          <source>Module containing the broadcasting implementation.</source>
          <target state="translated">Модуль,содержащий реализацию вещания.</target>
        </trans-unit>
        <trans-unit id="ac1e48420a4797de0ece18f47167f8bea686ef26" translate="yes" xml:space="preserve">
          <source>Module initialization and precompilation</source>
          <target state="translated">Инициализация и прекомпиляция модуля</target>
        </trans-unit>
        <trans-unit id="ec692ee34bf5f1de5b608ef24c4276cc3d0944e7" translate="yes" xml:space="preserve">
          <source>Module with garbage collection utilities.</source>
          <target state="translated">Модуль с утилитами для сбора мусора.</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="c708ba26889d0fdbad848a6a34a8587e74cf3305" translate="yes" xml:space="preserve">
          <source>Modules (namespaces) can be hierarchical. &lt;a href=&quot;../../base/base/index#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; have a dual role: they load the code and make it available in the namespace. &lt;code&gt;import&lt;/code&gt; for only the module name is possible (roughly equivalent to &lt;code&gt;ASDF:LOAD-OP&lt;/code&gt;). Slot names don't need to be exported separately. Global variables can't be assigned to from outside the module (except with &lt;code&gt;eval(mod, :(var = val))&lt;/code&gt; as an escape hatch).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f82982b865c3a95659f59755e8fee500abc86f4" translate="yes" xml:space="preserve">
          <source>Modules and files</source>
          <target state="translated">Модули и файлы</target>
        </trans-unit>
        <trans-unit id="8510a1d0d38afc78884abe8c896ed3ff2af14d40" translate="yes" xml:space="preserve">
          <source>Modules in Julia are separate variable workspaces, i.e. they introduce a new global scope. They are delimited syntactically, inside &lt;code&gt;module Name ... end&lt;/code&gt;. Modules allow you to create top-level definitions (aka global variables) without worrying about name conflicts when your code is used together with somebody else's. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting).</source>
          <target state="translated">Модули в Julia - это отдельные переменные рабочие области, т.е. они вводят новую глобальную область видимости. Они разделены синтаксически, внутри &lt;code&gt;module Name ... end&lt;/code&gt; . Модули позволяют создавать определения верхнего уровня (также известные как глобальные переменные), не беспокоясь о конфликтах имен, когда ваш код используется вместе с чужим. Внутри модуля вы можете контролировать, какие имена из других модулей видны (посредством импорта), и указывать, какие из ваших имен должны быть общедоступными (посредством экспорта).</target>
        </trans-unit>
        <trans-unit id="91c78ad25e39e2af6d232135bc4257fd35ca7940" translate="yes" xml:space="preserve">
          <source>Modulo Two Sum</source>
          <target state="translated">Модуло два Сумма</target>
        </trans-unit>
        <trans-unit id="c78082980964141d47941be353a64330f6b51990" translate="yes" xml:space="preserve">
          <source>Modulus after division by &lt;code&gt;2&amp;pi;&lt;/code&gt;, returning in the range $[0,2&amp;pi;)$.</source>
          <target state="translated">Модуль после деления на &lt;code&gt;2&amp;pi;&lt;/code&gt; , возвращаемый в диапазоне $ [0,2&amp;pi;) $.</target>
        </trans-unit>
        <trans-unit id="a351691306b2e5e66b41d3f5c7ffba6810525320" translate="yes" xml:space="preserve">
          <source>Modulus after flooring division, returning a value &lt;code&gt;r&lt;/code&gt; such that &lt;code&gt;mod(r, y) == mod(x, y)&lt;/code&gt; in the range $(0, y]$ for positive &lt;code&gt;y&lt;/code&gt; and in the range $[y,0)$ for negative &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Модуль после деления пола, возвращающий значение &lt;code&gt;r&lt;/code&gt; такое, что &lt;code&gt;mod(r, y) == mod(x, y)&lt;/code&gt; в диапазоне $ (0, y] $ для положительного значения &lt;code&gt;y&lt;/code&gt; и в диапазоне $ [y, 0) $ для отрицательный &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a8a13c5fc7802b76548bc6c9ce31726f4be07ed" translate="yes" xml:space="preserve">
          <source>Mon, Tue</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffae4168bc777c55ee4ffa00690c2cbb28b1c0b" translate="yes" xml:space="preserve">
          <source>Mon, Tues</source>
          <target state="translated">Пон,Вторник</target>
        </trans-unit>
        <trans-unit id="932eeb1076c85e522f02e15441fa371e3fd000ac" translate="yes" xml:space="preserve">
          <source>Monday</source>
          <target state="translated">Monday</target>
        </trans-unit>
        <trans-unit id="3c1ff5c46aff9b279cd8a11d7962636c6c595bab" translate="yes" xml:space="preserve">
          <source>Money Bag</source>
          <target state="translated">Денежный мешок</target>
        </trans-unit>
        <trans-unit id="b6639cb4b312c7ff05ac7325f845c67f865def44" translate="yes" xml:space="preserve">
          <source>Money With Wings</source>
          <target state="translated">Деньги с крыльями</target>
        </trans-unit>
        <trans-unit id="aeb0a4ab97f5db3410d52f9c451f8da976896310" translate="yes" xml:space="preserve">
          <source>Monitor a file descriptor &lt;code&gt;fd&lt;/code&gt; for changes in the read or write availability, and with a timeout given by &lt;code&gt;timeout_s&lt;/code&gt; seconds.</source>
          <target state="translated">Отслеживайте файловый дескриптор &lt;code&gt;fd&lt;/code&gt; на предмет изменений в доступности для чтения или записи и с таймаутом, заданным &lt;code&gt;timeout_s&lt;/code&gt; в секундах.</target>
        </trans-unit>
        <trans-unit id="7cd1562faa95bb9a9e863b102b09464e5cd6ea08" translate="yes" xml:space="preserve">
          <source>Monitor a file for changes by polling every &lt;code&gt;interval_s&lt;/code&gt; seconds until a change occurs or &lt;code&gt;timeout_s&lt;/code&gt; seconds have elapsed. The &lt;code&gt;interval_s&lt;/code&gt; should be a long period; the default is 5.007 seconds.</source>
          <target state="translated">Следите за изменениями в файле, опрашивая каждые &lt;code&gt;interval_s&lt;/code&gt; секунд, пока не произойдет изменение или не &lt;code&gt;timeout_s&lt;/code&gt; секунд. В &lt;code&gt;interval_s&lt;/code&gt; должен быть длительный период; значение по умолчанию - 5,007 секунд.</target>
        </trans-unit>
        <trans-unit id="4bd0ec65b8f729d265faeba6fa933846d7c2d687" translate="yes" xml:space="preserve">
          <source>Monkey</source>
          <target state="translated">Monkey</target>
        </trans-unit>
        <trans-unit id="bb09be0ab256a995fb854ed1c681d6db409b5a63" translate="yes" xml:space="preserve">
          <source>Monkey Face</source>
          <target state="translated">Обезьянья Лицо</target>
        </trans-unit>
        <trans-unit id="c8ee2da532776f830243f6b7e320f6344c60f050" translate="yes" xml:space="preserve">
          <source>Monorail</source>
          <target state="translated">Monorail</target>
        </trans-unit>
        <trans-unit id="68381046a452a28de3db3f76ce2d1e223be8c311" translate="yes" xml:space="preserve">
          <source>Month name shortened to 3-chars according to the &lt;code&gt;locale&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8bb646e34f3a1f66f555601f3aa3e959c4f36ae" translate="yes" xml:space="preserve">
          <source>Month of the year:</source>
          <target state="translated">Месяц года:</target>
        </trans-unit>
        <trans-unit id="39ffe0388e63ec156589f9f7dbfc37ce884b10df" translate="yes" xml:space="preserve">
          <source>Months of the Year:</source>
          <target state="translated">Месяцы года:</target>
        </trans-unit>
        <trans-unit id="a997188c7b1041363b78bd9fdcb758e1ac901a64" translate="yes" xml:space="preserve">
          <source>Moon Viewing Ceremony</source>
          <target state="translated">Церемония просмотра Луны</target>
        </trans-unit>
        <trans-unit id="5372b5bf846ad903de34d1fdbb6bac57298e63ef" translate="yes" xml:space="preserve">
          <source>More About Callbacks</source>
          <target state="translated">Подробнее об обратных вызовах</target>
        </trans-unit>
        <trans-unit id="eb61252c650b20a424bb584244f7ba0af0a2bba7" translate="yes" xml:space="preserve">
          <source>More complicated index types may require more context about the dimension into which they index. To support those cases, &lt;code&gt;to_indices(A, I)&lt;/code&gt; calls &lt;code&gt;to_indices(A, axes(A), I)&lt;/code&gt;, which then recursively walks through both the given tuple of indices and the dimensional indices of &lt;code&gt;A&lt;/code&gt; in tandem. As such, not all index types are guaranteed to propagate to &lt;code&gt;Base.to_index&lt;/code&gt;.</source>
          <target state="translated">Более сложные типы индексов могут потребовать более подробного описания измерения, по которому они индексируются. Чтобы поддержать эти случаи, &lt;code&gt;to_indices(A, I)&lt;/code&gt; вызывает &lt;code&gt;to_indices(A, axes(A), I)&lt;/code&gt; , который затем рекурсивно проходит как по заданному набору индексов, так и по размерным индексам &lt;code&gt;A&lt;/code&gt; в тандеме. Таким образом, не все типы индексов гарантированно распространяются на &lt;code&gt;Base.to_index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a28b8a7a0afdfc3986f92c88b6d9bd8d72ae68b9" translate="yes" xml:space="preserve">
          <source>More dots: Fuse vectorized operations</source>
          <target state="translated">Больше точек:Векторизированные операции предохранителя</target>
        </trans-unit>
        <trans-unit id="e49535ab32dd41ac98143e87fe7bcbc8d58da1ac" translate="yes" xml:space="preserve">
          <source>More examples will be discussed later in &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9114e0a5d18633194f649ad46bb864a2d100cdcf" translate="yes" xml:space="preserve">
          <source>More examples will be discussed later in &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;.</source>
          <target state="translated">Дополнительные примеры будут рассмотрены позже в &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;разделе &quot;Методы&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5f6174dab9b174876b6d1506f1b621ea3baaea5" translate="yes" xml:space="preserve">
          <source>More fine-grained control over display of &lt;code&gt;Polar&lt;/code&gt; objects is possible. In particular, sometimes one wants both a verbose multi-line printing format, used for displaying a single object in the REPL and other interactive environments, and also a more compact single-line format used for &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; or for displaying the object as part of another object (e.g. in an array). Although by default the &lt;code&gt;show(io, z)&lt;/code&gt; function is called in both cases, you can define a &lt;em&gt;different&lt;/em&gt; multi-line format for displaying an object by overloading a three-argument form of &lt;code&gt;show&lt;/code&gt; that takes the &lt;code&gt;text/plain&lt;/code&gt; MIME type as its second argument (see &lt;a href=&quot;../../base/io-network/index#Multimedia-I/O&quot;&gt;Multimedia I/O&lt;/a&gt;), for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2bb379bdba4c79a60942076ea4b662e49f8d9bb" translate="yes" xml:space="preserve">
          <source>More fine-grained control over display of &lt;code&gt;Polar&lt;/code&gt; objects is possible. In particular, sometimes one wants both a verbose multi-line printing format, used for displaying a single object in the REPL and other interactive environments, and also a more compact single-line format used for &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; or for displaying the object as part of another object (e.g. in an array). Although by default the &lt;code&gt;show(io, z)&lt;/code&gt; function is called in both cases, you can define a &lt;em&gt;different&lt;/em&gt; multi-line format for displaying an object by overloading a three-argument form of &lt;code&gt;show&lt;/code&gt; that takes the &lt;code&gt;text/plain&lt;/code&gt; MIME type as its second argument (see &lt;a href=&quot;../../base/io-network/index#Multimedia-I/O-1&quot;&gt;Multimedia I/O&lt;/a&gt;), for example:</source>
          <target state="translated">Возможен более точный контроль над отображением &lt;code&gt;Polar&lt;/code&gt; объектов. В частности, иногда требуется как подробный многострочный формат печати, используемый для отображения одного объекта в REPL и других интерактивных средах, так и более компактный однострочный формат, используемый для &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; или для отображения объекта как части другого. объект (например, в массиве). Хотя по умолчанию функция &lt;code&gt;show(io, z)&lt;/code&gt; вызывается в обоих случаях, вы можете определить &lt;em&gt;другой&lt;/em&gt; многострочный формат для отображения объекта, перегрузив трехаргументную форму &lt;code&gt;show&lt;/code&gt; , которая принимает тип MIME &lt;code&gt;text/plain&lt;/code&gt; в качестве второго аргумент (см. &lt;a href=&quot;../../base/io-network/index#Multimedia-I/O-1&quot;&gt;Мультимедийный ввод-вывод&lt;/a&gt; ), например:</target>
        </trans-unit>
        <trans-unit id="f807f392c5cb9f1e7fda57a006fbc06abbbb0bbb" translate="yes" xml:space="preserve">
          <source>More generally, &lt;code&gt;f.(args...)&lt;/code&gt; is actually equivalent to &lt;code&gt;broadcast(f, args...)&lt;/code&gt;, which allows you to operate on multiple arrays (even of different shapes), or a mix of arrays and scalars (see &lt;a href=&quot;../arrays/index#Broadcasting&quot;&gt;Broadcasting&lt;/a&gt;). For example, if you have &lt;code&gt;f(x,y) = 3x + 4y&lt;/code&gt;, then &lt;code&gt;f.(pi,A)&lt;/code&gt; will return a new array consisting of &lt;code&gt;f(pi,a)&lt;/code&gt; for each &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;A&lt;/code&gt;, and &lt;code&gt;f.(vector1,vector2)&lt;/code&gt; will return a new vector consisting of &lt;code&gt;f(vector1[i],vector2[i])&lt;/code&gt; for each index &lt;code&gt;i&lt;/code&gt; (throwing an exception if the vectors have different length).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f05c71e7a12085a3ebe14c1c0fed8c7488bc0dc" translate="yes" xml:space="preserve">
          <source>More generally, &lt;code&gt;f.(args...)&lt;/code&gt; is actually equivalent to &lt;code&gt;broadcast(f, args...)&lt;/code&gt;, which allows you to operate on multiple arrays (even of different shapes), or a mix of arrays and scalars (see &lt;a href=&quot;../arrays/index#Broadcasting-1&quot;&gt;Broadcasting&lt;/a&gt;). For example, if you have &lt;code&gt;f(x,y) = 3x + 4y&lt;/code&gt;, then &lt;code&gt;f.(pi,A)&lt;/code&gt; will return a new array consisting of &lt;code&gt;f(pi,a)&lt;/code&gt; for each &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;A&lt;/code&gt;, and &lt;code&gt;f.(vector1,vector2)&lt;/code&gt; will return a new vector consisting of &lt;code&gt;f(vector1[i],vector2[i])&lt;/code&gt; for each index &lt;code&gt;i&lt;/code&gt; (throwing an exception if the vectors have different length).</source>
          <target state="translated">В более общем смысле, &lt;code&gt;f.(args...)&lt;/code&gt; фактически эквивалентен &lt;code&gt;broadcast(f, args...)&lt;/code&gt; , который позволяет вам работать с несколькими массивами (даже различной формы) или смесью массивов и скаляров (см. &lt;a href=&quot;../arrays/index#Broadcasting-1&quot;&gt;Broadcasting&lt;/a&gt; ). Например, если у вас есть &lt;code&gt;f(x,y) = 3x + 4y&lt;/code&gt; , тогда &lt;code&gt;f.(pi,A)&lt;/code&gt; вернет новый массив, состоящий из &lt;code&gt;f(pi,a)&lt;/code&gt; для каждого &lt;code&gt;a&lt;/code&gt; в &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;f.(vector1,vector2)&lt;/code&gt; вернет новый вектор, состоящий из &lt;code&gt;f(vector1[i],vector2[i])&lt;/code&gt; для каждого индекса &lt;code&gt;i&lt;/code&gt; ( выдает исключение, если векторы имеют разную длину).</target>
        </trans-unit>
        <trans-unit id="cce6b41d29dd04e55028067c508756d479b0a9aa" translate="yes" xml:space="preserve">
          <source>More generally, concatenation can be accomplished through the &lt;a href=&quot;../../base/arrays/index#Base.cat&quot;&gt;&lt;code&gt;cat&lt;/code&gt;&lt;/a&gt; function. These syntaxes are shorthands for function calls that themselves are convenience functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b913d4fac598019e1594bf477f6f76ced64763" translate="yes" xml:space="preserve">
          <source>More generally, you can use &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; to read from or write to an external command.</source>
          <target state="translated">В более общем плане вы можете использовать &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; для чтения или записи внешней команды.</target>
        </trans-unit>
        <trans-unit id="16723d86f5a47f0ba34b59efade3de3bb73c4619" translate="yes" xml:space="preserve">
          <source>More on Channels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbed1d73be3b8c50f079db28b743039aeaaaf4c8" translate="yes" xml:space="preserve">
          <source>More precisely, the set of all finite-length strings &lt;em&gt;S&lt;/em&gt; together with the string concatenation operator &lt;code&gt;*&lt;/code&gt; forms a &lt;a href=&quot;https://en.wikipedia.org/wiki/Free_monoid&quot;&gt;free monoid&lt;/a&gt; (&lt;em&gt;S&lt;/em&gt;, &lt;code&gt;*&lt;/code&gt;). The identity element of this set is the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt;. Whenever a free monoid is not commutative, the operation is typically represented as &lt;code&gt;\cdot&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or a similar symbol, rather than &lt;code&gt;+&lt;/code&gt;, which as stated usually implies commutativity.</source>
          <target state="translated">Точнее, набор всех строк конечной длины &lt;em&gt;S&lt;/em&gt; вместе с оператором конкатенации строк &lt;code&gt;*&lt;/code&gt; образует &lt;a href=&quot;https://en.wikipedia.org/wiki/Free_monoid&quot;&gt;свободный моноид&lt;/a&gt; ( &lt;em&gt;S&lt;/em&gt; , &lt;code&gt;*&lt;/code&gt; ). Идентификационным элементом этого набора является пустая строка &lt;code&gt;&quot;&quot;&lt;/code&gt; . Когда свободный моноид не является коммутативным, операция обычно обозначается как &lt;code&gt;\cdot&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; или аналогичный символ, а не &lt;code&gt;+&lt;/code&gt; , что, как указано, обычно подразумевает коммутативность.</target>
        </trans-unit>
        <trans-unit id="e9cfd7dc4608b859ca3eb1fb55c826f67c16b0f8" translate="yes" xml:space="preserve">
          <source>More specifically, &lt;code&gt;a .^ b&lt;/code&gt; is parsed as the &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;&quot;dot&quot; call&lt;/a&gt;&lt;code&gt;(^).(a,b)&lt;/code&gt;, which performs a &lt;a href=&quot;../arrays/index#Broadcasting&quot;&gt;broadcast&lt;/a&gt; operation: it can combine arrays and scalars, arrays of the same size (performing the operation elementwise), and even arrays of different shapes (e.g. combining row and column vectors to produce a matrix). Moreover, like all vectorized &quot;dot calls,&quot; these &quot;dot operators&quot; are &lt;em&gt;fusing&lt;/em&gt;. For example, if you compute &lt;code&gt;2 .* A.^2 .+ sin.(A)&lt;/code&gt; (or equivalently &lt;code&gt;@. 2A^2 + sin(A)&lt;/code&gt;, using the &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt;&lt;code&gt;@.&lt;/code&gt;&lt;/a&gt; macro) for an array &lt;code&gt;A&lt;/code&gt;, it performs a &lt;em&gt;single&lt;/em&gt; loop over &lt;code&gt;A&lt;/code&gt;, computing &lt;code&gt;2a^2 + sin(a)&lt;/code&gt; for each element of &lt;code&gt;A&lt;/code&gt;. In particular, nested dot calls like &lt;code&gt;f.(g.(x))&lt;/code&gt; are fused, and &quot;adjacent&quot; binary operators like &lt;code&gt;x .+ 3 .* x.^2&lt;/code&gt; are equivalent to nested dot calls &lt;code&gt;(+).(x, (*).(3, (^).(x, 2)))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad8280d892c33adf910a8bff64139b7ac3434c8e" translate="yes" xml:space="preserve">
          <source>More specifically, &lt;code&gt;a .^ b&lt;/code&gt; is parsed as the &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;&quot;dot&quot; call&lt;/a&gt;&lt;code&gt;(^).(a,b)&lt;/code&gt;, which performs a &lt;a href=&quot;../arrays/index#Broadcasting-1&quot;&gt;broadcast&lt;/a&gt; operation: it can combine arrays and scalars, arrays of the same size (performing the operation elementwise), and even arrays of different shapes (e.g. combining row and column vectors to produce a matrix). Moreover, like all vectorized &quot;dot calls,&quot; these &quot;dot operators&quot; are &lt;em&gt;fusing&lt;/em&gt;. For example, if you compute &lt;code&gt;2 .* A.^2 .+ sin.(A)&lt;/code&gt; (or equivalently &lt;code&gt;@. 2A^2 + sin(A)&lt;/code&gt;, using the &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt;&lt;code&gt;@.&lt;/code&gt;&lt;/a&gt; macro) for an array &lt;code&gt;A&lt;/code&gt;, it performs a &lt;em&gt;single&lt;/em&gt; loop over &lt;code&gt;A&lt;/code&gt;, computing &lt;code&gt;2a^2 + sin(a)&lt;/code&gt; for each element of &lt;code&gt;A&lt;/code&gt;. In particular, nested dot calls like &lt;code&gt;f.(g.(x))&lt;/code&gt; are fused, and &quot;adjacent&quot; binary operators like &lt;code&gt;x .+ 3 .* x.^2&lt;/code&gt; are equivalent to nested dot calls &lt;code&gt;(+).(x, (*).(3, (^).(x, 2)))&lt;/code&gt;.</source>
          <target state="translated">Более конкретно, &lt;code&gt;a .^ b&lt;/code&gt; разбирается как &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;вызов &amp;laquo;точки&amp;raquo; &lt;/a&gt; &lt;code&gt;(^).(a,b)&lt;/code&gt; , который выполняет операцию &lt;a href=&quot;../arrays/index#Broadcasting-1&quot;&gt;широковещания&lt;/a&gt; : он может комбинировать массивы и скаляры, массивы одинакового размера (выполняя операцию поэлементно), и даже массивы различной формы (например, объединение векторов строк и столбцов для создания матрицы). Более того, как и все векторизованные &amp;laquo;вызовы точек&amp;raquo;, эти &amp;laquo;операторы точек&amp;raquo; &lt;em&gt;сливаются&lt;/em&gt; . Например, если вы вычисляете &lt;code&gt;2 .* A.^2 .+ sin.(A)&lt;/code&gt; (или эквивалентно &lt;code&gt;@. 2A^2 + sin(A)&lt;/code&gt; , используя макрос &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt; &lt;code&gt;@.&lt;/code&gt; &lt;/a&gt; ) Для массива &lt;code&gt;A&lt;/code&gt; , он выполняет &lt;em&gt;один&lt;/em&gt; цикл над &lt;code&gt;A&lt;/code&gt; , вычисляя &lt;code&gt;2a^2 + sin(a)&lt;/code&gt; для каждого элемента &lt;code&gt;A&lt;/code&gt; . В частности, вложенные вызовы точек, такие как &lt;code&gt;f.(g.(x))&lt;/code&gt; объединяются, а &quot;смежные&quot; бинарные операторы, такие как &lt;code&gt;x .+ 3 .* x.^2&lt;/code&gt; , эквивалентны вызовам вложенных точек &lt;code&gt;(+).(x, (*).(3, (^).(x, 2)))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23c6114d5cee868e3c446e0046f513b9baf30bbd" translate="yes" xml:space="preserve">
          <source>More task operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17af8621830fc8ff7e82aa48fbe7045fe41ab880" translate="yes" xml:space="preserve">
          <source>More usefully, it is possible to constrain varargs methods by a parameter. For example:</source>
          <target state="translated">Более полезным является ограничение методов varargs параметром.Например:</target>
        </trans-unit>
        <trans-unit id="779070101f9832b852f60dfb362c3b0c4dd35160" translate="yes" xml:space="preserve">
          <source>Moreover, &lt;em&gt;nested&lt;/em&gt;&lt;code&gt;f.(args...)&lt;/code&gt; calls are &lt;em&gt;fused&lt;/em&gt; into a single &lt;code&gt;broadcast&lt;/code&gt; loop. For example, &lt;code&gt;sin.(cos.(X))&lt;/code&gt; is equivalent to &lt;code&gt;broadcast(x -&amp;gt; sin(cos(x)), X)&lt;/code&gt;, similar to &lt;code&gt;[sin(cos(x)) for x in X]&lt;/code&gt;: there is only a single loop over &lt;code&gt;X&lt;/code&gt;, and a single array is allocated for the result. [In contrast, &lt;code&gt;sin(cos(X))&lt;/code&gt; in a typical &quot;vectorized&quot; language would first allocate one temporary array for &lt;code&gt;tmp=cos(X)&lt;/code&gt;, and then compute &lt;code&gt;sin(tmp)&lt;/code&gt; in a separate loop, allocating a second array.] This loop fusion is not a compiler optimization that may or may not occur, it is a &lt;em&gt;syntactic guarantee&lt;/em&gt; whenever nested &lt;code&gt;f.(args...)&lt;/code&gt; calls are encountered. Technically, the fusion stops as soon as a &quot;non-dot&quot; function call is encountered; for example, in &lt;code&gt;sin.(sort(cos.(X)))&lt;/code&gt; the &lt;code&gt;sin&lt;/code&gt; and &lt;code&gt;cos&lt;/code&gt; loops cannot be merged because of the intervening &lt;code&gt;sort&lt;/code&gt; function.</source>
          <target state="translated">Кроме того, &lt;em&gt;вложенная &lt;/em&gt; &lt;code&gt;f.(args...)&lt;/code&gt; вызовы &lt;em&gt;слиты&lt;/em&gt; в единый &lt;code&gt;broadcast&lt;/code&gt; цикл. Например, &lt;code&gt;sin.(cos.(X))&lt;/code&gt; эквивалентно &lt;code&gt;broadcast(x -&amp;gt; sin(cos(x)), X)&lt;/code&gt; , аналогично &lt;code&gt;[sin(cos(x)) for x in X]&lt;/code&gt; : есть только один цикл по &lt;code&gt;X&lt;/code&gt; , и для результата выделяется один массив. [Напротив, &lt;code&gt;sin(cos(X))&lt;/code&gt; в типичном &amp;laquo;векторизованном&amp;raquo; языке сначала выделяет один временный массив для &lt;code&gt;tmp=cos(X)&lt;/code&gt; , а затем вычисляет &lt;code&gt;sin(tmp)&lt;/code&gt; в отдельном цикле, выделяя второй массив.] Это объединение циклов - это не оптимизация компилятора, которая может произойти или не произойти, это&lt;em&gt;синтаксическая гарантия&lt;/em&gt; всякий раз, когда встречаются вложенные вызовы &lt;code&gt;f.(args...)&lt;/code&gt; . Технически слияние останавливается, как только встречается вызов функции, не являющейся точкой; например, в &lt;code&gt;sin.(sort(cos.(X)))&lt;/code&gt; &lt;code&gt;sin&lt;/code&gt; и &lt;code&gt;cos&lt;/code&gt; петли не могут быть объединены из - за промежуточной &lt;code&gt;sort&lt;/code&gt; функции.</target>
        </trans-unit>
        <trans-unit id="fd5329457d4ed40fab6163857a9591ce932a18cd" translate="yes" xml:space="preserve">
          <source>Moreover, if the compiler could not determine that the regex object was constant over all loops, certain optimizations might not be possible, making this version still less efficient than the more convenient literal form above. Of course, there are still situations where the non-literal form is more convenient: if one needs to interpolate a variable into the regular expression, one must take this more verbose approach; in cases where the regular expression pattern itself is dynamic, potentially changing upon each loop iteration, a new regular expression object must be constructed on each iteration. In the vast majority of use cases, however, regular expressions are not constructed based on run-time data. In this majority of cases, the ability to write regular expressions as compile-time values is invaluable.</source>
          <target state="translated">Более того,если компилятор не сможет определить,что объект регресса постоянен во всех циклах,некоторые оптимизации могут оказаться невозможными,что сделает данную версию еще менее эффективной,чем более удобная литературная форма,приведенная выше.Конечно,все еще существуют ситуации,в которых нелитеральная форма более удобна:если необходимо интерполировать переменную в регулярное выражение,то необходимо использовать этот более подробный подход;в тех случаях,когда сам шаблон регулярного выражения является динамическим,потенциально изменяющимся при каждой итерации цикла,на каждой итерации должен быть построен новый объект регулярного выражения.Однако в подавляющем большинстве случаев использования регулярные выражения не строятся на основе данных о времени выполнения.В этом большинстве случаев неоценима возможность записи регулярных выражений в виде значений времени компиляции.</target>
        </trans-unit>
        <trans-unit id="94796bcc387a6e8182d2873b6955e8376c00e9ec" translate="yes" xml:space="preserve">
          <source>Moreover, if you interpolate multiple arrays into the same word, the shell's Cartesian product generation behavior is emulated:</source>
          <target state="translated">Более того,если интерполировать несколько массивов в одно и то же слово,эмулируется поведение декартовой генерации продукта оболочки:</target>
        </trans-unit>
        <trans-unit id="a35393ea29790838fd27f9dba6491b1e4a45bdca" translate="yes" xml:space="preserve">
          <source>Moreover, these functions (like any Julia function) can be applied in &quot;vectorized&quot; fashion to arrays and other collections with the &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;dot syntax&lt;/a&gt;&lt;code&gt;f.(A)&lt;/code&gt;, e.g. &lt;code&gt;sin.(A)&lt;/code&gt; will compute the sine of each element of an array &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e032b71807c69c0bc1be8067fda2123f4bb83a6" translate="yes" xml:space="preserve">
          <source>Moreover, these functions (like any Julia function) can be applied in &quot;vectorized&quot; fashion to arrays and other collections with the &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax&lt;/a&gt;&lt;code&gt;f.(A)&lt;/code&gt;, e.g. &lt;code&gt;sin.(A)&lt;/code&gt; will compute the sine of each element of an array &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Более того, эти функции (как и любая функция Джулии) могут применяться &amp;laquo;векторизованным&amp;raquo; способом к массивам и другим коллекциям с &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;точечным синтаксисом &lt;/a&gt; &lt;code&gt;f.(A)&lt;/code&gt; , например &lt;code&gt;sin.(A)&lt;/code&gt; вычисляет синус каждого элемента массива &lt;code&gt;A&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="3695177f400d78b837a3ec533b6ee9eedcb9aba9" translate="yes" xml:space="preserve">
          <source>Moreover, you can also define &lt;code&gt;show&lt;/code&gt; methods for other MIME types in order to enable richer display (HTML, images, etcetera) of objects in environments that support this (e.g. IJulia). For example, we can define formatted HTML display of &lt;code&gt;Polar&lt;/code&gt; objects, with superscripts and italics, via:</source>
          <target state="translated">Более того, вы также можете определить методы &lt;code&gt;show&lt;/code&gt; для других типов MIME, чтобы обеспечить более богатое отображение (HTML, изображения и т. Д.) Объектов в средах, которые это поддерживают (например, IJulia). Например, мы можем определить форматированное HTML-отображение &lt;code&gt;Polar&lt;/code&gt; объектов с надстрочными индексами и курсивом через:</target>
        </trans-unit>
        <trans-unit id="2cedbde91aadbe841dc76e371af3e62bec121526" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;Period&lt;/code&gt; values can also be rounded to a specified resolution:</source>
          <target state="translated">Большинство значений &lt;code&gt;Period&lt;/code&gt; также можно округлить до указанного разрешения:</target>
        </trans-unit>
        <trans-unit id="4e19dc6bd3a4b02ba9e0283a25c37e3a958338a7" translate="yes" xml:space="preserve">
          <source>Most commonly you'll be loading code from files or packages, and you have a considerable amount of flexibility in controlling which processes load code. Consider a file, &lt;code&gt;DummyModule.jl&lt;/code&gt;, containing the following code:</source>
          <target state="translated">Чаще всего вы будете загружать код из файлов или пакетов, и у вас есть значительная гибкость в управлении процессами загрузки кода. Рассмотрим файл &lt;code&gt;DummyModule.jl&lt;/code&gt; , содержащий следующий код:</target>
        </trans-unit>
        <trans-unit id="c650c7bdb609a6165acfd0169fae2081b78f3b86" translate="yes" xml:space="preserve">
          <source>Most functions related to random generation accept an optional &lt;code&gt;AbstractRNG&lt;/code&gt; object as first argument, which defaults to the global one if not provided. Moreover, some of them accept optionally dimension specifications &lt;code&gt;dims...&lt;/code&gt; (which can be given as a tuple) to generate arrays of random values.</source>
          <target state="translated">Большинство функций, связанных со случайной генерацией, принимают необязательный объект &lt;code&gt;AbstractRNG&lt;/code&gt; в качестве первого аргумента, который по умолчанию является глобальным, если не указан. Более того, некоторые из них дополнительно принимают спецификации размеров &lt;code&gt;dims...&lt;/code&gt; (которые могут быть заданы в виде кортежа) для генерации массивов случайных значений.</target>
        </trans-unit>
        <trans-unit id="c1239d101be28fb7a51d055c4beba3cba9e6e698" translate="yes" xml:space="preserve">
          <source>Most modern computers possess more than one CPU, and several computers can be combined together in a cluster. Harnessing the power of these multiple CPUs allows many computations to be completed more quickly. There are two major factors that influence performance: the speed of the CPUs themselves, and the speed of their access to memory. In a cluster, it's fairly obvious that a given CPU will have fastest access to the RAM within the same computer (node). Perhaps more surprisingly, similar issues are relevant on a typical multicore laptop, due to differences in the speed of main memory and the &lt;a href=&quot;https://www.akkadia.org/drepper/cpumemory.pdf&quot;&gt;cache&lt;/a&gt;. Consequently, a good multiprocessing environment should allow control over the &quot;ownership&quot; of a chunk of memory by a particular CPU. Julia provides a multiprocessing environment based on message passing to allow programs to run on multiple processes in separate memory domains at once.</source>
          <target state="translated">Большинство современных компьютеров имеют более одного процессора, и несколько компьютеров могут быть объединены в кластер. Использование мощности этих нескольких процессоров позволяет выполнять многие вычисления быстрее. На производительность влияют два основных фактора: скорость самих процессоров и скорость их доступа к памяти. В кластере совершенно очевидно, что данный ЦП будет иметь самый быстрый доступ к ОЗУ на том же компьютере (узле). Возможно, более удивительно, что аналогичные проблемы актуальны для типичного многоядерного ноутбука из-за различий в скорости основной памяти и &lt;a href=&quot;https://www.akkadia.org/drepper/cpumemory.pdf&quot;&gt;кеш-памяти.&lt;/a&gt;, Следовательно, хорошая многопроцессорная среда должна позволять контролировать &amp;laquo;владение&amp;raquo; фрагментом памяти конкретным процессором. Julia предоставляет многопроцессорную среду, основанную на передаче сообщений, что позволяет программам запускаться сразу в нескольких процессах в разных доменах памяти.</target>
        </trans-unit>
        <trans-unit id="0eb4a0eddebf9dead1a35f328ee8b33ef53f3e18" translate="yes" xml:space="preserve">
          <source>Most non-&lt;code&gt;AbstractString&lt;/code&gt; objects are converted to strings closely corresponding to how they are entered as literal expressions:</source>
          <target state="translated">Большинство объектов, не относящихся к &lt;code&gt;AbstractString&lt;/code&gt; , преобразуются в строки, близко соответствующие тому, как они вводятся как буквальные выражения:</target>
        </trans-unit>
        <trans-unit id="009849b63af7fd56e46b025e9e1988be97d008f3" translate="yes" xml:space="preserve">
          <source>Most of the fields in &lt;code&gt;WorkerConfig&lt;/code&gt; are used by the inbuilt managers. Custom cluster managers would typically specify only &lt;code&gt;io&lt;/code&gt; or &lt;code&gt;host&lt;/code&gt; / &lt;code&gt;port&lt;/code&gt;:</source>
          <target state="translated">Большинство полей в &lt;code&gt;WorkerConfig&lt;/code&gt; используются встроенными менеджерами. Пользовательские менеджеры кластеров обычно указывают только &lt;code&gt;io&lt;/code&gt; или &lt;code&gt;host&lt;/code&gt; / &lt;code&gt;port&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fdbedbae85135376e0955ea53a24367ed77becc5" translate="yes" xml:space="preserve">
          <source>Most of the time, a package is uniquely identifiable simply from its name. However, sometimes a project might encounter a situation where it needs to use two different packages that share the same name. While you might be able fix this by renaming one of the packages, being forced to do so can be highly disruptive in a large, shared code base. Instead, Julia's code loading mechanism allows the same package name to refer to different packages in different components of an application.</source>
          <target state="translated">В большинстве случаев,пакет уникально идентифицируется просто по его имени.Однако,иногда проект может столкнуться с ситуацией,когда ему необходимо использовать два разных пакета с одним и тем же именем.Хотя вы можете исправить это,переименовав один из пакетов,принуждение к этому может быть очень разрушительным в большой общей кодовой базе.Вместо этого,механизм загрузки кода Julia позволяет использовать одно и то же имя пакета для ссылок на разные пакеты в разных компонентах приложения.</target>
        </trans-unit>
        <trans-unit id="c0a13ed301c1f3da1a566cff3cd69df8fc346456" translate="yes" xml:space="preserve">
          <source>Most real numbers cannot be represented exactly with floating-point numbers, and so for many purposes it is important to know the distance between two adjacent representable floating-point numbers, which is often known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_epsilon&quot;&gt;machine epsilon&lt;/a&gt;.</source>
          <target state="translated">Большинство действительных чисел не могут быть точно представлены числами с плавающей запятой, поэтому для многих целей важно знать расстояние между двумя соседними представляемыми числами с плавающей запятой, которое часто называют &lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_epsilon&quot;&gt;машинным эпсилон&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="451bfdf40e0411d54f7de109d79b121ca62be5c5" translate="yes" xml:space="preserve">
          <source>Most task switches occur as a result of waiting for events such as I/O requests, and are performed by a scheduler included in Julia Base. The scheduler maintains a queue of runnable tasks, and executes an event loop that restarts tasks based on external events such as message arrival.</source>
          <target state="translated">Большинство переключений задач происходит в результате ожидания таких событий,как запросы ввода/вывода,и выполняются планировщиком,включенным в Julia Base.Планировщик поддерживает очередь выполняемых задач и выполняет цикл обработки событий,который перезапускает задачи,основываясь на внешних событиях,таких как приход сообщений.</target>
        </trans-unit>
        <trans-unit id="979b60e882abda8a9c12cf29fe335277ebba6068" translate="yes" xml:space="preserve">
          <source>Mount Fuji</source>
          <target state="translated">гора Фудзи</target>
        </trans-unit>
        <trans-unit id="ea810cae67bdffd7ad390ce003d4876748a6fba6" translate="yes" xml:space="preserve">
          <source>Mountain Bicyclist</source>
          <target state="translated">горный велосипедист</target>
        </trans-unit>
        <trans-unit id="0cf2a0344224497ad15378a05503ae78e04f4bf8" translate="yes" xml:space="preserve">
          <source>Mountain Cableway</source>
          <target state="translated">Горный канатный путь</target>
        </trans-unit>
        <trans-unit id="d84c680c2896ded96f7a10d71dad68ce2418ed82" translate="yes" xml:space="preserve">
          <source>Mountain Railway</source>
          <target state="translated">Горная железная дорога</target>
        </trans-unit>
        <trans-unit id="573dd2c2ed953b97e3c31f3090925fe92109b779" translate="yes" xml:space="preserve">
          <source>Mouse</source>
          <target state="translated">Mouse</target>
        </trans-unit>
        <trans-unit id="5768b6f096a5a2264e0ec9dec9808a17ff5b43e8" translate="yes" xml:space="preserve">
          <source>Mouse Face</source>
          <target state="translated">Мышное лицо</target>
        </trans-unit>
        <trans-unit id="8b89346ec19490ee79f4cd52a3a3717eb0a29f3b" translate="yes" xml:space="preserve">
          <source>Mouth</source>
          <target state="translated">Mouth</target>
        </trans-unit>
        <trans-unit id="30b1f202851b68387e0cf962baee4d8839bb1316" translate="yes" xml:space="preserve">
          <source>Move cursor according to the direction of the Arrow key, while activating the region (&quot;shift selection&quot;)</source>
          <target state="translated">Перемещайте курсор в соответствии с направлением клавиши со стрелкой при активации области (&quot;сдвиг выделения&quot;).</target>
        </trans-unit>
        <trans-unit id="9fbb10cea5a283fe0ac0a7b27485eb8a05156e90" translate="yes" xml:space="preserve">
          <source>Move down one line (or change to the next history entry that matches the text before the cursor)</source>
          <target state="translated">Перемещение вниз на одну строку (или переход к следующей записи истории,которая соответствует тексту перед курсором).</target>
        </trans-unit>
        <trans-unit id="d39ec10b803e2fe3f34325c3c3abd699531c775a" translate="yes" xml:space="preserve">
          <source>Move left one character</source>
          <target state="translated">Переместить влево один символ</target>
        </trans-unit>
        <trans-unit id="0791a4c858c6d391e0ae088e06592877ac2b3393" translate="yes" xml:space="preserve">
          <source>Move left one word</source>
          <target state="translated">Переместить влево на одно слово</target>
        </trans-unit>
        <trans-unit id="4897d4c5d557d2a36d7979e57b09fe3bcda6c0ef" translate="yes" xml:space="preserve">
          <source>Move right one character</source>
          <target state="translated">Сдвинуть вправо один символ</target>
        </trans-unit>
        <trans-unit id="46615955d39b79da629fb77760f9faf2397e33ae" translate="yes" xml:space="preserve">
          <source>Move right one word</source>
          <target state="translated">Переместить вправо одно слово</target>
        </trans-unit>
        <trans-unit id="8c735f545a7e59af556c32f882f26a847507a45e" translate="yes" xml:space="preserve">
          <source>Move the file, link, or directory from &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt;. &lt;code&gt;force=true&lt;/code&gt; will first remove an existing &lt;code&gt;dst&lt;/code&gt;. Return &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">Переместите файл, ссылку или каталог из &lt;code&gt;src&lt;/code&gt; в &lt;code&gt;dst&lt;/code&gt; . &lt;code&gt;force=true&lt;/code&gt; сначала удалит существующий &lt;code&gt;dst&lt;/code&gt; . Вернуть &lt;code&gt;dst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a9cb71d0e79bee3c1501add0807182e5ae66211" translate="yes" xml:space="preserve">
          <source>Move to beginning of line</source>
          <target state="translated">Перейти к началу строки</target>
        </trans-unit>
        <trans-unit id="9ac320ded099850be4cfbe5245eb54c34673ceac" translate="yes" xml:space="preserve">
          <source>Move to end of line</source>
          <target state="translated">Перейти к концу строки</target>
        </trans-unit>
        <trans-unit id="c1dd98d3dcbabaacbdfa5f6b95879b0b4a046a03" translate="yes" xml:space="preserve">
          <source>Move up one line (or change to the previous history entry that matches the text before the cursor)</source>
          <target state="translated">Перемещение вверх на одну строку (или изменение на предыдущую запись истории,которая совпадает с текстом перед курсором).</target>
        </trans-unit>
        <trans-unit id="76725352326853201f27fde4c6c1ce275b820153" translate="yes" xml:space="preserve">
          <source>Movie Camera</source>
          <target state="translated">Кинокамера</target>
        </trans-unit>
        <trans-unit id="a6ca43aa7d11d81bf2d46a043f16aaedd09ef0f6" translate="yes" xml:space="preserve">
          <source>Moyai</source>
          <target state="translated">Moyai</target>
        </trans-unit>
        <trans-unit id="2b88c19cc18879e009ec23091705fee60af05e90" translate="yes" xml:space="preserve">
          <source>Much Greater-Than / Much Greater Than</source>
          <target state="translated">Намного больше,чем</target>
        </trans-unit>
        <trans-unit id="d5a0fbbca8f5245c8133de8c73b23f300c244dc4" translate="yes" xml:space="preserve">
          <source>Much Greater-Than / Much Greater Than + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Намного больше тана/гораздо больше,чем+сочетание длинного наложения с твердым покрытием/нештриховое наложение с длинным косая черта</target>
        </trans-unit>
        <trans-unit id="4f2c0deb0505dd20e806f5765890099e4b5a867f" translate="yes" xml:space="preserve">
          <source>Much Less-Than / Much Less Than</source>
          <target state="translated">Намного менее чем</target>
        </trans-unit>
        <trans-unit id="6be826cd51359393418fcb2adbb0047839a7b6e1" translate="yes" xml:space="preserve">
          <source>Much Less-Than / Much Less Than + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Намного меньше,чем/Намного меньше,чем+Комбинирование длинного наложения Solidus/нештрихового наложения длинного косая черта</target>
        </trans-unit>
        <trans-unit id="b47a2a6c416b663239d44555df35e9ac1ebf369f" translate="yes" xml:space="preserve">
          <source>Much as plain old abstract types serve to create a useful hierarchy of types over concrete types, parametric abstract types serve the same purpose with respect to parametric composite types. We could, for example, have declared &lt;code&gt;Point{T}&lt;/code&gt; to be a subtype of &lt;code&gt;Pointy{T}&lt;/code&gt; as follows:</source>
          <target state="translated">Подобно тому, как простые старые абстрактные типы служат для создания полезной иерархии типов над конкретными типами, параметрические абстрактные типы служат той же цели по отношению к параметрическим составным типам. Мы могли бы, например, объявить &lt;code&gt;Point{T}&lt;/code&gt; подтипом &lt;code&gt;Pointy{T}&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="2f35bd862c1f6f3023c5d86b53aa67708df9fe9c" translate="yes" xml:space="preserve">
          <source>Multi-Core or Distributed Processing</source>
          <target state="translated">Многоядерная или распределенная обработка</target>
        </trans-unit>
        <trans-unit id="5d8f806bc2cb3dd821e467dcedf520889e897194" translate="yes" xml:space="preserve">
          <source>Multi-Threading</source>
          <target state="translated">Multi-Threading</target>
        </trans-unit>
        <trans-unit id="a1769e396774be66a81c06a4bc46092468f38e81" translate="yes" xml:space="preserve">
          <source>Multi-Threading (Experimental)</source>
          <target state="translated">Многопоточность (экспериментальная)</target>
        </trans-unit>
        <trans-unit id="e1b066f6dcf0a56bf1362975edd9dba4ac4004b6" translate="yes" xml:space="preserve">
          <source>Multi-dimensional Arrays</source>
          <target state="translated">Многомерные массивы</target>
        </trans-unit>
        <trans-unit id="c2582f70ace65cdd3e0e5aa3007381331520ce71" translate="yes" xml:space="preserve">
          <source>Multi-processing and Distributed Computing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df9252fd5d4911ee5eb1c96d25797e8cf043b28" translate="yes" xml:space="preserve">
          <source>Multi-threading</source>
          <target state="translated">Multi-threading</target>
        </trans-unit>
        <trans-unit id="304d54aad0987ef425371304d27e4ffefba7eba5" translate="yes" xml:space="preserve">
          <source>Multi-threading functionality builds on tasks by allowing them to run simultaneously on more than one thread or CPU core, sharing memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e421129a56610bee84054ce99746152a4e075eb0" translate="yes" xml:space="preserve">
          <source>MultiSelectMenu</source>
          <target state="translated">MultiSelectMenu</target>
        </trans-unit>
        <trans-unit id="a9d638ce5bf60587999d44aed72b74552ba37415" translate="yes" xml:space="preserve">
          <source>Multidimensional Arrays</source>
          <target state="translated">Многомерные массивы</target>
        </trans-unit>
        <trans-unit id="2688e5975cc55bfb07b0932fafd5c212fc5ace21" translate="yes" xml:space="preserve">
          <source>Multidimensional and nonscalar indexed assignment</source>
          <target state="translated">Многомерное и нескалярное индексированное назначение</target>
        </trans-unit>
        <trans-unit id="e734bd25327fbeb74d44958ad03c60a53b4c7ad6" translate="yes" xml:space="preserve">
          <source>Multidimensional and nonscalar indexing</source>
          <target state="translated">Многомерная и нескалярная индексация</target>
        </trans-unit>
        <trans-unit id="bcc8b546795a10466bd74bf69b081a62bbb6c4d8" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays in Julia are stored in column-major order. This means that arrays are stacked one column at a time. This can be verified using the &lt;code&gt;vec&lt;/code&gt; function or the syntax &lt;code&gt;[:]&lt;/code&gt; as shown below (notice that the array is ordered &lt;code&gt;[1 3 2 4]&lt;/code&gt;, not &lt;code&gt;[1 2 3 4]&lt;/code&gt;):</source>
          <target state="translated">Многомерные массивы в Julia хранятся в порядке столбцов. Это означает, что массивы складываются по столбцу за раз. Это можно проверить с помощью функции &lt;code&gt;vec&lt;/code&gt; или синтаксиса &lt;code&gt;[:]&lt;/code&gt; , как показано ниже (обратите внимание, что массив упорядочен &lt;code&gt;[1 3 2 4]&lt;/code&gt; , а не &lt;code&gt;[1 2 3 4]&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="8dc001479bc2220a1c498e4c1d38b3ef0687b311" translate="yes" xml:space="preserve">
          <source>Multimap</source>
          <target state="translated">Multimap</target>
        </trans-unit>
        <trans-unit id="12a550b8fa4d35649c20c485e20ba65c48140443" translate="yes" xml:space="preserve">
          <source>Multimedia I/O</source>
          <target state="translated">Мультимедийный ввод/вывод</target>
        </trans-unit>
        <trans-unit id="20daf23b87d49b545626edacfe0595bc78ffe6bb" translate="yes" xml:space="preserve">
          <source>Multimedia-capable display backends may be registered by subclassing a generic &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt;&lt;code&gt;AbstractDisplay&lt;/code&gt;&lt;/a&gt; type and pushing them onto a stack of display backends via &lt;a href=&quot;#Base.Multimedia.pushdisplay&quot;&gt;&lt;code&gt;pushdisplay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Бэкэнды дисплея с поддержкой мультимедиа могут быть зарегистрированы путем создания подкласса общего типа &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt; &lt;code&gt;AbstractDisplay&lt;/code&gt; &lt;/a&gt; и помещения их в стек &lt;a href=&quot;#Base.Multimedia.pushdisplay&quot;&gt; &lt;code&gt;pushdisplay&lt;/code&gt; &lt;/a&gt; дисплея через pushdisplay .</target>
        </trans-unit>
        <trans-unit id="f901aab2cf166bf580d3c3b10747eb77b4d28786" translate="yes" xml:space="preserve">
          <source>Multimedia.@MIME_str</source>
          <target state="translated">Multimedia.@MIME_str</target>
        </trans-unit>
        <trans-unit id="1fad381232cafa3a6519f49a82f0ad5d43ee03f8" translate="yes" xml:space="preserve">
          <source>Multimedia.AbstractDisplay</source>
          <target state="translated">Multimedia.AbstractDisplay</target>
        </trans-unit>
        <trans-unit id="3bf6b34f9dc6831162a9ed70613e7214b009773a" translate="yes" xml:space="preserve">
          <source>Multimedia.MIME</source>
          <target state="translated">Multimedia.MIME</target>
        </trans-unit>
        <trans-unit id="1a3b6cfeea4ec290d631b42e28b7fd3dd7997acf" translate="yes" xml:space="preserve">
          <source>Multimedia.TextDisplay</source>
          <target state="translated">Multimedia.TextDisplay</target>
        </trans-unit>
        <trans-unit id="7d8e050779516bbc10cc3b22a2ff20011e576c53" translate="yes" xml:space="preserve">
          <source>Multimedia.display()</source>
          <target state="translated">Multimedia.display()</target>
        </trans-unit>
        <trans-unit id="44362a84f2293978fd977ef2de61866c3a99b218" translate="yes" xml:space="preserve">
          <source>Multimedia.displayable()</source>
          <target state="translated">Multimedia.displayable()</target>
        </trans-unit>
        <trans-unit id="591d47ad80c3149fb86dc4d9393ecc120230caeb" translate="yes" xml:space="preserve">
          <source>Multimedia.istextmime()</source>
          <target state="translated">Multimedia.istextmime()</target>
        </trans-unit>
        <trans-unit id="d02a6dd8bd8f25cd25c6ab6ab392ec5dde9ef69a" translate="yes" xml:space="preserve">
          <source>Multimedia.popdisplay()</source>
          <target state="translated">Multimedia.popdisplay()</target>
        </trans-unit>
        <trans-unit id="6a6027621de0719ce755c723b278c3459d48b0d9" translate="yes" xml:space="preserve">
          <source>Multimedia.pushdisplay()</source>
          <target state="translated">Multimedia.pushdisplay()</target>
        </trans-unit>
        <trans-unit id="a173fa25b54e08e60b3fab0e43245db6b1bb5c4f" translate="yes" xml:space="preserve">
          <source>Multimedia.redisplay()</source>
          <target state="translated">Multimedia.redisplay()</target>
        </trans-unit>
        <trans-unit id="17f6e961e36391308b259ffe96e74cfb78a59cf9" translate="yes" xml:space="preserve">
          <source>Multimedia.showable()</source>
          <target state="translated">Multimedia.showable()</target>
        </trans-unit>
        <trans-unit id="8b65075f1dc2c06140e3f24524c3b8e27d9efca2" translate="yes" xml:space="preserve">
          <source>Multiple Musical Notes</source>
          <target state="translated">Несколько музыкальных нот</target>
        </trans-unit>
        <trans-unit id="1eae37825f972d7374db88d51813ed8e004ec47c" translate="yes" xml:space="preserve">
          <source>Multiple Objects</source>
          <target state="translated">Многочисленные объекты</target>
        </trans-unit>
        <trans-unit id="a025ceee7b8b1c711d382e33043a2b3de0e6408b" translate="yes" xml:space="preserve">
          <source>Multiple Return Values</source>
          <target state="translated">Множественные возвращаемые значения</target>
        </trans-unit>
        <trans-unit id="8e15b8cb269e38ed2edf77db20f03d8707f3e964" translate="yes" xml:space="preserve">
          <source>Multiple dispatch together with the flexible parametric type system give Julia its ability to abstractly express high-level algorithms decoupled from implementation details, yet generate efficient, specialized code to handle each case at run time.</source>
          <target state="translated">Многократная диспетчеризация вместе с гибкой системой параметрического типа дают Джулии возможность абстрактно выражать высокоуровневые алгоритмы,отделенные от деталей реализации,и в то же время генерировать эффективный,специализированный код для обработки каждого случая во время выполнения.</target>
        </trans-unit>
        <trans-unit id="c25f913c3995067af10c2cde65a0d3a79da1b5af" translate="yes" xml:space="preserve">
          <source>Multiple function composition requires at least Julia 1.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7bab076d4c7874947ae3e9648b2fc792a2f1d6f" translate="yes" xml:space="preserve">
          <source>Multiple nested &lt;code&gt;for&lt;/code&gt; loops can be combined into a single outer loop, forming the cartesian product of its iterables:</source>
          <target state="translated">Несколько вложенных циклов &lt;code&gt;for&lt;/code&gt; можно объединить в один внешний цикл, образуя декартово произведение его итераций:</target>
        </trans-unit>
        <trans-unit id="495dbcc88072f8c65c5a84ca68f0504e42ed0ed7" translate="yes" xml:space="preserve">
          <source>Multiple readers in different tasks can read data concurrently via &lt;code&gt;take!&lt;/code&gt; calls.</source>
          <target state="translated">Несколько читателей, &lt;code&gt;take!&lt;/code&gt; разные задачи, могут одновременно читать данные через take! звонки.</target>
        </trans-unit>
        <trans-unit id="1e71ad5291dbedb2322b217da37e04afff92dc9d" translate="yes" xml:space="preserve">
          <source>Multiple variables can be declared in a single &lt;code&gt;const&lt;/code&gt; statement:</source>
          <target state="translated">В одном операторе &lt;code&gt;const&lt;/code&gt; можно объявить несколько переменных :</target>
        </trans-unit>
        <trans-unit id="0d73c9901bb6c946790a83a8a87b82ef0cec1f2c" translate="yes" xml:space="preserve">
          <source>Multiple variables can be declared within a single &lt;code&gt;const&lt;/code&gt;:</source>
          <target state="translated">Несколько переменных могут быть объявлены в одном &lt;code&gt;const&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d6191bf2ae4cde6b84e3731ebe3216e641b1f925" translate="yes" xml:space="preserve">
          <source>Multiple writers in different tasks can write to the same channel concurrently via &lt;code&gt;put!&lt;/code&gt; calls.</source>
          <target state="translated">Несколько писателей, выполняющих разные задачи, могут одновременно писать в один и тот же канал через команду &lt;code&gt;put!&lt;/code&gt; звонки.</target>
        </trans-unit>
        <trans-unit id="2b9ee6e2b5fcdbd970e8f069acf17877e49e0441" translate="yes" xml:space="preserve">
          <source>Multiplication</source>
          <target state="translated">Multiplication</target>
        </trans-unit>
        <trans-unit id="08798729863d0bb7b20e1d37c363bae614f6586a" translate="yes" xml:space="preserve">
          <source>Multiplication Sign</source>
          <target state="translated">Знак умножения</target>
        </trans-unit>
        <trans-unit id="3c76df64c4a57883fa1d5a89f8c1a59b60fe613a" translate="yes" xml:space="preserve">
          <source>Multiplication Sign In Double Circle</source>
          <target state="translated">Знак умножения в двойном круге</target>
        </trans-unit>
        <trans-unit id="0cb8782430ba3b81d227b0367b8483a3aec5c585" translate="yes" xml:space="preserve">
          <source>Multiplication Sign In Left Half Circle</source>
          <target state="translated">Знак умножения в левом полуокружности</target>
        </trans-unit>
        <trans-unit id="45899b842b1e5f0e8bbcebf1613882194369635c" translate="yes" xml:space="preserve">
          <source>Multiplication Sign In Right Half Circle</source>
          <target state="translated">Знак умножения в правом полукруге</target>
        </trans-unit>
        <trans-unit id="a355acf983afd120ac915695e7bbc1cfdb422169" translate="yes" xml:space="preserve">
          <source>Multiplication Sign In Triangle</source>
          <target state="translated">Знак умножения в треугольнике</target>
        </trans-unit>
        <trans-unit id="9d1dcaf767393e94d9fb3951d203efabe4bb0dae" translate="yes" xml:space="preserve">
          <source>Multiplication Sign With Dot Above</source>
          <target state="translated">Знак умножения с точкой выше</target>
        </trans-unit>
        <trans-unit id="fbdc4c450ca5244758ddd4c66eba1288b620d400" translate="yes" xml:space="preserve">
          <source>Multiplication Sign With Underbar</source>
          <target state="translated">Сигнал умножения с подбалкой</target>
        </trans-unit>
        <trans-unit id="3d3483bdb2415560ac9652dfcab542fdcef6d607" translate="yes" xml:space="preserve">
          <source>Multiplication operator. &lt;code&gt;x*y*z*...&lt;/code&gt; calls this function with all arguments, i.e. &lt;code&gt;*(x, y, z, ...)&lt;/code&gt;.</source>
          <target state="translated">Оператор умножения. &lt;code&gt;x*y*z*...&lt;/code&gt; вызывает эту функцию со всеми аргументами, т.е. &lt;code&gt;*(x, y, z, ...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acd94b4a618f8f7ee2103c3ea81c4f51d1003fe1" translate="yes" xml:space="preserve">
          <source>Multiplication order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbab753a795402e618da8df891a564ce24521592" translate="yes" xml:space="preserve">
          <source>Multiplication with respect to either full/square or non-full/square &lt;code&gt;Q&lt;/code&gt; is allowed, i.e. both &lt;code&gt;F.Q*F.R&lt;/code&gt; and &lt;code&gt;F.Q*A&lt;/code&gt; are supported. A &lt;code&gt;Q&lt;/code&gt; matrix can be converted into a regular matrix with &lt;a href=&quot;../../base/arrays/index#Base.Matrix&quot;&gt;&lt;code&gt;Matrix&lt;/code&gt;&lt;/a&gt;. This operation returns the &quot;thin&quot; Q factor, i.e., if &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; with &lt;code&gt;m&amp;gt;=n&lt;/code&gt;, then &lt;code&gt;Matrix(F.Q)&lt;/code&gt; yields an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix with orthonormal columns. To retrieve the &quot;full&quot; Q factor, an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;m&lt;/code&gt; orthogonal matrix, use &lt;code&gt;F.Q*Matrix(I,m,m)&lt;/code&gt;. If &lt;code&gt;m&amp;lt;=n&lt;/code&gt;, then &lt;code&gt;Matrix(F.Q)&lt;/code&gt; yields an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;m&lt;/code&gt; orthogonal matrix.</source>
          <target state="translated">Разрешено умножение относительно полного / квадратного или неполного / квадратного &lt;code&gt;Q&lt;/code&gt; , т. &lt;code&gt;F.Q*F.R&lt;/code&gt; Поддерживаются как FQ * FR, так и &lt;code&gt;F.Q*A&lt;/code&gt; &lt;code&gt;Q&lt;/code&gt; матрица может быть преобразована в обычную матрицу с &lt;a href=&quot;../../base/arrays/index#Base.Matrix&quot;&gt; &lt;code&gt;Matrix&lt;/code&gt; &lt;/a&gt; . Эта операция возвращает &amp;laquo;тонкий&amp;raquo; Q-фактор, т. Е. Если &lt;code&gt;A&lt;/code&gt; имеет &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; с &lt;code&gt;m&amp;gt;=n&lt;/code&gt; , тогда &lt;code&gt;Matrix(F.Q)&lt;/code&gt; дает матрицу &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; с ортонормированными столбцами. Чтобы получить &quot;полный&quot; Q-фактор, ортогональную матрицу &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;m&lt;/code&gt; , используйте &lt;code&gt;F.Q*Matrix(I,m,m)&lt;/code&gt; . Если &lt;code&gt;m&amp;lt;=n&lt;/code&gt; , то &lt;code&gt;Matrix(F.Q)&lt;/code&gt; дает ортогональную матрицу размера &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3237fef2698864d2d4dff1442ef27b98ff896474" translate="yes" xml:space="preserve">
          <source>Multiplies the matrix &lt;code&gt;C&lt;/code&gt; by &lt;code&gt;Q&lt;/code&gt; from the transformation supplied by &lt;code&gt;tzrzf!&lt;/code&gt;. Depending on &lt;code&gt;side&lt;/code&gt; or &lt;code&gt;trans&lt;/code&gt; the multiplication can be left-sided (&lt;code&gt;side = L, Q*C&lt;/code&gt;) or right-sided (&lt;code&gt;side = R, C*Q&lt;/code&gt;) and &lt;code&gt;Q&lt;/code&gt; can be unmodified (&lt;code&gt;trans = N&lt;/code&gt;), transposed (&lt;code&gt;trans = T&lt;/code&gt;), or conjugate transposed (&lt;code&gt;trans = C&lt;/code&gt;). Returns matrix &lt;code&gt;C&lt;/code&gt; which is modified in-place with the result of the multiplication.</source>
          <target state="translated">Умножает матрицу &lt;code&gt;C&lt;/code&gt; на &lt;code&gt;Q&lt;/code&gt; из преобразования, предоставленного &lt;code&gt;tzrzf!&lt;/code&gt; , В зависимости от &lt;code&gt;side&lt;/code&gt; или &lt;code&gt;trans&lt;/code&gt; умножение может быть левосторонним ( &lt;code&gt;side = L, Q*C&lt;/code&gt; ) или правым ( &lt;code&gt;side = R, C*Q&lt;/code&gt; ), а &lt;code&gt;Q&lt;/code&gt; может быть неизменным ( &lt;code&gt;trans = N&lt;/code&gt; ), транспонированным ( &lt;code&gt;trans = T&lt;/code&gt; ) или конъюгат транспонированный ( &lt;code&gt;trans = C&lt;/code&gt; ). Возвращает матрицу &lt;code&gt;C&lt;/code&gt; , которая изменяется на месте с результатом умножения.</target>
        </trans-unit>
        <trans-unit id="51373d5164159f5426002b0598a3884a7c93923c" translate="yes" xml:space="preserve">
          <source>Multiply &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, giving the result as a larger type.</source>
          <target state="translated">Умножьте &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , чтобы получить результат в виде большего типа.</target>
        </trans-unit>
        <trans-unit id="8c2b66d02b47a40957a9bf040f2f9789a10c4a5f" translate="yes" xml:space="preserve">
          <source>Multiply elements of &lt;code&gt;A&lt;/code&gt; over the singleton dimensions of &lt;code&gt;r&lt;/code&gt;, and write results to &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Умножьте элементы &lt;code&gt;A&lt;/code&gt; на одноэлементные измерения &lt;code&gt;r&lt;/code&gt; и запишите результаты в &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb50f95d1ea0332243fc7cfb57f8206ade911927" translate="yes" xml:space="preserve">
          <source>Multiply elements of an array over the given dimensions.</source>
          <target state="translated">Умножьте элементы массива на заданные размеры.</target>
        </trans-unit>
        <trans-unit id="e702a06c59098f213dc183738514d30defe88d1d" translate="yes" xml:space="preserve">
          <source>Multiset Multiplication</source>
          <target state="translated">мультисетное умножение</target>
        </trans-unit>
        <trans-unit id="46e9543c61867442bcf25b304349df9f5d65ca32" translate="yes" xml:space="preserve">
          <source>Multiset Union</source>
          <target state="translated">Мультисеть</target>
        </trans-unit>
        <trans-unit id="c2840c311dfdf5b2dd783cb8f018f5c5edd5488d" translate="yes" xml:space="preserve">
          <source>Multithreading support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0159a2df7e34a6cc82e0f98d19901fe45423221a" translate="yes" xml:space="preserve">
          <source>Multivariate apply in R, e.g. &lt;code&gt;mapply(choose, 11:13, 1:3)&lt;/code&gt;, can be written as &lt;code&gt;broadcast(binomial, 11:13, 1:3)&lt;/code&gt; in Julia. Equivalently Julia offers a shorter dot syntax for vectorizing functions &lt;code&gt;binomial.(11:13, 1:3)&lt;/code&gt;.</source>
          <target state="translated">Многовариантное применение в R, например &lt;code&gt;mapply(choose, 11:13, 1:3)&lt;/code&gt; , может быть записано как &lt;code&gt;broadcast(binomial, 11:13, 1:3)&lt;/code&gt; в Julia. Эквивалентно Джулия предлагает более короткий синтаксис с точками для векторизации &lt;code&gt;binomial.(11:13, 1:3)&lt;/code&gt; функций (11:13, 1: 3) .</target>
        </trans-unit>
        <trans-unit id="d1eadf2c10a086c1960a9b501d59933c8974dd2b" translate="yes" xml:space="preserve">
          <source>Multplication Order</source>
          <target state="translated">Порядок умножения</target>
        </trans-unit>
        <trans-unit id="aa146572cac44a8146d28c8ac452ea7d13c9ab21" translate="yes" xml:space="preserve">
          <source>Mushroom</source>
          <target state="translated">Mushroom</target>
        </trans-unit>
        <trans-unit id="a46b6d28712c4b7b4707908d1e571236cf12721a" translate="yes" xml:space="preserve">
          <source>Music Flat Sign / Flat</source>
          <target state="translated">Музыка Плоская вывеска/Плоская</target>
        </trans-unit>
        <trans-unit id="a04232f01f8df8edaadcea411ff36f7f6487ee84" translate="yes" xml:space="preserve">
          <source>Music Natural Sign / Natural</source>
          <target state="translated">Музыка Натуральный знак/Натуральный</target>
        </trans-unit>
        <trans-unit id="26d750dc923f792f858ed732c6ec0b1da0e99959" translate="yes" xml:space="preserve">
          <source>Music Sharp Sign / Sharp</source>
          <target state="translated">Музыка Резкий знак/Резкий</target>
        </trans-unit>
        <trans-unit id="683e80dc8a4c6e7c8bc826f53b6dfcf0a6bda4f2" translate="yes" xml:space="preserve">
          <source>Musical Keyboard</source>
          <target state="translated">Музыкальная клавиатура</target>
        </trans-unit>
        <trans-unit id="b65f0abd74cb5797c41071b0a9e2cddd68e16857" translate="yes" xml:space="preserve">
          <source>Musical Note</source>
          <target state="translated">Музыкальная нота</target>
        </trans-unit>
        <trans-unit id="2dfa13073285efc9898a345a8260636406d435b4" translate="yes" xml:space="preserve">
          <source>Musical Score</source>
          <target state="translated">Музыкальный балл</target>
        </trans-unit>
        <trans-unit id="b526f688cce16763794e58f91f1fb89b4e382f22" translate="yes" xml:space="preserve">
          <source>Mutable Composite Types</source>
          <target state="translated">Мутируемые композитные типы</target>
        </trans-unit>
        <trans-unit id="3c9af487b0eb75065e220e4b4f64315251059f6d" translate="yes" xml:space="preserve">
          <source>Mutable collections</source>
          <target state="translated">Мутируемые коллекции</target>
        </trans-unit>
        <trans-unit id="f1b1ed439ba2f9dd0159774d9902013a44e5bafb" translate="yes" xml:space="preserve">
          <source>Mutable values, on the other hand are heap-allocated and passed to functions as pointers to heap-allocated values except in cases where the compiler is sure that there's no way to tell that this is not what is happening.</source>
          <target state="translated">Мутируемые значения,с другой стороны,являются heap-allocated и передаются в функции как указатели на heap-allocated значения,за исключением случаев,когда компилятор уверен,что это не то,что происходит.</target>
        </trans-unit>
        <trans-unit id="d562bdafddbc28a1463062065c657c4bc9672cc9" translate="yes" xml:space="preserve">
          <source>Mutation of the bounds of the underlying array will invalidate this iterator.</source>
          <target state="translated">Мутация границ базового массива сделает этот итератор недействительным.</target>
        </trans-unit>
        <trans-unit id="2c601014fa28760ad8ec66e89966537368e4cbb2" translate="yes" xml:space="preserve">
          <source>N-Ary Circled Dot Operator</source>
          <target state="translated">N-Ary Circled Dot Operator</target>
        </trans-unit>
        <trans-unit id="9b908a94b34698b4d9b7b0207be4158da2feb778" translate="yes" xml:space="preserve">
          <source>N-Ary Circled Plus Operator</source>
          <target state="translated">N-Ary Circled Plus Оператор</target>
        </trans-unit>
        <trans-unit id="2fd5ce147977305f56f82ccf66ec27699a2f05e0" translate="yes" xml:space="preserve">
          <source>N-Ary Circled Times Operator</source>
          <target state="translated">N-Ary Circled Times Operator</target>
        </trans-unit>
        <trans-unit id="9a70409166d87ecdf40d895d65a2de86858c7d72" translate="yes" xml:space="preserve">
          <source>N-Ary Coproduct</source>
          <target state="translated">N-Ари Попутный продукт</target>
        </trans-unit>
        <trans-unit id="a39e136f6e4c1d1091281d6e70793affbdc62596" translate="yes" xml:space="preserve">
          <source>N-Ary Intersection</source>
          <target state="translated">N-Арийский перекресток</target>
        </trans-unit>
        <trans-unit id="75cd531fa98b88aa4c1ea0f5aad0923bb35686de" translate="yes" xml:space="preserve">
          <source>N-Ary Logical And</source>
          <target state="translated">N-Ary Logical And</target>
        </trans-unit>
        <trans-unit id="4cd0377615b0c0c9e50ec272b87620b1882f58ce" translate="yes" xml:space="preserve">
          <source>N-Ary Logical Or</source>
          <target state="translated">N-Ари Логический Или</target>
        </trans-unit>
        <trans-unit id="12a25a06e9c573bc3729989159399e1d0bee4414" translate="yes" xml:space="preserve">
          <source>N-Ary Product</source>
          <target state="translated">N-Арийский продукт</target>
        </trans-unit>
        <trans-unit id="9bceaf94be234c09815c4e2f3473560766a97e3a" translate="yes" xml:space="preserve">
          <source>N-Ary Square Intersection Operator</source>
          <target state="translated">Оператор пересечения площади N-Ари</target>
        </trans-unit>
        <trans-unit id="9acad29f71e0c492d455e428791c8757b2902981" translate="yes" xml:space="preserve">
          <source>N-Ary Square Union Operator</source>
          <target state="translated">Оператор профсоюза &quot;N-Арийская площадь</target>
        </trans-unit>
        <trans-unit id="5fc7d374c42e4f2df4bcb04f0f33dc4c12531c00" translate="yes" xml:space="preserve">
          <source>N-Ary Summation</source>
          <target state="translated">N-Арийское суммирование</target>
        </trans-unit>
        <trans-unit id="22be9150d2380639b3cc7120e2b0ad3eb38c0c10" translate="yes" xml:space="preserve">
          <source>N-Ary Times Operator</source>
          <target state="translated">N-Ари Таймс Оператор</target>
        </trans-unit>
        <trans-unit id="81f1103959c04f566d198e3617a3b0a0b4932170" translate="yes" xml:space="preserve">
          <source>N-Ary Union</source>
          <target state="translated">N-Арийский союз</target>
        </trans-unit>
        <trans-unit id="a7b227350c7615a207de1206fdd8cd99b07f317f" translate="yes" xml:space="preserve">
          <source>N-Ary Union Operator With Dot</source>
          <target state="translated">N-Ary оператор союза с точкой</target>
        </trans-unit>
        <trans-unit id="fc811ee4937db532790cf25d7cb94a1efeaa332a" translate="yes" xml:space="preserve">
          <source>N-Ary Union Operator With Plus</source>
          <target state="translated">N-Ary Union Оператор с Плюс</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="f7fd9c68f804acda665d2ab082217bb1583318f2" translate="yes" xml:space="preserve">
          <source>NaN</source>
          <target state="translated">NaN</target>
        </trans-unit>
        <trans-unit id="84eca33f462fff1d82716a00bb1a9da6eef01b51" translate="yes" xml:space="preserve">
          <source>NaN16</source>
          <target state="translated">NaN16</target>
        </trans-unit>
        <trans-unit id="c1186f579effcba17fc840178088ad9180ffa477" translate="yes" xml:space="preserve">
          <source>NaN32</source>
          <target state="translated">NaN32</target>
        </trans-unit>
        <trans-unit id="c04255172c46885eea43e832178b016bfeeae55b" translate="yes" xml:space="preserve">
          <source>Nabla</source>
          <target state="translated">Nabla</target>
        </trans-unit>
        <trans-unit id="1ef8040bc58bb62eac4b1f05cdee5404fd80b514" translate="yes" xml:space="preserve">
          <source>Nail Polish</source>
          <target state="translated">лак для ногтей</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="f0625d2052ba9bb5afda3d21d6721388e5f4c4b1" translate="yes" xml:space="preserve">
          <source>Name Badge</source>
          <target state="translated">Имя Значок</target>
        </trans-unit>
        <trans-unit id="da36348ca4a6d538eb48f90ec86de8739a592351" translate="yes" xml:space="preserve">
          <source>Named Tuple Types</source>
          <target state="translated">Названные типы кортежей</target>
        </trans-unit>
        <trans-unit id="00f19d99a1a121465f53068cd3e37c47ef1fad72" translate="yes" xml:space="preserve">
          <source>Named Tuples</source>
          <target state="translated">Именной кортеж</target>
        </trans-unit>
        <trans-unit id="dc6d9efdb67defed4600406bfad7cbe046812758" translate="yes" xml:space="preserve">
          <source>Named and numbered footnote references can be written using the following syntax. A footnote name must be a single alphanumeric word containing no punctuation.</source>
          <target state="translated">Названные и пронумерованные ссылки в сносках могут быть написаны с использованием следующего синтаксиса.Имя сноски должно быть одним буквенно-цифровым словом,не содержащим знаков препинания.</target>
        </trans-unit>
        <trans-unit id="72be3008659f32677ce2d2404bd56f83680d29f1" translate="yes" xml:space="preserve">
          <source>Named tuples are instances of the &lt;a href=&quot;../../base/base/index#Core.NamedTuple&quot;&gt;&lt;code&gt;NamedTuple&lt;/code&gt;&lt;/a&gt; type, which has two parameters: a tuple of symbols giving the field names, and a tuple type giving the field types.</source>
          <target state="translated">Именованные кортежи - это экземпляры типа &lt;a href=&quot;../../base/base/index#Core.NamedTuple&quot;&gt; &lt;code&gt;NamedTuple&lt;/code&gt; &lt;/a&gt; , который имеет два параметра: кортеж символов, дающий имена полей, и тип кортежа, дающий типы полей.</target>
        </trans-unit>
        <trans-unit id="3b5d82adfa43b289c6963f7407c953d4e61d46b7" translate="yes" xml:space="preserve">
          <source>Named tuples are very similar to tuples, except that fields can additionally be accessed by name using dot syntax (&lt;code&gt;x.a&lt;/code&gt;) in addition to the regular indexing syntax (&lt;code&gt;x[1]&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6a4d10273503fa27f8c46a18767ab4521c07a3" translate="yes" xml:space="preserve">
          <source>Named tuples are very similar to tuples, except that fields can additionally be accessed by name using dot syntax (&lt;code&gt;x.a&lt;/code&gt;).</source>
          <target state="translated">Именованные кортежи очень похожи на кортежи, за исключением того, что к полям можно дополнительно обращаться по имени, используя синтаксис с точкой ( &lt;code&gt;x.a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f45cc1e50f55d768c6a39cd232336976b7732dfc" translate="yes" xml:space="preserve">
          <source>Names of &lt;code&gt;Type&lt;/code&gt;s and &lt;code&gt;Module&lt;/code&gt;s begin with a capital letter and word separation is shown with upper camel case instead of underscores.</source>
          <target state="translated">Имена &lt;code&gt;Type&lt;/code&gt; и &lt;code&gt;Module&lt;/code&gt; начинаются с заглавной буквы, а разделение слов отображается верхним регистром вместо подчеркивания.</target>
        </trans-unit>
        <trans-unit id="669b5c2a0af852115b81963203fce679df22a31e" translate="yes" xml:space="preserve">
          <source>Names of &lt;code&gt;function&lt;/code&gt;s and &lt;code&gt;macro&lt;/code&gt;s are in lower case, without underscores.</source>
          <target state="translated">Имена &lt;code&gt;function&lt;/code&gt; и &lt;code&gt;macro&lt;/code&gt; пишутся строчными буквами без подчеркивания.</target>
        </trans-unit>
        <trans-unit id="315abfa13d69446ee3cab0a04d182cc545dfb2c3" translate="yes" xml:space="preserve">
          <source>Names of variables are in lower case.</source>
          <target state="translated">Имена переменных находятся в нижнем регистре.</target>
        </trans-unit>
        <trans-unit id="6caeb19c64bfdb2c7f9f0778d9792f83f81ab4c7" translate="yes" xml:space="preserve">
          <source>Namespace miscellanea</source>
          <target state="translated">Namespace miscellany</target>
        </trans-unit>
        <trans-unit id="81767a14b5865561a4a0f909d1a970b4158b5af2" translate="yes" xml:space="preserve">
          <source>Nand</source>
          <target state="translated">Nand</target>
        </trans-unit>
        <trans-unit id="67491a6c4d2a113101836cc6410bc0b315f4cb77" translate="yes" xml:space="preserve">
          <source>Naturally, it is possible for quote expressions to contain other quote expressions. Understanding how interpolation works in these cases can be a bit tricky. Consider this example:</source>
          <target state="translated">Естественно,возможно,что выражения в кавычках будут содержать другие выражения в кавычках.Понимание того,как работает интерполяция в этих случаях,может быть немного сложно.Рассмотрим этот пример:</target>
        </trans-unit>
        <trans-unit id="ff1b33b1d17b9acbddf9cac2115963e31d8b21a5" translate="yes" xml:space="preserve">
          <source>Navigate to your temporary directory and launch Julia, then do the following:</source>
          <target state="translated">Перейдите в свой временный каталог и запустите Джулию,затем сделайте следующее:</target>
        </trans-unit>
        <trans-unit id="8841f81b26ad9918dae04823591307ed2dd7da48" translate="yes" xml:space="preserve">
          <source>Necktie</source>
          <target state="translated">Necktie</target>
        </trans-unit>
        <trans-unit id="3ecd749b905c6977df0e77186fb9812acf0f28a8" translate="yes" xml:space="preserve">
          <source>Negated Double Vertical Bar Double Right Turnstile</source>
          <target state="translated">Отрицательный двойной вертикальный пруток двойной правый турникет</target>
        </trans-unit>
        <trans-unit id="ffe87c942f9f7bfee31e0905a674a7acab19a578" translate="yes" xml:space="preserve">
          <source>Negation of &lt;code&gt;&amp;isin;&lt;/code&gt; and &lt;code&gt;&amp;ni;&lt;/code&gt;, i.e. checks that &lt;code&gt;item&lt;/code&gt; is not in &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">Отрицание &lt;code&gt;&amp;isin;&lt;/code&gt; и &lt;code&gt;&amp;ni;&lt;/code&gt; , то есть проверяет , что &lt;code&gt;item&lt;/code&gt; не в &lt;code&gt;collection&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1931659c9e1b4ce9d7ec399d6f5e740532d35d3" translate="yes" xml:space="preserve">
          <source>Negation of &lt;code&gt;&amp;sube;&lt;/code&gt; and &lt;code&gt;&amp;supe;&lt;/code&gt;, i.e. checks that &lt;code&gt;a&lt;/code&gt; is not a subset of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Отрицание &lt;code&gt;&amp;sube;&lt;/code&gt; и &lt;code&gt;&amp;supe;&lt;/code&gt; , т.е. проверка того, что &lt;code&gt;a&lt;/code&gt; не является подмножеством &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c97b9bfba068fbd7a3a1fa54e3ccb57a97d94eb2" translate="yes" xml:space="preserve">
          <source>Negative Squared Ab</source>
          <target state="translated">отрицательный квадрат Аб</target>
        </trans-unit>
        <trans-unit id="fb3bdc3efad3dd419c1cb492507357bf8831cc24" translate="yes" xml:space="preserve">
          <source>Negative Squared Cross Mark</source>
          <target state="translated">Отрицательный квадратный знак креста</target>
        </trans-unit>
        <trans-unit id="7d7b2e1e90ccc0cf1ee98411e4a3d9f188ae7074" translate="yes" xml:space="preserve">
          <source>Negative Squared Latin Capital Letter A</source>
          <target state="translated">Отрицательный квадрат Латинская заглавная буква А</target>
        </trans-unit>
        <trans-unit id="304d28b12dcf81b90eb5e22beadebcff60a1f7d6" translate="yes" xml:space="preserve">
          <source>Negative Squared Latin Capital Letter B</source>
          <target state="translated">Отрицательный квадрат Латинская заглавная буква B</target>
        </trans-unit>
        <trans-unit id="0c862d7b34ecee68029345c3bf7b39b898342164" translate="yes" xml:space="preserve">
          <source>Negative Squared Latin Capital Letter O</source>
          <target state="translated">Отрицательная квадратная латинская заглавная буква О</target>
        </trans-unit>
        <trans-unit id="6a6308babfec9e69cdff52893e394748de4b3b29" translate="yes" xml:space="preserve">
          <source>Negative Squared Latin Capital Letter P</source>
          <target state="translated">Отрицательный квадрат Латинская заглавная буква P</target>
        </trans-unit>
        <trans-unit id="ffbd11351af129f60826174098cbdf05e74f050f" translate="yes" xml:space="preserve">
          <source>Neither &lt;code&gt;convert&lt;/code&gt; nor &lt;code&gt;cconvert&lt;/code&gt; should take a Julia object and turn it into a &lt;code&gt;Ptr&lt;/code&gt;.</source>
          <target state="translated">Ни &lt;code&gt;convert&lt;/code&gt; , ни &lt;code&gt;cconvert&lt;/code&gt; не должны принимать объект Julia и превращать его в &lt;code&gt;Ptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="233c2a39e94063ce181611891dcdd95a1291b1a5" translate="yes" xml:space="preserve">
          <source>Neither A Subset Of Nor Equal To</source>
          <target state="translated">Ни подмножество,ни равное</target>
        </trans-unit>
        <trans-unit id="c927af76b71cf28775cab6c0bc644144b321e55f" translate="yes" xml:space="preserve">
          <source>Neither A Superset Of Nor Equal To</source>
          <target state="translated">Ни супер набор,ни равный</target>
        </trans-unit>
        <trans-unit id="1b6ef024104f196dec9cbcb30309372186d114d7" translate="yes" xml:space="preserve">
          <source>Neither Approximately Nor Actually Equal To</source>
          <target state="translated">Ни приблизительно,ни фактически не равнозначно</target>
        </trans-unit>
        <trans-unit id="f956227c83f5924a3ea073b24bb6bd1a835fcb86" translate="yes" xml:space="preserve">
          <source>Neither Greater-Than Nor Equal To / Neither Greater Than Nor Equal To</source>
          <target state="translated">Ни больше,ни больше,ни больше,ни больше,ни больше,ни меньше.</target>
        </trans-unit>
        <trans-unit id="53a8706df6fc90ce626526d16857164211520a7a" translate="yes" xml:space="preserve">
          <source>Neither Greater-Than Nor Equivalent To / Neither Greater Than Nor Equivalent To</source>
          <target state="translated">Ни больше,ни больше,ни эквивалентна.</target>
        </trans-unit>
        <trans-unit id="6e188aa5a652ee8d5842cae5b3d3116acba271aa" translate="yes" xml:space="preserve">
          <source>Neither Greater-Than Nor Less-Than / Neither Greater Than Nor Less Than</source>
          <target state="translated">Ни больше,ни меньше,ни больше,ни меньше.</target>
        </trans-unit>
        <trans-unit id="5879307721237ad3ad1ce3bf914eafeb074a68e7" translate="yes" xml:space="preserve">
          <source>Neither Less-Than Nor Equal To / Neither Less Than Nor Equal To</source>
          <target state="translated">Ни меньше,ни меньше,ни меньше,ни меньше,ни меньше.</target>
        </trans-unit>
        <trans-unit id="ba60a77dfac9693c527e4257a55200358bb7ed68" translate="yes" xml:space="preserve">
          <source>Neither Less-Than Nor Equivalent To / Neither Less Than Nor Equivalent To</source>
          <target state="translated">Ни меньше,ни равнозначно/не меньше,чем равнозначно/не равнозначно</target>
        </trans-unit>
        <trans-unit id="05b8c2fde6692011493ae29c78dc0887e72418f7" translate="yes" xml:space="preserve">
          <source>Neither Less-Than Nor Greater-Than / Neither Less Than Nor Greater Than</source>
          <target state="translated">Ни меньше,ни больше,ни меньше,ни больше...</target>
        </trans-unit>
        <trans-unit id="8eaf74d125ce35ab9a8504c91cbc3fd36b5155df" translate="yes" xml:space="preserve">
          <source>Neither juxtaposition of two parenthesized expressions, nor placing a variable before a parenthesized expression, however, can be used to imply multiplication:</source>
          <target state="translated">Однако ни сопоставление двух выражений в круглых скобках,ни помещение переменной перед выражением в круглых скобках не может быть использовано для подразумевания умножения:</target>
        </trans-unit>
        <trans-unit id="125186d5ff63f69c3e2321b1e81aa13d69cff28e" translate="yes" xml:space="preserve">
          <source>Neptune</source>
          <target state="translated">Neptune</target>
        </trans-unit>
        <trans-unit id="8b4fbd05fd436fc9d45e06e93c5beb9d6849ca86" translate="yes" xml:space="preserve">
          <source>Nested quote</source>
          <target state="translated">Вложенная цитата</target>
        </trans-unit>
        <trans-unit id="552146d37d66cb78074b5849a522f96a5d21589c" translate="yes" xml:space="preserve">
          <source>Network I/O</source>
          <target state="translated">Сетевой ввод/вывод</target>
        </trans-unit>
        <trans-unit id="c0a64e9ee73a50340ce5cfbcba50917cd8be1ac8" translate="yes" xml:space="preserve">
          <source>Network Requirements for LocalManager and SSHManager</source>
          <target state="translated">Сетевые требования для LocalManager и SSHManager</target>
        </trans-unit>
        <trans-unit id="3a55c8cb72838904c479c39b6e41b29c517f702a" translate="yes" xml:space="preserve">
          <source>Networking and Streams</source>
          <target state="translated">Сети и потоки</target>
        </trans-unit>
        <trans-unit id="a54631a938fc351480252a8fbf952417324a21a2" translate="yes" xml:space="preserve">
          <source>Neuter</source>
          <target state="translated">Neuter</target>
        </trans-unit>
        <trans-unit id="d1b0bf8b5a4f962ac54b72ec0f3e2249c35062e8" translate="yes" xml:space="preserve">
          <source>Neutral Face</source>
          <target state="translated">нейтральное лицо</target>
        </trans-unit>
        <trans-unit id="b4dda3e4d7496caa2e8efb358bf65c52a3c57038" translate="yes" xml:space="preserve">
          <source>New Moon Symbol</source>
          <target state="translated">новолуние</target>
        </trans-unit>
        <trans-unit id="5162116d9d9cdaee88a84b1fdffa1911b0cf303d" translate="yes" xml:space="preserve">
          <source>New Moon With Face</source>
          <target state="translated">Новолуние с лицом</target>
        </trans-unit>
        <trans-unit id="4e0a4bfd07ff7fd179ef28a5c32dcfb6bc100f78" translate="yes" xml:space="preserve">
          <source>New atomic objects can be created from a non-atomic values; if none is specified, the atomic object is initialized with zero.</source>
          <target state="translated">Новые атомарные объекты могут быть созданы из неатомарных значений;если ни одно из них не указано,то атомарный объект инициализируется нулем.</target>
        </trans-unit>
        <trans-unit id="42da565d7b3c34bde47eabec6e6f2994bbe6f925" translate="yes" xml:space="preserve">
          <source>New global bindings are created on destination workers if they are referenced as part of a remote call.</source>
          <target state="translated">Новые глобальные привязки создаются на целевых работниках,если на них ссылаются как на часть удаленного вызова.</target>
        </trans-unit>
        <trans-unit id="0fcf5911a9a18167d53b9c21f18e27ba0cdf0f2d" translate="yes" xml:space="preserve">
          <source>New line, executing if it is complete</source>
          <target state="translated">Новая строка,выполняющаяся,если она закончена</target>
        </trans-unit>
        <trans-unit id="4bf7ffd18bc132813bddeb711b1027143b9438b3" translate="yes" xml:space="preserve">
          <source>New numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.</source>
          <target state="translated">Новые числовые типы должны реализовывать эту функцию для двух аргументов нового типа и обрабатывать сравнение с другими типами с помощью правил продвижения,где это возможно.</target>
        </trans-unit>
        <trans-unit id="bab8bf1f9729e23910958279e9c76398ca6d35f4" translate="yes" xml:space="preserve">
          <source>New numeric types with a canonical partial order should implement this function for two arguments of the new type. Types with a canonical total order should implement &lt;a href=&quot;../base/index#Base.isless&quot;&gt;&lt;code&gt;isless&lt;/code&gt;&lt;/a&gt; instead. (x &amp;lt; y) | (x == y)</source>
          <target state="translated">Новые числовые типы с каноническим частичным порядком должны реализовывать эту функцию для двух аргументов нового типа. &lt;a href=&quot;../base/index#Base.isless&quot;&gt; &lt;code&gt;isless&lt;/code&gt; &lt;/a&gt; этого следует реализовать isless для типов с каноническим общим порядком . (х &amp;lt;у) | (х == у)</target>
        </trans-unit>
        <trans-unit id="4375e0864ac979046f6e07a8e572643b3f85eecd" translate="yes" xml:space="preserve">
          <source>New objects of type &lt;code&gt;Foo&lt;/code&gt; are created by applying the &lt;code&gt;Foo&lt;/code&gt; type object like a function to values for its fields:</source>
          <target state="translated">Новые объекты типа &lt;code&gt;Foo&lt;/code&gt; создаются путем применения объекта типа &lt;code&gt;Foo&lt;/code&gt; как функции к значениям его полей:</target>
        </trans-unit>
        <trans-unit id="c14debc183a7a71d36ba349a00f8d8faf55873b6" translate="yes" xml:space="preserve">
          <source>New types should generally not implement this, and rely on the fallback definition &lt;code&gt;!=(x,y) = !(x==y)&lt;/code&gt; instead.</source>
          <target state="translated">Новые типы обычно не должны реализовывать это, и вместо этого полагаются на определение запасного варианта &lt;code&gt;!=(x,y) = !(x==y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5288a6ff5118bf7315848b31718dedea3e423463" translate="yes" xml:space="preserve">
          <source>New types should implement the 2-argument form, typically by calling the 2-argument &lt;code&gt;hash&lt;/code&gt; method recursively in order to mix hashes of the contents with each other (and with &lt;code&gt;h&lt;/code&gt;). Typically, any type that implements &lt;code&gt;hash&lt;/code&gt; should also implement its own &lt;code&gt;==&lt;/code&gt; (hence &lt;code&gt;isequal&lt;/code&gt;) to guarantee the property mentioned above. Types supporting subtraction (operator &lt;code&gt;-&lt;/code&gt;) should also implement &lt;a href=&quot;#Base.widen&quot;&gt;&lt;code&gt;widen&lt;/code&gt;&lt;/a&gt;, which is required to hash values inside heterogeneous arrays.</source>
          <target state="translated">Новые типы должны реализовывать форму с двумя аргументами, как правило, путем рекурсивного вызова метода &lt;code&gt;hash&lt;/code&gt; с двумя аргументами , чтобы смешивать хэши содержимого друг с другом (и с &lt;code&gt;h&lt;/code&gt; ). Как правило, любой тип, реализующий &lt;code&gt;hash&lt;/code&gt; также должен реализовывать свой собственный &lt;code&gt;==&lt;/code&gt; (следовательно, &lt;code&gt;isequal&lt;/code&gt; ), чтобы гарантировать свойство, упомянутое выше. Типы, поддерживающие вычитание (оператор &lt;code&gt;-&lt;/code&gt; ), также должны реализовывать &lt;a href=&quot;#Base.widen&quot;&gt; &lt;code&gt;widen&lt;/code&gt; &lt;/a&gt; , которое требуется для хеширования значений внутри гетерогенных массивов.</target>
        </trans-unit>
        <trans-unit id="8ebfdd35568644f8081c35fc3f12a59a472803b6" translate="yes" xml:space="preserve">
          <source>Newly launched workers are connected to each other and the master process in an all-to-all manner. Specifying the command line argument &lt;code&gt;--worker[=&amp;lt;cookie&amp;gt;]&lt;/code&gt; results in the launched processes initializing themselves as workers and connections being set up via TCP/IP sockets.</source>
          <target state="translated">Вновь запущенные воркеры полностью связаны друг с другом и с главным процессом. Указание аргумента командной строки &lt;code&gt;--worker[=&amp;lt;cookie&amp;gt;]&lt;/code&gt; приводит к тому, что запущенные процессы инициализируются как рабочие, а соединения устанавливаются через сокеты TCP / IP.</target>
        </trans-unit>
        <trans-unit id="5ebe6500747dd5dbad08cc1b33d55fac89ccbe97" translate="yes" xml:space="preserve">
          <source>Newspaper</source>
          <target state="translated">Newspaper</target>
        </trans-unit>
        <trans-unit id="5bd14d065cae3dc87a51a7f9bf093bcd68b07382" translate="yes" xml:space="preserve">
          <source>Next integer greater than or equal to &lt;code&gt;n&lt;/code&gt; that can be written as $\prod k_i^{p_i}$ for integers $p_1$, $p_2$, etc.</source>
          <target state="translated">Следующее целое число, большее или равное &lt;code&gt;n&lt;/code&gt; , которое может быть записано как $ \ prod k_i ^ {p_i} $ для целых чисел $ p_1 $, $ p_2 $ и т. Д.</target>
        </trans-unit>
        <trans-unit id="aba200342ccf03d1bafb26bcbb6342a3a0b1643f" translate="yes" xml:space="preserve">
          <source>Next, define the kernel:</source>
          <target state="translated">Далее,определите ядро:</target>
        </trans-unit>
        <trans-unit id="7f9875a180491e1b45f1d0759452d83c8b960ad6" translate="yes" xml:space="preserve">
          <source>Next, if the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is followed by a newline, the newline is stripped from the resulting string.</source>
          <target state="translated">Затем, если за открывающим символом &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; следует новая строка, новая строка удаляется из результирующей строки.</target>
        </trans-unit>
        <trans-unit id="c98ca6cb45da2e13d7f7832cf79ad9c6c39a9b49" translate="yes" xml:space="preserve">
          <source>Nicholas J. Higham, &quot;The squaring and scaling method for the matrix exponential revisited&quot;, SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. &lt;a href=&quot;https://doi.org/10.1137/090768539&quot;&gt;doi:10.1137/090768539&lt;/a&gt;</source>
          <target state="translated">Николас Дж. Хайэм, &amp;laquo;Повторное обращение к методу возведения в квадрат и масштабирования для экспоненциальной матрицы&amp;raquo;, Журнал SIAM по матричному анализу и приложениям, 26 (4), 2005, 1179-1193. &lt;a href=&quot;https://doi.org/10.1137/090768539&quot;&gt;DOI: 10,1137 / 090768539&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a9839fb83bfc341f1b5011bf886013fa6dc9c85" translate="yes" xml:space="preserve">
          <source>Night With Stars</source>
          <target state="translated">Ночь со звездами</target>
        </trans-unit>
        <trans-unit id="3b4b68ee82d1457f561bcf2ebd93545d2930b673" translate="yes" xml:space="preserve">
          <source>No Bicycles</source>
          <target state="translated">Велосипедов нет</target>
        </trans-unit>
        <trans-unit id="300395a40ea5ba24b06bf5bebc77f5acb519cd26" translate="yes" xml:space="preserve">
          <source>No Entry</source>
          <target state="translated">Нет Входа</target>
        </trans-unit>
        <trans-unit id="1dc67672d1e78df9c7a3ae0058c325f42dbcd6e3" translate="yes" xml:space="preserve">
          <source>No Entry Sign</source>
          <target state="translated">Знак отсутствия входа</target>
        </trans-unit>
        <trans-unit id="7c763368e2dec5b9f5a836da233b2fdd7abcf76a" translate="yes" xml:space="preserve">
          <source>No Mobile Phones</source>
          <target state="translated">Мобильные телефоны отсутствуют</target>
        </trans-unit>
        <trans-unit id="73a75f5a045c4f409b30178f7e28e222115eaf07" translate="yes" xml:space="preserve">
          <source>No One Under Eighteen Symbol</source>
          <target state="translated">Никто до восемнадцати лет Символ</target>
        </trans-unit>
        <trans-unit id="f30174bd862c1b850d5daf2da97d7d2e0ea07764" translate="yes" xml:space="preserve">
          <source>No Pedestrians</source>
          <target state="translated">У пешеходов</target>
        </trans-unit>
        <trans-unit id="d7ef380838898f831b1fb3b2b043fc3b8530cc7f" translate="yes" xml:space="preserve">
          <source>No Smoking Symbol</source>
          <target state="translated">Символ отказа от курения</target>
        </trans-unit>
        <trans-unit id="57eab258ddc4b2c598877a443b028f20a035c6a3" translate="yes" xml:space="preserve">
          <source>No checks are done during parsing to make sure that all footnote references have matching footnotes.</source>
          <target state="translated">Во время парсинга не производится проверка,чтобы убедиться,что все ссылки в сносках имеют совпадающие надписи.</target>
        </trans-unit>
        <trans-unit id="13a6288d973ec4996b49f9948606ae303dc2af4c" translate="yes" xml:space="preserve">
          <source>No code reload / cache invalidation is performed after changes are made to the source files themselves, (including by &lt;code&gt;Pkg.update&lt;/code&gt;), and no cleanup is done after &lt;code&gt;Pkg.rm&lt;/code&gt;</source>
          <target state="translated">Перезагрузка кода / аннулирование кеша не выполняется после внесения изменений в сами исходные файлы (в том числе с помощью &lt;code&gt;Pkg.update&lt;/code&gt; ), а очистка не выполняется после &lt;code&gt;Pkg.rm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecbe7bcfebb243ae01bf8cd3e5a27e1861e41f26" translate="yes" xml:space="preserve">
          <source>No iteration ever waits on a previous iteration to make forward progress.</source>
          <target state="translated">Никакая итерация никогда не ждет предыдущей итерации,чтобы продвинуться вперед.</target>
        </trans-unit>
        <trans-unit id="3e52b264d00ad4e4f1bda0e1a691bb9244f886ba" translate="yes" xml:space="preserve">
          <source>No more data was available to read from a file or stream.</source>
          <target state="translated">Больше не было возможности прочитать данные из файла или потока.</target>
        </trans-unit>
        <trans-unit id="9fef04914268ffcfc814a2c459f624e4fffeea1f" translate="yes" xml:space="preserve">
          <source>No need to vectorize code for performance; devectorized code is fast</source>
          <target state="translated">Нет необходимости векторизовать код для производительности,детектированный код быстр.</target>
        </trans-unit>
        <trans-unit id="0b4cf4302bd72eb2ed70f2329341a5c0f835663c" translate="yes" xml:space="preserve">
          <source>No, you are not allowed to have a &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; statement inside a function. If you want to import a module but only use its symbols inside a specific function or set of functions, you have two options:</source>
          <target state="translated">Нет, вам не разрешено иметь внутри функции оператор &lt;code&gt;using&lt;/code&gt; или &lt;code&gt;import&lt;/code&gt; . Если вы хотите импортировать модуль, но использовать его символы только внутри определенной функции или набора функций, у вас есть два варианта:</target>
        </trans-unit>
        <trans-unit id="b8b9f1367ad6269845f5ec54d66262066092883f" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">No.</target>
        </trans-unit>
        <trans-unit id="e8031546b21c9103c8369b938a711ee94aa6cb0c" translate="yes" xml:space="preserve">
          <source>Nomenclature: while the term &quot;constructor&quot; generally refers to the entire function which constructs objects of a type, it is common to abuse terminology slightly and refer to specific constructor methods as &quot;constructors&quot;. In such situations, it is generally clear from the context that the term is used to mean &quot;constructor method&quot; rather than &quot;constructor function&quot;, especially as it is often used in the sense of singling out a particular method of the constructor from all of the others.</source>
          <target state="translated">Номенклатура:в то время как термин &quot;конструктор&quot;,как правило,относится ко всей функции,которая конструирует объекты того или иного типа,принято немного злоупотреблять терминологией и называть конкретные методы конструкторов &quot;конструкторами&quot;.В таких ситуациях из контекста обычно ясно,что этот термин используется для обозначения &quot;метода конструктора&quot;,а не &quot;функции конструктора&quot;,тем более,что он часто используется в смысле выделения конкретного метода конструктора из всех остальных.</target>
        </trans-unit>
        <trans-unit id="5393bce9c456b5dccf1b10b47f64ec8dceba68b0" translate="yes" xml:space="preserve">
          <source>Non recursive version of &lt;a href=&quot;#Base.@macroexpand&quot;&gt;&lt;code&gt;@macroexpand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Нерекурсивная версия &lt;a href=&quot;#Base.@macroexpand&quot;&gt; &lt;code&gt;@macroexpand&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4fd4f1970b7db3e3254ed0b122568de524763f9c" translate="yes" xml:space="preserve">
          <source>Non-Potable Water Symbol</source>
          <target state="translated">Символ воды не для переноски</target>
        </trans-unit>
        <trans-unit id="924dd85922c4b4ff6e591e92e7dda2c98a76eb77" translate="yes" xml:space="preserve">
          <source>Non-Standard String Literals</source>
          <target state="translated">нестандартные струнные литералы</target>
        </trans-unit>
        <trans-unit id="9b186b7c2f679f7744cb664b1882bcc1ac565fe3" translate="yes" xml:space="preserve">
          <source>Non-associative</source>
          <target state="translated">Non-associative</target>
        </trans-unit>
        <trans-unit id="48fc3ac98a8542a16b7dcf01a843d3f0fabfb8c5" translate="yes" xml:space="preserve">
          <source>Non-boolean integers</source>
          <target state="translated">Небуланские целые числа</target>
        </trans-unit>
        <trans-unit id="4b33187713b64697a972670418561cf355a2a01e" translate="yes" xml:space="preserve">
          <source>Non-constant Function Specifications</source>
          <target state="translated">Непостоянные функциональные спецификации</target>
        </trans-unit>
        <trans-unit id="f7f79c9047efe79f312570b471a63dcc86aa67b7" translate="yes" xml:space="preserve">
          <source>Non-numeric types with a total order should implement this function. Numeric types only need to implement it if they have special values such as &lt;code&gt;NaN&lt;/code&gt;. Types with a partial order should implement &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">Эту функцию должны реализовывать нечисловые типы с полным порядком. Числовые типы должны реализовывать это только в том случае, если они имеют специальные значения, такие как &lt;code&gt;NaN&lt;/code&gt; . Типы с частичным порядком должны реализовывать &lt;code&gt;&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ba674a48316fb1433436a60a425791cc32b78b0" translate="yes" xml:space="preserve">
          <source>Nonforking</source>
          <target state="translated">Nonforking</target>
        </trans-unit>
        <trans-unit id="97f53a3ef5c6423e5a459f652ffb969748da2787" translate="yes" xml:space="preserve">
          <source>Nor</source>
          <target state="translated">Nor</target>
        </trans-unit>
        <trans-unit id="353d229b6f3ca31bd45bd9bebe8e58269912e930" translate="yes" xml:space="preserve">
          <source>Normal Subgroup Of</source>
          <target state="translated">Нормальная подгруппа</target>
        </trans-unit>
        <trans-unit id="a7f48eaa19bcc609000a719de46fc1f3c28fd022" translate="yes" xml:space="preserve">
          <source>Normal Subgroup Of Or Equal To</source>
          <target state="translated">Нормальная подгруппа или равная</target>
        </trans-unit>
        <trans-unit id="ea65c52c4dc34140ff47fd23bf1ce89abf2497b1" translate="yes" xml:space="preserve">
          <source>Normalize a path, removing &quot;.&quot; and &quot;..&quot; entries.</source>
          <target state="translated">Нормализуйте путь,удалив записи &quot;...&quot; и &quot;...&quot;.</target>
        </trans-unit>
        <trans-unit id="5db16edc23f62be0c1341058dd3eaba05abc2f92" translate="yes" xml:space="preserve">
          <source>Normalize the array &lt;code&gt;a&lt;/code&gt; in-place so that its &lt;code&gt;p&lt;/code&gt;-norm equals unity, i.e. &lt;code&gt;norm(a, p) == 1&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.normalize&quot;&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb5e4cb9a195c300eb971c48748e73eb51af152" translate="yes" xml:space="preserve">
          <source>Normalize the array &lt;code&gt;a&lt;/code&gt; so that its &lt;code&gt;p&lt;/code&gt;-norm equals unity, i.e. &lt;code&gt;norm(a, p) == 1&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.normalize!&quot;&gt;&lt;code&gt;normalize!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dff1142e88fe8e90deecc8b52307005080af42f" translate="yes" xml:space="preserve">
          <source>Normalize the string &lt;code&gt;s&lt;/code&gt; according to one of the four &quot;normal forms&quot; of the Unicode standard: &lt;code&gt;normalform&lt;/code&gt; can be &lt;code&gt;:NFC&lt;/code&gt;, &lt;code&gt;:NFD&lt;/code&gt;, &lt;code&gt;:NFKC&lt;/code&gt;, or &lt;code&gt;:NFKD&lt;/code&gt;. Normal forms C (canonical composition) and D (canonical decomposition) convert different visually identical representations of the same abstract string into a single canonical form, with form C being more compact. Normal forms KC and KD additionally canonicalize &quot;compatibility equivalents&quot;: they convert characters that are abstractly similar but visually distinct into a single canonical choice (e.g. they expand ligatures into the individual characters), with form KC being more compact.</source>
          <target state="translated">Нормализация струна &lt;code&gt;s&lt;/code&gt; в соответствии с одним из четырех &amp;laquo;нормальных форм&amp;raquo; стандарт Unicode: &lt;code&gt;normalform&lt;/code&gt; может быть &lt;code&gt;:NFC&lt;/code&gt; , &lt;code&gt;:NFD&lt;/code&gt; , &lt;code&gt;:NFKC&lt;/code&gt; , или &lt;code&gt;:NFKD&lt;/code&gt; . Нормальные формы C (каноническая композиция) и D (каноническая декомпозиция) преобразуют различные визуально идентичные представления одной и той же абстрактной строки в единую каноническую форму, при этом форма C более компактна. Нормальные формы KC и KD дополнительно канонизируют &amp;laquo;эквиваленты совместимости&amp;raquo;: они преобразуют абстрактно похожие, но визуально различные символы в один канонический выбор (например, они расширяют лигатуры на отдельные символы), при этом форма KC более компактна.</target>
        </trans-unit>
        <trans-unit id="50d67ce67ee1beedca3296a6a0355b79281766ab" translate="yes" xml:space="preserve">
          <source>Normalize the string &lt;code&gt;s&lt;/code&gt;. By default, canonical composition (&lt;code&gt;compose=true&lt;/code&gt;) is performed without ensuring Unicode versioning stability (&lt;code&gt;compat=false&lt;/code&gt;), which produces the shortest possible equivalent string but may introduce composition characters not present in earlier Unicode versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1256c1ca544db3bbe8bc3cbce15ea1460cf4f911" translate="yes" xml:space="preserve">
          <source>Normalize the vector &lt;code&gt;v&lt;/code&gt; in-place so that its &lt;code&gt;p&lt;/code&gt;-norm equals unity, i.e. &lt;code&gt;norm(v, p) == 1&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.normalize&quot;&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Нормализуйте вектор &lt;code&gt;v&lt;/code&gt; на месте так, чтобы его &lt;code&gt;p&lt;/code&gt; -норма была равна единице, то есть &lt;code&gt;norm(v, p) == 1&lt;/code&gt; . Смотрите также &lt;a href=&quot;#LinearAlgebra.normalize&quot;&gt; &lt;code&gt;normalize&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0ca0cad26499570c164bc9b04bdb5e73ad3b767" translate="yes" xml:space="preserve">
          <source>Normalize the vector &lt;code&gt;v&lt;/code&gt; so that its &lt;code&gt;p&lt;/code&gt;-norm equals unity, i.e. &lt;code&gt;norm(v, p) == 1&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.normalize!&quot;&gt;&lt;code&gt;normalize!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Нормализовать вектор &lt;code&gt;v&lt;/code&gt; так, чтобы его &lt;code&gt;p&lt;/code&gt; -норма была равна единице, т.е. &lt;code&gt;norm(v, p) == 1&lt;/code&gt; . См. Также &lt;a href=&quot;#LinearAlgebra.normalize!&quot;&gt; &lt;code&gt;normalize!&lt;/code&gt; &lt;/a&gt;и &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="478b31a56bd438b5767a545ce1ed00f11487d0db" translate="yes" xml:space="preserve">
          <source>North East Arrow / Upper Right Arrow</source>
          <target state="translated">Северо-восточная стрелка/Верхняя правая стрелка</target>
        </trans-unit>
        <trans-unit id="0f9632ee4c4b3913bab8a246eac9a7aaa6e34c3e" translate="yes" xml:space="preserve">
          <source>North East Arrow And South East Arrow</source>
          <target state="translated">Северо-Восточная Стрела и Юго-Восточная Стрела</target>
        </trans-unit>
        <trans-unit id="30cf74356d2a464d3ca7374ff4dc9e2894799efd" translate="yes" xml:space="preserve">
          <source>North East Arrow Crossing North West Arrow</source>
          <target state="translated">Северо-Восточная стрелка пересекает Северо-Западную стрелку</target>
        </trans-unit>
        <trans-unit id="916f9b242f547ef05ec66f2fa83e1592cdbcfdbd" translate="yes" xml:space="preserve">
          <source>North East Arrow Crossing South East Arrow</source>
          <target state="translated">Северо-восточная стрелка пересекающая юго-восточную стрелку</target>
        </trans-unit>
        <trans-unit id="b0e4cc646e9668d5edd815430e5705b8eb0282d0" translate="yes" xml:space="preserve">
          <source>North East Double Arrow / Upper Right Double Arrow</source>
          <target state="translated">Северо-восточная двойная стрелка/Верхняя правая двойная стрелка</target>
        </trans-unit>
        <trans-unit id="2851194a781dba08882cd8b5dcac7c7bff4bc98b" translate="yes" xml:space="preserve">
          <source>North West Arrow / Upper Left Arrow</source>
          <target state="translated">Северо-западная стрелка/верхняя левая стрелка</target>
        </trans-unit>
        <trans-unit id="233c55eeb0aa49ef4b20ef3585841b43d859f2df" translate="yes" xml:space="preserve">
          <source>North West Arrow And North East Arrow</source>
          <target state="translated">Северо-Западная Стрела и Северо-Восточная Стрела</target>
        </trans-unit>
        <trans-unit id="c8af1f130f612aaea28cebf3c5f06dbc620210fa" translate="yes" xml:space="preserve">
          <source>North West Arrow Crossing North East Arrow</source>
          <target state="translated">Северо-Западная Стрелка пересекает Северо-Восточную Стрелку</target>
        </trans-unit>
        <trans-unit id="f21049a5d207abc1091420d168abe05b73221d81" translate="yes" xml:space="preserve">
          <source>North West Arrow To Long Bar / Upper Left Arrow To Long Bar</source>
          <target state="translated">Стрелка на северо-запад к длинному бару/верхняя левая стрелка к длинному бару</target>
        </trans-unit>
        <trans-unit id="1ef9c199f598a375deeea550d911861c89af3632" translate="yes" xml:space="preserve">
          <source>North West Double Arrow / Upper Left Double Arrow</source>
          <target state="translated">Северо-Западная двойная стрелка/Верхняя левая двойная стрелка</target>
        </trans-unit>
        <trans-unit id="eb9f9930aed653b8a960f004b0d33be134abd920" translate="yes" xml:space="preserve">
          <source>Nose</source>
          <target state="translated">Nose</target>
        </trans-unit>
        <trans-unit id="4924b680ce01b04d3901d5887ba0094a80386e09" translate="yes" xml:space="preserve">
          <source>Not &lt;em&gt;all&lt;/em&gt; primitive types can be wrapped in an &lt;code&gt;Atomic&lt;/code&gt; tag. Supported types are &lt;code&gt;Int8&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;Int128&lt;/code&gt;, &lt;code&gt;UInt8&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt;, &lt;code&gt;UInt64&lt;/code&gt;, &lt;code&gt;UInt128&lt;/code&gt;, &lt;code&gt;Float16&lt;/code&gt;, &lt;code&gt;Float32&lt;/code&gt;, and &lt;code&gt;Float64&lt;/code&gt;. Additionally, &lt;code&gt;Int128&lt;/code&gt; and &lt;code&gt;UInt128&lt;/code&gt; are not supported on AAarch32 and ppc64le.</source>
          <target state="translated">Не &lt;em&gt;все&lt;/em&gt; примитивные типы можно заключить в &lt;code&gt;Atomic&lt;/code&gt; тег. Поддерживаемые типы &lt;code&gt;Int8&lt;/code&gt; , &lt;code&gt;Int16&lt;/code&gt; , &lt;code&gt;Int32&lt;/code&gt; , &lt;code&gt;Int64&lt;/code&gt; , &lt;code&gt;Int128&lt;/code&gt; , &lt;code&gt;UInt8&lt;/code&gt; , &lt;code&gt;UInt16&lt;/code&gt; , &lt;code&gt;UInt32&lt;/code&gt; , &lt;code&gt;UInt64&lt;/code&gt; , &lt;code&gt;UInt128&lt;/code&gt; , &lt;code&gt;Float16&lt;/code&gt; , &lt;code&gt;Float32&lt;/code&gt; и &lt;code&gt;Float64&lt;/code&gt; . Кроме того, &lt;code&gt;Int128&lt;/code&gt; и &lt;code&gt;UInt128&lt;/code&gt; не поддерживаются в AAarch32 и ppc64le.</target>
        </trans-unit>
        <trans-unit id="44c45a3975806f5aa3563e402ab48284ba7dd19a" translate="yes" xml:space="preserve">
          <source>Not A Subset Of</source>
          <target state="translated">Не подмножество</target>
        </trans-unit>
        <trans-unit id="a17eca69bf167ebef605d6f511649ff7e242d247" translate="yes" xml:space="preserve">
          <source>Not A Superset Of</source>
          <target state="translated">Не суперсет</target>
        </trans-unit>
        <trans-unit id="bc9d785d0ab5238febfc3ab6b86ae20357096f11" translate="yes" xml:space="preserve">
          <source>Not Almost Equal To</source>
          <target state="translated">Не почти равна</target>
        </trans-unit>
        <trans-unit id="d67d6c66a36751875c25ecc62a3d848e35280e41" translate="yes" xml:space="preserve">
          <source>Not An Element Of</source>
          <target state="translated">Не элемент</target>
        </trans-unit>
        <trans-unit id="e71b2d4992fb3377f88d850b0bb44606967664d0" translate="yes" xml:space="preserve">
          <source>Not Asymptotically Equal To</source>
          <target state="translated">Не асимптотически равны</target>
        </trans-unit>
        <trans-unit id="0e19001a3da6b3e710f2e1e08a6e032b4620604c" translate="yes" xml:space="preserve">
          <source>Not Equal To</source>
          <target state="translated">Не равнозначно</target>
        </trans-unit>
        <trans-unit id="f45023c8868a909904028b86e6e07605ae94f2c2" translate="yes" xml:space="preserve">
          <source>Not Equivalent To</source>
          <target state="translated">Не эквивалентно</target>
        </trans-unit>
        <trans-unit id="910c9a23745ec45bdbd8919929b0387676a27c9b" translate="yes" xml:space="preserve">
          <source>Not Greater-Than / Not Greater Than</source>
          <target state="translated">Не больше,чем</target>
        </trans-unit>
        <trans-unit id="5e65900a18143b1e895a94ccc959abe15bb1ab2e" translate="yes" xml:space="preserve">
          <source>Not Identical To</source>
          <target state="translated">Не идентично</target>
        </trans-unit>
        <trans-unit id="e4a2159809150c92b1584b86470e09ba5081e939" translate="yes" xml:space="preserve">
          <source>Not Less-Than / Not Less Than</source>
          <target state="translated">Ни меньше,ни меньше,чем</target>
        </trans-unit>
        <trans-unit id="0fed8df1648d0557424154c2315a039c686f4c4d" translate="yes" xml:space="preserve">
          <source>Not Normal Subgroup Of</source>
          <target state="translated">Не нормальная подгруппа</target>
        </trans-unit>
        <trans-unit id="645b3d2b60dd6a7e0784186eff65f0733da3c390" translate="yes" xml:space="preserve">
          <source>Not Normal Subgroup Of Or Equal To</source>
          <target state="translated">Не является нормальной подгруппой или равной</target>
        </trans-unit>
        <trans-unit id="70cb8e0c40ae6f2469c6439d1eaf86fb7dd00f0f" translate="yes" xml:space="preserve">
          <source>Not Parallel To</source>
          <target state="translated">Не параллельно</target>
        </trans-unit>
        <trans-unit id="5ab2276b84dac0a395ff693634647ac47704aca7" translate="yes" xml:space="preserve">
          <source>Not Sign</source>
          <target state="translated">Не подписано</target>
        </trans-unit>
        <trans-unit id="eca01d40cd859c6c6d1c5a246f8d23349bd1b255" translate="yes" xml:space="preserve">
          <source>Not Square Image Of Or Equal To</source>
          <target state="translated">Не квадратное изображение или равное</target>
        </trans-unit>
        <trans-unit id="9c087d8ffd300334402de9a832da5d7584b88f65" translate="yes" xml:space="preserve">
          <source>Not Square Original Of Or Equal To</source>
          <target state="translated">Not Square Original of or Equal to</target>
        </trans-unit>
        <trans-unit id="87f0c2899fae2d3fccc6eaa170295b507e0f676c" translate="yes" xml:space="preserve">
          <source>Not Tilde</source>
          <target state="translated">Не Тильде</target>
        </trans-unit>
        <trans-unit id="10e43a0344ab0a9a991f8d1b272b6b2064a08d9f" translate="yes" xml:space="preserve">
          <source>Not True</source>
          <target state="translated">Неправда</target>
        </trans-unit>
        <trans-unit id="7776746fa92a51dd2e030d64afc4c033677251e7" translate="yes" xml:space="preserve">
          <source>Not all integer values are valid Unicode code points, but for performance, the &lt;code&gt;Char&lt;/code&gt; conversion does not check that every character value is valid. If you want to check that each converted value is a valid code point, use the &lt;code&gt;isvalid&lt;/code&gt; function:</source>
          <target state="translated">Не все целочисленные значения являются допустимыми кодовыми точками Unicode, но для производительности преобразование &lt;code&gt;Char&lt;/code&gt; не проверяет допустимость каждого значения символа. Если вы хотите проверить, что каждое преобразованное значение является допустимым кодом, используйте функцию &lt;code&gt;isvalid&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="255c75003762a3b928c02073fccb1659790b5337" translate="yes" xml:space="preserve">
          <source>Not all iterator types &lt;code&gt;T&lt;/code&gt; support reverse-order iteration. If &lt;code&gt;T&lt;/code&gt; doesn't, then iterating over &lt;code&gt;Iterators.reverse(itr::T)&lt;/code&gt; will throw a &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; because of the missing &lt;a href=&quot;../collections/index#Base.iterate&quot;&gt;&lt;code&gt;iterate&lt;/code&gt;&lt;/a&gt; methods for &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt;. (To implement these methods, the original iterator &lt;code&gt;itr::T&lt;/code&gt; can be obtained from &lt;code&gt;r = Iterators.reverse(itr)&lt;/code&gt; by &lt;code&gt;r.itr&lt;/code&gt;.)</source>
          <target state="translated">Не все типы итераторов &lt;code&gt;T&lt;/code&gt; поддерживают итерацию в обратном порядке. Если &lt;code&gt;T&lt;/code&gt; этого не делает, то итерация по &lt;code&gt;Iterators.reverse(itr::T)&lt;/code&gt; вызовет &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; из-за отсутствия методов &lt;a href=&quot;../collections/index#Base.iterate&quot;&gt; &lt;code&gt;iterate&lt;/code&gt; &lt;/a&gt; для &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt; . (Для реализации этих методов исходный итератор &lt;code&gt;itr::T&lt;/code&gt; может быть получен из &lt;code&gt;r = Iterators.reverse(itr)&lt;/code&gt; помощью &lt;code&gt;r.itr&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="61b9146c66e430511ba5e31c64bc766e0b09ba88" translate="yes" xml:space="preserve">
          <source>Not all types support &lt;code&gt;axes&lt;/code&gt; and indexing, but many are convenient to allow in broadcast. The &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcastable&quot;&gt;&lt;code&gt;Base.broadcastable&lt;/code&gt;&lt;/a&gt; function is called on each argument to broadcast, allowing it to return something different that supports &lt;code&gt;axes&lt;/code&gt; and indexing. By default, this is the identity function for all &lt;code&gt;AbstractArray&lt;/code&gt;s and &lt;code&gt;Number&lt;/code&gt;s &amp;mdash; they already support &lt;code&gt;axes&lt;/code&gt; and indexing. For a handful of other types (including but not limited to types themselves, functions, special singletons like &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;, and dates), &lt;code&gt;Base.broadcastable&lt;/code&gt; returns the argument wrapped in a &lt;code&gt;Ref&lt;/code&gt; to act as a 0-dimensional &quot;scalar&quot; for the purposes of broadcasting. Custom types can similarly specialize &lt;code&gt;Base.broadcastable&lt;/code&gt; to define their shape, but they should follow the convention that &lt;code&gt;collect(Base.broadcastable(x)) == collect(x)&lt;/code&gt;. A notable exception is &lt;code&gt;AbstractString&lt;/code&gt;; strings are special-cased to behave as scalars for the purposes of broadcast even though they are iterable collections of their characters (see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;Strings&lt;/a&gt; for more).</source>
          <target state="translated">Не все типы поддерживают &lt;code&gt;axes&lt;/code&gt; и индексацию, но многие из них удобно использовать в трансляции. Функция &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcastable&quot;&gt; &lt;code&gt;Base.broadcastable&lt;/code&gt; &lt;/a&gt; вызывается для каждого аргумента широковещательной передачи, что позволяет ей возвращать что-то другое, поддерживающее &lt;code&gt;axes&lt;/code&gt; и индексацию. По умолчанию это функция идентификации для всех &lt;code&gt;AbstractArray&lt;/code&gt; s и &lt;code&gt;Number&lt;/code&gt; s - они уже поддерживают &lt;code&gt;axes&lt;/code&gt; и индексацию. Для нескольких других типов (включая , но не ограничиваясь типов самих функций, специальными одиночка , как &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; было , и дата), &lt;code&gt;Base.broadcastable&lt;/code&gt; возвращает аргумент , завернутый в &lt;code&gt;Ref&lt;/code&gt; действовать как 0-мерный &quot;скаляр&quot; для целей вещания. Пользовательские типы могут аналогичным образом специализировать &lt;code&gt;Base.broadcastable&lt;/code&gt; для определения своей формы, но они должны следовать соглашению, которое &lt;code&gt;collect(Base.broadcastable(x)) == collect(x)&lt;/code&gt; . Заметным исключением является &lt;code&gt;AbstractString&lt;/code&gt; ; Строки имеют специальный корпус, чтобы вести себя как скаляры для целей широковещательной передачи, даже если они являются повторяемыми коллекциями своих символов (подробнее см. в разделе &amp;laquo; &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;Строки&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d06aed80f156ee518eb97f78c31bd51b6209ccf7" translate="yes" xml:space="preserve">
          <source>Not all types support &lt;code&gt;axes&lt;/code&gt; and indexing, but many are convenient to allow in broadcast. The &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcastable&quot;&gt;&lt;code&gt;Base.broadcastable&lt;/code&gt;&lt;/a&gt; function is called on each argument to broadcast, allowing it to return something different that supports &lt;code&gt;axes&lt;/code&gt; and indexing. By default, this is the identity function for all &lt;code&gt;AbstractArray&lt;/code&gt;s and &lt;code&gt;Number&lt;/code&gt;s &amp;mdash; they already support &lt;code&gt;axes&lt;/code&gt; and indexing. For a handful of other types (including but not limited to types themselves, functions, special singletons like &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;, and dates), &lt;code&gt;Base.broadcastable&lt;/code&gt; returns the argument wrapped in a &lt;code&gt;Ref&lt;/code&gt; to act as a 0-dimensional &quot;scalar&quot; for the purposes of broadcasting. Custom types can similarly specialize &lt;code&gt;Base.broadcastable&lt;/code&gt; to define their shape, but they should follow the convention that &lt;code&gt;collect(Base.broadcastable(x)) == collect(x)&lt;/code&gt;. A notable exception is &lt;code&gt;AbstractString&lt;/code&gt;; strings are special-cased to behave as scalars for the purposes of broadcast even though they are iterable collections of their characters (see &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/ast/#Strings&quot;&gt;Strings&lt;/a&gt; for more).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376b17f23ac9bcdac899ff816a9bc77c9e5acbff" translate="yes" xml:space="preserve">
          <source>Not only is lack of associativity unfortunate for programmers who cannot rely it for techniques like this, but it also defeats almost anything compilers might want to do to optimize integer arithmetic. For example, since Julia integers use normal machine integer arithmetic, LLVM is free to aggressively optimize simple little functions like &lt;code&gt;f(k) = 5k-1&lt;/code&gt;. The machine code for this function is just this:</source>
          <target state="translated">Отсутствие ассоциативности не только неприятно для программистов, которые не могут полагаться на нее для подобных приемов, но и сводит на нет почти все, что компиляторы могут захотеть сделать для оптимизации целочисленной арифметики. Например, поскольку целые числа Джулии используют обычную машинную целочисленную арифметику, LLVM может агрессивно оптимизировать простые маленькие функции, такие как &lt;code&gt;f(k) = 5k-1&lt;/code&gt; . Машинный код для этой функции таков:</target>
        </trans-unit>
        <trans-unit id="31e53323374f02c10d280447ec7713899b4aba54" translate="yes" xml:space="preserve">
          <source>Not only is the string literal form shorter and far more convenient, but it is also more efficient: since the regular expression is compiled and the &lt;code&gt;Regex&lt;/code&gt; object is actually created &lt;em&gt;when the code is compiled&lt;/em&gt;, the compilation occurs only once, rather than every time the code is executed. Consider if the regular expression occurs in a loop:</source>
          <target state="translated">Строковый литерал не только короче и намного удобнее, но и более эффективен: поскольку регулярное выражение компилируется и объект &lt;code&gt;Regex&lt;/code&gt; фактически создается &lt;em&gt;при&lt;/em&gt; компиляции &lt;em&gt;кода&lt;/em&gt; , компиляция происходит только один раз, а не каждый раз код выполняется. Подумайте, встречается ли регулярное выражение в цикле:</target>
        </trans-unit>
        <trans-unit id="8e635455c1c04acc72cc3cb8b3930fa2002922c7" translate="yes" xml:space="preserve">
          <source>Not supported</source>
          <target state="translated">Не поддерживается</target>
        </trans-unit>
        <trans-unit id="578b6ae41c55ac5817217df1b33fc68cc954cc58" translate="yes" xml:space="preserve">
          <source>Not to be confused with &lt;code&gt;Sys.isbsd()&lt;/code&gt;, which is &lt;code&gt;true&lt;/code&gt; on DragonFly but also on other BSD-based systems. &lt;code&gt;Sys.isdragonfly()&lt;/code&gt; refers only to DragonFly.</source>
          <target state="translated">Не путать с &lt;code&gt;Sys.isbsd()&lt;/code&gt; , что &lt;code&gt;true&lt;/code&gt; для DragonFly, но также и для других систем на основе BSD. &lt;code&gt;Sys.isdragonfly()&lt;/code&gt; относится только к DragonFly.</target>
        </trans-unit>
        <trans-unit id="d42de750af9292296d2996dbdfe296c15be6dc0d" translate="yes" xml:space="preserve">
          <source>Not to be confused with &lt;code&gt;Sys.isbsd()&lt;/code&gt;, which is &lt;code&gt;true&lt;/code&gt; on FreeBSD but also on other BSD-based systems. &lt;code&gt;Sys.isfreebsd()&lt;/code&gt; refers only to FreeBSD.</source>
          <target state="translated">Не путать с &lt;code&gt;Sys.isbsd()&lt;/code&gt; , что &lt;code&gt;true&lt;/code&gt; для FreeBSD, но также и для других систем на основе BSD. &lt;code&gt;Sys.isfreebsd()&lt;/code&gt; относится только к FreeBSD.</target>
        </trans-unit>
        <trans-unit id="bd7b8351c728f277ea375c49956a749253ca4ccd" translate="yes" xml:space="preserve">
          <source>Not to be confused with &lt;code&gt;Sys.isbsd()&lt;/code&gt;, which is &lt;code&gt;true&lt;/code&gt; on NetBSD but also on other BSD-based systems. &lt;code&gt;Sys.isnetbsd()&lt;/code&gt; refers only to NetBSD.</source>
          <target state="translated">Не путать с &lt;code&gt;Sys.isbsd()&lt;/code&gt; , что &lt;code&gt;true&lt;/code&gt; для NetBSD, но также и для других систем на основе BSD. &lt;code&gt;Sys.isnetbsd()&lt;/code&gt; относится только к NetBSD.</target>
        </trans-unit>
        <trans-unit id="02e040fc63d08da8130023e8bf1da51746be0eb3" translate="yes" xml:space="preserve">
          <source>Not to be confused with &lt;code&gt;Sys.isbsd()&lt;/code&gt;, which is &lt;code&gt;true&lt;/code&gt; on OpenBSD but also on other BSD-based systems. &lt;code&gt;Sys.isopenbsd()&lt;/code&gt; refers only to OpenBSD.</source>
          <target state="translated">Не путать с &lt;code&gt;Sys.isbsd()&lt;/code&gt; , что &lt;code&gt;true&lt;/code&gt; для OpenBSD, но также и для других систем на основе BSD. &lt;code&gt;Sys.isopenbsd()&lt;/code&gt; относится только к OpenBSD.</target>
        </trans-unit>
        <trans-unit id="054fdc1887c4bd534bac1d0a3aea062860f9859e" translate="yes" xml:space="preserve">
          <source>Not-equals comparison operator. Always gives the opposite answer as &lt;a href=&quot;#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Оператор сравнения не равно. Всегда дает противоположный ответ как &lt;a href=&quot;#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09a3a6aa1ade2cda6a7d225bac58c2f12db2701f" translate="yes" xml:space="preserve">
          <source>Notably missing from this table are &lt;a href=&quot;../control-flow/index#man-compound-expressions&quot;&gt;begin blocks&lt;/a&gt; and &lt;a href=&quot;../control-flow/index#man-conditional-evaluation&quot;&gt;if blocks&lt;/a&gt; which do &lt;em&gt;not&lt;/em&gt; introduce new scopes. The three types of scopes follow somewhat different rules which will be explained below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a97115f7efbdab23d7b34d2c40462b51cbb049d" translate="yes" xml:space="preserve">
          <source>Notably missing from this table are &lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;begin blocks&lt;/a&gt; and &lt;a href=&quot;../control-flow/index#man-conditional-evaluation-1&quot;&gt;if blocks&lt;/a&gt; which do &lt;em&gt;not&lt;/em&gt; introduce new scopes. Both types of scopes follow somewhat different rules which will be explained below.</source>
          <target state="translated">Примечательно, что в этой таблице отсутствуют &lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;блоки begin&lt;/a&gt; и &lt;a href=&quot;../control-flow/index#man-conditional-evaluation-1&quot;&gt;if,&lt;/a&gt; которые &lt;em&gt;не&lt;/em&gt; вводят новые области действия. Оба типа прицелов подчиняются несколько разным правилам, которые будут объяснены ниже.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="975b275a254bd77182b630947c7d8ebcab739d76" translate="yes" xml:space="preserve">
          <source>Note also that container types, specifically may need type parameters in function calls. See the FAQ &lt;a href=&quot;../performance-tips/index#Avoid-fields-with-abstract-containers&quot;&gt;Avoid fields with abstract containers&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="849d9173bfaa5bb4ab294b9df21a5967dcab8225" translate="yes" xml:space="preserve">
          <source>Note also that container types, specifically may need type parameters in function calls. See the FAQ &lt;a href=&quot;../performance-tips/index#Avoid-fields-with-abstract-containers-1&quot;&gt;Avoid fields with abstract containers&lt;/a&gt; for more information.</source>
          <target state="translated">Также обратите внимание, что типам контейнеров, в частности, могут потребоваться параметры типа в вызовах функций. Для получения дополнительной информации см. FAQ &lt;a href=&quot;../performance-tips/index#Avoid-fields-with-abstract-containers-1&quot;&gt;Избегайте полей с абстрактными контейнерами&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a53f93a486d8d7a57250d379f8edb9cd25043f3" translate="yes" xml:space="preserve">
          <source>Note how each even iteration is significantly faster.</source>
          <target state="translated">Обратите внимание,что каждая равномерная итерация значительно быстрее.</target>
        </trans-unit>
        <trans-unit id="00b5f982274ede3eb024b1d3b08e8e7c8741dfd9" translate="yes" xml:space="preserve">
          <source>Note how the size of the resulting array is different in the last two cases.</source>
          <target state="translated">Обратите внимание,что в последних двух случаях размер результирующего массива отличается.</target>
        </trans-unit>
        <trans-unit id="d976f8413bff8e1f0c6cdf63fd9bf71518cc2d9f" translate="yes" xml:space="preserve">
          <source>Note on Optional and keyword Arguments</source>
          <target state="translated">Замечание об аргументах по выбору и ключевому слову</target>
        </trans-unit>
        <trans-unit id="1c7695f5595e993b4198f30c43fab04e9442751c" translate="yes" xml:space="preserve">
          <source>Note on Windows since there is a current directory for each drive, &lt;code&gt;joinpath(&quot;c:&quot;, &quot;foo&quot;)&lt;/code&gt; represents a path relative to the current directory on drive &quot;c:&quot; so this is equal to &quot;c:foo&quot;, not &quot;c:\foo&quot;. Furthermore, &lt;code&gt;joinpath&lt;/code&gt; treats this as a non-absolute path and ignores the drive letter casing, hence &lt;code&gt;joinpath(&quot;C:\A&quot;,&quot;c:b&quot;) = &quot;C:\A\b&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28ded9fb86e90fa4e9b6fc5221352277f1f430d" translate="yes" xml:space="preserve">
          <source>Note that &quot;constant-ness&quot; does not extend into mutable containers; only the association between a variable and its value is constant. If &lt;code&gt;x&lt;/code&gt; is an array or dictionary (for example) you can still modify, add, or remove elements.</source>
          <target state="translated">Обратите внимание, что &amp;laquo;постоянство&amp;raquo; не распространяется на изменяемые контейнеры; только связь между переменной и ее значением постоянна. Если &lt;code&gt;x&lt;/code&gt; - это массив или словарь (например), вы все равно можете изменять, добавлять или удалять элементы.</target>
        </trans-unit>
        <trans-unit id="2f33b173ac7918930bdfbf48b338b9676798c0c7" translate="yes" xml:space="preserve">
          <source>Note that 12:00AM corresponds 00:00 (midnight), and 12:00PM corresponds to 12:00 (noon). When parsing a time with a &lt;code&gt;p&lt;/code&gt; specifier, any hour (either &lt;code&gt;H&lt;/code&gt; or &lt;code&gt;I&lt;/code&gt;) is interpreted as as a 12-hour clock, so the &lt;code&gt;I&lt;/code&gt; code is mainly useful for output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="696a1593f42fbf6fdb11b6e9d243436195a50762" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; without parentheses is not an exception, but a type of exception. It needs to be called to obtain an &lt;code&gt;Exception&lt;/code&gt; object:</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt; без скобок - это не исключение, а тип исключения. Его нужно вызвать для получения объекта &lt;code&gt;Exception&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b8007f62d26730fb9d23ad56c13276aa54218371" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returns 11, the number of bytes (in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;) written to &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;, but this return value is suppressed with the &lt;code&gt;;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; возвращает 11, количество байтов (в &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; ), записанных в &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; , но это возвращаемое значение подавляется &lt;code&gt;;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="37adaed47b6bd184e2c19006696ca9a54db365b6" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt;&lt;code&gt;Threads.@threads&lt;/code&gt;&lt;/a&gt; does not have an optional reduction parameter like &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@distributed&quot;&gt;&lt;code&gt;@distributed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt; &lt;code&gt;Threads.@threads&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@distributed&quot;&gt; &lt;code&gt;@distributed&lt;/code&gt; &lt;/a&gt; не имеет необязательного параметра сокращения, такого как @distributed .</target>
        </trans-unit>
        <trans-unit id="56fd4dacad4e16bdd1b5c6c8643757fc415a3a05" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt;&lt;code&gt;@code_typed&lt;/code&gt;&lt;/a&gt; and friends will always show you specialized code, even if Julia would not normally specialize that method call. You need to check the &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/ast/#ast-lowered-method&quot;&gt;method internals&lt;/a&gt; if you want to see whether specializations are generated when argument types are changed, i.e., if &lt;code&gt;(@which f(...)).specializations&lt;/code&gt; contains specializations for the argument in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeada1a815471b81eb3fba82f7ffa1d182b6efc4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;3/4im == 3/(4*im) == -(3/4*im)&lt;/code&gt;, since a literal coefficient binds more tightly than division.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;3/4im == 3/(4*im) == -(3/4*im)&lt;/code&gt; , поскольку буквальный коэффициент связывает более жестко, чем деление.</target>
        </trans-unit>
        <trans-unit id="a28e4307aa56a3047fa10fe081f2a2b0189f815e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@fastmath&lt;/code&gt; also assumes that &lt;code&gt;NaN&lt;/code&gt;s will not occur during the computation, which can lead to surprising behavior:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;@fastmath&lt;/code&gt; также предполагает, что &lt;code&gt;NaN&lt;/code&gt; не будет возникать во время вычисления, что может привести к неожиданному поведению:</target>
        </trans-unit>
        <trans-unit id="44f37755c76cb167a60db94665d8037a8b6d4b88" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Hupper&lt;/code&gt; will not be equal to &lt;code&gt;Hlower&lt;/code&gt; unless &lt;code&gt;A&lt;/code&gt; is itself Hermitian (e.g. if &lt;code&gt;A == adjoint(A)&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;Hupper&lt;/code&gt; не будет равен &lt;code&gt;Hlower&lt;/code&gt; , если &lt;code&gt;A&lt;/code&gt; сам не является эрмитовым (например, если &lt;code&gt;A == adjoint(A)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e856098b5c682029aff8a00fd63966146351870" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Supper&lt;/code&gt; will not be equal to &lt;code&gt;Slower&lt;/code&gt; unless &lt;code&gt;A&lt;/code&gt; is itself symmetric (e.g. if &lt;code&gt;A == transpose(A)&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;Supper&lt;/code&gt; не будет равен &lt;code&gt;Slower&lt;/code&gt; , если &lt;code&gt;A&lt;/code&gt; сам не симметричен (например, если &lt;code&gt;A == transpose(A)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ab5d20eb7b7b4658ec16f617a8d465aa8cefd27a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;a&lt;/code&gt; is written to &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; by the &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; function and that the returned value is &lt;code&gt;1&lt;/code&gt; (since &lt;code&gt;0x61&lt;/code&gt; is one byte).</source>
          <target state="translated">Обратите внимание , что записывается в &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; функции , и что возвращаемое значение равно &lt;code&gt;1&lt;/code&gt; (так как &lt;code&gt;0x61&lt;/code&gt; занимает один байт). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49ba0090143db57a2046b4bea0136a386cb43ff2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;const&lt;/code&gt; only affects the variable binding; the variable may be bound to a mutable object (such as an array), and that object may still be modified. Additionally when one tries to assign a value to a variable that is declared constant the following scenarios are possible:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;const&lt;/code&gt; влияет только на привязку переменной; переменная может быть связана с изменяемым объектом (например, массивом), и этот объект все еще может быть изменен. Кроме того, когда кто-то пытается присвоить значение переменной, которая объявлена ​​постоянной, возможны следующие сценарии:</target>
        </trans-unit>
        <trans-unit id="a71dd5c1dc13bb0d3426a39b5d80f1ab214d1505" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;const&lt;/code&gt; only applies to one &lt;code&gt;=&lt;/code&gt; operation, therefore &lt;code&gt;const x = y = 1&lt;/code&gt; declares &lt;code&gt;x&lt;/code&gt; to be constant but not &lt;code&gt;y&lt;/code&gt;. On the other hand, &lt;code&gt;const x = const y = 1&lt;/code&gt; declares both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; constant.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;const&lt;/code&gt; применяется только к операции one &lt;code&gt;=&lt;/code&gt; , поэтому &lt;code&gt;const x = y = 1&lt;/code&gt; объявляет константу &lt;code&gt;x&lt;/code&gt; , но не &lt;code&gt;y&lt;/code&gt; . С другой стороны, &lt;code&gt;const x = const y = 1&lt;/code&gt; объявляет как &lt;code&gt;x&lt;/code&gt; ,так и &lt;code&gt;y&lt;/code&gt; постоянными.</target>
        </trans-unit>
        <trans-unit id="42b7bae28c5c9b6bf89128b216efa649678ec047" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;f&lt;/code&gt; must be made available to all worker processes; see &lt;a href=&quot;../../manual/distributed-computing/index#code-availability&quot;&gt;Code Availability and Loading Packages&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da2dbc9c6e30c7173aed1390cec1b44955d9a0a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;f&lt;/code&gt; must be made available to all worker processes; see &lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;Code Availability and Loading Packages&lt;/a&gt; for details.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;f&lt;/code&gt; должен быть доступен для всех рабочих процессов; подробности см. в разделе &amp;laquo; &lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;Доступность кода&amp;raquo; и &amp;laquo;Загрузка пакетов&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92d4b4f20914a2f80297acf7d51d2f544ab0b677" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;islinux&lt;/code&gt;, &lt;code&gt;isapple&lt;/code&gt;, and &lt;code&gt;isfreebsd&lt;/code&gt; are mutually exclusive subsets of &lt;code&gt;isunix&lt;/code&gt;. Additionally, there is a macro &lt;code&gt;@static&lt;/code&gt; which makes it possible to use these functions to conditionally hide invalid code, as demonstrated in the following examples.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;islinux&lt;/code&gt; , &lt;code&gt;isapple&lt;/code&gt; и &lt;code&gt;isfreebsd&lt;/code&gt; являются взаимоисключающими подмножествами &lt;code&gt;isunix&lt;/code&gt; . Кроме того, существует макрос &lt;code&gt;@static&lt;/code&gt; , который позволяет использовать эти функции для условного скрытия недопустимого кода, как показано в следующих примерах.</target>
        </trans-unit>
        <trans-unit id="ecce05e977eeb562c214d3763cad6d310a27574a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;objectid&lt;/code&gt; (which works by hashing the memory pointer) has similar issues (see notes on &lt;code&gt;Dict&lt;/code&gt; usage below).</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;objectid&lt;/code&gt; (который работает путем хеширования указателя памяти) имеет аналогичные проблемы (см. Примечания по использованию &lt;code&gt;Dict&lt;/code&gt; ниже).</target>
        </trans-unit>
        <trans-unit id="dec4ef0812f3a86c7546a41bb6d9a828672c6b6b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;repr(x)&lt;/code&gt; is usually similar to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia. See also &lt;a href=&quot;#Base.repr-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;repr(MIME(&quot;text/plain&quot;), x)&lt;/code&gt;&lt;/a&gt; to instead return a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed more for human consumption, equivalent to the REPL display of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;repr(x)&lt;/code&gt; обычно аналогичен тому, как значение &lt;code&gt;x&lt;/code&gt; вводится в Julia. См. Также &lt;a href=&quot;#Base.repr-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;repr(MIME(&quot;text/plain&quot;), x)&lt;/code&gt; &lt;/a&gt; чтобы вместо этого возвращать &quot;красивую&quot; версию &lt;code&gt;x&lt;/code&gt; , предназначенную больше для человеческого потребления, эквивалентную отображению REPL &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93ebaffc5da22f58b7b0da356367cc874b632fc4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;repr(x)&lt;/code&gt; is usually similar to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia. See also &lt;code&gt;repr(MIME(&quot;text/plain&quot;), x)&lt;/code&gt; to instead return a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed more for human consumption, equivalent to the REPL display of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c63c24c562ebbeffd401b993abf9ea07344548e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;size&lt;/code&gt; may not be defined for arrays with non-standard indices, in which case &lt;a href=&quot;#Base.axes-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;axes&lt;/code&gt;&lt;/a&gt; may be useful. See the manual chapter on &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;arrays with custom indices&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;size&lt;/code&gt; не может быть определен для массивов с нестандартными индексами, и в этом случае &lt;a href=&quot;#Base.axes-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;axes&lt;/code&gt; &lt;/a&gt; могут быть полезны. См. Главу руководства о &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;массивах с настраиваемыми индексами&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7559405697142cf45c00dae1c325e170d476ba8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;size&lt;/code&gt; may not be defined for arrays with non-standard indices, in which case &lt;a href=&quot;#Base.axes-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;axes&lt;/code&gt;&lt;/a&gt; may be useful. See the manual chapter on &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;arrays with custom indices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb1ecefd80819ec38c7d5d7a2809bfae7568534" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;x &amp;asymp; 0&lt;/code&gt; (i.e., comparing to zero with the default tolerances) is equivalent to &lt;code&gt;x == 0&lt;/code&gt; since the default &lt;code&gt;atol&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;. In such cases, you should either supply an appropriate &lt;code&gt;atol&lt;/code&gt; (or use &lt;code&gt;norm(x) &amp;le; atol&lt;/code&gt;) or rearrange your code (e.g. use &lt;code&gt;x &amp;asymp; y&lt;/code&gt; rather than &lt;code&gt;x - y &amp;asymp; 0&lt;/code&gt;). It is not possible to pick a nonzero &lt;code&gt;atol&lt;/code&gt; automatically because it depends on the overall scaling (the &quot;units&quot;) of your problem: for example, in &lt;code&gt;x - y &amp;asymp; 0&lt;/code&gt;, &lt;code&gt;atol=1e-9&lt;/code&gt; is an absurdly small tolerance if &lt;code&gt;x&lt;/code&gt; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Earth_radius&quot;&gt;radius of the Earth&lt;/a&gt; in meters, but an absurdly large tolerance if &lt;code&gt;x&lt;/code&gt; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bohr_radius&quot;&gt;radius of a Hydrogen atom&lt;/a&gt; in meters.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;x &amp;asymp; 0&lt;/code&gt; (т. Е. По сравнению с нулем с допусками по умолчанию) эквивалентно &lt;code&gt;x == 0&lt;/code&gt; поскольку &lt;code&gt;atol&lt;/code&gt; по умолчанию равен &lt;code&gt;0&lt;/code&gt; . В таких случаях вам следует либо предоставить соответствующий &lt;code&gt;atol&lt;/code&gt; (или использовать &lt;code&gt;norm(x) &amp;le; atol&lt;/code&gt; ), либо изменить код (например, использовать &lt;code&gt;x &amp;asymp; y&lt;/code&gt; вместо &lt;code&gt;x - y &amp;asymp; 0&lt;/code&gt; ). Невозможно выбрать ненулевой &lt;code&gt;atol&lt;/code&gt; автоматически, потому что он зависит от общего масштабирования (&amp;laquo;единиц&amp;raquo;) вашей проблемы: например, в &lt;code&gt;x - y &amp;asymp; 0&lt;/code&gt; , &lt;code&gt;atol=1e-9&lt;/code&gt; - абсурдно малый допуск, если &lt;code&gt;x&lt;/code&gt; равен &lt;a href=&quot;https://en.wikipedia.org/wiki/Earth_radius&quot;&gt;радиус Земли&lt;/a&gt;в метрах, но абсурдно большой допуск, если &lt;code&gt;x&lt;/code&gt; - &lt;a href=&quot;https://en.wikipedia.org/wiki/Bohr_radius&quot;&gt;радиус атома водорода&lt;/a&gt; в метрах.</target>
        </trans-unit>
        <trans-unit id="24da7a9bc07548c8c342e439381af79ca72b7da1" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;nested functions&lt;/em&gt; can modify their parent scope's &lt;em&gt;local&lt;/em&gt; variables:</source>
          <target state="translated">Обратите внимание, что &lt;em&gt;вложенные функции&lt;/em&gt; могут изменять &lt;em&gt;локальные&lt;/em&gt; переменные родительской области :</target>
        </trans-unit>
        <trans-unit id="2f99f6df1c98d4f166f129e241845886a06353ad" translate="yes" xml:space="preserve">
          <source>Note that Julia does not convert the endianness for you. Use &lt;a href=&quot;#Base.ntoh&quot;&gt;&lt;code&gt;ntoh&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.ltoh&quot;&gt;&lt;code&gt;ltoh&lt;/code&gt;&lt;/a&gt; for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff66b89cf231ebebae6ac564e03e80821f0734a" translate="yes" xml:space="preserve">
          <source>Note that a single space must appear after the &lt;code&gt;&amp;gt;&lt;/code&gt; character on each line. Quoted blocks may themselves contain other toplevel or inline elements.</source>
          <target state="translated">Обратите внимание, что после символа &lt;code&gt;&amp;gt;&lt;/code&gt; в каждой строке должен стоять один пробел . Цитированные блоки могут сами содержать другие элементы верхнего уровня или встроенные элементы.</target>
        </trans-unit>
        <trans-unit id="df038700fc9ed1f2d0e5d9e1529bee38f9f6f0ec" translate="yes" xml:space="preserve">
          <source>Note that although parallel for loops look like serial for loops, their behavior is dramatically different. In particular, the iterations do not happen in a specified order, and writes to variables or arrays will not be globally visible since iterations run on different processes. Any variables used inside the parallel loop will be copied and broadcast to each process.</source>
          <target state="translated">Обратите внимание,что хотя параллельные циклы для циклов выглядят как последовательные,их поведение кардинально отличается.В частности,итерации не происходят в указанном порядке,а запись в переменные или массивы не будет видна глобально,так как итерации выполняются на разных процессах.Любые переменные,используемые внутри параллельного цикла,будут скопированы и переданы каждому процессу.</target>
        </trans-unit>
        <trans-unit id="94aa43e85ddde561947d2c3630080b0641c93455" translate="yes" xml:space="preserve">
          <source>Note that although sometimes possible, changing the value of a &lt;code&gt;const&lt;/code&gt; variable is strongly discouraged, and is intended only for convenience during interactive use. Changing constants can cause various problems or unexpected behaviors. For instance, if a method references a constant and is already compiled before the constant is changed then it might keep using the old value:</source>
          <target state="translated">Обратите внимание, что, хотя иногда это возможно, изменение значения &lt;code&gt;const&lt;/code&gt; переменной настоятельно не рекомендуется и предназначено только для удобства во время интерактивного использования. Изменение констант может вызвать различные проблемы или неожиданное поведение. Например, если метод ссылается на константу и уже скомпилирован до изменения константы, он может продолжать использовать старое значение:</target>
        </trans-unit>
        <trans-unit id="c05b0f9e216e60cb065800bf991562a8ecf76051" translate="yes" xml:space="preserve">
          <source>Note that although sometimes possible, changing the value of a &lt;code&gt;const&lt;/code&gt; variable is strongly discouraged, and is intended only for convenience during interactive use. Changing constants can cause various problems or unexpected behaviors. For instance, if a method references a constant and is already compiled before the constant is changed, then it might keep using the old value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3d67b5d3f7f10d1a904a545691da68ecdd58fc" translate="yes" xml:space="preserve">
          <source>Note that although you should have a &lt;code&gt;~/.julia&lt;/code&gt; directory once you've run Julia for the first time, you may need to create the &lt;code&gt;~/.julia/config&lt;/code&gt; folder and the &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; file if you use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba3d59a18530117c201d12384305dcff7641d465" translate="yes" xml:space="preserve">
          <source>Note that an error will be thrown if &lt;code&gt;types&lt;/code&gt; are not leaf types when &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and any of the corresponding methods are an &lt;code&gt;@generated&lt;/code&gt; method.</source>
          <target state="translated">Обратите внимание , что ошибка будет сгенерирована , если &lt;code&gt;types&lt;/code&gt; не являются типами листьев , когда &lt;code&gt;generated&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , и любые из соответствующих методов являются &lt;code&gt;@generated&lt;/code&gt; метода.</target>
        </trans-unit>
        <trans-unit id="de63020091c1737ae855533fa49f1548ba9bc637" translate="yes" xml:space="preserve">
          <source>Note that comparisons such as &lt;code&gt;==&lt;/code&gt; operate on whole arrays, giving a single boolean answer. Use dot operators like &lt;code&gt;.==&lt;/code&gt; for elementwise comparisons. (For comparison operations like &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;em&gt;only&lt;/em&gt; the elementwise &lt;code&gt;.&amp;lt;&lt;/code&gt; version is applicable to arrays.)</source>
          <target state="translated">Обратите внимание, что сравнения, такие как &lt;code&gt;==&lt;/code&gt; , работают с целыми массивами, давая один логический ответ. Используйте операторы точки, например &lt;code&gt;.==&lt;/code&gt; , для поэлементных сравнений. (Для операций сравнения, таких как &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;em&gt;только&lt;/em&gt; поэлементная версия &lt;code&gt;.&amp;lt;&lt;/code&gt; Применима к массивам.)</target>
        </trans-unit>
        <trans-unit id="7284837c88b7791c6b3428c825f7f45c66f72e65" translate="yes" xml:space="preserve">
          <source>Note that currently Julia tasks are not scheduled to run on separate CPU cores. True kernel threads are discussed under the topic of &lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;Parallel Computing&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что в настоящее время задачи Julia не запланированы для запуска на отдельных ядрах ЦП. Настоящие потоки ядра обсуждаются в разделе &amp;laquo; &lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;Параллельные вычисления&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3beb748b948689adb5a3e8b4c3e812101bb26004" translate="yes" xml:space="preserve">
          <source>Note that depending on your terminal settings, your TTY may be line buffered and might thus require an additional enter before the data is sent to Julia.</source>
          <target state="translated">Обратите внимание,что в зависимости от настроек вашего терминала,ваше TTY может быть буферизировано и,таким образом,может потребоваться дополнительный ввод перед отправкой данных Джулии.</target>
        </trans-unit>
        <trans-unit id="349e4d1b361394f80e838bc17f47bce14935730e" translate="yes" xml:space="preserve">
          <source>Note that environments requiring higher levels of security can implement this via a custom &lt;code&gt;ClusterManager&lt;/code&gt;. For example, cookies can be pre-shared and hence not specified as a startup argument.</source>
          <target state="translated">Обратите внимание, что в средах, требующих более высокого уровня безопасности, это можно реализовать через настраиваемый &lt;code&gt;ClusterManager&lt;/code&gt; . Например, файлы cookie могут быть предварительно опубликованы и, следовательно, не указаны в качестве аргумента запуска.</target>
        </trans-unit>
        <trans-unit id="fcb9bdb3f2e4e941bd30620b1ce6b0954c3e0db3" translate="yes" xml:space="preserve">
          <source>Note that equivalent expressions may be constructed using &lt;code&gt;Meta.parse&lt;/code&gt; or the direct &lt;code&gt;Expr&lt;/code&gt; form:</source>
          <target state="translated">Обратите внимание, что эквивалентные выражения могут быть &lt;code&gt;Meta.parse&lt;/code&gt; с использованием Meta.parse или прямой формы &lt;code&gt;Expr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d754196211a26fe919af9c527a7cbca9ed7d86d3" translate="yes" xml:space="preserve">
          <source>Note that events may be coalesced, so multiple calls to &lt;code&gt;uv_async_send&lt;/code&gt; may result in a single wakeup notification to the condition.</source>
          <target state="translated">Обратите внимание, что события могут быть объединены, поэтому несколько вызовов &lt;code&gt;uv_async_send&lt;/code&gt; могут привести к одному уведомлению о пробуждении для условия.</target>
        </trans-unit>
        <trans-unit id="d4849ca2aa20715f560db64abeae419c21262c08" translate="yes" xml:space="preserve">
          <source>Note that for this code to work correctly, &lt;code&gt;result_array&lt;/code&gt; must be declared to be of type &lt;code&gt;Ref{Cdouble}&lt;/code&gt; and not &lt;code&gt;Ptr{Cdouble}&lt;/code&gt;. The memory is managed by Julia and the &lt;code&gt;Ref&lt;/code&gt; signature alerts Julia's garbage collector to keep managing the memory for &lt;code&gt;result_array&lt;/code&gt; while the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; executes. If &lt;code&gt;Ptr{Cdouble}&lt;/code&gt; were used instead, the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; may still work, but Julia's garbage collector would not be aware that the memory declared for &lt;code&gt;result_array&lt;/code&gt; is being used by the external C function. As a result, the code may produce a memory leak if &lt;code&gt;result_array&lt;/code&gt; never gets freed by the garbage collector, or if the garbage collector prematurely frees &lt;code&gt;result_array&lt;/code&gt;, the C function may end up throwing an invalid memory access exception.</source>
          <target state="translated">Обратите внимание , что для этого кода для правильной работы, &lt;code&gt;result_array&lt;/code&gt; должен быть объявлен тип &lt;code&gt;Ref{Cdouble}&lt;/code&gt; и не &lt;code&gt;Ptr{Cdouble}&lt;/code&gt; . Памятью управляет Джулия, и подпись &lt;code&gt;Ref&lt;/code&gt; предупреждает сборщик мусора Джулии, чтобы он продолжал управлять памятью для &lt;code&gt;result_array&lt;/code&gt; во время выполнения &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; . Если бы вместо этого использовался &lt;code&gt;Ptr{Cdouble}&lt;/code&gt; , &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; мог бы работать, но сборщик мусора Джулии не знал бы, что память, объявленная для &lt;code&gt;result_array&lt;/code&gt; , используется внешней функцией C. В результате код может вызвать утечку памяти, если &lt;code&gt;result_array&lt;/code&gt; никогда не освобождается сборщиком мусора, или, если сборщик мусора преждевременно освобождает &lt;code&gt;result_array&lt;/code&gt; , функция C может в конечном итоге выбросить недопустимое исключение доступа к памяти.</target>
        </trans-unit>
        <trans-unit id="33dfe8b7bf03d2d566e94e83790270ed34bc079e" translate="yes" xml:space="preserve">
          <source>Note that if both &lt;code&gt;on_error&lt;/code&gt; and &lt;code&gt;retry_delays&lt;/code&gt; are specified, the &lt;code&gt;on_error&lt;/code&gt; hook is called before retrying. If &lt;code&gt;on_error&lt;/code&gt; does not throw (or rethrow) an exception, the element will not be retried.</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;on_error&lt;/code&gt; и &lt;code&gt;retry_delays&lt;/code&gt; , и &lt;code&gt;on_error&lt;/code&gt; перед повторной попыткой вызывается ловушка on_error . Если &lt;code&gt;on_error&lt;/code&gt; не генерирует (или не генерирует повторно) исключение, элемент не будет повторяться.</target>
        </trans-unit>
        <trans-unit id="8626fd0453edd656ad43ae0bf974587f0b161aee" translate="yes" xml:space="preserve">
          <source>Note that if two or more &lt;code&gt;AbstractArrayStyle&lt;/code&gt; subtypes conflict, broadcasting machinery will fall back to producing &lt;code&gt;Array&lt;/code&gt;s. If this is undesirable, you may need to define binary &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt;&lt;code&gt;BroadcastStyle&lt;/code&gt;&lt;/a&gt; rules to control the output type.</source>
          <target state="translated">Обратите внимание, что если два или более подтипа &lt;code&gt;AbstractArrayStyle&lt;/code&gt; конфликтуют, широковещательная машина вернется к созданию &lt;code&gt;Array&lt;/code&gt; s. Если это нежелательно, вам может потребоваться определение двоичных правил &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt; &lt;code&gt;BroadcastStyle&lt;/code&gt; &lt;/a&gt; для управления типом вывода.</target>
        </trans-unit>
        <trans-unit id="ee4a4bbb303899c3b42bdc6b997f22ea80f22b9e" translate="yes" xml:space="preserve">
          <source>Note that in the above example the non-standard version number &lt;code&gt;v&quot;0.3-&quot;&lt;/code&gt; is used, with a trailing &lt;code&gt;-&lt;/code&gt;: this notation is a Julia extension of the standard, and it's used to indicate a version which is lower than any &lt;code&gt;0.3&lt;/code&gt; release, including all of its pre-releases. So in the above example the code would only run with stable &lt;code&gt;0.2&lt;/code&gt; versions, and exclude such versions as &lt;code&gt;v&quot;0.3.0-rc1&quot;&lt;/code&gt;. In order to also allow for unstable (i.e. pre-release) &lt;code&gt;0.2&lt;/code&gt; versions, the lower bound check should be modified like this: &lt;code&gt;v&quot;0.2-&quot; &amp;lt;= VERSION&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что в приведенном выше примере используется нестандартный номер версии &lt;code&gt;v&quot;0.3-&quot;&lt;/code&gt; с завершающим знаком &lt;code&gt;-&lt;/code&gt; : эта нотация является расширением стандарта Julia и используется для обозначения версии, которая ниже, чем любой выпуск &lt;code&gt;0.3&lt;/code&gt; , включая все его предварительные релизы. Таким образом, в приведенном выше примере код будет работать только со стабильными версиями &lt;code&gt;0.2&lt;/code&gt; и исключить такие версии, как &lt;code&gt;v&quot;0.3.0-rc1&quot;&lt;/code&gt; . Чтобы также допустить нестабильные (т.е. предварительные) версии &lt;code&gt;0.2&lt;/code&gt; , проверка нижней границы должна быть изменена следующим образом: &lt;code&gt;v&quot;0.2-&quot; &amp;lt;= VERSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9be55fa4cd393d6af048c6d169ea98f1e7964ae3" translate="yes" xml:space="preserve">
          <source>Note that in this form, the variables are listed outermost-first. This matches the order in which variables are substituted when a type is &quot;applied&quot; to parameter values using the syntax &lt;code&gt;T{p1, p2, ...}&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что в этой форме переменные перечислены первыми от внешних. Это соответствует порядку, в котором переменные заменяются, когда тип &amp;laquo;применяется&amp;raquo; к значениям параметров с использованием синтаксиса &lt;code&gt;T{p1, p2, ...}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="498b2a62007ef2fa8b25a9e52137f4198851e2fb" translate="yes" xml:space="preserve">
          <source>Note that it's very important to specify the two parameters of the &lt;code&gt;AbstractArray&lt;/code&gt;; the first defines the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;, and the second defines the &lt;a href=&quot;../../base/arrays/index#Base.ndims&quot;&gt;&lt;code&gt;ndims&lt;/code&gt;&lt;/a&gt;. That supertype and those three methods are all it takes for &lt;code&gt;SquaresVector&lt;/code&gt; to be an iterable, indexable, and completely functional array:</source>
          <target state="translated">Обратите внимание, что очень важно указать два параметра &lt;code&gt;AbstractArray&lt;/code&gt; ; первый определяет &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; , а второй определяет &lt;a href=&quot;../../base/arrays/index#Base.ndims&quot;&gt; &lt;code&gt;ndims&lt;/code&gt; &lt;/a&gt; . Этот супертип и эти три метода - это все, что требуется для &lt;code&gt;SquaresVector&lt;/code&gt; чтобы SquaresVector был итерируемым, индексируемым и полностью функциональным массивом:</target>
        </trans-unit>
        <trans-unit id="431d8af921ae8dd91eb1906a8ae4ef18ccab5ae1" translate="yes" xml:space="preserve">
          <source>Note that line breaks in literal strings, whether single- or triple-quoted, result in a newline (LF) character &lt;code&gt;\n&lt;/code&gt; in the string, even if your editor uses a carriage return &lt;code&gt;\r&lt;/code&gt; (CR) or CRLF combination to end lines. To include a CR in a string, use an explicit escape &lt;code&gt;\r&lt;/code&gt;; for example, you can enter the literal string &lt;code&gt;&quot;a CRLF line ending\r\n&quot;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что разрывы строк в литеральных строках, заключенные в одинарные или тройные кавычки, приводят к появлению символа новой строки (LF) &lt;code&gt;\n&lt;/code&gt; в строке, даже если ваш редактор использует комбинацию возврата каретки &lt;code&gt;\r&lt;/code&gt; (CR) или CRLF для завершения строк. Чтобы включить CR в строку, используйте явный escape-символ &lt;code&gt;\r&lt;/code&gt; ; например, вы можете ввести буквальную строку &lt;code&gt;&quot;a CRLF line ending\r\n&quot;&lt;/code&gt; строка CRLF, заканчивающаяся \ r \ n&amp;raquo; .</target>
        </trans-unit>
        <trans-unit id="1f41e3fca4e348fe7423c916f24a1ebeef22e314" translate="yes" xml:space="preserve">
          <source>Note that many editors are already defined. All of the following commands should already work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606154b87124703b920a4f5ad5aaefe035ca6c54" translate="yes" xml:space="preserve">
          <source>Note that mathematical functions typically return real values when applied to real numbers and complex values when applied to complex numbers. For example, &lt;code&gt;sqrt&lt;/code&gt; behaves differently when applied to &lt;code&gt;-1&lt;/code&gt; versus &lt;code&gt;-1 + 0im&lt;/code&gt; even though &lt;code&gt;-1 == -1 + 0im&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание, что математические функции обычно возвращают действительные значения при применении к действительным числам и комплексные значения при применении к комплексным числам. Например, &lt;code&gt;sqrt&lt;/code&gt; ведет себя по-разному при применении к &lt;code&gt;-1&lt;/code&gt; по сравнению с &lt;code&gt;-1 + 0im&lt;/code&gt; хотя &lt;code&gt;-1 == -1 + 0im&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9eda807989afc4e218057d81b9286e37073a79b3" translate="yes" xml:space="preserve">
          <source>Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file. (The &lt;a href=&quot;https://github.com/ihnorton/Clang.jl&quot;&gt;Clang package&lt;/a&gt; can be used to auto-generate Julia code from a C header file.)</source>
          <target state="translated">Обратите внимание, что никакие файлы заголовков C не используются нигде в процессе вызова функций C: вы несете ответственность за то, чтобы ваши типы Julia и сигнатуры вызовов точно отражали таковые в файле заголовка C. (Пакет &lt;a href=&quot;https://github.com/ihnorton/Clang.jl&quot;&gt;Clang&lt;/a&gt; можно использовать для автоматической генерации кода Julia из файла заголовка C.)</target>
        </trans-unit>
        <trans-unit id="261026964da2480f5c7569abb83b87f146a2a3d9" translate="yes" xml:space="preserve">
          <source>Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file.&lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="183a9f50d7f1857c8647ee5fe93d5bbd7477e31c" translate="yes" xml:space="preserve">
          <source>Note that no call to &lt;code&gt;free&lt;/code&gt; is required as the data is allocated by Julia.</source>
          <target state="translated">Обратите внимание, что звонок на &lt;code&gt;free&lt;/code&gt; не требуется, так как данные размещены Джулией.</target>
        </trans-unit>
        <trans-unit id="cfb133414980d856fc96bbdc597dbac34e0ca4ba" translate="yes" xml:space="preserve">
          <source>Note that relative-import qualifiers are only valid in &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; statements.</source>
          <target state="translated">Обратите внимание, что квалификаторы относительного импорта действительны только в операторах &lt;code&gt;using&lt;/code&gt; и &lt;code&gt;import&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a7b363c54f5b2b7264272e13433592e29120ac0" translate="yes" xml:space="preserve">
          <source>Note that symbols such as &lt;code&gt;:sin&lt;/code&gt; return precedence &lt;code&gt;0&lt;/code&gt;. This value represents invalid operators and not operators of lowest precedence. Similarly, such operators are assigned associativity &lt;code&gt;:none&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что такие символы, как &lt;code&gt;:sin&lt;/code&gt; , возвращают приоритет &lt;code&gt;0&lt;/code&gt; . Это значение представляет недопустимые операторы, а не операторы с самым низким приоритетом. Аналогично таким операторам присваивается ассоциативность &lt;code&gt;:none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80443d11b9c17836808e9bbc89413ca09c77f642" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method mentioned above operates on binary streams. In particular, values do not get converted to any canonical text representation but are written out as is:</source>
          <target state="translated">Обратите внимание, что упомянутый выше метод &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; работает с двоичными потоками. В частности, значения не преобразуются в какое-либо каноническое текстовое представление, а записываются как есть:</target>
        </trans-unit>
        <trans-unit id="0204290a5fdf9ea4887ee000c8c1756c0892f9d8" translate="yes" xml:space="preserve">
          <source>Note that the LAPACK API provided by Julia can and will change in the future. Since this API is not user-facing, there is no commitment to support/deprecate this specific set of functions in future releases.</source>
          <target state="translated">Обратите внимание,что API LAPACK,предоставленный Джулией,может измениться и будет изменен в будущем.Поскольку этот API не имеет пользовательского интерфейса,нет никаких обязательств по поддержке/удалению этого специфического набора функций в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="fb0eb4027dfd56b0c3ba1c07c0fa8ab9ef0924d1" translate="yes" xml:space="preserve">
          <source>Note that the above nesting rules do not pertain to type and macro definitions as they can only appear at the global scope. There are special scoping rules concerning the evaluation of default and keyword function arguments which are described in the &lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;Function section&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что приведенные выше правила вложения не относятся к определениям типов и макросов, поскольку они могут появляться только в глобальной области. Существуют специальные правила области действия, касающиеся оценки аргументов функции по умолчанию и ключевого слова, которые описаны в разделе &amp;laquo; &lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;Функции&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c3ae1e74a271f6b5b8e3aafc0222e0c6dcf4e1d" translate="yes" xml:space="preserve">
          <source>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression (although it can include a splat expression). And that these arguments will be evaluated in global scope during compile-time (not deferred until runtime). Adding a '$' in front of the function argument changes this to instead create a runtime closure over the local variable &lt;code&gt;callable&lt;/code&gt; (this is not supported on all architectures).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773b4fdf9694adf7f3707027d9426f0fc3ce50f4" translate="yes" xml:space="preserve">
          <source>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression (although it can include a splat expression). And that these arguments will be evaluated in global scope during compile-time (not deferred until runtime). Adding a '$' in front of the function argument changes this to instead create a runtime closure over the local variable &lt;code&gt;callable&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что кортеж типа аргумента должен быть буквальным кортежем, а не переменной или выражением с кортежным значением (хотя он может включать в себя выражение splat). И эти аргументы будут оцениваться в глобальной области во время компиляции (не откладываются до времени выполнения). Добавление символа &amp;laquo;$&amp;raquo; перед аргументом функции изменяет его, чтобы вместо этого создать закрытие среды выполнения над &lt;code&gt;callable&lt;/code&gt; локальной переменной .</target>
        </trans-unit>
        <trans-unit id="242e7f9d29400b013c5ba3cc47959df71abf9a55" translate="yes" xml:space="preserve">
          <source>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.</source>
          <target state="translated">Обратите внимание,что тип аргумента кортеж должен быть буквальным кортежом,а не переменной или выражением,имеющим значение кортежа.</target>
        </trans-unit>
        <trans-unit id="182fad7ccb0af7ec4c64a83ead848d9efa88d9ca" translate="yes" xml:space="preserve">
          <source>Note that the argument type tuple must be written as &lt;code&gt;(Cstring,)&lt;/code&gt;, not &lt;code&gt;(Cstring)&lt;/code&gt;. This is because &lt;code&gt;(Cstring)&lt;/code&gt; is just the expression &lt;code&gt;Cstring&lt;/code&gt; surrounded by parentheses, rather than a 1-tuple containing &lt;code&gt;Cstring&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38c436778b1dcecb24bcf6a6967cf9d78faefe3" translate="yes" xml:space="preserve">
          <source>Note that the argument type tuple must be written as &lt;code&gt;(Cstring,)&lt;/code&gt;, rather than &lt;code&gt;(Cstring)&lt;/code&gt;. This is because &lt;code&gt;(Cstring)&lt;/code&gt; is just the expression &lt;code&gt;Cstring&lt;/code&gt; surrounded by parentheses, rather than a 1-tuple containing &lt;code&gt;Cstring&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание, что кортеж типа аргумента должен быть записан как &lt;code&gt;(Cstring,)&lt;/code&gt; , а не &lt;code&gt;(Cstring)&lt;/code&gt; . Это потому, что &lt;code&gt;(Cstring)&lt;/code&gt; - это просто выражение &lt;code&gt;Cstring&lt;/code&gt; , окруженное круглыми скобками, а не кортеж из 1, содержащий &lt;code&gt;Cstring&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5b481f8f4087ae7ce46e79bd983600ff5e0124bb" translate="yes" xml:space="preserve">
          <source>Note that the behavior of &lt;code&gt;convert(T, x)&lt;/code&gt; appears to be nearly identical to &lt;code&gt;T(x)&lt;/code&gt;. Indeed, it usually is. However, there is a key semantic difference: since &lt;code&gt;convert&lt;/code&gt; can be called implicitly, its methods are restricted to cases that are considered &quot;safe&quot; or &quot;unsurprising&quot;. &lt;code&gt;convert&lt;/code&gt; will only convert between types that represent the same basic kind of thing (e.g. different representations of numbers, or different string encodings). It is also usually lossless; converting a value to a different type and back again should result in the exact same value.</source>
          <target state="translated">Обратите внимание, что поведение &lt;code&gt;convert(T, x)&lt;/code&gt; похоже, почти идентично &lt;code&gt;T(x)&lt;/code&gt; . Действительно, обычно это так. Однако есть ключевое семантическое различие: поскольку &lt;code&gt;convert&lt;/code&gt; может вызываться неявно, его методы ограничены случаями, которые считаются &amp;laquo;безопасными&amp;raquo; или &amp;laquo;неудивительными&amp;raquo;. &lt;code&gt;convert&lt;/code&gt; будет преобразовывать только те типы, которые представляют один и тот же базовый тип вещей (например, разные представления чисел или разные кодировки строк). Это также обычно без потерь; преобразование значения в другой тип и обратно должно привести к тому же самому значению.</target>
        </trans-unit>
        <trans-unit id="de8cab5819ee3b0454c8698908ed4fca8fb69a34" translate="yes" xml:space="preserve">
          <source>Note that the body returns a quoted expression, namely &lt;code&gt;:(x * x)&lt;/code&gt;, rather than just the value of &lt;code&gt;x * x&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что тело возвращает выражение в кавычках, а именно &lt;code&gt;:(x * x)&lt;/code&gt; , а не просто значение &lt;code&gt;x * x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da223622416ae78baf74a5fc7606f5c2031025b7" translate="yes" xml:space="preserve">
          <source>Note that the called function should never call back into Julia.</source>
          <target state="translated">Обратите внимание,что вызываемая функция никогда не должна перезванивать Джулии.</target>
        </trans-unit>
        <trans-unit id="0e4fe61bffc97cc873094be9b6ff384b4a7f4cb2" translate="yes" xml:space="preserve">
          <source>Note that the interactive prompt (aka REPL) is in the global scope of the module &lt;code&gt;Main&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что интерактивная подсказка (также известная как REPL) находится в глобальной области модуля &lt;code&gt;Main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97a7dbc6956af25ac60c32e9cb274b0c6fab138a" translate="yes" xml:space="preserve">
          <source>Note that the return type of the last invocation is different. This is because this server does not listen on TCP, but rather on a named pipe (Windows) or UNIX domain socket. Also note that Windows named pipe format has to be a specific pattern such that the name prefix (&lt;code&gt;\\.\pipe\&lt;/code&gt;) uniquely identifies the &lt;a href=&quot;https://docs.microsoft.com/windows/desktop/ipc/pipe-names&quot;&gt;file type&lt;/a&gt;. The difference between TCP and named pipes or UNIX domain sockets is subtle and has to do with the &lt;a href=&quot;../../stdlib/sockets/index#Sockets.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;connect&lt;/code&gt; methods. The &lt;a href=&quot;../../stdlib/sockets/index#Sockets.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; method retrieves a connection to the client that is connecting on the server we just created, while the &lt;code&gt;connect&lt;/code&gt; function connects to a server using the specified method. The &lt;code&gt;connect&lt;/code&gt; function takes the same arguments as &lt;code&gt;listen&lt;/code&gt;, so, assuming the environment (i.e. host, cwd, etc.) is the same you should be able to pass the same arguments to &lt;code&gt;connect&lt;/code&gt; as you did to listen to establish the connection. So let's try that out (after having created the server above):</source>
          <target state="translated">Обратите внимание, что тип возврата последнего вызова отличается. Это связано с тем, что этот сервер прослушивает не TCP, а именованный канал (Windows) или сокет домена UNIX. Также обратите внимание, что формат именованного канала Windows должен быть определенным шаблоном, чтобы префикс имени ( &lt;code&gt;\\.\pipe\&lt;/code&gt; ) однозначно определял &lt;a href=&quot;https://docs.microsoft.com/windows/desktop/ipc/pipe-names&quot;&gt;тип файла&lt;/a&gt; . Разница между TCP и именованными каналами или сокетами домена UNIX тонкая и связана с методами &lt;a href=&quot;../../stdlib/sockets/index#Sockets.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;connect&lt;/code&gt; . Метод &lt;a href=&quot;../../stdlib/sockets/index#Sockets.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; извлекает соединение с клиентом, который подключается к только что созданному серверу, а функция &lt;code&gt;connect&lt;/code&gt; подключается к серверу с помощью указанного метода. &lt;code&gt;connect&lt;/code&gt; Функция принимает те же аргументы, что и &lt;code&gt;listen&lt;/code&gt; , поэтому, предполагая, что среда (например, host, cwd и т. д.) такая же, вы должны иметь возможность передавать те же аргументы для &lt;code&gt;connect&lt;/code&gt; что и для прослушивания для установления соединения. Итак, давайте попробуем это (после создания сервера выше):</target>
        </trans-unit>
        <trans-unit id="8dd40c0b58dda0e7d5d9e1d231741d7f693239a0" translate="yes" xml:space="preserve">
          <source>Note that the set of operations that should not be attempted in a generated function is unbounded, and the runtime system can currently only detect a subset of the invalid operations. There are many other operations that will simply corrupt the runtime system without notification, usually in subtle ways not obviously connected to the bad definition. Because the function generator is run during inference, it must respect all of the limitations of that code.</source>
          <target state="translated">Обратите внимание,что набор операций,которые не следует пытаться выполнить в генерируемой функции,неограничен,и в настоящее время система выполнения может обнаружить только подмножество недействительных операций.Есть много других операций,которые просто повреждают систему без уведомления,обычно тонкими способами,не связанными с плохим определением.Поскольку генератор функций запускается во время вывода,он должен соблюдать все ограничения этого кода.</target>
        </trans-unit>
        <trans-unit id="7ac5f22fc15bc06ba6d15c028e253bf3612813cc" translate="yes" xml:space="preserve">
          <source>Note that the shifted factorization &lt;code&gt;A+&amp;mu;I = Q (H+&amp;mu;I) Q'&lt;/code&gt; can be constructed efficiently by &lt;code&gt;F + &amp;mu;*I&lt;/code&gt; using the &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt; object &lt;a href=&quot;#LinearAlgebra.I&quot;&gt;&lt;code&gt;I&lt;/code&gt;&lt;/a&gt;, which creates a new &lt;code&gt;Hessenberg&lt;/code&gt; object with shared storage and a modified shift. The shift of a given &lt;code&gt;F&lt;/code&gt; is obtained by &lt;code&gt;F.&amp;mu;&lt;/code&gt;. This is useful because multiple shifted solves &lt;code&gt;(F + &amp;mu;*I) \ b&lt;/code&gt; (for different &lt;code&gt;&amp;mu;&lt;/code&gt; and/or &lt;code&gt;b&lt;/code&gt;) can be performed efficiently once &lt;code&gt;F&lt;/code&gt; is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098c77a244efd4dcb7a85ef8231c87ef6a79d308" translate="yes" xml:space="preserve">
          <source>Note that the style is not to indent the body of the module, since that would typically lead to whole files being indented.</source>
          <target state="translated">Обратите внимание,что стиль не подразумевает отступов от тела модуля,так как это обычно приводит к отступам от целых файлов.</target>
        </trans-unit>
        <trans-unit id="a65dec74aa9406a63b1a11d6bdf0569c8ebb5a00" translate="yes" xml:space="preserve">
          <source>Note that the symbol following &lt;code&gt;catch&lt;/code&gt; will always be interpreted as a name for the exception, so care is needed when writing &lt;code&gt;try/catch&lt;/code&gt; expressions on a single line. The following code will &lt;em&gt;not&lt;/em&gt; work to return the value of &lt;code&gt;x&lt;/code&gt; in case of an error:</source>
          <target state="translated">Обратите внимание, что символ, следующий за &lt;code&gt;catch&lt;/code&gt; , всегда будет интерпретироваться как имя исключения, поэтому необходимо соблюдать осторожность при написании выражений &lt;code&gt;try/catch&lt;/code&gt; в одной строке. Следующий код не &lt;em&gt;сможет&lt;/em&gt; вернуть значение &lt;code&gt;x&lt;/code&gt; в случае ошибки:</target>
        </trans-unit>
        <trans-unit id="fe90e4507c70efe5bc46591274db5ae42533566c" translate="yes" xml:space="preserve">
          <source>Note that there is no printout of &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;. We can see that the body of the generated function was only executed once here, for the specific set of argument types, and the result was cached. After that, for this example, the expression returned from the generated function on the first invocation was re-used as the method body. However, the actual caching behavior is an implementation-defined performance optimization, so it is invalid to depend too closely on this behavior.</source>
          <target state="translated">Обратите внимание, что нет распечатки &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; . Мы видим, что тело сгенерированной функции было выполнено здесь только один раз для определенного набора типов аргументов, а результат был кэширован. После этого для этого примера выражение, возвращенное сгенерированной функцией при первом вызове, было повторно использовано в качестве тела метода. Однако фактическое поведение кэширования - это оптимизация производительности, определяемая реализацией, поэтому недопустимо слишком сильно зависеть от этого поведения.</target>
        </trans-unit>
        <trans-unit id="1ea0d770c1aabeba8e6465e5630623becb93c780" translate="yes" xml:space="preserve">
          <source>Note that this broad category includes characters such as &amp;frac34; and ௰. Use &lt;a href=&quot;#Base.Unicode.isdigit&quot;&gt;&lt;code&gt;isdigit&lt;/code&gt;&lt;/a&gt; to check whether a character a decimal digit between 0 and 9.</source>
          <target state="translated">Обратите внимание, что в эту широкую категорию входят такие символы, как &amp;frac34; и ௰. Используйте &lt;a href=&quot;#Base.Unicode.isdigit&quot;&gt; &lt;code&gt;isdigit&lt;/code&gt; ,&lt;/a&gt; чтобы проверить, является ли символ десятичной цифрой от 0 до 9.</target>
        </trans-unit>
        <trans-unit id="46bce16da8eb5fd4ccc3e853fc20098d7bbd0e2e" translate="yes" xml:space="preserve">
          <source>Note that this does not apply to globals created under module &lt;code&gt;Main&lt;/code&gt;. Globals under module &lt;code&gt;Main&lt;/code&gt; are serialized and new bindings created under &lt;code&gt;Main&lt;/code&gt; on the remote node.</source>
          <target state="translated">Обратите внимание, что это не относится к глобальным объектам, созданным в модуле &lt;code&gt;Main&lt;/code&gt; . Глобальные объекты в модуле &lt;code&gt;Main&lt;/code&gt; сериализуются, и новые привязки создаются в &lt;code&gt;Main&lt;/code&gt; на удаленном узле.</target>
        </trans-unit>
        <trans-unit id="decefaec1642643605dc8ee1c5de68e2852a981d" translate="yes" xml:space="preserve">
          <source>Note that this function is equivalent to, but more efficient than, calling &lt;code&gt;sortperm(...)[k]&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что эта функция эквивалентна, но более эффективна, чем вызов &lt;code&gt;sortperm(...)[k]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e07027027168426f4f2b4f5df57b78ff2fab63d3" translate="yes" xml:space="preserve">
          <source>Note that this is currently only supported for &lt;code&gt;T == BigFloat&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что в настоящее время это поддерживается только для &lt;code&gt;T == BigFloat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f0c770bab0c855a7467cef4c010de3b51ac415b" translate="yes" xml:space="preserve">
          <source>Note that this must be done &lt;em&gt;before&lt;/em&gt; starting Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f522da50be36203fff5e8db4bd6b88f1b3533d" translate="yes" xml:space="preserve">
          <source>Note that this syntax requires parser support so it is expanded directly by the parser rather than being implemented as a normal string macro &lt;code&gt;@var_str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a69672b19bbf6fc996983df5447f2fd2baf53ea0" translate="yes" xml:space="preserve">
          <source>Note that to use &lt;code&gt;:&lt;/code&gt; syntax, the symbol's name must be a valid identifier. Otherwise the &lt;code&gt;Symbol(str)&lt;/code&gt; constructor must be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0687d76141aed2877a1dff058cc77fb55f506a" translate="yes" xml:space="preserve">
          <source>Note that very short conditional statements (one-liners) are frequently expressed using Short-Circuit Evaluation in Julia, as outlined in the next section.</source>
          <target state="translated">Отметим,что очень короткие условные высказывания (однострочные)часто выражаются с помощью короткоцикловой оценки в Юлии,как указано в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="f8c15c95912e4eeb3f6bc8a0cd88bc94054fd059" translate="yes" xml:space="preserve">
          <source>Note that we did not have to explicitly close the channel in the producer. This is because the act of binding a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; to a &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; associates the open lifetime of a channel with that of the bound task. The channel object is closed automatically when the task terminates. Multiple channels can be bound to a task, and vice-versa.</source>
          <target state="translated">Обратите внимание, что нам не нужно было явно закрывать канал в производителе. Это связано с тем, что процесс привязки &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; к &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; связывает время существования открытого канала с временем существования связанной задачи. Объект канала автоматически закрывается при завершении задачи. К задаче можно привязать несколько каналов, и наоборот.</target>
        </trans-unit>
        <trans-unit id="a041f4940ddd89a348e7d26f6b6538be977f726f" translate="yes" xml:space="preserve">
          <source>Note that we used &lt;code&gt;1 .+ fetch(r)&lt;/code&gt; instead of &lt;code&gt;1 .+ r&lt;/code&gt;. This is because we do not know where the code will run, so in general a &lt;code&gt;fetch&lt;/code&gt; might be required to move &lt;code&gt;r&lt;/code&gt; to the process doing the addition. In this case, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; is smart enough to perform the computation on the process that owns &lt;code&gt;r&lt;/code&gt;, so the &lt;code&gt;fetch&lt;/code&gt; will be a no-op (no work is done).</source>
          <target state="translated">Обратите внимание , что мы использовали &lt;code&gt;1 .+ fetch(r)&lt;/code&gt; вместо &lt;code&gt;1 .+ r&lt;/code&gt; . Это связано с тем, что мы не знаем, где будет выполняться код, поэтому обычно может потребоваться &lt;code&gt;fetch&lt;/code&gt; для перемещения &lt;code&gt;r&lt;/code&gt; в процесс, выполняющий добавление. В этом случае &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; достаточно умен, чтобы выполнить вычисление для процесса, которому принадлежит &lt;code&gt;r&lt;/code&gt; , поэтому &lt;code&gt;fetch&lt;/code&gt; будет выполняться (работа не выполняется).</target>
        </trans-unit>
        <trans-unit id="8b476ca57178b877e88595d1fb22b7c6b4d72890" translate="yes" xml:space="preserve">
          <source>Note that we used &lt;code&gt;1 .+ fetch(r)&lt;/code&gt; instead of &lt;code&gt;1 .+ r&lt;/code&gt;. This is because we do not know where the code will run, so in general a &lt;code&gt;fetch&lt;/code&gt; might be required to move &lt;code&gt;r&lt;/code&gt; to the process doing the addition. In this case, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; is smart enough to perform the computation on the process that owns &lt;code&gt;r&lt;/code&gt;, so the &lt;code&gt;fetch&lt;/code&gt; will be a no-op (no work is done).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbfb57351589495d2dd8de2006388f09857c0744" translate="yes" xml:space="preserve">
          <source>Note that when calling &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace()&lt;/code&gt;&lt;/a&gt; you'll typically see a frame with &lt;code&gt;eval at boot.jl&lt;/code&gt;. When calling &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace()&lt;/code&gt;&lt;/a&gt; from the REPL you'll also have a few extra frames in the stack from &lt;code&gt;REPL.jl&lt;/code&gt;, usually looking something like this:</source>
          <target state="translated">Обратите внимание , что при вызове &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace()&lt;/code&gt; &lt;/a&gt; вы будете видеть , как правило кадр с &lt;code&gt;eval at boot.jl&lt;/code&gt; . При вызове &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace()&lt;/code&gt; &lt;/a&gt; из REPL у вас также будет несколько дополнительных кадров в стеке из &lt;code&gt;REPL.jl&lt;/code&gt; , обычно выглядящих примерно так:</target>
        </trans-unit>
        <trans-unit id="e0336c6d353bdf069375cc4ebc53bc56d524d283" translate="yes" xml:space="preserve">
          <source>Note that when using &lt;code&gt;ccall&lt;/code&gt; with the tuple input (e.g., &lt;code&gt;ccall((:my_fcn, &quot;./my_lib.so&quot;), ...)&lt;/code&gt;), the library is opened implicitly and it may not be explicitly closed.</source>
          <target state="translated">Обратите внимание, что при использовании &lt;code&gt;ccall&lt;/code&gt; с вводом кортежа (например, &lt;code&gt;ccall((:my_fcn, &quot;./my_lib.so&quot;), ...)&lt;/code&gt; ) библиотека открывается неявно и не может быть закрыта явно.</target>
        </trans-unit>
        <trans-unit id="f7755931bfc7e42557f4980dc1550eb2a0697dbe" translate="yes" xml:space="preserve">
          <source>Note that while Julia code runs on a single thread (by default), libraries used by Julia may launch their own internal threads. For example, the BLAS library may start as many threads as there are cores on a machine.</source>
          <target state="translated">Обратите внимание,что в то время как код Julia работает в одном потоке (по умолчанию),библиотеки,используемые Julia,могут запускать свои собственные внутренние потоки.Например,библиотека BLAS может запускать столько потоков,сколько имеется ядер на машине.</target>
        </trans-unit>
        <trans-unit id="5d81223c9c8d2eeed50e8859a101793fd1716551" translate="yes" xml:space="preserve">
          <source>Note that whitespace in your doctest is significant! The doctest will fail if you misalign the output of pretty-printing an array, for example.</source>
          <target state="translated">Обратите внимание,что пробельные символы в вашем доктесте значимы! Доктест не пройдет,если вы,например,неправильно выровняете вывод красивой печати массива.</target>
        </trans-unit>
        <trans-unit id="bd5a7cad245d42f3ac5b5566f1d477628cb424e9" translate="yes" xml:space="preserve">
          <source>Note that without a reducer function, &lt;code&gt;@distributed&lt;/code&gt; executes asynchronously, i.e. it spawns independent tasks on all available workers and returns immediately without waiting for completion. To wait for completion, prefix the call with &lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt;&lt;code&gt;@sync&lt;/code&gt;&lt;/a&gt;, like :</source>
          <target state="translated">Обратите внимание, что без функции редуктора &lt;code&gt;@distributed&lt;/code&gt; выполняется асинхронно, т. Е. Порождает независимые задачи для всех доступных воркеров и немедленно возвращается, не дожидаясь завершения. Чтобы дождаться завершения, &lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt; &lt;code&gt;@sync&lt;/code&gt; &lt;/a&gt; к вызову префикс @sync , например:</target>
        </trans-unit>
        <trans-unit id="8b82f9fcca40e4c57bacd44e7da3e166bdb809a5" translate="yes" xml:space="preserve">
          <source>Note that workers do not run a &lt;code&gt;.julia/config/startup.jl&lt;/code&gt; startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes.</source>
          <target state="translated">Обратите внимание, что рабочие не запускают &lt;code&gt;.julia/config/startup.jl&lt;/code&gt; запуска .julia / config / startup.jl и не синхронизируют свое глобальное состояние (например, глобальные переменные, определения новых методов и загруженные модули) с другими запущенными процессами.</target>
        </trans-unit>
        <trans-unit id="c96de6543363babe91fa2bd5f4b7d12201ebc82e" translate="yes" xml:space="preserve">
          <source>Note that workers do not run a &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes.</source>
          <target state="translated">Обратите внимание, что рабочие не запускают сценарий запуска &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; и не синхронизируют свое глобальное состояние (например, глобальные переменные, определения новых методов и загруженные модули) с какими-либо другими запущенными процессами.</target>
        </trans-unit>
        <trans-unit id="89baaa30648337782f32c5ae2ae7030426db160f" translate="yes" xml:space="preserve">
          <source>Note that workers do not run a &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes. You may use &lt;code&gt;addprocs(exeflags=&quot;--project&quot;)&lt;/code&gt; to initialize a worker with a particular environment, and then &lt;code&gt;@everywhere using &amp;lt;modulename&amp;gt;&lt;/code&gt; or &lt;code&gt;@everywhere include(&quot;file.jl&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a97820043be9298d4bc607709ec3ef73b5ab453" translate="yes" xml:space="preserve">
          <source>Note that you can also use &lt;code&gt;string(...)&lt;/code&gt; to concatenate strings (and other values converted to strings); similarly, &lt;code&gt;repeat&lt;/code&gt; can be used instead of &lt;code&gt;^&lt;/code&gt; to repeat strings. The &lt;a href=&quot;../strings/index#string-interpolation&quot;&gt;interpolation syntax&lt;/a&gt; is also useful for constructing strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d8a230b804b324888f6d3a86be63b3abee81ae" translate="yes" xml:space="preserve">
          <source>Note that you can also use &lt;code&gt;string(...)&lt;/code&gt; to concatenate strings (and other values converted to strings); similarly, &lt;code&gt;repeat&lt;/code&gt; can be used instead of &lt;code&gt;^&lt;/code&gt; to repeat strings. The &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;interpolation syntax&lt;/a&gt; is also useful for constructing strings.</source>
          <target state="translated">Обратите внимание, что вы также можете использовать &lt;code&gt;string(...)&lt;/code&gt; для объединения строк (и других значений, преобразованных в строки); аналогично, для повторения строк можно использовать &lt;code&gt;repeat&lt;/code&gt; вместо &lt;code&gt;^&lt;/code&gt; . &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;Синтаксис интерполяции&lt;/a&gt; также полезен для построения строк.</target>
        </trans-unit>
        <trans-unit id="bc21cdea00752ec368b11bbb1559eb6ea1d10cf4" translate="yes" xml:space="preserve">
          <source>Note that, at the time of this writing, the SHA3 code is not optimized, and as such is roughly an order of magnitude slower than SHA2.</source>
          <target state="translated">Отметим,что на момент написания этой статьи SHA3 код не оптимизирован,а потому примерно на порядок медленнее,чем SHA2.</target>
        </trans-unit>
        <trans-unit id="9c3731439f34ac151e71f6a88214f5aa6a661453" translate="yes" xml:space="preserve">
          <source>Note that, in Julia script started without &lt;code&gt;-i&lt;/code&gt; (interactive) option, &lt;code&gt;InterruptException&lt;/code&gt; is not thrown by default. Calling &lt;a href=&quot;../c/index#Base.exit_on_sigint&quot;&gt;&lt;code&gt;Base.exit_on_sigint(false)&lt;/code&gt;&lt;/a&gt; in the script can recover the behavior of the REPL. Alternatively, a Julia script can be started with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f69f72ec1b9af255308c07545be2fc8d856f28" translate="yes" xml:space="preserve">
          <source>Note the distinguishing &lt;code&gt;@&lt;/code&gt; before the macro name and the lack of commas between the argument expressions in the first form, and the lack of whitespace after &lt;code&gt;@name&lt;/code&gt; in the second form. The two styles should not be mixed. For example, the following syntax is different from the examples above; it passes the tuple &lt;code&gt;(expr1, expr2, ...)&lt;/code&gt; as one argument to the macro:</source>
          <target state="translated">Обратите внимание на различие &lt;code&gt;@&lt;/code&gt; перед именем макроса и отсутствие запятых между выражениями аргументов в первой форме и отсутствие пробелов после &lt;code&gt;@name&lt;/code&gt; во второй форме. Два стиля не следует смешивать. Например, следующий синтаксис отличается от приведенных выше примеров; он передает кортеж &lt;code&gt;(expr1, expr2, ...)&lt;/code&gt; как один аргумент макросу:</target>
        </trans-unit>
        <trans-unit id="f72a4ca407bc566d00161d17253a5df7ce9feb29" translate="yes" xml:space="preserve">
          <source>Note the dot syntax is also applicable to user-defined operators. For example, if you define &lt;code&gt;&amp;otimes;(A,B) = kron(A,B)&lt;/code&gt; to give a convenient infix syntax &lt;code&gt;A &amp;otimes; B&lt;/code&gt; for Kronecker products (&lt;a href=&quot;../../stdlib/linearalgebra/index#Base.kron&quot;&gt;&lt;code&gt;kron&lt;/code&gt;&lt;/a&gt;), then &lt;code&gt;[A,B] .&amp;otimes; [C,D]&lt;/code&gt; will compute &lt;code&gt;[A&amp;otimes;C, B&amp;otimes;D]&lt;/code&gt; with no additional coding.</source>
          <target state="translated">Обратите внимание, что точечный синтаксис также применим к определяемым пользователем операторам. Например, если вы определите &lt;code&gt;&amp;otimes;(A,B) = kron(A,B)&lt;/code&gt; чтобы получить удобный инфиксный синтаксис &lt;code&gt;A &amp;otimes; B&lt;/code&gt; для продуктов Кронекера ( &lt;a href=&quot;../../stdlib/linearalgebra/index#Base.kron&quot;&gt; &lt;code&gt;kron&lt;/code&gt; &lt;/a&gt; ), то &lt;code&gt;[A,B] .&amp;otimes; [C,D]&lt;/code&gt; вычислит &lt;code&gt;[A&amp;otimes;C, B&amp;otimes;D]&lt;/code&gt; без дополнительного кодирования.</target>
        </trans-unit>
        <trans-unit id="21adfeb51b92fa6389f9a0f8426e92487dbabd63" translate="yes" xml:space="preserve">
          <source>Note the evaluation behavior of chained comparisons:</source>
          <target state="translated">Обратите внимание на оценочное поведение при цепных сравнениях:</target>
        </trans-unit>
        <trans-unit id="4d5ad5e5567c252cacda0e45872c352990ca190e" translate="yes" xml:space="preserve">
          <source>Note the implications of covariance:</source>
          <target state="translated">Обратите внимание на последствия ковариаций:</target>
        </trans-unit>
        <trans-unit id="c4e365768e844c62cc4abb32f1de51046a7ca82a" translate="yes" xml:space="preserve">
          <source>Note the important difference between &lt;code&gt;sum(A)&lt;/code&gt; and &lt;code&gt;reduce(+, A)&lt;/code&gt; for arrays with small integer eltype:</source>
          <target state="translated">Обратите внимание на важную разницу между &lt;code&gt;sum(A)&lt;/code&gt; и &lt;code&gt;reduce(+, A)&lt;/code&gt; для массивов с небольшим целым типом eltype:</target>
        </trans-unit>
        <trans-unit id="d6be73201d2bdb5b60bd4ac16f617f03563234a7" translate="yes" xml:space="preserve">
          <source>Note the lack of a newline at the end of &lt;code&gt;/tmp/text.txt&lt;/code&gt;. Julia automatically inserts a newline before the &lt;code&gt;julia&amp;gt;&lt;/code&gt; prompt.</source>
          <target state="translated">Обратите внимание на отсутствие новой строки в конце &lt;code&gt;/tmp/text.txt&lt;/code&gt; . Джулия автоматически вставляет новую строку перед приглашением &lt;code&gt;julia&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b34f97175a230919ab690f3d87c164c80cc78fa" translate="yes" xml:space="preserve">
          <source>Note the two spaces before each &lt;code&gt;*&lt;/code&gt; and the single space after each one.</source>
          <target state="translated">Обратите внимание на два пробела перед каждым &lt;code&gt;*&lt;/code&gt; и один пробел после каждого.</target>
        </trans-unit>
        <trans-unit id="36a8e68f48fc3d2175af90fbf8e18f9e672cd18b" translate="yes" xml:space="preserve">
          <source>Note, though, that the above &lt;em&gt;only&lt;/em&gt; defines &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; with one integer index. Indexing with anything other than an &lt;code&gt;Int&lt;/code&gt; will throw a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; saying that there was no matching method. In order to support indexing with ranges or vectors of &lt;code&gt;Int&lt;/code&gt;s, separate methods must be written:</source>
          <target state="translated">Однако обратите внимание, что приведенное выше определяет &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;&lt;em&gt; только&lt;/em&gt; с одним целочисленным индексом. Индексирование с чем-либо, кроме &lt;code&gt;Int&lt;/code&gt; , вызовет &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; , что не было подходящего метода. Чтобы поддерживать индексацию с диапазонами или векторами &lt;code&gt;Int&lt;/code&gt; , необходимо написать отдельные методы:</target>
        </trans-unit>
        <trans-unit id="8482997969bd6e2f8506bbaee3f00bf7673cbff9" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Sampler(rng, x)&lt;/code&gt; is simply a shorthand for &lt;code&gt;Sampler(rng, x, Val(Inf))&lt;/code&gt;, and &lt;code&gt;Random.Repetition&lt;/code&gt; is an alias for &lt;code&gt;Union{Val{1}, Val{Inf}}&lt;/code&gt;.</source>
          <target state="translated">Примечание. &lt;code&gt;Sampler(rng, x)&lt;/code&gt; - это просто сокращение для &lt;code&gt;Sampler(rng, x, Val(Inf))&lt;/code&gt; , а &lt;code&gt;Random.Repetition&lt;/code&gt; - это псевдоним для &lt;code&gt;Union{Val{1}, Val{Inf}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d1a9fbb062505ef6ee2056aac065b143189a068" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;nextfloat()&lt;/code&gt;, &lt;code&gt;prevfloat()&lt;/code&gt; do not use the precision mentioned by &lt;code&gt;setprecision&lt;/code&gt;</source>
          <target state="translated">Примечание: &lt;code&gt;nextfloat()&lt;/code&gt; , &lt;code&gt;prevfloat()&lt;/code&gt; не используют точность, указанную &lt;code&gt;setprecision&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d257ed043f41d212dfcd94a6cc7dccb052911321" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;zip&lt;/code&gt; orders the calls to its subiterators in such a way that stateful iterators will not advance when another iterator finishes in the current iteration.</source>
          <target state="translated">Примечание: &lt;code&gt;zip&lt;/code&gt; упорядочивает вызовы своих подитераторов таким образом, что итераторы с сохранением состояния не будут продвигаться, когда другой итератор завершит текущую итерацию.</target>
        </trans-unit>
        <trans-unit id="08efe73137cc5e3a0b821052128f9b49198fdb18" translate="yes" xml:space="preserve">
          <source>Note: The absence of warnings generated by &lt;code&gt;@warn&lt;/code&gt; cannot be tested with this macro. Use &lt;code&gt;@test_logs expr&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ce3aec96b4e4fe9ae814dda08f7cfcb11c5b12" translate="yes" xml:space="preserve">
          <source>Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.</source>
          <target state="translated">Замечание:На данный момент данная возможность реализована только на 64-битных платформах x86 и AArch64.</target>
        </trans-unit>
        <trans-unit id="4ae106ae74dde49286b4f7547e9e4c37d9125364" translate="yes" xml:space="preserve">
          <source>Note: Warnings generated by &lt;code&gt;@warn&lt;/code&gt; cannot be tested with this macro. Use &lt;code&gt;@test_logs&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbe152fdfb8ac8116096c5833a5da72fe28dcdf6" translate="yes" xml:space="preserve">
          <source>Notebook</source>
          <target state="translated">Notebook</target>
        </trans-unit>
        <trans-unit id="3745a01d14712bbd397dca189f292ef9d4f82931" translate="yes" xml:space="preserve">
          <source>Notebook With Decorative Cover</source>
          <target state="translated">Ноутбук с декоративной крышкой</target>
        </trans-unit>
        <trans-unit id="f845802acfac532c071d4aaa950ebd7924f7445d" translate="yes" xml:space="preserve">
          <source>Noteworthy Differences from other Languages</source>
          <target state="translated">Примечательные отличия от других Языков</target>
        </trans-unit>
        <trans-unit id="66ce7a541bd48804d295c01fa8bd545df0afeca2" translate="yes" xml:space="preserve">
          <source>Noteworthy differences from C/C++</source>
          <target state="translated">Заметные отличия от С/С++</target>
        </trans-unit>
        <trans-unit id="e3122c16054a2bae65c636644688d117bb642dbb" translate="yes" xml:space="preserve">
          <source>Noteworthy differences from Common Lisp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7010f263a0a8c01d527c668d3aa731a8f234b4a1" translate="yes" xml:space="preserve">
          <source>Noteworthy differences from MATLAB</source>
          <target state="translated">Заметные отличия от MATLAB</target>
        </trans-unit>
        <trans-unit id="0dde472d5176039598d0e8a87239f04a077f873a" translate="yes" xml:space="preserve">
          <source>Noteworthy differences from Python</source>
          <target state="translated">Заметные отличия от Питона</target>
        </trans-unit>
        <trans-unit id="f7e2b96cfe1dbe019d8e0fb2a6d3e5e7789c4a19" translate="yes" xml:space="preserve">
          <source>Noteworthy differences from R</source>
          <target state="translated">Заметные отличия от R</target>
        </trans-unit>
        <trans-unit id="8eaeecbc1c997d4fd71223a0cf24b0b3a194db6a" translate="yes" xml:space="preserve">
          <source>Noteworthy external packages</source>
          <target state="translated">Примечательные внешние пакеты</target>
        </trans-unit>
        <trans-unit id="2cfa8112f928b66aa11f861fcbbd7f424b123fed" translate="yes" xml:space="preserve">
          <source>Nothingness and missing values</source>
          <target state="translated">Ничего небытия и отсутствующие ценности</target>
        </trans-unit>
        <trans-unit id="b285dba5e2d226b2bb71434ab5cf1c3897f514df" translate="yes" xml:space="preserve">
          <source>Notice both the 3&amp;times; speedup and the decreased memory allocation of the &lt;code&gt;fview&lt;/code&gt; version of the function.</source>
          <target state="translated">Обратите внимание как на 3- &lt;code&gt;fview&lt;/code&gt; ускорение, так и на уменьшенное выделение памяти в версии функции fview .</target>
        </trans-unit>
        <trans-unit id="e1f51bd973f62a02cf830582487e4dd72c9333cd" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;(1 + 2)&lt;/code&gt; now appears in the result instead of the symbol &lt;code&gt;x&lt;/code&gt;. Evaluating this expression yields an interpolated &lt;code&gt;3&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a584fefd44f3b390733917fbd3332df61560b9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;:(1 + 2)&lt;/code&gt; now appears in the result instead of the symbol &lt;code&gt;:x&lt;/code&gt;. Evaluating this expression yields an interpolated &lt;code&gt;3&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;:(1 + 2)&lt;/code&gt; теперь появляется в результате вместо символа &lt;code&gt;:x&lt;/code&gt; . Оценка этого выражения дает интерполированные &lt;code&gt;3&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cf54d9610c4312df35c98185a406d728d6063413" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Vararg{T}&lt;/code&gt; corresponds to zero or more elements of type &lt;code&gt;T&lt;/code&gt;. Vararg tuple types are used to represent the arguments accepted by varargs methods (see &lt;a href=&quot;../functions/index#Varargs-Functions&quot;&gt;Varargs Functions&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8a8a782d504cc3899237534fddcfde617523d9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Vararg{T}&lt;/code&gt; corresponds to zero or more elements of type &lt;code&gt;T&lt;/code&gt;. Vararg tuple types are used to represent the arguments accepted by varargs methods (see &lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;Vararg{T}&lt;/code&gt; , соответствует нуль или более элементов типа &lt;code&gt;T&lt;/code&gt; . Типы кортежей Vararg используются для представления аргументов, принимаемых методами varargs (см. &lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Функции Varargs&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="11bb07567655e1f8b926942e92a94d2603e316d5" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;copy_cols&lt;/code&gt; is much faster than &lt;code&gt;copy_rows&lt;/code&gt;. This is expected because &lt;code&gt;copy_cols&lt;/code&gt; respects the column-based memory layout of the &lt;code&gt;Matrix&lt;/code&gt; and fills it one column at a time. Additionally, &lt;code&gt;copy_col_row&lt;/code&gt; is much faster than &lt;code&gt;copy_row_col&lt;/code&gt; because it follows our rule of thumb that the first element to appear in a slice expression should be coupled with the inner-most loop.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;copy_cols&lt;/code&gt; намного быстрее, чем &lt;code&gt;copy_rows&lt;/code&gt; . Это ожидается, потому что &lt;code&gt;copy_cols&lt;/code&gt; учитывает структуру памяти &lt;code&gt;Matrix&lt;/code&gt; на основе столбцов и заполняет ее по одному столбцу за раз. Кроме того, &lt;code&gt;copy_col_row&lt;/code&gt; намного быстрее, чем &lt;code&gt;copy_row_col&lt;/code&gt; , потому что он следует нашему практическому правилу, согласно которому первый элемент, который появляется в выражении среза, должен быть связан с самым внутренним циклом.</target>
        </trans-unit>
        <trans-unit id="b6fec7442f6e6a427e8a8d522c95544bfa904449" translate="yes" xml:space="preserve">
          <source>Notice that a length-1 tuple must be written with a comma, &lt;code&gt;(1,)&lt;/code&gt;, since &lt;code&gt;(1)&lt;/code&gt; would just be a parenthesized value. &lt;code&gt;()&lt;/code&gt; represents the empty (length-0) tuple.</source>
          <target state="translated">Обратите внимание, что кортеж длиной 1 должен быть записан с запятой &lt;code&gt;(1,)&lt;/code&gt; , поскольку &lt;code&gt;(1)&lt;/code&gt; будет просто значением в скобках. &lt;code&gt;()&lt;/code&gt; представляет собой пустой кортеж (длина-0).</target>
        </trans-unit>
        <trans-unit id="f287cb5fedcc8f5e7808755801d877f4587681d7" translate="yes" xml:space="preserve">
          <source>Notice that each definition looks like the form of constructor call that it handles. The call &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; will invoke the definition &lt;code&gt;Point{T}(x,y)&lt;/code&gt; inside the &lt;code&gt;struct&lt;/code&gt; block. The outer constructor declaration, on the other hand, defines a method for the general &lt;code&gt;Point&lt;/code&gt; constructor which only applies to pairs of values of the same real type. This declaration makes constructor calls without explicit type parameters, like &lt;code&gt;Point(1,2)&lt;/code&gt; and &lt;code&gt;Point(1.0,2.5)&lt;/code&gt;, work. Since the method declaration restricts the arguments to being of the same type, calls like &lt;code&gt;Point(1,2.5)&lt;/code&gt;, with arguments of different types, result in &quot;no method&quot; errors.</source>
          <target state="translated">Обратите внимание, что каждое определение выглядит как форма вызова конструктора, которую оно обрабатывает. Вызов &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; вызовет определение &lt;code&gt;Point{T}(x,y)&lt;/code&gt; внутри блока &lt;code&gt;struct&lt;/code&gt; . Объявление внешнего конструктора, с другой стороны, определяет метод для общего конструктора &lt;code&gt;Point&lt;/code&gt; , который применяется только к парам значений одного и того же реального типа. Это объявление заставляет работать вызовы конструктора без явных параметров типа, таких как &lt;code&gt;Point(1,2)&lt;/code&gt; и &lt;code&gt;Point(1.0,2.5)&lt;/code&gt; . Поскольку объявление метода ограничивает аргументы одним типом, такие вызовы, как &lt;code&gt;Point(1,2.5)&lt;/code&gt; , с аргументами разных типов, приводят к ошибкам &amp;laquo;без метода&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b4e2247285a711b8f77ce042019fc6f3ec7e1067" translate="yes" xml:space="preserve">
          <source>Notice that it is perfectly possible to define a global inside a function like &lt;code&gt;__init__&lt;/code&gt;; this is one of the advantages of using a dynamic language. But by making it a constant at global scope, we can ensure that the type is known to the compiler and allow it to generate better optimized code. Obviously, any other globals in your module that depends on &lt;code&gt;foo_data_ptr&lt;/code&gt; would also have to be initialized in &lt;code&gt;__init__&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что вполне возможно определить глобал внутри такой функции, как &lt;code&gt;__init__&lt;/code&gt; ; это одно из преимуществ использования динамического языка. Но сделав его константой в глобальной области видимости, мы можем гарантировать, что тип известен компилятору и позволить ему генерировать более оптимизированный код. Очевидно, что любые другие глобальные переменные в вашем модуле, которые зависят от &lt;code&gt;foo_data_ptr&lt;/code&gt; , также должны быть инициализированы в &lt;code&gt;__init__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e26af993d1f21f6e38ead5214b5da67c55ed9c51" translate="yes" xml:space="preserve">
          <source>Notice that our use of this pattern with &lt;code&gt;count_heads&lt;/code&gt; can be generalized. We used two explicit &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; statements, which limits the parallelism to two processes. To run on any number of processes, we can use a &lt;em&gt;parallel for loop&lt;/em&gt;, running in distributed memory, which can be written in Julia using &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@distributed&quot;&gt;&lt;code&gt;@distributed&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="translated">Обратите внимание, что наше использование этого шаблона с &lt;code&gt;count_heads&lt;/code&gt; можно обобщить. Мы использовали два явных оператора &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; , что ограничивает параллелизм двумя процессами. Чтобы запустить любое количество процессов, мы можем использовать &lt;em&gt;параллельный цикл for&lt;/em&gt; , работающий в распределенной памяти, который можно записать на Julia с помощью &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@distributed&quot;&gt; &lt;code&gt;@distributed&lt;/code&gt; &lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="c6176e267224c5182e5ef2888a5422728bb14a5a" translate="yes" xml:space="preserve">
          <source>Notice that our use of this pattern with &lt;code&gt;count_heads&lt;/code&gt; can be generalized. We used two explicit &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; statements, which limits the parallelism to two processes. To run on any number of processes, we can use a &lt;em&gt;parallel for loop&lt;/em&gt;, running in distributed memory, which can be written in Julia using &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@distributed&quot;&gt;&lt;code&gt;@distributed&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7122bc7ae3f346c6db77a364221c454e445b8694" translate="yes" xml:space="preserve">
          <source>Notice that some useful information such as the event time is not included by default. This is because such information can be expensive to extract and is also &lt;em&gt;dynamically&lt;/em&gt; available to the current logger. It's simple to define a &lt;a href=&quot;#AbstractLogger-interface&quot;&gt;custom logger&lt;/a&gt; to augment event data with the time, backtrace, values of global variables and other useful information as required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72438d3388f10dff00ade8e549f029a3aeac6ed1" translate="yes" xml:space="preserve">
          <source>Notice that some useful information such as the event time is not included by default. This is because such information can be expensive to extract and is also &lt;em&gt;dynamically&lt;/em&gt; available to the current logger. It's simple to define a &lt;a href=&quot;#AbstractLogger-interface-1&quot;&gt;custom logger&lt;/a&gt; to augment event data with the time, backtrace, values of global variables and other useful information as required.</source>
          <target state="translated">Обратите внимание, что некоторая полезная информация, такая как время события, не включена по умолчанию. Это связано с тем, что извлечение такой информации может быть дорогостоящим, а также &lt;em&gt;динамически&lt;/em&gt; доступным для текущего регистратора. Определить &lt;a href=&quot;#AbstractLogger-interface-1&quot;&gt;настраиваемый регистратор просто&lt;/a&gt; для дополнения данных о событиях временем, трассировкой, значениями глобальных переменных и другой полезной информацией по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="4e77dd3d046d81afb4b62f7ad7414d418b5c22e3" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;$&lt;/code&gt; interpolation syntax allows inserting only a single expression into an enclosing expression. Occasionally, you have an array of expressions and need them all to become arguments of the surrounding expression. This can be done with the syntax &lt;code&gt;$(xs...)&lt;/code&gt;. For example, the following code generates a function call where the number of arguments is determined programmatically:</source>
          <target state="translated">Обратите внимание, что синтаксис &lt;code&gt;$&lt;/code&gt; interpolation позволяет вставлять только одно выражение во включающее выражение. Иногда у вас есть массив выражений, и вам нужно, чтобы все они стали аргументами окружающего выражения. Это можно сделать с помощью синтаксиса &lt;code&gt;$(xs...)&lt;/code&gt; . Например, следующий код генерирует вызов функции, в которой количество аргументов определяется программно:</target>
        </trans-unit>
        <trans-unit id="f30b72621d9228b399ae55ac5b16e08861f68644" translate="yes" xml:space="preserve">
          <source>Notice that the expressions &lt;code&gt;str[k]&lt;/code&gt; and &lt;code&gt;str[k:k]&lt;/code&gt; do not give the same result:</source>
          <target state="translated">Обратите внимание, что выражения &lt;code&gt;str[k]&lt;/code&gt; и &lt;code&gt;str[k:k]&lt;/code&gt; не дают одинакового результата:</target>
        </trans-unit>
        <trans-unit id="50882ef5eb622d73f029f8ec3b3fd05b58b270d6" translate="yes" xml:space="preserve">
          <source>Notice that the first two backslashes appear verbatim in the output, since they do not precede a quote character. However, the next backslash character escapes the backslash that follows it, and the last backslash escapes a quote, since these backslashes appear before a quote.</source>
          <target state="translated">Обратите внимание,что первые два обратных слеша появляются в выводе дословно,так как они не предшествуют символу кавычки.Однако следующий символ обратного слеша экранирует следующий за ним символ обратного слеша,а последний экранирует кавычки,так как эти обратные слеши появляются перед кавычкой.</target>
        </trans-unit>
        <trans-unit id="daa54f3f580d525d2a76ffa60a5689c1c5463f9e" translate="yes" xml:space="preserve">
          <source>Notice that the function is specified by type instead of by name. As with normal functions there is a terse syntax form. In the function body, &lt;code&gt;p&lt;/code&gt; will refer to the object that was called. A &lt;code&gt;Polynomial&lt;/code&gt; can be used as follows:</source>
          <target state="translated">Обратите внимание, что функция определяется типом, а не именем. Как и в случае с обычными функциями, существует краткая форма синтаксиса. В теле функции &lt;code&gt;p&lt;/code&gt; будет ссылаться на вызываемый объект. &lt;code&gt;Polynomial&lt;/code&gt; может быть использован следующим образом :</target>
        </trans-unit>
        <trans-unit id="5dcfe9bbe8a4c7456c17e6110860bb059bdd4a91" translate="yes" xml:space="preserve">
          <source>Notice that the result contains &lt;code&gt;$x&lt;/code&gt;, which means that &lt;code&gt;x&lt;/code&gt; has not been evaluated yet. In other words, the &lt;code&gt;$&lt;/code&gt; expression &quot;belongs to&quot; the inner quote expression, and so its argument is only evaluated when the inner quote expression is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96ff399952b84bc498d1458b6e85213e0bfa3829" translate="yes" xml:space="preserve">
          <source>Notice that the result contains &lt;code&gt;Expr(:$, :x)&lt;/code&gt;, which means that &lt;code&gt;x&lt;/code&gt; has not been evaluated yet. In other words, the &lt;code&gt;$&lt;/code&gt; expression &quot;belongs to&quot; the inner quote expression, and so its argument is only evaluated when the inner quote expression is:</source>
          <target state="translated">Обратите внимание, что результат содержит &lt;code&gt;Expr(:$, :x)&lt;/code&gt; , что означает, что &lt;code&gt;x&lt;/code&gt; еще не вычислен. Другими словами, выражение &lt;code&gt;$&lt;/code&gt; &quot;принадлежит&quot; выражению внутренней кавычки, и поэтому его аргумент оценивается только тогда, когда выражение внутренней кавычки:</target>
        </trans-unit>
        <trans-unit id="54f09e2f65ad8085647006de1626ffad88dc6727" translate="yes" xml:space="preserve">
          <source>Notice that the stack trace now indicates the appropriate line number and the missing frame.</source>
          <target state="translated">Обратите внимание,что трасса стека теперь указывает на соответствующий номер линии и недостающий кадр.</target>
        </trans-unit>
        <trans-unit id="aebc78ff444f4c01a4825c1a20cbd6cc86150c76" translate="yes" xml:space="preserve">
          <source>Notice that the vector returned by &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt; had 18 elements, while the vector returned by &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt; only has 6. This is because, by default, &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt; removes any lower-level C functions from the stack. If you want to include stack frames from C calls, you can do it like this:</source>
          <target state="translated">Обратите внимание, что вектор, возвращаемый &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; ,&lt;/a&gt; имеет 18 элементов, тогда как вектор, возвращаемый функцией stacktrace, имеет только 6. Это связано с тем, что по умолчанию &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt; удаляет из стека любые C-функции нижнего уровня. Если вы хотите включить кадры стека из вызовов C, вы можете сделать это следующим образом:</target>
        </trans-unit>
        <trans-unit id="ee5ca2b2885fa1bdef7f82616fa1f043f50e8db7" translate="yes" xml:space="preserve">
          <source>Notice that this is an &lt;code&gt;IndexCartesian&lt;/code&gt; array, so we must manually define &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; at the dimensionality of the array. Unlike the &lt;code&gt;SquaresVector&lt;/code&gt;, we are able to define &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;, and so we can mutate the array:</source>
          <target state="translated">Обратите внимание, что это массив &lt;code&gt;IndexCartesian&lt;/code&gt; , поэтому мы должны вручную определить &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;при размерности массива. В отличие от &lt;code&gt;SquaresVector&lt;/code&gt; , мы можем определить &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;, и поэтому мы можем изменить массив:</target>
        </trans-unit>
        <trans-unit id="af83b123f16ac259b3fe0cc2827d1e1b4b21fb95" translate="yes" xml:space="preserve">
          <source>Notice that we added an error check to the top of the function. This code will be common to both versions, and is run-time code in both versions (it will be quoted and returned as an expression from the generated version). That means that the values and types of local variables are not available at code generation time &amp;ndash;- the code-generation code can only see the types of arguments.</source>
          <target state="translated">Обратите внимание, что мы добавили проверку на ошибки в начало функции. Этот код будет общим для обеих версий и является кодом времени выполнения в обеих версиях (он будет заключен в кавычки и возвращен как выражение из сгенерированной версии). Это означает, что значения и типы локальных переменных недоступны во время генерации кода - код генерации кода может видеть только типы аргументов.</target>
        </trans-unit>
        <trans-unit id="85c1a66b9e620afc51ecba417f9133040596ec1a" translate="yes" xml:space="preserve">
          <source>Notice that we have to be careful about the return type: &lt;code&gt;qsort&lt;/code&gt; expects a function returning a C &lt;code&gt;int&lt;/code&gt;, so we annotate the return type of the function to be sure it returns a &lt;code&gt;Cint&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что мы должны быть осторожны с типом возвращаемого значения: &lt;code&gt;qsort&lt;/code&gt; ожидает, что функция вернет C &lt;code&gt;int&lt;/code&gt; , поэтому мы аннотируем возвращаемый тип функции, чтобы быть уверенным, что она вернет &lt;code&gt;Cint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97bfa30273f29d9ac1e683ece19a0a5356f6f5be" translate="yes" xml:space="preserve">
          <source>Notice that while Julia arrays use 1-based indexing, the C API uses 0-based indexing (for example in calling &lt;code&gt;jl_array_dim&lt;/code&gt;) in order to read as idiomatic C code.</source>
          <target state="translated">Обратите внимание, что в то время как массивы Julia используют индексирование на основе 1, C API использует индексирование на основе 0 (например, при вызове &lt;code&gt;jl_array_dim&lt;/code&gt; ), чтобы читать как идиоматический код C.</target>
        </trans-unit>
        <trans-unit id="7a732c1e34616f1731678500073f8d82eb56b429" translate="yes" xml:space="preserve">
          <source>Notice the extra set of parentheses in the definition of &lt;code&gt;gap&lt;/code&gt;. Without those, &lt;code&gt;gap&lt;/code&gt; would be a two-argument function, and this example would not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2b0ac6f443d8a0c98a2d2f9939dd9325a7d1bb" translate="yes" xml:space="preserve">
          <source>Notice the extra set of parentheses in the definition of &lt;code&gt;range&lt;/code&gt;. Without those, &lt;code&gt;range&lt;/code&gt; would be a two-argument function, and this example would not work.</source>
          <target state="translated">Обратите внимание на дополнительный набор круглых скобок в определении &lt;code&gt;range&lt;/code&gt; . Без них &lt;code&gt;range&lt;/code&gt; был бы функцией с двумя аргументами, и этот пример не работал бы.</target>
        </trans-unit>
        <trans-unit id="2f8d9d4ee1e20bc7f450236baf5646b01a058df8" translate="yes" xml:space="preserve">
          <source>Notice the feedback has changed. &lt;code&gt;dev/Example&lt;/code&gt; refers to the location of the newly created clone. If we look inside the &lt;code&gt;/tmp/tutorial&lt;/code&gt; directory, we will notice the following files:</source>
          <target state="translated">Обратите внимание, что отзыв изменился. &lt;code&gt;dev/Example&lt;/code&gt; относится к местоположению вновь созданного клона. Если мы заглянем в каталог &lt;code&gt;/tmp/tutorial&lt;/code&gt; , мы заметим следующие файлы:</target>
        </trans-unit>
        <trans-unit id="1a051068a64fb1c3e3e967fac93fc0840d028c92" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;@assert&lt;/code&gt; has two modes of operation, depending upon the number of arguments it receives! If there's only one argument, the tuple of expressions captured by &lt;code&gt;msgs&lt;/code&gt; will be empty and it will behave the same as the simpler definition above. But now if the user specifies a second argument, it is printed in the message body instead of the failing expression. You can inspect the result of a macro expansion with the aptly named &lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt;&lt;code&gt;@macroexpand&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">Теперь у &lt;code&gt;@assert&lt;/code&gt; есть два режима работы, в зависимости от количества получаемых аргументов! Если есть только один аргумент, кортеж выражений, захваченных &lt;code&gt;msgs&lt;/code&gt; , будет пустым и будет вести себя так же, как и более простое определение выше. Но теперь, если пользователь указывает второй аргумент, он печатается в теле сообщения вместо ошибочного выражения. Вы можете проверить результат расширения макроса с помощью метко названного макроса &lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt; &lt;code&gt;@macroexpand&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1e2231a9957a4ccae243c25509bec2784a2d3a3f" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;OrderedPair&lt;/code&gt; objects can only be constructed such that &lt;code&gt;x &amp;lt;= y&lt;/code&gt;:</source>
          <target state="translated">Теперь объекты &lt;code&gt;OrderedPair&lt;/code&gt; можно создавать только так, чтобы &lt;code&gt;x &amp;lt;= y&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="40de368ecfa7c73caca67b96df391a19f1bf239e" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;Point{Float64}&lt;/code&gt; and &lt;code&gt;DiagPoint{Float64}&lt;/code&gt; are implementations of the &lt;code&gt;Pointy{Float64}&lt;/code&gt; abstraction, and similarly for every other possible choice of type &lt;code&gt;T&lt;/code&gt;. This allows programming to a common interface shared by all &lt;code&gt;Pointy&lt;/code&gt; objects, implemented for both &lt;code&gt;Point&lt;/code&gt; and &lt;code&gt;DiagPoint&lt;/code&gt;. This cannot be fully demonstrated, however, until we have introduced methods and dispatch in the next section, &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad75dff988cb9333f0487b17ce167ce88105dcde" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;Point{Float64}&lt;/code&gt; and &lt;code&gt;DiagPoint{Float64}&lt;/code&gt; are implementations of the &lt;code&gt;Pointy{Float64}&lt;/code&gt; abstraction, and similarly for every other possible choice of type &lt;code&gt;T&lt;/code&gt;. This allows programming to a common interface shared by all &lt;code&gt;Pointy&lt;/code&gt; objects, implemented for both &lt;code&gt;Point&lt;/code&gt; and &lt;code&gt;DiagPoint&lt;/code&gt;. This cannot be fully demonstrated, however, until we have introduced methods and dispatch in the next section, &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;.</source>
          <target state="translated">Теперь обе &lt;code&gt;Point{Float64}&lt;/code&gt; и &lt;code&gt;DiagPoint{Float64}&lt;/code&gt; являются реализациями &lt;code&gt;Pointy{Float64}&lt;/code&gt; абстракции, а так же для любого другого возможного выбора типа &lt;code&gt;T&lt;/code&gt; . Это позволяет программировать общий интерфейс, общий для всех объектов &lt;code&gt;Pointy&lt;/code&gt; , реализованный как для &lt;code&gt;Point&lt;/code&gt; ,так и для &lt;code&gt;DiagPoint&lt;/code&gt; . Однако это невозможно полностью продемонстрировать, пока мы не представим методы и диспетчеризацию в следующем разделе, &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Методы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a8eb478caf8225997c8cf2d8c6dbbb955a7809c" translate="yes" xml:space="preserve">
          <source>Now if you look closely enough at this example, you may notice that it is incorrect, given our explanation above of preferred declaration types. Do you see it? The function we are calling is going to free the memory. This type of operation cannot be given a Julia object (it will crash or cause memory corruption). Therefore, it may be preferable to declare the &lt;code&gt;p&lt;/code&gt; type as &lt;code&gt;Ptr{gsl_permutation }&lt;/code&gt;, to make it harder for the user to mistakenly pass another sort of object there than one obtained via &lt;code&gt;gsl_permutation_alloc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75f16af32eb0cb857152589e2956bb0503dad48" translate="yes" xml:space="preserve">
          <source>Now just imagine that instead of 7-7-7, the slots are Year-Month-Day, or in our example, 2014-01-31. When you ask to add 1 month to this date, the month slot is incremented, so now we have 2014-02-31. Then the day number is checked if it is greater than the last valid day of the new month; if it is (as in the case above), the day number is adjusted down to the last valid day (28). What are the ramifications with this approach? Go ahead and add another month to our date, &lt;code&gt;2014-02-28 + Month(1) == 2014-03-28&lt;/code&gt;. What? Were you expecting the last day of March? Nope, sorry, remember the 7-7-7 slots. As few slots as possible are going to change, so we first increment the month slot by 1, 2014-03-28, and boom, we're done because that's a valid date. On the other hand, if we were to add 2 months to our original date, 2014-01-31, then we end up with 2014-03-31, as expected. The other ramification of this approach is a loss in associativity when a specific ordering is forced (i.e. adding things in different orders results in different outcomes). For example:</source>
          <target state="translated">Теперь представьте, что вместо 7-7-7 слоты - это год-месяц-день, или, в нашем примере, 2014-01-31. Когда вы просите добавить 1 месяц к этой дате, интервал месяца увеличивается, так что теперь у нас есть 2014-02-31. Затем проверяется номер дня, больше ли он последнего действительного дня нового месяца; если это так (как в случае выше), номер дня корректируется до последнего действительного дня (28). Каковы последствия этого подхода? Продолжайте и добавьте еще один месяц к нашей дате, &lt;code&gt;2014-02-28 + Month(1) == 2014-03-28&lt;/code&gt; , Какой? Вы ждали последнего дня марта? Неа, извините, вспомните про слоты 7-7-7. Будет изменено как можно меньше интервалов, поэтому мы сначала увеличиваем интервал месяца на 1, 2014-03-28, и бум, мы закончили, потому что это действительная дата. С другой стороны, если бы мы добавили 2 месяца к нашей исходной дате, 2014-01-31, то, как и ожидалось, мы получили бы 2014-03-31. Другим ответвлением этого подхода является потеря ассоциативности, когда конкретное упорядочивание принудительно (т.е. добавление вещей в разных порядках приводит к разным результатам). Например:</target>
        </trans-unit>
        <trans-unit id="11ea30dca65a438cc99f25502ce5c85d174da718" translate="yes" xml:space="preserve">
          <source>Now let us call a Julia function that performs an in-place operation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">Теперь позвольте нам вызвать функцию Julia, которая выполняет операцию на месте над &lt;code&gt;x&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1b1490ef0eb4ce2e4e1ae0d6c5f4d04bddc62f73" translate="yes" xml:space="preserve">
          <source>Now let's compare three different versions, one that runs in a single process:</source>
          <target state="translated">Теперь давайте сравним три разные версии,одна из которых работает в одном процессе:</target>
        </trans-unit>
        <trans-unit id="bd4926e8c07582ea5f2f0956525f2f77d29572cb" translate="yes" xml:space="preserve">
          <source>Now that you know the rules, let's look at some examples. Each example is assumed to be evaluated in a fresh REPL session so that the only globals in each snippet are the ones that are assigned in that block of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e900fad91950a54e7a71c41febff0c0a6fca83" translate="yes" xml:space="preserve">
          <source>Now the build command is simply &lt;code&gt;make&lt;/code&gt;.</source>
          <target state="translated">Теперь команда сборки просто &lt;code&gt;make&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c8889e683ee7699980eb83ade02cdbbcf851154" translate="yes" xml:space="preserve">
          <source>Now the content of &lt;code&gt;y&lt;/code&gt; can be accessed as before using &lt;code&gt;jl_array_data&lt;/code&gt;. As always, be sure to keep a reference to the array while it is in use.</source>
          <target state="translated">Теперь доступ к содержимому &lt;code&gt;y&lt;/code&gt; можно получить, как и раньше, с помощью &lt;code&gt;jl_array_data&lt;/code&gt; . Как всегда, не забудьте сохранить ссылку на массив, пока он используется.</target>
        </trans-unit>
        <trans-unit id="57cfaa73ec119cde1094487639ea3b5c37a52882" translate="yes" xml:space="preserve">
          <source>Now things get interesting. &lt;code&gt;OurRational&lt;/code&gt; has a single inner constructor method which checks that both of &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;den&lt;/code&gt; aren't zero and ensures that every rational is constructed in &quot;lowest terms&quot; with a non-negative denominator. This is accomplished by dividing the given numerator and denominator values by their greatest common divisor, computed using the &lt;code&gt;gcd&lt;/code&gt; function. Since &lt;code&gt;gcd&lt;/code&gt; returns the greatest common divisor of its arguments with sign matching the first argument (&lt;code&gt;den&lt;/code&gt; here), after this division the new value of &lt;code&gt;den&lt;/code&gt; is guaranteed to be non-negative. Because this is the only inner constructor for &lt;code&gt;OurRational&lt;/code&gt;, we can be certain that &lt;code&gt;OurRational&lt;/code&gt; objects are always constructed in this normalized form.</source>
          <target state="translated">Теперь все становится интересно. &lt;code&gt;OurRational&lt;/code&gt; имеет единственный внутренний метод-конструктор, который проверяет, что оба числа &lt;code&gt;num&lt;/code&gt; и &lt;code&gt;den&lt;/code&gt; не равны нулю, и гарантирует, что каждое рациональное число построено в &amp;laquo;наименьших значениях&amp;raquo; с неотрицательным знаменателем. Это достигается путем деления заданных значений числителя и знаменателя на их наибольший общий делитель, вычисленный с помощью функции &lt;code&gt;gcd&lt;/code&gt; . Поскольку &lt;code&gt;gcd&lt;/code&gt; возвращает наибольший общий делитель своих аргументов со знаком, соответствующим первому аргументу ( здесь &lt;code&gt;den&lt;/code&gt; ), после этого деления новое значение &lt;code&gt;den&lt;/code&gt; гарантированно будет неотрицательным. Потому что это единственный внутренний конструктор для &lt;code&gt;OurRational&lt;/code&gt; , мы можем быть уверены, что объекты &lt;code&gt;OurRational&lt;/code&gt; всегда строятся в этой нормализованной форме.</target>
        </trans-unit>
        <trans-unit id="7b1ac0d5470c2a73e8cced73d80392647d1e7c34" translate="yes" xml:space="preserve">
          <source>Now we add some new methods to &lt;code&gt;f(x)&lt;/code&gt;:</source>
          <target state="translated">Теперь мы добавляем несколько новых методов в &lt;code&gt;f(x)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2194482dd2eece4f043c167b6dbcda9beed128b2" translate="yes" xml:space="preserve">
          <source>Now we can fill the array:</source>
          <target state="translated">Теперь мы можем заполнить массив:</target>
        </trans-unit>
        <trans-unit id="dedd2e54cefbc13f3e2721f321d1470bf85ad17e" translate="yes" xml:space="preserve">
          <source>Now we can go back to the Julia REPL and load the package:</source>
          <target state="translated">Теперь мы можем вернуться к Julia REPL и загрузить пакет:</target>
        </trans-unit>
        <trans-unit id="8c5d4cd8d7eaa41a61a84bdaaaa49e76aabe6887" translate="yes" xml:space="preserve">
          <source>Now we will time each of these functions using the same random &lt;code&gt;10000&lt;/code&gt; by &lt;code&gt;1&lt;/code&gt; input vector:</source>
          <target state="translated">Теперь мы будем синхронизировать каждую из этих функций, используя одинаковые случайные &lt;code&gt;10000&lt;/code&gt; на &lt;code&gt;1&lt;/code&gt; входной вектор:</target>
        </trans-unit>
        <trans-unit id="f4a2c37f0e6c8ad902d4b308d7bdc8bae7e4b278" translate="yes" xml:space="preserve">
          <source>Now we're ready to profile this function:</source>
          <target state="translated">Теперь мы готовы профилировать эту функцию:</target>
        </trans-unit>
        <trans-unit id="e180693c6ce8b7b630dbe4c747b6eac35d812d82" translate="yes" xml:space="preserve">
          <source>Now you have a multitude of ways to employ those tools! For example with &lt;code&gt;OProfile&lt;/code&gt; you can try a simple recording :</source>
          <target state="translated">Теперь у вас есть множество способов использовать эти инструменты! Например, с &lt;code&gt;OProfile&lt;/code&gt; вы можете попробовать простую запись:</target>
        </trans-unit>
        <trans-unit id="97ad9c62852c43e82e47fc64421d617168397764" translate="yes" xml:space="preserve">
          <source>Now, consider a slightly more complex macro:</source>
          <target state="translated">Теперь рассмотрим немного более сложный макрос:</target>
        </trans-unit>
        <trans-unit id="48984640e1b770182f7f589e3d658df61fc570eb" translate="yes" xml:space="preserve">
          <source>Now, one very good way to solve such problems is by using the &lt;a href=&quot;#kernel-functions&quot;&gt;function-barrier technique&lt;/a&gt;. However, in some cases you might want to eliminate the type-instability altogether. In such cases, one approach is to pass the dimensionality as a parameter, for example through &lt;code&gt;Val{T}()&lt;/code&gt; (see &quot;Value types&quot;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4732b371dc166e4779a2688d805a6aba6fbd8acb" translate="yes" xml:space="preserve">
          <source>Now, one very good way to solve such problems is by using the &lt;a href=&quot;#kernel-functions-1&quot;&gt;function-barrier technique&lt;/a&gt;. However, in some cases you might want to eliminate the type-instability altogether. In such cases, one approach is to pass the dimensionality as a parameter, for example through &lt;code&gt;Val{T}()&lt;/code&gt; (see &quot;Value types&quot;):</source>
          <target state="translated">Один очень хороший способ решить такие проблемы - использовать &lt;a href=&quot;#kernel-functions-1&quot;&gt;технику функционального барьера&lt;/a&gt; . Однако в некоторых случаях вам может потребоваться полностью устранить нестабильность типов. В таких случаях один из подходов - передать размерность в качестве параметра, например, через &lt;code&gt;Val{T}()&lt;/code&gt; (см. &amp;laquo;Типы значений&amp;raquo;):</target>
        </trans-unit>
        <trans-unit id="6504cb22c421f4ddf0b407eb1bc7db394b17968b" translate="yes" xml:space="preserve">
          <source>Now, suppose that we have a 1-d array &lt;code&gt;A&lt;/code&gt; of values in Julia that we want to sort using the &lt;code&gt;qsort&lt;/code&gt; function (rather than Julia's built-in &lt;code&gt;sort&lt;/code&gt; function). Before we consider calling &lt;code&gt;qsort&lt;/code&gt; and passing arguments, we need to write a comparison function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21f06871f5b7030283f5fa9adc372a9eca6b71e0" translate="yes" xml:space="preserve">
          <source>Now, when we ask Julia to &lt;code&gt;collect&lt;/code&gt; all the elements into an array it can preallocate a &lt;code&gt;Vector{Int}&lt;/code&gt; of the right size instead of blindly &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt;ing each element into a &lt;code&gt;Vector{Any}&lt;/code&gt;:</source>
          <target state="translated">Теперь, когда мы просим Джулию &lt;code&gt;collect&lt;/code&gt; все элементы в массив, она может предварительно выделить &lt;code&gt;Vector{Int}&lt;/code&gt; нужного размера вместо того, чтобы вслепую &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt;вставка каждого элемента в &lt;code&gt;Vector{Any}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d636f6dac8ab2c27d31703e43f4beef4b1d56310" translate="yes" xml:space="preserve">
          <source>Number of bits</source>
          <target state="translated">Количество бит</target>
        </trans-unit>
        <trans-unit id="d91909ed1368e10bc84773d139187c5b722b5f11" translate="yes" xml:space="preserve">
          <source>Number of elements</source>
          <target state="translated">Количество элементов</target>
        </trans-unit>
        <trans-unit id="a9fc237be2cc9c335682ad011ee2e6adc0acaa38" translate="yes" xml:space="preserve">
          <source>Number of indices</source>
          <target state="translated">Количество индексов</target>
        </trans-unit>
        <trans-unit id="f85da1dd5129fe724d5c6d8cf4b7906fe8b9ce5c" translate="yes" xml:space="preserve">
          <source>Number of ones in the binary representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Количество единиц в двоичном представлении &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e30f19e99bb31f0cd0b6205f5f10b8b22424243a" translate="yes" xml:space="preserve">
          <source>Number of ones leading the binary representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Количество единиц в двоичном представлении &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="035d70cdae066ea3296b8fbd1a9d8c92fa39c6e4" translate="yes" xml:space="preserve">
          <source>Number of ones trailing the binary representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Количество единиц после двоичного представления &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0f8c6eb690602177ade028609fa24bb9574fa5a" translate="yes" xml:space="preserve">
          <source>Number of zeros in the binary representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Количество нулей в двоичном представлении &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8579d9f6447af083975c0dab9070490c43548e77" translate="yes" xml:space="preserve">
          <source>Number of zeros leading the binary representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Количество нулей в двоичном представлении &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8260cb1716ffd3b4779fd5a8ebf394508c0f77f9" translate="yes" xml:space="preserve">
          <source>Number of zeros trailing the binary representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Количество нулей в двоичном представлении &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28e471b5b867e86ef185edcc27daa9110d23a890" translate="yes" xml:space="preserve">
          <source>Number type representing an exact irrational value denoted by the symbol &lt;code&gt;sym&lt;/code&gt;.</source>
          <target state="translated">Числовой тип, представляющий точное иррациональное значение, обозначается символом &lt;code&gt;sym&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa5da0a005eba7aae00bc09dde0c276025c12077" translate="yes" xml:space="preserve">
          <source>Number type representing an exact irrational value, which is automatically rounded to the correct precision in arithmetic operations with other numeric quantities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9fe47bf2edbb12c61a5e953edc8a563d56b03f2" translate="yes" xml:space="preserve">
          <source>Number type representing an exact irrational value.</source>
          <target state="translated">Тип числа,представляющий собой точное иррациональное значение.</target>
        </trans-unit>
        <trans-unit id="1bd59bcc0babee970cc108b465cace01d488a590" translate="yes" xml:space="preserve">
          <source>Numbered capture groups can also be referenced as &lt;code&gt;\g&amp;lt;n&amp;gt;&lt;/code&gt; for disambiguation, as in:</source>
          <target state="translated">Нумерованные группы захвата также могут обозначаться как &lt;code&gt;\g&amp;lt;n&amp;gt;&lt;/code&gt; для устранения неоднозначности, например:</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="dbf34012797cab9d1c84ad002d9b7fc6caeff4db" translate="yes" xml:space="preserve">
          <source>Numerator of the rational representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Числитель рационального представления &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f269beab01cd6fcbe0ca0957b8e26bbc71c51503" translate="yes" xml:space="preserve">
          <source>Numeric Comparisons</source>
          <target state="translated">численные сравнения</target>
        </trans-unit>
        <trans-unit id="2daff25d81f34cfefe8596ae71656e7ff1f338f4" translate="yes" xml:space="preserve">
          <source>Numeric Literal Coefficients</source>
          <target state="translated">Числовые буквенные коэффициенты</target>
        </trans-unit>
        <trans-unit id="39da4e1b4b9cefed18b0fa29568809b13a0d2a02" translate="yes" xml:space="preserve">
          <source>Numeric literals also work as coefficients to parenthesized expressions:</source>
          <target state="translated">Числовые литералы также работают в качестве коэффициентов к выражениям в скобках:</target>
        </trans-unit>
        <trans-unit id="96a577a413493fbb35d59ebbc8fd8ccf1b95bd62" translate="yes" xml:space="preserve">
          <source>Numeric month with a minimum width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7bba39c17a5546a2869dc25f44284097be19715" translate="yes" xml:space="preserve">
          <source>Numeric year with a fixed width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f856346ac1bcf4a72d2933fe28689ea60a5e0a43" translate="yes" xml:space="preserve">
          <source>Numeric year with a minimum width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d5eae4bb697e0cf7a429c34af1a89533647ce7" translate="yes" xml:space="preserve">
          <source>Numerical Conversions</source>
          <target state="translated">численные преобразования</target>
        </trans-unit>
        <trans-unit id="67318deb09e2a0233296c2abeb6ce49da2c728ec" translate="yes" xml:space="preserve">
          <source>Numero Sign / Numero</source>
          <target state="translated">Номер подписи/Номер</target>
        </trans-unit>
        <trans-unit id="8005cd0fe11a7ac4eb3676a4ba6c81565fe4a74a" translate="yes" xml:space="preserve">
          <source>Nut And Bolt</source>
          <target state="translated">Орех и Вольт</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="93a1ab27a3b22e4b47afb67c1ce3d45df066fb66" translate="yes" xml:space="preserve">
          <source>Objects are printed at the REPL using the &lt;code&gt;show&lt;/code&gt; function with a specific &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt;. In particular, the &lt;code&gt;:limit&lt;/code&gt; attribute is set to &lt;code&gt;true&lt;/code&gt;. Other attributes can receive in certain &lt;code&gt;show&lt;/code&gt; methods a default value if it's not already set, like &lt;code&gt;:compact&lt;/code&gt;. It's possible, as an experimental feature, to specify the attributes used by the REPL via the &lt;code&gt;Base.active_repl.options.iocontext&lt;/code&gt; dictionary (associating values to attributes). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556a4054d8bd5ec84efc369a4b546d910bc81a6b" translate="yes" xml:space="preserve">
          <source>Objects created by calling &lt;code&gt;skipmissing&lt;/code&gt; on an array can be indexed using indices from the parent array. Indices corresponding to missing values are not valid for these objects and an error is thrown when trying to use them (they are also skipped by &lt;code&gt;keys&lt;/code&gt; and &lt;code&gt;eachindex&lt;/code&gt;)</source>
          <target state="translated">Объекты, созданные вызовом &lt;code&gt;skipmissing&lt;/code&gt; в массиве, могут быть проиндексированы с использованием индексов из родительского массива. Индексы, соответствующие отсутствующим значениям, недействительны для этих объектов, и при попытке их использования &lt;code&gt;eachindex&lt;/code&gt; ошибка (они также пропускаются &lt;code&gt;keys&lt;/code&gt; и eachindex )</target>
        </trans-unit>
        <trans-unit id="0bd56de9465fbf7f137d6e37169c5645c43a0700" translate="yes" xml:space="preserve">
          <source>Objects referred to by remote references can be freed only when &lt;em&gt;all&lt;/em&gt; held references in the cluster are deleted.</source>
          <target state="translated">Объекты, на которые ссылаются удаленные ссылки, могут быть освобождены только после удаления &lt;em&gt;всех&lt;/em&gt; удерживаемых ссылок в кластере.</target>
        </trans-unit>
        <trans-unit id="8ed0dbb8b43412ba667073b4f0e06db426a942a6" translate="yes" xml:space="preserve">
          <source>Oblique Angle Opening Down</source>
          <target state="translated">Окольный угол открытия вниз</target>
        </trans-unit>
        <trans-unit id="860d5d210e89bd48c50cf3489fe9ae16e754805a" translate="yes" xml:space="preserve">
          <source>Oblique Angle Opening Up</source>
          <target state="translated">Открытие под косым углом</target>
        </trans-unit>
        <trans-unit id="e48da80ca4c53858a37fe7a1f6c71c784aca6c04" translate="yes" xml:space="preserve">
          <source>Observe the following specific instances of these rules in our example:</source>
          <target state="translated">Соблюдайте следующие конкретные примеры этих правил в нашем примере:</target>
        </trans-unit>
        <trans-unit id="8a73a94f9cbd7863f359e15c75973f71824c00fb" translate="yes" xml:space="preserve">
          <source>Observe, that this definition calls another method of &lt;code&gt;Date&lt;/code&gt; function that takes one argument of &lt;code&gt;UTInstant{Day}&lt;/code&gt; type.</source>
          <target state="translated">Обратите внимание, что это определение вызывает другой метод функции &lt;code&gt;Date&lt;/code&gt; , который принимает один аргумент типа &lt;code&gt;UTInstant{Day}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b01fccba9afe7b3a5889d5a451ef90eca8e87545" translate="yes" xml:space="preserve">
          <source>Observe, that this definition calls another method of the &lt;code&gt;Date&lt;/code&gt; function that takes one argument of type &lt;code&gt;UTInstant{Day}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395a4e1c3075ee49f92be819610b463cda6e30f5" translate="yes" xml:space="preserve">
          <source>Observing any mutable state.</source>
          <target state="translated">Наблюдая за любым изменчивым состоянием.</target>
        </trans-unit>
        <trans-unit id="9fefcd102a7e155e0fdf1ae0996358a339e34548" translate="yes" xml:space="preserve">
          <source>Obtain a pointer to a global variable in a C-exported shared library, specified exactly as in &lt;a href=&quot;#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;. Returns a &lt;code&gt;Ptr{Type}&lt;/code&gt;, defaulting to &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; if no &lt;code&gt;Type&lt;/code&gt; argument is supplied. The values can be read or written by &lt;a href=&quot;#Base.unsafe_load&quot;&gt;&lt;code&gt;unsafe_load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.unsafe_store!&quot;&gt;&lt;code&gt;unsafe_store!&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">Получите указатель на глобальную переменную в совместно используемой библиотеке, экспортируемой на C, заданную точно так же, как в &lt;a href=&quot;#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; . Возвращает &lt;code&gt;Ptr{Type}&lt;/code&gt; , по &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; если аргумент &lt;code&gt;Type&lt;/code&gt; не указан. Значения могут быть прочитаны или записаны с помощью &lt;a href=&quot;#Base.unsafe_load&quot;&gt; &lt;code&gt;unsafe_load&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#Base.unsafe_store!&quot;&gt; &lt;code&gt;unsafe_store!&lt;/code&gt; &lt;/a&gt;соответственно.</target>
        </trans-unit>
        <trans-unit id="af546b114320fe8198ff3e12bb225650fba5d32f" translate="yes" xml:space="preserve">
          <source>Obtain a vector-like object containing the code units of a string. Returns a &lt;code&gt;CodeUnits&lt;/code&gt; wrapper by default, but &lt;code&gt;codeunits&lt;/code&gt; may optionally be defined for new string types if necessary.</source>
          <target state="translated">Получите векторный объект, содержащий кодовые единицы строки. Возвращает &lt;code&gt;CodeUnits&lt;/code&gt; обертки по умолчанию, но &lt;code&gt;codeunits&lt;/code&gt; необязательно может быть определена для новых типов строк , если это необходимо.</target>
        </trans-unit>
        <trans-unit id="4841adee9120f8d2d8a65cdf75b380276d57ffea" translate="yes" xml:space="preserve">
          <source>Obtain the contents of an &lt;code&gt;IOBuffer&lt;/code&gt; as an array, without copying. Afterwards, the &lt;code&gt;IOBuffer&lt;/code&gt; is reset to its initial state.</source>
          <target state="translated">Получить содержимое &lt;code&gt;IOBuffer&lt;/code&gt; в виде массива без копирования. После этого &lt;code&gt;IOBuffer&lt;/code&gt; возвращается в исходное состояние.</target>
        </trans-unit>
        <trans-unit id="499a51c422bbaa71f462d60ecac6f2d85b8b0346" translate="yes" xml:space="preserve">
          <source>Obtain the path of a temporary directory (possibly shared with other processes).</source>
          <target state="translated">Получить путь к временной директории (возможно,совместно с другими процессами).</target>
        </trans-unit>
        <trans-unit id="4489831ce34c02ca381337736e9c9e00ae27d366" translate="yes" xml:space="preserve">
          <source>Obtain the raw bytes of the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; as a vector of length 20.</source>
          <target state="translated">Получите необработанные байты &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; как вектор длиной 20.</target>
        </trans-unit>
        <trans-unit id="7f2ec1740404502e15faeec6b56d86fabcab7ff3" translate="yes" xml:space="preserve">
          <source>Obviously the intention is to modify the existing global variable &lt;code&gt;s&lt;/code&gt;. What else could it mean? However, not all real world code is so short or so clear. We found that code like the following often occurs in the wild:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6c798b8d29e94d3a8c1ad40f4212ec50bc5a9a" translate="yes" xml:space="preserve">
          <source>Occasionally it is useful to introduce a generic function without yet adding methods. This can be used to separate interface definitions from implementations. It might also be done for the purpose of documentation or code readability. The syntax for this is an empty &lt;code&gt;function&lt;/code&gt; block without a tuple of arguments:</source>
          <target state="translated">Иногда бывает полезно ввести универсальную функцию без добавления методов. Это можно использовать для отделения определений интерфейса от реализаций. Это также может быть сделано для документации или читабельности кода. Синтаксис для этого - пустой &lt;code&gt;function&lt;/code&gt; блок без кортежа аргументов:</target>
        </trans-unit>
        <trans-unit id="97d43ad70625a66b6b94ccb7dc102bc0d4e9d113" translate="yes" xml:space="preserve">
          <source>Occasionally you might want a remotely-computed value immediately. This typically happens when you read from a remote object to obtain data needed by the next local operation. The function &lt;code&gt;remotecall_fetch&lt;/code&gt; exists for this purpose. It is equivalent to &lt;code&gt;fetch(remotecall(...))&lt;/code&gt; but is more efficient.</source>
          <target state="translated">Иногда вам может понадобиться немедленно вычислить удаленное значение. Обычно это происходит, когда вы читаете с удаленного объекта, чтобы получить данные, необходимые для следующей локальной операции. Для &lt;code&gt;remotecall_fetch&lt;/code&gt; существует функция remotecall_fetch . Он эквивалентен &lt;code&gt;fetch(remotecall(...))&lt;/code&gt; но более эффективен.</target>
        </trans-unit>
        <trans-unit id="dc514d9dce6f845463dfbbd8fec27b149487fc06" translate="yes" xml:space="preserve">
          <source>Octal bytes (&lt;code&gt;\&lt;/code&gt; with 1-3 trailing octal digits)</source>
          <target state="translated">Восьмеричные байты ( &lt;code&gt;\&lt;/code&gt; с 1-3 восьмеричными цифрами в конце)</target>
        </trans-unit>
        <trans-unit id="c10a60e4dac35159da0056b94059aa3faefeaefe" translate="yes" xml:space="preserve">
          <source>Octopus</source>
          <target state="translated">Octopus</target>
        </trans-unit>
        <trans-unit id="d9359b5c701400516289c8d3362bab9584e8cb81" translate="yes" xml:space="preserve">
          <source>Oden</source>
          <target state="translated">Oden</target>
        </trans-unit>
        <trans-unit id="4ee7b7b8b904fd04e80da6c64df0a8e87c0a1ba8" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;rand&lt;/code&gt; must also be defined on those types (i.e. &lt;code&gt;rand(::AbstractRNG, ::SamplerDie1)&lt;/code&gt; and &lt;code&gt;rand(::AbstractRNG, ::SamplerDieMany)&lt;/code&gt;).</source>
          <target state="translated">Конечно, &lt;code&gt;rand&lt;/code&gt; также должен быть определен для этих типов (то есть &lt;code&gt;rand(::AbstractRNG, ::SamplerDie1)&lt;/code&gt; и &lt;code&gt;rand(::AbstractRNG, ::SamplerDieMany)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9135bc9aed14b8eb1de1f8f45ce9be4516707837" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;rand&lt;/code&gt; must also be defined on those types (i.e. &lt;code&gt;rand(::AbstractRNG, ::SamplerDie1)&lt;/code&gt; and &lt;code&gt;rand(::AbstractRNG, ::SamplerDieMany)&lt;/code&gt;). Note that, as usual, &lt;code&gt;SamplerTrivial&lt;/code&gt; and &lt;code&gt;SamplerSimple&lt;/code&gt; can be used if custom types are not necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5457388ab13abcc6abec066af3e04c777b0d8df3" translate="yes" xml:space="preserve">
          <source>Of course, a large amount of complexity is hidden in the functions used in this macro definition, but they are just functions, written entirely in Julia. You can read their source and see precisely what they do &amp;ndash; and all they do is construct expression objects to be inserted into your program's syntax tree.</source>
          <target state="translated">Конечно, в функциях, используемых в этом определении макроса, кроется большая сложность, но это просто функции, полностью написанные на Julia. Вы можете прочитать их исходный код и точно увидеть, что они делают - и все, что они делают, это конструируют объекты выражений, которые вставляются в синтаксическое дерево вашей программы.</target>
        </trans-unit>
        <trans-unit id="72d7295c70e56e8466ad32c5214d78627a9bd51e" translate="yes" xml:space="preserve">
          <source>Of course, all of this is true only if we construct &lt;code&gt;m&lt;/code&gt; with a concrete type. We can break this by explicitly constructing it with an abstract type:</source>
          <target state="translated">Конечно, все это верно, только если мы построим &lt;code&gt;m&lt;/code&gt; с конкретным типом. Мы можем нарушить это, явно построив его с помощью абстрактного типа:</target>
        </trans-unit>
        <trans-unit id="abca40c2892b53eaf0d0eec2e63897278688a5d5" translate="yes" xml:space="preserve">
          <source>Of course, in a purely linear function body like &lt;code&gt;g&lt;/code&gt;, the usage of &lt;code&gt;return&lt;/code&gt; is pointless since the expression &lt;code&gt;x + y&lt;/code&gt; is never evaluated and we could simply make &lt;code&gt;x * y&lt;/code&gt; the last expression in the function and omit the &lt;code&gt;return&lt;/code&gt;. In conjunction with other control flow, however, &lt;code&gt;return&lt;/code&gt; is of real use. Here, for example, is a function that computes the hypotenuse length of a right triangle with sides of length &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, avoiding overflow:</source>
          <target state="translated">Конечно, в чисто линейном теле функции, таком как &lt;code&gt;g&lt;/code&gt; , использование &lt;code&gt;return&lt;/code&gt; бессмысленно, поскольку выражение &lt;code&gt;x + y&lt;/code&gt; никогда не вычисляется, и мы могли бы просто сделать &lt;code&gt;x * y&lt;/code&gt; последним выражением в функции и опустить &lt;code&gt;return&lt;/code&gt; . Однако в сочетании с другим потоком управления &lt;code&gt;return&lt;/code&gt; имеет реальное значение. Вот, например, функция, которая вычисляет длину гипотенузы прямоугольного треугольника со сторонами длиной &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , избегая переполнения:</target>
        </trans-unit>
        <trans-unit id="c060c4ee5f5d3d9b28299a96d5d24b90afefae70" translate="yes" xml:space="preserve">
          <source>Of course, this depends on what &lt;code&gt;Int&lt;/code&gt; is aliased to &amp;ndash; but that is predefined to be the correct type &amp;ndash; either &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Конечно, это зависит от псевдонима &lt;code&gt;Int&lt;/code&gt; , но это предопределено как правильный тип - &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07abc77a1d3a227491552ba08254221470ef23ea" translate="yes" xml:space="preserve">
          <source>Of course, this pattern is so frequent that the helper type used above, namely &lt;code&gt;Random.SamplerSimple&lt;/code&gt;, is available, saving us the definition of &lt;code&gt;SamplerDie&lt;/code&gt;: we could have implemented our decoupling with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae308f41e4c98e31757bbb87283a37f1c3cd968" translate="yes" xml:space="preserve">
          <source>Of course, you can omit the dot if you write a specialized &quot;vector&quot; method of &lt;code&gt;f&lt;/code&gt;, e.g. via &lt;code&gt;f(A::AbstractArray) = map(f, A)&lt;/code&gt;, and this is just as efficient as &lt;code&gt;f.(A)&lt;/code&gt;. But that approach requires you to decide in advance which functions you want to vectorize.</source>
          <target state="translated">Конечно, вы можете опустить точку, если вы напишете специальный &quot;векторный&quot; метод &lt;code&gt;f&lt;/code&gt; , например, через &lt;code&gt;f(A::AbstractArray) = map(f, A)&lt;/code&gt; , и это так же эффективно, как &lt;code&gt;f.(A)&lt;/code&gt; . Но этот подход требует, чтобы вы заранее решили, какие функции вы хотите векторизовать.</target>
        </trans-unit>
        <trans-unit id="831dc22cfdc3471ccd19f00c0d2e0d9502fd0034" translate="yes" xml:space="preserve">
          <source>Of course, you can omit the dot if you write a specialized &quot;vector&quot; method of &lt;code&gt;f&lt;/code&gt;, e.g. via &lt;code&gt;f(A::AbstractArray) = map(f, A)&lt;/code&gt;, and this is just as efficient as &lt;code&gt;f.(A)&lt;/code&gt;. The advantage of the &lt;code&gt;f.(A)&lt;/code&gt; syntax is that which functions are vectorizable need not be decided upon in advance by the library writer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac1685b0fe25dd08856d4b861606712fb6d3693" translate="yes" xml:space="preserve">
          <source>Office Building</source>
          <target state="translated">офисное здание</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="2257e26e0c9b9059b11804e45de12c297441ab86" translate="yes" xml:space="preserve">
          <source>Often &lt;code&gt;wait&lt;/code&gt; is called within a &lt;code&gt;while&lt;/code&gt; loop to ensure a waited-for condition is met before proceeding.</source>
          <target state="translated">Часто &lt;code&gt;wait&lt;/code&gt; называется в &lt;code&gt;while&lt;/code&gt; петли , чтобы обеспечить подождал-за состояния выполняется перед началом работы.</target>
        </trans-unit>
        <trans-unit id="e3d60820a16fa72bfa32371eae9edc7f3327dc98" translate="yes" xml:space="preserve">
          <source>Often referred to as logical indexing or indexing with a logical mask, indexing by a boolean array selects elements at the indices where its values are &lt;code&gt;true&lt;/code&gt;. Indexing by a boolean vector &lt;code&gt;B&lt;/code&gt; is effectively the same as indexing by the vector of integers that is returned by &lt;code&gt;findall(B)&lt;/code&gt;. Similarly, indexing by a &lt;code&gt;N&lt;/code&gt;-dimensional boolean array is effectively the same as indexing by the vector of &lt;code&gt;CartesianIndex{N}&lt;/code&gt;s where its values are &lt;code&gt;true&lt;/code&gt;. A logical index must be a vector of the same length as the dimension it indexes into, or it must be the only index provided and match the size and dimensionality of the array it indexes into. It is generally more efficient to use boolean arrays as indices directly instead of first calling &lt;code&gt;findall&lt;/code&gt;.</source>
          <target state="translated">Индексирование с помощью логического массива, которое часто называют логическим индексированием или индексированием с помощью логической маски, выбирает элементы в индексах, где его значения &lt;code&gt;true&lt;/code&gt; . Индексирование по логическому вектору &lt;code&gt;B&lt;/code&gt; фактически то же самое, что индексирование по вектору целых чисел, возвращаемому &lt;code&gt;findall(B)&lt;/code&gt; . Точно так же индексирование &lt;code&gt;N&lt;/code&gt; - мерным логическим массивом фактически то же самое, что индексирование вектором &lt;code&gt;CartesianIndex{N}&lt;/code&gt; s, где его значения &lt;code&gt;true&lt;/code&gt; , Логический индекс должен быть вектором той же длины, что и измерение, в которое он индексируется, или он должен быть единственным предоставленным индексом и соответствовать размеру и размерности массива, в котором он индексируется. Как правило, более эффективно использовать логические массивы в качестве индексов напрямую вместо первого вызова &lt;code&gt;findall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edf1240e8d792d67e6dc46a33f81148bf56e1cc1" translate="yes" xml:space="preserve">
          <source>Often used as &lt;code&gt;setprecision(T, precision) do ... end&lt;/code&gt;</source>
          <target state="translated">Часто используется как &lt;code&gt;setprecision(T, precision) do ... end&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9fb34384bd74e18ded64446715a976c38fad361" translate="yes" xml:space="preserve">
          <source>Often, one wants to customize how instances of a type are displayed. This is accomplished by overloading the &lt;code&gt;show&lt;/code&gt; function. For example, suppose we define a type to represent complex numbers in polar form:</source>
          <target state="translated">Часто нужно настроить способ отображения экземпляров типа. Это достигается перегрузкой функции &lt;code&gt;show&lt;/code&gt; . Например, предположим, что мы определяем тип для представления комплексных чисел в полярной форме:</target>
        </trans-unit>
        <trans-unit id="2524666908366fb5b9cb1050fa0d98429c1b75dd" translate="yes" xml:space="preserve">
          <source>Ohm Sign / Ohm</source>
          <target state="translated">Ом знак/Ом</target>
        </trans-unit>
        <trans-unit id="43861169e81020d9c0306dfe1f07fadd4b506cc8" translate="yes" xml:space="preserve">
          <source>Ok Hand Sign</source>
          <target state="translated">Хороший знак</target>
        </trans-unit>
        <trans-unit id="9aeac8f5501f52ca5880e908db13ff62ecc66505" translate="yes" xml:space="preserve">
          <source>Older Man</source>
          <target state="translated">Старик</target>
        </trans-unit>
        <trans-unit id="493e473600aee0c7bcce465fd5f66ce4c04f4e72" translate="yes" xml:space="preserve">
          <source>Older Woman</source>
          <target state="translated">Старшая женщина</target>
        </trans-unit>
        <trans-unit id="f45cbb491b86714bd98c42e22c982d41684cdfce" translate="yes" xml:space="preserve">
          <source>Omitted and extra indices</source>
          <target state="translated">Пропущенные и дополнительные индексы</target>
        </trans-unit>
        <trans-unit id="bdd9f9feaf5acde15de18ad7f8bd40de4f1b782e" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures, &lt;a href=&quot;../../base/base/index#Core.typeof&quot;&gt;&lt;code&gt;typeof(ans)&lt;/code&gt;&lt;/a&gt; will be &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;. You can convert an integer value back to a &lt;code&gt;Char&lt;/code&gt; just as easily:</source>
          <target state="translated">На 32-битных архитектурах &lt;a href=&quot;../../base/base/index#Core.typeof&quot;&gt; &lt;code&gt;typeof(ans)&lt;/code&gt; &lt;/a&gt; будет &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; . Вы можете так же легко преобразовать целочисленное значение обратно в &lt;code&gt;Char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dd09e2bd2e91471e0bc628c7f284aa260673d9ee" translate="yes" xml:space="preserve">
          <source>On Linux systems, the TCP_QUICKACK is disabled or enabled on &lt;code&gt;socket&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6f162e1c6dd3fdf5b4b173fdf2b77540bc5038" translate="yes" xml:space="preserve">
          <source>On Soft Scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6339065c09aa2c526a5dbaab652f506bc74797" translate="yes" xml:space="preserve">
          <source>On Unix systems, replace a tilde character at the start of a path with the current user's home directory.</source>
          <target state="translated">На Unix-системах замените символ тильды в начале пути на домашний каталог текущего пользователя.</target>
        </trans-unit>
        <trans-unit id="bb1d6d9c207542f37a0eb9a4d30104dcffd38435" translate="yes" xml:space="preserve">
          <source>On Windows, split a path into the drive letter part and the path part. On Unix systems, the first component is always the empty string.</source>
          <target state="translated">В Windows разделите путь на букву диска и часть пути.В Unix-системах первым компонентом всегда является пустая строка.</target>
        </trans-unit>
        <trans-unit id="4c68460a13d1df8955c1f8bb29c597d386917eef" translate="yes" xml:space="preserve">
          <source>On Windows, this environment variable is ignored, and external commands are executed directly.</source>
          <target state="translated">На Windows эта переменная окружения игнорируется,а внешние команды выполняются напрямую.</target>
        </trans-unit>
        <trans-unit id="155eaef05899463a6426667bf84d001c6851f4ef" translate="yes" xml:space="preserve">
          <source>On Windows, this is a critical section object, on pthreads, this is a &lt;code&gt;pthread_mutex_t&lt;/code&gt;.</source>
          <target state="translated">В Windows это объект критического раздела, в pthreads это &lt;code&gt;pthread_mutex_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60dc73d26d92352d669b6b314c01d0e67b4f12bc" translate="yes" xml:space="preserve">
          <source>On With Exclamation Mark With Left Right Arrow Above</source>
          <target state="translated">На с восклицательным знаком с левой стрелкой вправо выше</target>
        </trans-unit>
        <trans-unit id="b47df2e0f9b94e375b78ff1379a3f11415ea9470" translate="yes" xml:space="preserve">
          <source>On a computer with a 2.4GHz Intel Core i5 processor, this produces:</source>
          <target state="translated">На компьютере с процессором Intel Core i5 2,4 ГГц,это производит:</target>
        </trans-unit>
        <trans-unit id="d6cc2cc0bff4a83bfe594a8a58bb2b33f6acda16" translate="yes" xml:space="preserve">
          <source>On a computer with a 2.7 GHz Intel Core i7 processor, this produces:</source>
          <target state="translated">На компьютере с процессором Intel Core i7 2,7 ГГц,это производит:</target>
        </trans-unit>
        <trans-unit id="0d05c50e4f9adbf55a00b2b6337dd680a4e8ea56" translate="yes" xml:space="preserve">
          <source>On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an &lt;code&gt;int&lt;/code&gt; in C is not the same as an &lt;code&gt;Int&lt;/code&gt; in Julia).</source>
          <target state="translated">Во всех поддерживаемых в настоящее время системах базовые типы значений C / C ++ можно преобразовать в типы Julia следующим образом. Каждому типу C соответствует соответствующий тип Julia с тем же именем и префиксом C. Это может помочь при написании переносимого кода (и помнить, что &lt;code&gt;int&lt;/code&gt; в C не то же самое, что &lt;code&gt;Int&lt;/code&gt; в Julia).</target>
        </trans-unit>
        <trans-unit id="bab9d1cbda261ee61dde55272f1af711e58d2855" translate="yes" xml:space="preserve">
          <source>On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C. This can help when writing portable code (and remembering that an &lt;code&gt;int&lt;/code&gt; in C is not the same as an &lt;code&gt;Int&lt;/code&gt; in Julia).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0381f586cce60e3ccff1893131fb730207dab27f" translate="yes" xml:space="preserve">
          <source>On the command line</source>
          <target state="translated">В командной строке</target>
        </trans-unit>
        <trans-unit id="587c20a5e51a65e62924cbe225a3fdc1498c623a" translate="yes" xml:space="preserve">
          <source>On the contrary, if one of the operands is &lt;code&gt;false&lt;/code&gt;, the result could be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; depending on the value of the other operand. Therefore, if that operand is &lt;code&gt;missing&lt;/code&gt;, the result has to be &lt;code&gt;missing&lt;/code&gt; too</source>
          <target state="translated">Напротив, если один из операндов &lt;code&gt;false&lt;/code&gt; , результат может быть либо &lt;code&gt;true&lt;/code&gt; либо &lt;code&gt;false&lt;/code&gt; зависимости от значения другого операнда. Поэтому, если этот операнд &lt;code&gt;missing&lt;/code&gt; , то результат должен быть не &lt;code&gt;missing&lt;/code&gt; слишком</target>
        </trans-unit>
        <trans-unit id="518a0d6b9d25183b82c9bf4eb99d6d93bfd19e36" translate="yes" xml:space="preserve">
          <source>On the first call (&lt;code&gt;@time sum_global()&lt;/code&gt;) the function gets compiled. (If you've not yet used &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt;&lt;code&gt;@time&lt;/code&gt;&lt;/a&gt; in this session, it will also compile functions needed for timing.) You should not take the results of this run seriously. For the second run, note that in addition to reporting the time, it also indicated that a significant amount of memory was allocated. We are here just computing a sum over all elements in a vector of 64-bit floats so there should be no need to allocate memory (at least not on the heap which is what &lt;code&gt;@time&lt;/code&gt; reports).</source>
          <target state="translated">При первом вызове ( &lt;code&gt;@time sum_global()&lt;/code&gt; ) функция компилируется. (Если вы еще не использовали &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt; &lt;code&gt;@time&lt;/code&gt; &lt;/a&gt; в этом сеансе, он также скомпилирует функции, необходимые для синхронизации.) Не следует серьезно относиться к результатам этого запуска. Для второго запуска обратите внимание, что помимо отчета о времени он также указал, что был выделен значительный объем памяти. Мы здесь просто вычисляем сумму по всем элементам в векторе 64-битных чисел с плавающей запятой, поэтому не должно быть необходимости выделять память (по крайней мере, не в куче, о чем сообщает &lt;code&gt;@time&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4ad03a446adb0683f0ee72ebe5c5d4de73ec2ee9" translate="yes" xml:space="preserve">
          <source>On the flip side, it is often handy to &quot;splat&quot; the values contained in an iterable collection into a function call as individual arguments. To do this, one also uses &lt;code&gt;...&lt;/code&gt; but in the function call instead:</source>
          <target state="translated">С другой стороны, часто бывает удобно &amp;laquo;вставить&amp;raquo; значения, содержащиеся в итерируемой коллекции, в вызов функции как отдельные аргументы. Для этого также используется &lt;code&gt;...&lt;/code&gt; но вместо этого в вызове функции:</target>
        </trans-unit>
        <trans-unit id="17b403ef50412b37149d7de8d64205fbc78be0d0" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; s are rewritable. For example, multiple processes can co-ordinate their processing by referencing the same remote &lt;code&gt;Channel&lt;/code&gt;.</source>
          <target state="translated">С другой стороны, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; можно перезаписывать. Например, несколько процессов могут координировать свою обработку, ссылаясь на один и тот же удаленный &lt;code&gt;Channel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63d9d088c9fae4ec91c2c4846a8d7718abfee493" translate="yes" xml:space="preserve">
          <source>On the other hand, any type of expression can be used at the end of a conditional chain. It will be evaluated and returned depending on the preceding conditionals:</source>
          <target state="translated">С другой стороны,в конце условной цепочки может быть использовано любое выражение.Оно будет оцениваться и возвращаться в зависимости от предыдущих условий:</target>
        </trans-unit>
        <trans-unit id="351c03433eb494876e9f9b819be4bdaa9e922583" translate="yes" xml:space="preserve">
          <source>On the other hand, language &lt;em&gt;interoperability&lt;/em&gt; is extremely useful: we want to exploit existing high-quality code in other languages from Julia (and vice versa)! The best way to enable this is not a transpiler, but rather via easy inter-language calling facilities. We have worked hard on this, from the built-in &lt;code&gt;ccall&lt;/code&gt; intrinsic (to call C and Fortran libraries) to &lt;a href=&quot;https://github.com/JuliaInterop&quot;&gt;JuliaInterop&lt;/a&gt; packages that connect Julia to Python, Matlab, C++, and more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02c05a8f3f1c4acb393f741faa4805c77971fea" translate="yes" xml:space="preserve">
          <source>On the other hand, missingness propagates when one of the operands is &lt;code&gt;true&lt;/code&gt;, for example the first one</source>
          <target state="translated">С другой стороны, отсутствие распространяется, когда один из операндов &lt;code&gt;true&lt;/code&gt; , например, первый.</target>
        </trans-unit>
        <trans-unit id="66752d66287e12266caf0e8fe423b26d0766c1cd" translate="yes" xml:space="preserve">
          <source>On the other hand, no error is thrown when the result can be determined without the &lt;code&gt;missing&lt;/code&gt; values. This is the case when the code short-circuits before evaluating the &lt;code&gt;missing&lt;/code&gt; operand, and when the &lt;code&gt;missing&lt;/code&gt; operand is the last one</source>
          <target state="translated">С другой стороны, ошибка не возникает, если результат может быть определен без &lt;code&gt;missing&lt;/code&gt; значений. Это тот случай, когда код замыкается перед оценкой &lt;code&gt;missing&lt;/code&gt; операнда, и когда &lt;code&gt;missing&lt;/code&gt; операнд является последним.</target>
        </trans-unit>
        <trans-unit id="66d783b202bcb5502d49204a4c1a17474d2de0ce" translate="yes" xml:space="preserve">
          <source>On the other hand, serializing a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; only involves the serialization of an identifier that identifies the location and instance of &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; referred to by the handle. A deserialized &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; object (on any worker), therefore also points to the same backing store as the original.</source>
          <target state="translated">С другой стороны, сериализация &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; включает только сериализацию идентификатора, который идентифицирует местоположение и экземпляр &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; ссылается дескриптор. Десериализованный &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; объект (на любого работника), следовательно , также указывает на то же резервное хранилище как оригинал.</target>
        </trans-unit>
        <trans-unit id="771a6039f4f4d3ec219eb1b8ab2a7b46116413f0" translate="yes" xml:space="preserve">
          <source>On the other hand, the &lt;em&gt;symbol&lt;/em&gt;&lt;code&gt;:b&lt;/code&gt; is used in the expression construction, so the value of the variable &lt;code&gt;b&lt;/code&gt; at that time is irrelevant &amp;ndash; &lt;code&gt;:b&lt;/code&gt; is just a symbol and the variable &lt;code&gt;b&lt;/code&gt; need not even be defined. At expression evaluation time, however, the value of the symbol &lt;code&gt;:b&lt;/code&gt; is resolved by looking up the value of the variable &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">С другой стороны, &lt;em&gt;символ &lt;/em&gt; &lt;code&gt;:b&lt;/code&gt; используется в конструкции выражения, поэтому значение переменной &lt;code&gt;b&lt;/code&gt; в это время не имеет значения - &lt;code&gt;:b&lt;/code&gt; - это просто символ, а переменную &lt;code&gt;b&lt;/code&gt; даже не нужно определять. Однако во время оценки выражения значение символа &lt;code&gt;:b&lt;/code&gt; определяется путем поиска значения переменной &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd495e4741a90baf6003c40c92c4aa3f0b4cd557" translate="yes" xml:space="preserve">
          <source>Once a variable is made visible via &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;, a module may not create its own variable with the same name. Imported variables are read-only; assigning to a global variable always affects a variable owned by the current module, or else raises an error.</source>
          <target state="translated">Когда переменная становится видимой с помощью &lt;code&gt;using&lt;/code&gt; или &lt;code&gt;import&lt;/code&gt; , модуль не может создавать свою собственную переменную с тем же именем. Импортированные переменные доступны только для чтения; присвоение глобальной переменной всегда влияет на переменную, принадлежащую текущему модулю, или вызывает ошибку.</target>
        </trans-unit>
        <trans-unit id="fbb4245dbb4242070beff681d151067e39a6f407" translate="yes" xml:space="preserve">
          <source>Once finalized, a reference becomes invalid and cannot be used in any further calls.</source>
          <target state="translated">После завершения работы ссылка становится недействительной и не может быть использована в дальнейших вызовах.</target>
        </trans-unit>
        <trans-unit id="153460770bc51983406d5b79bfce57e7867c875a" translate="yes" xml:space="preserve">
          <source>Once one learns to appreciate multiple dispatch, there's an understandable tendency to go overboard and try to use it for everything. For example, you might imagine using it to store information, e.g.</source>
          <target state="translated">Как только человек учится ценить многократную отправку,появляется вполне понятная тенденция перестараться и пытаться использовать ее для всего.Например,можно представить себе,как использовать его для хранения информации,например.</target>
        </trans-unit>
        <trans-unit id="c203638f9ad5d408088a4eef6ad04b4df41e5027" translate="yes" xml:space="preserve">
          <source>Oncoming Automobile</source>
          <target state="translated">Старый автомобиль</target>
        </trans-unit>
        <trans-unit id="61c05078278f8201b444547fd75a173fff4a3ad0" translate="yes" xml:space="preserve">
          <source>Oncoming Bus</source>
          <target state="translated">Возвращающийся автобус</target>
        </trans-unit>
        <trans-unit id="ddeaee107e2c4e76bf01661779970545629d3afd" translate="yes" xml:space="preserve">
          <source>Oncoming Police Car</source>
          <target state="translated">Грядущий полицейский автомобиль</target>
        </trans-unit>
        <trans-unit id="1f6e328b8fe4d57c863b1503f93724d6b14d7bf5" translate="yes" xml:space="preserve">
          <source>Oncoming Taxi</source>
          <target state="translated">Входящее такси</target>
        </trans-unit>
        <trans-unit id="10a5bbfdc49a80bbe793aee50ef76a76a7bc98ae" translate="yes" xml:space="preserve">
          <source>One alternative is to use a macro to capture &lt;a href=&quot;../../base/base/index#Base.@__MODULE__&quot;&gt;&lt;code&gt;@__MODULE__&lt;/code&gt;&lt;/a&gt; and store it alone with the current &lt;code&gt;counter&lt;/code&gt; value, however, it may be better to redesign the code to not depend on this global state.</source>
          <target state="translated">One alternative is to use a macro to capture &lt;a href=&quot;../../base/base/index#Base.@__MODULE__&quot;&gt; &lt;code&gt;@__MODULE__&lt;/code&gt; &lt;/a&gt; and store it alone with the current &lt;code&gt;counter&lt;/code&gt; value, however, it may be better to redesign the code to not depend on this global state.</target>
        </trans-unit>
        <trans-unit id="68452c858f7b1ccba1312252acfbe351a171f8df" translate="yes" xml:space="preserve">
          <source>One alternative to consider would be to check each integer operation for overflow and promote results to bigger integer types such as &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt;&lt;code&gt;Int128&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; in the case of overflow. Unfortunately, this introduces major overhead on every integer operation (think incrementing a loop counter) &amp;ndash; it requires emitting code to perform run-time overflow checks after arithmetic instructions and branches to handle potential overflows. Worse still, this would cause every computation involving integers to be type-unstable. As we mentioned above, &lt;a href=&quot;#man-type-stability&quot;&gt;type-stability is crucial&lt;/a&gt; for effective generation of efficient code. If you can't count on the results of integer operations being integers, it's impossible to generate fast, simple code the way C and Fortran compilers do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="319cbfa2cb6199265b8d88a5116ab6583eb207c7" translate="yes" xml:space="preserve">
          <source>One alternative to consider would be to check each integer operation for overflow and promote results to bigger integer types such as &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt;&lt;code&gt;Int128&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; in the case of overflow. Unfortunately, this introduces major overhead on every integer operation (think incrementing a loop counter) &amp;ndash; it requires emitting code to perform run-time overflow checks after arithmetic instructions and branches to handle potential overflows. Worse still, this would cause every computation involving integers to be type-unstable. As we mentioned above, &lt;a href=&quot;#man-type-stability-1&quot;&gt;type-stability is crucial&lt;/a&gt; for effective generation of efficient code. If you can't count on the results of integer operations being integers, it's impossible to generate fast, simple code the way C and Fortran compilers do.</source>
          <target state="translated">Одной из альтернатив, которую следует рассмотреть, может быть проверка каждой целочисленной операции на переполнение и продвижение результатов в более крупные целочисленные типы, такие как &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt; &lt;code&gt;Int128&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; в случае переполнения. К сожалению, это приводит к значительным накладным расходам для каждой целочисленной операции (подумайте об увеличении счетчика цикла) - для обработки возможных переполнений требуется выдача кода для выполнения проверок переполнения во время выполнения после арифметических инструкций и переходов. Что еще хуже, это приведет к тому, что каждое вычисление с целыми числами будет нестабильным по типу. Как мы упоминали выше, &lt;a href=&quot;#man-type-stability-1&quot;&gt;стабильность типов имеет решающее значение&lt;/a&gt; для эффективной генерации эффективного кода. Если вы не можете рассчитывать на то, что результаты целочисленных операций будут целыми числами, невозможно сгенерировать быстрый и простой код, как это делают компиляторы C и Fortran.</target>
        </trans-unit>
        <trans-unit id="87126a794e4c39ba4df13f6963f3107de93a4e22" translate="yes" xml:space="preserve">
          <source>One can also pass &lt;code&gt;key =&amp;gt; value&lt;/code&gt; expressions after a semicolon. For example, &lt;code&gt;plot(x, y; :width =&amp;gt; 2)&lt;/code&gt; is equivalent to &lt;code&gt;plot(x, y, width=2)&lt;/code&gt;. This is useful in situations where the keyword name is computed at runtime.</source>
          <target state="translated">Также можно передавать выражения &lt;code&gt;key =&amp;gt; value&lt;/code&gt; после точки с запятой. Например, &lt;code&gt;plot(x, y; :width =&amp;gt; 2)&lt;/code&gt; эквивалентен &lt;code&gt;plot(x, y, width=2)&lt;/code&gt; . Это полезно в ситуациях, когда имя ключевого слова вычисляется во время выполнения.</target>
        </trans-unit>
        <trans-unit id="02624e42b707c1de7f41e5350b4675b4c9d0f30a" translate="yes" xml:space="preserve">
          <source>One common mistake is to try and get the element-type by using introspection:</source>
          <target state="translated">Одной из распространенных ошибок является попытка получить элементированный тип с помощью интроспекции:</target>
        </trans-unit>
        <trans-unit id="6b006eab8378514a51041aafae3b9c6e3c4afb77" translate="yes" xml:space="preserve">
          <source>One consequence of federation is that there cannot be a central authority for package naming. Different entities may use the same name to refer to unrelated packages. This possibility is unavoidable since these entities do not coordinate and may not even know about each other. Because of the lack of a central naming authority, a single project may end up depending on different packages that have the same name. Julia's package loading mechanism does not require package names to be globally unique, even within the dependency graph of a single project. Instead, packages are identified by &lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;universally unique identifiers&lt;/a&gt; (UUIDs), which get assigned when each package is created. Usually you won't have to work directly with these somewhat cumbersome 128-bit identifiers since &lt;code&gt;Pkg&lt;/code&gt; will take care of generating and tracking them for you. However, these UUIDs provide the definitive answer to the question of &lt;em&gt;&quot;what package does &lt;code&gt;X&lt;/code&gt; refer to?&quot;&lt;/em&gt;</source>
          <target state="translated">Одним из следствий федерации является то, что не может быть центрального органа для именования пакетов. Различные объекты могут использовать одно и то же имя для обозначения несвязанных пакетов. Эта возможность неизбежна, поскольку эти сущности не координируют свои действия и могут даже не знать друг о друге. Из-за отсутствия централизованного центра именования один проект может завершиться в зависимости от разных пакетов с одинаковыми именами. Механизм загрузки пакетов Джулии не требует, чтобы имена пакетов были глобально уникальными, даже в пределах графа зависимостей одного проекта. Вместо этого пакеты идентифицируются &lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;универсальными уникальными идентификаторами&lt;/a&gt; (UUID), которые присваиваются при создании каждого пакета. Обычно вам не придется напрямую работать с этими несколько громоздкими 128-битными идентификаторами, поскольку &lt;code&gt;Pkg&lt;/code&gt; позаботится о создании и отслеживании их за вас. Однако эти UUID дают окончательный ответ на вопрос &lt;em&gt;&amp;laquo;на какой пакет ссылается &lt;code&gt;X&lt;/code&gt; ?&amp;raquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c776cd11f414b03738dd0416b0d39d2e16e1ed10" translate="yes" xml:space="preserve">
          <source>One dimensional &lt;a href=&quot;#Base.StridedArray&quot;&gt;&lt;code&gt;StridedArray&lt;/code&gt;&lt;/a&gt; with elements of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Одномерное &lt;a href=&quot;#Base.StridedArray&quot;&gt; &lt;code&gt;StridedArray&lt;/code&gt; &lt;/a&gt; с элементами типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4815d6606da01b20ef10c5c0e075447bfd75d6b1" translate="yes" xml:space="preserve">
          <source>One issue here is that if a function inherently requires integers, it might be better to force the caller to decide how non-integers should be converted (e.g. floor or ceiling). Another issue is that declaring more specific types leaves more &quot;space&quot; for future method definitions.</source>
          <target state="translated">Одна из проблем здесь заключается в том,что если функция по своей сути требует целых чисел,то,возможно,лучше заставить вызывающего абонента решить,как не входящие абоненты должны быть преобразованы (например,в пол или потолок).Другой вопрос заключается в том,что объявление более специфических типов оставляет больше &quot;пространства&quot; для будущих определений методов.</target>
        </trans-unit>
        <trans-unit id="ba07493d204a55c7202f5d3dbcd2c52e223ef48f" translate="yes" xml:space="preserve">
          <source>One may also access the underlying &lt;code&gt;UTInstant&lt;/code&gt; or integer value:</source>
          <target state="translated">Можно также получить доступ к базовому &lt;code&gt;UTInstant&lt;/code&gt; или целочисленному значению:</target>
        </trans-unit>
        <trans-unit id="bd0e415c6a547b8bbcaa1063befe52b13a2aa324" translate="yes" xml:space="preserve">
          <source>One note on parsing performance: using the &lt;code&gt;Date(date_string,format_string)&lt;/code&gt; function is fine if only called a few times. If there are many similarly formatted date strings to parse however, it is much more efficient to first create a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;Dates.DateFormat&lt;/code&gt;&lt;/a&gt;, and pass it instead of a raw format string.</source>
          <target state="translated">Одно замечание о производительности синтаксического анализа: использование функции &lt;code&gt;Date(date_string,format_string)&lt;/code&gt; нормально, если она вызывается несколько раз. Однако, если есть много строк даты в аналогичном формате для анализа, гораздо эффективнее сначала создать &lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;Dates.DateFormat&lt;/code&gt; &lt;/a&gt; и передать его вместо строки необработанного формата.</target>
        </trans-unit>
        <trans-unit id="9137ec2822fcee2353c1587235561d45cf358a22" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;HasLength()&lt;/code&gt;, &lt;code&gt;HasShape{N}()&lt;/code&gt;, &lt;code&gt;IsInfinite()&lt;/code&gt;, or &lt;code&gt;SizeUnknown()&lt;/code&gt; as appropriate</source>
          <target state="translated">Одно из &lt;code&gt;HasLength()&lt;/code&gt; , &lt;code&gt;HasShape{N}()&lt;/code&gt; , &lt;code&gt;IsInfinite()&lt;/code&gt; или &lt;code&gt;SizeUnknown()&lt;/code&gt; в зависимости от ситуации.</target>
        </trans-unit>
        <trans-unit id="436148adcb7ac2d18abd79ff00a2d087851952a3" translate="yes" xml:space="preserve">
          <source>One of Julia's goals is to provide an effective language for data analysis and statistical programming. For users coming to Julia from R, these are some noteworthy differences:</source>
          <target state="translated">Одной из целей Джулии является предоставление эффективного языка для анализа данных и статистического программирования.Для пользователей,приезжающих в Юлию из R,это некоторые примечательные различия:</target>
        </trans-unit>
        <trans-unit id="55096f5245208c5eb0440ec6a345fddb43363fbe" translate="yes" xml:space="preserve">
          <source>One of the &lt;code&gt;connect&lt;/code&gt; methods that does not follow the &lt;code&gt;listen&lt;/code&gt; methods is &lt;code&gt;connect(host::String,port)&lt;/code&gt;, which will attempt to connect to the host given by the &lt;code&gt;host&lt;/code&gt; parameter on the port given by the &lt;code&gt;port&lt;/code&gt; parameter. It allows you to do things like:</source>
          <target state="translated">Один из методов &lt;code&gt;connect&lt;/code&gt; , который не следует за методами &lt;code&gt;listen&lt;/code&gt; - это &lt;code&gt;connect(host::String,port)&lt;/code&gt; , который будет пытаться подключиться к хосту, заданному параметром &lt;code&gt;host&lt;/code&gt; , на порту, заданном параметром &lt;code&gt;port&lt;/code&gt; . Это позволяет вам делать такие вещи, как:</target>
        </trans-unit>
        <trans-unit id="10010155e6ee1cb87ecad6ce87a3f916af001f45" translate="yes" xml:space="preserve">
          <source>One of the most common and useful string operations is concatenation:</source>
          <target state="translated">Одной из наиболее распространенных и полезных операций со строками является конкатенация:</target>
        </trans-unit>
        <trans-unit id="e7a2348e6f04e9e17b6e21a7a69732c3c29d40af" translate="yes" xml:space="preserve">
          <source>One of the most common techniques to improve performance is to reduce memory allocation. The total amount of allocation can be measured with &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt;&lt;code&gt;@time&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.@allocated&quot;&gt;&lt;code&gt;@allocated&lt;/code&gt;&lt;/a&gt;, and specific lines triggering allocation can often be inferred from profiling via the cost of garbage collection that these lines incur. However, sometimes it is more efficient to directly measure the amount of memory allocated by each line of code.</source>
          <target state="translated">Один из наиболее распространенных методов повышения производительности - сокращение выделения памяти. Общий объем выделения можно измерить с помощью &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt; &lt;code&gt;@time&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/base/index#Base.@allocated&quot;&gt; &lt;code&gt;@allocated&lt;/code&gt; &lt;/a&gt; , а конкретные строки, запускающие выделение, часто можно вывести из профилирования через стоимость сборки мусора, которую эти строки несут. Однако иногда более эффективно напрямую измерить объем памяти, выделяемой каждой строкой кода.</target>
        </trans-unit>
        <trans-unit id="9af8b1074cbe3323673dd24c49db4be8d382b298" translate="yes" xml:space="preserve">
          <source>One only needs to introduce a single type parameter to force specialization, even if the other types are unconstrained. For example, this will also specialize, and is useful when the arguments are not all of the same type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45374d28bce37032091a9fea4342bae27c8b8de4" translate="yes" xml:space="preserve">
          <source>One problem remains however. Consider the following use of this macro:</source>
          <target state="translated">Однако остается одна проблема.Рассмотрим следующее использование этого макроса:</target>
        </trans-unit>
        <trans-unit id="b9f48341b16ff2de536604efaceb8038f76fbfcd" translate="yes" xml:space="preserve">
          <source>One risk with this design is the possibility that if there is no suitable promotion method converting &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to the same type, the second method will recurse on itself infinitely and trigger a stack overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3501153e12d4b87f4638178e60c29c5d300b9f87" translate="yes" xml:space="preserve">
          <source>One risk with this design is the possibility that if there is no suitable promotion method converting &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to the same type, the second method will recurse on itself infinitely and trigger a stack overflow. The non-exported function &lt;code&gt;Base.promote_noncircular&lt;/code&gt; can be used as an alternative; when promotion fails it will still throw an error, but one that fails faster with a more specific error message.</source>
          <target state="translated">Один из рисков этого дизайна заключается в возможности того, что, если нет подходящего метода продвижения, конвертирующего &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; в один и тот же тип, второй метод будет бесконечно рекурсивен сам по себе и вызовет переполнение стека. В качестве альтернативы можно использовать &lt;code&gt;Base.promote_noncircular&lt;/code&gt; функцию Base.promote_noncircular ; когда продвижение не удается, оно все равно выдаст ошибку, но ошибка будет быстрее с более конкретным сообщением об ошибке.</target>
        </trans-unit>
        <trans-unit id="7b7b822a81641982530f11d17ac5483aca96f2f6" translate="yes" xml:space="preserve">
          <source>One then writes method(s) (at least &lt;a href=&quot;#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt;) operating on &lt;code&gt;Broadcasted{MyContainerStyle}&lt;/code&gt;. There are also several pre-defined subtypes of &lt;code&gt;BroadcastStyle&lt;/code&gt; that you may be able to leverage; see the &lt;a href=&quot;../../manual/interfaces/index#man-interfaces-broadcasting&quot;&gt;Interfaces chapter&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f2f7c3f7aee7dfa793b808c1f3af767054aa1f" translate="yes" xml:space="preserve">
          <source>One then writes method(s) (at least &lt;a href=&quot;#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt;) operating on &lt;code&gt;Broadcasted{MyContainerStyle}&lt;/code&gt;. There are also several pre-defined subtypes of &lt;code&gt;BroadcastStyle&lt;/code&gt; that you may be able to leverage; see the &lt;a href=&quot;../../manual/interfaces/index#man-interfaces-broadcasting-1&quot;&gt;Interfaces chapter&lt;/a&gt; for more information.</source>
          <target state="translated">Затем &lt;code&gt;Broadcasted{MyContainerStyle}&lt;/code&gt; (по крайней мере, &lt;a href=&quot;#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt; ), работающие с Broadcasted {MyContainerStyle} . Есть также несколько предопределенных подтипов &lt;code&gt;BroadcastStyle&lt;/code&gt; , которые вы можете использовать; см. &lt;a href=&quot;../../manual/interfaces/index#man-interfaces-broadcasting-1&quot;&gt;главу &amp;laquo;Интерфейсы&amp;raquo;&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="d200e37937b9200fe9bf660a0dc70e4426e0648a" translate="yes" xml:space="preserve">
          <source>One way to significantly cut down on compile-times and testing complexity is to isolate the logic for converting to the desired type and the computation. This lets the compiler specialize and inline the conversion logic independent from the rest of the body of the larger kernel.</source>
          <target state="translated">Одним из способов значительно сократить время компиляции и сложность тестирования является изоляция логики преобразования в нужный тип и вычисления.Это позволяет компилятору специализироваться и встраивать логику преобразования независимо от остальной части тела большего ядра.</target>
        </trans-unit>
        <trans-unit id="d1645f1271d39f73f0d6321f16068bb1fe04a5c9" translate="yes" xml:space="preserve">
          <source>One way to think of this behavior is that &lt;code&gt;producer&lt;/code&gt; was able to return multiple times. Between calls to &lt;code&gt;put!&lt;/code&gt;, the producer's execution is suspended and the consumer has control.</source>
          <target state="translated">Можно подумать об этом поведении, что &lt;code&gt;producer&lt;/code&gt; мог возвращаться несколько раз. Между звонками &lt;code&gt;put!&lt;/code&gt; , исполнение производителя приостанавливается, и контроль остается у потребителя.</target>
        </trans-unit>
        <trans-unit id="06fd832dc6ac0ce055682a44df74b0f43374b3e5" translate="yes" xml:space="preserve">
          <source>One-dimensional &lt;a href=&quot;#Core.DenseArray&quot;&gt;&lt;code&gt;DenseArray&lt;/code&gt;&lt;/a&gt; with elements of type &lt;code&gt;T&lt;/code&gt;. Alias for &lt;code&gt;DenseArray{T,1}&lt;/code&gt;.</source>
          <target state="translated">Одномерный &lt;a href=&quot;#Core.DenseArray&quot;&gt; &lt;code&gt;DenseArray&lt;/code&gt; &lt;/a&gt; с элементами типа &lt;code&gt;T&lt;/code&gt; . Псевдоним для &lt;code&gt;DenseArray{T,1}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3df27b5108b582dd0321cfd13d78f7cf11d42868" translate="yes" xml:space="preserve">
          <source>One-dimensional dense array with elements of type &lt;code&gt;T&lt;/code&gt;, often used to represent a mathematical vector. Alias for &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array{T,1}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Одномерный плотный массив с элементами типа &lt;code&gt;T&lt;/code&gt; , часто используемый для представления математического вектора. Псевдоним для &lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array{T,1}&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="761532be36fbf4ec3ee7163dc62c1a3c16eed1d0" translate="yes" xml:space="preserve">
          <source>OneTo</source>
          <target state="translated">OneTo</target>
        </trans-unit>
        <trans-unit id="76ad803f3bc172b43390cf9edc7cbf4c7fe04f9b" translate="yes" xml:space="preserve">
          <source>Only a single dimension in &lt;code&gt;dims&lt;/code&gt; is currently supported. Equivalent to &lt;code&gt;(view(A,:,:,...,i,:,: ...)) for i in axes(A, dims))&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is in position &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f9c4d4b9ceb74b37011c17fefd6d754166722d" translate="yes" xml:space="preserve">
          <source>Only annotated tags can be peeled to &lt;code&gt;GitTag&lt;/code&gt; objects. Lightweight tags (the default) are references under &lt;code&gt;refs/tags/&lt;/code&gt; which point directly to &lt;code&gt;GitCommit&lt;/code&gt; objects.</source>
          <target state="translated">Только аннотированные теги могут быть &lt;code&gt;GitTag&lt;/code&gt; объектам GitTag . Облегченные теги (по умолчанию) - это ссылки в &lt;code&gt;refs/tags/&lt;/code&gt; которые указывают непосредственно на объекты &lt;code&gt;GitCommit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0826c50b1728d0d708f6df24eabe81219d4fd72a" translate="yes" xml:space="preserve">
          <source>Only certain &quot;simple&quot; types can be used atomically, namely the primitive boolean, integer, and float-point types. These are &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;Int8&lt;/code&gt;...&lt;code&gt;Int128&lt;/code&gt;, &lt;code&gt;UInt8&lt;/code&gt;...&lt;code&gt;UInt128&lt;/code&gt;, and &lt;code&gt;Float16&lt;/code&gt;...&lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="translated">Только определенные &amp;laquo;простые&amp;raquo; типы могут использоваться атомарно, а именно примитивные логические, целочисленные и типы с плавающей запятой. Это &lt;code&gt;Bool&lt;/code&gt; , &lt;code&gt;Int8&lt;/code&gt; ... &lt;code&gt;Int128&lt;/code&gt; , &lt;code&gt;UInt8&lt;/code&gt; ... &lt;code&gt;UInt128&lt;/code&gt; и &lt;code&gt;Float16&lt;/code&gt; ... &lt;code&gt;Float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d3b00a80434bbed5cd383bf9ee04282bf5a25c4" translate="yes" xml:space="preserve">
          <source>Only conversion to/from UTF-8 is currently supported.</source>
          <target state="translated">В настоящее время поддерживается только преобразование в/из UTF-8.</target>
        </trans-unit>
        <trans-unit id="1eeeb7bde4b30671f25e4d852799d258e6eb1b0e" translate="yes" xml:space="preserve">
          <source>Only one default constructor is generated for parametric types, since overriding it is not possible. This constructor accepts any arguments and converts them to the field types.</source>
          <target state="translated">Для параметрических типов генерируется только один конструктор по умолчанию,так как переопределение невозможно.Этот конструктор принимает любые аргументы и преобразует их в типы полей.</target>
        </trans-unit>
        <trans-unit id="5bed7725a4393ba41e127b736de1d452935e48f0" translate="yes" xml:space="preserve">
          <source>Only provide an argument list when really necessary.</source>
          <target state="translated">Предоставляйте список аргументов только тогда,когда это действительно необходимо.</target>
        </trans-unit>
        <trans-unit id="e29b5de56072ba7e7c5e4e8ea182586070ff91e4" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;master&lt;/code&gt; process can add or remove worker processes.</source>
          <target state="translated">Только &lt;code&gt;master&lt;/code&gt; процесс может добавлять или удалять рабочие процессы.</target>
        </trans-unit>
        <trans-unit id="9ea4110acec6b93703ee74f301aaf09b4d9cd7ab" translate="yes" xml:space="preserve">
          <source>Only the &lt;em&gt;lower&lt;/em&gt; triangle of the matrix will be used.</source>
          <target state="translated">Будет использован только &lt;em&gt;нижний&lt;/em&gt; треугольник матрицы.</target>
        </trans-unit>
        <trans-unit id="99042162ee5c91958ac1be23590ce2805ab4e78a" translate="yes" xml:space="preserve">
          <source>Only the &lt;em&gt;upper&lt;/em&gt; triangle of the matrix will be used.</source>
          <target state="translated">Будет использован только &lt;em&gt;верхний&lt;/em&gt; треугольник матрицы.</target>
        </trans-unit>
        <trans-unit id="c4ada366ae15c04b6cbda38f0f5be6dcbb2d22ea" translate="yes" xml:space="preserve">
          <source>Only valid in the context of an &lt;a href=&quot;#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the &lt;a href=&quot;../../manual/metaprogramming/index#man-macros&quot;&gt;Macros&lt;/a&gt; section of the Metaprogramming chapter of the manual for more details and examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b41da8066e8d8f89de45d239c8dc1ffa14f3b2b" translate="yes" xml:space="preserve">
          <source>Only valid in the context of an &lt;a href=&quot;#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the &lt;a href=&quot;../../manual/metaprogramming/index#man-macros-1&quot;&gt;Macros&lt;/a&gt; section of the Metaprogramming chapter of the manual for more details and examples.</source>
          <target state="translated">Допустимо только в контексте &lt;a href=&quot;#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; ,&lt;/a&gt; возвращаемого макросом. Предотвращает преобразование встроенных переменных в генетические переменные на этапе макросигиены. См. Раздел &amp;laquo; &lt;a href=&quot;../../manual/metaprogramming/index#man-macros-1&quot;&gt;Макросы&lt;/a&gt; &amp;raquo; в главе &amp;laquo;Метапрограммирование&amp;raquo; руководства для получения более подробной информации и примеров.</target>
        </trans-unit>
        <trans-unit id="21b2be4216216eef63fc5bb828bd7f58c8b5fe91" translate="yes" xml:space="preserve">
          <source>Only values, not variables, have types &amp;ndash; variables are simply names bound to values.</source>
          <target state="translated">Только значения, а не переменные, имеют типы - переменные - это просто имена, привязанные к значениям.</target>
        </trans-unit>
        <trans-unit id="d97553895fe582daa8b11a4132b4c59d7d7a6098" translate="yes" xml:space="preserve">
          <source>Oops. Adding a &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; operator to Matlab wouldn't help, because saturation that occurs when adding &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;2n&lt;/code&gt; has already destroyed the information necessary to compute the correct midpoint.</source>
          <target state="translated">К сожалению. Добавление оператора &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; в Matlab не поможет, поскольку насыщение, возникающее при добавлении &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;2n&lt;/code&gt; , уже уничтожило информацию, необходимую для вычисления правильной средней точки.</target>
        </trans-unit>
        <trans-unit id="406e4f0a56a5716867bbbdaa429f12887df5a44e" translate="yes" xml:space="preserve">
          <source>Open Book</source>
          <target state="translated">Открытая книга</target>
        </trans-unit>
        <trans-unit id="febd72d5a0f70743184299e93e82b1271a88bc68" translate="yes" xml:space="preserve">
          <source>Open Box</source>
          <target state="translated">Открытый ящик</target>
        </trans-unit>
        <trans-unit id="c34b416e0aabc7a83bd814267dec2bceb7820832" translate="yes" xml:space="preserve">
          <source>Open File Folder</source>
          <target state="translated">Открытая файловая папка</target>
        </trans-unit>
        <trans-unit id="570f6f57d565bf8540f0881deac6b1e5aaab0640" translate="yes" xml:space="preserve">
          <source>Open Hands Sign</source>
          <target state="translated">Знак открытых рук</target>
        </trans-unit>
        <trans-unit id="5468961e7240ee7f0d33502664aa34aa45966978" translate="yes" xml:space="preserve">
          <source>Open Lock</source>
          <target state="translated">открытый замок</target>
        </trans-unit>
        <trans-unit id="d56fae21a8b4c42f3ddbf993f9f6189849fb4662" translate="yes" xml:space="preserve">
          <source>Open Mailbox With Lowered Flag</source>
          <target state="translated">Открыть почтовый ящик с пониженным флагом</target>
        </trans-unit>
        <trans-unit id="4cd8dfeea777f97bde748d6c4492714eb41361d7" translate="yes" xml:space="preserve">
          <source>Open Mailbox With Raised Flag</source>
          <target state="translated">Открыть почтовый ящик с поднятым флагом</target>
        </trans-unit>
        <trans-unit id="c5437122a10ed7699fba87aa70335b78d772e41f" translate="yes" xml:space="preserve">
          <source>Open a TCP socket using libuv. If &lt;code&gt;delay&lt;/code&gt; is true, libuv delays creation of the socket's file descriptor till the first &lt;a href=&quot;#Base.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; call. &lt;code&gt;TCPSocket&lt;/code&gt; has various fields to denote the state of the socket as well as its send/receive buffers.</source>
          <target state="translated">Откройте сокет TCP с помощью libuv. Если &lt;code&gt;delay&lt;/code&gt; равен true, libuv откладывает создание файлового дескриптора сокета до первого вызова &lt;a href=&quot;#Base.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;TCPSocket&lt;/code&gt; имеет различные поля для обозначения состояния сокета, а также его буферов отправки / приема.</target>
        </trans-unit>
        <trans-unit id="08c669ce9e8c7f026f83710316844506366a7e81" translate="yes" xml:space="preserve">
          <source>Open a UDP socket using libuv. &lt;code&gt;UDPSocket&lt;/code&gt; has various fields to denote the state of the socket.</source>
          <target state="translated">Откройте сокет UDP с помощью libuv. &lt;code&gt;UDPSocket&lt;/code&gt; имеет различные поля для обозначения состояния сокета.</target>
        </trans-unit>
        <trans-unit id="52227891e75707f6a9cd180dec1ac02b43da23b0" translate="yes" xml:space="preserve">
          <source>Open a file and deserialize its contents.</source>
          <target state="translated">Откройте файл и десериализуйте его содержимое.</target>
        </trans-unit>
        <trans-unit id="d8d0d276fcf9e878e3601e4f3ec11f282a81eeff" translate="yes" xml:space="preserve">
          <source>Open a file and read its contents. &lt;code&gt;args&lt;/code&gt; is passed to &lt;code&gt;read&lt;/code&gt;: this is equivalent to &lt;code&gt;open(io-&amp;gt;read(io, args...), filename)&lt;/code&gt;.</source>
          <target state="translated">Откройте файл и прочтите его содержимое. &lt;code&gt;args&lt;/code&gt; передается для &lt;code&gt;read&lt;/code&gt; : это эквивалентно &lt;code&gt;open(io-&amp;gt;read(io, args...), filename)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="253d17f9d0742c44928428f7a4404eb72b5d7aa3" translate="yes" xml:space="preserve">
          <source>Open a file and serialize the given value to it.</source>
          <target state="translated">Откройте файл и выполните сериализацию заданного значения.</target>
        </trans-unit>
        <trans-unit id="47c11e34672f0f08478d57e985476572168f78bc" translate="yes" xml:space="preserve">
          <source>Open a file in a mode specified by five boolean keyword arguments:</source>
          <target state="translated">Откройте файл в режиме,заданном пятью булевыми аргументами ключевых слов:</target>
        </trans-unit>
        <trans-unit id="b60069cfc2b0cba6a24e60f4b0e11798b23031dc" translate="yes" xml:space="preserve">
          <source>Open a git repository at &lt;code&gt;path&lt;/code&gt; with extended controls (for instance, if the current user must be a member of a special access group to read &lt;code&gt;path&lt;/code&gt;).</source>
          <target state="translated">Откройте репозиторий git по &lt;code&gt;path&lt;/code&gt; с расширенными элементами управления (например, если текущий пользователь должен быть членом специальной группы доступа для чтения &lt;code&gt;path&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c21ae27cc36b37896e9299f5470a30ce05318357" translate="yes" xml:space="preserve">
          <source>Open a git repository at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">Откройте репозиторий git по &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6bfd40f922aa7ca03128208dcd4d40013760ce0" translate="yes" xml:space="preserve">
          <source>Open a new git repository at &lt;code&gt;path&lt;/code&gt;. If &lt;code&gt;bare&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the working tree will be created in &lt;code&gt;path/.git&lt;/code&gt;. If &lt;code&gt;bare&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, no working directory will be created.</source>
          <target state="translated">Откройте новый репозиторий git по &lt;code&gt;path&lt;/code&gt; . Если &lt;code&gt;bare&lt;/code&gt; - &lt;code&gt;false&lt;/code&gt; , рабочее дерево будет создано в &lt;code&gt;path/.git&lt;/code&gt; . Если &lt;code&gt;bare&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; , рабочий каталог создан не будет.</target>
        </trans-unit>
        <trans-unit id="6e32b68788e10f5efb73ae1c554923718ef6941a" translate="yes" xml:space="preserve">
          <source>Opening a file, doing something to its contents, and closing it again is a very common pattern. To make this easier, there exists another invocation of &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; which takes a function as its first argument and filename as its second, opens the file, calls the function with the file as an argument, and then closes it again. For example, given a function:</source>
          <target state="translated">Открытие файла, выполнение каких-либо действий с его содержимым и его повторное закрытие - очень распространенный шаблон. Чтобы упростить задачу, существует еще один вызов &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; ,&lt;/a&gt; который принимает функцию в качестве первого аргумента и имя файла в качестве второго, открывает файл, вызывает функцию с файлом в качестве аргумента, а затем снова закрывает ее. Например, для функции:</target>
        </trans-unit>
        <trans-unit id="69c9721ab40980ac2c3f7fd14c50821efba985b5" translate="yes" xml:space="preserve">
          <source>Operating system word size (&lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;) as well as path separator differences (&lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt;) will also affect the reproducibility of some doctests.</source>
          <target state="translated">Размер слова операционной системы ( &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; ), а также различия в разделителях пути ( &lt;code&gt;/&lt;/code&gt; или &lt;code&gt;\&lt;/code&gt; ) также влияют на воспроизводимость некоторых тестов.</target>
        </trans-unit>
        <trans-unit id="8d87b27bd5aedd5e01ab52666b185599e013766f" translate="yes" xml:space="preserve">
          <source>Operations on Types</source>
          <target state="translated">Операции на Типах</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="53d6250055dd8231245476710d174685174b7d89" translate="yes" xml:space="preserve">
          <source>Operator Precedence and Associativity</source>
          <target state="translated">Приоритет оператора и партнерская деятельность</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="93b63dff42dcd53d0f12d4293741e66cb2b84321" translate="yes" xml:space="preserve">
          <source>Operators Are Functions</source>
          <target state="translated">Операторы являются функциями</target>
        </trans-unit>
        <trans-unit id="283f15e3371d872597560981f14b9a2f5e0a420b" translate="yes" xml:space="preserve">
          <source>Operators With Special Names</source>
          <target state="translated">Операторы со специальными именами</target>
        </trans-unit>
        <trans-unit id="f019a8b6a52539e15849e341f41e00db685f57e9" translate="yes" xml:space="preserve">
          <source>Operators like &lt;code&gt;+&lt;/code&gt; are also valid identifiers, but are parsed specially. In some contexts, operators can be used just like variables; for example &lt;code&gt;(+)&lt;/code&gt; refers to the addition function, and &lt;code&gt;(+) = f&lt;/code&gt; will reassign it. Most of the Unicode infix operators (in category Sm), such as &lt;code&gt;&amp;oplus;&lt;/code&gt;, are parsed as infix operators and are available for user-defined methods (e.g. you can use &lt;code&gt;const &amp;otimes; = kron&lt;/code&gt; to define &lt;code&gt;&amp;otimes;&lt;/code&gt; as an infix Kronecker product). Operators can also be suffixed with modifying marks, primes, and sub/superscripts, e.g. &lt;code&gt;+̂ₐ&amp;Prime;&lt;/code&gt; is parsed as an infix operator with the same precedence as &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">Такие операторы, как &lt;code&gt;+&lt;/code&gt; , также являются допустимыми идентификаторами, но анализируются специально. В некоторых контекстах операторы могут использоваться как переменные; например &lt;code&gt;(+)&lt;/code&gt; относится к функции сложения, а &lt;code&gt;(+) = f&lt;/code&gt; переназначит ее. Большинство инфиксных операторов Unicode (в категории Sm), таких как &lt;code&gt;&amp;oplus;&lt;/code&gt; , анализируются как инфиксные операторы и доступны для определяемых пользователем методов (например, вы можете использовать &lt;code&gt;const &amp;otimes; = kron&lt;/code&gt; для определения &lt;code&gt;&amp;otimes;&lt;/code&gt; как инфиксного продукта Кронекера). Операторы также могут иметь суффиксы с модифицирующими знаками, простыми числами и дополнительными / надстрочными &lt;code&gt;+̂ₐ&amp;Prime;&lt;/code&gt; , например, + is &amp;Prime; анализируется как инфиксный оператор с тем же приоритетом, что и &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="977a00f3fb0022f9ead49744bbe4afa06cde1201" translate="yes" xml:space="preserve">
          <source>Ophiuchus</source>
          <target state="translated">Ophiuchus</target>
        </trans-unit>
        <trans-unit id="d2c649443c00279b2ab6db1f4eb3df011a9c205e" translate="yes" xml:space="preserve">
          <source>Optical Disc</source>
          <target state="translated">Оптический диск</target>
        </trans-unit>
        <trans-unit id="bbe45d1200c2548054cd7105d981e5416cd548c2" translate="yes" xml:space="preserve">
          <source>Optimize network I/O during parallel execution</source>
          <target state="translated">Оптимизация сетевого ввода/вывода во время параллельного выполнения</target>
        </trans-unit>
        <trans-unit id="7ee57de488e50e002c8d91e9ed122222d3621625" translate="yes" xml:space="preserve">
          <source>Optimizing generation with cached computation between calls</source>
          <target state="translated">Оптимизация генерации с кэшированием вычислений между вызовами</target>
        </trans-unit>
        <trans-unit id="28b9b9628dcf8cbfb41ac0e1a118c33a59e1c755" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;key&amp;ndash;value pairs&lt;/em&gt; allow arbitrary data to be attached to each event. Some keys have conventional meaning that can affect the way an event is interpreted (see &lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt;&lt;code&gt;@logmsg&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Необязательные &lt;em&gt;пары &quot;ключ-значение&quot;&lt;/em&gt; позволяют прикреплять произвольные данные к каждому событию. Некоторые ключи имеют обычное значение, которое может повлиять на способ интерпретации события (см. &lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt; &lt;code&gt;@logmsg&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="81d0780e7731b1fca95807bff5fa643e35b8da13" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;key&amp;ndash;value pairs&lt;/em&gt; allow arbitrary data to be attached to each event. Some keys have conventional meaning that can affect the way an event is interpreted (see &lt;a href=&quot;#Logging.@logmsg&quot;&gt;&lt;code&gt;@logmsg&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d691ad463ac25297b3313f781ce7492928f99d06" translate="yes" xml:space="preserve">
          <source>Optional Arguments</source>
          <target state="translated">Дополнительные аргументы</target>
        </trans-unit>
        <trans-unit id="6028b0d5037105ac8c7fc43ef8827d1357d9f48d" translate="yes" xml:space="preserve">
          <source>Optional arguments are actually just a convenient syntax for writing multiple method definitions with different numbers of arguments (see &lt;a href=&quot;../methods/index#Note-on-Optional-and-keyword-Arguments&quot;&gt;Note on Optional and keyword Arguments&lt;/a&gt;). This can be checked for our &lt;code&gt;Date&lt;/code&gt; function example by calling &lt;code&gt;methods&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c156ad5dd399595345f3f0b1a62545c1d9461fea" translate="yes" xml:space="preserve">
          <source>Optional arguments are actually just a convenient syntax for writing multiple method definitions with different numbers of arguments (see &lt;a href=&quot;../methods/index#Note-on-Optional-and-keyword-Arguments-1&quot;&gt;Note on Optional and keyword Arguments&lt;/a&gt;). This can be checked for our &lt;code&gt;Date&lt;/code&gt; function example by calling &lt;code&gt;methods&lt;/code&gt; function.</source>
          <target state="translated">Необязательные аргументы на самом деле являются просто удобным синтаксисом для написания нескольких определений методов с разным количеством аргументов (см. &lt;a href=&quot;../methods/index#Note-on-Optional-and-keyword-Arguments-1&quot;&gt;Примечание о дополнительных аргументах и ​​аргументах ключевого слова&lt;/a&gt; ). Это можно проверить в нашем примере функции &lt;code&gt;Date&lt;/code&gt; , вызвав &lt;code&gt;methods&lt;/code&gt; function.</target>
        </trans-unit>
        <trans-unit id="f672e593f5c2debc9f124a5145222ec3e7c5de62" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;AllowedType&lt;/code&gt; relaxes the test, by making it pass when either the type of &lt;code&gt;f(x)&lt;/code&gt; matches the inferred type modulo &lt;code&gt;AllowedType&lt;/code&gt;, or when the return type is a subtype of &lt;code&gt;AllowedType&lt;/code&gt;. This is useful when testing type stability of functions returning a small union such as &lt;code&gt;Union{Nothing, T}&lt;/code&gt; or &lt;code&gt;Union{Missing, T}&lt;/code&gt;.</source>
          <target state="translated">При желании &lt;code&gt;AllowedType&lt;/code&gt; ослабляет проверку, передавая ее, когда либо тип &lt;code&gt;f(x)&lt;/code&gt; соответствует выведенному типу по модулю &lt;code&gt;AllowedType&lt;/code&gt; , либо когда возвращаемый тип является подтипом &lt;code&gt;AllowedType&lt;/code&gt; . Это полезно при проверке стабильности типов функций, возвращающих небольшое объединение, такое как &lt;code&gt;Union{Nothing, T}&lt;/code&gt; или &lt;code&gt;Union{Missing, T}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ad55710ad0da179a2e07ff4ddd05386729e4605" translate="yes" xml:space="preserve">
          <source>Optionally, an &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; may be passed as the first argument to redirect output.</source>
          <target state="translated">При желании &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; &lt;/a&gt; может быть передан в качестве первого аргумента для перенаправления вывода.</target>
        </trans-unit>
        <trans-unit id="25e925eadfd24d6dcadbc98af889be63a7072a20" translate="yes" xml:space="preserve">
          <source>Optionally, with this form you can also specialize on the type of &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">При желании, с помощью данной формы Вы также можете специализироваться на типе &lt;code&gt;dest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df7538e747f40841380a56713e7d2787b0188307" translate="yes" xml:space="preserve">
          <source>Optionally, you can specify an offset (in bytes) if, for example, you want to skip over a header in the file. The default value for the offset is the current stream position for an &lt;code&gt;IOStream&lt;/code&gt;.</source>
          <target state="translated">При желании вы можете указать смещение (в байтах), если, например, вы хотите пропустить заголовок в файле. Значение смещения по умолчанию - это текущая позиция потока для &lt;code&gt;IOStream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="605701651cfa6ef7ed858d2bd4686cc27b775fbc" translate="yes" xml:space="preserve">
          <source>Optionally-generated functions</source>
          <target state="translated">Опционально генерируемые функции</target>
        </trans-unit>
        <trans-unit id="d7a89a6a7036867a56e048571964e7377e17b84b" translate="yes" xml:space="preserve">
          <source>Options for connecting through a proxy.</source>
          <target state="translated">Опции для подключения через прокси-сервер.</target>
        </trans-unit>
        <trans-unit id="9956408533f9b356f2027c2af19ba734ff7eeffb" translate="yes" xml:space="preserve">
          <source>Options for controlling the display of profile results</source>
          <target state="translated">Опции для управления отображением результатов профиля</target>
        </trans-unit>
        <trans-unit id="5570f96fecf594a439501b253a2a052232a9fcb8" translate="yes" xml:space="preserve">
          <source>Options to control how &lt;code&gt;git_status_foreach_ext()&lt;/code&gt; will issue callbacks. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_status_opt_t&quot;&gt;&lt;code&gt;git_status_opt_t&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Параметры для управления тем, как &lt;code&gt;git_status_foreach_ext()&lt;/code&gt; будет вызывать обратные вызовы. Соответствует структуре &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_status_opt_t&quot;&gt; &lt;code&gt;git_status_opt_t&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09b7d446a14ffb508604e0dc10c5b7aa125df09d" translate="yes" xml:space="preserve">
          <source>Or for use with Julia's metaprogramming functionality:</source>
          <target state="translated">Или для использования с функцией метапрограммирования Джулии:</target>
        </trans-unit>
        <trans-unit id="b5d347e4a07542d29e6ad6bac37e10d945034f91" translate="yes" xml:space="preserve">
          <source>Or in reverse order by a transformation:</source>
          <target state="translated">Или в обратном порядке путем трансформации:</target>
        </trans-unit>
        <trans-unit id="22c33f400210116707836ec8165b8593271e796f" translate="yes" xml:space="preserve">
          <source>Or similary with &lt;code&gt;perf&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f1bff2e8ff8f63044d056dab4a7ec43a5bafb9" translate="yes" xml:space="preserve">
          <source>Or similary with with &lt;code&gt;perf&lt;/code&gt; :</source>
          <target state="translated">Или аналогично с &lt;code&gt;perf&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="643c06d525fb92f1d6423f6e6b9cceb50ab627c9" translate="yes" xml:space="preserve">
          <source>Or the short form notation:</source>
          <target state="translated">Или короткая форма записи:</target>
        </trans-unit>
        <trans-unit id="e325f042a4fdea4bb2bf26bcb172b85f8d8b398f" translate="yes" xml:space="preserve">
          <source>Or you could put that code into a script and run it:</source>
          <target state="translated">Или вы можете поместить этот код в скрипт и запустить его:</target>
        </trans-unit>
        <trans-unit id="20dbfbec42bb9c9ae019f4de0fc6d751181ab4ba" translate="yes" xml:space="preserve">
          <source>Orange Book</source>
          <target state="translated">Апельсиновая книга</target>
        </trans-unit>
        <trans-unit id="1f4f65818576f11a271c283501f9c9777a309c75" translate="yes" xml:space="preserve">
          <source>Order-Related Functions</source>
          <target state="translated">Функции,связанные с порядком</target>
        </trans-unit>
        <trans-unit id="08958be0b6b4d59402e8c3539af8a1f6c4626498" translate="yes" xml:space="preserve">
          <source>Ordered lists are written by replacing the &quot;bullet&quot; character, either &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, or &lt;code&gt;-&lt;/code&gt;, with a positive integer followed by either &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">Упорядоченные списки записываются путем замены символа &amp;laquo;маркера&amp;raquo;, &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;-&lt;/code&gt; , положительным целым числом, за которым следует любой из них &lt;code&gt;.&lt;/code&gt; или &lt;code&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ebecd2371b5b94b4b632a7345f2ed4969d932ab" translate="yes" xml:space="preserve">
          <source>OrdinalRange</source>
          <target state="translated">OrdinalRange</target>
        </trans-unit>
        <trans-unit id="110f685c533d15161bdb96f31c09d8e08a6ec5f5" translate="yes" xml:space="preserve">
          <source>Original Of</source>
          <target state="translated">Оригинал</target>
        </trans-unit>
        <trans-unit id="8a2c422f6e969a4ab0e509e76d2af5e57bbac8a6" translate="yes" xml:space="preserve">
          <source>Orthogonalize your design</source>
          <target state="translated">Ортогонализируйте ваш дизайн</target>
        </trans-unit>
        <trans-unit id="354c9b5e6f7e399ccafd2041e1f89b4ea9b2b78c" translate="yes" xml:space="preserve">
          <source>Other Test Macros</source>
          <target state="translated">Другие тестовые макросы</target>
        </trans-unit>
        <trans-unit id="d932e5243006c50ece04ebc58ddfa354640e1bce" translate="yes" xml:space="preserve">
          <source>Other characters that support such extensions include \odot &lt;code&gt;⊙&lt;/code&gt; and \oplus &lt;code&gt;&amp;oplus;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f16299e775b6ed02c52fa3e91a6bae26c711f17" translate="yes" xml:space="preserve">
          <source>Other constructors:</source>
          <target state="translated">Другие конструкторы:</target>
        </trans-unit>
        <trans-unit id="de3bc1f63e468cd0b128dfc49cf966142493ea71" translate="yes" xml:space="preserve">
          <source>Other functions with optimized methods</source>
          <target state="translated">Другие функции с оптимизированными методами</target>
        </trans-unit>
        <trans-unit id="73004fc90947ff97722d45638ee7f61f1d20cbf1" translate="yes" xml:space="preserve">
          <source>Other known potential failure scenarios include:</source>
          <target state="translated">Другие известные сценарии потенциальных отказов включают в себя:</target>
        </trans-unit>
        <trans-unit id="c24cf096faa5c89a991560f741c7e988253e7c13" translate="yes" xml:space="preserve">
          <source>Other types of clusters can be supported by writing your own custom &lt;code&gt;ClusterManager&lt;/code&gt;, as described below in the &lt;a href=&quot;#ClusterManagers&quot;&gt;ClusterManagers&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8180f53ba099ee9c2b3f9518b6c8ae95ee30562b" translate="yes" xml:space="preserve">
          <source>Other types of clusters can be supported by writing your own custom &lt;code&gt;ClusterManager&lt;/code&gt;, as described below in the &lt;a href=&quot;#ClusterManagers-1&quot;&gt;ClusterManagers&lt;/a&gt; section.</source>
          <target state="translated">Другие типы кластеров можно поддерживать, написав свой собственный &lt;code&gt;ClusterManager&lt;/code&gt; , как описано ниже в разделе &lt;a href=&quot;#ClusterManagers-1&quot;&gt;ClusterManager&lt;/a&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
