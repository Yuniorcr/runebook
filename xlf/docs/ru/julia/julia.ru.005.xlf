<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="d32b092601fd9ebd2ac1ea5cb15d47455e3d9c4d" translate="yes" xml:space="preserve">
          <source>An updating operator rebinds the variable on the left-hand side. As a result, the type of the variable may change.</source>
          <target state="translated">Оператор обновления переманивает переменную с левой стороны.В результате тип переменной может измениться.</target>
        </trans-unit>
        <trans-unit id="8f8c77e7404ca30dcccf92c73c985f04a86420e7" translate="yes" xml:space="preserve">
          <source>Anchor</source>
          <target state="translated">Anchor</target>
        </trans-unit>
        <trans-unit id="e370a7226632723025763723f6dafd8d5d0d959c" translate="yes" xml:space="preserve">
          <source>And With Dot</source>
          <target state="translated">И с Дот</target>
        </trans-unit>
        <trans-unit id="fbef2e39e8fb91e6824e3edcfe418b3f32f423c2" translate="yes" xml:space="preserve">
          <source>And using that testset looks like:</source>
          <target state="translated">И использование этого тестового набора выглядит так:</target>
        </trans-unit>
        <trans-unit id="1f5999305ceff8dd17e050846ba5e997ba6e59ae" translate="yes" xml:space="preserve">
          <source>Anger Symbol</source>
          <target state="translated">символ гнева</target>
        </trans-unit>
        <trans-unit id="1fd70473fb3de634b409d4acaf49ffc1f90aae1f" translate="yes" xml:space="preserve">
          <source>Angle</source>
          <target state="translated">Angle</target>
        </trans-unit>
        <trans-unit id="b2a770be59cfda02ac18ae81ca3c69433ca33eac" translate="yes" xml:space="preserve">
          <source>Angle With S Inside</source>
          <target state="translated">Угол с S внутри</target>
        </trans-unit>
        <trans-unit id="2f17bd9fe54b168046c3599d1ee65207477b51c2" translate="yes" xml:space="preserve">
          <source>Angle With Underbar</source>
          <target state="translated">Угол с подбалкой</target>
        </trans-unit>
        <trans-unit id="235bfce3d68318529750179e362f5eb792952c9e" translate="yes" xml:space="preserve">
          <source>Angry Face</source>
          <target state="translated">Злое лицо</target>
        </trans-unit>
        <trans-unit id="5dcf9d8e34d0e0dc6accf2e555a98e501316d5eb" translate="yes" xml:space="preserve">
          <source>Angstrom Sign / Angstrom Unit</source>
          <target state="translated">Ангстром Сигнал/Ангстром Блок</target>
        </trans-unit>
        <trans-unit id="51cb7e1a070afb2a7be72806c484010b0b12881a" translate="yes" xml:space="preserve">
          <source>Anguished Face</source>
          <target state="translated">Смущённое лицо</target>
        </trans-unit>
        <trans-unit id="0a391a1d197db6b3528b4037a38a99b886bf2ca2" translate="yes" xml:space="preserve">
          <source>Annotate a &lt;code&gt;for&lt;/code&gt; loop to allow the compiler to take extra liberties to allow loop re-ordering</source>
          <target state="translated">Добавьте аннотации &lt;code&gt;for&lt;/code&gt; циклу for, чтобы компилятор имел дополнительные вольности и разрешил переупорядочение цикла.</target>
        </trans-unit>
        <trans-unit id="7c44ae2875c05d9e420a1ee94f547ea8d42d5f9f" translate="yes" xml:space="preserve">
          <source>Annotate values taken from untyped locations</source>
          <target state="translated">Аннотированные значения,взятые из нетиповых местоположений</target>
        </trans-unit>
        <trans-unit id="80abb045be1e210007d2a8998883d6f2947e4f8f" translate="yes" xml:space="preserve">
          <source>Annotates the expression &lt;code&gt;blk&lt;/code&gt; as a bounds checking block, allowing it to be elided by &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Аннотирует выражение &lt;code&gt;blk&lt;/code&gt; как блок проверки границ, позволяя опустить его с помощью &lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f497993755de46018a5ff1778be3f6bc999629d" translate="yes" xml:space="preserve">
          <source>Anonymous Functions</source>
          <target state="translated">Анонимные функции</target>
        </trans-unit>
        <trans-unit id="3f2245e0442788d1d0364df60f4a6e67754d3e89" translate="yes" xml:space="preserve">
          <source>Another common solution is to separate the reader and writer of the pipeline into separate &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s:</source>
          <target state="translated">Другое распространенное решение - разделить читателя и писателя конвейера на отдельные &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="fcd743f506f81055a92cce92b547fdb1e7daceb8" translate="yes" xml:space="preserve">
          <source>Another helper type is currently available for other cases, &lt;code&gt;Random.SamplerTag&lt;/code&gt;, but is considered as internal API, and can break at any time without proper deprecations.</source>
          <target state="translated">Другой вспомогательный тип в настоящее время доступен для других случаев, &lt;code&gt;Random.SamplerTag&lt;/code&gt; , но считается внутренним API и может выйти из строя в любое время без надлежащего устаревания.</target>
        </trans-unit>
        <trans-unit id="9b1d07d46031acec2c359f730da8bb2e51e75efb" translate="yes" xml:space="preserve">
          <source>Another non-standard version specification extension allows one to use a trailing &lt;code&gt;+&lt;/code&gt; to express an upper limit on build versions, e.g. &lt;code&gt;VERSION &amp;gt; v&quot;0.2-rc1+&quot;&lt;/code&gt; can be used to mean any version above &lt;code&gt;0.2-rc1&lt;/code&gt; and any of its builds: it will return &lt;code&gt;false&lt;/code&gt; for version &lt;code&gt;v&quot;0.2-rc1+win64&quot;&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;v&quot;0.2-rc2&quot;&lt;/code&gt;.</source>
          <target state="translated">Другое нестандартное расширение спецификации версии позволяет использовать завершающий &lt;code&gt;+&lt;/code&gt; для обозначения верхнего предела версий сборки, например, &lt;code&gt;VERSION &amp;gt; v&quot;0.2-rc1+&quot;&lt;/code&gt; может использоваться для обозначения любой версии выше &lt;code&gt;0.2-rc1&lt;/code&gt; и любой из ее сборок: it вернет &lt;code&gt;false&lt;/code&gt; для версии &lt;code&gt;v&quot;0.2-rc1+win64&quot;&lt;/code&gt; и &lt;code&gt;true&lt;/code&gt; для &lt;code&gt;v&quot;0.2-rc2&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f1f671807b09bc4fbe1759ebf099879c030bdbf" translate="yes" xml:space="preserve">
          <source>Another operation that applies to some types is &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt;&lt;code&gt;supertype&lt;/code&gt;&lt;/a&gt;, which reveals a type's supertype. Only declared types (&lt;code&gt;DataType&lt;/code&gt;) have unambiguous supertypes:</source>
          <target state="translated">Другая операция, которая применяется к некоторым типам, - это &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt; &lt;code&gt;supertype&lt;/code&gt; &lt;/a&gt; , который раскрывает супертип типа. Только объявленные типы ( &lt;code&gt;DataType&lt;/code&gt; ) имеют однозначные супертипы:</target>
        </trans-unit>
        <trans-unit id="937a3e6d6c5697202a728546d5a94531a97deb3c" translate="yes" xml:space="preserve">
          <source>Another possibility is the following, which could useful to adapt to cases where the parameter &lt;code&gt;T&lt;/code&gt; would need to be matched more narrowly:</source>
          <target state="translated">Другая возможность заключается в следующем, который может быть полезен для адаптации к случаям, когда параметр &lt;code&gt;T&lt;/code&gt; должен быть согласован более узко:</target>
        </trans-unit>
        <trans-unit id="934eafc149de740d97fce8516adf5aa645737af2" translate="yes" xml:space="preserve">
          <source>Another useful non-standard string literal is the byte-array string literal: &lt;code&gt;b&quot;...&quot;&lt;/code&gt;. This form lets you use string notation to express read only literal byte arrays &amp;ndash; i.e. arrays of &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; values. The type of those objects is &lt;code&gt;CodeUnits{UInt8, String}&lt;/code&gt;. The rules for byte array literals are the following:</source>
          <target state="translated">Другой полезный нестандартный строковый литерал - это строковый литерал байтового массива: &lt;code&gt;b&quot;...&quot;&lt;/code&gt; . Эта форма позволяет использовать строковую нотацию для выражения массивов байтов только для чтения, то есть массивов значений &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; . Тип этих объектов - &lt;code&gt;CodeUnits{UInt8, String}&lt;/code&gt; . Правила для литералов байтовых массивов следующие:</target>
        </trans-unit>
        <trans-unit id="30b18c65665f6fdbc3c1e0c1e53afe0ef7b0746f" translate="yes" xml:space="preserve">
          <source>Another way to create a sparse array is to convert a dense array into a sparse array using the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">Другой способ создать разреженный массив - преобразовать плотный массив в разреженный массив с помощью функции &lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d71bbbddbab448cf2f4551f57f136f71cf39aeab" translate="yes" xml:space="preserve">
          <source>Another way to view expressions is with &lt;code&gt;Meta.show_sexpr&lt;/code&gt;, which displays the &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S-expression&lt;/a&gt; form of a given &lt;code&gt;Expr&lt;/code&gt;, which may look very familiar to users of Lisp. Here's an example illustrating the display on a nested &lt;code&gt;Expr&lt;/code&gt;:</source>
          <target state="translated">Другой способ просмотра выражений - это &lt;code&gt;Meta.show_sexpr&lt;/code&gt; , который отображает форму &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S-выражения&lt;/a&gt; данного &lt;code&gt;Expr&lt;/code&gt; , которая может показаться очень знакомой пользователям Lisp. Вот пример, иллюстрирующий отображение вложенного &lt;code&gt;Expr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5468d9df43f9dcdfb8b8b349ce3a001cd05b665d" translate="yes" xml:space="preserve">
          <source>Another way, which used to be the only correct way before the advent of triangular dispatch in Julia v0.6, is:</source>
          <target state="translated">Другой путь,который был единственно правильным до появления треугольной диспетчерской в Юлии v0.6:</target>
        </trans-unit>
        <trans-unit id="02cc2a69720bd8bf1661deb23018e16470c069da" translate="yes" xml:space="preserve">
          <source>Ant</source>
          <target state="translated">Ant</target>
        </trans-unit>
        <trans-unit id="e25592206c84c0ddd18d548ca6206d3d080aef04" translate="yes" xml:space="preserve">
          <source>Antenna With Bars</source>
          <target state="translated">Антенна с барами</target>
        </trans-unit>
        <trans-unit id="27823909809855dca3ee48ccda6c67818ef39511" translate="yes" xml:space="preserve">
          <source>Anticlockwise Contour Integral</source>
          <target state="translated">Интеграл контура против часовой стрелки</target>
        </trans-unit>
        <trans-unit id="777a29798f3d057ac8c6bab9cead4b05d966905b" translate="yes" xml:space="preserve">
          <source>Anticlockwise Downwards And Upwards Open Circle Arrows</source>
          <target state="translated">Стрелки открытия круга против часовой стрелки вниз и вверх.</target>
        </trans-unit>
        <trans-unit id="e5cdf19e981398168cc33d41c80123d3c30a5081" translate="yes" xml:space="preserve">
          <source>Anticlockwise Integration</source>
          <target state="translated">Интеграция против часовой стрелки</target>
        </trans-unit>
        <trans-unit id="4ffeb49d53fc5643e555514643bbb1df4f049794" translate="yes" xml:space="preserve">
          <source>Anticlockwise Open Circle Arrow</source>
          <target state="translated">Стрелка открытия круга против часовой стрелки</target>
        </trans-unit>
        <trans-unit id="a52271b2a7c6cb5d3c1c456396438c1ddb68a4f9" translate="yes" xml:space="preserve">
          <source>Anticlockwise Top Semicircle Arrow</source>
          <target state="translated">Стрелка верхнего полукруга против часовой стрелки</target>
        </trans-unit>
        <trans-unit id="b661ec502ce7eec63576ef6980de816514a82733" translate="yes" xml:space="preserve">
          <source>Any changes you make to the array values (e.g., &lt;code&gt;A[3] = 0&lt;/code&gt;) will also change the values on disk</source>
          <target state="translated">Любые изменения, которые вы вносите в значения массива (например, &lt;code&gt;A[3] = 0&lt;/code&gt; ), также изменят значения на диске.</target>
        </trans-unit>
        <trans-unit id="3c5cca19d4f5741a5bb3f294473a79e10b7adbb5" translate="yes" xml:space="preserve">
          <source>Any code that is performance critical or being benchmarked should be inside a function.</source>
          <target state="translated">Любой код,критичный по производительности или подвергающийся бенчмаркингу,должен быть внутри функции.</target>
        </trans-unit>
        <trans-unit id="ba5b886162caf15daa7473ff8070c0f84e6be971" translate="yes" xml:space="preserve">
          <source>Any custom array of scalar indices that is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;</source>
          <target state="translated">Любой настраиваемый массив скалярных индексов, являющийся подтипом &lt;code&gt;AbstractArray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2973d806e6f61582719d2e58b280fa916079cead" translate="yes" xml:space="preserve">
          <source>Any custom testset type (subtype of &lt;code&gt;AbstractTestSet&lt;/code&gt;) can be given and it will also be used for any nested &lt;code&gt;@testset&lt;/code&gt; invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.</source>
          <target state="translated">Можно указать любой настраиваемый тип набора тестов (подтип &lt;code&gt;AbstractTestSet&lt;/code&gt; ), и он также будет использоваться для любых вложенных вызовов &lt;code&gt;@testset&lt;/code&gt; . Данные параметры применяются только к тому набору тестов, в котором они указаны. Тип набора тестов по умолчанию не имеет никаких параметров.</target>
        </trans-unit>
        <trans-unit id="31544d9a7acaba7c1156850319c97b90ce13cb9b" translate="yes" xml:space="preserve">
          <source>Any error stops &lt;code&gt;pmap&lt;/code&gt; from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument &lt;code&gt;on_error&lt;/code&gt; which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.</source>
          <target state="translated">Любая ошибка не позволяет &lt;code&gt;pmap&lt;/code&gt; обрабатывать оставшуюся часть коллекции. Чтобы переопределить это поведение, вы можете указать функцию обработки ошибок через аргумент &lt;code&gt;on_error&lt;/code&gt; , который принимает единственный аргумент, то есть исключение. Функция может остановить обработку, повторно выдав ошибку, или, чтобы продолжить, вернуть любое значение, которое затем возвращается вместе с результатами вызывающей стороне.</target>
        </trans-unit>
        <trans-unit id="fc28c907456157bf36df33491d1dd60e94bbee1e" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;f&lt;/code&gt; are printed to &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; on the remote worker.</source>
          <target state="translated">Любые исключения, вызванные &lt;code&gt;f&lt;/code&gt; , выводятся в &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; удаленного работника.</target>
        </trans-unit>
        <trans-unit id="74b6431314c500d9367b1ee7e25039a738c25b54" translate="yes" xml:space="preserve">
          <source>Any keyword arguments passed to &lt;code&gt;eigen&lt;/code&gt; are passed through to the lower-level &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt;&lt;code&gt;eigen!&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Любые аргументы ключевого слова, переданные в &lt;code&gt;eigen&lt;/code&gt; , передаются на собственный нижний уровень &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt; &lt;code&gt;eigen!&lt;/code&gt; &lt;/a&gt;функция.</target>
        </trans-unit>
        <trans-unit id="409446f789565d016b86ac80357893528260dc10" translate="yes" xml:space="preserve">
          <source>Any number of expressions many be documented together in this way. This syntax can be useful when two functions are related, such as non-mutating and mutating versions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f!&lt;/code&gt;.</source>
          <target state="translated">Таким способом можно документировать вместе любое количество выражений. Этот синтаксис может быть полезен, когда две функции связаны, например неизменяемые и изменяемые версии &lt;code&gt;f&lt;/code&gt; и &lt;code&gt;f!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="0687dd78d1b30c2783be213375797ef6105a33d2" translate="yes" xml:space="preserve">
          <source>Any object that defines this function is iterable and can be used in the &lt;a href=&quot;../../base/collections/index#lib-collections-iteration&quot;&gt;many functions that rely upon iteration&lt;/a&gt;. It can also be used directly in a &lt;a href=&quot;../../base/base/index#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop since the syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f23555229abe2136eae4796de9adb4981c0efa50" translate="yes" xml:space="preserve">
          <source>Any object that defines this function is iterable and can be used in the &lt;a href=&quot;../../base/collections/index#lib-collections-iteration-1&quot;&gt;many functions that rely upon iteration&lt;/a&gt;. It can also be used directly in a &lt;a href=&quot;../../base/base/index#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop since the syntax:</source>
          <target state="translated">Любой объект, определяющий эту функцию, является итеративным и может использоваться во &lt;a href=&quot;../../base/collections/index#lib-collections-iteration-1&quot;&gt;многих функциях, которые зависят от итерации&lt;/a&gt; . Его также можно использовать непосредственно в цикле &lt;a href=&quot;../../base/base/index#for&quot;&gt; &lt;code&gt;for&lt;/code&gt; ,&lt;/a&gt; поскольку синтаксис:</target>
        </trans-unit>
        <trans-unit id="14a4faaa9263f21666bc118177b8030fb0ebed4a" translate="yes" xml:space="preserve">
          <source>Any object that is not a type is not an instance of &lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="translated">Любой объект, не являющийся типом, не является экземпляром &lt;code&gt;Type&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5099776907c27052bfc78cf7373b0d68a21ec5f2" translate="yes" xml:space="preserve">
          <source>Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.</source>
          <target state="translated">Любая операция,которая приводит к ошибке,вероятно,в настоящее время не реализована и должна быть размещена как ошибка,чтобы ее можно было решить.</target>
        </trans-unit>
        <trans-unit id="f91c503ff4942107fdfd3a5ddc75b8099dc08779" translate="yes" xml:space="preserve">
          <source>Any process with a reference to a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; can put and take items from the channel. Data is automatically sent to (or retrieved from) the process a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; is associated with.</source>
          <target state="translated">Любой процесс со ссылкой на &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; может помещать и принимать элементы из канала. Данные автоматически отправляются (или извлекаются) процессу, с которым связан &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c010ba08796a2114052ab863fb8a9d226c9dd13" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Backslash Bar</source>
          <target state="translated">Функциональная символьная полоса обратной связи</target>
        </trans-unit>
        <trans-unit id="36d891e0ee22f437cc243dd2e9ea0702d961b80f" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Circle Stile</source>
          <target state="translated">Apl Функциональный символ Круглый пруток</target>
        </trans-unit>
        <trans-unit id="39c46b8ef7910ae74868b76b650aa07198ab578c" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol I-Beam</source>
          <target state="translated">Функциональный символ I-Beam</target>
        </trans-unit>
        <trans-unit id="d0546025dd10b13f2435dc3fcaee9e017037a2e5" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Quad Question</source>
          <target state="translated">Функциональное обозначение Четырехсторонний вопрос</target>
        </trans-unit>
        <trans-unit id="4d565c437bb750fa8a1eb8171844a8039a97d351" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Quad Up Caret</source>
          <target state="translated">Apl Функциональный символ Quad Up Caret</target>
        </trans-unit>
        <trans-unit id="2b164c5aca8328b895ebe3a8c42bb636c6e38b33" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Slash Bar</source>
          <target state="translated">Apl Функциональный символ косая черта</target>
        </trans-unit>
        <trans-unit id="259f6ae1ad06c26f4f50971a4ed64fd704fd9a77" translate="yes" xml:space="preserve">
          <source>Append &lt;code&gt;!&lt;/code&gt; to names of functions that modify their arguments</source>
          <target state="translated">Добавить &lt;code&gt;!&lt;/code&gt; к именам функций, которые изменяют свои аргументы</target>
        </trans-unit>
        <trans-unit id="93f34880658a83722dbec3227ce96d931d512e39" translate="yes" xml:space="preserve">
          <source>Append an item &lt;code&gt;v&lt;/code&gt; to the channel &lt;code&gt;c&lt;/code&gt;. Blocks if the channel is full.</source>
          <target state="translated">Добавьте элемент &lt;code&gt;v&lt;/code&gt; к каналу &lt;code&gt;c&lt;/code&gt; . Блокирует, если канал заполнен.</target>
        </trans-unit>
        <trans-unit id="b03f369e152e908d0c3e87c0759a78a3bbb83fd8" translate="yes" xml:space="preserve">
          <source>Applied to a function argument name, hints to the compiler that the method should not be specialized for different types of that argument, but instead to use precisely the declared type for each argument. This is only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument list, or in the function body. When applied to an argument, the macro must wrap the entire argument expression. When used in a function body, the macro must occur in statement position and before any code.</source>
          <target state="translated">Применительно к имени аргумента функции,подсказывает компилятору,что метод не должен быть специализированным для различных типов этого аргумента,а должен использовать точно объявленный тип для каждого аргумента.Это лишь подсказка,чтобы избежать избыточного генерирования кода.Может быть применен к аргументу в формальном списке аргументов или в теле функции.При применении к аргументу макрос должен обернуть выражение аргумента целиком.При использовании в теле функции макрос должен находиться в позиции оператора и перед любым кодом.</target>
        </trans-unit>
        <trans-unit id="8ab87eebb7a11b086ff8353783cc2be68600a9ff" translate="yes" xml:space="preserve">
          <source>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple &lt;code&gt;(filename,line)&lt;/code&gt; giving the location for the method that would be called for those arguments. It calls out to the &lt;code&gt;functionloc&lt;/code&gt; function.</source>
          <target state="translated">Применительно к вызову функции или макроса он оценивает аргументы для указанного вызова и возвращает кортеж &lt;code&gt;(filename,line)&lt;/code&gt; указывающий местоположение метода, который будет вызываться для этих аргументов. Он вызывает &lt;code&gt;functionloc&lt;/code&gt; functionloc.</target>
        </trans-unit>
        <trans-unit id="10b1d88dbbba24ca44bfc0cd98b524dd2c753624" translate="yes" xml:space="preserve">
          <source>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns the &lt;code&gt;Method&lt;/code&gt; object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the &lt;code&gt;which&lt;/code&gt; function.</source>
          <target state="translated">Применительно к вызову функции или макроса он оценивает аргументы указанного вызова и возвращает объект &lt;code&gt;Method&lt;/code&gt; для метода, который будет вызван для этих аргументов. Применительно к переменной он возвращает модуль, в котором была привязана переменная. Он вызывает функцию &lt;code&gt;which&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbb092978ae173971f51dbbabbad7be81b9e017d" translate="yes" xml:space="preserve">
          <source>Applies a function to the preceding argument. This allows for easy function chaining.</source>
          <target state="translated">Применяет функцию к предыдущему аргументу.Это позволяет легко связать функции.</target>
        </trans-unit>
        <trans-unit id="df9997f06ef19d21e85df7f2a8d3fde509d61f00" translate="yes" xml:space="preserve">
          <source>Apply function &lt;code&gt;f&lt;/code&gt; to each element(s) in &lt;code&gt;itrs&lt;/code&gt;, and then reduce the result using the binary function &lt;code&gt;op&lt;/code&gt;. If provided, &lt;code&gt;init&lt;/code&gt; must be a neutral element for &lt;code&gt;op&lt;/code&gt; that will be returned for empty collections. It is unspecified whether &lt;code&gt;init&lt;/code&gt; is used for non-empty collections. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">Примените функцию &lt;code&gt;f&lt;/code&gt; к каждому элементу (ам) в &lt;code&gt;itrs&lt;/code&gt; , а затем уменьшите результат, используя двоичную функцию &lt;code&gt;op&lt;/code&gt; . Если указано, &lt;code&gt;init&lt;/code&gt; должен быть нейтральным элементом для &lt;code&gt;op&lt;/code&gt; , который будет возвращен для пустых коллекций. Не указано, используется ли &lt;code&gt;init&lt;/code&gt; для непустых коллекций. В общем, нужно будет предоставить &lt;code&gt;init&lt;/code&gt; для работы с пустыми коллекциями.</target>
        </trans-unit>
        <trans-unit id="abde153c82249beeebbf8921343e0e5bfbfeae0c" translate="yes" xml:space="preserve">
          <source>Apply function &lt;code&gt;f&lt;/code&gt; to the git repository &lt;code&gt;repo&lt;/code&gt;, taking a &lt;a href=&quot;#LibGit2.snapshot&quot;&gt;&lt;code&gt;snapshot&lt;/code&gt;&lt;/a&gt; before applying &lt;code&gt;f&lt;/code&gt;. If an error occurs within &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;repo&lt;/code&gt; will be returned to its snapshot state using &lt;a href=&quot;#LibGit2.restore&quot;&gt;&lt;code&gt;restore&lt;/code&gt;&lt;/a&gt;. The error which occurred will be rethrown, but the state of &lt;code&gt;repo&lt;/code&gt; will not be corrupted.</source>
          <target state="translated">Применить функцию &lt;code&gt;f&lt;/code&gt; на мерзавца хранилище &lt;code&gt;repo&lt;/code&gt; , принимая &lt;a href=&quot;#LibGit2.snapshot&quot;&gt; &lt;code&gt;snapshot&lt;/code&gt; &lt;/a&gt; перед применением &lt;code&gt;f&lt;/code&gt; . Если в &lt;code&gt;f&lt;/code&gt; возникает ошибка , &lt;code&gt;repo&lt;/code&gt; будет возвращено в состояние моментального снимка с помощью &lt;a href=&quot;#LibGit2.restore&quot;&gt; &lt;code&gt;restore&lt;/code&gt; &lt;/a&gt; . Произошедшая ошибка будет воспроизведена повторно, но состояние &lt;code&gt;repo&lt;/code&gt; не будет нарушено.</target>
        </trans-unit>
        <trans-unit id="f6b68e61d0fe49a5c4e043952feeeef90f5166fd" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to each element of array &lt;code&gt;A&lt;/code&gt; and take the mean over dimensions &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3a1ca726a424329c0ade2ec9d0c7202e4993c0" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to each element of collection &lt;code&gt;itr&lt;/code&gt; and take the mean.</source>
          <target state="translated">Примените функцию &lt;code&gt;f&lt;/code&gt; к каждому элементу коллекции &lt;code&gt;itr&lt;/code&gt; и возьмите среднее значение.</target>
        </trans-unit>
        <trans-unit id="939711ce79fa9b7db5fc7f83d19a0a73f949253d" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAbstractString%7D&quot;&gt;&lt;code&gt;mktemp(parent)&lt;/code&gt;&lt;/a&gt; and remove the temporary file upon completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc364f76459203bdb0d1fe7d66f3331843d77fb" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktemp(parent)&lt;/code&gt;&lt;/a&gt; and remove the temporary file upon completion.</source>
          <target state="translated">Примените функцию &lt;code&gt;f&lt;/code&gt; к результату &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktemp(parent)&lt;/code&gt; &lt;/a&gt; и удалите временный файл по завершении.</target>
        </trans-unit>
        <trans-unit id="2dbf8268105b7901616a7ac6d30feda3dbda5ed9" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAbstractString%7D&quot;&gt;&lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt;&lt;/a&gt; and remove the temporary directory all of its contents upon completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d833cb24f42c76580b0926f643d9e169ba73703" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt;&lt;/a&gt; and remove the temporary directory all of its contents upon completion.</source>
          <target state="translated">Примените функцию &lt;code&gt;f&lt;/code&gt; к результату &lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt; &lt;/a&gt; и удалите из временного каталога все его содержимое по завершении.</target>
        </trans-unit>
        <trans-unit id="c30fb3d590d21605851a7bb8d8b8ee272dad26bb" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;code&gt;open(args...; kwargs...)&lt;/code&gt; and close the resulting file descriptor upon completion.</source>
          <target state="translated">Примените функцию &lt;code&gt;f&lt;/code&gt; к результату &lt;code&gt;open(args...; kwargs...)&lt;/code&gt; и закройте получившийся дескриптор файла по завершении.</target>
        </trans-unit>
        <trans-unit id="47f0920b156c6fa088e0adafa06695882e8a1ce9" translate="yes" xml:space="preserve">
          <source>Applying it to any other types of arguments will result in a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Применение его к любым другим типам аргументов приведет к &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7fea34195bef9eda50f65dd470da25827c0b940a" translate="yes" xml:space="preserve">
          <source>Approaches The Limit</source>
          <target state="translated">Подходы к границе</target>
        </trans-unit>
        <trans-unit id="36af3f4430ffa874f1e260736d3734767175bb17" translate="yes" xml:space="preserve">
          <source>Approximate floating point number &lt;code&gt;x&lt;/code&gt; as a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; number with components of the given integer type. The result will differ from &lt;code&gt;x&lt;/code&gt; by no more than &lt;code&gt;tol&lt;/code&gt;.</source>
          <target state="translated">Приблизительное число &lt;code&gt;x&lt;/code&gt; с плавающей запятой как &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; число с компонентами заданного целочисленного типа. Результат будет отличаться от &lt;code&gt;x&lt;/code&gt; не более чем на &lt;code&gt;tol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86cdef7d39fe1e6ca08d22290dae380c71b22482" translate="yes" xml:space="preserve">
          <source>Approximately But Not Actually Equal To</source>
          <target state="translated">Приблизительно,но не равнозначно</target>
        </trans-unit>
        <trans-unit id="a398789ce28e88dc00a7a33731c788d8238f5ac2" translate="yes" xml:space="preserve">
          <source>Approximately Equal Or Equal To</source>
          <target state="translated">Приблизительно равный или равный</target>
        </trans-unit>
        <trans-unit id="110d059e67ed3348bbc8fc7fc9a8a4830c0240e6" translate="yes" xml:space="preserve">
          <source>Approximately Equal To</source>
          <target state="translated">Приблизительно равны</target>
        </trans-unit>
        <trans-unit id="9d91d063fbecc40e31adb06a0bdab3785430bae5" translate="yes" xml:space="preserve">
          <source>Approximately Equal To Or The Image Of</source>
          <target state="translated">Приблизительно равное или похожее на изображение</target>
        </trans-unit>
        <trans-unit id="3e026e6d2a8adcf8897cf07eecff80b0380f276d" translate="yes" xml:space="preserve">
          <source>Aquarius</source>
          <target state="translated">Aquarius</target>
        </trans-unit>
        <trans-unit id="d037d2935a703a621340fc357146d1188aae9fef" translate="yes" xml:space="preserve">
          <source>Arbitrary Precision Arithmetic</source>
          <target state="translated">Арифметика произвольной точности</target>
        </trans-unit>
        <trans-unit id="ec0bee1bcca32dcc4d82f1af9b35b9a4e833d243" translate="yes" xml:space="preserve">
          <source>Arbitrary precision floating point number type.</source>
          <target state="translated">Тип числа с плавающей точкой произвольной точности.</target>
        </trans-unit>
        <trans-unit id="f38bd661446c82eb63be7e7f1e9af6fa5a6cfaaa" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integer type.</source>
          <target state="translated">Целый тип произвольной точности.</target>
        </trans-unit>
        <trans-unit id="853a983f6b8abdb9ecba43da2ceda1641c9d519f" translate="yes" xml:space="preserve">
          <source>Arc</source>
          <target state="translated">Arc</target>
        </trans-unit>
        <trans-unit id="dbf6ae45c2a646ca9f7ecaf4480259128f85d936" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;waitfor&lt;/code&gt; specifies how long to wait for the workers to shut down:</source>
          <target state="translated">Аргумент &lt;code&gt;waitfor&lt;/code&gt; указывает, как долго ждать завершения рабочих процессов :</target>
        </trans-unit>
        <trans-unit id="0d26bcd474b23ab47569a6a1a0ca62a2c9eb9205" translate="yes" xml:space="preserve">
          <source>Argument Passing Behavior</source>
          <target state="translated">Поведение при проходе через памятники</target>
        </trans-unit>
        <trans-unit id="938cc4ebe6a5288bbfb1485b585ece93ff21a6fc" translate="yes" xml:space="preserve">
          <source>Argument destructuring</source>
          <target state="translated">Разрушение памятников</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="ccfbfffe30467d0556e9822f3a3009bcd6857e77" translate="yes" xml:space="preserve">
          <source>Arguments to be passed to the LLVM backend.</source>
          <target state="translated">Аргументы будут переданы в LLVM бэкэнд.</target>
        </trans-unit>
        <trans-unit id="f480e0686764de02407b1abe1545f3d34ae95935" translate="yes" xml:space="preserve">
          <source>Aries</source>
          <target state="translated">Aries</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">арифметические операторы</target>
        </trans-unit>
        <trans-unit id="6ba961184ebd546b1a3177abda88c03934fb089a" translate="yes" xml:space="preserve">
          <source>Arithmetic on the &lt;code&gt;Ptr&lt;/code&gt; type in Julia (e.g. using &lt;code&gt;+&lt;/code&gt;) does not behave the same as C's pointer arithmetic. Adding an integer to a &lt;code&gt;Ptr&lt;/code&gt; in Julia always moves the pointer by some number of &lt;em&gt;bytes&lt;/em&gt;, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.</source>
          <target state="translated">Арифметика над типом &lt;code&gt;Ptr&lt;/code&gt; в Julia (например, с использованием &lt;code&gt;+&lt;/code&gt; ) не ведет себя так же, как арифметика указателя C. Добавление целого числа к &lt;code&gt;Ptr&lt;/code&gt; в Julia всегда перемещает указатель на некоторое количество &lt;em&gt;байтов&lt;/em&gt; , а не элементов. Таким образом, значения адреса, полученные из арифметики указателей, не зависят от типов элементов указателей.</target>
        </trans-unit>
        <trans-unit id="1595977488274506444762a7d4b561a282b06666" translate="yes" xml:space="preserve">
          <source>Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse matrices work in the same way as dense matrices. Indexing operations, especially assignment, are expensive, when carried out one element at a time. In many cases it may be better to convert the sparse matrix into &lt;code&gt;(I,J,V)&lt;/code&gt; format using &lt;a href=&quot;#SparseArrays.findnz&quot;&gt;&lt;code&gt;findnz&lt;/code&gt;&lt;/a&gt;, manipulate the values or the structure in the dense vectors &lt;code&gt;(I,J,V)&lt;/code&gt;, and then reconstruct the sparse matrix.</source>
          <target state="translated">Арифметические операции с разреженными матрицами также работают так же, как и с плотными матрицами. Индексирование, присвоение и объединение разреженных матриц работают так же, как и плотные матрицы. Операции индексирования, особенно присваивание, являются дорогостоящими, когда выполняются по одному элементу за раз. Во многих случаях может быть лучше преобразовать разреженную матрицу в формат &lt;code&gt;(I,J,V)&lt;/code&gt; с помощью &lt;a href=&quot;#SparseArrays.findnz&quot;&gt; &lt;code&gt;findnz&lt;/code&gt; &lt;/a&gt; , манипулировать значениями или структурой в плотных векторах &lt;code&gt;(I,J,V)&lt;/code&gt; , а затем восстановить разреженную матрицу.</target>
        </trans-unit>
        <trans-unit id="6b6663a1569cf067a646e962adc2c809327f2a1d" translate="yes" xml:space="preserve">
          <source>Array and Vectorized Operators and Functions</source>
          <target state="translated">Массив и векторизованные операторы и функции</target>
        </trans-unit>
        <trans-unit id="272896e88f7076a29401b63fcba504c622f100cf" translate="yes" xml:space="preserve">
          <source>Array functions</source>
          <target state="translated">Функции массива</target>
        </trans-unit>
        <trans-unit id="051f0d6bd098df06454138ddf1bfe22d07625d2a" translate="yes" xml:space="preserve">
          <source>Array literals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6e2a8a6e3331d091fde070355048d6a50fbdb0" translate="yes" xml:space="preserve">
          <source>Array traits</source>
          <target state="translated">Черты массива</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="a0d486c491afc0a11a53591657e1748ec0e15c70" translate="yes" xml:space="preserve">
          <source>Arrays With Missing Values</source>
          <target state="translated">Массивы с отсутствующими значениями</target>
        </trans-unit>
        <trans-unit id="14eed9a557bdf809c1d72ce7ef06aab3ac832f66" translate="yes" xml:space="preserve">
          <source>Arrays allowing for missing values can be constructed with the standard syntax. Use &lt;code&gt;Array{Union{Missing, T}}(missing, dims)&lt;/code&gt; to create arrays filled with missing values:</source>
          <target state="translated">Массивы с пропущенными значениями могут быть построены с использованием стандартного синтаксиса. Используйте &lt;code&gt;Array{Union{Missing, T}}(missing, dims)&lt;/code&gt; для создания массивов, заполненных отсутствующими значениями:</target>
        </trans-unit>
        <trans-unit id="d5a5bd6d399fb4d5330301010e8df836c12ff36c" translate="yes" xml:space="preserve">
          <source>Arrays are stored contiguously in memory, lending themselves to CPU vectorization and fewer memory accesses due to caching. These are the same reasons that it is recommended to access arrays in column-major order (see above). Irregular access patterns and non-contiguous views can drastically slow down computations on arrays because of non-sequential memory access.</source>
          <target state="translated">Массивы непрерывно хранятся в памяти,что позволяет использовать векторизацию процессора и уменьшает доступ к памяти за счет кэширования.По этим же причинам рекомендуется обращаться к массивам в порядке столбцов (см.выше).Нерегулярные схемы доступа и несмежные представления могут резко замедлить вычисления в массивах из-за непоследовательного доступа к памяти.</target>
        </trans-unit>
        <trans-unit id="2cd16e2399bb6c0b0c5a0ea05fbdc7c6bf1a6ee2" translate="yes" xml:space="preserve">
          <source>Arrays can also be directly constructed with square braces; the syntax &lt;code&gt;[A, B, C, ...]&lt;/code&gt; creates a one dimensional array (i.e., a vector) containing the comma-separated arguments as its elements. The element type (&lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;) of the resulting array is automatically determined by the types of the arguments inside the braces. If all the arguments are the same type, then that is its &lt;code&gt;eltype&lt;/code&gt;. If they all have a common &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;promotion type&lt;/a&gt; then they get converted to that type using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; and that type is the array's &lt;code&gt;eltype&lt;/code&gt;. Otherwise, a heterogeneous array that can hold anything &amp;mdash; a &lt;code&gt;Vector{Any}&lt;/code&gt; &amp;mdash; is constructed; this includes the literal &lt;code&gt;[]&lt;/code&gt; where no arguments are given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804cb53914986dde77e394241b65af0a2493a576" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed and also concatenated using the following functions:</source>
          <target state="translated">Массивы могут быть построены,а также объединены с помощью следующих функций:</target>
        </trans-unit>
        <trans-unit id="9a14bfc250b9401c09f27dc8758fb64c6d1849ec" translate="yes" xml:space="preserve">
          <source>Arrays can easily be sorted according to an arbitrary transformation of their values:</source>
          <target state="translated">Массивы легко сортируются в соответствии с произвольным преобразованием их значений:</target>
        </trans-unit>
        <trans-unit id="aa747a7d1d6f608a0335baa21f343f3341f91936" translate="yes" xml:space="preserve">
          <source>Arrays containing missing values can be created like other arrays</source>
          <target state="translated">Массивы,содержащие пропущенные значения,могут быть созданы,как и другие массивы</target>
        </trans-unit>
        <trans-unit id="ca4d2abddb6904030658a8e61f4450fbbd938fdf" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;CartesianIndex{N}&lt;/code&gt; (see below for more details)</source>
          <target state="translated">Массивы &lt;code&gt;CartesianIndex{N}&lt;/code&gt; (подробнее см. Ниже)</target>
        </trans-unit>
        <trans-unit id="075c9f606a29f390bc16b51c28be22f3d814f931" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;CartesianIndex{N}&lt;/code&gt; are also supported. They represent a collection of scalar indices that each span &lt;code&gt;N&lt;/code&gt; dimensions, enabling a form of indexing that is sometimes referred to as pointwise indexing. For example, it enables accessing the diagonal elements from the first &quot;page&quot; of &lt;code&gt;A&lt;/code&gt; from above:</source>
          <target state="translated">Также поддерживаются массивы &lt;code&gt;CartesianIndex{N}&lt;/code&gt; . Они представляют собой набор скалярных индексов, каждый из которых охватывает &lt;code&gt;N&lt;/code&gt; измерений, что позволяет использовать форму индексации, которую иногда называют точечной индексацией. Например, он позволяет получить доступ к диагональным элементам с первой &amp;laquo;страницы&amp;raquo; &lt;code&gt;A&lt;/code&gt; сверху:</target>
        </trans-unit>
        <trans-unit id="3d6407685d9a3a1c2957e4566ba6f78f8b15e030" translate="yes" xml:space="preserve">
          <source>Arrays of booleans, which select elements at their &lt;code&gt;true&lt;/code&gt; indices (see below for more details)</source>
          <target state="translated">Массивы логических значений, которые выбирают элементы по их &lt;code&gt;true&lt;/code&gt; индексам (подробнее см. Ниже)</target>
        </trans-unit>
        <trans-unit id="36fa144c795f904dbf232a8e653525a3d0ba71b7" translate="yes" xml:space="preserve">
          <source>Arrays of parameters can be expressed with &lt;code&gt;NTuple&lt;/code&gt;. For example, the struct in C notation written as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0969583730964394602b74ac92dacfa507bac99b" translate="yes" xml:space="preserve">
          <source>Arrays of parameters can be expressed with &lt;code&gt;NTuple&lt;/code&gt;:</source>
          <target state="translated">Массивы параметров можно выразить с помощью &lt;code&gt;NTuple&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7c5854ca021fe589728b87432b4e259d1c8248d3" translate="yes" xml:space="preserve">
          <source>Arrays of plain data types exhibit the same behavior.</source>
          <target state="translated">Массивы простых типов данных демонстрируют одинаковое поведение.</target>
        </trans-unit>
        <trans-unit id="6f655e915f910f157fee32ed03ecdc2ad3b9d1df" translate="yes" xml:space="preserve">
          <source>Arrays of unknown size (C99-compliant variable length structs specified by &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;[0]&lt;/code&gt;) are not directly supported. Often the best way to deal with these is to deal with the byte offsets directly. For example, if a C library declared a proper string type and returned a pointer to it:</source>
          <target state="translated">Массивы неизвестного размера (совместимые с C99 структуры переменной длины, указанные в &lt;code&gt;[]&lt;/code&gt; или &lt;code&gt;[0]&lt;/code&gt; ) напрямую не поддерживаются. Часто лучший способ справиться с этим - напрямую работать с байтовыми смещениями. Например, если библиотека C объявила правильный строковый тип и вернула на него указатель:</target>
        </trans-unit>
        <trans-unit id="0a4fe1e9982ed026b7b75e0b6640d07c49b347a1" translate="yes" xml:space="preserve">
          <source>Arrow Pointing Rightwards Then Curving Downwards</source>
          <target state="translated">Стрелка,направленная вправо,затем кривая вниз.</target>
        </trans-unit>
        <trans-unit id="d5a8479391be26e8e773c26793b7bf6d542adbb0" translate="yes" xml:space="preserve">
          <source>Arrow Pointing Rightwards Then Curving Upwards</source>
          <target state="translated">Стрелка,направленная вправо,затем кривая вверх.</target>
        </trans-unit>
        <trans-unit id="56cbb3f16cd1ca93b5689f5cddec6758302ebb86" translate="yes" xml:space="preserve">
          <source>Arthur C. Clarke, &lt;em&gt;Profiles of the Future&lt;/em&gt; (1961): Clarke's Third Law.</source>
          <target state="translated">Артур Кларк, &lt;em&gt;Профили будущего&lt;/em&gt; (1961): Третий закон Кларка.</target>
        </trans-unit>
        <trans-unit id="4be4b541c7c3be1117af5726c8607678780b96ca" translate="yes" xml:space="preserve">
          <source>Articulated Lorry</source>
          <target state="translated">Грузовой автомобиль с шарнирным соединением</target>
        </trans-unit>
        <trans-unit id="b1aa57e2147913434d8d33e99a2a302c3d412560" translate="yes" xml:space="preserve">
          <source>Artist Palette</source>
          <target state="translated">Художественная палитра</target>
        </trans-unit>
        <trans-unit id="07d39beaf4ec4f6ab344410b6e2ddcbafeee07b5" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;missing&lt;/code&gt; is a normal Julia object, this propagation rule only works for functions which have opted in to implement this behavior. This can be achieved either via a specific method defined for arguments of type &lt;code&gt;Missing&lt;/code&gt;, or simply by accepting arguments of this type, and passing them to functions which propagate them (like standard math operators). Packages should consider whether it makes sense to propagate missing values when defining new functions, and define methods appropriately if that is the case. Passing a &lt;code&gt;missing&lt;/code&gt; value to a function for which no method accepting arguments of type &lt;code&gt;Missing&lt;/code&gt; is defined throws a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;, just like for any other type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b55172c20f3a3018d935f94f15f420d19dd799" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;missing&lt;/code&gt; is a normal Julia object, this propagation rule only works for functions which have opted in to implement this behavior. This can be achieved either via a specific method defined for arguments of type &lt;code&gt;Missing&lt;/code&gt;, or simply by accepting arguments of this type, and passing them to functions which propagate them (like standard operators). Packages should consider whether it makes sense to propagate missing values when defining new functions, and define methods appropriately if that is the case. Passing a &lt;code&gt;missing&lt;/code&gt; value to a function for which no method accepting arguments of type &lt;code&gt;Missing&lt;/code&gt; is defined throws a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;, just like for any other type.</source>
          <target state="translated">Поскольку &lt;code&gt;missing&lt;/code&gt; обычный объект Julia, это правило распространения работает только для функций, которые выбрали реализацию этого поведения. Это может быть достигнуто либо с помощью специального метода, определенного для аргументов типа &lt;code&gt;Missing&lt;/code&gt; , либо просто путем принятия аргументов этого типа и передачи их функциям, которые их передают (например, стандартные операторы). Пакеты должны учитывать, имеет ли смысл распространять отсутствующие значения при определении новых функций, и соответствующим образом определять методы, если это так. Передача &lt;code&gt;missing&lt;/code&gt; значения функции, для которой не определен метод, принимающий аргументы типа &lt;code&gt;Missing&lt;/code&gt; , вызывает &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; , как и для любого другого типа.</target>
        </trans-unit>
        <trans-unit id="6c7f12d083082a8b358b33648f5e922218bf6328" translate="yes" xml:space="preserve">
          <source>As Julia &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; values are represented according to the ISO 8601 standard, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; was chosen as base (or &quot;rounding epoch&quot;) from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this differs slightly from Julia's internal representation of &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; s using Rata Die notation; but since the ISO 8601 standard is most visible to the end user, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; was chosen as the rounding epoch instead of the &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; used internally to minimize confusion.)</source>
          <target state="translated">Поскольку значения Julia &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; представлены в соответствии со стандартом ISO 8601, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; было выбрано в качестве базы (или &amp;laquo;эпохи округления&amp;raquo;), с которой начинается отсчет дней (и миллисекунд), используемых при округлении. расчеты. (Обратите внимание, что это немного отличается от внутреннего представления Джулии &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; s с использованием нотации Rata Die; но поскольку стандарт ISO 8601 наиболее заметен для конечного пользователя, в качестве эпохи округления был выбран &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; используется внутри, чтобы минимизировать путаницу.)</target>
        </trans-unit>
        <trans-unit id="018f199ee4bce38a37225bf7cf902f1a94cfebe8" translate="yes" xml:space="preserve">
          <source>As a bonus, all period arithmetic objects work directly with ranges:</source>
          <target state="translated">В качестве бонуса,арифметические объекты всех периодов работают непосредственно с диапазонами:</target>
        </trans-unit>
        <trans-unit id="1d37396b19dff556a9f0928d3fb79a1f9a87b4bb" translate="yes" xml:space="preserve">
          <source>As a complete but simple example, the following calls the &lt;code&gt;clock&lt;/code&gt; function from the standard C library on most Unix-derived systems:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d0293122d46f12e2772f00b98fe234a30f7099" translate="yes" xml:space="preserve">
          <source>As a complete but simple example, the following calls the &lt;code&gt;clock&lt;/code&gt; function from the standard C library:</source>
          <target state="translated">В качестве полного, но простого примера ниже приведем &lt;code&gt;clock&lt;/code&gt; функции часов из стандартной библиотеки C:</target>
        </trans-unit>
        <trans-unit id="539ad19d9070448cc3bfdfe89f4f38e027fe5c6c" translate="yes" xml:space="preserve">
          <source>As a convenience, constructing a &lt;code&gt;CartesianIndices&lt;/code&gt; from an array makes a range of its indices.</source>
          <target state="translated">Для удобства при построении &lt;code&gt;CartesianIndices&lt;/code&gt; из массива создается диапазон его индексов.</target>
        </trans-unit>
        <trans-unit id="0b5625230c61073f2e6e2ee043f6240a0a3c7016" translate="yes" xml:space="preserve">
          <source>As a general rule, the Base library uses the following order of arguments to functions, as applicable:</source>
          <target state="translated">Как правило,библиотека Base использует следующий порядок аргументов к функциям,если это применимо:</target>
        </trans-unit>
        <trans-unit id="0aeaa033e5a0e531782e60f4be3543a306118072" translate="yes" xml:space="preserve">
          <source>As a heuristic, Julia avoids automatically specializing on argument type parameters in three specific cases: &lt;code&gt;Type&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;, and &lt;code&gt;Vararg&lt;/code&gt;. Julia will always specialize when the argument is used within the method, but not if the argument is just passed through to another function. This usually has no performance impact at runtime and &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/functions/#compiler-efficiency-issues&quot;&gt;improves compiler performance&lt;/a&gt;. If you find it does have a performance impact at runtime in your case, you can trigger specialization by adding a type parameter to the method declaration. Here are some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876317f2ed373be8c206ea71cf8b7c051cb11062" translate="yes" xml:space="preserve">
          <source>As a more complicated example, let's define our own toy N-dimensional sparse-like array type built on top of &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">В качестве более сложного примера давайте определим наш собственный игрушечный N-мерный разреженный тип массива, построенный на основе &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e8594cf6335bb7f066fe658c47ad7b64d5f8a844" translate="yes" xml:space="preserve">
          <source>As a more extended and complex example, consider running the following &quot;kernel&quot; in parallel:</source>
          <target state="translated">В качестве более расширенного и сложного примера рассмотрим параллельный запуск следующего &quot;ядра&quot;:</target>
        </trans-unit>
        <trans-unit id="abc7b3fc409ca00052233fccf9f3605c7724641a" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, the single-line &lt;code&gt;show&lt;/code&gt; method should print a valid Julia expression for creating the shown object. When this &lt;code&gt;show&lt;/code&gt; method contains infix operators, such as the multiplication operator (&lt;code&gt;*&lt;/code&gt;) in our single-line &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;Polar&lt;/code&gt; above, it may not parse correctly when printed as part of another object. To see this, consider the expression object (see &lt;a href=&quot;../metaprogramming/index#Program-representation&quot;&gt;Program representation&lt;/a&gt;) which takes the square of a specific instance of our &lt;code&gt;Polar&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2067a667a08ddb9964ef86bab532db4e31b7d596" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, the single-line &lt;code&gt;show&lt;/code&gt; method should print a valid Julia expression for creating the shown object. When this &lt;code&gt;show&lt;/code&gt; method contains infix operators, such as the multiplication operator (&lt;code&gt;*&lt;/code&gt;) in our single-line &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;Polar&lt;/code&gt; above, it may not parse correctly when printed as part of another object. To see this, consider the expression object (see &lt;a href=&quot;../metaprogramming/index#Program-representation-1&quot;&gt;Program representation&lt;/a&gt;) which takes the square of a specific instance of our &lt;code&gt;Polar&lt;/code&gt; type:</source>
          <target state="translated">Как показывает практика, однострочный метод &lt;code&gt;show&lt;/code&gt; должен печатать допустимое выражение Julia для создания показанного объекта. Когда этот метод &lt;code&gt;show&lt;/code&gt; содержит инфиксные операторы, такие как оператор умножения ( &lt;code&gt;*&lt;/code&gt; ) в нашем однострочном методе &lt;code&gt;show&lt;/code&gt; для &lt;code&gt;Polar&lt;/code&gt; выше, он может некорректно анализироваться при печати как часть другого объекта. Чтобы увидеть это, рассмотрим объект выражения (см. &lt;a href=&quot;../metaprogramming/index#Program-representation-1&quot;&gt;Представление программы&lt;/a&gt; ), который принимает квадрат определенного экземпляра нашего &lt;code&gt;Polar&lt;/code&gt; типа:</target>
        </trans-unit>
        <trans-unit id="37e79152e5cc53d02dd6543f1f031bc76326d65b" translate="yes" xml:space="preserve">
          <source>As a special case, all names defined in &lt;code&gt;Main&lt;/code&gt; are considered &quot;exported&quot;, since it is not idiomatic to explicitly export names from &lt;code&gt;Main&lt;/code&gt;.</source>
          <target state="translated">В особом случае все имена, определенные в &lt;code&gt;Main&lt;/code&gt; , считаются &amp;laquo;экспортированными&amp;raquo;, поскольку явный экспорт имен из &lt;code&gt;Main&lt;/code&gt; не является идиоматическим .</target>
        </trans-unit>
        <trans-unit id="6ead86dd43c44d522a7884aedc1fd88eb5becf75" translate="yes" xml:space="preserve">
          <source>As a special case, functions can only be actually deep-copied if they are anonymous, otherwise they are just copied. The difference is only relevant in the case of closures, i.e. functions which may contain hidden internal references.</source>
          <target state="translated">В особом случае функции могут быть фактически глубоко скопированы только при условии их анонимности,в противном случае они просто копируются.Различие имеет значение только в случае закрытия,т.е.функций,которые могут содержать скрытые внутренние ссылки.</target>
        </trans-unit>
        <trans-unit id="d76af4d473b8d2d40c642b61a1fbe0edf6927389" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;AbstractString&lt;/code&gt; (for textual MIME types) or a &lt;code&gt;Vector{UInt8}&lt;/code&gt; (for binary MIME types), the &lt;code&gt;repr&lt;/code&gt; function assumes that &lt;code&gt;x&lt;/code&gt; is already in the requested &lt;code&gt;mime&lt;/code&gt; format and simply returns &lt;code&gt;x&lt;/code&gt;. This special case does not apply to the &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; MIME type. This is useful so that raw data can be passed to &lt;code&gt;display(m::MIME, x)&lt;/code&gt;.</source>
          <target state="translated">В качестве особого случая, если &lt;code&gt;x&lt;/code&gt; является &lt;code&gt;AbstractString&lt;/code&gt; (для текстовых типов MIME) или &lt;code&gt;Vector{UInt8}&lt;/code&gt; (для двоичных типов MIME), функция &lt;code&gt;repr&lt;/code&gt; предполагает, что &lt;code&gt;x&lt;/code&gt; уже находится в запрошенном формате &lt;code&gt;mime&lt;/code&gt; , и просто возвращает &lt;code&gt;x&lt;/code&gt; . Этот особый случай не применяется к типу MIME &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; . Это полезно для того, чтобы необработанные данные можно было передавать на &lt;code&gt;display(m::MIME, x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62d11f9f9e158c0b2c2708640ce2ac613943fd82" translate="yes" xml:space="preserve">
          <source>As a special part of this syntax, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the innermost array being indexed. Indexing syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">В качестве специальной части этого синтаксиса ключевое слово &lt;code&gt;end&lt;/code&gt; может использоваться для представления последнего индекса каждого измерения в скобках индексации, как это определяется размером самого внутреннего индексируемого массива. Синтаксис индексации без ключевого слова &lt;code&gt;end&lt;/code&gt; эквивалентен вызову &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bae7191c8b712d7ed7a7918d6d667ad51becb2b6" translate="yes" xml:space="preserve">
          <source>As already elaborated in &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL&quot;&gt;The Julia REPL&lt;/a&gt;, Julia's REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5535efde9a5741aaf5f5e686571434213ecef6c2" translate="yes" xml:space="preserve">
          <source>As already elaborated in &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;The Julia REPL&lt;/a&gt;, Julia's REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.</source>
          <target state="translated">Как уже говорилось в &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;Julia REPL&lt;/a&gt; , Julia REPL предоставляет богатую функциональность, которая облегчает эффективный интерактивный рабочий процесс. Вот несколько советов, которые могут еще больше улучшить вашу работу с командной строкой.</target>
        </trans-unit>
        <trans-unit id="06e64cdbccd93a2d388ef16dd274049eaf25b515" translate="yes" xml:space="preserve">
          <source>As an alternative for very simple cases, it is possible to just create a global container of type &lt;code&gt;Vector{Any}&lt;/code&gt; and fetch the elements from that when necessary, or even to create one global variable per pointer using</source>
          <target state="translated">В качестве альтернативы для очень простых случаев можно просто создать глобальный контейнер типа &lt;code&gt;Vector{Any}&lt;/code&gt; и при необходимости извлекать из него элементы или даже создать одну глобальную переменную для каждого указателя, используя</target>
        </trans-unit>
        <trans-unit id="d6c52d7f67846f1ec223096b1fa72569e5539d74" translate="yes" xml:space="preserve">
          <source>As an assertion to help confirm that your program works the way you expect,</source>
          <target state="translated">В качестве подтверждения того,что ваша программа работает так,как вы ожидаете,</target>
        </trans-unit>
        <trans-unit id="18c9d397fe2fae6bb521c88b045f04eec75021c6" translate="yes" xml:space="preserve">
          <source>As an example let us see how the &lt;code&gt;LocalManager&lt;/code&gt;, the manager responsible for starting workers on the same host, is implemented:</source>
          <target state="translated">В качестве примера давайте посмотрим, как &lt;code&gt;LocalManager&lt;/code&gt; , менеджер, ответственный за запуск воркеров на одном и том же хосте:</target>
        </trans-unit>
        <trans-unit id="5ea2f3f22affe5b0503e1b98807df2e143d66e8a" translate="yes" xml:space="preserve">
          <source>As an example of a non-TCP/IP transport, an implementation may choose to use MPI, in which case &lt;code&gt;--worker&lt;/code&gt; must NOT be specified. Instead, newly launched workers should call &lt;code&gt;init_worker(cookie)&lt;/code&gt; before using any of the parallel constructs.</source>
          <target state="translated">В качестве примера транспорта, отличного от TCP / IP, реализация может выбрать использование MPI, и в этом случае НЕ следует &lt;code&gt;--worker&lt;/code&gt; . Вместо этого вновь запущенные рабочие &lt;code&gt;init_worker(cookie)&lt;/code&gt; должны вызывать init_worker (cookie) перед использованием любой из параллельных конструкций.</target>
        </trans-unit>
        <trans-unit id="ab91e9f8f6b72a78ebd5768f4d6d25cd797012df" translate="yes" xml:space="preserve">
          <source>As an example, consider</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4fdf4e4340eb940fd457afeeed7b812831f6609" translate="yes" xml:space="preserve">
          <source>As an example, consider this call to &lt;a href=&quot;../../base/collections/index#Base.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d94b4e364183ef3f6a858e77d060fb33ee15b1a" translate="yes" xml:space="preserve">
          <source>As an example, suppose a package directory has the following structure and content:</source>
          <target state="translated">В качестве примера предположим,что каталог пакетов имеет следующую структуру и содержание:</target>
        </trans-unit>
        <trans-unit id="1237948f9e574bfd646187c2b196cb56c33c770b" translate="yes" xml:space="preserve">
          <source>As an example, suppose you wanted to define multiplication on symbols in a module:</source>
          <target state="translated">В качестве примера предположим,что вы хотели определить умножение на символах в модуле:</target>
        </trans-unit>
        <trans-unit id="59a193ac31c3261e6bf490ce9642a1cb05737a81" translate="yes" xml:space="preserve">
          <source>As an example, the builtin &lt;code&gt;AbstractRange&lt;/code&gt; objects use this machinery to optimize pieces of broadcasted expressions that can be eagerly evaluated purely in terms of the start, step, and length (or stop) instead of computing every single element. Just like all the other machinery, &lt;code&gt;broadcasted&lt;/code&gt; also computes and exposes the combined broadcast style of its arguments, so instead of specializing on &lt;code&gt;broadcasted(f, args...)&lt;/code&gt;, you can specialize on &lt;code&gt;broadcasted(::DestStyle, f, args...)&lt;/code&gt; for any combination of style, function, and arguments.</source>
          <target state="translated">В качестве примера, встроенные объекты &lt;code&gt;AbstractRange&lt;/code&gt; используют этот механизм для оптимизации частей транслируемых выражений, которые могут быть быстро оценены исключительно с точки зрения начала, шага и длины (или остановки) вместо вычисления каждого отдельного элемента. Как и все другие механизмы, &lt;code&gt;broadcasted&lt;/code&gt; также вычисляет и предоставляет объединенный стиль широковещания своих аргументов, поэтому вместо специализации на &lt;code&gt;broadcasted(f, args...)&lt;/code&gt; вы можете специализироваться на &lt;code&gt;broadcasted(::DestStyle, f, args...)&lt;/code&gt; для любой комбинации стиля, функции и аргументов.</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">В качестве примера:</target>
        </trans-unit>
        <trans-unit id="87ed434d0000a98d4576d846e0e095b93bb4582f" translate="yes" xml:space="preserve">
          <source>As an extension of this, in cases where the algorithm needs a copy of the input array, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; is insufficient as the return value may alias the original input. Combining &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; (to make the output array) and &lt;a href=&quot;../../base/c/index#Base.copyto!&quot;&gt;&lt;code&gt;copyto!&lt;/code&gt;&lt;/a&gt; (to fill it with the input data) is a generic way to express the requirement for a mutable copy of the input argument:</source>
          <target state="translated">В дополнение к этому, в случаях, когда алгоритму требуется копия входного массива, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; недостаточно, поскольку возвращаемое значение может быть псевдонимом исходного входного. Комбинируя &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt; (чтобы &lt;a href=&quot;../../base/c/index#Base.copyto!&quot;&gt; &lt;code&gt;copyto!&lt;/code&gt; &lt;/a&gt; выходной массив) и copyto! (чтобы заполнить его входными данными) - это общий способ выразить потребность в изменяемой копии входного аргумента:</target>
        </trans-unit>
        <trans-unit id="f8ea3b19e7de523c7e9925d469ae1f1489b7d884" translate="yes" xml:space="preserve">
          <source>As another example, here is a function that doubles any numeric argument, but leaves expressions alone:</source>
          <target state="translated">В качестве другого примера можно привести функцию,которая удваивает любой числовой аргумент,но оставляет выражения в покое:</target>
        </trans-unit>
        <trans-unit id="5a98ec0590a6653411278e5178b7dfd6cf089ca2" translate="yes" xml:space="preserve">
          <source>As calculations on floating-point values can be imprecise, you can perform approximate equality checks using either &lt;code&gt;@test a &amp;asymp; b&lt;/code&gt; (where &lt;code&gt;&amp;asymp;&lt;/code&gt;, typed via tab completion of &lt;code&gt;\approx&lt;/code&gt;, is the &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt; function) or use &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">Поскольку вычисления значений с плавающей запятой могут быть неточными, вы можете выполнить приблизительную проверку равенства, используя либо &lt;code&gt;@test a &amp;asymp; b&lt;/code&gt; (где &lt;code&gt;&amp;asymp;&lt;/code&gt; , набранный с помощью дополнения табуляции &lt;code&gt;\approx&lt;/code&gt; , это функция &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; &lt;/a&gt; ), либо напрямую использовать &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="671cfcc401170439c76fc45750de84c7f63c05ee" translate="yes" xml:space="preserve">
          <source>As can be seen once again, a remote call onto the local node behaves just like a direct invocation. The call modifies local objects passed as arguments. In the remote invocation, it operates on a copy of the arguments.</source>
          <target state="translated">Как видно еще раз,удаленный вызов на локальный узел ведет себя так же,как и прямой вызов.Вызов изменяет локальные объекты,передаваемые в качестве аргументов.При удаленном вызове он работает на копии аргументов.</target>
        </trans-unit>
        <trans-unit id="3cc0d715da9528bac336fc93fd62b1b74187bec5" translate="yes" xml:space="preserve">
          <source>As can be seen, &lt;code&gt;A&lt;/code&gt; is changed to the sorted array &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt;. Note that Julia knows how to convert an array into a &lt;code&gt;Ptr{Cdouble}&lt;/code&gt;, how to compute the size of a type in bytes (identical to C's &lt;code&gt;sizeof&lt;/code&gt; operator), and so on. For fun, try inserting a &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; line into &lt;code&gt;mycompare&lt;/code&gt;, which will allow you to see the comparisons that &lt;code&gt;qsort&lt;/code&gt; is performing (and to verify that it is really calling the Julia function that you passed to it).</source>
          <target state="translated">Как видно, &lt;code&gt;A&lt;/code&gt; заменяется на отсортированный массив &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt; . Обратите внимание, что Джулия знает, как преобразовать массив в &lt;code&gt;Ptr{Cdouble}&lt;/code&gt; , как вычислить размер типа в байтах (идентично оператору &lt;code&gt;sizeof&lt;/code&gt; в языке C ) и так далее. Для удовольствия попробуйте вставить &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; в &lt;code&gt;mycompare&lt;/code&gt; , что позволит вам увидеть сравнения, выполняемые &lt;code&gt;qsort&lt;/code&gt; (и убедиться, что он действительно вызывает функцию Julia, которую вы передали к нему).</target>
        </trans-unit>
        <trans-unit id="4b96915d6aea30f8cc88503d183daf83b43b1570" translate="yes" xml:space="preserve">
          <source>As can be seen, &lt;code&gt;put!&lt;/code&gt; on a locally owned &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; with the same object &lt;code&gt;v&lt;/code&gt; modifed between calls results in the same single object instance stored. As opposed to copies of &lt;code&gt;v&lt;/code&gt; being created when the node owning &lt;code&gt;rc&lt;/code&gt; is a different node.</source>
          <target state="translated">Как видно &lt;code&gt;put!&lt;/code&gt; на локальном &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; с одним и тем же объектом &lt;code&gt;v&lt;/code&gt; , измененным между вызовами, приводит к сохранению одного и того же единственного экземпляра объекта. В отличие от копий &lt;code&gt;v&lt;/code&gt; , создаваемых, когда узел, владеющий &lt;code&gt;rc&lt;/code&gt; , является другим узлом.</target>
        </trans-unit>
        <trans-unit id="e253ba428da9355b11a09e17058388a067c23f87" translate="yes" xml:space="preserve">
          <source>As can be seen, global variable &lt;code&gt;A&lt;/code&gt; is defined on worker 2, but &lt;code&gt;B&lt;/code&gt; is captured as a local variable and hence a binding for &lt;code&gt;B&lt;/code&gt; does not exist on worker 2.</source>
          <target state="translated">Как видно, глобальная переменная &lt;code&gt;A&lt;/code&gt; определена на рабочем 2, но &lt;code&gt;B&lt;/code&gt; фиксируется как локальная переменная, и, следовательно, привязка для &lt;code&gt;B&lt;/code&gt; не существует на рабочем 2.</target>
        </trans-unit>
        <trans-unit id="76f93ab509f4540b19db8475dd078bd3d9ad56c4" translate="yes" xml:space="preserve">
          <source>As convenient as date-period arithmetic is, often the kinds of calculations needed on dates take on a &lt;em&gt;calendrical&lt;/em&gt; or &lt;em&gt;temporal&lt;/em&gt; nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as &quot;Memorial Day = Last Monday of May&quot;, or &quot;Thanksgiving = 4th Thursday of November&quot;. These kinds of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.</source>
          <target state="translated">Какой бы удобной ни была арифметика даты и периода, часто необходимые для дат вычисления имеют &lt;em&gt;календарный&lt;/em&gt; или &lt;em&gt;временной&lt;/em&gt; характер, а не фиксированное количество периодов. Праздники - прекрасный тому пример; большинство из них следуют таким правилам, как &amp;laquo;День памяти = последний понедельник мая&amp;raquo; или &amp;laquo;День благодарения = 4-й четверг ноября&amp;raquo;. Такие временные выражения имеют дело с правилами, относящимися к календарю, например, первое или последнее число месяца, следующий вторник, первая и третья среды и т. Д.</target>
        </trans-unit>
        <trans-unit id="a1c026427d4e0f63d2dc15ae37577d2f94eafa8a" translate="yes" xml:space="preserve">
          <source>As expected we saw &quot;Hello World&quot; printed. So, let's actually analyze what happened behind the scenes. When we called &lt;code&gt;connect&lt;/code&gt;, we connect to the server we had just created. Meanwhile, the accept function returns a server-side connection to the newly created socket and prints &quot;Hello World&quot; to indicate that the connection was successful.</source>
          <target state="translated">Как и ожидалось, мы увидели напечатанное &amp;laquo;Hello World&amp;raquo;. Итак, давайте собственно проанализируем, что происходило за кулисами. Когда мы вызывали &lt;code&gt;connect&lt;/code&gt; , мы подключаемся к только что созданному серверу. Между тем, функция accept возвращает соединение на стороне сервера для вновь созданного сокета и печатает &amp;laquo;Hello World&amp;raquo;, чтобы указать, что соединение было успешным.</target>
        </trans-unit>
        <trans-unit id="a7387cbdd9f992b642e060d8d4bc6f44c8177451" translate="yes" xml:space="preserve">
          <source>As for &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;SparseVector&lt;/code&gt; type can also contain explicitly stored zeros. (See &lt;a href=&quot;#man-csc&quot;&gt;Sparse Matrix Storage&lt;/a&gt;.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb0a271b40c54ec6b4884cb957952b84f3d4f5b" translate="yes" xml:space="preserve">
          <source>As for &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;SparseVector&lt;/code&gt; type can also contain explicitly stored zeros. (See &lt;a href=&quot;#man-csc-1&quot;&gt;Sparse Matrix Storage&lt;/a&gt;.).</source>
          <target state="translated">Что касается &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC&lt;/code&gt; &lt;/a&gt; , тип &lt;code&gt;SparseVector&lt;/code&gt; также может содержать явно сохраненные нули. (См. &lt;a href=&quot;#man-csc-1&quot;&gt;Разреженное матричное хранилище&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="fc146c2940c0c078ab8141567616fc6c9d0de40c" translate="yes" xml:space="preserve">
          <source>As for hexadecimal literals, binary and octal literals produce unsigned integer types. The size of the binary data item is the minimal needed size, if the leading digit of the literal is not &lt;code&gt;0&lt;/code&gt;. In the case of leading zeros, the size is determined by the minimal needed size for a literal, which has the same length but leading digit &lt;code&gt;1&lt;/code&gt;. That allows the user to control the size. Values which cannot be stored in &lt;code&gt;UInt128&lt;/code&gt; cannot be written as such literals.</source>
          <target state="translated">Что касается шестнадцатеричных литералов, двоичные и восьмеричные литералы создают беззнаковые целочисленные типы. Размер элемента двоичных данных - это минимально необходимый размер, если первая цифра литерала не равна &lt;code&gt;0&lt;/code&gt; . В случае начальных нулей размер определяется минимально необходимым размером для литерала, который имеет ту же длину, но начальную цифру &lt;code&gt;1&lt;/code&gt; . Это позволяет пользователю контролировать размер. Значения, которые нельзя сохранить в &lt;code&gt;UInt128&lt;/code&gt; , нельзя записать как такие литералы.</target>
        </trans-unit>
        <trans-unit id="6db8bde5f510430fc099aa246b7efd8ae6ef4908" translate="yes" xml:space="preserve">
          <source>As for numeric arrays, choosing a non-stable default algorithm for array types for which the notion of a stable sort is meaningless (i.e. when two values comparing equal can not be distinguished) may make sense.</source>
          <target state="translated">Что касается числовых массивов,то выбор нестационарного алгоритма по умолчанию для типов массивов,для которых понятие стабильного сорта бессмысленно (т.е.когда два значения,сравнивающие равные,не могут быть различимы),может иметь смысл.</target>
        </trans-unit>
        <trans-unit id="5657074766ca713487af1f45c8fe2527e89dae0c" translate="yes" xml:space="preserve">
          <source>As for single values, use &lt;a href=&quot;../../base/base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt; to treat &lt;code&gt;missing&lt;/code&gt; values as equal to other &lt;code&gt;missing&lt;/code&gt; values but different from non-missing values</source>
          <target state="translated">Что касается одиночных значений, используйте &lt;a href=&quot;../../base/base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt; для обработки &lt;code&gt;missing&lt;/code&gt; значений как равных другим &lt;code&gt;missing&lt;/code&gt; значениям, но отличных от непропущенных значений.</target>
        </trans-unit>
        <trans-unit id="80909a25deba83e5c549936818feccfa43f85abd" translate="yes" xml:space="preserve">
          <source>As hinted above, one extremely useful feature of Julia is the capability to generate and manipulate Julia code within Julia itself. We have already seen one example of a function returning &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; objects: the &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; function, which takes a string of Julia code and returns the corresponding &lt;code&gt;Expr&lt;/code&gt;. A function can also take one or more &lt;code&gt;Expr&lt;/code&gt; objects as arguments, and return another &lt;code&gt;Expr&lt;/code&gt;. Here is a simple, motivating example:</source>
          <target state="translated">Как указывалось выше, одна чрезвычайно полезная функция Julia - это возможность генерировать код Julia и управлять им внутри самой Julia. Мы уже видели один пример функции, возвращающей объекты &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; : функция &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; , которая принимает строку кода Julia и возвращает соответствующее &lt;code&gt;Expr&lt;/code&gt; . Функция также может принимать один или несколько объектов &lt;code&gt;Expr&lt;/code&gt; в качестве аргументов и возвращать другое &lt;code&gt;Expr&lt;/code&gt; . Вот простой вдохновляющий пример:</target>
        </trans-unit>
        <trans-unit id="0e3a8b594e44456d63d508da5257e974c3de310d" translate="yes" xml:space="preserve">
          <source>As illustrated in the above example each column of &lt;code&gt;|&lt;/code&gt; characters must be aligned vertically.</source>
          <target state="translated">Как показано в приведенном выше примере, каждый столбец &lt;code&gt;|&lt;/code&gt; символы должны быть выровнены по вертикали.</target>
        </trans-unit>
        <trans-unit id="51316c0f471c7aa15821993b2904c54c98f59dec" translate="yes" xml:space="preserve">
          <source>As in Java, strings are immutable: the value of an &lt;code&gt;AbstractString&lt;/code&gt; object cannot be changed. To construct a different string value, you construct a new string from parts of other strings.</source>
          <target state="translated">Как и в Java, строки неизменяемы: значение объекта &lt;code&gt;AbstractString&lt;/code&gt; не может быть изменено. Чтобы создать другое строковое значение, вы создаете новую строку из частей других строк.</target>
        </trans-unit>
        <trans-unit id="10a53b8655071d9e82e3aaf67177dfbc302c86e3" translate="yes" xml:space="preserve">
          <source>As in keyword arguments, identifiers and dot expressions imply names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972bb7e6b4d2b9c22f53c9f2f7dc30a1be414e25" translate="yes" xml:space="preserve">
          <source>As in the example above, we recommend following some simple conventions when writing documentation:</source>
          <target state="translated">Как и в примере выше,мы рекомендуем при написании документации следовать некоторым простым конвенциям:</target>
        </trans-unit>
        <trans-unit id="a760e2170f972850310e9b6d50d6aa2fdbfb2289" translate="yes" xml:space="preserve">
          <source>As in the previous example, the first assignment to &lt;code&gt;s&lt;/code&gt; at the top of &lt;code&gt;sum_to&lt;/code&gt; causes &lt;code&gt;s&lt;/code&gt; to be a new local variable in the body of the function. The &lt;code&gt;for&lt;/code&gt; loop has its own inner local scope within the function scope. At the point where &lt;code&gt;s = s + i&lt;/code&gt; occurs, &lt;code&gt;s&lt;/code&gt; is already a local variable, so the assignment updates the existing &lt;code&gt;s&lt;/code&gt; instead of creating a new local. We can test this out by calling &lt;code&gt;sum_to&lt;/code&gt; in the REPL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42eaaebd11c27f9b1c1515d18b277f999ad14b89" translate="yes" xml:space="preserve">
          <source>As it was mentioned &lt;code&gt;CodeUnits{UInt8,String}&lt;/code&gt; type behaves like read only array of &lt;code&gt;UInt8&lt;/code&gt; and if you need a standard vector you can convert it using &lt;code&gt;Vector{UInt8}&lt;/code&gt;:</source>
          <target state="translated">Как уже упоминалось, &lt;code&gt;CodeUnits{UInt8,String}&lt;/code&gt; ведет себя как массив только для &lt;code&gt;UInt8&lt;/code&gt; и если вам нужен стандартный вектор, вы можете преобразовать его с помощью &lt;code&gt;Vector{UInt8}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ba1acaea73293bc8197cce97bdfefcad05927f1a" translate="yes" xml:space="preserve">
          <source>As mentioned above, one can also define new display backends. For example, a module that can display PNG images in a window can register this capability with Julia, so that calling &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; on types with PNG representations will automatically display the image using the module's window.</source>
          <target state="translated">Как упоминалось выше, можно также определить новые серверные части отображения. Например, модуль, который может отображать изображения PNG в окне, может зарегистрировать эту возможность в Julia, так что вызов &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt; для типов с представлениями PNG будет автоматически отображать изображение с помощью окна модуля.</target>
        </trans-unit>
        <trans-unit id="9a3464c75addc4046f2d5407323c1df1db4f1784" translate="yes" xml:space="preserve">
          <source>As mentioned briefly in &lt;a href=&quot;../functions/index#man-functions&quot;&gt;Functions&lt;/a&gt;, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb063e502e9f2dd374cf5645d0ea6281db87f213" translate="yes" xml:space="preserve">
          <source>As mentioned briefly in &lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;Functions&lt;/a&gt;, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:</source>
          <target state="translated">Как вкратце упоминалось в &lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;разделе &amp;laquo;Функции&amp;raquo;&lt;/a&gt; , необязательные аргументы реализованы как синтаксис для множественных определений методов. Например, это определение:</target>
        </trans-unit>
        <trans-unit id="be2578b9d9f02697184689069f4eff8d3539a32a" translate="yes" xml:space="preserve">
          <source>As of Julia 1.5, functions defined by &lt;code&gt;@deprecate&lt;/code&gt; do not print warning when &lt;code&gt;julia&lt;/code&gt; is run without the &lt;code&gt;--depwarn=yes&lt;/code&gt; flag set, as the default value of &lt;code&gt;--depwarn&lt;/code&gt; option is &lt;code&gt;no&lt;/code&gt;. The warnings are printed from tests run by &lt;code&gt;Pkg.test()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512c2f7db98f68697b03e7fce5871064de0272a9" translate="yes" xml:space="preserve">
          <source>As of Julia 1.5, this code works without the &lt;code&gt;global&lt;/code&gt; annotation in interactive contexts like the REPL or Jupyter notebooks (just like Julia 0.6) and in files and other non-interactive contexts, it prints this very direct warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48e9ac18414a96f1e01471c6b6626466797c864" translate="yes" xml:space="preserve">
          <source>As of this writing, the valid Unicode code points are &lt;code&gt;U+0000&lt;/code&gt; through &lt;code&gt;U+D7FF&lt;/code&gt; and &lt;code&gt;U+E000&lt;/code&gt; through &lt;code&gt;U+10FFFF&lt;/code&gt;. These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191e5fd5542b028418c413dac2b44eaff01d364f" translate="yes" xml:space="preserve">
          <source>As of this writing, the valid Unicode code points are &lt;code&gt;U+00&lt;/code&gt; through &lt;code&gt;U+d7ff&lt;/code&gt; and &lt;code&gt;U+e000&lt;/code&gt; through &lt;code&gt;U+10ffff&lt;/code&gt;. These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.</source>
          <target state="translated">На момент написания этой статьи допустимыми кодами Unicode являются от &lt;code&gt;U+00&lt;/code&gt; до &lt;code&gt;U+d7ff&lt;/code&gt; и от &lt;code&gt;U+e000&lt;/code&gt; до &lt;code&gt;U+10ffff&lt;/code&gt; . Еще не всем им присвоено понятное значение, и они не обязательно интерпретируются приложениями, но все эти значения считаются допустимыми символами Unicode.</target>
        </trans-unit>
        <trans-unit id="c64e98d3602dd7e8a13d28a764d202fba2aba952" translate="yes" xml:space="preserve">
          <source>As one can see here, &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt; simply returns true or false, indicating whether a match for the given regex occurs in the string. Commonly, however, one wants to know not just whether a string matched, but also &lt;em&gt;how&lt;/em&gt; it matched. To capture this information about a match, use the &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; function instead:</source>
          <target state="translated">Как можно видеть здесь, &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt; просто возвращает истину или ложь, указывая, есть ли совпадение для данного регулярного выражения в строке. Однако обычно нужно знать не только, совпала ли строка, но и &lt;em&gt;как&lt;/em&gt; она совпала. Для того, чтобы захватить эту информацию о матче, используйте &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; функцию вместо:</target>
        </trans-unit>
        <trans-unit id="c4a14a67f1bf4cea327a2eb12b0f80f0eef678ff" translate="yes" xml:space="preserve">
          <source>As the error states, an immediate cause of an &lt;code&gt;UndefVarError&lt;/code&gt; on a remote node is that a binding by that name does not exist. Let us explore some of the possible causes.</source>
          <target state="translated">Как указано в сообщении об ошибке, непосредственной причиной &lt;code&gt;UndefVarError&lt;/code&gt; на удаленном узле является то, что привязка с таким именем не существует. Давайте исследуем некоторые из возможных причин.</target>
        </trans-unit>
        <trans-unit id="1eb17e26ef0507943bf96943b437f10fc48bc317" translate="yes" xml:space="preserve">
          <source>As the example implies, the following command-line arguments to &lt;code&gt;julia&lt;/code&gt; are interpreted as command-line arguments to the program &lt;code&gt;script.jl&lt;/code&gt;, passed in the global constant &lt;code&gt;ARGS&lt;/code&gt;. The name of the script itself is passed in as the global &lt;code&gt;PROGRAM_FILE&lt;/code&gt;. Note that &lt;code&gt;ARGS&lt;/code&gt; is also set when a Julia expression is given using the &lt;code&gt;-e&lt;/code&gt; option on the command line (see the &lt;code&gt;julia&lt;/code&gt; help output below) but &lt;code&gt;PROGRAM_FILE&lt;/code&gt; will be empty. For example, to just print the arguments given to a script, you could do this:</source>
          <target state="translated">Как следует из примера, следующие аргументы командной строки для &lt;code&gt;julia&lt;/code&gt; интерпретируются как аргументы командной строки для программы &lt;code&gt;script.jl&lt;/code&gt; , переданные в глобальной константе &lt;code&gt;ARGS&lt;/code&gt; . Имя самого скрипта передается как глобальный &lt;code&gt;PROGRAM_FILE&lt;/code&gt; . Обратите внимание, что &lt;code&gt;ARGS&lt;/code&gt; также устанавливается, когда выражение Julia задается с использованием параметра &lt;code&gt;-e&lt;/code&gt; в командной строке (см. Вывод справки &lt;code&gt;julia&lt;/code&gt; ниже), но &lt;code&gt;PROGRAM_FILE&lt;/code&gt; будет пустым. Например, чтобы просто вывести аргументы, данные сценарию, можно сделать так:</target>
        </trans-unit>
        <trans-unit id="109c1f4fb3ce88e11db771658301b6b14b390770" translate="yes" xml:space="preserve">
          <source>As the example shows, the original Julia array &lt;code&gt;A&lt;/code&gt; has now been sorted: &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt;. Note that Julia &lt;a href=&quot;#automatic-type-conversion&quot;&gt;takes care of converting the array to a &lt;code&gt;Ptr{Cdouble}&lt;/code&gt;&lt;/a&gt;), computing the size of the element type in bytes, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981be6ff2cc90e0e705ac3383fc828a6dbdc7827" translate="yes" xml:space="preserve">
          <source>As this example shows, the element type of such arrays is &lt;code&gt;Union{Missing, T}&lt;/code&gt;, with &lt;code&gt;T&lt;/code&gt; the type of the non-missing values. This simply reflects the fact that array entries can be either of type &lt;code&gt;T&lt;/code&gt; (here, &lt;code&gt;Int64&lt;/code&gt;) or of type &lt;code&gt;Missing&lt;/code&gt;. This kind of array uses an efficient memory storage equivalent to an &lt;code&gt;Array{T}&lt;/code&gt; holding the actual values combined with an &lt;code&gt;Array{UInt8}&lt;/code&gt; indicating the type of the entry (i.e. whether it is &lt;code&gt;Missing&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;).</source>
          <target state="translated">Как показано в этом примере, тип элемента таких массивов - &lt;code&gt;Union{Missing, T}&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; - это тип непропущенных значений. Это просто отражает тот факт, что записи массива могут быть либо типа &lt;code&gt;T&lt;/code&gt; (здесь &lt;code&gt;Int64&lt;/code&gt; ), либо типа &lt;code&gt;Missing&lt;/code&gt; . Этот вид массива использует эффективный эквивалент памяти для хранения на &lt;code&gt;Array{T}&lt;/code&gt; , держащий фактические значения в сочетании с &lt;code&gt;Array{UInt8}&lt;/code&gt; , указывающего типа записи (то есть ли она &lt;code&gt;Missing&lt;/code&gt; или &lt;code&gt;T&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ed6ee60a4bf819b8376da694ce11cd02fe61b3bd" translate="yes" xml:space="preserve">
          <source>As usual, the absolute value (&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt;) of a complex number is its distance from zero. &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt;&lt;code&gt;abs2&lt;/code&gt;&lt;/a&gt; gives the square of the absolute value, and is of particular use for complex numbers since it avoids taking a square root. &lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt; returns the phase angle in radians (also known as the &lt;em&gt;argument&lt;/em&gt; or &lt;em&gt;arg&lt;/em&gt; function). The full gamut of other &lt;a href=&quot;../mathematical-operations/index#Elementary-Functions&quot;&gt;Elementary Functions&lt;/a&gt; is also defined for complex numbers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38e97b2426f385efa12439902693dc14bf8618f" translate="yes" xml:space="preserve">
          <source>As usual, the absolute value (&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt;) of a complex number is its distance from zero. &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt;&lt;code&gt;abs2&lt;/code&gt;&lt;/a&gt; gives the square of the absolute value, and is of particular use for complex numbers since it avoids taking a square root. &lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt; returns the phase angle in radians (also known as the &lt;em&gt;argument&lt;/em&gt; or &lt;em&gt;arg&lt;/em&gt; function). The full gamut of other &lt;a href=&quot;../mathematical-operations/index#Elementary-Functions-1&quot;&gt;Elementary Functions&lt;/a&gt; is also defined for complex numbers:</source>
          <target state="translated">Как обычно, абсолютное значение ( &lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt; &lt;code&gt;abs&lt;/code&gt; &lt;/a&gt; ) комплексного числа - это его расстояние от нуля. &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt; &lt;code&gt;abs2&lt;/code&gt; &lt;/a&gt; дает квадрат абсолютного значения и особенно полезен для комплексных чисел, поскольку позволяет избежать извлечения квадратного корня. &lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt; &lt;code&gt;angle&lt;/code&gt; &lt;/a&gt; возвращает фазовый угол в радианах (также известный как &lt;em&gt;аргумент&lt;/em&gt; или функция &lt;em&gt;arg&lt;/em&gt; ). Полная гамма других &lt;a href=&quot;../mathematical-operations/index#Elementary-Functions-1&quot;&gt;элементарных функций&lt;/a&gt; также определена для комплексных чисел:</target>
        </trans-unit>
        <trans-unit id="b6a7588d6f9c25c0288fa6f4060bf2933853ea1a" translate="yes" xml:space="preserve">
          <source>As usual, the promotion system makes interactions with other numeric types effortless:</source>
          <target state="translated">Как обычно,система продвижения делает взаимодействие с другими числовыми типами легким:</target>
        </trans-unit>
        <trans-unit id="0ac972252ac8a4d2677fb97cc60dc48ab7bb4888" translate="yes" xml:space="preserve">
          <source>As usual, this does not bring &lt;code&gt;DummyModule&lt;/code&gt; into scope on any of the process, which requires &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;. Moreover, when &lt;code&gt;DummyModule&lt;/code&gt; is brought into scope on one process, it is not on any other:</source>
          <target state="translated">Как обычно, &lt;code&gt;DummyModule&lt;/code&gt; не попадает в область видимости какого-либо процесса, который требует &lt;code&gt;using&lt;/code&gt; или &lt;code&gt;import&lt;/code&gt; . Более того, когда &lt;code&gt;DummyModule&lt;/code&gt; попадает в область видимости одного процесса, его нет ни в каком другом:</target>
        </trans-unit>
        <trans-unit id="98525fef666cf45bd35cbb0c018ea8c9988be2ad" translate="yes" xml:space="preserve">
          <source>As we have seen in &lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code&quot;&gt;Calling C and Fortran Code&lt;/a&gt;, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ffd73a9506b0079b3703beb529178a185c5762" translate="yes" xml:space="preserve">
          <source>As we have seen in &lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code-1&quot;&gt;Calling C and Fortran Code&lt;/a&gt;, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).</source>
          <target state="translated">Как мы видели в &lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code-1&quot;&gt;Вызове кода C и Fortran&lt;/a&gt; , у Джулии есть простой и эффективный способ вызова функций, написанных на C. Но есть ситуации, когда требуется обратное: вызов функции Джулии из кода C. Это можно использовать для интеграции кода Julia в более крупный проект C / C ++ без необходимости переписывать все на C / C ++. У Джулии есть API C, чтобы это стало возможным. Поскольку почти во всех языках программирования есть способ вызова функций C, API Julia C также может использоваться для построения дополнительных языковых мостов (например, вызова Julia из Python или C #).</target>
        </trans-unit>
        <trans-unit id="82c0a21a8d879f7a5c7272f023db6b90d1239835" translate="yes" xml:space="preserve">
          <source>As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects.</source>
          <target state="translated">Как мы видели,объекты Юлии представлены на C в виде указателей.Это ставит вопрос о том,кто отвечает за освобождение этих объектов.</target>
        </trans-unit>
        <trans-unit id="8632fecc892c2a5175874dd3d5957b71b599c90f" translate="yes" xml:space="preserve">
          <source>As we have seen, a typical parametric type has inner constructors that are called when type parameters are known; e.g. they apply to &lt;code&gt;Point{Int}&lt;/code&gt; but not to &lt;code&gt;Point&lt;/code&gt;. Optionally, outer constructors that determine type parameters automatically can be added, for example constructing a &lt;code&gt;Point{Int}&lt;/code&gt; from the call &lt;code&gt;Point(1,2)&lt;/code&gt;. Outer constructors call inner constructors to actually make instances. However, in some cases one would rather not provide inner constructors, so that specific type parameters cannot be requested manually.</source>
          <target state="translated">Как мы видели, типичный параметрический тип имеет внутренние конструкторы, которые вызываются, когда известны параметры типа; например, они применяются к &lt;code&gt;Point{Int}&lt;/code&gt; но не к &lt;code&gt;Point&lt;/code&gt; . При желании могут быть добавлены внешние конструкторы, которые автоматически определяют параметры типа, например создание &lt;code&gt;Point{Int}&lt;/code&gt; из вызова &lt;code&gt;Point(1,2)&lt;/code&gt; . Внешние конструкторы вызывают внутренние конструкторы для создания экземпляров. Однако в некоторых случаях предпочтительнее не предоставлять внутренние конструкторы, чтобы параметры конкретного типа нельзя было запрашивать вручную.</target>
        </trans-unit>
        <trans-unit id="92ef7f3ff78c47fd1600b930f6d1226b1a4419f4" translate="yes" xml:space="preserve">
          <source>As we have seen, such expressions support interpolation with &lt;code&gt;$&lt;/code&gt;. However, in some situations it is necessary to quote code &lt;em&gt;without&lt;/em&gt; performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type &lt;code&gt;QuoteNode&lt;/code&gt;. The parser yields &lt;code&gt;QuoteNode&lt;/code&gt;s for simple quoted items like symbols:</source>
          <target state="translated">Как мы видели, такие выражения поддерживают интерполяцию с помощью &lt;code&gt;$&lt;/code&gt; . Однако в некоторых ситуациях необходимо цитировать код &lt;em&gt;без&lt;/em&gt; выполнения интерполяции. Этот вид цитирования еще не имеет синтаксиса, но внутренне представлен как объект типа &lt;code&gt;QuoteNode&lt;/code&gt; . Парсер выдает &lt;code&gt;QuoteNode&lt;/code&gt; s для простых цитируемых элементов, таких как символы:</target>
        </trans-unit>
        <trans-unit id="8358ced5c8aa8043f6548995886cf6fc9b1c22a3" translate="yes" xml:space="preserve">
          <source>As we have seen, such expressions support interpolation with &lt;code&gt;$&lt;/code&gt;. However, in some situations it is necessary to quote code &lt;em&gt;without&lt;/em&gt; performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type &lt;code&gt;QuoteNode&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe3955e5cc39192c40411a547d67109141fbd1c" translate="yes" xml:space="preserve">
          <source>As we will see next, boxing is required to call Julia functions with specific arguments.</source>
          <target state="translated">Как мы увидим далее,бокс необходим для вызова функций Julia с определенными аргументами.</target>
        </trans-unit>
        <trans-unit id="b53a534247af6d63db181fe8ad6536af06cae1ff" translate="yes" xml:space="preserve">
          <source>As well as information about the &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;'s year and quarter:</source>
          <target state="translated">А также информацию о году и квартале &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="834e03682d6f73b9df03b1d3810b4934cc9cc3a8" translate="yes" xml:space="preserve">
          <source>As well as other useful operations, such as finding eigenvalues or eigenvectors:</source>
          <target state="translated">А также другие полезные операции,такие как поиск собственных значений или собственных векторов:</target>
        </trans-unit>
        <trans-unit id="4983ba754d4bcba44195d81235402b223d67bb4c" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;ccall&lt;/code&gt;, the return type and tuple of input types must be literal constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce2d2a88a78a8f4ae1b7b6c89e850d2a3f2b6a48" translate="yes" xml:space="preserve">
          <source>As with any &lt;code&gt;ccall&lt;/code&gt;, it is essential to get the argument signature exactly correct. Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by &lt;code&gt;Core.Intrinsics&lt;/code&gt;.</source>
          <target state="translated">Как и в случае любого &lt;code&gt;ccall&lt;/code&gt; , важно получить точно правильную подпись аргумента. Также обратите внимание, что не существует уровня совместимости, который гарантирует, что встроенная функция имеет смысл и работает с текущей целью, в отличие от эквивалентных функций Julia, предоставляемых &lt;code&gt;Core.Intrinsics&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f496eca34c1af36fc9e6f49533f03b24b7584356" translate="yes" xml:space="preserve">
          <source>As with incomplete objects returned from constructors, if &lt;code&gt;complete_me&lt;/code&gt; or any of its callees try to access the &lt;code&gt;data&lt;/code&gt; field of the &lt;code&gt;Lazy&lt;/code&gt; object before it has been initialized, an error will be thrown immediately.</source>
          <target state="translated">Как и неполными объекты , возвращаемых из конструкторов, если &lt;code&gt;complete_me&lt;/code&gt; или любые из его пытается вызываемыми методы доступа к &lt;code&gt;data&lt;/code&gt; поля от &lt;code&gt;Lazy&lt;/code&gt; объекта до его инициализации, ошибка будет отброшена сразу.</target>
        </trans-unit>
        <trans-unit id="206e9628ecffc277c3db7c6ada272a26870edc0c" translate="yes" xml:space="preserve">
          <source>As with literals in the previous section, if literal backticks need to be written within double backticks use an even number greater than two. Note that if a single literal backtick needs to be included within $\LaTeX$ markup then two enclosing backticks is sufficient.</source>
          <target state="translated">Как и в случае с литералами в предыдущем разделе,если буквенные черные метки должны быть записаны в двойные черные метки,используйте четное число больше двух.Обратите внимание,что если в разметку $\LaTeX$ необходимо включить один буквенный бэк-стик,то двух прилагаемых бэк-стиков будет достаточно.</target>
        </trans-unit>
        <trans-unit id="eb071802c875eedf2628f279f3c3aa261b7f9f4a" translate="yes" xml:space="preserve">
          <source>As with other streams, use &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; to disconnect the socket:</source>
          <target state="translated">Как и в случае с другими потоками, используйте &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; для отключения сокета:</target>
        </trans-unit>
        <trans-unit id="4caebefb85f01f12aff5118bde420090e55936d8" translate="yes" xml:space="preserve">
          <source>As with variables, Unicode can also be used for function names:</source>
          <target state="translated">Как и в случае с переменными,Юникод также может быть использован для имен функций:</target>
        </trans-unit>
        <trans-unit id="f11a9dc367827aceb27fae5caffbfb8a44dc892b" translate="yes" xml:space="preserve">
          <source>As you can see in the examples, logging statements make no mention of where log events go or how they are processed. This is a key design feature that makes the system composable and natural for concurrent use. It does this by separating two different concerns:</source>
          <target state="translated">Как видно из примеров,в протоколировании не упоминается,куда идут события журнала и как они обрабатываются.Это ключевая конструктивная особенность,которая делает систему композитной и естественной для одновременного использования.Это достигается путем разделения двух различных проблем:</target>
        </trans-unit>
        <trans-unit id="4b2d88632a2082abc54ba7d8928178e89f90f7d3" translate="yes" xml:space="preserve">
          <source>As you can see, for constructor calls with explicit type parameters, the arguments are converted to the implied field types: &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; works, but &lt;code&gt;Point{Int64}(1.0,2.5)&lt;/code&gt; raises an &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; when converting &lt;code&gt;2.5&lt;/code&gt; to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;. When the type is implied by the arguments to the constructor call, as in &lt;code&gt;Point(1,2)&lt;/code&gt;, then the types of the arguments must agree &amp;ndash; otherwise the &lt;code&gt;T&lt;/code&gt; cannot be determined &amp;ndash; but any pair of real arguments with matching type may be given to the generic &lt;code&gt;Point&lt;/code&gt; constructor.</source>
          <target state="translated">Как видите, для вызовов конструктора с явными параметрами типа аргументы преобразуются в подразумеваемые типы полей: &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; работает, но &lt;code&gt;Point{Int64}(1.0,2.5)&lt;/code&gt; вызывает &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt; при преобразовании &lt;code&gt;2.5&lt;/code&gt; в &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; . Когда тип подразумевается аргументами вызова конструктора, как в &lt;code&gt;Point(1,2)&lt;/code&gt; , тогда типы аргументов должны согласовываться - в противном случае &lt;code&gt;T&lt;/code&gt; не может быть определено - но может быть задана любая пара реальных аргументов с соответствующим типом в универсальный конструктор &lt;code&gt;Point&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5461c0708bdec655ec8f2787ade84a59cba9a62f" translate="yes" xml:space="preserve">
          <source>As you can see, if the wrong number of elements are in the splatted container, then the function call will fail, just as it would if too many arguments were given explicitly.</source>
          <target state="translated">Как видите,если в контейнере splatted находится неверное количество элементов,то вызов функции завершится неудачей,как и в случае явного указания слишком большого количества аргументов.</target>
        </trans-unit>
        <trans-unit id="e203af061ceae4264896923db832aa0fc04bb217" translate="yes" xml:space="preserve">
          <source>As you can see, in the first line we asked process 2 to construct a 2-by-2 random matrix, and in the second line we asked it to add 1 to it. The result of both calculations is available in the two futures, &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;. The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; macro evaluates the expression in the second argument on the process specified by the first argument.</source>
          <target state="translated">Как видите, в первой строке мы попросили процесс 2 построить случайную матрицу размером 2 на 2, а во второй строке мы попросили добавить к ней 1. Результат обоих вычислений доступен в двух фьючерсах, &lt;code&gt;r&lt;/code&gt; и &lt;code&gt;s&lt;/code&gt; . &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt; макро вычисляет выражение во втором аргументе о процессе указанного первым аргументом.</target>
        </trans-unit>
        <trans-unit id="741e859119d8cfeca907f894902aa3d526d932dd" translate="yes" xml:space="preserve">
          <source>As you can see, the arguments must be precisely of type &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. Other numeric types, such as integers or 32-bit floating-point values, are not automatically converted to 64-bit floating-point, nor are strings parsed as numbers. Because &lt;code&gt;Float64&lt;/code&gt; is a concrete type and concrete types cannot be subclassed in Julia, such a definition can only be applied to arguments that are exactly of type &lt;code&gt;Float64&lt;/code&gt;. It may often be useful, however, to write more general methods where the declared parameter types are abstract:</source>
          <target state="translated">Как видите, аргументы должны быть именно типа &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; . Другие числовые типы, такие как целые числа или 32-разрядные значения с плавающей запятой, не преобразуются автоматически в 64-разрядные числа с плавающей запятой, а строки не анализируются как числа. Поскольку &lt;code&gt;Float64&lt;/code&gt; - это конкретный тип, а конкретные типы не могут быть разделены на подклассы в Julia, такое определение может применяться только к аргументам, которые точно относятся к типу &lt;code&gt;Float64&lt;/code&gt; . Однако часто бывает полезно написать более общие методы, в которых объявленные типы параметров являются абстрактными:</target>
        </trans-unit>
        <trans-unit id="359b67713bb818c1f3c296863f7d844ae4bb9a8a" translate="yes" xml:space="preserve">
          <source>As you can see, the second version, where we used an &lt;code&gt;Int&lt;/code&gt; literal, preserved the type of the input argument, while the first didn't. This is because e.g. &lt;code&gt;promote_type(Int, Float64) == Float64&lt;/code&gt;, and promotion happens with the multiplication. Similarly, &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; literals are less type disruptive than &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; literals, but more disruptive than &lt;code&gt;Int&lt;/code&gt;s:</source>
          <target state="translated">Как видите, вторая версия, в которой мы использовали литерал &lt;code&gt;Int&lt;/code&gt; , сохранила тип входного аргумента, а первая - нет. Это потому, что, например, &lt;code&gt;promote_type(Int, Float64) == Float64&lt;/code&gt; , а продвижение происходит с умножением. Точно так же литералы &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; менее разрушительны, чем литералы &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; , но более разрушительны, чем &lt;code&gt;Int&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a10e4a732e45e67918d07e124985de66438f996f" translate="yes" xml:space="preserve">
          <source>As you can see, the space in the &lt;code&gt;path&lt;/code&gt; variable is appropriately escaped. But what if you &lt;em&gt;want&lt;/em&gt; to interpolate multiple words? In that case, just use an array (or any other iterable container):</source>
          <target state="translated">Как видите, пробел в переменной &lt;code&gt;path&lt;/code&gt; соответствующим образом экранирован. Но что, если вы &lt;em&gt;хотите&lt;/em&gt; интерполировать несколько слов? В этом случае просто используйте массив (или любой другой повторяемый контейнер):</target>
        </trans-unit>
        <trans-unit id="43e3dc387959de6b7b510dc6136369a6354233c2" translate="yes" xml:space="preserve">
          <source>As you can see, the type of the appended element must match the element type of the vector it is appended to, or else a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is raised. In the following example, the method type parameter &lt;code&gt;T&lt;/code&gt; is used as the return value:</source>
          <target state="translated">Как видите, тип добавляемого элемента должен соответствовать типу элемента вектора, к &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; он добавляется, в противном случае возникает ошибка MethodError . В следующем примере параметр типа метода &lt;code&gt;T&lt;/code&gt; используется как возвращаемое значение:</target>
        </trans-unit>
        <trans-unit id="b29b566be209e38051caa728ad8f87323746dc77" translate="yes" xml:space="preserve">
          <source>As you could see, the reduction operator can be omitted if it is not needed. In that case, the loop executes asynchronously, i.e. it spawns independent tasks on all available workers and returns an array of &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; immediately without waiting for completion. The caller can wait for the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; completions at a later point by calling &lt;code&gt;fetch&lt;/code&gt; on them, or wait for completion at the end of the loop by prefixing it with &lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt;&lt;code&gt;@sync&lt;/code&gt;&lt;/a&gt;, like &lt;code&gt;@sync @distributed for&lt;/code&gt;.</source>
          <target state="translated">Как видите, оператор сокращения можно опустить, если он не нужен. В этом случае цикл выполняется асинхронно, т. Е. Он порождает независимые задачи для всех доступных воркеров и сразу же возвращает массив &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; ,&lt;/a&gt; не дожидаясь завершения. Вызывающий может дождаться завершения &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; позже, вызвав для него &lt;code&gt;fetch&lt;/code&gt; , или дождаться завершения в конце цикла, добавив к нему префикс &lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt; &lt;code&gt;@sync&lt;/code&gt; &lt;/a&gt; , например &lt;code&gt;@sync @distributed for&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1a150349a442b853a138e3c1fe4e3f7948f68a2" translate="yes" xml:space="preserve">
          <source>As you may have realized, while memory associated with globals may be collected when they are reassigned on the master, no such action is taken on the workers as the bindings continue to be valid. &lt;code&gt;clear!&lt;/code&gt; can be used to manually reassign specific globals on remote nodes to &lt;code&gt;nothing&lt;/code&gt; once they are no longer required. This will release any memory associated with them as part of a regular garbage collection cycle.</source>
          <target state="translated">Как вы, возможно, уже поняли, хотя память, связанная с глобальными объектами, может быть собрана при их переназначении на ведущем устройстве, такие действия не выполняются с рабочими объектами, поскольку привязки остаются действительными. &lt;code&gt;clear!&lt;/code&gt; может использоваться для ручного переназначения определенных глобальных переменных на удаленных узлах на &lt;code&gt;nothing&lt;/code&gt; если они больше не требуются. Это освободит всю связанную с ними память в рамках обычного цикла сборки мусора.</target>
        </trans-unit>
        <trans-unit id="dacd35c567b889475ef2a3c6c433ab70c5f4775a" translate="yes" xml:space="preserve">
          <source>Assign &lt;code&gt;x&lt;/code&gt; to a named field in &lt;code&gt;value&lt;/code&gt; of composite type. The &lt;code&gt;value&lt;/code&gt; must be mutable and &lt;code&gt;x&lt;/code&gt; must be a subtype of &lt;code&gt;fieldtype(typeof(value), name)&lt;/code&gt;. See also &lt;a href=&quot;#Base.setproperty!&quot;&gt;&lt;code&gt;setproperty!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Присвойте &lt;code&gt;x&lt;/code&gt; именованному полю в &lt;code&gt;value&lt;/code&gt; составного типа. &lt;code&gt;value&lt;/code&gt; должно быть изменяемым и &lt;code&gt;x&lt;/code&gt; должны быть подтипом &lt;code&gt;fieldtype(typeof(value), name)&lt;/code&gt; . См. Также &lt;a href=&quot;#Base.setproperty!&quot;&gt; &lt;code&gt;setproperty!&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="31839985af6b213c58cad9bbfe8e7aebd2198424" translate="yes" xml:space="preserve">
          <source>Assign a value to a key in the current task's task-local storage.</source>
          <target state="translated">Присвоить значение ключу в локальном хранилище задач текущей задачи.</target>
        </trans-unit>
        <trans-unit id="343021dcf6fd7efdb357d926be862e74219ddb49" translate="yes" xml:space="preserve">
          <source>Assigning &lt;code&gt;[]&lt;/code&gt; does not eliminate elements from a collection; instead use &lt;a href=&quot;../collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Назначение &lt;code&gt;[]&lt;/code&gt; не удаляет элементы из коллекции; вместо этого используйте &lt;a href=&quot;../collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="6144b75b7bde706b0577dc11bf2dc87a5f571732" translate="yes" xml:space="preserve">
          <source>Assigning &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; does not create a copy of &lt;code&gt;b&lt;/code&gt;; instead use &lt;a href=&quot;#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.deepcopy&quot;&gt;&lt;code&gt;deepcopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Присвоение &lt;code&gt;a&lt;/code&gt; к &lt;code&gt;b&lt;/code&gt; не создает копию &lt;code&gt;b&lt;/code&gt; ; вместо этого используйте &lt;a href=&quot;#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#Base.deepcopy&quot;&gt; &lt;code&gt;deepcopy&lt;/code&gt; &lt;/a&gt;копию .</target>
        </trans-unit>
        <trans-unit id="07a6f2ac6ae10af3c874613ad299e2e22c70e6b5" translate="yes" xml:space="preserve">
          <source>Assigning numbers into &lt;code&gt;a&lt;/code&gt; will now convert them to &lt;code&gt;Float64&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; will be stored as a contiguous block of 64-bit floating-point values that can be manipulated efficiently.</source>
          <target state="translated">Присвоение чисел в &lt;code&gt;a&lt;/code&gt; теперь преобразует их в &lt;code&gt;Float64&lt;/code&gt; , а &lt;code&gt;a&lt;/code&gt; будет сохраняться как непрерывный блок 64-битных значений с плавающей запятой, которыми можно эффективно управлять.</target>
        </trans-unit>
        <trans-unit id="335227cba10c33b5a2154427c17bb8a45448ea75" translate="yes" xml:space="preserve">
          <source>Assigning to a field of an object converts to the declared type of the field.</source>
          <target state="translated">Присвоение поля объекту преобразуется в объявленный тип поля.</target>
        </trans-unit>
        <trans-unit id="ea3c536f7d8386d0d34fa46bb187211a095b9597" translate="yes" xml:space="preserve">
          <source>Assigning to a variable with a declared type (e.g. &lt;code&gt;local x::T&lt;/code&gt;) converts to that type.</source>
          <target state="translated">Присваивание переменной с объявленным типом (например, &lt;code&gt;local x::T&lt;/code&gt; ) преобразуется в этот тип.</target>
        </trans-unit>
        <trans-unit id="4352a222d8d135ef7905c51dc5e73ca198e904f1" translate="yes" xml:space="preserve">
          <source>Assigning to an array converts to the array's element type.</source>
          <target state="translated">Присвоение массиву преобразуется в тип элемента массива.</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="caee9fcfeeacb92daf3a9dd06e9024b473eac387" translate="yes" xml:space="preserve">
          <source>Assignment at out-of-bounds indices does not grow a collection. If the collection is a &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt; it can instead be grown with &lt;a href=&quot;../collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Присвоение индексов за пределами диапазона не увеличивает коллекцию. Если коллекция является &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt; ее можно увеличить с помощью &lt;a href=&quot;../collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt;или &lt;a href=&quot;../collections/index#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="cca9fba860c54e60aaec525df6854ad412b1850b" translate="yes" xml:space="preserve">
          <source>Assignment can operate on multiple variables in parallel, taking values from an iterable:</source>
          <target state="translated">Присвоение может работать с несколькими переменными параллельно,беря значения из итерабельного:</target>
        </trans-unit>
        <trans-unit id="729134453eca052fa22a956f1ac0e88899ca88fa" translate="yes" xml:space="preserve">
          <source>Assignment can operate on multiple variables in series, and will return the value of the right-hand-most expression:</source>
          <target state="translated">Назначение может работать с несколькими переменными последовательно,и будет возвращать значение самого правого выражения:</target>
        </trans-unit>
        <trans-unit id="a4c2fee77618ccc921a63bc548e408d4da3037fb" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;s&lt;/code&gt; in soft scope is ambiguous because a global variable by the same name exists: &lt;code&gt;s&lt;/code&gt; will be treated as a new local. Disambiguate by using &lt;code&gt;local s&lt;/code&gt; to suppress this warning or &lt;code&gt;global s&lt;/code&gt; to assign to the existing global variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="a997f01f100c5327776cf22824dbe2d9bd2208d2" translate="yes" xml:space="preserve">
          <source>Associate the lifetime of &lt;code&gt;chnl&lt;/code&gt; with a task. &lt;code&gt;Channel&lt;/code&gt;&lt;code&gt;chnl&lt;/code&gt; is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on &lt;code&gt;chnl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;chnl&lt;/code&gt; время жизни chnl с задачей. &lt;code&gt;Channel&lt;/code&gt; &lt;code&gt;chnl&lt;/code&gt; автоматически закрывается при завершении задачи. Любое неперехваченное исключение в задаче распространяется на всех официантов на &lt;code&gt;chnl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59f2aa2b1552b74e34281b33bf3cbb05f68d9bae" translate="yes" xml:space="preserve">
          <source>Associative collections (such as &lt;code&gt;Dict&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;) need to be re-hashed in &lt;code&gt;__init__&lt;/code&gt;. (In the future, a mechanism may be provided to register an initializer function.)</source>
          <target state="translated">Ассоциативные коллекции (такие как &lt;code&gt;Dict&lt;/code&gt; и &lt;code&gt;Set&lt;/code&gt; ) необходимо повторно хешировать в &lt;code&gt;__init__&lt;/code&gt; . (В будущем может быть предоставлен механизм для регистрации функции инициализатора.)</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="31eabac4e8c06c32e7c19300707a41f9f210b6ee" translate="yes" xml:space="preserve">
          <source>Assuming no method more specific than the above is found, Julia next internally defines and compiles a method called &lt;code&gt;myplus&lt;/code&gt; specifically for two &lt;code&gt;Int&lt;/code&gt; arguments based on the generic function given above, i.e., it implicitly defines and compiles:</source>
          <target state="translated">Предполагая, что не найден более конкретный метод, чем указанный выше, Джулия затем внутренне определяет и компилирует метод с именем &lt;code&gt;myplus&lt;/code&gt; специально для двух аргументов &lt;code&gt;Int&lt;/code&gt; на основе общей функции, приведенной выше, то есть он неявно определяет и компилирует:</target>
        </trans-unit>
        <trans-unit id="2717ba36a09eb99678b64bb90dc485e6b0a0d557" translate="yes" xml:space="preserve">
          <source>Asterisk Operator</source>
          <target state="translated">Звездочка Оператор</target>
        </trans-unit>
        <trans-unit id="07b5380b9f5c5fd84a32bc659548c9dfab4533bb" translate="yes" xml:space="preserve">
          <source>Astonished Face</source>
          <target state="translated">Удивлённое лицо</target>
        </trans-unit>
        <trans-unit id="b66ee82704200b04b4798e66b6593db1b1b13374" translate="yes" xml:space="preserve">
          <source>Asymptotically Equal To</source>
          <target state="translated">Асимптотически равно</target>
        </trans-unit>
        <trans-unit id="5245f726138014634759729b99de5b3247dde5eb" translate="yes" xml:space="preserve">
          <source>AsyncCondition</source>
          <target state="translated">AsyncCondition</target>
        </trans-unit>
        <trans-unit id="8eaa017d84f0d81a23063919ee4ccb624ecbac15" translate="yes" xml:space="preserve">
          <source>AsyncCondition()</source>
          <target state="translated">AsyncCondition()</target>
        </trans-unit>
        <trans-unit id="1b797bdd1bcf1af4799cd31c8e25a767ad70f14e" translate="yes" xml:space="preserve">
          <source>Asynchronous &quot;tasks&quot;, or coroutines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97d88f0cd43a7c5afba791559c54e8c7a9720c83" translate="yes" xml:space="preserve">
          <source>Asynchronous IO and concurrent synchronous writes</source>
          <target state="translated">Асинхронный ввод-вывод и одновременная синхронная запись</target>
        </trans-unit>
        <trans-unit id="8148eff566285bcd48743fb742f972c7a1dd962f" translate="yes" xml:space="preserve">
          <source>Asynchronous Programming</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61dfe1b51eb0bad1bc9d8b0b12b232b76aa4667" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;-O3&lt;/code&gt;, the compiler &lt;em&gt;might&lt;/em&gt; automatically vectorize operations on such tuples. For example, the following program, when compiled with &lt;code&gt;julia -O3&lt;/code&gt; generates two SIMD addition instructions (&lt;code&gt;addps&lt;/code&gt;) on x86 systems:</source>
          <target state="translated">При &lt;code&gt;-O3&lt;/code&gt; компилятор &lt;em&gt;может&lt;/em&gt; автоматически векторизовать операции с такими кортежами. Например, следующая программа при компиляции с &lt;code&gt;julia -O3&lt;/code&gt; генерирует две инструкции сложения SIMD ( &lt;code&gt;addps&lt;/code&gt; ) в системах x86:</target>
        </trans-unit>
        <trans-unit id="eb9e6602f2f530b7763a4fc47a789b6bcda1d592" translate="yes" xml:space="preserve">
          <source>At a high-level, each environment conceptually defines three maps: roots, graph and paths. When resolving the meaning of &lt;code&gt;import X&lt;/code&gt;, the roots and graph maps are used to determine the identity of &lt;code&gt;X&lt;/code&gt;, while the paths map is used to locate the source code of &lt;code&gt;X&lt;/code&gt;. The specific roles of the three maps are:</source>
          <target state="translated">На высоком уровне каждая среда концептуально определяет три карты: корни, граф и пути. При решении значения &lt;code&gt;import X&lt;/code&gt; , корни и карты графиков используются для определения идентичности &lt;code&gt;X&lt;/code&gt; , в то время как карта пути используется , чтобы найти исходный код &lt;code&gt;X&lt;/code&gt; . Особые роли трех карт:</target>
        </trans-unit>
        <trans-unit id="1f9ae804041641dde19215ce7dbf17a3259634a7" translate="yes" xml:space="preserve">
          <source>At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic. The first and most obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and replace the result with &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin(Int)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax(Int)&lt;/code&gt;&lt;/a&gt; as appropriate. This alone expands each integer operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse &amp;ndash; saturating integer arithmetic isn't associative. Consider this Matlab computation:</source>
          <target state="translated">На первый взгляд это кажется достаточно разумным, поскольку 9223372036854775807 намного ближе к 9223372036854775808, чем -9223372036854775808, и целые числа по-прежнему представлены с фиксированным размером естественным образом, совместимым с C и Фортраном. Однако насыщенная целочисленная арифметика представляет собой серьезную проблему. Первая и наиболее очевидная проблема заключается в том, что машинная целочисленная арифметика работает не так, поэтому реализация насыщенных операций требует выдачи инструкций после каждой машинной целочисленной операции для проверки отсутствия переполнения или переполнения и замены результата на &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin(Int)&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax(Int)&lt;/code&gt; &lt;/a&gt;по мере необходимости. Одно только это расширяет каждую целочисленную операцию из одной быстрой инструкции до полудюжины инструкций, возможно, включая ветки. Уч. Но становится еще хуже - насыщающая целочисленная арифметика не ассоциативна. Рассмотрим это вычисление в Matlab:</target>
        </trans-unit>
        <trans-unit id="9939b5009359c95078c2105da459f4858711c0ae" translate="yes" xml:space="preserve">
          <source>At least Julia 1.4 is required for specifying a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557269c7906899330df530ce61ccdd6c30d22fca" translate="yes" xml:space="preserve">
          <source>At the base of this functionality is &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo&lt;/code&gt;&lt;/a&gt;, which will do the appropriate address resolution:</source>
          <target state="translated">В основе этой функции лежит &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo&lt;/code&gt; &lt;/a&gt; , который будет выполнять соответствующее разрешение адресов:</target>
        </trans-unit>
        <trans-unit id="dc65621fc57dd780fd2d22a2ad965178ea5de343" translate="yes" xml:space="preserve">
          <source>At the top, the inferred return type of the function is shown as &lt;code&gt;Body::Float64&lt;/code&gt;. The next lines represent the body of &lt;code&gt;f&lt;/code&gt; in Julia's SSA IR form. The numbered boxes are labels and represent targets for jumps (via &lt;code&gt;goto&lt;/code&gt;) in your code. Looking at the body, you can see that the first thing that happens is that &lt;code&gt;pos&lt;/code&gt; is called and the return value has been inferred as the &lt;code&gt;Union&lt;/code&gt; type &lt;code&gt;UNION{FLOAT64, INT64}&lt;/code&gt; shown in uppercase since it is a non-concrete type. This means that we cannot know the exact return type of &lt;code&gt;pos&lt;/code&gt; based on the input types. However, the result of &lt;code&gt;y*x&lt;/code&gt;is a &lt;code&gt;Float64&lt;/code&gt; no matter if &lt;code&gt;y&lt;/code&gt; is a &lt;code&gt;Float64&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt; The net result is that &lt;code&gt;f(x::Float64)&lt;/code&gt; will not be type-unstable in its output, even if some of the intermediate computations are type-unstable.</source>
          <target state="translated">Вверху предполагаемый тип возвращаемого значения функции показан как &lt;code&gt;Body::Float64&lt;/code&gt; . Следующие строки представляют собой тело &lt;code&gt;f&lt;/code&gt; в форме SSA IR Джулии. Пронумерованные поля являются метками и представляют цели для переходов (через &lt;code&gt;goto&lt;/code&gt; ) в вашем коде. Глядя на тело, вы можете увидеть, что первое, что происходит, - это вызов &lt;code&gt;pos&lt;/code&gt; , и возвращаемое значение выводится как тип &lt;code&gt;Union&lt;/code&gt; &lt;code&gt;UNION{FLOAT64, INT64}&lt;/code&gt; показанный в верхнем регистре, поскольку это не конкретный тип. Это означает, что мы не можем знать точный тип возврата &lt;code&gt;pos&lt;/code&gt; на основе типов ввода. Однако результатом &lt;code&gt;y*x&lt;/code&gt; будет &lt;code&gt;Float64&lt;/code&gt; независимо от того, если &lt;code&gt;y&lt;/code&gt; является &lt;code&gt;Float64&lt;/code&gt; или &lt;code&gt;Int64&lt;/code&gt; .Конечный результат состоит в том, что &lt;code&gt;f(x::Float64)&lt;/code&gt; не будет нестабильным по типу в своем выводе, даже если некоторые из промежуточных вычислений являются нестабильными по типу.</target>
        </trans-unit>
        <trans-unit id="4b8bfb8cb1b051b835dbefff1b5c12822cd90431" translate="yes" xml:space="preserve">
          <source>At this point, the project should build and run.</source>
          <target state="translated">На этом этапе проект должен быть построен и запущен.</target>
        </trans-unit>
        <trans-unit id="07f4310d23db89112b431f6fd02d1ccd231d2fd9" translate="yes" xml:space="preserve">
          <source>At this time, most operations in the Julia runtime and standard libraries can be used in a thread-safe manner, if the user code is data-race free. However, in some areas work on stabilizing thread support is ongoing. Multi-threaded programming has many inherent difficulties, and if a program using threads exhibits unusual or undesirable behavior (e.g. crashes or mysterious results), thread interactions should typically be suspected first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e4a73a06b9dee6071ddafa6ecf05d8154a9294" translate="yes" xml:space="preserve">
          <source>Athletic Shoe</source>
          <target state="translated">Атлетическая обувь</target>
        </trans-unit>
        <trans-unit id="f3fbd2fd9cc354420ab6c1b9170e0b29144a85e6" translate="yes" xml:space="preserve">
          <source>Atomic Operations</source>
          <target state="translated">Атомные операции</target>
        </trans-unit>
        <trans-unit id="ad3b6bf5f22249f1093a69cf5b097656cf10a2e0" translate="yes" xml:space="preserve">
          <source>Atomic objects can be accessed using the &lt;code&gt;[]&lt;/code&gt; notation:</source>
          <target state="translated">Доступ к атомарным объектам можно получить с помощью обозначения &lt;code&gt;[]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fb34ad6782840b3609292d56d50524837de11852" translate="yes" xml:space="preserve">
          <source>Atomic operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b48033c48155a217b1ebf999c90a4b598f3e71" translate="yes" xml:space="preserve">
          <source>Atomic operations use an &lt;code&gt;atomic_&lt;/code&gt; prefix, such as &lt;a href=&quot;#Base.Threads.atomic_add!&quot;&gt;&lt;code&gt;atomic_add!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.Threads.atomic_xchg!&quot;&gt;&lt;code&gt;atomic_xchg!&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">Атомарные операции используют префикс &lt;code&gt;atomic_&lt;/code&gt; , например &lt;a href=&quot;#Base.Threads.atomic_add!&quot;&gt; &lt;code&gt;atomic_add!&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#Base.Threads.atomic_xchg!&quot;&gt; &lt;code&gt;atomic_xchg!&lt;/code&gt; &lt;/a&gt;, и т.д.</target>
        </trans-unit>
        <trans-unit id="ad6e575d4f77e8328667d22e1296bcc529f4eb15" translate="yes" xml:space="preserve">
          <source>Atomically add &lt;code&gt;val&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Атомно добавить &lt;code&gt;val&lt;/code&gt; к &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98b4786f90c42de0fa6575d5c8690c2d57540c23" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-and &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">Атомарно побитовое и &lt;code&gt;x&lt;/code&gt; с &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c59f0d3e8acb12180dbf858879145e09dbd4d31" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-nand (not-and) &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">Атомарно поразрядно-nand (not-and) &lt;code&gt;x&lt;/code&gt; с &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49dfbe4ce1039803bba1e66c619d680aaacd0303" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-or &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">Атомарно побитовое или &lt;code&gt;x&lt;/code&gt; с &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="361657c422d3986bfb8673c88d09205f8b549983" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-xor (exclusive-or) &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">Атомарно побитовый xor (исключающее ИЛИ) &lt;code&gt;x&lt;/code&gt; с &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720563406f6bfeb8b472dd6dd26fe3888437904c" translate="yes" xml:space="preserve">
          <source>Atomically compare-and-set &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Атомарно сравнить и установить &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cea0404569a918b8e5d8c74ca2a23340344009b" translate="yes" xml:space="preserve">
          <source>Atomically compares the value in &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;cmp&lt;/code&gt;. If equal, write &lt;code&gt;newval&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. Otherwise, leaves &lt;code&gt;x&lt;/code&gt; unmodified. Returns the old value in &lt;code&gt;x&lt;/code&gt;. By comparing the returned value to &lt;code&gt;cmp&lt;/code&gt; (via &lt;code&gt;===&lt;/code&gt;) one knows whether &lt;code&gt;x&lt;/code&gt; was modified and now holds the new value &lt;code&gt;newval&lt;/code&gt;.</source>
          <target state="translated">Атомарно сравнивает значение в &lt;code&gt;x&lt;/code&gt; с &lt;code&gt;cmp&lt;/code&gt; . Если равно, запишите &lt;code&gt;newval&lt;/code&gt; в &lt;code&gt;x&lt;/code&gt; . В противном случае оставляет &lt;code&gt;x&lt;/code&gt; без изменений. Возвращает старое значение в &lt;code&gt;x&lt;/code&gt; . Сравнивая возвращаемое значение с &lt;code&gt;cmp&lt;/code&gt; (через &lt;code&gt;===&lt;/code&gt; ), можно узнать, был ли изменен &lt;code&gt;x&lt;/code&gt; и теперь он содержит новое значение &lt;code&gt;newval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db092cd5c9d8911e3a523593755743a6ba3ff929" translate="yes" xml:space="preserve">
          <source>Atomically exchange the value in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Атомно поменять значение в &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ede158726902e9e7c885034b5dc7b476eaa3f0cb" translate="yes" xml:space="preserve">
          <source>Atomically exchanges the value in &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;newval&lt;/code&gt;. Returns the &lt;strong&gt;old&lt;/strong&gt; value.</source>
          <target state="translated">&lt;code&gt;newval&lt;/code&gt; значение в &lt;code&gt;x&lt;/code&gt; на newval . Возвращает &lt;strong&gt;старое&lt;/strong&gt; значение.</target>
        </trans-unit>
        <trans-unit id="c3d2e4b23d13f6bba7a47950035a93b86bb83a39" translate="yes" xml:space="preserve">
          <source>Atomically store the maximum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Атомарно сохранить максимум &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;val&lt;/code&gt; в &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df88790f08323bff2d950ce1c8f1b209a38e86ef" translate="yes" xml:space="preserve">
          <source>Atomically store the minimum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Атомно сохранить минимум &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;val&lt;/code&gt; в &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="689e84464421ff470b8dc38055180d25d70684c4" translate="yes" xml:space="preserve">
          <source>Atomically subtract &lt;code&gt;val&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Атомарно вычесть &lt;code&gt;val&lt;/code&gt; из &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a5910ec96daddf32d8679bdc1681e3d2b896833" translate="yes" xml:space="preserve">
          <source>Attempt an automatic merge rebase of the current branch, from &lt;code&gt;upstream&lt;/code&gt; if provided, or otherwise from the upstream tracking branch. &lt;code&gt;newbase&lt;/code&gt; is the branch to rebase onto. By default this is &lt;code&gt;upstream&lt;/code&gt;.</source>
          <target state="translated">Попытка автоматического слияния перебазирования текущей ветви из &lt;code&gt;upstream&lt;/code&gt; если оно предусмотрено, или иным образом из восходящей ветви отслеживания. &lt;code&gt;newbase&lt;/code&gt; - это ветка, на которую нужно перебазироваться. По умолчанию это &lt;code&gt;upstream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67fbdff1fd74a3e2ffeba20e52cb54a817a837a9" translate="yes" xml:space="preserve">
          <source>Aubergine</source>
          <target state="translated">Aubergine</target>
        </trans-unit>
        <trans-unit id="237f5a2b8d61f639bee4e8b48edc5e86ef3821ad" translate="yes" xml:space="preserve">
          <source>Auto-conversion:</source>
          <target state="translated">Auto-conversion:</target>
        </trans-unit>
        <trans-unit id="83f8ababd899b8c0947ef4217c49ed91a00e554d" translate="yes" xml:space="preserve">
          <source>Automated Teller Machine</source>
          <target state="translated">Автоматический автомат продавца</target>
        </trans-unit>
        <trans-unit id="674ab38ea62e0b4a07e2dda58e235dd6968ef52f" translate="yes" xml:space="preserve">
          <source>Automatic Type Conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ff4de6909c953084efbf3fcf51ba0455525196" translate="yes" xml:space="preserve">
          <source>Automatic generation of efficient, specialized code for different argument types</source>
          <target state="translated">Автоматическая генерация эффективного,специализированного кода для различных типов аргументов</target>
        </trans-unit>
        <trans-unit id="e3d0413f1114ca7420957b409369ba320c5e643a" translate="yes" xml:space="preserve">
          <source>Automobile</source>
          <target state="translated">Automobile</target>
        </trans-unit>
        <trans-unit id="c2381c9ae6de19786317e42c36cfe48f1d110cd4" translate="yes" xml:space="preserve">
          <source>Available for method extension</source>
          <target state="translated">Доступно для расширения метода</target>
        </trans-unit>
        <trans-unit id="1913fba71b8ad5575c96582256e93730389a751d" translate="yes" xml:space="preserve">
          <source>Avoid changing the type of a variable</source>
          <target state="translated">Избегайте изменения типа переменной</target>
        </trans-unit>
        <trans-unit id="491716d25d0cc5eef3fc083042b6cf3fb1c73628" translate="yes" xml:space="preserve">
          <source>Avoid confusion about whether something is an instance or a type</source>
          <target state="translated">Избегайте путаницы в том,является ли что-то примером или типом.</target>
        </trans-unit>
        <trans-unit id="f43c7e32c4f8af3884df62b42a58c3f06c2cb00b" translate="yes" xml:space="preserve">
          <source>Avoid containers with abstract type parameters</source>
          <target state="translated">Избегайте контейнеров с абстрактными параметрами типа</target>
        </trans-unit>
        <trans-unit id="a69832582d8c220962ec16f3f74807795126efb7" translate="yes" xml:space="preserve">
          <source>Avoid elaborate container types</source>
          <target state="translated">Избегайте сложных типов контейнеров</target>
        </trans-unit>
        <trans-unit id="5a42b7935afc0b3ec5008a2229ca382f69673505" translate="yes" xml:space="preserve">
          <source>Avoid fields with abstract containers</source>
          <target state="translated">Избегайте полей с абстрактными контейнерами</target>
        </trans-unit>
        <trans-unit id="f619d134c2c6942d7932e906b9ce6c23d632cfef" translate="yes" xml:space="preserve">
          <source>Avoid fields with abstract type</source>
          <target state="translated">Избегайте полей с абстрактным типом</target>
        </trans-unit>
        <trans-unit id="ea9c797001a229bb0f7e2e5dcae3538ba2a55b2c" translate="yes" xml:space="preserve">
          <source>Avoid global variables</source>
          <target state="translated">Избегайте глобальных переменных</target>
        </trans-unit>
        <trans-unit id="8c84ddcd06891b88969d0af7db4510b7be8ee56a" translate="yes" xml:space="preserve">
          <source>Avoid running top-level operations, e.g. &lt;code&gt;include&lt;/code&gt;, or &lt;code&gt;eval&lt;/code&gt; of type, method, and module definitions in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b73d63c4cb77f3bf8c6e423749bbf23c01ee5d" translate="yes" xml:space="preserve">
          <source>Avoid strange type &lt;code&gt;Union&lt;/code&gt;s</source>
          <target state="translated">Избегайте странного типа &lt;code&gt;Union&lt;/code&gt; s</target>
        </trans-unit>
        <trans-unit id="79292115b6e992f614cf724c1dfa9586d06bbe03" translate="yes" xml:space="preserve">
          <source>Avoid string interpolation for I/O</source>
          <target state="translated">Избегайте строковой интерполяции для ввода/вывода</target>
        </trans-unit>
        <trans-unit id="8a11c76e8b2bd9a028ae58c6c15b510f4680d17f" translate="yes" xml:space="preserve">
          <source>Avoid type piracy</source>
          <target state="translated">Избегайте типового пиратства</target>
        </trans-unit>
        <trans-unit id="bf3ba609a722d28177b4a138e6e131e1148dc2ff" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary arrays. For example, instead of &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum([x,y,z])&lt;/code&gt;&lt;/a&gt; use &lt;code&gt;x+y+z&lt;/code&gt;.</source>
          <target state="translated">Избегайте ненужных массивов. Например, вместо &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum([x,y,z])&lt;/code&gt; &lt;/a&gt; используйте &lt;code&gt;x+y+z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9540041dc787b11f982141e4085503960ffd2c7" translate="yes" xml:space="preserve">
          <source>Avoid using floats for numeric literals in generic code when possible</source>
          <target state="translated">По возможности избегать использования флоатов для числовых литералов в общем коде.</target>
        </trans-unit>
        <trans-unit id="4802b2a45694be10a378fb271220844de2096707" translate="yes" xml:space="preserve">
          <source>Avoid using passwords in URLs. Unlike the credential objects, Julia is not able to securely zero or destroy the sensitive data after use and the password may remain in memory; possibly to be exposed by an uninitialized memory.</source>
          <target state="translated">Избегайте использования паролей в URL-адресах.В отличие от объектов мандатов,Джулия не может безопасно обнулить или уничтожить конфиденциальные данные после использования,а пароль может остаться в памяти;возможно,он будет открыт неинициализированной памятью.</target>
        </trans-unit>
        <trans-unit id="2371521c12f038f3e299464707c70bda3ff3e6b1" translate="yes" xml:space="preserve">
          <source>Avoid writing overly-specific types</source>
          <target state="translated">Избегайте слишком специфических видов письма</target>
        </trans-unit>
        <trans-unit id="5073587ca8bbf875c2d3d248119f4effa8701deb" translate="yes" xml:space="preserve">
          <source>Avoiding Deadlock in Pipelines</source>
          <target state="translated">Предотвращение тупика в трубопроводах</target>
        </trans-unit>
        <trans-unit id="65b99874e3a064ddb84e4d624ff070c43bf412eb" translate="yes" xml:space="preserve">
          <source>Avoiding changing the value of global variables is considered by many to be a programming best-practice. Changing the value of a global variable can cause &quot;action at a distance&quot;, making the behavior of a program harder to reason about. This is why the scope blocks that introduce local scope require the &lt;code&gt;global&lt;/code&gt; keyword to declare the intent to modify a global variable.</source>
          <target state="translated">Многие считают, что избегание изменения значений глобальных переменных является лучшей практикой программирования. Изменение значения глобальной переменной может вызвать &amp;laquo;действие на расстоянии&amp;raquo;, что затрудняет анализ поведения программы. Вот почему блоки области видимости, которые представляют локальную область видимости, требуют, чтобы ключевое слово &lt;code&gt;global&lt;/code&gt; объявляло намерение изменить глобальную переменную.</target>
        </trans-unit>
        <trans-unit id="5b00714b611fee1b5fd3b2b1cfc1708286a4e472" translate="yes" xml:space="preserve">
          <source>Avoiding globals</source>
          <target state="translated">Избегая шаров</target>
        </trans-unit>
        <trans-unit id="4e9ba62b391f99ca62e6bfebe5faa916e7ed0f96" translate="yes" xml:space="preserve">
          <source>Awad H. Al-Mohy and Nicholas J. Higham, &quot;Improved inverse scaling and squaring algorithms for the matrix logarithm&quot;, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. &lt;a href=&quot;https://doi.org/10.1137/110852553&quot;&gt;doi:10.1137/110852553&lt;/a&gt;</source>
          <target state="translated">Авад Х. Аль-Мохи и Николас Дж. Хайэм, &quot;Улучшенные алгоритмы обратного масштабирования и возведения в квадрат для матричного логарифма&quot;, SIAM Journal on Scientific Computing, 34 (4), 2012, C153-C169. &lt;a href=&quot;https://doi.org/10.1137/110852553&quot;&gt;DOI: 10,1137 / 110852553&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12401b9104fcd17aca879a9457a3f9b5a0090df6" translate="yes" xml:space="preserve">
          <source>Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, &quot;Computing the Fr&amp;eacute;chet derivative of the matrix logarithm and estimating the condition number&quot;, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. &lt;a href=&quot;https://doi.org/10.1137/120885991&quot;&gt;doi:10.1137/120885991&lt;/a&gt;</source>
          <target state="translated">Авад Х. Аль-Мохи, Николас Дж. Хайэм и Сэмюэл Д. Релтон, &amp;laquo;Вычисление производной Фреше матричного логарифма и оценка числа обусловленности&amp;raquo;, SIAM Journal on Scientific Computing, 35 (4), 2013, C394-C410. &lt;a href=&quot;https://doi.org/10.1137/120885991&quot;&gt;DOI: 10,1137 / 120885991&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6dad1f19392ce0b096b44b01c81c76a664e7337c" translate="yes" xml:space="preserve">
          <source>B&amp;eacute;zout coefficients are &lt;em&gt;not&lt;/em&gt; uniquely defined. &lt;code&gt;gcdx&lt;/code&gt; returns the minimal B&amp;eacute;zout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are minimal in the sense that $|u| &amp;lt; |y/d|$ and $|v| &amp;lt; |x/d|$. Furthermore, the signs of &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are chosen so that &lt;code&gt;d&lt;/code&gt; is positive. For unsigned integers, the coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; might be near their &lt;code&gt;typemax&lt;/code&gt;, and the identity then holds only via the unsigned integers' modulo arithmetic.</source>
          <target state="translated">Коэффициенты Безу &lt;em&gt;не&lt;/em&gt; определены однозначно. &lt;code&gt;gcdx&lt;/code&gt; возвращает минимальные коэффициенты Безу, которые вычисляются расширенным алгоритмом Евклида. (См. Д. Кнут, TAoCP, 2 / e, стр. 325, алгоритм X.) Для целых чисел со знаком эти коэффициенты &lt;code&gt;u&lt;/code&gt; и &lt;code&gt;v&lt;/code&gt; минимальны в том смысле, что $ | u | &amp;lt;| y / d | $ и $ | v | &amp;lt;| х / д | $. Кроме того, знаки &lt;code&gt;u&lt;/code&gt; и &lt;code&gt;v&lt;/code&gt; выбраны так, чтобы &lt;code&gt;d&lt;/code&gt; было положительным. Для целых чисел без знака коэффициенты &lt;code&gt;u&lt;/code&gt; и &lt;code&gt;v&lt;/code&gt; могут быть близки к их &lt;code&gt;typemax&lt;/code&gt; , и тогда идентичность сохраняется только через арифметику целых чисел без знака по модулю.</target>
        </trans-unit>
        <trans-unit id="0f4d56d1e20778bf2e1052ecb3219509238fb660" translate="yes" xml:space="preserve">
          <source>BD</source>
          <target state="translated">BD</target>
        </trans-unit>
        <trans-unit id="2868e5c7bf03fbd81359d6f8be00b333b386ffca" translate="yes" xml:space="preserve">
          <source>BLAS Character Arguments</source>
          <target state="translated">Аргументы о характере BLAS</target>
        </trans-unit>
        <trans-unit id="e299ffe232555a867fe66272d999c06385ea8b66" translate="yes" xml:space="preserve">
          <source>BLAS Functions</source>
          <target state="translated">BLAS-функции</target>
        </trans-unit>
        <trans-unit id="38726bba2d45fa38b747b2e7e3f161c3f4fb4718" translate="yes" xml:space="preserve">
          <source>BLAS character arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f10410d90763f9147a245aec96798dc0ea5a38e4" translate="yes" xml:space="preserve">
          <source>BLAS functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13c3d98d3a2445afc653d610809196ddb501f8c1" translate="yes" xml:space="preserve">
          <source>Baby</source>
          <target state="translated">Baby</target>
        </trans-unit>
        <trans-unit id="404344724dd01c5a65fcea59173146b18cd1b603" translate="yes" xml:space="preserve">
          <source>Baby Angel</source>
          <target state="translated">Маленький Ангел</target>
        </trans-unit>
        <trans-unit id="8b580757a627745bff29a8f25e39330265bdc27b" translate="yes" xml:space="preserve">
          <source>Baby Bottle</source>
          <target state="translated">Детская бутылочка</target>
        </trans-unit>
        <trans-unit id="459882191a5a45ebff1c155b876b56cf4eb8ef5e" translate="yes" xml:space="preserve">
          <source>Baby Chick</source>
          <target state="translated">Маленькая цыпочка</target>
        </trans-unit>
        <trans-unit id="1871c181df7f050df811e7ae71f7e0946094c40f" translate="yes" xml:space="preserve">
          <source>Baby Symbol</source>
          <target state="translated">Детский символ</target>
        </trans-unit>
        <trans-unit id="2867999045ac5ccc323dde4dccea9a973b94383f" translate="yes" xml:space="preserve">
          <source>Back With Leftwards Arrow Above</source>
          <target state="translated">Назад со стрелкой влево выше</target>
        </trans-unit>
        <trans-unit id="cc1f0103d6d9cbde7e99045cc49ad45fc083e009" translate="yes" xml:space="preserve">
          <source>Background and References</source>
          <target state="translated">Справочная информация и ссылки</target>
        </trans-unit>
        <trans-unit id="fc10601fec1e951e91f278b7b703a3337af22c80" translate="yes" xml:space="preserve">
          <source>Backslashes (&lt;code&gt;\&lt;/code&gt;) are escaped with a double-backslash (&lt;code&gt;&quot;\\&quot;&lt;/code&gt;). Non-printable characters are escaped either with their standard C escape codes, &lt;code&gt;&quot;\0&quot;&lt;/code&gt; for NUL (if unambiguous), unicode code point (&lt;code&gt;&quot;\u&quot;&lt;/code&gt; prefix) or hex (&lt;code&gt;&quot;\x&quot;&lt;/code&gt; prefix).</source>
          <target state="translated">Обратная косая черта ( &lt;code&gt;\&lt;/code&gt; ) экранируется двойной обратной косой чертой ( &lt;code&gt;&quot;\\&quot;&lt;/code&gt; ). Непечатаемые символы экранируются стандартными escape-кодами C, &lt;code&gt;&quot;\0&quot;&lt;/code&gt; для NUL (если однозначно), кодовой точкой Unicode ( префикс &lt;code&gt;&quot;\u&quot;&lt;/code&gt; ) или шестнадцатеричным ( префикс &lt;code&gt;&quot;\x&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6d4e3b07bbe1ccb3ac5b9922a337b1d4f919bc4f" translate="yes" xml:space="preserve">
          <source>Backspace, &lt;code&gt;^H&lt;/code&gt;</source>
          <target state="translated">Backspace, &lt;code&gt;^H&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6d84b04bcccd220267af9a3b46464c46ba45d26" translate="yes" xml:space="preserve">
          <source>Bactrian Camel</source>
          <target state="translated">Бактрианский верблюд</target>
        </trans-unit>
        <trans-unit id="447082b449cc1df13e5c0addef786ca50488ff0e" translate="yes" xml:space="preserve">
          <source>Baggage Claim</source>
          <target state="translated">претензия к багажу</target>
        </trans-unit>
        <trans-unit id="ebd009a68817c4cc14d70f9ca5aa28ad5c4de62a" translate="yes" xml:space="preserve">
          <source>Balance the matrix &lt;code&gt;A&lt;/code&gt; before computing its eigensystem or Schur factorization. &lt;code&gt;job&lt;/code&gt; can be one of &lt;code&gt;N&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will not be permuted or scaled), &lt;code&gt;P&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will only be permuted), &lt;code&gt;S&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will only be scaled), or &lt;code&gt;B&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will be both permuted and scaled). Modifies &lt;code&gt;A&lt;/code&gt; in-place and returns &lt;code&gt;ilo&lt;/code&gt;, &lt;code&gt;ihi&lt;/code&gt;, and &lt;code&gt;scale&lt;/code&gt;. If permuting was turned on, &lt;code&gt;A[i,j] = 0&lt;/code&gt; if &lt;code&gt;j &amp;gt; i&lt;/code&gt; and &lt;code&gt;1 &amp;lt; j &amp;lt; ilo&lt;/code&gt; or &lt;code&gt;j &amp;gt; ihi&lt;/code&gt;. &lt;code&gt;scale&lt;/code&gt; contains information about the scaling/permutations performed.</source>
          <target state="translated">Сбалансируйте матрицу &lt;code&gt;A&lt;/code&gt; перед вычислением ее собственной системы или факторизации Шура. &lt;code&gt;job&lt;/code&gt; может быть одним из &lt;code&gt;N&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; не будет переставляться или масштабироваться), &lt;code&gt;P&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; будет только переставляться), &lt;code&gt;S&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; будет только масштабироваться) или &lt;code&gt;B&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; будет и переставляться, и масштабироваться). Изменяет &lt;code&gt;A&lt;/code&gt; на месте и возвращает &lt;code&gt;ilo&lt;/code&gt; , &lt;code&gt;ihi&lt;/code&gt; и &lt;code&gt;scale&lt;/code&gt; . Если перестановка была включена, &lt;code&gt;A[i,j] = 0&lt;/code&gt; если &lt;code&gt;j &amp;gt; i&lt;/code&gt; и &lt;code&gt;1 &amp;lt; j &amp;lt; ilo&lt;/code&gt; или &lt;code&gt;j &amp;gt; ihi&lt;/code&gt; . &lt;code&gt;scale&lt;/code&gt; содержит информацию о выполненном масштабировании / перестановках.</target>
        </trans-unit>
        <trans-unit id="64f241f5415d400e3d7d028f504e941ebbdb9386" translate="yes" xml:space="preserve">
          <source>Balloon</source>
          <target state="translated">Balloon</target>
        </trans-unit>
        <trans-unit id="a5ae768a2f5127a27b546388e40cac06994c9b36" translate="yes" xml:space="preserve">
          <source>Ballot Box With Check</source>
          <target state="translated">Коробка для голосования с чеком</target>
        </trans-unit>
        <trans-unit id="fc6fae10db2bd0b625077d7c6d1b9a96925fd2b7" translate="yes" xml:space="preserve">
          <source>Banana</source>
          <target state="translated">Banana</target>
        </trans-unit>
        <trans-unit id="9e89988cc3fba2850fb19459e04e7b3325be4f84" translate="yes" xml:space="preserve">
          <source>Bank</source>
          <target state="translated">Bank</target>
        </trans-unit>
        <trans-unit id="ef4f81080d95142c3db9938d48a26e8efe95cd36" translate="yes" xml:space="preserve">
          <source>Banknote With Dollar Sign</source>
          <target state="translated">Купюра с долларовым знаком</target>
        </trans-unit>
        <trans-unit id="3177af01daaed29235d1e99ba9255338076b9f27" translate="yes" xml:space="preserve">
          <source>Banknote With Euro Sign</source>
          <target state="translated">Купюра со знаком евро</target>
        </trans-unit>
        <trans-unit id="3a6546fb8ecf3af86528410e140549606f1d3249" translate="yes" xml:space="preserve">
          <source>Banknote With Pound Sign</source>
          <target state="translated">Купюра с фунтом знака</target>
        </trans-unit>
        <trans-unit id="63a28a516e785c09b112a71c85ad02804c64137a" translate="yes" xml:space="preserve">
          <source>Banknote With Yen Sign</source>
          <target state="translated">Купюра с иенской подписью</target>
        </trans-unit>
        <trans-unit id="75fe8df5591aba61913518914c1f05bdb42306e6" translate="yes" xml:space="preserve">
          <source>Bar Chart</source>
          <target state="translated">Бар-график</target>
        </trans-unit>
        <trans-unit id="bddd12f808af35a2e999d9124c970232527e7e1d" translate="yes" xml:space="preserve">
          <source>Barber Pole</source>
          <target state="translated">парикмахерские поляки</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="2aa4376a2de743967992b5357971a1c7721c03e3" translate="yes" xml:space="preserve">
          <source>Base Submodules</source>
          <target state="translated">Базовые субмодули</target>
        </trans-unit>
        <trans-unit id="13b575497d7efff2ec5b49faf71dbac3532ee190" translate="yes" xml:space="preserve">
          <source>Base collection types require manual locking if used simultaneously by multiple threads where at least one thread modifies the collection (common examples include &lt;code&gt;push!&lt;/code&gt; on arrays, or inserting items into a &lt;code&gt;Dict&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="895c330ff6166a7f13701f8d9b78f313787269c8" translate="yes" xml:space="preserve">
          <source>Base64</source>
          <target state="translated">Base64</target>
        </trans-unit>
        <trans-unit id="ec2d7744c603baf507e66bf82835dfb6204656a8" translate="yes" xml:space="preserve">
          <source>Baseball</source>
          <target state="translated">Baseball</target>
        </trans-unit>
        <trans-unit id="bf046bc3c151c25669b6483d54157a9641394a6d" translate="yes" xml:space="preserve">
          <source>Based on this observation, we can conclude that if one of the operands is &lt;code&gt;true&lt;/code&gt; and the other &lt;code&gt;missing&lt;/code&gt;, we know that the result is &lt;code&gt;true&lt;/code&gt; in spite of the uncertainty about the actual value of one of the operands. If we had been able to observe the actual value of the second operand, it could only be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, and in both cases the result would be &lt;code&gt;true&lt;/code&gt;. Therefore, in this particular case, missingness does &lt;em&gt;not&lt;/em&gt; propagate</source>
          <target state="translated">Основываясь на этом наблюдении, мы можем сделать вывод, что если один из операндов &lt;code&gt;true&lt;/code&gt; а другой &lt;code&gt;missing&lt;/code&gt; , мы знаем, что результат &lt;code&gt;true&lt;/code&gt; несмотря на неопределенность фактического значения одного из операндов. Если бы мы могли наблюдать фактическое значение второго операнда, оно могло бы быть только &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; , и в обоих случаях результат был бы &lt;code&gt;true&lt;/code&gt; . Следовательно, в данном конкретном случае отсутствие &lt;em&gt;не&lt;/em&gt; распространяется.</target>
        </trans-unit>
        <trans-unit id="791f5b6a2aaabca7a2c4cad24b70f6e46c76fdcc" translate="yes" xml:space="preserve">
          <source>Basic &lt;code&gt;Task&lt;/code&gt; operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01a71bb934cc266c2f79a70a4a484bfb32292d0" translate="yes" xml:space="preserve">
          <source>Basic Functions</source>
          <target state="translated">Основные функции</target>
        </trans-unit>
        <trans-unit id="aeb63e6ce576503861f1c499cfdf84cff87567db" translate="yes" xml:space="preserve">
          <source>Basic Stream I/O</source>
          <target state="translated">Базовый вход/выход потока</target>
        </trans-unit>
        <trans-unit id="f9e89ba8027afc2d4c24183a1cbbfbb04137326a" translate="yes" xml:space="preserve">
          <source>Basic Unit Tests</source>
          <target state="translated">Испытания базовых блоков</target>
        </trans-unit>
        <trans-unit id="58c96a6812d6bac9777029dd40fb7e6afd5c8c94" translate="yes" xml:space="preserve">
          <source>Basic functions</source>
          <target state="translated">Основные функции</target>
        </trans-unit>
        <trans-unit id="24be2e19e7e4671eaee4ac0a6f5a6a524bab3529" translate="yes" xml:space="preserve">
          <source>Basic tables can be written using the syntax described below. Note that markdown tables have limited features and cannot contain nested toplevel elements unlike other elements discussed above &amp;ndash; only inline elements are allowed. Tables must always contain a header row with column names. Cells cannot span multiple rows or columns of the table.</source>
          <target state="translated">Базовые таблицы могут быть написаны с использованием синтаксиса, описанного ниже. Обратите внимание, что таблицы уценки имеют ограниченные возможности и не могут содержать вложенные элементы верхнего уровня, в отличие от других элементов, рассмотренных выше - разрешены только встроенные элементы. Таблицы всегда должны содержать строку заголовка с именами столбцов. Ячейки не могут занимать несколько строк или столбцов таблицы.</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">Основное использование</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="25cdb3adf0a06c600dd49fc47c73f5654e3fddf0" translate="yes" xml:space="preserve">
          <source>Basketball And Hoop</source>
          <target state="translated">Баскетбол и Хуп</target>
        </trans-unit>
        <trans-unit id="a687b3ff7f182c39a1247454d3d7927ea0efa80d" translate="yes" xml:space="preserve">
          <source>Bath</source>
          <target state="translated">Bath</target>
        </trans-unit>
        <trans-unit id="24f0469ed67f7f88a5ef12c0cd27feac4f206fb4" translate="yes" xml:space="preserve">
          <source>Bathtub</source>
          <target state="translated">Bathtub</target>
        </trans-unit>
        <trans-unit id="4a9be042afe6257111a01c05b72af9f1f3015176" translate="yes" xml:space="preserve">
          <source>Battery</source>
          <target state="translated">Battery</target>
        </trans-unit>
        <trans-unit id="5efe26975abbced9003edb837133f3af03f436e7" translate="yes" xml:space="preserve">
          <source>Be aware of when Julia avoids specializing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d363e26ebe520321aa01d471833fdb370bebd1b2" translate="yes" xml:space="preserve">
          <source>Be aware of when a macro could really be a function instead.</source>
          <target state="translated">Помните,когда макрос действительно может быть функцией.</target>
        </trans-unit>
        <trans-unit id="f0826b18a2138cb79c2b1a66c614cdb664f937ef" translate="yes" xml:space="preserve">
          <source>Be aware that finalizers registered by a library may break if threads are enabled. This may require some transitional work across the ecosystem before threading can be widely adopted with confidence. See the next section for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c70535563b2fda1a64503b874c826edb8884cf" translate="yes" xml:space="preserve">
          <source>Be aware that this strategy has at least one major disadvantage: in many cases, it is not possible for users to further customize the behavior of &lt;code&gt;f&lt;/code&gt; by defining further specializations of your exported function &lt;code&gt;f&lt;/code&gt;. Instead, they have to define specializations for your internal methods &lt;code&gt;_fA&lt;/code&gt; and &lt;code&gt;_fB&lt;/code&gt;, and this blurs the lines between exported and internal methods.</source>
          <target state="translated">Имейте в виду, что эта стратегия имеет по крайней мере один серьезный недостаток: во многих случаях пользователи не могут дополнительно настроить поведение &lt;code&gt;f&lt;/code&gt; путем определения дополнительных специализаций вашей экспортируемой функции &lt;code&gt;f&lt;/code&gt; . Вместо этого они должны определить специализации для ваших внутренних методов &lt;code&gt;_fA&lt;/code&gt; и &lt;code&gt;_fB&lt;/code&gt; , и это стирает границы между экспортируемыми и внутренними методами.</target>
        </trans-unit>
        <trans-unit id="9beb1443ec7c795007b178f28f0ce7235335f46d" translate="yes" xml:space="preserve">
          <source>Be careful to ensure that a Julia reference to &lt;code&gt;x&lt;/code&gt; exists as long as the result of this function will be used. Accordingly, the argument &lt;code&gt;x&lt;/code&gt; to this function should never be an expression, only a variable name or field reference. For example, &lt;code&gt;x=a.b.c&lt;/code&gt; is acceptable, but &lt;code&gt;x=[a,b,c]&lt;/code&gt; is not.</source>
          <target state="translated">Будьте осторожны и убедитесь, что ссылка Julia на &lt;code&gt;x&lt;/code&gt; существует до тех пор, пока будет использоваться результат этой функции. Соответственно, аргумент &lt;code&gt;x&lt;/code&gt; этой функции никогда не должен быть выражением, а только именем переменной или ссылкой на поле. Например, &lt;code&gt;x=a.b.c&lt;/code&gt; приемлемо, а &lt;code&gt;x=[a,b,c]&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="fe66257c8592b5cf4fc84f98162f41a3e02473c6" translate="yes" xml:space="preserve">
          <source>Be careful when using &lt;code&gt;invoke&lt;/code&gt; for functions that you don't write. What definition is used for given &lt;code&gt;argtypes&lt;/code&gt; is an implementation detail unless the function is explicitly states that calling with certain &lt;code&gt;argtypes&lt;/code&gt; is a part of public API. For example, the change between &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt; in the example below is usually considered compatible because the change is invisible by the caller with a normal (non-&lt;code&gt;invoke&lt;/code&gt;) call. However, the change is visible if you use &lt;code&gt;invoke&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590d4269627728c65164df59752ab3f2172388df" translate="yes" xml:space="preserve">
          <source>Be careful with non-constant global variables in Julia, especially in tight loops. Since you can write close-to-metal code in Julia (unlike Python), the effect of globals can be drastic (see &lt;a href=&quot;../performance-tips/index#man-performance-tips&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb87858674ab3ef5b1beab58a7148fcb802f60e" translate="yes" xml:space="preserve">
          <source>Be careful with type equality</source>
          <target state="translated">Будьте осторожны с типом равенства</target>
        </trans-unit>
        <trans-unit id="8bfb6bdbe4ae64df10562422552d5b22da6f47fc" translate="yes" xml:space="preserve">
          <source>Beamed Eighth Notes / Barred Eighth Notes</source>
          <target state="translated">Восьмые ноты с лучами/Запрещенные восемь нот</target>
        </trans-unit>
        <trans-unit id="c8d8cb92fc4cef48d0b0c66441f7a0ef79489b94" translate="yes" xml:space="preserve">
          <source>Bear Face</source>
          <target state="translated">Медвежье лицо</target>
        </trans-unit>
        <trans-unit id="aa8c1d8ab7be7fc9804d2a597a6630cb0b4cde3e" translate="yes" xml:space="preserve">
          <source>Beating Heart</source>
          <target state="translated">Бьющееся сердце</target>
        </trans-unit>
        <trans-unit id="eaebe47425c9f545a41d705608612a34bef824ca" translate="yes" xml:space="preserve">
          <source>Because</source>
          <target state="translated">Because</target>
        </trans-unit>
        <trans-unit id="3b0620b59c6d57d025b388d048ef8892a00c82a2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;a&lt;/code&gt; is a an array of abstract type &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt;, it must be able to hold any &lt;code&gt;Real&lt;/code&gt; value. Since &lt;code&gt;Real&lt;/code&gt; objects can be of arbitrary size and structure, &lt;code&gt;a&lt;/code&gt; must be represented as an array of pointers to individually allocated &lt;code&gt;Real&lt;/code&gt; objects. However, if we instead only allow numbers of the same type, e.g. &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, to be stored in &lt;code&gt;a&lt;/code&gt; these can be stored more efficiently:</source>
          <target state="translated">Поскольку &lt;code&gt;a&lt;/code&gt; является массивом абстрактного типа &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; , он должен содержать любое значение &lt;code&gt;Real&lt;/code&gt; . Так как &lt;code&gt;Real&lt;/code&gt; объекты могут иметь произвольный размер и структуру, должен быть представлен в виде массива указателей на индивидуально выделенных &lt;code&gt;Real&lt;/code&gt; объектов. Однако, если мы вместо этого разрешаем хранить в &lt;code&gt;a&lt;/code&gt; только числа одного типа, например &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; , их можно будет хранить более эффективно: &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9408c8b817a5e76474fc2023c5d1c8f64eadcc39" translate="yes" xml:space="preserve">
          <source>Because C doesn't support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, you need to first encapsulate the value inside a &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref{T}&lt;/code&gt;&lt;/a&gt; of the appropriate type. When you pass this &lt;code&gt;Ref&lt;/code&gt; object as an argument, Julia will automatically pass a C pointer to the encapsulated data:</source>
          <target state="translated">Поскольку C не поддерживает несколько возвращаемых значений, часто функции C принимают указатели на данные, которые функция будет изменять. Чтобы выполнить это в &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; , вам нужно сначала инкапсулировать значение в &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref{T}&lt;/code&gt; &lt;/a&gt; соответствующего типа. Когда вы передаете этот объект &lt;code&gt;Ref&lt;/code&gt; в качестве аргумента, Джулия автоматически передает указатель C на инкапсулированные данные:</target>
        </trans-unit>
        <trans-unit id="d44d25a0390ec817de43e662485f00ec7ef00a32" translate="yes" xml:space="preserve">
          <source>Because Julia's compiler is different from the interpreters used for languages like Python or R, you may find that Julia's performance is unintuitive at first. If you find that something is slow, we highly recommend reading through the &lt;a href=&quot;manual/performance-tips/index#man-performance-tips&quot;&gt;Performance Tips&lt;/a&gt; section before trying anything else. Once you understand how Julia works, it's easy to write code that's nearly as fast as C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46c2c088cdd51f72db20e5f94b9c484cd07ee1a5" translate="yes" xml:space="preserve">
          <source>Because Julia's compiler is different from the interpreters used for languages like Python or R, you may find that Julia's performance is unintuitive at first. If you find that something is slow, we highly recommend reading through the &lt;a href=&quot;manual/performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt; section before trying anything else. Once you understand how Julia works, it's easy to write code that's nearly as fast as C.</source>
          <target state="translated">Поскольку компилятор Джулии отличается от интерпретаторов, используемых для таких языков, как Python или R, вы можете обнаружить, что производительность Джулии поначалу не интуитивна. Если вы обнаружите, что что-то работает медленно, мы настоятельно рекомендуем прочитать раздел &amp;laquo; &lt;a href=&quot;manual/performance-tips/index#man-performance-tips-1&quot;&gt;Советы&lt;/a&gt; по производительности &amp;raquo;, прежде чем пробовать что-либо еще. Как только вы поймете, как работает Джулия, легко написать код, который почти так же быстр, как C.</target>
        </trans-unit>
        <trans-unit id="7d35da8223bf95881284388f273666759cae71cf" translate="yes" xml:space="preserve">
          <source>Because finalizers can interrupt any code, they must be very careful in how they interact with any global state. Unfortunately, the main reason that finalizers are used is to update global state (a pure function is generally rather pointless as a finalizer). This leads us to a bit of a conundrum. There are a few approaches to dealing with this problem:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57b0f43957e0dd94a3628a775697cb33089c39f" translate="yes" xml:space="preserve">
          <source>Because of these shared properties, these types are internally represented as instances of the same concept, &lt;code&gt;DataType&lt;/code&gt;, which is the type of any of these types:</source>
          <target state="translated">Из-за этих общих свойств эти типы внутренне представлены как экземпляры одной и той же концепции &lt;code&gt;DataType&lt;/code&gt; , которая является типом любого из этих типов:</target>
        </trans-unit>
        <trans-unit id="42b7af0f4b58f310d2c30a12b918265991dec35c" translate="yes" xml:space="preserve">
          <source>Because of variable-length encodings, the number of characters in a string (given by &lt;code&gt;length(s)&lt;/code&gt;) is not always the same as the last index. If you iterate through the indices 1 through &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex(s)&lt;/code&gt;&lt;/a&gt; and index into &lt;code&gt;s&lt;/code&gt;, the sequence of characters returned when errors aren't thrown is the sequence of characters comprising the string &lt;code&gt;s&lt;/code&gt;. Thus we have the identity that &lt;code&gt;length(s) &amp;lt;= lastindex(s)&lt;/code&gt;, since each character in a string must have its own index. The following is an inefficient and verbose way to iterate through the characters of &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">Из-за кодирования переменной длины количество символов в строке (заданное &lt;code&gt;length(s)&lt;/code&gt; ) не всегда совпадает с последним индексом. Если вы перебираете индексы с 1 по &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt; &lt;code&gt;lastindex(s)&lt;/code&gt; &lt;/a&gt; и индексируете в &lt;code&gt;s&lt;/code&gt; , последовательность символов, возвращаемая, когда ошибки не возникают, представляет собой последовательность символов, составляющих строку &lt;code&gt;s&lt;/code&gt; . Таким образом, у нас есть тождество, которое &lt;code&gt;length(s) &amp;lt;= lastindex(s)&lt;/code&gt; , поскольку каждый символ в строке должен иметь свой собственный индекс. Ниже приводится неэффективный и подробный способ перебора символов &lt;code&gt;s&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="757a38ed122bb8b64391606ad821806f34182e36" translate="yes" xml:space="preserve">
          <source>Because supporting generic programming is deemed more important than potential performance optimizations that can be achieved by other means (e.g., using explicit loops), operators like &lt;code&gt;+=&lt;/code&gt; and &lt;code&gt;*=&lt;/code&gt; work by rebinding new values.</source>
          <target state="translated">Поскольку поддержка общего программирования считается более важной, чем потенциальная оптимизация производительности, которая может быть достигнута другими способами (например, с использованием явных циклов), такие операторы, как &lt;code&gt;+=&lt;/code&gt; и &lt;code&gt;*=&lt;/code&gt; , работают путем повторного связывания новых значений.</target>
        </trans-unit>
        <trans-unit id="b50e23d2e501ab3f771dc2f5a71cc510c1b86367" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; types are stored as single &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; values, date parts or fields can be retrieved through accessor functions. The lowercase accessors return the field as an integer:</source>
          <target state="translated">Поскольку типы &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; хранятся как отдельные значения &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; , части даты или поля могут быть получены с помощью функций доступа. Методы доступа в нижнем регистре возвращают поле как целое число:</target>
        </trans-unit>
        <trans-unit id="bc4c89911afb2810477bab2fec0bf376b9a4f915" translate="yes" xml:space="preserve">
          <source>Because the compiler knows that integer addition and multiplication are associative and that multiplication distributes over addition &amp;ndash; neither of which is true of saturating arithmetic &amp;ndash; it can optimize the entire loop down to just a multiply and an add. Saturated arithmetic completely defeats this kind of optimization since associativity and distributivity can fail at each loop iteration, causing different outcomes depending on which iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple operations into fewer equivalent operations.</source>
          <target state="translated">Поскольку компилятор знает, что целочисленное сложение и умножение являются ассоциативными и что умножение распределяется по сложению - ни одно из этих условий не относится к арифметике с насыщением, - он может оптимизировать весь цикл до простого умножения и сложения. Насыщенная арифметика полностью исключает этот вид оптимизации, поскольку ассоциативность и распределительность могут давать сбой на каждой итерации цикла, вызывая разные результаты в зависимости от того, на какой итерации произошел сбой. Компилятор может развернуть цикл, но не может алгебраически сократить несколько операций до меньшего числа эквивалентных операций.</target>
        </trans-unit>
        <trans-unit id="b0fb1c1b010730bc0463b629ac89a10341b04531" translate="yes" xml:space="preserve">
          <source>Because the operator &lt;code&gt;^&lt;/code&gt; has higher precedence than &lt;code&gt;*&lt;/code&gt; (see &lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity&quot;&gt;Operator Precedence and Associativity&lt;/a&gt;), this output does not faithfully represent the expression &lt;code&gt;a ^ 2&lt;/code&gt; which should be equal to &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt;. To solve this issue, we must make a custom method for &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt;, which is called internally by the expression object when printing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a8e98adc86bd54f822093e18075fecd0592176" translate="yes" xml:space="preserve">
          <source>Because the operator &lt;code&gt;^&lt;/code&gt; has higher precedence than &lt;code&gt;*&lt;/code&gt; (see &lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity-1&quot;&gt;Operator Precedence and Associativity&lt;/a&gt;), this output does not faithfully represent the expression &lt;code&gt;a ^ 2&lt;/code&gt; which should be equal to &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt;. To solve this issue, we must make a custom method for &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt;, which is called internally by the expression object when printing:</source>
          <target state="translated">Поскольку оператор &lt;code&gt;^&lt;/code&gt; имеет более высокий приоритет, чем &lt;code&gt;*&lt;/code&gt; (см. &lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity-1&quot;&gt;Приоритет операторов и ассоциативность&lt;/a&gt; ), этот вывод не точно представляет выражение &lt;code&gt;a ^ 2&lt;/code&gt; , которое должно быть равно &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt; . Чтобы решить эту проблему, мы должны создать собственный метод для &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt; , который вызывается внутри объекта выражения при печати:</target>
        </trans-unit>
        <trans-unit id="f808dfd9f99fca14db2870360d26f322b8ed85e2" translate="yes" xml:space="preserve">
          <source>Because the precise way in which random numbers are generated is considered an implementation detail, bug fixes and speed improvements may change the stream of numbers that are generated after a version change. Relying on a specific seed or generated stream of numbers during unit testing is thus discouraged - consider testing properties of the methods in question instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae99b1d876ba3cfdc461cae08478806ff8d8ca63" translate="yes" xml:space="preserve">
          <source>Beer Mug</source>
          <target state="translated">Пивная кружка</target>
        </trans-unit>
        <trans-unit id="5672f13a1da17dc7ad6970da457803cdfb5de94c" translate="yes" xml:space="preserve">
          <source>Before Julia 1.2 this signature was restricted to &lt;code&gt;f::Function&lt;/code&gt;.</source>
          <target state="translated">До Julia 1.2 эта подпись была ограничена &lt;code&gt;f::Function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebd25c6fc66535562035f061458e887115328bc8" translate="yes" xml:space="preserve">
          <source>Before running Julia set the environment variable &lt;code&gt;ENABLE_JITPROFILING&lt;/code&gt; to 1.</source>
          <target state="translated">Перед запуском Джулии установите для переменной среды &lt;code&gt;ENABLE_JITPROFILING&lt;/code&gt; значение 1.</target>
        </trans-unit>
        <trans-unit id="0dc928d36409cbb3c824f1591ba22fe5ec9e9dd8" translate="yes" xml:space="preserve">
          <source>Before the execution of the body of a &lt;code&gt;@testset&lt;/code&gt;, there is an implicit call to &lt;code&gt;Random.seed!(seed)&lt;/code&gt; where &lt;code&gt;seed&lt;/code&gt; is the current seed of the global RNG. Moreover, after the execution of the body, the state of the global RNG is restored to what it was before the &lt;code&gt;@testset&lt;/code&gt;. This is meant to ease reproducibility in case of failure, and to allow seamless re-arrangements of &lt;code&gt;@testset&lt;/code&gt;s regardless of their side-effect on the global RNG state.</source>
          <target state="translated">Перед выполнением тела &lt;code&gt;@testset&lt;/code&gt; существует неявный вызов &lt;code&gt;Random.seed!(seed)&lt;/code&gt; где &lt;code&gt;seed&lt;/code&gt; - это текущее начальное значение глобального ГСЧ. Более того, после выполнения тела состояние глобального ГСЧ восстанавливается до того, что было до &lt;code&gt;@testset&lt;/code&gt; . Это предназначено для облегчения воспроизводимости в случае сбоя и обеспечения возможности бесшовной перекомпоновки &lt;code&gt;@testset&lt;/code&gt; независимо от их побочного эффекта на глобальное состояние ГСЧ.</target>
        </trans-unit>
        <trans-unit id="e1451b7dd9bc69e125d61828d9b5cab1b14b61ea" translate="yes" xml:space="preserve">
          <source>Before the program terminates, it is strongly recommended to call &lt;code&gt;jl_atexit_hook&lt;/code&gt;. The above example program calls this before returning from &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">Перед завершением программы настоятельно рекомендуется вызвать &lt;code&gt;jl_atexit_hook&lt;/code&gt; . В приведенном выше примере программа вызывает это перед возвратом из &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b47e5d0ff5715fb37f74adf8fc2abb257a9578b" translate="yes" xml:space="preserve">
          <source>Beginners will write this kind of code without the &lt;code&gt;global&lt;/code&gt; and have no idea why their code doesn't work&amp;mdash;the error that they get is that &lt;code&gt;s&lt;/code&gt; is undefined, which does not seem to enlighten anyone who happens to make this mistake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5e33825f4e17f1ad04b807863fc5ef1363c528" translate="yes" xml:space="preserve">
          <source>Behaves like a &lt;code&gt;Ptr{T}&lt;/code&gt; that can manage its memory via the Julia GC.</source>
          <target state="translated">Ведет себя как &lt;code&gt;Ptr{T}&lt;/code&gt; который может управлять своей памятью через Julia GC.</target>
        </trans-unit>
        <trans-unit id="e09863e9196cd18ccb74a5a4e0f5e83a34c2821d" translate="yes" xml:space="preserve">
          <source>Behaves like applying &lt;code&gt;n&lt;/code&gt; times &lt;code&gt;nextind&lt;/code&gt; for &lt;code&gt;n==1&lt;/code&gt;. The only difference is that if &lt;code&gt;n&lt;/code&gt; is so large that applying &lt;code&gt;nextind&lt;/code&gt; would reach &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; then each remaining iteration increases the returned value by &lt;code&gt;1&lt;/code&gt;. This means that in this case &lt;code&gt;nextind&lt;/code&gt; can return a value greater than &lt;code&gt;ncodeunits(str)+1&lt;/code&gt;.</source>
          <target state="translated">Аналогично применению &lt;code&gt;n&lt;/code&gt; раз &lt;code&gt;nextind&lt;/code&gt; для &lt;code&gt;n==1&lt;/code&gt; . Единственное отличие состоит в том, что если &lt;code&gt;n&lt;/code&gt; настолько велико, что применение &lt;code&gt;nextind&lt;/code&gt; достигнет &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; тогда каждая оставшаяся итерация увеличивает возвращаемое значение на &lt;code&gt;1&lt;/code&gt; . Это означает, что в этом случае &lt;code&gt;nextind&lt;/code&gt; может вернуть значение больше &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2b1b1654cc55316ed5e2b35c84126cef980b48d" translate="yes" xml:space="preserve">
          <source>Behaves like applying &lt;code&gt;n&lt;/code&gt; times &lt;code&gt;prevind&lt;/code&gt; for &lt;code&gt;n==1&lt;/code&gt;. The only difference is that if &lt;code&gt;n&lt;/code&gt; is so large that applying &lt;code&gt;prevind&lt;/code&gt; would reach &lt;code&gt;0&lt;/code&gt; then each remaining iteration decreases the returned value by &lt;code&gt;1&lt;/code&gt;. This means that in this case &lt;code&gt;prevind&lt;/code&gt; can return a negative value.</source>
          <target state="translated">Ведет себя как применение &lt;code&gt;n&lt;/code&gt; раз &lt;code&gt;prevind&lt;/code&gt; для &lt;code&gt;n==1&lt;/code&gt; . Единственное отличие состоит в том, что если &lt;code&gt;n&lt;/code&gt; настолько велико, что применение &lt;code&gt;prevind&lt;/code&gt; достигнет &lt;code&gt;0&lt;/code&gt; , тогда каждая оставшаяся итерация уменьшает возвращаемое значение на &lt;code&gt;1&lt;/code&gt; . Это означает, что в этом случае &lt;code&gt;prevind&lt;/code&gt; может вернуть отрицательное значение.</target>
        </trans-unit>
        <trans-unit id="d4198662a72fd519a4f968a74051bafac710dc07" translate="yes" xml:space="preserve">
          <source>Bell</source>
          <target state="translated">Bell</target>
        </trans-unit>
        <trans-unit id="bbab278669c1eda7fe0bdb1650c9fd25169b898f" translate="yes" xml:space="preserve">
          <source>Bell With Cancellation Stroke</source>
          <target state="translated">Колокол с Аннулирующим Ходом</target>
        </trans-unit>
        <trans-unit id="94add7afb4e17fd6f1526d2edfd18924f6fd72ab" translate="yes" xml:space="preserve">
          <source>Below is an example where subnormals noticeably impact performance on some hardware:</source>
          <target state="translated">Ниже приведен пример,когда субнормалы заметно влияют на производительность некоторых аппаратных средств:</target>
        </trans-unit>
        <trans-unit id="58c2a686d8a6b7d42c702706aa646004223a601b" translate="yes" xml:space="preserve">
          <source>Below we discuss particular challenges and some alternative ways to resolve such issues.</source>
          <target state="translated">Ниже мы обсудим конкретные проблемы и некоторые альтернативные пути их решения.</target>
        </trans-unit>
        <trans-unit id="e6be4001a8d2924783c806798a0e30c2803a6922" translate="yes" xml:space="preserve">
          <source>Bento Box</source>
          <target state="translated">Бенто Бокс</target>
        </trans-unit>
        <trans-unit id="3f0f29bd74024b1bd9eec443c00d50257286a7db" translate="yes" xml:space="preserve">
          <source>Benzene Ring</source>
          <target state="translated">Бензольное кольцо</target>
        </trans-unit>
        <trans-unit id="c667600d6a843f35f26780da4256a01e9f67553a" translate="yes" xml:space="preserve">
          <source>Benzene Ring With Circle</source>
          <target state="translated">Бензольное кольцо с кругом</target>
        </trans-unit>
        <trans-unit id="79faabb26deabd43b3e790cb4753636cfebf2e58" translate="yes" xml:space="preserve">
          <source>Besides being used for the &lt;a href=&quot;../../base/constants/index#Base.VERSION&quot;&gt;&lt;code&gt;VERSION&lt;/code&gt;&lt;/a&gt; constant, &lt;code&gt;VersionNumber&lt;/code&gt; objects are widely used in the &lt;code&gt;Pkg&lt;/code&gt; module, to specify packages versions and their dependencies.</source>
          <target state="translated">Помимо использования для константы &lt;a href=&quot;../../base/constants/index#Base.VERSION&quot;&gt; &lt;code&gt;VERSION&lt;/code&gt; &lt;/a&gt; , объекты &lt;code&gt;VersionNumber&lt;/code&gt; широко используются в модуле &lt;code&gt;Pkg&lt;/code&gt; для указания версий пакетов и их зависимостей.</target>
        </trans-unit>
        <trans-unit id="4c077965afc4d3ad848734d7192dc33685665fb8" translate="yes" xml:space="preserve">
          <source>Bet Symbol / Second Transfinite Cardinal</source>
          <target state="translated">Символ ставки/Второй кардинал перевода денег</target>
        </trans-unit>
        <trans-unit id="1b22feb0c0c13c69ebe6389111ff7312bd0c946b" translate="yes" xml:space="preserve">
          <source>Between</source>
          <target state="translated">Between</target>
        </trans-unit>
        <trans-unit id="4e83ab72f5680a7927bc2ee1770585b538110359" translate="yes" xml:space="preserve">
          <source>Bicycle</source>
          <target state="translated">Bicycle</target>
        </trans-unit>
        <trans-unit id="af44c67fc560bdac204e3457136721b15282deb9" translate="yes" xml:space="preserve">
          <source>Bicyclist</source>
          <target state="translated">Bicyclist</target>
        </trans-unit>
        <trans-unit id="ca17e7c02d8603afa7449be022da99c068361156" translate="yes" xml:space="preserve">
          <source>Bidiagonal</source>
          <target state="translated">Bidiagonal</target>
        </trans-unit>
        <trans-unit id="f0830adbb847a3826b894a8d2b1be1aa3648828e" translate="yes" xml:space="preserve">
          <source>BigFloats and BigInts</source>
          <target state="translated">БигФлоуты и БигИнты</target>
        </trans-unit>
        <trans-unit id="669a7400e7ecdc8abb5def5c2be2775fd1a39afb" translate="yes" xml:space="preserve">
          <source>Bignums are supported, but conversion is not automatic; ordinary integers &lt;a href=&quot;../faq/index#faq-integer-arithmetic&quot;&gt;overflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aacc2899433eb85e7a2394fe9113a636959564b2" translate="yes" xml:space="preserve">
          <source>Bikini</source>
          <target state="translated">Bikini</target>
        </trans-unit>
        <trans-unit id="aaaa53539dc3641fca1eac5e64bf0cba011ff6e3" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;). Column-permutation &lt;code&gt;q&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s column count (&lt;code&gt;length(q) == A.n&lt;/code&gt;). Row-permutation &lt;code&gt;p&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s row count (&lt;code&gt;length(p) == A.m&lt;/code&gt;).</source>
          <target state="translated">Двусторонняя перестановка &lt;code&gt;A&lt;/code&gt; , возвращая &lt;code&gt;PAQ&lt;/code&gt; ( &lt;code&gt;A[p,q]&lt;/code&gt; ). Длина перестановки столбцов &lt;code&gt;q&lt;/code&gt; должна соответствовать количеству столбцов &lt;code&gt;A&lt;/code&gt; ( &lt;code&gt;length(q) == A.n&lt;/code&gt; ). Длина перестановки строк &lt;code&gt;p&lt;/code&gt; должна соответствовать количеству строк &lt;code&gt;A&lt;/code&gt; ( &lt;code&gt;length(p) == A.m&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5033e83ebc769b610ff5842eedc3584eb861a747" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;). Column-permutation &lt;code&gt;q&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s column count (&lt;code&gt;length(q) == size(A, 2)&lt;/code&gt;). Row-permutation &lt;code&gt;p&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s row count (&lt;code&gt;length(p) == size(A, 1)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa67c0c72b73769483142d524a72dd00b47e7280" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, storing result &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;) in &lt;code&gt;X&lt;/code&gt;. Stores intermediate result &lt;code&gt;(AQ)^T&lt;/code&gt; (&lt;code&gt;transpose(A[:,q])&lt;/code&gt;) in optional argument &lt;code&gt;C&lt;/code&gt; if present. Requires that none of &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, and, if present, &lt;code&gt;C&lt;/code&gt; alias each other; to store result &lt;code&gt;PAQ&lt;/code&gt; back into &lt;code&gt;A&lt;/code&gt;, use the following method lacking &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">Переставляют на двусторонней основе , сохранения результата &lt;code&gt;PAQ&lt;/code&gt; ( &lt;code&gt;A[p,q]&lt;/code&gt; ) в &lt;code&gt;X&lt;/code&gt; . Сохраняет промежуточный результат &lt;code&gt;(AQ)^T&lt;/code&gt; ( &lt;code&gt;transpose(A[:,q])&lt;/code&gt; ) в необязательном аргументе &lt;code&gt;C&lt;/code&gt; , если он присутствует. Требует, чтобы ни один из &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; и, если присутствует, &lt;code&gt;C&lt;/code&gt; не являлся псевдонимом друг друга; чтобы сохранить результат &lt;code&gt;PAQ&lt;/code&gt; обратно в &lt;code&gt;A&lt;/code&gt; , используйте следующий метод без &lt;code&gt;X&lt;/code&gt; : &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c4f1f960deffd3639bacc943d7beee3c049657a" translate="yes" xml:space="preserve">
          <source>Billiards</source>
          <target state="translated">Billiards</target>
        </trans-unit>
        <trans-unit id="c1d93ced1617078468dc67be83745c4934553581" translate="yes" xml:space="preserve">
          <source>Binary (or unary) operators like &lt;code&gt;.+&lt;/code&gt; are handled with the same mechanism: they are equivalent to &lt;code&gt;broadcast&lt;/code&gt; calls and are fused with other nested &quot;dot&quot; calls. &lt;code&gt;X .+= Y&lt;/code&gt; etcetera is equivalent to &lt;code&gt;X .= X .+ Y&lt;/code&gt; and results in a fused in-place assignment; see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators&quot;&gt;dot operators&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9a9dae508a5a43298d0ecf022071a0f6818999" translate="yes" xml:space="preserve">
          <source>Binary (or unary) operators like &lt;code&gt;.+&lt;/code&gt; are handled with the same mechanism: they are equivalent to &lt;code&gt;broadcast&lt;/code&gt; calls and are fused with other nested &quot;dot&quot; calls. &lt;code&gt;X .+= Y&lt;/code&gt; etcetera is equivalent to &lt;code&gt;X .= X .+ Y&lt;/code&gt; and results in a fused in-place assignment; see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot operators&lt;/a&gt;.</source>
          <target state="translated">Бинарные (или унарные) операторы, такие как &lt;code&gt;.+&lt;/code&gt; , Обрабатываются одним и тем же механизмом: они эквивалентны &lt;code&gt;broadcast&lt;/code&gt; вызовам и объединяются с другими вложенными вызовами &amp;laquo;точки&amp;raquo;. &lt;code&gt;X .+= Y&lt;/code&gt; и т.д. эквивалентно &lt;code&gt;X .= X .+ Y&lt;/code&gt; и приводит к слитному назначению на месте; см. также &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;точечные операторы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a754b43c5cd6bc6c82c954daabe8d0dd0d9ab2bb" translate="yes" xml:space="preserve">
          <source>Binary and octal literals are also supported:</source>
          <target state="translated">Также поддерживаются двоичные и восьмеричные буквы:</target>
        </trans-unit>
        <trans-unit id="f84a08f5fd91d8b683f66ada3a3f0d37dd8d9416" translate="yes" xml:space="preserve">
          <source>Binary arithmetic &amp;ndash; &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;</source>
          <target state="translated">Двоичная арифметика - &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96c4e4b4e465473735caeea3bbe55395f833f831" translate="yes" xml:space="preserve">
          <source>Binary format: 1 sign, 11 exponent, 52 fraction bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c2dc88cfba0517f9a198be3d135a4aa4ba4c99" translate="yes" xml:space="preserve">
          <source>Binary format: 1 sign, 5 exponent, 10 fraction bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8b640f698cc5a43263f00b745c9489369b4eda" translate="yes" xml:space="preserve">
          <source>Binary format: 1 sign, 8 exponent, 23 fraction bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e24dd0237ae9c6c248482e7cdae84d6dd71aee" translate="yes" xml:space="preserve">
          <source>Binary, octal, and hexadecimal literals may be signed by a &lt;code&gt;-&lt;/code&gt; immediately preceding the unsigned literal. They produce an unsigned integer of the same size as the unsigned literal would do, with the two's complement of the value:</source>
          <target state="translated">Двоичные, восьмеричные и шестнадцатеричные литералы могут быть подписаны &lt;code&gt;-&lt;/code&gt; непосредственно перед беззнаковым литералом. Они производят беззнаковое целое того же размера, что и беззнаковый литерал, с двумя дополнениями значения:</target>
        </trans-unit>
        <trans-unit id="ccb7426c705bde96fa9acacc232348e6649fb196" translate="yes" xml:space="preserve">
          <source>Bind &lt;code&gt;socket&lt;/code&gt; to the given &lt;code&gt;host:port&lt;/code&gt;. Note that &lt;code&gt;0.0.0.0&lt;/code&gt; will listen on all devices.</source>
          <target state="translated">Привязать &lt;code&gt;socket&lt;/code&gt; к данному &lt;code&gt;host:port&lt;/code&gt; . Обратите внимание, что &lt;code&gt;0.0.0.0&lt;/code&gt; будет прослушивать все устройства.</target>
        </trans-unit>
        <trans-unit id="fe7e2953e9474b2bd135241c7c997e4972287729" translate="yes" xml:space="preserve">
          <source>Bird</source>
          <target state="translated">Bird</target>
        </trans-unit>
        <trans-unit id="65c2eaa1dcfba5d5f9a0a3584ad5e6d8f7aef198" translate="yes" xml:space="preserve">
          <source>Birthday Cake</source>
          <target state="translated">День рождения Торт</target>
        </trans-unit>
        <trans-unit id="93ea79c838264d2a1d87b4b0c60302c8a973255c" translate="yes" xml:space="preserve">
          <source>BitArray</source>
          <target state="translated">BitArray</target>
        </trans-unit>
        <trans-unit id="4b9bfa4acc76402f1ab1ef6ccdbff0077343e801" translate="yes" xml:space="preserve">
          <source>BitArray()</source>
          <target state="translated">BitArray()</target>
        </trans-unit>
        <trans-unit id="f8cd7716f7a5997d4efd153b8de6bda8ac575d3b" translate="yes" xml:space="preserve">
          <source>BitSet</source>
          <target state="translated">BitSet</target>
        </trans-unit>
        <trans-unit id="d102341c9ef55fb595a96df06da32dfabaf31707" translate="yes" xml:space="preserve">
          <source>Bits Types</source>
          <target state="translated">Типы битов</target>
        </trans-unit>
        <trans-unit id="3d60896c2746f9344a7ec07d0c544abfbd6ac054" translate="yes" xml:space="preserve">
          <source>Bitshifts</source>
          <target state="translated">Bitshifts</target>
        </trans-unit>
        <trans-unit id="f06f824cef5caab026aebdaccc85d665d4b620db" translate="yes" xml:space="preserve">
          <source>Bitwise Operators</source>
          <target state="translated">Дополнительные операторы</target>
        </trans-unit>
        <trans-unit id="003769240202348f8c8c50c01088aea9a66d1338" translate="yes" xml:space="preserve">
          <source>Bitwise and. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one operand is &lt;code&gt;missing&lt;/code&gt; and the other is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Побитовое и. Реализует &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;трехзначную логику&lt;/a&gt; , возвращая значение &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; ,&lt;/a&gt; если один операнд &lt;code&gt;missing&lt;/code&gt; а другой - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39242907d8fbb94d63ee93aa69c2eae1e3bdde37" translate="yes" xml:space="preserve">
          <source>Bitwise and. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one operand is &lt;code&gt;missing&lt;/code&gt; and the other is &lt;code&gt;true&lt;/code&gt;. Add parentheses for function application form: &lt;code&gt;(&amp;amp;)(x, y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8386afef0f71e44b527049e051999293a919fac" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive or of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one of the arguments is &lt;code&gt;missing&lt;/code&gt;.</source>
          <target state="translated">Побитовое исключающее ИЛИ &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . Реализует &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;трехзначную логику&lt;/a&gt; , возвращая значение &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; ,&lt;/a&gt; если один из аргументов &lt;code&gt;missing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95edcf566466d2b1f53eaf47da115b29e2f2b799" translate="yes" xml:space="preserve">
          <source>Bitwise not.</source>
          <target state="translated">Ни в коем случае.</target>
        </trans-unit>
        <trans-unit id="55d4c457eca0630bcbc6d9ef2deac549be6e9eb1" translate="yes" xml:space="preserve">
          <source>Bitwise or. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one operand is &lt;code&gt;missing&lt;/code&gt; and the other is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Побитовое или. Реализует &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;трехзначную логику&lt;/a&gt; , возвращая &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; если один операнд &lt;code&gt;missing&lt;/code&gt; а другой - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbd4e8d6d33b0a0cb69eddf98c203dfb76b59494" translate="yes" xml:space="preserve">
          <source>Black Circle</source>
          <target state="translated">Чёрный круг</target>
        </trans-unit>
        <trans-unit id="0548413521ae8836d60c83abbcac0b4ffd5b48c9" translate="yes" xml:space="preserve">
          <source>Black Circle With Two White Dots</source>
          <target state="translated">Черный круг с двумя белыми точками</target>
        </trans-unit>
        <trans-unit id="d7fd466be098000d71600e8371d0c45e2c49fceb" translate="yes" xml:space="preserve">
          <source>Black Circle With White Dot Right</source>
          <target state="translated">Черный круг с белой точкой правой</target>
        </trans-unit>
        <trans-unit id="757cd02902cbeae20fd43d03ee03d7081baecb82" translate="yes" xml:space="preserve">
          <source>Black Club Suit</source>
          <target state="translated">Клубный костюм Блэк</target>
        </trans-unit>
        <trans-unit id="9450d23785e56cc9d47bc85752234baaa5f58935" translate="yes" xml:space="preserve">
          <source>Black Diamond</source>
          <target state="translated">Черный бриллиант</target>
        </trans-unit>
        <trans-unit id="1e863cdb2d578f5fa6a621df1fbd38ab6818ad43" translate="yes" xml:space="preserve">
          <source>Black Diamond Suit</source>
          <target state="translated">Черный бриллиантовый костюм</target>
        </trans-unit>
        <trans-unit id="143603a649d02ce401e75e3d4b9853da1d1fab9f" translate="yes" xml:space="preserve">
          <source>Black Down-Pointing Double Triangle</source>
          <target state="translated">Черный указательный вниз Двойной треугольник</target>
        </trans-unit>
        <trans-unit id="7131227a767e1555b67aefca3c1775aaf0e8eee4" translate="yes" xml:space="preserve">
          <source>Black Down-Pointing Small Triangle / Black Down Pointing Small Triangle</source>
          <target state="translated">Черный направленный вниз Малый треугольник/Черный направленный вниз Малый треугольник</target>
        </trans-unit>
        <trans-unit id="157034cbc1651891d53bf3735a8280c2c9e17261" translate="yes" xml:space="preserve">
          <source>Black Down-Pointing Triangle / Black Down Pointing Triangle</source>
          <target state="translated">Черный указательный треугольник/Черный указательный треугольник вниз</target>
        </trans-unit>
        <trans-unit id="79bb28413b3c0425fd63303d0da05ee06907711e" translate="yes" xml:space="preserve">
          <source>Black Heart Suit</source>
          <target state="translated">Костюм Чёрного Сердца</target>
        </trans-unit>
        <trans-unit id="84860fcb2778d5994fb2e1ec4ed5e1ff25be0c69" translate="yes" xml:space="preserve">
          <source>Black Hexagon</source>
          <target state="translated">Блэк-Гексагон</target>
        </trans-unit>
        <trans-unit id="eb3fe0b35214fe985deafdd4923cb6b5b71ecc00" translate="yes" xml:space="preserve">
          <source>Black Horizontal Ellipse</source>
          <target state="translated">Черный Горизонтальный Эллипс</target>
        </trans-unit>
        <trans-unit id="3d24dccec23ef173830493e234a9797701114f4b" translate="yes" xml:space="preserve">
          <source>Black Large Circle</source>
          <target state="translated">Черный Большой круг</target>
        </trans-unit>
        <trans-unit id="546e54ab988bdc54b4d67a0c87d99ffab31da61d" translate="yes" xml:space="preserve">
          <source>Black Large Square</source>
          <target state="translated">Большой черный квадрат</target>
        </trans-unit>
        <trans-unit id="6c8aa0f6c88d86e760e667a1cfc3b50d0980df03" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Double Triangle</source>
          <target state="translated">Черный левый указательный двойной треугольник</target>
        </trans-unit>
        <trans-unit id="cc1db57a30b84796696c95aebddd648e97e8d503" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Pointer / Black Left Pointing Pointer</source>
          <target state="translated">Черный левый указатель/Черный левый указатель</target>
        </trans-unit>
        <trans-unit id="f5b4fdf2d1f644120341bc595bfdc32acb38d8d9" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Small Triangle / Black Left Pointing Small Triangle</source>
          <target state="translated">Черный левый указывающий небольшой треугольник/Черный левый указывающий небольшой треугольник</target>
        </trans-unit>
        <trans-unit id="394197a1901b539e852cc0120322c6a8cc9c8a83" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Triangle / Black Left Pointing Triangle</source>
          <target state="translated">Черный левосторонний треугольник/Черный левосторонний треугольник</target>
        </trans-unit>
        <trans-unit id="651c14702ebcf7b7b2d5b2b8b2d4c78353cf3dc3" translate="yes" xml:space="preserve">
          <source>Black Lower Left Triangle</source>
          <target state="translated">Черный Нижний Левый Треугольник</target>
        </trans-unit>
        <trans-unit id="a993e08e4e58513d7c168e38a98af83c1b823e70" translate="yes" xml:space="preserve">
          <source>Black Lower Right Triangle</source>
          <target state="translated">Черный нижний правый треугольник</target>
        </trans-unit>
        <trans-unit id="7784160f9d8de2c5b48e65c73c3ba7c32077d5d3" translate="yes" xml:space="preserve">
          <source>Black Lozenge</source>
          <target state="translated">Чёрный Лозенге</target>
        </trans-unit>
        <trans-unit id="f51954be7eb46c9d2126809c883eed1d9b6af3da" translate="yes" xml:space="preserve">
          <source>Black Medium Diamond</source>
          <target state="translated">Черный Средний Алмаз</target>
        </trans-unit>
        <trans-unit id="e638cf3b3eda8a7622b5719c7bc597161ec84dff" translate="yes" xml:space="preserve">
          <source>Black Medium Lozenge</source>
          <target state="translated">Черный Средний Лозенге</target>
        </trans-unit>
        <trans-unit id="7d1eb991c64f2c0aa6c491bf46495204bab8b980" translate="yes" xml:space="preserve">
          <source>Black Medium Small Square</source>
          <target state="translated">Черный Средний Малый Квадрат</target>
        </trans-unit>
        <trans-unit id="35e1e8816c4ad0b081b1abc5f0b5e6e68515fdd3" translate="yes" xml:space="preserve">
          <source>Black Medium Square</source>
          <target state="translated">Чёрный Средний квадрат</target>
        </trans-unit>
        <trans-unit id="bd88cc2496f705279f693662165cafc22758e595" translate="yes" xml:space="preserve">
          <source>Black Nib</source>
          <target state="translated">Черное перо</target>
        </trans-unit>
        <trans-unit id="17a74c499db585ffc78ad964cf24f74eeab12fbc" translate="yes" xml:space="preserve">
          <source>Black Parallelogram</source>
          <target state="translated">Чёрный Параллелограмм</target>
        </trans-unit>
        <trans-unit id="a5e0106e423905d56ce64cbee75d3dab7ab613a8" translate="yes" xml:space="preserve">
          <source>Black Pentagon</source>
          <target state="translated">Чёрный Пентагон</target>
        </trans-unit>
        <trans-unit id="641e8ed8cc5074283080ad85521696fc93454500" translate="yes" xml:space="preserve">
          <source>Black Question Mark Ornament</source>
          <target state="translated">Черный знак вопроса Орнамент</target>
        </trans-unit>
        <trans-unit id="d17f522d42443e1dee4d94f18ac22410a504bd60" translate="yes" xml:space="preserve">
          <source>Black Rectangle</source>
          <target state="translated">Чёрный прямоугольник</target>
        </trans-unit>
        <trans-unit id="c7dbb16f8d25cc978eab91325f13bfbb34eb443b" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Double Triangle</source>
          <target state="translated">Черный прямоугольный двойной треугольник</target>
        </trans-unit>
        <trans-unit id="9a22fd5458a747bf2f8b9190b0800a8f327c6da4" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Pentagon</source>
          <target state="translated">Чёрный прямоугольный Пентагон</target>
        </trans-unit>
        <trans-unit id="08e8d8d34fe44b6c1da81bad30dfbb3dd0e4dc17" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Pointer / Black Right Pointing Pointer</source>
          <target state="translated">Черная правая указка/Черная правая указка</target>
        </trans-unit>
        <trans-unit id="356acd32b10439549774affb8876e75924c2d411" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Small Triangle / Black Right Pointing Small Triangle</source>
          <target state="translated">Черный прямоугольный Малый треугольник/Черный прямоугольный Малый треугольник,указывающий направление</target>
        </trans-unit>
        <trans-unit id="91e55728177959f6eb733905e6d5d4b3b30df4c9" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Triangle / Black Right Pointing Triangle</source>
          <target state="translated">Черный прямоугольный треугольник/Черный прямоугольный треугольник</target>
        </trans-unit>
        <trans-unit id="7d35d74427ef7783600f70aed6734b005afcf3a5" translate="yes" xml:space="preserve">
          <source>Black Rightwards Arrow / Black Right Arrow</source>
          <target state="translated">Черная стрелка вправо/Черная стрелка вправо</target>
        </trans-unit>
        <trans-unit id="4e1227a3b661c19e11075ce6c898353138a6cae4" translate="yes" xml:space="preserve">
          <source>Black Scissors</source>
          <target state="translated">Чёрные ножницы</target>
        </trans-unit>
        <trans-unit id="3a1f9cf604664d5b2cfd7032309a96005ebcdd85" translate="yes" xml:space="preserve">
          <source>Black Small Diamond</source>
          <target state="translated">Черный маленький алмаз</target>
        </trans-unit>
        <trans-unit id="560e8f05828a680fa9a4f86877ed9847156b94a9" translate="yes" xml:space="preserve">
          <source>Black Small Lozenge</source>
          <target state="translated">Чёрный Малый Лозенге</target>
        </trans-unit>
        <trans-unit id="2b77f77dfe2cfd17e674571a7ea6fb868ae1d0ef" translate="yes" xml:space="preserve">
          <source>Black Small Square</source>
          <target state="translated">Черный Малый квадрат</target>
        </trans-unit>
        <trans-unit id="53c256b922dbb0b4f34a326b72cef14e0af86c98" translate="yes" xml:space="preserve">
          <source>Black Small Star</source>
          <target state="translated">Чёрная малая звезда</target>
        </trans-unit>
        <trans-unit id="0ae1e3c46db08b1fb9b73728e2d7c428044fafa6" translate="yes" xml:space="preserve">
          <source>Black Smiling Face</source>
          <target state="translated">Черная Улыбающаяся Лицо</target>
        </trans-unit>
        <trans-unit id="8e05108bb9601bfdc9ba0035253f2d64bdf60694" translate="yes" xml:space="preserve">
          <source>Black Spade Suit</source>
          <target state="translated">Костюм Black Spade</target>
        </trans-unit>
        <trans-unit id="a01d4a6e7dbc191a1cae5b3bc838a6150cf238dd" translate="yes" xml:space="preserve">
          <source>Black Square</source>
          <target state="translated">Чёрный квадрат</target>
        </trans-unit>
        <trans-unit id="034b512bb5927fe50340904cd99432e1e4d73c3e" translate="yes" xml:space="preserve">
          <source>Black Square Button</source>
          <target state="translated">кнопка Чёрного квадрата</target>
        </trans-unit>
        <trans-unit id="fc626f5b71fcc01fb3ad79538a1fdd9c2c9068b3" translate="yes" xml:space="preserve">
          <source>Black Star</source>
          <target state="translated">Чёрная звезда</target>
        </trans-unit>
        <trans-unit id="cb52335be163268292bf2e0b734ba8007620b51b" translate="yes" xml:space="preserve">
          <source>Black Sun With Rays</source>
          <target state="translated">Черное солнце с лучами</target>
        </trans-unit>
        <trans-unit id="337ee67e4218483768c29454b46d3636ae0684a9" translate="yes" xml:space="preserve">
          <source>Black Telephone</source>
          <target state="translated">Черный Телефон</target>
        </trans-unit>
        <trans-unit id="35536366f9217c4ba0ce04cd1f6ccbeed6b48c42" translate="yes" xml:space="preserve">
          <source>Black Universal Recycling Symbol</source>
          <target state="translated">Черный Универсальный Символ переработки</target>
        </trans-unit>
        <trans-unit id="b63e9c12f3af70d3503bfb12a43507958e2cc9a3" translate="yes" xml:space="preserve">
          <source>Black Up-Pointing Double Triangle</source>
          <target state="translated">Черный указательный двойной треугольник</target>
        </trans-unit>
        <trans-unit id="5f6c177d2a76e96c788cfff6b45ea350fc5d5f85" translate="yes" xml:space="preserve">
          <source>Black Up-Pointing Small Triangle / Black Up Pointing Small Triangle</source>
          <target state="translated">Черный Указывающий вверх Малый треугольник/Черный Указывающий вверх Малый треугольник</target>
        </trans-unit>
        <trans-unit id="b019fe1ecc9d7bb3e20c546241096de99470763e" translate="yes" xml:space="preserve">
          <source>Black Up-Pointing Triangle / Black Up Pointing Triangle</source>
          <target state="translated">Черный вверх-Указательный треугольник/Черный вверх-Указательный треугольник</target>
        </trans-unit>
        <trans-unit id="fd38c797487c28729bfa7084dbd1bc7a8bd9f832" translate="yes" xml:space="preserve">
          <source>Black Upper Left Triangle</source>
          <target state="translated">Черный левый верхний треугольник</target>
        </trans-unit>
        <trans-unit id="330a4e0eb7ba380f3677a102ba04f4ed4533c835" translate="yes" xml:space="preserve">
          <source>Black Upper Right Triangle</source>
          <target state="translated">Черный верхний правый треугольник</target>
        </trans-unit>
        <trans-unit id="b5b860326f4e45d10acdc58e96248cded912b473" translate="yes" xml:space="preserve">
          <source>Black Vertical Ellipse</source>
          <target state="translated">Черный вертикальный эллипс</target>
        </trans-unit>
        <trans-unit id="12f762cae12dfd257dbcc1ff1c80f6e21ca05f3a" translate="yes" xml:space="preserve">
          <source>Black Vertical Rectangle</source>
          <target state="translated">Чёрный вертикальный прямоугольник</target>
        </trans-unit>
        <trans-unit id="b6c6da3063676ec7403eb5eae23f28a26cc0a5b1" translate="yes" xml:space="preserve">
          <source>Black Very Small Square</source>
          <target state="translated">Черный Очень маленький квадрат</target>
        </trans-unit>
        <trans-unit id="f56700596b30b0c05182a7f770b5570cc76ca6d1" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital C / Black-Letter C</source>
          <target state="translated">Черная буква C/Черная буква C</target>
        </trans-unit>
        <trans-unit id="3212f9c9a227cc0ef9fc8c3906dee3d018e41215" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital H / Black-Letter H</source>
          <target state="translated">Чёрный список H/Чёрный список H</target>
        </trans-unit>
        <trans-unit id="882d2d7aaddec9c72be91b9b04d8760d1ae0ecd3" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital I / Black-Letter I</source>
          <target state="translated">Чёрный капитал I/Чёрный капитал I</target>
        </trans-unit>
        <trans-unit id="8fc35324b6b0420a0444517c7f25614eb146dba4" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital R / Black-Letter R</source>
          <target state="translated">Черная буква R/Черная буква R</target>
        </trans-unit>
        <trans-unit id="4d139693ac24fa1ff39a927bee456e508f1aa95b" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital Z / Black-Letter Z</source>
          <target state="translated">Черная буква Z/Черная буква Z</target>
        </trans-unit>
        <trans-unit id="b847d9aaffd54e2b50551787d032091550aee835" translate="yes" xml:space="preserve">
          <source>Blank Symbol / Blank</source>
          <target state="translated">Пустой символ/пустой</target>
        </trans-unit>
        <trans-unit id="9a1f6bbeb59612c3b0d54abe35a469485c6370c0" translate="yes" xml:space="preserve">
          <source>Block quotes</source>
          <target state="translated">Блочные котировки</target>
        </trans-unit>
        <trans-unit id="413fe7b76bad922e0442b15508cafb42d749001b" translate="yes" xml:space="preserve">
          <source>Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of &lt;code&gt;0.001&lt;/code&gt;.</source>
          <target state="translated">Заблокировать текущую задачу на указанное количество секунд. Минимальное время ожидания составляет 1 миллисекунду или вводимое значение &lt;code&gt;0.001&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da010911be728132526ebfb6c6611c41bf6de799" translate="yes" xml:space="preserve">
          <source>Block the current task until some event occurs, depending on the type of the argument:</source>
          <target state="translated">Блокировать текущую задачу до тех пор,пока не произойдет какое-либо событие,в зависимости от типа аргумента:</target>
        </trans-unit>
        <trans-unit id="53a69c53a3e2458ff176a179fec2def0b4121cba" translate="yes" xml:space="preserve">
          <source>Blossom</source>
          <target state="translated">Blossom</target>
        </trans-unit>
        <trans-unit id="a6a6cc1c6c34e00f61be8a8c251a0e48237ab0a0" translate="yes" xml:space="preserve">
          <source>Blowfish</source>
          <target state="translated">Blowfish</target>
        </trans-unit>
        <trans-unit id="5963e560ae138684a55eeb248a0ec6a3d3e89c64" translate="yes" xml:space="preserve">
          <source>Blue Book</source>
          <target state="translated">Синяя книга</target>
        </trans-unit>
        <trans-unit id="a660e98a286d13e32848e06494a9c4e64598de77" translate="yes" xml:space="preserve">
          <source>Blue Heart</source>
          <target state="translated">Голубое сердце</target>
        </trans-unit>
        <trans-unit id="30efd20f542ce356dcbbbbb0473393dd8189443b" translate="yes" xml:space="preserve">
          <source>Boar</source>
          <target state="translated">Boar</target>
        </trans-unit>
        <trans-unit id="19e07430eed6d97d6d73cb4a2967b1f316520f54" translate="yes" xml:space="preserve">
          <source>Bold</source>
          <target state="translated">Bold</target>
        </trans-unit>
        <trans-unit id="d5bf9d845ab97255cb3ab1100656db4f59731808" translate="yes" xml:space="preserve">
          <source>Bomb</source>
          <target state="translated">Bomb</target>
        </trans-unit>
        <trans-unit id="441da1bf0eb8dcaca895f5d48325eab484ada1e0" translate="yes" xml:space="preserve">
          <source>Bookmark</source>
          <target state="translated">Bookmark</target>
        </trans-unit>
        <trans-unit id="d51cc7068c060eda1ab4c1992e8e7188251dc5d0" translate="yes" xml:space="preserve">
          <source>Bookmark Tabs</source>
          <target state="translated">Закладки Вкладки</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="9110e7395759cef34c9766cb75b920652e0ab037" translate="yes" xml:space="preserve">
          <source>Boolean not. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;missing&lt;/code&gt;.</source>
          <target state="translated">Логическое нет. Реализует &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;трехзначной логики&lt;/a&gt; , возвратившись &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , если &lt;code&gt;x&lt;/code&gt; является &lt;code&gt;missing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29a8f9f9b6a1cad56addb73a669797d31b6ebe67" translate="yes" xml:space="preserve">
          <source>Boolean operations &lt;em&gt;without&lt;/em&gt; short-circuit evaluation can be done with the bitwise boolean operators introduced in &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;: &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;. These are normal functions, which happen to support infix operator syntax, but always evaluate their arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5e74670608867d2d5a7f2c19b7656691fac4def" translate="yes" xml:space="preserve">
          <source>Boolean operations &lt;em&gt;without&lt;/em&gt; short-circuit evaluation can be done with the bitwise boolean operators introduced in &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;: &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;. These are normal functions, which happen to support infix operator syntax, but always evaluate their arguments:</source>
          <target state="translated">Логические операции &lt;em&gt;без&lt;/em&gt; вычисления короткого замыкания могут выполняться с помощью поразрядных логических операторов, представленных в разделе &amp;laquo; &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Математические операции и элементарные функции&amp;raquo;&lt;/a&gt; : &lt;code&gt;&amp;amp;&lt;/code&gt; и &lt;code&gt;|&lt;/code&gt; , Это обычные функции, которые поддерживают синтаксис инфиксных операторов, но всегда оценивают свои аргументы:</target>
        </trans-unit>
        <trans-unit id="6aee8c1403b8f533d1b1cfe7c809aba2942d98a3" translate="yes" xml:space="preserve">
          <source>Boolean type, containing the values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Логический тип, содержащий значения &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d3edec84ef05d40009ef42ad79a184127ff2d32" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are basically immutable &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; wrappers. The single &lt;code&gt;instant&lt;/code&gt; field of either type is actually a &lt;code&gt;UTInstant{P}&lt;/code&gt; type, which represents a continuously increasing machine timeline based on the UT second &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;. The &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; type is not aware of time zones (&lt;em&gt;naive&lt;/em&gt;, in Python parlance), analogous to a &lt;em&gt;LocalDateTime&lt;/em&gt; in Java 8. Additional time zone functionality can be added through the &lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;TimeZones.jl package&lt;/a&gt;, which compiles the &lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;IANA time zone database&lt;/a&gt;. Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so &lt;code&gt;0000-12-31&lt;/code&gt; is the day before &lt;code&gt;0001-01-01&lt;/code&gt;, and year &lt;code&gt;-0001&lt;/code&gt; (yes, negative one for the year) is 2 BC/BCE, year &lt;code&gt;-0002&lt;/code&gt; is 3 BC/BCE, etc.</source>
          <target state="translated">И &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; ,&lt;/a&gt; и &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; в основном являются неизменяемыми оболочками &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; . Единственное &lt;code&gt;instant&lt;/code&gt; поле любого типа на самом деле является &lt;code&gt;UTInstant{P}&lt;/code&gt; , который представляет непрерывно увеличивающуюся машинную шкалу времени на основе секунды UT &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; . Тип &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; не знает часовых поясов ( &lt;em&gt;наивно&lt;/em&gt; , на языке Python), аналог &lt;em&gt;LocalDateTime&lt;/em&gt; в Java 8. Дополнительные функции часового пояса можно добавить с помощью &lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;пакета TimeZones.jl&lt;/a&gt; , который компилирует &lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;базу данных часовых поясов IANA&lt;/a&gt; . И &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; ,&lt;/a&gt; и &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; основаны на&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;&lt;/a&gt;Стандарт ISO 8601 , который следует пролептическому григорианскому календарю. Следует отметить, что стандарт ISO 8601 касается дат до нашей эры / до нашей эры. В общем, за последним днем ​​эры до н.э. / до н.э., 1-12-31 до н.э. / до н.э., последовал 1-1-1 н.э. / н.э., поэтому нулевого года не существует. Однако стандарт ISO гласит, что 1 BC / BCE - это нулевой год, поэтому &lt;code&gt;0000-12-31&lt;/code&gt; - это день перед &lt;code&gt;0001-01-01&lt;/code&gt; , а год &lt;code&gt;-0001&lt;/code&gt; (да, отрицательный год) - 2 BC / BCE. , год &lt;code&gt;-0002&lt;/code&gt; - это 3 г. до н.э. / до н.э., и т. д.</target>
        </trans-unit>
        <trans-unit id="9bd9372ad6716aa533ad19c4f4344f9f861990d8" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are basically immutable &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; wrappers. The single &lt;code&gt;instant&lt;/code&gt; field of either type is actually a &lt;code&gt;UTInstant{P}&lt;/code&gt; type, which represents a continuously increasing machine timeline based on the UT second &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;. The &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; type is not aware of time zones (&lt;em&gt;naive&lt;/em&gt;, in Python parlance), analogous to a &lt;em&gt;LocalDateTime&lt;/em&gt; in Java 8. Additional time zone functionality can be added through the &lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;TimeZones.jl package&lt;/a&gt;, which compiles the &lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;IANA time zone database&lt;/a&gt;. Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so &lt;code&gt;0000-12-31&lt;/code&gt; is the day before &lt;code&gt;0001-01-01&lt;/code&gt;, and year &lt;code&gt;-0001&lt;/code&gt; (yes, negative one for the year) is 2 BC/BCE, year &lt;code&gt;-0002&lt;/code&gt; is 3 BC/BCE, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ca8268eafdcc74cc03d82127ce5107332b47b7" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are basically immutable &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; wrappers. The single &lt;code&gt;instant&lt;/code&gt; field of either type is actually a &lt;code&gt;UTInstant{P}&lt;/code&gt; type, which represents a continuously increasing machine timeline based on the UT second &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;. The &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; type is not aware of time zones (&lt;em&gt;naive&lt;/em&gt;, in Python parlance), analogous to a &lt;em&gt;LocalDateTime&lt;/em&gt; in Java 8. Additional time zone functionality can be added through the &lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;TimeZones.jl package&lt;/a&gt;, which compiles the &lt;a href=&quot;https://www.iana.org/time-zones&quot;&gt;IANA time zone database&lt;/a&gt;. Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so &lt;code&gt;0000-12-31&lt;/code&gt; is the day before &lt;code&gt;0001-01-01&lt;/code&gt;, and year &lt;code&gt;-0001&lt;/code&gt; (yes, negative one for the year) is 2 BC/BCE, year &lt;code&gt;-0002&lt;/code&gt; is 3 BC/BCE, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9bf1ed5d0b3dee373193977f771d3d28aa04eff" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;fdot&lt;/code&gt; compute the same thing. However, &lt;code&gt;fdot&lt;/code&gt; (defined with the help of the &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt;&lt;code&gt;@.&lt;/code&gt;&lt;/a&gt; macro) is significantly faster when applied to an array:</source>
          <target state="translated">И &lt;code&gt;f&lt;/code&gt; , и &lt;code&gt;fdot&lt;/code&gt; вычисляют одно и то же. Однако &lt;code&gt;fdot&lt;/code&gt; (определенный с помощью макроса &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt; &lt;code&gt;@.&lt;/code&gt; &lt;/a&gt; ) Значительно быстрее применяется к массиву:</target>
        </trans-unit>
        <trans-unit id="894facd8272490d18ae36dfbd0aea23dbfd8d0be" translate="yes" xml:space="preserve">
          <source>Both abstract and concrete types can be parameterized by other types. They can also be parameterized by symbols, by values of any type for which &lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt;&lt;code&gt;isbits&lt;/code&gt;&lt;/a&gt; returns true (essentially, things like numbers and bools that are stored like C types or &lt;code&gt;struct&lt;/code&gt;s with no pointers to other objects), and also by tuples thereof. Type parameters may be omitted when they do not need to be referenced or restricted.</source>
          <target state="translated">И абстрактные, и конкретные типы могут параметризоваться другими типами. Они также могут быть параметризованы символами, значениями любого типа, для которых &lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt; &lt;code&gt;isbits&lt;/code&gt; &lt;/a&gt; возвращает true (по сути, такими вещами, как числа и логические значения, которые хранятся как типы C или &lt;code&gt;struct&lt;/code&gt; без указателей на другие объекты), а также их кортежами. Параметры типа могут быть опущены, если на них нет необходимости ссылаться или ограничивать их.</target>
        </trans-unit>
        <trans-unit id="63dac16e286415a31cf4c5cfa7d67dab90fd4b82" translate="yes" xml:space="preserve">
          <source>Both concatenation and string interpolation call &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; to convert objects into string form. However, &lt;code&gt;string&lt;/code&gt; actually just returns the output of &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, so new types should add methods to &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;show&lt;/code&gt; instead of &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Конкатенация и строковая интерполяция вызывают &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; для преобразования объектов в строковую форму. Однако &lt;code&gt;string&lt;/code&gt; самом деле просто возвращает вывод &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; , поэтому новые типы должны добавлять методы для &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;show&lt;/code&gt; вместо &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="007479614c6ddfc352db8c91872c6cdcf690ee04" translate="yes" xml:space="preserve">
          <source>Both expressions are interpreted as function application: any expression that is not a numeric literal, when immediately followed by a parenthetical, is interpreted as a function applied to the values in parentheses (see &lt;a href=&quot;../faq/index#Functions&quot;&gt;Functions&lt;/a&gt; for more about functions). Thus, in both of these cases, an error occurs since the left-hand value is not a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92cf62db18ffc6b16befca5871ba839cf28860c" translate="yes" xml:space="preserve">
          <source>Both expressions are interpreted as function application: any expression that is not a numeric literal, when immediately followed by a parenthetical, is interpreted as a function applied to the values in parentheses (see &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Functions&lt;/a&gt; for more about functions). Thus, in both of these cases, an error occurs since the left-hand value is not a function.</source>
          <target state="translated">Оба выражения интерпретируются как приложение функции: любое выражение, не являющееся числовым литералом, если сразу за ним следует скобка, интерпретируется как функция, применяемая к значениям в круглых скобках ( дополнительную информацию о функциях см. В разделе &amp;laquo; &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Функции&amp;raquo;&lt;/a&gt; ). Таким образом, в обоих этих случаях возникает ошибка, поскольку левое значение не является функцией.</target>
        </trans-unit>
        <trans-unit id="fe2f60cb62bba939fc1814f0702994179d2cc9fd" translate="yes" xml:space="preserve">
          <source>Both these implementations, although different, do essentially the same thing: a runtime loop over the dimensions of the array, collecting the offset in each dimension into the final index.</source>
          <target state="translated">Обе эти реализации,хотя и отличаются друг от друга,по сути,делают одно и то же:цикл выполнения над измерениями массива,собирая смещение в каждом измерении в итоговый индекс.</target>
        </trans-unit>
        <trans-unit id="9c695a21716f0561a4e4e8d8969c9a67ff3ac14a" translate="yes" xml:space="preserve">
          <source>Bottom Curly Bracket</source>
          <target state="translated">Нижняя кронштейн-керли</target>
        </trans-unit>
        <trans-unit id="5c381cbda1ed56fa362cad0521e4ca378f6df12d" translate="yes" xml:space="preserve">
          <source>Bottom Left Corner</source>
          <target state="translated">Нижний левый угол</target>
        </trans-unit>
        <trans-unit id="8b91a1776362601aa94f5e511fc42880fb137818" translate="yes" xml:space="preserve">
          <source>Bottom Right Corner</source>
          <target state="translated">Нижний правый угол</target>
        </trans-unit>
        <trans-unit id="408cb2c9aacb6c00f4eea9f155e68230edfc13be" translate="yes" xml:space="preserve">
          <source>Bottom Square Bracket</source>
          <target state="translated">Кронштейн нижнего квадрата</target>
        </trans-unit>
        <trans-unit id="b587f4044bf50468cb606a8c8b879cf7bf3a57b0" translate="yes" xml:space="preserve">
          <source>Bottom Square Bracket Over Top Square Bracket</source>
          <target state="translated">Нижний квадратный кронштейн над верхним квадратным кронштейном</target>
        </trans-unit>
        <trans-unit id="be63873217899f3efce2481a86c1d5a6e1aa9ff7" translate="yes" xml:space="preserve">
          <source>Bouquet</source>
          <target state="translated">Bouquet</target>
        </trans-unit>
        <trans-unit id="527e7050bb885ff38897eb7cbe0d818d6e05448e" translate="yes" xml:space="preserve">
          <source>Bowling</source>
          <target state="translated">Bowling</target>
        </trans-unit>
        <trans-unit id="df3f8f8f9dfd1bd2fca6e5c445d1a47fa385ede3" translate="yes" xml:space="preserve">
          <source>Bowtie</source>
          <target state="translated">Bowtie</target>
        </trans-unit>
        <trans-unit id="2365940089f0b35468618bed420a02ff8d78ea80" translate="yes" xml:space="preserve">
          <source>Box Drawings Light Diagonal Upper Left To Lower Right / Forms Light Diagonal Upper Left To Lower Right</source>
          <target state="translated">Чертежи коробки Светлые диагональные верхние левые в нижние правые/Формы светлые диагональные верхние левые в нижние правые</target>
        </trans-unit>
        <trans-unit id="510ae6748e0c9b114a5f8b83c8badc7f63a16bc0" translate="yes" xml:space="preserve">
          <source>Box Drawings Light Diagonal Upper Right To Lower Left / Forms Light Diagonal Upper Right To Lower Left</source>
          <target state="translated">Чертежи коробки Светлый диагональ вверху справа вниз слева/Формы светлый диагональ вверху справа вниз слева</target>
        </trans-unit>
        <trans-unit id="12f6d098ab5b7193c3d26b08f696b2a980dca3f4" translate="yes" xml:space="preserve">
          <source>Box Drawings Light Triple Dash Vertical / Forms Light Triple Dash Vertical</source>
          <target state="translated">Рисунки коробки Светлый тройной тире Вертикаль/Формы Светлый тройной тире Вертикаль</target>
        </trans-unit>
        <trans-unit id="85230437c79e72b707969ab19fa9c93e520c40d0" translate="yes" xml:space="preserve">
          <source>Box Drawings Up Light And Left Heavy / Forms Up Light And Left Heavy</source>
          <target state="translated">Ящик рисунки вверх легкий и левый тяжелый/формирует вверх легкий и левый тяжелый</target>
        </trans-unit>
        <trans-unit id="b9dc9d8cb52edb821b0da78df2b6682eb917d791" translate="yes" xml:space="preserve">
          <source>Boy</source>
          <target state="translated">Boy</target>
        </trans-unit>
        <trans-unit id="c61eb5df5d78529f719e752eeef8ece81e0caaa8" translate="yes" xml:space="preserve">
          <source>Bread</source>
          <target state="translated">Bread</target>
        </trans-unit>
        <trans-unit id="67334b607f6cd61759a7703ce073645a7bb380d4" translate="yes" xml:space="preserve">
          <source>Break functions into multiple definitions</source>
          <target state="translated">Разбить функции на несколько определений</target>
        </trans-unit>
        <trans-unit id="8a10e4a625ea22134f5962dee4da949a99868e13" translate="yes" xml:space="preserve">
          <source>Break out of a loop immediately.</source>
          <target state="translated">Немедленно вырваться из петли.</target>
        </trans-unit>
        <trans-unit id="392384778265e06187313603c1377439a8615e6f" translate="yes" xml:space="preserve">
          <source>Break the &lt;code&gt;ConfigEntry&lt;/code&gt; up to the following pieces: section, subsection, name, and value.</source>
          <target state="translated">Разделите &lt;code&gt;ConfigEntry&lt;/code&gt; на следующие части: раздел, подраздел, имя и значение.</target>
        </trans-unit>
        <trans-unit id="7632e2c1e249278468e77e6447234ae7607c5253" translate="yes" xml:space="preserve">
          <source>Breve / Spacing Breve</source>
          <target state="translated">Бреве/промежуток времени Бреве</target>
        </trans-unit>
        <trans-unit id="daaf045cb7109dd158210ed8775987a60503bbb6" translate="yes" xml:space="preserve">
          <source>Bride With Veil</source>
          <target state="translated">Невеста с вуалем</target>
        </trans-unit>
        <trans-unit id="4e7371d09f6498019117c2fcbb67ffe9a940c17f" translate="yes" xml:space="preserve">
          <source>Bridge At Night</source>
          <target state="translated">Мост ночью</target>
        </trans-unit>
        <trans-unit id="ee60d60ea805fbda38f6f538481a92d3787df0b9" translate="yes" xml:space="preserve">
          <source>Brief description</source>
          <target state="translated">краткое описание</target>
        </trans-unit>
        <trans-unit id="b11bca2ce38ace33f9cb3a0f0323440cce89dd0f" translate="yes" xml:space="preserve">
          <source>Briefcase</source>
          <target state="translated">Briefcase</target>
        </trans-unit>
        <trans-unit id="77ca3fc6500edac54d325df1bbb7ac8e363c54b5" translate="yes" xml:space="preserve">
          <source>Broadcast</source>
          <target state="translated">Broadcast</target>
        </trans-unit>
        <trans-unit id="5959941fc9ce31c144990539361b6855d239f922" translate="yes" xml:space="preserve">
          <source>Broadcast Styles</source>
          <target state="translated">Стили вещания</target>
        </trans-unit>
        <trans-unit id="cdaa679362eaad18a4a290d4b2177d1c9eddf091" translate="yes" xml:space="preserve">
          <source>Broadcast and vectorization</source>
          <target state="translated">Трансляция и векторизация</target>
        </trans-unit>
        <trans-unit id="7df7947bfeebee1e64e3a5fe7acfcbaa176cd869" translate="yes" xml:space="preserve">
          <source>Broadcast the function &lt;code&gt;f&lt;/code&gt; over the arrays, tuples, collections, &lt;a href=&quot;../c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref&lt;/code&gt;&lt;/a&gt;s and/or scalars &lt;code&gt;As&lt;/code&gt;.</source>
          <target state="translated">Передайте функцию &lt;code&gt;f&lt;/code&gt; по массивам, кортежам, коллекциям, &lt;a href=&quot;../c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref&lt;/code&gt; &lt;/a&gt; и / или скалярам &lt;code&gt;As&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="074efe61b6453184efecedf79f56223cb3b56a06" translate="yes" xml:space="preserve">
          <source>Broadcast.@__dot__</source>
          <target state="translated">Broadcast.@__dot__</target>
        </trans-unit>
        <trans-unit id="d9974c014c3e7a0c286c1e54c44afebb2e5a2605" translate="yes" xml:space="preserve">
          <source>Broadcast.AbstractArrayStyle</source>
          <target state="translated">Broadcast.AbstractArrayStyle</target>
        </trans-unit>
        <trans-unit id="e479e2fec9cd8edd73518e3aa9d740af4ffed128" translate="yes" xml:space="preserve">
          <source>Broadcast.ArrayStyle</source>
          <target state="translated">Broadcast.ArrayStyle</target>
        </trans-unit>
        <trans-unit id="46b115d26f9c6f955c31e3892d4b89859d8782ab" translate="yes" xml:space="preserve">
          <source>Broadcast.BroadcastStyle</source>
          <target state="translated">Broadcast.BroadcastStyle</target>
        </trans-unit>
        <trans-unit id="dfd372b601ba77b3813f2634bb5fb9643c14c102" translate="yes" xml:space="preserve">
          <source>Broadcast.DefaultArrayStyle</source>
          <target state="translated">Broadcast.DefaultArrayStyle</target>
        </trans-unit>
        <trans-unit id="6969d3cd7b2ed2ce0f9a60fb4945dade93d4e117" translate="yes" xml:space="preserve">
          <source>Broadcast.broadcast!()</source>
          <target state="translated">Broadcast.broadcast!()</target>
        </trans-unit>
        <trans-unit id="2d33589d08eead5af3fe72a94a8b53b3373f4645" translate="yes" xml:space="preserve">
          <source>Broadcast.broadcast()</source>
          <target state="translated">Broadcast.broadcast()</target>
        </trans-unit>
        <trans-unit id="d8be6debc5bb7fb35ee9eb11d215775cae452707" translate="yes" xml:space="preserve">
          <source>Broadcast.broadcastable()</source>
          <target state="translated">Broadcast.broadcastable()</target>
        </trans-unit>
        <trans-unit id="48464259628c114acb1957dc941186fb95dc6984" translate="yes" xml:space="preserve">
          <source>Broadcast.combine_axes()</source>
          <target state="translated">Broadcast.combine_axes()</target>
        </trans-unit>
        <trans-unit id="65a7f7386144353a37453858bdd5ecb6ccb1274f" translate="yes" xml:space="preserve">
          <source>Broadcast.combine_styles()</source>
          <target state="translated">Broadcast.combine_styles()</target>
        </trans-unit>
        <trans-unit id="d36a0668f40c2a01499f97eb697585c01ce9b9ab" translate="yes" xml:space="preserve">
          <source>Broadcast.result_style()</source>
          <target state="translated">Broadcast.result_style()</target>
        </trans-unit>
        <trans-unit id="ba459229366746c447e3cdf752eb917433152cfe" translate="yes" xml:space="preserve">
          <source>Broadcasting</source>
          <target state="translated">Broadcasting</target>
        </trans-unit>
        <trans-unit id="0e83693fd8be7602fb86ef05c34ce5d03fd5fce4" translate="yes" xml:space="preserve">
          <source>Broadcasting applies the function &lt;code&gt;f&lt;/code&gt; over the elements of the container arguments and the scalars themselves in &lt;code&gt;As&lt;/code&gt;. Singleton and missing dimensions are expanded to match the extents of the other arguments by virtually repeating the value. By default, only a limited number of types are considered scalars, including &lt;code&gt;Number&lt;/code&gt;s, &lt;code&gt;String&lt;/code&gt;s, &lt;code&gt;Symbol&lt;/code&gt;s, &lt;code&gt;Type&lt;/code&gt;s, &lt;code&gt;Function&lt;/code&gt;s and some common singletons like &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;. All other arguments are iterated over or indexed into elementwise.</source>
          <target state="translated">Широковещательная рассылка применяет функцию &lt;code&gt;f&lt;/code&gt; к элементам аргументов контейнера и самим скалярам в &lt;code&gt;As&lt;/code&gt; . Одноэлементные и отсутствующие измерения расширяются, чтобы соответствовать размерам других аргументов, виртуально повторяя значение. По умолчанию только ограниченное количество типов считается скалярами, включая &lt;code&gt;Number&lt;/code&gt; s, &lt;code&gt;String&lt;/code&gt; s, &lt;code&gt;Symbol&lt;/code&gt; s, &lt;code&gt;Type&lt;/code&gt; s, &lt;code&gt;Function&lt;/code&gt; s и некоторые общие синглтоны, такие как &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; . Все остальные аргументы повторяются или индексируются поэлементно.</target>
        </trans-unit>
        <trans-unit id="7b246945f4825122c3abc36d497da5fe651d872b" translate="yes" xml:space="preserve">
          <source>Broadcasting behavior of &lt;code&gt;SrcType&lt;/code&gt;</source>
          <target state="translated">Широковещательное поведение &lt;code&gt;SrcType&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e2fa4ca8541a569a98cefd4832f00fffb8a668a" translate="yes" xml:space="preserve">
          <source>Broadcasting of CartesianIndices requires at least Julia 1.1.</source>
          <target state="translated">Для трансляции Картезианских Индексов требуется,по крайней мере,Юлия 1.1.</target>
        </trans-unit>
        <trans-unit id="de4b71257ec056201227e217cf933d2e092cf0c7" translate="yes" xml:space="preserve">
          <source>Broken Bar / Broken Vertical Bar</source>
          <target state="translated">Сломанный бар/Сломанный вертикальный бар</target>
        </trans-unit>
        <trans-unit id="0d35795616ab98cd5aa59673de45c7c6c73a4a9c" translate="yes" xml:space="preserve">
          <source>Broken Heart</source>
          <target state="translated">Разбитое сердце</target>
        </trans-unit>
        <trans-unit id="79b7916b0d6bd1fa29180da64a852f6051cdd3b6" translate="yes" xml:space="preserve">
          <source>Broken Tests</source>
          <target state="translated">Разбитые тесты</target>
        </trans-unit>
        <trans-unit id="8cb75fd2f909d7fe2d9ebdd702d582785b35815a" translate="yes" xml:space="preserve">
          <source>Browser-based workflow</source>
          <target state="translated">Рабочий процесс на основе браузера</target>
        </trans-unit>
        <trans-unit id="271befc09ec922fba884ac992f346efbaa84c1c6" translate="yes" xml:space="preserve">
          <source>Bug</source>
          <target state="translated">Bug</target>
        </trans-unit>
        <trans-unit id="a0ff1503de64d75563fdaa852cd66a5161072182" translate="yes" xml:space="preserve">
          <source>Build the output matrix as &lt;code&gt;similar(R, dims)&lt;/code&gt;, where &lt;code&gt;dims&lt;/code&gt; are the desired dimensions of the output array.</source>
          <target state="translated">Создайте матрицу вывода как &lt;code&gt;similar(R, dims)&lt;/code&gt; , где &lt;code&gt;dims&lt;/code&gt; - желаемые размеры выходного массива.</target>
        </trans-unit>
        <trans-unit id="9b68712d139bce25a7399715ee37cf5a89ca4787" translate="yes" xml:space="preserve">
          <source>Building a similar type with a different type parameter</source>
          <target state="translated">Строительство аналогичного типа с другим типом параметра</target>
        </trans-unit>
        <trans-unit id="472631cf7902fb6cb7b3cc2952c6a64c270752fa" translate="yes" xml:space="preserve">
          <source>Building an advanced macro</source>
          <target state="translated">Создание продвинутого макроса</target>
        </trans-unit>
        <trans-unit id="fe79fc1370416c81e94ca362477853ed355de172" translate="yes" xml:space="preserve">
          <source>Built-in &lt;code&gt;Exception&lt;/code&gt;s</source>
          <target state="translated">Встроенные &lt;code&gt;Exception&lt;/code&gt; s</target>
        </trans-unit>
        <trans-unit id="b98da0ccc81f4f734434572f19ccc66972aae344" translate="yes" xml:space="preserve">
          <source>Bullet</source>
          <target state="translated">Bullet</target>
        </trans-unit>
        <trans-unit id="b2e3c9a189a187c73db37aa7676051a963459c1a" translate="yes" xml:space="preserve">
          <source>Bullet Operator</source>
          <target state="translated">Пулевой оператор</target>
        </trans-unit>
        <trans-unit id="ffb3a635db82436b5aade99cffc92370f3f7ed19" translate="yes" xml:space="preserve">
          <source>Bullseye</source>
          <target state="translated">Bullseye</target>
        </trans-unit>
        <trans-unit id="6380df8107fb2d9626efb1aee5cb211de2982cbd" translate="yes" xml:space="preserve">
          <source>Bunch-Kaufman (see &lt;a href=&quot;#LinearAlgebra.bunchkaufman&quot;&gt;&lt;code&gt;bunchkaufman&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Банч-Кауфман (см. &lt;a href=&quot;#LinearAlgebra.bunchkaufman&quot;&gt; &lt;code&gt;bunchkaufman&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d42c62a3c53679a83b69d0fce6f99bfd41a308aa" translate="yes" xml:space="preserve">
          <source>Bunch-Kaufman factorization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56070a568367d5a4e9970cfff19cb97578ce1361" translate="yes" xml:space="preserve">
          <source>Bus</source>
          <target state="translated">Bus</target>
        </trans-unit>
        <trans-unit id="de2d017d398674ca4eafe20ca3761f2f657234b8" translate="yes" xml:space="preserve">
          <source>Bus Stop</source>
          <target state="translated">Автобусная остановка</target>
        </trans-unit>
        <trans-unit id="97d53e844a4148a55c4152e5e7736932ca111090" translate="yes" xml:space="preserve">
          <source>Bust In Silhouette</source>
          <target state="translated">Бюст в силуэте</target>
        </trans-unit>
        <trans-unit id="45f0d298267aa05679aedb20cf6611cfa3d2a5d1" translate="yes" xml:space="preserve">
          <source>Busts In Silhouette</source>
          <target state="translated">Бюсты в силуэте</target>
        </trans-unit>
        <trans-unit id="e7a7510504bc122560ba5c8208e379522ff06902" translate="yes" xml:space="preserve">
          <source>But here is a thing you should pay attention to: suppose &lt;code&gt;x&lt;/code&gt; is bound to an object of type &lt;code&gt;Array&lt;/code&gt; (or any other &lt;em&gt;mutable&lt;/em&gt; type). From within the function, you cannot &quot;unbind&quot; &lt;code&gt;x&lt;/code&gt; from this Array, but you can change its content. For example:</source>
          <target state="translated">Но вот на что следует обратить внимание: предположим, &lt;code&gt;x&lt;/code&gt; привязан к объекту типа &lt;code&gt;Array&lt;/code&gt; (или любому другому &lt;em&gt;изменяемому&lt;/em&gt; типу). Изнутри функции вы не можете &amp;laquo;отвязать&amp;raquo; &lt;code&gt;x&lt;/code&gt; от этого массива, но можете изменить его содержимое. Например:</target>
        </trans-unit>
        <trans-unit id="0adf28177ba73d224bb6721567052c88af510023" translate="yes" xml:space="preserve">
          <source>But how does one construct the first instance when no instance exists to provide as a valid value for its &lt;code&gt;obj&lt;/code&gt; field? The only solution is to allow creating an incompletely initialized instance of &lt;code&gt;SelfReferential&lt;/code&gt; with an unassigned &lt;code&gt;obj&lt;/code&gt; field, and using that incomplete instance as a valid value for the &lt;code&gt;obj&lt;/code&gt; field of another instance, such as, for example, itself.</source>
          <target state="translated">Но как создать первый экземпляр, если не существует экземпляра, который можно было бы предоставить в качестве допустимого значения для своего поля &lt;code&gt;obj&lt;/code&gt; ? Единственное решение - разрешить создание не полностью инициализированного экземпляра &lt;code&gt;SelfReferential&lt;/code&gt; с неназначенным полем &lt;code&gt;obj&lt;/code&gt; и использование этого неполного экземпляра в качестве допустимого значения для поля &lt;code&gt;obj&lt;/code&gt; другого экземпляра, такого как, например, он сам.</target>
        </trans-unit>
        <trans-unit id="64b3ab17aa40196bbbe2b14cd1e8633f165597c6" translate="yes" xml:space="preserve">
          <source>But in general, embedding projects will be more complicated than the above, and so the following allows general makefile support as well &amp;ndash; assuming GNU make because of the use of the &lt;strong&gt;shell&lt;/strong&gt; macro expansions. Additionally, though many times &lt;code&gt;julia-config.jl&lt;/code&gt; may be found in the directory &lt;code&gt;/usr/local&lt;/code&gt;, this is not necessarily the case, but Julia can be used to locate &lt;code&gt;julia-config.jl&lt;/code&gt; too, and the makefile can be used to take advantage of that. The above example is extended to use a Makefile:</source>
          <target state="translated">Но в целом встраивание проектов будет сложнее, чем описанные выше, и поэтому нижеследующее также обеспечивает общую поддержку make-файлов - при условии, что GNU make из-за использования расширений макросов &lt;strong&gt;оболочки&lt;/strong&gt; . Кроме того, хотя часто &lt;code&gt;julia-config.jl&lt;/code&gt; можно найти в каталоге &lt;code&gt;/usr/local&lt;/code&gt; , это не обязательно так, но Julia также можно использовать для поиска &lt;code&gt;julia-config.jl&lt;/code&gt; , а make-файл можно использовать для преимущество этого. Приведенный выше пример расширен для использования Makefile:</target>
        </trans-unit>
        <trans-unit id="26a3e909feee0f8ba5a7fedacb473c7c1f12eb3d" translate="yes" xml:space="preserve">
          <source>But now let's say you want to write a function that creates a 3&amp;times;3&amp;times;... array in arbitrary dimensions; you might be tempted to write a function</source>
          <target state="translated">Но теперь предположим, что вы хотите написать функцию, которая создает массив 3 &amp;times; 3 &amp;times; ... в произвольных размерах; у вас может возникнуть соблазн написать функцию</target>
        </trans-unit>
        <trans-unit id="7e347dfe55eb3d3f84185c35ba67fdd467b54efe" translate="yes" xml:space="preserve">
          <source>But there's an exception: future calls to &lt;code&gt;newfun&lt;/code&gt;&lt;em&gt;from the REPL&lt;/em&gt; work as expected, being able to both see and call the new definition of &lt;code&gt;newfun&lt;/code&gt;.</source>
          <target state="translated">Но есть исключение: будущие вызовы &lt;code&gt;newfun&lt;/code&gt; &lt;em&gt;из REPL&lt;/em&gt; работают, как ожидалось, имея возможность видеть и вызывать новое определение &lt;code&gt;newfun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dcbe9aaf1e0a6755fccfa933b76845ffa848937" translate="yes" xml:space="preserve">
          <source>But we are currently on the master thread. To check, we use the function &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.threadid&quot;&gt;&lt;code&gt;Threads.threadid&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Но в настоящее время мы находимся в основном потоке. Для проверки используем функцию &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.threadid&quot;&gt; &lt;code&gt;Threads.threadid&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c84f932b434e9c92f4f20cc3eb7ea04021d4d339" translate="yes" xml:space="preserve">
          <source>By convention, function names ending with an exclamation point (&lt;code&gt;!&lt;/code&gt;) modify their arguments. Some functions have both modifying (e.g., &lt;code&gt;sort!&lt;/code&gt;) and non-modifying (&lt;code&gt;sort&lt;/code&gt;) versions.</source>
          <target state="translated">По соглашению имена функций, заканчивающиеся восклицательным знаком ( &lt;code&gt;!&lt;/code&gt; ), Изменяют свои аргументы. Некоторые функции имеют как модифицирующую (например, &lt;code&gt;sort!&lt;/code&gt; ), Так и немодифицирующую ( &lt;code&gt;sort&lt;/code&gt; ) версии.</target>
        </trans-unit>
        <trans-unit id="b2d3b6d57737895d1e4453b18b72e5f94ecdeb4e" translate="yes" xml:space="preserve">
          <source>By convention, functions that modify their arguments have a &lt;code&gt;!&lt;/code&gt; at the end of the name, for example &lt;code&gt;push!&lt;/code&gt;.</source>
          <target state="translated">По соглашению функции, изменяющие свои аргументы, имеют &lt;code&gt;!&lt;/code&gt; в конце имени, например &lt;code&gt;push!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="ab2ce248423f04c77b0bad395e4714e39c7fb937" translate="yes" xml:space="preserve">
          <source>By default (&lt;code&gt;alpha = beta = 1&lt;/code&gt;), quantiles are computed via linear interpolation between the points &lt;code&gt;((k-1)/(n-1), v[k])&lt;/code&gt;, for &lt;code&gt;k = 1:n&lt;/code&gt; where &lt;code&gt;n = length(itr)&lt;/code&gt;. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R and NumPy default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760f93efed44d4a2ba0963c541f9ed0ec06bfb96" translate="yes" xml:space="preserve">
          <source>By default (&lt;code&gt;alpha = beta = 1&lt;/code&gt;), quantiles are computed via linear interpolation between the points &lt;code&gt;((k-1)/(n-1), v[k])&lt;/code&gt;, for &lt;code&gt;k = 1:n&lt;/code&gt; where &lt;code&gt;n = length(v)&lt;/code&gt;. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R and NumPy default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a501bd6222e05849ace3fea85fb677e79bd185" translate="yes" xml:space="preserve">
          <source>By default a worker will listen on a free port at the address returned by a call to &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getipaddr&quot;&gt;&lt;code&gt;getipaddr()&lt;/code&gt;&lt;/a&gt;. A specific address to listen on may be specified by optional argument &lt;code&gt;--bind-to bind_addr[:port]&lt;/code&gt;. This is useful for multi-homed hosts.</source>
          <target state="translated">По умолчанию рабочий будет прослушивать свободный порт по адресу, возвращаемому вызовом &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getipaddr&quot;&gt; &lt;code&gt;getipaddr()&lt;/code&gt; &lt;/a&gt; . Конкретный адрес для прослушивания может быть указан необязательным аргументом &lt;code&gt;--bind-to bind_addr[:port]&lt;/code&gt; . Это полезно для многосетевых хостов.</target>
        </trans-unit>
        <trans-unit id="cb670232f9c9a08075052bf52fba2ffbf6b303ba" translate="yes" xml:space="preserve">
          <source>By default all exceptions are caught to prevent log message generation from crashing the program. This lets users confidently toggle little-used functionality - such as debug logging - in a production system.</source>
          <target state="translated">По умолчанию все исключения перехватываются,чтобы предотвратить сбой в генерации сообщений журнала.Это позволяет пользователям уверенно переключать малоиспользуемую функциональность-такую как отладочный лог-в производственной системе.</target>
        </trans-unit>
        <trans-unit id="3274665bf281763d801f2b3f0f09acc363497f47" translate="yes" xml:space="preserve">
          <source>By default julia does not wait for the editor to close, running it in the background. However, if the editor is terminal based, you will probably want to set &lt;code&gt;wait=true&lt;/code&gt; and julia will wait for the editor to close before resuming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09501703ac8c23ae9a60cea7e5421daf3cd18b0" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;@testset&lt;/code&gt; macro will return the testset object itself, though this behavior can be customized in other testset types. If a &lt;code&gt;for&lt;/code&gt; loop is used then the macro collects and returns a list of the return values of the &lt;code&gt;finish&lt;/code&gt; method, which by default will return a list of the testset objects used in each iteration.</source>
          <target state="translated">По умолчанию макрос &lt;code&gt;@testset&lt;/code&gt; возвращает сам объект набора тестов, хотя это поведение можно настроить в других типах наборов тестов. Если используется цикл &lt;code&gt;for&lt;/code&gt; , макрос собирает и возвращает список возвращаемых значений метода &lt;code&gt;finish&lt;/code&gt; , который по умолчанию возвращает список объектов тестового набора, используемых в каждой итерации.</target>
        </trans-unit>
        <trans-unit id="62c321cdf328de0b934c0ed64ba600400a916f6d" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pmap&lt;/code&gt; distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify &lt;code&gt;distributed=false&lt;/code&gt;. This is equivalent to using &lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt;&lt;code&gt;asyncmap&lt;/code&gt;&lt;/a&gt;. For example, &lt;code&gt;pmap(f, c; distributed=false)&lt;/code&gt; is equivalent to &lt;code&gt;asyncmap(f,c; ntasks=()-&amp;gt;nworkers())&lt;/code&gt;</source>
          <target state="translated">По умолчанию &lt;code&gt;pmap&lt;/code&gt; распределяет вычисления по всем указанным воркерам . Чтобы использовать только локальный процесс и распределять по задачам, укажите &lt;code&gt;distributed=false&lt;/code&gt; . Это эквивалентно использованию &lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt; &lt;code&gt;asyncmap&lt;/code&gt; &lt;/a&gt; . Например, &lt;code&gt;pmap(f, c; distributed=false)&lt;/code&gt; эквивалентно &lt;code&gt;asyncmap(f,c; ntasks=()-&amp;gt;nworkers())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="869bf1d13613c15994bb6c5a2998c89afa6bc5e7" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;readdir&lt;/code&gt; sorts the list of names it returns. If you want to skip sorting the names and get them in the order that the file system lists them, you can use &lt;code&gt;readir(dir, sort=false)&lt;/code&gt; to opt out of sorting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f89fa8608376528e1d0c826b9825a253fbd041b" translate="yes" xml:space="preserve">
          <source>By default, Fortran compilers &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling#Fortran&quot;&gt;generate mangled names&lt;/a&gt; (for example, converting function names to lowercase or uppercase, often appending an underscore), and so to call a Fortran function via &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; you must pass the mangled identifier corresponding to the rule followed by your Fortran compiler. Also, when calling a Fortran function, all inputs must be passed as pointers to allocated values on the heap or stack. This applies not only to arrays and other mutable objects which are normally heap-allocated, but also to scalar values such as integers and floats which are normally stack-allocated and commonly passed in registers when using C or Julia calling conventions.</source>
          <target state="translated">По умолчанию компиляторы Fortran &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling#Fortran&quot;&gt;генерируют искаженные имена&lt;/a&gt; (например, преобразовывая имена функций в нижний или верхний регистр, часто добавляя подчеркивание), поэтому для вызова функции Fortran через &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; вы должны передать искаженный идентификатор, соответствующий правилу, которому следует ваш компилятор Fortran. , Кроме того, при вызове функции Fortran все входные данные должны передаваться как указатели на выделенные значения в куче или стеке. Это относится не только к массивам и другим изменяемым объектам, которые обычно выделяются в куче, но также и к скалярным значениям, таким как целые числа и числа с плавающей запятой, которые обычно выделяются в стеке и обычно передаются в регистрах при использовании соглашений о вызовах C или Julia.</target>
        </trans-unit>
        <trans-unit id="7b4db9ff202a42835afe09d8709e3f5d83b19913" translate="yes" xml:space="preserve">
          <source>By default, Julia returns &lt;code&gt;BitArrays&lt;/code&gt; from &lt;a href=&quot;../../manual/arrays/index#Broadcasting&quot;&gt;broadcasting&lt;/a&gt; operations that generate boolean elements (including dotted-comparisons like &lt;code&gt;.==&lt;/code&gt;) as well as from the functions &lt;a href=&quot;#Base.trues&quot;&gt;&lt;code&gt;trues&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.falses&quot;&gt;&lt;code&gt;falses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97954da2a37348f9b604be87e49342f9bb3f535a" translate="yes" xml:space="preserve">
          <source>By default, Julia returns &lt;code&gt;BitArrays&lt;/code&gt; from &lt;a href=&quot;../../manual/arrays/index#Broadcasting-1&quot;&gt;broadcasting&lt;/a&gt; operations that generate boolean elements (including dotted-comparisons like &lt;code&gt;.==&lt;/code&gt;) as well as from the functions &lt;a href=&quot;#Base.trues&quot;&gt;&lt;code&gt;trues&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.falses&quot;&gt;&lt;code&gt;falses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">По умолчанию Юлия возвращает &lt;code&gt;BitArrays&lt;/code&gt; из &lt;a href=&quot;../../manual/arrays/index#Broadcasting-1&quot;&gt;трансляции&lt;/a&gt; операций , которые генерируют логические элементы ( в том числе пунктирных-сравнений как &lt;code&gt;.==&lt;/code&gt; ), а также от функций &lt;a href=&quot;#Base.trues&quot;&gt; &lt;code&gt;trues&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Base.falses&quot;&gt; &lt;code&gt;falses&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b61e736cef16f73d649bec40a1cb5e23234e0fb3" translate="yes" xml:space="preserve">
          <source>By default, Julia starts up with a single thread of execution. This can be verified by using the command &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.nthreads&quot;&gt;&lt;code&gt;Threads.nthreads()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">По умолчанию Джулия запускается с одним потоком выполнения. В этом можно убедиться с помощью команды &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.nthreads&quot;&gt; &lt;code&gt;Threads.nthreads()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a32e1e323d14dc3db4577d3f3c64972051fa6f1a" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;redisplay&lt;/code&gt; functions simply call &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt;. However, some display backends may override &lt;code&gt;redisplay&lt;/code&gt; to modify an existing display of &lt;code&gt;x&lt;/code&gt; (if any). Using &lt;code&gt;redisplay&lt;/code&gt; is also a hint to the backend that &lt;code&gt;x&lt;/code&gt; may be redisplayed several times, and the backend may choose to defer the display until (for example) the next interactive prompt.</source>
          <target state="translated">По умолчанию функции &lt;code&gt;redisplay&lt;/code&gt; просто вызывают &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display&lt;/code&gt; &lt;/a&gt; . Однако некоторые серверные модули отображения могут переопределить &lt;code&gt;redisplay&lt;/code&gt; чтобы изменить существующее отображение &lt;code&gt;x&lt;/code&gt; (если есть). Использование &lt;code&gt;redisplay&lt;/code&gt; также является подсказкой для бэкэнда, что &lt;code&gt;x&lt;/code&gt; может быть повторно отображен несколько раз, и бэкэнд может отложить отображение до (например) следующего интерактивного приглашения.</target>
        </trans-unit>
        <trans-unit id="3a789ab7e78cdd1c9fcc76d1aa6c29cc8860d633" translate="yes" xml:space="preserve">
          <source>By default, the eigenvalues and vectors are sorted lexicographically by &lt;code&gt;(real(&amp;lambda;),imag(&amp;lambda;))&lt;/code&gt;. A different comparison function &lt;code&gt;by(&amp;lambda;)&lt;/code&gt; can be passed to &lt;code&gt;sortby&lt;/code&gt;, or you can pass &lt;code&gt;sortby=nothing&lt;/code&gt; to leave the eigenvalues in an arbitrary order. Some special matrix types (e.g. &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt;&lt;code&gt;SymTridiagonal&lt;/code&gt;&lt;/a&gt;) may implement their own sorting convention and not accept a &lt;code&gt;sortby&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2434a57ba6bd0a71b3ac08a278b454d4192e915f" translate="yes" xml:space="preserve">
          <source>By default, the eigenvalues and vectors are sorted lexicographically by &lt;code&gt;(real(&amp;lambda;),imag(&amp;lambda;))&lt;/code&gt;. A different comparison function &lt;code&gt;by(&amp;lambda;)&lt;/code&gt; can be passed to &lt;code&gt;sortby&lt;/code&gt;, or you can pass &lt;code&gt;sortby=nothing&lt;/code&gt; to leave the eigenvalues in an arbitrary order. Some special matrix types (e.g. &lt;code&gt;Diagonal&lt;/code&gt; or &lt;code&gt;SymTridiagonal&lt;/code&gt;) may implement their own sorting convention and not accept a &lt;code&gt;sortby&lt;/code&gt; keyword.</source>
          <target state="translated">По умолчанию собственные значения и векторы лексикографически отсортированы по &lt;code&gt;(real(&amp;lambda;),imag(&amp;lambda;))&lt;/code&gt; . Другая функция сравнения &lt;code&gt;by(&amp;lambda;)&lt;/code&gt; может быть передан в &lt;code&gt;sortby&lt;/code&gt; , или вы не можете передать &lt;code&gt;sortby=nothing&lt;/code&gt; , чтобы оставить собственные в произвольном порядке. Некоторые специальные типы матриц (например, &lt;code&gt;Diagonal&lt;/code&gt; или &lt;code&gt;SymTridiagonal&lt;/code&gt; ) могут реализовывать собственное соглашение о сортировке и не принимать ключевое слово &lt;code&gt;sortby&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a1522d8655f0697d6a68319f9a29fb0897d5118" translate="yes" xml:space="preserve">
          <source>By default, the relative tolerance &lt;code&gt;rtol&lt;/code&gt; is &lt;code&gt;n*ϵ&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the smallest dimension of &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;ϵ&lt;/code&gt; is the &lt;a href=&quot;../dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the element type of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">По умолчанию, относительный допуск &lt;code&gt;rtol&lt;/code&gt; является &lt;code&gt;n*ϵ&lt;/code&gt; , где &lt;code&gt;n&lt;/code&gt; является размер наименьшего размера &lt;code&gt;M&lt;/code&gt; , а &lt;code&gt;ϵ&lt;/code&gt; является &lt;a href=&quot;../dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; типа элемента из &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36562c471751aaedc6db712652b89541573e3bb4" translate="yes" xml:space="preserve">
          <source>By extension any odd number of backticks may be used to enclose a lesser number of backticks.</source>
          <target state="translated">Расширяется нечетное количество черных фишек,которое может быть использовано для вложения меньшего количества черных фишек.</target>
        </trans-unit>
        <trans-unit id="300c0d12698af77dc8e2c084d058d532e1315b6c" translate="yes" xml:space="preserve">
          <source>By printing the array, one can verify that the elements of &lt;code&gt;x&lt;/code&gt; are now reversed.</source>
          <target state="translated">Распечатав массив, можно убедиться, что элементы &lt;code&gt;x&lt;/code&gt; теперь перевернуты.</target>
        </trans-unit>
        <trans-unit id="760e88f232085bdc1aa9ba910e6eb19bee1e689b" translate="yes" xml:space="preserve">
          <source>By running &quot;infrequently&quot; there is very little performance overhead; while profiling, your code can run at nearly native speed.</source>
          <target state="translated">При запуске &quot;редко&quot; накладных расходов на производительность очень мало;при профилировании ваш код может работать практически на собственной скорости.</target>
        </trans-unit>
        <trans-unit id="95b6f4faddfdd9853ff8e907fd6f47265a9f07a0" translate="yes" xml:space="preserve">
          <source>By using an RNG parameter initialized with a given seed, you can reproduce the same pseudorandom number sequence when running your program multiple times. However, a minor release of Julia (e.g. 1.3 to 1.4) &lt;em&gt;may change&lt;/em&gt; the sequence of pseudorandom numbers generated from a specific seed. (Even if the sequence produced by a low-level function like &lt;a href=&quot;#Base.rand&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; does not change, the output of higher-level functions like &lt;a href=&quot;#Random.randsubseq&quot;&gt;&lt;code&gt;randsubseq&lt;/code&gt;&lt;/a&gt; may change due to algorithm updates.) Rationale: guaranteeing that pseudorandom streams never change prohibits many algorithmic improvements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24780bfad6073c3cb5039801b32f126d34c1cde" translate="yes" xml:space="preserve">
          <source>Byte Array Literals</source>
          <target state="translated">Байтовый массив букв</target>
        </trans-unit>
        <trans-unit id="c950fe9e51a4a280dd4bb58c0d0951450fe7bbf3" translate="yes" xml:space="preserve">
          <source>C &lt;strong&gt;MUST NOT&lt;/strong&gt; modify the memory returned via &lt;code&gt;Ref{T}&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is an &lt;code&gt;isbits&lt;/code&gt; type</source>
          <target state="translated">C &lt;strong&gt;НЕ ДОЛЖЕН&lt;/strong&gt; модифицировать память, возвращаемую через &lt;code&gt;Ref{T}&lt;/code&gt; если &lt;code&gt;T&lt;/code&gt; является типом &lt;code&gt;isbits&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a10776e7bb2378d8306c9c38209f9a25bdd03a13" translate="yes" xml:space="preserve">
          <source>C Bischof and C Van Loan, &quot;The WY representation for products of Householder matrices&quot;, SIAM J Sci Stat Comput 8 (1987), s2-s13. &lt;a href=&quot;https://doi.org/10.1137/0908009&quot;&gt;doi:10.1137/0908009&lt;/a&gt;</source>
          <target state="translated">С. Бишоф и С. Ван Лоан, &quot;Представление WY для произведений матриц Хаусхолдера&quot;, SIAM J Sci Stat Comput 8 (1987), s2-s13. &lt;a href=&quot;https://doi.org/10.1137/0908009&quot;&gt;DOI: 10,1137 / 0908009&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9a1acddb6f4bd40edd805612e996267e826e064" translate="yes" xml:space="preserve">
          <source>C Interface</source>
          <target state="translated">C-интерфейс</target>
        </trans-unit>
        <trans-unit id="6592ddb6b4a1a593e3571fb32f8e7a37a9f3a350" translate="yes" xml:space="preserve">
          <source>C Standard Library</source>
          <target state="translated">C Стандартная библиотека</target>
        </trans-unit>
        <trans-unit id="3a8599236e86a8cb6d00c7c55845e656c7c05673" translate="yes" xml:space="preserve">
          <source>C Wrapper Examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e127f5f8d00244c8e1c9f0ff88de5ec4ac1783" translate="yes" xml:space="preserve">
          <source>C function pointer for &lt;code&gt;credentials_callback&lt;/code&gt;</source>
          <target state="translated">Указатель функции C для &lt;code&gt;credentials_callback&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c33ee7fd9016392ef47ce064a1a8200fb287dc56" translate="yes" xml:space="preserve">
          <source>C function pointer for &lt;code&gt;fetchhead_foreach_callback&lt;/code&gt;</source>
          <target state="translated">Указатель функции C для &lt;code&gt;fetchhead_foreach_callback&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf80fd7e58e3463df2196d9d8b7daa3fb24795de" translate="yes" xml:space="preserve">
          <source>C function pointer for &lt;code&gt;mirror_callback&lt;/code&gt;</source>
          <target state="translated">Указатель функции C для &lt;code&gt;mirror_callback&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5cb63f576281637ef8721a44852ed39bd47bda3e" translate="yes" xml:space="preserve">
          <source>C functions that take an argument of the type &lt;code&gt;char**&lt;/code&gt; can be called by using a &lt;code&gt;Ptr{Ptr{UInt8}}&lt;/code&gt; type within Julia. For example, C functions of the form:</source>
          <target state="translated">Функции C, которые принимают аргумент типа &lt;code&gt;char**&lt;/code&gt; могут быть вызваны с помощью типа &lt;code&gt;Ptr{Ptr{UInt8}}&lt;/code&gt; в Julia. Например, функции C вида:</target>
        </trans-unit>
        <trans-unit id="eb931938945d732d0cc3c0bc381f1e2e03fc8a86" translate="yes" xml:space="preserve">
          <source>C functions that take an argument of type &lt;code&gt;char**&lt;/code&gt; can be called by using a &lt;code&gt;Ptr{Ptr{UInt8}}&lt;/code&gt; type within Julia. For example, C functions of the form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272eaa6fb30cbc6d678d9c3342e07f66e1c123e0" translate="yes" xml:space="preserve">
          <source>C name</source>
          <target state="translated">C имя</target>
        </trans-unit>
        <trans-unit id="315194526a16e46e96fc7a6c9fe2f734e368a015" translate="yes" xml:space="preserve">
          <source>C shell on Linux/macOS, CMD on Windows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="7877de4c10096f42fa8b542b38a0c8abfeff2993" translate="yes" xml:space="preserve">
          <source>CFunction</source>
          <target state="translated">CFunction</target>
        </trans-unit>
        <trans-unit id="d6deb7587f97d7c2e002671a4a7ec9c17092aa98" translate="yes" xml:space="preserve">
          <source>CRC32c</source>
          <target state="translated">CRC32c</target>
        </trans-unit>
        <trans-unit id="946e46ea933373d5acfe718ba4c46ff0c631d8da" translate="yes" xml:space="preserve">
          <source>C_NULL</source>
          <target state="translated">C_NULL</target>
        </trans-unit>
        <trans-unit id="062c01810c7f050347900909c2a5c905fb7f6b61" translate="yes" xml:space="preserve">
          <source>Caches credential information for re-use</source>
          <target state="translated">Кэширует учетные данные для повторного использования</target>
        </trans-unit>
        <trans-unit id="9f296c645c05d20e8d397ba3c6535ccc69ae356d" translate="yes" xml:space="preserve">
          <source>Caching of native pointers.</source>
          <target state="translated">Кэширование местных указателей.</target>
        </trans-unit>
        <trans-unit id="ffbcb973995142c82bf466dc886625f88d2fbcf8" translate="yes" xml:space="preserve">
          <source>Cactus</source>
          <target state="translated">Cactus</target>
        </trans-unit>
        <trans-unit id="ac32f232b7ff982020ec20b1d05cbfe41644842d" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;A&lt;/code&gt;, and return the result.</source>
          <target state="translated">Вычислите матрицу-матричное произведение $ AB $, перезаписав &lt;code&gt;A&lt;/code&gt; , и верните результат.</target>
        </trans-unit>
        <trans-unit id="129c66daa23d40a052d78c17325451f781f1cd27" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;A&lt;/code&gt;, and return the result. Here, &lt;code&gt;B&lt;/code&gt; must be of special matrix type, like, e.g., &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.UpperTriangular&quot;&gt;&lt;code&gt;UpperTriangular&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.LowerTriangular&quot;&gt;&lt;code&gt;LowerTriangular&lt;/code&gt;&lt;/a&gt;, or of some orthogonal type, see &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt;&lt;code&gt;QR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d41dc1e33975c5f259e3c41e3a555f7d4e2007c" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;B&lt;/code&gt;, and return the result.</source>
          <target state="translated">Вычислите произведение матрицы на матрицу $ AB $, перезаписав &lt;code&gt;B&lt;/code&gt; , и верните результат.</target>
        </trans-unit>
        <trans-unit id="f409cbcda5b59decdd240fd1a21ee0be89005565" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;B&lt;/code&gt;, and return the result. Here, &lt;code&gt;A&lt;/code&gt; must be of special matrix type, like, e.g., &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.UpperTriangular&quot;&gt;&lt;code&gt;UpperTriangular&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.LowerTriangular&quot;&gt;&lt;code&gt;LowerTriangular&lt;/code&gt;&lt;/a&gt;, or of some orthogonal type, see &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt;&lt;code&gt;QR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c95fa1680ff9d2f9d27d1192e3762d37dafb02b" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;-x&lt;/code&gt;, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. &lt;code&gt;Int&lt;/code&gt;) cannot represent &lt;code&gt;-typemin(Int)&lt;/code&gt;, thus leading to an overflow.</source>
          <target state="translated">Вычисляет &lt;code&gt;-x&lt;/code&gt; , проверяя при необходимости ошибки переполнения. Например, стандартные целые числа со &lt;code&gt;-typemin(Int)&lt;/code&gt; дополнения до двух (например, &lt;code&gt;Int&lt;/code&gt; ) не могут представлять -typemin (Int) , что приводит к переполнению.</target>
        </trans-unit>
        <trans-unit id="6167c036f7bc22425fe096ac27be440fe0ac62c7" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;abs(x)&lt;/code&gt;, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. &lt;code&gt;Int&lt;/code&gt;) cannot represent &lt;code&gt;abs(typemin(Int))&lt;/code&gt;, thus leading to an overflow.</source>
          <target state="translated">Вычисляет &lt;code&gt;abs(x)&lt;/code&gt; , проверяя при необходимости ошибки переполнения. Например, стандартные целые числа со &lt;code&gt;abs(typemin(Int))&lt;/code&gt; дополнения до двух (например, &lt;code&gt;Int&lt;/code&gt; ) не могут представлять abs (typemin (Int)) , что приводит к переполнению.</target>
        </trans-unit>
        <trans-unit id="28790cf90cf177147936302a9d1094b853b086f9" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;cld(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">Вычисляет &lt;code&gt;cld(x,y)&lt;/code&gt; , проверяя наличие ошибок переполнения.</target>
        </trans-unit>
        <trans-unit id="4c05dcdfe5d48ed5364bba76a8d88216a7900800" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;div(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">Вычисляет &lt;code&gt;div(x,y)&lt;/code&gt; , проверяя при необходимости ошибки переполнения.</target>
        </trans-unit>
        <trans-unit id="a3d2d9753cdcfd6dd922be36bbcacaaf32453196" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;fld(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">Вычисляет &lt;code&gt;fld(x,y)&lt;/code&gt; , проверяя при необходимости ошибки переполнения.</target>
        </trans-unit>
        <trans-unit id="2c843612cbe327e35009726e8d036ba9b466e318" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;mod(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">Вычисляет &lt;code&gt;mod(x,y)&lt;/code&gt; , проверяя наличие ошибок переполнения.</target>
        </trans-unit>
        <trans-unit id="3ff6965bc32424b3a4e9ae967a2b78b31c8687be" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;r = x*y&lt;/code&gt;, with the flag &lt;code&gt;f&lt;/code&gt; indicating whether overflow has occurred.</source>
          <target state="translated">Вычисляет &lt;code&gt;r = x*y&lt;/code&gt; , при этом флаг &lt;code&gt;f&lt;/code&gt; указывает, произошло ли переполнение.</target>
        </trans-unit>
        <trans-unit id="31af4e89c705ea1b47696c4b34bfb97a778c9f15" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;r = x+y&lt;/code&gt;, with the flag &lt;code&gt;f&lt;/code&gt; indicating whether overflow has occurred.</source>
          <target state="translated">Вычисляет &lt;code&gt;r = x+y&lt;/code&gt; , при этом флаг &lt;code&gt;f&lt;/code&gt; указывает, произошло ли переполнение.</target>
        </trans-unit>
        <trans-unit id="fd998eb3f6f3e0335eab6ff45b9ad97358dd0ca0" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;r = x-y&lt;/code&gt;, with the flag &lt;code&gt;f&lt;/code&gt; indicating whether overflow has occurred.</source>
          <target state="translated">Вычисляет &lt;code&gt;r = x-y&lt;/code&gt; , при этом флаг &lt;code&gt;f&lt;/code&gt; указывает, произошло ли переполнение.</target>
        </trans-unit>
        <trans-unit id="efdf3f45f374c38b59fd728eaad712d7890f84ff" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x%y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">Вычисляет &lt;code&gt;x%y&lt;/code&gt; , проверяя при необходимости ошибки переполнения.</target>
        </trans-unit>
        <trans-unit id="08676bba541f171d54d453c583476f048c4309ad" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x*y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">Вычисляет &lt;code&gt;x*y&lt;/code&gt; , проверяя при необходимости ошибки переполнения.</target>
        </trans-unit>
        <trans-unit id="dd10e9d48c83e327a775e0dc3fbaa5b8a6d8c773" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x+y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">Вычисляет &lt;code&gt;x+y&lt;/code&gt; , проверяя при необходимости ошибки переполнения.</target>
        </trans-unit>
        <trans-unit id="7bc22057d7126532dbb6ba4068b470e14e78325a" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x-y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">Вычисляет &lt;code&gt;x-y&lt;/code&gt; , проверяя при необходимости ошибки переполнения.</target>
        </trans-unit>
        <trans-unit id="aba6566e0673d1e53c249760fa025027d921398e" translate="yes" xml:space="preserve">
          <source>Calculates the matrix-matrix or matrix-vector product $AB$ and stores the result in &lt;code&gt;Y&lt;/code&gt;, overwriting the existing value of &lt;code&gt;Y&lt;/code&gt;. Note that &lt;code&gt;Y&lt;/code&gt; must not be aliased with either &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">Вычисление матрица-матрица или матрица-вектор продукт $ AB $ и сохраняет результат в &lt;code&gt;Y&lt;/code&gt; , перезапись существующего значения &lt;code&gt;Y&lt;/code&gt; . Обратите внимание , что &lt;code&gt;Y&lt;/code&gt; не должен быть совмещенным с любым &lt;code&gt;A&lt;/code&gt; или &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adab5090ac6a1b7b5420faac7be86c41721ba27c" translate="yes" xml:space="preserve">
          <source>Calendar</source>
          <target state="translated">Calendar</target>
        </trans-unit>
        <trans-unit id="4ba307e0d2e402f172b3a88156165205934537c5" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;calloc&lt;/code&gt; from the C standard library.</source>
          <target state="translated">Вызовите &lt;code&gt;calloc&lt;/code&gt; из стандартной библиотеки C.</target>
        </trans-unit>
        <trans-unit id="56834381560a3dd99cb2329bb238ba01df160757" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;free&lt;/code&gt; from the C standard library. Only use this on memory obtained from &lt;a href=&quot;#Base.Libc.malloc&quot;&gt;&lt;code&gt;malloc&lt;/code&gt;&lt;/a&gt;, not on pointers retrieved from other C libraries. &lt;a href=&quot;../c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt; objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple &lt;code&gt;libc&lt;/code&gt; libraries exist on the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd40525129514b0914afc63feb30f354e65a4d9" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;free&lt;/code&gt; from the C standard library. Only use this on memory obtained from &lt;code&gt;malloc&lt;/code&gt;, not on pointers retrieved from other C libraries. &lt;code&gt;Ptr&lt;/code&gt; objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple &lt;code&gt;libc&lt;/code&gt; libraries exist on the system.</source>
          <target state="translated">Звоните &lt;code&gt;free&lt;/code&gt; из стандартной библиотеки C. Используйте это только для памяти, полученной из &lt;code&gt;malloc&lt;/code&gt; , а не для указателей, полученных из других библиотек C. Объекты &lt;code&gt;Ptr&lt;/code&gt; , полученные из библиотек C, должны освобождаться бесплатными функциями, определенными в этой библиотеке, чтобы избежать ошибок утверждения, если в системе существует несколько библиотек &lt;code&gt;libc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9203b7a42060148350d2e8b3d4cff8d77d5adeaf" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;malloc&lt;/code&gt; from the C standard library.</source>
          <target state="translated">Вызов &lt;code&gt;malloc&lt;/code&gt; из стандартной библиотеки C.</target>
        </trans-unit>
        <trans-unit id="d59c9f90d0e1176d4cad8b98ecd8773005b655fb" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;realloc&lt;/code&gt; from the C standard library.</source>
          <target state="translated">Вызов &lt;code&gt;realloc&lt;/code&gt; из стандартной библиотеки C.</target>
        </trans-unit>
        <trans-unit id="04826291b163107f55d0704047219ec8c7242923" translate="yes" xml:space="preserve">
          <source>Call C functions directly (no wrappers or special APIs needed)</source>
          <target state="translated">Вызов функций C напрямую (обертки или специальные API не нужны)</target>
        </trans-unit>
        <trans-unit id="176405e1dde8747bb226b06f36937d8d5df0ebaf" translate="yes" xml:space="preserve">
          <source>Call LLVM IR string in the first argument. Similar to an LLVM function &lt;code&gt;define&lt;/code&gt; block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).</source>
          <target state="translated">Вызовите строку LLVM IR в первом аргументе. Подобно блоку &lt;code&gt;define&lt;/code&gt; функции LLVM , аргументы доступны как последовательные безымянные переменные SSA (% 0,% 1 и т. Д.).</target>
        </trans-unit>
        <trans-unit id="801735440ba4554b8dcf3670b61d4a15d05b05d1" translate="yes" xml:space="preserve">
          <source>Call a function &lt;code&gt;f&lt;/code&gt; asynchronously on the given arguments on the specified process. Return a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;. Keyword arguments, if any, are passed through to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Вызов функции &lt;code&gt;f&lt;/code&gt; асинхронно для данных аргументов в указанном процессе. Верните &lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; . Аргументы ключевого слова, если таковые имеются, передаются в &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e66b49e037c9bfd84faa519573d27e88a8767628" translate="yes" xml:space="preserve">
          <source>Call a function in a C-exported shared library, specified by &lt;code&gt;library.function_name&lt;/code&gt;, where &lt;code&gt;library&lt;/code&gt; is a string constant or literal. The library may be omitted, in which case the &lt;code&gt;function_name&lt;/code&gt; is resolved in the current process. Alternatively, &lt;code&gt;@ccall&lt;/code&gt; may also be used to call a function pointer &lt;code&gt;$function_pointer&lt;/code&gt;, such as one returned by &lt;code&gt;dlsym&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a025fbe4a998cb1c2319eebb3e04b735a78fa3" translate="yes" xml:space="preserve">
          <source>Call a function in a C-exported shared library, specified by the tuple &lt;code&gt;(function_name, library)&lt;/code&gt;, where each component is either a string or symbol. Instead of specifying a library, one can also use a &lt;code&gt;function_name&lt;/code&gt; symbol or string, which is resolved in the current process. Alternatively, &lt;code&gt;ccall&lt;/code&gt; may also be used to call a function pointer &lt;code&gt;function_pointer&lt;/code&gt;, such as one returned by &lt;code&gt;dlsym&lt;/code&gt;.</source>
          <target state="translated">Вызов функции в совместно используемой библиотеке, экспортированной на C, заданной кортежем &lt;code&gt;(function_name, library)&lt;/code&gt; , где каждый компонент представляет собой строку или символ. Вместо указания библиотеки можно также использовать символ или строку &lt;code&gt;function_name&lt;/code&gt; , которые разрешаются в текущем процессе. В качестве альтернативы &lt;code&gt;ccall&lt;/code&gt; также может использоваться для вызова указателя &lt;code&gt;function_pointer&lt;/code&gt; , такого как тот, который возвращается &lt;code&gt;dlsym&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d59f24dd0afcb729960eb267538b17e7042fcc85" translate="yes" xml:space="preserve">
          <source>Call function &lt;code&gt;f&lt;/code&gt; on each element of iterable &lt;code&gt;c&lt;/code&gt;. For multiple iterable arguments, &lt;code&gt;f&lt;/code&gt; is called elementwise. &lt;code&gt;foreach&lt;/code&gt; should be used instead of &lt;code&gt;map&lt;/code&gt; when the results of &lt;code&gt;f&lt;/code&gt; are not needed, for example in &lt;code&gt;foreach(println, array)&lt;/code&gt;.</source>
          <target state="translated">Вызов функции &lt;code&gt;f&lt;/code&gt; для каждого элемента итерации &lt;code&gt;c&lt;/code&gt; . Для нескольких повторяемых аргументов &lt;code&gt;f&lt;/code&gt; называется поэлементно. &lt;code&gt;foreach&lt;/code&gt; результаты &lt;code&gt;f&lt;/code&gt; не нужны, например, в &lt;code&gt;foreach(println, array)&lt;/code&gt; вместо &lt;code&gt;map&lt;/code&gt; следует использовать foreach .</target>
        </trans-unit>
        <trans-unit id="ebb83c3d13bcfdfda803f0b35d77b6d7243cd9fe" translate="yes" xml:space="preserve">
          <source>Call the Win32 &lt;code&gt;GetLastError&lt;/code&gt; function [only available on Windows].</source>
          <target state="translated">Вызовите &lt;code&gt;GetLastError&lt;/code&gt; Win32 GetLastError [доступно только в Windows].</target>
        </trans-unit>
        <trans-unit id="ce4eab5c7f440edfe5b683c8baa8b023cc553366" translate="yes" xml:space="preserve">
          <source>Call the function &lt;code&gt;body&lt;/code&gt; with a modified task-local storage, in which &lt;code&gt;value&lt;/code&gt; is assigned to &lt;code&gt;key&lt;/code&gt;; the previous value of &lt;code&gt;key&lt;/code&gt;, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.</source>
          <target state="translated">Вызвать &lt;code&gt;body&lt;/code&gt; функции с измененным локальным хранилищем задачи, в котором &lt;code&gt;value&lt;/code&gt; присвоено &lt;code&gt;key&lt;/code&gt; ; впоследствии восстанавливается предыдущее значение &lt;code&gt;key&lt;/code&gt; или его отсутствие. Полезно для имитации динамической области видимости.</target>
        </trans-unit>
        <trans-unit id="eaa0c352f0575f82994206173cabc3866ad95796" translate="yes" xml:space="preserve">
          <source>Call the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string. &lt;code&gt;context&lt;/code&gt; can be either an &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; whose properties will be used, or a &lt;code&gt;Pair&lt;/code&gt; specifying a property and its value. &lt;code&gt;sizehint&lt;/code&gt; suggests the capacity of the buffer (in bytes).</source>
          <target state="translated">Вызов данной функции с потоком ввода-вывода и предоставленными дополнительными аргументами. Все, что записано в этот поток ввода-вывода, возвращается в виде строки. &lt;code&gt;context&lt;/code&gt; может быть либо &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; свойства которого будет использоваться, или &lt;code&gt;Pair&lt;/code&gt; указывается свойство и его значение. &lt;code&gt;sizehint&lt;/code&gt; предлагает емкость буфера (в байтах).</target>
        </trans-unit>
        <trans-unit id="2664dee6a3ad5a12623406c5af1cda40ecf12ba0" translate="yes" xml:space="preserve">
          <source>Callback settings. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_remote_callbacks&quot;&gt;&lt;code&gt;git_remote_callbacks&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Настройки обратного звонка. Соответствует структуре &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_remote_callbacks&quot;&gt; &lt;code&gt;git_remote_callbacks&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8256faf5b345c67f126415204dbd66a186005c2" translate="yes" xml:space="preserve">
          <source>Called by cluster managers implementing custom transports. It initializes a newly launched process as a worker. Command line argument &lt;code&gt;--worker[=&amp;lt;cookie&amp;gt;]&lt;/code&gt; has the effect of initializing a process as a worker using TCP/IP sockets for transport. &lt;code&gt;cookie&lt;/code&gt; is a &lt;a href=&quot;#Distributed.cluster_cookie-Tuple%7B%7D&quot;&gt;&lt;code&gt;cluster_cookie&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вызывается менеджерами кластера, реализующими настраиваемые транспорты. Он инициализирует только что запущенный процесс как рабочий. Аргумент командной строки &lt;code&gt;--worker[=&amp;lt;cookie&amp;gt;]&lt;/code&gt; имеет эффект инициализации процесса как рабочего с использованием сокетов TCP / IP для транспорта. &lt;code&gt;cookie&lt;/code&gt; - это файл &lt;a href=&quot;#Distributed.cluster_cookie-Tuple%7B%7D&quot;&gt; &lt;code&gt;cluster_cookie&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="caea39a5ffed5cf53b4f9992aa9aebdfdb841ef9" translate="yes" xml:space="preserve">
          <source>Called by cluster managers using custom transports. It should be called when the custom transport implementation receives the first message from a remote worker. The custom transport must manage a logical connection to the remote worker and provide two &lt;code&gt;IO&lt;/code&gt; objects, one for incoming messages and the other for messages addressed to the remote worker. If &lt;code&gt;incoming&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the remote peer initiated the connection. Whichever of the pair initiates the connection sends the cluster cookie and its Julia version number to perform the authentication handshake.</source>
          <target state="translated">Вызывается менеджерами кластера с использованием настраиваемых транспортов. Его следует вызывать, когда реализация настраиваемого транспорта получает первое сообщение от удаленного работника. Пользовательский транспорт должен управлять логическим подключением к удаленному исполнителю и предоставлять два объекта &lt;code&gt;IO&lt;/code&gt; : один для входящих сообщений, а другой - для сообщений, адресованных удаленному исполнителю. Если значение &lt;code&gt;incoming&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; , удаленный узел инициировал соединение. Независимо от того, какая из пары инициирует соединение, отправляет файл cookie кластера и его номер версии Julia для выполнения квитирования аутентификации.</target>
        </trans-unit>
        <trans-unit id="66dd1be7576a64af07b2ce99b1a2ed2a7c06b791" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#Core.Ref&quot;&gt;&lt;code&gt;Ref(array[, index])&lt;/code&gt;&lt;/a&gt; is generally preferable to this function as it guarantees validity.</source>
          <target state="translated">Вызов &lt;a href=&quot;#Core.Ref&quot;&gt; &lt;code&gt;Ref(array[, index])&lt;/code&gt; &lt;/a&gt; как правило, предпочтительнее этой функции, поскольку это гарантирует ее достоверность.</target>
        </trans-unit>
        <trans-unit id="0d16198678162c2927c2f17ed3e602251edd7089" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; inside a macro is a particularly dangerous warning sign; it means the macro will only work when called at the top level. If such a macro is written as a function instead, it will naturally have access to the run-time values it needs.</source>
          <target state="translated">Вызов &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; внутри макроса - особенно опасный предупреждающий знак; это означает, что макрос будет работать только при вызове на верхнем уровне. Если вместо этого такой макрос написан как функция, он, естественно, будет иметь доступ к нужным значениям времени выполнения.</target>
        </trans-unit>
        <trans-unit id="b72748e09098c6bd97f55e59c563c3a122bb6331" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; to cause a side-effect in another module. This will also cause a warning to be emitted when the incremental precompile flag is set.</source>
          <target state="translated">Вызов &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; ,&lt;/a&gt; чтобы вызвать побочный эффект в другом модуле. Это также вызовет выдачу предупреждения, если установлен флаг инкрементальной предварительной компиляции.</target>
        </trans-unit>
        <trans-unit id="41aa7e1fcfd92670fa5a846085d3341583baabcf" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace()&lt;/code&gt;&lt;/a&gt; returns a vector of &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; s. For ease of use, the alias &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackTrace&quot;&gt;&lt;code&gt;StackTraces.StackTrace&lt;/code&gt;&lt;/a&gt; can be used in place of &lt;code&gt;Vector{StackFrame}&lt;/code&gt;. (Examples with &lt;code&gt;[...]&lt;/code&gt; indicate that output may vary depending on how the code is run.)</source>
          <target state="translated">Вызов &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace()&lt;/code&gt; &lt;/a&gt; возвращает вектор &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt; s. Для простоты использования псевдоним &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackTrace&quot;&gt; &lt;code&gt;StackTraces.StackTrace&lt;/code&gt; &lt;/a&gt; можно использовать вместо &lt;code&gt;Vector{StackFrame}&lt;/code&gt; . (Примеры с &lt;code&gt;[...]&lt;/code&gt; указывают, что вывод может отличаться в зависимости от того, как выполняется код.)</target>
        </trans-unit>
        <trans-unit id="4a4f549c9307f9b4d84be21408b77dbb68a1f198" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;rand&lt;/code&gt; and other RNG-related functions should be avoided in doctests since they will not produce consistent outputs during different Julia sessions. If you would like to show some random number generation related functionality, one option is to explicitly construct and seed your own &lt;a href=&quot;../../stdlib/random/index#Random.MersenneTwister&quot;&gt;&lt;code&gt;MersenneTwister&lt;/code&gt;&lt;/a&gt; (or other pseudorandom number generator) and pass it to the functions you are doctesting.</source>
          <target state="translated">В тестах документов следует избегать вызова &lt;code&gt;rand&lt;/code&gt; и других функций, связанных с RNG, поскольку они не будут давать согласованные результаты во время разных сеансов Julia. Если вы хотите продемонстрировать некоторые функции, связанные с генерацией случайных чисел, один из вариантов - явно создать и заполнить свой собственный &lt;a href=&quot;../../stdlib/random/index#Random.MersenneTwister&quot;&gt; &lt;code&gt;MersenneTwister&lt;/code&gt; &lt;/a&gt; (или другой генератор псевдослучайных чисел) и передать его функциям, которые вы проверяете.</target>
        </trans-unit>
        <trans-unit id="2d7425b9bc6bdd37cfb5d8f6425582078c2424c2" translate="yes" xml:space="preserve">
          <source>Calling C and Fortran Code</source>
          <target state="translated">Вызов С и код Фортран</target>
        </trans-unit>
        <trans-unit id="0a72734e5b9d7e776161f32d3bf09af339418e1e" translate="yes" xml:space="preserve">
          <source>Calling Convention</source>
          <target state="translated">Вызывающая конвенция</target>
        </trans-unit>
        <trans-unit id="9abfa6ddb5caaadbeab0376e3006f230505bfdea" translate="yes" xml:space="preserve">
          <source>Calling Julia Functions</source>
          <target state="translated">Звонок Джулии Функции</target>
        </trans-unit>
        <trans-unit id="85116a89bb1c5c01cfc46fa63875b231c5d2c577" translate="yes" xml:space="preserve">
          <source>Calling a method of a class in Python (&lt;code&gt;a = MyClass(x), x.func(y)&lt;/code&gt;) corresponds to a function call in Julia, e.g. &lt;code&gt;a = MyStruct(x), func(x::MyStruct, y)&lt;/code&gt;. In general, multiple dispatch is more flexible and powerful than the Python class system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49d09ca1110825e69afa568f7e07eeec5300e61" translate="yes" xml:space="preserve">
          <source>Calling any function that is defined after the body of the generated function. This condition is relaxed for incrementally-loaded precompiled modules to allow calling any function in the module.</source>
          <target state="translated">Вызов любой функции,которая определена после тела генерируемой функции.Это условие ослабляется для инкрементно нагруженных прекомпилированных модулей,чтобы позволить вызов любой функции в модуле.</target>
        </trans-unit>
        <trans-unit id="41d74c50b2c67c3ddc7b0e22937873f076e4b22e" translate="yes" xml:space="preserve">
          <source>Calling this function is the &quot;safe&quot; way to write algorithms that exploit linear indexing.</source>
          <target state="translated">Вызов этой функции является &quot;безопасным&quot; способом записи алгоритмов,использующих линейное индексирование.</target>
        </trans-unit>
        <trans-unit id="0a19b7e26b2ba75ac27255f31f21e98a34d62953" translate="yes" xml:space="preserve">
          <source>Calls</source>
          <target state="translated">Calls</target>
        </trans-unit>
        <trans-unit id="19d45b5117925d478df6d24e3b83936bcd7c78e0" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;f(args...; kwargs...)&lt;/code&gt;, but guarantees that the most recent method of &lt;code&gt;f&lt;/code&gt; will be executed. This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function &lt;code&gt;f&lt;/code&gt;. (The drawback is that &lt;code&gt;invokelatest&lt;/code&gt; is somewhat slower than calling &lt;code&gt;f&lt;/code&gt; directly, and the type of the result cannot be inferred by the compiler.)</source>
          <target state="translated">Вызывает &lt;code&gt;f(args...; kwargs...)&lt;/code&gt; , но гарантирует, что будет выполнен самый последний метод &lt;code&gt;f&lt;/code&gt; . Это полезно в особых обстоятельствах, например, в длительных циклах событий или функциях обратного вызова, которые могут вызывать устаревшие версии функции &lt;code&gt;f&lt;/code&gt; . (Недостатком является то, что &lt;code&gt;invokelatest&lt;/code&gt; несколько медленнее, чем вызов &lt;code&gt;f&lt;/code&gt; напрямую, и компилятор не может определить тип результата.)</target>
        </trans-unit>
        <trans-unit id="4da9c9af9631e294961d5a16fdc681ca3d84f508" translate="yes" xml:space="preserve">
          <source>Camera</source>
          <target state="translated">Camera</target>
        </trans-unit>
        <trans-unit id="f01f585ee537bca9460fb6cd89d91523ae410c34" translate="yes" xml:space="preserve">
          <source>Can I use &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; inside a function?</source>
          <target state="translated">Могу ли я использовать &lt;code&gt;using&lt;/code&gt; или &lt;code&gt;import&lt;/code&gt; внутри функции?</target>
        </trans-unit>
        <trans-unit id="07d6cb97820e052be2b530d0dd83bba8edfc5e64" translate="yes" xml:space="preserve">
          <source>Cancer</source>
          <target state="translated">Cancer</target>
        </trans-unit>
        <trans-unit id="dbffdf1f157a14a19d2c2aeb64068a16056948d8" translate="yes" xml:space="preserve">
          <source>Candy</source>
          <target state="translated">Candy</target>
        </trans-unit>
        <trans-unit id="f20a12fff18e89250e7a4fc78447ee7170895a65" translate="yes" xml:space="preserve">
          <source>Cannot exactly convert &lt;code&gt;val&lt;/code&gt; to type &lt;code&gt;T&lt;/code&gt; in a method of function &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">Не могу точно преобразовать &lt;code&gt;val&lt;/code&gt; ввести &lt;code&gt;T&lt;/code&gt; в методе функции &lt;code&gt;name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91fe73e52f951e9f466713424d00ece47cdc7524" translate="yes" xml:space="preserve">
          <source>Canonicalize a path by expanding symbolic links and removing &quot;.&quot; and &quot;..&quot; entries. On case-insensitive case-preserving filesystems (typically Mac and Windows), the filesystem's stored case for the path is returned.</source>
          <target state="translated">Канонизируйте путь,расширяя символические связи и удаляя записи &quot;...&quot; и &quot;...&quot;.В файловых системах,не чувствительных к регистру (обычно Mac и Windows),возвращается регистр файловой системы для пути.</target>
        </trans-unit>
        <trans-unit id="90a16c05e849a5af3a6ddd19c2db0fa10e54dd2d" translate="yes" xml:space="preserve">
          <source>Capitalize the first character of each word in &lt;code&gt;s&lt;/code&gt;; if &lt;code&gt;strict&lt;/code&gt; is true, every other character is converted to lowercase, otherwise they are left unchanged. By default, all non-letters are considered as word separators; a predicate can be passed as the &lt;code&gt;wordsep&lt;/code&gt; keyword to determine which characters should be considered as word separators. See also &lt;a href=&quot;#Base.Unicode.uppercasefirst&quot;&gt;&lt;code&gt;uppercasefirst&lt;/code&gt;&lt;/a&gt; to capitalize only the first character in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Используйте заглавные буквы в первом символе каждого слова в &lt;code&gt;s&lt;/code&gt; ; если &lt;code&gt;strict&lt;/code&gt; истинно, все остальные символы преобразуются в нижний регистр, в противном случае они остаются без изменений. По умолчанию все символы, отличные от букв, считаются разделителями слов; в качестве &lt;code&gt;wordsep&lt;/code&gt; слова wordsep можно передать предикат, чтобы определить, какие символы следует рассматривать как разделители слов. Также смотрите &lt;a href=&quot;#Base.Unicode.uppercasefirst&quot;&gt; &lt;code&gt;uppercasefirst&lt;/code&gt; &lt;/a&gt; чтобы использовать только первый символ в &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9bf29452874274eefd7cb3833b9f64b68215e7a" translate="yes" xml:space="preserve">
          <source>Capricorn</source>
          <target state="translated">Capricorn</target>
        </trans-unit>
        <trans-unit id="7a60d3a75036d27b63be0e55a67bb26ec4e25de4" translate="yes" xml:space="preserve">
          <source>Captures can also be accessed by indexing the &lt;code&gt;RegexMatch&lt;/code&gt; object with the number or name of the capture group:</source>
          <target state="translated">Доступ к &lt;code&gt;RegexMatch&lt;/code&gt; также можно получить путем индексации объекта RegexMatch с номером или именем группы захвата:</target>
        </trans-unit>
        <trans-unit id="88b6c532d029fa2352cf701d32470679db245f1e" translate="yes" xml:space="preserve">
          <source>Captures can be referenced in a substitution string when using &lt;code&gt;replace&lt;/code&gt; by using &lt;code&gt;\n&lt;/code&gt; to refer to the nth capture group and prefixing the substitution string with &lt;code&gt;s&lt;/code&gt;. Capture group 0 refers to the entire match object. Named capture groups can be referenced in the substitution with &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">На записи можно ссылаться в строке подстановки при использовании &lt;code&gt;replace&lt;/code&gt; , используя &lt;code&gt;\n&lt;/code&gt; для ссылки на n-ю группу захвата и добавляя к строке подстановки префикс &lt;code&gt;s&lt;/code&gt; . Группа захвата 0 относится ко всему объекту соответствия. На именованные группы захвата можно ссылаться в подстановке с помощью &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="f2a9f7332f7a09946296f88c18131b92dbb1279f" translate="yes" xml:space="preserve">
          <source>Card Index</source>
          <target state="translated">Карточный указатель</target>
        </trans-unit>
        <trans-unit id="0cca55f8e3afeb49c40b1e95517a9c1135c7a560" translate="yes" xml:space="preserve">
          <source>Carousel Horse</source>
          <target state="translated">Карусель Лошадь</target>
        </trans-unit>
        <trans-unit id="255e5aac2127bb14392d1d0c859050548a802598" translate="yes" xml:space="preserve">
          <source>Carp Streamer</source>
          <target state="translated">Карп-Стример</target>
        </trans-unit>
        <trans-unit id="722d5852eba2640d07e63d26f677b7d3dce6d40c" translate="yes" xml:space="preserve">
          <source>Cartesian indexing</source>
          <target state="translated">декартовое индексирование</target>
        </trans-unit>
        <trans-unit id="2a2b1fd0558d005d15bb6a090f84de302c0d4517" translate="yes" xml:space="preserve">
          <source>Cartesian indices</source>
          <target state="translated">картезианские индексы</target>
        </trans-unit>
        <trans-unit id="2111431e539d8078cb148dae299ad435bcf94b27" translate="yes" xml:space="preserve">
          <source>Case &lt;code&gt;n &amp;gt; 1&lt;/code&gt;</source>
          <target state="translated">Случай &lt;code&gt;n &amp;gt; 1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9f1c61da11e76b12eda645d65ffd7fe29682099" translate="yes" xml:space="preserve">
          <source>Case &lt;code&gt;n == 0&lt;/code&gt;</source>
          <target state="translated">Случай &lt;code&gt;n == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29a059f07d864d6895c8f26aada84e3e2ae48daa" translate="yes" xml:space="preserve">
          <source>Case &lt;code&gt;n == 1&lt;/code&gt;</source>
          <target state="translated">Случай &lt;code&gt;n == 1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5a951eefa4da8021cf83c2a312ac9db2161e292" translate="yes" xml:space="preserve">
          <source>Case Study: Rational</source>
          <target state="translated">Практический пример:Rational</target>
        </trans-unit>
        <trans-unit id="226c8be8625b7e7ff2acf9e7afa1f2c1a67ee20d" translate="yes" xml:space="preserve">
          <source>Case Study: Rational Promotions</source>
          <target state="translated">Практический пример:Рациональные стимулы</target>
        </trans-unit>
        <trans-unit id="cebe54c7626cb1cefaca5f7f5ea6c96b4a7a2882" translate="yes" xml:space="preserve">
          <source>Cat</source>
          <target state="translated">Cat</target>
        </trans-unit>
        <trans-unit id="e321d6511fec0b2a4b2f0a4b6c9161ea67d3b862" translate="yes" xml:space="preserve">
          <source>Cat Face</source>
          <target state="translated">кошачья морда</target>
        </trans-unit>
        <trans-unit id="0304d8e66e7196a0cbe56d1a1e3f50a5d44586dc" translate="yes" xml:space="preserve">
          <source>Cat Face With Tears Of Joy</source>
          <target state="translated">Кошачья морда со слезами радости</target>
        </trans-unit>
        <trans-unit id="8694b8421f68b951f951f9af799f80af5160aedd" translate="yes" xml:space="preserve">
          <source>Cat Face With Wry Smile</source>
          <target state="translated">Лицо кошки с кривой улыбкой</target>
        </trans-unit>
        <trans-unit id="34dfec8f22dde17704da94df2192063529be5d2d" translate="yes" xml:space="preserve">
          <source>Catalan's constant.</source>
          <target state="translated">Каталонская константа.</target>
        </trans-unit>
        <trans-unit id="b8c6b9519d52cad00665d92e155963171c5e725d" translate="yes" xml:space="preserve">
          <source>Catch exceptions during event evaluation</source>
          <target state="translated">Поймать исключение во время оценки события</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="1a80861772b0484c4f5af5303cebead59df45b86" translate="yes" xml:space="preserve">
          <source>Caution Sign</source>
          <target state="translated">предупреждающий знак</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="e4c530b1c24d3c230e2d840c8f5a4bd61e8f0170" translate="yes" xml:space="preserve">
          <source>Cchar</source>
          <target state="translated">Cchar</target>
        </trans-unit>
        <trans-unit id="98ea122cbe5434a5105ed227191d1c86da875820" translate="yes" xml:space="preserve">
          <source>Cdouble</source>
          <target state="translated">Cdouble</target>
        </trans-unit>
        <trans-unit id="ef6d3da178771ba00eefbc1133066d5d42ce7c22" translate="yes" xml:space="preserve">
          <source>Certain constructs in the language introduce &lt;em&gt;scope blocks&lt;/em&gt;, which are regions of code that are eligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks. There are two main types of scopes in Julia, &lt;em&gt;global scope&lt;/em&gt; and &lt;em&gt;local scope&lt;/em&gt;. The latter can be nested. The constructs introducing scope blocks are:</source>
          <target state="translated">Некоторые конструкции в языке вводят &lt;em&gt;блоки области видимости&lt;/em&gt; , которые представляют собой области кода, которые могут быть областью действия некоторого набора переменных. Область видимости переменной не может быть произвольным набором исходных строк; вместо этого он всегда будет соответствовать одному из этих блоков. В Julia есть два основных типа областей: &lt;em&gt;глобальная&lt;/em&gt; и &lt;em&gt;локальная&lt;/em&gt; . Последние могут быть вложенными. Конструкции, представляющие блоки области видимости:</target>
        </trans-unit>
        <trans-unit id="79d6412ea668dd527aa9bd5226b88db41d88b00b" translate="yes" xml:space="preserve">
          <source>Certain constructs in the language introduce &lt;em&gt;scope blocks&lt;/em&gt;, which are regions of code that are eligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks. There are two main types of scopes in Julia, &lt;em&gt;global scope&lt;/em&gt; and &lt;em&gt;local scope&lt;/em&gt;. The latter can be nested. There is also a distinction in Julia between constructs which introduce a &quot;hard scope&quot; and those which only introduce a &quot;soft scope&quot;, which affects whether shadowing a global variable by the same name is allowed or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a436f524b4f30d26cce25c6fb61307697fefc2aa" translate="yes" xml:space="preserve">
          <source>Certain operations make mathematical sense but result in errors:</source>
          <target state="translated">Некоторые операции имеют математический смысл,но приводят к ошибкам:</target>
        </trans-unit>
        <trans-unit id="b83c053cc3abf67280351793fa40fe0857a1ef12" translate="yes" xml:space="preserve">
          <source>Cfloat</source>
          <target state="translated">Cfloat</target>
        </trans-unit>
        <trans-unit id="1bf8d41c6633f510ee163ba63fad81c499b65c06" translate="yes" xml:space="preserve">
          <source>Chaining comparisons</source>
          <target state="translated">Сравнение цепочек</target>
        </trans-unit>
        <trans-unit id="e4b02f736800960ffeb31d1ce4d94bc68e9b3522" translate="yes" xml:space="preserve">
          <source>Chaining comparisons is often quite convenient in numerical code. Chained comparisons use the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator for scalar comparisons, and the &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt; operator for elementwise comparisons, which allows them to work on arrays. For example, &lt;code&gt;0 .&amp;lt; A .&amp;lt; 1&lt;/code&gt; gives a boolean array whose entries are true where the corresponding elements of &lt;code&gt;A&lt;/code&gt; are between 0 and 1.</source>
          <target state="translated">Цепочки сравнений часто довольно удобны в числовом коде. Связанные сравнения используют оператор &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; для скалярных сравнений и оператор &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt; для поэлементных сравнений, что позволяет им работать с массивами. Например, &lt;code&gt;0 .&amp;lt; A .&amp;lt; 1&lt;/code&gt; дает логический массив, записи которого истинны, где соответствующие элементы &lt;code&gt;A&lt;/code&gt; находятся между 0 и 1.</target>
        </trans-unit>
        <trans-unit id="e392d2ea4fb56f31affc92a17a7f093445989a1e" translate="yes" xml:space="preserve">
          <source>Change the &lt;code&gt;T&lt;/code&gt; arithmetic precision (in bits) for the duration of &lt;code&gt;f&lt;/code&gt;. It is logically equivalent to:</source>
          <target state="translated">Измените арифметическую точность &lt;code&gt;T&lt;/code&gt; (в битах) на время &lt;code&gt;f&lt;/code&gt; . Логически это эквивалентно:</target>
        </trans-unit>
        <trans-unit id="aa7aae11d28e8bd4a1ac0973becf0187af2f72ff" translate="yes" xml:space="preserve">
          <source>Change the next word to lowercase</source>
          <target state="translated">Измените следующее слово на нижний регистр</target>
        </trans-unit>
        <trans-unit id="a9d00290564b5f132466d2d65a5760e410b77379" translate="yes" xml:space="preserve">
          <source>Change the next word to titlecase</source>
          <target state="translated">Измените следующее слово на титульный кейс</target>
        </trans-unit>
        <trans-unit id="a1848e10eea50d9a7d51e412b6c651b68fe304e4" translate="yes" xml:space="preserve">
          <source>Change the next word to uppercase</source>
          <target state="translated">Изменить следующее слово на заглавный</target>
        </trans-unit>
        <trans-unit id="52116f45eb7f0166da051d04ad38b63f5e208b1f" translate="yes" xml:space="preserve">
          <source>Change the owner and/or group of &lt;code&gt;path&lt;/code&gt; to &lt;code&gt;owner&lt;/code&gt; and/or &lt;code&gt;group&lt;/code&gt;. If the value entered for &lt;code&gt;owner&lt;/code&gt; or &lt;code&gt;group&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; the corresponding ID will not change. Only integer &lt;code&gt;owner&lt;/code&gt;s and &lt;code&gt;group&lt;/code&gt;s are currently supported. Return &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">Измените владельца и / или группу &lt;code&gt;path&lt;/code&gt; к &lt;code&gt;owner&lt;/code&gt; и / или &lt;code&gt;group&lt;/code&gt; . Если значение, введенное для &lt;code&gt;owner&lt;/code&gt; или &lt;code&gt;group&lt;/code&gt; равно &lt;code&gt;-1&lt;/code&gt; , соответствующий идентификатор не изменится. В настоящее время поддерживаются только целочисленные &lt;code&gt;owner&lt;/code&gt; и &lt;code&gt;group&lt;/code&gt; . Обратный &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4cadce06d0cab691571969b2bd50452957441f5" translate="yes" xml:space="preserve">
          <source>Change the permissions mode of &lt;code&gt;path&lt;/code&gt; to &lt;code&gt;mode&lt;/code&gt;. Only integer &lt;code&gt;mode&lt;/code&gt;s (e.g. &lt;code&gt;0o777&lt;/code&gt;) are currently supported. If &lt;code&gt;recursive=true&lt;/code&gt; and the path is a directory all permissions in that directory will be recursively changed. Return &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">Измените режим разрешений &lt;code&gt;path&lt;/code&gt; к &lt;code&gt;mode&lt;/code&gt; . В настоящее время поддерживается только целочисленный &lt;code&gt;mode&lt;/code&gt; s (например, &lt;code&gt;0o777&lt;/code&gt; ). Если &lt;code&gt;recursive=true&lt;/code&gt; и путь - это каталог, все разрешения в этом каталоге будут рекурсивно изменены. Обратный &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32a989fb98b8f1dbfc4dbfdbda4cfa7a8f5a564e" translate="yes" xml:space="preserve">
          <source>Change the rounding mode of floating point type &lt;code&gt;T&lt;/code&gt; for the duration of &lt;code&gt;f&lt;/code&gt;. It is logically equivalent to:</source>
          <target state="translated">Измените режим округления типа &lt;code&gt;T&lt;/code&gt; с плавающей запятой на время &lt;code&gt;f&lt;/code&gt; . Логически это эквивалентно:</target>
        </trans-unit>
        <trans-unit id="6826b0c27162177562d5dac46bf63880b08e8521" translate="yes" xml:space="preserve">
          <source>Change the type-interpretation of a block of memory. For arrays, this constructs a view of the array with the same binary data as the given array, but with the specified element type. For example, &lt;code&gt;reinterpret(Float32, UInt32(7))&lt;/code&gt; interprets the 4 bytes corresponding to &lt;code&gt;UInt32(7)&lt;/code&gt; as a &lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Измените интерпретацию типа блока памяти. Для массивов это создает представление массива с теми же двоичными данными, что и данный массив, но с указанным типом элемента. Например, &lt;code&gt;reinterpret(Float32, UInt32(7))&lt;/code&gt; интерпретирует 4 байта, соответствующие &lt;code&gt;UInt32(7)&lt;/code&gt; как &lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4eec72c597c649417c08cf8310c3fd12582209e" translate="yes" xml:space="preserve">
          <source>Change to the first history entry (of the current session if it is before the current position in history)</source>
          <target state="translated">Переход к первой записи в истории (текущей сессии,если она предшествует текущей позиции в истории)</target>
        </trans-unit>
        <trans-unit id="2d9790ce2e89644c1d5ef1d4178a0e20ffa229c9" translate="yes" xml:space="preserve">
          <source>Change to the last history entry</source>
          <target state="translated">Изменение на последнюю запись истории</target>
        </trans-unit>
        <trans-unit id="f00c73a7c5134c054bca76810185e125c387bc0a" translate="yes" xml:space="preserve">
          <source>Change to the next history entry</source>
          <target state="translated">Переход на следующую запись истории</target>
        </trans-unit>
        <trans-unit id="cfe48d07ba26c0afb2979f42a242b38ee82c88da" translate="yes" xml:space="preserve">
          <source>Change to the previous history entry</source>
          <target state="translated">Изменение на предыдущую запись истории</target>
        </trans-unit>
        <trans-unit id="879f0b1bef59eeebf78cfd3a22f6f8077810cecf" translate="yes" xml:space="preserve">
          <source>Channel</source>
          <target state="translated">Channel</target>
        </trans-unit>
        <trans-unit id="18e03e2a37ba37df713f9665ef752fb8b40fc1e8" translate="yes" xml:space="preserve">
          <source>Channels</source>
          <target state="translated">Channels</target>
        </trans-unit>
        <trans-unit id="5d2585d6b1ebe562ed90e098229697dd1edbced3" translate="yes" xml:space="preserve">
          <source>Channels and RemoteChannels</source>
          <target state="translated">Каналы и дистанционные каналы</target>
        </trans-unit>
        <trans-unit id="5de527ad4b50c6e5971cd0c9d1c61d30dff8242c" translate="yes" xml:space="preserve">
          <source>Channels are created via the &lt;code&gt;Channel{T}(sz)&lt;/code&gt; constructor. The channel will only hold objects of type &lt;code&gt;T&lt;/code&gt;. If the type is not specified, the channel can hold objects of any type. &lt;code&gt;sz&lt;/code&gt; refers to the maximum number of elements that can be held in the channel at any time. For example, &lt;code&gt;Channel(32)&lt;/code&gt; creates a channel that can hold a maximum of 32 objects of any type. A &lt;code&gt;Channel{MyType}(64)&lt;/code&gt; can hold up to 64 objects of &lt;code&gt;MyType&lt;/code&gt; at any time.</source>
          <target state="translated">Каналы создаются с помощью конструктора &lt;code&gt;Channel{T}(sz)&lt;/code&gt; . Канал будет содержать только объекты типа &lt;code&gt;T&lt;/code&gt; . Если тип не указан, канал может содержать объекты любого типа. &lt;code&gt;sz&lt;/code&gt; относится к максимальному количеству элементов, которые могут храниться в канале в любое время. Например, &lt;code&gt;Channel(32)&lt;/code&gt; создает канал, который может содержать максимум 32 объекта любого типа. &lt;code&gt;Channel{MyType}(64)&lt;/code&gt; может содержать до 64 объектов &lt;code&gt;MyType&lt;/code&gt; в любое время.</target>
        </trans-unit>
        <trans-unit id="f0af2b3f98cdd8293e5cd590c14f3ad654402a21" translate="yes" xml:space="preserve">
          <source>Character Tie</source>
          <target state="translated">Галстук для персонажей</target>
        </trans-unit>
        <trans-unit id="ed74ee0fd869597bc8b7e61e821510ccb8a627ec" translate="yes" xml:space="preserve">
          <source>Character literals use the same behavior.</source>
          <target state="translated">В буквах персонажей используется одно и то же поведение.</target>
        </trans-unit>
        <trans-unit id="af451d4e9c685856e4c14256f0f0685adcf83857" translate="yes" xml:space="preserve">
          <source>Character(s)</source>
          <target state="translated">Character(s)</target>
        </trans-unit>
        <trans-unit id="69803692f05446db28128e4d652fcda3604ec718" translate="yes" xml:space="preserve">
          <source>Characteristics:</source>
          <target state="translated">Characteristics:</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="d9a77eec8cc54d9b9059ecff9f7f8b0c3d4a4b0c" translate="yes" xml:space="preserve">
          <source>Characters not listed above are normally treated as delimiters between date and time slots. For example a &lt;code&gt;dt&lt;/code&gt; string of &quot;1996-01-15T00:00:00.0&quot; would have a &lt;code&gt;format&lt;/code&gt; string like &quot;y-m-dTH:M:S.s&quot;. If you need to use a code character as a delimiter you can escape it using backslash. The date &quot;1995y01m&quot; would have the format &quot;y\ym\m&quot;.</source>
          <target state="translated">Символы, не перечисленные выше, обычно рассматриваются как разделители между датой и временными интервалами. Например, строка &lt;code&gt;dt&lt;/code&gt; &amp;laquo;1996-01-15T00: 00: 00.0&amp;raquo; будет иметь &lt;code&gt;format&lt;/code&gt; строку типа &amp;laquo;ym-dTH: M: Ss&amp;raquo;. Если вам нужно использовать кодовый символ в качестве разделителя, вы можете избежать его, используя обратную косую черту. Дата &quot;1995y01m&quot; будет иметь формат &quot;y \ ym \ m&quot;.</target>
        </trans-unit>
        <trans-unit id="ebef4e9d21d309d10e724345b9594679b3cd6e69" translate="yes" xml:space="preserve">
          <source>Chart With Downwards Trend</source>
          <target state="translated">Диаграмма с нисходящим трендом</target>
        </trans-unit>
        <trans-unit id="fda4f4461a399f03823d93f75ef10112a332c903" translate="yes" xml:space="preserve">
          <source>Chart With Upwards Trend</source>
          <target state="translated">Диаграмма с восходящим трендом</target>
        </trans-unit>
        <trans-unit id="a4a446b006052a5af669c7f6d998cf1743a7f6f9" translate="yes" xml:space="preserve">
          <source>Chart With Upwards Trend And Yen Sign</source>
          <target state="translated">Диаграмма с восходящим трендом и подписью иены</target>
        </trans-unit>
        <trans-unit id="73e89165960f554ff917c3b3ac9d3b096b8d5eaf" translate="yes" xml:space="preserve">
          <source>Check Mark</source>
          <target state="translated">Проверить отметку</target>
        </trans-unit>
        <trans-unit id="6af7b65d95d1fd3d3c46eeef377ffa00fb6e86a4" translate="yes" xml:space="preserve">
          <source>Check if &lt;code&gt;ex&lt;/code&gt; is an expression with head &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cccac008dc853e30120df3e9a70c3898d9b2bee" translate="yes" xml:space="preserve">
          <source>Check if commit &lt;code&gt;id&lt;/code&gt; (which is a &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; in string form) is in the repository.</source>
          <target state="translated">Проверьте, есть ли в репозитории &lt;code&gt;id&lt;/code&gt; фиксации (который представляет собой &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; в строковой форме).</target>
        </trans-unit>
        <trans-unit id="36465e7df054d1a8db11c41ceb01463ffd339488" translate="yes" xml:space="preserve">
          <source>Check if the current branch is an &quot;orphan&quot; branch, i.e. has no commits. The first commit to this branch will have no parents.</source>
          <target state="translated">Проверьте,является ли текущая ветка &quot;сиротской&quot;,т.е.не имеет никаких коммитов.Первый коммит в этом ответвлении не будет иметь родителей.</target>
        </trans-unit>
        <trans-unit id="b66e0b7684d9561bc0ff2976ce4bdbc130c0a5c9" translate="yes" xml:space="preserve">
          <source>Check if there have been any changes to tracked files in the working tree (if &lt;code&gt;cached=false&lt;/code&gt;) or the index (if &lt;code&gt;cached=true&lt;/code&gt;). &lt;code&gt;pathspecs&lt;/code&gt; are the specifications for options for the diff.</source>
          <target state="translated">Проверьте, не произошли ли какие-либо изменения в отслеживаемых файлах в рабочем дереве (если &lt;code&gt;cached=false&lt;/code&gt; ) или в индексе (если &lt;code&gt;cached=true&lt;/code&gt; ). &lt;code&gt;pathspecs&lt;/code&gt; - это спецификации опций для diff.</target>
        </trans-unit>
        <trans-unit id="10941e2df89576fa668bf1f89fbe0ad9fb195edb" translate="yes" xml:space="preserve">
          <source>Check that a matrix is square, then return its common dimension. For multiple arguments, return a vector.</source>
          <target state="translated">Убедитесь,что матрица квадратная,затем верните ее общую размерность.Для множественных аргументов верните вектор.</target>
        </trans-unit>
        <trans-unit id="6861a1cca611ecd76d506c1580f9dd38e9dfec32" translate="yes" xml:space="preserve">
          <source>Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.</source>
          <target state="translated">Проверьте две формы массива на совместимость,позволяя использовать размеры одной кнопки в трейлинге,и верните ту форму,которая имеет больше размеров.</target>
        </trans-unit>
        <trans-unit id="5847f57e4c8ac4313a08831cbbd9321dc7c8aa94" translate="yes" xml:space="preserve">
          <source>Check whether the &lt;code&gt;lock&lt;/code&gt; is held by any task/thread. This should not be used for synchronization (see instead &lt;a href=&quot;#Base.trylock&quot;&gt;&lt;code&gt;trylock&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Проверьте, удерживается ли &lt;code&gt;lock&lt;/code&gt; какой-либо задачей / потоком. Это не должно использоваться для синхронизации (см. Вместо этого &lt;a href=&quot;#Base.trylock&quot;&gt; &lt;code&gt;trylock&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="387def941a675fd43bb90cd2f103bc1835695e36" translate="yes" xml:space="preserve">
          <source>Checked.add_with_overflow()</source>
          <target state="translated">Checked.add_with_overflow()</target>
        </trans-unit>
        <trans-unit id="5861f86d2198b43b150ea6be20eecd4f4ca194fb" translate="yes" xml:space="preserve">
          <source>Checked.checked_abs()</source>
          <target state="translated">Checked.checked_abs()</target>
        </trans-unit>
        <trans-unit id="0e340663d314653dc7f7258455c8c64ec865a402" translate="yes" xml:space="preserve">
          <source>Checked.checked_add()</source>
          <target state="translated">Checked.checked_add()</target>
        </trans-unit>
        <trans-unit id="793b46bf345ea840a66fc3ce7be504df87f6aad8" translate="yes" xml:space="preserve">
          <source>Checked.checked_cld()</source>
          <target state="translated">Checked.checked_cld()</target>
        </trans-unit>
        <trans-unit id="cbb75d95e9a638cb0354f430f1c41528c16d5f1e" translate="yes" xml:space="preserve">
          <source>Checked.checked_div()</source>
          <target state="translated">Checked.checked_div()</target>
        </trans-unit>
        <trans-unit id="10f25d8f5722c731db35c0585785eb14e0947047" translate="yes" xml:space="preserve">
          <source>Checked.checked_fld()</source>
          <target state="translated">Checked.checked_fld()</target>
        </trans-unit>
        <trans-unit id="844d8f377decea211f1aa04e5b41ffd6aa8ec8aa" translate="yes" xml:space="preserve">
          <source>Checked.checked_mod()</source>
          <target state="translated">Checked.checked_mod()</target>
        </trans-unit>
        <trans-unit id="6e287962b9c64e9790cebd017023df56a743a004" translate="yes" xml:space="preserve">
          <source>Checked.checked_mul()</source>
          <target state="translated">Checked.checked_mul()</target>
        </trans-unit>
        <trans-unit id="8cddbe8ee88213cf9e9d56a609fa85a89e086da7" translate="yes" xml:space="preserve">
          <source>Checked.checked_neg()</source>
          <target state="translated">Checked.checked_neg()</target>
        </trans-unit>
        <trans-unit id="e44667638c3a1dc209bda165095e1d1cd133cc75" translate="yes" xml:space="preserve">
          <source>Checked.checked_rem()</source>
          <target state="translated">Checked.checked_rem()</target>
        </trans-unit>
        <trans-unit id="0088d172f06fff6ea323397de23669a32c31474b" translate="yes" xml:space="preserve">
          <source>Checked.checked_sub()</source>
          <target state="translated">Checked.checked_sub()</target>
        </trans-unit>
        <trans-unit id="ab7e607ffaab3ede22444bf0bafb0736dd5575b5" translate="yes" xml:space="preserve">
          <source>Checked.mul_with_overflow()</source>
          <target state="translated">Checked.mul_with_overflow()</target>
        </trans-unit>
        <trans-unit id="44a69fd61235a11b4b6edaa45c7d2594c6702f55" translate="yes" xml:space="preserve">
          <source>Checked.sub_with_overflow()</source>
          <target state="translated">Checked.sub_with_overflow()</target>
        </trans-unit>
        <trans-unit id="f66ee858da2bed315f19a0831545acdc098092b9" translate="yes" xml:space="preserve">
          <source>Checking for equality with a singleton</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099aaa95277770b044f9e7efabb37f097dce362a" translate="yes" xml:space="preserve">
          <source>Checkout a new git branch in the &lt;code&gt;repo&lt;/code&gt; repository. &lt;code&gt;commit&lt;/code&gt; is the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt;, in string form, which will be the start of the new branch. If &lt;code&gt;commit&lt;/code&gt; is an empty string, the current HEAD will be used.</source>
          <target state="translated">Заказ нового GIT филиал в &lt;code&gt;repo&lt;/code&gt; хранилище. &lt;code&gt;commit&lt;/code&gt; - это &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; в строковой форме, который будет началом новой ветки. Если &lt;code&gt;commit&lt;/code&gt; - пустая строка, будет использоваться текущий HEAD.</target>
        </trans-unit>
        <trans-unit id="a01db35293e447e7dfa93e429ed3057a3d6edb4e" translate="yes" xml:space="preserve">
          <source>Checks if there are any differences between the tree specified by &lt;code&gt;treeish&lt;/code&gt; and the tracked files in the working tree (if &lt;code&gt;cached=false&lt;/code&gt;) or the index (if &lt;code&gt;cached=true&lt;/code&gt;). &lt;code&gt;pathspecs&lt;/code&gt; are the specifications for options for the diff.</source>
          <target state="translated">Проверяет, есть ли какие-либо различия между деревом, указанным &lt;code&gt;treeish&lt;/code&gt; , и отслеживаемыми файлами в рабочем дереве (если &lt;code&gt;cached=false&lt;/code&gt; ) или индексом (если &lt;code&gt;cached=true&lt;/code&gt; ). &lt;code&gt;pathspecs&lt;/code&gt; - это спецификации опций для diff.</target>
        </trans-unit>
        <trans-unit id="80497c05495db1c1e51a0b937bd9ffa77fb142ff" translate="yes" xml:space="preserve">
          <source>Cheering Megaphone</source>
          <target state="translated">Подбадривающий Мегафон</target>
        </trans-unit>
        <trans-unit id="e81bedf047792fbe90c699c0d92561bd6df81796" translate="yes" xml:space="preserve">
          <source>Chequered Flag</source>
          <target state="translated">клетчатый флаг</target>
        </trans-unit>
        <trans-unit id="78bc6d7859d13eaa4171edc4973a040f60c5efa2" translate="yes" xml:space="preserve">
          <source>Cherries</source>
          <target state="translated">Cherries</target>
        </trans-unit>
        <trans-unit id="d980b2a4bed67957e89a2bfcbf9122253661d3b9" translate="yes" xml:space="preserve">
          <source>Cherry Blossom</source>
          <target state="translated">цветок вишни</target>
        </trans-unit>
        <trans-unit id="c712b8835755410091fbe89cfba2f9989bcdddf1" translate="yes" xml:space="preserve">
          <source>Chestnut</source>
          <target state="translated">Chestnut</target>
        </trans-unit>
        <trans-unit id="baaa18844b8db958c57edddf824f4a8b5cd9e298" translate="yes" xml:space="preserve">
          <source>Chicken</source>
          <target state="translated">Chicken</target>
        </trans-unit>
        <trans-unit id="6684f920ddf587816828d0949794d536f2044d85" translate="yes" xml:space="preserve">
          <source>Children Crossing</source>
          <target state="translated">Детский крест</target>
        </trans-unit>
        <trans-unit id="be60ee4f4851b8d244bba0827efe90ca53080f02" translate="yes" xml:space="preserve">
          <source>Chocolate Bar</source>
          <target state="translated">Шоколадная плитка</target>
        </trans-unit>
        <trans-unit id="36f117bd7dd482a1010ab9584c224f54936b91cc" translate="yes" xml:space="preserve">
          <source>Cholesky (see &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt; (см. Холецкий )</target>
        </trans-unit>
        <trans-unit id="e3c96b15f464a32f9dbfcd9be5dcfbc00bda9510" translate="yes" xml:space="preserve">
          <source>Cholesky factorization</source>
          <target state="translated">факторизация Холесского</target>
        </trans-unit>
        <trans-unit id="da141a0edd85453be825d6aa02b625b2d8b12905" translate="yes" xml:space="preserve">
          <source>Christmas Tree</source>
          <target state="translated">рождественская ёлка</target>
        </trans-unit>
        <trans-unit id="e72e88ea6123b50e6208c2e997da2b67631286d6" translate="yes" xml:space="preserve">
          <source>Church</source>
          <target state="translated">Church</target>
        </trans-unit>
        <trans-unit id="f4ea571bfe0617f587935723651430356fc70f4c" translate="yes" xml:space="preserve">
          <source>Cinema</source>
          <target state="translated">Cinema</target>
        </trans-unit>
        <trans-unit id="20638d5f9a181ef513cf00b55dcce4c98adb55f7" translate="yes" xml:space="preserve">
          <source>Cint</source>
          <target state="translated">Cint</target>
        </trans-unit>
        <trans-unit id="810c53332cece6a0ba48a6c0ba3b4f10aa580f90" translate="yes" xml:space="preserve">
          <source>Cintmax_t</source>
          <target state="translated">Cintmax_t</target>
        </trans-unit>
        <trans-unit id="f012b4aef95600337cc3ea8a98c28a295ab93f2f" translate="yes" xml:space="preserve">
          <source>Circle With All But Upper Left Quadrant Black</source>
          <target state="translated">Круг со всеми,кроме верхнего левого квадранта черного.</target>
        </trans-unit>
        <trans-unit id="e64a2f1f5550310ac4fcf3d82a1eba3eb03373e3" translate="yes" xml:space="preserve">
          <source>Circle With Left Half Black</source>
          <target state="translated">Круг с левой половиной черного</target>
        </trans-unit>
        <trans-unit id="4242c36ce736c0ae2d9e13bbac4c03ddccb00e63" translate="yes" xml:space="preserve">
          <source>Circle With Lower Half Black</source>
          <target state="translated">Круг с нижней половиной черного</target>
        </trans-unit>
        <trans-unit id="9946dda080b1d6f72432e4888afcc095dde79ea8" translate="yes" xml:space="preserve">
          <source>Circle With Right Half Black</source>
          <target state="translated">Круг с правой половиной черного</target>
        </trans-unit>
        <trans-unit id="d869eafe06cb16bdb3bb0bc2e1be15db03901859" translate="yes" xml:space="preserve">
          <source>Circle With Upper Half Black</source>
          <target state="translated">Круг с верхней половиной черный</target>
        </trans-unit>
        <trans-unit id="a8f7c61db4ce9bd030f686d3b28ef55edb06c05f" translate="yes" xml:space="preserve">
          <source>Circle With Upper Right Quadrant Black</source>
          <target state="translated">Круг с верхним правым квадрантом черный</target>
        </trans-unit>
        <trans-unit id="7ac2156e5b2912f2254d2f3ae90f1a8c149be7ab" translate="yes" xml:space="preserve">
          <source>Circle With Vertical Fill</source>
          <target state="translated">Круг с вертикальным заполнением</target>
        </trans-unit>
        <trans-unit id="bdade6bd883a792ea7c7650d2326b104f190c6db" translate="yes" xml:space="preserve">
          <source>Circled Anticlockwise-Rotated Division Sign</source>
          <target state="translated">Вращающийся против часовой стрелки знак деления</target>
        </trans-unit>
        <trans-unit id="288b0220ab4dfdbd33067b22c1e4248e5492c4f4" translate="yes" xml:space="preserve">
          <source>Circled Asterisk Operator</source>
          <target state="translated">Звездочка оператора</target>
        </trans-unit>
        <trans-unit id="c23f14422e51f91da407f474f9afc3cc0d6b1a61" translate="yes" xml:space="preserve">
          <source>Circled Bullet</source>
          <target state="translated">замкнутая пуля</target>
        </trans-unit>
        <trans-unit id="317b273eb94a369a8c28e6bf5cd7c75c54af9e35" translate="yes" xml:space="preserve">
          <source>Circled Dash</source>
          <target state="translated">Закрученный тире</target>
        </trans-unit>
        <trans-unit id="f5d528c73ab76ab5f33f09420750954ff64b51f9" translate="yes" xml:space="preserve">
          <source>Circled Division Sign</source>
          <target state="translated">Знак округлого дивизиона</target>
        </trans-unit>
        <trans-unit id="af5e4fc428d95afd21ff1ec53e8506a2bd73fb48" translate="yes" xml:space="preserve">
          <source>Circled Division Slash</source>
          <target state="translated">Круговой дивизион Слэш</target>
        </trans-unit>
        <trans-unit id="1540fdfaea096a26f649db63c8e3d97ec047096a" translate="yes" xml:space="preserve">
          <source>Circled Dot Operator</source>
          <target state="translated">Циркулированный точечный оператор</target>
        </trans-unit>
        <trans-unit id="13716b865f5fa5c0c59b298bdb824a0403d1d0a8" translate="yes" xml:space="preserve">
          <source>Circled Equals</source>
          <target state="translated">Круговые равнозначные</target>
        </trans-unit>
        <trans-unit id="6fb20198e34869ba5357fb1484d789a4a9cf41a3" translate="yes" xml:space="preserve">
          <source>Circled Greater-Than</source>
          <target state="translated">Вокруг Большого Тана</target>
        </trans-unit>
        <trans-unit id="768c6a3e34cf1fa1fe17c4122cd2eb756b5c8db1" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Accept</source>
          <target state="translated">Циркулированный идеограф Принять</target>
        </trans-unit>
        <trans-unit id="cd7d8396b4543ec8eac2c933faab0d381b5eddf4" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Advantage</source>
          <target state="translated">Циркулированный идеограф Преимущество</target>
        </trans-unit>
        <trans-unit id="68de940ba4435005de139e8e8a3c0d351749a305" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Congratulation</source>
          <target state="translated">Циркулированный идеограф Поздравление</target>
        </trans-unit>
        <trans-unit id="73f2e57c66e79ca73dc25a784afe3bf12db57991" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Secret</source>
          <target state="translated">Circled Ideograph Secret</target>
        </trans-unit>
        <trans-unit id="a40a39ec3a6682d21b6ef060b4feb0021bb56a91" translate="yes" xml:space="preserve">
          <source>Circled Latin Capital Letter M</source>
          <target state="translated">Закрученная латинская заглавная буква М</target>
        </trans-unit>
        <trans-unit id="0737d90c41767eac9bb882a65f60e50a52a763a4" translate="yes" xml:space="preserve">
          <source>Circled Latin Capital Letter S</source>
          <target state="translated">Закрученная латинская заглавная буква S</target>
        </trans-unit>
        <trans-unit id="3921273fcb7324637d2df323be0460e56b6c07e5" translate="yes" xml:space="preserve">
          <source>Circled Less-Than</source>
          <target state="translated">Вокруг Менее чем</target>
        </trans-unit>
        <trans-unit id="11ab89c625b1e2be31e3ce88e58467e9d8b591d3" translate="yes" xml:space="preserve">
          <source>Circled Minus</source>
          <target state="translated">Круговой минус</target>
        </trans-unit>
        <trans-unit id="49fb7ea6102e3ddbe3f49605b323255242257db1" translate="yes" xml:space="preserve">
          <source>Circled Multiplication Sign With Circumflex Accent</source>
          <target state="translated">Циркулируемый знак умножения с круговым акцентом</target>
        </trans-unit>
        <trans-unit id="b54193aa1a494f0d833f0a8740fb732847cecb8a" translate="yes" xml:space="preserve">
          <source>Circled Parallel</source>
          <target state="translated">Круговая параллель</target>
        </trans-unit>
        <trans-unit id="8f99a8867a889f5ea35c2600d3c7f7047a7990e2" translate="yes" xml:space="preserve">
          <source>Circled Plus</source>
          <target state="translated">Circled Plus</target>
        </trans-unit>
        <trans-unit id="b2f2ab10cbdb08e806c050f7e4c9abf4807d102e" translate="yes" xml:space="preserve">
          <source>Circled Reverse Solidus</source>
          <target state="translated">Круговая обратная твердая среда</target>
        </trans-unit>
        <trans-unit id="7a06e50e7385bdb39935cdfabe9072e82b9447d8" translate="yes" xml:space="preserve">
          <source>Circled Ring Operator</source>
          <target state="translated">Кольцевой оператор</target>
        </trans-unit>
        <trans-unit id="3118f0f5bf53391e1d64d00f6fd9c8f83519338c" translate="yes" xml:space="preserve">
          <source>Circled Times</source>
          <target state="translated">Circled Times</target>
        </trans-unit>
        <trans-unit id="e0d7ab77f8105b38fa7df093b28a79c9646ca42a" translate="yes" xml:space="preserve">
          <source>Circled White Bullet</source>
          <target state="translated">Циркулированная белая пуля</target>
        </trans-unit>
        <trans-unit id="9d61e5de58e6dee3981e042fcf23eeed9646f7cf" translate="yes" xml:space="preserve">
          <source>Circled White Star</source>
          <target state="translated">Круглая Белая Звезда</target>
        </trans-unit>
        <trans-unit id="7748321d0967d869f81325b4585f9b2588000677" translate="yes" xml:space="preserve">
          <source>Circularly shift, i.e. rotate, the data in &lt;code&gt;src&lt;/code&gt;, storing the result in &lt;code&gt;dest&lt;/code&gt;. &lt;code&gt;shifts&lt;/code&gt; specifies the amount to shift in each dimension.</source>
          <target state="translated">Циклически сдвигайте, то есть вращайте данные в &lt;code&gt;src&lt;/code&gt; , сохраняя результат в &lt;code&gt;dest&lt;/code&gt; . &lt;code&gt;shifts&lt;/code&gt; определяет величину сдвига в каждом измерении.</target>
        </trans-unit>
        <trans-unit id="d8d1450c5aa55fa70cdef969d2aed9b6bea5b253" translate="yes" xml:space="preserve">
          <source>Circularly shift, i.e. rotate, the data in an array. The second argument is a tuple or vector giving the amount to shift in each dimension, or an integer to shift only in the first dimension.</source>
          <target state="translated">Круговой сдвиг,т.е.вращение,данных в массиве.Второй аргумент-кортеж или вектор,дающий величину сдвига в каждом измерении,или целое число для сдвига только в первом измерении.</target>
        </trans-unit>
        <trans-unit id="a48e6cb43386bd05dea50af46a123ad0d776b80b" translate="yes" xml:space="preserve">
          <source>Circulation Function</source>
          <target state="translated">Функция циркуляции</target>
        </trans-unit>
        <trans-unit id="37536a1d3cc9b23bf2b06cce0eca23c6a4e7e102" translate="yes" xml:space="preserve">
          <source>Circus Tent</source>
          <target state="translated">Цирковой шатёр</target>
        </trans-unit>
        <trans-unit id="2db191558345453d3d04631fffed018826e9442e" translate="yes" xml:space="preserve">
          <source>Cityscape At Dusk</source>
          <target state="translated">Городской пейзаж в сумерках</target>
        </trans-unit>
        <trans-unit id="4010aa5c7daa771d33be51467b1f2b3303269a35" translate="yes" xml:space="preserve">
          <source>Clamp &lt;code&gt;x&lt;/code&gt; between &lt;code&gt;typemin(T)&lt;/code&gt; and &lt;code&gt;typemax(T)&lt;/code&gt; and convert the result to type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11cf0a77f6ee3236fe15d4a64163013e4f57ac86" translate="yes" xml:space="preserve">
          <source>Clapper Board</source>
          <target state="translated">Клэпперский совет</target>
        </trans-unit>
        <trans-unit id="1a53c684edaeea21a3a7c9865bbc7c7a6b647d98" translate="yes" xml:space="preserve">
          <source>Clapping Hands Sign</source>
          <target state="translated">Знак &quot;Претензионные руки</target>
        </trans-unit>
        <trans-unit id="516efc45347d5f1d25705370de6f7e8790454c94" translate="yes" xml:space="preserve">
          <source>Clear any existing backtraces from the internal buffer.</source>
          <target state="translated">Очистите все существующие обратные пути из внутреннего буфера.</target>
        </trans-unit>
        <trans-unit id="82280dd39a2e304ec7a95875634d07334aea409a" translate="yes" xml:space="preserve">
          <source>Clear console screen</source>
          <target state="translated">Чистый экран консоли</target>
        </trans-unit>
        <trans-unit id="fb1b9ef26d7247fef7acad9f0bc4d393aa69d604" translate="yes" xml:space="preserve">
          <source>Clearly, this is far from the way mathematical integers behave, and you might think it less than ideal for a high-level programming language to expose this to the user. For numerical work where efficiency and transparency are at a premium, however, the alternatives are worse.</source>
          <target state="translated">Очевидно,что это далеко не то,как ведут себя математические целые числа,и вы можете подумать,что для языка программирования высокого уровня это менее чем идеально.Однако для числовой работы,где эффективность и прозрачность стоят на первом месте,альтернативы хуже.</target>
        </trans-unit>
        <trans-unit id="ec4842b9335f240ce519c3e7eb35a6d7dd134038" translate="yes" xml:space="preserve">
          <source>Clears any stored memory allocation data when running julia with &lt;code&gt;--track-allocation&lt;/code&gt;. Execute the command(s) you want to test (to force JIT-compilation), then call &lt;a href=&quot;#Profile.clear_malloc_data&quot;&gt;&lt;code&gt;clear_malloc_data&lt;/code&gt;&lt;/a&gt;. Then execute your command(s) again, quit Julia, and examine the resulting &lt;code&gt;*.mem&lt;/code&gt; files.</source>
          <target state="translated">Очищает все сохраненные данные о распределении памяти при запуске julia с &lt;code&gt;--track-allocation&lt;/code&gt; . Выполните команды, которые вы хотите протестировать (для принудительной JIT-компиляции), затем вызовите &lt;a href=&quot;#Profile.clear_malloc_data&quot;&gt; &lt;code&gt;clear_malloc_data&lt;/code&gt; &lt;/a&gt; . Затем снова выполните вашу команду (ы), &lt;code&gt;*.mem&lt;/code&gt; из Julia и проверьте полученные файлы * .mem .</target>
        </trans-unit>
        <trans-unit id="f1508fb36867e2dc32f615b5c14b90813384914e" translate="yes" xml:space="preserve">
          <source>Clears global bindings in modules by initializing them to &lt;code&gt;nothing&lt;/code&gt;. &lt;code&gt;syms&lt;/code&gt; should be of type &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; or a collection of &lt;code&gt;Symbol&lt;/code&gt;s . &lt;code&gt;pids&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt; identify the processes and the module in which global variables are to be reinitialized. Only those names found to be defined under &lt;code&gt;mod&lt;/code&gt; are cleared.</source>
          <target state="translated">Очищает глобальные привязки в модулях инициализации их &lt;code&gt;nothing&lt;/code&gt; . &lt;code&gt;syms&lt;/code&gt; должны иметь тип &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; или набор &lt;code&gt;Symbol&lt;/code&gt; . &lt;code&gt;pids&lt;/code&gt; и &lt;code&gt;mod&lt;/code&gt; идентифицируют процессы и модуль, в которых должны быть повторно инициализированы глобальные переменные. Удаляются только те имена, которые определены в &lt;code&gt;mod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a37999e16f7842ef3bf129008cd89f6cdc6cb0f" translate="yes" xml:space="preserve">
          <source>Clinking Beer Mugs</source>
          <target state="translated">Слипающиеся пивные кружки</target>
        </trans-unit>
        <trans-unit id="5efe0c9323a499a8546aeac42d4b659bd2a4039f" translate="yes" xml:space="preserve">
          <source>Clipboard</source>
          <target state="translated">Clipboard</target>
        </trans-unit>
        <trans-unit id="80b2a110ce7d7c4741fab08718b7b0bad1a6e22a" translate="yes" xml:space="preserve">
          <source>Clock Face Eight Oclock</source>
          <target state="translated">Циферблат часов восемь часов</target>
        </trans-unit>
        <trans-unit id="890e9e574fe3a811e9c99a391d98d07a63fc0336" translate="yes" xml:space="preserve">
          <source>Clock Face Eight-Thirty</source>
          <target state="translated">Циферблат часов восемь-тридцать</target>
        </trans-unit>
        <trans-unit id="a9b707e0c691e0552e2f8bc3916fe311413cb1c1" translate="yes" xml:space="preserve">
          <source>Clock Face Eleven Oclock</source>
          <target state="translated">Циферблат часов Одиннадцать часов</target>
        </trans-unit>
        <trans-unit id="8ae5c10b2e512ab4d1e9f3ac4882a5accd7c7ae1" translate="yes" xml:space="preserve">
          <source>Clock Face Eleven-Thirty</source>
          <target state="translated">Циферблат часов одиннадцать-тридцать</target>
        </trans-unit>
        <trans-unit id="e22dfa89a765cf1fb21d2f5d1bc38f3ade0afd76" translate="yes" xml:space="preserve">
          <source>Clock Face Five Oclock</source>
          <target state="translated">Циферблат часов пять часов</target>
        </trans-unit>
        <trans-unit id="3a7136e9fc05d844d8d22ef7e7a4065f750e1bbb" translate="yes" xml:space="preserve">
          <source>Clock Face Five-Thirty</source>
          <target state="translated">Циферблат часов пять-тридцать</target>
        </trans-unit>
        <trans-unit id="6c604425f0ef3b9a4e6a798a11e9cb980c5f5643" translate="yes" xml:space="preserve">
          <source>Clock Face Four Oclock</source>
          <target state="translated">Циферблат часов четыре часа</target>
        </trans-unit>
        <trans-unit id="1d7bba61675982358fbf74be54ea171922d5d085" translate="yes" xml:space="preserve">
          <source>Clock Face Four-Thirty</source>
          <target state="translated">Циферблат часов четыре-тридцать</target>
        </trans-unit>
        <trans-unit id="8effbf7e8f00a8276bde132d10680427c2d5ec2c" translate="yes" xml:space="preserve">
          <source>Clock Face Nine Oclock</source>
          <target state="translated">Циферблат часов девять часов</target>
        </trans-unit>
        <trans-unit id="b0f219a4f731970988c8def9f6a9220234b63061" translate="yes" xml:space="preserve">
          <source>Clock Face Nine-Thirty</source>
          <target state="translated">Циферблат часов Девять Тридцать</target>
        </trans-unit>
        <trans-unit id="2aa0624b2187d35a495fb74b7a70417ce4d8cdc6" translate="yes" xml:space="preserve">
          <source>Clock Face One Oclock</source>
          <target state="translated">Циферблат часов один Оклок</target>
        </trans-unit>
        <trans-unit id="92624a0e738083d85292206e98f359ce3546ed05" translate="yes" xml:space="preserve">
          <source>Clock Face One-Thirty</source>
          <target state="translated">Циферблат часов один-тридцать</target>
        </trans-unit>
        <trans-unit id="4ee4d2dec1cb5fcd6697bd397977fe18c3d4992c" translate="yes" xml:space="preserve">
          <source>Clock Face Seven Oclock</source>
          <target state="translated">Циферблат часов семь часов</target>
        </trans-unit>
        <trans-unit id="17aef1804b57cd3ede0fe80570334485de56eaea" translate="yes" xml:space="preserve">
          <source>Clock Face Seven-Thirty</source>
          <target state="translated">Циферблат часов семь-тридцать</target>
        </trans-unit>
        <trans-unit id="f2ce5a71eefd68ceefa6e2f6811d47032f42f6eb" translate="yes" xml:space="preserve">
          <source>Clock Face Six Oclock</source>
          <target state="translated">Циферблат часов Шесть часов</target>
        </trans-unit>
        <trans-unit id="78a9100a5f02623dca735f3dacc48fead261c2cd" translate="yes" xml:space="preserve">
          <source>Clock Face Six-Thirty</source>
          <target state="translated">Циферблат часов Шесть Тридцать</target>
        </trans-unit>
        <trans-unit id="29ed028a4b2d7ccf27a87e9aa08dd08fd6ebb1a6" translate="yes" xml:space="preserve">
          <source>Clock Face Ten Oclock</source>
          <target state="translated">Циферблат часов десять часов</target>
        </trans-unit>
        <trans-unit id="288b3a0678ebc38844da6df6f1e87880c74baafc" translate="yes" xml:space="preserve">
          <source>Clock Face Ten-Thirty</source>
          <target state="translated">Циферблат часов с десятью тридцатью</target>
        </trans-unit>
        <trans-unit id="bb465de467c2b010bb6b846eb78c2a1229522242" translate="yes" xml:space="preserve">
          <source>Clock Face Three Oclock</source>
          <target state="translated">Циферблат часов три часа</target>
        </trans-unit>
        <trans-unit id="cfd958f3c422c51d841c78b6b7f3d9e44fc3ad75" translate="yes" xml:space="preserve">
          <source>Clock Face Three-Thirty</source>
          <target state="translated">Циферблат часов Три Три Тридцать</target>
        </trans-unit>
        <trans-unit id="7f669cae21a33d00c881936310a0c78e765a67d2" translate="yes" xml:space="preserve">
          <source>Clock Face Twelve Oclock</source>
          <target state="translated">Циферблат часов Двенадцать часов</target>
        </trans-unit>
        <trans-unit id="1ef2e813447d172d893056c5340a57fc6839f314" translate="yes" xml:space="preserve">
          <source>Clock Face Twelve-Thirty</source>
          <target state="translated">Циферблат часов Двенадцать Тридцать</target>
        </trans-unit>
        <trans-unit id="4f6902106020e062d23dd43ecf72cd67020b6c3e" translate="yes" xml:space="preserve">
          <source>Clock Face Two Oclock</source>
          <target state="translated">Циферблат часов два часа</target>
        </trans-unit>
        <trans-unit id="bcda9b95a7f9d026cc96f88e4ef6597b3948c3f5" translate="yes" xml:space="preserve">
          <source>Clock Face Two-Thirty</source>
          <target state="translated">Циферблат часов два-тридцать</target>
        </trans-unit>
        <trans-unit id="3343394a9f3b65dd62d440bfd227fa40ca3918a2" translate="yes" xml:space="preserve">
          <source>Clockwise Contour Integral</source>
          <target state="translated">Интеграл контура по часовой стрелке</target>
        </trans-unit>
        <trans-unit id="bef25f4fbfeb987aed2d95c207d8122fa87692e3" translate="yes" xml:space="preserve">
          <source>Clockwise Downwards And Upwards Open Circle Arrows</source>
          <target state="translated">По часовой стрелке вниз и вверх Открытые круглые стрелки</target>
        </trans-unit>
        <trans-unit id="b8015a573f0320267e05a1e6968f148a65bd38e5" translate="yes" xml:space="preserve">
          <source>Clockwise Integral</source>
          <target state="translated">Интеграл по часовой стрелке</target>
        </trans-unit>
        <trans-unit id="7dcd16fa461353aaddde398802c410edb65684a9" translate="yes" xml:space="preserve">
          <source>Clockwise Open Circle Arrow</source>
          <target state="translated">Стрелка открытия круга по часовой стрелке</target>
        </trans-unit>
        <trans-unit id="0de2e9fdaa78d1a87383fa303df054177c3eef28" translate="yes" xml:space="preserve">
          <source>Clockwise Rightwards And Leftwards Open Circle Arrows</source>
          <target state="translated">По часовой стрелке вправо и влево Стрелки открываются.</target>
        </trans-unit>
        <trans-unit id="78f3f16a08531e7f8a413160ff88e095df7562f2" translate="yes" xml:space="preserve">
          <source>Clockwise Rightwards And Leftwards Open Circle Arrows With Circled One Overlay</source>
          <target state="translated">По часовой стрелке вправо и влево Стрелки открывания круга с наложением по одному кругу</target>
        </trans-unit>
        <trans-unit id="5a2532914552dd4a4df03ca6c532a1cda0ad9c3e" translate="yes" xml:space="preserve">
          <source>Clockwise Top Semicircle Arrow</source>
          <target state="translated">Стрелка верхнего полукруга по часовой стрелке</target>
        </trans-unit>
        <trans-unit id="bd5a088aabea6d4dfe11cc8a8a32a9c1483fc8dd" translate="yes" xml:space="preserve">
          <source>Clone a remote repository located at &lt;code&gt;repo_url&lt;/code&gt; to the local filesystem location &lt;code&gt;repo_path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;repo_url&lt;/code&gt; удаленный репозиторий, расположенный по адресу repo_url, в расположение локальной файловой системы &lt;code&gt;repo_path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c018fd37cc98046cd18021dbc1501935677a8d0b" translate="yes" xml:space="preserve">
          <source>Clone the remote repository at &lt;code&gt;repo_url&lt;/code&gt; (which can be a remote URL or a path on the local filesystem) to &lt;code&gt;repo_path&lt;/code&gt; (which must be a path on the local filesystem). Options for the clone, such as whether to perform a bare clone or not, are set by &lt;a href=&quot;#LibGit2.CloneOptions&quot;&gt;&lt;code&gt;CloneOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;repo_url&lt;/code&gt; удаленный репозиторий с repo_url (который может быть удаленным URL-адресом или путем в локальной файловой системе) в &lt;code&gt;repo_path&lt;/code&gt; (который должен быть путем в локальной файловой системе). Параметры для клона, например, выполнять ли клонирование с &lt;a href=&quot;#LibGit2.CloneOptions&quot;&gt; &lt;code&gt;CloneOptions&lt;/code&gt; &lt;/a&gt; или нет, устанавливаются CloneOptions .</target>
        </trans-unit>
        <trans-unit id="03c26d678d2b5f993e8a4888363c7faf8f7499f8" translate="yes" xml:space="preserve">
          <source>Clong</source>
          <target state="translated">Clong</target>
        </trans-unit>
        <trans-unit id="ba9c34e2f3436e5d9b8a5291e72a776889a2ff30" translate="yes" xml:space="preserve">
          <source>Clonglong</source>
          <target state="translated">Clonglong</target>
        </trans-unit>
        <trans-unit id="b5209dad4d3f1bed9db6402ecbcc5727437490f8" translate="yes" xml:space="preserve">
          <source>Close a channel. An exception (optionally given by &lt;code&gt;excp&lt;/code&gt;), is thrown by:</source>
          <target state="translated">Закройте канал. Исключение (необязательно указываемое &lt;code&gt;excp&lt;/code&gt; ) выдается :</target>
        </trans-unit>
        <trans-unit id="10c5d49bb09afa0ca8e3334711e18326dcf891af" translate="yes" xml:space="preserve">
          <source>Close an I/O stream. Performs a &lt;a href=&quot;#Base.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">Закройте поток ввода-вывода. Сначала выполняется &lt;a href=&quot;#Base.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="454adf74b3f6704e85f70c7ddf537bda059f03dd" translate="yes" xml:space="preserve">
          <source>Close shared library referenced by handle.</source>
          <target state="translated">Закрыть общую библиотеку,на которую ссылается рукоятка.</target>
        </trans-unit>
        <trans-unit id="8170fa95b5dabb39e3ab1424d8d01e1c3b92e425" translate="yes" xml:space="preserve">
          <source>Closed Book</source>
          <target state="translated">Закрытая книга</target>
        </trans-unit>
        <trans-unit id="f01ec4341502afd5ff0fd4449550b0f2d821118a" translate="yes" xml:space="preserve">
          <source>Closed Intersection With Serifs</source>
          <target state="translated">Закрытое пересечение с серифами</target>
        </trans-unit>
        <trans-unit id="f96d5b0a19b4b209a04614ed2d984814137842d3" translate="yes" xml:space="preserve">
          <source>Closed Lock With Key</source>
          <target state="translated">Закрытый замок с ключом</target>
        </trans-unit>
        <trans-unit id="fc6222181031539686fbc1981c6536202f4eebfd" translate="yes" xml:space="preserve">
          <source>Closed Mailbox With Lowered Flag</source>
          <target state="translated">Закрытый почтовый ящик с пониженным флагом</target>
        </trans-unit>
        <trans-unit id="675cf6fab44f887f9851bda94e48adbe87600a21" translate="yes" xml:space="preserve">
          <source>Closed Mailbox With Raised Flag</source>
          <target state="translated">Закрытый почтовый ящик с поднятым флагом</target>
        </trans-unit>
        <trans-unit id="deb82abc2edb75e5d2559fdc5e14496f68ebe0bb" translate="yes" xml:space="preserve">
          <source>Closed Subset</source>
          <target state="translated">Закрытый подзаголовок</target>
        </trans-unit>
        <trans-unit id="27f828ad61dfe0b96ce6597aa9645041a206cb0a" translate="yes" xml:space="preserve">
          <source>Closed Subset Or Equal To</source>
          <target state="translated">Закрытая подгруппа или равная</target>
        </trans-unit>
        <trans-unit id="9ca1f162310be3f8fde01956aa333063b943a628" translate="yes" xml:space="preserve">
          <source>Closed Superset</source>
          <target state="translated">Закрытый Суперсеть</target>
        </trans-unit>
        <trans-unit id="c1a77c6e35a02621888adfea720e18df739c611e" translate="yes" xml:space="preserve">
          <source>Closed Superset Or Equal To</source>
          <target state="translated">Закрытый Суперсет или равный</target>
        </trans-unit>
        <trans-unit id="1d0ef3df97ab3df50e949a9a1324005eda6b8edb" translate="yes" xml:space="preserve">
          <source>Closed Umbrella</source>
          <target state="translated">Закрытый зонт</target>
        </trans-unit>
        <trans-unit id="2509ab5953079af2e5239350a2c4c20c24bf4b87" translate="yes" xml:space="preserve">
          <source>Closed Union With Serifs</source>
          <target state="translated">Закрытый союз с засечками</target>
        </trans-unit>
        <trans-unit id="f8612daffee734ab8fe7ac27e4779293f47bd9f2" translate="yes" xml:space="preserve">
          <source>Closed Union With Serifs And Smash Product</source>
          <target state="translated">Закрытый союз с серифами и смэш-продуктом</target>
        </trans-unit>
        <trans-unit id="6d5a3633bf3066d6ab42acadf4720d0c57381f8b" translate="yes" xml:space="preserve">
          <source>Closing a Library</source>
          <target state="translated">Закрытие библиотеки</target>
        </trans-unit>
        <trans-unit id="aaaf708c53d56650e9ea07591d01dc353b945138" translate="yes" xml:space="preserve">
          <source>Closure &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; rely on LLVM trampolines, which are not available on all platforms (for example ARM and PowerPC).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a1d4177a6fdb9b5f67b13428352c7562697b82" translate="yes" xml:space="preserve">
          <source>Closure cfunctions</source>
          <target state="translated">Функции закрытия</target>
        </trans-unit>
        <trans-unit id="b2efeaa1a7d6d2185ea02473cf758203dfcea3fe" translate="yes" xml:space="preserve">
          <source>Cloud</source>
          <target state="translated">Cloud</target>
        </trans-unit>
        <trans-unit id="ac3f2b0304dbad8004f320d418e21b773f559bef" translate="yes" xml:space="preserve">
          <source>Cluster Cookie</source>
          <target state="translated">Кластерное печенье</target>
        </trans-unit>
        <trans-unit id="2719f92d9319470b062026857b1b798355606f18" translate="yes" xml:space="preserve">
          <source>Cluster Manager Interface</source>
          <target state="translated">Интерфейс менеджера кластера</target>
        </trans-unit>
        <trans-unit id="24b40ea7b4c6d2a2754b767ef66941a1b621105f" translate="yes" xml:space="preserve">
          <source>Cluster Managers with Custom Transports</source>
          <target state="translated">Кластерные менеджеры с таможенными перевозками</target>
        </trans-unit>
        <trans-unit id="c66ed07e93160ccf42e9560935c19321d18456bf" translate="yes" xml:space="preserve">
          <source>ClusterManagers</source>
          <target state="translated">ClusterManagers</target>
        </trans-unit>
        <trans-unit id="36a5cc40f84a6918339448f7f9c84d698b78ed22" translate="yes" xml:space="preserve">
          <source>Cmd</source>
          <target state="translated">Cmd</target>
        </trans-unit>
        <trans-unit id="598ac4d5aadd51518cf7408c7b09c93d77fd77bc" translate="yes" xml:space="preserve">
          <source>Cocktail Glass</source>
          <target state="translated">Бокал для коктейлей</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="a99f20e7919aa57d6d229cdc49d476b887823796" translate="yes" xml:space="preserve">
          <source>Code Availability and Loading Packages</source>
          <target state="translated">Доступность кода и загрузка пакетов</target>
        </trans-unit>
        <trans-unit id="d0078b16e6e193ac2fab2fcfbc625d4cc9fdb7f5" translate="yes" xml:space="preserve">
          <source>Code Generation</source>
          <target state="translated">Генерация кода</target>
        </trans-unit>
        <trans-unit id="f24dc61405e4a6ac1922198818e95b7dcd3db014" translate="yes" xml:space="preserve">
          <source>Code Loading</source>
          <target state="translated">Загрузка кода</target>
        </trans-unit>
        <trans-unit id="b69ba088ce9ad1ce235332dd2372fe802609e0da" translate="yes" xml:space="preserve">
          <source>Code blocks</source>
          <target state="translated">Блоки кода</target>
        </trans-unit>
        <trans-unit id="42113fe2d252dc34afb2007f91d2f4059784abe7" translate="yes" xml:space="preserve">
          <source>Code inclusion is quite straightforward and simple: it evaluates the given source file in the context of the caller. Package loading is built on top of code inclusion and serves a &lt;a href=&quot;../modules/index#modules&quot;&gt;different purpose&lt;/a&gt;. The rest of this chapter focuses on the behavior and mechanics of package loading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a9d7c94aa1ad1ba8632efb3563e42b2453a554" translate="yes" xml:space="preserve">
          <source>Code inclusion is quite straightforward and simple: it evaluates the given source file in the context of the caller. Package loading is built on top of code inclusion and serves a &lt;a href=&quot;../modules/index#modules-1&quot;&gt;different purpose&lt;/a&gt;. The rest of this chapter focuses on the behavior and mechanics of package loading.</source>
          <target state="translated">Включение кода довольно прямолинейно и просто: он оценивает данный исходный файл в контексте вызывающего. Загрузка пакета основана на включении кода и служит &lt;a href=&quot;../modules/index#modules-1&quot;&gt;другой цели&lt;/a&gt; . Остальная часть этой главы посвящена поведению и механике загрузки пакетов.</target>
        </trans-unit>
        <trans-unit id="35b9be6a9b072a2d90be1ca50990262602cae797" translate="yes" xml:space="preserve">
          <source>Code point(s)</source>
          <target state="translated">Кодовой пункт (-ы)</target>
        </trans-unit>
        <trans-unit id="33284c9a71b782e3478512a7869d4dc33c4b362d" translate="yes" xml:space="preserve">
          <source>Code should be as generic as possible. Instead of writing:</source>
          <target state="translated">Код должен быть как можно более общим.Вместо того,чтобы писать:</target>
        </trans-unit>
        <trans-unit id="aae5cfaaacaac3a30cf57079dd346c86a7f7fc5e" translate="yes" xml:space="preserve">
          <source>Code using immutable objects can be easier to reason about.</source>
          <target state="translated">Код,использующий неизменяемые объекты,может быть легче аргументирован.</target>
        </trans-unit>
        <trans-unit id="80674c31d4ab113b84f8bfda79f90e7c65f5531a" translate="yes" xml:space="preserve">
          <source>Collect a list of log records generated by &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;collect_test_logs&lt;/code&gt;, check that they match the sequence &lt;code&gt;log_patterns&lt;/code&gt;, and return the value of &lt;code&gt;expression&lt;/code&gt;. The &lt;code&gt;keywords&lt;/code&gt; provide some simple filtering of log records: the &lt;code&gt;min_level&lt;/code&gt; keyword controls the minimum log level which will be collected for the test, the &lt;code&gt;match_mode&lt;/code&gt; keyword defines how matching will be performed (the default &lt;code&gt;:all&lt;/code&gt; checks that all logs and patterns match pairwise; use &lt;code&gt;:any&lt;/code&gt; to check that the pattern matches at least once somewhere in the sequence.)</source>
          <target state="translated">Соберите список записей журнала, сгенерированных &lt;code&gt;expression&lt;/code&gt; с помощью &lt;code&gt;collect_test_logs&lt;/code&gt; , убедитесь, что они соответствуют последовательности &lt;code&gt;log_patterns&lt;/code&gt; , и верните значение &lt;code&gt;expression&lt;/code&gt; . В &lt;code&gt;keywords&lt;/code&gt; обеспечивают некоторую простую фильтрацию записей журнала: в &lt;code&gt;min_level&lt;/code&gt; контроль ключевых слов на уровень журнала минимального , который будет собираться на тест &lt;code&gt;match_mode&lt;/code&gt; определяет ключевое слово , как будет выполняться согласование (по умолчанию &lt;code&gt;:all&lt;/code&gt; проверяет , что все журналы и шаблоны совпадают попарно; использование &lt;code&gt;:any&lt;/code&gt; , чтобы проверить, совпадает ли шаблон хотя бы один раз где-то в последовательности.)</target>
        </trans-unit>
        <trans-unit id="0a8af36fa1d1619f2da90f35bd9c11b35a37e433" translate="yes" xml:space="preserve">
          <source>Collect information about the status of each file in the git repository &lt;code&gt;repo&lt;/code&gt; (e.g. is the file modified, staged, etc.). &lt;code&gt;status_opts&lt;/code&gt; can be used to set various options, for instance whether or not to look at untracked files or whether to include submodules or not. See &lt;a href=&quot;#LibGit2.StatusOptions&quot;&gt;&lt;code&gt;StatusOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Сбор информации о состоянии каждого файла в хранилище мерзавца &lt;code&gt;repo&lt;/code&gt; (например , это файл изменен, поставил и т.д.). &lt;code&gt;status_opts&lt;/code&gt; можно использовать для установки различных опций, например, следует ли просматривать неотслеживаемые файлы или включать ли подмодули или нет. Смотрите &lt;a href=&quot;#LibGit2.StatusOptions&quot;&gt; &lt;code&gt;StatusOptions&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="2e2ef8c695440679e7d61620a3e6f58db57bb36f" translate="yes" xml:space="preserve">
          <source>Collections and Data Structures</source>
          <target state="translated">Сборы и структуры данных</target>
        </trans-unit>
        <trans-unit id="b600a07f6e2a178ebfbe565ac70dc1d11d80d058" translate="yes" xml:space="preserve">
          <source>Collections passed to functions are also not copied. Functions can modify (mutate) the contents of the objects their arguments refer to. (The names of functions which do this are conventionally suffixed with '!'.)</source>
          <target state="translated">Коллекции,переданные в функции,также не копируются.Функции могут изменять (мутировать)содержимое объектов,на которые ссылаются их аргументы.(Имена функций,которые это делают,условно суффиксованы с '!').</target>
        </trans-unit>
        <trans-unit id="7a2802907d31a8ef64806a9e6c2120bb1e4caacf" translate="yes" xml:space="preserve">
          <source>Collision Symbol</source>
          <target state="translated">символ столкновения</target>
        </trans-unit>
        <trans-unit id="ac30df75efbedb8442edcd22700caca733d79868" translate="yes" xml:space="preserve">
          <source>Colon</source>
          <target state="translated">Colon</target>
        </trans-unit>
        <trans-unit id="0a14c37ba89fcb5b7168d9ef916ce4e00e67937f" translate="yes" xml:space="preserve">
          <source>Colon Equals / Colon Equal</source>
          <target state="translated">Двоеточие равно/Двоеточие равно</target>
        </trans-unit>
        <trans-unit id="bb11dae2a053933f6bc7422a2373bf8281b97e57" translate="yes" xml:space="preserve">
          <source>Colons (:) are used to signify indexing entire objects or dimensions at once.</source>
          <target state="translated">Символы (:)используются для обозначения индексации целых объектов или размеров сразу.</target>
        </trans-unit>
        <trans-unit id="f95263d15db043d5d52856caad1fadeda6d1c2bc" translate="yes" xml:space="preserve">
          <source>Combinatorics</source>
          <target state="translated">Combinatorics</target>
        </trans-unit>
        <trans-unit id="5350d59289c3e9b699c68a850143c7c2aca47e8e" translate="yes" xml:space="preserve">
          <source>Combined inplace matrix-matrix or matrix-vector multiply-add $A B &amp;alpha; + C &amp;beta;$. The result is stored in &lt;code&gt;C&lt;/code&gt; by overwriting it. Note that &lt;code&gt;C&lt;/code&gt; must not be aliased with either &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173cad0d0654b3f6eb52faa1ce6c93b0376b3f89" translate="yes" xml:space="preserve">
          <source>Combined multiply-add: computes &lt;code&gt;x*y+z&lt;/code&gt;, but allowing the add and multiply to be merged with each other or with surrounding operations for performance. For example, this may be implemented as an &lt;a href=&quot;#Base.fma&quot;&gt;&lt;code&gt;fma&lt;/code&gt;&lt;/a&gt; if the hardware supports it efficiently. The result can be different on different machines and can also be different on the same machine due to constant propagation or other optimizations. See &lt;a href=&quot;#Base.fma&quot;&gt;&lt;code&gt;fma&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Комбинированное умножение-сложение: вычисляет &lt;code&gt;x*y+z&lt;/code&gt; , но позволяет объединять операции сложения и умножения друг с другом или с окружающими операциями для повышения производительности. Например, это может быть реализовано как &lt;a href=&quot;#Base.fma&quot;&gt; &lt;code&gt;fma&lt;/code&gt; ,&lt;/a&gt; если оборудование поддерживает его эффективно. Результат может отличаться на разных машинах, а также может отличаться на одной машине из-за постоянного распространения или других оптимизаций. См. &lt;a href=&quot;#Base.fma&quot;&gt; &lt;code&gt;fma&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4f01a71c42b25ea3da620732f8db11437dd099b" translate="yes" xml:space="preserve">
          <source>Combining Acute Accent / Non-Spacing Acute</source>
          <target state="translated">Сочетание острого акцента/нескоростной резкости</target>
        </trans-unit>
        <trans-unit id="0734b67961e0eb56239f8b7b60c539fb6834880e" translate="yes" xml:space="preserve">
          <source>Combining Annuity Symbol</source>
          <target state="translated">Комбинированный аннуитетный символ</target>
        </trans-unit>
        <trans-unit id="95ae63a999d098981e7621ee2008c43b0f6a60c6" translate="yes" xml:space="preserve">
          <source>Combining Asterisk Above</source>
          <target state="translated">Сочетание звездочек выше</target>
        </trans-unit>
        <trans-unit id="685cd2e09ad265192e0356f28e46509d84ab4d71" translate="yes" xml:space="preserve">
          <source>Combining Breve / Non-Spacing Breve</source>
          <target state="translated">Комбинирующий перерыв/нестационарный перерыв</target>
        </trans-unit>
        <trans-unit id="8e2be6c64a88e84a6f429cab4bdb53ba4fe80660" translate="yes" xml:space="preserve">
          <source>Combining Bridge Below / Non-Spacing Bridge Below</source>
          <target state="translated">Комбинирующий мост Под/нескоростной мост Под</target>
        </trans-unit>
        <trans-unit id="a3f38dbfee0a0277b8fc6dd5b6eb831595bf84a0" translate="yes" xml:space="preserve">
          <source>Combining Candrabindu / Non-Spacing Candrabindu</source>
          <target state="translated">Сочетание Кэндрабинду/нешаговый Кэндрабинду</target>
        </trans-unit>
        <trans-unit id="8aff768b42edc639adecd3dd04d42d7aed791251" translate="yes" xml:space="preserve">
          <source>Combining Caron / Non-Spacing Hacek</source>
          <target state="translated">Комбинирование Caron/Нескользящий Hacek</target>
        </trans-unit>
        <trans-unit id="3c4e117dd5db64357d4d73eb9cdd1ba25f04fdb1" translate="yes" xml:space="preserve">
          <source>Combining Cedilla / Non-Spacing Cedilla</source>
          <target state="translated">Сочетание Седильи/Нескользящей Чедильи</target>
        </trans-unit>
        <trans-unit id="91f0dba538ac66d644d07a8387e2e7e115f196c5" translate="yes" xml:space="preserve">
          <source>Combining Circumflex Accent / Non-Spacing Circumflex</source>
          <target state="translated">Комбинирующий циркумфлекс Акцент/Нескользящий циркумфлекс</target>
        </trans-unit>
        <trans-unit id="a43cbdb97b8f699aa2f8714ed59973b90ec0f295" translate="yes" xml:space="preserve">
          <source>Combining Comma Above Right / Non-Spacing Comma Above Right</source>
          <target state="translated">Комбинированная запятая справа вверху/нескоростная запятая справа вверху</target>
        </trans-unit>
        <trans-unit id="a33ec808d6857cd58bedcf6f6f9afde52f57d4fd" translate="yes" xml:space="preserve">
          <source>Combining Diaeresis / Non-Spacing Diaeresis</source>
          <target state="translated">Сочетание диареза/непериодического диареза</target>
        </trans-unit>
        <trans-unit id="becaf6a97e81c19ea9f31b976c527ddc1bbea3ee" translate="yes" xml:space="preserve">
          <source>Combining Dot Above / Non-Spacing Dot Above</source>
          <target state="translated">Комбинирование точки выше/не-шасси точка выше</target>
        </trans-unit>
        <trans-unit id="d95e2893d2008e3fc0c1b9bc24115f37f1791066" translate="yes" xml:space="preserve">
          <source>Combining Double Acute Accent / Non-Spacing Double Acute</source>
          <target state="translated">Сочетание двойного острого акцента/нескорости двойной остроты</target>
        </trans-unit>
        <trans-unit id="f08f92ba4b2bb682dc3e2d5e9c8df57b5dedb3f6" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Circle / Enclosing Circle</source>
          <target state="translated">Комбинирующий замыкающий круг/замыкающий круг</target>
        </trans-unit>
        <trans-unit id="83f22c6a001242a5a561f3a7895cf7d7aaaebd0b" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Diamond / Enclosing Diamond</source>
          <target state="translated">Комбинирование Алмазный/Алмазный Заводской</target>
        </trans-unit>
        <trans-unit id="ec76e2f012d98e1337784adeec747df1b78cf15b" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Square / Enclosing Square</source>
          <target state="translated">Объединение Ограждающих площадей/Ограждающих площадей</target>
        </trans-unit>
        <trans-unit id="efc364102d3ca81f092b677aca701ad08ab10de7" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Upward Pointing Triangle</source>
          <target state="translated">Объединение закрывающего направленного вверх треугольника</target>
        </trans-unit>
        <trans-unit id="22bab50c74edd0eb4d138ac01ac71ba994064528" translate="yes" xml:space="preserve">
          <source>Combining Four Dots Above / Non-Spacing Four Dots Above</source>
          <target state="translated">Объединение четырёх точек над/нескользящих четырёх точек над</target>
        </trans-unit>
        <trans-unit id="38e73c84dac801257b0f5e15b8402de9de60fd4a" translate="yes" xml:space="preserve">
          <source>Combining Grave Accent / Non-Spacing Grave</source>
          <target state="translated">Сочетание могильного акцента/нескользящей могилы</target>
        </trans-unit>
        <trans-unit id="fb49a0f3994aaa3fea7e9d53f4e24c6dd93638a6" translate="yes" xml:space="preserve">
          <source>Combining Hook Above / Non-Spacing Hook Above</source>
          <target state="translated">Комбинирование крюк выше/не-расстояние Крюк выше</target>
        </trans-unit>
        <trans-unit id="4cb010ffd9ffa4a05013b3488b30c23afb01fdf1" translate="yes" xml:space="preserve">
          <source>Combining Left Angle Above / Non-Spacing Left Angle Above</source>
          <target state="translated">Сочетание левого угла наверху/нескорости Левый угол наверху</target>
        </trans-unit>
        <trans-unit id="08e42cf0385a0528419967690402d2f77fea8ecf" translate="yes" xml:space="preserve">
          <source>Combining Left Arrow Above / Non-Spacing Left Arrow Above</source>
          <target state="translated">Объединение левой стрелки выше/непередвижная левая стрелка выше</target>
        </trans-unit>
        <trans-unit id="877d024a8659b4afa7238332933b7ad143528441" translate="yes" xml:space="preserve">
          <source>Combining Left Arrow Below</source>
          <target state="translated">Сочетание левой стрелки ниже</target>
        </trans-unit>
        <trans-unit id="8e6257e591a7e8d45ef0764ba2aea89c01420024" translate="yes" xml:space="preserve">
          <source>Combining Left Harpoon Above / Non-Spacing Left Harpoon Above</source>
          <target state="translated">Сочетание левого гарпуна выше/нескоростной левый гарпун выше</target>
        </trans-unit>
        <trans-unit id="98b334c8eb46b8b78fdd86ea856a3c01a529a309" translate="yes" xml:space="preserve">
          <source>Combining Left Right Arrow Above / Non-Spacing Left Right Arrow Above</source>
          <target state="translated">Сочетание левой правой стрелки выше/непередвижная левая стрелка вправо Стрелка влево Наверху</target>
        </trans-unit>
        <trans-unit id="cedc5fa73afb530ac1a47e52244635331691700e" translate="yes" xml:space="preserve">
          <source>Combining Left Right Arrow Below</source>
          <target state="translated">Сочетание левой и правой стрелок внизу</target>
        </trans-unit>
        <trans-unit id="3ecd111368eb8e38f96414851bb4b26f50509766" translate="yes" xml:space="preserve">
          <source>Combining Leftwards Harpoon With Barb Downwards</source>
          <target state="translated">Сочетание левого гарпуна с Барб вниз</target>
        </trans-unit>
        <trans-unit id="0dfea306ba6d2c2199ba2e9e71aebfc34b9abf34" translate="yes" xml:space="preserve">
          <source>Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Сочетание наложения с длинным сплошным слоем/нескоростного наложения с длинным косым черенком</target>
        </trans-unit>
        <trans-unit id="9f887140bfcfd6f9e5fb967ba98a3207c8b16bb7" translate="yes" xml:space="preserve">
          <source>Combining Long Stroke Overlay / Non-Spacing Long Bar Overlay</source>
          <target state="translated">Сочетание наложения с длинным ходом/нескоростного наложения с длинным прутком</target>
        </trans-unit>
        <trans-unit id="739259d807921f9f328b7781ee790a60e450a0a1" translate="yes" xml:space="preserve">
          <source>Combining Long Vertical Line Overlay / Non-Spacing Long Vertical Bar Overlay</source>
          <target state="translated">Комбинирование наложения длинных вертикальных линий/непередвижного наложения длинных вертикальных балок</target>
        </trans-unit>
        <trans-unit id="2fa244bc31952195840fcfc3a299980dbf801f6f" translate="yes" xml:space="preserve">
          <source>Combining Low Line / Non-Spacing Underscore</source>
          <target state="translated">Сочетание низкой линии/нескоростного подчёркивания</target>
        </trans-unit>
        <trans-unit id="bf4b2a4b27fa69268427f002d7db69ac9dc2b07c" translate="yes" xml:space="preserve">
          <source>Combining Macron / Non-Spacing Macron</source>
          <target state="translated">Сочетание Макрона/Нескользящего Макрона</target>
        </trans-unit>
        <trans-unit id="a27d4c9bf29370f4faabca36676f0b74743a74d7" translate="yes" xml:space="preserve">
          <source>Combining Ogonek / Non-Spacing Ogonek</source>
          <target state="translated">Сочетание Огонека/нескоростного Огонека</target>
        </trans-unit>
        <trans-unit id="6d0be0f1d7e1edefb9f72a94ba4677970ba978c9" translate="yes" xml:space="preserve">
          <source>Combining Overline / Non-Spacing Overscore</source>
          <target state="translated">Сочетание оверлайн/нескоростной оверлайн/нескоростной оверлайн</target>
        </trans-unit>
        <trans-unit id="7fad7b377dc7ab955143e3c864e92020afd810c8" translate="yes" xml:space="preserve">
          <source>Combining Palatalized Hook Below / Non-Spacing Palatalized Hook Below</source>
          <target state="translated">Сочетание палетализированного крюка под/не-шасси палетализированного крюка под</target>
        </trans-unit>
        <trans-unit id="a8de9e264b7b283c54023c71a0b50c54c5639e6e" translate="yes" xml:space="preserve">
          <source>Combining Retroflex Hook Below / Non-Spacing Retroflex Hook Below</source>
          <target state="translated">Комбинирование Ретрофлекс крюк ниже/нестесненный Ретрофлекс крюк ниже</target>
        </trans-unit>
        <trans-unit id="2ba0d1fd66790c9bf8dd50de28c5fd6f05110ed4" translate="yes" xml:space="preserve">
          <source>Combining Right Arrow Above / Non-Spacing Right Arrow Above</source>
          <target state="translated">Сочетание стрелки вправо выше/непередвижная стрелка вправо Стрелка вправо выше</target>
        </trans-unit>
        <trans-unit id="8a30e8c07ae1959f3cd09497d8080f6227316b77" translate="yes" xml:space="preserve">
          <source>Combining Right Arrow Below</source>
          <target state="translated">Сочетание правой стрелки ниже</target>
        </trans-unit>
        <trans-unit id="4befcc9e0a743f1dd40b3e9e50041b9252baebcb" translate="yes" xml:space="preserve">
          <source>Combining Right Harpoon Above / Non-Spacing Right Harpoon Above</source>
          <target state="translated">Сочетание правого гарпуна выше/нескоростной правый гарпун выше</target>
        </trans-unit>
        <trans-unit id="aeddc0f0eef5dd1ae0bb9d2d0caf8ade2b689afe" translate="yes" xml:space="preserve">
          <source>Combining Rightwards Harpoon With Barb Downwards</source>
          <target state="translated">Сочетание гарпуна вправо с Барб вниз</target>
        </trans-unit>
        <trans-unit id="59a9a29108a67d4f908b40c8ecffadfd41391c2c" translate="yes" xml:space="preserve">
          <source>Combining Ring Above / Non-Spacing Ring Above</source>
          <target state="translated">Комбинирующее кольцо Над/Нескользящее кольцо Над</target>
        </trans-unit>
        <trans-unit id="5111c307faa772b3a9538095159cefe4c37acd0e" translate="yes" xml:space="preserve">
          <source>Combining Three Dots Above / Non-Spacing Three Dots Above</source>
          <target state="translated">Объединение трех точек наверху/не на расстоянии трех точек наверху</target>
        </trans-unit>
        <trans-unit id="b28cdba8bdbc1c8dbf325c4c84adf50cfa7b9f07" translate="yes" xml:space="preserve">
          <source>Combining Tilde / Non-Spacing Tilde</source>
          <target state="translated">Сочетание тильды/нескоростной тильды</target>
        </trans-unit>
        <trans-unit id="415941ac9a1882af5b80885af204940e2087908c" translate="yes" xml:space="preserve">
          <source>Combining Tilde Below / Non-Spacing Tilde Below</source>
          <target state="translated">Сочетание тильды ниже/нескоростной тильды ниже</target>
        </trans-unit>
        <trans-unit id="890e5eec0caff7a7e81de77d0eefa045a1434041" translate="yes" xml:space="preserve">
          <source>Combining Triple Underdot</source>
          <target state="translated">Сочетание тройной точки</target>
        </trans-unit>
        <trans-unit id="308897e651f5347eeb783d7242b9d33cce1a8f1b" translate="yes" xml:space="preserve">
          <source>Combining Turned Comma Above / Non-Spacing Turned Comma Above</source>
          <target state="translated">Сочетание перевёрнутой запятой выше/непередвижная перевёрнутая запятая выше</target>
        </trans-unit>
        <trans-unit id="866e577b99c41379b3aa42c4489796f50fe38cc1" translate="yes" xml:space="preserve">
          <source>Combining Wide Bridge Above</source>
          <target state="translated">Сочетание Широкого моста над</target>
        </trans-unit>
        <trans-unit id="88113a7dbb8d79749cd6e0f0600302ccfd5aa3c0" translate="yes" xml:space="preserve">
          <source>Combining dot operators with numeric literals can be ambiguous. For example, it is not clear whether &lt;code&gt;1.+x&lt;/code&gt; means &lt;code&gt;1. + x&lt;/code&gt; or &lt;code&gt;1 .+ x&lt;/code&gt;. Therefore this syntax is disallowed, and spaces must be used around the operator in such cases.</source>
          <target state="translated">Комбинирование операторов точки с числовыми литералами может быть неоднозначным. Например, неясно, означает ли &lt;code&gt;1.+x&lt;/code&gt; &lt;code&gt;1. + x&lt;/code&gt; или &lt;code&gt;1 .+ x&lt;/code&gt; . Следовательно, этот синтаксис запрещен, и в таких случаях необходимо использовать пробелы вокруг оператора.</target>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="8ddf0393cc298edc03dc88f0719f2655cd0574b7" translate="yes" xml:space="preserve">
          <source>Commit all currently buffered writes to the given stream.</source>
          <target state="translated">Записывайте в данный поток все записи,находящиеся в буфере.</target>
        </trans-unit>
        <trans-unit id="a347aae8b8a9fc1e2f6210e5e5378437485857d4" translate="yes" xml:space="preserve">
          <source>Commit the current patch to the rebase &lt;code&gt;rb&lt;/code&gt;, using &lt;code&gt;sig&lt;/code&gt; as the committer. Is silent if the commit has already been applied.</source>
          <target state="translated">Зафиксируйте текущий патч в rebase &lt;code&gt;rb&lt;/code&gt; , используя &lt;code&gt;sig&lt;/code&gt; в качестве коммиттера. Молчит, если фиксация уже была применена.</target>
        </trans-unit>
        <trans-unit id="2be9168624323737db43ee381ca8992f9a73de9d" translate="yes" xml:space="preserve">
          <source>Common Operations</source>
          <target state="translated">Общие операции</target>
        </trans-unit>
        <trans-unit id="a204c5d42b8380165174afefc8c02b676b132a6b" translate="yes" xml:space="preserve">
          <source>Communicating with Channels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66508cd4da8f90000c3284eb64d70b8945911d14" translate="yes" xml:space="preserve">
          <source>Compact WY form of the QR factorization</source>
          <target state="translated">Компактная WY форма QR-факторизации</target>
        </trans-unit>
        <trans-unit id="6bf1e82b56d17bf4bd651ed651f5ad4b9fb92d04" translate="yes" xml:space="preserve">
          <source>Compare how these results differ:</source>
          <target state="translated">Сравните,чем отличаются эти результаты:</target>
        </trans-unit>
        <trans-unit id="3937ff70415e32705a844575737929096286a5fd" translate="yes" xml:space="preserve">
          <source>Compare two strings. Return &lt;code&gt;0&lt;/code&gt; if both strings have the same length and the character at each index is the same in both strings. Return &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is a prefix of &lt;code&gt;b&lt;/code&gt;, or if &lt;code&gt;a&lt;/code&gt; comes before &lt;code&gt;b&lt;/code&gt; in alphabetical order. Return &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is a prefix of &lt;code&gt;a&lt;/code&gt;, or if &lt;code&gt;b&lt;/code&gt; comes before &lt;code&gt;a&lt;/code&gt; in alphabetical order (technically, lexicographical order by Unicode code points).</source>
          <target state="translated">Сравните две строки. Верните &lt;code&gt;0&lt;/code&gt; , если обе строки имеют одинаковую длину и символы в каждом индексе одинаковы в обеих строках. Верните &lt;code&gt;-1&lt;/code&gt; , если &lt;code&gt;a&lt;/code&gt; является префиксом &lt;code&gt;b&lt;/code&gt; , или если &lt;code&gt;a&lt;/code&gt; стоит перед &lt;code&gt;b&lt;/code&gt; в алфавитном порядке. Верните &lt;code&gt;1&lt;/code&gt; , если &lt;code&gt;b&lt;/code&gt; является префиксом &lt;code&gt;a&lt;/code&gt; , или если &lt;code&gt;b&lt;/code&gt; стоит перед &lt;code&gt;a&lt;/code&gt; в алфавитном порядке (технически, лексикографический порядок по кодовым точкам Unicode).</target>
        </trans-unit>
        <trans-unit id="058bad1213f1f21ce991a75b5be44ee324a930b6" translate="yes" xml:space="preserve">
          <source>Compared to using &lt;a href=&quot;../math/index#Base.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, directly constructing a &lt;code&gt;LinRange&lt;/code&gt; should have less overhead but won't try to correct for floating point errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3294837eea456d1d9b5c37c0aa8f59ea86b3c495" translate="yes" xml:space="preserve">
          <source>Comparison &amp;ndash; &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;asymp;&lt;/code&gt; (&lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt;), &lt;code&gt;≉&lt;/code&gt;</source>
          <target state="translated">Сравнение - &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;asymp;&lt;/code&gt; ( &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; &lt;/a&gt; ), &lt;code&gt;≉&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bfbdf2ba206862934e1703fb9dabae9ccfe529b" translate="yes" xml:space="preserve">
          <source>Comparison with &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Сравнение с &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e46ee00fde40e955c86abe019a61121e06d653c9" translate="yes" xml:space="preserve">
          <source>Comparisons</source>
          <target state="translated">Comparisons</target>
        </trans-unit>
        <trans-unit id="a1f782aa0dd22ca1d8ddd5007091a2531356eecb" translate="yes" xml:space="preserve">
          <source>Compile the given function &lt;code&gt;f&lt;/code&gt; for the argument tuple (of types) &lt;code&gt;args&lt;/code&gt;, but do not execute it.</source>
          <target state="translated">Скомпилируйте данную функцию &lt;code&gt;f&lt;/code&gt; для кортежа аргументов (типов) &lt;code&gt;args&lt;/code&gt; , но не выполняйте ее.</target>
        </trans-unit>
        <trans-unit id="d208cd655bc27c326dbf72e200351336cfc4e60e" translate="yes" xml:space="preserve">
          <source>Complement</source>
          <target state="translated">Complement</target>
        </trans-unit>
        <trans-unit id="05138c0edd56f7bbbd9cae9c6f481c62b93d161a" translate="yes" xml:space="preserve">
          <source>Completion of paths works for strings and julia's shell mode:</source>
          <target state="translated">Завершение дорожек работает для строк и режима оболочки Джулии:</target>
        </trans-unit>
        <trans-unit id="10b26b96b1c573965f14a325ef88109f84be8e3b" translate="yes" xml:space="preserve">
          <source>Complex</source>
          <target state="translated">Complex</target>
        </trans-unit>
        <trans-unit id="ff549706d081e3e60cc13e4b49b48c707d5b0c58" translate="yes" xml:space="preserve">
          <source>Complex Example</source>
          <target state="translated">Сложный пример</target>
        </trans-unit>
        <trans-unit id="c73def212afdc811169afd7e77aebfbeecb5facc" translate="yes" xml:space="preserve">
          <source>Complex Numbers</source>
          <target state="translated">Сложные Числа</target>
        </trans-unit>
        <trans-unit id="d92056b9511d12d7ca9a02729b4db7f33b444189" translate="yes" xml:space="preserve">
          <source>Complex and Rational Numbers</source>
          <target state="translated">Сложные и рациональные числа</target>
        </trans-unit>
        <trans-unit id="4bf180d1d0870c204edb37eb372ac0df5d17b6dd" translate="yes" xml:space="preserve">
          <source>Complex blocks:</source>
          <target state="translated">Сложные блоки:</target>
        </trans-unit>
        <trans-unit id="0a73edd8fc9653ee436727fd08c0b9f3b06b1113" translate="yes" xml:space="preserve">
          <source>Complex method &quot;cascades&quot; with default arguments</source>
          <target state="translated">Сложный метод &quot;каскадирует&quot; с аргументами по умолчанию</target>
        </trans-unit>
        <trans-unit id="f9ed4ba22fe6a41d861b48b53689d9f5e1620b3b" translate="yes" xml:space="preserve">
          <source>Complex number type with real and imaginary part of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Сложный тип номер с реальной и мнимой частью типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="b4dd6b3b31c6eea3e9660b73bc2f3101abdfba71" translate="yes" xml:space="preserve">
          <source>Compose functions: i.e. &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; means &lt;code&gt;f(g(args...))&lt;/code&gt;. The &lt;code&gt;∘&lt;/code&gt; symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing &lt;code&gt;\circ&amp;lt;tab&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Составьте функции: т.е. &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; означает &lt;code&gt;f(g(args...))&lt;/code&gt; . Символ &lt;code&gt;∘&lt;/code&gt; можно ввести в Julia REPL (и в большинство редакторов, настроенных соответствующим образом), набрав &lt;code&gt;\circ&amp;lt;tab&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bf0ab10fb9860e23b1ca89e4313be7fafb258f7" translate="yes" xml:space="preserve">
          <source>Composite Types</source>
          <target state="translated">Композитные типы</target>
        </trans-unit>
        <trans-unit id="df2490ae2d6c4446ef7afd32a3da2e5ee7b69ac4" translate="yes" xml:space="preserve">
          <source>Composite objects declared with &lt;code&gt;struct&lt;/code&gt; are &lt;em&gt;immutable&lt;/em&gt;; they cannot be modified after construction. This may seem odd at first, but it has several advantages:</source>
          <target state="translated">Составные объекты, объявленные с помощью &lt;code&gt;struct&lt;/code&gt; , &lt;em&gt;неизменяемы&lt;/em&gt; ; они не могут быть изменены после постройки. Сначала это может показаться странным, но у этого есть несколько преимуществ:</target>
        </trans-unit>
        <trans-unit id="01e0dcd858e537fe0307f2358a312f03c6681c12" translate="yes" xml:space="preserve">
          <source>Composite types are introduced with the &lt;a href=&quot;../../base/base/index#struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; keyword followed by a block of field names, optionally annotated with types using the &lt;code&gt;::&lt;/code&gt; operator:</source>
          <target state="translated">Составные типы вводятся с &lt;a href=&quot;../../base/base/index#struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; ключевым словом , за которым следует блок имен полей, необязательно аннотированный с типами , используя &lt;code&gt;::&lt;/code&gt; оператора:</target>
        </trans-unit>
        <trans-unit id="9189e65c24f2bdb8de9b12a05127190c54ae9a3c" translate="yes" xml:space="preserve">
          <source>Composite types such as &lt;code&gt;struct&lt;/code&gt; in C or &lt;code&gt;TYPE&lt;/code&gt; in Fortran90 (or &lt;code&gt;STRUCTURE&lt;/code&gt; / &lt;code&gt;RECORD&lt;/code&gt; in some variants of F77), can be mirrored in Julia by creating a &lt;code&gt;struct&lt;/code&gt; definition with the same field layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5701f0731819052a01bc826ae56db27fca5211d9" translate="yes" xml:space="preserve">
          <source>Composite types, aka &lt;code&gt;struct&lt;/code&gt; in C or &lt;code&gt;TYPE&lt;/code&gt; in Fortran90 (or &lt;code&gt;STRUCTURE&lt;/code&gt; / &lt;code&gt;RECORD&lt;/code&gt; in some variants of F77), can be mirrored in Julia by creating a &lt;code&gt;struct&lt;/code&gt; definition with the same field layout.</source>
          <target state="translated">Составные типы, также известные как &lt;code&gt;struct&lt;/code&gt; в C или &lt;code&gt;TYPE&lt;/code&gt; в Fortran90 (или &lt;code&gt;STRUCTURE&lt;/code&gt; / &lt;code&gt;RECORD&lt;/code&gt; в некоторых вариантах F77), могут быть отражены в Julia путем создания определения &lt;code&gt;struct&lt;/code&gt; с тем же расположением полей.</target>
        </trans-unit>
        <trans-unit id="7544d508f3b0902a380eab3d1ae0e5d8d3c1b60c" translate="yes" xml:space="preserve">
          <source>CompositeException</source>
          <target state="translated">CompositeException</target>
        </trans-unit>
        <trans-unit id="79e03922c06b260c57343358b29b8c08b337403a" translate="yes" xml:space="preserve">
          <source>Composition of one function ∘(f) requires at least Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29eeb6459e95f17b9e773f8892492e90000d531" translate="yes" xml:space="preserve">
          <source>Compound Expressions</source>
          <target state="translated">Сложные выражения</target>
        </trans-unit>
        <trans-unit id="3c63c3a24b2a5e684ce3eb80765c227218a808f0" translate="yes" xml:space="preserve">
          <source>Compound methods are provided, as they provide a measure of efficiency if multiple fields are needed at the same time:</source>
          <target state="translated">Предусмотрены комбинированные методы,так как они обеспечивают меру эффективности в случае необходимости одновременного использования нескольких полей:</target>
        </trans-unit>
        <trans-unit id="ed2ff637c10fb1755e29c0eb2376d67d8e5a91b4" translate="yes" xml:space="preserve">
          <source>Comprehensions</source>
          <target state="translated">Comprehensions</target>
        </trans-unit>
        <trans-unit id="c10ef362f781785063bbb997cd5031a5191aade1" translate="yes" xml:space="preserve">
          <source>Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand, instead of allocating an array and storing them in advance (see &lt;a href=&quot;#Iteration&quot;&gt;Iteration&lt;/a&gt;). For example, the following expression sums a series without allocating memory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e547d2519645c376aaf30ba92bb6080596e3ef5" translate="yes" xml:space="preserve">
          <source>Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand, instead of allocating an array and storing them in advance (see &lt;a href=&quot;#Iteration-1&quot;&gt;Iteration&lt;/a&gt;). For example, the following expression sums a series without allocating memory:</source>
          <target state="translated">Пояснения также можно писать без квадратных скобок, создавая объект, известный как генератор. Этот объект можно итерировать для получения значений по запросу, вместо того, чтобы выделять массив и сохранять их заранее (см. &lt;a href=&quot;#Iteration-1&quot;&gt;Итерация&lt;/a&gt; ). Например, следующее выражение суммирует ряд без выделения памяти:</target>
        </trans-unit>
        <trans-unit id="908bf8150b71b44066207c270126a10d2c63b84b" translate="yes" xml:space="preserve">
          <source>Comprehensions provide a general and powerful way to construct arrays. Comprehension syntax is similar to set construction notation in mathematics:</source>
          <target state="translated">Понимание дает общий и мощный способ построения массивов.Синтаксис понимания аналогичен заданной в математике нотации построения:</target>
        </trans-unit>
        <trans-unit id="41931e1bad3441e4fffdabe12a675d7a10ef5fe7" translate="yes" xml:space="preserve">
          <source>Compressed Sparse Column (CSC) Sparse Matrix Storage</source>
          <target state="translated">Сжатая разделенная колонка (CSC)Хранение разделенных матриц</target>
        </trans-unit>
        <trans-unit id="df6e999370e627bd7fb17556cf85a2f9046d57dd" translate="yes" xml:space="preserve">
          <source>Compute $10^x$.</source>
          <target state="translated">Вычислите 10^x$.</target>
        </trans-unit>
        <trans-unit id="3440d15eee03e7b747a1a78d06bc04de26352e6b" translate="yes" xml:space="preserve">
          <source>Compute $\cos(\pi x) / x - \sin(\pi x) / (\pi x^2)$ if $x \neq 0$, and $0$ if $x = 0$. This is the derivative of &lt;code&gt;sinc(x)&lt;/code&gt;.</source>
          <target state="translated">Вычислить $ \ cos (\ pi x) / x - \ sin (\ pi x) / (\ pi x ^ 2) $, если $ x \ neq 0 $, и $ 0 $, если $ x = 0 $. Это производная от &lt;code&gt;sinc(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="641b97c82ee25690f10e6e7742dc51e5d15732ca" translate="yes" xml:space="preserve">
          <source>Compute $\cos(\pi x)$ more accurately than &lt;code&gt;cos(pi*x)&lt;/code&gt;, especially for large &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Вычислить $ \ cos (\ pi x) $ более точно, чем &lt;code&gt;cos(pi*x)&lt;/code&gt; , особенно для больших &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b6e2580104ead79696c9bd035d3ea44c420e327" translate="yes" xml:space="preserve">
          <source>Compute $\sin(\pi x) / (\pi x)$ if $x \neq 0$, and $1$ if $x = 0$.</source>
          <target state="translated">Рассчитайте $\sin(\pi x)/(\pi x)$ если $x \neq 0$,и $1$ если $x=0$.</target>
        </trans-unit>
        <trans-unit id="5609ddf7e7650835bda46710354a43594cc254bb" translate="yes" xml:space="preserve">
          <source>Compute $\sin(\pi x)$ more accurately than &lt;code&gt;sin(pi*x)&lt;/code&gt;, especially for large &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Вычислить $ \ sin (\ pi x) $ более точно, чем &lt;code&gt;sin(pi*x)&lt;/code&gt; , особенно для больших &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="929982bef54c338e6e35e28527b86375aafc50c8" translate="yes" xml:space="preserve">
          <source>Compute $x \times 2^n$.</source>
          <target state="translated">Рассчитайте $x \times 2^n$.</target>
        </trans-unit>
        <trans-unit id="64de6f27384f256461bed9916267c818d5e5214a" translate="yes" xml:space="preserve">
          <source>Compute $x^p \pmod m$.</source>
          <target state="translated">Вычислите $x^p \pmod m$.</target>
        </trans-unit>
        <trans-unit id="19ceaddf89a47393966a49ad36ca860fe7e80321" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;A / B&lt;/code&gt; in-place and overwriting &lt;code&gt;A&lt;/code&gt; to store the result.</source>
          <target state="translated">Вычислить &lt;code&gt;A / B&lt;/code&gt; на месте и перезаписать &lt;code&gt;A&lt;/code&gt; , чтобы сохранить результат.</target>
        </trans-unit>
        <trans-unit id="7f0218a9f1bc487c2b5096445bf17474b3168d25" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;A \ B&lt;/code&gt; in-place and overwriting &lt;code&gt;B&lt;/code&gt; to store the result.</source>
          <target state="translated">Вычислить &lt;code&gt;A \ B&lt;/code&gt; на месте и перезаписать &lt;code&gt;B&lt;/code&gt; , чтобы сохранить результат.</target>
        </trans-unit>
        <trans-unit id="fec3a07dc37940dceabb5be53b362461307a4c1d" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;A \ B&lt;/code&gt; in-place and store the result in &lt;code&gt;Y&lt;/code&gt;, returning the result.</source>
          <target state="translated">Вычислить &lt;code&gt;A \ B&lt;/code&gt; на месте и сохранить результат в &lt;code&gt;Y&lt;/code&gt; , вернув результат.</target>
        </trans-unit>
        <trans-unit id="98e6c5fec537a69040a39ae887c67e4d70213543" translate="yes" xml:space="preserve">
          <source>Compute a convenient factorization of &lt;code&gt;A&lt;/code&gt;, based upon the type of the input matrix. &lt;code&gt;factorize&lt;/code&gt; checks &lt;code&gt;A&lt;/code&gt; to see if it is symmetric/triangular/etc. if &lt;code&gt;A&lt;/code&gt; is passed as a generic matrix. &lt;code&gt;factorize&lt;/code&gt; checks every element of &lt;code&gt;A&lt;/code&gt; to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: &lt;code&gt;A=factorize(A); x=A\b; y=A\C&lt;/code&gt;.</source>
          <target state="translated">Вычислите удобную факторизацию &lt;code&gt;A&lt;/code&gt; в зависимости от типа входной матрицы. &lt;code&gt;factorize&lt;/code&gt; проверяет &lt;code&gt;A&lt;/code&gt; , чтобы увидеть, является ли он симметричным / треугольным и т. д. если &lt;code&gt;A&lt;/code&gt; передается как общая матрица. &lt;code&gt;factorize&lt;/code&gt; проверяет каждый элемент &lt;code&gt;A&lt;/code&gt; , чтобы проверить / исключить каждое свойство. Он замкнет короткое замыкание, как только сможет исключить симметрию / треугольную структуру. Возвращаемое значение можно повторно использовать для эффективного решения нескольких систем. Например: &lt;code&gt;A=factorize(A); x=A\b; y=A\C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="081b8630c615f09be39d92a0115c25e75916aff0" translate="yes" xml:space="preserve">
          <source>Compute a type that contains the intersection of &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt;. Usually this will be the smallest such type or one close to it.</source>
          <target state="translated">Вычислить тип , который содержит пересечение &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;S&lt;/code&gt; . Обычно это будет самый маленький из таких типов или близкий к нему.</target>
        </trans-unit>
        <trans-unit id="db62a7195b361bd27a6ab49b26fc5d995d7a85c5" translate="yes" xml:space="preserve">
          <source>Compute an &lt;code&gt;LDLt&lt;/code&gt; factorization of the real symmetric tridiagonal matrix &lt;code&gt;S&lt;/code&gt; such that &lt;code&gt;S = L*Diagonal(d)*L'&lt;/code&gt; where &lt;code&gt;L&lt;/code&gt; is a unit lower triangular matrix and &lt;code&gt;d&lt;/code&gt; is a vector. The main use of an &lt;code&gt;LDLt&lt;/code&gt; factorization &lt;code&gt;F = ldlt(S)&lt;/code&gt; is to solve the linear system of equations &lt;code&gt;Sx = b&lt;/code&gt; with &lt;code&gt;F\b&lt;/code&gt;.</source>
          <target state="translated">Вычислите &lt;code&gt;LDLt&lt;/code&gt; - факторизацию реальной симметричной трехдиагональной матрицы &lt;code&gt;S&lt;/code&gt; так , чтобы &lt;code&gt;S = L*Diagonal(d)*L'&lt;/code&gt; где &lt;code&gt;L&lt;/code&gt; - единичная нижнетреугольная матрица, а &lt;code&gt;d&lt;/code&gt; - вектор. Основное использование факторизации &lt;code&gt;LDLt&lt;/code&gt; &lt;code&gt;F = ldlt(S)&lt;/code&gt; - решение линейной системы уравнений &lt;code&gt;Sx = b&lt;/code&gt; с &lt;code&gt;F\b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c1ac6c08b678223e4887392c381e9189c7ba93b" translate="yes" xml:space="preserve">
          <source>Compute an integer hash code such that &lt;code&gt;isequal(x,y)&lt;/code&gt; implies &lt;code&gt;hash(x)==hash(y)&lt;/code&gt;. The optional second argument &lt;code&gt;h&lt;/code&gt; is a hash code to be mixed with the result.</source>
          <target state="translated">Вычислите целочисленный хэш-код, такой что &lt;code&gt;isequal(x,y)&lt;/code&gt; подразумевает &lt;code&gt;hash(x)==hash(y)&lt;/code&gt; . Необязательный второй аргумент &lt;code&gt;h&lt;/code&gt; - это хэш-код, который нужно смешать с результатом.</target>
        </trans-unit>
        <trans-unit id="79e6e6b92700158abe5cbe60e135ba2eff400933" translate="yes" xml:space="preserve">
          <source>Compute both the minimum and maximum element in a single pass, and return them as a 2-tuple.</source>
          <target state="translated">Вычислите и минимальный,и максимальный элемент за один проход и верните их в 2-х экземплярах.</target>
        </trans-unit>
        <trans-unit id="55674d923cbe36a00a2dcb12dc90008788433dbf" translate="yes" xml:space="preserve">
          <source>Compute both the minimum and maximum of &lt;code&gt;f&lt;/code&gt; applied to each element in &lt;code&gt;itr&lt;/code&gt; and return them as a 2-tuple. Only one pass is made over &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">Вычислите как минимум, так и максимум &lt;code&gt;f&lt;/code&gt; , применяемого к каждому элементу в &lt;code&gt;itr&lt;/code&gt; , и верните их как кортеж из двух элементов . Только один проход производится через &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fc034d752a929a676df33e97329f28013afb4ac" translate="yes" xml:space="preserve">
          <source>Compute cosine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">Вычислите косинус &lt;code&gt;x&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; выражается в градусах.</target>
        </trans-unit>
        <trans-unit id="2812b6470b645598b89e13c27d80693c2571602e" translate="yes" xml:space="preserve">
          <source>Compute cosine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">Вычислите косинус &lt;code&gt;x&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; выражается в радианах.</target>
        </trans-unit>
        <trans-unit id="ed29aab024d008c6bdfa953e7bd9ab905379d015" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic cosine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Вычислите гиперболический косинус &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec21c723d13f003816fe96579a7df0d489520259" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic sine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Вычислите гиперболический синус &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac3565a823d4a3efc52e74fc685ed86ae6db58a3" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic tangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Вычислить гиперболический тангенс &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3738eef2209a39b21f53d71ed43b07f931e624c" translate="yes" xml:space="preserve">
          <source>Compute sine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">Вычислите синус &lt;code&gt;x&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; в градусах.</target>
        </trans-unit>
        <trans-unit id="6cf01364af065ae849f27852465a3d3bfe52089d" translate="yes" xml:space="preserve">
          <source>Compute sine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">Вычислите синус &lt;code&gt;x&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; в радианах.</target>
        </trans-unit>
        <trans-unit id="c2d206b82e6db8e986bbbf98cbf0eb72129c224a" translate="yes" xml:space="preserve">
          <source>Compute tangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">Вычислите тангенс &lt;code&gt;x&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; выражен в градусах.</target>
        </trans-unit>
        <trans-unit id="202a93fa28b48e329210fdf808f2d1b87daa3ed4" translate="yes" xml:space="preserve">
          <source>Compute tangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">Вычислите тангенс &lt;code&gt;x&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; в радианах.</target>
        </trans-unit>
        <trans-unit id="f664081b059842ba583be8e317e1608e46a53fd3" translate="yes" xml:space="preserve">
          <source>Compute the &lt;a href=&quot;#LinearAlgebra.LQ&quot;&gt;&lt;code&gt;LQ&lt;/code&gt;&lt;/a&gt; factorization of &lt;code&gt;A&lt;/code&gt;, using the input matrix as a workspace. See also &lt;a href=&quot;#LinearAlgebra.lq&quot;&gt;&lt;code&gt;lq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dbf493148049741c81504ff6b4e5ee8560f996f" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;LQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = LQ&lt;/code&gt;.</source>
          <target state="translated">Вычислите &lt;code&gt;LQ&lt;/code&gt; - факторизацию &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = LQ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17538b08e9c154c3f5dd62072c8fa0ea05f963fc" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;LQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = LQ&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Вычислите &lt;code&gt;LQ&lt;/code&gt; - факторизацию &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = LQ&lt;/code&gt; . &lt;code&gt;tau&lt;/code&gt; содержит скаляры, которые параметризуют элементарные отражатели факторизации. &lt;code&gt;tau&lt;/code&gt; должны иметь длину , превышающую или равную наименьшему измерению &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ad780cc4431af9be511082a782160bff6da4c65" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QL&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QL&lt;/code&gt;.</source>
          <target state="translated">Вычислите &lt;code&gt;QL&lt;/code&gt; - факторизацию &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7a649b9c569a9a9a900055ad2e3e530ad769e9f" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QL&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QL&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Вычислите &lt;code&gt;QL&lt;/code&gt; - факторизацию &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QL&lt;/code&gt; . &lt;code&gt;tau&lt;/code&gt; содержит скаляры, которые параметризуют элементарные отражатели факторизации. &lt;code&gt;tau&lt;/code&gt; должны иметь длину , превышающую или равную наименьшему измерению &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73e05a032664ce6a5bb59d6231727896e0d85677" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;.</source>
          <target state="translated">Вычислите &lt;code&gt;QR&lt;/code&gt; - факторизацию &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd5939dcb4cf796b127a8200b499f432e4d64b40" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Вычислите &lt;code&gt;QR&lt;/code&gt; - факторизацию &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QR&lt;/code&gt; . &lt;code&gt;tau&lt;/code&gt; содержит скаляры, которые параметризуют элементарные отражатели факторизации. &lt;code&gt;tau&lt;/code&gt; должны иметь длину , превышающую или равную наименьшему измерению &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14220f2b6c0b60f7df0cde02fa4f1c544028c987" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;RQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = RQ&lt;/code&gt;.</source>
          <target state="translated">Вычислите &lt;code&gt;RQ&lt;/code&gt; - факторизацию &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = RQ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="861e3be13c33c99b622d41916c8e070553b49f73" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;RQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = RQ&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Вычислите &lt;code&gt;RQ&lt;/code&gt; - факторизацию &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = RQ&lt;/code&gt; . &lt;code&gt;tau&lt;/code&gt; содержит скаляры, которые параметризуют элементарные отражатели факторизации. &lt;code&gt;tau&lt;/code&gt; должны иметь длину , превышающую или равную наименьшему измерению &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1941b58e1c7afe2d3c77d99152574462461df1db" translate="yes" xml:space="preserve">
          <source>Compute the Bunch-Kaufman &lt;a href=&quot;#footnote-Bunch1977&quot;&gt;[Bunch1977]&lt;/a&gt; factorization of a &lt;code&gt;Symmetric&lt;/code&gt; or &lt;code&gt;Hermitian&lt;/code&gt; matrix &lt;code&gt;A&lt;/code&gt; as $P'*U*D*U'*P$ or $P'*L*D*L'*P$, depending on which triangle is stored in &lt;code&gt;A&lt;/code&gt;, and return a &lt;code&gt;BunchKaufman&lt;/code&gt; object. Note that if &lt;code&gt;A&lt;/code&gt; is complex symmetric then &lt;code&gt;U'&lt;/code&gt; and &lt;code&gt;L'&lt;/code&gt; denote the unconjugated transposes, i.e. &lt;code&gt;transpose(U)&lt;/code&gt; and &lt;code&gt;transpose(L)&lt;/code&gt;.</source>
          <target state="translated">Вычислите факторизацию Банча-Кауфмана &lt;a href=&quot;#footnote-Bunch1977&quot;&gt;[Bunch1977] &lt;/a&gt; &lt;code&gt;Symmetric&lt;/code&gt; или &lt;code&gt;Hermitian&lt;/code&gt; матрицы &lt;code&gt;A&lt;/code&gt; как $ P '* U * D * U' * P $ или $ P '* L * D * L' * P $, в зависимости от того, какой треугольник хранится в &lt;code&gt;A&lt;/code&gt; , и вернуть объект &lt;code&gt;BunchKaufman&lt;/code&gt; . Обратите внимание, что если &lt;code&gt;A&lt;/code&gt; является комплексно-симметричным, то &lt;code&gt;U'&lt;/code&gt; и &lt;code&gt;L'&lt;/code&gt; обозначают несопряженные транспозиции, то есть &lt;code&gt;transpose(U)&lt;/code&gt; и &lt;code&gt;transpose(L)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a24a7193e031893d923ed86bc5db45171f4b4182" translate="yes" xml:space="preserve">
          <source>Compute the Bunch-Kaufman &lt;sup&gt;&lt;a href=&quot;#footnote-Bunch1977&quot; id=&quot;citeref-Bunch1977&quot;&gt;[Bunch1977]&lt;/a&gt;&lt;/sup&gt; factorization of a symmetric or Hermitian matrix &lt;code&gt;A&lt;/code&gt; as &lt;code&gt;P'*U*D*U'*P&lt;/code&gt; or &lt;code&gt;P'*L*D*L'*P&lt;/code&gt;, depending on which triangle is stored in &lt;code&gt;A&lt;/code&gt;, and return a &lt;a href=&quot;#LinearAlgebra.BunchKaufman&quot;&gt;&lt;code&gt;BunchKaufman&lt;/code&gt;&lt;/a&gt; object. Note that if &lt;code&gt;A&lt;/code&gt; is complex symmetric then &lt;code&gt;U'&lt;/code&gt; and &lt;code&gt;L'&lt;/code&gt; denote the unconjugated transposes, i.e. &lt;code&gt;transpose(U)&lt;/code&gt; and &lt;code&gt;transpose(L)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adc6e0822f31506444311768e4f6ded0f9f1c41" translate="yes" xml:space="preserve">
          <source>Compute the CRC-32c checksum of the given &lt;code&gt;data&lt;/code&gt;, which can be an &lt;code&gt;Array{UInt8}&lt;/code&gt;, a contiguous subarray thereof, or a &lt;code&gt;String&lt;/code&gt;. Optionally, you can pass a starting &lt;code&gt;crc&lt;/code&gt; integer to be mixed in with the checksum. The &lt;code&gt;crc&lt;/code&gt; parameter can be used to compute a checksum on data divided into chunks: performing &lt;code&gt;crc32c(data2, crc32c(data1))&lt;/code&gt; is equivalent to the checksum of &lt;code&gt;[data1; data2]&lt;/code&gt;. (Technically, a little-endian checksum is computed.)</source>
          <target state="translated">Вычислить контрольную сумму CRC-32c заданных &lt;code&gt;data&lt;/code&gt; , которая может быть &lt;code&gt;Array{UInt8}&lt;/code&gt; , его непрерывным подмассивом или &lt;code&gt;String&lt;/code&gt; . При желании вы можете передать начальное целое число &lt;code&gt;crc&lt;/code&gt; , которое будет смешано с контрольной суммой. Параметр &lt;code&gt;crc&lt;/code&gt; может использоваться для вычисления контрольной суммы данных, разделенных на блоки: выполнение &lt;code&gt;crc32c(data2, crc32c(data1))&lt;/code&gt; эквивалентно контрольной сумме &lt;code&gt;[data1; data2]&lt;/code&gt; . (Технически вычисляется обратная контрольная сумма.)</target>
        </trans-unit>
        <trans-unit id="451fab004d9b252be766b8c8da0ec9401bcb730d" translate="yes" xml:space="preserve">
          <source>Compute the Cholesky factorization of a dense symmetric positive definite matrix &lt;code&gt;A&lt;/code&gt; and return a &lt;a href=&quot;#LinearAlgebra.Cholesky&quot;&gt;&lt;code&gt;Cholesky&lt;/code&gt;&lt;/a&gt; factorization. The matrix &lt;code&gt;A&lt;/code&gt; can either be a &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt; or a &lt;em&gt;perfectly&lt;/em&gt; symmetric or Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt;. The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F&lt;/code&gt; with: &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;. The following functions are available for &lt;code&gt;Cholesky&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt;&lt;code&gt;logdet&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
