<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="81f2145109807b12c478f9428b7d01692494e503" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_cb&lt;/code&gt;: An optional callback used to create the &lt;a href=&quot;#LibGit2.GitRemote&quot;&gt;&lt;code&gt;GitRemote&lt;/code&gt;&lt;/a&gt; before making the clone from it.</source>
          <target state="translated">&lt;code&gt;remote_cb&lt;/code&gt; : дополнительный обратный вызов, используемый для создания &lt;a href=&quot;#LibGit2.GitRemote&quot;&gt; &lt;code&gt;GitRemote&lt;/code&gt; &lt;/a&gt; перед созданием из него клона.</target>
        </trans-unit>
        <trans-unit id="08210342f9819d0a52928951c3cf701a468f0a0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_cb_payload&lt;/code&gt;: The payload for the remote callback.</source>
          <target state="translated">&lt;code&gt;remote_cb_payload&lt;/code&gt; : полезная нагрузка для удаленного обратного вызова.</target>
        </trans-unit>
        <trans-unit id="0b84ddfb974082fe30d2fdbc1437b3f617f6a788" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteref_id&lt;/code&gt; is a low-level API which returns a &lt;code&gt;RRID&lt;/code&gt; object that wraps &lt;code&gt;whence&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; values of a remote reference.</source>
          <target state="translated">&lt;code&gt;remoteref_id&lt;/code&gt; - это низкоуровневый API, который возвращает объект &lt;code&gt;RRID&lt;/code&gt; , который обертывает значения &lt;code&gt;whence&lt;/code&gt; и &lt;code&gt;id&lt;/code&gt; удаленной ссылки.</target>
        </trans-unit>
        <trans-unit id="8507e85a94a6cd1cb8268156f73c57a12952c455" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt;: the URL of &lt;code&gt;remote&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt; : URL-адрес &lt;code&gt;remote&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af1618648ef5cfe8bc793d28a4d2646feb098771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt;: the URL of &lt;code&gt;remote&lt;/code&gt;. If not specified, will be assumed based on the given name of &lt;code&gt;remote&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt; : URL-адрес &lt;code&gt;remote&lt;/code&gt; . Если не указано, будет предполагаться на основе заданного имени &lt;code&gt;remote&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="609e8e82126a8aeb5967ff81fbb3ef2aa24bd998" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rename_threshold&lt;/code&gt;: how similar two files must to consider one a rename of the other. This is an integer that sets the percentage similarity. The default is 50.</source>
          <target state="translated">&lt;code&gt;rename_threshold&lt;/code&gt; : насколько похожие два файла должны рассматривать один как переименование другого. Это целое число, задающее процентное сходство. По умолчанию - 50.</target>
        </trans-unit>
        <trans-unit id="e2a99cf9dace7b445312c1ed6b449e6eaff870cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repository_cb&lt;/code&gt;: An optional callback which will be used to create the &lt;em&gt;new&lt;/em&gt; repository into which the clone is made.</source>
          <target state="translated">&lt;code&gt;repository_cb&lt;/code&gt; : необязательный обратный вызов, который будет использоваться для создания &lt;em&gt;нового&lt;/em&gt; репозитория, в котором будет сделан клон.</target>
        </trans-unit>
        <trans-unit id="69b143fd85b9454789782c1eb3c8d602eb3b9b29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repository_cb_payload&lt;/code&gt;: The payload for the repository callback.</source>
          <target state="translated">&lt;code&gt;repository_cb_payload&lt;/code&gt; : полезная нагрузка для обратного вызова репозитория.</target>
        </trans-unit>
        <trans-unit id="5023aea211818a0760fb42fd29ef6a5a0289aa0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repr&lt;/code&gt; returns the output of &lt;code&gt;show&lt;/code&gt; as a string.</source>
          <target state="translated">&lt;code&gt;repr&lt;/code&gt; возвращает вывод &lt;code&gt;show&lt;/code&gt; в виде строки.</target>
        </trans-unit>
        <trans-unit id="7ff0db60e6e9b0f8032c3c60e6fb8dfbe0818b4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return x&lt;/code&gt; causes the enclosing function to exit early, passing the given value &lt;code&gt;x&lt;/code&gt; back to its caller. &lt;code&gt;return&lt;/code&gt; by itself with no value is equivalent to &lt;code&gt;return nothing&lt;/code&gt; (see &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;return x&lt;/code&gt; заставляет включающую функцию выйти раньше, передавая заданное значение &lt;code&gt;x&lt;/code&gt; обратно вызывающей стороне. Сам по себе &lt;code&gt;return&lt;/code&gt; без значения эквивалентен отсутствию &lt;code&gt;return nothing&lt;/code&gt; ( &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; не вижу ).</target>
        </trans-unit>
        <trans-unit id="502272392029d8c1210ca8442ce973a51a80b2c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="45cec38c32f578811af123b4529c8927598f6954" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rewrite_notes_ref&lt;/code&gt;: name of the reference to notes to use to rewrite the commit notes as the rebase is finished.</source>
          <target state="translated">&lt;code&gt;rewrite_notes_ref&lt;/code&gt; : имя ссылки на примечания, которое будет использоваться для перезаписи примечаний к фиксации по завершении перебазирования.</target>
        </trans-unit>
        <trans-unit id="ee12f97ff2f79dfd78b89cda4ab0e281561a61af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;right_justify&lt;/code&gt; is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).</source>
          <target state="translated">&lt;code&gt;right_justify&lt;/code&gt; - это целочисленный столбец, в котором метаданные журнала выровнены по правому краю . По умолчанию - ноль (метаданные размещаются в отдельной строке).</target>
        </trans-unit>
        <trans-unit id="b331dc2677ed78e2b46e6f7e4f15579bf2430629" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.ceil&quot;&gt;&lt;code&gt;ceil&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; с использованием этого режима округления является псевдонимом для &lt;a href=&quot;#Base.ceil&quot;&gt; &lt;code&gt;ceil&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b82694560cc17d932ed74b0e5a76969bf6a0851b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.floor&quot;&gt;&lt;code&gt;floor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; с использованием этого режима округления является псевдонимом для &lt;a href=&quot;#Base.floor&quot;&gt; &lt;code&gt;floor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6064aeb0303df233165e5be4f2a31b0e19b1991" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.trunc&quot;&gt;&lt;code&gt;trunc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; с использованием этого режима округления является псевдонимом для &lt;a href=&quot;#Base.trunc&quot;&gt; &lt;code&gt;trunc&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e4f32289fec3fa365e6110d93226bbad2f67917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; allows the &lt;code&gt;.&lt;/code&gt; modifier to match newlines.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; позволяет &lt;code&gt;.&lt;/code&gt; модификатор для соответствия новой строке.</target>
        </trans-unit>
        <trans-unit id="f9a850a68210f1321a24f7f9f7751b659bc2b984" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sB&lt;/code&gt; has been tagged as a matrix that's (real) symmetric, so for later operations we might perform on it, such as eigenfactorization or computing matrix-vector products, efficiencies can be found by only referencing half of it. For example:</source>
          <target state="translated">&lt;code&gt;sB&lt;/code&gt; был помечен как (действительная) симметричная матрица, поэтому для последующих операций, которые мы могли бы выполнить с ней, таких как собственное разложение или вычисление произведения матрица-вектор, эффективность можно определить, указав только половину ее. Например:</target>
        </trans-unit>
        <trans-unit id="ccc484e194571496ce1eda5190c7d8120eefadd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scheme::AbstractString=&quot;&quot;&lt;/code&gt;: the URL scheme which identifies the protocol to be used. For HTTP use &quot;http&quot;, SSH use &quot;ssh&quot;, etc. When &lt;code&gt;scheme&lt;/code&gt; is not provided the output format will be &quot;ssh&quot; but using the scp-like syntax.</source>
          <target state="translated">&lt;code&gt;scheme::AbstractString=&quot;&quot;&lt;/code&gt; : схема URL, которая определяет используемый протокол. Для HTTP используйте &amp;laquo;http&amp;raquo;, SSH используйте &amp;laquo;ssh&amp;raquo; и т. Д. Если &lt;code&gt;scheme&lt;/code&gt; не указана, формат вывода будет &amp;laquo;ssh&amp;raquo;, но с использованием синтаксиса, подобного scp.</target>
        </trans-unit>
        <trans-unit id="93b2806e781d6fca17b7143cb112498a0b664a1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scroll::Symbol=:na&lt;/code&gt;: If &lt;code&gt;:wrap&lt;/code&gt; then wrap the cursor around top and bottom, if :&lt;code&gt;nowrap&lt;/code&gt; do not wrap cursor</source>
          <target state="translated">&lt;code&gt;scroll::Symbol=:na&lt;/code&gt; : If &lt;code&gt;:wrap&lt;/code&gt; тогда обтекать курсор сверху и снизу, if: &lt;code&gt;nowrap&lt;/code&gt; не переносить курсор</target>
        </trans-unit>
        <trans-unit id="4b280689ba075d50a8bf44f6918ee06bdd7f1ee9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_head::Bool=true&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, after the branch creation finishes the branch head will be set as the HEAD of &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_head::Bool=true&lt;/code&gt; : если &lt;code&gt;true&lt;/code&gt; , то после завершения создания ветки заголовок ветки будет установлен как HEAD &lt;code&gt;repo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cc61ed461b5dbaa13fd1fd838ddca4a2542572c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_zero_subnormals(true)&lt;/code&gt; can speed up some computations on some hardware. However, it can break identities such as &lt;code&gt;(x-y==0) == (x==y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_zero_subnormals(true)&lt;/code&gt; может ускорить некоторые вычисления на некотором оборудовании. Однако он может нарушить такие идентификаторы, как &lt;code&gt;(x-y==0) == (x==y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c2e75ceadb77395d5345eca4bc8bc47dec72358" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shaxxx()&lt;/code&gt; takes &lt;code&gt;AbstractString&lt;/code&gt; and array-like objects (&lt;code&gt;NTuple&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt;) with elements of type &lt;code&gt;UInt8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shaxxx()&lt;/code&gt; принимает &lt;code&gt;AbstractString&lt;/code&gt; и объекты &lt;code&gt;NTuple&lt;/code&gt; &lt;code&gt;Array&lt;/code&gt; ( NTuple и Array ) с элементами типа &lt;code&gt;UInt8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4ec3df759f8c80bc7761d61c8e5aa7aa26b8f04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show&lt;/code&gt;: a flag for which files to examine and in which order. The default is &lt;code&gt;Consts.STATUS_SHOW_INDEX_AND_WORKDIR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;show&lt;/code&gt; : флаг, какие файлы проверять и в каком порядке. По умолчанию - &lt;code&gt;Consts.STATUS_SHOW_INDEX_AND_WORKDIR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a32266a7567a6361fd0030ea46dc886158ce573e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show_commit_oid_as_fallback&lt;/code&gt;: if no matching reference can be found which describes a commit, show the commit's &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; instead of throwing an error (the default behavior).</source>
          <target state="translated">&lt;code&gt;show_commit_oid_as_fallback&lt;/code&gt; : если не может быть найдена соответствующая ссылка, описывающая фиксацию, показать &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; фиксации&lt;/a&gt; вместо выдачи ошибки (поведение по умолчанию).</target>
        </trans-unit>
        <trans-unit id="321d9936b85b091cfbe32e4ed333aa1019f70153" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show_limited&lt;/code&gt; limits the printing of large data structures to something which can fit on the screen by setting the &lt;code&gt;:limit&lt;/code&gt;&lt;code&gt;IOContext&lt;/code&gt; key during formatting.</source>
          <target state="translated">&lt;code&gt;show_limited&lt;/code&gt; ограничивает печать больших структур данных чем-то, что может поместиться на экране, путем установки ключа &lt;code&gt;:limit&lt;/code&gt; &lt;code&gt;IOContext&lt;/code&gt; во время форматирования.</target>
        </trans-unit>
        <trans-unit id="eb77d8781dd9b346f7972d289b6b8d6656b27a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sig::Signature=Signature(repo)&lt;/code&gt;: the tagger's signature.</source>
          <target state="translated">&lt;code&gt;sig::Signature=Signature(repo)&lt;/code&gt; : подпись теггера.</target>
        </trans-unit>
        <trans-unit id="d753c86afdec45711bc5c02d99a4e474cd4a4e96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;similarity&lt;/code&gt;: Used to indicate if a file has been renamed or copied.</source>
          <target state="translated">&lt;code&gt;similarity&lt;/code&gt; : используется, чтобы указать, был ли файл переименован или скопирован.</target>
        </trans-unit>
        <trans-unit id="ff10e5c77568c1b5f3ae641f11c70c8c65f4ba74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size(A) == size(B) || throw(DimensionMismatch(&quot;Size of A not equal to size of B&quot;))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;size(A) == size(B) || throw(DimensionMismatch(&quot;Size of A not equal to size of B&quot;))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d10f869613b60c50f32f40c9033fbe46c6290e23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt;: the size of the item in bytes.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; : размер элемента в байтах.</target>
        </trans-unit>
        <trans-unit id="5477a94f16fd95259abdf4ec79e87fa8ddde3d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizehint&lt;/code&gt;: suggests a capacity of the buffer (&lt;code&gt;data&lt;/code&gt; must implement &lt;code&gt;sizehint!(data, size)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;sizehint&lt;/code&gt; : предлагает емкость буфера ( &lt;code&gt;data&lt;/code&gt; должны реализовывать &lt;code&gt;sizehint!(data, size)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e3b3de6bcf724e5eb7a7cd993fb64be110536dd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortedby&lt;/code&gt; &amp;ndash; Controls the order in &lt;code&gt;:flat&lt;/code&gt; format. &lt;code&gt;:filefuncline&lt;/code&gt; (default) sorts by the source line, whereas &lt;code&gt;:count&lt;/code&gt; sorts in order of number of collected samples.</source>
          <target state="translated">&lt;code&gt;sortedby&lt;/code&gt; - контролирует порядок в &lt;code&gt;:flat&lt;/code&gt; формате. &lt;code&gt;:filefuncline&lt;/code&gt; (по умолчанию) сортирует по строке исходного текста , тогда как &lt;code&gt;:count&lt;/code&gt; сортирует по количеству собранных выборок.</target>
        </trans-unit>
        <trans-unit id="9ab7b3a3ab6403e446642819fa1d378711eeccfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortslices&lt;/code&gt; extends naturally to higher dimensions. E.g., if &lt;code&gt;A&lt;/code&gt; is a a 2x2x2 array, &lt;code&gt;sortslices(A, dims=3)&lt;/code&gt; will sort slices within the 3rd dimension, passing the 2x2 slices &lt;code&gt;A[:, :, 1]&lt;/code&gt; and &lt;code&gt;A[:, :, 2]&lt;/code&gt; to the comparison function. Note that while there is no default order on higher-dimensional slices, you may use the &lt;code&gt;by&lt;/code&gt; or &lt;code&gt;lt&lt;/code&gt; keyword argument to specify such an order.</source>
          <target state="translated">&lt;code&gt;sortslices&lt;/code&gt; естественным образом распространяется на более высокие измерения. Например, если &lt;code&gt;A&lt;/code&gt; представляет собой массив 2x2x2, &lt;code&gt;sortslices(A, dims=3)&lt;/code&gt; будет сортировать фрагменты в 3-м измерении, передавая фрагменты 2x2 &lt;code&gt;A[:, :, 1]&lt;/code&gt; и &lt;code&gt;A[:, :, 2]&lt;/code&gt; в функцию сравнения. , Обратите внимание, что хотя для многомерных срезов нет порядка по умолчанию, вы можете использовать аргумент ключевого слова &lt;code&gt;by&lt;/code&gt; или &lt;code&gt;lt&lt;/code&gt; , чтобы указать такой порядок.</target>
        </trans-unit>
        <trans-unit id="4951048c7ac40b21df3d0f006898cdcb02270fbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spec&lt;/code&gt; is a textual specification: see &lt;a href=&quot;https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions&quot;&gt;the git docs&lt;/a&gt; for a full list.</source>
          <target state="translated">&lt;code&gt;spec&lt;/code&gt; - это текстовая спецификация: полный список см. &lt;a href=&quot;https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions&quot;&gt;в документации git&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f04859a49c065ca19fcdcec7b6d599fc9662e04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sqrt(x)&lt;/code&gt;, &lt;code&gt;&amp;radic;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sqrt(x)&lt;/code&gt; , &lt;code&gt;&amp;radic;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1844a8d2cb0ff3056c35be76a61b67e6353a981b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sshflags&lt;/code&gt; &amp;ndash; flags to use in establishing the SSH connection</source>
          <target state="translated">&lt;code&gt;sshflags&lt;/code&gt; - флаги для использования при установлении SSH-соединения</target>
        </trans-unit>
        <trans-unit id="7a4e3e2ec23bd08e30d9fd3aad5785bb62849893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sshflags&lt;/code&gt;: specifies additional ssh options, e.g. &lt;code&gt;sshflags=`-i /home/foo/bar.pem&lt;/code&gt;`</source>
          <target state="translated">&lt;code&gt;sshflags&lt;/code&gt; : Определяет дополнительные параметры SSH, например &lt;code&gt;sshflags=`-i /home/foo/bar.pem&lt;/code&gt; `</target>
        </trans-unit>
        <trans-unit id="482b777392d5aea02672e566aeba40602b1e6b50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stable=true&lt;/code&gt;: enforce Unicode Versioning Stability</source>
          <target state="translated">&lt;code&gt;stable=true&lt;/code&gt; : обеспечить стабильность управления версиями Unicode</target>
        </trans-unit>
        <trans-unit id="a1d673d269bddb99403b4804cd814dccb535526a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_worker&lt;/code&gt; is an internal function which is the default entry point for worker processes connecting via TCP/IP. It sets up the process as a Julia cluster worker.</source>
          <target state="translated">&lt;code&gt;start_worker&lt;/code&gt; - это внутренняя функция, которая является точкой входа по умолчанию для рабочих процессов, подключающихся через TCP / IP. Он настраивает процесс как рабочий кластера Julia.</target>
        </trans-unit>
        <trans-unit id="0d39313a7b53c31deacd642a6f563eef785766ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startswith&lt;/code&gt; does not compile the anchoring into the regular expression, but instead passes the anchoring as &lt;code&gt;match_option&lt;/code&gt; to PCRE. If compile time is amortized, &lt;code&gt;occursin(r&quot;^...&quot;, s)&lt;/code&gt; is faster than &lt;code&gt;startswith(s, r&quot;...&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;startswith&lt;/code&gt; не компилирует привязку в регулярное выражение, а вместо этого передает привязку как &lt;code&gt;match_option&lt;/code&gt; в PCRE. Если во время компиляции амортизируется, &lt;code&gt;occursin(r&quot;^...&quot;, s)&lt;/code&gt; быстрее , чем &lt;code&gt;startswith(s, r&quot;...&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15339811e6d33db9e7897efcdd503d8c3b49eea3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt;: One of &lt;code&gt;Consts.DELTA_STATUS&lt;/code&gt;, indicating whether the file has been added/modified/deleted.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; : один из &lt;code&gt;Consts.DELTA_STATUS&lt;/code&gt; , указывающий, был ли файл добавлен / изменен / удален.</target>
        </trans-unit>
        <trans-unit id="593409fff5972acd2d5fc66532b51e6073c0482a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt;: contains the status flags for the file, indicating if it is current, or has been changed in some way in the index or work tree.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; : содержит флаги состояния для файла, указывающие, является ли он текущим или каким-либо образом был изменен в индексе или рабочем дереве.</target>
        </trans-unit>
        <trans-unit id="7130447a57fb8968eccd9497b959129d184d5ebe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stop&lt;/code&gt; as a positional argument requires at least Julia 1.1.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; как позиционный аргумент требует как минимум Юлии 1.1.</target>
        </trans-unit>
        <trans-unit id="d0f59bf23005820bb215225956bc86d1eabe9e2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stop&lt;/code&gt; may be specified as either a positional or keyword argument.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; может быть указан как позиционный аргумент или как ключевое слово.</target>
        </trans-unit>
        <trans-unit id="e12b59a2409adf775bb3ba9ebdfd0542b9cb0251" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stream&lt;/code&gt; must be a &lt;code&gt;TTY&lt;/code&gt;, a &lt;code&gt;Pipe&lt;/code&gt;, or a socket.</source>
          <target state="translated">&lt;code&gt;stream&lt;/code&gt; должен быть &lt;code&gt;TTY&lt;/code&gt; , &lt;code&gt;Pipe&lt;/code&gt; или сокетом.</target>
        </trans-unit>
        <trans-unit id="92d2aefd112ecb4c0e212056a16040530a1c9949" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; should usually not be defined directly. Instead, define a method &lt;code&gt;print(io::IO, x::MyType)&lt;/code&gt;. If &lt;code&gt;string(x)&lt;/code&gt; for a certain type needs to be highly efficient, then it may make sense to add a method to &lt;code&gt;string&lt;/code&gt; and define &lt;code&gt;print(io::IO, x::MyType) = print(io, string(x))&lt;/code&gt; to ensure the functions are consistent.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; обычно не следует определять напрямую. Вместо этого определите метод &lt;code&gt;print(io::IO, x::MyType)&lt;/code&gt; . Если &lt;code&gt;string(x)&lt;/code&gt; для определенного типа должна быть высокоэффективной, тогда может иметь смысл добавить метод в &lt;code&gt;string&lt;/code&gt; и определить &lt;code&gt;print(io::IO, x::MyType) = print(io, string(x))&lt;/code&gt; чтобы обеспечить согласованность функций.</target>
        </trans-unit>
        <trans-unit id="3a0a1bd4f366a04445c7d0b5b5d4912e1e3e7619" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strings&lt;/code&gt; can be any iterable over elements &lt;code&gt;x&lt;/code&gt; which are convertible to strings via &lt;code&gt;print(io::IOBuffer, x)&lt;/code&gt;. &lt;code&gt;strings&lt;/code&gt; will be printed to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strings&lt;/code&gt; могут быть любыми итерациями по элементам &lt;code&gt;x&lt;/code&gt; , которые можно преобразовать в строки с помощью &lt;code&gt;print(io::IOBuffer, x)&lt;/code&gt; . &lt;code&gt;strings&lt;/code&gt; будут напечатаны в &lt;code&gt;io&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03d10d2948fe43796bacbfe30f1e399090a85dee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripcc=true&lt;/code&gt;: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified</source>
          <target state="translated">&lt;code&gt;stripcc=true&lt;/code&gt; : убрать управляющие символы; горизонтальные табуляции и подача форм преобразуются в пробелы; новые строки также преобразуются в пробелы, если не указан флаг преобразования новой строки</target>
        </trans-unit>
        <trans-unit id="348e9291c5b543afc5d72a87490213ecd8d4eb07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripignore=true&lt;/code&gt;: strip Unicode's &quot;default ignorable&quot; characters (e.g. the soft hyphen or the left-to-right marker)</source>
          <target state="translated">&lt;code&gt;stripignore=true&lt;/code&gt; : убрать &amp;laquo;игнорируемые по умолчанию&amp;raquo; символы Unicode (например, мягкий дефис или маркер слева направо)</target>
        </trans-unit>
        <trans-unit id="ea8af5006099bc8365d7c8c2016e824fc2c530ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripmark=true&lt;/code&gt;: strip diacritical marks (e.g. accents)</source>
          <target state="translated">&lt;code&gt;stripmark=true&lt;/code&gt; : убрать диакритические знаки (например, акценты)</target>
        </trans-unit>
        <trans-unit id="152fe4fc303b0a193c1b742fe9f4ede9b98c674b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct T&lt;/code&gt; (including typedef to a struct)</source>
          <target state="translated">&lt;code&gt;struct T&lt;/code&gt; (включая typedef для структуры)</target>
        </trans-unit>
        <trans-unit id="c56e50a4a868cc2df17e58d4812fe396996de54a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="ba2cc4e0e66a121d0318b71f9b1e31d8945e78e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt;s are immutable by default; an instance of one of these types cannot be modified after construction. Use &lt;a href=&quot;#mutable%20struct&quot;&gt;&lt;code&gt;mutable struct&lt;/code&gt;&lt;/a&gt; instead to declare a type whose instances can be modified.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; s по умолчанию неизменяемы; экземпляр одного из этих типов не может быть изменен после построения. Вместо этого используйте &lt;a href=&quot;#mutable%20struct&quot;&gt; &lt;code&gt;mutable struct&lt;/code&gt; &lt;/a&gt; чтобы объявить тип, экземпляры которого можно изменять.</target>
        </trans-unit>
        <trans-unit id="13e850a37abc68848cc3b254dc2d22440b355863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;supertype operator&lt;/code&gt; (reverse of subtype operator)</source>
          <target state="translated">&lt;code&gt;supertype operator&lt;/code&gt; (обратный оператору подтипа)</target>
        </trans-unit>
        <trans-unit id="cc1fbbda24d7f513ea72de9ed041f7b7a1294c63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;supress_output::Bool=false&lt;/code&gt;: For testing. If true, menu will not be printed to console.</source>
          <target state="translated">&lt;code&gt;supress_output::Bool=false&lt;/code&gt; : для тестирования. Если true, меню не будет выводиться на консоль.</target>
        </trans-unit>
        <trans-unit id="865fee67603befce1b0155fd32588cd0eea3727b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but modifies the arguments &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in-place, instead of making copies.</source>
          <target state="translated">&lt;code&gt;svd!&lt;/code&gt; то же самое, что и &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt; , но изменяет аргументы &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; на месте, а не копирует.</target>
        </trans-unit>
        <trans-unit id="23f1a2a22493ae52966dc56d654ec748102e1aa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy.</source>
          <target state="translated">&lt;code&gt;svd!&lt;/code&gt; то же самое, что и &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt; , но экономит место за счет перезаписи ввода &lt;code&gt;A&lt;/code&gt; вместо создания копии.</target>
        </trans-unit>
        <trans-unit id="26f8b179c1cd1baf106b501d9f23e6788334be4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take!&lt;/code&gt; - take a worker from the available pool (to be used for remote function execution)</source>
          <target state="translated">&lt;code&gt;take!&lt;/code&gt; - взять воркера из доступного пула (для удаленного выполнения функции)</target>
        </trans-unit>
        <trans-unit id="a385216e2414d1ff7d0e710e07a4b2820a4c3d37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take!&lt;/code&gt; and &lt;code&gt;fetch&lt;/code&gt; (which retrieves but does not remove the value) on a closed channel successfully return any existing values until it is emptied. Continuing the above example:</source>
          <target state="translated">&lt;code&gt;take!&lt;/code&gt; и &lt;code&gt;fetch&lt;/code&gt; (которая извлекает, но не удаляет значение) в закрытом канале успешно возвращает любые существующие значения, пока он не будет очищен. Продолжая приведенный выше пример:</target>
        </trans-unit>
        <trans-unit id="f655219d63910b18e55d1c7b6d809270664f739b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target_directory&lt;/code&gt;: If not empty, checkout to this directory instead of the &lt;code&gt;workdir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;target_directory&lt;/code&gt; : Если не пустой, извлечет этот каталог вместо &lt;code&gt;workdir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73fa24ada0f915b08e5eb705950254ddb5149ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target_limit&lt;/code&gt;: the maximum number of files to compare with to look for renames. The default is 200.</source>
          <target state="translated">&lt;code&gt;target_limit&lt;/code&gt; : максимальное количество файлов для сравнения для поиска переименований. По умолчанию 200.</target>
        </trans-unit>
        <trans-unit id="8aa9f0c43ae05a2ce21f07a765041be8eb22e9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task_local_storage&lt;/code&gt; manipulates a key-value store specific to the current task.</source>
          <target state="translated">&lt;code&gt;task_local_storage&lt;/code&gt; управляет хранилищем ключей и значений, специфичным для текущей задачи.</target>
        </trans-unit>
        <trans-unit id="918476307e3ca43e70bc1905ec5bcef98a16e9bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;their_label&lt;/code&gt;: In case of conflicts, the name of &quot;their&quot; side.</source>
          <target state="translated">&lt;code&gt;their_label&lt;/code&gt; : В случае конфликтов название &amp;laquo;своей&amp;raquo; стороны.</target>
        </trans-unit>
        <trans-unit id="6030193bdbe78c187e1658db0e709e4fa8490cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology&lt;/code&gt;: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.</source>
          <target state="translated">&lt;code&gt;topology&lt;/code&gt; : определяет, как рабочие подключаются друг к другу. Отправка сообщения между неподключенными работниками приводит к ошибке.</target>
        </trans-unit>
        <trans-unit id="afb214098cd0d7a7d60c3cf6760db696f2f4fcce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:all_to_all&lt;/code&gt;: All processes are connected to each other. The default.</source>
          <target state="translated">&lt;code&gt;topology=:all_to_all&lt;/code&gt; : Все процессы связаны друг с другом. По умолчанию.</target>
        </trans-unit>
        <trans-unit id="88dec064b9bfcaf6a26453d2e661939ebc23d230" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:custom&lt;/code&gt;: The &lt;code&gt;launch&lt;/code&gt; method of the cluster manager specifies the connection topology via fields &lt;code&gt;ident&lt;/code&gt; and &lt;code&gt;connect_idents&lt;/code&gt; in &lt;code&gt;WorkerConfig&lt;/code&gt;. A worker with a cluster manager identity &lt;code&gt;ident&lt;/code&gt; will connect to all workers specified in &lt;code&gt;connect_idents&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;topology=:custom&lt;/code&gt; : Метод &lt;code&gt;launch&lt;/code&gt; диспетчера кластера определяет топологию подключения через поля &lt;code&gt;ident&lt;/code&gt; ifier и &lt;code&gt;connect_idents&lt;/code&gt; в &lt;code&gt;WorkerConfig&lt;/code&gt; . Рабочий с &lt;code&gt;ident&lt;/code&gt; менеджера кластера будет подключаться ко всем рабочим, указанным в &lt;code&gt;connect_idents&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2b734d8bcd640fb2c65bc20498e0e55564a7cf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:master_worker&lt;/code&gt;: Only the driver process, i.e. &lt;code&gt;pid&lt;/code&gt; 1 connects to the workers. The workers do not connect to each other.</source>
          <target state="translated">&lt;code&gt;topology=:master_worker&lt;/code&gt; только процесс драйвера, т.е. &lt;code&gt;pid&lt;/code&gt; 1. Рабочие не подключаются друг к другу.</target>
        </trans-unit>
        <trans-unit id="2d9f7d8f681c6583e7676e7d6edc9308af158917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;track::AbstractString=&quot;&quot;&lt;/code&gt;: the name of the remote branch this new branch should track, if any. If empty (the default), no remote branch will be tracked.</source>
          <target state="translated">&lt;code&gt;track::AbstractString=&quot;&quot;&lt;/code&gt; : имя удаленной ветки, которую эта новая ветка должна отслеживать, если таковая имеется. Если пусто (по умолчанию), удаленная ветвь отслеживаться не будет.</target>
        </trans-unit>
        <trans-unit id="4e2130c7a7a9a101281bd18d3a385769f9600d03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trans&lt;/code&gt;/&lt;code&gt;tX&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trans&lt;/code&gt;/&lt;code&gt;tX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14ddcb95a156c7bb55a2265603cd736316fe9393" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tree_id::GitHash = GitHash()&lt;/code&gt; is a git tree to use to create the commit, showing its ancestry and relationship with any other history. &lt;code&gt;tree&lt;/code&gt; must belong to &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tree_id::GitHash = GitHash()&lt;/code&gt; - это дерево git, используемое для создания фиксации, показывающее его происхождение и связь с любой другой историей. &lt;code&gt;tree&lt;/code&gt; должно принадлежать &lt;code&gt;repo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5eb7dc6b4355a5d1f4c868ec0c32021d4596579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; (1)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; (1)</target>
        </trans-unit>
        <trans-unit id="0936c575e4a9bce1faa418b1592ef449dfc0490a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trunc(T, x)&lt;/code&gt; converts the result to type &lt;code&gt;T&lt;/code&gt;, throwing an &lt;code&gt;InexactError&lt;/code&gt; if the value is not representable.</source>
          <target state="translated">&lt;code&gt;trunc(T, x)&lt;/code&gt; преобразует результат в тип &lt;code&gt;T&lt;/code&gt; , выбрасывая &lt;code&gt;InexactError&lt;/code&gt; , если значение не представляется возможным.</target>
        </trans-unit>
        <trans-unit id="7b21c9a0f1d3cee2b1f4d67453d1344f204a37a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trunc(x)&lt;/code&gt; returns the nearest integral value of the same type as &lt;code&gt;x&lt;/code&gt; whose absolute value is less than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trunc(x)&lt;/code&gt; возвращает ближайшее целое значение того же типа, что и &lt;code&gt;x&lt;/code&gt; , абсолютное значение которого меньше или равно &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbee0eec9b2e55430d527d6582dd8877f12bb7b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;truncate&lt;/code&gt;: truncates the buffer size to zero length.</source>
          <target state="translated">&lt;code&gt;truncate&lt;/code&gt; : обрезает размер буфера до нулевой длины.</target>
        </trans-unit>
        <trans-unit id="41b6e3b3fb48f326fbad1eec1eadf0a833f25b9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try/catch&lt;/code&gt; statements also allow the &lt;code&gt;Exception&lt;/code&gt; to be saved in a variable. The following contrived example calculates the square root of the second element of &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is indexable, otherwise assumes &lt;code&gt;x&lt;/code&gt; is a real number and returns its square root:</source>
          <target state="translated">&lt;code&gt;try/catch&lt;/code&gt; Операторы try / catch также позволяют сохранять &lt;code&gt;Exception&lt;/code&gt; в переменной. В следующем надуманном примере вычисляется квадратный корень из второго элемента &lt;code&gt;x&lt;/code&gt; , если &lt;code&gt;x&lt;/code&gt; является индексируемым, в противном случае предполагается, что &lt;code&gt;x&lt;/code&gt; является действительным числом, и возвращает его квадратный корень:</target>
        </trans-unit>
        <trans-unit id="c33b1b48f85121178c6189a83f36ae5a4de3a504" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="abd7dd9b12720a69f43edb81b0af4bb55b4e9603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ttl&lt;/code&gt;: Time-to-live of packets sent on the socket (default: &lt;code&gt;nothing&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ttl&lt;/code&gt; : время жизни пакетов, отправленных через сокет (по умолчанию: &lt;code&gt;nothing&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bbe2f11d5812292598ef7400b637ef93f999bc1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt; &amp;ndash; &lt;code&gt;true&lt;/code&gt; (use tunneling), &lt;code&gt;false&lt;/code&gt; (do not use tunneling), or &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; (use default for the manager)</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; (использовать туннелирование), &lt;code&gt;false&lt;/code&gt; (не использовать туннелирование) или &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; (использовать по умолчанию для менеджера)</target>
        </trans-unit>
        <trans-unit id="402b0271ddb14ba3adb678d7b893e14da34abca5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt;, &lt;code&gt;bind_addr&lt;/code&gt;, &lt;code&gt;sshflags&lt;/code&gt; and &lt;code&gt;max_parallel&lt;/code&gt; are used when a ssh tunnel is required to connect to the workers from the master process.</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; , &lt;code&gt;bind_addr&lt;/code&gt; , &lt;code&gt;sshflags&lt;/code&gt; и &lt;code&gt;max_parallel&lt;/code&gt; используются , когда SSH туннель требуется для подключения к рабочим из главного процесса.</target>
        </trans-unit>
        <trans-unit id="3ae98d30d6b9f87be7214d21f7b1f1658026f596" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt; then SSH tunneling will be used to connect to the worker from the master process. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; : если &lt;code&gt;true&lt;/code&gt; , то для подключения к рабочему из главного процесса будет использоваться SSH-туннель. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fdfbb92ea4996a990fc0aedc71b8b96f842b098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unchecked::String=&quot;[ ]&quot;|&quot;⬚&quot;)&lt;/code&gt;: string to use for unchecked</source>
          <target state="translated">&lt;code&gt;unchecked::String=&quot;[ ]&quot;|&quot;⬚&quot;)&lt;/code&gt; : строка, используемая для снятия отметки</target>
        </trans-unit>
        <trans-unit id="ae5641baee7f560f12b53646e74002ae2a7b0bf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;up_arrow::Char='^'|'&amp;uarr;'&lt;/code&gt;: character to use for up arrow</source>
          <target state="translated">&lt;code&gt;up_arrow::Char='^'|'&amp;uarr;'&lt;/code&gt; : символ для стрелки вверх</target>
        </trans-unit>
        <trans-unit id="1286bd62882b2197d9326752a14abf249e35dcf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;update_fetchhead&lt;/code&gt;: whether to update the &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt;&lt;code&gt;FetchHead&lt;/code&gt;&lt;/a&gt; after the fetch. The default is to perform the update, which is the normal git behavior.</source>
          <target state="translated">&lt;code&gt;update_fetchhead&lt;/code&gt; : обновлять ли &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt; &lt;code&gt;FetchHead&lt;/code&gt; &lt;/a&gt; после выборки. По умолчанию выполняется обновление, что является нормальным поведением git.</target>
        </trans-unit>
        <trans-unit id="689158119264263de422838a5b03a631131c1362" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uplo&lt;/code&gt;/&lt;code&gt;ul&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;uplo&lt;/code&gt;/&lt;code&gt;ul&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab24710e9825de064a163f5ce94d79be47ade840" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;url&lt;/code&gt;: The URL of the fetch head.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; : URL заголовка выборки.</target>
        </trans-unit>
        <trans-unit id="f442181197e49f968f2471275a5f012e278f3859" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;url&lt;/code&gt;: the URL of the proxy.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; : URL-адрес прокси.</target>
        </trans-unit>
        <trans-unit id="19c4e769ed90cfd681ef1b310a2d6f9ad4296082" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;userdata&lt;/code&gt; is provided for custom cluster managers to store their own worker-specific information.</source>
          <target state="translated">&lt;code&gt;userdata&lt;/code&gt; предоставляется для настраиваемых менеджеров кластеров для хранения их собственной информации о работнике.</target>
        </trans-unit>
        <trans-unit id="d3b8331fceffede2316a7974124bb49b8eeb18b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;username::AbstractString=&quot;&quot;&lt;/code&gt;: the username to use in the output if provided.</source>
          <target state="translated">&lt;code&gt;username::AbstractString=&quot;&quot;&lt;/code&gt; : имя пользователя для использования в выводе, если оно указано.</target>
        </trans-unit>
        <trans-unit id="6c27371ad1b21bb51acb86107c58f827061ba3f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using Foo&lt;/code&gt; will load the module or package &lt;code&gt;Foo&lt;/code&gt; and make its &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt;ed names available for direct use. Names can also be used via dot syntax (e.g. &lt;code&gt;Foo.foo&lt;/code&gt; to access the name &lt;code&gt;foo&lt;/code&gt;), whether they are &lt;code&gt;export&lt;/code&gt;ed or not. See the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;using Foo&lt;/code&gt; загрузит модуль или пакет &lt;code&gt;Foo&lt;/code&gt; и сделает его &lt;a href=&quot;#export&quot;&gt; &lt;code&gt;export&lt;/code&gt; &lt;/a&gt; имена доступными для прямого использования. Имена также могут использоваться через точечный синтаксис (например, &lt;code&gt;Foo.foo&lt;/code&gt; для доступа к имени &lt;code&gt;foo&lt;/code&gt; ) независимо от того, &lt;code&gt;export&lt;/code&gt; они или нет. См. Подробности в &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;разделе руководства о модулях&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="838b54a9eab8767958b3b80fdcf1e81d2fcffe22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="3e6a732011c1dc2660c4dbf3be189b6cbac8e5cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v&lt;/code&gt; now gets converted to the channel's type with &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;put!&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; теперь преобразуется в тип канала с помощью &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; as &lt;code&gt;put!&lt;/code&gt; называется.</target>
        </trans-unit>
        <trans-unit id="a66a7e6c62d3aec6a461aa958f979b8da4631830" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;verbose&lt;/code&gt;: print all additional information</source>
          <target state="translated">&lt;code&gt;verbose&lt;/code&gt; : распечатать всю дополнительную информацию</target>
        </trans-unit>
        <trans-unit id="38771c8d2e3b58102e803157f1021fdc77359ffa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;version&lt;/code&gt;: version of the struct in use, in case this changes later. For now, always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;version&lt;/code&gt; : версия используемой структуры, если она изменится позже. Пока всегда &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1609ac09d4613eb0a602a783024f2b37f908873d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vl&lt;/code&gt; is the lower bound of the window of eigenvalues to search for, and &lt;code&gt;vu&lt;/code&gt; is the upper bound.</source>
          <target state="translated">&lt;code&gt;vl&lt;/code&gt; - это нижняя граница окна поиска собственных значений, а &lt;code&gt;vu&lt;/code&gt; - верхняя граница.</target>
        </trans-unit>
        <trans-unit id="39634ab88344e26a6c4f7e1a95904a898f43f0de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; and &lt;code&gt;[[noreturn]]&lt;/code&gt; or &lt;code&gt;_Noreturn&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; и &lt;code&gt;[[noreturn]]&lt;/code&gt; или &lt;code&gt;_Noreturn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f798cc6e3986d2379a7244ce2f55decce5179fd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when&lt;/code&gt;: a &lt;a href=&quot;#LibGit2.TimeStruct&quot;&gt;&lt;code&gt;TimeStruct&lt;/code&gt;&lt;/a&gt; indicating when the commit was authored/committed into the repository.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; : &lt;a href=&quot;#LibGit2.TimeStruct&quot;&gt; &lt;code&gt;TimeStruct&lt;/code&gt; ,&lt;/a&gt; указывающий, когда фиксация была создана / зафиксирована в репозитории.</target>
        </trans-unit>
        <trans-unit id="3719daed583548857eb7718a7ea0092ff6bffe3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;whence&lt;/code&gt; - refers to the node the remote reference was created from. Note that this is different from the node where the underlying object referred to actually exists. For example calling &lt;code&gt;RemoteChannel(2)&lt;/code&gt; from the master process would result in a &lt;code&gt;where&lt;/code&gt; value of 2 and a &lt;code&gt;whence&lt;/code&gt; value of 1.</source>
          <target state="translated">&lt;code&gt;whence&lt;/code&gt; - относится к узлу, с которого была создана удаленная ссылка. Обратите внимание, что это отличается от узла, на котором фактически существует указанный базовый объект. Например, вызов &lt;code&gt;RemoteChannel(2)&lt;/code&gt; из главного процесса приведет к получению значения &lt;code&gt;where&lt;/code&gt; 2 и значения 1 &lt;code&gt;whence&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4feca933c79656bb4a1cc14d4c9d2c920ea65480" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt; - refers to the node where the underlying object/storage referred to by the reference actually exists.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; - относится к узлу, где фактически существует базовый объект / хранилище, на которое ссылается ссылка.</target>
        </trans-unit>
        <trans-unit id="be931cf43d24dd627ab40ea349a9901fcb931b4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="551426be1e371b3925c0f4c041a102931aa878ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; loops repeatedly evaluate a conditional expression, and continue evaluating the body of the while loop as long as the expression remains true. If the condition expression is false when the while loop is first reached, the body is never evaluated.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; Циклы while повторно вычисляют условное выражение и продолжают вычислять тело цикла while, пока выражение остается истинным. Если выражение условия ложно при первом достижении цикла while, тело никогда не оценивается.</target>
        </trans-unit>
        <trans-unit id="f18b5d8d4e26142e2aee4c1c2ade071ef4896235" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="9e0e55014bc39303400ae1fa6e711c88709191dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windows_hide::Bool&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;), then on Windows no new console window is displayed when the &lt;code&gt;Cmd&lt;/code&gt; is executed. This has no effect if a console is already open or on non-Windows systems.</source>
          <target state="translated">&lt;code&gt;windows_hide::Bool&lt;/code&gt; : если &lt;code&gt;true&lt;/code&gt; (по умолчанию &lt;code&gt;false&lt;/code&gt; ), то в Windows новое окно консоли не отображается при выполнении &lt;code&gt;Cmd&lt;/code&gt; . Это не действует, если консоль уже открыта или в системах, отличных от Windows.</target>
        </trans-unit>
        <trans-unit id="dfac6550a56cdb5e20498842d2ca74d4884878f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windows_verbatim::Bool&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;), then on Windows the &lt;code&gt;Cmd&lt;/code&gt; will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single &quot;command-line&quot; string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes &lt;code&gt;&quot;&lt;/code&gt; in the command line, and &lt;code&gt;\&lt;/code&gt; or &lt;code&gt;&quot;&lt;/code&gt; are preceded by backslashes. &lt;code&gt;windows_verbatim=true&lt;/code&gt; is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.</source>
          <target state="translated">&lt;code&gt;windows_verbatim::Bool&lt;/code&gt; : Если &lt;code&gt;true&lt;/code&gt; (по умолчанию &lt;code&gt;false&lt;/code&gt; ), то в Windows &lt;code&gt;Cmd&lt;/code&gt; отправит процессу строку командной строки без кавычек или экранирования аргументов, даже аргументов, содержащих пробелы. (В Windows аргументы отправляются программе в виде единой строки &amp;laquo;командной строки&amp;raquo;, и программы несут ответственность за ее анализ на аргументы. По умолчанию пустые аргументы и аргументы с пробелами или табуляцией заключаются в двойные кавычки &lt;code&gt;&quot;&lt;/code&gt; в команде line, а &lt;code&gt;\&lt;/code&gt; или &lt;code&gt;&quot;&lt;/code&gt; предшествуют обратная косая черта. &lt;code&gt;windows_verbatim=true&lt;/code&gt; используется для запуска программ, которые нестандартно анализируют командную строку.) Не влияет на системы, отличные от Windows.</target>
        </trans-unit>
        <trans-unit id="7b8aee3aafac635044e497c27a0514876ff35397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;write(io, c)&lt;/code&gt;, in contrast, may emit an encoding depending on &lt;code&gt;typeof(c)&lt;/code&gt;, and &lt;code&gt;read(io, typeof(c))&lt;/code&gt; should read the same encoding as &lt;code&gt;write&lt;/code&gt;. New &lt;code&gt;AbstractChar&lt;/code&gt; types must provide their own implementations of &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;write(io, c)&lt;/code&gt; , напротив, может выдавать кодировку в зависимости от &lt;code&gt;typeof(c)&lt;/code&gt; , а &lt;code&gt;read(io, typeof(c))&lt;/code&gt; должен читать ту же кодировку, что и &lt;code&gt;write&lt;/code&gt; . Новые типы &lt;code&gt;AbstractChar&lt;/code&gt; должны обеспечивать собственные реализации &lt;code&gt;write&lt;/code&gt; и &lt;code&gt;read&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fadd3731757e74adbe714a9fc3cde1b0f50d386" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x % T&lt;/code&gt; converts an integer &lt;code&gt;x&lt;/code&gt; to a value of integer type &lt;code&gt;T&lt;/code&gt; congruent to &lt;code&gt;x&lt;/code&gt; modulo &lt;code&gt;2^n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of bits in &lt;code&gt;T&lt;/code&gt;. In other words, the binary representation is truncated to fit.</source>
          <target state="translated">&lt;code&gt;x % T&lt;/code&gt; преобразует целое число &lt;code&gt;x&lt;/code&gt; до значения целого типа &lt;code&gt;T&lt;/code&gt; конгруэнтен &lt;code&gt;x&lt;/code&gt; по модулю &lt;code&gt;2^n&lt;/code&gt; , где &lt;code&gt;n&lt;/code&gt; есть число бит в &lt;code&gt;T&lt;/code&gt; . Другими словами, двоичное представление усекается по размеру.</target>
        </trans-unit>
        <trans-unit id="90c41f1363237dda010ffbdcb1e50483f239fe01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x &amp;sdot; y&lt;/code&gt; (where &lt;code&gt;&amp;sdot;&lt;/code&gt; can be typed by tab-completing &lt;code&gt;\cdot&lt;/code&gt; in the REPL) is a synonym for &lt;code&gt;dot(x, y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;sdot; y&lt;/code&gt; (где &lt;code&gt;&amp;sdot;&lt;/code&gt; можно ввести с помощью символа табуляции &lt;code&gt;\cdot&lt;/code&gt; в REPL) является синонимом &lt;code&gt;dot(x, y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a73d00c797f625743ed5be89aa6859e0e140e7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x*2^n&lt;/code&gt; computed efficiently for integer values of &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x*2^n&lt;/code&gt; вычисляется эффективно для целых значений &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1940ccb42a82ee4f57a9ef424ce506f2b4432f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; и &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a950a8c9e0c5cf38b19bf4e5268bb9ee46dfc69c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are identical</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; идентичны</target>
        </trans-unit>
        <trans-unit id="ab3ac69532931e0ece805a61f4c297980ed1e736" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; may also be arrays of numbers, in which case &lt;code&gt;norm&lt;/code&gt; defaults to the usual &lt;code&gt;norm&lt;/code&gt; function in LinearAlgebra, but may be changed by passing a &lt;code&gt;norm::Function&lt;/code&gt; keyword argument. (For numbers, &lt;code&gt;norm&lt;/code&gt; is the same thing as &lt;code&gt;abs&lt;/code&gt;.) When &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are arrays, if &lt;code&gt;norm(x-y)&lt;/code&gt; is not finite (i.e. &lt;code&gt;&amp;plusmn;Inf&lt;/code&gt; or &lt;code&gt;NaN&lt;/code&gt;), the comparison falls back to checking whether all elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are approximately equal component-wise.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; также могут быть массивами чисел, и в этом случае &lt;code&gt;norm&lt;/code&gt; по умолчанию соответствует обычной функции &lt;code&gt;norm&lt;/code&gt; в LinearAlgebra, но может быть изменен путем передачи аргумента ключевого слова &lt;code&gt;norm::Function&lt;/code&gt; . (Для чисел, &lt;code&gt;norm&lt;/code&gt; это то же самое , как &lt;code&gt;abs&lt;/code&gt; .) Когда &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; являются массивами, если &lt;code&gt;norm(x-y)&lt;/code&gt; не является конечным (т.е. &lt;code&gt;&amp;plusmn;Inf&lt;/code&gt; или &lt;code&gt;NaN&lt;/code&gt; ), сравнение возвращается к проверке все ли элементы &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; являются примерно равные по компонентам.</target>
        </trans-unit>
        <trans-unit id="a48f8b3cde36a8ddf02a94dfeb998cab82856e48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; enables &quot;comment mode&quot;: whitespace is enabled except when escaped with &lt;code&gt;\&lt;/code&gt;, and &lt;code&gt;#&lt;/code&gt; is treated as starting a comment.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; включает &quot;режим комментариев&quot;: пробелы разрешены, кроме случаев, когда они экранированы с помощью &lt;code&gt;\&lt;/code&gt; , а &lt;code&gt;#&lt;/code&gt; рассматривается как начало комментария.</target>
        </trans-unit>
        <trans-unit id="9b7e404002ef27b1a2197f45feec798673ffc690" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is a finite number</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; - конечное число</target>
        </trans-unit>
        <trans-unit id="c0524cd745ecc91f2a8a799e342f5f682c7f1d35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is infinite</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; бесконечно</target>
        </trans-unit>
        <trans-unit id="47fb95081b3ce22a0b461fae81e21bbc77c62b2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is not a number</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; не число</target>
        </trans-unit>
        <trans-unit id="64a786472b355da8522bfc59ef4c0762b67c585b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;||&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="54aac4fafe7a37588d94288478848558abaf1196" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~/.julia&lt;/code&gt; where &lt;code&gt;~&lt;/code&gt; is the user home as appropriate on the system;</source>
          <target state="translated">&lt;code&gt;~/.julia&lt;/code&gt; , где &lt;code&gt;~&lt;/code&gt; - домашний адрес пользователя в системе;</target>
        </trans-unit>
        <trans-unit id="2df118c2fbb6c1d7ba0ff4dd87b88d00cf764a55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Before&lt;/em&gt; loading any code, make sure you're running Revise: say &lt;code&gt;using Revise&lt;/code&gt; or follow its documentation on configuring it to run automatically.</source>
          <target state="translated">&lt;em&gt;Перед&lt;/em&gt; загрузкой любого кода убедитесь, что вы используете Revise: скажем, &lt;code&gt;using Revise&lt;/code&gt; или следуйте документации по настройке для автоматического запуска.</target>
        </trans-unit>
        <trans-unit id="743bea8b6e02264a01bcef3ea67aed3f0cad8650" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Creating&lt;/em&gt; log events is the concern of the module author who needs to decide where events are triggered and which information to include.</source>
          <target state="translated">&lt;em&gt;Создание&lt;/em&gt; событий журнала - это забота автора модуля, который должен решить, какие события запускаются и какую информацию включать.</target>
        </trans-unit>
        <trans-unit id="b124a7e86891727331d73882ce0c24f7eaafd8ac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don't copy these examples!&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Не копируйте эти примеры!&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="71cf9402e58fc3879fb68f8afe68b31dae06eee0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Processing&lt;/em&gt; of log events &amp;mdash; that is, display, filtering, aggregation and recording &amp;mdash; is the concern of the application author who needs to bring multiple modules together into a cooperating application.</source>
          <target state="translated">&lt;em&gt;Обработка&lt;/em&gt; событий журнала - то есть отображение, фильтрация, агрегирование и запись - это забота автора приложения, которому необходимо объединить несколько модулей в одно взаимодействующее приложение.</target>
        </trans-unit>
        <trans-unit id="7685c1fa95d4518c2af3eb032fd247fef3129095" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divide-and-conquer&lt;/em&gt; sort strategy.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;Стратегия сортировки &quot; &lt;em&gt;разделяй и властвуй&quot;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="955d87cc46ecdddf5939b69f5d5e66211dd43025" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divide-and-conquer&lt;/em&gt;: sort strategy similar to &lt;a href=&quot;#Base.Sort.MergeSort&quot;&gt;&lt;code&gt;MergeSort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;разделяй и властвуй&lt;/em&gt; : стратегия сортировки, аналогичная &lt;a href=&quot;#Base.Sort.MergeSort&quot;&gt; &lt;code&gt;MergeSort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="547c0f175b81af7715456826fa2ddb801ca75ea1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;good performance&lt;/em&gt; for large collections.</source>
          <target state="translated">&lt;em&gt;хорошая производительность&lt;/em&gt; для больших коллекций.</target>
        </trans-unit>
        <trans-unit id="76e3721332fa8c80267a6d025e92a7b31c647f77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;iid&lt;/em&gt;, independently and identically distributed.</source>
          <target state="translated">&lt;em&gt;iid&lt;/em&gt; , независимо и одинаково распространяемые.</target>
        </trans-unit>
        <trans-unit id="4eecbf6b8e99fcad79c0f04ad8ffa79c56d8a143" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;in-place&lt;/em&gt; in memory.</source>
          <target state="translated">&lt;em&gt;на месте&lt;/em&gt; в памяти.</target>
        </trans-unit>
        <trans-unit id="53b7f08036597cd9367e51ae64cec4b72d17fb7f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;not in-place&lt;/em&gt; in memory.</source>
          <target state="translated">&lt;em&gt;не на месте&lt;/em&gt; в памяти.</target>
        </trans-unit>
        <trans-unit id="69d8a8fdc356b8320c038747a06bcc5697c84ab8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;not stable&lt;/em&gt;: does not preserve the ordering of elements which compare equal (e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters which ignores case).</source>
          <target state="translated">&lt;em&gt;нестабильно&lt;/em&gt; : не сохраняет порядок элементов, которые сравниваются одинаково (например, &amp;laquo;a&amp;raquo; и &amp;laquo;A&amp;raquo; в виде букв без учета регистра).</target>
        </trans-unit>
        <trans-unit id="bc0febd17aa71743548f98f48c43c546e1abfb04" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;quadratic performance&lt;/em&gt; in the number of elements to be sorted: it is well-suited to small collections but should not be used for large ones.</source>
          <target state="translated">&lt;em&gt;квадратичная производительность&lt;/em&gt; по количеству сортируемых элементов: она хорошо подходит для небольших коллекций, но не должна использоваться для больших.</target>
        </trans-unit>
        <trans-unit id="a1491802554c00bcc7d066e787c837a325301ece" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stable&lt;/em&gt;: preserves the ordering of elements which compare equal (e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters which ignores case).</source>
          <target state="translated">&lt;em&gt;стабильный&lt;/em&gt; : сохраняет порядок элементов, которые сравниваются одинаково (например, &amp;laquo;a&amp;raquo; и &amp;laquo;A&amp;raquo; в виде букв без учета регистра).</target>
        </trans-unit>
        <trans-unit id="47450e33687d2bd35b73c1a40f6abb2479676524" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A package directory&lt;/strong&gt; is a directory containing the source trees of a set of packages as subdirectories, and forms an &lt;em&gt;implicit environment&lt;/em&gt;. If &lt;code&gt;X&lt;/code&gt; is a subdirectory of a package directory and &lt;code&gt;X/src/X.jl&lt;/code&gt; exists, then the package &lt;code&gt;X&lt;/code&gt; is available in the package directory environment and &lt;code&gt;X/src/X.jl&lt;/code&gt; is the source file by which it is loaded.</source>
          <target state="translated">&lt;strong&gt;Каталог пакетов&lt;/strong&gt; - это каталог, содержащий деревья исходных текстов набора пакетов в виде подкаталогов и образующий &lt;em&gt;неявную среду&lt;/em&gt; . Если &lt;code&gt;X&lt;/code&gt; является подкаталогом каталога пакета и существует &lt;code&gt;X/src/X.jl&lt;/code&gt; , то пакет &lt;code&gt;X&lt;/code&gt; доступен в среде каталога пакетов, а &lt;code&gt;X/src/X.jl&lt;/code&gt; - исходный файл, из которого он загружается.</target>
        </trans-unit>
        <trans-unit id="ab6e1278144bfe85f8b9792c5068eed40f8bd5eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A project environment&lt;/strong&gt; is a directory with a project file and an optional manifest file, and forms an &lt;em&gt;explicit environement&lt;/em&gt;. The project file determines what the names and identities of the direct dependencies of a project are. The manifest file, if present, gives a complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to locate and load the correct version.</source>
          <target state="translated">&lt;strong&gt;Среда проекта&lt;/strong&gt; - это каталог с файлом проекта и необязательным файлом манифеста, который образует &lt;em&gt;явную среду&lt;/em&gt; . Файл проекта определяет имена и идентификаторы прямых зависимостей проекта. Файл манифеста, если он присутствует, дает полный граф зависимостей, включая все прямые и косвенные зависимости, точные версии каждой зависимости и достаточную информацию для поиска и загрузки правильной версии.</target>
        </trans-unit>
        <trans-unit id="5dcf2f7a4986e6945bd060c2a9f0b685ebc4a479" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Automatic promotion for built-in arithmetic types and operators.&lt;/strong&gt; In most languages, built-in numeric types, when used as operands to arithmetic operators with infix syntax, such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;/&lt;/code&gt;, are automatically promoted to a common type to produce the expected results. C, Java, Perl, and Python, to name a few, all correctly compute the sum &lt;code&gt;1 + 1.5&lt;/code&gt; as the floating-point value &lt;code&gt;2.5&lt;/code&gt;, even though one of the operands to &lt;code&gt;+&lt;/code&gt; is an integer. These systems are convenient and designed carefully enough that they are generally all-but-invisible to the programmer: hardly anyone consciously thinks of this promotion taking place when writing such an expression, but compilers and interpreters must perform conversion before addition since integers and floating-point values cannot be added as-is. Complex rules for such automatic conversions are thus inevitably part of specifications and implementations for such languages.</source>
          <target state="translated">&lt;strong&gt;Автоматическое продвижение встроенных арифметических типов и операторов.&lt;/strong&gt; В большинстве языков встроенные числовые типы при использовании в качестве операндов для арифметических операторов с инфиксным синтаксисом, например &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; и &lt;code&gt;/&lt;/code&gt; , автоматически переводятся в общий тип для получения ожидаемых результатов. C, Java, Perl и Python, и это лишь некоторые из них, правильно вычисляют сумму &lt;code&gt;1 + 1.5&lt;/code&gt; как значение с плавающей запятой &lt;code&gt;2.5&lt;/code&gt; , даже если один из операндов равен &lt;code&gt;+&lt;/code&gt; целое число. Эти системы удобны и разработаны достаточно тщательно, чтобы они, как правило, практически незаметны для программиста: вряд ли кто-то сознательно задумывается об этом продвижении при написании такого выражения, но компиляторы и интерпретаторы должны выполнять преобразование перед сложением, поскольку целые числа и числа с плавающей точкой - баллы не могут быть добавлены как есть. Таким образом, сложные правила для таких автоматических преобразований неизбежно являются частью спецификаций и реализаций таких языков.</target>
        </trans-unit>
        <trans-unit id="40672dddf16a6430318b3eb0b9096db189222d38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Brief description&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Краткое описание&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="540bb8e1a8c92de3d9695826131a325154196169" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Broadcasting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Broadcasting&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f7d8aeead87b3699dcf3142b1e6dee864b1f9e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bypassing default machinery&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Обход оборудования по умолчанию&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c3f895628a42c1489009a0b0558d48806270adc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code inclusion:&lt;/strong&gt; e.g. &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt;. Inclusion allows you to split a single program across multiple source files. The expression &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; causes the contents of the file &lt;code&gt;source.jl&lt;/code&gt; to be evaluated in the global scope of the module where the &lt;code&gt;include&lt;/code&gt; call occurs. If &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; is called multiple times, &lt;code&gt;source.jl&lt;/code&gt; is evaluated multiple times. The included path, &lt;code&gt;source.jl&lt;/code&gt;, is interpreted relative to the file where the &lt;code&gt;include&lt;/code&gt; call occurs. This makes it simple to relocate a subtree of source files. In the REPL, included paths are interpreted relative to the current working directory, &lt;a href=&quot;../../base/file/index#Base.Filesystem.pwd&quot;&gt;&lt;code&gt;pwd()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Включение кода:&lt;/strong&gt; например, &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; . Включение позволяет разделить одну программу на несколько исходных файлов. Выражение &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; приводит к тому, что содержимое файла &lt;code&gt;source.jl&lt;/code&gt; оценивается в глобальной области видимости модуля, в котором происходит вызов &lt;code&gt;include&lt;/code&gt; . Если &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; вызывается несколько раз, &lt;code&gt;source.jl&lt;/code&gt; оценивается несколько раз. Включенный путь, &lt;code&gt;source.jl&lt;/code&gt; , интерпретируется относительно файла, в котором происходит вызов &lt;code&gt;include&lt;/code&gt; . Это упрощает перемещение поддерева исходных файлов. В REPL включенные пути интерпретируются относительно текущего рабочего каталога,&lt;a href=&quot;../../base/file/index#Base.Filesystem.pwd&quot;&gt; &lt;code&gt;pwd()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01b2956aa02b611eba1c44ae4666e386f9a69158" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion between linear and cartesian indices&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Преобразование между линейным и декартовым индексами&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8981b2e89255132713afc6ec39691c7bdea5024d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cursor movement&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Движение курсора&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f5b988cb89cb4ede6b56c1271511dfc59d67ac0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default definition&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Определение по умолчанию&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1c863333a531bcda45cde640d9c35956bb33378" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Editing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Editing&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c838c65ad1ba4b74d30de6df9d506f5e2b0ac9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Everything else&lt;/strong&gt;. Any other arguments.</source>
          <target state="translated">&lt;strong&gt;Все остальное&lt;/strong&gt; . Любые другие аргументы.</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c3d140c8e464f134cec3b0eebd38bf683f55d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aec29b6e22750bc511d0ca82430cb4a126753e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="3c9102cd5f3ec81f62379dfb14e7e329a015e35f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extensions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Extensions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a9d05122489d09030ff3668a78437ee26a3f82b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;External links&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;внешние ссылки&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83e0b267355d0c11ea2a53fe10c727c43451c8c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Floating-point types:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Типы с плавающей запятой:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a16a8e8a484df94b3401f2c14b02422be6ca3e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function argument&lt;/strong&gt;. Putting a function argument first permits the use of &lt;a href=&quot;../../base/base/index#do&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; blocks for passing multiline anonymous functions.</source>
          <target state="translated">&lt;strong&gt;Аргумент функции&lt;/strong&gt; . Ввод аргумента функции первым позволяет использовать блоки &lt;a href=&quot;../../base/base/index#do&quot;&gt; &lt;code&gt;do&lt;/code&gt; &lt;/a&gt; для передачи многострочных анонимных функций.</target>
        </trans-unit>
        <trans-unit id="1ca787ea86b26829b090b38d91fb7a76042f2799" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Higher dimensional examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Примеры более высоких измерений&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6a830a0dff55184e4ece6c75f5be5491d3d9702" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Higher dimensions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Высшие измерения&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f0fb2b5df39867dacb9671eb2a360e55518f879f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I/O stream&lt;/strong&gt;. Specifying the &lt;code&gt;IO&lt;/code&gt; object first permits passing the function to functions such as &lt;a href=&quot;../../base/io-network/index#Base.sprint&quot;&gt;&lt;code&gt;sprint&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;sprint(show, x)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Поток ввода-вывода&lt;/strong&gt; . Указание объекта &lt;code&gt;IO&lt;/code&gt; сначала позволяет передать функцию таким функциям, как &lt;a href=&quot;../../base/io-network/index#Base.sprint&quot;&gt; &lt;code&gt;sprint&lt;/code&gt; &lt;/a&gt; , например &lt;code&gt;sprint(show, x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45650bbd2deb4cc345f368e53f1b5e765a99a0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implementation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Implementation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6981e39179d49e3bc1edb6f6043ddc4d3a9c17e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important optional methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Важные необязательные методы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="feaf5b204440e5d7b91a26fca33465989ee60de5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input being mutated&lt;/strong&gt;. For example, in &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt;&lt;code&gt;fill!(x, v)&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;x&lt;/code&gt; is the object being mutated and it appears before the value to be inserted into &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Ввод изменен&lt;/strong&gt; . Например, в &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt; &lt;code&gt;fill!(x, v)&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;x&lt;/code&gt; является объектом будучи мутировал и, кажется , прежде , чем значение для вставки в &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35035aa4af72e7ec2407cb311a13aa4b3f4086e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input not being mutated&lt;/strong&gt;. In &lt;code&gt;fill!(x, v)&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; being mutated and it comes after &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Вход не изменяется&lt;/strong&gt; . В &lt;code&gt;fill!(x, v)&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; это &lt;em&gt;не&lt;/em&gt; будучи мутировал , и он приходит после того, как &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96c1aac8a2ffe99a6f68662d283f199e4c7902db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Integer types:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Целочисленные типы:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5b0deb4e2e9417b81879cdc846953811ed3197f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key&lt;/strong&gt;. For associative collections, this is the key of the key-value pair(s). For other indexed collections, this is the index.</source>
          <target state="translated">&lt;strong&gt;Ключ&lt;/strong&gt; . Для ассоциативных коллекций это ключ пары ключ-значение. Для других проиндексированных коллекций это index.</target>
        </trans-unit>
        <trans-unit id="ff1552788ed9b7867471169f6f6e13e67ae56e49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keyword Arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Аргументы ключевых слов&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6d1fbca2eaaca33fbedfae851b1718e81cb621c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keyword arguments&lt;/strong&gt;. In Julia keyword arguments have to come last anyway in function definitions; they're listed here for the sake of completeness.</source>
          <target state="translated">&lt;strong&gt;Аргументы ключевого слова&lt;/strong&gt; . В ключевом слове Julia аргументы в любом случае должны стоять последними в определениях функций; они перечислены здесь для полноты картины.</target>
        </trans-unit>
        <trans-unit id="940941ba13fb5db6a5ccc6b2d81447af0218c6f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keywords&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Keywords&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="739565cef16139694d18e4e833e383d92f6229e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lather. Rinse. Repeat.&lt;/strong&gt; Explore ideas at the &lt;code&gt;julia&lt;/code&gt; command prompt. Save good ideas in &lt;code&gt;tst.jl&lt;/code&gt;. To execute &lt;code&gt;tst.jl&lt;/code&gt; after it has been changed, just &lt;code&gt;include&lt;/code&gt; it again.</source>
          <target state="translated">&lt;strong&gt;Lather. Полоскание. Повторение.&lt;/strong&gt; Изучите идеи в командной строке &lt;code&gt;julia&lt;/code&gt; . Сохранить хорошие идеи в &lt;code&gt;tst.jl&lt;/code&gt; . Чтобы выполнить &lt;code&gt;tst.jl&lt;/code&gt; после того , как было изменено, просто &lt;code&gt;include&lt;/code&gt; его снова.</target>
        </trans-unit>
        <trans-unit id="062ff7c1f91aac8affdefeef654af299368b137e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No automatic promotion.&lt;/strong&gt; This camp includes Ada and ML &amp;ndash; very &quot;strict&quot; statically typed languages. In these languages, every conversion must be explicitly specified by the programmer. Thus, the example expression &lt;code&gt;1 + 1.5&lt;/code&gt; would be a compilation error in both Ada and ML. Instead one must write &lt;code&gt;real(1) + 1.5&lt;/code&gt;, explicitly converting the integer &lt;code&gt;1&lt;/code&gt; to a floating-point value before performing addition. Explicit conversion everywhere is so inconvenient, however, that even Ada has some degree of automatic conversion: integer literals are promoted to the expected integer type automatically, and floating-point literals are similarly promoted to appropriate floating-point types.</source>
          <target state="translated">&lt;strong&gt;Нет автоматического продвижения. &lt;/strong&gt;В этот лагерь входят Ada и ML - очень &amp;laquo;строгие&amp;raquo; статически типизированные языки. В этих языках каждое преобразование должно быть явно указано программистом. Таким образом, пример выражения &lt;code&gt;1 + 1.5&lt;/code&gt; будет ошибкой компиляции как в Ada, так и в ML. Вместо этого нужно написать &lt;code&gt;real(1) + 1.5&lt;/code&gt; , явно преобразовав целое число &lt;code&gt;1&lt;/code&gt; в значение с плавающей запятой перед выполнением сложения. Явное преобразование повсюду настолько неудобно, что даже в Ada есть некоторая степень автоматического преобразования: целочисленные литералы автоматически переводятся в ожидаемый целочисленный тип, а литералы с плавающей запятой аналогичным образом переводятся в соответствующие типы с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="19f000a09892ceb4a24beccfa194f3fb0e83a418" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-traditional indices&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Нетрадиционные индексы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3411b52319b78e51339257b20de47be2deece6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Due to the specifics of the &lt;code&gt;libgit2&lt;/code&gt; authentication procedure, when authentication fails, this function is called again without any indication whether authentication was successful or not. To avoid an infinite loop from repeatedly using the same faulty credentials, we will keep track of state using the payload.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : из-за &lt;code&gt;libgit2&lt;/code&gt; процедуры аутентификации libgit2 , когда аутентификация не удалась, эта функция вызывается снова без какого-либо указания, была ли аутентификация успешной или нет. Чтобы избежать бесконечного цикла из-за многократного использования одних и тех же ошибочных учетных данных, мы будем отслеживать состояние с помощью полезной нагрузки.</target>
        </trans-unit>
        <trans-unit id="9305d29fbc35afa9e63a3c399be778dee6ddefff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This section covers embedding Julia code in C on Unix-like operating systems. For doing this on Windows, please see the section following this.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . В этом разделе рассматривается встраивание кода Julia в C в Unix-подобных операционных системах. Чтобы сделать это в Windows, см. Следующий раздел.</target>
        </trans-unit>
        <trans-unit id="fbff1879231e49a20a9f4f3abc431b43d8a6387c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Optional methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Дополнительные методы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9fb86f3d0dc24e6e4655476741634ef5c5d50df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Package loading:&lt;/strong&gt; e.g. &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt;. The import mechanism allows you to load a package&amp;mdash;i.e. an independent, reusable collection of Julia code, wrapped in a module&amp;mdash;and makes the resulting module available by the name &lt;code&gt;X&lt;/code&gt; inside of the importing module. If the same &lt;code&gt;X&lt;/code&gt; package is imported multiple times in the same Julia session, it is only loaded the first time&amp;mdash;on subsequent imports, the importing module gets a reference to the same module. Note though, that &lt;code&gt;import X&lt;/code&gt; can load different packages in different contexts: &lt;code&gt;X&lt;/code&gt; can refer to one package named &lt;code&gt;X&lt;/code&gt; in the main project but potentially to different packages also named &lt;code&gt;X&lt;/code&gt; in each dependency. More on this below.</source>
          <target state="translated">&lt;strong&gt;Пакет загрузки:&lt;/strong&gt; например , &lt;code&gt;import X&lt;/code&gt; или с &lt;code&gt;using X&lt;/code&gt; . Механизм импорта позволяет загружать пакет - т. Е. Независимую многократно используемую коллекцию кода Julia, заключенную в модуль, - и делает получившийся модуль доступным по имени &lt;code&gt;X&lt;/code&gt; внутри модуля импорта. Если один и тот же пакет &lt;code&gt;X&lt;/code&gt; импортируется несколько раз в одном сеансе Julia, он загружается только в первый раз - при последующих импортах импортирующий модуль получает ссылку на тот же модуль. Однако обратите внимание, что &lt;code&gt;import X&lt;/code&gt; может загружать разные пакеты в разных контекстах: &lt;code&gt;X&lt;/code&gt; может ссылаться на один пакет с именем &lt;code&gt;X&lt;/code&gt; в основном проекте, но, возможно, на разные пакеты, также называемые &lt;code&gt;X&lt;/code&gt; в каждой зависимости. Подробнее об этом ниже.</target>
        </trans-unit>
        <trans-unit id="fd7c146c235ccd96ea634cfca88f3355f9e6c234" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Program control&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Программный контроль&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a191672dfe99327da9dff700b45c0a90a2ec39c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put code under development in a temporary module.&lt;/strong&gt; Create a file, say &lt;code&gt;Tmp.jl&lt;/code&gt;, and include within it</source>
          <target state="translated">&lt;strong&gt;Поместите разрабатываемый код во временный модуль. &lt;/strong&gt;Создайте файл, скажем &lt;code&gt;Tmp.jl&lt;/code&gt; , и включите в него</target>
        </trans-unit>
        <trans-unit id="4eebb852c621ba2a07cde7c387d74387c1073db2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put your test code in another file.&lt;/strong&gt; Create another file, say &lt;code&gt;tst.jl&lt;/code&gt;, which looks like</source>
          <target state="translated">&lt;strong&gt;Поместите свой тестовый код в другой файл. &lt;/strong&gt;Создайте еще один файл, скажем &lt;code&gt;tst.jl&lt;/code&gt; , который выглядит как</target>
        </trans-unit>
        <trans-unit id="261a3928dc6c3e62bad4f4dc9c5ff983868f3948" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Смотрите также&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76a6a8a34ed60528197f028d9fedecb6c66b4c1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System Independent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Независимая от системы:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="212d71ac9a214ae43f2cb6533589aa526743d53d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System-dependent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;System-dependent:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="62fabcca68af5e84228e26aadaf1eb51caedddfe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The dependency graph&lt;/strong&gt; of a project directory is determined by the presence and contents of project files in the subdirectory of each package. The rules are:</source>
          <target state="translated">&lt;strong&gt;Граф зависимости&lt;/strong&gt; каталога проекта определяется наличием и содержимым файлов проекта в подкаталоге каждого пакета. Правила следующие:</target>
        </trans-unit>
        <trans-unit id="35fd5fb379b76233f79b688e018757619277e941" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The dependency graph&lt;/strong&gt; of a project environment is determined by the contents of the manifest file, if present. If there is no manifest file, graph is empty. A manifest file contains a stanza for each of a project's direct or indirect dependencies. For each dependency, the file lists the package's UUID and a source tree hash or an explicit path to the source code. Consider the following example manifest file for &lt;code&gt;App&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;График зависимостей&lt;/strong&gt; среды проекта определяется содержимым файла манифеста, если он есть. Если файла манифеста нет, график пуст. Файл манифеста содержит раздел для каждой прямой или косвенной зависимости проекта. Для каждой зависимости в файле перечислены UUID пакета и хэш дерева исходного кода или явный путь к исходному коду. Рассмотрим следующий пример файла манифеста для &lt;code&gt;App&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="99a933b1a5fc31f0c493bc7563a8e1ef2ab60637" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key point here is that Julia code is internally represented as a data structure that is accessible from the language itself.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ключевым моментом здесь является то, что код Julia внутренне представлен как структура данных, доступная из самого языка.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ec20ee36876b86777c4834a05d78e1ed0df59a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The paths map&lt;/strong&gt; in a package directory is simple: it maps subdirectory names to their corresponding entry-point paths. In other words, if the path to our example project directory is &lt;code&gt;/home/me/animals&lt;/code&gt; then the &lt;code&gt;paths&lt;/code&gt; map could be represented by this dictionary:</source>
          <target state="translated">&lt;strong&gt;Карта путей&lt;/strong&gt; в каталоге пакета проста: она сопоставляет имена подкаталогов с соответствующими путями точек входа. Другими словами, если путь к каталогу нашего примера проекта - &lt;code&gt;/home/me/animals&lt;/code&gt; , то карта &lt;code&gt;paths&lt;/code&gt; может быть представлена ​​этим словарем:</target>
        </trans-unit>
        <trans-unit id="7176439c445de46708b9fc3e70d97730d2317fd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The paths map&lt;/strong&gt; of a project environment is extracted from the manifest file. The path of a package &lt;code&gt;uuid&lt;/code&gt; named &lt;code&gt;X&lt;/code&gt; is determined by these rules (in order):</source>
          <target state="translated">&lt;strong&gt;Карта путей&lt;/strong&gt; среды проекта извлекается из файла манифеста. Путь к &lt;code&gt;uuid&lt;/code&gt; пакета с именем &lt;code&gt;X&lt;/code&gt; определяется этими правилами (по порядку):</target>
        </trans-unit>
        <trans-unit id="d3d291e6a57a7e987da705641960c2e565ce87e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The roots map&lt;/strong&gt; is determined by examining the contents of the package directory to generate a list of all packages that exist. Additionally, a UUID will be assigned to each entry as follows: For a given package found inside the folder &lt;code&gt;X&lt;/code&gt;...</source>
          <target state="translated">&lt;strong&gt;Карта корней&lt;/strong&gt; определяется путем изучения содержимого каталога пакетов для создания списка всех существующих пакетов. Кроме того, каждой записи будет присвоен UUID следующим образом: Для данного пакета, находящегося внутри папки &lt;code&gt;X&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="cd6e60a191a6ba1c08e90279b391c492d145ca70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The roots map&lt;/strong&gt; of the environment is determined by the contents of the project file, specifically, its top-level &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;uuid&lt;/code&gt; entries and its &lt;code&gt;[deps]&lt;/code&gt; section (all optional). Consider the following example project file for the hypothetical application, &lt;code&gt;App&lt;/code&gt;, as described earlier:</source>
          <target state="translated">&lt;strong&gt;Корни карту&lt;/strong&gt; окружающей среды определяется содержимым файла проекта, в частности, его верхнего уровня &lt;code&gt;name&lt;/code&gt; и &lt;code&gt;uuid&lt;/code&gt; записи и его &lt;code&gt;[deps]&lt;/code&gt; раздел (все по желанию). Рассмотрим следующий пример файла проекта для гипотетического приложения &lt;code&gt;App&lt;/code&gt; , как описано ранее:</target>
        </trans-unit>
        <trans-unit id="fda932e2af71b43d983578e7c22d5ddfec83e11d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type&lt;/strong&gt;. Passing a type typically means that the output will have the given type. In &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse(Int, &quot;1&quot;)&lt;/code&gt;&lt;/a&gt;, the type comes before the string to parse. There are many such examples where the type appears first, but it's useful to note that in &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read(io, String)&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;IO&lt;/code&gt; argument appears before the type, which is in keeping with the order outlined here.</source>
          <target state="translated">&lt;strong&gt;Тип&lt;/strong&gt; . Передача типа обычно означает, что вывод будет иметь данный тип. При &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse(Int, &quot;1&quot;)&lt;/code&gt; &lt;/a&gt; тип стоит перед строкой для синтаксического анализа. Есть много таких примеров , когда тип появляется первым, но это полезно отметить , что в &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read(io, String)&lt;/code&gt; &lt;/a&gt; , то &lt;code&gt;IO&lt;/code&gt; аргумент появляется перед типом, который в соответствии с порядком изложен здесь.</target>
        </trans-unit>
        <trans-unit id="93eadc871861400a6078e0c61f3521be0b3a0f8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;. For associative collections, this is the value of the key-value pair(s). In cases like &lt;code&gt;fill!(x, v)&lt;/code&gt;, this is &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Ценность&lt;/strong&gt; . Для ассоциативных коллекций это значение пар &quot;ключ-значение&quot;. В таких случаях, как &lt;code&gt;fill!(x, v)&lt;/code&gt; , это &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5d0e0a9d5ca3af4a899d7c1e28f16c0a7bba6fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Varargs&lt;/strong&gt;. This refers to arguments that can be listed indefinitely at the end of a function call. For example, in &lt;code&gt;Matrix{T}(undef, dims)&lt;/code&gt;, the dimensions can be given as a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;Matrix{T}(undef, (1,2))&lt;/code&gt;, or as &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt;&lt;code&gt;Vararg&lt;/code&gt;&lt;/a&gt;s, e.g. &lt;code&gt;Matrix{T}(undef, 1, 2)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Вараргс&lt;/strong&gt; . Это относится к аргументам, которые могут быть перечислены бесконечно в конце вызова функции. Например, в &lt;code&gt;Matrix{T}(undef, dims)&lt;/code&gt; размеры могут быть заданы как &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; , например, &lt;code&gt;Matrix{T}(undef, (1,2))&lt;/code&gt; , или как &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt; &lt;code&gt;Vararg&lt;/code&gt; &lt;/a&gt; s, например, &lt;code&gt;Matrix{T}(undef, 1, 2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="545631b4b295bbbbaed02465401d0864d0ba7cd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What code will this generate?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Какой код это сгенерирует?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3b9ef5ff046429380c724127c17394868104ef2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What happens next?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что происходит дальше?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d0ff7b4939bf14804a87f9610d1e80a40b4a40b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[1]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[1]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b12835c0c0b2c5b88b2a8e731d5eb2b1969e8e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[2]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[2]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a1a83d04dbd981bd8fe4ab619b42f958ca751fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH12]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH12]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b43d748a54903580e1f21b7242d8d7bb7c4a651a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_1]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_1]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a356e5ff840b60f1a7fd81a3055863d97b69c77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_2]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_2]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06b68ee69a50f3609b2ad16980f29687180123ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_3]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_3]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a85a3aeb27ca57bd4a8e009398c96aa33508ed10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_4]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_4]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddd2e496892d30147f2d48e88aa633252774dbf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_5]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_5]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ddc74cbd626ac29e02b601b534c540a40ab5c0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_6]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_6]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e97166948a5a3dd11986acbec9fbe6e3cecc60a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AHR13]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AHR13]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65bccd8483458eb47f0cf100e59d18c925a72cfd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[B96]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[B96]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c87f94a30b3537fd21ece46a3be3dc64a62b55b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[BH83]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[BH83]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="11b1b49422b93ae8106416d25659e6c4a205faf3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Bischof1987]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Bischof1987]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27d14e168d4fa4ad2378bdf18be346c186cebb91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Bunch1977]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Bunch1977]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a39f9cf2c50ef187780e440b9a6f2239b055ca1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Clarke61]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Clarke61]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6c9f7af37c9c1abf3d2cee7bcb7b4328414a23f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[H05]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[H05]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86010be2d69f415c30df7072124ec31548c70f03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[KY88]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[KY88]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="95c6fae5f939df06b7b59cc5c966b9329d025d70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[S84]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[S84]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa6c947d8396f46ae50ccb15050b140acd93e682" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Schreiber1989]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Schreiber1989]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="274fa9920703743f7af11b5a3280a2a8b5492b20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[issue8859]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[issue8859]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="deb59e9858773588134a730e8495054b325e35ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;graph:&lt;/strong&gt;&lt;code&gt;context::UUID&lt;/code&gt; ⟶ &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;граф: &lt;/strong&gt; &lt;code&gt;context::UUID&lt;/code&gt; ⟶ &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da29c13a3741ca50b24df3f7e215f047cc6fe3b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;malloc/free&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;malloc/free&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cc5e4770f37b853a29d3b06890d6a4abca810ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;paths:&lt;/strong&gt;&lt;code&gt;uuid::UUID&lt;/code&gt; &amp;times; &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;path::String&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;пути: &lt;/strong&gt; &lt;code&gt;uuid::UUID&lt;/code&gt; &amp;times; &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;path::String&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e060769be59aa948e668dd91db6570aedd04731c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;roots:&lt;/strong&gt;&lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;корни: &lt;/strong&gt; &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec6dd4d3b2fc9b4797a8648dcfb6a94dffc781ff" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;4.0 &lt;i&gt;i&lt;/i&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;4.0 &lt;i&gt;я&lt;/i&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="4b5fcf2420327f83a4a6033c345a55bd47a95680" translate="yes" xml:space="preserve">
          <source>==()</source>
          <target state="translated">==()</target>
        </trans-unit>
        <trans-unit id="924d44730ffe4a504a8c5b50688254e4e4997e86" translate="yes" xml:space="preserve">
          <source>@__DIR__</source>
          <target state="translated">@__DIR__</target>
        </trans-unit>
        <trans-unit id="bd05d820a39cc57788c144db33dd9e5d64bc802d" translate="yes" xml:space="preserve">
          <source>@__FILE__</source>
          <target state="translated">@__FILE__</target>
        </trans-unit>
        <trans-unit id="0a7e2fb02c2ce1b02c47c60a07b07cab4fff90c0" translate="yes" xml:space="preserve">
          <source>@__LINE__</source>
          <target state="translated">@__LINE__</target>
        </trans-unit>
        <trans-unit id="cc0701eaddfdfad8a65ef41e959c8e4f27062811" translate="yes" xml:space="preserve">
          <source>@__MODULE__</source>
          <target state="translated">@__MODULE__</target>
        </trans-unit>
        <trans-unit id="0662c8864fe3f1ee3b1e0fb430b61c3e64455909" translate="yes" xml:space="preserve">
          <source>@allocated</source>
          <target state="translated">@allocated</target>
        </trans-unit>
        <trans-unit id="521dba9e02174468f68a0b805b470b64bd37b2ab" translate="yes" xml:space="preserve">
          <source>@assert</source>
          <target state="translated">@assert</target>
        </trans-unit>
        <trans-unit id="3b7c965e962f36eb0e6c472eea82392cdc514ade" translate="yes" xml:space="preserve">
          <source>@async</source>
          <target state="translated">@async</target>
        </trans-unit>
        <trans-unit id="e9bfca0d6780244df737a5f488a11f321a4e3e28" translate="yes" xml:space="preserve">
          <source>@b_str</source>
          <target state="translated">@b_str</target>
        </trans-unit>
        <trans-unit id="f0925e6a5b16433b144a470019c1c0dd5de55e2d" translate="yes" xml:space="preserve">
          <source>@boundscheck</source>
          <target state="translated">@boundscheck</target>
        </trans-unit>
        <trans-unit id="4c462c8f8efc0e427cbc1cf6bea236a9cc0c83e0" translate="yes" xml:space="preserve">
          <source>@cfunction</source>
          <target state="translated">@cfunction</target>
        </trans-unit>
        <trans-unit id="4edd1d89ba51e67e5cde36c993ecbd6d4257872d" translate="yes" xml:space="preserve">
          <source>@deprecate</source>
          <target state="translated">@deprecate</target>
        </trans-unit>
        <trans-unit id="c460a7d72a405ba1e96118402a7742091a82dc52" translate="yes" xml:space="preserve">
          <source>@elapsed</source>
          <target state="translated">@elapsed</target>
        </trans-unit>
        <trans-unit id="34bfbc0fb605f42aad89cbd346daff31c66f5b0e" translate="yes" xml:space="preserve">
          <source>@eval</source>
          <target state="translated">@eval</target>
        </trans-unit>
        <trans-unit id="0ce3f8c769d6a2e9b95a931f13c7916418581d1b" translate="yes" xml:space="preserve">
          <source>@generated</source>
          <target state="translated">@generated</target>
        </trans-unit>
        <trans-unit id="d7621df9275358d3c30a2cfd8844f4521261ee73" translate="yes" xml:space="preserve">
          <source>@gensym</source>
          <target state="translated">@gensym</target>
        </trans-unit>
        <trans-unit id="a443a35e19dcd1ec15e45404c7ffcdeb21fd2474" translate="yes" xml:space="preserve">
          <source>@goto</source>
          <target state="translated">@goto</target>
        </trans-unit>
        <trans-unit id="19d47413bcaa88444056e76c473085f6a1b72db9" translate="yes" xml:space="preserve">
          <source>@inbounds</source>
          <target state="translated">@inbounds</target>
        </trans-unit>
        <trans-unit id="b5cf25ca00c54f41be13cd9463b582cceefc51b6" translate="yes" xml:space="preserve">
          <source>@inline</source>
          <target state="translated">@inline</target>
        </trans-unit>
        <trans-unit id="8ca0acccfff73ec5f39bf9a76ceb21c3d72aa439" translate="yes" xml:space="preserve">
          <source>@isdefined</source>
          <target state="translated">@isdefined</target>
        </trans-unit>
        <trans-unit id="03c2e7fdb001cbf566801d52a83375cbdaa52bd5" translate="yes" xml:space="preserve">
          <source>@label</source>
          <target state="translated">@label</target>
        </trans-unit>
        <trans-unit id="4ea1201781ae986fc43d71514b609cb6e748d76c" translate="yes" xml:space="preserve">
          <source>@macroexpand</source>
          <target state="translated">@macroexpand</target>
        </trans-unit>
        <trans-unit id="1fd88e55d30c6edcea950811aea00f2ce4456bac" translate="yes" xml:space="preserve">
          <source>@macroexpand1</source>
          <target state="translated">@macroexpand1</target>
        </trans-unit>
        <trans-unit id="78b6dbe95bbae61a934cb6e904cb50533688efaf" translate="yes" xml:space="preserve">
          <source>@noinline</source>
          <target state="translated">@noinline</target>
        </trans-unit>
        <trans-unit id="a5325bbb0409334c7f59038d601431b5a3a33c33" translate="yes" xml:space="preserve">
          <source>@nospecialize</source>
          <target state="translated">@nospecialize</target>
        </trans-unit>
        <trans-unit id="cacd42ee4286c01451a0c3f4cbfa6028f915c0f9" translate="yes" xml:space="preserve">
          <source>@polly</source>
          <target state="translated">@polly</target>
        </trans-unit>
        <trans-unit id="4806d3609cdd2247d8453f645dee6710dc41ea0f" translate="yes" xml:space="preserve">
          <source>@propagate_inbounds</source>
          <target state="translated">@propagate_inbounds</target>
        </trans-unit>
        <trans-unit id="8d60f37515947a1cb20c28aea812b1fc5a9f5bf0" translate="yes" xml:space="preserve">
          <source>@pure</source>
          <target state="translated">@pure</target>
        </trans-unit>
        <trans-unit id="3a55093c30bbbe794bf8d402406d8fcf7a4d1310" translate="yes" xml:space="preserve">
          <source>@r_str</source>
          <target state="translated">@r_str</target>
        </trans-unit>
        <trans-unit id="5996760e14e5f71bfe6fa0d484bd050be2d81350" translate="yes" xml:space="preserve">
          <source>@raw_str</source>
          <target state="translated">@raw_str</target>
        </trans-unit>
        <trans-unit id="97cb7ca3c593693dc788600f2394549a69a72d68" translate="yes" xml:space="preserve">
          <source>@s_str</source>
          <target state="translated">@s_str</target>
        </trans-unit>
        <trans-unit id="0b2cd610c2ee6714f1bb72ef08e30cbecc00753b" translate="yes" xml:space="preserve">
          <source>@show</source>
          <target state="translated">@show</target>
        </trans-unit>
        <trans-unit id="74ed0e99c473ebedb95b8c861f075073cb57397f" translate="yes" xml:space="preserve">
          <source>@specialize</source>
          <target state="translated">@specialize</target>
        </trans-unit>
        <trans-unit id="151387036f429960867face2abcd91f32770c4e2" translate="yes" xml:space="preserve">
          <source>@static</source>
          <target state="translated">@static</target>
        </trans-unit>
        <trans-unit id="a68f475d88760f9b0feb2de9ebbfc91426a3b8f2" translate="yes" xml:space="preserve">
          <source>@sync</source>
          <target state="translated">@sync</target>
        </trans-unit>
        <trans-unit id="d38a8f83640ce0fff0b022161540cfdf0fb32550" translate="yes" xml:space="preserve">
          <source>@task</source>
          <target state="translated">@task</target>
        </trans-unit>
        <trans-unit id="aa18b4621d361b5a46f6036593dc03baa5cf1328" translate="yes" xml:space="preserve">
          <source>@threadcall</source>
          <target state="translated">@threadcall</target>
        </trans-unit>
        <trans-unit id="692eee2d0727b5f3f157c333231a8f4d656b6df0" translate="yes" xml:space="preserve">
          <source>@threadcall (Experimental)</source>
          <target state="translated">@threadcall (экспериментальный)</target>
        </trans-unit>
        <trans-unit id="cd087251781047bb579dc74d06a058b6ba3920e2" translate="yes" xml:space="preserve">
          <source>@time</source>
          <target state="translated">@time</target>
        </trans-unit>
        <trans-unit id="8568facb0a4570662a512fe404e622e193f338a6" translate="yes" xml:space="preserve">
          <source>@timed</source>
          <target state="translated">@timed</target>
        </trans-unit>
        <trans-unit id="27b687fc74e91aa623c8e1b6ee200080f7df4707" translate="yes" xml:space="preserve">
          <source>@timev</source>
          <target state="translated">@timev</target>
        </trans-unit>
        <trans-unit id="805c0ec7ef38a1e449165679942f376bf2b79ddf" translate="yes" xml:space="preserve">
          <source>@v_str</source>
          <target state="translated">@v_str</target>
        </trans-unit>
        <trans-unit id="30bb2b68176ace645967cfe93607300e8069c9f2" translate="yes" xml:space="preserve">
          <source>@view</source>
          <target state="translated">@view</target>
        </trans-unit>
        <trans-unit id="c0636d48f28866f15bfbc1ee9241d4414596eec3" translate="yes" xml:space="preserve">
          <source>@views</source>
          <target state="translated">@views</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="ae3a173d257f68d7b3200b2390513b03472ff42a" translate="yes" xml:space="preserve">
          <source>A &quot;strided&quot; array is stored in memory with elements laid out in regular offsets such that an instance with a supported &lt;code&gt;isbits&lt;/code&gt; element type can be passed to external C and Fortran functions that expect this memory layout. Strided arrays must define a &lt;a href=&quot;../../base/arrays/index#Base.strides&quot;&gt;&lt;code&gt;strides(A)&lt;/code&gt;&lt;/a&gt; method that returns a tuple of &quot;strides&quot; for each dimension; a provided &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt;&lt;code&gt;stride(A,k)&lt;/code&gt;&lt;/a&gt; method accesses the &lt;code&gt;k&lt;/code&gt;th element within this tuple. Increasing the index of dimension &lt;code&gt;k&lt;/code&gt; by &lt;code&gt;1&lt;/code&gt; should increase the index &lt;code&gt;i&lt;/code&gt; of &lt;code&gt;getindex(A,i)&lt;/code&gt; by &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt;&lt;code&gt;stride(A,k)&lt;/code&gt;&lt;/a&gt;. If a pointer conversion method &lt;a href=&quot;../../base/c/index#Base.unsafe_convert&quot;&gt;&lt;code&gt;Base.unsafe_convert(Ptr{T}, A)&lt;/code&gt;&lt;/a&gt; is provided, the memory layout must correspond in the same way to these strides. &lt;code&gt;DenseArray&lt;/code&gt; is a very specific example of a strided array where the elements are arranged contiguously, thus it provides its subtypes with the appropriate definition of &lt;code&gt;strides&lt;/code&gt;. More concrete examples can be found within the &lt;a href=&quot;../interfaces/index#man-interface-strided-arrays-1&quot;&gt;interface guide for strided arrays&lt;/a&gt;. &lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt;&lt;code&gt;StridedVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt; are convenient aliases for many of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.</source>
          <target state="translated">&amp;laquo;Строчный&amp;raquo; массив хранится в памяти с элементами, размещенными в регулярных смещениях, так что экземпляр с поддерживаемым &lt;code&gt;isbits&lt;/code&gt; элемента isbits может быть передан внешним функциям C и Fortran, которые ожидают этого макета памяти. Массивы с &lt;a href=&quot;../../base/arrays/index#Base.strides&quot;&gt; &lt;code&gt;strides(A)&lt;/code&gt; &lt;/a&gt; должны определять метод strides (A), который возвращает кортеж &amp;laquo;шагов&amp;raquo; для каждого измерения; предоставленный метод &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt; &lt;code&gt;stride(A,k)&lt;/code&gt; &lt;/a&gt; обращается к &lt;code&gt;k&lt;/code&gt; - му элементу в этом кортеже. Увеличение индекса измерения &lt;code&gt;k&lt;/code&gt; на &lt;code&gt;1&lt;/code&gt; должно увеличивать индекс &lt;code&gt;i&lt;/code&gt; для &lt;code&gt;getindex(A,i)&lt;/code&gt; на &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt; &lt;code&gt;stride(A,k)&lt;/code&gt; &lt;/a&gt; . Если метод преобразования указателя &lt;a href=&quot;../../base/c/index#Base.unsafe_convert&quot;&gt; &lt;code&gt;Base.unsafe_convert(Ptr{T}, A)&lt;/code&gt; &lt;/a&gt;предусмотрено, макет памяти должен точно так же соответствовать этим шагам. &lt;code&gt;DenseArray&lt;/code&gt; - это очень специфический пример массива с полосами, в котором элементы расположены непрерывно, поэтому он предоставляет своим подтипам соответствующее определение &lt;code&gt;strides&lt;/code&gt; . Более конкретные примеры можно найти в &lt;a href=&quot;../interfaces/index#man-interface-strided-arrays-1&quot;&gt;руководстве по интерфейсу для полосатых массивов&lt;/a&gt; . &lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt; &lt;code&gt;StridedVector&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; &lt;/a&gt; - удобные псевдонимы для многих типов встроенных массивов, которые считаются последовательными массивами, что позволяет им отправлять на выбор специализированные реализации, вызывающие хорошо настроенные и оптимизированные функции BLAS и LAPACK, используя только указатель и шаги.</target>
        </trans-unit>
        <trans-unit id="87a6d45076b09098eb9df88807c997bb15e85369" translate="yes" xml:space="preserve">
          <source>A (all)</source>
          <target state="translated">А (все)</target>
        </trans-unit>
        <trans-unit id="9e0270f067c0a720b45c4eb9f114b3b4f763ba05" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#LibGit2.GitCommit&quot;&gt;&lt;code&gt;GitCommit&lt;/code&gt;&lt;/a&gt; will be peeled to a &lt;a href=&quot;#LibGit2.GitTree&quot;&gt;&lt;code&gt;GitTree&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#LibGit2.GitCommit&quot;&gt; &lt;code&gt;GitCommit&lt;/code&gt; &lt;/a&gt; будет очищенный к &lt;a href=&quot;#LibGit2.GitTree&quot;&gt; &lt;code&gt;GitTree&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba75f83e672a51cdb25eeef228f835e8a4e0af8a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt; operator represents a scalar times the identity operator, &lt;code&gt;&amp;lambda;*I&lt;/code&gt;. The identity operator &lt;code&gt;I&lt;/code&gt; is defined as a constant and is an instance of &lt;code&gt;UniformScaling&lt;/code&gt;. The size of these operators are generic and match the other matrix in the binary operations &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt;. For &lt;code&gt;A+I&lt;/code&gt; and &lt;code&gt;A-I&lt;/code&gt; this means that &lt;code&gt;A&lt;/code&gt; must be square. Multiplication with the identity operator &lt;code&gt;I&lt;/code&gt; is a noop (except for checking that the scaling factor is one) and therefore almost without overhead.</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; &lt;/a&gt; оператор представляет собой скалярные раз тождественный оператор, &lt;code&gt;&amp;lambda;*I&lt;/code&gt; . Оператор идентичности &lt;code&gt;I&lt;/code&gt; определяется как константа и является экземпляром &lt;code&gt;UniformScaling&lt;/code&gt; . Размер этих операторов является общим и соответствует другой матрице в бинарных операциях &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; и &lt;code&gt;\&lt;/code&gt; . Для &lt;code&gt;A+I&lt;/code&gt; и &lt;code&gt;A-I&lt;/code&gt; это означает, что &lt;code&gt;A&lt;/code&gt; должно быть квадратным. Умножение с оператором идентичности &lt;code&gt;I&lt;/code&gt; не требует никаких затрат (за исключением проверки того, что коэффициент масштабирования равен единице) и, следовательно, почти без накладных расходов.</target>
        </trans-unit>
        <trans-unit id="c842dce0eb13d715db2132316b0c05a4d0e9a5e4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; that sets the value of &lt;code&gt;Distributed.worker_timeout()&lt;/code&gt; (default: &lt;code&gt;60.0&lt;/code&gt;). This function gives the number of seconds a worker process will wait for a master process to establish a connection before dying.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; , который устанавливает значение &lt;code&gt;Distributed.worker_timeout()&lt;/code&gt; ( по умолчанию: &lt;code&gt;60.0&lt;/code&gt; ). Эта функция дает количество секунд, в течение которых рабочий процесс будет ждать, пока главный процесс установит соединение, прежде чем завершиться.</target>
        </trans-unit>
        <trans-unit id="f904b64ee325fb09a13719884cf4994b4a67dc0b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is in an open state initially. This means that it can be read from and written to freely via &lt;code&gt;take!&lt;/code&gt; and &lt;code&gt;put!&lt;/code&gt; calls. &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; closes a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;. On a closed &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;put!&lt;/code&gt; will fail. For example:</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; находится в открытом состоянии на начальном этапе. Это означает, что его можно свободно читать и записывать с помощью &lt;code&gt;take!&lt;/code&gt; и &lt;code&gt;put!&lt;/code&gt; звонки. &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; закрывает &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; . На закрытом &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;put!&lt;/code&gt; не удастся. Например:</target>
        </trans-unit>
        <trans-unit id="8375d9780c1ae8c1682f81b0f7a6ce2515b39852" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is local to a process. Worker 2 cannot directly refer to a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; on worker 3 and vice-versa. A &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;, however, can put and take values across workers.</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; является локальным для процесса. Работник 2 не может напрямую ссылаться на &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; на работнике 3 и наоборот. Однако &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; может передавать и принимать значения между исполнителями.</target>
        </trans-unit>
        <trans-unit id="fc8c6fb411b59b42a835d08f8b3cc960e82887e0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; can be thought of as a &lt;em&gt;handle&lt;/em&gt; to a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; можно рассматривать как &lt;em&gt;ручки&lt;/em&gt; на &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17cfa5600f21f142fc6aae797119fcc13529b73c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; iterator of length &lt;code&gt;n&lt;/code&gt; whose elements exponentially increase at a rate in the interval &lt;code&gt;factor&lt;/code&gt; * (1 &amp;plusmn; &lt;code&gt;jitter&lt;/code&gt;). The first element is &lt;code&gt;first_delay&lt;/code&gt; and all elements are clamped to &lt;code&gt;max_delay&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; итератор длиной &lt;code&gt;n&lt;/code&gt; , элементы которой растет экспоненциально со скоростью в интервале &lt;code&gt;factor&lt;/code&gt; * (1 &amp;plusmn; &lt;code&gt;jitter&lt;/code&gt; ). Первый элемент - &lt;code&gt;first_delay&lt;/code&gt; , и все элементы &lt;code&gt;max_delay&lt;/code&gt; на max_delay .</target>
        </trans-unit>
        <trans-unit id="7c79d61fbf339539f4166e2a7bfbe466aba53081" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; pair, which must be written as a literal constant,</source>
          <target state="translated">&lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; пара, который должен быть записан в виде буквальной константы,</target>
        </trans-unit>
        <trans-unit id="524fcaed9fa041013c206a6350ca0d844bfa68a7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(name, library)&lt;/code&gt; function specification must be a constant expression. However, it is possible to use computed values as function names by staging through &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; as follows:</source>
          <target state="translated">&lt;code&gt;(name, library)&lt;/code&gt; функция спецификация должна быть константным выражением. Тем не менее, можно использовать вычисленные значения в качестве имен функций, используя &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="d15e6f0f33d377d6237a8e9e56d281edb772d043" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;:&lt;/code&gt; character on either end of a column's header separator (the row containing &lt;code&gt;-&lt;/code&gt; characters) specifies whether the row is left-aligned, right-aligned, or (when &lt;code&gt;:&lt;/code&gt; appears on both ends) center-aligned. Providing no &lt;code&gt;:&lt;/code&gt; characters will default to right-aligning the column.</source>
          <target state="translated">A &lt;code&gt;:&lt;/code&gt; символ на любом конце разделителя заголовка столбца (строка, содержащая символы &lt;code&gt;-&lt;/code&gt; ) определяет, выравнивается ли строка по левому краю, по правому краю или (когда &lt;code&gt;:&lt;/code&gt; появляется на обоих концах) по центру. Если нет &lt;code&gt;:&lt;/code&gt; символы по умолчанию выравнивают столбец по правому краю.</target>
        </trans-unit>
        <trans-unit id="d46ad2498166339bc8bbf3585924bc43d1e8d5c2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BufferStream&lt;/code&gt; is an in-memory &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; which behaves like an &lt;code&gt;IO&lt;/code&gt;&amp;ndash;it is a stream which can be handled asynchronously.</source>
          <target state="translated">&lt;code&gt;BufferStream&lt;/code&gt; находится в оперативной памяти &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt; , которая ведет себя как &lt;code&gt;IO&lt;/code&gt; -IT представляет собой поток , который может быть обработан асинхронно.</target>
        </trans-unit>
        <trans-unit id="d1f408408afbccca18234c62817be522377e93f0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CartesianIndex&lt;/code&gt; is sometimes produced by &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt;, and always when iterating with an explicit &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CartesianIndex&lt;/code&gt; иногда производится &lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; , и всегда при переборе с явной &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d375921fbca2bf53253dd9c9c9cb98fe33f687c8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Channel&lt;/code&gt; can be used as an iterable object in a &lt;code&gt;for&lt;/code&gt; loop, in which case the loop runs as long as the &lt;code&gt;Channel&lt;/code&gt; has data or is open. The loop variable takes on all values added to the &lt;code&gt;Channel&lt;/code&gt;. The &lt;code&gt;for&lt;/code&gt; loop is terminated once the &lt;code&gt;Channel&lt;/code&gt; is closed and emptied.</source>
          <target state="translated">&lt;code&gt;Channel&lt;/code&gt; может быть использован в качестве итератора объекта в &lt;code&gt;for&lt;/code&gt; цикла, и в этом случае цикл выполняется до тех пор , как &lt;code&gt;Channel&lt;/code&gt; имеет данные или открыто. Переменная цикла принимает все значения, добавленные к &lt;code&gt;Channel&lt;/code&gt; . Цикл &lt;code&gt;for&lt;/code&gt; завершается после закрытия и опорожнения &lt;code&gt;Channel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1464a151c99f208872dfcf6ce120c5e13267f23e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Char&lt;/code&gt; value represents a single character: it is just a 32-bit primitive type with a special literal representation and appropriate arithmetic behaviors, and which can be converted to a numeric value representing a &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;Unicode code point&lt;/a&gt;. (Julia packages may define other subtypes of &lt;code&gt;AbstractChar&lt;/code&gt;, e.g. to optimize operations for other &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding&quot;&gt;text encodings&lt;/a&gt;.) Here is how &lt;code&gt;Char&lt;/code&gt; values are input and shown:</source>
          <target state="translated">Значение &lt;code&gt;Char&lt;/code&gt; представляет один символ: это всего лишь 32-битный примитивный тип со специальным буквальным представлением и соответствующим арифметическим поведением, который можно преобразовать в числовое значение, представляющее &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;кодовую точку Unicode&lt;/a&gt; . (Пакеты Julia могут определять другие подтипы &lt;code&gt;AbstractChar&lt;/code&gt; , например, для оптимизации операций для других &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding&quot;&gt;текстовых кодировок&lt;/a&gt; .) Вот как значения &lt;code&gt;Char&lt;/code&gt; вводятся и отображаются:</target>
        </trans-unit>
        <trans-unit id="29831ac830f246eb0b5dcfbe779b29bb30cb2979" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CompoundPeriod&lt;/code&gt; is useful for expressing time periods that are not a fixed multiple of smaller periods. For example, &quot;a year and a day&quot; is not a fixed number of days, but can be expressed using a &lt;code&gt;CompoundPeriod&lt;/code&gt;. In fact, a &lt;code&gt;CompoundPeriod&lt;/code&gt; is automatically generated by addition of different period types, e.g. &lt;code&gt;Year(1) + Day(1)&lt;/code&gt; produces a &lt;code&gt;CompoundPeriod&lt;/code&gt; result.</source>
          <target state="translated">&lt;code&gt;CompoundPeriod&lt;/code&gt; полезно для выражения периодов времени, которые не являются фиксированной кратно меньших периодов. Например, &amp;laquo;год и день&amp;raquo; - это не фиксированное количество дней, но его можно выразить с помощью &lt;code&gt;CompoundPeriod&lt;/code&gt; . Фактически &lt;code&gt;CompoundPeriod&lt;/code&gt; автоматически генерируется путем добавления различных типов периодов, например, &lt;code&gt;Year(1) + Day(1)&lt;/code&gt; дает результат &lt;code&gt;CompoundPeriod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="013639aa4c9e00f4e19703e4c05f20b5824ce3b4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DataType&lt;/code&gt; may be abstract or concrete. If it is concrete, it has a specified size, storage layout, and (optionally) field names. Thus a primitive type is a &lt;code&gt;DataType&lt;/code&gt; with nonzero size, but no field names. A composite type is a &lt;code&gt;DataType&lt;/code&gt; that has field names or is empty (zero size).</source>
          <target state="translated">&lt;code&gt;DataType&lt;/code&gt; может быть абстрактными или бетоном. Если он конкретный, он имеет указанный размер, схему хранения и (необязательно) имена полей. Таким образом, примитивный тип - это &lt;code&gt;DataType&lt;/code&gt; с ненулевым размером, но без имен полей. Составной тип - это &lt;code&gt;DataType&lt;/code&gt; , имеющий имена полей или пустой (нулевой размер).</target>
        </trans-unit>
        <trans-unit id="c0a8047ce7922366b0e1686ff32c1d95d34209f7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitCommit&lt;/code&gt; will be peeled to a &lt;code&gt;GitTree&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GitCommit&lt;/code&gt; будет очищенный к &lt;code&gt;GitTree&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d18c2ea92257c3ec465776fe14e9a5ed1ec94622" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitRevWalker&lt;/code&gt;&lt;em&gt;walks&lt;/em&gt; through the &lt;em&gt;revisions&lt;/em&gt; (i.e. commits) of a git repository &lt;code&gt;repo&lt;/code&gt;. It is a collection of the commits in the repository, and supports iteration and calls to &lt;a href=&quot;#LibGit2.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LibGit2.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; (for instance, &lt;code&gt;count&lt;/code&gt; could be used to determine what percentage of commits in a repository were made by a certain author).</source>
          <target state="translated">&lt;code&gt;GitRevWalker&lt;/code&gt; &lt;em&gt;ходит&lt;/em&gt; по &lt;em&gt;пересмотру&lt;/em&gt; (т.е. фиксаций) одного мерзавца хранилища &lt;code&gt;repo&lt;/code&gt; . Это набор коммитов в репозитории, который поддерживает итерацию и вызовы для &lt;a href=&quot;#LibGit2.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#LibGit2.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; (например, &lt;code&gt;count&lt;/code&gt; можно использовать для определения того, какой процент коммитов в репозитории был сделан определенным автором).</target>
        </trans-unit>
        <trans-unit id="7218806e6e918d7a7efe224d0bbd25603b822749" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitTag&lt;/code&gt; will be peeled to the object it references.</source>
          <target state="translated">&lt;code&gt;GitTag&lt;/code&gt; будет очищен до объекта он ссылается.</target>
        </trans-unit>
        <trans-unit id="56db16f375b3ec2b4282d7f16a671aeb187ec450" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MIME&lt;/code&gt; object can be passed as the second argument to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt; to request output in that format.</source>
          <target state="translated">&lt;code&gt;MIME&lt;/code&gt; - объект может быть передан в качестве второго аргумента &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt; для вывода запроса в этом формате.</target>
        </trans-unit>
        <trans-unit id="64ab14f4b27b0ebae05bdd35cfc7b0f0829b66e2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MersenneTwister&lt;/code&gt; or &lt;code&gt;RandomDevice&lt;/code&gt; RNG can generate uniformly random numbers of the following types: &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int16&quot;&gt;&lt;code&gt;Int16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt32&quot;&gt;&lt;code&gt;UInt32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt64&quot;&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt;&lt;code&gt;Int128&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt128&quot;&gt;&lt;code&gt;UInt128&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; (or complex numbers of those types). Random floating point numbers are generated uniformly in $[0, 1)$. As &lt;code&gt;BigInt&lt;/code&gt; represents unbounded integers, the interval must be specified (e.g. &lt;code&gt;rand(big.(1:6))&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;MersenneTwister&lt;/code&gt; или &lt;code&gt;RandomDevice&lt;/code&gt; ГСЧ может генерировать равномерно случайные числа следующих типов: &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int16&quot;&gt; &lt;code&gt;Int16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt32&quot;&gt; &lt;code&gt;UInt32&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt64&quot;&gt; &lt;code&gt;UInt64&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt; &lt;code&gt;Int128&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt128&quot;&gt; &lt;code&gt;UInt128&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; (или комплексные числа этих типов). Случайные числа с плавающей запятой генерируются равномерно в $ [0, 1) $. Как &lt;code&gt;BigInt&lt;/code&gt; представляет неограниченные целые числа, интервал должен быть указан (например, &lt;code&gt;rand(big.(1:6))&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fcc156039502be223f5f3af68d44a563690ef471" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Module&lt;/code&gt; is a separate global variable workspace. See &lt;a href=&quot;#module&quot;&gt;&lt;code&gt;module&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; является отдельной глобальной переменной рабочей областью. См. &lt;a href=&quot;#module&quot;&gt; &lt;code&gt;module&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;раздел руководства о модулях&lt;/a&gt; для получения подробной информации.</target>
        </trans-unit>
        <trans-unit id="fe27036120fb22dce22db3d877ea4b7e275e7b94" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NamedTuple&lt;/code&gt; type can be used as a constructor, accepting a single tuple argument. The constructed &lt;code&gt;NamedTuple&lt;/code&gt; type can be either a concrete type, with both parameters specified, or a type that specifies only field names:</source>
          <target state="translated">Тип &lt;code&gt;NamedTuple&lt;/code&gt; можно использовать как конструктор, принимающий единственный аргумент кортежа. Построенная &lt;code&gt;NamedTuple&lt;/code&gt; типа может быть либо типа бетона, с указанным оба параметра, или типа , который определяет только имена полей:</target>
        </trans-unit>
        <trans-unit id="ea99f7079d8791c0343a7307d5e653f1f644267c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Polar&lt;/code&gt; object will then display automatically using HTML in an environment that supports HTML display, but you can call &lt;code&gt;show&lt;/code&gt; manually to get HTML output if you want:</source>
          <target state="translated">Затем объект &lt;code&gt;Polar&lt;/code&gt; будет автоматически отображаться с использованием HTML в среде, которая поддерживает отображение HTML, но вы можете вызвать &lt;code&gt;show&lt;/code&gt; вручную, чтобы получить вывод HTML, если хотите:</target>
        </trans-unit>
        <trans-unit id="c3372e99dcae94f7a8aba1e912fc8ad984983e16" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;VersionNumber&lt;/code&gt; object describing which version of Julia is in use. For details see &lt;a href=&quot;../../manual/strings/index#man-version-number-literals-1&quot;&gt;Version Number Literals&lt;/a&gt;.</source>
          <target state="translated">Объект &lt;code&gt;VersionNumber&lt;/code&gt; , описывающий, какая версия Julia используется. Подробнее см. &lt;a href=&quot;../../manual/strings/index#man-version-number-literals-1&quot;&gt;Литералы номера версии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac1b0b9643100f5709d747b0fa1193640db35af9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do&lt;/code&gt; block, like any other inner function, can &quot;capture&quot; variables from its enclosing scope. For example, the variable &lt;code&gt;data&lt;/code&gt; in the above example of &lt;code&gt;open...do&lt;/code&gt; is captured from the outer scope. Captured variables can create performance challenges as discussed in &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="translated">Блок &lt;code&gt;do&lt;/code&gt; , как и любая другая внутренняя функция, может &amp;laquo;захватывать&amp;raquo; переменные из окружающей его области видимости. Например, &lt;code&gt;data&lt;/code&gt; переменных в приведенном выше примере &lt;code&gt;open...do&lt;/code&gt; захватываются из внешней области. Захваченные переменные могут создавать проблемы с производительностью, как описано в &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;советах&lt;/a&gt; по производительности .</target>
        </trans-unit>
        <trans-unit id="13afa4d8f5eaeee48f3a15d19e444c7dc58d320a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop or comprehension iteration variable is always a new variable:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; цикла или переменной понимание итерации всегда новая переменная:</target>
        </trans-unit>
        <trans-unit id="1cc87568b64210c7c32ecbee8a0599fd750c9777" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;group&lt;/code&gt; for the event, which is set to the base name of the file by default, without extension. This can be used to group messages into categories more finely than the log level (for example, all deprecation warnings have group &lt;code&gt;:depwarn&lt;/code&gt;), or into logical groupings across or within modules.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; для события, которое устанавливается на базовое имя файла по умолчанию, без расширения. Это можно использовать для более &lt;code&gt;:depwarn&lt;/code&gt; группировки сообщений по категориям, чем уровень журнала (например, все предупреждения об устаревании имеют group : depwarn ) или в логические группировки по модулям или внутри них.</target>
        </trans-unit>
        <trans-unit id="236e91049303fa66d220cd5b5421a9050d83f949" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; statement allows intercepting errors (exceptions) thrown by &lt;a href=&quot;#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; so that program execution can continue. For example, the following code attempts to write a file, but warns the user and proceeds instead of terminating execution if the file cannot be written:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; утверждение позволяет перехватывать ошибки (исключения) , брошенные &lt;a href=&quot;#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt; , так что выполнение программы может быть продолжено. Например, следующий код пытается записать файл, но предупреждает пользователя и продолжает вместо завершения выполнения, если файл не может быть записан:</target>
        </trans-unit>
        <trans-unit id="6f7e3d0cb44d68c0e786c74714c652c1e6239ca4" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;package&lt;/em&gt; is a source tree with a standard layout providing functionality that can be reused by other Julia projects. A package is loaded by &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt; statements. These statements also make the module named &lt;code&gt;X&lt;/code&gt;&amp;mdash;which results from loading the package code&amp;mdash;available within the module where the import statement occurs. The meaning of &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;import X&lt;/code&gt; is context-dependent: which &lt;code&gt;X&lt;/code&gt; package is loaded depends on what code the statement occurs in. Thus, handling of &lt;code&gt;import X&lt;/code&gt; happens in two stages: first, it determines &lt;strong&gt;what&lt;/strong&gt; package is defined to be &lt;code&gt;X&lt;/code&gt; in this context; second, it determines &lt;strong&gt;where&lt;/strong&gt; that particular &lt;code&gt;X&lt;/code&gt; package is found.</source>
          <target state="translated">&lt;em&gt;Пакет&lt;/em&gt; является источник дерева со стандартной компоновкой обеспечения функциональных возможностей, которые могут быть повторно использованы в других проектах Юлия. Пакет загружается с помощью &lt;code&gt;import X&lt;/code&gt; или &lt;code&gt;using X&lt;/code&gt; операторов X. Эти операторы также делают модуль с именем &lt;code&gt;X&lt;/code&gt; , который является результатом загрузки кода пакета, доступным внутри модуля, в котором выполняется оператор импорта. Значение &lt;code&gt;X&lt;/code&gt; в &lt;code&gt;import X&lt;/code&gt; зависит от контекста: какой пакет &lt;code&gt;X&lt;/code&gt; загружен, зависит от того, в каком коде встречается оператор. Таким образом, обработка &lt;code&gt;import X&lt;/code&gt; происходит в два этапа: во-первых, он определяет, &lt;strong&gt;какой&lt;/strong&gt; пакет определен как &lt;code&gt;X&lt;/code&gt; в контексте; во-вторых, он определяет, &lt;strong&gt;где находится&lt;/strong&gt; этот конкретный пакет &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ea5ce3cb4556ddc297c6aeebda772ae9221423a" translate="yes" xml:space="preserve">
          <source>A C function declared to return &lt;code&gt;Cvoid&lt;/code&gt; will return the value &lt;code&gt;nothing&lt;/code&gt; in Julia.</source>
          <target state="translated">Функция AC, объявленная как возвращающая &lt;code&gt;Cvoid&lt;/code&gt; , вернет в Julia значение &lt;code&gt;nothing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="def83ea9fa11b0a4be5ef6b08c5ce4257e5755ca" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native character type &lt;a href=&quot;#Base.Cchar&quot;&gt;&lt;code&gt;Cchar&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native wide character type, see &lt;a href=&quot;#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">Строка в стиле C, состоящая из собственного символьного типа &lt;a href=&quot;#Base.Cchar&quot;&gt; &lt;code&gt;Cchar&lt;/code&gt; &lt;/a&gt; s. &lt;code&gt;Cstring&lt;/code&gt; завершаются NUL. Для строк в стиле C, состоящих из собственного типа широких символов, см. &lt;a href=&quot;#Base.Cwstring&quot;&gt; &lt;code&gt;Cwstring&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о взаимодействии строк с C см. В &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;руководстве&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac0a9fe2ade0eb6e9c2e2cc4b61f726d6a965d9c" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native wide character type &lt;a href=&quot;#Base.Cwchar_t&quot;&gt;&lt;code&gt;Cwchar_t&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cwstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native character type, see &lt;a href=&quot;#Base.Cstring&quot;&gt;&lt;code&gt;Cstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">Строка в стиле C, состоящая из собственного типа широких символов &lt;a href=&quot;#Base.Cwchar_t&quot;&gt; &lt;code&gt;Cwchar_t&lt;/code&gt; &lt;/a&gt; s. &lt;code&gt;Cwstring&lt;/code&gt; завершаются NUL. Для строк в стиле C, состоящих из собственного символьного типа, см. &lt;a href=&quot;#Base.Cstring&quot;&gt; &lt;code&gt;Cstring&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о взаимодействии строк с C см. В &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;руководстве&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="023376b34dc0e6e575fb072d80744bfc1276423d" translate="yes" xml:space="preserve">
          <source>A Givens rotation linear operator. The fields &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt; represent the cosine and sine of the rotation angle, respectively. The &lt;code&gt;Givens&lt;/code&gt; type supports left multiplication &lt;code&gt;G*A&lt;/code&gt; and conjugated transpose right multiplication &lt;code&gt;A*G'&lt;/code&gt;. The type doesn't have a &lt;code&gt;size&lt;/code&gt; and can therefore be multiplied with matrices of arbitrary size as long as &lt;code&gt;i2&amp;lt;=size(A,2)&lt;/code&gt; for &lt;code&gt;G*A&lt;/code&gt; or &lt;code&gt;i2&amp;lt;=size(A,1)&lt;/code&gt; for &lt;code&gt;A*G'&lt;/code&gt;.</source>
          <target state="translated">Линейный оператор вращения Гивенса. Поля &lt;code&gt;c&lt;/code&gt; и &lt;code&gt;s&lt;/code&gt; представляют собой косинус и синус угла поворота соответственно. Тип &lt;code&gt;Givens&lt;/code&gt; поддерживает левое умножение &lt;code&gt;G*A&lt;/code&gt; и сопряженное транспонирование правого умножения &lt;code&gt;A*G'&lt;/code&gt; . Тип не имеет &lt;code&gt;size&lt;/code&gt; и поэтому может быть умножен на матрицы произвольного размера, если &lt;code&gt;i2&amp;lt;=size(A,2)&lt;/code&gt; для &lt;code&gt;G*A&lt;/code&gt; или &lt;code&gt;i2&amp;lt;=size(A,1)&lt;/code&gt; для &lt;code&gt;A*G'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0f95cfdddef2f3b16bd0eaacf8c5ec7871a86e5" translate="yes" xml:space="preserve">
          <source>A Julia Function</source>
          <target state="translated">Функция Джулии</target>
        </trans-unit>
        <trans-unit id="338b907694ffa95225d1463f09b5454501424162" translate="yes" xml:space="preserve">
          <source>A Julia cluster has the following characteristics:</source>
          <target state="translated">Кластер Джулия обладает следующими характеристиками:</target>
        </trans-unit>
        <trans-unit id="afbb147573dcd49250e15c543ce261c2ed456757" translate="yes" xml:space="preserve">
          <source>A Julia script may contain any number of functions, and all definitions will be externally visible when the file is loaded. Function definitions can be loaded from files outside the current working directory.</source>
          <target state="translated">Скрипт Julia может содержать любое количество функций,и все определения будут внешне видны при загрузке файла.Определения функций могут быть загружены из файлов вне текущей рабочей директории.</target>
        </trans-unit>
        <trans-unit id="ec5c0a21b198e35d9011cfccf1720c04200ccca0" translate="yes" xml:space="preserve">
          <source>A LibGit2 credential callback function which provides different credential acquisition functionality w.r.t. a connection protocol. The &lt;code&gt;payload_ptr&lt;/code&gt; is required to contain a &lt;code&gt;LibGit2.CredentialPayload&lt;/code&gt; object which will keep track of state and settings.</source>
          <target state="translated">Функция обратного вызова учетных данных LibGit2, которая обеспечивает различные функции получения учетных данных по протоколу подключения. &lt;code&gt;payload_ptr&lt;/code&gt; обязан содержать &lt;code&gt;LibGit2.CredentialPayload&lt;/code&gt; объект , который будет следить за состоянием и настройками.</target>
        </trans-unit>
        <trans-unit id="01a933ad46a5f5ec0c3c3e174d75cd08e0a9bf13" translate="yes" xml:space="preserve">
          <source>A LibGit2 representation of an array of strings. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_strarray&quot;&gt;&lt;code&gt;git_strarray&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Представление LibGit2 массива строк. Соответствует структуре &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_strarray&quot;&gt; &lt;code&gt;git_strarray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb6b4f3bedfc4889701c09c75dc083d1c8d58006" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization stored in a compact blocked format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">Факторизация QR-матрицы, хранящаяся в компактном блочном формате, обычно получается из &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; . Если $ A $ - матрица размера &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; , то</target>
        </trans-unit>
        <trans-unit id="a2bfddaee8ff7a44aec0ab4b2b1e184a0f187d2e" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization stored in a packed format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">Факторизация QR-матрицы, хранящаяся в упакованном формате, обычно полученная из &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; . Если $ A $ - матрица размера &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; , то</target>
        </trans-unit>
        <trans-unit id="c9925c571d2e1e694cc1d660f2d03ec4cf1ec057" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization with column pivoting in a packed format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">Факторизация QR-матрицы с поворотом столбцов в упакованном формате, обычно получаемая из &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; . Если $ A $ - матрица размера &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; , то</target>
        </trans-unit>
        <trans-unit id="028b2fd647f67d6a5b3b18c1e2a4be06ea973f76" translate="yes" xml:space="preserve">
          <source>A basic editor/REPL workflow</source>
          <target state="translated">Базовый редактор/РЕПОЛЬНЫЙ рабочий процесс</target>
        </trans-unit>
        <trans-unit id="3e270c005ba798894763e8eb54b974bf29e5d476" translate="yes" xml:space="preserve">
          <source>A buffered IO stream wrapping an OS file descriptor. Mostly used to represent files returned by &lt;a href=&quot;#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Буферизованный поток ввода-вывода, обертывающий файловый дескриптор ОС. В основном используется для представления файлов, возвращаемых &lt;a href=&quot;#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6761a9dad52906730c7e2d2e824c87ab1ba9a0c" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt; returns a vector of &lt;code&gt;Union{Ptr{Nothing}, Base.InterpreterIP}&lt;/code&gt;, which may then be passed into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt; for translation:</source>
          <target state="translated">Вызов &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt; возвращает вектор &lt;code&gt;Union{Ptr{Nothing}, Base.InterpreterIP}&lt;/code&gt; , который затем может быть передан в &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt; для перевода:</target>
        </trans-unit>
        <trans-unit id="783595edaa0cd8106f88e2687e628c9ad8922d54" translate="yes" xml:space="preserve">
          <source>A cartesian indexing style uses multiple integers/indices to describe the position in the array. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;(2, 3, 4)&lt;/code&gt; custom matrix type with cartesian indexing, we could reference &lt;code&gt;A[2, 1, 3]&lt;/code&gt; and Julia would automatically convert this into the correct location in the underlying memory. See also &lt;a href=&quot;#Base.IndexLinear&quot;&gt;&lt;code&gt;IndexLinear&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В декартовом стиле индексации для описания позиции в массиве используется несколько целых чисел / индексов. Например, если бы &lt;code&gt;A&lt;/code&gt; был пользовательским типом матрицы &lt;code&gt;(2, 3, 4)&lt;/code&gt; с декартовой индексацией, мы могли бы ссылаться на &lt;code&gt;A[2, 1, 3]&lt;/code&gt; и Джулия автоматически преобразовала бы это в правильное место в базовой памяти. См. Также &lt;a href=&quot;#Base.IndexLinear&quot;&gt; &lt;code&gt;IndexLinear&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b670cf7ce6aa053516969f59beb26f75521a626" translate="yes" xml:space="preserve">
          <source>A channel can be visualized as a pipe, i.e., it has a write end and a read end :</source>
          <target state="translated">Канал можно визуализировать как трубу,т.е.у него есть конец для записи и конец для чтения:</target>
        </trans-unit>
        <trans-unit id="cda0bd3645d716870c693b3b59018dd4924caf33" translate="yes" xml:space="preserve">
          <source>A classic example is the standard C library &lt;code&gt;qsort&lt;/code&gt; function, declared as:</source>
          <target state="translated">Классическим примером является стандартная функция &lt;code&gt;qsort&lt;/code&gt; библиотеки C , объявленная как:</target>
        </trans-unit>
        <trans-unit id="e90162b2f2534c5d2ad98ffd6060c363829dd8a7" translate="yes" xml:space="preserve">
          <source>A cluster spanning machines using the &lt;code&gt;--machine-file&lt;/code&gt; option. This uses a passwordless &lt;code&gt;ssh&lt;/code&gt; login to start Julia worker processes (from the same path as the current host) on the specified machines.</source>
          <target state="translated">Кластер, охватывающий машины, использующий параметр &lt;code&gt;--machine-file&lt;/code&gt; . При этом используется вход по &lt;code&gt;ssh&lt;/code&gt; без пароля для запуска рабочих процессов Julia (с того же пути, что и текущий хост) на указанных машинах.</target>
        </trans-unit>
        <trans-unit id="7d02127d252ebd3948a9767c4487385c4243c197" translate="yes" xml:space="preserve">
          <source>A common pitfall when running external programs via a shell is that if a file name contains characters that are special to the shell, they may cause undesirable behavior. Suppose, for example, rather than &lt;code&gt;/etc/passwd&lt;/code&gt;, we wanted to sort the contents of the file &lt;code&gt;/Volumes/External HD/data.csv&lt;/code&gt;. Let's try it:</source>
          <target state="translated">Распространенная ошибка при запуске внешних программ через оболочку заключается в том, что если имя файла содержит символы, которые являются специальными для оболочки, они могут вызвать нежелательное поведение. Предположим, например, что вместо &lt;code&gt;/etc/passwd&lt;/code&gt; мы хотим отсортировать содержимое файла &lt;code&gt;/Volumes/External HD/data.csv&lt;/code&gt; . Давай попробуем:</target>
        </trans-unit>
        <trans-unit id="6454f39a38aef4a6a88d7b516cb03974038d7792" translate="yes" xml:space="preserve">
          <source>A common use of variables is giving names to specific, unchanging values. Such variables are only assigned once. This intent can be conveyed to the compiler using the &lt;a href=&quot;../../base/base/index#const&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">Обычно переменные используются для присвоения имен конкретным неизменным значениям. Такие переменные присваиваются только один раз. Это намерение может быть передано компилятору с помощью ключевого слова &lt;a href=&quot;../../base/base/index#const&quot;&gt; &lt;code&gt;const&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d3cb20f10d68d34ff29611ac3f50ba68dd4c4b99" translate="yes" xml:space="preserve">
          <source>A comprehensive overview of all documentable Julia syntax.</source>
          <target state="translated">Всеобъемлющий обзор всего документального синтаксиса Джулии.</target>
        </trans-unit>
        <trans-unit id="0d6d37f3dca8ed9b04613226e4330c5ab758e3f1" translate="yes" xml:space="preserve">
          <source>A concrete implementation of an &lt;code&gt;AbstractChannel&lt;/code&gt; (like &lt;code&gt;Channel&lt;/code&gt;), is required to implement &lt;code&gt;put!&lt;/code&gt;, &lt;code&gt;take!&lt;/code&gt;, &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;isready&lt;/code&gt; and &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;. The remote object referred to by a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is stored in a &lt;code&gt;Channel{Any}(1)&lt;/code&gt;, i.e., a &lt;code&gt;Channel&lt;/code&gt; of size 1 capable of holding objects of &lt;code&gt;Any&lt;/code&gt; type.</source>
          <target state="translated">Для реализации &lt;code&gt;put!&lt;/code&gt; Требуется конкретная реализация &lt;code&gt;AbstractChannel&lt;/code&gt; (например, &lt;code&gt;Channel&lt;/code&gt; ). , &lt;code&gt;take!&lt;/code&gt; , &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;isready&lt;/code&gt; и &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; . Удаленный объект, на который ссылается &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; , хранится в &lt;code&gt;Channel{Any}(1)&lt;/code&gt; , то есть в &lt;code&gt;Channel&lt;/code&gt; размера 1, способном содержать объекты &lt;code&gt;Any&lt;/code&gt; типа.</target>
        </trans-unit>
        <trans-unit id="e6d94519717188d6531df826c6d7c056c25b4e04" translate="yes" xml:space="preserve">
          <source>A constructor is just like any other function in Julia in that its overall behavior is defined by the combined behavior of its methods. Accordingly, you can add functionality to a constructor by simply defining new methods. For example, let's say you want to add a constructor method for &lt;code&gt;Foo&lt;/code&gt; objects that takes only one argument and uses the given value for both the &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; fields. This is simple:</source>
          <target state="translated">Конструктор похож на любую другую функцию в Julia в том смысле, что его общее поведение определяется комбинированным поведением его методов. Соответственно, вы можете добавить функциональность конструктору, просто определив новые методы. Например, предположим, что вы хотите добавить метод конструктора для объектов &lt;code&gt;Foo&lt;/code&gt; , который принимает только один аргумент и использует заданное значение для полей &lt;code&gt;bar&lt;/code&gt; и &lt;code&gt;baz&lt;/code&gt; . Это просто:</target>
        </trans-unit>
        <trans-unit id="da756968deae2626766b76b59d785afc3e81b3a6" translate="yes" xml:space="preserve">
          <source>A convenience macro for writing &lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt;&lt;code&gt;MIME&lt;/code&gt;&lt;/a&gt; types, typically used when adding methods to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;. For example the syntax &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; could be used to define how to write an HTML representation of &lt;code&gt;MyType&lt;/code&gt;.</source>
          <target state="translated">Удобный макрос для записи типов &lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt; &lt;code&gt;MIME&lt;/code&gt; &lt;/a&gt; , обычно используемый при добавлении методов для &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt; . Например, синтаксис &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; может использоваться для определения того, как писать HTML-представление &lt;code&gt;MyType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce500fee8f2cf895c4ff2e81b81207ab74479894" translate="yes" xml:space="preserve">
          <source>A correct way to define a method that accepts all arguments of type &lt;code&gt;Point{T}&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; is:</source>
          <target state="translated">Правильный способ определения метода, который принимает все аргументы типа &lt;code&gt;Point{T}&lt;/code&gt; где &lt;code&gt;T&lt;/code&gt; - подтип &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; , следующий:</target>
        </trans-unit>
        <trans-unit id="3fdea15c071a796482bb0cbad61dbe066b8e91d1" translate="yes" xml:space="preserve">
          <source>A curated list of useful learning resources to help new users get started can be found on the &lt;a href=&quot;https://julialang.org/learning/&quot;&gt;learning&lt;/a&gt; page of the main Julia web site.</source>
          <target state="translated">Кураторский список полезных учебных ресурсов, которые помогут новым пользователям начать работу, можно найти на странице &lt;a href=&quot;https://julialang.org/learning/&quot;&gt;обучения&lt;/a&gt; на главном веб-сайте Julia.</target>
        </trans-unit>
        <trans-unit id="f02f82182ef74a9efe3bec210a9632727895f0a5" translate="yes" xml:space="preserve">
          <source>A custom title for the box can be provided as a string (in double quotes) after the admonition type. If no title text is specified after the admonition type, then the title used will be the type of the block, i.e. &lt;code&gt;&quot;Note&quot;&lt;/code&gt; in the case of the &lt;code&gt;note&lt;/code&gt; admonition.</source>
          <target state="translated">Пользовательский заголовок для поля может быть указан в виде строки (в двойных кавычках) после типа предупреждения. Если после типа предупреждения не указан текст заголовка, то в качестве заголовка будет использован тип блока, то есть &lt;code&gt;&quot;Note&quot;&lt;/code&gt; в случае &lt;code&gt;note&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66ad883b8ebd4cb13361ac5dca2bf64c895374f2" translate="yes" xml:space="preserve">
          <source>A data buffer for exporting data from libgit2. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_buf&quot;&gt;&lt;code&gt;git_buf&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Буфер данных для экспорта данных из libgit2. Соответствует структуре &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_buf&quot;&gt; &lt;code&gt;git_buf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="043f580a8a8cc9a9005c9d9892ccd32895f20dc0" translate="yes" xml:space="preserve">
          <source>A deprecated function internally performs a lookup in order to print a relevant warning only once. This extra lookup can cause a significant slowdown, so all uses of deprecated functions should be modified as suggested by the warnings.</source>
          <target state="translated">Утраченная функция внутренне выполняет поиск,чтобы распечатать соответствующее предупреждение только один раз.Этот дополнительный поиск может привести к значительному замедлению,поэтому все использование устаревших функций должно быть изменено в соответствии с предупреждениями.</target>
        </trans-unit>
        <trans-unit id="8caa8da69c3b3cb75cd1d014abbbf0696fbf4493" translate="yes" xml:space="preserve">
          <source>A directory path that indicates which project should be the initial active project. Setting this environment variable has the same effect as specifying the &lt;code&gt;--project&lt;/code&gt; start-up option, but &lt;code&gt;--project&lt;/code&gt; has higher precedence. If the variable is set to &lt;code&gt;@.&lt;/code&gt; then Julia tries to find a project directory that contains &lt;code&gt;Project.toml&lt;/code&gt; or &lt;code&gt;JuliaProject.toml&lt;/code&gt; file from the current directory and its parents. See also the chapter on &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;Code Loading&lt;/a&gt;.</source>
          <target state="translated">Путь к каталогу, указывающий, какой проект должен быть начальным активным проектом. Установка этой переменной среды имеет тот же эффект, что и указание &lt;code&gt;--project&lt;/code&gt; запуска --project , но &lt;code&gt;--project&lt;/code&gt; имеет более высокий приоритет. Если переменная установлена ​​на &lt;code&gt;@.&lt;/code&gt; Затем Джулия пытается найти каталог проекта , который содержит &lt;code&gt;Project.toml&lt;/code&gt; или &lt;code&gt;JuliaProject.toml&lt;/code&gt; файл из текущего каталога и его родителей. См. Также главу о &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;загрузке кода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="214eedeee1125bd3c3f68e94a3d499c9e468ec4a" translate="yes" xml:space="preserve">
          <source>A distributed memory, parallel for loop of the form :</source>
          <target state="translated">Распределенная память,параллельная циклу формы :</target>
        </trans-unit>
        <trans-unit id="19754b4c8d91fdeebb8f2031c8dcc27614b27813" translate="yes" xml:space="preserve">
          <source>A document can be split up into different sections using headers. Headers use the following syntax:</source>
          <target state="translated">Документ можно разделить на разные разделы с помощью заголовков.Заголовки используют следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="906831c5f1833fe1c6cead11729270eaa1e64820" translate="yes" xml:space="preserve">
          <source>A fast, unfair-scheduling version of &lt;code&gt;schedule(t, arg); yield()&lt;/code&gt; which immediately yields to &lt;code&gt;t&lt;/code&gt; before calling the scheduler.</source>
          <target state="translated">Быстрая, нечестная версия &lt;code&gt;schedule(t, arg); yield()&lt;/code&gt; которая немедленно уступает &lt;code&gt;t&lt;/code&gt; перед вызовом планировщика.</target>
        </trans-unit>
        <trans-unit id="5b34dfa04ee74a34a9d1a9cbb45d550b2f88b889" translate="yes" xml:space="preserve">
          <source>A few general rules to note:</source>
          <target state="translated">Следует отметить несколько общих правил:</target>
        </trans-unit>
        <trans-unit id="af07889865f77b7c4b96703878fe873de95ec344" translate="yes" xml:space="preserve">
          <source>A few other points to be aware of:</source>
          <target state="translated">Несколько других моментов,о которых следует знать:</target>
        </trans-unit>
        <trans-unit id="60a8d349acf8be941cbc934da15ee121f8a78126" translate="yes" xml:space="preserve">
          <source>A few popular languages have singleton types, including Haskell, Scala and Ruby. In general usage, the term &quot;singleton type&quot; refers to a type whose only instance is a single value. This meaning applies to Julia's singleton types, but with that caveat that only type objects have singleton types.</source>
          <target state="translated">Несколько популярных языков имеют однокнопочные типы,включая Haskell,Scala и Ruby.В общем употреблении термин &quot;однокнопочный тип&quot; относится к типу,единственным экземпляром которого является одно значение.Это значение применимо к однокнопочным типам Julia,но с этой оговоркой,что только объекты типа имеют однокнопочные типы.</target>
        </trans-unit>
        <trans-unit id="00922cb6654b9fb1b8cc559d5766ed07010c9573" translate="yes" xml:space="preserve">
          <source>A few special expressions correspond to calls to functions with non-obvious names. These are:</source>
          <target state="translated">Несколько специальных выражений соответствуют вызовам функций с неочевидными именами.Это:</target>
        </trans-unit>
        <trans-unit id="df6e90fee529846cc6c25c991e16a7b9cfb908be" translate="yes" xml:space="preserve">
          <source>A file can also be preloaded on multiple processes at startup with the &lt;code&gt;-L&lt;/code&gt; flag, and a driver script can be used to drive the computation:</source>
          <target state="translated">Файл также может быть предварительно загружен в несколько процессов при запуске с помощью флага &lt;code&gt;-L&lt;/code&gt; , а для выполнения вычислений можно использовать сценарий драйвера:</target>
        </trans-unit>
        <trans-unit id="bef6fc12def87705c0724012674763d06330988e" translate="yes" xml:space="preserve">
          <source>A full list of tab-completions can be found in the &lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input-1&quot;&gt;Unicode Input&lt;/a&gt; section of the manual.</source>
          <target state="translated">Полный список дополнений табуляции можно найти в разделе руководства &amp;laquo; &lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input-1&quot;&gt;Ввод Unicode&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="776e65341479516956a84c86603101c98f11aaf1" translate="yes" xml:space="preserve">
          <source>A full suite of parsing and formatting tests and examples is available in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/io.jl&quot;&gt;&lt;code&gt;stdlib/Dates/test/io.jl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Полный набор разбора и форматирования тесты и примеры доступны в &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/io.jl&quot;&gt; &lt;code&gt;stdlib/Dates/test/io.jl&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d1efd2d920b71c04b3aea5f88fea207dff694c1" translate="yes" xml:space="preserve">
          <source>A function &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; to request the richest available multimedia display of a Julia object &lt;code&gt;x&lt;/code&gt; (with a plain-text fallback).</source>
          <target state="translated">Функция &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt; для запроса самого богатого доступного мультимедийного отображения объекта Julia &lt;code&gt;x&lt;/code&gt; (с откатом в виде обычного текста).</target>
        </trans-unit>
        <trans-unit id="96f1b83c87e5168541a9af06566b09eb353921f1" translate="yes" xml:space="preserve">
          <source>A function is called using the traditional parenthesis syntax:</source>
          <target state="translated">Функция вызывается с использованием традиционного синтаксиса скобок:</target>
        </trans-unit>
        <trans-unit id="d5d505a0f9d0a8bc085cb6ea8549229cd44ccf9a" translate="yes" xml:space="preserve">
          <source>A function name may be used alone in place of the tuple (just &lt;code&gt;:function&lt;/code&gt; or &lt;code&gt;&quot;function&quot;&lt;/code&gt;). In this case the name is resolved within the current process. This form can be used to call C library functions, functions in the Julia runtime, or functions in an application linked to Julia.</source>
          <target state="translated">Имя функции может использоваться отдельно вместо кортежа (просто &lt;code&gt;:function&lt;/code&gt; или &lt;code&gt;&quot;function&quot;&lt;/code&gt; ). В этом случае имя разрешается в текущем процессе. Эта форма может использоваться для вызова функций библиотеки C, функций в среде выполнения Julia или функций в приложении, связанном с Julia.</target>
        </trans-unit>
        <trans-unit id="59d50016e8809b20104597755ad0d300cddc21a6" translate="yes" xml:space="preserve">
          <source>A function signature:</source>
          <target state="translated">Функциональная подпись:</target>
        </trans-unit>
        <trans-unit id="fe743a5fafb686fdaff2fd3950e5909b38ec521c" translate="yes" xml:space="preserve">
          <source>A function with a declared return type converts its return value to that type.</source>
          <target state="translated">Функция с объявленным типом возврата преобразует свое возвращаемое значение в этот тип.</target>
        </trans-unit>
        <trans-unit id="25a045a60155304dcdc010c60b6dbf032ba437c0" translate="yes" xml:space="preserve">
          <source>A git object identifier, based on the sha-1 hash. It is a 20 byte string (40 hex digits) used to identify a &lt;code&gt;GitObject&lt;/code&gt; in a repository.</source>
          <target state="translated">Идентификатор объекта git на основе хэша sha-1. Это 20-байтовая строка (40 шестнадцатеричных цифр), используемая для идентификации &lt;code&gt;GitObject&lt;/code&gt; в репозитории.</target>
        </trans-unit>
        <trans-unit id="2b9dac9baaf8e5d26caf82470268456378e7b354" translate="yes" xml:space="preserve">
          <source>A given &lt;code&gt;AbstractChar&lt;/code&gt; subtype may be capable of representing only a subset of Unicode, in which case conversion from an unsupported &lt;code&gt;UInt32&lt;/code&gt; value may throw an error. Conversely, the built-in &lt;a href=&quot;#Core.Char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt; type represents a &lt;em&gt;superset&lt;/em&gt; of Unicode (in order to losslessly encode invalid byte streams), in which case conversion of a non-Unicode value &lt;em&gt;to&lt;/em&gt;&lt;code&gt;UInt32&lt;/code&gt; throws an error. The &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;isvalid&lt;/code&gt;&lt;/a&gt; function can be used to check which codepoints are representable in a given &lt;code&gt;AbstractChar&lt;/code&gt; type.</source>
          <target state="translated">Данный подтип &lt;code&gt;AbstractChar&lt;/code&gt; может представлять только подмножество Unicode, и в этом случае преобразование из неподдерживаемого значения &lt;code&gt;UInt32&lt;/code&gt; может вызвать ошибку. И наоборот, встроенный тип &lt;a href=&quot;#Core.Char&quot;&gt; &lt;code&gt;Char&lt;/code&gt; &lt;/a&gt; представляет собой &lt;em&gt;надмножество&lt;/em&gt; Unicode (чтобы без потерь кодировать недопустимые потоки байтов), и в этом случае преобразование значения, отличного от Unicode, &lt;em&gt;в &lt;/em&gt; &lt;code&gt;UInt32&lt;/code&gt; вызывает ошибку. &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;isvalid&lt;/code&gt; &lt;/a&gt; функция может быть использована , чтобы проверить , какие кодовые представимы в данном &lt;code&gt;AbstractChar&lt;/code&gt; типа.</target>
        </trans-unit>
        <trans-unit id="04d95958adcacd4e7b4382e807134e41ec53c3fc" translate="yes" xml:space="preserve">
          <source>A global variable might have its value, and therefore its type, change at any point. This makes it difficult for the compiler to optimize code using global variables. Variables should be local, or passed as arguments to functions, whenever possible.</source>
          <target state="translated">Глобальная переменная может иметь свое значение и,следовательно,ее тип может измениться в любой момент.Это затрудняет компилятору оптимизацию кода с использованием глобальных переменных.Переменные должны быть локальными или по возможности передаваться в качестве аргументов в функции.</target>
        </trans-unit>
        <trans-unit id="e11090dc004521cb3583f54e041c822a584bd2f5" translate="yes" xml:space="preserve">
          <source>A great strength of Julia is that since the API is exposed synchronously even though the I/O is actually happening asynchronously, we didn't have to worry about callbacks or even making sure that the server gets to run. When we called &lt;code&gt;connect&lt;/code&gt; the current task waited for the connection to be established and only continued executing after that was done. In this pause, the server task resumed execution (because a connection request was now available), accepted the connection, printed the message and waited for the next client. Reading and writing works in the same way. To see this, consider the following simple echo server:</source>
          <target state="translated">Большая сила Джулии заключается в том, что, поскольку API предоставляется синхронно, даже если ввод-вывод на самом деле происходит асинхронно, нам не нужно было беспокоиться об обратных вызовах или даже о том, чтобы сервер запускался. Когда мы вызывали &lt;code&gt;connect&lt;/code&gt; , текущая задача ждала установления соединения и продолжала выполнение только после того, как это было сделано. В этой паузе задача сервера возобновила выполнение (поскольку теперь был доступен запрос на соединение), приняла соединение, распечатала сообщение и ждала следующего клиента. Чтение и письмо работают одинаково. Чтобы убедиться в этом, рассмотрим следующий простой эхо-сервер:</target>
        </trans-unit>
        <trans-unit id="0a9e1db1edf203efc9535001b0c4d60d58c32400" translate="yes" xml:space="preserve">
          <source>A header line can contain any inline syntax in the same way as a paragraph can.</source>
          <target state="translated">Строка заголовка может содержать любой строчный синтаксис так же,как и абзац.</target>
        </trans-unit>
        <trans-unit id="a5bee9cb41ed39aedfa6d81eeafb7305d47a4fcb" translate="yes" xml:space="preserve">
          <source>A key part in defining an &lt;code&gt;AbstractArray&lt;/code&gt; subtype is &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;IndexStyle&lt;/code&gt;&lt;/a&gt;. Since indexing is such an important part of an array and often occurs in hot loops, it's important to make both indexing and indexed assignment as efficient as possible. Array data structures are typically defined in one of two ways: either it most efficiently accesses its elements using just one index (linear indexing) or it intrinsically accesses the elements with indices specified for every dimension. These two modalities are identified by Julia as &lt;code&gt;IndexLinear()&lt;/code&gt; and &lt;code&gt;IndexCartesian()&lt;/code&gt;. Converting a linear index to multiple indexing subscripts is typically very expensive, so this provides a traits-based mechanism to enable efficient generic code for all array types.</source>
          <target state="translated">Ключевым &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;IndexStyle&lt;/code&gt; &lt;/a&gt; в определении подтипа &lt;code&gt;AbstractArray&lt;/code&gt; является IndexStyle . Поскольку индексация является такой важной частью массива и часто возникает в циклах быстрого выполнения, важно сделать как индексацию, так и присвоение индекса как можно эффективнее. Структуры данных массива обычно определяются одним из двух способов: либо он наиболее эффективно обращается к своим элементам, используя только один индекс (линейное индексирование), либо он внутренне обращается к элементам с индексами, указанными для каждого измерения. Эти две &lt;code&gt;IndexLinear()&lt;/code&gt; определены Джулией как IndexLinear () и &lt;code&gt;IndexCartesian()&lt;/code&gt; . Преобразование линейного индекса в несколько индексов индексации обычно очень дорого, поэтому это обеспечивает механизм на основе признаков, позволяющий использовать эффективный универсальный код для всех типов массивов.</target>
        </trans-unit>
        <trans-unit id="3a023b19be8aa0bdde697959a3cb353c50c4a7e6" translate="yes" xml:space="preserve">
          <source>A linear index into the array &lt;code&gt;A&lt;/code&gt; can be converted to a &lt;code&gt;CartesianIndex&lt;/code&gt; for cartesian indexing with &lt;code&gt;CartesianIndices(A)[i]&lt;/code&gt; (see &lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;), and a set of &lt;code&gt;N&lt;/code&gt; cartesian indices can be converted to a linear index with &lt;code&gt;LinearIndices(A)[i_1, i_2, ..., i_N]&lt;/code&gt; (see &lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Линейный индекс в массиве &lt;code&gt;A&lt;/code&gt; может быть преобразован в &lt;code&gt;CartesianIndex&lt;/code&gt; для декартовой индексации с помощью &lt;code&gt;CartesianIndices(A)[i]&lt;/code&gt; (см. &lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt; ), а набор из &lt;code&gt;N&lt;/code&gt; декартовых индексов может быть преобразован в линейный индекс с помощью &lt;code&gt;LinearIndices(A)[i_1, i_2, ..., i_N]&lt;/code&gt; (см. &lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt; &lt;code&gt;LinearIndices&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fba3600321961b41d61a445772a6a0bbc42feb66" translate="yes" xml:space="preserve">
          <source>A linear indexing style uses one integer to describe the position in the array (even if it's a multidimensional array) and column-major ordering is used to access the elements. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;(2, 3)&lt;/code&gt; custom matrix type with linear indexing, and we referenced &lt;code&gt;A[5]&lt;/code&gt; (using linear style), this would be equivalent to referencing &lt;code&gt;A[1, 3]&lt;/code&gt; (since &lt;code&gt;2*1 + 3 = 5&lt;/code&gt;). See also &lt;a href=&quot;#Base.IndexCartesian&quot;&gt;&lt;code&gt;IndexCartesian&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Стиль линейной индексации использует одно целое число для описания позиции в массиве (даже если это многомерный массив), а для доступа к элементам используется порядок столбцов. Например, если бы &lt;code&gt;A&lt;/code&gt; был &lt;code&gt;(2, 3)&lt;/code&gt; пользовательским типом матрицы с линейной индексацией, и мы ссылались бы на &lt;code&gt;A[5]&lt;/code&gt; (используя линейный стиль), это было бы эквивалентно ссылке на &lt;code&gt;A[1, 3]&lt;/code&gt; (поскольку &lt;code&gt;2*1 + 3 = 5&lt;/code&gt; ). См. Также &lt;a href=&quot;#Base.IndexCartesian&quot;&gt; &lt;code&gt;IndexCartesian&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60b78a78e322605d51a66eddac408816c2a8d70e" translate="yes" xml:space="preserve">
          <source>A literal tuple of input types</source>
          <target state="translated">Буквальный кортеж входных типов</target>
        </trans-unit>
        <trans-unit id="abd07e8344438c1637a18b8d088b307bacd1facc" translate="yes" xml:space="preserve">
          <source>A little further down, you see:</source>
          <target state="translated">Немного дальше вниз,видите ли:</target>
        </trans-unit>
        <trans-unit id="b734fc221d82e75922a1b3bf7185abae1cf63084" translate="yes" xml:space="preserve">
          <source>A local cluster specified with the &lt;code&gt;-p&lt;/code&gt; option as shown above.</source>
          <target state="translated">Локальный кластер, указанный с параметром &lt;code&gt;-p&lt;/code&gt; , как показано выше.</target>
        </trans-unit>
        <trans-unit id="b83cf191c90b25b0d5f433557856a4746d3a9017" translate="yes" xml:space="preserve">
          <source>A logger controls how log records are filtered and dispatched. When a log record is generated, the logger is the first piece of user configurable code which gets to inspect the record and decide what to do with it.</source>
          <target state="translated">Журналист управляет тем,как журнальные записи фильтруются и отправляются.Когда запись в журнале генерируется,регистратор-это первая часть настраиваемого пользователем кода,который проверяет запись и решает,что с ней делать.</target>
        </trans-unit>
        <trans-unit id="042546047eaee48205b79c0943331492c9d777d2" translate="yes" xml:space="preserve">
          <source>A lot of the power and extensibility in Julia comes from a collection of informal interfaces. By extending a few specific methods to work for a custom type, objects of that type not only receive those functionalities, but they are also able to be used in other methods that are written to generically build upon those behaviors.</source>
          <target state="translated">Большая часть мощности и расширяемости в Джулии происходит из коллекции неформальных интерфейсов.Расширяя несколько специфических методов для работы с пользовательским типом,объекты этого типа не только получают эти функциональные возможности,но и могут быть использованы в других методах,которые написаны,чтобы в общих чертах построить на этом поведении.</target>
        </trans-unit>
        <trans-unit id="cdda590f5cebd6037d45dcdc70b7f61af7141059" translate="yes" xml:space="preserve">
          <source>A low-level API which returns the backing &lt;code&gt;AbstractChannel&lt;/code&gt; for an &lt;code&gt;id&lt;/code&gt; returned by &lt;a href=&quot;#Distributed.remoteref_id&quot;&gt;&lt;code&gt;remoteref_id&lt;/code&gt;&lt;/a&gt;. The call is valid only on the node where the backing channel exists.</source>
          <target state="translated">Низкоуровневый API, который возвращает резервный &lt;code&gt;AbstractChannel&lt;/code&gt; для &lt;code&gt;id&lt;/code&gt; возвращаемого &lt;a href=&quot;#Distributed.remoteref_id&quot;&gt; &lt;code&gt;remoteref_id&lt;/code&gt; &lt;/a&gt; . Вызов действителен только на узле, на котором существует поддерживающий канал.</target>
        </trans-unit>
        <trans-unit id="43d1ae4e08959da49eefb761652820ef46f3ee1d" translate="yes" xml:space="preserve">
          <source>A low-level API which, given a &lt;code&gt;IO&lt;/code&gt; connection or a &lt;code&gt;Worker&lt;/code&gt;, returns the &lt;code&gt;pid&lt;/code&gt; of the worker it is connected to. This is useful when writing custom &lt;a href=&quot;../serialization/index#Serialization.serialize&quot;&gt;&lt;code&gt;serialize&lt;/code&gt;&lt;/a&gt; methods for a type, which optimizes the data written out depending on the receiving process id.</source>
          <target state="translated">Низкоуровневый API , который, учитывая &lt;code&gt;IO&lt;/code&gt; соединение или &lt;code&gt;Worker&lt;/code&gt; , возвращает &lt;code&gt;pid&lt;/code&gt; процесса работника он подключен. Это полезно при написании пользовательских методов &lt;a href=&quot;../serialization/index#Serialization.serialize&quot;&gt; &lt;code&gt;serialize&lt;/code&gt; &lt;/a&gt; для типа, которые оптимизируют записываемые данные в зависимости от идентификатора принимающего процесса.</target>
        </trans-unit>
        <trans-unit id="ba795db29049d0891e980ecd11cc60ac3e97da8e" translate="yes" xml:space="preserve">
          <source>A machine specification is either a string &lt;code&gt;machine_spec&lt;/code&gt; or a tuple - &lt;code&gt;(machine_spec, count)&lt;/code&gt;.</source>
          <target state="translated">Спецификация машины - это либо строка &lt;code&gt;machine_spec&lt;/code&gt; , либо кортеж - &lt;code&gt;(machine_spec, count)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd1f8848b8ea19b616dae75f53fa9e5a2b6e59a0" translate="yes" xml:space="preserve">
          <source>A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.</source>
          <target state="translated">Макрос для оценки выражения,отбрасывающий результирующее значение,вместо того,чтобы возвращать количество секунд,которое потребовалось для выполнения в качестве числа с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="eb3b3a4181a161e900f67d35ae07d34f42540d5c" translate="yes" xml:space="preserve">
          <source>A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression. Note: the expression is evaluated inside a local function, instead of the current context, in order to eliminate the effects of compilation, however, there still may be some allocations due to JIT compilation. This also makes the results inconsistent with the &lt;code&gt;@time&lt;/code&gt; macros, which do not try to adjust for the effects of compilation.</source>
          <target state="translated">Макрос для оценки выражения, отбрасывающий результирующее значение, вместо этого возвращающий общее количество байтов, выделенных во время оценки выражения. Примечание: выражение оценивается внутри локальной функции, а не в текущем контексте, чтобы исключить эффекты компиляции, однако некоторые выделения могут быть из-за JIT-компиляции. Это также делает результаты несовместимыми с макросами &lt;code&gt;@time&lt;/code&gt; , которые не пытаются приспособиться к эффектам компиляции.</target>
        </trans-unit>
        <trans-unit id="d8419a19f9c35dcf69afb6a224b11b1158512f81" translate="yes" xml:space="preserve">
          <source>A macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.</source>
          <target state="translated">Макрос для выполнения выражения,возвращающий значение выражения,прошедшее время,суммарные выделенные байты,время сбора мусора и объект с различными счетчиками выделения памяти.</target>
        </trans-unit>
        <trans-unit id="ec81ff86af0859e961659a65c9fded1ce9fa3695" translate="yes" xml:space="preserve">
          <source>A macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression.</source>
          <target state="translated">Макрос для выполнения выражения,распечатывающий время его выполнения,количество выделенных байтов и общее количество вызванных им распределений,прежде чем вернуть значение выражения.</target>
        </trans-unit>
        <trans-unit id="f89e0c8d5e0780de8c8e7183eaddeb751b876c48" translate="yes" xml:space="preserve">
          <source>A macro to parallelize a for-loop to run with multiple threads. This spawns &lt;code&gt;nthreads()&lt;/code&gt; number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.</source>
          <target state="translated">Макрос для распараллеливания цикла for для работы с несколькими потоками. Это порождает количество потоков &lt;code&gt;nthreads()&lt;/code&gt; , разделяет пространство итерации между ними и выполняет итерацию параллельно. В конце цикла помещается барьер, который ожидает, пока все потоки завершат выполнение, и цикл возвращается.</target>
        </trans-unit>
        <trans-unit id="4056e98728a50b1503d6d58ab30b4f400279b462" translate="yes" xml:space="preserve">
          <source>A memory address referring to data of type &lt;code&gt;T&lt;/code&gt;. However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.</source>
          <target state="translated">Адрес памяти со ссылкой на данные типа &lt;code&gt;T&lt;/code&gt; . Однако нет гарантии, что память действительно действительна или что она действительно представляет данные указанного типа.</target>
        </trans-unit>
        <trans-unit id="95d230cf10af62aec1cf82bb28af648076032cf6" translate="yes" xml:space="preserve">
          <source>A message &lt;code&gt;id&lt;/code&gt; that is a unique, fixed identifier for the &lt;em&gt;source code statement&lt;/em&gt; where the logging macro appears. This identifier is designed to be fairly stable even if the source code of the file changes, as long as the logging statement itself remains the same.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; сообщения, который является уникальным фиксированным идентификатором для &lt;em&gt;оператора исходного кода, в&lt;/em&gt; котором появляется макрос ведения журнала. Этот идентификатор разработан так, чтобы быть достаточно стабильным, даже если исходный код файла изменяется, пока сам оператор регистрации остается прежним.</target>
        </trans-unit>
        <trans-unit id="2750f8d62ad398e67307a20fbfa3a8d50bdd8b0e" translate="yes" xml:space="preserve">
          <source>A method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.</source>
          <target state="translated">Метод с сигнатурой требуемого типа в данной общей функции не существует.Кроме того,не существует уникального наиболее специфического метода.</target>
        </trans-unit>
        <trans-unit id="cb18ac1bbb6e9e8d32b3f5b781aaa128caf3d148" translate="yes" xml:space="preserve">
          <source>A more portable file would need to encode the word size &amp;ndash; 32 bit or 64 bit &amp;ndash; and endianness information in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be used with memory-mapping).</source>
          <target state="translated">Более переносимый файл должен будет закодировать размер слова - 32-битный или 64-битный - и информацию о порядке байтов в заголовке. На практике рассмотрите возможность кодирования двоичных данных с использованием стандартных форматов, таких как HDF5 (который можно использовать с отображением памяти).</target>
        </trans-unit>
        <trans-unit id="d12bebeb20e9c7a91d427b124d0d24b749dfc69d" translate="yes" xml:space="preserve">
          <source>A natural extension to the iterated dispatch above is to add a layer to method selection that allows to dispatch on sets of types which are independent from the sets defined by the type hierarchy. We could construct such a set by writing out a &lt;code&gt;Union&lt;/code&gt; of the types in question, but then this set would not be extensible as &lt;code&gt;Union&lt;/code&gt;-types cannot be altered after creation. However, such an extensible set can be programmed with a design pattern often referred to as a &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633&quot;&gt;&quot;Holy-trait&quot;&lt;/a&gt;.</source>
          <target state="translated">Естественным расширением итеративной отправки выше является добавление слоя к выбору метода, который позволяет выполнять диспетчеризацию наборов типов, которые не зависят от наборов, определенных иерархией типов. Мы могли бы построить такой набор, записав &lt;code&gt;Union&lt;/code&gt; рассматриваемых типов, но тогда этот набор не будет расширяемым, поскольку типы &lt;code&gt;Union&lt;/code&gt; не могут быть изменены после создания. Однако такой расширяемый набор может быть запрограммирован с помощью шаблона проектирования, который часто называют &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633&quot;&gt;&amp;laquo;священной чертой&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1df2e0e7411bff84daf33858b6c998ccc3af6df2" translate="yes" xml:space="preserve">
          <source>A negative value returned from &lt;code&gt;f&lt;/code&gt; stops the tree walk. A positive value means that the entry will be skipped if &lt;code&gt;post&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Отрицательное значение, возвращаемое функцией &lt;code&gt;f&lt;/code&gt; , останавливает обход дерева. Положительное значение означает , что запись будет пропущена , если &lt;code&gt;post&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6eadc295d0ba924158738dd40574dc88fa55d3a0" translate="yes" xml:space="preserve">
          <source>A new local scope is introduced by most code blocks (see above &lt;a href=&quot;#man-scope-table-1&quot;&gt;table&lt;/a&gt; for a complete list). A local scope inherits all the variables from a parent local scope, both for reading and writing. Unlike global scopes, local scopes are not namespaces, thus variables in an inner scope cannot be retrieved from the parent scope through some sort of qualified access.</source>
          <target state="translated">Новая локальная область видимости вводится в большинстве блоков кода ( полный список см. В &lt;a href=&quot;#man-scope-table-1&quot;&gt;таблице&lt;/a&gt; выше ). Локальная область видимости наследует все переменные родительской локальной области как для чтения, так и для записи. В отличие от глобальных областей, локальные области не являются пространствами имен, поэтому переменные во внутренней области не могут быть получены из родительской области с помощью определенного вида доступа.</target>
        </trans-unit>
        <trans-unit id="d714251afe7092bca2f3b7a144d31cf965234924" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; значение типа Float16 .</target>
        </trans-unit>
        <trans-unit id="2193a2ca1ad4d9733b4b0300e7ecba88f3943810" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; значение типа Float32 .</target>
        </trans-unit>
        <trans-unit id="81968f8bb93ba2bc693aa91379d45e0967799536" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; значение типа Float64 .</target>
        </trans-unit>
        <trans-unit id="bf0553a64a83d6adf63b024a57032beb1f6f23e7" translate="yes" xml:space="preserve">
          <source>A one-dimensional &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt;&lt;code&gt;SharedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Одномерный &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt; &lt;code&gt;SharedArray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="763a944bd46fad5722e83f3b2781f484dab35fa0" translate="yes" xml:space="preserve">
          <source>A package can only be loaded once per Julia session. If you have run &lt;code&gt;import Example&lt;/code&gt; in the current Julia session, you will have to restart Julia and rerun &lt;code&gt;activate tutorial&lt;/code&gt; in the Pkg REPL. &lt;a href=&quot;https://github.com/timholy/Revise.jl/&quot;&gt;Revise.jl&lt;/a&gt; can make this process significantly more pleasant, but setting it up is beyond the scope of this guide.</source>
          <target state="translated">Пакет можно загрузить только один раз за сеанс Julia. Если вы запустили &lt;code&gt;import Example&lt;/code&gt; в текущем сеансе Julia, вам придется перезапустить Julia и повторно запустить &lt;code&gt;activate tutorial&lt;/code&gt; по активации в Pkg REPL. &lt;a href=&quot;https://github.com/timholy/Revise.jl/&quot;&gt;Revise.jl&lt;/a&gt; может сделать этот процесс значительно более приятным, но его настройка выходит за рамки этого руководства.</target>
        </trans-unit>
        <trans-unit id="d8ea4ea99a9ccce09db2edcbcf21139124c0c674" translate="yes" xml:space="preserve">
          <source>A package with a project file but no explicit UUID can only be depended on by packages without project files since dummy UUIDs assigned to these packages are strictly internal.</source>
          <target state="translated">Пакет с проектным файлом,но без явного UUID,может зависеть только от пакетов без проектного файла,так как поддельные UUID,присвоенные этим пакетам,являются строго внутренними.</target>
        </trans-unit>
        <trans-unit id="74b114825488547a02a0f9d88544ac2cd2767c9b" translate="yes" xml:space="preserve">
          <source>A package with a project file cannot depend on one without a project file since packages with project files can only load packages in &lt;code&gt;graph&lt;/code&gt; and packages without project files do not appear in &lt;code&gt;graph&lt;/code&gt;.</source>
          <target state="translated">Пакет с файлом проекта не может зависеть от пакета без файла проекта, поскольку пакеты с файлами проекта могут загружать пакеты только в &lt;code&gt;graph&lt;/code&gt; а пакеты без файлов проекта не отображаются на &lt;code&gt;graph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd75d89f707123dd68c78d210bdb2e047dca58d2" translate="yes" xml:space="preserve">
          <source>A package without a project file can depend on any top-level dependency, and since every package in a package directory is available at the top-level, it can import all packages in the environment.</source>
          <target state="translated">Пакет без файла проекта может зависеть от любой зависимости верхнего уровня,а поскольку каждый пакет в каталоге пакета доступен на верхнем уровне,он может импортировать все пакеты в окружение.</target>
        </trans-unit>
        <trans-unit id="b56c2cd76cad76c5809c4c87d958f6925a4c437f" translate="yes" xml:space="preserve">
          <source>A paragraph is a block of plain text, possibly containing any number of inline elements defined in the &lt;a href=&quot;#Inline-elements-1&quot;&gt;Inline elements&lt;/a&gt; section above, with one or more blank lines above and below it.</source>
          <target state="translated">Абзац - это блок простого текста, возможно, содержащий любое количество встроенных элементов, определенных в разделе &amp;laquo; &lt;a href=&quot;#Inline-elements-1&quot;&gt;Встроенные элементы&lt;/a&gt; &amp;raquo; выше, с одной или несколькими пустыми строками над и под ним.</target>
        </trans-unit>
        <trans-unit id="83f9c9755a3a3b90210c6624d61e0b0a1f59e0fa" translate="yes" xml:space="preserve">
          <source>A particularly useful case of a &lt;code&gt;Union&lt;/code&gt; type is &lt;code&gt;Union{T, Nothing}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; can be any type and &lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is the singleton type whose only instance is the object &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;. This pattern is the Julia equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt;&lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; types in other languages. Declaring a function argument or a field as &lt;code&gt;Union{T, Nothing}&lt;/code&gt; allows setting it either to a value of type &lt;code&gt;T&lt;/code&gt;, or to &lt;code&gt;nothing&lt;/code&gt; to indicate that there is no value. See &lt;a href=&quot;../faq/index#faq-nothing-1&quot;&gt;this FAQ entry&lt;/a&gt; for more information.</source>
          <target state="translated">Особенно полезным случаем типа &lt;code&gt;Union&lt;/code&gt; является &lt;code&gt;Union{T, Nothing}&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; может быть любым типом, а &lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt; - это одноэлементный тип, единственным экземпляром которого является объект &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; . Этот шаблон является эквивалентом типов &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt; &lt;code&gt;Nullable&lt;/code&gt; , &lt;code&gt;Option&lt;/code&gt; или &lt;code&gt;Maybe&lt;/code&gt; &lt;/a&gt; в других языках для Julia . Объявление аргумента функции или поля как &lt;code&gt;Union{T, Nothing}&lt;/code&gt; позволяет установить либо значение типа &lt;code&gt;T&lt;/code&gt; , либо &lt;code&gt;nothing&lt;/code&gt; чтобы указать, что значение отсутствует. См. &lt;a href=&quot;../faq/index#faq-nothing-1&quot;&gt;Этот раздел часто задаваемых вопросов&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="c0f8b8ac2cfde0d10f30bb94c874c9e1f1def48e" translate="yes" xml:space="preserve">
          <source>A pointer to the data block</source>
          <target state="translated">Указатель на блок данных</target>
        </trans-unit>
        <trans-unit id="6b9ee627484ba20558d37b2c66115f6d170670ea" translate="yes" xml:space="preserve">
          <source>A positive &lt;code&gt;Int&lt;/code&gt; that determines how much time the max-sum subroutine &lt;code&gt;MaxSum.maxsum()&lt;/code&gt; of the package dependency resolver will devote to attempting satisfying constraints before giving up: this value is by default &lt;code&gt;1&lt;/code&gt;, and larger values correspond to larger amounts of time.</source>
          <target state="translated">Положительное значение &lt;code&gt;Int&lt;/code&gt; , определяющее, сколько времени подпрограмма max-sum &lt;code&gt;MaxSum.maxsum()&lt;/code&gt; распознавателя зависимостей пакетов будет посвящать попыткам удовлетворения ограничений, прежде чем отказаться: это значение по умолчанию равно &lt;code&gt;1&lt;/code&gt; , а большие значения соответствуют большему количеству времени.</target>
        </trans-unit>
        <trans-unit id="30e83519d088c9c533da7a48902b81020f8078b5" translate="yes" xml:space="preserve">
          <source>A pre-computed &lt;code&gt;mean&lt;/code&gt; may be provided.</source>
          <target state="translated">Может быть предоставлено предварительно вычисленное &lt;code&gt;mean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2cb212a617bce583ce37ac7b92063a39d21aed2" translate="yes" xml:space="preserve">
          <source>A prefix &lt;code&gt;&amp;amp;&lt;/code&gt; is used on an argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to indicate that a pointer to a scalar argument should be passed instead of the scalar value itself (required for all Fortran function arguments, as noted above). The following example computes a dot product using a BLAS function.</source>
          <target state="translated">Префикс &lt;code&gt;&amp;amp;&lt;/code&gt; используется в аргументе для &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; ,&lt;/a&gt; чтобы указать, что указатель на скалярный аргумент должен быть передан вместо самого скалярного значения (требуется для всех аргументов функции Fortran, как указано выше). В следующем примере вычисляется скалярное произведение с использованием функции BLAS.</target>
        </trans-unit>
        <trans-unit id="1649f26efb9cb12037079805dd99e4da0fb754f9" translate="yes" xml:space="preserve">
          <source>A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in the language itself:</source>
          <target state="translated">Примитивный тип-это конкретный тип,данные которого состоят из обычных старых битов.Классическими примерами примитивных типов являются целые числа и значения с плавающей точкой.В отличие от большинства языков,Julia позволяет объявлять свои собственные типы примитивов,вместо того,чтобы предоставлять только фиксированный набор встроенных типов.Фактически,все стандартные типы примитивов определяются в самом языке:</target>
        </trans-unit>
        <trans-unit id="f4a9df194804c22a7662de8018248499081325a7" translate="yes" xml:space="preserve">
          <source>A project environment is determined by a directory containing a project file called &lt;code&gt;Project.toml&lt;/code&gt;, and optionally a manifest file called &lt;code&gt;Manifest.toml&lt;/code&gt;. These files may also be called &lt;code&gt;JuliaProject.toml&lt;/code&gt; and &lt;code&gt;JuliaManifest.toml&lt;/code&gt;, in which case &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; are ignored. This allows for coexistence with other tools that might consider files called &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; significant. For pure Julia projects, however, the names &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; are preferred.</source>
          <target state="translated">Среда проекта определяется каталогом, содержащим файл проекта с именем &lt;code&gt;Project.toml&lt;/code&gt; и, необязательно, файл &lt;code&gt;Manifest.toml&lt;/code&gt; именем Manifest.toml . Эти файлы также могут называться &lt;code&gt;JuliaProject.toml&lt;/code&gt; и &lt;code&gt;JuliaManifest.toml&lt;/code&gt; , и в этом случае &lt;code&gt;Project.toml&lt;/code&gt; и &lt;code&gt;Manifest.toml&lt;/code&gt; игнорируются. Это позволяет сосуществовать с другими инструментами, которые могут рассматривать файлы &lt;code&gt;Project.toml&lt;/code&gt; и &lt;code&gt;Manifest.toml&lt;/code&gt; как важные. Однако для чистых проектов Julia предпочтительнее использовать имена &lt;code&gt;Project.toml&lt;/code&gt; и &lt;code&gt;Manifest.toml&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69645bb907ec77da55ad793cb959dcc26c6879c9" translate="yes" xml:space="preserve">
          <source>A pure function can only depend on immutable information. This also means a &lt;code&gt;@pure&lt;/code&gt; function cannot use any global mutable state, including generic functions. Calls to generic functions depend on method tables which are mutable global state. Use with caution, incorrect &lt;code&gt;@pure&lt;/code&gt; annotation of a function may introduce hard to identify bugs. Double check for calls to generic functions.</source>
          <target state="translated">Чистая функция может зависеть только от неизменной информации. Это также означает, что функция &lt;code&gt;@pure&lt;/code&gt; не может использовать какое-либо глобальное изменяемое состояние, включая общие функции. Вызов общих функций зависит от таблиц методов, которые являются изменяемым глобальным состоянием. Используйте с осторожностью, неправильная аннотация &lt;code&gt;@pure&lt;/code&gt; функции может затруднить выявление ошибок. Дважды проверьте вызовы общих функций.</target>
        </trans-unit>
        <trans-unit id="f6f0f859ed475e8984520389a632de12d979f1bf" translate="yes" xml:space="preserve">
          <source>A range &lt;code&gt;r&lt;/code&gt; where &lt;code&gt;r[i]&lt;/code&gt; produces values of type &lt;code&gt;T&lt;/code&gt; (in the second form, &lt;code&gt;T&lt;/code&gt; is deduced automatically), parameterized by a &lt;code&gt;ref&lt;/code&gt;erence value, a &lt;code&gt;step&lt;/code&gt;, and the &lt;code&gt;len&lt;/code&gt;gth. By default &lt;code&gt;ref&lt;/code&gt; is the starting value &lt;code&gt;r[1]&lt;/code&gt;, but alternatively you can supply it as the value of &lt;code&gt;r[offset]&lt;/code&gt; for some other index &lt;code&gt;1 &amp;lt;= offset &amp;lt;= len&lt;/code&gt;. In conjunction with &lt;code&gt;TwicePrecision&lt;/code&gt; this can be used to implement ranges that are free of roundoff error.</source>
          <target state="translated">Диапазон &lt;code&gt;r&lt;/code&gt; , где &lt;code&gt;r[i]&lt;/code&gt; производит значения типа &lt;code&gt;T&lt;/code&gt; (во второй форме, &lt;code&gt;T&lt;/code&gt; выводится автоматически), параметризирован &lt;code&gt;ref&lt;/code&gt; значение разностной, на &lt;code&gt;step&lt;/code&gt; , и &lt;code&gt;len&lt;/code&gt; GTH. По умолчанию &lt;code&gt;ref&lt;/code&gt; является начальным значением &lt;code&gt;r[1]&lt;/code&gt; , но в качестве альтернативы вы можете указать его как значение &lt;code&gt;r[offset]&lt;/code&gt; для некоторого другого индекса &lt;code&gt;1 &amp;lt;= offset &amp;lt;= len&lt;/code&gt; . В сочетании с &lt;code&gt;TwicePrecision&lt;/code&gt; это можно использовать для реализации диапазонов без ошибок округления.</target>
        </trans-unit>
        <trans-unit id="c9b444cdaa1ec0c32645903217d293c523a2b655" translate="yes" xml:space="preserve">
          <source>A range parameterized by a &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;, filled with elements spaced by &lt;code&gt;1&lt;/code&gt; from &lt;code&gt;start&lt;/code&gt; until &lt;code&gt;stop&lt;/code&gt; is exceeded. The syntax &lt;code&gt;a:b&lt;/code&gt; with &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; both &lt;code&gt;Integer&lt;/code&gt;s creates a &lt;code&gt;UnitRange&lt;/code&gt;.</source>
          <target state="translated">Диапазон, параметризованный &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;stop&lt;/code&gt; типа &lt;code&gt;T&lt;/code&gt; , заполненный элементами, расположенными с интервалом &lt;code&gt;1&lt;/code&gt; от &lt;code&gt;start&lt;/code&gt; до превышения &lt;code&gt;stop&lt;/code&gt; . Синтаксис &lt;code&gt;a:b&lt;/code&gt; с &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; как &lt;code&gt;Integer&lt;/code&gt; s создает &lt;code&gt;UnitRange&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6f1f96e933c37623ad62bee872115dc2545ea76" translate="yes" xml:space="preserve">
          <source>A range with &lt;code&gt;len&lt;/code&gt; linearly spaced elements between its &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. The size of the spacing is controlled by &lt;code&gt;len&lt;/code&gt;, which must be an &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">Диапазон с &lt;code&gt;len&lt;/code&gt; линейно разнесенными элементами между его &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;stop&lt;/code&gt; . Размер интервала контролируется параметром &lt;code&gt;len&lt;/code&gt; , который должен быть &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="706e2d69e0228bb191f57826b2fe6dee1a0d2fd7" translate="yes" xml:space="preserve">
          <source>A related strategy exploits &lt;code&gt;promote&lt;/code&gt; to bring &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to a common type:</source>
          <target state="translated">Эксплойты связанной стратегии &lt;code&gt;promote&lt;/code&gt; приведению &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; к общему типу:</target>
        </trans-unit>
        <trans-unit id="1aacdb7c22de01fd91d580f3ce3c32f6aebf1795" translate="yes" xml:space="preserve">
          <source>A remote call returns a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; to its result. Remote calls return immediately; the process that made the call proceeds to its next operation while the remote call happens somewhere else. You can wait for a remote call to finish by calling &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the returned &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;, and you can obtain the full value of the result using &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">Удаленный вызов возвращает результат &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; . Удаленные звонки возвращаются немедленно; процесс, выполнивший вызов, переходит к своей следующей операции, в то время как удаленный вызов происходит в другом месте. Вы можете дождаться завершения удаленного вызова, вызвав &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; для возвращенного &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; , и вы можете получить полное значение результата с помощью &lt;code&gt;fetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c718be7a47524e3c8c121a2838b8196bfca32d81" translate="yes" xml:space="preserve">
          <source>A return type can also be specified in the function declaration using the &lt;code&gt;::&lt;/code&gt; operator. This converts the return value to the specified type.</source>
          <target state="translated">Тип возврата также можно указать в объявлении функции с помощью оператора &lt;code&gt;::&lt;/code&gt; . Это преобразует возвращаемое значение в указанный тип.</target>
        </trans-unit>
        <trans-unit id="487eaf5a6ef062e68fb2638581518230a5bbf1cb" translate="yes" xml:space="preserve">
          <source>A return type of &lt;code&gt;Union{}&lt;/code&gt; means the function will not return i.e. C++11 &lt;code&gt;[[noreturn]]&lt;/code&gt; or C11 &lt;code&gt;_Noreturn&lt;/code&gt; (e.g. &lt;code&gt;jl_throw&lt;/code&gt; or &lt;code&gt;longjmp&lt;/code&gt;). Do not use this for functions that return no value (&lt;code&gt;void&lt;/code&gt;) but do return, use &lt;code&gt;Cvoid&lt;/code&gt; instead.</source>
          <target state="translated">Тип возвращаемого значения &lt;code&gt;Union{}&lt;/code&gt; означает, что функция не вернет, например, C ++ 11 &lt;code&gt;[[noreturn]]&lt;/code&gt; или C11 &lt;code&gt;_Noreturn&lt;/code&gt; (например, &lt;code&gt;jl_throw&lt;/code&gt; или &lt;code&gt;longjmp&lt;/code&gt; ). Не используйте это для функций, которые не возвращают значения ( &lt;code&gt;void&lt;/code&gt; ), но возвращают, вместо этого используйте &lt;code&gt;Cvoid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d36c3c7861e0bdac1682c4b5f59e170ca861f5e" translate="yes" xml:space="preserve">
          <source>A rich language of types for constructing and describing objects, that can also optionally be used to make type declarations</source>
          <target state="translated">Богатый язык типов для построения и описания объектов,который также может быть опционально использован для объявления типов</target>
        </trans-unit>
        <trans-unit id="72264caef899e2b19ef0b87abaee4b3d2fbc99bb" translate="yes" xml:space="preserve">
          <source>A sampling profiler does not provide complete line-by-line coverage, because the backtraces occur at intervals (by default, 1 ms on Unix systems and 10 ms on Windows, although the actual scheduling is subject to operating system load). Moreover, as discussed further below, because samples are collected at a sparse subset of all execution points, the data collected by a sampling profiler is subject to statistical noise.</source>
          <target state="translated">Профилировщик выборки не обеспечивает полного линейного покрытия,так как обратные трассы происходят с интервалами (по умолчанию 1 мс на Unix-системах и 10 мс на Windows,хотя фактическое планирование зависит от загрузки операционной системы).Более того,как будет рассмотрено ниже,поскольку выборки собираются в разреженном подмножестве всех точек выполнения,данные,собранные профилировщиком выборки,подвержены статистическому шуму.</target>
        </trans-unit>
        <trans-unit id="1c43fdae247597897ddce375dd4bc720d67a5129" translate="yes" xml:space="preserve">
          <source>A scalar index. By default this includes:</source>
          <target state="translated">Скалярный индекс.По умолчанию он включает в себя:</target>
        </trans-unit>
        <trans-unit id="b55191124d22706cdd504c425bc25474c70cfe4b" translate="yes" xml:space="preserve">
          <source>A shortened git object identifier, which can be used to identify a git object when it is unique, consisting of the initial &lt;code&gt;len&lt;/code&gt; hexadecimal digits of &lt;code&gt;hash&lt;/code&gt; (the remaining digits are ignored).</source>
          <target state="translated">Сокращенный идентификатор объекта git, который может использоваться для идентификации объекта git, если он уникален, состоящий из начальных &lt;code&gt;len&lt;/code&gt; шестнадцатеричных цифр &lt;code&gt;hash&lt;/code&gt; (остальные цифры игнорируются).</target>
        </trans-unit>
        <trans-unit id="077f5f2c61a2286cb303f8e0203873661f4fb602" translate="yes" xml:space="preserve">
          <source>A simple TCP example</source>
          <target state="translated">Простой пример TCP</target>
        </trans-unit>
        <trans-unit id="a9e3389d4f0df30d0d029c511221cff89bde7e83" translate="yes" xml:space="preserve">
          <source>A simple example is an iterable sequence of square numbers with a defined length:</source>
          <target state="translated">Простой пример-это итерабельная последовательность квадратных чисел с заданной длиной:</target>
        </trans-unit>
        <trans-unit id="4f74541df487be036520d1a453fae53d9f7cabea" translate="yes" xml:space="preserve">
          <source>A simple use of this script is from the command line. Assuming that &lt;code&gt;julia-config.jl&lt;/code&gt; is located in &lt;code&gt;/usr/local/julia/share/julia&lt;/code&gt;, it can be invoked on the command line directly and takes any combination of 3 flags:</source>
          <target state="translated">Простое использование этого сценария - из командной строки. Предполагая, что &lt;code&gt;julia-config.jl&lt;/code&gt; находится в &lt;code&gt;/usr/local/julia/share/julia&lt;/code&gt; , он может быть вызван напрямую из командной строки и принимает любую комбинацию из 3 флагов:</target>
        </trans-unit>
        <trans-unit id="fa70eb6573e06a90b5cea95755e1d5d87242bd36" translate="yes" xml:space="preserve">
          <source>A singleton of this type provides a hash table interface to environment variables.</source>
          <target state="translated">Одиночная кнопка этого типа предоставляет интерфейс хэш-таблицы к переменным окружения.</target>
        </trans-unit>
        <trans-unit id="742dc31813ae03b1c856e52c5abe6409c9fab8c0" translate="yes" xml:space="preserve">
          <source>A special syntax exists for broadcasting: &lt;code&gt;f.(args...)&lt;/code&gt; is equivalent to &lt;code&gt;broadcast(f, args...)&lt;/code&gt;, and nested &lt;code&gt;f.(g.(args...))&lt;/code&gt; calls are fused into a single broadcast loop.</source>
          <target state="translated">Для широковещательной передачи существует специальный синтаксис: &lt;code&gt;f.(args...)&lt;/code&gt; эквивалентен &lt;code&gt;broadcast(f, args...)&lt;/code&gt; , а вложенные вызовы &lt;code&gt;f.(g.(args...))&lt;/code&gt; объединяются в один цикл широковещательной передачи. ,</target>
        </trans-unit>
        <trans-unit id="c0fbd3b8f6db43e593e0be31ea0f379f85f1e4ca" translate="yes" xml:space="preserve">
          <source>A stack of &quot;depot&quot; locations where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. By default it includes:</source>
          <target state="translated">Стек &quot;депо&quot;,где менеджер пакетов,а также механизмы загрузки кода Julia,ищет реестры пакетов,установленные пакеты,именованные окружения,репо-клоны,кэшированные скомпилированные образы пакетов и конфигурационные файлы.По умолчанию он включает в себя:</target>
        </trans-unit>
        <trans-unit id="83cbeda4e6c8af61ba213e9c4a7b5e87e7da5098" translate="yes" xml:space="preserve">
          <source>A strided array is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt; whose entries are stored in memory with fixed strides. Provided the element type of the array is compatible with BLAS, a strided array can utilize BLAS and LAPACK routines for more efficient linear algebra routines. A typical example of a user-defined strided array is one that wraps a standard &lt;code&gt;Array&lt;/code&gt; with additional structure.</source>
          <target state="translated">Построенный массив - это подтип &lt;code&gt;AbstractArray&lt;/code&gt; , записи которого сохраняются в памяти с фиксированным шагом. При условии, что тип элемента массива совместим с BLAS, разделенный массив может использовать процедуры BLAS и LAPACK для более эффективных процедур линейной алгебры. Типичным примером определяемого пользователем последовательного массива является массив, который обертывает стандартный &lt;code&gt;Array&lt;/code&gt; дополнительной структурой.</target>
        </trans-unit>
        <trans-unit id="1b1c35701525a8cf6b4348121d4ed856a675b22b" translate="yes" xml:space="preserve">
          <source>A string containing the build triple.</source>
          <target state="translated">Строка,содержащая тройку сборки.</target>
        </trans-unit>
        <trans-unit id="8f5d09501ae972f4c8432e623c2b5b34015798e0" translate="yes" xml:space="preserve">
          <source>A string containing the full path to the directory containing the &lt;code&gt;julia&lt;/code&gt; executable.</source>
          <target state="translated">Строка, содержащая полный путь к каталогу, содержащему исполняемый файл &lt;code&gt;julia&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfd4ca3ee2c70681a147013214927fa8b03d2dc0" translate="yes" xml:space="preserve">
          <source>A string containing the script name passed to Julia from the command line. Note that the script name remains unchanged from within included files. Alternatively see &lt;a href=&quot;../file/index#Base.@__FILE__&quot;&gt;&lt;code&gt;@__FILE__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Строка, содержащая имя сценария, переданная Джулии из командной строки. Обратите внимание, что имя сценария остается неизменным из включенных файлов. В качестве альтернативы см. &lt;a href=&quot;../file/index#Base.@__FILE__&quot;&gt; &lt;code&gt;@__FILE__&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0797e0a3c7343edc1c5ee87f67440aa1e7a16452" translate="yes" xml:space="preserve">
          <source>A string giving the literal bit representation of a number.</source>
          <target state="translated">Строка,дающая буквальное битовое представление числа.</target>
        </trans-unit>
        <trans-unit id="99fade2fd2012046282e2903a7ae0c96b265f5e9" translate="yes" xml:space="preserve">
          <source>A struct can also declare an abstract super type via &lt;code&gt;&amp;lt;:&lt;/code&gt; syntax:</source>
          <target state="translated">Структура также может объявлять абстрактный супертип с помощью синтаксиса &lt;code&gt;&amp;lt;:&lt;/code&gt; ::</target>
        </trans-unit>
        <trans-unit id="d8c381a5b7c7400aeadc10868e02841473506c28" translate="yes" xml:space="preserve">
          <source>A successful invocation indicates that the request has been accepted for execution on the remote node.</source>
          <target state="translated">Успешный вызов означает,что запрос был принят к исполнению на удаленном узле.</target>
        </trans-unit>
        <trans-unit id="62cc4725cdcde932b6f43e77c33829a7243aa044" translate="yes" xml:space="preserve">
          <source>A symbol in the current scope is not defined.</source>
          <target state="translated">Символ в текущем диапазоне не определен.</target>
        </trans-unit>
        <trans-unit id="c20565dfe8ced2501d963ee2eb2804c69c838706" translate="yes" xml:space="preserve">
          <source>A symbol representing the architecture of the build configuration.</source>
          <target state="translated">Символ,представляющий архитектуру конфигурации сборки.</target>
        </trans-unit>
        <trans-unit id="1630c742579320a925646310ce24a54343db4200" translate="yes" xml:space="preserve">
          <source>A symbol representing the name of the operating system, as returned by &lt;code&gt;uname&lt;/code&gt; of the build configuration.</source>
          <target state="translated">Символ, представляющий имя операционной системы, возвращенное &lt;code&gt;uname&lt;/code&gt; конфигурации сборки.</target>
        </trans-unit>
        <trans-unit id="55d0851ad9930d2d2a1ce1a82a1321a9316a97a9" translate="yes" xml:space="preserve">
          <source>A symbol representing the operator associativity can also be found by calling the built-in function &lt;code&gt;Base.operator_associativity&lt;/code&gt;:</source>
          <target state="translated">Символ, представляющий ассоциативность оператора, также можно найти, вызвав встроенную функцию &lt;code&gt;Base.operator_associativity&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="31ca630f0d77e0cda110e0b86407ebc755d3a20f" translate="yes" xml:space="preserve">
          <source>A system call failed with an error code (in the &lt;code&gt;errno&lt;/code&gt; global variable).</source>
          <target state="translated">Системный вызов завершился неудачно с кодом ошибки (в глобальной переменной &lt;code&gt;errno&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9449233a2f73e499e6bb945337a8062b4696d604" translate="yes" xml:space="preserve">
          <source>A task created explicitly by calling &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; is initially not known to the scheduler. This allows you to manage tasks manually using &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; if you wish. However, when such a task waits for an event, it still gets restarted automatically when the event happens, as you would expect. It is also possible to make the scheduler run a task whenever it can, without necessarily waiting for any events. This is done by calling &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt;, or using the &lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt;&lt;code&gt;@async&lt;/code&gt;&lt;/a&gt; macro (see &lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;Parallel Computing&lt;/a&gt; for more details).</source>
          <target state="translated">Задача, созданная явно путем вызова &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; , изначально не известна планировщику. Это позволяет вам управлять задачами вручную, используя &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; ,&lt;/a&gt; если хотите. Однако, когда такая задача ожидает события, она по-прежнему автоматически перезапускается, когда событие происходит, как и следовало ожидать. Также можно заставить планировщик запускать задачу всякий раз, когда это возможно, не дожидаясь каких-либо событий. Это делается путем вызова &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt; или использования макроса &lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt; &lt;code&gt;@async&lt;/code&gt; &lt;/a&gt; (подробнее см. В разделе &amp;laquo; &lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;Параллельные вычисления&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="98741cc98ee16d9ab3a998adf5789df91d6bd8b6" translate="yes" xml:space="preserve">
          <source>A thread-safe version of &lt;a href=&quot;#Base.Condition&quot;&gt;&lt;code&gt;Base.Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.Condition&quot;&gt; &lt;code&gt;Base.Condition&lt;/code&gt; &lt;/a&gt; версия Base.Condition .</target>
        </trans-unit>
        <trans-unit id="742c13a103d2480e968af031241292dc13ffa910" translate="yes" xml:space="preserve">
          <source>A tuple of input types. The input types must be written as a literal tuple, not a tuple-valued variable or expression.</source>
          <target state="translated">Кортеж входного типа.Типы входных данных должны быть записаны как буквальный кортеж,а не как переменная или выражение,имеющее значение кортежа.</target>
        </trans-unit>
        <trans-unit id="02ac3688690ac8c45320416c8e40058c167fb818" translate="yes" xml:space="preserve">
          <source>A two-dimensional &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt;&lt;code&gt;SharedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Двумерный &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt; &lt;code&gt;SharedArray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cae43ab9952736150051924872c889307cc7b33" translate="yes" xml:space="preserve">
          <source>A type assertion failure, or calling an intrinsic function with an incorrect argument type.</source>
          <target state="translated">Ошибка утверждения типа или вызов intrinsic-функции с неверным типом аргумента.</target>
        </trans-unit>
        <trans-unit id="6c65420499bd2ab6c38a5269a2949906fd25fe5c" translate="yes" xml:space="preserve">
          <source>A type representing a standard internet data format. &quot;MIME&quot; stands for &quot;Multipurpose Internet Mail Extensions&quot;, since the standard was originally used to describe multimedia attachments to email messages.</source>
          <target state="translated">Тип,представляющий стандартный формат данных в Интернете.&quot;MIME&quot; означает &quot;Multipurpose Internet Mail Extensions&quot;,так как стандарт изначально использовался для описания мультимедийных вложений в сообщения электронной почты.</target>
        </trans-unit>
        <trans-unit id="fa12877ef329dc75c9fda25bdec3c035fe723779" translate="yes" xml:space="preserve">
          <source>A type representing compound expressions in parsed julia code (ASTs). Each expression consists of a &lt;code&gt;head&lt;/code&gt;&lt;code&gt;Symbol&lt;/code&gt; identifying which kind of expression it is (e.g. a call, for loop, conditional statement, etc.), and subexpressions (e.g. the arguments of a call). The subexpressions are stored in a &lt;code&gt;Vector{Any}&lt;/code&gt; field called &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">Тип, представляющий составные выражения в разобранном коде julia (AST). Каждое выражение состоит из &lt;code&gt;head&lt;/code&gt; &lt;code&gt;Symbol&lt;/code&gt; идентифицирующей , какой вид выражения оно (например, для вызова цикла, условного оператора и т.д.), а также подвыражения (например , аргументы вызова). Подвыражения хранятся в поле &lt;code&gt;Vector{Any}&lt;/code&gt; называется &lt;code&gt;args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12166025929849592cdb9b904ad437a429f4da9f" translate="yes" xml:space="preserve">
          <source>A type union is a special abstract type which includes as objects all instances of any of its argument types, constructed using the special &lt;a href=&quot;../../base/base/index#Core.Union&quot;&gt;&lt;code&gt;Union&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">Объединение типов - это специальный абстрактный тип, который включает в качестве объектов все экземпляры любого из своих типов аргументов, построенных с использованием специального ключевого слова &lt;a href=&quot;../../base/base/index#Core.Union&quot;&gt; &lt;code&gt;Union&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c659722eaa7a1851dcf2b15fa8b1da6d2c52b7b1" translate="yes" xml:space="preserve">
          <source>A type union is an abstract type which includes all instances of any of its argument types. The empty union &lt;a href=&quot;#Union%7B%7D&quot;&gt;&lt;code&gt;Union{}&lt;/code&gt;&lt;/a&gt; is the bottom type of Julia.</source>
          <target state="translated">Объединение типов - это абстрактный тип, который включает в себя все экземпляры любого из своих типов аргументов. Пустое объединение &lt;a href=&quot;#Union%7B%7D&quot;&gt; &lt;code&gt;Union{}&lt;/code&gt; &lt;/a&gt; - это нижний тип Julia.</target>
        </trans-unit>
        <trans-unit id="78a19252283d099431e9543c48dcfeb2c0c70cdb" translate="yes" xml:space="preserve">
          <source>A type used for controlling the rounding mode of floating point operations (via &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt;&lt;code&gt;rounding&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;setrounding&lt;/code&gt; functions), or as optional arguments for rounding to the nearest integer (via the &lt;code&gt;round&lt;/code&gt; function).</source>
          <target state="translated">Тип, используемый для управления режимом округления операций с плавающей запятой (через функции &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt; &lt;code&gt;rounding&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;setrounding&lt;/code&gt; округления ) или в качестве дополнительных аргументов для округления до ближайшего целого числа (через функцию &lt;code&gt;round&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cce4e44b3212d47f6685805f453e4928d3ab1723" translate="yes" xml:space="preserve">
          <source>A type with no fields that is the type of &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Тип без полей, который является типом &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c8120bb7a13d8189f767168488ba78dd50f96b4" translate="yes" xml:space="preserve">
          <source>A type with no fields whose singleton instance &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; is used to represent missing values.</source>
          <target state="translated">Тип без полей, у которого &lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; одноэлементный экземпляр, используется для представления отсутствующих значений.</target>
        </trans-unit>
        <trans-unit id="306e436a1878b67ebef890bd34b67f5c57414a92" translate="yes" xml:space="preserve">
          <source>A typical usage of such a pair of return values, however, extracts each value into a variable. Julia supports simple tuple &quot;destructuring&quot; that facilitates this:</source>
          <target state="translated">Типичное использование такой пары возвращаемых значений,однако,извлекает каждое значение в переменную.Джулия поддерживает простую &quot;деструкцию&quot; кортежа,которая облегчает это:</target>
        </trans-unit>
        <trans-unit id="913d40733121bbdbb40702c29375806cce6f85d2" translate="yes" xml:space="preserve">
          <source>A union of types over all values of a type parameter. &lt;code&gt;UnionAll&lt;/code&gt; is used to describe parametric types where the values of some parameters are not known.</source>
          <target state="translated">Объединение типов по всем значениям параметра типа. &lt;code&gt;UnionAll&lt;/code&gt; используется для описания параметрических типов, где значения некоторых параметров неизвестны.</target>
        </trans-unit>
        <trans-unit id="a657ba8f21c293af12b12dfaacd8ec7d70ec5e5a" translate="yes" xml:space="preserve">
          <source>A useful tool for measuring performance is the &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt;&lt;code&gt;@time&lt;/code&gt;&lt;/a&gt; macro. We here repeat the example with the global variable above, but this time with the type annotation removed:</source>
          <target state="translated">Полезным инструментом для измерения производительности является макрос &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt; &lt;code&gt;@time&lt;/code&gt; &lt;/a&gt; . Здесь мы повторяем пример с глобальной переменной выше, но на этот раз без аннотации типа:</target>
        </trans-unit>
        <trans-unit id="c5253993e5fc44814c87723bb62dfda7d99d25d2" translate="yes" xml:space="preserve">
          <source>A variable name can be &quot;reserved&quot; without assigning to it by declaring it as &lt;code&gt;global x&lt;/code&gt;. This prevents name conflicts for globals initialized after load time.</source>
          <target state="translated">Имя переменной можно &amp;laquo;зарезервировать&amp;raquo; без присвоения ему, объявив его &lt;code&gt;global x&lt;/code&gt; . Это предотвращает конфликты имен для глобальных объектов, инициализированных после загрузки.</target>
        </trans-unit>
        <trans-unit id="7fd534d23374f6545f94032e172165c5e2ffe3bb" translate="yes" xml:space="preserve">
          <source>A variable referring to the last computed value, automatically set at the interactive prompt.</source>
          <target state="translated">Переменная,относящаяся к последнему вычисленному значению,автоматически устанавливается в интерактивной подсказке.</target>
        </trans-unit>
        <trans-unit id="9301af4052e23061aeab00f8629595c8531efad3" translate="yes" xml:space="preserve">
          <source>A variable, in Julia, is a name associated (or bound) to a value. It's useful when you want to store a value (that you obtained after some math, for example) for later use. For example:</source>
          <target state="translated">Переменная,в Юлии,это имя,связанное (или привязанное)со значением.Она полезна,когда вы хотите сохранить значение (которое вы получили после некоторых математических вычислений,например)для последующего использования.Например:</target>
        </trans-unit>
        <trans-unit id="343ec2d984e66e00b3ae00539feb443a8166ee65" translate="yes" xml:space="preserve">
          <source>A variation on this approach, which avoids the appearance of type instability is to merge the &lt;code&gt;Int&lt;/code&gt; and &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; types into a single hybrid integer type, that internally changes representation when a result no longer fits into the size of a machine integer. While this superficially avoids type-instability at the level of Julia code, it just sweeps the problem under the rug by foisting all of the same difficulties onto the C code implementing this hybrid integer type. This approach &lt;em&gt;can&lt;/em&gt; be made to work and can even be made quite fast in many cases, but has several drawbacks. One problem is that the in-memory representation of integers and arrays of integers no longer match the natural representation used by C, Fortran and other languages with native machine integers. Thus, to interoperate with those languages, we would ultimately need to introduce native integer types anyway. Any unbounded representation of integers cannot have a fixed number of bits, and thus cannot be stored inline in an array with fixed-size slots &amp;ndash; large integer values will always require separate heap-allocated storage. And of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps &amp;ndash; situations where performance degrades unexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability to represent integer arrays without additional heap storage, and unpredictable performance characteristics make even the cleverest hybrid integer implementations a poor choice for high-performance numerical work.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; этого подхода, который позволяет избежать появления нестабильности типа, является объединение типов &lt;code&gt;Int&lt;/code&gt; и BigInt в один гибридный целочисленный тип, который внутренне изменяет представление, когда результат больше не соответствует размеру машинного целого числа. Хотя это внешне позволяет избежать нестабильности типов на уровне кода Джулии, он просто скрывает проблему, навязывая все те же трудности коду C, реализующему этот гибридный целочисленный тип. Такой подход &lt;em&gt;может&lt;/em&gt;заставить работать и даже во многих случаях может быть сделано довольно быстро, но имеет несколько недостатков. Одна из проблем заключается в том, что представление целых чисел и массивов целых чисел в памяти больше не соответствует естественному представлению, используемому в C, Fortran и других языках с машинными целыми числами. Таким образом, для взаимодействия с этими языками нам в любом случае потребуется ввести собственные целочисленные типы. Любое неограниченное представление целых чисел не может иметь фиксированное количество битов и, следовательно, не может храниться в массиве со слотами фиксированного размера - большие целочисленные значения всегда требуют отдельного хранилища, выделенного кучей. И, конечно же, независимо от того, насколько умна вы используете гибридную целочисленную реализацию, всегда есть ловушки производительности - ситуации, когда производительность неожиданно падает. Сложное представление, отсутствие взаимодействия с C и Fortran,Невозможность представления целочисленных массивов без дополнительного хранилища в куче и непредсказуемые характеристики производительности делают даже самые умные гибридные целочисленные реализации плохим выбором для высокопроизводительной численной работы.</target>
        </trans-unit>
        <trans-unit id="e58331c965191dacd80a8789c7e948a53ee2b04e" translate="yes" xml:space="preserve">
          <source>A very special macro is &lt;a href=&quot;../../base/base/index#Base.@generated&quot;&gt;&lt;code&gt;@generated&lt;/code&gt;&lt;/a&gt;, which allows you to define so-called &lt;em&gt;generated functions&lt;/em&gt;. These have the capability to generate specialized code depending on the types of their arguments with more flexibility and/or less code than what can be achieved with multiple dispatch. While macros work with expressions at parse time and cannot access the types of their inputs, a generated function gets expanded at a time when the types of the arguments are known, but the function is not yet compiled.</source>
          <target state="translated">Совершенно особый макрос - &lt;a href=&quot;../../base/base/index#Base.@generated&quot;&gt; &lt;code&gt;@generated&lt;/code&gt; &lt;/a&gt; , который позволяет вам определять так называемые &lt;em&gt;сгенерированные функции&lt;/em&gt; . Они имеют возможность генерировать специализированный код в зависимости от типов своих аргументов с большей гибкостью и / или меньшим количеством кода, чем то, что может быть достигнуто с помощью множественной отправки. Хотя макросы работают с выражениями во время синтаксического анализа и не могут получить доступ к типам своих входных данных, сгенерированная функция расширяется в то время, когда типы аргументов известны, но функция еще не скомпилирована.</target>
        </trans-unit>
        <trans-unit id="141d8c5657b1c8b0553ace4a61596a7c1734a9a6" translate="yes" xml:space="preserve">
          <source>A wrapper type used in &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; to distinguish between the absence of a value (&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;) and the presence of a &lt;code&gt;nothing&lt;/code&gt; value (i.e. &lt;code&gt;Some(nothing)&lt;/code&gt;).</source>
          <target state="translated">Тип оболочки, используемый в &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; чтобы различать отсутствие значения ( &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; ) и наличие значения &amp;laquo; &lt;code&gt;nothing&lt;/code&gt; (то есть &lt;code&gt;Some(nothing)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="89c25a6e98b7d12432623429744aea6cf501424a" translate="yes" xml:space="preserve">
          <source>API reference</source>
          <target state="translated">ссылка API</target>
        </trans-unit>
        <trans-unit id="f6db2b825c2703e26c1c6b659f77956e578c5caf" translate="yes" xml:space="preserve">
          <source>ARGS</source>
          <target state="translated">ARGS</target>
        </trans-unit>
        <trans-unit id="a1df128dfacd3f460cbb61bb4087bb92287d3fcb" translate="yes" xml:space="preserve">
          <source>ARI</source>
          <target state="translated">ARI</target>
        </trans-unit>
        <trans-unit id="cade2543bf82eecb0447ba12066fcc5daa136208" translate="yes" xml:space="preserve">
          <source>ASCII characters and ASCII escapes produce a single byte.</source>
          <target state="translated">ASCII-символы и ASCII-беги дают один байт.</target>
        </trans-unit>
        <trans-unit id="20ab2d9088d2ab458d63ed3bd729fda9297db5a4" translate="yes" xml:space="preserve">
          <source>AV</source>
          <target state="translated">AV</target>
        </trans-unit>
        <trans-unit id="33a783add30fb01fc6df3bfeb87611c9fd6e0247" translate="yes" xml:space="preserve">
          <source>Abbr.</source>
          <target state="translated">Abbr.</target>
        </trans-unit>
        <trans-unit id="d634b593f2d04c176e6178cce99b9871b914261f" translate="yes" xml:space="preserve">
          <source>Above, it was pointed out that one can resolve ambiguities like</source>
          <target state="translated">Выше было отмечено,что можно разрешить такие двусмысленности,как</target>
        </trans-unit>
        <trans-unit id="444368fcd88ae8ee9706df79374d2260c8851efb" translate="yes" xml:space="preserve">
          <source>Abstract Arrays</source>
          <target state="translated">абстрактные массивы</target>
        </trans-unit>
        <trans-unit id="afab87d7da169104e68739efdca076e3028a0b71" translate="yes" xml:space="preserve">
          <source>Abstract Types</source>
          <target state="translated">Абстрактные типы</target>
        </trans-unit>
        <trans-unit id="3731303601cb9a5262dd9843918c4065a4b09ed2" translate="yes" xml:space="preserve">
          <source>Abstract containers and element types</source>
          <target state="translated">Абстрактные контейнеры и типы элементов</target>
        </trans-unit>
        <trans-unit id="b81afa6e965e7c1908221b1c01f57fb3e1ed309d" translate="yes" xml:space="preserve">
          <source>Abstract number types</source>
          <target state="translated">Абстрактные числовые типы</target>
        </trans-unit>
        <trans-unit id="203bf0ca60eba0b4df86ca193ff6564bf1f08046" translate="yes" xml:space="preserve">
          <source>Abstract supertype describing types that implement the synchronization primitives: &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.trylock&quot;&gt;&lt;code&gt;trylock&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#Base.islocked&quot;&gt;&lt;code&gt;islocked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Абстрактный супертип, описывающий типы, реализующие примитивы синхронизации: &lt;a href=&quot;#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.trylock&quot;&gt; &lt;code&gt;trylock&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Base.islocked&quot;&gt; &lt;code&gt;islocked&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="161cfe5f22c6ec0c5c1636e00ae6b86b4dfab7b0" translate="yes" xml:space="preserve">
          <source>Abstract supertype for IP addresses. &lt;a href=&quot;#Sockets.IPv4&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Sockets.IPv6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; are subtypes of this.</source>
          <target state="translated">Абстрактный супертип для IP-адресов. &lt;a href=&quot;#Sockets.IPv4&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Sockets.IPv6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt; являются подтипами этого.</target>
        </trans-unit>
        <trans-unit id="7ec52c1e034eaa75fbf55c8ad047e12dee7c43d5" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all floating point numbers.</source>
          <target state="translated">Абстрактный супертип для всех чисел с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="d3c5cb7bbcaf4de0abc6af421aee06fd1805c5f7" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all integers.</source>
          <target state="translated">Абстрактный супертип для всех целых чисел.</target>
        </trans-unit>
        <trans-unit id="c2307397eab7e7e325b924259a7acd689ce9202f" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all number types.</source>
          <target state="translated">Абстрактный супертип для всех типов чисел.</target>
        </trans-unit>
        <trans-unit id="8137ecd293ea0b9f148b79a2c5d9ef23135b11e0" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all real numbers.</source>
          <target state="translated">Абстрактный супертип для всех реальных чисел.</target>
        </trans-unit>
        <trans-unit id="5d4c24eb8dfef4792ccde0796267cae116c984c2" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all signed integers.</source>
          <target state="translated">Абстрактный супертип для всех значащих целых чисел.</target>
        </trans-unit>
        <trans-unit id="98c1a75aa7f0d6a8990b451bf94db6a410025a03" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all unsigned integers.</source>
          <target state="translated">Абстрактный супертип для всех беззнаковых целых чисел.</target>
        </trans-unit>
        <trans-unit id="93e4098f9689d748060c11ebe52324df10ec1351" translate="yes" xml:space="preserve">
          <source>Abstract supertype for rich display output devices. &lt;a href=&quot;#Base.Multimedia.TextDisplay&quot;&gt;&lt;code&gt;TextDisplay&lt;/code&gt;&lt;/a&gt; is a subtype of this.</source>
          <target state="translated">Абстрактный супертип для устройств вывода на дисплей. &lt;a href=&quot;#Base.Multimedia.TextDisplay&quot;&gt; &lt;code&gt;TextDisplay&lt;/code&gt; &lt;/a&gt; - это подтип этого.</target>
        </trans-unit>
        <trans-unit id="76cd9a3f07be7d40989b1baf043119bf5df6066e" translate="yes" xml:space="preserve">
          <source>Abstract type of all functions.</source>
          <target state="translated">Абстрактный тип всех функций.</target>
        </trans-unit>
        <trans-unit id="84e429cc9f28682f2f27e8d636ad9613a3b2da6d" translate="yes" xml:space="preserve">
          <source>Abstract types are declared using the &lt;a href=&quot;../../base/base/index#abstract%20type&quot;&gt;&lt;code&gt;abstract type&lt;/code&gt;&lt;/a&gt; keyword. The general syntaxes for declaring an abstract type are:</source>
          <target state="translated">Абстрактные типы объявляются с помощью ключевого слова &lt;a href=&quot;../../base/base/index#abstract%20type&quot;&gt; &lt;code&gt;abstract type&lt;/code&gt; &lt;/a&gt; . Общие синтаксисы для объявления абстрактного типа:</target>
        </trans-unit>
        <trans-unit id="c58fec15e5232080566685f01231f0dc1e49a918" translate="yes" xml:space="preserve">
          <source>Abstract types cannot be instantiated, and serve only as nodes in the type graph, thereby describing sets of related concrete types: those concrete types which are their descendants. We begin with abstract types even though they have no instantiation because they are the backbone of the type system: they form the conceptual hierarchy which makes Julia's type system more than just a collection of object implementations.</source>
          <target state="translated">Абстрактные типы не могут быть конкретизированы и служат только узлами на типовом графе,тем самым описывая наборы связанных конкретных типов:те конкретные типы,которые являются их потомками.Мы начинаем с абстрактных типов,несмотря на то,что они не имеют конкретизации,поскольку являются основой системы типов:они формируют концептуальную иерархию,которая делает систему типов Юлии больше,чем просто набор реализаций объектов.</target>
        </trans-unit>
        <trans-unit id="99f8f0ef23e181287cd6d3022637085c03e3e6b8" translate="yes" xml:space="preserve">
          <source>AbstractDict</source>
          <target state="translated">AbstractDict</target>
        </trans-unit>
        <trans-unit id="c0458876d81208a95087a4de5e1caaa1d2000c99" translate="yes" xml:space="preserve">
          <source>AbstractDisplay &lt;code&gt;x&lt;/code&gt; using the topmost applicable display in the display stack, typically using the richest supported multimedia output for &lt;code&gt;x&lt;/code&gt;, with plain-text &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; output as a fallback. The &lt;code&gt;display(d, x)&lt;/code&gt; variant attempts to display &lt;code&gt;x&lt;/code&gt; on the given display &lt;code&gt;d&lt;/code&gt; only, throwing a &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;d&lt;/code&gt; cannot display objects of this type.</source>
          <target state="translated">AbstractDisplay &lt;code&gt;x&lt;/code&gt; , используя верхний дисплей , применимый в стеке дисплея, как правило , с использованием самого богатыми поддерживаемой мультимедиа выхода для &lt;code&gt;x&lt;/code&gt; , с обычным текстом &lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; выводом в качестве запасного варианта. Вариант &lt;code&gt;display(d, x)&lt;/code&gt; пытается отобразить &lt;code&gt;x&lt;/code&gt; только на данном отображении &lt;code&gt;d&lt;/code&gt; , &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; если &lt;code&gt;d&lt;/code&gt; не может отображать объекты этого типа.</target>
        </trans-unit>
        <trans-unit id="7eaed6a73d55c164395b7a1a21e441cbb954faed" translate="yes" xml:space="preserve">
          <source>AbstractIrrational</source>
          <target state="translated">AbstractIrrational</target>
        </trans-unit>
        <trans-unit id="bf18f60e42cfb0779a9b4f7ddad8d2d330b3942c" translate="yes" xml:space="preserve">
          <source>AbstractLock</source>
          <target state="translated">AbstractLock</target>
        </trans-unit>
        <trans-unit id="b088bdfb0583418c7216120363be65d53cfb24c4" translate="yes" xml:space="preserve">
          <source>AbstractMatrix</source>
          <target state="translated">AbstractMatrix</target>
        </trans-unit>
        <trans-unit id="1a85fd0dbacd4a4cf6bcd5291fb7d75e1f9be36d" translate="yes" xml:space="preserve">
          <source>AbstractRange</source>
          <target state="translated">AbstractRange</target>
        </trans-unit>
        <trans-unit id="ce89d8527dc144fe8623087bd9235422a835ad7f" translate="yes" xml:space="preserve">
          <source>AbstractSet</source>
          <target state="translated">AbstractSet</target>
        </trans-unit>
        <trans-unit id="1d4be86b60074a8c81bb5c652c7352a1af4f56bd" translate="yes" xml:space="preserve">
          <source>AbstractUnitRange</source>
          <target state="translated">AbstractUnitRange</target>
        </trans-unit>
        <trans-unit id="69ac868610201e6a40f57ef6a33cac3933afa73e" translate="yes" xml:space="preserve">
          <source>AbstractVecOrMat</source>
          <target state="translated">AbstractVecOrMat</target>
        </trans-unit>
        <trans-unit id="6167adb4464ed99a679a24201ae93baff8fe87bb" translate="yes" xml:space="preserve">
          <source>AbstractVector</source>
          <target state="translated">AbstractVector</target>
        </trans-unit>
        <trans-unit id="ff33b5833701038044ed7a8bf95bb5da1639a716" translate="yes" xml:space="preserve">
          <source>Abusing this will corrupt the runtime system and cause undefined behavior:</source>
          <target state="translated">Злоупотребление этим повлечет за собой повреждение системы исполнения и приведет к неопределенному поведению:</target>
        </trans-unit>
        <trans-unit id="1067d0a82d1d5a296a37f79af88170005dbcf1e6" translate="yes" xml:space="preserve">
          <source>Ac Current</source>
          <target state="translated">Активный ток</target>
        </trans-unit>
        <trans-unit id="d1e31fbd4f9f4072d2446b9b7e8c1f20663d7c76" translate="yes" xml:space="preserve">
          <source>Accepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.</source>
          <target state="translated">Принимает соединение на данном сервере и возвращает соединение клиенту.Может быть предоставлен неинициализированный клиентский поток,в этом случае он будет использоваться вместо создания нового потока.</target>
        </trans-unit>
        <trans-unit id="5a231d65a330d9d9348434455d2fcc49d60050da" translate="yes" xml:space="preserve">
          <source>Access arrays in memory order, along columns</source>
          <target state="translated">Массивы доступа в порядке памяти,вдоль столбцов</target>
        </trans-unit>
        <trans-unit id="b34a6bc7b1bae42bda9d01ca1c470c5375ab7fb7" translate="yes" xml:space="preserve">
          <source>Accesses must have a stride pattern and cannot be &quot;gathers&quot; (random-index reads) or &quot;scatters&quot; (random-index writes).</source>
          <target state="translated">Доступы должны иметь шаблон шаблонов и не могут быть &quot;сейсмограммами&quot; (случайно-индексные чтения)или &quot;рассеивателями&quot; (случайно-индексная запись).</target>
        </trans-unit>
        <trans-unit id="04dff1094ca04d8d22abd4cb907396dab9a3d50f" translate="yes" xml:space="preserve">
          <source>Accessing Data through a Pointer</source>
          <target state="translated">Доступ к данным через указатель</target>
        </trans-unit>
        <trans-unit id="4e0aa606654432d6afe63016328a7456acbf5548" translate="yes" xml:space="preserve">
          <source>Accessing Documentation</source>
          <target state="translated">Доступ к документации</target>
        </trans-unit>
        <trans-unit id="5effc224ab155ff163fdf8204037715e80f5787f" translate="yes" xml:space="preserve">
          <source>Accessing Global Variables</source>
          <target state="translated">Доступ к глобальным переменным</target>
        </trans-unit>
        <trans-unit id="eece63f5b1a8127dcc472656346b5e65a1a16b4d" translate="yes" xml:space="preserve">
          <source>Accessing Returned Arrays</source>
          <target state="translated">Доступ к возвращаемым массивам</target>
        </trans-unit>
        <trans-unit id="94331919d037782e6104eb270ff9d9fb7da43903" translate="yes" xml:space="preserve">
          <source>Accessing the value associated with a name in a named tuple can be done using field access syntax, e.g. &lt;code&gt;x.a&lt;/code&gt;, or using &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;x[:a]&lt;/code&gt;. A tuple of the names can be obtained using &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt;, and a tuple of the values can be obtained using &lt;a href=&quot;../collections/index#Base.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Доступ к значению, связанному с именем в именованном кортеже, может быть выполнен с использованием синтаксиса доступа к полю, например &lt;code&gt;x.a&lt;/code&gt; , или с помощью &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; , например &lt;code&gt;x[:a]&lt;/code&gt; . Кортеж имен можно получить с помощью &lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt; , а кортеж значений можно получить с помощью &lt;a href=&quot;../collections/index#Base.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e66b7f3723702c43ff6e0aa8ffbcb4594a04f89" translate="yes" xml:space="preserve">
          <source>Accessor Functions</source>
          <target state="translated">Функции аксессуара</target>
        </trans-unit>
        <trans-unit id="d2767f0a53b5589f58d10c2a600ba9c937b4860b" translate="yes" xml:space="preserve">
          <source>Accumulation and clearing</source>
          <target state="translated">Накопление и очистка</target>
        </trans-unit>
        <trans-unit id="8d4bc1e3633428932020325ab9038391aedb805b" translate="yes" xml:space="preserve">
          <source>Accurate natural logarithm of &lt;code&gt;1+x&lt;/code&gt;. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments less than -1.</source>
          <target state="translated">Точный натуральный логарифм &lt;code&gt;1+x&lt;/code&gt; . Выдает &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt; для &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; аргументов меньше , чем -1.</target>
        </trans-unit>
        <trans-unit id="daec25040f3792b222435be23467b3ab6876b7a5" translate="yes" xml:space="preserve">
          <source>Accurately compute $e^x-1$.</source>
          <target state="translated">Точно рассчитайте $e^x-1$.</target>
        </trans-unit>
        <trans-unit id="11d200c26fa49e2ce4befb8e0cf46e14cd0db2d8" translate="yes" xml:space="preserve">
          <source>Acquire the &lt;code&gt;lock&lt;/code&gt; when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.</source>
          <target state="translated">Получите &lt;code&gt;lock&lt;/code&gt; когда она станет доступной. Если блокировка уже заблокирована другой задачей / потоком, подождите, пока она станет доступной.</target>
        </trans-unit>
        <trans-unit id="111fa83b00bb4738853e63e06a10c68a0195c86f" translate="yes" xml:space="preserve">
          <source>Acquire the lock if it is available, and return &lt;code&gt;true&lt;/code&gt; if successful. If the lock is already locked by a different task/thread, return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Получите блокировку, если она доступна, и верните &lt;code&gt;true&lt;/code&gt; в случае успеха. Если блокировка уже заблокирована другой задачей / потоком, верните &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2342ed0f0b229a0d03ed8168b59f19edf073636" translate="yes" xml:space="preserve">
          <source>Acute Angle</source>
          <target state="translated">Острый угол</target>
        </trans-unit>
        <trans-unit id="4e210cb6cb9deed65bd9b851c840063ddc24f3fc" translate="yes" xml:space="preserve">
          <source>Add a &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; to the scheduler's queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as &lt;a href=&quot;#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Добавить &lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; в очередь планировщика. Это приводит к тому, что задача будет выполняться постоянно, когда система в противном случае простаивает, если только задача не выполняет операцию блокировки, такую ​​как &lt;a href=&quot;#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba7029093da6b4c90c7e27d2113f54b848408051" translate="yes" xml:space="preserve">
          <source>Add a &lt;em&gt;fetch&lt;/em&gt; refspec for the specified &lt;code&gt;rmt&lt;/code&gt;. This refspec will contain information about which branch(es) to fetch from.</source>
          <target state="translated">Добавьте ссылку на &lt;em&gt;выборку&lt;/em&gt; для указанного &lt;code&gt;rmt&lt;/code&gt; . Этот refspec будет содержать информацию о том, из какой ветки (веток) производить выборку.</target>
        </trans-unit>
        <trans-unit id="bc32e59f77d37df698d49af8f9d944b43a7af79c" translate="yes" xml:space="preserve">
          <source>Add a &lt;em&gt;push&lt;/em&gt; refspec for the specified &lt;code&gt;rmt&lt;/code&gt;. This refspec will contain information about which branch(es) to push to.</source>
          <target state="translated">Добавьте &lt;em&gt;push&lt;/em&gt; refspec для указанного &lt;code&gt;rmt&lt;/code&gt; . Этот refspec будет содержать информацию о том, в какую ветвь (-а) нажать.</target>
        </trans-unit>
        <trans-unit id="7d2e4a20c94af16618f42a95303b58afe01cacad" translate="yes" xml:space="preserve">
          <source>Add a mark at the current position of stream &lt;code&gt;s&lt;/code&gt;. Return the marked position.</source>
          <target state="translated">Добавьте отметку в текущей позиции потока &lt;code&gt;s&lt;/code&gt; . Верните отмеченную позицию.</target>
        </trans-unit>
        <trans-unit id="c81d1e9a4af83f24f843b4a0dd03ec8759d823af" translate="yes" xml:space="preserve">
          <source>Add all the files with paths specified by &lt;code&gt;files&lt;/code&gt; to the index &lt;code&gt;idx&lt;/code&gt; (or the index of the &lt;code&gt;repo&lt;/code&gt;). If the file already exists, the index entry will be updated. If the file does not exist already, it will be newly added into the index. &lt;code&gt;files&lt;/code&gt; may contain glob patterns which will be expanded and any matching files will be added (unless &lt;code&gt;INDEX_ADD_DISABLE_PATHSPEC_MATCH&lt;/code&gt; is set, see below). If a file has been ignored (in &lt;code&gt;.gitignore&lt;/code&gt; or in the config), it &lt;em&gt;will not&lt;/em&gt; be added, &lt;em&gt;unless&lt;/em&gt; it is already being tracked in the index, in which case it &lt;em&gt;will&lt;/em&gt; be updated. The keyword argument &lt;code&gt;flags&lt;/code&gt; is a set of bit-flags which control the behavior with respect to ignored files:</source>
          <target state="translated">Добавьте все файлы с путями, указанными в &lt;code&gt;files&lt;/code&gt; в индекс &lt;code&gt;idx&lt;/code&gt; (или индекс &lt;code&gt;repo&lt;/code&gt; ). Если файл уже существует, запись индекса будет обновлена. Если файл еще не существует, он будет снова добавлен в индекс. &lt;code&gt;files&lt;/code&gt; могут содержать шаблоны глобусов, которые будут расширены, и любые соответствующие файлы будут добавлены (если не установлен &lt;code&gt;INDEX_ADD_DISABLE_PATHSPEC_MATCH&lt;/code&gt; , см. ниже). Если файл был проигнорирован (в &lt;code&gt;.gitignore&lt;/code&gt; или в конфигурации), он &lt;em&gt;не&lt;/em&gt; будет добавлен, &lt;em&gt;если&lt;/em&gt; он уже не отслеживается в индексе, и в этом случае он &lt;em&gt;будет&lt;/em&gt; обновлен. &lt;code&gt;flags&lt;/code&gt; аргумента ключевого слова представляет собой набор битовых флагов, которые управляют поведением игнорируемых файлов:</target>
        </trans-unit>
        <trans-unit id="f9859b5e151c0d4dccb9ba69eeb3e7174642b756" translate="yes" xml:space="preserve">
          <source>Add processes on remote machines via SSH. Requires &lt;code&gt;julia&lt;/code&gt; to be installed in the same location on each node, or to be available via a shared file system.</source>
          <target state="translated">Добавляйте процессы на удаленные машины через SSH. Требуется, чтобы &lt;code&gt;julia&lt;/code&gt; была установлена ​​в одном месте на каждом узле или была доступна через общую файловую систему.</target>
        </trans-unit>
        <trans-unit id="c93d7a95d43dad0a2e3566faa9380568c513bf49" translate="yes" xml:space="preserve">
          <source>Add the elements of &lt;code&gt;collection2&lt;/code&gt; to the end of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">Добавьте элементы &lt;code&gt;collection2&lt;/code&gt; в конец &lt;code&gt;collection&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="8f60daef6009f4b56c282cccb45652345ff90737" translate="yes" xml:space="preserve">
          <source>Addition operator. &lt;code&gt;x+y+z+...&lt;/code&gt; calls this function with all arguments, i.e. &lt;code&gt;+(x, y, z, ...)&lt;/code&gt;.</source>
          <target state="translated">Оператор сложения. &lt;code&gt;x+y+z+...&lt;/code&gt; вызывает эту функцию со всеми аргументами, т.е. &lt;code&gt;+(x, y, z, ...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23397c083849f8b996730f9a8baa14e28dc8e903" translate="yes" xml:space="preserve">
          <source>Additional examples and tests are available in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl&quot;&gt;&lt;code&gt;stdlib/Dates/test/adjusters.jl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Дополнительные примеры и тесты доступны в &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl&quot;&gt; &lt;code&gt;stdlib/Dates/test/adjusters.jl&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="685ef1698c6666c2bd0d492d0ee46828879da80d" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; is not limited to arrays (see the function documentation), it also handles tuples and treats any argument that is not an array, tuple or &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref&lt;/code&gt;&lt;/a&gt; (except for &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt;) as a &quot;scalar&quot;.</source>
          <target state="translated">Кроме того, &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; не ограничивается массивами (см. Документацию по функциям), она также обрабатывает кортежи и обрабатывает любой аргумент, не являющийся массивом, кортежем или &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref&lt;/code&gt; &lt;/a&gt; (кроме &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr&lt;/code&gt; &lt;/a&gt; ), как &amp;laquo;скаляр&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7f79534c24bf8f2a16bd71a1b6a3a39a544a8226" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;../../base/math/index#Base.Math.sinpi&quot;&gt;&lt;code&gt;sinpi(x)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.Math.cospi&quot;&gt;&lt;code&gt;cospi(x)&lt;/code&gt;&lt;/a&gt; are provided for more accurate computations of &lt;code&gt;sin(pi*x)&lt;/code&gt; and &lt;code&gt;cos(pi*x)&lt;/code&gt; respectively.</source>
          <target state="translated">Кроме того, &lt;a href=&quot;../../base/math/index#Base.Math.sinpi&quot;&gt; &lt;code&gt;sinpi(x)&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/math/index#Base.Math.cospi&quot;&gt; &lt;code&gt;cospi(x)&lt;/code&gt; &lt;/a&gt; предоставляются для более точных вычислений &lt;code&gt;sin(pi*x)&lt;/code&gt; и &lt;code&gt;cos(pi*x)&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="bf3a3f7bf5e98e1e5497ee4fe9676516a92be473" translate="yes" xml:space="preserve">
          <source>Additionally, code blocks can be enclosed using triple backticks with an optional &quot;language&quot; to specify how a block of code should be highlighted.</source>
          <target state="translated">Кроме того,блоки кода могут быть вложены с помощью тройных обратных ссылок с дополнительным &quot;языком&quot;,чтобы указать,как блок кода должен быть выделен.</target>
        </trans-unit>
        <trans-unit id="aa6d0dd52c8f973d7d02448858d93589ccb8e270" translate="yes" xml:space="preserve">
          <source>Additionally, full support for &lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers-1&quot;&gt;Complex and Rational Numbers&lt;/a&gt; is built on top of these primitive numeric types. All numeric types interoperate naturally without explicit casting, thanks to a flexible, user-extensible &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;type promotion system&lt;/a&gt;.</source>
          <target state="translated">Кроме того, на основе этих примитивных числовых типов построена полная поддержка &lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers-1&quot;&gt;сложных и рациональных чисел&lt;/a&gt; . Все числовые типы взаимодействуют естественным образом без явного приведения типов, благодаря гибкой, расширяемой пользователем &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;системе продвижения типов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccda9828ec19af11c51796660b5ccb16a7d0e952" translate="yes" xml:space="preserve">
          <source>Additionally, normal and exponential distributions are implemented for some &lt;code&gt;AbstractFloat&lt;/code&gt; and &lt;code&gt;Complex&lt;/code&gt; types, see &lt;a href=&quot;#Base.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Random.randexp&quot;&gt;&lt;code&gt;randexp&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Кроме того, для некоторых типов &lt;code&gt;AbstractFloat&lt;/code&gt; и &lt;code&gt;Complex&lt;/code&gt; реализованы нормальные и экспоненциальные распределения , подробности см. В &lt;a href=&quot;#Base.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Random.randexp&quot;&gt; &lt;code&gt;randexp&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99173595dabed80445cea4531dee6a385768b591" translate="yes" xml:space="preserve">
          <source>Additionally, parenthesized expressions can be used as coefficients to variables, implying multiplication of the expression by the variable:</source>
          <target state="translated">Кроме того,выражения в скобках могут использоваться в качестве коэффициентов к переменным,что подразумевает умножение выражения на переменную:</target>
        </trans-unit>
        <trans-unit id="fc43d556aa5aff0175b36169557918148740e7bb" translate="yes" xml:space="preserve">
          <source>Additionally, some exception types take one or more arguments that are used for error reporting:</source>
          <target state="translated">Кроме того,некоторые типы исключений принимают один или несколько аргументов,которые используются для сообщения об ошибках:</target>
        </trans-unit>
        <trans-unit id="8af66c1813abced10595ff4db44c8598650f35a8" translate="yes" xml:space="preserve">
          <source>Additionally, to support the syntax &lt;code&gt;S[end]&lt;/code&gt;, we must define &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to specify the last valid index. It is recommended to also define &lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt;&lt;code&gt;firstindex&lt;/code&gt;&lt;/a&gt; to specify the first valid index:</source>
          <target state="translated">Кроме того, для поддержки синтаксиса &lt;code&gt;S[end]&lt;/code&gt; мы должны определить &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt; &lt;code&gt;lastindex&lt;/code&gt; ,&lt;/a&gt; чтобы указать последний действительный индекс. Также рекомендуется определить &lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt; &lt;code&gt;firstindex&lt;/code&gt; ,&lt;/a&gt; чтобы указать первый действительный индекс:</target>
        </trans-unit>
        <trans-unit id="0d6e9dda2992ae61bd194a5d6431ac6a6fc0e4af" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; each of which should be a documentable expression. This syntax is equivalent to</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , каждая из которых должна быть документированным выражением. Этот синтаксис эквивалентен</target>
        </trans-unit>
        <trans-unit id="8943e54e348b67270f56f401533e4c55795efd88" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to expression generated by expanding &lt;code&gt;@m expression&lt;/code&gt;. This allows for expressions decorated with &lt;code&gt;@inline&lt;/code&gt;, &lt;code&gt;@noinline&lt;/code&gt;, &lt;code&gt;@generated&lt;/code&gt;, or any other macro to be documented in the same way as undecorated expressions.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к выражению, сгенерированному расширением &lt;code&gt;@m expression&lt;/code&gt; . Это позволяет &lt;code&gt;@inline&lt;/code&gt; выражения, украшенные @inline , &lt;code&gt;@noinline&lt;/code&gt; , &lt;code&gt;@generated&lt;/code&gt; или любым другим макросом, так же, как выражения без декорирования.</target>
        </trans-unit>
        <trans-unit id="c5cf536102070d30975cbdc29561f68968871a8c" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;@m(::Any)&lt;/code&gt; macro definition.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; в определение &lt;code&gt;@m(::Any)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84e25857657b333b201a4364df19960589319dca" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;Binding&lt;/code&gt;s &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; в &lt;code&gt;Binding&lt;/code&gt; s &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f9a2f04c857c99469b4786ce6042e5c04d6c307" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;M&lt;/code&gt;. Adding the docstring above the &lt;code&gt;Module&lt;/code&gt; is the preferred syntax, however both are equivalent.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к &lt;code&gt;Module&lt;/code&gt; &lt;code&gt;M&lt;/code&gt; . Добавление строки документации над &lt;code&gt;Module&lt;/code&gt; является предпочтительным синтаксисом, однако оба они эквивалентны.</target>
        </trans-unit>
        <trans-unit id="d607a4ba66a2defbbbd671ccd4f1fc3f1e66348d" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the function &lt;code&gt;f&lt;/code&gt;. The first version is the preferred syntax, however both are equivalent.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к функции &lt;code&gt;f&lt;/code&gt; . Первая версия является предпочтительным синтаксисом, однако обе эквивалентны.</target>
        </trans-unit>
        <trans-unit id="015afea43fcf05b33dc7ee7ee68bca2953573884" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the macro named &lt;code&gt;@m&lt;/code&gt;.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; в макрос с именем &lt;code&gt;@m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="827af43a45abefcd341e6f719f9f401e5c730792" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the method &lt;code&gt;f(::Any)&lt;/code&gt;.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к методу &lt;code&gt;f(::Any)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8df7e7a7df772447527b2f26ed82b0a9c8b23e3" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the value associated with &lt;code&gt;sym&lt;/code&gt;. Users should prefer documenting &lt;code&gt;sym&lt;/code&gt; at its definition.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к значению, связанному с &lt;code&gt;sym&lt;/code&gt; . Пользователи должны предпочесть документирование &lt;code&gt;sym&lt;/code&gt; в его определении.</target>
        </trans-unit>
        <trans-unit id="7496f9703fbec9a9c078ee921645986d1520779f" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to two &lt;code&gt;Method&lt;/code&gt;s, namely &lt;code&gt;f(::Any)&lt;/code&gt; and &lt;code&gt;f(::Any, ::Any)&lt;/code&gt;.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к двум &lt;code&gt;Method&lt;/code&gt; s, а именно &lt;code&gt;f(::Any)&lt;/code&gt; и &lt;code&gt;f(::Any, ::Any)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c8aaa795c4bb3bd668d398ed223b6d5b98c3053" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;&quot;x&quot;&lt;/code&gt; to field &lt;code&gt;T.x&lt;/code&gt; and &lt;code&gt;&quot;y&quot;&lt;/code&gt; to field &lt;code&gt;T.y&lt;/code&gt;. Also applicable to &lt;code&gt;mutable struct&lt;/code&gt; types.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к типу &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;&quot;x&quot;&lt;/code&gt; к полю &lt;code&gt;T.x&lt;/code&gt; и &lt;code&gt;&quot;y&quot;&lt;/code&gt; к полю &lt;code&gt;T.y&lt;/code&gt; . Также применимо к &lt;code&gt;mutable struct&lt;/code&gt; типам структур .</target>
        </trans-unit>
        <trans-unit id="509ef7b304e0d5048959f5a1e066b6245d575e62" translate="yes" xml:space="preserve">
          <source>Adds the docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to types &lt;code&gt;T1&lt;/code&gt;, &lt;code&gt;T2&lt;/code&gt;, and &lt;code&gt;T3&lt;/code&gt;.</source>
          <target state="translated">Добавляет строку документации &lt;code&gt;&quot;...&quot;&lt;/code&gt; к типам &lt;code&gt;T1&lt;/code&gt; , &lt;code&gt;T2&lt;/code&gt; и &lt;code&gt;T3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9a51c66a638e61a03f3ba3bc6a5ae7966f901a4" translate="yes" xml:space="preserve">
          <source>Adjuster Functions</source>
          <target state="translated">Функции регулятора</target>
        </trans-unit>
        <trans-unit id="3ed15208c269239266d3575007709a349ee8dcb4" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; by iterating at most &lt;code&gt;limit&lt;/code&gt; iterations by &lt;code&gt;step&lt;/code&gt; increments until &lt;code&gt;func&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;func&lt;/code&gt; must take a single &lt;code&gt;TimeType&lt;/code&gt; argument and return a &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;same&lt;/code&gt; allows &lt;code&gt;dt&lt;/code&gt; to be considered in satisfying &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">Регулирует &lt;code&gt;dt&lt;/code&gt; , повторяя не более &lt;code&gt;limit&lt;/code&gt; итераций с &lt;code&gt;step&lt;/code&gt; пока &lt;code&gt;func&lt;/code&gt; не вернет &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;func&lt;/code&gt; должен принимать единственный аргумент &lt;code&gt;TimeType&lt;/code&gt; и возвращать &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;same&lt;/code&gt; позволяет рассматривать &lt;code&gt;dt&lt;/code&gt; при выполнении &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="542b7e7c2fd74f8d271308bdddf4ad37b5294110" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the Monday of its week.</source>
          <target state="translated">Настраивает &lt;code&gt;dt&lt;/code&gt; на понедельник своей недели.</target>
        </trans-unit>
        <trans-unit id="ba3476b1421df6e3edaa8e17f787d5952e83be65" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the Sunday of its week.</source>
          <target state="translated">Настраивает &lt;code&gt;dt&lt;/code&gt; на воскресенье своей недели.</target>
        </trans-unit>
        <trans-unit id="3224cd68e5551ff4e3fc4fc6b2b947ffc7f24a64" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first &lt;code&gt;dow&lt;/code&gt; of its month. Alternatively, &lt;code&gt;of=Year&lt;/code&gt; will adjust to the first &lt;code&gt;dow&lt;/code&gt; of the year.</source>
          <target state="translated">Приспосабливает &lt;code&gt;dt&lt;/code&gt; к первому &lt;code&gt;dow&lt;/code&gt; месяца. В качестве альтернативы, &lt;code&gt;of=Year&lt;/code&gt; будет соответствовать первому &lt;code&gt;dow&lt;/code&gt; года.</target>
        </trans-unit>
        <trans-unit id="85f046851c6e044a73b6195b73c28ea067eb7654" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its month.</source>
          <target state="translated">Настраивает &lt;code&gt;dt&lt;/code&gt; на первый день месяца.</target>
        </trans-unit>
        <trans-unit id="f4430fe642c3e3cf011a04583f6d0f8ce92cdee6" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its quarter.</source>
          <target state="translated">Приспосабливает &lt;code&gt;dt&lt;/code&gt; к первому дню квартала.</target>
        </trans-unit>
        <trans-unit id="84bc65bd05f794b2297c4096e727f0dd2edbb9dd" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its year.</source>
          <target state="translated">Приспосабливает &lt;code&gt;dt&lt;/code&gt; к первому дню года.</target>
        </trans-unit>
        <trans-unit id="2f0c9a334203505d658bff6209e3cc9cb72c986e" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last &lt;code&gt;dow&lt;/code&gt; of its month. Alternatively, &lt;code&gt;of=Year&lt;/code&gt; will adjust to the last &lt;code&gt;dow&lt;/code&gt; of the year.</source>
          <target state="translated">Приспосабливает &lt;code&gt;dt&lt;/code&gt; к последнему &lt;code&gt;dow&lt;/code&gt; месяца. В качестве альтернативы &lt;code&gt;of=Year&lt;/code&gt; будет соответствовать последнему &lt;code&gt;dow&lt;/code&gt; года.</target>
        </trans-unit>
        <trans-unit id="78d3c49adba39ac1f401e060e547fe0cc0d6d99c" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its month.</source>
          <target state="translated">Настраивает &lt;code&gt;dt&lt;/code&gt; на последний день месяца.</target>
        </trans-unit>
        <trans-unit id="64612df263c1926bf9efeecdbaf1b82e9cd07b8e" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its quarter.</source>
          <target state="translated">Корректирует &lt;code&gt;dt&lt;/code&gt; до последнего дня квартала.</target>
        </trans-unit>
        <trans-unit id="91489c37594baa78e3476045075dafd7e9ef8e93" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its year.</source>
          <target state="translated">Настраивает &lt;code&gt;dt&lt;/code&gt; на последний день года.</target>
        </trans-unit>
        <trans-unit id="f360011526f7451524f23fc8d46d352e948cc7d3" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the next day of week corresponding to &lt;code&gt;dow&lt;/code&gt; with &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt;. Setting &lt;code&gt;same=true&lt;/code&gt; allows the current &lt;code&gt;dt&lt;/code&gt; to be considered as the next &lt;code&gt;dow&lt;/code&gt;, allowing for no adjustment to occur.</source>
          <target state="translated">Настраивает &lt;code&gt;dt&lt;/code&gt; на следующий день недели , соответствующий &lt;code&gt;dow&lt;/code&gt; с &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt; . Установка &lt;code&gt;same=true&lt;/code&gt; позволяет рассматривать текущий &lt;code&gt;dt&lt;/code&gt; как следующий &lt;code&gt;dow&lt;/code&gt; , не допуская никаких корректировок.</target>
        </trans-unit>
        <trans-unit id="068372d2e011960d73021d80afa760372bcf985c" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the previous day of week corresponding to &lt;code&gt;dow&lt;/code&gt; with &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt;. Setting &lt;code&gt;same=true&lt;/code&gt; allows the current &lt;code&gt;dt&lt;/code&gt; to be considered as the previous &lt;code&gt;dow&lt;/code&gt;, allowing for no adjustment to occur.</source>
          <target state="translated">Настраивает &lt;code&gt;dt&lt;/code&gt; на предыдущий день недели, соответствующий &lt;code&gt;dow&lt;/code&gt; с &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt; . Д. Установка &lt;code&gt;same=true&lt;/code&gt; позволяет рассматривать текущее значение &lt;code&gt;dt&lt;/code&gt; как предыдущее значение &lt;code&gt;dow&lt;/code&gt; без возможности корректировки.</target>
        </trans-unit>
        <trans-unit id="59c3f81e00ff6162254f4463064f47b013b2418f" translate="yes" xml:space="preserve">
          <source>Admonitions</source>
          <target state="translated">Admonitions</target>
        </trans-unit>
        <trans-unit id="836a223dfb6110b2db06c9c781ddc336919a8a06" translate="yes" xml:space="preserve">
          <source>Admonitions, like most other toplevel elements, can contain other toplevel elements.</source>
          <target state="translated">Допущения,как и большинство других элементов топ-уровня,могут содержать и другие элементы топ-уровня.</target>
        </trans-unit>
        <trans-unit id="b83b0b84935203a338ba6594cae9f540216d121e" translate="yes" xml:space="preserve">
          <source>Advance the iterator to obtain the next element. If no elements remain, &lt;code&gt;nothing&lt;/code&gt; should be returned. Otherwise, a 2-tuple of the next element and the new iteration state should be returned.</source>
          <target state="translated">Переместите итератор, чтобы получить следующий элемент. Если никаких элементов не осталось, &lt;code&gt;nothing&lt;/code&gt; должно быть возвращено. В противном случае должен быть возвращен кортеж из двух элементов следующего элемента и новое состояние итерации.</target>
        </trans-unit>
        <trans-unit id="4b6a7abaa616c69342aad0f3bc06d227b49b3cf3" translate="yes" xml:space="preserve">
          <source>Advance the stream &lt;code&gt;io&lt;/code&gt; such that the next-read character will be the first remaining for which &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. If the keyword argument &lt;code&gt;linecomment&lt;/code&gt; is specified, all characters from that character until the start of the next line are ignored.</source>
          <target state="translated">Продвиньте поток &lt;code&gt;io&lt;/code&gt; так, чтобы следующий прочитанный символ был первым оставшимся, для которого &lt;code&gt;predicate&lt;/code&gt; вернул &lt;code&gt;false&lt;/code&gt; . Если указано ключевое слово аргумент &lt;code&gt;linecomment&lt;/code&gt; , все символы от этого символа до начала следующей строки игнорируются.</target>
        </trans-unit>
        <trans-unit id="ec9c1eee60a6c8d412e86494c4538774b81ce815" translate="yes" xml:space="preserve">
          <source>Advanced Usage</source>
          <target state="translated">Расширенное использование</target>
        </trans-unit>
        <trans-unit id="ff26be938424cf2d67217e2575645ca68557c533" translate="yes" xml:space="preserve">
          <source>Aerial Tramway</source>
          <target state="translated">Аэродромный трамвай</target>
        </trans-unit>
        <trans-unit id="c3753451b13262a44f9a5817e07e24e560603141" translate="yes" xml:space="preserve">
          <source>After a call like &lt;code&gt;x = 5; y = power_by_squaring(x, 4)&lt;/code&gt;, you would get the expected result: &lt;code&gt;x == 5 &amp;amp;&amp;amp; y == 625&lt;/code&gt;. However, now suppose that &lt;code&gt;*=&lt;/code&gt;, when used with matrices, instead mutated the left hand side. There would be two problems:</source>
          <target state="translated">После звонка типа &lt;code&gt;x = 5; y = power_by_squaring(x, 4)&lt;/code&gt; , вы получите ожидаемый результат: &lt;code&gt;x == 5 &amp;amp;&amp;amp; y == 625&lt;/code&gt; . Однако теперь предположим, что &lt;code&gt;*=&lt;/code&gt; , когда используется с матрицами, вместо этого изменяет левую часть. Было бы две проблемы:</target>
        </trans-unit>
        <trans-unit id="db34be90d58adae735cb60ab04365869aa56065b" translate="yes" xml:space="preserve">
          <source>Airplane</source>
          <target state="translated">Airplane</target>
        </trans-unit>
        <trans-unit id="80135999396a20e42730a1c2e1dfae947e0952c1" translate="yes" xml:space="preserve">
          <source>Alarm Clock</source>
          <target state="translated">Будильник</target>
        </trans-unit>
        <trans-unit id="4c76737983211c324879531ef47ac946ce297c2e" translate="yes" xml:space="preserve">
          <source>Alef Symbol / First Transfinite Cardinal</source>
          <target state="translated">Символ Алефа/Первый трансформированный кардинал</target>
        </trans-unit>
        <trans-unit id="f2f34a33d9ae0109b50986f6079e5b5b8422fa27" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;UndefInitializer()&lt;/code&gt;, which constructs an instance of the singleton type &lt;a href=&quot;#Core.UndefInitializer&quot;&gt;&lt;code&gt;UndefInitializer&lt;/code&gt;&lt;/a&gt;, used in array initialization to indicate the array-constructor-caller would like an uninitialized array.</source>
          <target state="translated">Псевдоним для &lt;code&gt;UndefInitializer()&lt;/code&gt; , который создает экземпляр одноэлементного типа &lt;a href=&quot;#Core.UndefInitializer&quot;&gt; &lt;code&gt;UndefInitializer&lt;/code&gt; &lt;/a&gt; , используемый при инициализации массива, чтобы указать, что вызывающий конструктор массива хотел бы получить неинициализированный массив.</target>
        </trans-unit>
        <trans-unit id="38d75bc82e2c72130349f85ee2dea5673d201a42" translate="yes" xml:space="preserve">
          <source>Alien Monster</source>
          <target state="translated">Чужеродные монстры</target>
        </trans-unit>
        <trans-unit id="0c70d0069c9dc176b6060d55ab195149b38ec01a" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;export&lt;/code&gt;ed names (&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;), &lt;code&gt;MyModule.x&lt;/code&gt;, &lt;code&gt;MyModule.y&lt;/code&gt; and &lt;code&gt;MyModule.p&lt;/code&gt;</source>
          <target state="translated">Все &lt;code&gt;export&lt;/code&gt; имена ( &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; ), &lt;code&gt;MyModule.x&lt;/code&gt; , &lt;code&gt;MyModule.y&lt;/code&gt; и &lt;code&gt;MyModule.p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91f95289d7bb9f459a113b14aa6caea6d6b0ee5b" translate="yes" xml:space="preserve">
          <source>All Equal To</source>
          <target state="translated">Все равны</target>
        </trans-unit>
        <trans-unit id="59150af6415167841703220f4f97802416f10725" translate="yes" xml:space="preserve">
          <source>All I/O tasks, timers, REPL commands, etc are multiplexed onto a single OS thread via an event loop. A patched version of libuv (&lt;a href=&quot;http://docs.libuv.org/en/v1.x/&quot;&gt;http://docs.libuv.org/en/v1.x/&lt;/a&gt;) provides this functionality. Yield points provide for co-operatively scheduling multiple tasks onto the same OS thread. I/O tasks and timers yield implicitly while waiting for the event to occur. Calling &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt; explicitly allows for other tasks to be scheduled.</source>
          <target state="translated">Все задачи ввода-вывода, таймеры, команды REPL и т. Д. Мультиплексируются в один поток ОС через цикл событий. Исправленная версия libuv ( &lt;a href=&quot;http://docs.libuv.org/en/v1.x/&quot;&gt;http://docs.libuv.org/en/v1.x/&lt;/a&gt; ) предоставляет эту функцию. Точки доходности обеспечивают совместное планирование нескольких задач в одном потоке ОС. Задачи ввода-вывода и таймеры неявно уступают место в ожидании наступления события. Вызов &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; &lt;/a&gt; явно позволяет планировать другие задачи.</target>
        </trans-unit>
        <trans-unit id="e522896e2dfc730e2866839376a2a265314c5b2a" translate="yes" xml:space="preserve">
          <source>All Julia streams expose at least a &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method, taking the stream as their first argument, e.g.:</source>
          <target state="translated">Все потоки Julia предоставляют по крайней мере методы &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; , принимая поток в качестве первого аргумента, например:</target>
        </trans-unit>
        <trans-unit id="c6a6b81f53852c577455dd25f826592290abcb2e" translate="yes" xml:space="preserve">
          <source>All Objects</source>
          <target state="translated">Все объекты</target>
        </trans-unit>
        <trans-unit id="b272413234229118c2015aaa68ca35bdb9c75799" translate="yes" xml:space="preserve">
          <source>All code in the REPL is evaluated in global scope, so a variable defined and assigned at top level will be a &lt;strong&gt;global&lt;/strong&gt; variable. Variables defined at top level scope inside modules are also global.</source>
          <target state="translated">Весь код в REPL оценивается в глобальной области, поэтому переменная, определенная и назначенная на верхнем уровне, будет &lt;strong&gt;глобальной&lt;/strong&gt; переменной. Переменные, определенные на верхнем уровне внутри модулей, также являются глобальными.</target>
        </trans-unit>
        <trans-unit id="d45486021b7cdd7677275ec32e5637b641c26f3c" translate="yes" xml:space="preserve">
          <source>All comma-separated expressions after &lt;code&gt;for&lt;/code&gt; are interpreted as ranges. Adding parentheses lets us add a third argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Все выражения, разделенные запятыми после &lt;code&gt;for&lt;/code&gt; , интерпретируются как диапазоны. Добавление круглых скобок позволяет нам добавить третий аргумент в &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e1833bbb77ee3eab574ef8615d776277ec2b68aa" translate="yes" xml:space="preserve">
          <source>All connections are authenticated on both sides to ensure that only workers started by the master are allowed to connect to each other.</source>
          <target state="translated">Все соединения аутентифицируются с обеих сторон,чтобы гарантировать,что только рабочие,запущенные мастером,могут подключаться друг к другу.</target>
        </trans-unit>
        <trans-unit id="9ad5ec5b3a4aaf8bd9fb90db1fc3be44898322c8" translate="yes" xml:space="preserve">
          <source>All declared types (the &lt;code&gt;DataType&lt;/code&gt; variety) can be parameterized, with the same syntax in each case. We will discuss them in the following order: first, parametric composite types, then parametric abstract types, and finally parametric primitive types.</source>
          <target state="translated">Все объявленные типы ( разнообразие &lt;code&gt;DataType&lt;/code&gt; ) могут быть параметризованы с использованием одного и того же синтаксиса в каждом случае. Мы обсудим их в следующем порядке: сначала параметрические составные типы, затем параметрические абстрактные типы и, наконец, параметрические примитивные типы.</target>
        </trans-unit>
        <trans-unit id="d9c5dd854b32fb08dbc64da03bc88b2f5ca50052" translate="yes" xml:space="preserve">
          <source>All instances of some abstract types are by default considered &quot;sufficiently similar&quot; that a universal &lt;code&gt;convert&lt;/code&gt; definition is provided in Julia Base. For example, this definition states that it's valid to &lt;code&gt;convert&lt;/code&gt; any &lt;code&gt;Number&lt;/code&gt; type to any other by calling a 1-argument constructor:</source>
          <target state="translated">Все экземпляры некоторых абстрактных типов по умолчанию считаются &amp;laquo;достаточно похожими&amp;raquo;, &lt;code&gt;convert&lt;/code&gt; в Julia Base предоставляется универсальное определение преобразования . Например, это определение гласит, что можно &lt;code&gt;convert&lt;/code&gt; любой &lt;code&gt;Number&lt;/code&gt; тип в любой другой, вызвав конструктор с одним аргументом:</target>
        </trans-unit>
        <trans-unit id="40a2b8b6f65bf4cf79d2f004dafadcaa12f30e1e" translate="yes" xml:space="preserve">
          <source>All interface customization is done through the keyword only &lt;code&gt;TerminalMenus.config()&lt;/code&gt; function.</source>
          <target state="translated">Вся настройка интерфейса выполняется с помощью функции &lt;code&gt;TerminalMenus.config()&lt;/code&gt; только для ключевых слов .</target>
        </trans-unit>
        <trans-unit id="5e93c45e883f28df975e96b20e62c4d715867d52" translate="yes" xml:space="preserve">
          <source>All non-real parts of the diagonal will be ignored.</source>
          <target state="translated">Все нереальные части диагонали будут проигнорированы.</target>
        </trans-unit>
        <trans-unit id="7f36c1fb18a59b1d9f547660c394427791f475ab" translate="yes" xml:space="preserve">
          <source>All of the logging macros &lt;code&gt;@debug&lt;/code&gt;, &lt;code&gt;@info&lt;/code&gt;, &lt;code&gt;@warn&lt;/code&gt; and &lt;code&gt;@error&lt;/code&gt; share common features that are described in detail in the documentation for the more general macro &lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt;&lt;code&gt;@logmsg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Все макросы журналирования &lt;code&gt;@debug&lt;/code&gt; , &lt;code&gt;@info&lt;/code&gt; , &lt;code&gt;@warn&lt;/code&gt; и &lt;code&gt;@error&lt;/code&gt; имеют общие функции, которые подробно описаны в документации для более общего макроса &lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt; &lt;code&gt;@logmsg&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="97250d85e46e2f0063062a4fe00d04b5c8c86241" translate="yes" xml:space="preserve">
          <source>All operations on sparse matrices are carefully implemented to exploit the CSC data structure for performance, and to avoid expensive operations.</source>
          <target state="translated">Все операции с разреженными матрицами тщательно выполняются,чтобы использовать структуру данных CSC для повышения производительности и избежать дорогостоящих операций.</target>
        </trans-unit>
        <trans-unit id="d92bd72fff847012d04881678e278a18d2126812" translate="yes" xml:space="preserve">
          <source>All other combinations of arguments default to returning an &lt;code&gt;Array&lt;/code&gt;, but custom container types can define their own implementation and promotion-like rules to customize the result when they appear as arguments.</source>
          <target state="translated">Все другие комбинации аргументов по умолчанию возвращают &lt;code&gt;Array&lt;/code&gt; , но пользовательские типы контейнеров могут определять свою собственную реализацию и правила, подобные продвижению, для настройки результата, когда они появляются в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="de25475b274a168126e2d504207af50116291e77" translate="yes" xml:space="preserve">
          <source>All processes can directly communicate with each other.</source>
          <target state="translated">Все процессы могут напрямую взаимодействовать друг с другом.</target>
        </trans-unit>
        <trans-unit id="7feddee30f64db86bbc24d86a29d550a804d3b31" translate="yes" xml:space="preserve">
          <source>All processes in a cluster share the same cookie which, by default, is a randomly generated string on the master process:</source>
          <target state="translated">Все процессы в кластере используют один и тот же куки-файл,который по умолчанию является случайно сгенерированной строкой на мастер-процессе:</target>
        </trans-unit>
        <trans-unit id="ad59be0f62242de6d2f5d39eccfa83593fd9484b" translate="yes" xml:space="preserve">
          <source>All string types are subtypes of the abstract type &lt;code&gt;AbstractString&lt;/code&gt;, and external packages define additional &lt;code&gt;AbstractString&lt;/code&gt; subtypes (e.g. for other encodings). If you define a function expecting a string argument, you should declare the type as &lt;code&gt;AbstractString&lt;/code&gt; in order to accept any string type.</source>
          <target state="translated">Все строковые типы являются подтипами абстрактного типа &lt;code&gt;AbstractString&lt;/code&gt; , а внешние пакеты определяют дополнительные подтипы &lt;code&gt;AbstractString&lt;/code&gt; (например, для других кодировок). Если вы определяете функцию, ожидающую строкового аргумента, вы должны объявить тип как &lt;code&gt;AbstractString&lt;/code&gt; , чтобы принять любой строковый тип.</target>
        </trans-unit>
        <trans-unit id="b0dc699cc676b22c3459d4cf16d1eaa2e5774729" translate="yes" xml:space="preserve">
          <source>All subtypes of &lt;code&gt;AbstractDateToken&lt;/code&gt; must define this method in order to be able to print a Date / DateTime object according to a &lt;code&gt;DateFormat&lt;/code&gt; containing that token.</source>
          <target state="translated">Все подтипы &lt;code&gt;AbstractDateToken&lt;/code&gt; должны определять этот метод, чтобы иметь возможность печатать объект Date / DateTime в соответствии с &lt;code&gt;DateFormat&lt;/code&gt; , содержащим этот токен.</target>
        </trans-unit>
        <trans-unit id="1c882b6f017fe5d01060c9bf473577d13959404c" translate="yes" xml:space="preserve">
          <source>All the sorting and order related functions rely on a &quot;less than&quot; relation defining a total order on the values to be manipulated. The &lt;code&gt;isless&lt;/code&gt; function is invoked by default, but the relation can be specified via the &lt;code&gt;lt&lt;/code&gt; keyword.</source>
          <target state="translated">Все функции, связанные с сортировкой и упорядочением, полагаются на отношение &amp;laquo;меньше&amp;raquo;, определяющее общий порядок значений, которыми нужно управлять. Функция &lt;code&gt;isless&lt;/code&gt; вызывается по умолчанию, но отношение можно указать с помощью ключевого слова &lt;code&gt;lt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c82535675951a4a1fb997658084e8ecb7b3e47f" translate="yes" xml:space="preserve">
          <source>All the standard trigonometric and hyperbolic functions are also defined:</source>
          <target state="translated">Также определены все стандартные тригонометрические и гиперболические функции:</target>
        </trans-unit>
        <trans-unit id="6670e96208b5b1af061bdf66066d2386e48cd71d" translate="yes" xml:space="preserve">
          <source>All workers in a cluster share the same &lt;a href=&quot;#man-cluster-cookie-1&quot;&gt;cookie&lt;/a&gt; as the master. When the cookie is unspecified, i.e, with the &lt;code&gt;--worker&lt;/code&gt; option, the worker tries to read it from its standard input. &lt;code&gt;LocalManager&lt;/code&gt; and &lt;code&gt;SSHManager&lt;/code&gt; both pass the cookie to newly launched workers via their standard inputs.</source>
          <target state="translated">Все воркеры в кластере используют тот же &lt;a href=&quot;#man-cluster-cookie-1&quot;&gt;файл cookie,&lt;/a&gt; что и главный. Когда cookie не &lt;code&gt;--worker&lt;/code&gt; , то есть с параметром --worker , воркер пытается прочитать его со стандартного ввода. &lt;code&gt;LocalManager&lt;/code&gt; и &lt;code&gt;SSHManager&lt;/code&gt; передают cookie вновь запущенным рабочим через свои стандартные входы.</target>
        </trans-unit>
        <trans-unit id="cc1f71fefd88bfe7d7be3a2017ea32033d467364" translate="yes" xml:space="preserve">
          <source>Allocation of output container</source>
          <target state="translated">Распределение выходного контейнера</target>
        </trans-unit>
        <trans-unit id="dbd9853a9ad8ada702240986063881992112c9e5" translate="yes" xml:space="preserve">
          <source>Allowed Variable Names</source>
          <target state="translated">Допустимые переменные имена</target>
        </trans-unit>
        <trans-unit id="18ef6092b26e1508d93983ee74a79d58892de4c1" translate="yes" xml:space="preserve">
          <source>Almost Equal Or Equal To</source>
          <target state="translated">Почти равны или равны</target>
        </trans-unit>
        <trans-unit id="1fbf3e4677335672b3087596163b48e552785b56" translate="yes" xml:space="preserve">
          <source>Almost Equal To</source>
          <target state="translated">Почти равный</target>
        </trans-unit>
        <trans-unit id="7475fcee6d3c9395bedceacb414c243d6b969b91" translate="yes" xml:space="preserve">
          <source>Almost Equal To With Circumflex Accent</source>
          <target state="translated">Почти одинаково с акцентом циркумфлекс.</target>
        </trans-unit>
        <trans-unit id="2c35923911b4ba37311dbb677458e2c0adca9382" translate="yes" xml:space="preserve">
          <source>Alright, now that we have a better understanding of how generated functions work, let's use them to build some more advanced (and valid) functionality...</source>
          <target state="translated">Хорошо,теперь,когда мы лучше понимаем,как работают генерируемые функции,давайте используем их,чтобы построить более продвинутую (и действующую)функциональность...</target>
        </trans-unit>
        <trans-unit id="c2ff920784db1defb83bee5378709d9aaacf2e45" translate="yes" xml:space="preserve">
          <source>Also notice the difference between &lt;code&gt;max.(a,b)&lt;/code&gt;, which &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;s &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; elementwise over &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum(a)&lt;/code&gt;&lt;/a&gt;, which finds the largest value within &lt;code&gt;a&lt;/code&gt;. The same relationship holds for &lt;code&gt;min.(a,b)&lt;/code&gt; and &lt;code&gt;minimum(a)&lt;/code&gt;.</source>
          <target state="translated">Также обратите внимание на разницу между &lt;code&gt;max.(a,b)&lt;/code&gt; , который &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; s &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; поэлементно через &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , и &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum(a)&lt;/code&gt; &lt;/a&gt; , который находит наибольшее значение в &lt;code&gt;a&lt;/code&gt; . Такое же соотношение сохраняется для &lt;code&gt;minimum(a)&lt;/code&gt; &lt;code&gt;min.(a,b)&lt;/code&gt; и минимума (a) .</target>
        </trans-unit>
        <trans-unit id="9c0081a46476345434d3719172fe53c135ada9e3" translate="yes" xml:space="preserve">
          <source>Also observe the significant distinction between &lt;code&gt;\xff&lt;/code&gt; and &lt;code&gt;\uff&lt;/code&gt;: the former escape sequence encodes the &lt;em&gt;byte 255&lt;/em&gt;, whereas the latter escape sequence represents the &lt;em&gt;code point 255&lt;/em&gt;, which is encoded as two bytes in UTF-8:</source>
          <target state="translated">Также &lt;code&gt;\xff&lt;/code&gt; внимание на существенное различие между \ xff и &lt;code&gt;\uff&lt;/code&gt; : первая escape-последовательность кодирует &lt;em&gt;байт 255&lt;/em&gt; , тогда как последняя escape-последовательность представляет собой &lt;em&gt;кодовую точку 255&lt;/em&gt; , которая закодирована как два байта в UTF-8:</target>
        </trans-unit>
        <trans-unit id="6bc9da3cb0ed97f96102bee03dd8744d00eda6b1" translate="yes" xml:space="preserve">
          <source>Also recommended is Bruce Dawson's &lt;a href=&quot;https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/&quot;&gt;series of blog posts on floating-point numbers&lt;/a&gt;.</source>
          <target state="translated">Также рекомендуется &lt;a href=&quot;https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/&quot;&gt;серия публикаций&lt;/a&gt; Брюса Доусона о числах с плавающей запятой .</target>
        </trans-unit>
        <trans-unit id="a4d960a868768098e1ba53fb3f2c0df8ab0a40a7" translate="yes" xml:space="preserve">
          <source>Also, &lt;em&gt;every&lt;/em&gt; binary operator supports a &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot version&lt;/a&gt; that can be applied to arrays (and combinations of arrays and scalars) in such &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;fused broadcasting operations&lt;/a&gt;, e.g. &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt;.</source>
          <target state="translated">Кроме того, &lt;em&gt;каждый&lt;/em&gt; бинарный оператор поддерживает &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;версию&lt;/a&gt; с точкой, которая может применяться к массивам (и комбинациям массивов и скаляров) в таких объединенных &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;операциях широковещательной передачи&lt;/a&gt; , например &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef09b3cc10de506de44d97115e3fd6f71c9ee1fa" translate="yes" xml:space="preserve">
          <source>Also, the function that arguments are splatted into need not be a varargs function (although it often is):</source>
          <target state="translated">Кроме того,функция,в которую разбиваются аргументы,не обязательно должна быть функцией varargs (хотя это часто бывает):</target>
        </trans-unit>
        <trans-unit id="a36cb69e8042fa50a20647f8ee8afd7f80876eda" translate="yes" xml:space="preserve">
          <source>Alternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of &lt;code&gt;mode&lt;/code&gt; correspond to those from &lt;code&gt;fopen(3)&lt;/code&gt; or Perl &lt;code&gt;open&lt;/code&gt;, and are equivalent to setting the following boolean groups:</source>
          <target state="translated">Альтернативный синтаксис для open, где спецификатор режима на основе строки используется вместо пяти логических значений. Значения &lt;code&gt;mode&lt;/code&gt; соответствуют значениям из &lt;code&gt;fopen(3)&lt;/code&gt; или Perl &lt;code&gt;open&lt;/code&gt; и эквивалентны установке следующих булевых групп:</target>
        </trans-unit>
        <trans-unit id="a084d20c27ad4b5e370e6e41af49a7a8b0bbbe9c" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;using Module&lt;/code&gt; will import all exported &lt;code&gt;Module&lt;/code&gt; functions into the current namespace.</source>
          <target state="translated">В качестве альтернативы, &lt;code&gt;using Module&lt;/code&gt; импортирует все экспортированные функции &lt;code&gt;Module&lt;/code&gt; в текущее пространство имен.</target>
        </trans-unit>
        <trans-unit id="cfd0514a347606051a7fccfba50cde275fcde17f" translate="yes" xml:space="preserve">
          <source>Alternatively, a sequence of pair arguments may be passed.</source>
          <target state="translated">В качестве альтернативы может быть передана последовательность аргументов пары.</target>
        </trans-unit>
        <trans-unit id="05c4eee40518a92290ba5caa4623a48a40f59cc6" translate="yes" xml:space="preserve">
          <source>Alternatively, finer control and additional transformations may be be obtained by calling &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt;, where any number of the following boolean keywords options (which all default to &lt;code&gt;false&lt;/code&gt; except for &lt;code&gt;compose&lt;/code&gt;) are specified:</source>
          <target state="translated">В качестве альтернативы, более &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt; управление и дополнительные преобразования могут быть получены путем вызова Unicode.normalize (s; keywords ...) , где указано любое количество следующих логических параметров ключевых слов (для всех которых по умолчанию установлено значение &lt;code&gt;false&lt;/code&gt; , кроме &lt;code&gt;compose&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="010a2642adb5dc50cd6b75461c8c6c62daaeaa3c" translate="yes" xml:space="preserve">
          <source>Alternatively, for all methods but one you can insist that there is at least one element in the tuple:</source>
          <target state="translated">В качестве альтернативы,для всех методов,кроме одного,можно настоять на том,чтобы в кортеже был хотя бы один элемент:</target>
        </trans-unit>
        <trans-unit id="658838e4feeee97296786aaec18103d8deb93854" translate="yes" xml:space="preserve">
          <source>Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:</source>
          <target state="translated">В качестве альтернативы,если вы уже выделили массив,вы можете сгенерировать тонкую обертку вокруг его данных:</target>
        </trans-unit>
        <trans-unit id="09d124820084afee646f363e2b5b6737ae2fc063" translate="yes" xml:space="preserve">
          <source>Alternatively, look at the &lt;code&gt;embedding.c&lt;/code&gt; program in the Julia source tree in the &lt;code&gt;test/embedding/&lt;/code&gt; folder. The file &lt;code&gt;ui/repl.c&lt;/code&gt; program is another simple example of how to set &lt;code&gt;jl_options&lt;/code&gt; options while linking against &lt;code&gt;libjulia&lt;/code&gt;.</source>
          <target state="translated">Или посмотрите программу &lt;code&gt;embedding.c&lt;/code&gt; в дереве исходных текстов Julia в папке &lt;code&gt;test/embedding/&lt;/code&gt; . Программа файла &lt;code&gt;ui/repl.c&lt;/code&gt; - еще один простой пример того, как установить параметры &lt;code&gt;jl_options&lt;/code&gt; при линковке с &lt;code&gt;libjulia&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="138af7c8699b17e1331dd202694df9508d5db6a5" translate="yes" xml:space="preserve">
          <source>Although MATLAB users may find Julia's syntax familiar, Julia is not a MATLAB clone. There are major syntactic and functional differences. The following are some noteworthy differences that may trip up Julia users accustomed to MATLAB:</source>
          <target state="translated">Хотя пользователи MATLAB могут найти синтаксис Джулии знакомым,Джулия не является клоном MATLAB.Существуют значительные синтаксические и функциональные различия.Ниже приведены некоторые примечательные различия,которые могут сбить с толку пользователей Julia,привыкших к MATLAB:</target>
        </trans-unit>
        <trans-unit id="995141b8a0f9c91fdda45a6f5368f07495906a19" translate="yes" xml:space="preserve">
          <source>Although it is generally a good idea to return a fully initialized object from an inner constructor, it is possible to return incompletely initialized objects:</source>
          <target state="translated">Хотя,как правило,хорошо возвращать полностью инициализированный объект из внутреннего конструктора,можно возвращать и не полностью инициализированные объекты:</target>
        </trans-unit>
        <trans-unit id="37777e78887373deee2eff18df3fa452fb79fe3f" translate="yes" xml:space="preserve">
          <source>Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the Julia language. Core operations typically have dozens of methods:</source>
          <target state="translated">Хотя это кажется простым понятием,многократная диспетчеризация по типам значений является,пожалуй,самой мощной и центральной особенностью языка Julia.Операции с ядром,как правило,имеют десятки методов:</target>
        </trans-unit>
        <trans-unit id="29da1b638100965fc90d2d714395923c89f62871" translate="yes" xml:space="preserve">
          <source>Although one could, in principle, define methods for the &lt;code&gt;promote&lt;/code&gt; function directly, this would require many redundant definitions for all possible permutations of argument types. Instead, the behavior of &lt;code&gt;promote&lt;/code&gt; is defined in terms of an auxiliary function called &lt;a href=&quot;../../base/base/index#Base.promote_rule&quot;&gt;&lt;code&gt;promote_rule&lt;/code&gt;&lt;/a&gt;, which one can provide methods for. The &lt;code&gt;promote_rule&lt;/code&gt; function takes a pair of type objects and returns another type object, such that instances of the argument types will be promoted to the returned type. Thus, by defining the rule:</source>
          <target state="translated">Хотя в принципе можно было бы определять методы для функции &lt;code&gt;promote&lt;/code&gt; напрямую, это потребовало бы множества избыточных определений для всех возможных перестановок типов аргументов. Вместо этого поведение &lt;code&gt;promote&lt;/code&gt; определяется в терминах вспомогательной функции, называемой &lt;a href=&quot;../../base/base/index#Base.promote_rule&quot;&gt; &lt;code&gt;promote_rule&lt;/code&gt; &lt;/a&gt; , для которой можно предоставить методы. Функция &lt;code&gt;promote_rule&lt;/code&gt; принимает пару объектов типа и возвращает объект другого типа, так что экземпляры типов аргументов будут повышены до возвращаемого типа. Таким образом, определяя правило:</target>
        </trans-unit>
        <trans-unit id="b980acb1a668eb7b397d3aa918a20ac9dccd65cc" translate="yes" xml:space="preserve">
          <source>Although one sometimes speaks of dynamic languages as being &quot;typeless&quot;, they are definitely not: every object, whether primitive or user-defined, has a type. The lack of type declarations in most dynamic languages, however, means that one cannot instruct the compiler about the types of values, and often cannot explicitly talk about types at all. In static languages, on the other hand, while one can &amp;ndash; and usually must &amp;ndash; annotate types for the compiler, types exist only at compile time and cannot be manipulated or expressed at run time. In Julia, types are themselves run-time objects, and can also be used to convey information to the compiler.</source>
          <target state="translated">Хотя иногда говорят о динамических языках как о &amp;laquo;лишенных типа&amp;raquo;, это определенно не так: каждый объект, будь то примитивный или определяемый пользователем, имеет тип. Однако отсутствие объявлений типов в большинстве динамических языков означает, что нельзя проинструктировать компилятор о типах значений и часто вообще нельзя явно говорить о типах. В статических языках, с другой стороны, хотя можно и обычно необходимо аннотировать типы для компилятора, типы существуют только во время компиляции и не могут быть обработаны или выражены во время выполнения. В Julia типы сами по себе являются объектами времени выполнения и также могут использоваться для передачи информации компилятору.</target>
        </trans-unit>
        <trans-unit id="125f5076dabfcecbce55bdc53934ea25594cddd6" translate="yes" xml:space="preserve">
          <source>Although this seems innocent enough, the problem is that &lt;code&gt;0&lt;/code&gt; is an integer (of type &lt;code&gt;Int&lt;/code&gt;) and &lt;code&gt;x&lt;/code&gt; might be of any type. Thus, depending on the value of &lt;code&gt;x&lt;/code&gt;, this function might return a value of either of two types. This behavior is allowed, and may be desirable in some cases. But it can easily be fixed as follows:</source>
          <target state="translated">Хотя это кажется достаточно невинным, проблема в том, что &lt;code&gt;0&lt;/code&gt; - целое число (типа &lt;code&gt;Int&lt;/code&gt; ), а &lt;code&gt;x&lt;/code&gt; может быть любого типа. Таким образом, в зависимости от значения &lt;code&gt;x&lt;/code&gt; эта функция может возвращать значение любого из двух типов. Такое поведение разрешено и может быть желательным в некоторых случаях. Но это легко исправить следующим образом:</target>
        </trans-unit>
        <trans-unit id="0ec497a089c99ee5c6f04e61edfbbd31dd8344ae" translate="yes" xml:space="preserve">
          <source>Always gives the opposite answer as &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Всегда дает противоположный ответ: &lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4fd498143f69490fe006adbf63236a973c15889" translate="yes" xml:space="preserve">
          <source>Always show the signature of a function at the top of the documentation, with a four-space indent so that it is printed as Julia code.</source>
          <target state="translated">Всегда показывайте подпись функции в верхней части документации,с четырехпробным отступом,чтобы она была распечатана как код Julia.</target>
        </trans-unit>
        <trans-unit id="660916a9bd0a5e0c60196e069f980a7e1234e2f9" translate="yes" xml:space="preserve">
          <source>Amalgamation Or Coproduct</source>
          <target state="translated">Амальгамация или продукт</target>
        </trans-unit>
        <trans-unit id="6ed272289e5ab5f2571a80ecd7c9ab3c53aaab06" translate="yes" xml:space="preserve">
          <source>Ambulance</source>
          <target state="translated">Ambulance</target>
        </trans-unit>
        <trans-unit id="6d1fa3121887df24f251a0892c85ff68056930fd" translate="yes" xml:space="preserve">
          <source>American Football</source>
          <target state="translated">американский футбол</target>
        </trans-unit>
        <trans-unit id="f035eead5c54745562ec49798968d1579aa5f09e" translate="yes" xml:space="preserve">
          <source>An 8-byte identifying header is written to the stream first. To avoid writing the header, construct a &lt;code&gt;Serializer&lt;/code&gt; and use it as the first argument to &lt;code&gt;serialize&lt;/code&gt; instead. See also &lt;a href=&quot;#Serialization.writeheader&quot;&gt;&lt;code&gt;Serialization.writeheader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Сначала в поток записывается 8-байтовый идентифицирующий заголовок. Чтобы избежать написания заголовка, &lt;code&gt;Serializer&lt;/code&gt; &lt;code&gt;serialize&lt;/code&gt; вместо этого используйте его в качестве первого аргумента для сериализации . См. Также &lt;a href=&quot;#Serialization.writeheader&quot;&gt; &lt;code&gt;Serialization.writeheader&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f8eb9358e7cc36217bd2b82eb7c1c39f3757d67" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; that allows reading and performs writes by appending. Seeking and truncating are not supported. See &lt;a href=&quot;#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; for the available constructors. If &lt;code&gt;data&lt;/code&gt; is given, creates a &lt;code&gt;PipeBuffer&lt;/code&gt; to operate on a data vector, optionally specifying a size beyond which the underlying &lt;code&gt;Array&lt;/code&gt; may not be grown.</source>
          <target state="translated">&lt;a href=&quot;#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt; , что позволяет читать и выполняет пишет, присоединяя. Поиск и усечение не поддерживаются. См. Доступные конструкторы в &lt;a href=&quot;#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt; . Если &lt;code&gt;data&lt;/code&gt; заданы, создает &lt;code&gt;PipeBuffer&lt;/code&gt; для работы с вектором данных, при необходимости указывая размер, за пределами которого базовый &lt;code&gt;Array&lt;/code&gt; не может быть увеличен .</target>
        </trans-unit>
        <trans-unit id="46a38d582619a610af47f792a125ea49f7521df6" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; is raised if all workers cannot be terminated before the requested &lt;code&gt;waitfor&lt;/code&gt; seconds.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt; повышается , если все работники не могут быть прекращены до запрошенного &lt;code&gt;waitfor&lt;/code&gt; секунд.</target>
        </trans-unit>
        <trans-unit id="1bb56954c25d718243d7106afdb56cc9d480c633" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AbstractRange&lt;/code&gt; giving the indices of the &lt;code&gt;k&lt;/code&gt;th diagonal of the matrix &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AbstractRange&lt;/code&gt; давая индексы &lt;code&gt;k&lt;/code&gt; - й диагонали матрицы &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="213f54bf4207eca3291be6421983a526dc7b3d7a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArgumentError&lt;/code&gt; is thrown if &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values. Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the quantiles of non-missing values.</source>
          <target state="translated">&lt;code&gt;ArgumentError&lt;/code&gt; отбрасывается , если &lt;code&gt;itr&lt;/code&gt; содержит &lt;code&gt;NaN&lt;/code&gt; или &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; значения. Используйте &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; функцию , чтобы опустить &lt;code&gt;missing&lt;/code&gt; записи и вычисление квантилей , не являющихся пропущенными значений.</target>
        </trans-unit>
        <trans-unit id="6168a5d96f0d40b398487557f6a06e26763f063a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArgumentError&lt;/code&gt; is thrown if &lt;code&gt;v&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">&lt;code&gt;ArgumentError&lt;/code&gt; отбрасывается , если &lt;code&gt;v&lt;/code&gt; содержит &lt;code&gt;NaN&lt;/code&gt; или &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; значения.</target>
        </trans-unit>
        <trans-unit id="de0265152d952d723c42ab1da85aac224914443f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;N&lt;/code&gt; dimensional &lt;em&gt;strided&lt;/em&gt; array with elements of type &lt;code&gt;T&lt;/code&gt;. These arrays follow the &lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays-1&quot;&gt;strided array interface&lt;/a&gt;. If &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;StridedArray&lt;/code&gt;, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, &lt;code&gt;A&lt;/code&gt; could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing &lt;code&gt;A&lt;/code&gt; along dimension &lt;code&gt;d&lt;/code&gt; jumps in memory by [&lt;code&gt;strides(A, d)&lt;/code&gt;] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; мерный &lt;em&gt;strided&lt;/em&gt; массив с элементами типа &lt;code&gt;T&lt;/code&gt; . Эти массивы следуют &lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays-1&quot;&gt;интерфейсу&lt;/a&gt; с полосатым массивом . Если &lt;code&gt;A&lt;/code&gt; - &lt;code&gt;StridedArray&lt;/code&gt; , то его элементы хранятся в памяти со смещениями, которые могут варьироваться в зависимости от измерения, но являются постоянными в пределах измерения. Например, &lt;code&gt;A&lt;/code&gt; может иметь шаг 2 в измерении 1 и шаг 3 в измерении 2. При увеличении &lt;code&gt;A&lt;/code&gt; по измерению &lt;code&gt;d&lt;/code&gt; происходит скачок в памяти на [ &lt;code&gt;strides(A, d)&lt;/code&gt; ] слотов. Массивы с штриховкой особенно важны и полезны, потому что иногда их можно передавать напрямую как указатели на библиотеки иностранного языка, такие как BLAS.</target>
        </trans-unit>
        <trans-unit id="aa4010002940515c72a60f1328742b5780fa5172" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;NTuple&lt;/code&gt; of &lt;code&gt;N&lt;/code&gt;&lt;code&gt;Int&lt;/code&gt;s used to represent the dimensions of an &lt;a href=&quot;#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;NTuple&lt;/code&gt; из &lt;code&gt;N&lt;/code&gt; &lt;code&gt;Int&lt;/code&gt; ы используется для представления размеров в &lt;a href=&quot;#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86ab7a7129a70bb02730939dd401c0c0cf3528b7" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;environment&lt;/em&gt; determines what &lt;code&gt;import X&lt;/code&gt; and &lt;code&gt;using X&lt;/code&gt; mean in various code contexts and what files these statements cause to be loaded. Julia understands two kinds of environments:</source>
          <target state="translated">&lt;em&gt;Среда&lt;/em&gt; определяет то , что &lt;code&gt;import X&lt;/code&gt; и с &lt;code&gt;using X&lt;/code&gt; означает в различных кодовых контексты и какие файлы эти заявления вызывают к загрузке. Джулия понимает два типа окружения:</target>
        </trans-unit>
        <trans-unit id="d4692c48e17766970146c81604672bba8f6ba8a0" translate="yes" xml:space="preserve">
          <source>An HTML renderer would display this as: &lt;code&gt;Polar{Float64}&lt;/code&gt; complex number: 3.0</source>
          <target state="translated">Средство визуализации HTML отобразит это как: Комплексное число &lt;code&gt;Polar{Float64}&lt;/code&gt; : 3,0</target>
        </trans-unit>
        <trans-unit id="f5d640fb430f989eb8d86d4a923189e2c2ab6f36" translate="yes" xml:space="preserve">
          <source>An action signature (e.g. for committers, taggers, etc). Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt;&lt;code&gt;git_signature&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Подпись действия (например, для коммиттеров, тегеров и т. Д.). Соответствует структуре &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt; &lt;code&gt;git_signature&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="831ca4165fd1236bfdc4d70ab9d199abd7cc83b7" translate="yes" xml:space="preserve">
          <source>An advanced example</source>
          <target state="translated">Продвинутый пример</target>
        </trans-unit>
        <trans-unit id="d38eace5e9dd251808391417899bd07eb120ad72" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;Vector{StackFrame}&lt;/code&gt; provided for convenience; returned by calls to &lt;code&gt;stacktrace&lt;/code&gt;.</source>
          <target state="translated">Псевдоним для &lt;code&gt;Vector{StackFrame}&lt;/code&gt; предоставлен для удобства; возвращается вызовами &lt;code&gt;stacktrace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90783e8e994e5b4a2ae87f94a62cbca8637e0361" translate="yes" xml:space="preserve">
          <source>An alternative is to create a &quot;view&quot; of the array, which is an array object (a &lt;code&gt;SubArray&lt;/code&gt;) that actually references the data of the original array in-place, without making a copy. (If you write to a view, it modifies the original array's data as well.) This can be done for individual slices by calling &lt;a href=&quot;../../base/arrays/index#Base.view&quot;&gt;&lt;code&gt;view&lt;/code&gt;&lt;/a&gt;, or more simply for a whole expression or block of code by putting &lt;a href=&quot;../../base/arrays/index#Base.@views&quot;&gt;&lt;code&gt;@views&lt;/code&gt;&lt;/a&gt; in front of that expression. For example:</source>
          <target state="translated">Альтернативой является создание &amp;laquo;представления&amp;raquo; массива, которое представляет собой объект массива ( &lt;code&gt;SubArray&lt;/code&gt; ), который фактически ссылается на данные исходного массива на месте, без создания копии. (Если вы пишете в представление, оно также изменяет данные исходного массива.) Это можно сделать для отдельных срезов, вызвав &lt;a href=&quot;../../base/arrays/index#Base.view&quot;&gt; &lt;code&gt;view&lt;/code&gt; &lt;/a&gt; , или, проще говоря, для всего выражения или блока кода, поместив &lt;a href=&quot;../../base/arrays/index#Base.@views&quot;&gt; &lt;code&gt;@views&lt;/code&gt; &lt;/a&gt; перед этим выражением. Например:</target>
        </trans-unit>
        <trans-unit id="885d0eebcc9f4c68f23331045091c9a5f90ade43" translate="yes" xml:space="preserve">
          <source>An alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic, where adding to the largest integer value leaves it unchanged and likewise for subtracting from the smallest integer value. This is precisely what Matlab&amp;trade; does:</source>
          <target state="translated">Альтернативой использованию гибридных целых чисел или продвижению в BigInts является использование насыщающей целочисленной арифметики, когда добавление к наибольшему целочисленному значению оставляет его неизменным, а также для вычитания из наименьшего целочисленного значения. Именно это делает Matlab &amp;trade;:</target>
        </trans-unit>
        <trans-unit id="91592a446374cc055177971cd79c3aca7e004b7f" translate="yes" xml:space="preserve">
          <source>An alternative way to invoke a macro over an array literal (or comprehension) is to juxtapose both without using parentheses. In this case, the array will be the only expression fed to the macro. The following syntax is equivalent (and different from &lt;code&gt;@name [a b] * v&lt;/code&gt;):</source>
          <target state="translated">Альтернативный способ вызвать макрос над литералом массива (или пониманием) - это сопоставить оба без использования скобок. В этом случае массив будет единственным выражением, загружаемым в макрос. Следующий синтаксис эквивалентен (и отличается от &lt;code&gt;@name [a b] * v&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="f03a7e8903dd9860d01fd9cd12eaf55e1fc8996a" translate="yes" xml:space="preserve">
          <source>An analogous &quot;type-stability&quot; problem exists for variables used repeatedly within a function:</source>
          <target state="translated">Аналогичная проблема &quot;тип-стабильность&quot; существует для переменных,многократно используемых внутри функции:</target>
        </trans-unit>
        <trans-unit id="743741f9ed42719bff5265ccfe550c12e7459fce" translate="yes" xml:space="preserve">
          <source>An annotated git commit carries with it information about how it was looked up and why, so that rebase or merge operations have more information about the context of the commit. Conflict files contain information about the source/target branches in the merge which are conflicting, for instance. An annotated commit can refer to the tip of a remote branch, for instance when a &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt;&lt;code&gt;FetchHead&lt;/code&gt;&lt;/a&gt; is passed, or to a branch head described using &lt;code&gt;GitReference&lt;/code&gt;.</source>
          <target state="translated">Аннотированный коммит git содержит информацию о том, как он был найден и почему, так что операции перебазирования или слияния имеют больше информации о контексте коммита. Файлы конфликтов содержат информацию, например, об исходной / целевой ветвях в слиянии, которые конфликтуют. Аннотированная фиксация может относиться к концу удаленной ветки, например, когда &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt; &lt;code&gt;FetchHead&lt;/code&gt; &lt;/a&gt; , или к &lt;code&gt;GitReference&lt;/code&gt; ветки, описанному с помощью GitReference .</target>
        </trans-unit>
        <trans-unit id="0977e50dcc26db8fee5c84903315951fecb439bb" translate="yes" xml:space="preserve">
          <source>An anonymous function accepting multiple arguments can be written using the syntax &lt;code&gt;(x,y,z)-&amp;gt;2x+y-z&lt;/code&gt;. A zero-argument anonymous function is written as &lt;code&gt;()-&amp;gt;3&lt;/code&gt;. The idea of a function with no arguments may seem strange, but is useful for &quot;delaying&quot; a computation. In this usage, a block of code is wrapped in a zero-argument function, which is later invoked by calling it as &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Анонимная функция, принимающая несколько аргументов, может быть написана с использованием синтаксиса &lt;code&gt;(x,y,z)-&amp;gt;2x+y-z&lt;/code&gt; . Анонимная функция без аргументов записывается как &lt;code&gt;()-&amp;gt;3&lt;/code&gt; . Идея функции без аргументов может показаться странной, но она полезна для &amp;laquo;задержки&amp;raquo; вычислений. В этом случае блок кода заключен в функцию с нулевым аргументом, которая позже вызывается, вызывая ее как &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="670132e18df0dbda4c7927cbfa1f5f772c1b879a" translate="yes" xml:space="preserve">
          <source>An array allowing for &lt;code&gt;missing&lt;/code&gt; values but which does not contain any such value can be converted back to an array which does not allow for missing values using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;. If the array contains &lt;code&gt;missing&lt;/code&gt; values, a &lt;code&gt;MethodError&lt;/code&gt; is thrown during conversion</source>
          <target state="translated">Массив, допускающий &lt;code&gt;missing&lt;/code&gt; значения, но не содержащий таких значений, может быть преобразован обратно в массив, который не допускает пропущенных значений с помощью &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; . Если массив содержит &lt;code&gt;missing&lt;/code&gt; значения, во время преобразования &lt;code&gt;MethodError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41ac00a0bf9a5b610ef1696b9ce7b1bd86b26f82" translate="yes" xml:space="preserve">
          <source>An array is a collection of objects stored in a multi-dimensional grid. In the most general case, an array may contain objects of type &lt;a href=&quot;../../base/base/index#Core.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;. For most computational purposes, arrays should contain objects of a more specific type, such as &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Массив - это набор объектов, хранящихся в многомерной сетке. В самом общем случае массив может содержать объекты типа &lt;a href=&quot;../../base/base/index#Core.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; . Для большинства вычислительных целей массивы должны содержать объекты более определенного типа, например &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4fe522b01ac3a23b4adab253f39d747e24150892" translate="yes" xml:space="preserve">
          <source>An array of paths for &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; statements to consider as project environments or package directories when loading code. It is populated based on the &lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH-1&quot;&gt;&lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt;&lt;/a&gt; environment variable if set; otherwise it defaults to &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. Entries starting with &lt;code&gt;@&lt;/code&gt; have special meanings:</source>
          <target state="translated">Массив путей для операторов &lt;code&gt;using&lt;/code&gt; и &lt;code&gt;import&lt;/code&gt; , рассматриваемых как среды проекта или каталоги пакетов при загрузке кода. Он заполняется на &lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH-1&quot;&gt; &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; &lt;/a&gt; переменной среды JULIA_LOAD_PATH, если она установлена; в противном случае по умолчанию используется &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt; . Записи, начинающиеся с &lt;code&gt;@&lt;/code&gt; , имеют особое значение:</target>
        </trans-unit>
        <trans-unit id="cfcaca5094f1a9b10cd4725d7c73753c4f7c3e54" translate="yes" xml:space="preserve">
          <source>An array of scalar indices. This includes:</source>
          <target state="translated">Массив скалярных индексов.Это включает в себя:</target>
        </trans-unit>
        <trans-unit id="81e3e729218c7a16f9993c281c977ad17183e8f6" translate="yes" xml:space="preserve">
          <source>An array of the command line arguments passed to Julia, as strings.</source>
          <target state="translated">Массив аргументов командной строки,переданных Джулии,в виде строк.</target>
        </trans-unit>
        <trans-unit id="a0af30d315d1e58152feb3e6efd0b431012c6b41" translate="yes" xml:space="preserve">
          <source>An array with a specific element type can be constructed using the syntax &lt;code&gt;T[A, B, C, ...]&lt;/code&gt;. This will construct a 1-d array with element type &lt;code&gt;T&lt;/code&gt;, initialized to contain elements &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, etc. For example, &lt;code&gt;Any[x, y, z]&lt;/code&gt; constructs a heterogeneous array that can contain any values.</source>
          <target state="translated">Массив с определенным типом элемента может быть построен с использованием синтаксиса &lt;code&gt;T[A, B, C, ...]&lt;/code&gt; . Это создаст 1-мерный массив с типом элемента &lt;code&gt;T&lt;/code&gt; , инициализированный для содержания элементов &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; и т. Д. Например, &lt;code&gt;Any[x, y, z]&lt;/code&gt; создает гетерогенный массив, который может содержать любые значения.</target>
        </trans-unit>
        <trans-unit id="d49e95020e020a9b4ba7b0d2bd91635b96ade391" translate="yes" xml:space="preserve">
          <source>An assert might be disabled at various optimization levels. Assert should therefore only be used as a debugging tool and not used for authentication verification (e.g., verifying passwords), nor should side effects needed for the function to work correctly be used inside of asserts.</source>
          <target state="translated">Утверждение может быть отключено на различных уровнях оптимизации.Поэтому assert должен использоваться только как отладочный инструмент и не должен использоваться для проверки подлинности (например,для верификации паролей),а также не должен использовать внутри assert побочные эффекты,необходимые для корректной работы функции.</target>
        </trans-unit>
        <trans-unit id="71e89ce9e3702ca0f3496a7358d3f83d3e141bca" translate="yes" xml:space="preserve">
          <source>An assignment introducing a variable used inside a function, type or macro definition need not come before its inner usage:</source>
          <target state="translated">Присвоение,вводящее переменную,используемую внутри функции,типа или определения макроса,не обязательно должно предшествовать ее внутреннему использованию:</target>
        </trans-unit>
        <trans-unit id="d60802623cdaa53cdbcd142bd02b31e05d1a86f4" translate="yes" xml:space="preserve">
          <source>An easy way to find out is to extract the body into another (regular) function:</source>
          <target state="translated">Легкий способ выяснить это-извлечь организм в другую (регулярную)функцию:</target>
        </trans-unit>
        <trans-unit id="75ba7cfd59f985e2f5eac9d9bfbe0747c5db6475" translate="yes" xml:space="preserve">
          <source>An environment's graph is a multilevel map which assigns, for each &lt;code&gt;context&lt;/code&gt; UUID, a map from names to UUIDs, similar to the roots map but specific to that &lt;code&gt;context&lt;/code&gt;. When Julia sees &lt;code&gt;import X&lt;/code&gt; in the code of the package whose UUID is &lt;code&gt;context&lt;/code&gt;, it looks up the identity of &lt;code&gt;X&lt;/code&gt; as &lt;code&gt;graph[context][:X]&lt;/code&gt;. In particular, this means that &lt;code&gt;import X&lt;/code&gt; can refer to different packages depending on &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">Граф среды - это многоуровневая карта, которая назначает для каждого UUID &lt;code&gt;context&lt;/code&gt; карту от имен к UUID, аналогичную карте корней, но специфичную для этого &lt;code&gt;context&lt;/code&gt; . Когда Джулия видит &lt;code&gt;import X&lt;/code&gt; в коде пакета, UUID которого является &lt;code&gt;context&lt;/code&gt; , он ищет идентификатор &lt;code&gt;X&lt;/code&gt; как &lt;code&gt;graph[context][:X]&lt;/code&gt; . В частности, это означает, что &lt;code&gt;import X&lt;/code&gt; может ссылаться на разные пакеты в зависимости от &lt;code&gt;context&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e064b0051e803a86c003daf19461cf607e832da" translate="yes" xml:space="preserve">
          <source>An environment's roots map assigns package names to UUIDs for all the top-level dependencies that the environment makes available to the main project (i.e. the ones that can be loaded in &lt;code&gt;Main&lt;/code&gt;). When Julia encounters &lt;code&gt;import X&lt;/code&gt; in the main project, it looks up the identity of &lt;code&gt;X&lt;/code&gt; as &lt;code&gt;roots[:X]&lt;/code&gt;.</source>
          <target state="translated">Карта корней среды присваивает имена пакетов UUID для всех зависимостей верхнего уровня, которые среда делает доступными для основного проекта (т. Е. Тех, которые могут быть загружены в &lt;code&gt;Main&lt;/code&gt; ). Когда Джулия встречает &lt;code&gt;import X&lt;/code&gt; в основном проекте, она ищет идентификатор &lt;code&gt;X&lt;/code&gt; как &lt;code&gt;roots[:X]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a6b075a0dfee676c2586ba796e8721ea7d846f5" translate="yes" xml:space="preserve">
          <source>An error occurred when running a module's &lt;code&gt;__init__&lt;/code&gt; function. The actual error thrown is available in the &lt;code&gt;.error&lt;/code&gt; field.</source>
          <target state="translated">Произошла ошибка при запуске функции &lt;code&gt;__init__&lt;/code&gt; модуля . Фактическая ошибка доступна в поле &lt;code&gt;.error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f872e576e1623149d829361d58e2cd908722e2d7" translate="yes" xml:space="preserve">
          <source>An error occurred when trying to access &lt;code&gt;str&lt;/code&gt; at index &lt;code&gt;i&lt;/code&gt; that is not valid.</source>
          <target state="translated">Произошла ошибка при попытке доступа к &lt;code&gt;str&lt;/code&gt; по &lt;code&gt;i&lt;/code&gt; индексу i .</target>
        </trans-unit>
        <trans-unit id="f33bd5b60514925c67cf1bcd27c0b818d1eaa51d" translate="yes" xml:space="preserve">
          <source>An error occurred while &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;ing, &lt;a href=&quot;#Base.require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;ing, or &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; a file. The error specifics should be available in the &lt;code&gt;.error&lt;/code&gt; field.</source>
          <target state="translated">Произошла ошибка при &lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt; файла. Сведения об ошибке должны быть доступны в поле &lt;code&gt;.error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07364c5431123506298c1f1b97819a8211a7dee0" translate="yes" xml:space="preserve">
          <source>An example of correct usage of &lt;code&gt;Val&lt;/code&gt; would be:</source>
          <target state="translated">Пример правильного использования &lt;code&gt;Val&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c493074be2f87d14f247d6f580604d1e79d5ee3a" translate="yes" xml:space="preserve">
          <source>An exception is raised if a global constant is requested to be cleared.</source>
          <target state="translated">Исключение делается в том случае,если требуется очистить глобальную константу.</target>
        </trans-unit>
        <trans-unit id="74b831638ce2bece413802b1ce5999bdb817b935" translate="yes" xml:space="preserve">
          <source>An explicit &lt;code&gt;global&lt;/code&gt; is needed to assign to a global variable:</source>
          <target state="translated">Явный &lt;code&gt;global&lt;/code&gt; необходим для присвоения глобальной переменной:</target>
        </trans-unit>
        <trans-unit id="fa929fb7568ac9e14759cbe89ba07ba8ca4d3c90" translate="yes" xml:space="preserve">
          <source>An expression wrapped in this manner is left alone by the macro expander and simply pasted into the output verbatim. Therefore it will be resolved in the macro call environment.</source>
          <target state="translated">Выражение,обернутое таким образом,оставляется макрорасширителем и просто вставляется в выходной файл дословно.Поэтому оно будет разрешено в среде вызова макросов.</target>
        </trans-unit>
        <trans-unit id="4f8ce9f561ef25fa8ebcdf84d21250bf4af4d01b" translate="yes" xml:space="preserve">
          <source>An immutable object might contain mutable objects, such as arrays, as fields. Those contained objects will remain mutable; only the fields of the immutable object itself cannot be changed to point to different objects.</source>
          <target state="translated">Неизменный объект может содержать мутирующие объекты,такие как массивы,например,поля.Содержащиеся в нем объекты останутся мутируемыми;только поля самого неизменяемого объекта не могут быть изменены,чтобы указывать на различные объекты.</target>
        </trans-unit>
        <trans-unit id="a6b2f30177c22471afdf680fdefbc947052099b3" translate="yes" xml:space="preserve">
          <source>An implementation of an &lt;code&gt;AbstractWorkerPool&lt;/code&gt;. &lt;a href=&quot;#Distributed.remote&quot;&gt;&lt;code&gt;remote&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Distributed.remotecall_fetch-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;remotecall_fetch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; (and other remote calls which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker nodes, especially closures (which may capture large amounts of data).</source>
          <target state="translated">Реализация &lt;code&gt;AbstractWorkerPool&lt;/code&gt; . &lt;a href=&quot;#Distributed.remote&quot;&gt; &lt;code&gt;remote&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Distributed.remotecall_fetch-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;remotecall_fetch&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt; (и другие удаленные вызовы, выполняющие функции удаленно) выигрывают от кэширования сериализованных / десериализованных функций на рабочих узлах, особенно закрытий (которые могут захватывать большие объемы данных).</target>
        </trans-unit>
        <trans-unit id="22b306a470a7687a028d866f374bb4a4513c3bca" translate="yes" xml:space="preserve">
          <source>An implementation of distributed memory parallel computing is provided by module &lt;code&gt;Distributed&lt;/code&gt; as part of the standard library shipped with Julia.</source>
          <target state="translated">Реализация параллельных вычислений с распределенной памятью обеспечивается модулем &lt;code&gt;Distributed&lt;/code&gt; как часть стандартной библиотеки, поставляемой с Julia.</target>
        </trans-unit>
        <trans-unit id="d783ac603cd4b08c0d7cd2a76549bc1da1d2e64a" translate="yes" xml:space="preserve">
          <source>An important and powerful feature of Julia's type system is that it is parametric: types can take parameters, so that type declarations actually introduce a whole family of new types &amp;ndash; one for each possible combination of parameter values. There are many languages that support some version of &lt;a href=&quot;https://en.wikipedia.org/wiki/Generic_programming&quot;&gt;generic programming&lt;/a&gt;, wherein data structures and algorithms to manipulate them may be specified without specifying the exact types involved. For example, some form of generic programming exists in ML, Haskell, Ada, Eiffel, C++, Java, C#, F#, and Scala, just to name a few. Some of these languages support true parametric polymorphism (e.g. ML, Haskell, Scala), while others support ad-hoc, template-based styles of generic programming (e.g. C++, Java). With so many different varieties of generic programming and parametric types in various languages, we won't even attempt to compare Julia's parametric types to other languages, but will instead focus on explaining Julia's system in its own right. We will note, however, that because Julia is a dynamically typed language and doesn't need to make all type decisions at compile time, many traditional difficulties encountered in static parametric type systems can be relatively easily handled.</source>
          <target state="translated">Важной и мощной особенностью системы типов Джулии является то, что она является параметрической: типы могут принимать параметры, так что объявления типов фактически вводят целое семейство новых типов - по одному для каждой возможной комбинации значений параметров. Есть много языков, которые поддерживают некоторую версию &lt;a href=&quot;https://en.wikipedia.org/wiki/Generic_programming&quot;&gt;общего программирования.&lt;/a&gt;, при этом структуры данных и алгоритмы для управления ими могут быть указаны без указания конкретных задействованных типов. Например, некоторая форма общего программирования существует в ML, Haskell, Ada, Eiffel, C ++, Java, C #, F # и Scala, и это лишь некоторые из них. Некоторые из этих языков поддерживают истинный параметрический полиморфизм (например, ML, Haskell, Scala), в то время как другие поддерживают специальные стили общего программирования на основе шаблонов (например, C ++, Java). Имея так много различных разновидностей общего программирования и параметрических типов на разных языках, мы даже не будем пытаться сравнивать параметрические типы Джулии с другими языками, а вместо этого сосредоточимся на объяснении системы Джулии как таковой. Отметим, однако, что, поскольку Julia - это язык с динамической типизацией, которому не нужно принимать все решения о типе во время компиляции,со многими традиционными трудностями, встречающимися в статических системах параметрического типа, можно относительно легко справиться.</target>
        </trans-unit>
        <trans-unit id="a620af1ece25f934c185b8ddc35721eeb3f3fac2" translate="yes" xml:space="preserve">
          <source>An important point to note is that there is no loss in performance if the programmer relies on a function whose arguments are abstract types, because it is recompiled for each tuple of argument concrete types with which it is invoked. (There may be a performance issue, however, in the case of function arguments that are containers of abstract types; see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;.)</source>
          <target state="translated">Важно отметить, что нет потери в производительности, если программист полагается на функцию, аргументы которой являются абстрактными типами, потому что она перекомпилируется для каждого кортежа конкретных типов аргументов, с которыми она вызывается. (Однако может возникнуть проблема с производительностью в случае аргументов функции, которые являются контейнерами абстрактных типов; см. &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Советы по производительности&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="8a07f992d12e5a1cbc667f425042e464cb426b62" translate="yes" xml:space="preserve">
          <source>An important thing to remember is that, once fetched, a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; will cache its value locally. Further &lt;code&gt;fetch&lt;/code&gt; calls do not entail a network hop. Once all referencing &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s have fetched, the remote stored value is deleted.</source>
          <target state="translated">Важно помнить, что после получения &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; кэширует свое значение локально. Дальнейшие вызовы &lt;code&gt;fetch&lt;/code&gt; не влекут за собой сетевых переходов. После того, как будут получены все ссылки &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; , удаленное сохраненное значение удаляется.</target>
        </trans-unit>
        <trans-unit id="4b9125cf95c1847e0bf4f4e8c480c3ff78274eac" translate="yes" xml:space="preserve">
          <source>An important use of abstract types is to provide default implementations for concrete types. To give a simple example, consider:</source>
          <target state="translated">Важным использованием абстрактных типов является предоставление реализаций по умолчанию для конкретных типов.Чтобы привести простой пример,рассмотрим:</target>
        </trans-unit>
        <trans-unit id="46c08a285690627fd53df02bea8440f31cc7ca2d" translate="yes" xml:space="preserve">
          <source>An indexing operation into an &lt;code&gt;AbstractDict&lt;/code&gt; (&lt;code&gt;Dict&lt;/code&gt;) or &lt;code&gt;Set&lt;/code&gt; like object tried to access or delete a non-existent element.</source>
          <target state="translated">Операция индексации в объект &lt;code&gt;AbstractDict&lt;/code&gt; ( &lt;code&gt;Dict&lt;/code&gt; ) или &lt;code&gt;Set&lt;/code&gt; , подобный объекту, попыталась получить доступ или удалить несуществующий элемент.</target>
        </trans-unit>
        <trans-unit id="c0ef57c4e27de9e0e08cd005dba316af8fe9863a" translate="yes" xml:space="preserve">
          <source>An indexing operation into an array, &lt;code&gt;a&lt;/code&gt;, tried to access an out-of-bounds element at index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">Операция индексации в массиве &lt;code&gt;a&lt;/code&gt; попыталась получить доступ к элементу за пределами диапазона по индексу &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba7dc87158f89283a983f53bb3f993c869462761" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Point{Float64}&lt;/code&gt; can be represented compactly and efficiently as an immediate pair of 64-bit values;</source>
          <target state="translated">Экземпляр &lt;code&gt;Point{Float64}&lt;/code&gt; можно компактно и эффективно представить как непосредственную пару 64-битных значений;</target>
        </trans-unit>
        <trans-unit id="81188cb690cdf51aa857fee109d4a9ecc33db0cb" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Point{Real}&lt;/code&gt; must be able to hold any pair of instances of &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt;. Since objects that are instances of &lt;code&gt;Real&lt;/code&gt; can be of arbitrary size and structure, in practice an instance of &lt;code&gt;Point{Real}&lt;/code&gt; must be represented as a pair of pointers to individually allocated &lt;code&gt;Real&lt;/code&gt; objects.</source>
          <target state="translated">Экземпляр &lt;code&gt;Point{Real}&lt;/code&gt; должен иметь возможность содержать любую пару экземпляров &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; . Поскольку объекты, являющиеся экземплярами &lt;code&gt;Real&lt;/code&gt; , могут иметь произвольный размер и структуру, на практике экземпляр &lt;code&gt;Point{Real}&lt;/code&gt; должен быть представлен как пара указателей на индивидуально выделенные объекты &lt;code&gt;Real&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d49ef831f7376a07158e43b82f759fbd73bc08a0" translate="yes" xml:space="preserve">
          <source>An issue that arises in more complex macros is that of &lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;hygiene&lt;/a&gt;. In short, macros must ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding code they expand into. Conversely, the expressions that are passed into a macro as arguments are often &lt;em&gt;expected&lt;/em&gt; to evaluate in the context of the surrounding code, interacting with and modifying the existing variables. Another concern arises from the fact that a macro may be called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved to the correct module. Julia already has a major advantage over languages with textual macro expansion (like C) in that it only needs to consider the returned expression. All the other variables (such as &lt;code&gt;msg&lt;/code&gt; in &lt;code&gt;@assert&lt;/code&gt; above) follow the &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;normal scoping block behavior&lt;/a&gt;.</source>
          <target state="translated">Проблема, которая возникает в более сложных макросах, - это проблема &lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;гигиены&lt;/a&gt; . Короче говоря, макросы должны гарантировать, что переменные, которые они вводят в возвращаемых выражениях, случайно не конфликтуют с существующими переменными в окружающем коде, в который они расширяются. И наоборот, выражения, которые передаются в макрос в качестве аргументов, часто &lt;em&gt;ожидаются.&lt;/em&gt;для оценки в контексте окружающего кода, взаимодействуя с существующими переменными и изменяя их. Другая проблема возникает из-за того, что макрос может вызываться в другом модуле, отличном от того, в котором он был определен. В этом случае нам нужно убедиться, что все глобальные переменные разрешены в правильный модуль. У Джулии уже есть большое преимущество перед языками с текстовым расширением макросов (например, C) в том, что ей нужно учитывать только возвращаемое выражение. Все другие переменные (например, &lt;code&gt;msg&lt;/code&gt; в &lt;code&gt;@assert&lt;/code&gt; выше) следуют &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;обычному поведению блока области видимости&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5758b288cd7216deea6832521aad4c2142aa23b0" translate="yes" xml:space="preserve">
          <source>An iterator that accesses each element of the array &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;i =&amp;gt; x&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the index for the element and &lt;code&gt;x = A[i]&lt;/code&gt;. Identical to &lt;code&gt;pairs(A)&lt;/code&gt;, except that the style of index can be selected. Also similar to &lt;code&gt;enumerate(A)&lt;/code&gt;, except &lt;code&gt;i&lt;/code&gt; will be a valid index for &lt;code&gt;A&lt;/code&gt;, while &lt;code&gt;enumerate&lt;/code&gt; always counts from 1 regardless of the indices of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Итератор, который обращается к каждому элементу массива &lt;code&gt;A&lt;/code&gt; , возвращая &lt;code&gt;i =&amp;gt; x&lt;/code&gt; , где &lt;code&gt;i&lt;/code&gt; - индекс элемента, а &lt;code&gt;x = A[i]&lt;/code&gt; . Идентично &lt;code&gt;pairs(A)&lt;/code&gt; , за исключением того, что можно выбрать стиль индекса. Также похоже на &lt;code&gt;enumerate(A)&lt;/code&gt; , за исключением того, &lt;code&gt;i&lt;/code&gt; будет допустимый индекс для &lt;code&gt;A&lt;/code&gt; , в то время как &lt;code&gt;enumerate&lt;/code&gt; всегда рассчитывает с 1 независимо от показателей &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7a506ba2a82dcb065490fadb0cc0de3162d7501" translate="yes" xml:space="preserve">
          <source>An iterator that counts forever, starting at &lt;code&gt;start&lt;/code&gt; and incrementing by &lt;code&gt;step&lt;/code&gt;.</source>
          <target state="translated">Итератора , который подсчитывает навсегда, начиная с &lt;code&gt;start&lt;/code&gt; и увеличивается на &lt;code&gt;step&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48922b72538924c877a99f16d2a1501116dd1387" translate="yes" xml:space="preserve">
          <source>An iterator that cycles through &lt;code&gt;iter&lt;/code&gt; forever. If &lt;code&gt;iter&lt;/code&gt; is empty, so is &lt;code&gt;cycle(iter)&lt;/code&gt;.</source>
          <target state="translated">Итератор, который бесконечно проходит через &lt;code&gt;iter&lt;/code&gt; . Если &lt;code&gt;iter&lt;/code&gt; пуст, &lt;code&gt;cycle(iter)&lt;/code&gt; - тоже .</target>
        </trans-unit>
        <trans-unit id="2529486fdd6052d642060ef494ef6207d50e0319" translate="yes" xml:space="preserve">
          <source>An iterator that generates all but the first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">Итератор, который генерирует все элементы &lt;code&gt;iter&lt;/code&gt; , кроме первых &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="225cd1fc20e6b5e9157d6660f2d5a16cf5eaa208" translate="yes" xml:space="preserve">
          <source>An iterator that generates at most the first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">Итератор, который генерирует не более первых &lt;code&gt;n&lt;/code&gt; элементов &lt;code&gt;iter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e73058facca13f8b20620aa03238c21f3f77bff" translate="yes" xml:space="preserve">
          <source>An iterator that generates the value &lt;code&gt;x&lt;/code&gt; forever. If &lt;code&gt;n&lt;/code&gt; is specified, generates &lt;code&gt;x&lt;/code&gt; that many times (equivalent to &lt;code&gt;take(repeated(x), n)&lt;/code&gt;).</source>
          <target state="translated">Итератор, который навсегда генерирует значение &lt;code&gt;x&lt;/code&gt; . Если указано &lt;code&gt;n&lt;/code&gt; , генерирует &lt;code&gt;x&lt;/code&gt; столько раз (эквивалент &lt;code&gt;take(repeated(x), n)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="36e9bbba550395bdb9417724cabe5c648e9c151a" translate="yes" xml:space="preserve">
          <source>An iterator that yields &lt;code&gt;(i, x)&lt;/code&gt; where &lt;code&gt;i&lt;/code&gt; is a counter starting at 1, and &lt;code&gt;x&lt;/code&gt; is the &lt;code&gt;i&lt;/code&gt;th value from the given iterator. It's useful when you need not only the values &lt;code&gt;x&lt;/code&gt; over which you are iterating, but also the number of iterations so far. Note that &lt;code&gt;i&lt;/code&gt; may not be valid for indexing &lt;code&gt;iter&lt;/code&gt;; it's also possible that &lt;code&gt;x != iter[i]&lt;/code&gt;, if &lt;code&gt;iter&lt;/code&gt; has indices that do not start at 1. See the &lt;code&gt;pairs(IndexLinear(), iter)&lt;/code&gt; method if you want to ensure that &lt;code&gt;i&lt;/code&gt; is an index.</source>
          <target state="translated">Итератор, который возвращает &lt;code&gt;(i, x)&lt;/code&gt; где &lt;code&gt;i&lt;/code&gt; - счетчик, начинающийся с 1, а &lt;code&gt;x&lt;/code&gt; - это &lt;code&gt;i&lt;/code&gt; - е значение из данного итератора. Это полезно, когда вам нужны не только значения &lt;code&gt;x&lt;/code&gt; , по которым вы повторяете, но также количество итераций на данный момент. Обратите внимание, что &lt;code&gt;i&lt;/code&gt; может быть недействительным для индексации &lt;code&gt;iter&lt;/code&gt; ; также возможно, что &lt;code&gt;x != iter[i]&lt;/code&gt; , если у &lt;code&gt;iter&lt;/code&gt; есть индексы, которые не начинаются с 1. Если вы хотите убедиться, что &lt;code&gt;i&lt;/code&gt; является индексом, посмотрите метод &lt;code&gt;pairs(IndexLinear(), iter)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="266c36edd3f7797ff58b1ca95649bcf6b5c4372b" translate="yes" xml:space="preserve">
          <source>An iterator that yields the same elements as &lt;code&gt;iter&lt;/code&gt;, but starting at the given &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">Итератор, который возвращает те же элементы, что и &lt;code&gt;iter&lt;/code&gt; , но начиная с заданного &lt;code&gt;state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5702ee8b32ef9343efe014a1fb61b5e64e3eeb50" translate="yes" xml:space="preserve">
          <source>An object of type &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt;, representing an identity matrix of any size.</source>
          <target state="translated">Объект типа &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; &lt;/a&gt; , представляющий единичную матрицу любого размера.</target>
        </trans-unit>
        <trans-unit id="71c4c33f82250491a99ad21209540c93bfa32676" translate="yes" xml:space="preserve">
          <source>An object that represents an array of scalar indices and can be converted to such by &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt;&lt;code&gt;to_indices&lt;/code&gt;&lt;/a&gt;. By default this includes:</source>
          <target state="translated">Объект, который представляет собой массив скалярных индексов и может быть преобразован в него с помощью &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt; &lt;code&gt;to_indices&lt;/code&gt; &lt;/a&gt; . По умолчанию это включает:</target>
        </trans-unit>
        <trans-unit id="d4b6750cc125525c2ec2f6b1301138ae1f12a25d" translate="yes" xml:space="preserve">
          <source>An object that safely references data of type &lt;code&gt;T&lt;/code&gt;. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the &lt;code&gt;Ref&lt;/code&gt; itself is referenced.</source>
          <target state="translated">Объект , который безопасно ссылки на данные типа &lt;code&gt;T&lt;/code&gt; . Этот тип гарантированно указывает на допустимую, выделенную Julia память правильного типа. Базовые данные защищены от освобождения сборщиком мусора, пока есть &lt;code&gt;Ref&lt;/code&gt; сам Ref .</target>
        </trans-unit>
        <trans-unit id="89e56b05f03b0a54be4311a52e3844ad08220010" translate="yes" xml:space="preserve">
          <source>An object with an immutable type may be copied freely by the compiler since its immutability makes it impossible to programmatically distinguish between the original object and a copy.</source>
          <target state="translated">Объект с неизменяемым типом может быть свободно скопирован компилятором,так как его неизменяемость делает невозможным программно отличить исходный объект от копии.</target>
        </trans-unit>
        <trans-unit id="85eb57c0af1152d6c55f74e29c04701d2792e006" translate="yes" xml:space="preserve">
          <source>An operation allocated too much memory for either the system or the garbage collector to handle properly.</source>
          <target state="translated">Операция,на которую выделяется слишком много памяти,чтобы система или сборщик мусора могли справиться с ней надлежащим образом.</target>
        </trans-unit>
        <trans-unit id="51b16b4dd3a608065010ab050f1c044d587e4984" translate="yes" xml:space="preserve">
          <source>An operation tried to write to memory that is read-only.</source>
          <target state="translated">Операция пыталась записать в память,которая доступна только для чтения.</target>
        </trans-unit>
        <trans-unit id="0cdeff47b1133140cdc39aa6281a4193e4a3fd25" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-matrix operations is available</source>
          <target state="translated">Доступен оптимизированный метод матрично-матричных операций</target>
        </trans-unit>
        <trans-unit id="0f3dca7e150e49f15f11e7561b432ec79e089bf1" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-scalar operations is available</source>
          <target state="translated">Доступен оптимизированный метод матрично-скалярных операций.</target>
        </trans-unit>
        <trans-unit id="061f7a534d622ec7d7b76381cb35a581642e8473" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-vector operations is available</source>
          <target state="translated">Доступен оптимизированный метод матрично-векторных операций</target>
        </trans-unit>
        <trans-unit id="1459d918f4690c46e6b424c4fc07b16a81bb1321" translate="yes" xml:space="preserve">
          <source>An optimized method to find all the characteristic values and/or vectors is available</source>
          <target state="translated">Доступен оптимизированный метод поиска всех характерных значений и/или векторов</target>
        </trans-unit>
        <trans-unit id="cf356b7797f09dd430255cabba22e6b669b5778d" translate="yes" xml:space="preserve">
          <source>An optimized method to find the &lt;code&gt;il&lt;/code&gt;th through the &lt;code&gt;ih&lt;/code&gt;th characteristic values are available</source>
          <target state="translated">Доступен оптимизированный метод нахождения значений характеристик с &lt;code&gt;il&lt;/code&gt; - го по &lt;code&gt;ih&lt;/code&gt; - е.</target>
        </trans-unit>
        <trans-unit id="55662dcd806465abd15ea9ee92465cc49d4f4bb3" translate="yes" xml:space="preserve">
          <source>An optimized method to find the characteristic values in the interval [&lt;code&gt;vl&lt;/code&gt;, &lt;code&gt;vh&lt;/code&gt;] is available</source>
          <target state="translated">Доступен оптимизированный метод нахождения характеристических значений в интервале [ &lt;code&gt;vl&lt;/code&gt; , &lt;code&gt;vh&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="06771105d28cfe0fe650b94de200ff6d276e071c" translate="yes" xml:space="preserve">
          <source>An optimized method to find the characteristic vectors corresponding to the characteristic values &lt;code&gt;x=[x1, x2,...]&lt;/code&gt; is available</source>
          <target state="translated">Оптимизирован способ найти собственные векторы , соответствующие характеристических значений &lt;code&gt;x=[x1, x2,...]&lt;/code&gt; доступен</target>
        </trans-unit>
        <trans-unit id="f0a93e7d7160ec681ea6d7e4c04a7926b5ad27e7" translate="yes" xml:space="preserve">
          <source>An ordered list may start from a number other than one, as in the second list of the above example, where it is numbered from five. As with unordered lists, ordered lists can contain nested toplevel elements.</source>
          <target state="translated">Заказанный список может начинаться с номера,отличного от номера,как во втором списке вышеприведенного примера,где он пронумерован от пяти.Как и в случае с неупорядоченными списками,упорядоченные списки могут содержать вложенные элементы верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="03ca662d4f2c4b45816c66be6d31e3cf1480577f" translate="yes" xml:space="preserve">
          <source>An unsigned 64-bit integer (&lt;code&gt;uint64_t&lt;/code&gt;) that sets the maximum number of threads available to Julia. If &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; exceeds the number of available physical CPU cores, then the number of threads is set to the number of cores. If &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; is not positive or is not set, or if the number of CPU cores cannot be determined through system calls, then the number of threads is set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">64-разрядное целое число без знака ( &lt;code&gt;uint64_t&lt;/code&gt; ), которое устанавливает максимальное количество потоков, доступных для Julia. Если &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; превышает количество доступных физических ядер ЦП, то количество потоков устанавливается равным количеству ядер. Если &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; не является положительным или не задано, или если количество ядер ЦП не может быть определено с помощью системных вызовов, то количество потоков устанавливается на &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d32b092601fd9ebd2ac1ea5cb15d47455e3d9c4d" translate="yes" xml:space="preserve">
          <source>An updating operator rebinds the variable on the left-hand side. As a result, the type of the variable may change.</source>
          <target state="translated">Оператор обновления переманивает переменную с левой стороны.В результате тип переменной может измениться.</target>
        </trans-unit>
        <trans-unit id="8f8c77e7404ca30dcccf92c73c985f04a86420e7" translate="yes" xml:space="preserve">
          <source>Anchor</source>
          <target state="translated">Anchor</target>
        </trans-unit>
        <trans-unit id="e370a7226632723025763723f6dafd8d5d0d959c" translate="yes" xml:space="preserve">
          <source>And With Dot</source>
          <target state="translated">И с Дот</target>
        </trans-unit>
        <trans-unit id="fbef2e39e8fb91e6824e3edcfe418b3f32f423c2" translate="yes" xml:space="preserve">
          <source>And using that testset looks like:</source>
          <target state="translated">И использование этого тестового набора выглядит так:</target>
        </trans-unit>
        <trans-unit id="1f5999305ceff8dd17e050846ba5e997ba6e59ae" translate="yes" xml:space="preserve">
          <source>Anger Symbol</source>
          <target state="translated">символ гнева</target>
        </trans-unit>
        <trans-unit id="1fd70473fb3de634b409d4acaf49ffc1f90aae1f" translate="yes" xml:space="preserve">
          <source>Angle</source>
          <target state="translated">Angle</target>
        </trans-unit>
        <trans-unit id="b2a770be59cfda02ac18ae81ca3c69433ca33eac" translate="yes" xml:space="preserve">
          <source>Angle With S Inside</source>
          <target state="translated">Угол с S внутри</target>
        </trans-unit>
        <trans-unit id="2f17bd9fe54b168046c3599d1ee65207477b51c2" translate="yes" xml:space="preserve">
          <source>Angle With Underbar</source>
          <target state="translated">Угол с подбалкой</target>
        </trans-unit>
        <trans-unit id="235bfce3d68318529750179e362f5eb792952c9e" translate="yes" xml:space="preserve">
          <source>Angry Face</source>
          <target state="translated">Злое лицо</target>
        </trans-unit>
        <trans-unit id="5dcf9d8e34d0e0dc6accf2e555a98e501316d5eb" translate="yes" xml:space="preserve">
          <source>Angstrom Sign / Angstrom Unit</source>
          <target state="translated">Ангстром Сигнал/Ангстром Блок</target>
        </trans-unit>
        <trans-unit id="51cb7e1a070afb2a7be72806c484010b0b12881a" translate="yes" xml:space="preserve">
          <source>Anguished Face</source>
          <target state="translated">Смущённое лицо</target>
        </trans-unit>
        <trans-unit id="0a391a1d197db6b3528b4037a38a99b886bf2ca2" translate="yes" xml:space="preserve">
          <source>Annotate a &lt;code&gt;for&lt;/code&gt; loop to allow the compiler to take extra liberties to allow loop re-ordering</source>
          <target state="translated">Добавьте аннотации &lt;code&gt;for&lt;/code&gt; циклу for, чтобы компилятор имел дополнительные вольности и разрешил переупорядочение цикла.</target>
        </trans-unit>
        <trans-unit id="7c44ae2875c05d9e420a1ee94f547ea8d42d5f9f" translate="yes" xml:space="preserve">
          <source>Annotate values taken from untyped locations</source>
          <target state="translated">Аннотированные значения,взятые из нетиповых местоположений</target>
        </trans-unit>
        <trans-unit id="80abb045be1e210007d2a8998883d6f2947e4f8f" translate="yes" xml:space="preserve">
          <source>Annotates the expression &lt;code&gt;blk&lt;/code&gt; as a bounds checking block, allowing it to be elided by &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Аннотирует выражение &lt;code&gt;blk&lt;/code&gt; как блок проверки границ, позволяя опустить его с помощью &lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f497993755de46018a5ff1778be3f6bc999629d" translate="yes" xml:space="preserve">
          <source>Anonymous Functions</source>
          <target state="translated">Анонимные функции</target>
        </trans-unit>
        <trans-unit id="3f2245e0442788d1d0364df60f4a6e67754d3e89" translate="yes" xml:space="preserve">
          <source>Another common solution is to separate the reader and writer of the pipeline into separate &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s:</source>
          <target state="translated">Другое распространенное решение - разделить читателя и писателя конвейера на отдельные &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="fcd743f506f81055a92cce92b547fdb1e7daceb8" translate="yes" xml:space="preserve">
          <source>Another helper type is currently available for other cases, &lt;code&gt;Random.SamplerTag&lt;/code&gt;, but is considered as internal API, and can break at any time without proper deprecations.</source>
          <target state="translated">Другой вспомогательный тип в настоящее время доступен для других случаев, &lt;code&gt;Random.SamplerTag&lt;/code&gt; , но считается внутренним API и может выйти из строя в любое время без надлежащего устаревания.</target>
        </trans-unit>
        <trans-unit id="9b1d07d46031acec2c359f730da8bb2e51e75efb" translate="yes" xml:space="preserve">
          <source>Another non-standard version specification extension allows one to use a trailing &lt;code&gt;+&lt;/code&gt; to express an upper limit on build versions, e.g. &lt;code&gt;VERSION &amp;gt; v&quot;0.2-rc1+&quot;&lt;/code&gt; can be used to mean any version above &lt;code&gt;0.2-rc1&lt;/code&gt; and any of its builds: it will return &lt;code&gt;false&lt;/code&gt; for version &lt;code&gt;v&quot;0.2-rc1+win64&quot;&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;v&quot;0.2-rc2&quot;&lt;/code&gt;.</source>
          <target state="translated">Другое нестандартное расширение спецификации версии позволяет использовать завершающий &lt;code&gt;+&lt;/code&gt; для обозначения верхнего предела версий сборки, например, &lt;code&gt;VERSION &amp;gt; v&quot;0.2-rc1+&quot;&lt;/code&gt; может использоваться для обозначения любой версии выше &lt;code&gt;0.2-rc1&lt;/code&gt; и любой из ее сборок: it вернет &lt;code&gt;false&lt;/code&gt; для версии &lt;code&gt;v&quot;0.2-rc1+win64&quot;&lt;/code&gt; и &lt;code&gt;true&lt;/code&gt; для &lt;code&gt;v&quot;0.2-rc2&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f1f671807b09bc4fbe1759ebf099879c030bdbf" translate="yes" xml:space="preserve">
          <source>Another operation that applies to some types is &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt;&lt;code&gt;supertype&lt;/code&gt;&lt;/a&gt;, which reveals a type's supertype. Only declared types (&lt;code&gt;DataType&lt;/code&gt;) have unambiguous supertypes:</source>
          <target state="translated">Другая операция, которая применяется к некоторым типам, - это &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt; &lt;code&gt;supertype&lt;/code&gt; &lt;/a&gt; , который раскрывает супертип типа. Только объявленные типы ( &lt;code&gt;DataType&lt;/code&gt; ) имеют однозначные супертипы:</target>
        </trans-unit>
        <trans-unit id="937a3e6d6c5697202a728546d5a94531a97deb3c" translate="yes" xml:space="preserve">
          <source>Another possibility is the following, which could useful to adapt to cases where the parameter &lt;code&gt;T&lt;/code&gt; would need to be matched more narrowly:</source>
          <target state="translated">Другая возможность заключается в следующем, который может быть полезен для адаптации к случаям, когда параметр &lt;code&gt;T&lt;/code&gt; должен быть согласован более узко:</target>
        </trans-unit>
        <trans-unit id="934eafc149de740d97fce8516adf5aa645737af2" translate="yes" xml:space="preserve">
          <source>Another useful non-standard string literal is the byte-array string literal: &lt;code&gt;b&quot;...&quot;&lt;/code&gt;. This form lets you use string notation to express read only literal byte arrays &amp;ndash; i.e. arrays of &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; values. The type of those objects is &lt;code&gt;CodeUnits{UInt8, String}&lt;/code&gt;. The rules for byte array literals are the following:</source>
          <target state="translated">Другой полезный нестандартный строковый литерал - это строковый литерал байтового массива: &lt;code&gt;b&quot;...&quot;&lt;/code&gt; . Эта форма позволяет использовать строковую нотацию для выражения массивов байтов только для чтения, то есть массивов значений &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; . Тип этих объектов - &lt;code&gt;CodeUnits{UInt8, String}&lt;/code&gt; . Правила для литералов байтовых массивов следующие:</target>
        </trans-unit>
        <trans-unit id="30b18c65665f6fdbc3c1e0c1e53afe0ef7b0746f" translate="yes" xml:space="preserve">
          <source>Another way to create a sparse array is to convert a dense array into a sparse array using the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">Другой способ создать разреженный массив - преобразовать плотный массив в разреженный массив с помощью функции &lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d71bbbddbab448cf2f4551f57f136f71cf39aeab" translate="yes" xml:space="preserve">
          <source>Another way to view expressions is with &lt;code&gt;Meta.show_sexpr&lt;/code&gt;, which displays the &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S-expression&lt;/a&gt; form of a given &lt;code&gt;Expr&lt;/code&gt;, which may look very familiar to users of Lisp. Here's an example illustrating the display on a nested &lt;code&gt;Expr&lt;/code&gt;:</source>
          <target state="translated">Другой способ просмотра выражений - это &lt;code&gt;Meta.show_sexpr&lt;/code&gt; , который отображает форму &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S-выражения&lt;/a&gt; данного &lt;code&gt;Expr&lt;/code&gt; , которая может показаться очень знакомой пользователям Lisp. Вот пример, иллюстрирующий отображение вложенного &lt;code&gt;Expr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5468d9df43f9dcdfb8b8b349ce3a001cd05b665d" translate="yes" xml:space="preserve">
          <source>Another way, which used to be the only correct way before the advent of triangular dispatch in Julia v0.6, is:</source>
          <target state="translated">Другой путь,который был единственно правильным до появления треугольной диспетчерской в Юлии v0.6:</target>
        </trans-unit>
        <trans-unit id="02cc2a69720bd8bf1661deb23018e16470c069da" translate="yes" xml:space="preserve">
          <source>Ant</source>
          <target state="translated">Ant</target>
        </trans-unit>
        <trans-unit id="e25592206c84c0ddd18d548ca6206d3d080aef04" translate="yes" xml:space="preserve">
          <source>Antenna With Bars</source>
          <target state="translated">Антенна с барами</target>
        </trans-unit>
        <trans-unit id="27823909809855dca3ee48ccda6c67818ef39511" translate="yes" xml:space="preserve">
          <source>Anticlockwise Contour Integral</source>
          <target state="translated">Интеграл контура против часовой стрелки</target>
        </trans-unit>
        <trans-unit id="777a29798f3d057ac8c6bab9cead4b05d966905b" translate="yes" xml:space="preserve">
          <source>Anticlockwise Downwards And Upwards Open Circle Arrows</source>
          <target state="translated">Стрелки открытия круга против часовой стрелки вниз и вверх.</target>
        </trans-unit>
        <trans-unit id="e5cdf19e981398168cc33d41c80123d3c30a5081" translate="yes" xml:space="preserve">
          <source>Anticlockwise Integration</source>
          <target state="translated">Интеграция против часовой стрелки</target>
        </trans-unit>
        <trans-unit id="4ffeb49d53fc5643e555514643bbb1df4f049794" translate="yes" xml:space="preserve">
          <source>Anticlockwise Open Circle Arrow</source>
          <target state="translated">Стрелка открытия круга против часовой стрелки</target>
        </trans-unit>
        <trans-unit id="a52271b2a7c6cb5d3c1c456396438c1ddb68a4f9" translate="yes" xml:space="preserve">
          <source>Anticlockwise Top Semicircle Arrow</source>
          <target state="translated">Стрелка верхнего полукруга против часовой стрелки</target>
        </trans-unit>
        <trans-unit id="b661ec502ce7eec63576ef6980de816514a82733" translate="yes" xml:space="preserve">
          <source>Any changes you make to the array values (e.g., &lt;code&gt;A[3] = 0&lt;/code&gt;) will also change the values on disk</source>
          <target state="translated">Любые изменения, которые вы вносите в значения массива (например, &lt;code&gt;A[3] = 0&lt;/code&gt; ), также изменят значения на диске.</target>
        </trans-unit>
        <trans-unit id="3c5cca19d4f5741a5bb3f294473a79e10b7adbb5" translate="yes" xml:space="preserve">
          <source>Any code that is performance critical or being benchmarked should be inside a function.</source>
          <target state="translated">Любой код,критичный по производительности или подвергающийся бенчмаркингу,должен быть внутри функции.</target>
        </trans-unit>
        <trans-unit id="ba5b886162caf15daa7473ff8070c0f84e6be971" translate="yes" xml:space="preserve">
          <source>Any custom array of scalar indices that is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;</source>
          <target state="translated">Любой настраиваемый массив скалярных индексов, являющийся подтипом &lt;code&gt;AbstractArray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2973d806e6f61582719d2e58b280fa916079cead" translate="yes" xml:space="preserve">
          <source>Any custom testset type (subtype of &lt;code&gt;AbstractTestSet&lt;/code&gt;) can be given and it will also be used for any nested &lt;code&gt;@testset&lt;/code&gt; invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.</source>
          <target state="translated">Можно указать любой настраиваемый тип набора тестов (подтип &lt;code&gt;AbstractTestSet&lt;/code&gt; ), и он также будет использоваться для любых вложенных вызовов &lt;code&gt;@testset&lt;/code&gt; . Данные параметры применяются только к тому набору тестов, в котором они указаны. Тип набора тестов по умолчанию не имеет никаких параметров.</target>
        </trans-unit>
        <trans-unit id="31544d9a7acaba7c1156850319c97b90ce13cb9b" translate="yes" xml:space="preserve">
          <source>Any error stops &lt;code&gt;pmap&lt;/code&gt; from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument &lt;code&gt;on_error&lt;/code&gt; which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.</source>
          <target state="translated">Любая ошибка не позволяет &lt;code&gt;pmap&lt;/code&gt; обрабатывать оставшуюся часть коллекции. Чтобы переопределить это поведение, вы можете указать функцию обработки ошибок через аргумент &lt;code&gt;on_error&lt;/code&gt; , который принимает единственный аргумент, то есть исключение. Функция может остановить обработку, повторно выдав ошибку, или, чтобы продолжить, вернуть любое значение, которое затем возвращается вместе с результатами вызывающей стороне.</target>
        </trans-unit>
        <trans-unit id="fc28c907456157bf36df33491d1dd60e94bbee1e" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;f&lt;/code&gt; are printed to &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; on the remote worker.</source>
          <target state="translated">Любые исключения, вызванные &lt;code&gt;f&lt;/code&gt; , выводятся в &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; удаленного работника.</target>
        </trans-unit>
        <trans-unit id="74b6431314c500d9367b1ee7e25039a738c25b54" translate="yes" xml:space="preserve">
          <source>Any keyword arguments passed to &lt;code&gt;eigen&lt;/code&gt; are passed through to the lower-level &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt;&lt;code&gt;eigen!&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Любые аргументы ключевого слова, переданные в &lt;code&gt;eigen&lt;/code&gt; , передаются на собственный нижний уровень &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt; &lt;code&gt;eigen!&lt;/code&gt; &lt;/a&gt;функция.</target>
        </trans-unit>
        <trans-unit id="409446f789565d016b86ac80357893528260dc10" translate="yes" xml:space="preserve">
          <source>Any number of expressions many be documented together in this way. This syntax can be useful when two functions are related, such as non-mutating and mutating versions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f!&lt;/code&gt;.</source>
          <target state="translated">Таким способом можно документировать вместе любое количество выражений. Этот синтаксис может быть полезен, когда две функции связаны, например неизменяемые и изменяемые версии &lt;code&gt;f&lt;/code&gt; и &lt;code&gt;f!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="f23555229abe2136eae4796de9adb4981c0efa50" translate="yes" xml:space="preserve">
          <source>Any object that defines this function is iterable and can be used in the &lt;a href=&quot;../../base/collections/index#lib-collections-iteration-1&quot;&gt;many functions that rely upon iteration&lt;/a&gt;. It can also be used directly in a &lt;a href=&quot;../../base/base/index#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop since the syntax:</source>
          <target state="translated">Любой объект, определяющий эту функцию, является итеративным и может использоваться во &lt;a href=&quot;../../base/collections/index#lib-collections-iteration-1&quot;&gt;многих функциях, которые зависят от итерации&lt;/a&gt; . Его также можно использовать непосредственно в цикле &lt;a href=&quot;../../base/base/index#for&quot;&gt; &lt;code&gt;for&lt;/code&gt; ,&lt;/a&gt; поскольку синтаксис:</target>
        </trans-unit>
        <trans-unit id="14a4faaa9263f21666bc118177b8030fb0ebed4a" translate="yes" xml:space="preserve">
          <source>Any object that is not a type is not an instance of &lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="translated">Любой объект, не являющийся типом, не является экземпляром &lt;code&gt;Type&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5099776907c27052bfc78cf7373b0d68a21ec5f2" translate="yes" xml:space="preserve">
          <source>Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.</source>
          <target state="translated">Любая операция,которая приводит к ошибке,вероятно,в настоящее время не реализована и должна быть размещена как ошибка,чтобы ее можно было решить.</target>
        </trans-unit>
        <trans-unit id="f91c503ff4942107fdfd3a5ddc75b8099dc08779" translate="yes" xml:space="preserve">
          <source>Any process with a reference to a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; can put and take items from the channel. Data is automatically sent to (or retrieved from) the process a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; is associated with.</source>
          <target state="translated">Любой процесс со ссылкой на &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; может помещать и принимать элементы из канала. Данные автоматически отправляются (или извлекаются) процессу, с которым связан &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c010ba08796a2114052ab863fb8a9d226c9dd13" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Backslash Bar</source>
          <target state="translated">Функциональная символьная полоса обратной связи</target>
        </trans-unit>
        <trans-unit id="36d891e0ee22f437cc243dd2e9ea0702d961b80f" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Circle Stile</source>
          <target state="translated">Apl Функциональный символ Круглый пруток</target>
        </trans-unit>
        <trans-unit id="39c46b8ef7910ae74868b76b650aa07198ab578c" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol I-Beam</source>
          <target state="translated">Функциональный символ I-Beam</target>
        </trans-unit>
        <trans-unit id="d0546025dd10b13f2435dc3fcaee9e017037a2e5" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Quad Question</source>
          <target state="translated">Функциональное обозначение Четырехсторонний вопрос</target>
        </trans-unit>
        <trans-unit id="4d565c437bb750fa8a1eb8171844a8039a97d351" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Quad Up Caret</source>
          <target state="translated">Apl Функциональный символ Quad Up Caret</target>
        </trans-unit>
        <trans-unit id="2b164c5aca8328b895ebe3a8c42bb636c6e38b33" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Slash Bar</source>
          <target state="translated">Apl Функциональный символ косая черта</target>
        </trans-unit>
        <trans-unit id="259f6ae1ad06c26f4f50971a4ed64fd704fd9a77" translate="yes" xml:space="preserve">
          <source>Append &lt;code&gt;!&lt;/code&gt; to names of functions that modify their arguments</source>
          <target state="translated">Добавить &lt;code&gt;!&lt;/code&gt; к именам функций, которые изменяют свои аргументы</target>
        </trans-unit>
        <trans-unit id="93f34880658a83722dbec3227ce96d931d512e39" translate="yes" xml:space="preserve">
          <source>Append an item &lt;code&gt;v&lt;/code&gt; to the channel &lt;code&gt;c&lt;/code&gt;. Blocks if the channel is full.</source>
          <target state="translated">Добавьте элемент &lt;code&gt;v&lt;/code&gt; к каналу &lt;code&gt;c&lt;/code&gt; . Блокирует, если канал заполнен.</target>
        </trans-unit>
        <trans-unit id="b03f369e152e908d0c3e87c0759a78a3bbb83fd8" translate="yes" xml:space="preserve">
          <source>Applied to a function argument name, hints to the compiler that the method should not be specialized for different types of that argument, but instead to use precisely the declared type for each argument. This is only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument list, or in the function body. When applied to an argument, the macro must wrap the entire argument expression. When used in a function body, the macro must occur in statement position and before any code.</source>
          <target state="translated">Применительно к имени аргумента функции,подсказывает компилятору,что метод не должен быть специализированным для различных типов этого аргумента,а должен использовать точно объявленный тип для каждого аргумента.Это лишь подсказка,чтобы избежать избыточного генерирования кода.Может быть применен к аргументу в формальном списке аргументов или в теле функции.При применении к аргументу макрос должен обернуть выражение аргумента целиком.При использовании в теле функции макрос должен находиться в позиции оператора и перед любым кодом.</target>
        </trans-unit>
        <trans-unit id="8ab87eebb7a11b086ff8353783cc2be68600a9ff" translate="yes" xml:space="preserve">
          <source>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple &lt;code&gt;(filename,line)&lt;/code&gt; giving the location for the method that would be called for those arguments. It calls out to the &lt;code&gt;functionloc&lt;/code&gt; function.</source>
          <target state="translated">Применительно к вызову функции или макроса он оценивает аргументы для указанного вызова и возвращает кортеж &lt;code&gt;(filename,line)&lt;/code&gt; указывающий местоположение метода, который будет вызываться для этих аргументов. Он вызывает &lt;code&gt;functionloc&lt;/code&gt; functionloc.</target>
        </trans-unit>
        <trans-unit id="10b1d88dbbba24ca44bfc0cd98b524dd2c753624" translate="yes" xml:space="preserve">
          <source>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns the &lt;code&gt;Method&lt;/code&gt; object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the &lt;code&gt;which&lt;/code&gt; function.</source>
          <target state="translated">Применительно к вызову функции или макроса он оценивает аргументы указанного вызова и возвращает объект &lt;code&gt;Method&lt;/code&gt; для метода, который будет вызван для этих аргументов. Применительно к переменной он возвращает модуль, в котором была привязана переменная. Он вызывает функцию &lt;code&gt;which&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbb092978ae173971f51dbbabbad7be81b9e017d" translate="yes" xml:space="preserve">
          <source>Applies a function to the preceding argument. This allows for easy function chaining.</source>
          <target state="translated">Применяет функцию к предыдущему аргументу.Это позволяет легко связать функции.</target>
        </trans-unit>
        <trans-unit id="df9997f06ef19d21e85df7f2a8d3fde509d61f00" translate="yes" xml:space="preserve">
          <source>Apply function &lt;code&gt;f&lt;/code&gt; to each element(s) in &lt;code&gt;itrs&lt;/code&gt;, and then reduce the result using the binary function &lt;code&gt;op&lt;/code&gt;. If provided, &lt;code&gt;init&lt;/code&gt; must be a neutral element for &lt;code&gt;op&lt;/code&gt; that will be returned for empty collections. It is unspecified whether &lt;code&gt;init&lt;/code&gt; is used for non-empty collections. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">Примените функцию &lt;code&gt;f&lt;/code&gt; к каждому элементу (ам) в &lt;code&gt;itrs&lt;/code&gt; , а затем уменьшите результат, используя двоичную функцию &lt;code&gt;op&lt;/code&gt; . Если указано, &lt;code&gt;init&lt;/code&gt; должен быть нейтральным элементом для &lt;code&gt;op&lt;/code&gt; , который будет возвращен для пустых коллекций. Не указано, используется ли &lt;code&gt;init&lt;/code&gt; для непустых коллекций. В общем, нужно будет предоставить &lt;code&gt;init&lt;/code&gt; для работы с пустыми коллекциями.</target>
        </trans-unit>
        <trans-unit id="abde153c82249beeebbf8921343e0e5bfbfeae0c" translate="yes" xml:space="preserve">
          <source>Apply function &lt;code&gt;f&lt;/code&gt; to the git repository &lt;code&gt;repo&lt;/code&gt;, taking a &lt;a href=&quot;#LibGit2.snapshot&quot;&gt;&lt;code&gt;snapshot&lt;/code&gt;&lt;/a&gt; before applying &lt;code&gt;f&lt;/code&gt;. If an error occurs within &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;repo&lt;/code&gt; will be returned to its snapshot state using &lt;a href=&quot;#LibGit2.restore&quot;&gt;&lt;code&gt;restore&lt;/code&gt;&lt;/a&gt;. The error which occurred will be rethrown, but the state of &lt;code&gt;repo&lt;/code&gt; will not be corrupted.</source>
          <target state="translated">Применить функцию &lt;code&gt;f&lt;/code&gt; на мерзавца хранилище &lt;code&gt;repo&lt;/code&gt; , принимая &lt;a href=&quot;#LibGit2.snapshot&quot;&gt; &lt;code&gt;snapshot&lt;/code&gt; &lt;/a&gt; перед применением &lt;code&gt;f&lt;/code&gt; . Если в &lt;code&gt;f&lt;/code&gt; возникает ошибка , &lt;code&gt;repo&lt;/code&gt; будет возвращено в состояние моментального снимка с помощью &lt;a href=&quot;#LibGit2.restore&quot;&gt; &lt;code&gt;restore&lt;/code&gt; &lt;/a&gt; . Произошедшая ошибка будет воспроизведена повторно, но состояние &lt;code&gt;repo&lt;/code&gt; не будет нарушено.</target>
        </trans-unit>
        <trans-unit id="0f3a1ca726a424329c0ade2ec9d0c7202e4993c0" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to each element of collection &lt;code&gt;itr&lt;/code&gt; and take the mean.</source>
          <target state="translated">Примените функцию &lt;code&gt;f&lt;/code&gt; к каждому элементу коллекции &lt;code&gt;itr&lt;/code&gt; и возьмите среднее значение.</target>
        </trans-unit>
        <trans-unit id="3bc364f76459203bdb0d1fe7d66f3331843d77fb" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktemp(parent)&lt;/code&gt;&lt;/a&gt; and remove the temporary file upon completion.</source>
          <target state="translated">Примените функцию &lt;code&gt;f&lt;/code&gt; к результату &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktemp(parent)&lt;/code&gt; &lt;/a&gt; и удалите временный файл по завершении.</target>
        </trans-unit>
        <trans-unit id="5d833cb24f42c76580b0926f643d9e169ba73703" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt;&lt;/a&gt; and remove the temporary directory all of its contents upon completion.</source>
          <target state="translated">Примените функцию &lt;code&gt;f&lt;/code&gt; к результату &lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt; &lt;/a&gt; и удалите из временного каталога все его содержимое по завершении.</target>
        </trans-unit>
        <trans-unit id="c30fb3d590d21605851a7bb8d8b8ee272dad26bb" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;code&gt;open(args...; kwargs...)&lt;/code&gt; and close the resulting file descriptor upon completion.</source>
          <target state="translated">Примените функцию &lt;code&gt;f&lt;/code&gt; к результату &lt;code&gt;open(args...; kwargs...)&lt;/code&gt; и закройте получившийся дескриптор файла по завершении.</target>
        </trans-unit>
        <trans-unit id="47f0920b156c6fa088e0adafa06695882e8a1ce9" translate="yes" xml:space="preserve">
          <source>Applying it to any other types of arguments will result in a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Применение его к любым другим типам аргументов приведет к &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7fea34195bef9eda50f65dd470da25827c0b940a" translate="yes" xml:space="preserve">
          <source>Approaches The Limit</source>
          <target state="translated">Подходы к границе</target>
        </trans-unit>
        <trans-unit id="36af3f4430ffa874f1e260736d3734767175bb17" translate="yes" xml:space="preserve">
          <source>Approximate floating point number &lt;code&gt;x&lt;/code&gt; as a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; number with components of the given integer type. The result will differ from &lt;code&gt;x&lt;/code&gt; by no more than &lt;code&gt;tol&lt;/code&gt;.</source>
          <target state="translated">Приблизительное число &lt;code&gt;x&lt;/code&gt; с плавающей запятой как &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; число с компонентами заданного целочисленного типа. Результат будет отличаться от &lt;code&gt;x&lt;/code&gt; не более чем на &lt;code&gt;tol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86cdef7d39fe1e6ca08d22290dae380c71b22482" translate="yes" xml:space="preserve">
          <source>Approximately But Not Actually Equal To</source>
          <target state="translated">Приблизительно,но не равнозначно</target>
        </trans-unit>
        <trans-unit id="a398789ce28e88dc00a7a33731c788d8238f5ac2" translate="yes" xml:space="preserve">
          <source>Approximately Equal Or Equal To</source>
          <target state="translated">Приблизительно равный или равный</target>
        </trans-unit>
        <trans-unit id="110d059e67ed3348bbc8fc7fc9a8a4830c0240e6" translate="yes" xml:space="preserve">
          <source>Approximately Equal To</source>
          <target state="translated">Приблизительно равны</target>
        </trans-unit>
        <trans-unit id="9d91d063fbecc40e31adb06a0bdab3785430bae5" translate="yes" xml:space="preserve">
          <source>Approximately Equal To Or The Image Of</source>
          <target state="translated">Приблизительно равное или похожее на изображение</target>
        </trans-unit>
        <trans-unit id="3e026e6d2a8adcf8897cf07eecff80b0380f276d" translate="yes" xml:space="preserve">
          <source>Aquarius</source>
          <target state="translated">Aquarius</target>
        </trans-unit>
        <trans-unit id="d037d2935a703a621340fc357146d1188aae9fef" translate="yes" xml:space="preserve">
          <source>Arbitrary Precision Arithmetic</source>
          <target state="translated">Арифметика произвольной точности</target>
        </trans-unit>
        <trans-unit id="ec0bee1bcca32dcc4d82f1af9b35b9a4e833d243" translate="yes" xml:space="preserve">
          <source>Arbitrary precision floating point number type.</source>
          <target state="translated">Тип числа с плавающей точкой произвольной точности.</target>
        </trans-unit>
        <trans-unit id="f38bd661446c82eb63be7e7f1e9af6fa5a6cfaaa" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integer type.</source>
          <target state="translated">Целый тип произвольной точности.</target>
        </trans-unit>
        <trans-unit id="853a983f6b8abdb9ecba43da2ceda1641c9d519f" translate="yes" xml:space="preserve">
          <source>Arc</source>
          <target state="translated">Arc</target>
        </trans-unit>
        <trans-unit id="dbf6ae45c2a646ca9f7ecaf4480259128f85d936" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;waitfor&lt;/code&gt; specifies how long to wait for the workers to shut down:</source>
          <target state="translated">Аргумент &lt;code&gt;waitfor&lt;/code&gt; указывает, как долго ждать завершения рабочих процессов :</target>
        </trans-unit>
        <trans-unit id="0d26bcd474b23ab47569a6a1a0ca62a2c9eb9205" translate="yes" xml:space="preserve">
          <source>Argument Passing Behavior</source>
          <target state="translated">Поведение при проходе через памятники</target>
        </trans-unit>
        <trans-unit id="938cc4ebe6a5288bbfb1485b585ece93ff21a6fc" translate="yes" xml:space="preserve">
          <source>Argument destructuring</source>
          <target state="translated">Разрушение памятников</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="ccfbfffe30467d0556e9822f3a3009bcd6857e77" translate="yes" xml:space="preserve">
          <source>Arguments to be passed to the LLVM backend.</source>
          <target state="translated">Аргументы будут переданы в LLVM бэкэнд.</target>
        </trans-unit>
        <trans-unit id="f480e0686764de02407b1abe1545f3d34ae95935" translate="yes" xml:space="preserve">
          <source>Aries</source>
          <target state="translated">Aries</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">арифметические операторы</target>
        </trans-unit>
        <trans-unit id="6ba961184ebd546b1a3177abda88c03934fb089a" translate="yes" xml:space="preserve">
          <source>Arithmetic on the &lt;code&gt;Ptr&lt;/code&gt; type in Julia (e.g. using &lt;code&gt;+&lt;/code&gt;) does not behave the same as C's pointer arithmetic. Adding an integer to a &lt;code&gt;Ptr&lt;/code&gt; in Julia always moves the pointer by some number of &lt;em&gt;bytes&lt;/em&gt;, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.</source>
          <target state="translated">Арифметика над типом &lt;code&gt;Ptr&lt;/code&gt; в Julia (например, с использованием &lt;code&gt;+&lt;/code&gt; ) не ведет себя так же, как арифметика указателя C. Добавление целого числа к &lt;code&gt;Ptr&lt;/code&gt; в Julia всегда перемещает указатель на некоторое количество &lt;em&gt;байтов&lt;/em&gt; , а не элементов. Таким образом, значения адреса, полученные из арифметики указателей, не зависят от типов элементов указателей.</target>
        </trans-unit>
        <trans-unit id="1595977488274506444762a7d4b561a282b06666" translate="yes" xml:space="preserve">
          <source>Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse matrices work in the same way as dense matrices. Indexing operations, especially assignment, are expensive, when carried out one element at a time. In many cases it may be better to convert the sparse matrix into &lt;code&gt;(I,J,V)&lt;/code&gt; format using &lt;a href=&quot;#SparseArrays.findnz&quot;&gt;&lt;code&gt;findnz&lt;/code&gt;&lt;/a&gt;, manipulate the values or the structure in the dense vectors &lt;code&gt;(I,J,V)&lt;/code&gt;, and then reconstruct the sparse matrix.</source>
          <target state="translated">Арифметические операции с разреженными матрицами также работают так же, как и с плотными матрицами. Индексирование, присвоение и объединение разреженных матриц работают так же, как и плотные матрицы. Операции индексирования, особенно присваивание, являются дорогостоящими, когда выполняются по одному элементу за раз. Во многих случаях может быть лучше преобразовать разреженную матрицу в формат &lt;code&gt;(I,J,V)&lt;/code&gt; с помощью &lt;a href=&quot;#SparseArrays.findnz&quot;&gt; &lt;code&gt;findnz&lt;/code&gt; &lt;/a&gt; , манипулировать значениями или структурой в плотных векторах &lt;code&gt;(I,J,V)&lt;/code&gt; , а затем восстановить разреженную матрицу.</target>
        </trans-unit>
        <trans-unit id="6b6663a1569cf067a646e962adc2c809327f2a1d" translate="yes" xml:space="preserve">
          <source>Array and Vectorized Operators and Functions</source>
          <target state="translated">Массив и векторизованные операторы и функции</target>
        </trans-unit>
        <trans-unit id="272896e88f7076a29401b63fcba504c622f100cf" translate="yes" xml:space="preserve">
          <source>Array functions</source>
          <target state="translated">Функции массива</target>
        </trans-unit>
        <trans-unit id="ec6e2a8a6e3331d091fde070355048d6a50fbdb0" translate="yes" xml:space="preserve">
          <source>Array traits</source>
          <target state="translated">Черты массива</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="a0d486c491afc0a11a53591657e1748ec0e15c70" translate="yes" xml:space="preserve">
          <source>Arrays With Missing Values</source>
          <target state="translated">Массивы с отсутствующими значениями</target>
        </trans-unit>
        <trans-unit id="14eed9a557bdf809c1d72ce7ef06aab3ac832f66" translate="yes" xml:space="preserve">
          <source>Arrays allowing for missing values can be constructed with the standard syntax. Use &lt;code&gt;Array{Union{Missing, T}}(missing, dims)&lt;/code&gt; to create arrays filled with missing values:</source>
          <target state="translated">Массивы с пропущенными значениями могут быть построены с использованием стандартного синтаксиса. Используйте &lt;code&gt;Array{Union{Missing, T}}(missing, dims)&lt;/code&gt; для создания массивов, заполненных отсутствующими значениями:</target>
        </trans-unit>
        <trans-unit id="d5a5bd6d399fb4d5330301010e8df836c12ff36c" translate="yes" xml:space="preserve">
          <source>Arrays are stored contiguously in memory, lending themselves to CPU vectorization and fewer memory accesses due to caching. These are the same reasons that it is recommended to access arrays in column-major order (see above). Irregular access patterns and non-contiguous views can drastically slow down computations on arrays because of non-sequential memory access.</source>
          <target state="translated">Массивы непрерывно хранятся в памяти,что позволяет использовать векторизацию процессора и уменьшает доступ к памяти за счет кэширования.По этим же причинам рекомендуется обращаться к массивам в порядке столбцов (см.выше).Нерегулярные схемы доступа и несмежные представления могут резко замедлить вычисления в массивах из-за непоследовательного доступа к памяти.</target>
        </trans-unit>
        <trans-unit id="804cb53914986dde77e394241b65af0a2493a576" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed and also concatenated using the following functions:</source>
          <target state="translated">Массивы могут быть построены,а также объединены с помощью следующих функций:</target>
        </trans-unit>
        <trans-unit id="9a14bfc250b9401c09f27dc8758fb64c6d1849ec" translate="yes" xml:space="preserve">
          <source>Arrays can easily be sorted according to an arbitrary transformation of their values:</source>
          <target state="translated">Массивы легко сортируются в соответствии с произвольным преобразованием их значений:</target>
        </trans-unit>
        <trans-unit id="aa747a7d1d6f608a0335baa21f343f3341f91936" translate="yes" xml:space="preserve">
          <source>Arrays containing missing values can be created like other arrays</source>
          <target state="translated">Массивы,содержащие пропущенные значения,могут быть созданы,как и другие массивы</target>
        </trans-unit>
        <trans-unit id="ca4d2abddb6904030658a8e61f4450fbbd938fdf" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;CartesianIndex{N}&lt;/code&gt; (see below for more details)</source>
          <target state="translated">Массивы &lt;code&gt;CartesianIndex{N}&lt;/code&gt; (подробнее см. Ниже)</target>
        </trans-unit>
        <trans-unit id="075c9f606a29f390bc16b51c28be22f3d814f931" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;CartesianIndex{N}&lt;/code&gt; are also supported. They represent a collection of scalar indices that each span &lt;code&gt;N&lt;/code&gt; dimensions, enabling a form of indexing that is sometimes referred to as pointwise indexing. For example, it enables accessing the diagonal elements from the first &quot;page&quot; of &lt;code&gt;A&lt;/code&gt; from above:</source>
          <target state="translated">Также поддерживаются массивы &lt;code&gt;CartesianIndex{N}&lt;/code&gt; . Они представляют собой набор скалярных индексов, каждый из которых охватывает &lt;code&gt;N&lt;/code&gt; измерений, что позволяет использовать форму индексации, которую иногда называют точечной индексацией. Например, он позволяет получить доступ к диагональным элементам с первой &amp;laquo;страницы&amp;raquo; &lt;code&gt;A&lt;/code&gt; сверху:</target>
        </trans-unit>
        <trans-unit id="3d6407685d9a3a1c2957e4566ba6f78f8b15e030" translate="yes" xml:space="preserve">
          <source>Arrays of booleans, which select elements at their &lt;code&gt;true&lt;/code&gt; indices (see below for more details)</source>
          <target state="translated">Массивы логических значений, которые выбирают элементы по их &lt;code&gt;true&lt;/code&gt; индексам (подробнее см. Ниже)</target>
        </trans-unit>
        <trans-unit id="0969583730964394602b74ac92dacfa507bac99b" translate="yes" xml:space="preserve">
          <source>Arrays of parameters can be expressed with &lt;code&gt;NTuple&lt;/code&gt;:</source>
          <target state="translated">Массивы параметров можно выразить с помощью &lt;code&gt;NTuple&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7c5854ca021fe589728b87432b4e259d1c8248d3" translate="yes" xml:space="preserve">
          <source>Arrays of plain data types exhibit the same behavior.</source>
          <target state="translated">Массивы простых типов данных демонстрируют одинаковое поведение.</target>
        </trans-unit>
        <trans-unit id="6f655e915f910f157fee32ed03ecdc2ad3b9d1df" translate="yes" xml:space="preserve">
          <source>Arrays of unknown size (C99-compliant variable length structs specified by &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;[0]&lt;/code&gt;) are not directly supported. Often the best way to deal with these is to deal with the byte offsets directly. For example, if a C library declared a proper string type and returned a pointer to it:</source>
          <target state="translated">Массивы неизвестного размера (совместимые с C99 структуры переменной длины, указанные в &lt;code&gt;[]&lt;/code&gt; или &lt;code&gt;[0]&lt;/code&gt; ) напрямую не поддерживаются. Часто лучший способ справиться с этим - напрямую работать с байтовыми смещениями. Например, если библиотека C объявила правильный строковый тип и вернула на него указатель:</target>
        </trans-unit>
        <trans-unit id="0a4fe1e9982ed026b7b75e0b6640d07c49b347a1" translate="yes" xml:space="preserve">
          <source>Arrow Pointing Rightwards Then Curving Downwards</source>
          <target state="translated">Стрелка,направленная вправо,затем кривая вниз.</target>
        </trans-unit>
        <trans-unit id="d5a8479391be26e8e773c26793b7bf6d542adbb0" translate="yes" xml:space="preserve">
          <source>Arrow Pointing Rightwards Then Curving Upwards</source>
          <target state="translated">Стрелка,направленная вправо,затем кривая вверх.</target>
        </trans-unit>
        <trans-unit id="56cbb3f16cd1ca93b5689f5cddec6758302ebb86" translate="yes" xml:space="preserve">
          <source>Arthur C. Clarke, &lt;em&gt;Profiles of the Future&lt;/em&gt; (1961): Clarke's Third Law.</source>
          <target state="translated">Артур Кларк, &lt;em&gt;Профили будущего&lt;/em&gt; (1961): Третий закон Кларка.</target>
        </trans-unit>
        <trans-unit id="4be4b541c7c3be1117af5726c8607678780b96ca" translate="yes" xml:space="preserve">
          <source>Articulated Lorry</source>
          <target state="translated">Грузовой автомобиль с шарнирным соединением</target>
        </trans-unit>
        <trans-unit id="b1aa57e2147913434d8d33e99a2a302c3d412560" translate="yes" xml:space="preserve">
          <source>Artist Palette</source>
          <target state="translated">Художественная палитра</target>
        </trans-unit>
        <trans-unit id="b2b55172c20f3a3018d935f94f15f420d19dd799" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;missing&lt;/code&gt; is a normal Julia object, this propagation rule only works for functions which have opted in to implement this behavior. This can be achieved either via a specific method defined for arguments of type &lt;code&gt;Missing&lt;/code&gt;, or simply by accepting arguments of this type, and passing them to functions which propagate them (like standard operators). Packages should consider whether it makes sense to propagate missing values when defining new functions, and define methods appropriately if that is the case. Passing a &lt;code&gt;missing&lt;/code&gt; value to a function for which no method accepting arguments of type &lt;code&gt;Missing&lt;/code&gt; is defined throws a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;, just like for any other type.</source>
          <target state="translated">Поскольку &lt;code&gt;missing&lt;/code&gt; обычный объект Julia, это правило распространения работает только для функций, которые выбрали реализацию этого поведения. Это может быть достигнуто либо с помощью специального метода, определенного для аргументов типа &lt;code&gt;Missing&lt;/code&gt; , либо просто путем принятия аргументов этого типа и передачи их функциям, которые их передают (например, стандартные операторы). Пакеты должны учитывать, имеет ли смысл распространять отсутствующие значения при определении новых функций, и соответствующим образом определять методы, если это так. Передача &lt;code&gt;missing&lt;/code&gt; значения функции, для которой не определен метод, принимающий аргументы типа &lt;code&gt;Missing&lt;/code&gt; , вызывает &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; , как и для любого другого типа.</target>
        </trans-unit>
        <trans-unit id="6c7f12d083082a8b358b33648f5e922218bf6328" translate="yes" xml:space="preserve">
          <source>As Julia &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; values are represented according to the ISO 8601 standard, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; was chosen as base (or &quot;rounding epoch&quot;) from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this differs slightly from Julia's internal representation of &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; s using Rata Die notation; but since the ISO 8601 standard is most visible to the end user, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; was chosen as the rounding epoch instead of the &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; used internally to minimize confusion.)</source>
          <target state="translated">Поскольку значения Julia &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; представлены в соответствии со стандартом ISO 8601, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; было выбрано в качестве базы (или &amp;laquo;эпохи округления&amp;raquo;), с которой начинается отсчет дней (и миллисекунд), используемых при округлении. расчеты. (Обратите внимание, что это немного отличается от внутреннего представления Джулии &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; s с использованием нотации Rata Die; но поскольку стандарт ISO 8601 наиболее заметен для конечного пользователя, в качестве эпохи округления был выбран &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; используется внутри, чтобы минимизировать путаницу.)</target>
        </trans-unit>
        <trans-unit id="018f199ee4bce38a37225bf7cf902f1a94cfebe8" translate="yes" xml:space="preserve">
          <source>As a bonus, all period arithmetic objects work directly with ranges:</source>
          <target state="translated">В качестве бонуса,арифметические объекты всех периодов работают непосредственно с диапазонами:</target>
        </trans-unit>
        <trans-unit id="25d0293122d46f12e2772f00b98fe234a30f7099" translate="yes" xml:space="preserve">
          <source>As a complete but simple example, the following calls the &lt;code&gt;clock&lt;/code&gt; function from the standard C library:</source>
          <target state="translated">В качестве полного, но простого примера ниже приведем &lt;code&gt;clock&lt;/code&gt; функции часов из стандартной библиотеки C:</target>
        </trans-unit>
        <trans-unit id="539ad19d9070448cc3bfdfe89f4f38e027fe5c6c" translate="yes" xml:space="preserve">
          <source>As a convenience, constructing a &lt;code&gt;CartesianIndices&lt;/code&gt; from an array makes a range of its indices.</source>
          <target state="translated">Для удобства при построении &lt;code&gt;CartesianIndices&lt;/code&gt; из массива создается диапазон его индексов.</target>
        </trans-unit>
        <trans-unit id="0b5625230c61073f2e6e2ee043f6240a0a3c7016" translate="yes" xml:space="preserve">
          <source>As a general rule, the Base library uses the following order of arguments to functions, as applicable:</source>
          <target state="translated">Как правило,библиотека Base использует следующий порядок аргументов к функциям,если это применимо:</target>
        </trans-unit>
        <trans-unit id="876317f2ed373be8c206ea71cf8b7c051cb11062" translate="yes" xml:space="preserve">
          <source>As a more complicated example, let's define our own toy N-dimensional sparse-like array type built on top of &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">В качестве более сложного примера давайте определим наш собственный игрушечный N-мерный разреженный тип массива, построенный на основе &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e8594cf6335bb7f066fe658c47ad7b64d5f8a844" translate="yes" xml:space="preserve">
          <source>As a more extended and complex example, consider running the following &quot;kernel&quot; in parallel:</source>
          <target state="translated">В качестве более расширенного и сложного примера рассмотрим параллельный запуск следующего &quot;ядра&quot;:</target>
        </trans-unit>
        <trans-unit id="2067a667a08ddb9964ef86bab532db4e31b7d596" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, the single-line &lt;code&gt;show&lt;/code&gt; method should print a valid Julia expression for creating the shown object. When this &lt;code&gt;show&lt;/code&gt; method contains infix operators, such as the multiplication operator (&lt;code&gt;*&lt;/code&gt;) in our single-line &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;Polar&lt;/code&gt; above, it may not parse correctly when printed as part of another object. To see this, consider the expression object (see &lt;a href=&quot;../metaprogramming/index#Program-representation-1&quot;&gt;Program representation&lt;/a&gt;) which takes the square of a specific instance of our &lt;code&gt;Polar&lt;/code&gt; type:</source>
          <target state="translated">Как показывает практика, однострочный метод &lt;code&gt;show&lt;/code&gt; должен печатать допустимое выражение Julia для создания показанного объекта. Когда этот метод &lt;code&gt;show&lt;/code&gt; содержит инфиксные операторы, такие как оператор умножения ( &lt;code&gt;*&lt;/code&gt; ) в нашем однострочном методе &lt;code&gt;show&lt;/code&gt; для &lt;code&gt;Polar&lt;/code&gt; выше, он может некорректно анализироваться при печати как часть другого объекта. Чтобы увидеть это, рассмотрим объект выражения (см. &lt;a href=&quot;../metaprogramming/index#Program-representation-1&quot;&gt;Представление программы&lt;/a&gt; ), который принимает квадрат определенного экземпляра нашего &lt;code&gt;Polar&lt;/code&gt; типа:</target>
        </trans-unit>
        <trans-unit id="37e79152e5cc53d02dd6543f1f031bc76326d65b" translate="yes" xml:space="preserve">
          <source>As a special case, all names defined in &lt;code&gt;Main&lt;/code&gt; are considered &quot;exported&quot;, since it is not idiomatic to explicitly export names from &lt;code&gt;Main&lt;/code&gt;.</source>
          <target state="translated">В особом случае все имена, определенные в &lt;code&gt;Main&lt;/code&gt; , считаются &amp;laquo;экспортированными&amp;raquo;, поскольку явный экспорт имен из &lt;code&gt;Main&lt;/code&gt; не является идиоматическим .</target>
        </trans-unit>
        <trans-unit id="6ead86dd43c44d522a7884aedc1fd88eb5becf75" translate="yes" xml:space="preserve">
          <source>As a special case, functions can only be actually deep-copied if they are anonymous, otherwise they are just copied. The difference is only relevant in the case of closures, i.e. functions which may contain hidden internal references.</source>
          <target state="translated">В особом случае функции могут быть фактически глубоко скопированы только при условии их анонимности,в противном случае они просто копируются.Различие имеет значение только в случае закрытия,т.е.функций,которые могут содержать скрытые внутренние ссылки.</target>
        </trans-unit>
        <trans-unit id="d76af4d473b8d2d40c642b61a1fbe0edf6927389" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;AbstractString&lt;/code&gt; (for textual MIME types) or a &lt;code&gt;Vector{UInt8}&lt;/code&gt; (for binary MIME types), the &lt;code&gt;repr&lt;/code&gt; function assumes that &lt;code&gt;x&lt;/code&gt; is already in the requested &lt;code&gt;mime&lt;/code&gt; format and simply returns &lt;code&gt;x&lt;/code&gt;. This special case does not apply to the &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; MIME type. This is useful so that raw data can be passed to &lt;code&gt;display(m::MIME, x)&lt;/code&gt;.</source>
          <target state="translated">В качестве особого случая, если &lt;code&gt;x&lt;/code&gt; является &lt;code&gt;AbstractString&lt;/code&gt; (для текстовых типов MIME) или &lt;code&gt;Vector{UInt8}&lt;/code&gt; (для двоичных типов MIME), функция &lt;code&gt;repr&lt;/code&gt; предполагает, что &lt;code&gt;x&lt;/code&gt; уже находится в запрошенном формате &lt;code&gt;mime&lt;/code&gt; , и просто возвращает &lt;code&gt;x&lt;/code&gt; . Этот особый случай не применяется к типу MIME &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; . Это полезно для того, чтобы необработанные данные можно было передавать на &lt;code&gt;display(m::MIME, x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62d11f9f9e158c0b2c2708640ce2ac613943fd82" translate="yes" xml:space="preserve">
          <source>As a special part of this syntax, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the innermost array being indexed. Indexing syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">В качестве специальной части этого синтаксиса ключевое слово &lt;code&gt;end&lt;/code&gt; может использоваться для представления последнего индекса каждого измерения в скобках индексации, как это определяется размером самого внутреннего индексируемого массива. Синтаксис индексации без ключевого слова &lt;code&gt;end&lt;/code&gt; эквивалентен вызову &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5535efde9a5741aaf5f5e686571434213ecef6c2" translate="yes" xml:space="preserve">
          <source>As already elaborated in &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;The Julia REPL&lt;/a&gt;, Julia's REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.</source>
          <target state="translated">Как уже говорилось в &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;Julia REPL&lt;/a&gt; , Julia REPL предоставляет богатую функциональность, которая облегчает эффективный интерактивный рабочий процесс. Вот несколько советов, которые могут еще больше улучшить вашу работу с командной строкой.</target>
        </trans-unit>
        <trans-unit id="06e64cdbccd93a2d388ef16dd274049eaf25b515" translate="yes" xml:space="preserve">
          <source>As an alternative for very simple cases, it is possible to just create a global container of type &lt;code&gt;Vector{Any}&lt;/code&gt; and fetch the elements from that when necessary, or even to create one global variable per pointer using</source>
          <target state="translated">В качестве альтернативы для очень простых случаев можно просто создать глобальный контейнер типа &lt;code&gt;Vector{Any}&lt;/code&gt; и при необходимости извлекать из него элементы или даже создать одну глобальную переменную для каждого указателя, используя</target>
        </trans-unit>
        <trans-unit id="d6c52d7f67846f1ec223096b1fa72569e5539d74" translate="yes" xml:space="preserve">
          <source>As an assertion to help confirm that your program works the way you expect,</source>
          <target state="translated">В качестве подтверждения того,что ваша программа работает так,как вы ожидаете,</target>
        </trans-unit>
        <trans-unit id="18c9d397fe2fae6bb521c88b045f04eec75021c6" translate="yes" xml:space="preserve">
          <source>As an example let us see how the &lt;code&gt;LocalManager&lt;/code&gt;, the manager responsible for starting workers on the same host, is implemented:</source>
          <target state="translated">В качестве примера давайте посмотрим, как &lt;code&gt;LocalManager&lt;/code&gt; , менеджер, ответственный за запуск воркеров на одном и том же хосте:</target>
        </trans-unit>
        <trans-unit id="5ea2f3f22affe5b0503e1b98807df2e143d66e8a" translate="yes" xml:space="preserve">
          <source>As an example of a non-TCP/IP transport, an implementation may choose to use MPI, in which case &lt;code&gt;--worker&lt;/code&gt; must NOT be specified. Instead, newly launched workers should call &lt;code&gt;init_worker(cookie)&lt;/code&gt; before using any of the parallel constructs.</source>
          <target state="translated">В качестве примера транспорта, отличного от TCP / IP, реализация может выбрать использование MPI, и в этом случае НЕ следует &lt;code&gt;--worker&lt;/code&gt; . Вместо этого вновь запущенные рабочие &lt;code&gt;init_worker(cookie)&lt;/code&gt; должны вызывать init_worker (cookie) перед использованием любой из параллельных конструкций.</target>
        </trans-unit>
        <trans-unit id="8d94b4e364183ef3f6a858e77d060fb33ee15b1a" translate="yes" xml:space="preserve">
          <source>As an example, suppose a package directory has the following structure and content:</source>
          <target state="translated">В качестве примера предположим,что каталог пакетов имеет следующую структуру и содержание:</target>
        </trans-unit>
        <trans-unit id="1237948f9e574bfd646187c2b196cb56c33c770b" translate="yes" xml:space="preserve">
          <source>As an example, suppose you wanted to define multiplication on symbols in a module:</source>
          <target state="translated">В качестве примера предположим,что вы хотели определить умножение на символах в модуле:</target>
        </trans-unit>
        <trans-unit id="59a193ac31c3261e6bf490ce9642a1cb05737a81" translate="yes" xml:space="preserve">
          <source>As an example, the builtin &lt;code&gt;AbstractRange&lt;/code&gt; objects use this machinery to optimize pieces of broadcasted expressions that can be eagerly evaluated purely in terms of the start, step, and length (or stop) instead of computing every single element. Just like all the other machinery, &lt;code&gt;broadcasted&lt;/code&gt; also computes and exposes the combined broadcast style of its arguments, so instead of specializing on &lt;code&gt;broadcasted(f, args...)&lt;/code&gt;, you can specialize on &lt;code&gt;broadcasted(::DestStyle, f, args...)&lt;/code&gt; for any combination of style, function, and arguments.</source>
          <target state="translated">В качестве примера, встроенные объекты &lt;code&gt;AbstractRange&lt;/code&gt; используют этот механизм для оптимизации частей транслируемых выражений, которые могут быть быстро оценены исключительно с точки зрения начала, шага и длины (или остановки) вместо вычисления каждого отдельного элемента. Как и все другие механизмы, &lt;code&gt;broadcasted&lt;/code&gt; также вычисляет и предоставляет объединенный стиль широковещания своих аргументов, поэтому вместо специализации на &lt;code&gt;broadcasted(f, args...)&lt;/code&gt; вы можете специализироваться на &lt;code&gt;broadcasted(::DestStyle, f, args...)&lt;/code&gt; для любой комбинации стиля, функции и аргументов.</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">В качестве примера:</target>
        </trans-unit>
        <trans-unit id="87ed434d0000a98d4576d846e0e095b93bb4582f" translate="yes" xml:space="preserve">
          <source>As an extension of this, in cases where the algorithm needs a copy of the input array, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; is insufficient as the return value may alias the original input. Combining &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; (to make the output array) and &lt;a href=&quot;../../base/c/index#Base.copyto!&quot;&gt;&lt;code&gt;copyto!&lt;/code&gt;&lt;/a&gt; (to fill it with the input data) is a generic way to express the requirement for a mutable copy of the input argument:</source>
          <target state="translated">В дополнение к этому, в случаях, когда алгоритму требуется копия входного массива, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; недостаточно, поскольку возвращаемое значение может быть псевдонимом исходного входного. Комбинируя &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt; (чтобы &lt;a href=&quot;../../base/c/index#Base.copyto!&quot;&gt; &lt;code&gt;copyto!&lt;/code&gt; &lt;/a&gt; выходной массив) и copyto! (чтобы заполнить его входными данными) - это общий способ выразить потребность в изменяемой копии входного аргумента:</target>
        </trans-unit>
        <trans-unit id="f8ea3b19e7de523c7e9925d469ae1f1489b7d884" translate="yes" xml:space="preserve">
          <source>As another example, here is a function that doubles any numeric argument, but leaves expressions alone:</source>
          <target state="translated">В качестве другого примера можно привести функцию,которая удваивает любой числовой аргумент,но оставляет выражения в покое:</target>
        </trans-unit>
        <trans-unit id="5a98ec0590a6653411278e5178b7dfd6cf089ca2" translate="yes" xml:space="preserve">
          <source>As calculations on floating-point values can be imprecise, you can perform approximate equality checks using either &lt;code&gt;@test a &amp;asymp; b&lt;/code&gt; (where &lt;code&gt;&amp;asymp;&lt;/code&gt;, typed via tab completion of &lt;code&gt;\approx&lt;/code&gt;, is the &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt; function) or use &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">Поскольку вычисления значений с плавающей запятой могут быть неточными, вы можете выполнить приблизительную проверку равенства, используя либо &lt;code&gt;@test a &amp;asymp; b&lt;/code&gt; (где &lt;code&gt;&amp;asymp;&lt;/code&gt; , набранный с помощью дополнения табуляции &lt;code&gt;\approx&lt;/code&gt; , это функция &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; &lt;/a&gt; ), либо напрямую использовать &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="671cfcc401170439c76fc45750de84c7f63c05ee" translate="yes" xml:space="preserve">
          <source>As can be seen once again, a remote call onto the local node behaves just like a direct invocation. The call modifies local objects passed as arguments. In the remote invocation, it operates on a copy of the arguments.</source>
          <target state="translated">Как видно еще раз,удаленный вызов на локальный узел ведет себя так же,как и прямой вызов.Вызов изменяет локальные объекты,передаваемые в качестве аргументов.При удаленном вызове он работает на копии аргументов.</target>
        </trans-unit>
        <trans-unit id="3cc0d715da9528bac336fc93fd62b1b74187bec5" translate="yes" xml:space="preserve">
          <source>As can be seen, &lt;code&gt;A&lt;/code&gt; is changed to the sorted array &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt;. Note that Julia knows how to convert an array into a &lt;code&gt;Ptr{Cdouble}&lt;/code&gt;, how to compute the size of a type in bytes (identical to C's &lt;code&gt;sizeof&lt;/code&gt; operator), and so on. For fun, try inserting a &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; line into &lt;code&gt;mycompare&lt;/code&gt;, which will allow you to see the comparisons that &lt;code&gt;qsort&lt;/code&gt; is performing (and to verify that it is really calling the Julia function that you passed to it).</source>
          <target state="translated">Как видно, &lt;code&gt;A&lt;/code&gt; заменяется на отсортированный массив &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt; . Обратите внимание, что Джулия знает, как преобразовать массив в &lt;code&gt;Ptr{Cdouble}&lt;/code&gt; , как вычислить размер типа в байтах (идентично оператору &lt;code&gt;sizeof&lt;/code&gt; в языке C ) и так далее. Для удовольствия попробуйте вставить &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; в &lt;code&gt;mycompare&lt;/code&gt; , что позволит вам увидеть сравнения, выполняемые &lt;code&gt;qsort&lt;/code&gt; (и убедиться, что он действительно вызывает функцию Julia, которую вы передали к нему).</target>
        </trans-unit>
        <trans-unit id="4b96915d6aea30f8cc88503d183daf83b43b1570" translate="yes" xml:space="preserve">
          <source>As can be seen, &lt;code&gt;put!&lt;/code&gt; on a locally owned &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; with the same object &lt;code&gt;v&lt;/code&gt; modifed between calls results in the same single object instance stored. As opposed to copies of &lt;code&gt;v&lt;/code&gt; being created when the node owning &lt;code&gt;rc&lt;/code&gt; is a different node.</source>
          <target state="translated">Как видно &lt;code&gt;put!&lt;/code&gt; на локальном &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; с одним и тем же объектом &lt;code&gt;v&lt;/code&gt; , измененным между вызовами, приводит к сохранению одного и того же единственного экземпляра объекта. В отличие от копий &lt;code&gt;v&lt;/code&gt; , создаваемых, когда узел, владеющий &lt;code&gt;rc&lt;/code&gt; , является другим узлом.</target>
        </trans-unit>
        <trans-unit id="e253ba428da9355b11a09e17058388a067c23f87" translate="yes" xml:space="preserve">
          <source>As can be seen, global variable &lt;code&gt;A&lt;/code&gt; is defined on worker 2, but &lt;code&gt;B&lt;/code&gt; is captured as a local variable and hence a binding for &lt;code&gt;B&lt;/code&gt; does not exist on worker 2.</source>
          <target state="translated">Как видно, глобальная переменная &lt;code&gt;A&lt;/code&gt; определена на рабочем 2, но &lt;code&gt;B&lt;/code&gt; фиксируется как локальная переменная, и, следовательно, привязка для &lt;code&gt;B&lt;/code&gt; не существует на рабочем 2.</target>
        </trans-unit>
        <trans-unit id="76f93ab509f4540b19db8475dd078bd3d9ad56c4" translate="yes" xml:space="preserve">
          <source>As convenient as date-period arithmetic is, often the kinds of calculations needed on dates take on a &lt;em&gt;calendrical&lt;/em&gt; or &lt;em&gt;temporal&lt;/em&gt; nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as &quot;Memorial Day = Last Monday of May&quot;, or &quot;Thanksgiving = 4th Thursday of November&quot;. These kinds of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.</source>
          <target state="translated">Какой бы удобной ни была арифметика даты и периода, часто необходимые для дат вычисления имеют &lt;em&gt;календарный&lt;/em&gt; или &lt;em&gt;временной&lt;/em&gt; характер, а не фиксированное количество периодов. Праздники - прекрасный тому пример; большинство из них следуют таким правилам, как &amp;laquo;День памяти = последний понедельник мая&amp;raquo; или &amp;laquo;День благодарения = 4-й четверг ноября&amp;raquo;. Такие временные выражения имеют дело с правилами, относящимися к календарю, например, первое или последнее число месяца, следующий вторник, первая и третья среды и т. Д.</target>
        </trans-unit>
        <trans-unit id="a1c026427d4e0f63d2dc15ae37577d2f94eafa8a" translate="yes" xml:space="preserve">
          <source>As expected we saw &quot;Hello World&quot; printed. So, let's actually analyze what happened behind the scenes. When we called &lt;code&gt;connect&lt;/code&gt;, we connect to the server we had just created. Meanwhile, the accept function returns a server-side connection to the newly created socket and prints &quot;Hello World&quot; to indicate that the connection was successful.</source>
          <target state="translated">Как и ожидалось, мы увидели напечатанное &amp;laquo;Hello World&amp;raquo;. Итак, давайте собственно проанализируем, что происходило за кулисами. Когда мы вызывали &lt;code&gt;connect&lt;/code&gt; , мы подключаемся к только что созданному серверу. Между тем, функция accept возвращает соединение на стороне сервера для вновь созданного сокета и печатает &amp;laquo;Hello World&amp;raquo;, чтобы указать, что соединение было успешным.</target>
        </trans-unit>
        <trans-unit id="2bb0a271b40c54ec6b4884cb957952b84f3d4f5b" translate="yes" xml:space="preserve">
          <source>As for &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;SparseVector&lt;/code&gt; type can also contain explicitly stored zeros. (See &lt;a href=&quot;#man-csc-1&quot;&gt;Sparse Matrix Storage&lt;/a&gt;.).</source>
          <target state="translated">Что касается &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC&lt;/code&gt; &lt;/a&gt; , тип &lt;code&gt;SparseVector&lt;/code&gt; также может содержать явно сохраненные нули. (См. &lt;a href=&quot;#man-csc-1&quot;&gt;Разреженное матричное хранилище&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="fc146c2940c0c078ab8141567616fc6c9d0de40c" translate="yes" xml:space="preserve">
          <source>As for hexadecimal literals, binary and octal literals produce unsigned integer types. The size of the binary data item is the minimal needed size, if the leading digit of the literal is not &lt;code&gt;0&lt;/code&gt;. In the case of leading zeros, the size is determined by the minimal needed size for a literal, which has the same length but leading digit &lt;code&gt;1&lt;/code&gt;. That allows the user to control the size. Values which cannot be stored in &lt;code&gt;UInt128&lt;/code&gt; cannot be written as such literals.</source>
          <target state="translated">Что касается шестнадцатеричных литералов, двоичные и восьмеричные литералы создают беззнаковые целочисленные типы. Размер элемента двоичных данных - это минимально необходимый размер, если первая цифра литерала не равна &lt;code&gt;0&lt;/code&gt; . В случае начальных нулей размер определяется минимально необходимым размером для литерала, который имеет ту же длину, но начальную цифру &lt;code&gt;1&lt;/code&gt; . Это позволяет пользователю контролировать размер. Значения, которые нельзя сохранить в &lt;code&gt;UInt128&lt;/code&gt; , нельзя записать как такие литералы.</target>
        </trans-unit>
        <trans-unit id="6db8bde5f510430fc099aa246b7efd8ae6ef4908" translate="yes" xml:space="preserve">
          <source>As for numeric arrays, choosing a non-stable default algorithm for array types for which the notion of a stable sort is meaningless (i.e. when two values comparing equal can not be distinguished) may make sense.</source>
          <target state="translated">Что касается числовых массивов,то выбор нестационарного алгоритма по умолчанию для типов массивов,для которых понятие стабильного сорта бессмысленно (т.е.когда два значения,сравнивающие равные,не могут быть различимы),может иметь смысл.</target>
        </trans-unit>
        <trans-unit id="5657074766ca713487af1f45c8fe2527e89dae0c" translate="yes" xml:space="preserve">
          <source>As for single values, use &lt;a href=&quot;../../base/base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt; to treat &lt;code&gt;missing&lt;/code&gt; values as equal to other &lt;code&gt;missing&lt;/code&gt; values but different from non-missing values</source>
          <target state="translated">Что касается одиночных значений, используйте &lt;a href=&quot;../../base/base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt; для обработки &lt;code&gt;missing&lt;/code&gt; значений как равных другим &lt;code&gt;missing&lt;/code&gt; значениям, но отличных от непропущенных значений.</target>
        </trans-unit>
        <trans-unit id="80909a25deba83e5c549936818feccfa43f85abd" translate="yes" xml:space="preserve">
          <source>As hinted above, one extremely useful feature of Julia is the capability to generate and manipulate Julia code within Julia itself. We have already seen one example of a function returning &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; objects: the &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; function, which takes a string of Julia code and returns the corresponding &lt;code&gt;Expr&lt;/code&gt;. A function can also take one or more &lt;code&gt;Expr&lt;/code&gt; objects as arguments, and return another &lt;code&gt;Expr&lt;/code&gt;. Here is a simple, motivating example:</source>
          <target state="translated">Как указывалось выше, одна чрезвычайно полезная функция Julia - это возможность генерировать код Julia и управлять им внутри самой Julia. Мы уже видели один пример функции, возвращающей объекты &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; : функция &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; , которая принимает строку кода Julia и возвращает соответствующее &lt;code&gt;Expr&lt;/code&gt; . Функция также может принимать один или несколько объектов &lt;code&gt;Expr&lt;/code&gt; в качестве аргументов и возвращать другое &lt;code&gt;Expr&lt;/code&gt; . Вот простой вдохновляющий пример:</target>
        </trans-unit>
        <trans-unit id="0e3a8b594e44456d63d508da5257e974c3de310d" translate="yes" xml:space="preserve">
          <source>As illustrated in the above example each column of &lt;code&gt;|&lt;/code&gt; characters must be aligned vertically.</source>
          <target state="translated">Как показано в приведенном выше примере, каждый столбец &lt;code&gt;|&lt;/code&gt; символы должны быть выровнены по вертикали.</target>
        </trans-unit>
        <trans-unit id="51316c0f471c7aa15821993b2904c54c98f59dec" translate="yes" xml:space="preserve">
          <source>As in Java, strings are immutable: the value of an &lt;code&gt;AbstractString&lt;/code&gt; object cannot be changed. To construct a different string value, you construct a new string from parts of other strings.</source>
          <target state="translated">Как и в Java, строки неизменяемы: значение объекта &lt;code&gt;AbstractString&lt;/code&gt; не может быть изменено. Чтобы создать другое строковое значение, вы создаете новую строку из частей других строк.</target>
        </trans-unit>
        <trans-unit id="972bb7e6b4d2b9c22f53c9f2f7dc30a1be414e25" translate="yes" xml:space="preserve">
          <source>As in the example above, we recommend following some simple conventions when writing documentation:</source>
          <target state="translated">Как и в примере выше,мы рекомендуем при написании документации следовать некоторым простым конвенциям:</target>
        </trans-unit>
        <trans-unit id="42eaaebd11c27f9b1c1515d18b277f999ad14b89" translate="yes" xml:space="preserve">
          <source>As it was mentioned &lt;code&gt;CodeUnits{UInt8,String}&lt;/code&gt; type behaves like read only array of &lt;code&gt;UInt8&lt;/code&gt; and if you need a standard vector you can convert it using &lt;code&gt;Vector{UInt8}&lt;/code&gt;:</source>
          <target state="translated">Как уже упоминалось, &lt;code&gt;CodeUnits{UInt8,String}&lt;/code&gt; ведет себя как массив только для &lt;code&gt;UInt8&lt;/code&gt; и если вам нужен стандартный вектор, вы можете преобразовать его с помощью &lt;code&gt;Vector{UInt8}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ba1acaea73293bc8197cce97bdfefcad05927f1a" translate="yes" xml:space="preserve">
          <source>As mentioned above, one can also define new display backends. For example, a module that can display PNG images in a window can register this capability with Julia, so that calling &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; on types with PNG representations will automatically display the image using the module's window.</source>
          <target state="translated">Как упоминалось выше, можно также определить новые серверные части отображения. Например, модуль, который может отображать изображения PNG в окне, может зарегистрировать эту возможность в Julia, так что вызов &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt; для типов с представлениями PNG будет автоматически отображать изображение с помощью окна модуля.</target>
        </trans-unit>
        <trans-unit id="fb063e502e9f2dd374cf5645d0ea6281db87f213" translate="yes" xml:space="preserve">
          <source>As mentioned briefly in &lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;Functions&lt;/a&gt;, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:</source>
          <target state="translated">Как вкратце упоминалось в &lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;разделе &amp;laquo;Функции&amp;raquo;&lt;/a&gt; , необязательные аргументы реализованы как синтаксис для множественных определений методов. Например, это определение:</target>
        </trans-unit>
        <trans-unit id="191e5fd5542b028418c413dac2b44eaff01d364f" translate="yes" xml:space="preserve">
          <source>As of this writing, the valid Unicode code points are &lt;code&gt;U+00&lt;/code&gt; through &lt;code&gt;U+d7ff&lt;/code&gt; and &lt;code&gt;U+e000&lt;/code&gt; through &lt;code&gt;U+10ffff&lt;/code&gt;. These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.</source>
          <target state="translated">На момент написания этой статьи допустимыми кодами Unicode являются от &lt;code&gt;U+00&lt;/code&gt; до &lt;code&gt;U+d7ff&lt;/code&gt; и от &lt;code&gt;U+e000&lt;/code&gt; до &lt;code&gt;U+10ffff&lt;/code&gt; . Еще не всем им присвоено понятное значение, и они не обязательно интерпретируются приложениями, но все эти значения считаются допустимыми символами Unicode.</target>
        </trans-unit>
        <trans-unit id="c64e98d3602dd7e8a13d28a764d202fba2aba952" translate="yes" xml:space="preserve">
          <source>As one can see here, &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt; simply returns true or false, indicating whether a match for the given regex occurs in the string. Commonly, however, one wants to know not just whether a string matched, but also &lt;em&gt;how&lt;/em&gt; it matched. To capture this information about a match, use the &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; function instead:</source>
          <target state="translated">Как можно видеть здесь, &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt; просто возвращает истину или ложь, указывая, есть ли совпадение для данного регулярного выражения в строке. Однако обычно нужно знать не только, совпала ли строка, но и &lt;em&gt;как&lt;/em&gt; она совпала. Для того, чтобы захватить эту информацию о матче, используйте &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; функцию вместо:</target>
        </trans-unit>
        <trans-unit id="c4a14a67f1bf4cea327a2eb12b0f80f0eef678ff" translate="yes" xml:space="preserve">
          <source>As the error states, an immediate cause of an &lt;code&gt;UndefVarError&lt;/code&gt; on a remote node is that a binding by that name does not exist. Let us explore some of the possible causes.</source>
          <target state="translated">Как указано в сообщении об ошибке, непосредственной причиной &lt;code&gt;UndefVarError&lt;/code&gt; на удаленном узле является то, что привязка с таким именем не существует. Давайте исследуем некоторые из возможных причин.</target>
        </trans-unit>
        <trans-unit id="1eb17e26ef0507943bf96943b437f10fc48bc317" translate="yes" xml:space="preserve">
          <source>As the example implies, the following command-line arguments to &lt;code&gt;julia&lt;/code&gt; are interpreted as command-line arguments to the program &lt;code&gt;script.jl&lt;/code&gt;, passed in the global constant &lt;code&gt;ARGS&lt;/code&gt;. The name of the script itself is passed in as the global &lt;code&gt;PROGRAM_FILE&lt;/code&gt;. Note that &lt;code&gt;ARGS&lt;/code&gt; is also set when a Julia expression is given using the &lt;code&gt;-e&lt;/code&gt; option on the command line (see the &lt;code&gt;julia&lt;/code&gt; help output below) but &lt;code&gt;PROGRAM_FILE&lt;/code&gt; will be empty. For example, to just print the arguments given to a script, you could do this:</source>
          <target state="translated">Как следует из примера, следующие аргументы командной строки для &lt;code&gt;julia&lt;/code&gt; интерпретируются как аргументы командной строки для программы &lt;code&gt;script.jl&lt;/code&gt; , переданные в глобальной константе &lt;code&gt;ARGS&lt;/code&gt; . Имя самого скрипта передается как глобальный &lt;code&gt;PROGRAM_FILE&lt;/code&gt; . Обратите внимание, что &lt;code&gt;ARGS&lt;/code&gt; также устанавливается, когда выражение Julia задается с использованием параметра &lt;code&gt;-e&lt;/code&gt; в командной строке (см. Вывод справки &lt;code&gt;julia&lt;/code&gt; ниже), но &lt;code&gt;PROGRAM_FILE&lt;/code&gt; будет пустым. Например, чтобы просто вывести аргументы, данные сценарию, можно сделать так:</target>
        </trans-unit>
        <trans-unit id="981be6ff2cc90e0e705ac3383fc828a6dbdc7827" translate="yes" xml:space="preserve">
          <source>As this example shows, the element type of such arrays is &lt;code&gt;Union{Missing, T}&lt;/code&gt;, with &lt;code&gt;T&lt;/code&gt; the type of the non-missing values. This simply reflects the fact that array entries can be either of type &lt;code&gt;T&lt;/code&gt; (here, &lt;code&gt;Int64&lt;/code&gt;) or of type &lt;code&gt;Missing&lt;/code&gt;. This kind of array uses an efficient memory storage equivalent to an &lt;code&gt;Array{T}&lt;/code&gt; holding the actual values combined with an &lt;code&gt;Array{UInt8}&lt;/code&gt; indicating the type of the entry (i.e. whether it is &lt;code&gt;Missing&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;).</source>
          <target state="translated">Как показано в этом примере, тип элемента таких массивов - &lt;code&gt;Union{Missing, T}&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; - это тип непропущенных значений. Это просто отражает тот факт, что записи массива могут быть либо типа &lt;code&gt;T&lt;/code&gt; (здесь &lt;code&gt;Int64&lt;/code&gt; ), либо типа &lt;code&gt;Missing&lt;/code&gt; . Этот вид массива использует эффективный эквивалент памяти для хранения на &lt;code&gt;Array{T}&lt;/code&gt; , держащий фактические значения в сочетании с &lt;code&gt;Array{UInt8}&lt;/code&gt; , указывающего типа записи (то есть ли она &lt;code&gt;Missing&lt;/code&gt; или &lt;code&gt;T&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c38e97b2426f385efa12439902693dc14bf8618f" translate="yes" xml:space="preserve">
          <source>As usual, the absolute value (&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt;) of a complex number is its distance from zero. &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt;&lt;code&gt;abs2&lt;/code&gt;&lt;/a&gt; gives the square of the absolute value, and is of particular use for complex numbers since it avoids taking a square root. &lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt; returns the phase angle in radians (also known as the &lt;em&gt;argument&lt;/em&gt; or &lt;em&gt;arg&lt;/em&gt; function). The full gamut of other &lt;a href=&quot;../mathematical-operations/index#Elementary-Functions-1&quot;&gt;Elementary Functions&lt;/a&gt; is also defined for complex numbers:</source>
          <target state="translated">Как обычно, абсолютное значение ( &lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt; &lt;code&gt;abs&lt;/code&gt; &lt;/a&gt; ) комплексного числа - это его расстояние от нуля. &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt; &lt;code&gt;abs2&lt;/code&gt; &lt;/a&gt; дает квадрат абсолютного значения и особенно полезен для комплексных чисел, поскольку позволяет избежать извлечения квадратного корня. &lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt; &lt;code&gt;angle&lt;/code&gt; &lt;/a&gt; возвращает фазовый угол в радианах (также известный как &lt;em&gt;аргумент&lt;/em&gt; или функция &lt;em&gt;arg&lt;/em&gt; ). Полная гамма других &lt;a href=&quot;../mathematical-operations/index#Elementary-Functions-1&quot;&gt;элементарных функций&lt;/a&gt; также определена для комплексных чисел:</target>
        </trans-unit>
        <trans-unit id="b6a7588d6f9c25c0288fa6f4060bf2933853ea1a" translate="yes" xml:space="preserve">
          <source>As usual, the promotion system makes interactions with other numeric types effortless:</source>
          <target state="translated">Как обычно,система продвижения делает взаимодействие с другими числовыми типами легким:</target>
        </trans-unit>
        <trans-unit id="0ac972252ac8a4d2677fb97cc60dc48ab7bb4888" translate="yes" xml:space="preserve">
          <source>As usual, this does not bring &lt;code&gt;DummyModule&lt;/code&gt; into scope on any of the process, which requires &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;. Moreover, when &lt;code&gt;DummyModule&lt;/code&gt; is brought into scope on one process, it is not on any other:</source>
          <target state="translated">Как обычно, &lt;code&gt;DummyModule&lt;/code&gt; не попадает в область видимости какого-либо процесса, который требует &lt;code&gt;using&lt;/code&gt; или &lt;code&gt;import&lt;/code&gt; . Более того, когда &lt;code&gt;DummyModule&lt;/code&gt; попадает в область видимости одного процесса, его нет ни в каком другом:</target>
        </trans-unit>
        <trans-unit id="f7ffd73a9506b0079b3703beb529178a185c5762" translate="yes" xml:space="preserve">
          <source>As we have seen in &lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code-1&quot;&gt;Calling C and Fortran Code&lt;/a&gt;, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).</source>
          <target state="translated">Как мы видели в &lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code-1&quot;&gt;Вызове кода C и Fortran&lt;/a&gt; , у Джулии есть простой и эффективный способ вызова функций, написанных на C. Но есть ситуации, когда требуется обратное: вызов функции Джулии из кода C. Это можно использовать для интеграции кода Julia в более крупный проект C / C ++ без необходимости переписывать все на C / C ++. У Джулии есть API C, чтобы это стало возможным. Поскольку почти во всех языках программирования есть способ вызова функций C, API Julia C также может использоваться для построения дополнительных языковых мостов (например, вызова Julia из Python или C #).</target>
        </trans-unit>
        <trans-unit id="82c0a21a8d879f7a5c7272f023db6b90d1239835" translate="yes" xml:space="preserve">
          <source>As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects.</source>
          <target state="translated">Как мы видели,объекты Юлии представлены на C в виде указателей.Это ставит вопрос о том,кто отвечает за освобождение этих объектов.</target>
        </trans-unit>
        <trans-unit id="8632fecc892c2a5175874dd3d5957b71b599c90f" translate="yes" xml:space="preserve">
          <source>As we have seen, a typical parametric type has inner constructors that are called when type parameters are known; e.g. they apply to &lt;code&gt;Point{Int}&lt;/code&gt; but not to &lt;code&gt;Point&lt;/code&gt;. Optionally, outer constructors that determine type parameters automatically can be added, for example constructing a &lt;code&gt;Point{Int}&lt;/code&gt; from the call &lt;code&gt;Point(1,2)&lt;/code&gt;. Outer constructors call inner constructors to actually make instances. However, in some cases one would rather not provide inner constructors, so that specific type parameters cannot be requested manually.</source>
          <target state="translated">Как мы видели, типичный параметрический тип имеет внутренние конструкторы, которые вызываются, когда известны параметры типа; например, они применяются к &lt;code&gt;Point{Int}&lt;/code&gt; но не к &lt;code&gt;Point&lt;/code&gt; . При желании могут быть добавлены внешние конструкторы, которые автоматически определяют параметры типа, например создание &lt;code&gt;Point{Int}&lt;/code&gt; из вызова &lt;code&gt;Point(1,2)&lt;/code&gt; . Внешние конструкторы вызывают внутренние конструкторы для создания экземпляров. Однако в некоторых случаях предпочтительнее не предоставлять внутренние конструкторы, чтобы параметры конкретного типа нельзя было запрашивать вручную.</target>
        </trans-unit>
        <trans-unit id="92ef7f3ff78c47fd1600b930f6d1226b1a4419f4" translate="yes" xml:space="preserve">
          <source>As we have seen, such expressions support interpolation with &lt;code&gt;$&lt;/code&gt;. However, in some situations it is necessary to quote code &lt;em&gt;without&lt;/em&gt; performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type &lt;code&gt;QuoteNode&lt;/code&gt;. The parser yields &lt;code&gt;QuoteNode&lt;/code&gt;s for simple quoted items like symbols:</source>
          <target state="translated">Как мы видели, такие выражения поддерживают интерполяцию с помощью &lt;code&gt;$&lt;/code&gt; . Однако в некоторых ситуациях необходимо цитировать код &lt;em&gt;без&lt;/em&gt; выполнения интерполяции. Этот вид цитирования еще не имеет синтаксиса, но внутренне представлен как объект типа &lt;code&gt;QuoteNode&lt;/code&gt; . Парсер выдает &lt;code&gt;QuoteNode&lt;/code&gt; s для простых цитируемых элементов, таких как символы:</target>
        </trans-unit>
        <trans-unit id="cfe3955e5cc39192c40411a547d67109141fbd1c" translate="yes" xml:space="preserve">
          <source>As we will see next, boxing is required to call Julia functions with specific arguments.</source>
          <target state="translated">Как мы увидим далее,бокс необходим для вызова функций Julia с определенными аргументами.</target>
        </trans-unit>
        <trans-unit id="b53a534247af6d63db181fe8ad6536af06cae1ff" translate="yes" xml:space="preserve">
          <source>As well as information about the &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;'s year and quarter:</source>
          <target state="translated">А также информацию о году и квартале &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="834e03682d6f73b9df03b1d3810b4934cc9cc3a8" translate="yes" xml:space="preserve">
          <source>As well as other useful operations, such as finding eigenvalues or eigenvectors:</source>
          <target state="translated">А также другие полезные операции,такие как поиск собственных значений или собственных векторов:</target>
        </trans-unit>
        <trans-unit id="ce2d2a88a78a8f4ae1b7b6c89e850d2a3f2b6a48" translate="yes" xml:space="preserve">
          <source>As with any &lt;code&gt;ccall&lt;/code&gt;, it is essential to get the argument signature exactly correct. Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by &lt;code&gt;Core.Intrinsics&lt;/code&gt;.</source>
          <target state="translated">Как и в случае любого &lt;code&gt;ccall&lt;/code&gt; , важно получить точно правильную подпись аргумента. Также обратите внимание, что не существует уровня совместимости, который гарантирует, что встроенная функция имеет смысл и работает с текущей целью, в отличие от эквивалентных функций Julia, предоставляемых &lt;code&gt;Core.Intrinsics&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f496eca34c1af36fc9e6f49533f03b24b7584356" translate="yes" xml:space="preserve">
          <source>As with incomplete objects returned from constructors, if &lt;code&gt;complete_me&lt;/code&gt; or any of its callees try to access the &lt;code&gt;data&lt;/code&gt; field of the &lt;code&gt;Lazy&lt;/code&gt; object before it has been initialized, an error will be thrown immediately.</source>
          <target state="translated">Как и неполными объекты , возвращаемых из конструкторов, если &lt;code&gt;complete_me&lt;/code&gt; или любые из его пытается вызываемыми методы доступа к &lt;code&gt;data&lt;/code&gt; поля от &lt;code&gt;Lazy&lt;/code&gt; объекта до его инициализации, ошибка будет отброшена сразу.</target>
        </trans-unit>
        <trans-unit id="206e9628ecffc277c3db7c6ada272a26870edc0c" translate="yes" xml:space="preserve">
          <source>As with literals in the previous section, if literal backticks need to be written within double backticks use an even number greater than two. Note that if a single literal backtick needs to be included within $\LaTeX$ markup then two enclosing backticks is sufficient.</source>
          <target state="translated">Как и в случае с литералами в предыдущем разделе,если буквенные черные метки должны быть записаны в двойные черные метки,используйте четное число больше двух.Обратите внимание,что если в разметку $\LaTeX$ необходимо включить один буквенный бэк-стик,то двух прилагаемых бэк-стиков будет достаточно.</target>
        </trans-unit>
        <trans-unit id="eb071802c875eedf2628f279f3c3aa261b7f9f4a" translate="yes" xml:space="preserve">
          <source>As with other streams, use &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; to disconnect the socket:</source>
          <target state="translated">Как и в случае с другими потоками, используйте &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; для отключения сокета:</target>
        </trans-unit>
        <trans-unit id="4caebefb85f01f12aff5118bde420090e55936d8" translate="yes" xml:space="preserve">
          <source>As with variables, Unicode can also be used for function names:</source>
          <target state="translated">Как и в случае с переменными,Юникод также может быть использован для имен функций:</target>
        </trans-unit>
        <trans-unit id="f11a9dc367827aceb27fae5caffbfb8a44dc892b" translate="yes" xml:space="preserve">
          <source>As you can see in the examples, logging statements make no mention of where log events go or how they are processed. This is a key design feature that makes the system composable and natural for concurrent use. It does this by separating two different concerns:</source>
          <target state="translated">Как видно из примеров,в протоколировании не упоминается,куда идут события журнала и как они обрабатываются.Это ключевая конструктивная особенность,которая делает систему композитной и естественной для одновременного использования.Это достигается путем разделения двух различных проблем:</target>
        </trans-unit>
        <trans-unit id="4b2d88632a2082abc54ba7d8928178e89f90f7d3" translate="yes" xml:space="preserve">
          <source>As you can see, for constructor calls with explicit type parameters, the arguments are converted to the implied field types: &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; works, but &lt;code&gt;Point{Int64}(1.0,2.5)&lt;/code&gt; raises an &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; when converting &lt;code&gt;2.5&lt;/code&gt; to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;. When the type is implied by the arguments to the constructor call, as in &lt;code&gt;Point(1,2)&lt;/code&gt;, then the types of the arguments must agree &amp;ndash; otherwise the &lt;code&gt;T&lt;/code&gt; cannot be determined &amp;ndash; but any pair of real arguments with matching type may be given to the generic &lt;code&gt;Point&lt;/code&gt; constructor.</source>
          <target state="translated">Как видите, для вызовов конструктора с явными параметрами типа аргументы преобразуются в подразумеваемые типы полей: &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; работает, но &lt;code&gt;Point{Int64}(1.0,2.5)&lt;/code&gt; вызывает &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt; при преобразовании &lt;code&gt;2.5&lt;/code&gt; в &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; . Когда тип подразумевается аргументами вызова конструктора, как в &lt;code&gt;Point(1,2)&lt;/code&gt; , тогда типы аргументов должны согласовываться - в противном случае &lt;code&gt;T&lt;/code&gt; не может быть определено - но может быть задана любая пара реальных аргументов с соответствующим типом в универсальный конструктор &lt;code&gt;Point&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5461c0708bdec655ec8f2787ade84a59cba9a62f" translate="yes" xml:space="preserve">
          <source>As you can see, if the wrong number of elements are in the splatted container, then the function call will fail, just as it would if too many arguments were given explicitly.</source>
          <target state="translated">Как видите,если в контейнере splatted находится неверное количество элементов,то вызов функции завершится неудачей,как и в случае явного указания слишком большого количества аргументов.</target>
        </trans-unit>
        <trans-unit id="e203af061ceae4264896923db832aa0fc04bb217" translate="yes" xml:space="preserve">
          <source>As you can see, in the first line we asked process 2 to construct a 2-by-2 random matrix, and in the second line we asked it to add 1 to it. The result of both calculations is available in the two futures, &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;. The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; macro evaluates the expression in the second argument on the process specified by the first argument.</source>
          <target state="translated">Как видите, в первой строке мы попросили процесс 2 построить случайную матрицу размером 2 на 2, а во второй строке мы попросили добавить к ней 1. Результат обоих вычислений доступен в двух фьючерсах, &lt;code&gt;r&lt;/code&gt; и &lt;code&gt;s&lt;/code&gt; . &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt; макро вычисляет выражение во втором аргументе о процессе указанного первым аргументом.</target>
        </trans-unit>
        <trans-unit id="741e859119d8cfeca907f894902aa3d526d932dd" translate="yes" xml:space="preserve">
          <source>As you can see, the arguments must be precisely of type &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. Other numeric types, such as integers or 32-bit floating-point values, are not automatically converted to 64-bit floating-point, nor are strings parsed as numbers. Because &lt;code&gt;Float64&lt;/code&gt; is a concrete type and concrete types cannot be subclassed in Julia, such a definition can only be applied to arguments that are exactly of type &lt;code&gt;Float64&lt;/code&gt;. It may often be useful, however, to write more general methods where the declared parameter types are abstract:</source>
          <target state="translated">Как видите, аргументы должны быть именно типа &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; . Другие числовые типы, такие как целые числа или 32-разрядные значения с плавающей запятой, не преобразуются автоматически в 64-разрядные числа с плавающей запятой, а строки не анализируются как числа. Поскольку &lt;code&gt;Float64&lt;/code&gt; - это конкретный тип, а конкретные типы не могут быть разделены на подклассы в Julia, такое определение может применяться только к аргументам, которые точно относятся к типу &lt;code&gt;Float64&lt;/code&gt; . Однако часто бывает полезно написать более общие методы, в которых объявленные типы параметров являются абстрактными:</target>
        </trans-unit>
        <trans-unit id="359b67713bb818c1f3c296863f7d844ae4bb9a8a" translate="yes" xml:space="preserve">
          <source>As you can see, the second version, where we used an &lt;code&gt;Int&lt;/code&gt; literal, preserved the type of the input argument, while the first didn't. This is because e.g. &lt;code&gt;promote_type(Int, Float64) == Float64&lt;/code&gt;, and promotion happens with the multiplication. Similarly, &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; literals are less type disruptive than &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; literals, but more disruptive than &lt;code&gt;Int&lt;/code&gt;s:</source>
          <target state="translated">Как видите, вторая версия, в которой мы использовали литерал &lt;code&gt;Int&lt;/code&gt; , сохранила тип входного аргумента, а первая - нет. Это потому, что, например, &lt;code&gt;promote_type(Int, Float64) == Float64&lt;/code&gt; , а продвижение происходит с умножением. Точно так же литералы &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; менее разрушительны, чем литералы &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; , но более разрушительны, чем &lt;code&gt;Int&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a10e4a732e45e67918d07e124985de66438f996f" translate="yes" xml:space="preserve">
          <source>As you can see, the space in the &lt;code&gt;path&lt;/code&gt; variable is appropriately escaped. But what if you &lt;em&gt;want&lt;/em&gt; to interpolate multiple words? In that case, just use an array (or any other iterable container):</source>
          <target state="translated">Как видите, пробел в переменной &lt;code&gt;path&lt;/code&gt; соответствующим образом экранирован. Но что, если вы &lt;em&gt;хотите&lt;/em&gt; интерполировать несколько слов? В этом случае просто используйте массив (или любой другой повторяемый контейнер):</target>
        </trans-unit>
        <trans-unit id="43e3dc387959de6b7b510dc6136369a6354233c2" translate="yes" xml:space="preserve">
          <source>As you can see, the type of the appended element must match the element type of the vector it is appended to, or else a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is raised. In the following example, the method type parameter &lt;code&gt;T&lt;/code&gt; is used as the return value:</source>
          <target state="translated">Как видите, тип добавляемого элемента должен соответствовать типу элемента вектора, к &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; он добавляется, в противном случае возникает ошибка MethodError . В следующем примере параметр типа метода &lt;code&gt;T&lt;/code&gt; используется как возвращаемое значение:</target>
        </trans-unit>
        <trans-unit id="b29b566be209e38051caa728ad8f87323746dc77" translate="yes" xml:space="preserve">
          <source>As you could see, the reduction operator can be omitted if it is not needed. In that case, the loop executes asynchronously, i.e. it spawns independent tasks on all available workers and returns an array of &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; immediately without waiting for completion. The caller can wait for the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; completions at a later point by calling &lt;code&gt;fetch&lt;/code&gt; on them, or wait for completion at the end of the loop by prefixing it with &lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt;&lt;code&gt;@sync&lt;/code&gt;&lt;/a&gt;, like &lt;code&gt;@sync @distributed for&lt;/code&gt;.</source>
          <target state="translated">Как видите, оператор сокращения можно опустить, если он не нужен. В этом случае цикл выполняется асинхронно, т. Е. Он порождает независимые задачи для всех доступных воркеров и сразу же возвращает массив &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; ,&lt;/a&gt; не дожидаясь завершения. Вызывающий может дождаться завершения &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; позже, вызвав для него &lt;code&gt;fetch&lt;/code&gt; , или дождаться завершения в конце цикла, добавив к нему префикс &lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt; &lt;code&gt;@sync&lt;/code&gt; &lt;/a&gt; , например &lt;code&gt;@sync @distributed for&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1a150349a442b853a138e3c1fe4e3f7948f68a2" translate="yes" xml:space="preserve">
          <source>As you may have realized, while memory associated with globals may be collected when they are reassigned on the master, no such action is taken on the workers as the bindings continue to be valid. &lt;code&gt;clear!&lt;/code&gt; can be used to manually reassign specific globals on remote nodes to &lt;code&gt;nothing&lt;/code&gt; once they are no longer required. This will release any memory associated with them as part of a regular garbage collection cycle.</source>
          <target state="translated">Как вы, возможно, уже поняли, хотя память, связанная с глобальными объектами, может быть собрана при их переназначении на ведущем устройстве, такие действия не выполняются с рабочими объектами, поскольку привязки остаются действительными. &lt;code&gt;clear!&lt;/code&gt; может использоваться для ручного переназначения определенных глобальных переменных на удаленных узлах на &lt;code&gt;nothing&lt;/code&gt; если они больше не требуются. Это освободит всю связанную с ними память в рамках обычного цикла сборки мусора.</target>
        </trans-unit>
        <trans-unit id="dacd35c567b889475ef2a3c6c433ab70c5f4775a" translate="yes" xml:space="preserve">
          <source>Assign &lt;code&gt;x&lt;/code&gt; to a named field in &lt;code&gt;value&lt;/code&gt; of composite type. The &lt;code&gt;value&lt;/code&gt; must be mutable and &lt;code&gt;x&lt;/code&gt; must be a subtype of &lt;code&gt;fieldtype(typeof(value), name)&lt;/code&gt;. See also &lt;a href=&quot;#Base.setproperty!&quot;&gt;&lt;code&gt;setproperty!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Присвойте &lt;code&gt;x&lt;/code&gt; именованному полю в &lt;code&gt;value&lt;/code&gt; составного типа. &lt;code&gt;value&lt;/code&gt; должно быть изменяемым и &lt;code&gt;x&lt;/code&gt; должны быть подтипом &lt;code&gt;fieldtype(typeof(value), name)&lt;/code&gt; . См. Также &lt;a href=&quot;#Base.setproperty!&quot;&gt; &lt;code&gt;setproperty!&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="31839985af6b213c58cad9bbfe8e7aebd2198424" translate="yes" xml:space="preserve">
          <source>Assign a value to a key in the current task's task-local storage.</source>
          <target state="translated">Присвоить значение ключу в локальном хранилище задач текущей задачи.</target>
        </trans-unit>
        <trans-unit id="343021dcf6fd7efdb357d926be862e74219ddb49" translate="yes" xml:space="preserve">
          <source>Assigning &lt;code&gt;[]&lt;/code&gt; does not eliminate elements from a collection; instead use &lt;a href=&quot;../collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Назначение &lt;code&gt;[]&lt;/code&gt; не удаляет элементы из коллекции; вместо этого используйте &lt;a href=&quot;../collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="6144b75b7bde706b0577dc11bf2dc87a5f571732" translate="yes" xml:space="preserve">
          <source>Assigning &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; does not create a copy of &lt;code&gt;b&lt;/code&gt;; instead use &lt;a href=&quot;#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.deepcopy&quot;&gt;&lt;code&gt;deepcopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Присвоение &lt;code&gt;a&lt;/code&gt; к &lt;code&gt;b&lt;/code&gt; не создает копию &lt;code&gt;b&lt;/code&gt; ; вместо этого используйте &lt;a href=&quot;#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#Base.deepcopy&quot;&gt; &lt;code&gt;deepcopy&lt;/code&gt; &lt;/a&gt;копию .</target>
        </trans-unit>
        <trans-unit id="07a6f2ac6ae10af3c874613ad299e2e22c70e6b5" translate="yes" xml:space="preserve">
          <source>Assigning numbers into &lt;code&gt;a&lt;/code&gt; will now convert them to &lt;code&gt;Float64&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; will be stored as a contiguous block of 64-bit floating-point values that can be manipulated efficiently.</source>
          <target state="translated">Присвоение чисел в &lt;code&gt;a&lt;/code&gt; теперь преобразует их в &lt;code&gt;Float64&lt;/code&gt; , а &lt;code&gt;a&lt;/code&gt; будет сохраняться как непрерывный блок 64-битных значений с плавающей запятой, которыми можно эффективно управлять.</target>
        </trans-unit>
        <trans-unit id="335227cba10c33b5a2154427c17bb8a45448ea75" translate="yes" xml:space="preserve">
          <source>Assigning to a field of an object converts to the declared type of the field.</source>
          <target state="translated">Присвоение поля объекту преобразуется в объявленный тип поля.</target>
        </trans-unit>
        <trans-unit id="ea3c536f7d8386d0d34fa46bb187211a095b9597" translate="yes" xml:space="preserve">
          <source>Assigning to a variable with a declared type (e.g. &lt;code&gt;local x::T&lt;/code&gt;) converts to that type.</source>
          <target state="translated">Присваивание переменной с объявленным типом (например, &lt;code&gt;local x::T&lt;/code&gt; ) преобразуется в этот тип.</target>
        </trans-unit>
        <trans-unit id="4352a222d8d135ef7905c51dc5e73ca198e904f1" translate="yes" xml:space="preserve">
          <source>Assigning to an array converts to the array's element type.</source>
          <target state="translated">Присвоение массиву преобразуется в тип элемента массива.</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="caee9fcfeeacb92daf3a9dd06e9024b473eac387" translate="yes" xml:space="preserve">
          <source>Assignment at out-of-bounds indices does not grow a collection. If the collection is a &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt; it can instead be grown with &lt;a href=&quot;../collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Присвоение индексов за пределами диапазона не увеличивает коллекцию. Если коллекция является &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt; ее можно увеличить с помощью &lt;a href=&quot;../collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt;или &lt;a href=&quot;../collections/index#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="cca9fba860c54e60aaec525df6854ad412b1850b" translate="yes" xml:space="preserve">
          <source>Assignment can operate on multiple variables in parallel, taking values from an iterable:</source>
          <target state="translated">Присвоение может работать с несколькими переменными параллельно,беря значения из итерабельного:</target>
        </trans-unit>
        <trans-unit id="729134453eca052fa22a956f1ac0e88899ca88fa" translate="yes" xml:space="preserve">
          <source>Assignment can operate on multiple variables in series, and will return the value of the right-hand-most expression:</source>
          <target state="translated">Назначение может работать с несколькими переменными последовательно,и будет возвращать значение самого правого выражения:</target>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="a997f01f100c5327776cf22824dbe2d9bd2208d2" translate="yes" xml:space="preserve">
          <source>Associate the lifetime of &lt;code&gt;chnl&lt;/code&gt; with a task. &lt;code&gt;Channel&lt;/code&gt;&lt;code&gt;chnl&lt;/code&gt; is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on &lt;code&gt;chnl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;chnl&lt;/code&gt; время жизни chnl с задачей. &lt;code&gt;Channel&lt;/code&gt; &lt;code&gt;chnl&lt;/code&gt; автоматически закрывается при завершении задачи. Любое неперехваченное исключение в задаче распространяется на всех официантов на &lt;code&gt;chnl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59f2aa2b1552b74e34281b33bf3cbb05f68d9bae" translate="yes" xml:space="preserve">
          <source>Associative collections (such as &lt;code&gt;Dict&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;) need to be re-hashed in &lt;code&gt;__init__&lt;/code&gt;. (In the future, a mechanism may be provided to register an initializer function.)</source>
          <target state="translated">Ассоциативные коллекции (такие как &lt;code&gt;Dict&lt;/code&gt; и &lt;code&gt;Set&lt;/code&gt; ) необходимо повторно хешировать в &lt;code&gt;__init__&lt;/code&gt; . (В будущем может быть предоставлен механизм для регистрации функции инициализатора.)</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="31eabac4e8c06c32e7c19300707a41f9f210b6ee" translate="yes" xml:space="preserve">
          <source>Assuming no method more specific than the above is found, Julia next internally defines and compiles a method called &lt;code&gt;myplus&lt;/code&gt; specifically for two &lt;code&gt;Int&lt;/code&gt; arguments based on the generic function given above, i.e., it implicitly defines and compiles:</source>
          <target state="translated">Предполагая, что не найден более конкретный метод, чем указанный выше, Джулия затем внутренне определяет и компилирует метод с именем &lt;code&gt;myplus&lt;/code&gt; специально для двух аргументов &lt;code&gt;Int&lt;/code&gt; на основе общей функции, приведенной выше, то есть он неявно определяет и компилирует:</target>
        </trans-unit>
        <trans-unit id="2717ba36a09eb99678b64bb90dc485e6b0a0d557" translate="yes" xml:space="preserve">
          <source>Asterisk Operator</source>
          <target state="translated">Звездочка Оператор</target>
        </trans-unit>
        <trans-unit id="07b5380b9f5c5fd84a32bc659548c9dfab4533bb" translate="yes" xml:space="preserve">
          <source>Astonished Face</source>
          <target state="translated">Удивлённое лицо</target>
        </trans-unit>
        <trans-unit id="b66ee82704200b04b4798e66b6593db1b1b13374" translate="yes" xml:space="preserve">
          <source>Asymptotically Equal To</source>
          <target state="translated">Асимптотически равно</target>
        </trans-unit>
        <trans-unit id="5245f726138014634759729b99de5b3247dde5eb" translate="yes" xml:space="preserve">
          <source>AsyncCondition</source>
          <target state="translated">AsyncCondition</target>
        </trans-unit>
        <trans-unit id="8eaa017d84f0d81a23063919ee4ccb624ecbac15" translate="yes" xml:space="preserve">
          <source>AsyncCondition()</source>
          <target state="translated">AsyncCondition()</target>
        </trans-unit>
        <trans-unit id="97d88f0cd43a7c5afba791559c54e8c7a9720c83" translate="yes" xml:space="preserve">
          <source>Asynchronous IO and concurrent synchronous writes</source>
          <target state="translated">Асинхронный ввод-вывод и одновременная синхронная запись</target>
        </trans-unit>
        <trans-unit id="d61dfe1b51eb0bad1bc9d8b0b12b232b76aa4667" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;-O3&lt;/code&gt;, the compiler &lt;em&gt;might&lt;/em&gt; automatically vectorize operations on such tuples. For example, the following program, when compiled with &lt;code&gt;julia -O3&lt;/code&gt; generates two SIMD addition instructions (&lt;code&gt;addps&lt;/code&gt;) on x86 systems:</source>
          <target state="translated">При &lt;code&gt;-O3&lt;/code&gt; компилятор &lt;em&gt;может&lt;/em&gt; автоматически векторизовать операции с такими кортежами. Например, следующая программа при компиляции с &lt;code&gt;julia -O3&lt;/code&gt; генерирует две инструкции сложения SIMD ( &lt;code&gt;addps&lt;/code&gt; ) в системах x86:</target>
        </trans-unit>
        <trans-unit id="eb9e6602f2f530b7763a4fc47a789b6bcda1d592" translate="yes" xml:space="preserve">
          <source>At a high-level, each environment conceptually defines three maps: roots, graph and paths. When resolving the meaning of &lt;code&gt;import X&lt;/code&gt;, the roots and graph maps are used to determine the identity of &lt;code&gt;X&lt;/code&gt;, while the paths map is used to locate the source code of &lt;code&gt;X&lt;/code&gt;. The specific roles of the three maps are:</source>
          <target state="translated">На высоком уровне каждая среда концептуально определяет три карты: корни, граф и пути. При решении значения &lt;code&gt;import X&lt;/code&gt; , корни и карты графиков используются для определения идентичности &lt;code&gt;X&lt;/code&gt; , в то время как карта пути используется , чтобы найти исходный код &lt;code&gt;X&lt;/code&gt; . Особые роли трех карт:</target>
        </trans-unit>
        <trans-unit id="1f9ae804041641dde19215ce7dbf17a3259634a7" translate="yes" xml:space="preserve">
          <source>At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic. The first and most obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and replace the result with &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin(Int)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax(Int)&lt;/code&gt;&lt;/a&gt; as appropriate. This alone expands each integer operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse &amp;ndash; saturating integer arithmetic isn't associative. Consider this Matlab computation:</source>
          <target state="translated">На первый взгляд это кажется достаточно разумным, поскольку 9223372036854775807 намного ближе к 9223372036854775808, чем -9223372036854775808, и целые числа по-прежнему представлены с фиксированным размером естественным образом, совместимым с C и Фортраном. Однако насыщенная целочисленная арифметика представляет собой серьезную проблему. Первая и наиболее очевидная проблема заключается в том, что машинная целочисленная арифметика работает не так, поэтому реализация насыщенных операций требует выдачи инструкций после каждой машинной целочисленной операции для проверки отсутствия переполнения или переполнения и замены результата на &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin(Int)&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax(Int)&lt;/code&gt; &lt;/a&gt;по мере необходимости. Одно только это расширяет каждую целочисленную операцию из одной быстрой инструкции до полудюжины инструкций, возможно, включая ветки. Уч. Но становится еще хуже - насыщающая целочисленная арифметика не ассоциативна. Рассмотрим это вычисление в Matlab:</target>
        </trans-unit>
        <trans-unit id="557269c7906899330df530ce61ccdd6c30d22fca" translate="yes" xml:space="preserve">
          <source>At the base of this functionality is &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo&lt;/code&gt;&lt;/a&gt;, which will do the appropriate address resolution:</source>
          <target state="translated">В основе этой функции лежит &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo&lt;/code&gt; &lt;/a&gt; , который будет выполнять соответствующее разрешение адресов:</target>
        </trans-unit>
        <trans-unit id="dc65621fc57dd780fd2d22a2ad965178ea5de343" translate="yes" xml:space="preserve">
          <source>At the top, the inferred return type of the function is shown as &lt;code&gt;Body::Float64&lt;/code&gt;. The next lines represent the body of &lt;code&gt;f&lt;/code&gt; in Julia's SSA IR form. The numbered boxes are labels and represent targets for jumps (via &lt;code&gt;goto&lt;/code&gt;) in your code. Looking at the body, you can see that the first thing that happens is that &lt;code&gt;pos&lt;/code&gt; is called and the return value has been inferred as the &lt;code&gt;Union&lt;/code&gt; type &lt;code&gt;UNION{FLOAT64, INT64}&lt;/code&gt; shown in uppercase since it is a non-concrete type. This means that we cannot know the exact return type of &lt;code&gt;pos&lt;/code&gt; based on the input types. However, the result of &lt;code&gt;y*x&lt;/code&gt;is a &lt;code&gt;Float64&lt;/code&gt; no matter if &lt;code&gt;y&lt;/code&gt; is a &lt;code&gt;Float64&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt; The net result is that &lt;code&gt;f(x::Float64)&lt;/code&gt; will not be type-unstable in its output, even if some of the intermediate computations are type-unstable.</source>
          <target state="translated">Вверху предполагаемый тип возвращаемого значения функции показан как &lt;code&gt;Body::Float64&lt;/code&gt; . Следующие строки представляют собой тело &lt;code&gt;f&lt;/code&gt; в форме SSA IR Джулии. Пронумерованные поля являются метками и представляют цели для переходов (через &lt;code&gt;goto&lt;/code&gt; ) в вашем коде. Глядя на тело, вы можете увидеть, что первое, что происходит, - это вызов &lt;code&gt;pos&lt;/code&gt; , и возвращаемое значение выводится как тип &lt;code&gt;Union&lt;/code&gt; &lt;code&gt;UNION{FLOAT64, INT64}&lt;/code&gt; показанный в верхнем регистре, поскольку это не конкретный тип. Это означает, что мы не можем знать точный тип возврата &lt;code&gt;pos&lt;/code&gt; на основе типов ввода. Однако результатом &lt;code&gt;y*x&lt;/code&gt; будет &lt;code&gt;Float64&lt;/code&gt; независимо от того, если &lt;code&gt;y&lt;/code&gt; является &lt;code&gt;Float64&lt;/code&gt; или &lt;code&gt;Int64&lt;/code&gt; .Конечный результат состоит в том, что &lt;code&gt;f(x::Float64)&lt;/code&gt; не будет нестабильным по типу в своем выводе, даже если некоторые из промежуточных вычислений являются нестабильными по типу.</target>
        </trans-unit>
        <trans-unit id="4b8bfb8cb1b051b835dbefff1b5c12822cd90431" translate="yes" xml:space="preserve">
          <source>At this point, the project should build and run.</source>
          <target state="translated">На этом этапе проект должен быть построен и запущен.</target>
        </trans-unit>
        <trans-unit id="11e4a73a06b9dee6071ddafa6ecf05d8154a9294" translate="yes" xml:space="preserve">
          <source>Athletic Shoe</source>
          <target state="translated">Атлетическая обувь</target>
        </trans-unit>
        <trans-unit id="f3fbd2fd9cc354420ab6c1b9170e0b29144a85e6" translate="yes" xml:space="preserve">
          <source>Atomic Operations</source>
          <target state="translated">Атомные операции</target>
        </trans-unit>
        <trans-unit id="ad3b6bf5f22249f1093a69cf5b097656cf10a2e0" translate="yes" xml:space="preserve">
          <source>Atomic objects can be accessed using the &lt;code&gt;[]&lt;/code&gt; notation:</source>
          <target state="translated">Доступ к атомарным объектам можно получить с помощью обозначения &lt;code&gt;[]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="33b48033c48155a217b1ebf999c90a4b598f3e71" translate="yes" xml:space="preserve">
          <source>Atomic operations use an &lt;code&gt;atomic_&lt;/code&gt; prefix, such as &lt;a href=&quot;#Base.Threads.atomic_add!&quot;&gt;&lt;code&gt;atomic_add!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.Threads.atomic_xchg!&quot;&gt;&lt;code&gt;atomic_xchg!&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">Атомарные операции используют префикс &lt;code&gt;atomic_&lt;/code&gt; , например &lt;a href=&quot;#Base.Threads.atomic_add!&quot;&gt; &lt;code&gt;atomic_add!&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#Base.Threads.atomic_xchg!&quot;&gt; &lt;code&gt;atomic_xchg!&lt;/code&gt; &lt;/a&gt;, и т.д.</target>
        </trans-unit>
        <trans-unit id="ad6e575d4f77e8328667d22e1296bcc529f4eb15" translate="yes" xml:space="preserve">
          <source>Atomically add &lt;code&gt;val&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Атомно добавить &lt;code&gt;val&lt;/code&gt; к &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98b4786f90c42de0fa6575d5c8690c2d57540c23" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-and &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">Атомарно побитовое и &lt;code&gt;x&lt;/code&gt; с &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c59f0d3e8acb12180dbf858879145e09dbd4d31" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-nand (not-and) &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">Атомарно поразрядно-nand (not-and) &lt;code&gt;x&lt;/code&gt; с &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49dfbe4ce1039803bba1e66c619d680aaacd0303" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-or &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">Атомарно побитовое или &lt;code&gt;x&lt;/code&gt; с &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="361657c422d3986bfb8673c88d09205f8b549983" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-xor (exclusive-or) &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">Атомарно побитовый xor (исключающее ИЛИ) &lt;code&gt;x&lt;/code&gt; с &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720563406f6bfeb8b472dd6dd26fe3888437904c" translate="yes" xml:space="preserve">
          <source>Atomically compare-and-set &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Атомарно сравнить и установить &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cea0404569a918b8e5d8c74ca2a23340344009b" translate="yes" xml:space="preserve">
          <source>Atomically compares the value in &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;cmp&lt;/code&gt;. If equal, write &lt;code&gt;newval&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. Otherwise, leaves &lt;code&gt;x&lt;/code&gt; unmodified. Returns the old value in &lt;code&gt;x&lt;/code&gt;. By comparing the returned value to &lt;code&gt;cmp&lt;/code&gt; (via &lt;code&gt;===&lt;/code&gt;) one knows whether &lt;code&gt;x&lt;/code&gt; was modified and now holds the new value &lt;code&gt;newval&lt;/code&gt;.</source>
          <target state="translated">Атомарно сравнивает значение в &lt;code&gt;x&lt;/code&gt; с &lt;code&gt;cmp&lt;/code&gt; . Если равно, запишите &lt;code&gt;newval&lt;/code&gt; в &lt;code&gt;x&lt;/code&gt; . В противном случае оставляет &lt;code&gt;x&lt;/code&gt; без изменений. Возвращает старое значение в &lt;code&gt;x&lt;/code&gt; . Сравнивая возвращаемое значение с &lt;code&gt;cmp&lt;/code&gt; (через &lt;code&gt;===&lt;/code&gt; ), можно узнать, был ли изменен &lt;code&gt;x&lt;/code&gt; и теперь он содержит новое значение &lt;code&gt;newval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db092cd5c9d8911e3a523593755743a6ba3ff929" translate="yes" xml:space="preserve">
          <source>Atomically exchange the value in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Атомно поменять значение в &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ede158726902e9e7c885034b5dc7b476eaa3f0cb" translate="yes" xml:space="preserve">
          <source>Atomically exchanges the value in &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;newval&lt;/code&gt;. Returns the &lt;strong&gt;old&lt;/strong&gt; value.</source>
          <target state="translated">&lt;code&gt;newval&lt;/code&gt; значение в &lt;code&gt;x&lt;/code&gt; на newval . Возвращает &lt;strong&gt;старое&lt;/strong&gt; значение.</target>
        </trans-unit>
        <trans-unit id="c3d2e4b23d13f6bba7a47950035a93b86bb83a39" translate="yes" xml:space="preserve">
          <source>Atomically store the maximum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Атомарно сохранить максимум &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;val&lt;/code&gt; в &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df88790f08323bff2d950ce1c8f1b209a38e86ef" translate="yes" xml:space="preserve">
          <source>Atomically store the minimum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Атомно сохранить минимум &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;val&lt;/code&gt; в &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="689e84464421ff470b8dc38055180d25d70684c4" translate="yes" xml:space="preserve">
          <source>Atomically subtract &lt;code&gt;val&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Атомарно вычесть &lt;code&gt;val&lt;/code&gt; из &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a5910ec96daddf32d8679bdc1681e3d2b896833" translate="yes" xml:space="preserve">
          <source>Attempt an automatic merge rebase of the current branch, from &lt;code&gt;upstream&lt;/code&gt; if provided, or otherwise from the upstream tracking branch. &lt;code&gt;newbase&lt;/code&gt; is the branch to rebase onto. By default this is &lt;code&gt;upstream&lt;/code&gt;.</source>
          <target state="translated">Попытка автоматического слияния перебазирования текущей ветви из &lt;code&gt;upstream&lt;/code&gt; если оно предусмотрено, или иным образом из восходящей ветви отслеживания. &lt;code&gt;newbase&lt;/code&gt; - это ветка, на которую нужно перебазироваться. По умолчанию это &lt;code&gt;upstream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67fbdff1fd74a3e2ffeba20e52cb54a817a837a9" translate="yes" xml:space="preserve">
          <source>Aubergine</source>
          <target state="translated">Aubergine</target>
        </trans-unit>
        <trans-unit id="237f5a2b8d61f639bee4e8b48edc5e86ef3821ad" translate="yes" xml:space="preserve">
          <source>Auto-conversion:</source>
          <target state="translated">Auto-conversion:</target>
        </trans-unit>
        <trans-unit id="83f8ababd899b8c0947ef4217c49ed91a00e554d" translate="yes" xml:space="preserve">
          <source>Automated Teller Machine</source>
          <target state="translated">Автоматический автомат продавца</target>
        </trans-unit>
        <trans-unit id="d3ff4de6909c953084efbf3fcf51ba0455525196" translate="yes" xml:space="preserve">
          <source>Automatic generation of efficient, specialized code for different argument types</source>
          <target state="translated">Автоматическая генерация эффективного,специализированного кода для различных типов аргументов</target>
        </trans-unit>
        <trans-unit id="e3d0413f1114ca7420957b409369ba320c5e643a" translate="yes" xml:space="preserve">
          <source>Automobile</source>
          <target state="translated">Automobile</target>
        </trans-unit>
        <trans-unit id="c2381c9ae6de19786317e42c36cfe48f1d110cd4" translate="yes" xml:space="preserve">
          <source>Available for method extension</source>
          <target state="translated">Доступно для расширения метода</target>
        </trans-unit>
        <trans-unit id="1913fba71b8ad5575c96582256e93730389a751d" translate="yes" xml:space="preserve">
          <source>Avoid changing the type of a variable</source>
          <target state="translated">Избегайте изменения типа переменной</target>
        </trans-unit>
        <trans-unit id="491716d25d0cc5eef3fc083042b6cf3fb1c73628" translate="yes" xml:space="preserve">
          <source>Avoid confusion about whether something is an instance or a type</source>
          <target state="translated">Избегайте путаницы в том,является ли что-то примером или типом.</target>
        </trans-unit>
        <trans-unit id="f43c7e32c4f8af3884df62b42a58c3f06c2cb00b" translate="yes" xml:space="preserve">
          <source>Avoid containers with abstract type parameters</source>
          <target state="translated">Избегайте контейнеров с абстрактными параметрами типа</target>
        </trans-unit>
        <trans-unit id="a69832582d8c220962ec16f3f74807795126efb7" translate="yes" xml:space="preserve">
          <source>Avoid elaborate container types</source>
          <target state="translated">Избегайте сложных типов контейнеров</target>
        </trans-unit>
        <trans-unit id="5a42b7935afc0b3ec5008a2229ca382f69673505" translate="yes" xml:space="preserve">
          <source>Avoid fields with abstract containers</source>
          <target state="translated">Избегайте полей с абстрактными контейнерами</target>
        </trans-unit>
        <trans-unit id="f619d134c2c6942d7932e906b9ce6c23d632cfef" translate="yes" xml:space="preserve">
          <source>Avoid fields with abstract type</source>
          <target state="translated">Избегайте полей с абстрактным типом</target>
        </trans-unit>
        <trans-unit id="ea9c797001a229bb0f7e2e5dcae3538ba2a55b2c" translate="yes" xml:space="preserve">
          <source>Avoid global variables</source>
          <target state="translated">Избегайте глобальных переменных</target>
        </trans-unit>
        <trans-unit id="03b73d63c4cb77f3bf8c6e423749bbf23c01ee5d" translate="yes" xml:space="preserve">
          <source>Avoid strange type &lt;code&gt;Union&lt;/code&gt;s</source>
          <target state="translated">Избегайте странного типа &lt;code&gt;Union&lt;/code&gt; s</target>
        </trans-unit>
        <trans-unit id="79292115b6e992f614cf724c1dfa9586d06bbe03" translate="yes" xml:space="preserve">
          <source>Avoid string interpolation for I/O</source>
          <target state="translated">Избегайте строковой интерполяции для ввода/вывода</target>
        </trans-unit>
        <trans-unit id="8a11c76e8b2bd9a028ae58c6c15b510f4680d17f" translate="yes" xml:space="preserve">
          <source>Avoid type piracy</source>
          <target state="translated">Избегайте типового пиратства</target>
        </trans-unit>
        <trans-unit id="bf3ba609a722d28177b4a138e6e131e1148dc2ff" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary arrays. For example, instead of &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum([x,y,z])&lt;/code&gt;&lt;/a&gt; use &lt;code&gt;x+y+z&lt;/code&gt;.</source>
          <target state="translated">Избегайте ненужных массивов. Например, вместо &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum([x,y,z])&lt;/code&gt; &lt;/a&gt; используйте &lt;code&gt;x+y+z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9540041dc787b11f982141e4085503960ffd2c7" translate="yes" xml:space="preserve">
          <source>Avoid using floats for numeric literals in generic code when possible</source>
          <target state="translated">По возможности избегать использования флоатов для числовых литералов в общем коде.</target>
        </trans-unit>
        <trans-unit id="4802b2a45694be10a378fb271220844de2096707" translate="yes" xml:space="preserve">
          <source>Avoid using passwords in URLs. Unlike the credential objects, Julia is not able to securely zero or destroy the sensitive data after use and the password may remain in memory; possibly to be exposed by an uninitialized memory.</source>
          <target state="translated">Избегайте использования паролей в URL-адресах.В отличие от объектов мандатов,Джулия не может безопасно обнулить или уничтожить конфиденциальные данные после использования,а пароль может остаться в памяти;возможно,он будет открыт неинициализированной памятью.</target>
        </trans-unit>
        <trans-unit id="2371521c12f038f3e299464707c70bda3ff3e6b1" translate="yes" xml:space="preserve">
          <source>Avoid writing overly-specific types</source>
          <target state="translated">Избегайте слишком специфических видов письма</target>
        </trans-unit>
        <trans-unit id="5073587ca8bbf875c2d3d248119f4effa8701deb" translate="yes" xml:space="preserve">
          <source>Avoiding Deadlock in Pipelines</source>
          <target state="translated">Предотвращение тупика в трубопроводах</target>
        </trans-unit>
        <trans-unit id="65b99874e3a064ddb84e4d624ff070c43bf412eb" translate="yes" xml:space="preserve">
          <source>Avoiding changing the value of global variables is considered by many to be a programming best-practice. Changing the value of a global variable can cause &quot;action at a distance&quot;, making the behavior of a program harder to reason about. This is why the scope blocks that introduce local scope require the &lt;code&gt;global&lt;/code&gt; keyword to declare the intent to modify a global variable.</source>
          <target state="translated">Многие считают, что избегание изменения значений глобальных переменных является лучшей практикой программирования. Изменение значения глобальной переменной может вызвать &amp;laquo;действие на расстоянии&amp;raquo;, что затрудняет анализ поведения программы. Вот почему блоки области видимости, которые представляют локальную область видимости, требуют, чтобы ключевое слово &lt;code&gt;global&lt;/code&gt; объявляло намерение изменить глобальную переменную.</target>
        </trans-unit>
        <trans-unit id="5b00714b611fee1b5fd3b2b1cfc1708286a4e472" translate="yes" xml:space="preserve">
          <source>Avoiding globals</source>
          <target state="translated">Избегая шаров</target>
        </trans-unit>
        <trans-unit id="4e9ba62b391f99ca62e6bfebe5faa916e7ed0f96" translate="yes" xml:space="preserve">
          <source>Awad H. Al-Mohy and Nicholas J. Higham, &quot;Improved inverse scaling and squaring algorithms for the matrix logarithm&quot;, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. &lt;a href=&quot;https://doi.org/10.1137/110852553&quot;&gt;doi:10.1137/110852553&lt;/a&gt;</source>
          <target state="translated">Авад Х. Аль-Мохи и Николас Дж. Хайэм, &quot;Улучшенные алгоритмы обратного масштабирования и возведения в квадрат для матричного логарифма&quot;, SIAM Journal on Scientific Computing, 34 (4), 2012, C153-C169. &lt;a href=&quot;https://doi.org/10.1137/110852553&quot;&gt;DOI: 10,1137 / 110852553&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12401b9104fcd17aca879a9457a3f9b5a0090df6" translate="yes" xml:space="preserve">
          <source>Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, &quot;Computing the Fr&amp;eacute;chet derivative of the matrix logarithm and estimating the condition number&quot;, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. &lt;a href=&quot;https://doi.org/10.1137/120885991&quot;&gt;doi:10.1137/120885991&lt;/a&gt;</source>
          <target state="translated">Авад Х. Аль-Мохи, Николас Дж. Хайэм и Сэмюэл Д. Релтон, &amp;laquo;Вычисление производной Фреше матричного логарифма и оценка числа обусловленности&amp;raquo;, SIAM Journal on Scientific Computing, 35 (4), 2013, C394-C410. &lt;a href=&quot;https://doi.org/10.1137/120885991&quot;&gt;DOI: 10,1137 / 120885991&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6dad1f19392ce0b096b44b01c81c76a664e7337c" translate="yes" xml:space="preserve">
          <source>B&amp;eacute;zout coefficients are &lt;em&gt;not&lt;/em&gt; uniquely defined. &lt;code&gt;gcdx&lt;/code&gt; returns the minimal B&amp;eacute;zout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are minimal in the sense that $|u| &amp;lt; |y/d|$ and $|v| &amp;lt; |x/d|$. Furthermore, the signs of &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are chosen so that &lt;code&gt;d&lt;/code&gt; is positive. For unsigned integers, the coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; might be near their &lt;code&gt;typemax&lt;/code&gt;, and the identity then holds only via the unsigned integers' modulo arithmetic.</source>
          <target state="translated">Коэффициенты Безу &lt;em&gt;не&lt;/em&gt; определены однозначно. &lt;code&gt;gcdx&lt;/code&gt; возвращает минимальные коэффициенты Безу, которые вычисляются расширенным алгоритмом Евклида. (См. Д. Кнут, TAoCP, 2 / e, стр. 325, алгоритм X.) Для целых чисел со знаком эти коэффициенты &lt;code&gt;u&lt;/code&gt; и &lt;code&gt;v&lt;/code&gt; минимальны в том смысле, что $ | u | &amp;lt;| y / d | $ и $ | v | &amp;lt;| х / д | $. Кроме того, знаки &lt;code&gt;u&lt;/code&gt; и &lt;code&gt;v&lt;/code&gt; выбраны так, чтобы &lt;code&gt;d&lt;/code&gt; было положительным. Для целых чисел без знака коэффициенты &lt;code&gt;u&lt;/code&gt; и &lt;code&gt;v&lt;/code&gt; могут быть близки к их &lt;code&gt;typemax&lt;/code&gt; , и тогда идентичность сохраняется только через арифметику целых чисел без знака по модулю.</target>
        </trans-unit>
        <trans-unit id="0f4d56d1e20778bf2e1052ecb3219509238fb660" translate="yes" xml:space="preserve">
          <source>BD</source>
          <target state="translated">BD</target>
        </trans-unit>
        <trans-unit id="2868e5c7bf03fbd81359d6f8be00b333b386ffca" translate="yes" xml:space="preserve">
          <source>BLAS Character Arguments</source>
          <target state="translated">Аргументы о характере BLAS</target>
        </trans-unit>
        <trans-unit id="e299ffe232555a867fe66272d999c06385ea8b66" translate="yes" xml:space="preserve">
          <source>BLAS Functions</source>
          <target state="translated">BLAS-функции</target>
        </trans-unit>
        <trans-unit id="13c3d98d3a2445afc653d610809196ddb501f8c1" translate="yes" xml:space="preserve">
          <source>Baby</source>
          <target state="translated">Baby</target>
        </trans-unit>
        <trans-unit id="404344724dd01c5a65fcea59173146b18cd1b603" translate="yes" xml:space="preserve">
          <source>Baby Angel</source>
          <target state="translated">Маленький Ангел</target>
        </trans-unit>
        <trans-unit id="8b580757a627745bff29a8f25e39330265bdc27b" translate="yes" xml:space="preserve">
          <source>Baby Bottle</source>
          <target state="translated">Детская бутылочка</target>
        </trans-unit>
        <trans-unit id="459882191a5a45ebff1c155b876b56cf4eb8ef5e" translate="yes" xml:space="preserve">
          <source>Baby Chick</source>
          <target state="translated">Маленькая цыпочка</target>
        </trans-unit>
        <trans-unit id="1871c181df7f050df811e7ae71f7e0946094c40f" translate="yes" xml:space="preserve">
          <source>Baby Symbol</source>
          <target state="translated">Детский символ</target>
        </trans-unit>
        <trans-unit id="2867999045ac5ccc323dde4dccea9a973b94383f" translate="yes" xml:space="preserve">
          <source>Back With Leftwards Arrow Above</source>
          <target state="translated">Назад со стрелкой влево выше</target>
        </trans-unit>
        <trans-unit id="cc1f0103d6d9cbde7e99045cc49ad45fc083e009" translate="yes" xml:space="preserve">
          <source>Background and References</source>
          <target state="translated">Справочная информация и ссылки</target>
        </trans-unit>
        <trans-unit id="fc10601fec1e951e91f278b7b703a3337af22c80" translate="yes" xml:space="preserve">
          <source>Backslashes (&lt;code&gt;\&lt;/code&gt;) are escaped with a double-backslash (&lt;code&gt;&quot;\\&quot;&lt;/code&gt;). Non-printable characters are escaped either with their standard C escape codes, &lt;code&gt;&quot;\0&quot;&lt;/code&gt; for NUL (if unambiguous), unicode code point (&lt;code&gt;&quot;\u&quot;&lt;/code&gt; prefix) or hex (&lt;code&gt;&quot;\x&quot;&lt;/code&gt; prefix).</source>
          <target state="translated">Обратная косая черта ( &lt;code&gt;\&lt;/code&gt; ) экранируется двойной обратной косой чертой ( &lt;code&gt;&quot;\\&quot;&lt;/code&gt; ). Непечатаемые символы экранируются стандартными escape-кодами C, &lt;code&gt;&quot;\0&quot;&lt;/code&gt; для NUL (если однозначно), кодовой точкой Unicode ( префикс &lt;code&gt;&quot;\u&quot;&lt;/code&gt; ) или шестнадцатеричным ( префикс &lt;code&gt;&quot;\x&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6d4e3b07bbe1ccb3ac5b9922a337b1d4f919bc4f" translate="yes" xml:space="preserve">
          <source>Backspace, &lt;code&gt;^H&lt;/code&gt;</source>
          <target state="translated">Backspace, &lt;code&gt;^H&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6d84b04bcccd220267af9a3b46464c46ba45d26" translate="yes" xml:space="preserve">
          <source>Bactrian Camel</source>
          <target state="translated">Бактрианский верблюд</target>
        </trans-unit>
        <trans-unit id="447082b449cc1df13e5c0addef786ca50488ff0e" translate="yes" xml:space="preserve">
          <source>Baggage Claim</source>
          <target state="translated">претензия к багажу</target>
        </trans-unit>
        <trans-unit id="ebd009a68817c4cc14d70f9ca5aa28ad5c4de62a" translate="yes" xml:space="preserve">
          <source>Balance the matrix &lt;code&gt;A&lt;/code&gt; before computing its eigensystem or Schur factorization. &lt;code&gt;job&lt;/code&gt; can be one of &lt;code&gt;N&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will not be permuted or scaled), &lt;code&gt;P&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will only be permuted), &lt;code&gt;S&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will only be scaled), or &lt;code&gt;B&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will be both permuted and scaled). Modifies &lt;code&gt;A&lt;/code&gt; in-place and returns &lt;code&gt;ilo&lt;/code&gt;, &lt;code&gt;ihi&lt;/code&gt;, and &lt;code&gt;scale&lt;/code&gt;. If permuting was turned on, &lt;code&gt;A[i,j] = 0&lt;/code&gt; if &lt;code&gt;j &amp;gt; i&lt;/code&gt; and &lt;code&gt;1 &amp;lt; j &amp;lt; ilo&lt;/code&gt; or &lt;code&gt;j &amp;gt; ihi&lt;/code&gt;. &lt;code&gt;scale&lt;/code&gt; contains information about the scaling/permutations performed.</source>
          <target state="translated">Сбалансируйте матрицу &lt;code&gt;A&lt;/code&gt; перед вычислением ее собственной системы или факторизации Шура. &lt;code&gt;job&lt;/code&gt; может быть одним из &lt;code&gt;N&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; не будет переставляться или масштабироваться), &lt;code&gt;P&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; будет только переставляться), &lt;code&gt;S&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; будет только масштабироваться) или &lt;code&gt;B&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; будет и переставляться, и масштабироваться). Изменяет &lt;code&gt;A&lt;/code&gt; на месте и возвращает &lt;code&gt;ilo&lt;/code&gt; , &lt;code&gt;ihi&lt;/code&gt; и &lt;code&gt;scale&lt;/code&gt; . Если перестановка была включена, &lt;code&gt;A[i,j] = 0&lt;/code&gt; если &lt;code&gt;j &amp;gt; i&lt;/code&gt; и &lt;code&gt;1 &amp;lt; j &amp;lt; ilo&lt;/code&gt; или &lt;code&gt;j &amp;gt; ihi&lt;/code&gt; . &lt;code&gt;scale&lt;/code&gt; содержит информацию о выполненном масштабировании / перестановках.</target>
        </trans-unit>
        <trans-unit id="64f241f5415d400e3d7d028f504e941ebbdb9386" translate="yes" xml:space="preserve">
          <source>Balloon</source>
          <target state="translated">Balloon</target>
        </trans-unit>
        <trans-unit id="a5ae768a2f5127a27b546388e40cac06994c9b36" translate="yes" xml:space="preserve">
          <source>Ballot Box With Check</source>
          <target state="translated">Коробка для голосования с чеком</target>
        </trans-unit>
        <trans-unit id="fc6fae10db2bd0b625077d7c6d1b9a96925fd2b7" translate="yes" xml:space="preserve">
          <source>Banana</source>
          <target state="translated">Banana</target>
        </trans-unit>
        <trans-unit id="9e89988cc3fba2850fb19459e04e7b3325be4f84" translate="yes" xml:space="preserve">
          <source>Bank</source>
          <target state="translated">Bank</target>
        </trans-unit>
        <trans-unit id="ef4f81080d95142c3db9938d48a26e8efe95cd36" translate="yes" xml:space="preserve">
          <source>Banknote With Dollar Sign</source>
          <target state="translated">Купюра с долларовым знаком</target>
        </trans-unit>
        <trans-unit id="3177af01daaed29235d1e99ba9255338076b9f27" translate="yes" xml:space="preserve">
          <source>Banknote With Euro Sign</source>
          <target state="translated">Купюра со знаком евро</target>
        </trans-unit>
        <trans-unit id="3a6546fb8ecf3af86528410e140549606f1d3249" translate="yes" xml:space="preserve">
          <source>Banknote With Pound Sign</source>
          <target state="translated">Купюра с фунтом знака</target>
        </trans-unit>
        <trans-unit id="63a28a516e785c09b112a71c85ad02804c64137a" translate="yes" xml:space="preserve">
          <source>Banknote With Yen Sign</source>
          <target state="translated">Купюра с иенской подписью</target>
        </trans-unit>
        <trans-unit id="75fe8df5591aba61913518914c1f05bdb42306e6" translate="yes" xml:space="preserve">
          <source>Bar Chart</source>
          <target state="translated">Бар-график</target>
        </trans-unit>
        <trans-unit id="bddd12f808af35a2e999d9124c970232527e7e1d" translate="yes" xml:space="preserve">
          <source>Barber Pole</source>
          <target state="translated">парикмахерские поляки</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="2aa4376a2de743967992b5357971a1c7721c03e3" translate="yes" xml:space="preserve">
          <source>Base Submodules</source>
          <target state="translated">Базовые субмодули</target>
        </trans-unit>
        <trans-unit id="895c330ff6166a7f13701f8d9b78f313787269c8" translate="yes" xml:space="preserve">
          <source>Base64</source>
          <target state="translated">Base64</target>
        </trans-unit>
        <trans-unit id="ec2d7744c603baf507e66bf82835dfb6204656a8" translate="yes" xml:space="preserve">
          <source>Baseball</source>
          <target state="translated">Baseball</target>
        </trans-unit>
        <trans-unit id="bf046bc3c151c25669b6483d54157a9641394a6d" translate="yes" xml:space="preserve">
          <source>Based on this observation, we can conclude that if one of the operands is &lt;code&gt;true&lt;/code&gt; and the other &lt;code&gt;missing&lt;/code&gt;, we know that the result is &lt;code&gt;true&lt;/code&gt; in spite of the uncertainty about the actual value of one of the operands. If we had been able to observe the actual value of the second operand, it could only be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, and in both cases the result would be &lt;code&gt;true&lt;/code&gt;. Therefore, in this particular case, missingness does &lt;em&gt;not&lt;/em&gt; propagate</source>
          <target state="translated">Основываясь на этом наблюдении, мы можем сделать вывод, что если один из операндов &lt;code&gt;true&lt;/code&gt; а другой &lt;code&gt;missing&lt;/code&gt; , мы знаем, что результат &lt;code&gt;true&lt;/code&gt; несмотря на неопределенность фактического значения одного из операндов. Если бы мы могли наблюдать фактическое значение второго операнда, оно могло бы быть только &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; , и в обоих случаях результат был бы &lt;code&gt;true&lt;/code&gt; . Следовательно, в данном конкретном случае отсутствие &lt;em&gt;не&lt;/em&gt; распространяется.</target>
        </trans-unit>
        <trans-unit id="c01a71bb934cc266c2f79a70a4a484bfb32292d0" translate="yes" xml:space="preserve">
          <source>Basic Functions</source>
          <target state="translated">Основные функции</target>
        </trans-unit>
        <trans-unit id="aeb63e6ce576503861f1c499cfdf84cff87567db" translate="yes" xml:space="preserve">
          <source>Basic Stream I/O</source>
          <target state="translated">Базовый вход/выход потока</target>
        </trans-unit>
        <trans-unit id="f9e89ba8027afc2d4c24183a1cbbfbb04137326a" translate="yes" xml:space="preserve">
          <source>Basic Unit Tests</source>
          <target state="translated">Испытания базовых блоков</target>
        </trans-unit>
        <trans-unit id="58c96a6812d6bac9777029dd40fb7e6afd5c8c94" translate="yes" xml:space="preserve">
          <source>Basic functions</source>
          <target state="translated">Основные функции</target>
        </trans-unit>
        <trans-unit id="24be2e19e7e4671eaee4ac0a6f5a6a524bab3529" translate="yes" xml:space="preserve">
          <source>Basic tables can be written using the syntax described below. Note that markdown tables have limited features and cannot contain nested toplevel elements unlike other elements discussed above &amp;ndash; only inline elements are allowed. Tables must always contain a header row with column names. Cells cannot span multiple rows or columns of the table.</source>
          <target state="translated">Базовые таблицы могут быть написаны с использованием синтаксиса, описанного ниже. Обратите внимание, что таблицы уценки имеют ограниченные возможности и не могут содержать вложенные элементы верхнего уровня, в отличие от других элементов, рассмотренных выше - разрешены только встроенные элементы. Таблицы всегда должны содержать строку заголовка с именами столбцов. Ячейки не могут занимать несколько строк или столбцов таблицы.</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">Основное использование</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="25cdb3adf0a06c600dd49fc47c73f5654e3fddf0" translate="yes" xml:space="preserve">
          <source>Basketball And Hoop</source>
          <target state="translated">Баскетбол и Хуп</target>
        </trans-unit>
        <trans-unit id="a687b3ff7f182c39a1247454d3d7927ea0efa80d" translate="yes" xml:space="preserve">
          <source>Bath</source>
          <target state="translated">Bath</target>
        </trans-unit>
        <trans-unit id="24f0469ed67f7f88a5ef12c0cd27feac4f206fb4" translate="yes" xml:space="preserve">
          <source>Bathtub</source>
          <target state="translated">Bathtub</target>
        </trans-unit>
        <trans-unit id="4a9be042afe6257111a01c05b72af9f1f3015176" translate="yes" xml:space="preserve">
          <source>Battery</source>
          <target state="translated">Battery</target>
        </trans-unit>
        <trans-unit id="d363e26ebe520321aa01d471833fdb370bebd1b2" translate="yes" xml:space="preserve">
          <source>Be aware of when a macro could really be a function instead.</source>
          <target state="translated">Помните,когда макрос действительно может быть функцией.</target>
        </trans-unit>
        <trans-unit id="24c70535563b2fda1a64503b874c826edb8884cf" translate="yes" xml:space="preserve">
          <source>Be aware that this strategy has at least one major disadvantage: in many cases, it is not possible for users to further customize the behavior of &lt;code&gt;f&lt;/code&gt; by defining further specializations of your exported function &lt;code&gt;f&lt;/code&gt;. Instead, they have to define specializations for your internal methods &lt;code&gt;_fA&lt;/code&gt; and &lt;code&gt;_fB&lt;/code&gt;, and this blurs the lines between exported and internal methods.</source>
          <target state="translated">Имейте в виду, что эта стратегия имеет по крайней мере один серьезный недостаток: во многих случаях пользователи не могут дополнительно настроить поведение &lt;code&gt;f&lt;/code&gt; путем определения дополнительных специализаций вашей экспортируемой функции &lt;code&gt;f&lt;/code&gt; . Вместо этого они должны определить специализации для ваших внутренних методов &lt;code&gt;_fA&lt;/code&gt; и &lt;code&gt;_fB&lt;/code&gt; , и это стирает границы между экспортируемыми и внутренними методами.</target>
        </trans-unit>
        <trans-unit id="9beb1443ec7c795007b178f28f0ce7235335f46d" translate="yes" xml:space="preserve">
          <source>Be careful to ensure that a Julia reference to &lt;code&gt;x&lt;/code&gt; exists as long as the result of this function will be used. Accordingly, the argument &lt;code&gt;x&lt;/code&gt; to this function should never be an expression, only a variable name or field reference. For example, &lt;code&gt;x=a.b.c&lt;/code&gt; is acceptable, but &lt;code&gt;x=[a,b,c]&lt;/code&gt; is not.</source>
          <target state="translated">Будьте осторожны и убедитесь, что ссылка Julia на &lt;code&gt;x&lt;/code&gt; существует до тех пор, пока будет использоваться результат этой функции. Соответственно, аргумент &lt;code&gt;x&lt;/code&gt; этой функции никогда не должен быть выражением, а только именем переменной или ссылкой на поле. Например, &lt;code&gt;x=a.b.c&lt;/code&gt; приемлемо, а &lt;code&gt;x=[a,b,c]&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="5cb87858674ab3ef5b1beab58a7148fcb802f60e" translate="yes" xml:space="preserve">
          <source>Be careful with type equality</source>
          <target state="translated">Будьте осторожны с типом равенства</target>
        </trans-unit>
        <trans-unit id="8bfb6bdbe4ae64df10562422552d5b22da6f47fc" translate="yes" xml:space="preserve">
          <source>Beamed Eighth Notes / Barred Eighth Notes</source>
          <target state="translated">Восьмые ноты с лучами/Запрещенные восемь нот</target>
        </trans-unit>
        <trans-unit id="c8d8cb92fc4cef48d0b0c66441f7a0ef79489b94" translate="yes" xml:space="preserve">
          <source>Bear Face</source>
          <target state="translated">Медвежье лицо</target>
        </trans-unit>
        <trans-unit id="aa8c1d8ab7be7fc9804d2a597a6630cb0b4cde3e" translate="yes" xml:space="preserve">
          <source>Beating Heart</source>
          <target state="translated">Бьющееся сердце</target>
        </trans-unit>
        <trans-unit id="eaebe47425c9f545a41d705608612a34bef824ca" translate="yes" xml:space="preserve">
          <source>Because</source>
          <target state="translated">Because</target>
        </trans-unit>
        <trans-unit id="3b0620b59c6d57d025b388d048ef8892a00c82a2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;a&lt;/code&gt; is a an array of abstract type &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt;, it must be able to hold any &lt;code&gt;Real&lt;/code&gt; value. Since &lt;code&gt;Real&lt;/code&gt; objects can be of arbitrary size and structure, &lt;code&gt;a&lt;/code&gt; must be represented as an array of pointers to individually allocated &lt;code&gt;Real&lt;/code&gt; objects. However, if we instead only allow numbers of the same type, e.g. &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, to be stored in &lt;code&gt;a&lt;/code&gt; these can be stored more efficiently:</source>
          <target state="translated">Поскольку &lt;code&gt;a&lt;/code&gt; является массивом абстрактного типа &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; , он должен содержать любое значение &lt;code&gt;Real&lt;/code&gt; . Так как &lt;code&gt;Real&lt;/code&gt; объекты могут иметь произвольный размер и структуру, должен быть представлен в виде массива указателей на индивидуально выделенных &lt;code&gt;Real&lt;/code&gt; объектов. Однако, если мы вместо этого разрешаем хранить в &lt;code&gt;a&lt;/code&gt; только числа одного типа, например &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; , их можно будет хранить более эффективно: &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9408c8b817a5e76474fc2023c5d1c8f64eadcc39" translate="yes" xml:space="preserve">
          <source>Because C doesn't support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, you need to first encapsulate the value inside a &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref{T}&lt;/code&gt;&lt;/a&gt; of the appropriate type. When you pass this &lt;code&gt;Ref&lt;/code&gt; object as an argument, Julia will automatically pass a C pointer to the encapsulated data:</source>
          <target state="translated">Поскольку C не поддерживает несколько возвращаемых значений, часто функции C принимают указатели на данные, которые функция будет изменять. Чтобы выполнить это в &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; , вам нужно сначала инкапсулировать значение в &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref{T}&lt;/code&gt; &lt;/a&gt; соответствующего типа. Когда вы передаете этот объект &lt;code&gt;Ref&lt;/code&gt; в качестве аргумента, Джулия автоматически передает указатель C на инкапсулированные данные:</target>
        </trans-unit>
        <trans-unit id="46c2c088cdd51f72db20e5f94b9c484cd07ee1a5" translate="yes" xml:space="preserve">
          <source>Because Julia's compiler is different from the interpreters used for languages like Python or R, you may find that Julia's performance is unintuitive at first. If you find that something is slow, we highly recommend reading through the &lt;a href=&quot;manual/performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt; section before trying anything else. Once you understand how Julia works, it's easy to write code that's nearly as fast as C.</source>
          <target state="translated">Поскольку компилятор Джулии отличается от интерпретаторов, используемых для таких языков, как Python или R, вы можете обнаружить, что производительность Джулии поначалу не интуитивна. Если вы обнаружите, что что-то работает медленно, мы настоятельно рекомендуем прочитать раздел &amp;laquo; &lt;a href=&quot;manual/performance-tips/index#man-performance-tips-1&quot;&gt;Советы&lt;/a&gt; по производительности &amp;raquo;, прежде чем пробовать что-либо еще. Как только вы поймете, как работает Джулия, легко написать код, который почти так же быстр, как C.</target>
        </trans-unit>
        <trans-unit id="d57b0f43957e0dd94a3628a775697cb33089c39f" translate="yes" xml:space="preserve">
          <source>Because of these shared properties, these types are internally represented as instances of the same concept, &lt;code&gt;DataType&lt;/code&gt;, which is the type of any of these types:</source>
          <target state="translated">Из-за этих общих свойств эти типы внутренне представлены как экземпляры одной и той же концепции &lt;code&gt;DataType&lt;/code&gt; , которая является типом любого из этих типов:</target>
        </trans-unit>
        <trans-unit id="42b7af0f4b58f310d2c30a12b918265991dec35c" translate="yes" xml:space="preserve">
          <source>Because of variable-length encodings, the number of characters in a string (given by &lt;code&gt;length(s)&lt;/code&gt;) is not always the same as the last index. If you iterate through the indices 1 through &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex(s)&lt;/code&gt;&lt;/a&gt; and index into &lt;code&gt;s&lt;/code&gt;, the sequence of characters returned when errors aren't thrown is the sequence of characters comprising the string &lt;code&gt;s&lt;/code&gt;. Thus we have the identity that &lt;code&gt;length(s) &amp;lt;= lastindex(s)&lt;/code&gt;, since each character in a string must have its own index. The following is an inefficient and verbose way to iterate through the characters of &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">Из-за кодирования переменной длины количество символов в строке (заданное &lt;code&gt;length(s)&lt;/code&gt; ) не всегда совпадает с последним индексом. Если вы перебираете индексы с 1 по &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt; &lt;code&gt;lastindex(s)&lt;/code&gt; &lt;/a&gt; и индексируете в &lt;code&gt;s&lt;/code&gt; , последовательность символов, возвращаемая, когда ошибки не возникают, представляет собой последовательность символов, составляющих строку &lt;code&gt;s&lt;/code&gt; . Таким образом, у нас есть тождество, которое &lt;code&gt;length(s) &amp;lt;= lastindex(s)&lt;/code&gt; , поскольку каждый символ в строке должен иметь свой собственный индекс. Ниже приводится неэффективный и подробный способ перебора символов &lt;code&gt;s&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="757a38ed122bb8b64391606ad821806f34182e36" translate="yes" xml:space="preserve">
          <source>Because supporting generic programming is deemed more important than potential performance optimizations that can be achieved by other means (e.g., using explicit loops), operators like &lt;code&gt;+=&lt;/code&gt; and &lt;code&gt;*=&lt;/code&gt; work by rebinding new values.</source>
          <target state="translated">Поскольку поддержка общего программирования считается более важной, чем потенциальная оптимизация производительности, которая может быть достигнута другими способами (например, с использованием явных циклов), такие операторы, как &lt;code&gt;+=&lt;/code&gt; и &lt;code&gt;*=&lt;/code&gt; , работают путем повторного связывания новых значений.</target>
        </trans-unit>
        <trans-unit id="b50e23d2e501ab3f771dc2f5a71cc510c1b86367" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; types are stored as single &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; values, date parts or fields can be retrieved through accessor functions. The lowercase accessors return the field as an integer:</source>
          <target state="translated">Поскольку типы &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; хранятся как отдельные значения &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; , части даты или поля могут быть получены с помощью функций доступа. Методы доступа в нижнем регистре возвращают поле как целое число:</target>
        </trans-unit>
        <trans-unit id="bc4c89911afb2810477bab2fec0bf376b9a4f915" translate="yes" xml:space="preserve">
          <source>Because the compiler knows that integer addition and multiplication are associative and that multiplication distributes over addition &amp;ndash; neither of which is true of saturating arithmetic &amp;ndash; it can optimize the entire loop down to just a multiply and an add. Saturated arithmetic completely defeats this kind of optimization since associativity and distributivity can fail at each loop iteration, causing different outcomes depending on which iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple operations into fewer equivalent operations.</source>
          <target state="translated">Поскольку компилятор знает, что целочисленное сложение и умножение являются ассоциативными и что умножение распределяется по сложению - ни одно из этих условий не относится к арифметике с насыщением, - он может оптимизировать весь цикл до простого умножения и сложения. Насыщенная арифметика полностью исключает этот вид оптимизации, поскольку ассоциативность и распределительность могут давать сбой на каждой итерации цикла, вызывая разные результаты в зависимости от того, на какой итерации произошел сбой. Компилятор может развернуть цикл, но не может алгебраически сократить несколько операций до меньшего числа эквивалентных операций.</target>
        </trans-unit>
        <trans-unit id="b3a8e98adc86bd54f822093e18075fecd0592176" translate="yes" xml:space="preserve">
          <source>Because the operator &lt;code&gt;^&lt;/code&gt; has higher precedence than &lt;code&gt;*&lt;/code&gt; (see &lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity-1&quot;&gt;Operator Precedence and Associativity&lt;/a&gt;), this output does not faithfully represent the expression &lt;code&gt;a ^ 2&lt;/code&gt; which should be equal to &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt;. To solve this issue, we must make a custom method for &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt;, which is called internally by the expression object when printing:</source>
          <target state="translated">Поскольку оператор &lt;code&gt;^&lt;/code&gt; имеет более высокий приоритет, чем &lt;code&gt;*&lt;/code&gt; (см. &lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity-1&quot;&gt;Приоритет операторов и ассоциативность&lt;/a&gt; ), этот вывод не точно представляет выражение &lt;code&gt;a ^ 2&lt;/code&gt; , которое должно быть равно &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt; . Чтобы решить эту проблему, мы должны создать собственный метод для &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt; , который вызывается внутри объекта выражения при печати:</target>
        </trans-unit>
        <trans-unit id="ae99b1d876ba3cfdc461cae08478806ff8d8ca63" translate="yes" xml:space="preserve">
          <source>Beer Mug</source>
          <target state="translated">Пивная кружка</target>
        </trans-unit>
        <trans-unit id="5672f13a1da17dc7ad6970da457803cdfb5de94c" translate="yes" xml:space="preserve">
          <source>Before Julia 1.2 this signature was restricted to &lt;code&gt;f::Function&lt;/code&gt;.</source>
          <target state="translated">До Julia 1.2 эта подпись была ограничена &lt;code&gt;f::Function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebd25c6fc66535562035f061458e887115328bc8" translate="yes" xml:space="preserve">
          <source>Before running Julia set the environment variable &lt;code&gt;ENABLE_JITPROFILING&lt;/code&gt; to 1.</source>
          <target state="translated">Перед запуском Джулии установите для переменной среды &lt;code&gt;ENABLE_JITPROFILING&lt;/code&gt; значение 1.</target>
        </trans-unit>
        <trans-unit id="0dc928d36409cbb3c824f1591ba22fe5ec9e9dd8" translate="yes" xml:space="preserve">
          <source>Before the execution of the body of a &lt;code&gt;@testset&lt;/code&gt;, there is an implicit call to &lt;code&gt;Random.seed!(seed)&lt;/code&gt; where &lt;code&gt;seed&lt;/code&gt; is the current seed of the global RNG. Moreover, after the execution of the body, the state of the global RNG is restored to what it was before the &lt;code&gt;@testset&lt;/code&gt;. This is meant to ease reproducibility in case of failure, and to allow seamless re-arrangements of &lt;code&gt;@testset&lt;/code&gt;s regardless of their side-effect on the global RNG state.</source>
          <target state="translated">Перед выполнением тела &lt;code&gt;@testset&lt;/code&gt; существует неявный вызов &lt;code&gt;Random.seed!(seed)&lt;/code&gt; где &lt;code&gt;seed&lt;/code&gt; - это текущее начальное значение глобального ГСЧ. Более того, после выполнения тела состояние глобального ГСЧ восстанавливается до того, что было до &lt;code&gt;@testset&lt;/code&gt; . Это предназначено для облегчения воспроизводимости в случае сбоя и обеспечения возможности бесшовной перекомпоновки &lt;code&gt;@testset&lt;/code&gt; независимо от их побочного эффекта на глобальное состояние ГСЧ.</target>
        </trans-unit>
        <trans-unit id="e1451b7dd9bc69e125d61828d9b5cab1b14b61ea" translate="yes" xml:space="preserve">
          <source>Before the program terminates, it is strongly recommended to call &lt;code&gt;jl_atexit_hook&lt;/code&gt;. The above example program calls this before returning from &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">Перед завершением программы настоятельно рекомендуется вызвать &lt;code&gt;jl_atexit_hook&lt;/code&gt; . В приведенном выше примере программа вызывает это перед возвратом из &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b5e33825f4e17f1ad04b807863fc5ef1363c528" translate="yes" xml:space="preserve">
          <source>Behaves like a &lt;code&gt;Ptr{T}&lt;/code&gt; that can manage its memory via the Julia GC.</source>
          <target state="translated">Ведет себя как &lt;code&gt;Ptr{T}&lt;/code&gt; который может управлять своей памятью через Julia GC.</target>
        </trans-unit>
        <trans-unit id="e09863e9196cd18ccb74a5a4e0f5e83a34c2821d" translate="yes" xml:space="preserve">
          <source>Behaves like applying &lt;code&gt;n&lt;/code&gt; times &lt;code&gt;nextind&lt;/code&gt; for &lt;code&gt;n==1&lt;/code&gt;. The only difference is that if &lt;code&gt;n&lt;/code&gt; is so large that applying &lt;code&gt;nextind&lt;/code&gt; would reach &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; then each remaining iteration increases the returned value by &lt;code&gt;1&lt;/code&gt;. This means that in this case &lt;code&gt;nextind&lt;/code&gt; can return a value greater than &lt;code&gt;ncodeunits(str)+1&lt;/code&gt;.</source>
          <target state="translated">Аналогично применению &lt;code&gt;n&lt;/code&gt; раз &lt;code&gt;nextind&lt;/code&gt; для &lt;code&gt;n==1&lt;/code&gt; . Единственное отличие состоит в том, что если &lt;code&gt;n&lt;/code&gt; настолько велико, что применение &lt;code&gt;nextind&lt;/code&gt; достигнет &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; тогда каждая оставшаяся итерация увеличивает возвращаемое значение на &lt;code&gt;1&lt;/code&gt; . Это означает, что в этом случае &lt;code&gt;nextind&lt;/code&gt; может вернуть значение больше &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2b1b1654cc55316ed5e2b35c84126cef980b48d" translate="yes" xml:space="preserve">
          <source>Behaves like applying &lt;code&gt;n&lt;/code&gt; times &lt;code&gt;prevind&lt;/code&gt; for &lt;code&gt;n==1&lt;/code&gt;. The only difference is that if &lt;code&gt;n&lt;/code&gt; is so large that applying &lt;code&gt;prevind&lt;/code&gt; would reach &lt;code&gt;0&lt;/code&gt; then each remaining iteration decreases the returned value by &lt;code&gt;1&lt;/code&gt;. This means that in this case &lt;code&gt;prevind&lt;/code&gt; can return a negative value.</source>
          <target state="translated">Ведет себя как применение &lt;code&gt;n&lt;/code&gt; раз &lt;code&gt;prevind&lt;/code&gt; для &lt;code&gt;n==1&lt;/code&gt; . Единственное отличие состоит в том, что если &lt;code&gt;n&lt;/code&gt; настолько велико, что применение &lt;code&gt;prevind&lt;/code&gt; достигнет &lt;code&gt;0&lt;/code&gt; , тогда каждая оставшаяся итерация уменьшает возвращаемое значение на &lt;code&gt;1&lt;/code&gt; . Это означает, что в этом случае &lt;code&gt;prevind&lt;/code&gt; может вернуть отрицательное значение.</target>
        </trans-unit>
        <trans-unit id="d4198662a72fd519a4f968a74051bafac710dc07" translate="yes" xml:space="preserve">
          <source>Bell</source>
          <target state="translated">Bell</target>
        </trans-unit>
        <trans-unit id="bbab278669c1eda7fe0bdb1650c9fd25169b898f" translate="yes" xml:space="preserve">
          <source>Bell With Cancellation Stroke</source>
          <target state="translated">Колокол с Аннулирующим Ходом</target>
        </trans-unit>
        <trans-unit id="94add7afb4e17fd6f1526d2edfd18924f6fd72ab" translate="yes" xml:space="preserve">
          <source>Below is an example where subnormals noticeably impact performance on some hardware:</source>
          <target state="translated">Ниже приведен пример,когда субнормалы заметно влияют на производительность некоторых аппаратных средств:</target>
        </trans-unit>
        <trans-unit id="58c2a686d8a6b7d42c702706aa646004223a601b" translate="yes" xml:space="preserve">
          <source>Below we discuss particular challenges and some alternative ways to resolve such issues.</source>
          <target state="translated">Ниже мы обсудим конкретные проблемы и некоторые альтернативные пути их решения.</target>
        </trans-unit>
        <trans-unit id="e6be4001a8d2924783c806798a0e30c2803a6922" translate="yes" xml:space="preserve">
          <source>Bento Box</source>
          <target state="translated">Бенто Бокс</target>
        </trans-unit>
        <trans-unit id="3f0f29bd74024b1bd9eec443c00d50257286a7db" translate="yes" xml:space="preserve">
          <source>Benzene Ring</source>
          <target state="translated">Бензольное кольцо</target>
        </trans-unit>
        <trans-unit id="c667600d6a843f35f26780da4256a01e9f67553a" translate="yes" xml:space="preserve">
          <source>Benzene Ring With Circle</source>
          <target state="translated">Бензольное кольцо с кругом</target>
        </trans-unit>
        <trans-unit id="79faabb26deabd43b3e790cb4753636cfebf2e58" translate="yes" xml:space="preserve">
          <source>Besides being used for the &lt;a href=&quot;../../base/constants/index#Base.VERSION&quot;&gt;&lt;code&gt;VERSION&lt;/code&gt;&lt;/a&gt; constant, &lt;code&gt;VersionNumber&lt;/code&gt; objects are widely used in the &lt;code&gt;Pkg&lt;/code&gt; module, to specify packages versions and their dependencies.</source>
          <target state="translated">Помимо использования для константы &lt;a href=&quot;../../base/constants/index#Base.VERSION&quot;&gt; &lt;code&gt;VERSION&lt;/code&gt; &lt;/a&gt; , объекты &lt;code&gt;VersionNumber&lt;/code&gt; широко используются в модуле &lt;code&gt;Pkg&lt;/code&gt; для указания версий пакетов и их зависимостей.</target>
        </trans-unit>
        <trans-unit id="4c077965afc4d3ad848734d7192dc33685665fb8" translate="yes" xml:space="preserve">
          <source>Bet Symbol / Second Transfinite Cardinal</source>
          <target state="translated">Символ ставки/Второй кардинал перевода денег</target>
        </trans-unit>
        <trans-unit id="1b22feb0c0c13c69ebe6389111ff7312bd0c946b" translate="yes" xml:space="preserve">
          <source>Between</source>
          <target state="translated">Between</target>
        </trans-unit>
        <trans-unit id="4e83ab72f5680a7927bc2ee1770585b538110359" translate="yes" xml:space="preserve">
          <source>Bicycle</source>
          <target state="translated">Bicycle</target>
        </trans-unit>
        <trans-unit id="af44c67fc560bdac204e3457136721b15282deb9" translate="yes" xml:space="preserve">
          <source>Bicyclist</source>
          <target state="translated">Bicyclist</target>
        </trans-unit>
        <trans-unit id="ca17e7c02d8603afa7449be022da99c068361156" translate="yes" xml:space="preserve">
          <source>Bidiagonal</source>
          <target state="translated">Bidiagonal</target>
        </trans-unit>
        <trans-unit id="f0830adbb847a3826b894a8d2b1be1aa3648828e" translate="yes" xml:space="preserve">
          <source>BigFloats and BigInts</source>
          <target state="translated">БигФлоуты и БигИнты</target>
        </trans-unit>
        <trans-unit id="aacc2899433eb85e7a2394fe9113a636959564b2" translate="yes" xml:space="preserve">
          <source>Bikini</source>
          <target state="translated">Bikini</target>
        </trans-unit>
        <trans-unit id="aaaa53539dc3641fca1eac5e64bf0cba011ff6e3" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;). Column-permutation &lt;code&gt;q&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s column count (&lt;code&gt;length(q) == A.n&lt;/code&gt;). Row-permutation &lt;code&gt;p&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s row count (&lt;code&gt;length(p) == A.m&lt;/code&gt;).</source>
          <target state="translated">Двусторонняя перестановка &lt;code&gt;A&lt;/code&gt; , возвращая &lt;code&gt;PAQ&lt;/code&gt; ( &lt;code&gt;A[p,q]&lt;/code&gt; ). Длина перестановки столбцов &lt;code&gt;q&lt;/code&gt; должна соответствовать количеству столбцов &lt;code&gt;A&lt;/code&gt; ( &lt;code&gt;length(q) == A.n&lt;/code&gt; ). Длина перестановки строк &lt;code&gt;p&lt;/code&gt; должна соответствовать количеству строк &lt;code&gt;A&lt;/code&gt; ( &lt;code&gt;length(p) == A.m&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aa67c0c72b73769483142d524a72dd00b47e7280" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, storing result &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;) in &lt;code&gt;X&lt;/code&gt;. Stores intermediate result &lt;code&gt;(AQ)^T&lt;/code&gt; (&lt;code&gt;transpose(A[:,q])&lt;/code&gt;) in optional argument &lt;code&gt;C&lt;/code&gt; if present. Requires that none of &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, and, if present, &lt;code&gt;C&lt;/code&gt; alias each other; to store result &lt;code&gt;PAQ&lt;/code&gt; back into &lt;code&gt;A&lt;/code&gt;, use the following method lacking &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">Переставляют на двусторонней основе , сохранения результата &lt;code&gt;PAQ&lt;/code&gt; ( &lt;code&gt;A[p,q]&lt;/code&gt; ) в &lt;code&gt;X&lt;/code&gt; . Сохраняет промежуточный результат &lt;code&gt;(AQ)^T&lt;/code&gt; ( &lt;code&gt;transpose(A[:,q])&lt;/code&gt; ) в необязательном аргументе &lt;code&gt;C&lt;/code&gt; , если он присутствует. Требует, чтобы ни один из &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; и, если присутствует, &lt;code&gt;C&lt;/code&gt; не являлся псевдонимом друг друга; чтобы сохранить результат &lt;code&gt;PAQ&lt;/code&gt; обратно в &lt;code&gt;A&lt;/code&gt; , используйте следующий метод без &lt;code&gt;X&lt;/code&gt; : &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c4f1f960deffd3639bacc943d7beee3c049657a" translate="yes" xml:space="preserve">
          <source>Billiards</source>
          <target state="translated">Billiards</target>
        </trans-unit>
        <trans-unit id="6a9a9dae508a5a43298d0ecf022071a0f6818999" translate="yes" xml:space="preserve">
          <source>Binary (or unary) operators like &lt;code&gt;.+&lt;/code&gt; are handled with the same mechanism: they are equivalent to &lt;code&gt;broadcast&lt;/code&gt; calls and are fused with other nested &quot;dot&quot; calls. &lt;code&gt;X .+= Y&lt;/code&gt; etcetera is equivalent to &lt;code&gt;X .= X .+ Y&lt;/code&gt; and results in a fused in-place assignment; see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot operators&lt;/a&gt;.</source>
          <target state="translated">Бинарные (или унарные) операторы, такие как &lt;code&gt;.+&lt;/code&gt; , Обрабатываются одним и тем же механизмом: они эквивалентны &lt;code&gt;broadcast&lt;/code&gt; вызовам и объединяются с другими вложенными вызовами &amp;laquo;точки&amp;raquo;. &lt;code&gt;X .+= Y&lt;/code&gt; и т.д. эквивалентно &lt;code&gt;X .= X .+ Y&lt;/code&gt; и приводит к слитному назначению на месте; см. также &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;точечные операторы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a754b43c5cd6bc6c82c954daabe8d0dd0d9ab2bb" translate="yes" xml:space="preserve">
          <source>Binary and octal literals are also supported:</source>
          <target state="translated">Также поддерживаются двоичные и восьмеричные буквы:</target>
        </trans-unit>
        <trans-unit id="f84a08f5fd91d8b683f66ada3a3f0d37dd8d9416" translate="yes" xml:space="preserve">
          <source>Binary arithmetic &amp;ndash; &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;</source>
          <target state="translated">Двоичная арифметика - &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08e24dd0237ae9c6c248482e7cdae84d6dd71aee" translate="yes" xml:space="preserve">
          <source>Binary, octal, and hexadecimal literals may be signed by a &lt;code&gt;-&lt;/code&gt; immediately preceding the unsigned literal. They produce an unsigned integer of the same size as the unsigned literal would do, with the two's complement of the value:</source>
          <target state="translated">Двоичные, восьмеричные и шестнадцатеричные литералы могут быть подписаны &lt;code&gt;-&lt;/code&gt; непосредственно перед беззнаковым литералом. Они производят беззнаковое целое того же размера, что и беззнаковый литерал, с двумя дополнениями значения:</target>
        </trans-unit>
        <trans-unit id="ccb7426c705bde96fa9acacc232348e6649fb196" translate="yes" xml:space="preserve">
          <source>Bind &lt;code&gt;socket&lt;/code&gt; to the given &lt;code&gt;host:port&lt;/code&gt;. Note that &lt;code&gt;0.0.0.0&lt;/code&gt; will listen on all devices.</source>
          <target state="translated">Привязать &lt;code&gt;socket&lt;/code&gt; к данному &lt;code&gt;host:port&lt;/code&gt; . Обратите внимание, что &lt;code&gt;0.0.0.0&lt;/code&gt; будет прослушивать все устройства.</target>
        </trans-unit>
        <trans-unit id="fe7e2953e9474b2bd135241c7c997e4972287729" translate="yes" xml:space="preserve">
          <source>Bird</source>
          <target state="translated">Bird</target>
        </trans-unit>
        <trans-unit id="65c2eaa1dcfba5d5f9a0a3584ad5e6d8f7aef198" translate="yes" xml:space="preserve">
          <source>Birthday Cake</source>
          <target state="translated">День рождения Торт</target>
        </trans-unit>
        <trans-unit id="93ea79c838264d2a1d87b4b0c60302c8a973255c" translate="yes" xml:space="preserve">
          <source>BitArray</source>
          <target state="translated">BitArray</target>
        </trans-unit>
        <trans-unit id="4b9bfa4acc76402f1ab1ef6ccdbff0077343e801" translate="yes" xml:space="preserve">
          <source>BitArray()</source>
          <target state="translated">BitArray()</target>
        </trans-unit>
        <trans-unit id="f8cd7716f7a5997d4efd153b8de6bda8ac575d3b" translate="yes" xml:space="preserve">
          <source>BitSet</source>
          <target state="translated">BitSet</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
